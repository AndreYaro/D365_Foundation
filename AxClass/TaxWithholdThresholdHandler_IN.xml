<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxWithholdThresholdHandler_IN</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>TaxWithholdThresholdHandler_IN</c> is used to calculate and get the target threshold section of the specified application source line
/// </summary>
[ThresholdHandlerAttribute_IN(enumStr(TaxThresholdSourceLineType_IN), TaxThresholdSourceLineType_IN::TaxWithhold)]
class TaxWithholdThresholdHandler_IN extends ThresholdHandler_IN
{
    boolean                             isTaxValueDataCalc;
    TaxValueData_IN                     taxValueData;
    TaxWHTThresholdSourceLineImpl_IN    taxWHTThresholdSourceLineImpl;
    TaxValueThresholdProfileType_IN     taxValueThresholdProfileType;
    TaxWithholdComponentTable_IN        taxWithholdComponentTable;
    TaxWithholdCalculation_IN           taxWithholdCalculation;
    real                                rateOfDeduction;
    Map                                 calcPostedUncalculatedTransMap;

    List                                progThresholdSections;
    boolean                             isProgThresholdSectionsCalculated;
    Map                                 progTaxValueData;
    boolean                             isProgTaxValueDataCalculated;

    private boolean isThresholdBasedOnPaymentOnly = FeatureStateProvider::isFeatureEnabled(TaxWithholdCustomerThresholdBasedOnPaymentOnlyFeature::instance());

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmWHTThresholdSourceLineImpl</Name>
				<Source><![CDATA[
    internal TaxWHTThresholdSourceLineImpl_IN parmWHTThresholdSourceLineImpl(TaxWHTThresholdSourceLineImpl_IN _taxWHTThresholdSourceLineImpl = taxWHTThresholdSourceLineImpl)
    {
        taxWHTThresholdSourceLineImpl = _taxWHTThresholdSourceLineImpl;
        return taxWHTThresholdSourceLineImpl;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getConcessionCertificateDetails</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Get ConcessionCertificateDetails of found section.
    /// </summary>
    /// <returns>
    ///     Return ConcessionCertificateDetails.
    /// </returns>
    public ConcessionCertificateDetails_IN getConcessionCertificateDetails()
    {
        ConcessionCertificateDetails_IN concessionCertificateDetailsLoc;

        select firstOnly concessionCertificateDetailsLoc
            where concessionCertificateDetailsLoc.SourceReferenceTableId    == taxValueThresholdProfileType.parmTaxValueThresholdProfileTableId()
                && concessionCertificateDetailsLoc.SourceReferenceRecId     == taxValueThresholdProfileType.parmTaxValueThresholdProfileRecId()
                && concessionCertificateDetailsLoc.ThresholdSections        == this.getTargetThresholdSection().RecId;

        return concessionCertificateDetailsLoc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTargetSectionParent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the top parent senction of target section.
    /// </summary>
    /// <returns>
    /// Returns the top parent of target section.
    /// </returns>
    public ThresholdSections_IN getTargetSectionParent()
    {
        ThresholdSections_IN            thresholdSectionParent;
        ThresholdSections_IN            thresholdSection;
        List                            thresholdSectionParentList;
        ListEnumerator                  enumerator;

        thresholdSection = this.getTargetThresholdSection();
        thresholdSectionParentList = this.getTargetThresholdSectionParents();
        if (thresholdSectionParentList.elements())
        {
            //get the first one in the list which is the top parent of this section
            enumerator = thresholdSectionParentList.getEnumerator();
            enumerator.moveNext();
            thresholdSectionParent = enumerator.current();
        }
        else
        {
            thresholdSectionParent = thresholdSection;
        }

        return thresholdSectionParent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxBaseAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets sum of uncalculated transaction amount and current transline amount, and the sum will be applied for tax.
    /// </summary>
    /// <returns>
    /// Sum of uncalculated trans amount and current transline amount
    /// </returns>
    public AmountMST getTaxBaseAmountMST()
    {
        return this.getUncalculatedTransAmountMST() + taxWHTThresholdSourceLineImpl.parmCurTransLineAmountMST();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxValueData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets sets of <c>TaxValueData_IN</c>, which are attached to target threshold section.
    /// </summary>
    /// <returns>
    /// <c>TaxValueData_IN</c>
    /// </returns>
    public TaxValueData_IN getTaxValueData()
    {
        if (!isTaxValueDataCalc)
        {
            select firstOnly taxValueData
                where taxValueData.ThresholdSections                        == this.getTargetThresholdSection().RecId
                    && taxValueData.IsOverLook                              == taxWHTThresholdSourceLineImpl.parmIsOverLook()
                    && taxValueData.ValidFrom                               <= taxWHTThresholdSourceLineImpl.parmThreholdLineTransDate()
                    && (taxValueData.ValidTo                                >= taxWHTThresholdSourceLineImpl.parmThreholdLineTransDate() || !taxValueData.ValidTo)
                    && ((taxWHTThresholdSourceLineImpl.parmAccountType()    == AccountType_IN::Vend
                            && taxValueData.PANTaxStatus_IN                 == TaxInformationVendTable_IN::findByVendTable(taxWHTThresholdSourceLineImpl.parmAccountNum()).getPANTaxStatus_IN())
                        || (taxWHTThresholdSourceLineImpl.parmAccountType() == AccountType_IN::Cust
                            && taxValueData.PANTaxStatus_IN                 == TaxInformationCustTable_IN::findByCustTable(taxWHTThresholdSourceLineImpl.parmAccountNum()).getPANTaxStatus_IN())
                        || (taxWHTThresholdSourceLineImpl.parmAccountType() != AccountType_IN::Vend
                            && taxWHTThresholdSourceLineImpl.parmAccountType() != AccountType_IN::Cust
                            && taxValueData.PANTaxStatus_IN                 == PANTaxStatus_IN::NotApplicable))
                    && taxValueData.SourceReferenceTableId                  == taxValueThresholdProfileType.parmTaxValueThresholdProfileTableId()
                    && taxValueData.SourceReferenceRecId                    == taxValueThresholdProfileType.parmTaxValueThresholdProfileRecId();
        }
        return taxValueData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUncalculatedTransAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
    /// Collects and gets sum of amount of uncalculated transactions.
    /// </summary>
    /// <returns>
    /// Sum of amount of uncalculated transactions
    /// </returns>
    public AmountMST getUncalculatedTransAmountMST()
    {
        TaxWithholdTrans_IN             taxWithholdTrans;
        TmpTaxWithholdWorkTrans_IN      tmpTaxWithholdWorkTrans;
        TaxWithholdUncommitted_IN       taxWithHoldUncommitted;
        AmountMST                       unPostedUncalculatedTransAmountMST;
        AmountMST                       postedUncalculatedTransAmountMST;
        ThresholdSections_IN            thresholdSection;
        ThresholdSections_IN            thresholdSectionParent;
        TaxWithholdTable                taxWithholdTable;

        thresholdSectionParent = this.getTargetSectionParent();
        thresholdSection       = this.getTargetThresholdSection();

        boolean isProgressiveInclusiveCalculation = this.isTaxInclusiveAndProgressive();

        if (this.getTaxValueData().CalcUncalcPostedTrans)
        {
            tmpTaxWithholdWorkTrans.setTmpData(taxWithholdCalculation.parmTmpTaxWithholdWorkTrans());

            //unPostedUncalculatedTrans Amount
            if (taxWithholdCalculation.parmTaxModuleType() != TaxModuleType::Voucher)
            {
                select sum (TaxBaseAmount)
                    from tmpTaxWithholdWorkTrans
                    where tmpTaxWithholdWorkTrans.HeadingRecId                  == taxWithholdCalculation.parmHeadingRecID()
                        && tmpTaxWithholdWorkTrans.HeadingTableId               == taxWithholdCalculation.parmHeadingTableID()
                        && tmpTaxWithholdWorkTrans.AccountNumber                == taxWHTThresholdSourceLineImpl.parmAccountNum()
                        && tmpTaxWithholdWorkTrans.IsTaxCalculated              == false
                        && (!isThresholdBasedOnPaymentOnly || taxWHTThresholdSourceLineImpl.parmAccountType() != AccountType_IN::Cust || !tmpTaxWithholdWorkTrans.IsTaxInterim)
                        exists join taxWithholdTable
                            where taxWithholdTable.TaxWithholdCode              == tmpTaxWithholdWorkTrans.TaxWithholdCode
                                && taxWithholdTable.TaxWithholdComponent_IN     == taxWithholdComponentTable.RecId;

                // update IsTaxCalculated status
                if (tmpTaxWithholdWorkTrans.TaxBaseAmount)
                {
                    unPostedUncalculatedTransAmountMST = tmpTaxWithholdWorkTrans.TaxBaseAmount;
                    update_recordSet tmpTaxWithholdWorkTrans
                        setting IsTaxCalculated = true
                        where tmpTaxWithholdWorkTrans.HeadingRecId              == taxWithholdCalculation.parmHeadingRecID()
                            && tmpTaxWithholdWorkTrans.HeadingTableId           == taxWithholdCalculation.parmHeadingTableID()
                            && tmpTaxWithholdWorkTrans.AccountNumber            == taxWHTThresholdSourceLineImpl.parmAccountNum()
                            && tmpTaxWithholdWorkTrans.IsTaxCalculated          == false
                            && (!isThresholdBasedOnPaymentOnly || taxWHTThresholdSourceLineImpl.parmAccountType() != AccountType_IN::Cust || !tmpTaxWithholdWorkTrans.IsTaxInterim)
                            exists join taxWithholdTable
                                where taxWithholdTable.TaxWithholdCode          == tmpTaxWithholdWorkTrans.TaxWithholdCode
                                    && taxWithholdTable.TaxWithholdComponent_IN == taxWithholdComponentTable.RecId;
                }
            }
            else
            {
                //Collect previously uncalculated Vouchers: Only For Journals
                //AdvancePayment : For these uncalc Vouchers, they has zero tax rate and TaxBaseAmount is the same as amountOriginMST, so need to get WHT deducted here.
                select sum(TaxBaseAmount) from taxWithHoldUncommitted
                    where taxWithHoldUncommitted.HeadingTableId             == taxWithholdCalculation.parmHeadingTableID()
                        && taxWithHoldUncommitted.HeadingRecId              == taxWithholdCalculation.parmHeadingRecID()
                        && taxWithHoldUncommitted.AccountNumber             == taxWHTThresholdSourceLineImpl.parmAccountNum()
                        && taxWithHoldUncommitted.IsTaxCalculated           == false
                        && taxWithHoldUncommitted.TaxCalcAsNonTaxTransInVoucher == ""
                        && taxWithHoldUncommitted.AdvancePayment            == true
                        && (!isThresholdBasedOnPaymentOnly || taxWHTThresholdSourceLineImpl.parmAccountType() != AccountType_IN::Cust || !taxWithHoldUncommitted.IsTaxInterim)
                        exists join taxWithholdTable
                             where taxWithholdTable.TaxWithholdCode          == taxWithHoldUncommitted.TaxWithholdCode
                                && taxWithholdTable.TaxWithholdComponent_IN == taxWithholdComponentTable.RecId;

                if (isProgressiveInclusiveCalculation)
                {
                    unPostedUncalculatedTransAmountMST = taxWithHoldUncommitted.TaxBaseAmount;
                }
                else
                {
                    unPostedUncalculatedTransAmountMST = taxWithHoldUncommitted.TaxBaseAmount * 100 / (100 + rateOfDeduction);
                }

                if(unPostedUncalculatedTransAmountMST)
                {
                    update_recordSet taxWithHoldUncommitted
                        setting TaxCalcAsNonTaxTransInVoucher = taxWithholdCalculation.parmVoucher()
                        where taxWithHoldUncommitted.HeadingTableId             == taxWithholdCalculation.parmHeadingTableID()
                            && taxWithHoldUncommitted.HeadingRecId              == taxWithholdCalculation.parmHeadingRecID()
                            && taxWithHoldUncommitted.AccountNumber             == taxWHTThresholdSourceLineImpl.parmAccountNum()
                            && taxWithHoldUncommitted.IsTaxCalculated           == false
                            && taxWithHoldUncommitted.TaxCalcAsNonTaxTransInVoucher == ""
                            && taxWithHoldUncommitted.AdvancePayment            == true
                            && (!isThresholdBasedOnPaymentOnly || taxWHTThresholdSourceLineImpl.parmAccountType() != AccountType_IN::Cust || !taxWithHoldUncommitted.IsTaxInterim)
                            exists join taxWithholdTable
                                where taxWithholdTable.TaxWithholdCode          == taxWithHoldUncommitted.TaxWithholdCode
                                    && taxWithholdTable.TaxWithholdComponent_IN == taxWithholdComponentTable.RecId;

                    }
                    //non-AdvancePayment
                    select sum(TaxBaseAmount) from taxWithHoldUncommitted
                        where taxWithHoldUncommitted.HeadingTableId     == taxWithholdCalculation.parmHeadingTableID()
                            && taxWithHoldUncommitted.HeadingRecId      == taxWithholdCalculation.parmHeadingRecID()
                            && taxWithHoldUncommitted.AccountNumber     == taxWHTThresholdSourceLineImpl.parmAccountNum()
                            && taxWithHoldUncommitted.IsTaxCalculated   == false
                            && taxWithHoldUncommitted.TaxCalcAsNonTaxTransInVoucher == ""
                            && taxWithHoldUncommitted.AdvancePayment    == false
                            && (!isThresholdBasedOnPaymentOnly || taxWHTThresholdSourceLineImpl.parmAccountType() != AccountType_IN::Cust || !taxWithHoldUncommitted.IsTaxInterim)
                            exists join taxWithholdTable
                                where taxWithholdTable.TaxWithholdCode          == taxWithHoldUncommitted.TaxWithholdCode
                                    && taxWithholdTable.TaxWithholdComponent_IN == taxWithholdComponentTable.RecId;

                    unPostedUncalculatedTransAmountMST += taxWithHoldUncommitted.TaxBaseAmount;

                    if(unPostedUncalculatedTransAmountMST)
                    {
                        update_recordSet taxWithHoldUncommitted
                            setting TaxCalcAsNonTaxTransInVoucher = taxWithholdCalculation.parmVoucher()
                            where taxWithHoldUncommitted.HeadingTableId     == taxWithholdCalculation.parmHeadingTableID()
                                && taxWithHoldUncommitted.HeadingRecId      == taxWithholdCalculation.parmHeadingRecID()
                                && taxWithHoldUncommitted.AccountNumber     == taxWHTThresholdSourceLineImpl.parmAccountNum()
                                && taxWithHoldUncommitted.IsTaxCalculated   == false
                                && taxWithHoldUncommitted.TaxCalcAsNonTaxTransInVoucher == ""
                                && taxWithHoldUncommitted.AdvancePayment    == false
                                && (!isThresholdBasedOnPaymentOnly || taxWHTThresholdSourceLineImpl.parmAccountType() != AccountType_IN::Cust || !taxWithHoldUncommitted.IsTaxInterim)
                                exists join taxWithholdTable
                                    where taxWithholdTable.TaxWithholdCode          == taxWithHoldUncommitted.TaxWithholdCode
                                        && taxWithholdTable.TaxWithholdComponent_IN == taxWithholdComponentTable.RecId;
                }
            }

            //PostedUncalculatedTrans Amount
            if (!calcPostedUncalculatedTransMap.exists(taxWithholdComponentTable.RecId))
            {
                //AdvancePayment
                select sum(WithholdBaseAmount) from taxWithholdTrans
                    where ((taxWithholdTrans.VendAccount                         == taxWHTThresholdSourceLineImpl.parmAccountNum()
                                && taxWHTThresholdSourceLineImpl.parmAccountType() == AccountType_IN::Vend)
                            || (taxWithholdTrans.CustAccount                    == taxWHTThresholdSourceLineImpl.parmAccountNum()
                                && taxWHTThresholdSourceLineImpl.parmAccountType() == AccountType_IN::Cust
                                && (!isThresholdBasedOnPaymentOnly || !taxWithholdTrans.IsTaxInterim)))
                        && taxWithholdTrans.TaxWithholdComponent                == taxWithholdComponentTable.RecId
                        && (taxWithholdTrans.TransDate                          >= thresholdSectionParent.ValidFrom
                            || !thresholdSection.ValidFrom)
                        && (taxWithholdTrans.TransDate                          <= thresholdSectionParent.ValidTo
                            || !thresholdSection.ValidTo)
                        && taxWithholdTrans.TaxWithholdCalculated               == false
                        && taxWithholdTrans.AdvancePayment                      == true
                        && taxWithholdTrans.IsPartOfTurnOver;

                if (isProgressiveInclusiveCalculation)
                {
                    postedUncalculatedTransAmountMST = taxWithholdTrans.WithholdBaseAmount;
                }
                else
                {
                    postedUncalculatedTransAmountMST = taxWithholdTrans.WithholdBaseAmount * 100 / (100 + rateOfDeduction);
                }

                //non-AdvancePayment
                select sum(WithholdBaseAmount) from taxWithholdTrans
                    where ((taxWithholdTrans.VendAccount                         == taxWHTThresholdSourceLineImpl.parmAccountNum()
                                && taxWHTThresholdSourceLineImpl.parmAccountType() == AccountType_IN::Vend)
                            || (taxWithholdTrans.CustAccount                    == taxWHTThresholdSourceLineImpl.parmAccountNum()
                                && taxWHTThresholdSourceLineImpl.parmAccountType() == AccountType_IN::Cust
                                && (!isThresholdBasedOnPaymentOnly || !taxWithholdTrans.IsTaxInterim)))
                        && taxWithholdTrans.TaxWithholdComponent                == taxWithholdComponentTable.RecId
                        && (taxWithholdTrans.TransDate                          >= thresholdSectionParent.ValidFrom
                            || !thresholdSection.ValidFrom)
                        && (taxWithholdTrans.TransDate                          <= thresholdSectionParent.ValidTo
                            || !thresholdSection.ValidTo)
                        && taxWithholdTrans.TaxWithholdCalculated               == false
                        && taxWithholdTrans.AdvancePayment                      == false;
                postedUncalculatedTransAmountMST += taxWithholdTrans.WithholdBaseAmount;

                calcPostedUncalculatedTransMap.insert(taxWithholdComponentTable.RecId,true);
            }
        }
        return postedUncalculatedTransAmountMST + unPostedUncalculatedTransAmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initialize</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initiates object of <c>TaxWithholdThresholdHandler_IN</c>.
    /// </summary>
    /// <param name="_thresholdSourceLine">
    /// Record of application
    /// </param>
    public void initialize(ThresholdSourceLine_IN _thresholdSourceLine)
    {
        super(_thresholdSourceLine);
        taxWHTThresholdSourceLineImpl   = _thresholdSourceLine;

        this.initThreshold();

        taxWithholdComponentTable       = TaxWithholdComponentTable_IN::find(
            TaxWithholdTable::find(taxWHTThresholdSourceLineImpl.parmTaxWithholdCode()).TaxWithholdComponent_IN);
        taxWithholdCalculation = taxWHTThresholdSourceLineImpl.parmTaxWithholdCalculation();

        isProgThresholdSectionsCalculated   = false;
        progThresholdSections               = new List(Types::Record);
        progTaxValueData                    = new Map(Types::Int64, Types::Record);
        isProgTaxValueDataCalculated        = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initThreshold</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initiates threshold with target one.
    /// </summary>
    protected void initThreshold()
    {
        taxValueThresholdProfileType = TaxValueThresholdProfileType_IN::construct(
            taxWHTThresholdSourceLineImpl.parmAccountType(),
            taxWHTThresholdSourceLineImpl.parmAccountNum(),
            TaxWithholdTable::find(taxWHTThresholdSourceLineImpl.parmTaxWithholdCode()));
        threshold = taxValueThresholdProfileType.getTargetThreshold();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCalcPostedUncalculatedTransMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets and sets map of calcPostedUncalculatedTrans. This map stores the info of whether
    /// posted transaction has been calculated before current transaction line.
    /// </summary>
    /// <param name="_calcPostedUncalculatedTransMap">
    ///     The map of CalcPostedUncalculatedTrans.
    /// </param>
    /// <returns>
    ///     The current value of CalcPostedUncalculatedTransMap.
    /// </returns>
    public Map parmCalcPostedUncalculatedTransMap(Map _calcPostedUncalculatedTransMap = calcPostedUncalculatedTransMap)
    {
        calcPostedUncalculatedTransMap = _calcPostedUncalculatedTransMap;
        return calcPostedUncalculatedTransMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRateOfDeduction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets withholding tax rate, on which tax will be deducted.
    /// </summary>
    /// <param name="_rateOfDeduction">
    /// tax rate
    /// </param>
    /// <returns>
    /// tax rate
    /// </returns>
    public Real parmRateOfDeduction(real _rateOfDeduction = rateOfDeduction)
    {
        rateOfDeduction = _rateOfDeduction;
        return rateOfDeduction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCalculatedAmount</Name>
				<Source><![CDATA[
    private AmountCur getCalculatedAmount(FromDate _taxThresholdSectionFromDate, ToDate _taxThresholdSectionToDate)
    {
        PANNumber_IN pAN;
        NoYes isPANBased = taxWHTThresholdSourceLineImpl.isPANBasedAccumulation();
        // Get PAN number if PAN based accumulation is activated.
        if (isPANBased == NoYes::Yes)
        {
            pAN = taxWHTThresholdSourceLineImpl.getPANNumber();
        }

        AmountMST calculatedAmount;
        FromDate validFrom = _taxThresholdSectionFromDate;
        ToDate validTo = _taxThresholdSectionToDate;
        // Only available when Tax Liability on Payment is enabled on the tax group.
        AmountCur historyTurnOver;
        if ((isThresholdBasedOnPaymentOnly
                && TaxWithholdGroupHeading::find(taxWHTThresholdSourceLineImpl.parmTaxWithholdGroup()).TaxLiabilityOnPayment_IN
                && taxWHTThresholdSourceLineImpl.parmAccountType() == AccountType_IN::Cust)
            || (FeatureStateProvider::isFeatureEnabled(TaxWHTHistoryTurnOverForVendFeature::instance())
                && taxWHTThresholdSourceLineImpl.parmAccountType() == AccountType_IN::Vend))
        {
            CustVendACType custVendType = taxWHTThresholdSourceLineImpl.parmAccountType() == AccountType_IN::Cust ?
                CustVendACType::Cust :
                CustVendACType::Vend;

            historyTurnOver = TaxWithholdHistoryTurnOverUtils_IN::getTaxWithholdHistoryTurnOver(
                validFrom,
                validTo,
                taxWHTThresholdSourceLineImpl,
                custVendType);
            validFrom = TaxWithholdHistoryTurnOverUtils_IN::getAdjustedFromDateBasedOnHistoryTurnOver(
                validFrom,
                validTo,
                custVendType,
                taxWHTThresholdSourceLineImpl);
        }
        calculatedAmount += historyTurnOver;

        TaxWithholdTrans_IN taxWithholdTrans;
        TaxWithholdTable taxWithholdTable;
        TaxWithholdUncommitted_IN taxWithHoldUncommitted;
        // when pan is not empty, it means PAN based accumulation is applied.
        if (pAN && isPANBased == NoYes::Yes)
        {
            TaxInformationVendTable_IN taxInfoVendTable;
            TaxInformationCustTable_IN taxInfoCustTable;

            // get the total amount of all transactons which are posted.
            if (taxWHTThresholdSourceLineImpl.parmAccountType() == AccountType_IN::Vend)
            {
                select sum(AmountOriginMST) from taxWithholdTrans
                where taxWithholdTrans.VendAccount
                        && taxWithholdTrans.TaxWithholdComponent == taxWithholdComponentTable.RecId
                        && (taxWithholdTrans.TransDate >= _taxThresholdSectionFromDate
                            || !_taxThresholdSectionFromDate)
                        && (taxWithholdTrans.TransDate <= _taxThresholdSectionToDate
                            || !_taxThresholdSectionToDate)
                        && taxWithholdTrans.IsPartOfTurnOver
                exists join taxInfoVendTable
                where taxInfoVendTable.VendTable == taxWithholdTrans.VendAccount && taxInfoVendTable.PANStatus == PANStatus_IN::Received
                        && taxInfoVendTable.PANNumber == pAN;
            }
            else
            {
                select sum(AmountOriginMST) from taxWithholdTrans
                where taxWithholdTrans.CustAccount
                        && taxWithholdTrans.TaxWithholdComponent == taxWithholdComponentTable.RecId
                        && (taxWithholdTrans.TransDate >= validFrom
                            || !validFrom)
                        && (taxWithholdTrans.TransDate <= validTo
                            || !validTo)
                        && taxWithholdTrans.IsPartOfTurnOver
                        && (!isThresholdBasedOnPaymentOnly || !taxWithholdTrans.IsTaxInterim)
                exists join taxInfoCustTable
                where taxInfoCustTable.CustTable == taxWithholdTrans.CustAccount
                    && taxInfoCustTable.PANStatus == PANStatus_IN::Received
                    && taxInfoCustTable.PANNumber == pAN;
            }

            calculatedAmount += taxWithholdTrans.AmountOriginMST;
        }
        else
        {
            select sum(WithholdBaseAmount) from taxWithholdTrans
            where ((taxWithholdTrans.VendAccount == taxWHTThresholdSourceLineImpl.parmAccountNum()
                        && taxWHTThresholdSourceLineImpl.parmAccountType() == AccountType_IN::Vend)
                    || (taxWithholdTrans.CustAccount == taxWHTThresholdSourceLineImpl.parmAccountNum()
                        && taxWHTThresholdSourceLineImpl.parmAccountType() == AccountType_IN::Cust
                        && (!isThresholdBasedOnPaymentOnly || !taxWithholdTrans.IsTaxInterim)))
                && taxWithholdTrans.TaxWithholdComponent == taxWithholdComponentTable.RecId
                && (taxWithholdTrans.TransDate >= validFrom
                    || !validFrom)
                && (taxWithholdTrans.TransDate <= validTo
                    || !validTo)
                && taxWithholdTrans.IsPartOfTurnOver;

            // Legacy code: taxWithholdTrans.WithholdBaseAmount should be -> taxWithholdTrans.AmountOriginMST. Further changes are needed.
            calculatedAmount += taxWithholdTrans.WithholdBaseAmount;
        }

        // Calculate cumulative for Journals
        if (taxWithholdCalculation.parmTaxModuleType() == TaxModuleType::Voucher
            || taxWithholdCalculation.parmTaxModuleType() == TaxModuleType::Project)
        {
            // For the lines with different voucher, use <c>TaxWithholdUncommitted_IN</c> to calculate cumulative
            select sum(TaxBaseAmount) from taxWithHoldUncommitted
                where taxWithHoldUncommitted.HeadingTableId == taxWithholdCalculation.parmHeadingTableID()
                    && taxWithHoldUncommitted.HeadingRecId == taxWithholdCalculation.parmHeadingRecID()
                    && taxWithHoldUncommitted.AccountNumber == taxWHTThresholdSourceLineImpl.parmAccountNum()
                    && taxWithHoldUncommitted.Voucher != taxWithholdCalculation.parmVoucher()
                    && (!isThresholdBasedOnPaymentOnly || taxWHTThresholdSourceLineImpl.parmAccountType() != AccountType_IN::Cust || !taxWithHoldUncommitted.IsTaxInterim)
                    exists join taxWithholdTable
                        where taxWithholdTable.TaxWithholdCode == taxWithHoldUncommitted.TaxWithholdCode
                            && taxWithholdTable.TaxWithholdComponent_IN == taxWithholdComponentTable.RecId;

            calculatedAmount += taxWithHoldUncommitted.TaxBaseAmount;

            // For the lines with same voucher, use <c>TmpTaxWithholdWorkTrans_IN</c> to calculate cumulative
            TmpTaxWithholdWorkTrans_IN  tmpTaxWithholdWorkTrans;
            tmpTaxWithholdWorkTrans.setTmpData(taxWithholdCalculation.parmTmpTaxWithholdWorkTrans());
            select sum (TaxBaseAmount)
                from tmpTaxWithholdWorkTrans
                where tmpTaxWithholdWorkTrans.HeadingRecId == taxWithholdCalculation.parmHeadingRecID()
                    && tmpTaxWithholdWorkTrans.HeadingTableId == taxWithholdCalculation.parmHeadingTableID()
                    && tmpTaxWithholdWorkTrans.AccountNumber == taxWHTThresholdSourceLineImpl.parmAccountNum()
                    && tmpTaxWithholdWorkTrans.Voucher == taxWithholdCalculation.parmVoucher()
                    && (!isThresholdBasedOnPaymentOnly || taxWHTThresholdSourceLineImpl.parmAccountType() != AccountType_IN::Cust || !tmpTaxWithholdWorkTrans.IsTaxInterim)
                    exists join taxWithholdTable
                        where taxWithholdTable.TaxWithholdCode == tmpTaxWithholdWorkTrans.TaxWithholdCode
                            && taxWithholdTable.TaxWithholdComponent_IN == taxWithholdComponentTable.RecId;

            calculatedAmount += tmpTaxWithholdWorkTrans.TaxBaseAmount;
        }
        else
        {
            TmpTaxWithholdWorkTrans_IN      tmpTaxWithholdWorkTrans;
            tmpTaxWithholdWorkTrans.setTmpData(taxWithholdCalculation.parmTmpTaxWithholdWorkTrans());
            select sum (TaxBaseAmount)
                from tmpTaxWithholdWorkTrans
                where tmpTaxWithholdWorkTrans.HeadingRecId                  == taxWithholdCalculation.parmHeadingRecID()
                    && tmpTaxWithholdWorkTrans.HeadingTableId               == taxWithholdCalculation.parmHeadingTableID()
                    && tmpTaxWithholdWorkTrans.AccountNumber                == taxWHTThresholdSourceLineImpl.parmAccountNum()
                    && (!isThresholdBasedOnPaymentOnly || taxWHTThresholdSourceLineImpl.parmAccountType() != AccountType_IN::Cust || !tmpTaxWithholdWorkTrans.IsTaxInterim)
                    exists join taxWithholdTable
                        where taxWithholdTable.TaxWithholdCode              == tmpTaxWithholdWorkTrans.TaxWithholdCode
                            && taxWithholdTable.TaxWithholdComponent_IN     == taxWithholdComponentTable.RecId;

            calculatedAmount += tmpTaxWithholdWorkTrans.TaxBaseAmount;
        }

        return calculatedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProgressiveTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Get progressive tax amount based on found section.
    /// </summary>
    /// <param name="_grossAmount">
    ///     The amount which used as base amount.
    /// </param>
    /// <returns>
    ///     Return true and tax amount if progressive calculation succeed, otherwise, return false and original amount out.
    /// </returns>
    public container getProgressiveTaxAmount(AmountMST _grossAmount)
    {
        AmountMST               unCalculatedAmt, calculatedAmount, diffAmount, taxAmount = 0, pretaxAmount = 0;
        ListEnumerator          listEnumerator;
        TaxValueData_IN         taxValueDataIN;
        ThresholdSections_IN    taxThresholdSection;
        List                    skippedSection = new List(Types::Record);
        ListEnumerator          skippedSectionEnumerator;
        ThresholdSections_IN    preTaxThresholdSection;
        TaxValueData_IN         preTaxValueDataIN;
        List                    sectionInUse = new List(Types::Record);
        TaxWithholdTrans_IN     taxWithholdTrans;
        TaxWithholdTable        taxWithholdTable;

        this.getProgressiveTaxValueData();

        if (!this.isValidProgressiveThreshold())
        {
            return [false, _grossAmount];
        }

        taxThresholdSection = this.getTargetThresholdSection();
        calculatedAmount = this.getCalculatedAmount(taxThresholdSection.ValidFrom, taxThresholdSection.ValidTo);

        unCalculatedAmt = _grossAmount;
        listEnumerator = this.getProgressiveThresholdSections().getEnumerator();

        // For performance improvement
        while(listEnumerator.moveNext())
        {
            taxThresholdSection = listEnumerator.current();
            if (taxThresholdSection.UpLimit != 0 && CalculatedAmount > taxThresholdSection.UpLimit)
            {
                calculatedAmount -= taxThresholdSection.UpLimit;
                continue;
            }
            else
            {
                taxThresholdSection.LowLimit += CalculatedAmount;
                calculatedAmount = 0;
                sectionInUse.addEnd(taxThresholdSection);
            }
        }

        listEnumerator = sectionInUse.getEnumerator();
        while (listEnumerator.moveNext())
        {
            taxThresholdSection = listEnumerator.current();
            taxValueDataIN = progTaxValueData.lookup(taxThresholdSection.RecId);
            if (!taxValueDataIN.IsCalculate)
            {
                // Section defined with unmark 'Calculate tax'
                skippedSection.addEnd(taxThresholdSection);
                continue;
            }

            if (skippedSection.elements() > 0)
            {
                skippedSectionEnumerator = skippedSection.getEnumerator();

                // If the previous threshold section defines with unmarked 'Calculate tax',
                //  the follwers have to take their limits to work out the correct amount
                while (skippedSectionEnumerator.moveNext())
                {
                    preTaxThresholdSection = skippedSectionEnumerator.current();
                    preTaxValueDataIN = progTaxValueData.lookup(preTaxThresholdSection.RecId);

                    if (calculatedAmount >= (preTaxThresholdSection.UpLimit - preTaxThresholdSection.LowLimit))
                    {
                        calculatedAmount -= (preTaxThresholdSection.UpLimit - preTaxThresholdSection.LowLimit);
                    }
                    else
                    {
                        diffAmount = preTaxThresholdSection.UpLimit - preTaxThresholdSection.LowLimit - CalculatedAmount;
                        calculatedAmount = 0;
                        if (unCalculatedAmt > diffAmount)
                        {
                            if (preTaxValueDataIN.CalcUncalcPostedTrans)
                            {
                                taxAmount += preTaxValueDataIN.TaxValue * diffAmount;
                            }
                            else if (taxValueDataIN.CalcUncalcPostedTrans)
                            {
                                pretaxAmount += taxValueDataIN.TaxValue * diffAmount;
                            }

                            unCalculatedAmt -= diffAmount;
                        }
                        else
                        {
                            if (preTaxValueDataIN.CalcUncalcPostedTrans)
                            {
                                taxAmount += preTaxValueDataIN.TaxValue * unCalculatedAmt;
                            }
                            else if (taxValueDataIN.CalcUncalcPostedTrans)
                            {
                                pretaxAmount += taxValueDataIN.TaxValue * unCalculatedAmt;
                            }

                            unCalculatedAmt = 0;
                        }
                    }
                }

                skippedSection = new List(Types::Record);
            }

            if (taxThresholdSection.UpLimit != 0)
            {
                if (calculatedAmount >= (taxThresholdSection.UpLimit - taxThresholdSection.LowLimit))
                {
                    calculatedAmount -= (taxThresholdSection.UpLimit - taxThresholdSection.LowLimit);
                }
                else
                {
                    diffAmount = taxThresholdSection.UpLimit - taxThresholdSection.LowLimit - CalculatedAmount;
                    calculatedAmount = 0;
                    if (unCalculatedAmt > diffAmount)
                    {
                        taxAmount += taxValueDataIN.TaxValue * diffAmount;
                        unCalculatedAmt -= diffAmount;
                    }
                    else
                    {
                        taxAmount += taxValueDataIN.TaxValue * unCalculatedAmt;
                        unCalculatedAmt = 0;
                    }
                }
            }
            else
            {
                if (calculatedAmount >= 0)
                {
                    taxAmount += unCalculatedAmt * taxValueDataIN.TaxValue;
                    calculatedAmount = 0;
                    unCalculatedAmt = 0;
                }
            }

            if (taxValueDataIN.CalcUncalcPostedTrans)
            taxAmount += pretaxAmount;
        }

        return [true, taxAmount];
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxInclusiveAndProgressive</Name>
				<Source><![CDATA[
    internal boolean isTaxInclusiveAndProgressive()
    {
        return isThresholdBasedOnPaymentOnly
            && taxWHTThresholdSourceLineImpl
            && taxWHTThresholdSourceLineImpl.parmIsPriceInclusive()
            && TaxWithholdGroupHeading::find(taxWHTThresholdSourceLineImpl.parmTaxWithholdGroup()).TaxLiabilityOnPayment_IN
            && taxWHTThresholdSourceLineImpl.parmAccountType() == AccountType_IN::Cust;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProgressiveTaxAmountAndAmountOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets progressive tax amount and amount origin based on found section.
    /// </summary>
    /// <param name = "_grossAmount">The amount which used as base amount.</param>
    /// <param name = "_isInclusiveCalculation">Is current transaction inclusive.</param>
    /// <returns>A container with value true, tax amount and gross amount without tax if progressive calculation succeed; otherwise, a container with value false and original amount out.</returns>
    internal container getProgressiveTaxAmountAndAmountOrigin(AmountMST _grossAmount, boolean _isInclusiveCalculation)
    {
        AmountMST grossAmountExcludeTax;
        this.getProgressiveTaxValueData();
        if (!this.isValidProgressiveThreshold())
        {
            if (_isInclusiveCalculation)
            {
                // If current transaction is progressive and tax is calculated with price inclusive, the caller passed the "_grossAmount" as amount include tax.
                // So here if the progressive is invalid, just get the gross amount exclude tax.
                grossAmountExcludeTax = _grossAmount / (1 + rateOfDeduction / 100);
                return [false, grossAmountExcludeTax, grossAmountExcludeTax];
            }
            else
            {
                return [false, _grossAmount, _grossAmount];
            }
        }

        ThresholdSections_IN targetTaxThresholdSection = this.getTargetThresholdSection();
        AmountMST calculatedAmount = this.getCalculatedAmount(targetTaxThresholdSection.ValidFrom, targetTaxThresholdSection.ValidTo);

        // Reverse the section list and remove the section which do not use.
        ListEnumerator listEnumerator = this.getProgressiveThresholdSections().getEnumerator();
        List sectionInUse = new List(Types::Record);
        while(listEnumerator.moveNext())
        {
            ThresholdSections_IN currentTaxThresholdSection = listEnumerator.current();
            if (currentTaxThresholdSection.UpLimit != 0 && calculatedAmount >= (currentTaxThresholdSection.UpLimit - currentTaxThresholdSection.LowLimit))
            {
                calculatedAmount -= (currentTaxThresholdSection.UpLimit - currentTaxThresholdSection.LowLimit);
            }
            else
            {
                if (calculatedAmount != 0)
                {
                    currentTaxThresholdSection.LowLimit += calculatedAmount;
                    calculatedAmount = 0;
                }
                sectionInUse.addStart(currentTaxThresholdSection);
            }
        }

        // Set tax value for each section, since if the section tax value is not marked as calculated, it may not use their own tax value.
        Map sectionTaxValueMap = new Map(Types::Int64, Types::Real);
        ListEnumerator inUsedListEnumerator = sectionInUse.getEnumerator();
        List calculationSection = new List(Types::Record);
        TaxValue_IN upperCalcLevelTaxValue;
        while (inUsedListEnumerator.moveNext())
        {
            ThresholdSections_IN currentTaxThresholdSection = inUsedListEnumerator.current();
            TaxValueData_IN currentTaxValueData = progTaxValueData.exists(currentTaxThresholdSection.RecId) ? progTaxValueData.lookup(currentTaxThresholdSection.RecId) : null;
            if (currentTaxValueData)
            {
                TaxValue_IN currentTaxValue;
                if (currentTaxValueData.IsCalculate)
                {
                    // If current section tax value is calculated, use his own tax value.
                    currentTaxValue = currentTaxValueData.TaxValue;
                    if (currentTaxValueData.CalcUncalcPostedTrans)
                    {
                        upperCalcLevelTaxValue = currentTaxValueData.TaxValue;
                    }
                }
                else
                {
                    if (currentTaxValueData.CalcUncalcPostedTrans)
                    {
                        // If current section tax value is calculate previous non taxes. use his own tax value.
                        // This is follow the origin logic which implemented in getProgressiveTaxAmount
                        currentTaxValue = currentTaxValueData.TaxValue;
                    }
                    else
                    {
                        // If current section tax value is not calculated previous non taxes, use the upper level tax value which is marked as calculate and calculate previous.
                        currentTaxValue = upperCalcLevelTaxValue;
                    }
                }

                sectionTaxValueMap.add(currentTaxThresholdSection.RecId, currentTaxValue);
            }

            calculationSection.addStart(currentTaxThresholdSection);
        }

        // Calculate tax
        AmountMST unCalculatedAmt = _grossAmount;
        AmountMST taxAmount;
        ListEnumerator calcSectionListEnumerator = calculationSection.getEnumerator();
        while (calcSectionListEnumerator.moveNext())
        {
            if (unCalculatedAmt == 0)
            {
                break;
            }
            ThresholdSections_IN currentCalcSection = calcSectionListEnumerator.current();
            TaxValue_IN currentCalcTaxValue = sectionTaxValueMap.exists(currentCalcSection.RecId) ? sectionTaxValueMap.lookup(currentCalcSection.RecId) : 0;
            if (currentCalcSection.UpLimit != 0)
            {
                AmountMST calcBaseAmount = currentCalcSection.UpLimit - currentCalcSection.LowLimit;
                AmountMST currrentSectionRange = calcBaseAmount;
                // Adjust section range if price inclusive
                if (_isInclusiveCalculation)
                {
                    currrentSectionRange = calcBaseAmount * (1 + currentCalcTaxValue / 100);
                }

                if (unCalculatedAmt > currrentSectionRange)
                {
                    // The amount which used to calculate will always be the section limits range.
                    taxAmount += calcBaseAmount * currentCalcTaxValue;
                    grossAmountExcludeTax += calcBaseAmount;
                    unCalculatedAmt -= currrentSectionRange;
                }
                else
                {
                    // Adjust the base if price inclusive
                    if (unCalculatedAmt && _isInclusiveCalculation)
                    {
                        unCalculatedAmt = unCalculatedAmt / (1 + currentCalcTaxValue / 100);
                    }
                    taxAmount += unCalculatedAmt * currentCalcTaxValue;
                    grossAmountExcludeTax += unCalculatedAmt;
                    unCalculatedAmt = 0;
                }
            }
            else
            {
                // Adjust the base if price inclusive
                if (unCalculatedAmt && _isInclusiveCalculation)
                {
                    unCalculatedAmt = unCalculatedAmt / (1 + currentCalcTaxValue / 100);
                }
                taxAmount += unCalculatedAmt * currentCalcTaxValue;
                grossAmountExcludeTax += unCalculatedAmt;
                unCalculatedAmt = 0;
            }
        }

        return [true, taxAmount, grossAmountExcludeTax];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProgressiveTaxValueData</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Get progressive tax value data which found.
    /// </summary>
    /// <returns>
    ///     Return the tax value data which may used for progressive calculation.
    /// </returns>
    public Map getProgressiveTaxValueData()
    {
        ListEnumerator                      listEnumerator;
        ThresholdSections_IN                taxThresholdSection;
        TaxValueData_IN                     taxValueData_IN;

        if (!isProgTaxValueDataCalculated)
        {

            listEnumerator = this.getProgressiveThresholdSections().GetEnumerator();

            this.getTaxValueData();

            while(listEnumerator.moveNext())
            {
                taxThresholdSection = listEnumerator.current();
                select firstOnly taxValueData_IN
                    where taxValueData_IN.ThresholdSections                 == taxThresholdSection.RecId
                        && taxValueData_IN.IsOverLook                       == taxValueData.IsOverLook
                        && taxValueData_IN.ValidFrom                        <= taxWHTThresholdSourceLineImpl.parmThreholdLineTransDate()
                        && (taxValueData_IN.ValidTo                         >= taxWHTThresholdSourceLineImpl.parmThreholdLineTransDate() || !taxValueData.ValidTo)
                        && taxValueData_IN.PANTaxStatus_IN                  == taxValueData.PANTaxStatus_IN
                        && taxValueData_IN.SourceReferenceTableId           == taxValueData.SourceReferenceTableId
                        && taxValueData_IN.SourceReferenceRecId             == taxValueData.SourceReferenceRecId;

                if (taxValueData_IN.RecId != 0)
                {
                    progTaxValueData.insert(taxThresholdSection.RecId, taxValueData_IN);
                }
            }

            isProgTaxValueDataCalculated = true;
        }

        return progTaxValueData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isValidProgressiveThreshold</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether progressive calculation is capable.
    /// </summary>
    /// <returns>
    ///     Return true if progressive calculation is capable.
    /// </returns>
    public boolean isValidProgressiveThreshold()
    {
        if (this.getProgressiveThresholdSections().elements() <= 1)
        return false;

        if (progTaxValueData.elements() != this.getProgressiveThresholdSections().elements())
        return false;

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProgressiveThresholdSections</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets a list of progressive <c>ThresholdSections_IN</c>.
    ///     If it has not been calculated yet, calculate it.
    /// </summary>
    /// <returns>
    ///     Returns a list of threshold sections.
    /// </returns>
    public List getProgressiveThresholdSections()
    {
        ListEnumerator listEnumerator;

        if (!isProgThresholdSectionsCalculated)
        {
            this.getTargetThresholdSectionsLeftSiblings();
            listEnumerator = targetThresholdSectionsLeftSiblings.getEnumerator();

            while(listEnumerator.moveNext())
            {
                progThresholdSections.addEnd(listEnumerator.current());
            }
            progThresholdSections.addEnd(targetThresholdSection);

            this.sortProgressiveSections();

            isProgThresholdSectionsCalculated = true;
        }

        return progThresholdSections;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sortProgressiveSections</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sorts the progressive <c>ThresholdSections_IN</c> list.
    ///     It also validate the list and the list will be emptied if it is invalid.
    /// </summary>
    protected void sortProgressiveSections()
    {
        Map                  mapSection;
        ListEnumerator       listEnumerator;
        ThresholdSections_IN thresholdSection;
        MapEnumerator        mapEnumerator;
        boolean              gapExists = false;
        ThresholdSections_IN preThresholdSection;

        if (progThresholdSections.elements() <= 1)
        return;

        mapSection = new Map(Types::Real, Types::Record);

        try
        {
            listEnumerator = progThresholdSections.getEnumerator();
            while(listEnumerator.moveNext())
            {
                thresholdSection = listEnumerator.current();
                if (thresholdSection.ThresholdCalculationType == ThresholdCalculationType_IN::Cumulative)
                {
                    mapSection.insert(thresholdSection.LowLimit, thresholdSection);
                }
            }

            if (mapSection.elements() <= 1)
            {
                progThresholdSections = new List(Types::Record);
                return;
            }

            progThresholdSections = new List(Types::Record);
            mapEnumerator = mapSection.getEnumerator();
            while(mapEnumerator.moveNext())
            {
                progThresholdSections.addEnd(mapEnumerator.currentValue());
                if (preThresholdSection.RecId == 0)
                {
                    preThresholdSection = mapEnumerator.currentValue();
                }
                else
                {
                    thresholdSection = mapEnumerator.currentValue();
                    if (preThresholdSection.UpLimit == 0)
                    {
                        gapExists = true;
                        break;
                    }
                    else
                    {
                        if (preThresholdSection.UpLimit != thresholdSection.LowLimit)
                        {
                            gapExists = true;
                            break;
                        }
                        else
                        {
                            preThresholdSection = mapEnumerator.currentValue();
                        }
                    }
                }
            }

            if (gapExists)
            {
                progThresholdSections = new List(Types::Record);
            }
        }
        catch(Exception::Error)
        {
            // Skip the error!
            progThresholdSections = new List(Types::Record);
            retry;
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>