<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>EcoResCategoryTreeDatasource</Name>
	<SourceCode>
		<Declaration><![CDATA[
class EcoResCategoryTreeDatasource extends CCFormTreeDatasource
{
    EcoResCategoryHierarchy         currentSelectedCategoryHierarchy;
    ProcCategoryTmpPolicyRule       procCategoryTmpPolicyRule;
    ImageListAppl_EcoResCategory    ecoresImageList;
    FormDataSource                  formDataSourceParent;
    EcoResCategoryLookupParameters  lookupParameters;
    boolean                         showFriendlyNameWithName;
    QueryBuildRange                 formDataSourceRange;
    boolean                         greyOutNonLeafNodes;
    boolean                         showActiveNodesOnly;
    boolean                         organizationFilterSet;
    Map                             availableCategoriesMap;
    Array                           matchingCategoryArray;
    boolean                         filterSet;
    EcoResCategoryName              nameFilter;
    int                             currentIndexInFocus;

    private EcoResCategoryLevel     levelLimit;

    #resAppl
    #EcoResCategoryDefaults

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addChildCategoriesToMap</Name>
				<Source><![CDATA[
    private void addChildCategoriesToMap(RecId _recId)
    {
        EcoResCategory  ecoResCategory;

        if (!availableCategoriesMap.exists(_recId))
        {
            availableCategoriesMap.insert(_recId, _recId);
        }

        while select RecId from ecoResCategory
            where ecoResCategory.ParentCategory == _recId
        {
            this.addChildCategoriesToMap(ecoResCategory.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addParentCategoriesToMap</Name>
				<Source><![CDATA[
    private void addParentCategoriesToMap(EcoResCategory _ecoResCategory)
    {
        EcoResCategory  ecoResCategory;

        if (!availableCategoriesMap.exists(_ecoResCategory.RecId))
        {
            availableCategoriesMap.insert(_ecoResCategory.RecId, _ecoResCategory.RecId);
        }

        while select * from ecoResCategory
            where ecoResCategory.RecId == _ecoResCategory.ParentCategory
        {
            this.addParentCategoriesToMap(ecoResCategory);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>onExpanded</Name>
				<Source><![CDATA[
    internal void onExpanded(int _idx, FormTreeExpand _action)
    {
        if (_action == FormTreeExpand::Expand)
        {
            using (EcoResCategoryTreePerformanceContext context = EcoResCategoryTreePerformanceContext::construct())
            {
                this.updateTree(_idx);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSubTree</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Builds the subtree nodes in the tree control.
    /// </summary>
    /// <param name="_parentIdx">
    ///    The index of the item in the tree for which to build the subtree.
    /// </param>
    /// <param name="_parentVaue">
    ///    The category ID of the selected node.
    /// </param>
    /// <param name="_rebuild">
    ///    A Boolean value that indicates whether to rebuild the tree from nothing.
    /// </param>
    /// <returns>
    ///    The index of the currently selected item in the tree.
    /// </returns>
    int buildSubTree(int _parentIdx, anytype _parentVaue, boolean _rebuild = false)
    {
        int             idxCurrentRecord;
        int64           filterRecordsCount = 0;

        tree.lockWindowUpdate(true);

        FormTreeItem parentTreeItem = tree.getItem(_parentIdx);
        boolean stateExpandedOnce = !_rebuild && parentTreeItem && parentTreeItem.stateExpandedOnce();

        if (_rebuild || !stateExpandedOnce)
        {
            if (filterSet)
            {
                filterRecordsCount = EcoResCategory::getRoot(currentSelectedCategoryHierarchy.RecId)
                    .existByNameInCategory(nameFilter, showActiveNodesOnly, greyOutNonLeafNodes, organizationFilterSet ? lookupParameters : null);

                if (filterRecordsCount > #MaxFilterRecordsCount)
                {
                    Box::stop("@SYS308853");
                    return _parentIdx;
                }
            }

            if (_rebuild) // delete existing subtree
            {
                int hdl = tree.getChild(_parentIdx);
                while (hdl)
                {
                    tree.delete(hdl);
                    hdl = tree.getChild(_parentIdx);
                }
                matchingCategoryArray   = new Array(Types::Integer);
                currentIndexInFocus     = 0;
            }
            [SelectedData] = selectionStack.pop();

            EcoResCategory ecoResParentCategory = EcoResCategory::find(_parentVaue);

            //refresh this node
            if (parentTreeItem)
            {
                parentTreeItem.text(this.constructItemText(ecoResParentCategory, ''));
                tree.setItem(parentTreeItem);
            }

            using (EcoResCategoryTreePerformanceContext context = EcoResCategoryTreePerformanceContext::construct())
            {
                EcoResCategoryTranslation categoryTranslation;
                EcoResCategory ecoResCategory = this.findCategoryChildren(ecoResParentCategory, categoryTranslation);
            
                int children = 0;
                while (ecoResCategory)
                {
                    boolean isAMatch     = false;
                    boolean expandBranch = false;
                    boolean bold = false;

                    if (!this.isCategoryAvailable(ecoResCategory.RecId))
                    {
                        next ecoResCategory;
                        continue;
                    }

                    if (filterSet)
                    {
                        if (  (ecoResCategory.IsActive || !showActiveNodesOnly) &&
                                (ecoResCategory.isLeaf() || !greyOutNonLeafNodes) &&
                                    (ecoResCategory.Name like nameFilter))
                        {
                            //if this node meets the filter criteria, then highlight this node
                            isAMatch     = true;
                            bold         = true;
                        }
                        if (ecoResCategory.existByNameInCategory(nameFilter,
                                                                 showActiveNodesOnly,
                                                                 greyOutNonLeafNodes, 
                                                                 organizationFilterSet ? lookupParameters : null))
                        {
                            //if either this node or any of its descendants meet the filter criteria
                            //we need to expand this branch to later highlight the node
                            expandBranch = true;
                        }
                    }

                    FormTreeItem formTreeItem = new FormTreeItem(this.constructItemText(ecoResCategory, categoryTranslation.FriendlyName), this.image(), this.checkChildrenExist(ecoResCategory), ecoResCategory.RecId);
                    if (greyOutNonLeafNodes)
                    {
                        if (ecoResCategory.isLeaf())
                        {
                            bold = true;
                        }
                        else
                        {
                            formTreeItem.stateCut(true);
                        }
                    }

                    if (bold)
                    {
                        formTreeItem.stateBold(true);
                    }

                    int idx = tree.addItem(_parentIdx, 0, formTreeItem);

                    if (isAMatch)
                    {
                        matchingCategoryArray.value(matchingCategoryArray.lastIndex() + 1, idx);
                    }

                    formTreeItem = tree.getItem(idx);
                    formTreeItem.overlayImage(this.overlayImage(ecoResCategory));
                    tree.setItem(formTreeItem);

                    if (basicRecId == ecoResCategory.RecId)
                    {
                        idxCurrentRecord = idx;
                    }

                    children++;

                    if (selectionStack.qty())
                    {
                        if (ecoResCategory.RecId == SelectedData)
                        {
                            tree.expand(idx, FormTreeExpand::Expand);
                        }
                    }
                    else
                    {
                        if (ecoResCategory.RecId == SelectedData)
                        {
                            selectIdx = idx;
                        }
                    }

                    if (expandBranch && filterSet &&  filterRecordsCount <= #MaxFilterRecordsCount)
                    {
                        //Expand the tree only if there are fewer records matching the filter criteria.
                        tree.expand(idx, FormTreeExpand::Expand);
                    }

                    next ecoResCategory;
                }

                parentTreeItem.children(children);
                parentTreeItem.stateExpandedOnce(true);
                tree.setItem(parentTreeItem);
            }
        }
        tree.lockWindowUpdate(false);

        return idxCurrentRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCategoryChildren</Name>
				<Source><![CDATA[
    /// <summary>
    /// Responsible for finding all children categories of a parent category.
    /// In order to improve performance, translations are fetched in the same query in findTreeChildren.
    /// For compatibility reasons, getChildrenEcoResCategory is still called and used if it returns a result.
    /// Unless extended, getChildrenEcoResCategory will return null in the <c>EcoResCategoryTreePerformanceContext</c>.
    /// </summary>
    /// <param name = "_parentCategory">The parent category for which children should be fetched.</param>
    /// <param name = "_categoryTranslation">The translation buffer to populate.</param>
    /// <returns>The category table buffer populated with the child categories of the parent category.</returns>
    private EcoResCategory findCategoryChildren(EcoResCategory _parentCategory, EcoResCategoryTranslation _categoryTranslation)
    {
        EcoResCategory ecoResCategory = this.getChildrenEcoResCategory(_parentCategory);
        if (!ecoResCategory && EcoResCategoryTreePerformanceContext::isPerformanceContextEnabled())
        {
            this.findTreeChildren(ecoResCategory, _categoryTranslation, _parentCategory);
        }
        return ecoResCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTreeChildren</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fetches children of the parent category with their translations for building the tree.
    /// </summary>
    /// <param name = "_ecoResCategory">The category buffer to be populated.</param>
    /// <param name = "_categoryTranslation">The translation buffer to be populated.</param>
    /// <param name = "_parentCategory">The parent category, whose children should be fetched.</param>
    private void findTreeChildren(EcoResCategory _ecoResCategory, EcoResCategoryTranslation _categoryTranslation, EcoResCategory _parentCategory)
    {
        LanguageId languageId = LanguageTable::defaultLanguage();
        boolean isRetailDisplayOrderFeatureEnabled = FeatureStateProvider::isFeatureEnabled(RetailEnableDisplayOrderForMerchandisingFeature::instance());
        if (levelLimit > 0)
        {
            if (isRetailDisplayOrderFeatureEnabled)
            {
                // Order by DisplayOrder and Name
                select * from _ecoResCategory
                         order by _ecoResCategory.DisplayOrder, _ecoResCategory.Name
                         where _ecoResCategory.CategoryHierarchy == _parentCategory.CategoryHierarchy
                            && _ecoResCategory.ParentCategory  == _parentCategory.RecId
                            && (_ecoResCategory.IsActive == true || _ecoResCategory.IsActive == showActiveNodesOnly)
                            && _ecoResCategory.Level <= levelLimit
                         outer join FriendlyName from _categoryTranslation
                         where _categoryTranslation.Category == _ecoResCategory.RecId
                            && _categoryTranslation.LanguageId == languageId;
            }
            else
            {
                // Order by Name only
                select * from _ecoResCategory
                         order by _ecoResCategory.Name
                         where _ecoResCategory.CategoryHierarchy == _parentCategory.CategoryHierarchy
                            && _ecoResCategory.ParentCategory  == _parentCategory.RecId
                            && (_ecoResCategory.IsActive == true || _ecoResCategory.IsActive == showActiveNodesOnly)
                            && _ecoResCategory.Level <= levelLimit
                         outer join FriendlyName from _categoryTranslation
                         where _categoryTranslation.Category == _ecoResCategory.RecId
                            && _categoryTranslation.LanguageId == languageId;
            }
        }
        else
        {
            if (isRetailDisplayOrderFeatureEnabled)
            {
                // Order by DisplayOrder and Name
                select * from _ecoResCategory
                         order by _ecoResCategory.DisplayOrder, _ecoResCategory.Name
                         where _ecoResCategory.CategoryHierarchy == _parentCategory.CategoryHierarchy
                            && _ecoResCategory.ParentCategory  == _parentCategory.RecId
                            && (_ecoResCategory.IsActive == true || _ecoResCategory.IsActive == showActiveNodesOnly)
                         outer join FriendlyName from _categoryTranslation
                         where _categoryTranslation.Category == _ecoResCategory.RecId
                            && _categoryTranslation.LanguageId == languageId;
            }
            else
            {
                // Order by Name Only
                select * from _ecoResCategory
                         order by _ecoResCategory.Name
                         where _ecoResCategory.CategoryHierarchy == _parentCategory.CategoryHierarchy
                            && _ecoResCategory.ParentCategory  == _parentCategory.RecId
                            && (_ecoResCategory.IsActive == true || _ecoResCategory.IsActive == showActiveNodesOnly)
                         outer join FriendlyName from _categoryTranslation
                         where _categoryTranslation.Category == _ecoResCategory.RecId
                            && _categoryTranslation.LanguageId == languageId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkChildrenExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the given category has any child categories.
    /// For performance reasons, the isLeaf method can be used to determine if there are any children. 
    /// For compatibility reasons, getChildCount is still called, enabling extensions to modify the result.
    /// </summary>
    /// <param name = "_ecoResCategory">The category to check for children.</param>
    /// <returns>True if there are any children; false if there are none.</returns>
    private boolean checkChildrenExist(EcoResCategory _ecoResCategory)
    {
        int64 childCount = _ecoResCategory.getChildCount(showActiveNodesOnly, levelLimit);

        if (childCount == 0 && EcoResCategoryTreePerformanceContext::isPerformanceContextEnabled())
        {
            return !_ecoResCategory.isLeaf();
        }

        return childCount != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canModifyCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether it can modify the currently selected node.
    /// </summary>
    /// <returns>
    /// true if it is enabled; otherwise, false.
    /// </returns>
    boolean canModifyCategory()
    {
        int         idx     = tree.getSelection();
        int         idxRoot = tree.getRoot();
        boolean     bDelete = false;

        //Root cannot be deleted. Rest we can.
        if (idx && (idx != idxRoot))
        {
            bDelete = true;
        }

        return bDelete;
    }

]]></Source>
			</Method>
			<Method>
				<Name>create</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new category node in the tree control which is controlled by this class.
    /// </summary>
    void create()
    {
        int                     idx = tree.getSelection();
        EcoResCategory          ecoResCategory;

        if (!formDataSource.leaveRecord())
        {
            return;
        }

        tree.expand(idx, FormTreeExpand::Expand);

        // Validate the maximum number of categories and throw warning if the categories are created more than 1000 for category hierarchy.
        EcoResCategory::validateMaxCountOfCategoryInCategoryHierarchy(currentSelectedCategoryHierarchy.RecId);

        EcoResCategory ecoResParentCategory = EcoResCategory::find(tree.getItem(idx).data());
        ecoResCategory.initValue();
        ecoResCategory.initFromParent(ecoResParentCategory);
        ecoResCategory.Name  = EcoResCategory::findNonExistNameInHierarchy(currentSelectedCategoryHierarchy.RecId);

        if (ecoResCategory.addToHierarchy() && ecoResCategory.RecId)
        {
            formDataSource.research();
            basicRecId = ecoResCategory.RecId;
            Common childRecord = ecoResCategory;
            tree.setFocus();

            FormTreeItem formTreeItem = tree.getItem(idx);
            int children = formTreeItem.children();
            formTreeItem.children(children+1);
            formTreeItem.stateExpandedOnce(true);
            formTreeItem.data(ecoResParentCategory.RecId);
            tree.setItem(formTreeItem);

            formTreeItem = new FormTreeItem(this.itemTextEx(childRecord.(id), this.itemDescription(childRecord),  this.itemFriendlyName(childRecord), ecoResCategory.IsActive),
                                            this.image(),
                                            0,
                                            basicRecId);

            int idxCurrentRecord = tree.addItem(idx,0,formTreeItem);
            formTreeItem = tree.getItem(idxCurrentRecord);
            formTreeItem.overlayImage(this.overlayImage(childRecord));
            tree.setItem( formTreeItem );
            tree.select(idxCurrentRecord);

            // Code to insert the EcoResCategoryTranslation fileds
            EcoResCategoryTranslation::createOrUpdateCategoryTranslation(ecoResCategory.RecId, ecoResCategory.Name,"","");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the currently selected category node.
    /// </summary>
    /// <param name="_noConfirmationDialog">
    ///    A Boolean value that indicates whether to display a confirmation dialog box.
    /// </param>
    void delete(boolean _noConfirmationDialog = false)
    {
        int             idx            = tree.getSelection();
        int             idxParent      = tree.getParent(idx);
        FormTreeItem    formTreeItem   = tree.getItem(idx);
        EcoResCategory  ecoResCategory = null;
        str             warningLabel;

        if (!formTreeItem)
        {
            return;
        }

        boolean bHasChildren = formTreeItem.children();

        ecoResCategory = EcoResCategory::find(formTreeItem.data(), true);

        if (bHasChildren)
        {
            warningLabel = "@SYS134301";
        }
        else
        {
            warningLabel = "@SYS134302";
        }

        if (_noConfirmationDialog || Box::yesNo(strfmt(warningLabel, formTreeItem.text()), DialogButton::No) == DialogButton::Yes)
        {
            formDataSource.reread();

            ecoResCategory.deleteSubTree();
            tree.select(idxParent);

            formDataSource.reread();
            formDataSource.refresh();

            if (idxParent == 0)
            {
                tree.deleteAll();
                return;
            }

            tree.setFocus();
            tree.delete(idx);
            tree.select(idxParent);
            formTreeItem    = tree.getItem(idxParent);
            formTreeItem.children(tree.getChild((formTreeItem.idx())));
            tree.setItem(formTreeItem);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dragDropRestriction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the category hierarchy specific restrictions on dropping on a given target.
    /// </summary>
    /// <param name="_idx">
    /// The ID of the target element in the tree control, which is controlled by this class.
    /// </param>
    /// <param name="_dragSource">
    /// The source of the drag. The tree control, if valid.
    /// </param>
    /// <returns>
    /// The <c>FormDrag::None</c> enumeration value if the drop is not enabled; otherwise, the
    /// <c>FormDrag::Move</c> enumeration value.
    /// </returns>
    /// <remarks>
    /// The function is overridden to disallow Drag Drop functionality.
    /// </remarks>
    [SuppressBpWarning('BPParameterNotUsed', 'Unused parameters cannot be deleted from overrides.')]
    FormDrag dragDropRestriction(int _idx, FormControl _dragSource)
    {
        FormDrag        ret = FormDrag::None;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandAndSelect</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Expands the tree and selects the tree node with the specified data value.
    /// </summary>
    /// <param name="_selectData">
    ///    The category ID of the node to be selected.
    /// </param>
    public void expandAndSelect(anytype _selectData)
    {
        anytype             treeElementData;
        EcoResCategory      ecoResCategoryAscendants = null;
        EcoResCategory      ecoResCategorySelect     = EcoResCategory::find(_selectData);
        anytype             currentRecordId;

        if (!ecoResCategorySelect ||
                !ecoResCategorySelect.RecId ||
                    ecoResCategorySelect.CategoryHierarchy != currentSelectedCategoryHierarchy.RecId)
        {
            return;
        }

        ecoResCategoryAscendants = this.getEcoResCategoryAscendants(ecoResCategorySelect);
        this.initSelectIdx();

        tree.lockWindowUpdate(true);
        int idx = tree.getRoot();

        //walk through the ascendants, selecting each one of them
        while (ecoResCategoryAscendants)
        {
            currentRecordId     = ecoResCategoryAscendants.RecId;
            treeElementData     = tree.getItem(idx).data();

            while (treeElementData != currentRecordId)
            {
                idx             = tree.getNextVisible(idx);
                treeElementData = tree.getItem(idx).data();
            }

            tree.select(idx);
            next ecoResCategoryAscendants;

            if (ecoResCategoryAscendants)
            {
                tree.expand(idx, FormTreeExpand::Expand);
            }
        }

        //select the current one
        if (ecoResCategorySelect)
        {
            tree.expand(idx, FormTreeExpand::Expand);
            currentRecordId     = ecoResCategorySelect.RecId;
            treeElementData     = tree.getItem(idx).data();

            boolean isFlightEnabled = ProcHierarchyCorruptedCategoryThrowsWarningFlight::instance().isEnabled();

            while (treeElementData != currentRecordId)
            {
                idx = tree.getNextVisible(idx);

                if (!idx && isFlightEnabled)
                {
                    throw warning(strFmt("@SCM:EcoResCategoryNotFoundInNestedSetModel", ecoResCategorySelect.Name));
                }

                treeElementData = tree.getItem(idx).data();
            }
            tree.select(idx);
        }

        tree.setFocus();
        tree.select(idx);
        tree.selectSetFirstVisible(idx);
        tree.lockWindowUpdate(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>image</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the image needed depending on the type of category element represented by the current
    /// record.
    /// </summary>
    /// <param name="_childRecord">
    /// The current record.
    /// </param>
    /// <returns>
    /// The ID of the image.
    /// </returns>
    /// <remarks>
    /// See also the <see cref="M:EcoResCategoryTreeDatasource.imageList" /> method.
    /// </remarks>
    int image(Common _childRecord = null)
    {
        // Both root & ancestor categories share the same icon
        ecoresImageList.add(#ImageSetupValidationAssignCategories);
        return ecoresImageList.image(#ImageSetupValidationAssignCategories);
    }

]]></Source>
			</Method>
			<Method>
				<Name>imageList</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a list of images referenced by the ID retrieved by the
    ///    <c>EcoResCategoryTreeDatasource.image</c> method.
    /// </summary>
    /// <returns>
    ///    The image list.
    /// </returns>
    Imagelist imageList()
    {
        return ecoresImageList.imageList();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeAvailableCategoriesMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a map with categories that are available in the organization combination.
    /// </summary>
    /// <remarks>
    /// This method filters out the categories that are based on the categories selected on the linked
    /// purchase agreement.
    /// </remarks>
    private void initializeAvailableCategoriesMap()
    {
        organizationFilterSet    = false;
        availableCategoriesMap   = new Map(Types::Int64, Types::Int64);

        if (lookupParameters.parmBuyingLegalEntity() || lookupParameters.parmReceivingOperatingUnit())
        {
            procCategoryTmpPolicyRule.setTmpData(EcoResCategory::getProcCategoryRules(SysPolicyRuleTypeEnum::CategoryAccessPolicyRule,
                                                                            lookupParameters.parmBuyingLegalEntity(),
                                                                            lookupParameters.parmReceivingOperatingUnit(),
                                                                            lookupParameters.parmOrganizationOption()));

            select count(RecId) from procCategoryTmpPolicyRule;

            //when there are no category access rules, all categories should be available
            if (procCategoryTmpPolicyRule.RecId)
            {
                organizationFilterSet = true;
                this.populateAvailableCategoriesMap();
            }
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            if (lookupParameters.parmPurchAgreementHeaderRecId())
            {
                EcoResCategory                      thisCategory;
                AgreementLine                       agreementLine;
                AgreementHeader                     agreementHeader;
                while select RecId, CategoryHierarchy, ParentCategory from thisCategory
                    join Category from agreementLine where thisCategory.RecId == agreementLine.Category
                    join RecId from agreementHeader where agreementLine.Agreement == agreementHeader.RecId
                    && agreementHeader.RecId == lookupParameters.parmPurchAgreementHeaderRecId()
                {
                    if (!availableCategoriesMap.exists(thisCategory.RecId))
                    {
                        if (!availableCategoriesMap.exists(thisCategory.CategoryHierarchy))
                        {
                            availableCategoriesMap.insert(thisCategory.CategoryHierarchy, thisCategory.CategoryHierarchy);
                        }

                        if (!availableCategoriesMap.exists(thisCategory.ParentCategory))
                        {
                            availableCategoriesMap.insert(thisCategory.ParentCategory, thisCategory.ParentCategory);
                        }

                        availableCategoriesMap.insert(thisCategory.RecId, thisCategory.RecId);
                        this.addChildCategoriesToMap(thisCategory.RecId);
                        this.addParentCategoriesToMap(thisCategory);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateAvailableCategoriesMap</Name>
				<Source><![CDATA[
    private void populateAvailableCategoriesMap()
    {
        EcoResCategory subCategory, superCategory;
        ProcCategoryAccessPolicyParameter procCategoryAccessPolicyParameter;

        while select procCategoryTmpPolicyRule
                join procCategoryAccessPolicyParameter
               where procCategoryTmpPolicyRule.PolicyRule == procCategoryAccessPolicyParameter.ProcurementCategoryAccessPolicyRule
                join subCategory
               where subCategory.RecId == procCategoryAccessPolicyParameter.ProcurementCategory
                join RecId from superCategory
            group by superCategory.RecId
               where superCategory.NestedSetLeft <= subCategory.NestedSetLeft
                  && superCategory.NestedSetRight >= subCategory.NestedSetRight
                  && superCategory.CategoryHierarchy == subCategory.CategoryHierarchy
        {
            availableCategoriesMap.insert(superCategory.RecId, superCategory.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRoot</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new root node in the tree control.
    /// </summary>
    /// <param name="_txt">
    ///    The category name text.
    /// </param>
    /// <param name="_rootValue">
    ///    The root node category ID.
    /// </param>
    /// <param name="_rootImage">
    ///    The ID of the image to be displayed for the root node.
    /// </param>
    void initRoot(str 250 _txt, anytype _rootValue, int _rootImage = 0)
    {
        if (!this.isCategoryAvailable(_rootValue))
        {
            return;
        }

        super(_txt, _rootValue, _rootImage);

        int idx = tree.getRoot();

        if (idx)
        {
            tree.select(idx);
            if (greyOutNonLeafNodes)
            {
                this.setItemStateCut(tree.getRoot());
            }
            FormTreeItem formTreeItem = tree.getItem(idx);
            formTreeItem.overlayImage(this.overlayImage(EcoResCategory::find(formTreeItem.data())));
            tree.setItem( formTreeItem );
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSelectIdx</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Resets the selected tree node.
    /// </summary>
    void initSelectIdx()
    {
        selectIdx = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new tree record.
    /// </summary>
    /// <param name="_common">
    ///    The record to initialize.
    /// </param>
    /// <returns>
    ///    The initialized record.
    /// </returns>
    /// <remarks>
    ///    Default names and descriptions are given.
    /// </remarks>
    Common initValue(Common _common)
    {
        EcoResCategory ecoResCategory;

        ecoResCategory.initValue();
        ecoResCategory.Name        = #NewSubCategory;
        return ecoResCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCategoryAvailable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a category is available in the specified organization combination.
    /// </summary>
    /// <param name="_ecoResCategoryId">
    /// The category ID to check for availability.
    /// </param>
    /// <returns>
    /// true if a category is available; otherwise, false .
    /// </returns>
    boolean isCategoryAvailable(EcoResCategoryId _ecoResCategoryId)
    {
        boolean available;

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            available = (organizationFilterSet || lookupParameters.parmPurchAgreementHeaderRecId()) ? availableCategoriesMap.exists(_ecoResCategoryId) : true;
        }
        else
        {
            available = organizationFilterSet? availableCategoriesMap.exists(_ecoResCategoryId) : true;
        }
        return available;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemFriendlyName</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the <c>FriendlyName</c> code for the specified category.
    /// </summary>
    /// <param name="_common">
    ///    The current category record.
    /// </param>
    /// <returns>
    ///    The <c>FriendlyName</c> code for the specified category.
    /// </returns>
    str itemFriendlyName(Common _common)
    {
        EcoResCategory ecoResCategory = _common;
        EcoResCategoryFriendlyName  ecoResFriendlyName = EcoResCategoryTranslation::find(ecoResCategory.RecId).FriendlyName;

        return strfmt('%1', ecoResFriendlyName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemTextEx</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the tree node item text to be displayed.
    /// </summary>
    /// <param name="_idTxt">
    ///    The category ID text.
    /// </param>
    /// <param name="_descriptionTxt">
    ///    The current category name text.
    /// </param>
    /// <param name="_friendlyName">
    ///    The current category friendlyName text.
    /// </param>
    /// <param name="_isActive">
    ///    Controls whether text for marking inactive nodes should be included.
    /// </param>
    /// <returns>
    ///    The concatenated tree node item text for display purposes.
    /// </returns>
    /// <remarks>
    ///    This method is used to control whether the commodity code will be displayed together with the
    ///    category name in the tree view control.
    /// </remarks>
    str itemTextEx(anytype _idTxt, anytype _descriptionTxt, str _friendlyName, boolean _isActive)
    {
        str ret = this.itemText(_idTxt, _descriptionTxt);

        if (showFriendlyNameWithName && _friendlyName !='')
        {
            ret = ret + strfmt(" (%1)", _friendlyName);
        }

        if (!_isActive)
        {
            ret = strfmt("@SCM:CategoryNodeInactive", ret);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructItemText</Name>
				<Source><![CDATA[
    private str constructItemText(EcoResCategory _ecoResCategory, EcoResCategoryFriendlyName _friendlyName)
    {
        return this.itemTextEx(_ecoResCategory.RecId, this.itemDescription(_ecoResCategory),  _friendlyName ? _friendlyName : this.itemFriendlyName(_ecoResCategory), _ecoResCategory.IsActive);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadPosition</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads the initial position in the tree control which is controlled by this class.
    /// </summary>
    void loadPosition()
    {
        Integer         version;

        if (useLastValue)
        {
            if (xSysLastValue::getLast(this))
            {
                [version,#CurrentList] = xSysLastValue::getValue(this.lastValueDataAreaId(),
                                                                 this.lastValueUserId(),
                                                                 this.lastValueType(),
                                                                 this.lastValueElementName());
            }
        }

        // This is the reason to overload CCFormTreeDatasource.loadPosition(),
        // since the inherited code causes
        // AnyType RecId data to change type to String.
        if (version != #CurrentVersion)
        {
            SelectedData = EcoResCategory::getRoot(currentSelectedCategoryHierarchy.RecId).RecId;
        }

        this.getRelations(SelectedData);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new(FormDataSource                  _formDataSource,
                    FormTreeControl                 _formTreeControl,
                    fieldId                         _id,
                    fieldId                         _parentId,
                    anytype                         _txtField,
                    boolean                         _showIdInDescription,
                    boolean                         _useLastValue,
                    fieldId                         _id2,
                    EcoResCategoryHierarchy         _ecoResCategoryHierarchy,
                    FormDataSource                  _formDataSourceParent,
                    EcoResCategoryLookupParameters  _lookupParameters = null,
                    fieldId                         _sortId = fieldnum(EcoResCategory, NestedSetLeft)
                    )
    {
        formDataSourceParent             = _formDataSourceParent;
        ecoresImageList                  = new ImageListAppl_EcoResCategory();
        currentSelectedCategoryHierarchy = _ecoResCategoryHierarchy;
        matchingCategoryArray            = new Array(Types::Integer);

        if (_lookupParameters)
        {
            showFriendlyNameWithName  = _lookupParameters.parmShowFriendlyNameWithName();
            greyOutNonLeafNodes       = _lookupParameters.parmLeafNodeOnlySelect();
            showActiveNodesOnly       = _lookupParameters.parmShowActiveNodesOnly();
            nameFilter                = _lookupParameters.parmEcoResCategoryNameFilter();
            levelLimit                = _lookupParameters.parmLimitByLevel();

            if (nameFilter != '' && nameFilter != '*')
            {
                filterSet             = true;
            }

            lookupParameters          = _lookupParameters;
        }
        else
        {
            showFriendlyNameWithName  = false;
            greyOutNonLeafNodes       = false;
            showActiveNodesOnly       = false;
            filterSet                 = false;
            nameFilter                = '*';

            lookupParameters = new EcoResCategoryLookupParameters();
        }

        this.initializeAvailableCategoriesMap();

        this.buildQueryRanges(_formDataSource, _id);

        super( _formDataSource,  _formTreeControl,  _id,  _parentId,  _txtField,  _showIdInDescription,  _useLastValue,  _id2, _sortId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromParameter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of <c>EcoResCategoryTreeDatasource</c>.
    /// </summary>
    /// <param name = "_formDataSource"> The form data source. </param>
    /// <param name = "_formTreeControl"> The form tree control. </param>
    /// <param name = "_id"> The field identifier. </param>
    /// <param name = "_parentId"> The parent identifier. </param>
    /// <param name = "_txtField"> The text Field. </param>
    /// <param name = "_showIdInDescription"> The Boolean that determines if the id will be shown in the description. </param>
    /// <param name = "_useLastValue"> The boolean that determines if the last value will be used. </param>
    /// <param name = "_id2"> The second field identifier.</param>
    /// <param name = "_ecoResCategoryHierarchy"> The <c>EcoResCategoryHierarchy</c>. </param>
    /// <param name = "_formDataSourceParent"> The form data source parent.</param>
    /// <param name = "_lookupParameters"> The lookup parameters; optional. </param>
    /// <param name = "_sortId"> The sorting Id; optional. </param>
    /// <returns> The <c>EcoResCategoryTreeDatasource</c> instance. </returns>
    public static EcoResCategoryTreeDatasource newFromParameter(FormDataSource  _formDataSource,
                                                                FormTreeControl                 _formTreeControl,
                                                                fieldId                         _id,
                                                                fieldId                         _parentId,
                                                                anytype                         _txtField,
                                                                boolean                         _showIdInDescription,
                                                                boolean                         _useLastValue,
                                                                fieldId                         _id2,
                                                                EcoResCategoryHierarchy         _ecoResCategoryHierarchy,
                                                                FormDataSource                  _formDataSourceParent,
                                                                EcoResCategoryLookupParameters  _lookupParameters = null,
                                                                fieldId                         _sortId = fieldnum(EcoResCategory, NestedSetLeft))                                                                
    {
        EcoResCategoryTreeDatasource  ecoResCategoryTreeDatasource = new EcoResCategoryTreeDatasource(_formDataSource,
                                                                                                        _formTreeControl,
                                                                                                        _id,
                                                                                                        _parentId,
                                                                                                        _txtField,
                                                                                                        _showIdInDescription,
                                                                                                        _useLastValue,
                                                                                                        _id2,
                                                                                                        _ecoResCategoryHierarchy,
                                                                                                        _formDataSourceParent,
                                                                                                        _lookupParameters,
                                                                                                        _sortId);
        return ecoResCategoryTreeDatasource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQueryRanges</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Builds query ranges on the form datasource.
    /// </summary>
    /// <param name = "_formDataSource">
    ///     The form data source.
    /// </param>
    /// <param name = "_id">
    ///     The field ID.
    /// </param>
    protected void buildQueryRanges(FormDataSource _formDataSource, FieldId _id)
    {
        EcoResCategory  ecoResCategory;
        
        // This specialization assumes that the id of nodes is the RecId field.
        Debug::assert(_id == fieldname2id(ecoResCategory.TableId, fieldStr(Common, RecId)));

        Query query = _formDataSource.query();
        query.dataSourceTable(tablenum(EcoResCategory)).clearRanges();
        
        formDataSourceRange = query.dataSourceTable(ecoResCategory.TableId).findRange(fieldname2id(ecoResCategory.TableId, fieldStr(Common, RecId)));
        if (! formDataSourceRange)
        {
            formDataSourceRange = query.dataSourceTable(ecoResCategory.TableId).addRange(fieldname2id(ecoResCategory.TableId, fieldStr(Common, RecId)));
        }

        if (showActiveNodesOnly)
        {
            QueryBuildRange range = query.dataSourceTable(tablenum(EcoResCategory)).findRange(fieldnum(EcoResCategory, IsActive));
            if (!range)
            {
                range = query.dataSourceTable(tablenum(EcoResCategory)).addRange(fieldnum(EcoResCategory, IsActive));
            }
            range.value( queryValue(1) );
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>overlayImage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the overlay image needed depending on whether the category is active.
    /// </summary>
    /// <param name="_childRecord">
    /// The current record.
    /// </param>
    /// <returns>
    /// The ID of the overlay image.
    /// </returns>
    /// <remarks>
    /// See also the <see cref="M:EcoResCategoryTreeDatasource.imageList" /> method.
    /// </remarks>
    int overlayImage(Common _childRecord)
    {
        int            ret            = 0;
        EcoResCategory ecoResCategory = _childRecord;

        if (!ecoResCategory.IsActive)
        {
            ret = ecoresImageList.image(ImageListAppl_EcoResCategory::getImageOverlay4InactiveCategory());
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTmpProcCategoryPolicyRules</Name>
				<Source><![CDATA[
    public ProcCategoryTmpPolicyRule parmTmpProcCategoryPolicyRules(ProcCategoryTmpPolicyRule _procCategoryTmpPolicyRule = procCategoryTmpPolicyRule)
    {
        procCategoryTmpPolicyRule  = _procCategoryTmpPolicyRule;
        return procCategoryTmpPolicyRule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateTree</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a tree for the specified category with only the specified category and ascendants.
    /// </summary>
    /// <param name="_selectData">
    ///    The category ID of the node to select.
    /// </param>
    public void populateTree(anytype _selectData)
    {
        EcoResCategory      ecoResCategoryRoot       = EcoResCategory::getRoot(currentSelectedCategoryHierarchy.RecId);
        EcoResCategory      ecoResCategorySelect     = EcoResCategory::find(_selectData);
        EcoResCategory      ecoResCategoryAscendants = null;
        int                 idx, idxNew;

        // _txt only called from form with fixed texts (labels)
        FormTreeItem formTreeItem = new FormTreeItem(ecoResCategoryRoot.Name,
                                                                 this.image(),
                                                                 1,
                                                                 ecoResCategoryRoot.RecId);
        if (greyOutNonLeafNodes)
        {
            formTreeItem.stateCut(true);
        }
        tree.deleteAll();
        idxNew = tree.addItem(0,0,formTreeItem);
        tree.select(tree.getRoot());

        if (!ecoResCategorySelect || !ecoResCategorySelect.RecId)
        {
            return;
        }
        ecoResCategoryAscendants = this.getEcoResCategoryAscendants(ecoResCategorySelect);

        //walk through the ascendants, adding each one of them to the tree
        while (ecoResCategoryAscendants)
        {
            if (ecoResCategoryAscendants.RecId != ecoResCategoryRoot.RecId)
            {
                basicRecId = ecoResCategoryAscendants.RecId;
                tree.setFocus();
                idx          = tree.getSelection();
                formTreeItem = tree.getItem(idx);
                formTreeItem.children(formTreeItem.children()+1);
                formTreeItem.stateExpandedOnce(true);
                tree.setItem(formTreeItem);

                formTreeItem = new FormTreeItem(this.itemTextEx(ecoResCategoryAscendants.(id),
                                                this.itemDescription(ecoResCategoryAscendants),
                                                this.itemFriendlyName(ecoResCategoryAscendants),
                                                ecoResCategoryAscendants.IsActive),
                                                this.image(),
                                                0,
                                                basicRecId);

                idxNew = tree.addItem(idx,0,formTreeItem);

                if (greyOutNonLeafNodes && !ecoResCategoryAscendants.isLeaf())
                {
                    this.setItemStateCut(idxNew);
                }
                formTreeItem = tree.getItem(idxNew);
                formTreeItem.overlayImage(this.overlayImage(ecoResCategoryAscendants));
                tree.setItem( formTreeItem );
                tree.expand(idx, FormTreeExpand::Expand);
                tree.select(idxNew);
            }

            if (ecoResCategoryAscendants.RecId != ecoResCategorySelect.RecId)
            {
                next ecoResCategoryAscendants;
                if (!ecoResCategoryAscendants.RecId)
                {
                    //once done with the ascendants add the selected node
                    ecoResCategoryAscendants = ecoResCategorySelect;
                }
            }
            else
            {
                break;
            }
        }
        tree.setFocus();
        tree.select(idxNew);
        formTreeItem = tree.getItem(idxNew);
        formTreeItem.stateBold(true);
        tree.setItem( formTreeItem );
        tree.lockWindowUpdate(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectionChanged</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes the form data source query whenever the current selection in the tree changes.
    /// </summary>
    /// <param name="oldItem">
    ///    The previously selected item. This parameter has been declared for this method on a base class but
    ///    is not used here.
    /// </param>
    /// <param name="newItem">
    ///    The item now selected.
    /// </param>
    void selectionChanged(FormTreeItem oldItem, FormTreeItem newItem)
    {
        SelectedData = newItem.data();
        if (SelectedData)
        {
            formDataSourceRange = formDataSource.queryBuildDataSource().findRange(fieldnum(EcoResCategory, RecId));
            if (! formDataSourceRange)
            {
                formDataSourceRange = formDataSource.queryBuildDataSource().addRange(fieldnum(EcoResCategory, RecId));
            }
            formDataSourceRange.value(strfmt('%1', SelectedData));
            formDataSource.executeQuery();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectionChanging</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes the form data source query whenever the current selection in the tree is changing.
    /// </summary>
    /// <param name="_oldItem">
    ///    The current selected item.
    /// </param>
    /// <param name="_newItem">
    ///    The item now being selected.
    /// </param>
    /// <param name="_how">
    ///    How the new item is being selected.
    /// </param>
    /// <returns>
    ///    true if the selection change should be vetoed; otherwise, false. A boolean value that indicates
    ///    whether to veto selection change or not.
    /// </returns>
    [SuppressBpWarning('BPParameterNotUsed', 'Unused parameters cannot be deleted from overrides.')]
    public boolean selectionChanging(FormTreeItem _oldItem, FormTreeItem _newItem, FormTreeSelect _how)
    {
        boolean ret  = !formDataSource.leaveRecord();
        SelectedData = _oldItem.data();
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDatasourceStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Controls whether the tree data source should enable levels to be created.
    /// </summary>
    /// <param name="_idx">
    /// The index of the item in the tree for which to create a level child record.
    /// </param>
    void setDatasourceStatus(int _idx)
    {
        return;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFocusOnFirstMatch</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets focus on the first tree element that matches the specified category filter criteria.
    /// </summary>
    /// <returns>
    ///    The index of the currently selected element.
    /// </returns>
    int setFocusOnFirstMatch()
    {
        int idx = 0;

        tree.setFocus();
        if (matchingCategoryArray.lastIndex())
        {
            currentIndexInFocus = 1;
            idx                 = matchingCategoryArray.value(currentIndexInFocus);

            tree.select(idx);
            tree.selectSetFirstVisible(idx);
        }

        return currentIndexInFocus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFocusOnNextMatch</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets focus on the next tree element that matched the specified category filter criteria.
    /// </summary>
    /// <param name="_offset">
    ///    An integer value that indicates number of elements to move forward or backward in the filtered
    ///    category array; optional.
    /// </param>
    /// <returns>
    ///    The index of the currently selected element.
    /// </returns>
    int setFocusOnNextMatch(int _offset = 1)
    {
        int idx = 0;
        int matchingArrayFirstIndex = (matchingCategoryArray.lastIndex() > 0)? 1 : 0;
        int matchingArrayLastIndex  = matchingCategoryArray.lastIndex();
        int newArrayIndexOffset     = 0;

        if (matchingArrayLastIndex > 0)
        {
            newArrayIndexOffset = _offset mod matchingArrayLastIndex;

            if (newArrayIndexOffset < 0)
            {
                newArrayIndexOffset += matchingArrayLastIndex;
            }
        }

        tree.setFocus();
        if (newArrayIndexOffset)
        {
            currentIndexInFocus = matchingArrayFirstIndex + ((currentIndexInFocus - 1 + newArrayIndexOffset) mod matchingArrayLastIndex);

            idx = matchingCategoryArray.value(currentIndexInFocus);
            tree.select(idx);
            tree.selectSetFirstVisible(idx);
        }
        return currentIndexInFocus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setItemStateCut</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the disabled image for the specified category node.
    /// </summary>
    /// <param name="_idx">
    ///    The ID of the target element in the tree control which is controlled by this class.
    /// </param>
    /// <param name="_greyedOut">
    ///    A Boolean value that indicates whether the node should be greyed out; optional.
    /// </param>
    void setItemStateCut(int _idx, boolean _greyedOut = true)
    {
        FormTreeItem treeItem = tree.getItem(_idx);
        treeItem.stateCut(_greyedOut);
        tree.setItem(treeItem);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setNameFilter</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the category filter string.
    /// </summary>
    /// <param name="_ecoResCategoryNameFilter">
    ///    The category name filter expression to use to filter the records; optional.
    /// </param>
    void setNameFilter(EcoResCategoryName _ecoResCategoryNameFilter = '*')
    {
        if (!tree.getRoot())
        {
            return;
        }

        nameFilter  = Global::strLRTrim(_ecoResCategoryNameFilter);
        filterSet   = false;

        if (nameFilter != '' && nameFilter != '*')
        {
            filterSet = true;
        }

        tree.select(tree.getRoot());
        this.buildSubTree(tree.getRoot(), tree.getItem(tree.getRoot()).data(), true);
        tree.expand(tree.getRoot(), FormTreeExpand::Expand);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the status of the currently selected category node.
    /// </summary>
    /// <param name="_isActive">
    /// A Boolean value that indicates whether to enable this category.
    /// </param>
    /// <param name="_noConfirmationDialog">
    /// A Boolean value that indicates whether to display a confirmation dialog box.
    /// </param>
    /// <param name="_thisCatagoryonly">
    /// A Boolean value that indicates whether to set the status to only this category.
    /// </param>
    void setStatus(boolean _isActive, boolean _noConfirmationDialog = false, boolean _thisCatagoryonly = false)
    {
        int             idx = tree.getSelection();
        str             warningLabel;
        EcoResCategory  ecoResCategory = null;

        if (!formDataSource.leaveRecord())
        {
            return;
        }

        ecoResCategory =  EcoResCategory::find(tree.getItem(idx).data());

        if ( !ecoResCategory && ecoResCategory.RecId !=0 )
        {
            throw Global::error("@SYS102208");
        }
        else
        {
            FormTreeItem formTreeItem = tree.getItem(idx);
            boolean bHasChildren = formTreeItem.children();

            if (_isActive && !ecoResCategory.IsActive)
            {
                if ( !ecoResCategory.isLeaf() )
                {
                    if (!ecoResCategory.getParent().IsActive) // 4. Inactive parent and inactive child
                    {
                        warningLabel = _thisCatagoryonly ? strfmt("@SYS309706" , formTreeItem.text()) : strfmt("@SYS309707" , formTreeItem.text());
                    }
                    else if ( ecoResCategory.getParent().IsActive ) // 3. Inactive child
                    {
                        warningLabel = _thisCatagoryonly ? "@SCM:CategoryActivateSingle" : "@SCM:CategoryActivateWithSubcategories";
                    }
                }
                else
                if ( ecoResCategory.isLeaf() )
                {
                    if (ecoResCategory.getParent().IsActive) // 1. Active parent and no child
                    {
                        warningLabel = "@SCM:CategoryActivateSingle";
                    }
                    else if (!ecoResCategory.getParent().IsActive) // 2. Inactive parent and no child
                    {
                        warningLabel = strfmt("@SYS301521", formTreeItem.text());
                    }
                }
            }
            else
            {
                if (bHasChildren)
                {
                    warningLabel = strfmt("@SYS301520", formTreeItem.text());
                }
                else
                {
                    warningLabel = strfmt("@SYS301519", formTreeItem.text());
                }
            }

            if (_noConfirmationDialog || Box::yesNo(warningLabel, DialogButton::No) == DialogButton::Yes)
            {
                ecoResCategory = formDataSource.cursor();
                ecoResCategory.setCategoryStatus(_isActive, _thisCatagoryonly);
                formDataSource.research();
                this.updateTree(idx, _isActive);
                tree.select(idx);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTree</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the tree nodes in the tree control.
    /// </summary>
    /// <param name="_idx">
    /// The item indicating the subtree to be updated. By default the entire tree is updated.
    /// </param>
    /// <param name="_updateAncestors">
    /// A Boolean value that indicates whether to update its ancestors; optional.
    /// </param>
    void updateTree(int _idx = 0, boolean _updateAncestors = false)
    {
        if (EcoResCategoryTreePerformanceContext::isPerformanceContextEnabled())
        {
            return;
        }

        int             idx = _idx;
        FormTreeItem    formTreeItem = tree.getItem(_idx);

        tree.lockWindowUpdate(true);

        if (!_idx || !formTreeItem || !formTreeItem.data())
        {
            idx = tree.getRoot();
            formTreeItem = tree.getItem(idx);
        }

        int selectedIdx = idx;
        EcoResCategory specifiedRecord = EcoResCategory::find(formTreeItem.data());
        EcoResCategory currentRecord = specifiedRecord;

        while (idx &&
                (currentRecord.NestedSetLeft >= specifiedRecord.NestedSetLeft
                    && currentRecord.NestedSetLeft <= specifiedRecord.NestedSetRight) )
        {
            formTreeItem = tree.getItem(idx);
            formTreeItem.overlayImage(this.overlayImage(currentRecord));
            formTreeItem.text(this.itemTextEx(currentRecord.RecId, this.itemDescription(currentRecord),  this.itemFriendlyName(currentRecord), currentRecord.IsActive));
            tree.setItem( formTreeItem );

            idx = tree.getNextVisible(idx);
            if (idx)
            {
                currentRecord = EcoResCategory::find(tree.getItem(idx).data());
            }
        }

        idx = tree.getParent(selectedIdx);
        while (_updateAncestors && idx)
        {
            formTreeItem  = tree.getItem(idx);
            currentRecord = EcoResCategory::find(tree.getItem(idx).data());

            formTreeItem.overlayImage(this.overlayImage(currentRecord));
            formTreeItem.text(this.itemTextEx(currentRecord.RecId, this.itemDescription(currentRecord),  this.itemFriendlyName(currentRecord), currentRecord.IsActive));
            tree.setItem( formTreeItem );
            idx = tree.getParent(idx);
        }

        tree.lockWindowUpdate(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChildrenEcoResCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves all the child Categories of this given Category.
    /// </summary>
    /// <param name="_ecoResParentCategory">
    /// The <c>EcoResCategory</c> record that contains parent category
	/// for which we should return all children.
    /// </param>
    /// <returns>
    /// A record buffer of the <c>EcoResCategory</c> table if children found; otherwise, an empty buffer.
    /// </returns>
    protected EcoResCategory getChildrenEcoResCategory(EcoResCategory _ecoResParentCategory)
    {
        return _ecoResParentCategory.getChildren(false, showActiveNodesOnly, levelLimit);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEcoResCategoryAscendants</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves all the ascendant categories of this given category.
    /// </summary>
    /// <param name="_ecoResCategory">
    /// The <c>EcoResCategory</c> record for which we should return all the ascendants.
    /// </param>
    /// <returns>
    /// A record buffer of the <c>EcoResCategory</c> table if ascendants were found; otherwise, an empty
    /// buffer.
    /// </returns>
    protected EcoResCategory getEcoResCategoryAscendants(EcoResCategory _ecoResCategory)
    {
        return _ecoResCategory.getAscendants();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>