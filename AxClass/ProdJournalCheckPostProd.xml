<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProdJournalCheckPostProd</Name>
	<SourceCode>
		<Declaration><![CDATA[
class ProdJournalCheckPostProd extends ProdJournalCheckPost implements BatchRetryable
{
    // A flag for put-away work creation.
    boolean createPutawayWork;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkCoByTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the posting transaction for co-product or byproduct items.
    /// </summary>
    /// <param name="_journalTransData">
    /// The transaction data.
    /// </param>
    /// <returns>
    /// true if the journal line can be posted; otherwise false.
    /// </returns>
    public boolean checkCoByTrans(JournalTransData     _journalTransData)
    {
        boolean             ok                  = true;
        ProdJournalTable    prodJournalTable    = journalTableData.journalTable();
        ProdJournalProd     prodJournalProd     = _journalTransData.journalTrans();
        InventQty           overDelv;

        PmfProdCoBy prodCoBy = prodJournalProd.pmfProdCoBy();
        if (prodJournalProd.ProdFinished)
        {
            ok = ok && ProdJournalProd::checkNotMissingPosting(prodJournalProd.ProdId, prodJournalProd.JournalId, prodJournalProd.ItemId);
            ok = ok && ProdJournalBOM::checkNotMissingPosting(prodJournalProd.ProdId);
        }

        InventUpd_Physical physical = InventUpd_Physical::pmfNewCheckPostProdJournalCoBy(prodCoBy, prodJournalProd);
        if (!physical.check(prodJournalProd.TransDate))
        {
            ok = false;
        }
        if (!prodJournalTable.AcceptError)
        {
            if (prodJournalProd.QtyGood + prodCoBy.reportedFinishedGood() < 0)
            {
                ok = checkFailed("@SYS16548");
            }
            if (prodJournalProd.QtyError + prodCoBy.reportedFinishedError() < 0)
            {
                ok = checkFailed("@SYS8111");
            }
            if (PdsGlobal::pdsIsCWItem(prodCoBy.ItemId))
            {
                if (prodJournalProd.PdsCWBatchGood + prodCoBy.pdsCWReportedFinishedGood() < 0)
                {
                    ok = checkFailed("@PDS166");
                }
                if (prodJournalProd.PdsCWBatchErr  + prodCoBy.pdsCWReportedFinishedError() < 0)
                {
                    ok = checkFailed("@PDS167");
                }

                if (abs(prodCoBy.QtyCoByStUp) > 0)
                {
                    overDelv = (prodJournalProd.QtyGood    + prodCoBy.reportedFinishedGood()
                             + prodJournalProd.QtyError + prodCoBy.reportedFinishedError()
                             - abs(prodCoBy.QtyCoByStUp)) / abs(prodCoBy.QtyCoByStUp) * 100;
                }

                if (overDelv > PdsCatchWeight::minOverDelivery(prodCoBy.ItemId))
                {
                    ok = checkFailed("@PDS183");
                }
            }
            else
            {
                if (this.coByProductRAFQuantityExceedsStartedQuantity(prodJournalProd, prodCoBy))
                {
                    ok = checkFailed("@SYS16097");
                }
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>coByProductRAFQuantityExceedsStartedQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Compares the sum of co-by product quantities with the started quantity.
    /// The sum consists of goods quantity, reported as finished goods quantity, errors quantity and reported as finished errors quantity.
    /// </summary>
    /// <param name = "_prodJournalProd">Production journal transaction</param>
    /// <param name = "_prodCoBy">Production co-by product</param>
    /// <returns>Returns true if the sum is greater than the started quantity, otherwise false.</returns>
    protected boolean coByProductRAFQuantityExceedsStartedQuantity(ProdJournalProd _prodJournalProd, PmfProdCoBy _prodCoBy)
    {
        return _prodJournalProd.QtyGood + _prodCoBy.reportedFinishedGood()
            + _prodJournalProd.QtyError + _prodCoBy.reportedFinishedError() > _prodCoBy.QtyCoByStUp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournal</Name>
				<Source><![CDATA[
    public boolean checkJournal(JournalTransList _journalTransList)
    {
        boolean ok = this.validatePlaningItemIsReleased(_journalTransList);

        ok = ok && super(_journalTransList);

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProdTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the posting transaction for an end item.
    /// </summary>
    /// <param name="_journalTransData">
    /// The transaction data.
    /// </param>
    /// <returns>
    /// true if the journal line can be posted; otherwise false.
    /// </returns>
    public boolean checkProdTrans(JournalTransData     _journalTransData)
    {
        boolean             ok                  = true;
        ProdJournalTable    prodJournalTable    = journalTableData.journalTable();
        ProdJournalProd     prodJournalProd     = _journalTransData.journalTrans();
        InventQty           overDelv;
        // <GEERU>
        ProdReportedErrorReportedFinished releasedError;
        // </GEERU>

        ProdTable prodTable = prodJournalProd.prodTable();
        if (!prodTable.checkRefProdJournalProd(prodJournalProd))
        {
            return false;
        }
        if (prodJournalProd.ProdFinished)
        {
            ok = ok && ProdJournalProd::checkNotMissingPosting(prodJournalProd.ProdId, prodJournalProd.JournalId, prodJournalProd.ItemId);
            ok = ok && ProdJournalBOM::checkNotMissingPosting(prodJournalProd.ProdId);
        }

        boolean hasRoute = (select firstonly prodRoute where prodRoute.ProdId == prodTable.ProdId).RecId;
        InventUpd_Physical physical = InventUpd_Physical::newCheckPostProdJournalProd(prodTable, prodJournalProd);
        if (!physical.check(prodJournalProd.TransDate))
        {
            ok = false;
        }
        if (! prodJournalTable.AcceptError)
        {
            // <GEERU>
            if (countryRegion_RU)
            {
                releasedError = prodTable.releasedError_RU();
            }
            // </GEERU>
            if (prodJournalProd.QtyGood+ prodTable.reportedFinishedGood() < 0)
            {
                ok = checkFailed("@SYS16548");
            }
            if (prodJournalProd.QtyError+ prodTable.reportedFinishedError() < 0)
            {
                ok = checkFailed("@SYS8111");
            }
            if (PdsGlobal::pdsIsCWItem(prodJournalProd.prodTable().ItemId))
            {
                if (prodJournalProd.PdsCWBatchGood + prodTable.pdsCWReportedFinishedGood() < 0)
                {
                    ok = checkFailed("@PDS166");
                }
                if (prodJournalProd.PdsCWBatchErr + prodTable.pdsCWReportedFinishedErr() < 0)
                {
                    ok = checkFailed("@PDS167");
                }

                if (abs(prodTable.QtyStUp) > 0)
                {
                    overDelv = (prodJournalProd.QtyGood + prodTable.reportedFinishedGood()
                            + prodJournalProd.QtyError + prodTable.reportedFinishedError()
                            - abs(prodTable.QtyStUp)) / abs(prodTable.QtyStUp) *100;
                }

                if (overDelv > PdsCatchWeight::minOverDelivery(prodTable.ItemId))
                {
                    ok = checkFailed("@PDS183");
                }
            }
            else
            {
                // <GEERU>
                if (this.endItemRAFQuantityExceedsStartedQuantity(prodJournalProd, prodTable, releasedError))
                {
                    ok = checkFailed("@SYS16097");
                }
                // </GEERU>
            }
            if (prodJournalProd.ProdFinished)
            {
                if ((!prodJournalProd.ProdPickList && !ProdBOM::checkIsItemsReleased(prodTable.ProdId))
                    || (hasRoute && !ProdRoute::checkIsRouteReportedFinished(prodTable.ProdId)))
                {
                    ok = false;
                }
                if (prodTable.RouteJobs && !ProdRouteJob::checkIsJobsReportedFinished(prodTable.ProdId))
                {
                    ok = false;
                }
                if (hasRoute)
                {
                    if (prodTable.ProdType != ProdType::Process)
                    {
                        boolean prodMultiLineRAF = FeatureStateProvider::isFeatureEnabled(ProdMultiLineReportAsFinishSerialNumFeature::instance());

                        if (prodMultiLineRAF && InventTable::find(prodTable.ItemId).isItemSerialNumberActivated())
                        {
                            ProdReportedGood  journalQtyGood;
                            ProdReportedError journalQtyError;
                            [journalQtyGood, journalQtyError] = ProdJournalProd::sumQtyGoodQtyErrorFromProdJournal(prodJournalProd.ProdId, prodJournalProd.JournalId);
                            ok = this.checkMismatchReportedQuantity(journalQtyGood, journalQtyError, prodJournalProd, prodTable, releasedError) && ok;
                        }
                        else
                        {
                            ok = this.checkMismatchReportedQuantity(prodJournalProd.QtyGood, prodJournalProd.QtyError, prodJournalProd,  prodTable, releasedError) && ok;
                        }
                    }
                }
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>endItemRAFQuantityExceedsStartedQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Compares the sum of the end item quantities with the started quantity.
    /// The sum consists of goods quantity, reported as finished goods quantity, errors quantity, reported as finished errors quantity and released errors quantity.
    /// </summary>
    /// <param name = "_prodJournalProd">Production journal transaction</param>
    /// <param name = "_prodTable">Production order</param>
    /// <param name = "_releasedError">Released error quantity</param>
    /// <returns>True if the sum is greater than the started quantity, otherwise false.</returns>
    protected boolean endItemRAFQuantityExceedsStartedQuantity(ProdJournalProd _prodJournalProd, ProdTable _prodTable, ProdReportedErrorReportedFinished _releasedError)
    {
        return _prodJournalProd.QtyGood  + _prodTable.reportedFinishedGood()
             + _prodJournalProd.QtyError + _prodTable.reportedFinishedError() + _releasedError > _prodTable.QtyStUp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkMismatchReportedQuantity</Name>
				<Source><![CDATA[
    private boolean checkMismatchReportedQuantity(ProdReportedGood                  _prodReportedGood, 
                                                  ProdReportedError                 _prodReportedError,
                                                  ProdJournalProd                   _prodJournalProd,
                                                  ProdTable                         _prodTable,
                                                  ProdReportedErrorReportedFinished _releasedError)
    {
        if (_prodReportedGood + _prodTable.reportedFinishedGood() != _prodTable.routeReportedGood())
        {
            return checkFailed(strFmt("@SYS3976",  _prodJournalProd.QtyGood + _prodTable.reportedFinishedGood())
                                + '\n' + strFmt("@SYS13528",  _prodTable.routeReportedGood()));
        }
        // <GEERU>
        if (_prodReportedError + _prodTable.reportedFinishedError() + _releasedError != _prodTable.routeReportedError())
        {
            return checkFailed(strfmt("@SYS5774",_prodJournalProd.QtyError+ _prodTable.reportedFinishedError() + _releasedError) + '\n' +
                                             strfmt("@SYS13528",_prodTable.routeReportedError()));
        }
        // </GEERU>

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFollowingPmfCoByProcess</Name>
				<Source><![CDATA[
    protected boolean isFollowingPmfCoByProcess(ProdJournalProd _prodJournalProd)
    {
        return _prodJournalProd.isFollowingPmfCoByProcess();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTrans</Name>
				<Source><![CDATA[
    boolean checkTrans(JournalTransData     _journalTransData)
    {
        ProdJournalProd     prodJournalProd     = _journalTransData.journalTrans();
        boolean             ok                  = true;

        setPrefix(fieldLabelValue(prodJournalProd.TableId, fieldNum(ProdJournalProd,ProdId), prodJournalProd.ProdId));

        if (! super(_journalTransData))
        {
            return false;
        }

        if (this.isFollowingPmfCoByProcess(prodJournalProd))
        {
            ok = this.checkCoByTrans(_journalTransData);
        }
        else
        {
            ok = this.checkProdTrans(_journalTransData);
        }

        //
        // the SYS code has been moved to <c>checkProdTrans</c>
        //

        // <GEERU>
        if (countryRegion_RU && ok)
        {
            ProdTable prodTable = prodJournalProd.prodTable();
            if (prodTable.useReleaseFromProduction_RU())
            {
                if (prodJournalProd.QtyError && ! prodJournalProd.ReleaseKindId_RU)
                {
                    ok = checkFailed("@GLS115786");
                }

                if (!prodJournalProd.QtyError && prodJournalProd.ReleaseKindId_RU)
                {
                    ok = checkFailed(strFmt("@GLS115764", prodJournalProd.ReleaseKindId_RU));
                }
            }
        }
        // </GEERU>

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProdOrderSetWithFinishedJobs</Name>
				<Source><![CDATA[
    private Set getProdOrderSetWithFinishedJobs(JournalTransList _journalTransList)
    {
        Set prodTableSet = new Set(Types::String);
        Set prodSetIgnore = new Set(Types::String);

        while (_journalTransList.next())
        {
            JournalTransData journalTransData = _journalTransList.journalTransData();
            ProdJournalProd prodJournalProd = journalTransData.journalTrans();

            if (!prodSetIgnore.in(prodJournalProd.ProdId))
            {
                if (!prodJournalProd.ProdFinished)
                {
                    prodTableSet.remove(prodJournalProd.ProdId);
                    prodSetIgnore.add(prodJournalProd.ProdId);
                }
                else
                {
                    prodTableSet.add(prodJournalProd.ProdId);
                }
            }
        }
        _journalTransList.reset();
        return prodTableSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckExistJournalRelease_RU</Name>
				<Source><![CDATA[
    public NoYes mustCheckExistJournalRelease_RU()
    {
        return NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetRemainingInventPhysicalForProductionOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets the remaining inventory physical quantities for a production order.
    /// </summary>
    /// <param name = "_prodTable">The production order</param>    
    protected void resetRemainingInventPhysicalForProductionOrder(ProdTable _prodTable)
    {
        _prodTable.RemainInventPhysical      = 0;
        _prodTable.PdsCWRemainInventPhysical = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetRemainingInventPhysicalForCoByProduction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets the remaining inventory physical quantities for a co-by production.
    /// </summary>
    /// <param name = "_prodCoBy">The co-by production.</param>
    protected void resetRemainingInventPhysicalForCoByProduction(PmfProdCoBy _prodCoBy)
    {
        _prodCoBy.RemainCoByPhysical     = 0;
        _prodCoBy.PdsCWRemainPhysical    = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useInventDimFromMovementWhenUpdatingPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the inventory dimensions from the invent movement should be used for the physical update.
    /// </summary>
    /// <param name = "_prodJournalProd">The production journal.</param>
    /// <returns>true if the inventory dimension should be use; otherwise, false.</returns>
    protected boolean useInventDimFromMovementWhenUpdatingPhysical(ProdJournalProd _prodJournalProd)
    {
        return ((_prodJournalProd.QtyGood < 0 && _prodJournalProd.QtyError == 0)
            || (_prodJournalProd.QtyGood == 0 && _prodJournalProd.QtyError < 0));
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTransLedger</Name>
				<Source><![CDATA[
    void postTransLedger(
        JournalTransData    _journalTransData,
        LedgerVoucher       _ledgerVoucher)
    {
        InventUpd_Physical          physical;
        ProdTable                   prodTable;

        ProdJournalTable            prodJournalTableBOM;

        PmfProdCoBy                 prodCoBy;
        boolean                     cwItem;

        ProdJournalTable prodJournalTable = journalTableData.journalTable();
        ProdJournalProd prodJournalProd = _journalTransData.journalTrans();

        setPrefix(fieldLabelValue(prodJournalProd.TableId, fieldNum(ProdJournalProd, ProdId), prodJournalProd.ProdId));

        setPrefix(fieldLabelValue(prodJournalProd.TableId, fieldNum(ProdJournalProd, ItemId), prodJournalProd.ItemId));

        if (this.isFollowingPmfCoByProcess(prodJournalProd))
        {
            prodCoBy = prodJournalProd.pmfProdCoBy(true);
            cwItem = PdsGlobal::pdsIsCWItem(prodCoBy.ItemId);
        }
        else
        {
            prodTable = prodJournalProd.prodTable(true);
            cwItem = PdsGlobal::pdsIsCWItem(prodTable.ItemId);
        }

        super(_journalTransData, _ledgerVoucher);

        if (InventReportDimHistory::canCreateHistory(prodJournalProd))
        {
            InventReportDimHistory::addFromProdJournalProd(prodJournalProd);
        }

        if (prodCoBy)
        {
            physical = InventUpd_Physical::pmfNewCheckPostProdJournalCoBy(prodCoBy, prodJournalProd);
        }
        else
        {
            physical = InventUpd_Physical::newCheckPostProdJournalProd(prodTable, prodJournalProd);
        }
        InventMovement inventMovement = physical.movement();
        boolean useInventDimFromMovementWhenUpdatingPhysical = !cwItem && !prodCoBy && this.useInventDimFromMovementWhenUpdatingPhysical(prodJournalProd);

        InventDimId inventDimIDProd;
        if (useInventDimFromMovementWhenUpdatingPhysical)
        {
            inventDimIDProd         = prodTable.InventDimId;
            prodTable.InventDimId   = inventMovement.inventDimId();
            prodTable.doUpdate();
        }

        physical.updateNow(_ledgerVoucher);

        if (useInventDimFromMovementWhenUpdatingPhysical)
        {
            prodTable.InventDimId = inventDimIDProd;
            prodTable.doUpdate();
        }

        if (prodTable)
        {
            if (prodJournalProd.ProdFinished)
            {
                this.updateNoneShortage(prodTable,prodJournalProd);
            }

            // Reread the production order record as this might have been updated in the previous calls
            prodTable.reread();

            if (prodJournalProd.ProdFinished
                && prodTable.ProdType != ProdType::Process
            )
            {
                if (prodTable.status().isBefore(ProdStatus::ReportedFinished))
                {
                    prodTable.ProdStatus = ProdStatus::ReportedFinished;
                }

                prodTable.FinishedDate = prodJournalProd.TransDate;
            }
        }

        if (prodTable
            && (   (cwItem && !prodTable.PdsCWRemainInventPhysical)
                || (prodJournalProd.ProdFinished && prodTable.RemainInventPhysical)))
        {
            this.resetRemainingInventPhysicalForProductionOrder(prodTable);
        }
        else if (prodCoBy
            && (   (cwItem && !prodCoBy.PdsCWRemainPhysical)
                || (prodJournalProd.ProdFinished && prodCoBy.RemainCoByPhysical)))
        {
            this.resetRemainingInventPhysicalForCoByProduction(prodCoBy);
        }

        using (InventQualityOrderPhysicalVoucherContext context = InventQualityOrderPhysicalVoucherContext::construct())
        {
            context.parmPhysicalVoucherForBlocking(_ledgerVoucher.lastVoucher());
            context.parmInventDim(prodJournalProd.InventDim());
            if (prodTable)
            {
                this.createQualityOrderAfterProductionReportFinished(prodTable, prodJournalProd);
                prodTable.update();
            }
            else if (this.mustCreateQualityOrderForCoByProduct(prodCoBy))
            {
                InventQualityManagementCreateHandler::createProductionReportFinishedCo(prodJournalProd, InventTestExecution::After);
                prodCoBy.update();
            }
        }

        if (this.mustProcessPickingList(prodJournalProd, prodTable))
        {
            if (!cacheProdJournalTableBOM)
            {
                cacheProdJournalTableBOM = this.initCacheProdJournalTableBOM();
            }

            if (!prodJournalProd.ProdPickListJournalId)
            {
                prodJournalTableBOM = ProdJournalTable::findWaitCreateLine(prodJournalProd.ProdId, ProdJournalType::Picklist, prodJournalProd.ProdFinished, 0, true);

                if (mapJournalDate && prodJournalTableBOM.RecId)
                {
                    while (prodJournalTableBOM.RecId && mapJournalDate.exists(prodJournalTableBOM.JournalId))
                    {
                        if (mapJournalDate.lookup(prodJournalTableBOM.JournalId) == prodJournalProd.TransDate)
                        {
                            break;
                        }
                        else
                        {
                            next prodJournalTableBOM;
                        }
                    }
                }

                if (! prodJournalTableBOM.RecId)
                {
                    prodJournalTableBOM.initWaitCreateLine(prodJournalTable.JournalNameIdPickList, prodJournalProd.ProdId, ProdJournalType::Picklist, prodJournalProd.ProdFinished, 0);
                }

                prodJournalTableBOM.addQtyFromJournalTransaction(prodJournalProd);

                prodJournalTableBOM.write();

                cacheProdJournalTableBOM.ins(prodJournalTableBOM, true);

                if (!mapJournalDate)
                {
                    mapJournalDate = new Map(typeOf(prodJournalTableBOM.JournalId), typeOf(prodJournalProd.TransDate));
                }

                if (!mapJournalDate.exists(prodJournalTableBOM.JournalId))
                {
                    mapJournalDate.insert(prodJournalTableBOM.JournalId, prodJournalProd.TransDate);
                }

                prodJournalProd.ProdPickListJournalId = prodJournalTableBOM.JournalId;
                prodJournalProd.doUpdate();
            }
            else
            {
                prodJournalTableBOM = ProdJournalTable::find(prodJournalProd.ProdPickListJournalId, true);
                if (prodJournalTableBOM.RecId && ! prodJournalTableBOM.Posted)
                {
                    cacheProdJournalTableBOM.ins(prodJournalTableBOM);
                }
            }
        }

        costAmountPhysical  += physical.updPhysicalAmountLedger();
        if (prodJournalProd.PmfProductType      != PmfProductType::By_Product
            && prodJournalProd.PmfProductType   != PmfProductType::Co_Product)
        {
            cwQtyGood           += prodJournalProd.PdsCWBatchGood;
            cwQtyError          += prodJournalProd.PdsCWBatchErr;
            qtyGood             += prodJournalProd.QtyGood;
            qtyError            += prodJournalProd.QtyError;

            if (!inventCostProdIndirect || inventCostProdIndirect.parmVoucher() != _ledgerVoucher.lastVoucher())
            {
                inventCostProdIndirect = InventCostProdIndirect::newFromLedgerVoucher(_ledgerVoucher);
            }

            this.addInventCostProdIndirectRelation(_journalTransData, inventCostProdIndirect);

            InventTrans inventTrans = InventTrans::findTransId(prodTable.InventTransId);

            // Check whether the InventTrans still exists
            if (inventTrans)
            {
                inventCostProdIndirect.calcInvent(
                    InventCostProdIndirectData_Invent::newFinishedFromInventTrans(inventTrans,
                        prodJournalProd.QtyGood,
                        prodTable.CollectRefLevel,
                        inventMovement.mustBeBookedPhysically()));
            }
        }

        if (prodJournalProd.PmfProductType == PmfProductType::By_Product)
        {
            this.postBurdenRouteCard(prodJournalProd);

            this.updateRecycledByproductConsumptions(prodJournalProd);
        }

        if (prodJournalProd.PDSBaseValue)
        {
            InventTable inventTable = inventTable::find(prodJournalProd.ItemId);
            if (inventTable.PDSBaseAttributeId
                && inventTable.PDSPotencyAttribRecording == PDSPotencyAttribRecordingEnum::PurchProdReceipt)
            {
                InventDim inventDim = inventDim::find(prodJournalProd.InventDimId);
                if (inventDim.InventBatchId)
                {
                    InventBatch inventBatch = InventBatch::find(inventDim.InventBatchId, prodJournalProd.ItemId);
                    inventBatch.pdsCreateAttribute(prodJournalProd.PDSBaseValue);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createQualityOrderAfterProductionReportFinished</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a quality order after production order is reported as finished 
    /// </summary>
    /// <param name = "_prodTable">A production order.</param>
    /// <param name = "_prodJournalProd">A production reported as finished journal line</param>
    protected void createQualityOrderAfterProductionReportFinished(ProdTable _prodTable, ProdJournalProd _prodJournalProd)
    {
        if (_prodJournalProd.QtyGood || _prodJournalProd.PdsCWBatchGood)
        {
            InventQualityManagementBlockHandler::blockProductionReportFinished(_prodTable);
            InventQualityManagementCreateHandler::createProductionReportFinishedAfter(_prodTable,
                    _prodJournalProd.QtyGood,
                    _prodJournalProd.PdsCWBatchGood);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreateQualityOrderForCoByProduct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a quality order must be created for a production co-by product.
    /// </summary>
    /// <param name = "_prodCoBy">A production co-by product.</param>
    /// <returns>true if a quality order must be created; otherwise, false.</returns>
    protected boolean mustCreateQualityOrderForCoByProduct(PmfProdCoBy _prodCoBy)
    {
        return _prodCoBy.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustProcessPickingList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether picking list must be processed.
    /// </summary>
    /// <param name = "_prodJournalProd">A production journal transaction.</param>
    /// <param name = "_prodTable">A production order.</param>
    /// <returns>true if the picking list must be processed; otherwise, false.</returns>
    protected boolean mustProcessPickingList(ProdJournalProd _prodJournalProd, ProdTable _prodTable)
    {
        return _prodJournalProd.ProdPickList && _prodTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the list of journal transactions related to <c>PmfProdCoby</c> records.
    /// </summary>
    /// <param name="_journalTransList">
    /// A list of journal transactions.
    /// </param>
    public void postVoucher(JournalTransList _journalTransList)
    {
        ProdJournalProd         prodJournalProd;
        boolean                 prodFinished = false;

        super(_journalTransList);

        if (_journalTransList.first())
        {
            ProdJournalTransData prodJournalTransData = _journalTransList.journalTransData();
            ProdJournalTable prodJournalTable = prodJournalTransData.journalTableData().journalTable();

            ProdTable prodTable = ProdTable::find(prodJournalTransData.prodId());
            ProdTableJour prodTableJour = this.initProdTableJour(prodJournalTransData,prodTable);
            boolean isEnableTrackedComponentsEnabled = BOMParameters::find().EnableTrackedComponents;

            do
            {
                prodJournalProd = _journalTransList.item();

                if (this.isFollowingPmfCoByProcess(prodJournalProd))
                {
                    prodTableJour.JournalType = ProdJourType::Receipt;

                    prodTableJour.QtyError    = prodJournalProd.QtyError;
                    prodTableJour.QtyGood     = prodJournalProd.QtyGood;

                    prodTableJour.PdsCWBatchGood    = prodJournalProd.PdsCWBatchGood;
                    prodTableJour.PdsCWBatchErr     = prodJournalProd.PdsCWBatchErr;

                    prodTableJour.ItemId        = prodJournalProd.ItemId;
                    prodTableJour.InventTransId = prodJournalProd.InventTransId;
                    prodTableJour.QtyGood       = prodJournalProd.QtyGood;
                    prodTableJour.QtyError      = prodJournalProd.QtyError;
                    prodTableJour.insert();
                }

                prodFinished = prodFinished || prodJournalProd.ProdFinished;

                if (isEnableTrackedComponentsEnabled)
                {
                    // manually created RAF journal lines with pre-created product LOT associations => update journal references.
                    ProdAsBuiltBOMProductLotAssociation::updateRecordsetFromReportFinishedLine(prodJournalProd);
                }
            }
            while (_journalTransList.next());

            if (prodTable.ProdType == ProdType::Process
                && prodTable.status().isBefore(ProdStatus::ReportedFinished)
                && (prodFinished
                    || (prodTable.inventTable().PmfProductType == PmfProductType::MainItem
                        && !FeatureStateProvider::isFeatureEnabled(ProdPlanningItemAutoReportAsFinishedToggle::instance()))))
            {
                PmfProdCoBy coBy;

                select firstonly TableId from coBy
                    where coBy.ProdId               == prodTable.ProdId
                        && coBy.RemainCoByPhysical  > 0;

                if (!coBy)
                {
                    if (prodTable.prodParametersDim().DeleteCapReservReportFinish)
                    {
                        WrkCtrCapResHandler::construct().deleteOrderReservations(WrkCtrCapRefType::Production, prodTable.ProdId);
                    }

                    ProdRoute::reportOprAsFinished(prodTable.ProdId);
                    ProdRouteJob::reportJobAsFinished(prodTable.ProdId);
                    if (prodJournalTable.ProdAutoPickList)
                    {
                        ProdBOM::updateNonePhysicalRemain(prodTable.ProdId);
                        prodTable.reread();
                    }

                    ttsbegin;
                    prodTable.selectForUpdate(true);
                    prodTable.ProdStatus = ProdStatus::ReportedFinished;
                    prodTable.FinishedDate = prodJournalProd.TransDate;
                    prodTable.update();
                    ttscommit;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>prefix</Name>
				<Source><![CDATA[
    str prefix()
    {
        if (journalCheckPostType == JournalCheckPostType::Check)
        {
            return "@SYS28450" + ' - ' + "@SYS26712";
        }
        return "@SYS5943" + ' - ' + "@SYS26712";
    }

]]></Source>
			</Method>
			<Method>
				<Name>preRun</Name>
				<Source><![CDATA[
    protected void preRun()
    {
        this.createQualityOrderBeforePostRAF(this.parmJournalId());
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    void run()
    {
        super();
        this.postProdJournalTableBOM();

        if (createPutawayWork)
        {           
            ttsbegin;

            this.createPutWork();

            ttscommit;

        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferErrorJournalLine</Name>
				<Source><![CDATA[
    protected void transferErrorJournalLine(
        JournalTransMap     _journalTrans,
        JournalTableData    _toJournalTableData,
        JournalTableMap     _toJournalTable)
    {
        ProdJournalProd     prodJournalProd = _journalTrans;

        if (prodJournalProd.InventTransId)
        {
            InventTransOrigin::changeReferenceId(InventTransOrigin::findByInventTransId(prodJournalProd.InventTransId).RecId, prodJournalProd.ProdId);
        }

        super(_journalTrans, _toJournalTableData, _toJournalTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNoneShortage</Name>
				<Source><![CDATA[
    public void updateNoneShortage(ProdTable       _prodTable,
                                   ProdJournalProd _prodJournalProd)
    {
        if (_prodTable.prodParametersDim().DeleteCapReservReportFinish)
        {
            WrkCtrCapResHandler::construct().deleteOrderReservations(WrkCtrCapRefType::Production, _prodTable.ProdId);
        }

        ProdRoute::reportOprAsFinished(_prodTable.ProdId);
        ProdRouteJob::reportJobAsFinished(_prodTable.ProdId);

        // Clean up remaining inventory that is not being consumed
        if (!_prodJournalProd.ProdPickList)
        {
            ProdBOM::updateNonePhysicalRemain(_prodTable.ProdId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePlaningItemIsReleased</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that production order for planning item is completely released.
    /// </summary>
    /// <param name="_journalTransList">
    /// List of transactions.
    /// </param>
    /// <returns>
    /// true - if production order release, false - otherwise
    /// </returns>
    private boolean validatePlaningItemIsReleased(JournalTransList _journalTransList)
    {
        boolean ok = true;

        ProdJournalTable prodJournalTable = journalTableData.journalTable();

        if (!prodJournalTable.AcceptError || !ProdJourCheckPostAcceptErrorFlight::instance().isEnabled())
        {
            Set prodTableSet = this.getProdOrderSetWithFinishedJobs(_journalTransList);

            _journalTransList.reset();
            while (_journalTransList.next())
            {
                JournalTransData journalTransData = _journalTransList.journalTransData();
                ProdJournalProd prodJournalProd = journalTransData.journalTrans();

                ProdTable prodTable = prodJournalProd.prodTable();
                if (prodTable.inventTable().PmfProductType == PmfProductType::MainItem && prodTableSet.in(prodTable.ProdId))
                {
                    boolean hasRoute = ProdRoute::findFirst(prodTable.ProdId).RecId;

                    if ((!prodJournalProd.ProdPickList && !ProdBOM::checkIsItemsReleased(prodTable.ProdId))
                    || (hasRoute && !ProdRoute::checkIsRouteReportedFinished(prodTable.ProdId)))
                    {
                        ok = false;
                        prodTableSet.remove(prodTable.ProdId);
                    }
                }
            }
        }

        _journalTransList.reset();

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS26712";
    }

]]></Source>
			</Method>
			<Method>
				<Name>newJournalCheckPost</Name>
				<Source><![CDATA[
    static ProdJournalCheckPostProd newJournalCheckPost(
        boolean                 _autoBlock,
        boolean                 _showInfoResult,
        JournalCheckPostType    _journalCheckPostType,
        tableId                 _tableId,
        JournalId               _journalId,
        boolean                 _createPutawayWork = false)
    {
        ProdJournalCheckPostProd journalCheckPost = new ProdJournalCheckPostProd();

        journalCheckPost.getLast();
        journalCheckPost.parmAutoBlock(_autoBlock);
        journalCheckPost.parmShowInfoResult(_showInfoResult);
        journalCheckPost.parmJournalCheckPostType(_journalCheckPostType);
        journalCheckPost.parmJournalTableId(_tableId);
        journalCheckPost.parmJournalId(_journalId);
        journalCheckPost.parmThrowCheckFailed(false);
        journalCheckPost.parmCreatePutawayWork(_createPutawayWork);

        return journalCheckPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPostJournal</Name>
				<Source><![CDATA[
    static ProdJournalCheckPostProd newPostJournal(
        ProdJournalId   _prodJournalId,
        boolean         _showInfoResult)
    {
        ProdJournalCheckPostProd journalCheckPost = new ProdJournalCheckPostProd();
        journalCheckPost.getLast();
        journalCheckPost.parmAutoBlock(true);
        journalCheckPost.parmShowInfoResult(_showInfoResult);
        journalCheckPost.parmJournalCheckPostType(JournalCheckPostType::Post);
        journalCheckPost.parmJournalTableId(tableNum(ProdJournalTable));
        journalCheckPost.parmJournalId(_prodJournalId);
        journalCheckPost.parmVoucher('');
        journalCheckPost.parmThrowCheckFailed(true);
        return journalCheckPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPutWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates Put-away work for the items in the Journal.
    /// </summary>
    /// <remarks>
    /// Work is created only for items that are enabled for advanced warehouse processes and
    /// have Good Quantity > 0, and if the journal is not posted
    /// </remarks>
    public void createPutWork()
    {        
        if (this.mustUseWhsWorkCreateProdPutMixedLPForPutawayWork())
        {
            this.createPutWorkUsingWhsWorkCreateProdPutMixedLP();
        }
        else
        {
            ProdJournalTable     prodJournalTable;
            ProdJournalProd      rafJournalLine;
            WHSInventTable       whsInventTable;
            InventDim            inventDim;
            Inventlocation       inventLocation;

            while select rafJournalLine
            where rafJournalLine.JournalId == journalId
               && rafJournalLine.QtyGood    > 0
            exists join prodJournalTable
                where prodJournalTable.JournalId == journalId
                   && prodJournalTable.Posted
                exists join InventDim
                    where inventDim.inventDimId == rafJournalLine.InventDimId
                    exists join inventLocation
                        where inventLocation.InventLocationId == inventDim.InventLocationId
                            && inventLocation.WHSEnabled
                        exists join whsInventTable
                            where whsInventTable.ItemId == rafJournalLine.ItemId
            {
                this.doCreatePutWork(rafJournalLine);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUseWhsWorkCreateProdPutMixedLPForPutawayWork</Name>
				<Source><![CDATA[
    private boolean mustUseWhsWorkCreateProdPutMixedLPForPutawayWork()
    {
        return WHSUseMixedLPPutawayForProductionRAFContext::current() != null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPutWorkUsingWhsWorkCreateProdPutMixedLP</Name>
				<Source><![CDATA[
    private void createPutWorkUsingWhsWorkCreateProdPutMixedLP()
    {
        ProdJournalTable            prodJournalTable;
        ProdJournalProd             rafJournalLine;
        WHSInventTable              whsInventTable;
        InventDim                   inventDim;
        Inventlocation              inventLocation;
        WHSLicensePlateId           lastLicensePlateId;
        WhsWorkCreateProdPutMixedLP whsWorkCreateProdPutMixedLP;

        // Loop over RAF journal lines and call WhsWorkCreateProdPutMixedLP grouped by LicensePlateId. Therefore, order by InventDim.LicensePlateId.
        while select rafJournalLine
            order by InventDim.LicensePlateId asc
            where rafJournalLine.JournalId == journalId
                && rafJournalLine.QtyGood    > 0
            join LicensePlateId from InventDim
                where inventDim.inventDimId == rafJournalLine.InventDimId
                exists join inventLocation
                    where inventLocation.InventLocationId == inventDim.InventLocationId
                        && inventLocation.WHSEnabled
                    exists join whsInventTable
                        where whsInventTable.ItemId == rafJournalLine.ItemId
            exists join prodJournalTable
                where prodJournalTable.JournalId == journalId
                    && prodJournalTable.Posted
        {
            if (!inventDim.LicensePlateId)
            {
                // Fallback to WHSWorkCreateProdPut if no LP
                this.doCreatePutWork(rafJournalLine);
                continue;
            }

            if (inventDim.LicensePlateId != lastLicensePlateId)
            {
                lastLicensePlateId = inventDim.LicensePlateId;

                if (whsWorkCreateProdPutMixedLP)
                {
                    WHSWorkTable::autoExecuteWorkInWorkBuildId(whsWorkCreateProdPutMixedLP.createWork());
                }

                whsWorkCreateProdPutMixedLP = WhsWorkCreateProdPutMixedLP::construct(rafJournalLine);
            }

            whsWorkCreateProdPutMixedLP.addRAFJournalLine(rafJournalLine);
        }

        if (whsWorkCreateProdPutMixedLP)
        {
            WHSWorkTable::autoExecuteWorkInWorkBuildId(whsWorkCreateProdPutMixedLP.createWork());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>doCreatePutWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates work for a RAF Journal line.
    /// </summary>
    /// <param name="_rafJournalLine">
    /// RAF Journal line for which work should be created.
    /// </param>
    protected void doCreatePutWork(ProdJournalProd _rafJournalLine)
    {
        WHSWorkCreateProdPut workCreateProdPut = new WHSWorkCreateProdPut(ProdTable::find(_rafJournalLine.ProdId));
        WHSWorkTable::autoExecuteWorkInWorkBuildId(workCreateProdPut.createWorkFromRAFJournalLine(_rafJournalLine));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCreatePutawayWork</Name>
				<Source><![CDATA[
    public boolean parmCreatePutawayWork(boolean _createPutAwayWork = createPutAwayWork)
    {
        createPutAwayWork = _createPutAwayWork;
        return createPutAwayWork;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postBurdenRouteCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the burden route card.
    /// </summary>
    /// <param name="_prodJournalProd">
    /// The <c>ProdJournalProd</c> record.
    /// </param>
    private void postBurdenRouteCard(ProdJournalProd _prodJournalProd)
    {
        ProdTable prodTable = _prodJournalProd.prodTable(false);
        PmfProdCoBy prodCoBy = _prodJournalProd.pmfProdCoBy(false);

        PmfBurdenProdRouteCardPost pmfBurdenProdRouteCardPost = PmfBurdenProdRouteCardPost::newFromProdTable(prodTable);
        pmfBurdenProdRouteCardPost.parmByProduct(prodCoBy);
        pmfBurdenProdRouteCardPost.parmTransDate(_prodJournalProd.TransDate);

        pmfBurdenProdRouteCardPost.post();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRecycledByproductConsumptions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates realized amounts for a recycled byproduct.
    /// </summary>
    /// <param name="_prodJournalProd">
    /// The <c>ProdJournalProd</c> record.
    /// </param>
    private void updateRecycledByproductConsumptions(ProdJournalProd _prodJournalProd)
    {
        ProdBOM                                 prodBOM;
        InventDim                               inventDim;
        InventDimParm                           inventDimParm;

        inventDimParm.setAllProductDimensions();

        if (_prodJournalProd.pmfProdCoBy() &&
            _prodJournalProd.pmfProdCoBy().ProductType == PmfProductType::By_Product &&
            _prodJournalProd.pmfProdCoBy().BurdenType  == PmfBurdenType::Recycled)
        {
            while select prodBOM
            where prodBOM.ProdId == _prodJournalProd.ProdId
               && prodBOM.ItemId == _prodJournalProd.ItemId
            #inventDimExistsJoin(prodBom.inventDimId, inventDim, _prodJournalProd.inventDim(), inventDimParm)
            {
                ProdCalcTrans::updateRealCalcBOM(_prodJournalProd.prodTable(), prodBOM);
                PmfCoByProdCalcTrans::updateRealCalcBOM(_prodJournalProd.prodTable(), prodBOM);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    final boolean isRetryable() 
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJournalTablePosted</Name>
				<Source><![CDATA[
    protected void updateJournalTablePosted(JournalTableMap _journalTable)
    {
        super(_journalTable);

        if (BOMParameters::find().EnableTrackedComponents)
        {
            ProdJournalTable journalHeader  = ProdJournalTable::find(_journalTable.JournalId);            
            if (journalHeader.JournalType != ProdJournalType::ReportFinished)
            {
                return;
            }

            ProdAsBuiltBOMProductLotAssociation::complete(journalHeader.ProdId, journalHeader.JournalId);

            if (FeatureStateProvider::isFeatureEnabled(SCTTracingActivityFeature::instance()))
            {
                SCTTracingActivityBuilder_ProdReportFinished::createTracingActivity(journalHeader);
            }
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>