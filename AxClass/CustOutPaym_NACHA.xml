<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustOutPaym_NACHA</Name>
	<SourceCode>
		<Declaration><![CDATA[
class CustOutPaym_NACHA extends CustOutPaym
{
    #define.FileFormatLen(3)

    Counter             recCount;               // Count of All Records in this EFT - needed when computing the Block Count in the Control Record
    Counter             numTransactions;        // Number of Transaction Records

    AmountCur           totalDebitAmount;
    AmountCur           totalCreditAmount;

    real                routingHash;            // Hash value used to verify data against alteration
    str #FileFormatLen  fileFormat;             // "CCD", "CTX" or "PPD"
    int                 sequenceNumber;         // Used to generate the Trace Number on the payment records
    int                 numberOfBlockLines;

    BankAccountTable    bankAccountTable;

    DialogField         dialogEffectiveEntryDate;
    date                effectiveEntDate;

    #ISOCountryRegionCodes
    #define.HashEntryMaximum(10000000000)
    #define.DebugNACHA(False)
    #define.NACHARecLen(94)
    #define.NACHABlockSize(940)

    #DEFINE.SysLastValuesCurrentVersion(1)
    #localmacro.SysLastValuesList
        effectiveEntDate,
        recCount,
        numTransactions,
        routingHash,
        fileFormat,
        sequenceNumber
    #endmacro

    #DEFINE.CurrentVersion(5)
    #LOCALMACRO.CurrentList
        effectiveEntDate,
        recCount,
        numTransactions,
        routingHash,
        fileFormat,
        sequenceNumber
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmNumberOfBlockLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// The number of filler block lines.
    /// </summary>
    /// <returns>
    /// The number of filler block lines.
    /// </returns>
    public int parmNumberOfBlockLines()
    {
        return numberOfBlockLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addACHControlFieldPositions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes field alignment information to the output file to help verify the data.
    /// </summary>
    /// <remarks>
    ///    Alignment information can be turned on for NACHA by setting the <c>DebugNACHA</c> macro in the
    ///    <c>CustOutPaym_NACHA</c> class declaration to true.This is a debug
    ///    method.ABBBBBBCCCCCCDDDDDDDDEEEEEEEEEEFFFFFFFFFFFFGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH - ACH CONTROL RECORD HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH - Reserved = &lt;BLANK&gt;
    ///    GGGGGGGGGGGG - Total Credit Amount FFFFFFFFFFFF - Total Debit Amount EEEEEEEEEE - Entry Hash
    ///    DDDDDDDD - Entry/Addenda Count CCCCCC - Block Count BBBBBB - Batch Count = "000001"A - Record Type
    ///    Code = "9"
    /// </remarks>
    protected void addACHControlFieldPositions()
    {
        #define.ACHCRecord          ('ABBBBBBCCCCCCDDDDDDDDEEEEEEEEEEFFFFFFFFFFFFGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH - ACH CONTROL RECORD')
        #define.ACHCReserved        ('                                                       HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH - Reserved = <BLANK>')
        #define.ACHCCreditAmount    ('                                           GGGGGGGGGGGG - Total Credit Amount')
        #define.ACHCDebitAmount     ('                               FFFFFFFFFFFF - Total Debit Amount')
        #define.ACHCEntryHash       ('                     EEEEEEEEEE - Entry Hash')
        #define.ACHCAddendaCount    ('             DDDDDDDD - Entry/Addenda Count')
        #define.ACHCBlockCount      ('       CCCCCC - Block Count')
        #define.ACHCBatchCount      (' BBBBBB - Batch Count = "000001"')
        #define.ACHCRecordTypeCode  ('A - Record Type Code = "9"')

        file.write(#ACHCRecord);
        file.write(#ACHCReserved);
        file.write(#ACHCCreditAmount);
        file.write(#ACHCDebitAmount);
        file.write(#ACHCEntryHash);
        file.write(#ACHCAddendaCount);
        file.write(#ACHCBlockCount);
        file.write(#ACHCBatchCount);
        file.write(#ACHCRecordTypeCode);
        file.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addACHHeaderFieldPositions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes field alignment information to the output file to help in verifying the data.
    /// </summary>
    /// <remarks>
    ///    Alignment information can be turned on for NACHA by setting the <c>DebugNACHA</c> macro in the
    ///    <c>CustOutPaym_NACHA</c> class declaration to true.This is a debug
    ///    method.ABBCCCCCCCCCCDDDDDDDDDDEEEEEEFFFFGHHHIIJKKKKKKKKKKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMM - ACH HEADER RECORD MMMMMMMM - Reference Code = &lt;BLANK&gt; LLLLLLLLLLLLLLLLLLLLLLL - Immediate
    ///    Origin Name KKKKKKKKKKKKKKKKKKKKKKK - Immediate Destination Name J - Format Code = "1" II -
    ///    Blocking Factor = "10" HHH - Record Size = "094" G - File ID Modifier = "A" FFFF - File Creation
    ///    Time [HHMM] EEEEEE - File Creation Date [YYMMDD] DDDDDDDDDD - Immediate Origin CCCCCCCCCC -
    ///    Immediate Destination BB - Priority Code = "01"A - Record Type Code = "1"
    /// </remarks>
    protected void addACHHeaderFieldPositions()
    {
        #define.ACHHRecord          ('ABBCCCCCCCCCCDDDDDDDDDDEEEEEEFFFFGHHHIIJKKKKKKKKKKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMM - ACH HEADER RECORD')
        #define.ACHHRefCode         ('                                                                                      MMMMMMMM - Reference Code = <BLANK>')
        #define.ACHHOriginName      ('                                                               LLLLLLLLLLLLLLLLLLLLLLL - Immediate Origin Name')
        #define.ACHHDestinationName ('                                        KKKKKKKKKKKKKKKKKKKKKKK - Immediate Destination Name')
        #define.ACHHFormatCode      ('                                       J - Format Code = "1"')
        #define.ACHHBlockingFactor  ('                                     II - Blocking Factor = "10"')
        #define.ACHHRecordSize      ('                                  HHH - Record Size = "094"')
        #define.ACHHFileIDModifier  ('                                 G - File ID Modifier = "A"')
        #define.ACHHFileCreationTime('                             FFFF - File Creation Time [HHMM]')
        #define.ACHHFileCreationDate('                       EEEEEE - File Creation Date [YYMMDD]')
        #define.ACHHImmediateOrigin ('             DDDDDDDDDD - Immediate Origin')
        #define.ACHHImmediateDest   ('   CCCCCCCCCC - Immediate Destination')
        #define.ACHHPriorityCode    (' BB - Priority Code = "01"')
        #define.ACHHRecordTypeCode  ('A - Record Type Code = "1"')

        file.write(#ACHHRecord);
        file.write(#ACHHRefCode);
        file.write(#ACHHOriginName);
        file.write(#ACHHDestinationName);
        file.write(#ACHHFormatCode);
        file.write(#ACHHBlockingFactor);
        file.write(#ACHHRecordSize);
        file.write(#ACHHFileIDModifier);
        file.write(#ACHHFileCreationTime);
        file.write(#ACHHFileCreationDate);
        file.write(#ACHHImmediateOrigin);
        file.write(#ACHHImmediateDest);
        file.write(#ACHHPriorityCode);
        file.write(#ACHHRecordTypeCode);
        file.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addAlignment</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes alignment markers to the output file to help in verifying the accuracy of the data.
    /// </summary>
    /// <param name="lenLine">
    ///    The length of the line to write to the output file; always 94 for NACHA.
    /// </param>
    /// <remarks>
    ///    This is a debug method. The alignment information can be turned on for NACHA by setting the
    ///    <c>DebugNACHA</c> macro in the <c>CustOutPaym_NACHA</c> class declaration to true.
    /// </remarks>
    protected void addAlignment(int lenLine)
    {
        str     align1;
        str     align2;
        int     multi;

        #define.align1('         1         2         3         4         5         6         7         8         9         0         1         2         3         4         5')
        #define.align2('1234567890')
        #define.ModulusTen(10)

        multi = (lenLine div #ModulusTen) + 1;
        align1 = substr(#align1, 1, lenLine);
        align2 = substr(strrep(#align2, multi), 1, lenLine);

        file.write(align1);
        file.write(align2);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBatchControlFieldPositions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes field alignment information to the output file to help verify the data.
    /// </summary>
    /// <remarks>
    ///    This is a debug method. The alignment information can be turned on for NACHA by setting the
    ///    <c>DebugNACHA</c> macro in the <c>CustOutPaym_NACHA</c> class declaration to true.
    /// </remarks>
    protected void addBatchControlFieldPositions()
    {
        #define.BATCRecord          ('ABBBCCCCCCDDDDDDDDDDEEEEEEEEEEEEFFFFFFFFFFFFGGGGGGGGGGHHHHHHHHHHHHHHHHHHHIIIIIIJJJJJJJJKKKKKKK - BATCH CONTROL RECORD')
        #define.BATCBatchNumber     ('                                                                                       KKKKKKK - Batch Number = "0000001"')
        #define.BATCOriginatingDFI  ('                                                                               JJJJJJJJ - Originating DFI Identification [TTTTAAAA]')
        #define.BATCReserved        ('                                                                         IIIIII - Reserved = <BLANK>')
        #define.BATCAuthentication  ('                                                      HHHHHHHHHHHHHHHHHHH - Message Authentication Code = <BLANK>')
        #define.BATCCompanyID       ('                                            GGGGGGGGGG - Company Identification')
        #define.BATCCreditAmount    ('                                FFFFFFFFFFFF - Total Credit Amount')
        #define.BATCDebitAmount     ('                    EEEEEEEEEEEE - Total Debit Amount')
        #define.BATCEntryHash       ('          DDDDDDDDDD - Entry Hash')
        #define.BATCAddendaCount    ('    CCCCCC - Entry/Addenda Count')
        #define.BATCServiceClassCode(' BBB - Service Class Code = "220" for Credits ["225" for Debits]')
        #define.BATCRecordTypeCode  ('A - Record Type Code = "8"')

        file.write(#BATCRecord);
        file.write(#BATCBatchNumber);
        file.write(#BATCOriginatingDFI);
        file.write(#BATCReserved);
        file.write(#BATCAuthentication);
        file.write(#BATCCompanyID);
        file.write(#BATCCreditAmount);
        file.write(#BATCDebitAmount);
        file.write(#BATCEntryHash);
        file.write(#BATCAddendaCount);
        file.write(#BATCServiceClassCode);
        file.write(#BATCRecordTypeCode);
        file.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBatchHeaderFieldPositions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes field alignment information to the output file to help verify the data.
    /// </summary>
    /// <remarks>
    ///    This is a debug method. The alignment information can be turned on for NACHA by setting the
    ///    <c>DebugNACHA</c> macro in the <c>CustOutPaym_NACHA</c> class declaration to true.
    /// </remarks>
    protected void addBatchHeaderFieldPositions()
    {
        #define.BATHRecord          ('ABBBCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEFFFGGGGGGGGGGHHHHHHIIIIIIJJJKLLLLLLLLMMMMMMM - BATCH HEADER RECORD')
        #define.BATHBatchNumber     ('                                                                                       MMMMMMM - Batch Number = "0000001"')
        #define.BATHOriginatingDFI  ('                                                                               LLLLLLLL - Orifinating DFI Identification')
        #define.BATHOriginStatusCode('                                                                              K - Originator Status Code = "1"')
        #define.BATHSettlementDate  ('                                                                           JJJ - Settlement Date [Julian] - ACH Operator Inserted')
        #define.BATHEffectiveDate   ('                                                                     IIIIII - Effective Entry Date [YYMMDD]')
        #define.BATHDescriptiveDate ('                                                               HHHHHH - Company Descriptive Date [MMDDYY]')
        #define.BATHEntryDescription('                                                     GGGGGGGGGG - Company Entry Description = "RECEIVABLE"')
        #define.BATHEntryClassCode  ('                                                  FFF - Standard Entry Class Code [CCD/PPD/CTX]')
        #define.BATHCompanyID       ('                                        EEEEEEEEEE - Company Identification')
        #define.BATHDiscData        ('                    DDDDDDDDDDDDDDDDDDDD - Company Discretionary Date')
        #define.BATHCompanyName     ('    CCCCCCCCCCCCCCCC - Company Name')
        #define.BATHServiceClassCode(' BBB - Service Class Code = "220" for Credits, "225" for Debits ')
        #define.BATHRecordTypeCode  ('A - Record Type Code = "5"')

        file.write(#BATHRecord);
        file.write(#BATHBatchNumber);
        file.write(#BATHOriginatingDFI);
        file.write(#BATHOriginStatusCode);
        file.write(#BATHSettlementDate);
        file.write(#BATHEffectiveDate);
        file.write(#BATHDescriptiveDate);
        file.write(#BATHEntryDescription);
        file.write(#BATHEntryClassCode);
        file.write(#BATHCompanyID);
        file.write(#BATHDiscData);
        file.write(#BATHCompanyName);
        file.write(#BATHServiceClassCode);
        file.write(#BATHRecordTypeCode);
        file.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDetailRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a payment record to the output file, increments the transaction totals, and updates the
    ///    routing hash with the routing number of the bank account for the payment record.
    /// </summary>
    /// <param name="formatType">
    ///    The format type. CCD, CTX or PPD are the only currently supported NACHA payment formats.
    /// </param>
    /// <param name="bankRoutingNumber">
    ///    The routing number of the customer's bank account.
    /// </param>
    /// <param name="debitAmount">
    ///    The debit transaction amount.
    /// </param>
    /// <param name="creditAmount">
    ///    The credit transaction amount.
    /// </param>
    /// <remarks>
    ///    This method should be called from the CustOutPaymRecord_NACHA_abc classes when a payment record is
    ///    added to the output file.
    /// </remarks>
    // This method should be called whenever a detail record is added to the NACHA EFt
    public void addDetailRecord(str 3 formatType, str bankRoutingNumber, AmountCur debitAmount, AmountCur creditAmount)
    {
        real        hash;
        #define.RoutingNumLen(9)
        #define.RoutingNumWOCheckDigitLen(8)

        recCount ++;
        totalDebitAmount += debitAmount;
        totalCreditAmount += creditAmount;
        numTransactions ++;

        if (numTransactions == 1)
        {
            fileFormat = formatType;
            file.writeExp(this.createBatchHeaderRecord());

            if (#DebugNACHA)
            {
                this.addBatchHeaderFieldPositions();
            }
        }

        // The routingHash is the sum of the bank routing numbers (first 8 digits) of each detail record.
        if (strlen(bankRoutingNumber) >= #RoutingNumLen)
        // Do not include the Check Digit from the Routing Number in the Hash Calculation
        {
            hash = str2num(substr(bankRoutingNumber,1, #RoutingNumWOCheckDigitLen));
        }
        else
        {
            hash = str2num(bankRoutingNumber);
        }

        routingHash += hash;

        // If the value exceeds 9999999999, then the number is decremented by 10000000000
        if (routingHash >= #HashEntryMaximum)
        {
            routingHash -= #HashEntryMaximum;
        }

        if (#DebugNACHA)
        {
            this.addAlignment(#NACHARecLen);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addHeaderControlRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a header record (control or batch) to the output file.
    /// </summary>
    /// <remarks>
    ///    This method is called whenever a header record (control or batch) is added to the output file. If
    ///    the debug flag has been set, alignment markers are printed and the record count is incremented.
    /// </remarks>
    public void addHeaderControlRecord()
    {
        if (#DebugNACHA)
        {
            this.addAlignment(#NACHARecLen);
        }

        recCount ++;
    }

]]></Source>
			</Method>
			<Method>
				<Name>close</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes the batch control and Automated Clearing House (ACH) control records, and prints the Control
    ///    Report or Payment Advice, or both.
    /// </summary>
    /// <remarks>
    ///    This is called at the end of the Electronic Funds Transfer (EFT) output file creation to write the
    ///    batch control and ACH control records, and to print the Control Report or Payment Advice, or both.
    /// </remarks>
    public void close()
    {
        file.writeExp(this.createBatchControlRecord());

        if (#DebugNACHA)
        {
            this.addBatchControlFieldPositions();
        }

        file.writeExp(this.createACH_ControlRecord());

        if (#DebugNACHA)
        {
            this.addACHControlFieldPositions();
        }

        this.createFillerRecordsToBlockTheFile();

        setprefix(strfmt("@SYS73667", filename));                   // File name:
        info(strfmt("@SYS73668", numTransactions));                 // Number of transactions:
        info(strfmt("@SYS73670", totalDebitAmount, bankAccountTable.CurrencyCode));

        if (printControlReport)
        {
            this.printControlReport();
        }

        if (printPaymAdvice)
        {
            this.printPaymAdvice();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFillerRecordsToBlockTheFile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create filler lines to block the file.
    /// </summary>
    protected void createFillerRecordsToBlockTheFile()
    {
        numberOfBlockLines = CustVendOutPaymNACHA::createFillerRecordsToBlockTheFile(file, bankAccountTable, recCount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>codepage</Name>
				<Source><![CDATA[
    protected int codepage()
    {
        #Localcodepage

        return #cp_1252;
    }

]]></Source>
			</Method>
			<Method>
				<Name>printPaymAdvice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prints the payment advice report.
    /// </summary>
    public void printPaymAdvice()
    {
        Args args = new Args();

        if (BankPaymAdviceReportV2FeatureExposure::isEnabled())
        {
            BankPaymAdviceDefaultParameters defaultParameters = BankPaymAdviceDefaultParameters::newForPaymAdvicePrintRun(
                this.getPaymRecords(),
                new SrsPrintDestinationSettings(this.getPrinterSettings(PaymDocumentType::PaymAdvice)),
                printPaymAdvicePrintMgmt);

            args.parmObject(defaultParameters);

            new MenuFunction(menuitemOutputStr(BankPaymAdviceCustV2), MenuItemType::Output).run(args);
        }
        else
        {
            args.caller(this);
            args.parmObject(this.getPaymRecords());
            args.parmEnumType(enumNum(NoYes));
            args.parmEnum(printPaymAdvicePrintMgmt);

            new MenuFunction(menuItemOutputStr(BankPaymAdviceCust), MenuItemType::Output).run(args);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEffectiveEntryDate</Name>
				<Source><![CDATA[
    internal EffectiveDate parmEffectiveEntryDate(EffectiveDate _effectiveDate = effectiveEntDate)
    {
        effectiveEntDate = _effectiveDate;

        return effectiveEntDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createACH_ControlRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes the Automated Clearing House (ACH) control record to the Electronic Funds Transfer (EFT)
    ///    output file.
    /// </summary>
    /// <returns>
    ///    The ACH control record.
    /// </returns>
    //
    //  Entry Hash is calucated as follows:
    //      It is the sum of the values of the "Receiving DFI's" of the Detail Records (CCD, CTX, PPD)
    //      NOTE: Do NOT include the Check Digit from the Receiving DFI -- it is only the first 8 digits of the Routing Number.
    //
    protected container createACH_ControlRecord()
    {
        container   controlACH                  =   connull();

        #define.recTypeCode('9')
        #define.batchCount('000001')
        #define.zero('0')
        #define.spc(' ')
        #define.NumTrxLen(8)
        #define.RoutingHashLen(10)
        #define.AmountLen(12)
        #define.BlockSizeLen(6)

        str 1       recordTypeCode              = #recTypeCode;         // 01 - 01
        str 6       batchCount                  = #batchCount;          // 02 - 07      Will always be '000001' until we add support for payments for multiple companies
        str 6       blockCount                  = strrep(#zero, 6);     // 08 - 13
        str 8       entryAddendaCount           = strrep(#zero, 8);     // 14 - 21
        str 10      entryHash                   = strrep(#zero, 10);    // 22 - 31      Sum of the values of the "Receiving DFI's" of the Detail Records (First 8 digits of Routing Number only - Do NOT include the Check Digit)
        str 12      debitTotal                  = strrep(#zero, 12);    // 32 - 43
        str 12      creditTotal                 = strrep(#zero, 12);    // 44 - 55
        str 39      reserved                    = strrep(#spc, 39);     // 56 - 94

        // A block is 940 characters... determine how many blocks exist in this EFT:
        if (((recCount * #NACHARecLen) mod #NACHABlockSize) != 0)
        {
            blockCount = num2Str0(((recCount * #NACHARecLen) div #NACHABlockSize) + 1, #BlockSizeLen, 0, 0, 0);
        }
        else
        {
            blockCount = num2Str0(((recCount * #NACHARecLen) div #NACHABlockSize), #BlockSizeLen, 0, 0, 0);
        }

        entryAddendaCount = num2Str0(numTransactions, #NumTrxLen);
        entryHash = num2Str0(routingHash, #RoutingHashLen);

        debitTotal = this.num2StrNACHA(totalDebitAmount, #AmountLen);
        creditTotal = this.num2StrNACHA(totalCreditAmount, #AmountLen);

        controlACH = conins(controlACH, 1, recordTypeCode + batchCount + blockCount + entryAddendaCount +
                              entryHash + debitTotal + creditTotal + reserved);

        this.addHeaderControlRecord();
        return controlACH;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createACH_HeaderRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes the Automated Clearing House (ACH) header record to the Electronic Funds Transfer (EFT)
    ///    output file.
    /// </summary>
    /// <returns>
    ///    The ACH header record.
    /// </returns>
    protected container createACH_HeaderRecord()
    {
        container   headerACH                   =   connull();

        #define.recTypeCode('1')
        #define.PriortyCode('01')
        #define.zero('0')
        #define.spc(' ')
        #define.formatCode('1')
        #define.bFactor('10')
        #define.recSize('094')
        #define.IdMod('A')
        #define.DateSequenceYMD(321)
        #define.DateDay(2)
        #define.DateMonth(2)
        #define.DestBankNameLen(23)
        #define.OrigNameLen(23)
                                                                            // Offset           Hardcoded       Value
        str 1       recordTypeCode              =   #recTypeCode;           // 01 - 01          1
        str 2       priorityCode                =   #PriortyCode;           // 02 - 03          01
        str 10      immediateDestination        =   strrep(#zero, 10);      // 04 - 13                          bankAccount.RegistraionNum
        str 10      immediateOrigin             =   strrep(#zero, 10);      // 14 - 23                          bankAccount.CompanyPaymId
        str 6       fileCreationDate            =   strrep(#zero, 6);       // 24 - 29                          System Date
        str 4       fileCreationTime            =   strrep(#zero, 4);       // 30 - 33                          System Time (HHMM)
        str 1       fileIdModifier              =   #IdMod;                 // 34 - 34          a
        str 3       recordSize                  =   #recSize;               // 35 - 37          094
        str 2       blockingFactor              =   #bFactor;               // 38 - 39          10
        str 1       formatCode                  =   #formatCode;            // 40 - 40          1
        str 23      immediateDestinationName    =   strrep(#spc, 23);       // 41 - 63                          bankAccount.DestinationName - new field on Bank Accounts Form (aka Clearing Bank)
        str 23      immediateOriginName         =   strrep(#spc, 23);       // 64 - 86                          bankAccount.Name ==> custVendPaym.sendersBankName
        str 8       referenceCode               =   strrep(#spc, 8);        // 87 - 94          <BLANK>

        UtcDateTime creationDateTimeInUserTimeZone = DateTimeUtil::applyTimeZoneOffset(DateTimeUtil::utcNow(), DateTimeUtil::getUserPreferredTimeZone());
        date creationDate = DateTimeUtil::date(creationDateTimeInUserTimeZone);
        TimeOfDay creationTime = DateTimeUtil::time(creationDateTimeInUserTimeZone);

        fileCreationDate = date2str(creationDate, #DateSequenceYMD, #DateDay, 0, #DateMonth, 0, 2, DateFlags::None); // YYMMDd
        fileCreationTime = this.time2StrHM_NA(creationTime); // HHMm

        bankAccountTable = BankAccountTable::find(this.parmBankAccountID());
        immediateDestination = #spc + this.getBankRoutingNumber(BankUSRoutingNumberFormat::WithCheckDigit);

        if (strlen(bankAccountTable.CompanyPaymId) <= 9)
        {
            // US Standard is for this to be 9 digits, preceeded by a space...
            immediateOrigin = #spc + bankAccountTable.CompanyPaymId;
        }
        else
        {
            // Bank of America uses the 9 digit standard, plus an ID, so all 10 digits must be provided
            immediateOrigin = bankAccountTable.CompanyPaymId;
        }

        immediateDestinationName = strLFix(bankAccountTable.BankDestinationName, #DestBankNameLen, #spc);
        immediateOriginName = strLFix(bankAccountTable.Name, #OrigNameLen, #spc);

        headerACH = conins(headerACH, 1, recordTypeCode + priorityCode + immediateDestination + immediateOrigin +
                             fileCreationDate + fileCreationTime + fileIdModifier + recordSize + blockingFactor +
                             formatCode + immediateDestinationName + immediateOriginName + referenceCode);

        this.addHeaderControlRecord();
        return headerACH;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBatchControlRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes the batch control record to the Electronic Funds Transfer (EFT) output file.
    /// </summary>
    /// <returns>
    ///    The batch control record.
    /// </returns>
    //
    //  Entry Hash is calucated as follows:
    //      It is the sum of the values of the "Receiving DFI's" of the Detail Records (CCD, CTX, PPD)
    //      NOTE: Do NOT include the Check Digit from the Receiving DFI -- it is only the first 8 digits of the Routing Number.
    //
    protected container createBatchControlRecord()
    {
        container   controlBatch                =   connull();

        #define.recTypeCode('8')
        #define.classCode('225')
        #define.zero('0')
        #define.spc(' ')
        #define.batchNum('0000001')
        #define.NumTrxLength(6)
        #define.RoutingHashLen(10)
        #define.AmountLen(12)
        #define.CompPaymIDLen(10)
                                                                            // Offset           Hardcoded       Value
        str 1       recordTypeCode              =   #recTypeCode;           // 01 - 01          8
        str 3       serviceClassCode            =   #classCode;             // 02 - 04          225             225 when generated from Accounts Receivable -> Means "Debits Only"
        str 6       entryAddendaCount           =   strrep(#zero, 6);       // 05 - 10                          Number of Detail Records
        str 10      entryHash                   =   strrep(#zero, 10);      // 11 - 20                          Sum of the values of the "Receiving DFI's" of the Detail Records (First 8 digits of Routing Number only - Do NOT include the Check Digit)
        str 12      totalDebitAmt               =   strrep(#zero, 12);      // 21 - 32                          Total of Debit entries
        str 12      totalCreditAmt              =   strrep(#zero, 12);      // 33 - 44                          Total of Credit entries
        str 10      companyId                   =   strrep(#spc, 10);       // 45 - 54                          bankAccount.CompanyId
        str 19      messageAuthenticationCode   =   strrep(#spc, 19);       // 55 - 73          <BLANK>
        str 6       reserved                    =   strrep(#spc, 6);        // 74 - 79          <BLANK>
        str 8       originatingDFI_Id           =   strrep(#zero, 8);       // 80 - 87                          bankAccount.RoutingNumber
        str 7       batchNumber                 =   #batchNum;              // 88 - 94          0000001

        entryAddendaCount = num2Str0(numTransactions, #NumTrxLength);
        entryHash = num2Str0(routingHash, #RoutingHashLen);
        totalDebitAmt = this.num2StrNACHA(totalDebitAmount, #AmountLen);
        totalCreditAmt = this.num2StrNACHA(totalCreditAmount, #AmountLen);

        companyId = substr(bankAccountTable.CompanyPaymId + strrep(#spc, #CompPaymIDLen), 1, #CompPaymIDLen);

        originatingDFI_Id = this.getBankRoutingNumber(BankUSRoutingNumberFormat::WithoutCheckDigit);

        controlBatch = conins(controlBatch, 1, recordTypeCode + serviceClassCode + entryAddendaCount + entryHash + totalDebitAmt + totalCreditAmt +
               companyId + messageAuthenticationCode + reserved + originatingDFI_Id + batchNumber);

        this.addHeaderControlRecord();
        return controlBatch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBatchHeaderRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes the batch header record to the Electronic Funds Transfer (EFT) output file.
    /// </summary>
    /// <returns>
    ///    The batch header record.
    /// </returns>
    protected container createBatchHeaderRecord()
    {
        container   headerBatch                 =   connull();

        #define.recTypeCode('5')
        #define.classCode('225')
        #define.one('1')
        #define.zero('0')
        #define.spc(' ')
        #define.discData('AXAPTA EFT DEPOSIT  ')
        #define.entDesc('RECEIVABLE')
        #define.batchNum('0000001')
        #define.DateSeqMDY(213)
        #define.DateSeqYMD(321)
        #define.DateDay(2)
        #define.DateMonth(2)
        #define.DateYear(2)
        #define.CompStatementNameLen(16)
        #define.CompPaymIDLen(10)

                                                                            // Offset           Hardcoded       Value
        str 1       recordTypeCode              =   #recTypeCode;           // 01 - 01          5
        str 3       serviceClassCode            =   #classCode;             // 02 - 04          225             225 when generated from Accounts Receivable -> Means "Debits Only"
        str 16      companyName                 =   strrep(#spc, 16);       // 05 - 20                          bankAccount.CompanyStatementName *NEW FIELD*
        str 20      companyDiscretionaryData    =   #discData;              // 21 - 40
        str 10      companyId                   =   strrep(#spc, 10);       // 41 - 50                          custVendPaym.SendersBanksIdentificationOfSender ~ bankAccount.CompanyId
        str 3       standardEntryClassCode      =   strrep(#spc, 3);        // 51 - 53                          CCD, CTX or PPD, depending on the payment.
        str 10      companyEntryDescription     =   #entDesc;               // 54 - 63          RECEIVABLe
        str 6       companyDescriptiveDate      =   strrep(#zero, 6);       // 64 - 69                          System Date
        str 6       effectiveEntryDate          =   strrep(#spc, 6);        // 70 - 75                          Default to System Date, but user will receive prompt to change
        str 3       settlementDate              =   strrep(#spc, 3);        // 76 - 78          BLANK           Julian Date inserted by ACH Operator
        str 1       originatorStatusCode        =   #one;                   // 79 - 79          1
        str 8       originationDFI_Id           =   strrep(#spc, 8);        // 80 - 87                          bankAccount.RoutingNumber
        str 7       batchNumber                 =   #batchNum;              // 88 - 94          0000001

        companyName = strLFix(bankAccountTable.BankCompanyStatementName, #CompStatementNameLen, #spc);
        companyId = strLFix(bankAccountTable.CompanyPaymId, #CompPaymIDLen, #spc);
        standardEntryClassCode = fileFormat;

        companyDescriptiveDate = date2str(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), #DateSeqMDY, #DateDay, 0, #DateMonth, 0, #DateYear, DateFlags::None);     // MMDDYy
        if (effectiveEntDate != dateNull())
        {
            effectiveEntryDate = date2str(effectiveEntDate, #DateSeqYMD, #DateDay, 0, #DateMonth, 0, #DateYear, DateFlags::None);  // YYMMDd
        }
        
        originationDFI_Id = this.getBankRoutingNumber(BankUSRoutingNumberFormat::WithoutCheckDigit);

        headerBatch = conins(headerBatch, 1, recordTypeCode + serviceClassCode + companyName + companyDiscretionaryData + companyId +
               standardEntryClassCode + companyEntryDescription + companyDescriptiveDate + effectiveEntryDate + settlementDate +
               originatorStatusCode + originationDFI_Id + batchNumber);

        this.addHeaderControlRecord();
        return headerBatch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendOutPaymRecordRootClassId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    The method should return the class ID of the corresponding parent of <c>CustVendOutPaymRecord</c>
    ///    classes.
    /// </summary>
    /// <returns>
    ///    The class ID.
    /// </returns>
    /// <remarks>
    ///    The class must be inherited from the <c>CustVendOutPaymRecord</c> class.
    /// </remarks>
    public classId custVendOutPaymRecordRootClassId()
    {
        return classnum(CustOutPaymRecord_NACHA);
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    ///    interface.
    /// </summary>
    /// <returns>
    ///    A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    ///    A dialog can be either built by using the <c>Dialog</c> class or by using a class that is created
    ///    in the Application Object Tree (AOT).
    /// </remarks>
    public Object dialog()
    {
        DialogRunbase  dialog = super();

        this.dialogAddFileName(dialog);

        dialogEffectiveEntryDate = dialog.addFieldValue(extendedtypestr(DueDate), DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), "@SYS8280");

        this.dialogAddPrintDocument(PaymDocumentType::ControlReport, dialog, true);
        this.dialogAddPrintDocument(PaymDocumentType::PaymAdvice, dialog, true, true, true);

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBankRoutingNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the bank account routing number (the registration number) in the specified format.
    /// </summary>
    /// <param name="_format">
    /// The format in which the routing number should be returned.
    /// </param>
    /// <returns>
    /// The routing number in the specified format.
    /// </returns>
    /// <remarks>
    ///  The possible values for the
    ///  <c>
    ///  _format
    ///  </c>
    ///   parameter are as follows:
    ///  <list type="bullet">
    ///   <item>
    ///   <description>With the check digit (returns nine digits)</description>
    ///   </item>
    ///   <item>
    ///   <description>Without the check digit (returns eight digits)</description>
    ///   </item>
    ///   <item>
    ///   <description>Check digit only (returns one digit)</description>
    ///   </item>
    ///   <item>
    ///   <description>The Federal Reserve routing number (returns four digits)</description>
    ///   </item>
    ///   <item>
    ///   <description>ABA institution identifier (returns four digits)</description>
    ///   </item>
    ///  </list>
    ///   In the United States, the routing number must contain nine digits. The first four digits consist
    ///  of the Federal Reserve routing number, the next four digits are the ABA institution identifier, and
    ///  the ninth digit is a check digit. The Automated Clearing House (ACH) origin (routing number)
    ///  contains a leading space, followed by the full routing number with check digit.
    /// </remarks>
    //  Return the Bank Routing (aka Registration) Number in the specified format:
    //
    //  The United States Bank Routing Number is made up as follows:
    //
    //                  TTTTAAAAc
    //
    //      T = Federal Reserve Routing Number
    //      A = ABA Institution Identifier
    //      C = Check Digit
    //
    //  US Routing Numbers are usually expressed as this entire number WITH the Check Digit
    //  The ACH Origin (Routing Number) contains a leading space, followed by the full Routing Number w/ Check Digit
    //
    public str getBankRoutingNumber(BankUSRoutingNumberFormat _format)
    {
        #define.ACHRoutingNumLen(10)
        #define.RoutingNumWOCheckDigitLen(8)
        #define.RoutingNumLen(9)
        #define.FedResLen(4)
        #define.ABAOffset(5)
        #define.ABALen(4)
        #define.ACHOffset(2)

        str         bankRoutingNumber;
        str         retRoutingNumber;

        bankRoutingNumber = bankAccountTable.RegistrationNum;

        if (strlen(bankRoutingNumber) == #RoutingNumWOCheckDigitLen)
        // If the Routing Number is stored without the Check Digit...
        {
            if (_format == BankUSRoutingNumberFormat::CheckDigitOnly || _format == BankUSRoutingNumberFormat::WithCheckDigit)
            {
            // And if they are requesting a format that includes the Check Digit, add it:
                bankRoutingNumber = bankRoutingNumber + num2str(Bank_US::calcRoutingNumberCheckDigit(bankRoutingNumber), 1, 0, 0, 0);
            }
        }

        if (strlen(bankRoutingNumber) == #ACHRoutingNumLen)
        {
            // If the Routing Number is stored in the ACH Format, remove the leading space
            bankRoutingNumber = substr(bankRoutingNumber, #ACHOffset, #RoutingNumLen);
        }

        switch (_format)
        {
            case BankUSRoutingNumberFormat::WithCheckDigit:
                retRoutingNumber = bankRoutingNumber;
                break;

            case BankUSRoutingNumberFormat::WithoutCheckDigit:
                retRoutingNumber = substr(bankRoutingNumber, 1, #RoutingNumWOCheckDigitLen);
                break;

            case BankUSRoutingNumberFormat::CheckDigitOnly:
                retRoutingNumber = substr(bankRoutingNumber, #RoutingNumLen, 1);
                break;

            case BankUSRoutingNumberFormat::FederalReserveRoutingNumber:
                retRoutingNumber = substr(bankRoutingNumber, 1, #FedResLen);
                break;

            case BankUSRoutingNumberFormat::ABA_InstitutionIdentifier:
                retRoutingNumber = substr(bankRoutingNumber, #ABAOffset, #ABALen);
                break;
        }

        return retRoutingNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
    {
        super();
        effectiveEntDate = dialogEffectiveEntryDate.value();
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextSequenceNumber</Name>
				<Source><![CDATA[
    public int getNextSequenceNumber()
    {
        sequenceNumber++;
        return sequenceNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionCodeDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for the NACHA transaction code.
    /// </summary>
    /// <param name = "_custBankAccount">The customer bank account.</param>
    /// <param name = "_eventHandlerResult">An <c>EventHandlerResult</c> where the transaction code can be returned.</param>
    static delegate void getTransactionCodeDelegate(CustBankAccount _custBankAccount, EventHandlerResult _eventHandlerResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the appropriate NACHA transaction code that will be used in the output file, based on the
    ///    specified bank account type.
    /// </summary>
    /// <param name="_custBankAccount">
    ///    The customer bank account.
    /// </param>
    /// <returns>
    ///    The transaction code that will be used in the output file.
    /// </returns>
    /// <remarks>
    ///    <list type="table">
    ///       <listHeader>
    ///          <description>Module</description><description>Bank Account
    ///          Type</description><description>Transaction Code</description>
    ///       </listHeader>
    ///       <item>
    ///          <description>Accounts
    ///          Payable</description><description>Checking</description><description>22</description>
    ///       </item>
    ///       <item>
    ///          <description>Accounts
    ///          Payable</description><description>Savings</description><description>32</description>
    ///       </item>
    ///       <item>
    ///          <description>Accounts
    ///          Receivable</description><description>Checking</description><description>27</description>
    ///       </item>
    ///       <item>
    ///          <description>Accounts
    ///          Receivable</description><description>Savings</description><description>37</description>
    ///       </item>
    ///    </list>
    /// </remarks>
    // Return the approprite NACHA Transaction Code based on the Bank Account Type
    //
    // Transaction Codes:
    //
    // Module               Bank Account Type   Transaction Code Value
    // -------------------- ------------------- ----------------------
    // Accounts Payable     Checking            22
    // Accounts Payable     Savings             32
    // Accounts Receivable  Checking            27
    // Accounts Receivable  Savings             37
    //
    public int getTransactionCode(CustBankAccount _custBankAccount)
    {
        #define.ARChecking(27)
        #define.ARSavings(37)

        int     transactionCode = #ARChecking;       // Default to Checking

        switch (_custBankAccount.BankAccountType)
        {
            case BankAccountType::CheckingAccount:
                transactionCode = #ARChecking;
                break;

            case BankAccountType::SavingsAccount:
                transactionCode = #ARSavings;
                break;

            default:
                EventHandlerResult result = new EventHandlerResult();
                CustOutPaym_NACHA::getTransactionCodeDelegate(_custBankAccount, result);
                if (result.hasResult())
                {
                    transactionCode = result.result();
                }
                break;
        }

        return transactionCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interfaceName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the name of the format to display in the user interface.
    /// </summary>
    /// <returns>
    /// The name of the format to display in the user interface.
    /// </returns>
    /// <remarks>
    /// Formats without an interface name cannot be used in electronic banking as export formats. However,
    /// they can serve as parents for other formats.
    /// </remarks>
    public PaymInterfaceName interfaceName()
    {
        return 'NACHA (US)';
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDebug</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the <c>DebugNACHA</c> flag has been set. Used to determine when to print
    ///    alignment and field position descriptions to the output file.
    /// </summary>
    /// <returns>
    ///    true if the <c>DebugNACHA</c> flag has been set; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The <c>DebugNACHA</c> flag should be used for testing only.
    /// </remarks>
    public boolean isDebug()
    {
        return #DebugNACHA;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isExportFormatNACHA</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the export format against the method of payment.
    /// </summary>
    /// <param name="_paymMode">
    ///    The unique identifier for the method of payment.
    /// </param>
    /// <returns>
    ///    true if export format is NACHA (US); otherwise, false.
    /// </returns>
    protected boolean isExportFormatNACHA(CustPaymMode _paymMode)
    {
        CustPaymModeTable custPaymModeTable = CustPaymModeTable::find(_paymMode);
        boolean ret = custPaymModeTable.ClassId == classnum(CustOutPaym_NACHA);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>num2StrNACHA</Name>
				<Source><![CDATA[
    // Convert a currency value to a string with the format $$$$$$cc
    public TempStr num2StrNACHA(real      value,
                                int       lgth)
    {
        str 100         curTxt;
        str             dollars;
        str             cents;

        #define.zero('0')
        #define.NumDecimals(2)
        #define.DecimalLength(3)

        // Decimal Separator must be either 1 (point) or 2 (comma) -- no option for NO decimal separator...
        curTxt = num2str(abs(value), 0, #NumDecimals, 1, 0);

        dollars = substr(curTxt, 1, strlen(curTxt) - #DecimalLength);
        cents = substr(curTxt, strlen(curTxt) - 1, #NumDecimals);
        curTxt = dollars + cents;

        return strrep(#zero, lgth - strlen(curTxt)) + curTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>open</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Opens the media, such as creating a file, and creates the header of the media, such as creating a
    ///    start record for a file.
    /// </summary>
    public void open()
    {
        sequenceNumber = 0;

        // Open file for text-output
        file = CustVendOutPaym::newFile(this.codepage());

        if (!file || file.status() != IO_Status::Ok)
        {
            // Error opening the file
            throw error(strfmt("@SYS73665", filename));
        }

        file.writeExp(this.createACH_HeaderRecord());
        if (#DebugNACHA)
        {
            this.addACHHeaderFieldPositions();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList] + [super()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>packSysLastValues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Packs the data required for <c>SysLastValues</c>.
    /// </summary>
    /// <returns>
    ///    A container that stores the data to be persisted by <c>SysLastValues</c>.
    /// </returns>
    /// <remarks>
    ///    The pack and unpack pattern does not have provisions for supporting different serialization and
    ///    <c>SysLastValues</c> pack lists. This separate packing mechanism has been implemented for
    ///    <c>SysLastValues</c> and is first defined on the class one level above the <c>RunBase</c> or
    ///    <c>RunBaseBatch</c> class. Derivative classes also implement this method so that a whole object can
    ///    be packed for <c>SysLastValues</c>.
    /// </remarks>
    public container packSysLastValues()
    {
        return [#SysLastValuesCurrentVersion,#SysLastValuesList, super()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>time2StrHM_NA</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Converts a time to a string with the format of HHMM, where HH represents hours and MM represents
    ///    minutes, without a divider.
    /// </summary>
    /// <param name="_time">
    ///    The time to convert.
    /// </param>
    /// <returns>
    ///    A string with the format of HHMM, where HH represents hours and MM represents minutes; no divider.
    /// </returns>
    /// <remarks>
    ///    This is the required format for time in the NACHA file format specification.
    /// </remarks>
    // Convert a Time to a string with the format "HHMM"
    public TempStr time2StrHM_NA(int _time)
    {
        #define.SecondsPerHour(3600)
        #define.SecondsPerMinute(60)
        #define.HourLen(2)
        #define.MinuteLen(2)

        return num2Str0(_time div #SecondsPerHour, #HourLen, 0, 0, 0) + num2Str0(_time mod #SecondsPerHour div #SecondsPerMinute, #MinuteLen, 0, 0, 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Version version = RunBase::getVersion(_packedClass);
        container base;
        boolean     ret;

        #LOCALMACRO.CurrentListV3
            fileName,
            printControlReport,
            effectiveEntDate
        #ENDMACRO
        #define.Version3(3)

        #LOCALMACRO.CurrentListV4
            effectiveEntDate
        #ENDMACRO

        switch (version)
        {
            case #CurrentVersion :
                [version, #CurrentList, base] = _packedClass;
                ret = super(base);
                break;

            case 4:
                [version, #CurrentListV4, base] = _packedClass;
                ret = super(base);
                break;

            case #Version3 :
                [version, #CurrentListV3] = _packedClass;
                ret = true;
                break;

            default :
                ret = false;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpackSysLastValues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Unpacks the data required for <c>SysLastValues</c>.
    /// </summary>
    /// <param name="_packedValues">
    ///    The values stored by the <c>SysLastValues</c> framework that are to be unpacked.
    /// </param>
    /// <remarks>
    ///    The pack and unpack pattern does not have provisions for supporting different serialization and
    ///    <c>SysLastValues</c> pack lists. This separate packing mechanism has been implemented for
    ///    <c>SysLastValues</c> and is first defined on the class one level above the <c>RunBase</c> or
    ///    <c>RunBaseBatch</c> class. Derivative classes also implement this method so that a whole object can
    ///    be unpacked for <c>SysLastValues</c>.
    /// </remarks>
    public void unpackSysLastValues(container _packedValues)
    {
        container baseClassPackedValues;
        Version version = RunBase::getVersion(_packedValues);

        switch (version)
        {
            case #SysLastValuesCurrentVersion:
                [version, #SysLastValuesList, baseClassPackedValues] = _packedValues;
                super(baseClassPackedValues);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the state of the internal variables.
    /// </summary>
    /// <param name="_calledFrom">
    ///    Identifies the object from which this method is called. The default value is null.
    /// </param>
    /// <returns>
    ///    true if the internal variables are valid; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method must validate the state of the internal variables. It is called before closing the
    ///    dialog, and should be called in the <c>run</c> method.It must only contain code that adds warnings
    ///    to the Infolog.The throw command is not allowed in this method.The method should generally return
    ///    errors using the <c>Global::CheckFailed</c> method.Export formats that are designed to handle only
    ///    one method of payment per payment media must call the <c>checkUniquePaymMode</c> method.
    /// </remarks>
    public boolean validate(Object _calledFrom = null)
    {
        boolean ok = true;
        Bank    bank;

        bankAccountTable = BankAccountTable::find(accountId);
        if (!bankAccountTable)
        {
            ok = checkFailed(strfmt("@SYS26720", accountId));
        }

        else
        {
            ok = BankAccountTable::checkIsActive(bankAccountTable.AccountID);

            // Create a Bank validation object based on the bank's location
            bank = Bank::construct(SysCountryRegionCode::locationCountryInfo(bankAccountTable.Location));

            // Can only validate the routing number if the bank exists...
            ok = ok && bank.checkBankRegNum(bankAccountTable.RegistrationNum, bankAccountTable.BankCodeType);

            if (ok)
            {
                if (!bankAccountTable.BankCompanyStatementName)
                {
                    // The company statement name has not been setup for the bank account '%1'.
                    ok = checkFailed(strfmt("@SYS98118", bankAccountTable.AccountID));
                }

                if (!bankAccountTable.CompanyPaymId)
                {
                    // The company ID for electronic payment must be defined for the bank account %1.
                    ok = checkFailed(strfmt("@SYS72611", bankAccountTable.AccountID));
                }
            }
        }

        if (ok && (!filename))
        {
            ok = checkFailed("@SYS18624");
        }

        if (ok && (!this.validatePrenote()))
        {
            ok = false;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePrenote</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates prenotes for the transaction record.
    /// </summary>
    /// <returns>
    ///    true if validates; otherwise, false.
    /// </returns>
    public boolean validatePrenote()
    {
        LedgerJournalTrans  ledgerJournalTrans;
        boolean ret = true;

        if (this.isBankPrenote())
        {
            while select JournalNum, LedgerDimension, CustVendBankAccountId, PaymMode, AccountType, Company from ledgerJournalTrans where
            ledgerJournalTrans.JournalNum == ledgerJournalId
            {
                if (this.isElectronicPayment(ledgerJournalTrans.PaymMode))
                {
                    if (!this.isPrenoteApproved(accountId,ledgerJournalTrans.parmAccount()))
                    {
                        ret = checkFailed("@SYS128521");
                    }
                }
                else if (this.isExportFormatNACHA(ledgerJournalTrans.PaymMode))
                {
                    if (!this.isPrenoteApproved(accountId,ledgerJournalTrans.parmAccount()))
                    {
                        ret = (Box::okCancel(strfmt("@SYS128482",enum2str(this.getPaymentType(ledgerJournalTrans.PaymMode)),enum2str(CustPaymentType::ElectronicPayment)),DialogButton::Ok) == DialogButton::Ok);
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the description of the class.
    /// </summary>
    /// <returns>
    ///    The description of the class.
    /// </returns>
    public static ClassDescription description()
    {
        return new CustOutPaym_NACHA().interfaceName();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Describes whether the class is designed for execution in a new session.
    /// </summary>
    /// <returns>
    /// true if the class is designed for executing the operation in a new session; otherwise, false.
    /// </returns>
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>