<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventCleanupWHSInventSumService</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class InventCleanupWHSInventSumService extends InventCleanupInventSumService
{
    #WHSReservationHierarchy
    RefRecId                     reservationHierarchy;
    WHSReservationHierarchyLevel highestReservationLevel;
    FieldId                      highestReservationFieldId;
    int64                        cleanupCounter;
    int64                        cleanedUpInTransactionScope;
    int                          commitSize;
    int                          uncommitedIterationCounter;
    int                          initialTtsLevel;
    Set                          examinedItemInventDimAcrossHierarchy;
    Set                          examinedItemInventDimUpHierarchy;

    const int                    ItemInventDimMaxCacheSize = 100000;
    const int                    UndefinedHierarchyLevel = -1; 
    List                         dimProductDimFieldList; //cache locally to avoid looking this up in the cache 
    const int64                  LoggerIntervalTimeInMilliseconds = 300000;
    
    private InventInstrumentationLogger logger;

    private utcdatetime modifiedBefore;         
    private boolean isInventUseDimOfWHSInventReserveToggleEnabled = InventUseDimOfWHSInventReserveToggle::instance().isEnabled();

    private boolean useInventSumWithInventDim;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkCleanedUpRecordCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Commit records if the number of records exceeds the maximum number of uncommitted records.
    /// </summary>
    private void checkCleanedUpRecordCount()
    {
        if (this.shouldCommitRecords())
        {
            this.onPreCommitRecords();

            ttscommit;
            cleanupCounter += cleanedUpInTransactionScope;
            cleanedUpInTransactionScope = 0;
            uncommitedIterationCounter = 0;
            ttsbegin;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCommitRecords</Name>
				<Source><![CDATA[
    private boolean shouldCommitRecords()
    {
        if (WHSInventCleanupWHSInventSumServiceCommitIfLoopIterationExceedsLimitFlight::instance().isEnabled())
        {
            return (uncommitedIterationCounter >= commitSize || cleanedUpInTransactionScope >= commitSize)
                    && (appl.ttsLevel() - initialTtsLevel) == 1;
        }
        else
        {
            return cleanedUpInTransactionScope >= commitSize && (appl.ttsLevel() - initialTtsLevel) == 1;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>onPreCommitRecords</Name>
				<Source><![CDATA[
    private void onPreCommitRecords()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>instrumentationLogger</Name>
				<Source><![CDATA[
    final internal InventInstrumentationLogger instrumentationLogger()
    {
        if (!logger)
        {
            logger = InventInstrumentationLogger::createLogger(classId2Name(classIdGet(this)));
        }

        return logger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initialize</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the instance.
    /// </summary>
    protected void initialize()
    {
        cleanupCounter = 0;
        cleanedUpInTransactionScope = 0;
        dimProductDimFieldList = InventDim::dimProductDimFieldList();
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanup</Name>
				<Source><![CDATA[
    [SysObsolete('Method is obsolete, use the cleanupInventSumWithInventDim instead.', false, 20\12\2023)]
    public void cleanup(InventCleanupWHSInventSumContract _dataContract)
    {
        this.runCleanup(_dataContract);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupInventSumWithInventDim</Name>
				<Source><![CDATA[
    public void cleanupInventSumWithInventDim(InventCleanupWHSInventSumWithInventDimContract _dataContract)
    {
        useInventSumWithInventDim = true;

        this.runCleanup(_dataContract);
    }

]]></Source>
			</Method>
			<Method>
				<Name>runCleanup</Name>
				<Source><![CDATA[
    private void runCleanup(InventCleanupInventSumContract _dataContract)
    {
        System.Diagnostics.Stopwatch stopwatch, loggerStopwatch;

        #OCCRetryCount
        #TimeConstants

        using (var activityContext = this.instrumentationLogger().cleanupActivities().inventSumCleanupTimeTaken())
        {
            InventCleanupWHSInventSumWithInventDimContract  cleanupWHSInventSumWithInventDimContract;
            InventCleanupWHSInventSumContract               cleanupWHSInventSumContract;

            if (useInventSumWithInventDim)
            {
                cleanupWHSInventSumWithInventDimContract = _dataContract as InventCleanupWHSInventSumWithInventDimContract;
            }
            else
            {
                cleanupWHSInventSumContract = _dataContract as InventCleanupWHSInventSumContract;
            }

            this.initialize();

            commitSize = _dataContract.parmCommitSize();
            highestReservationFieldId = useInventSumWithInventDim ? cleanupWHSInventSumWithInventDimContract.parmHighestFieldId() : cleanupWHSInventSumContract.parmHighestFieldId();

            this.instrumentationLogger().cleanupActivities().cleanupCalledWithCommitSizeAndHierarchy(commitSize, highestReservationFieldId);

            ActivityDuration maximumExecutionTimeInHours = useInventSumWithInventDim ? cleanupWHSInventSumWithInventDimContract.parmMaximumExecutionTimeInHours() : cleanupWHSInventSumContract.parmMaximumExecutionTimeInHours();
            int64 maximumExecutionTimeInMilliseconds = any2Int64(maximumExecutionTimeInHours * #MillisecondsPerHour);
            
            loggerStopwatch = System.Diagnostics.Stopwatch::StartNew();

            if (maximumExecutionTimeInMilliseconds > 0)
            {
                stopwatch = System.Diagnostics.Stopwatch::StartNew();
            }

            str encodedQuery = useInventSumWithInventDim ? cleanupWHSInventSumWithInventDimContract.parmQuery() : cleanupWHSInventSumContract.parmQuery();

            Query query = new Query(SysOperationHelper::base64Decode(encodedQuery));
            this.addModifiedDateTimeFilter(query, _dataContract.parmDeleteWhenNotUpdatedForDays());
            modifiedBefore = DateTimeUtil::addDays(DateTimeUtil::utcNow(), -_dataContract.parmDeleteWhenNotUpdatedForDays());

            // Check ranges. If any are specified the highest reservation field from the data contract is used in the clean up process,
            // otherwise the clean up process goes to the highest level in the reservation hierarchy.
            if (this.isAnyStorageOrTrackingDimensionSetInQuery(query))
            {
                highestReservationLevel = UndefinedHierarchyLevel;
            }
            else
            {
                highestReservationLevel = #ITEMHIERARCHYLEVEL;
            }

            QueryRun queryRun = new QueryRun(query);

            SysOperationProgress progress = this.showProgress();

            ItemId      prevItemId;
            
            try
            {
                initialTtsLevel = appl.ttsLevel();
                cleanedUpInTransactionScope = 0;
                uncommitedIterationCounter = 0;
            
                if (initialTtsLevel > 0)
                {
                    this.instrumentationLogger().cleanupActivities().outerTTS(initialTtsLevel);
                }

                while (queryRun.next())
                {
                    InventSum inventSum = this.readInventSum(queryRun);
                    InventDim inventDim = this.readInventDim(queryRun);
                    InventTable inventTable = this.readInventTable(queryRun);

                    // Set the highest reservation hierarchy level if the item has changed.
                    if (prevItemId != inventTable.ItemId)
                    {
                        this.setHighestReservationLevel(highestReservationFieldId, inventTable);
                        reservationHierarchy = WHSReservationHierarchyItem::findByItem(inventSum.DataAreaId, inventTable.ItemId).ReservationHierarchy;
                    }

                    if ((appl.ttsLevel() - initialTtsLevel) == 0)
                    {
                        ttsbegin;
                    }

                    uncommitedIterationCounter++;

                    this.cleanUpWHSInventReserve(inventSum, inventDim, inventTable);

                    if (this.validateWHSInventReserveRecsDeleted(inventTable, inventDim)
                    && this.cleanUpInventSum(inventSum, inventDim))
                    {
                        cleanedUpInTransactionScope++;
                    }

                    this.checkCleanedUpRecordCount();

                    prevItemId = inventTable.ItemId;
                    
                    if (LoggerIntervalTimeInMilliseconds < loggerStopwatch.ElapsedMilliseconds)
                    {
                        this.instrumentationLogger().cleanupActivities().periodicReporting(inventTable.RecId);
                        loggerStopwatch.restart();
                    }

                    if (maximumExecutionTimeInMilliseconds > 0 && maximumExecutionTimeInMilliseconds < stopwatch.ElapsedMilliseconds)
                    {
                        info(strFmt("@WAX:OnlyPartialCleanUpCompletedAsTheAllocatedMaximumExecutionTimeOfHoursIsReached", maximumExecutionTimeInHours));

                        break;
                    }

                }

                if ((appl.ttsLevel() - initialTtsLevel) == 1)
                {
                    ttscommit;
                    cleanupCounter += cleanedUpInTransactionScope;
                }

                info(strFmt("@SYS4006018", cleanupCounter));
                this.instrumentationLogger().cleanupActivities().deletedInventSumRecords(cleanupCounter);

            }
            catch (Exception::Deadlock)
            {
                queryRun.reset();
                retry;
            }
            catch (Exception::TransientSqlConnectionError)
            {
                if (ReqTransientSqlConnectionErrorHandlingHelper::retryTransientSqlConnectionError())
                {
                    queryRun.reset();
                    retry;
                }
                else
                {
                    throw;
                }
            }
            catch (Exception::DuplicateKeyException)
            {
                if (appl.ttsLevel() == 0)
                {
                    if (xSession::currentRetryCount() >= #RetryNum)
                    {
                        throw Exception::DuplicateKeyExceptionNotRecovered;
                    }
                    else
                    {
                        queryRun.reset();
                        retry;
                    }
                }
                else
                {
                    throw;
                }
            }
            catch (Exception::UpdateConflict)
            {
                if (appl.ttsLevel() == 0)
                {
                    if (xSession::currentRetryCount() >= #RetryNum)
                    {
                        throw Exception::UpdateConflictNotRecovered;
                    }
                    else
                    {
                        queryRun.reset();
                        retry;
                    }
                }
                else
                {
                    throw;
                }
            }

            progress.kill();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>readInventDim</Name>
				<Source><![CDATA[
    protected InventDim readInventDim(QueryRun _queryRun)
    {
        if (useInventSumWithInventDim)
        {
            InventSum inventSum = _queryRun.get(tableNum(InventSum));

            InventDim inventDim;
            inventDim.initFromInventSum(inventSum);
            inventDim.inventDimId = inventSum.InventDimId;

            return inventDim;
        }

        return super(_queryRun);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAnyStorageOrTrackingDimensionSetInQuery</Name>
				<Source><![CDATA[
    private boolean isAnyStorageOrTrackingDimensionSetInQuery(Query _query)
    {
        Set storageAndTrackingDimensionsSet = useInventSumWithInventDim ? this.getInventSumStorageAndTrackingDimensionsSet() : this.getStorageAndTrackingDimensionsSet();
        
        boolean ret = this.isAnyStorageOrTrackingDimensionSetInInventDimDataSource(storageAndTrackingDimensionsSet, _query);

		if (!ret)
        {
            ret = this.isAnyStorageOrTrackingDimensionSetInQueryFilters(storageAndTrackingDimensionsSet, _query);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAnyStorageOrTrackingDimensionSetInInventDimDataSource</Name>
				<Source><![CDATA[
    private boolean isAnyStorageOrTrackingDimensionSetInInventDimDataSource(Set _storageAndTrackingDimensionsSet, Query _query)
    {
        QueryBuildDataSource qbdsWithInventDim = useInventSumWithInventDim ? _query.dataSourceTable(tableNum(InventSum)) : _query.dataSourceTable(tableNum(InventDim));
  
        for (int i = 1; i <= qbdsWithInventDim.rangeCount(); i++)
		{
            QueryBuildRange queryBuildRange = qbdsWithInventDim.range(i);

            if (queryBuildRange.value()
				&& _storageAndTrackingDimensionsSet.in(queryBuildRange.field()))
			{
                return true;
			}
		}

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAnyStorageOrTrackingDimensionSetInQueryFilters</Name>
				<Source><![CDATA[
    private boolean isAnyStorageOrTrackingDimensionSetInQueryFilters(Set _storageAndTrackingDimensionsSet, Query _query)
    {
        for (int i = 1; i <= _query.queryFilterCount(); i++)
		{
            QueryFilter				queryFilter					    = _query.queryFilter(i);
			QueryBuildDataSource	qbdsQueryFilterWithInventDim    = queryFilter.dataSource();

            if (useInventSumWithInventDim)
            {
                if (qbdsQueryFilterWithInventDim.table() == tableNum(InventSum)
                    && queryFilter.value()
                    && _storageAndTrackingDimensionsSet.in(fieldName2Id(tableNum(InventSum), queryFilter.field())))
                {
                    return true;
                }
            }
            else
            {
                if (qbdsQueryFilterWithInventDim.table() == tableNum(InventDim)
                    && queryFilter.value()
                    && _storageAndTrackingDimensionsSet.in(fieldName2Id(tableNum(InventDim), queryFilter.field())))
                {
                    return true;
                }
            }			
		}

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanUpInventSum</Name>
				<Source><![CDATA[
    protected boolean cleanUpInventSum(InventSum _inventSum, InventDim _inventDim)
    {
        if (!this.validateInventSumDelete(_inventSum))
        {
            return false;
        }

        this.deleteInventSum(_inventSum);

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanUpWHSInventReserve</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes <c>WHSInventReserve</c> records for the specified <c>InventSum</c> record.
    /// </summary>
    /// <param name="_inventSum">
    ///    The <c>InventSum</c> record to be cleaned up.
    /// </param>
    /// <param name="_inventDim">
    ///    The dimension set record associated with the <c>InventSum</c> record.
    /// </param>
    /// <param name="_inventTable">
    ///    The item record associated with the <c>InventSum</c> record.
    /// </param>
    /// <returns>
    ///    true if the <c>InventSum</c> record can be deleted; otherwise, false.
    /// </returns>
    protected boolean cleanUpWHSInventReserve(
        InventSum   _inventSum,
        InventDim   _inventDim,
        InventTable _inventTable)
    {
        boolean ret;

        if (this.negativePhysicalInventoryAllowed(_inventDim.InventLocationId, _inventSum.ItemId, _inventSum.DataAreaId))
        {
            ret = this.deleteWHSInventReserveAcrossHierarchy(_inventSum, _inventDim, _inventTable);
        }
        else
        {
            ret = this.deleteWHSInventReserveUpHierarchy(_inventTable, _inventDim);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteWHSInventReserveAcrossHierarchy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes empty <c>WHSInventReserve</c> records based on the specified <c>InventSum</c> record
    /// by first removing all records at the lowest level, then moving up the reservation hierarchy if possible.
    /// </summary>
    /// <param name="_inventSum">
    /// The specified <c>InventSum</c> record.
    /// </param>
    /// <param name="_inventDim">
    /// The dimension set from the <c>InventSum</c> record.
    /// </param>
    /// <param name="_inventTable">
    /// The item information related to the <c>InventSum</c> record.
    /// </param>
    /// <returns>
    /// true if the <c>WHSInventReserve</c> records were deleted to a point where the <c>InventSum</c> record can be removed; otherwise, false.
    /// </returns>
    private boolean deleteWHSInventReserveAcrossHierarchy(
        InventSum   _inventSum,
        InventDim   _inventDim,
        InventTable _inventTable)
    {
        WHSReservationHierarchyLevel    curResHierarchyLevel;
        WHSReservationHierarchyLevel    lowestResHierarchyLevel;
        WHSInventReserve                whsInventReserve;
        WHSInventReserve                whsInventReserveLowerLevel;
        InventDim                       inventDim;
        InventDim                       inventDimCriteria = InventDim::findOrCreate(_inventDim);
        InventDim                       inventDimLowerLevel;
        InventDimParm                   inventDimParm;
        InventDimParm                   inventDimParmLowerLevel;
        boolean                         ret;

        // If the dimension has unallowed blank values, we won't find any inventreserve records on at least some levels, so for performance reasons we exit early.
        if (WHSReservationHierarchyInventDimUtil::inventDimHasNotAllowedBlankValues(
                                                    _inventDim,
                                                    WHSReservationHierarchyProvider::construct().getDimListAllFromInventTable(_inventTable, WHSReservationHierarchySortOrder::BottomUp),
                                                    InventDimGroupSetup::newInventTable(_inventTable)))
        {
            return false;
        }

        if (!examinedItemInventDimAcrossHierarchy || examinedItemInventDimAcrossHierarchy.elements() >= ItemInventDimMaxCacheSize)
        {
            examinedItemInventDimAcrossHierarchy = new Set(Types::Container);
        }

        do
        {
            // Reset variable to determine when to break out of loop.
            int64 recsRemoved = 0;

            // Get the current reservation hierarchy level
            if (curResHierarchyLevel == 0)
            {
                lowestResHierarchyLevel = WHSReservationHierarchyProvider::construct().getBottomHierarchyLevel(_inventTable);
                curResHierarchyLevel = lowestResHierarchyLevel;
            }
            else
            {
                curResHierarchyLevel--;
            }

            // Find a dimension set record where the field corresponding to the current reservation level is blank.
            inventDimCriteria = this.findHigherReservationInventDim(inventDimCriteria, curResHierarchyLevel);
            inventDimParm.initFromInventDim(inventDimCriteria);
            container keyItemDimCriteria = [_inventSum.ItemId, inventDimCriteria.InventDimId];
            if (!examinedItemInventDimAcrossHierarchy.in(keyItemDimCriteria))
            {
                //we only need to do this once per item+dimcritera. Either we delete the rows or we can't delete them.
                //On the lowest hierarchyLevel we don't need to track dims as they only exists once.
                if (curResHierarchyLevel != lowestResHierarchyLevel)
                {
                    examinedItemInventDimAcrossHierarchy.add(keyItemDimCriteria);
                }

                if (isInventUseDimOfWHSInventReserveToggleEnabled)
                {
                    InventSum inventSum;
                    InventDimId inventDimId;

                    while select forupdate whsInventReserve
                    where whsInventReserve.ItemId               == _inventSum.ItemId
                        && whsInventReserve.HierarchyLevel      == curResHierarchyLevel
                        && whsInventReserve.AvailOrdered        == 0
                        && whsInventReserve.AvailPhysical       == 0
                        && whsInventReserve.ReservOrdered       == 0
                        && whsInventReserve.ReservPhysical      == 0
                        // Need to also account for warehouse enabled CW items
                        && whsInventReserve.CWAvailOrdered      == 0
                        && whsInventReserve.CWAvailPhysical     == 0
                        && whsInventReserve.CWReservOrdered     == 0
                        && whsInventReserve.CWReservPhysical    == 0
                        && #InventDimFieldsFilter(whsInventReserve, inventDimCriteria, inventDimParm)
                    notexists join inventSum
                        where inventSum.ItemId == whsInventReserve.ItemId
                            && inventSum.InventDimId == whsInventReserve.InventDimId
                            && inventSum.ModifiedDateTime > modifiedBefore
                    {
                        // Verify that there are no open records on any level below the current level matching the dimensions.
                        if (curResHierarchyLevel != lowestResHierarchyLevel)
                        {
                            if (inventDimId != whsInventReserve.InventDimId)
                            {
                                inventDimId = whsInventReserve.InventDimId;
                                inventDimParmLowerLevel.initFromInventReserve(whsInventReserve);
                        
                                //Set all product dimensions to allow SQL to pick a good index
                                inventDimParmLowerLevel.setAllProductDimensions();
                            }

                            select firstonly RecId from whsInventReserveLowerLevel
                            where whsInventReserveLowerLevel.ItemId == whsInventReserve.ItemId
                                && whsInventReserveLowerLevel.HierarchyLevel    > curResHierarchyLevel
                                && (whsInventReserveLowerLevel.AvailPhysical    != 0
                                || whsInventReserveLowerLevel.AvailOrdered      != 0
                                || whsInventReserveLowerLevel.ReservPhysical    != 0
                                || whsInventReserveLowerLevel.ReservOrdered     != 0
                                // Need to also account for warehouse enabled CW items
                                || whsInventReserveLowerLevel.CWAvailOrdered    != 0
                                || whsInventReserveLowerLevel.CWAvailPhysical   != 0
                                || whsInventReserveLowerLevel.CWReservOrdered   != 0
                                || whsInventReserveLowerLevel.CWReservPhysical  != 0)
                                && #InventDimFieldsFilter(whsInventReserveLowerLevel, whsInventReserve, inventDimParmLowerLevel);
                        }

                        if (whsInventReserveLowerLevel.RecId == 0 && whsInventReserve.validateDelete())
                        {
                            whsInventReserve.delete();
                            recsRemoved += 1;
                        }
                    }

                }
                else
                {
                    while select forupdate whsInventReserve
                    where whsInventReserve.ItemId               == _inventSum.ItemId
                        && whsInventReserve.HierarchyLevel      == curResHierarchyLevel
                        && whsInventReserve.AvailOrdered        == 0
                        && whsInventReserve.AvailPhysical       == 0
                        && whsInventReserve.ReservOrdered       == 0
                        && whsInventReserve.ReservPhysical      == 0
                        // Need to also account for warehouse enabled CW items
                        && whsInventReserve.CWAvailOrdered      == 0
                        && whsInventReserve.CWAvailPhysical     == 0
                        && whsInventReserve.CWReservOrdered     == 0
                        && whsInventReserve.CWReservPhysical    == 0
                    #InventDimInnerJoin(whsInventReserve.InventDimId, inventDim, inventDimCriteria, inventDimParm)
                    {
                        // Verify that there are no open records on any level below the current level matching the dimensions.
                        if (curResHierarchyLevel != lowestResHierarchyLevel)
                        {
                            inventDimParmLowerLevel.initFromInventDim(inventDim);
                        
                            //Set all product dimensions to allow SQL to pick a good index
                            inventDimParmLowerLevel.setAllProductDimensions();

                            select firstonly RecId from whsInventReserveLowerLevel
                            where whsInventReserveLowerLevel.ItemId == whsInventReserve.ItemId
                                && whsInventReserveLowerLevel.HierarchyLevel    > curResHierarchyLevel
                                && (whsInventReserveLowerLevel.AvailPhysical    != 0
                                || whsInventReserveLowerLevel.AvailOrdered      != 0
                                || whsInventReserveLowerLevel.ReservPhysical    != 0
                                || whsInventReserveLowerLevel.ReservOrdered     != 0
                                // Need to also account for warehouse enabled CW items
                                || whsInventReserveLowerLevel.CWAvailOrdered    != 0
                                || whsInventReserveLowerLevel.CWAvailPhysical   != 0
                                || whsInventReserveLowerLevel.CWReservOrdered   != 0
                                || whsInventReserveLowerLevel.CWReservPhysical  != 0)
                            #InventDimExistsJoin(whsInventReserveLowerLevel.InventDimId, inventDimLowerLevel, inventDim, inventDimParmLowerLevel);
                        }

                        if (whsInventReserveLowerLevel.RecId == 0 && whsInventReserve.validateDelete())
                        {
                            whsInventReserve.delete();
                            recsRemoved += 1;
                        }
                    }
                }
            }
            if (recsRemoved > 0)
            {
                cleanedUpInTransactionScope += recsRemoved;
                this.checkCleanedUpRecordCount();
                this.instrumentationLogger().cleanupActivities().deletedInventReserveRecords(recsRemoved, curResHierarchyLevel);
                ret = true;
            }
        }

        while (curResHierarchyLevel > highestReservationLevel);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteWHSInventReserveUpHierarchy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes empty <c>WHSInventReserve</c> records based on the specified <c>InventSum</c> record
    /// by moving up the reservation hierarchy.
    /// </summary>
    /// <param name="_inventTable">
    /// The item information for the item associated with the records being deleted.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The dimension set from the <c>InventSum</c> record.
    /// </param>
    /// <returns>
    /// true if the <c>WHSInventReserve</c> records were deleted to a point where the <c>InventSum</c> record can be removed; otherwise, false.
    /// </returns>
    private boolean deleteWHSInventReserveUpHierarchy(InventTable _inventTable, InventDim _inventDimCriteria)
    {
        WHSInventReserve                whsInventReserve;
        WHSReservationHierarchyElement  reservationHierarchyElement;
        int64                           recsUpdated;

        if (!examinedItemInventDimUpHierarchy || examinedItemInventDimUpHierarchy.elements() >= ItemInventDimMaxCacheSize)
        {
            examinedItemInventDimUpHierarchy = new Set(Types::Container);
        }

        InventDimParm inventDimParm = this.initInventDimParmHighestReserveLevel(_inventTable, _inventDimCriteria);

        container keyItemDimCriteria;

        // Update cache with the same criteria as we delete and not all dimensions.
        InventDim inventDimCriteria = _inventDimCriteria.data();
        inventDimCriteria.clearNotSelectedDim(inventDimParm);
        keyItemDimCriteria = [_inventTable.ItemId, InventDim::findOrCreate(inventDimCriteria).inventDimId];

        if (!examinedItemInventDimUpHierarchy.in(keyItemDimCriteria))
        {
            examinedItemInventDimUpHierarchy.add(keyItemDimCriteria);

            // Adding forceLiterals keyword as during test runs we've observed performance degradation caused by selection of less optimum execution plans.
            if (isInventUseDimOfWHSInventReserveToggleEnabled)
            {
                InventSum inventSum;

                delete_from forceliterals whsInventReserve
                where whsInventReserve.ItemId          == _inventTable.ItemId
                    && whsInventReserve.AvailOrdered   == 0
                    && whsInventReserve.AvailPhysical  == 0
                    && whsInventReserve.ReservOrdered  == 0
                    && whsInventReserve.ReservPhysical == 0
                    // Need to also account for warehouse enabled CW items
                    && whsInventReserve.CWAvailOrdered      == 0
                    && whsInventReserve.CWAvailPhysical     == 0
                    && whsInventReserve.CWReservOrdered     == 0
                    && whsInventReserve.CWReservPhysical    == 0
                    && #InventDimFieldsFilter(whsInventReserve, _inventDimCriteria, inventDimParm)
                exists join reservationHierarchyElement
                    where reservationHierarchyElement.ReservationHierarchy       == reservationHierarchy
                        && (reservationHierarchyElement.ReservationHierarchyLevel == whsInventReserve.HierarchyLevel
                            || whsInventReserve.HierarchyLevel == #ITEMHIERARCHYLEVEL) //for the item level there is no reservation hierachy element
                        && whsInventReserve.HierarchyLevel >= highestReservationLevel
                notexists join inventSum
                    where inventSum.ItemId == whsInventReserve.ItemId
                        && inventSum.InventDimId == whsInventReserve.InventDimId
                        && inventSum.ModifiedDateTime > modifiedBefore;
            }
            else
            {
                InventDim inventDim;

                delete_from forceliterals whsInventReserve
                where whsInventReserve.ItemId          == _inventTable.ItemId
                    && whsInventReserve.AvailOrdered   == 0
                    && whsInventReserve.AvailPhysical  == 0
                    && whsInventReserve.ReservOrdered  == 0
                    && whsInventReserve.ReservPhysical == 0
                    // Need to also account for warehouse enabled CW items
                    && whsInventReserve.CWAvailOrdered      == 0
                    && whsInventReserve.CWAvailPhysical     == 0
                    && whsInventReserve.CWReservOrdered     == 0
                    && whsInventReserve.CWReservPhysical    == 0
                #InventDimExistsJoin(whsInventReserve.InventDimId, inventDim, _inventDimCriteria, inventDimParm)
                exists join reservationHierarchyElement
                    where reservationHierarchyElement.ReservationHierarchy       == reservationHierarchy
                        && (reservationHierarchyElement.ReservationHierarchyLevel == whsInventReserve.HierarchyLevel
                            || whsInventReserve.HierarchyLevel == #ITEMHIERARCHYLEVEL) //for the item level there is no reservation hierachy element
                        && whsInventReserve.HierarchyLevel >= highestReservationLevel;
            }

            recsUpdated = whsInventReserve.RowCount();
            cleanedUpInTransactionScope += recsUpdated;
            this.checkCleanedUpRecordCount();
        }

        return recsUpdated > 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findHigherReservationInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find an inventory dimension record that has all fields above the current reservation level specified.
    /// </summary>
    /// <param name="_inventDim">
    /// The current inventory dimension set.
    /// </param>
    /// <param name="_resHierarchyLevel">
    /// The current reservation hierarchy level.
    /// </param>
    /// <returns>
    /// The inventory dimension set that was found.
    /// </returns>
    private InventDim findHigherReservationInventDim(InventDim _inventDim, WHSReservationHierarchyLevel _resHierarchyLevel)
    {
        WHSReservationHierarchyElement reservationHierarchyElement;
        InventDim inventDimCriteria = InventDim::find(_inventDim.InventDimId);

        if (_resHierarchyLevel == #ITEMHIERARCHYLEVEL)
        {
            return inventDimCriteria;
        }

        select firstonly DimensionFieldId from reservationHierarchyElement
            where reservationHierarchyElement.ReservationHierarchyLevel == _resHierarchyLevel
                && reservationHierarchyElement.ReservationHierarchy     == reservationHierarchy;

        inventDimCriteria.(reservationHierarchyElement.DimensionFieldId) = InventDim::emptyDimField(reservationHierarchyElement.DimensionFieldId);
        inventDimCriteria = InventDim::findOrCreate(inventDimCriteria);

        return inventDimCriteria;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventDimParmHighestReserveLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an <c>InventDimParm</c> record based on the item and the highest reserveration hierarchy field to delete up to.
    /// </summary>
    /// <param name="_inventTable">
    /// The item information for the records to be deleted.
    /// </param>
    /// <returns>
    /// The initialized <c>InventDimParm</c> buffer.
    /// </returns>
    /// <remarks>
    /// If the highest reservation field value is customized this needs to be updated.
    /// </remarks>
    protected InventDimParm initInventDimParmHighestReserveLevel(InventTable _inventTable, InventDim _inventDimCriteria = null)
    {
        InventDimParm inventDimParm;

        if (highestReservationLevel == #ITEMHIERARCHYLEVEL)
        {
            //we need to ensure that we still respect filtering on specific product dimension if we delete all the way up the hiearchy
            if (_inventDimCriteria.anyProductDimensionSpecified())
            {
                inventDimParm.initfromInventDim(_inventDimCriteria, InventDim::dimProductDimFieldList());
            }
        }
        else if (highestReservationFieldId == fieldNum(InventDim, WMSLocationId))
        {
            inventDimParm = WHSReservationHierarchyInventDimUtil::initInventDimParmAboveLocation(_inventTable);
        }
        else
        {
            throw error("@WAX:OnHandCleanupUnexpectedHighestReservationLevel");
        }

        return inventDimParm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>negativePhysicalInventoryAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the item model for the <c>InventSum</c> item allows negative physical inventory.
    /// </summary>
    /// <param name="_inventLocationId">
    /// The warehouse related to the on hand records.
    /// </param>
    /// <param name="_itemId">
    /// The item number from the on hand record.
    /// </param>
    /// <param name="_dataAreaId">
    /// The data area Id from the on hand record.
    /// </param>
    /// <returns>
    /// True if negative inventory is allowed; otherwise, false.
    /// </returns>
    protected boolean negativePhysicalInventoryAllowed(
        InventLocationId    _inventLocationId,
        ItemId              _itemId,
        DataAreaId          _dataAreaId)
    {
        // Check if the warehouse and item allow negative inventory.
        return (InventModelGroupItem::modelGroupByItemIdLegalEntity(_itemId, _dataAreaId).NegativePhysical
            || InventLocation::find(_inventLocationId).RetailInventNegPhysical);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setHighestReservationLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the highest reservation hierarchy level variable.
    /// </summary>
    /// <param name="_highestFieldId">
    /// The highest <c>InventDim</c> field that the job should clear records for.
    /// </param>
    /// <param name="_inventTable">
    /// The item information for the records being removed.
    /// </param>
    private void setHighestReservationLevel(FieldId _highestFieldId, InventTable _inventTable)
    {
        //the item level is in-dependent of the item so if we are deleting all the way up in the hiearchy we don't need to set a new level based on the item.
        if (highestReservationLevel != #ITEMHIERARCHYLEVEL)
        {
            highestReservationLevel = WHSReservationHierarchyProvider::construct().getDimLevel(_inventTable, _highestFieldId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInventSumDelete</Name>
				<Source><![CDATA[
    protected boolean validateInventSumDelete(InventSum _inventSum)
    {
        boolean ret = super(_inventSum);

        if (ret)
        {
            WHSReservationHierarchyLevel level = WHSReservationHierarchyInventDimUtil::getLevelOfFirstBlankDim(
                _inventSum.ItemId,
                _inventSum.inventDim(),
                WHSReservationHierarchySortOrder::TopDown);
            // Do not delete <c>InventSum</c> record if the dimension set is above the highest reservation level to delete.
            if (level < highestReservationLevel
                && level != 0) // if there are no blank dimension fields then level will be zero.
            {
                ret = false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWHSInventReserveRecsDeleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that an <c>InventSum</c> record can be deleted based on the remaining <c>WHSInventReserve</c>
    /// records related to the item and dimension set.
    /// </summary>
    /// <param name="_inventTable">
    /// The item information for the <c>InventSum</c> record.
    /// </param>
    /// <param name="_inventDim">
    /// The dimension set for the <c>InventSum</c> record.
    /// </param>
    /// <returns>
    /// True if a record can be deleted, otherwise false.
    /// </returns>
    private boolean validateWHSInventReserveRecsDeleted(InventTable _inventTable, InventDim _inventDim)
    {
        WHSInventReserve                    whsInventReserve;
        InventDim                           inventDimCriteria;
        WHSReservationHierarchyElement      resHierarchyElement;
        InventDimParm                       inventDimParm;

        inventDimCriteria.data(_inventDim);
        inventDimCriteria.clearFieldsFromHierarchyList(
            WHSReservationHierarchyProvider::construct().
                getDimListBelowLocation(_inventTable, WHSReservationHierarchySortOrder::BottomUp));

        inventDimParm.initFromInventDim(inventDimCriteria);

        // To get more predictable query performance we want the join to start from WHSInventReserve.
        if (isInventUseDimOfWHSInventReserveToggleEnabled)
        {
            select firstonly forceselectorder RecId from whsInventReserve
            where whsInventReserve.ItemId == _inventTable.ItemId
                && (whsInventReserve.AvailOrdered  == 0
                && whsInventReserve.AvailPhysical  == 0
                && whsInventReserve.ReservOrdered  == 0
                && whsInventReserve.ReservPhysical == 0
                // Need to also account for warehouse enabled CW items
                && whsInventReserve.CWAvailOrdered      == 0
                && whsInventReserve.CWAvailPhysical     == 0
                && whsInventReserve.CWReservOrdered     == 0
                && whsInventReserve.CWReservPhysical    == 0)
                && #InventDimFieldsFilter(whsInventReserve, inventDimCriteria, inventDimParm)
            exists join resHierarchyElement
                where resHierarchyElement.ReservationHierarchy == reservationHierarchy
                    && (resHierarchyElement.ReservationHierarchyLevel == whsInventReserve.HierarchyLevel
                        || whsInventReserve.HierarchyLevel == #ITEMHIERARCHYLEVEL)
                    && whsInventReserve.HierarchyLevel >= highestReservationLevel;            
        }
        else
        {
            InventDim inventDim;

            select firstonly forceselectorder RecId from whsInventReserve
            where whsInventReserve.ItemId == _inventTable.ItemId
                && (whsInventReserve.AvailOrdered  == 0
                && whsInventReserve.AvailPhysical  == 0
                && whsInventReserve.ReservOrdered  == 0
                && whsInventReserve.ReservPhysical == 0
                // Need to also account for warehouse enabled CW items
                && whsInventReserve.CWAvailOrdered      == 0
                && whsInventReserve.CWAvailPhysical     == 0
                && whsInventReserve.CWReservOrdered     == 0
                && whsInventReserve.CWReservPhysical    == 0)
            exists join resHierarchyElement
                where resHierarchyElement.ReservationHierarchy == reservationHierarchy
                    && (resHierarchyElement.ReservationHierarchyLevel == whsInventReserve.HierarchyLevel
                        || whsInventReserve.HierarchyLevel == #ITEMHIERARCHYLEVEL)
                    && whsInventReserve.HierarchyLevel >= highestReservationLevel
            #InventDimExistsJoin(whsInventReserve.InventDimId, InventDim, inventDimCriteria, inventDimParm);
        }

        return whsInventReserve.RecId == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStorageAndTrackingDimensionsSet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a set of all the tracking and storage dimensions of <c>InventDim</c>
    /// </summary>
    /// <returns>
    /// A set of all the tracking and storage dimennsion.
    /// </returns>
    private Set getStorageAndTrackingDimensionsSet()
    {
        container trackingDimFieldListCon = InventDim::dimTrackingDimFieldList().pack();
        List storageAndTrackingDimensions = List::create(trackingDimFieldListCon);
        storageAndTrackingDimensions.appendList(InventDim::dimStorageDimFieldList());
        
        Set storageAndTrackingDimensionsSet = new Set(Types::Integer);
        
        ListEnumerator enumerator = storageAndTrackingDimensions.getEnumerator();
        while (enumerator.moveNext())
        {
            storageAndTrackingDimensionsSet.add(enumerator.current());
        }

        return storageAndTrackingDimensionsSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventSumStorageAndTrackingDimensionsSet</Name>
				<Source><![CDATA[
    private Set getInventSumStorageAndTrackingDimensionsSet()
    {
        container trackingDimFieldListCon = InventDim::dimTrackingDimFieldList().pack();
        List storageAndTrackingDimensions = List::create(trackingDimFieldListCon);
        storageAndTrackingDimensions.appendList(InventDim::dimStorageDimFieldList());
        
        Set storageAndTrackingDimensionsSet = new Set(Types::Integer);
        
        ListEnumerator enumerator = storageAndTrackingDimensions.getEnumerator();
        while (enumerator.moveNext())
        {
            storageAndTrackingDimensionsSet.add(InventDim::getInventSumFieldIdFromInventDimFieldId(enumerator.current()));
        }

        return storageAndTrackingDimensionsSet;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>