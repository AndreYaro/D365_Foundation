<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>JmgJobBundle</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>JmgJobBundle</c> class should be used to create all the registrations in shop floor control.
/// </summary>
/// <remarks>
///  In shop floor control, jobs are said to be bundled when an employee is working on several jobs at
///  the same time. This class encapsulates all of the tasks that are associated with the registration
///  process. These tasks include the following:
///  <list type="bullet">
///   <item>
///   <description>Providing registrations for all of a job bundle at the same time, which includes a
///   check to indicate whether the jobs are a valid bundle.</description>
///   </item>
///   <item>
///   <description>Providing stop registrations for the jobs that the employee is currently working on
///   before start registrations are made on new jobs.</description>
///   </item>
///   <item>
///   <description>Requesting feedback for the jobs that the employee is currently
///   performing.</description>
///   </item>
///   <item>
///   <description>Requesting startup information about jobs to start.</description>
///   </item>
///   <item>
///   <description>Displaying information about the registration process to the user.</description>
///   </item>
///   <item>
///   <description>Providing the employee clock in status to make sure that a clock in registration is
///   made when the employee is making job registrations when they are clocked out, or indicating whether
///   the employee forgot to clock out.</description>
///   </item>
///  </list>
///
///  Most of these features can be enabled or disabled when a
///  <c>
///  JmgJobBundle
///  </c>
///   object is created. For more information, see the
///  <c>
///  JmgJobBundle.new
///  </c>
///   method. There are two typical uses for the
///  <c>
///   JmgJobBundle
///  </c>
///   class:
///  <list type="bullet">
///   <item>
///    <description>
///    Changing jobs. Employees stop working on one set of jobs and start working on a new set of
///    jobs.This is accomplished by instantiating a new object, adding some jobs, and then calling the
///    <c>JmgJobBundle.makeRegistrations</c> method.
///    </description>
///   </item>
///   <item>
///    <description>
///    Providing feedback on active jobs. Employees finish a part of the work order and want to report the
///    results back to shop floor control. This is performed by creating a new object and then starting
///    the <c>JmgJobBundle.makeFeedbackOnActiveJobs</c> method.
///    </description>
///   </item>
///  </list>
/// </remarks>
class JmgJobBundle extends Object
{
    private static boolean isJmgTermRegArchiveInitExtensibilityFlightEnabled = JmgTermRegArchiveInitExtensibilityFlight::instance().isEnabled();
    private static boolean isJmgJobBundleOrderByOprPriorityFlightEnabled = JmgJobBundleOrderByOprPriorityV2Flight::instance().isEnabled();

    Map activeJobs;
    Map newJobs;

    Map activeJobsParameters;
    Map activeJobsExistingParameters;
    Map partialStartupParameters;
    Map newJobsParameters;

    JmgWorkerRecId      worker;
    boolean             continueBundle;
    boolean             askForFeedback;
    boolean             showInfo;

    boolean             forceNewBundle;

    boolean             bundleCommitted;

    boolean             emplClockedIn;

    JmgWrkCtrIdPilot    wrkCtrIdPilot;
    boolean             resourceRegistration;

    JmgJobBundleType    bundleType;

    JmgDate             registrationDate;
    JmgTime             registrationTime;
    utcdatetime         sysDateTime;

    JmgRegistrationSetup    registrationSetup;

    boolean             showMessage;
    str                 messageText;

    NoYes               autoStamp;

    // Production postings:
    JmgProdMultiStartUp         jmgProdMultiStartUp;
    List                        statusQtyProdJournalCheckPostList;
    JmgProdMultiReportFinished  jmgProdMultiReportFinished;

    [SysObsolete('Multi-line report as finish journal is taken care of by ProdMultiLineReportAsFinishSerialNumFeature', false, 03\07\2022)]
    private List                reportFinishedMultiLineJournalCheckPostList;

    FormRun             callerForm;

    // Multi site validation
    InventDimId         inventDimId;
    boolean             taEnabled;
    boolean             registrationsCancelledByUser;
    private  JmgInstrumentationLogger jmgInstrumentationLogger;

    private NoYes hasCancelledEmployeeClockOutDialog;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a job to the job bundle.
    /// </summary>
    /// <param name="_jmgJobTable">
    /// A <c>JmgJobTable</c> record, which refers to the job to add to the bundle.
    /// </param>
    /// <param name="_regParameters">
    /// The registration parameters, which is used when a registration is created on the job.
    /// </param>
    /// <remarks>
    /// An error is thrown if the bundle has already been committed or if the job cannot be added to the
    /// bundle because of an invalid job combination. Being already committed means that if the
    /// <c>makeRegistrations</c> method has been called. Jobs cannot be bundled. If the job has already
    /// been added to the job bundle one time, nothing occurs.Only production jobs can be bundled. Hence,
    /// an error is thrown if, for example, a production job is added first, followed by a project job.
    /// Jobs can also be added by using the <c>addTermJob</c> method.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    /// The worker is not able to create a registration on the job.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    /// In the Manufacturing execution workload hub context, worker tries to bundle jobs for sites that are deployed to scale unit.
    /// </exception>
    public void addJob(JmgJobTable _jmgJobTable,
                       JmgRegistrationParameters _regParameters = new JmgRegistrationParameters())
    {
        JmgTermJob job;

        this.bundleCommitted();

        if (!newJobs.exists(_jmgJobTable.JobId))
        {
            job = JmgTermJob::construct(_jmgJobTable.JobId);

            if (job.allow() && !job.reportedFinish())
            {
                this.validateBundle(job);

                newJobs.insert(_jmgJobTable.JobId, job);
                newJobsParameters.insert(_jmgJobTable.JobId, _regParameters);
            }
            else
            {
                throw error(strFmt("@SYS39813", _jmgJobTable.JobId));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTermJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a job to the job bundle.
    /// </summary>
    /// <param name="_termJob">
    /// A <c>JmgTermJob</c> object, which refers to the job to add to the bundle.
    /// </param>
    /// <param name="_regParameters">
    /// The registration parameters, which is used when a registration is created on the job.
    /// </param>
    /// <remarks>
    /// An error is thrown if the bundle has already been committed, for example, if the
    /// <c>JmgJobBundle.makeRegistrations</c> method has been called, or if the job cannot be added to the
    /// bundle because of an invalid job combination. Jobs cannot be bundled. If the job has already been
    /// added to the job bundle, nothing occurs. Only production jobs can be bundled. Hence, an error is
    /// thrown if, for example, a production job is added first, followed by a project job. Jobs can also
    /// be added by using the <c>JmgJobBundle.addJob</c> method.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    /// The worker is not able to create a registration on the job.
    /// </exception>
    public void addTermJob(JmgTermJob _termJob,
                           JmgRegistrationParameters _regParameters = new JmgRegistrationParameters())
    {
        this.bundleCommitted();

        if (_termJob.allow() && !_termJob.reportedFinish())
        {
            if (!newJobs.exists(_termJob.jobId()))
            {
                this.validateBundle(_termJob);

                newJobs.insert(_termJob.jobId(), _termJob);
                newJobsParameters.insert(_termJob.jobId(), _regParameters);
            }
        }
        else
        {
            throw error(strFmt("@SYS39813", _termJob.jobId()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>bundleCommitted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Throws an error if the bundle has been committed.
    /// </summary>
    /// <remarks>
    ///    A bundle is committed if registrations have been made on the jobs, such as if the
    ///    <c>mgJobBundle.makeRegistrations</c> method has been invoked. The method should be called before
    ///    the job bundle is manipulated to make sure that the bundle has not already been committed.
    /// </remarks>
    private void bundleCommitted()
    {
        if (bundleCommitted)
        {
            throw error("@SYS39892");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBundleCommitted</Name>
				<Source><![CDATA[
    public boolean isBundleCommitted()
    {
        return bundleCommitted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>bundleSize</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the number of jobs added to the bundle.
    /// </summary>
    /// <returns>
    /// The number of jobs added to the bundle.
    /// </returns>
    /// <remarks>
    /// If the <paramref name="continueBundle" /> parameter is set to true, which is performed either by
    /// specifying it in the <c>JmgJobBundle.new</c> method or by using the
    /// <c>JmgJobBundle.continueBundle</c> method, the number of jobs that the employee is currently
    /// working on is included in the return value.
    /// </remarks>
    public int bundleSize()
    {
        if (continueBundle)
        {
            return activeJobs.elements() + newJobs.elements();
        }
        return newJobs.elements();
    }

]]></Source>
			</Method>
			<Method>
				<Name>bundleType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the bundle type.
    /// </summary>
    /// <returns>
    ///    The bundle type.
    /// </returns>
    /// <remarks>
    ///    The bundle type changes according to the type of jobs added to the bundle. The possible bundle
    ///    types are as follows:
    ///    <list type="bullet">
    ///       <item>
    ///          <description>
    ///             <c>JmgJobBundleType::Empty</c>: The job bundle contains no jobs.
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             <c>JmgJobBundleType::IPC</c>: The job bundle contains an indirect activity job.
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             <c>JmgJobBundleType::Prod</c>: The job bundle contains one or more production jobs.
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             <c>JmgJobBundleType::Proj</c>: The job bundle contains a project job.
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             <c>JmgJobBundleType::Absence</c>: The job bundle contains an absence job.
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             <c>JmgJobBundleType::BreakReg</c>: The job bundle contains a break job.
    ///          </description>
    ///       </item>
    ///    </list>
    /// </remarks>
    public JmgJobBundleType bundleType()
    {
        return bundleType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelProductionPostings</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes any production journals that were created during a canceled registration.
    /// </summary>
    /// <param name="_includeBOMJournals">
    /// true if any generated BOM Journals must be removed; otherwise, false.
    /// </param>
    public void cancelProductionPostings(boolean _includeBOMJournals = true)
    {
        using(var activityContext = this.initInstrumentationParms(this.getOrCreateLogger().registration().cancelProductionPosting()))
        {
            this.logActivityParms_Journals(activityContext);
            activityContext.addCustomProperty(JmgRegistrationInstrumentationActivities::ParmIncludeBOMJournals, any2Str(_includeBOMJournals));

            this.removeStatusQtyProdJournals();
            this.removeAssociatedBomJournals(_includeBOMJournals); // BOM journals associated with status quantity

            if (!FeatureStateProvider::isFeatureEnabled(ProdMultiLineReportAsFinishSerialNumFeature::instance()))
            {
                this.removeReportFinishedMultiLineJournals();
            }

            if (jmgProdMultiReportFinished)
            {
                ProdParmReportFinished::deleteParameters(jmgProdMultiReportFinished.parmId());
            }

            if (jmgProdMultiStartUp)
            {
                ProdParmStartUp::deleteParameters(jmgProdMultiStartUp.parmId());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeStatusQtyProdJournals</Name>
				<Source><![CDATA[
    private void removeStatusQtyProdJournals()
    {
        if (statusQtyProdJournalCheckPostList)
        {
            ProdJournalCheckPost prodJournalCheckPost;
            ProdJournalTable     prodJournalTable;
            ListEnumerator       journalEnumerator = statusQtyProdJournalCheckPostList.getEnumerator();

            // Status quantity:
            while (journalEnumerator.moveNext())
            {
                prodJournalCheckPost = journalEnumerator.current();
                prodJournalTable    = ProdJournalTable::find(prodJournalCheckPost.parmJournalId(), true);
                if (prodJournalTable)
                {
                    prodJournalTable.delete();
                }
            }
            statusQtyProdJournalCheckPostList = null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeAssociatedBomJournals</Name>
				<Source><![CDATA[
    private void removeAssociatedBomJournals(boolean _includeBOMJournals)
    {
        if (_includeBOMJournals)
        {
            ProdJournalTable            prodJournalTable;
            JmgRegistrationParameters   regParams;
            MapIterator feedbackIterator = new MapIterator(activeJobsParameters);

            while (feedbackIterator.more())
            {
                regParams = feedbackIterator.value();
                prodJournalTable = ProdJournalTable::find(regParams.prodJournalIdBOM(), true);

                if (prodJournalTable)
                {
                    if (prodJournalTable.Posted == NoYes::No)
                    {
                        // Delete empty journal
                        prodJournalTable.delete();
                        regParams.prodJournalIdBOM('');
                    }
                }
                else
                {
                    regParams.prodJournalIdBOM('');
                }

                feedbackIterator.next();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeReportFinishedMultiLineJournals</Name>
				<Source><![CDATA[
    [SysObsolete('Multi-line report as finish journal is taken care of by ProdMultiLineReportAsFinishSerialNumFeature', false, 03\07\2022)]
    private void removeReportFinishedMultiLineJournals()
    {
        // Remove Report As Finished multi-line journals
        if (reportFinishedMultiLineJournalCheckPostList)
        {
            ProdJournalTable     prodJournalTable;
            ProdJournalCheckPost prodJournalCheckPost;
            ListEnumerator       journalEnumerator = reportFinishedMultiLineJournalCheckPostList.getEnumerator();

            while (journalEnumerator.moveNext())
            {
                prodJournalCheckPost = journalEnumerator.current();
                prodJournalTable    = ProdJournalTable::find(prodJournalCheckPost.parmJournalId(), true);
                if (prodJournalTable)
                {
                    prodJournalTable.delete();
                }
            }
            reportFinishedMultiLineJournalCheckPostList = null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkEmployeeForgotClockOut</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether an employee have been clocked in for too long.
    /// </summary>
    public void checkEmployeeForgotClockOut()
    {
        // check to see if employee has been clocked in for too long.
        if (askForFeedback && taEnabled)
        {
            Args argContainer = new Args();
            var clockOutArgs = new JmgCheckEmployeeForgotClockOutArgs();
            clockOutArgs.parmCallerForm(callerForm);
            clockOutArgs.parmWorker(worker);
            clockOutArgs.parmCurrentTime(sysDateTime);
            argContainer.parmObject(clockOutArgs);

            JmgCheckEmployeeForgotClockOut::main(argContainer);
            this.parmHasCancelledEmployeeClockOutDialog(argContainer.parmEnum());
            this.reset();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHasCancelledEmployeeClockOutDialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether an employee cancelled the forgot clock-out job dialog.
    /// </summary>
    /// <param name = "_hasCancelledEmployeeClockOutDialog">A NoYes enum value.</param>
    /// <returns>Yes if employee cancelled the dialog; otherwise, No.</returns>
    [Hookable(false)]
    public NoYes parmHasCancelledEmployeeClockOutDialog(NoYes _hasCancelledEmployeeClockOutDialog = hasCancelledEmployeeClockOutDialog)
    {
        hasCancelledEmployeeClockOutDialog = _hasCancelledEmployeeClockOutDialog;
        return hasCancelledEmployeeClockOutDialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPilot</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether a worker is currently working as a pilot.
    /// </summary>
    /// <exception cref="M:Exception::Error">
    ///    The worker is currently working as a pilot.
    /// </exception>
    private void checkPilot()
    {
        boolean     throwError;
        JmgTermJob  job;

        // If an employee is a pilot, he should not be allowed to clock out.
        throwError  = false;
        if (JmgEmployee::isPilot(worker))
        {
            if (bundleType  == JmgJobBundleType::Absence)
            {
                throwError  = true;
            }
            else if (bundleType == JmgJobBundleType::IPC)
            {
                job = new MapIterator(newJobs).value();
                if (job.signType() == JmgSignInOut::SignOut)
                {
                    throwError  = true;
                }
            }
        }
        if (throwError)
        {
            throw error(strFmt("@SYS40025", HcmWorker::find(worker).PersonnelNumber));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkRegistrationTime</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks the <c>JmgTermReg</c> table for registrations later than the time entered in the job bundle.
    /// </summary>
    /// <remarks>
    ///    Depending on the shop floor control parameter setup, it either throws an error or automatically
    ///    archives the future registrations in the <c>JmgTermRegArchive</c> table. Online registrations
    ///    should always be made in chronological order. If a registration has been made in the future, such
    ///    as during a test where the system time has been manipulated, this method checks for such
    ///    registrations and either prevents the employee from making registrations before contacting a
    ///    supervisor, or automatically archives the registrations in the <c>JmgTermRegArchive</c> table. The
    ///    future registrations are handled according to the <c>RegistrationErrorMode</c> field of the
    ///    <c>JmgParameters</c> table.
    /// </remarks>
    protected void checkRegistrationTime()
    {
        JmgTermReg  jmgTermReg;

        switch (JmgParameters::find().RegistrationErrorMode)
        {
            case JmgRegistrationErrorMode::Prohibit:
                select firstonly jmgTermReg
                    where jmgTermReg.Worker == worker &&
                          jmgTermReg.RegDateTime > DateTimeUtil::newDateTime(registrationDate, registrationTime, DateTimeUtil::getUserPreferredTimeZone());

                if (jmgTermReg)
                {
                    throw error("@SYS40031");
                }
                break;
            case JmgRegistrationErrorMode::AutoCorrect:
                JmgTermRegArchive       jmgTermRegArchive;
                JmgTermRegArchiveMap    jmgTermRegArchiveMap;

                ttsbegin;
                while select forupdate jmgTermReg
                    where jmgTermReg.Worker == worker &&
                          jmgTermReg.RegDateTime > DateTimeUtil::newDateTime(registrationDate, registrationTime, DateTimeUtil::getUserPreferredTimeZone())
                {
                    if (isJmgTermRegArchiveInitExtensibilityFlightEnabled)
                    {
                        jmgTermRegArchive = JmgTermRegArchive::initFromJmgTermReg(jmgTermReg);
                    }
                    else
                    {
                        jmgTermRegArchiveMap.data(jmgTermReg);
                        jmgTermRegArchive.data(jmgTermRegArchiveMap);
                    }

                    jmgTermRegArchive.Description = strFmt("@SYS40032", JmgProfileSeconds::formattedSeconds(registrationTime, JmgSecondPresentationEnum::Clocktime), registrationDate);

                    jmgTermRegArchive.insert();
                    jmgTermReg.delete();
                }
                ttscommit;
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearActiveJobs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes all active jobs from the bundle.
    /// </summary>
    /// <remarks>
    /// An error is thrown if the bundle is committed.
    /// </remarks>
    public void clearActiveJobs()
    {
        this.bundleCommitted();

        activeJobs = new Map(Types::String, Types::Class);

        if (this.bundleSize() == 0)
        {
            bundleType = JmgJobBundleType::Empty;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>containsJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves whether the job bundle contains the job with the specified job ID.
    /// </summary>
    /// <param name="_jobId">
    /// The job ID to look for in the bundle.
    /// </param>
    /// <returns>
    /// <c>NoYes::Yes</c> if the bundle contains the job; otherwise, <c>NoYes::No</c>.
    /// </returns>
    /// <remarks>
    /// If the <c>JmgJobBundle.continueBundle</c> parameter is set to true, the active jobs are also
    /// checked.
    /// </remarks>
    public NoYes containsJob(JmgJobId _jobId)
    {
        if (newJobs.exists(_jobId) || (continueBundle && activeJobs.exists(_jobId)))
        {
            return NoYes::Yes;
        }
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>continueBundle</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets or retrieves the <c>continueBundle</c> parameter.
    /// </summary>
    /// <param name="_continueBundle">
    /// A Boolean value that represents the new value of the <c>continueBundle</c> parameter; optional.
    /// </param>
    /// <returns>
    /// The current value of the <c>continueBundle</c> parameter.
    /// </returns>
    /// <remarks>
    /// If the <paramref name="continueBundle" /> parameter is set to true, an error is thrown if the
    /// <paramref name="activeJobs" /> and <paramref name="newJobs" /> together make up an invalid bundle.
    /// If the <paramref name="continueBundle" /> parameter is set to true, the jobs upon which the
    /// employee is active is not stopped when <c>makeRegistrations</c> is called. Only the jobs added to
    /// the job bundle is started, and those bundled with the already started jobs. If the <paramref
    /// name="continueBundle" /> parameter is set to false, a stop registration is made for each active job
    /// before start registrations are made for the added jobs.
    /// </remarks>
    public boolean continueBundle(boolean _continueBundle = continueBundle)
    {
        MapIterator mapIterator;
        JmgTermJob  job;

        this.bundleCommitted();

        if (_continueBundle == continueBundle)
        {
            return continueBundle;
        }

        if (forceNewBundle && _continueBundle)
        {
            return false;
        }

        using(var activityContext = this.getOrCreateLogger().registration().bundle())
        {
            bundleType = JmgJobBundleType::Empty;
            if (_continueBundle)
            {
                mapIterator = new MapIterator(activeJobs);
                while (mapIterator.more())
                {
                    job = mapIterator.value();
                    this.validateBundle(job, false);
                    mapIterator.next();
                }
            }

            if (bundleType != JmgJobBundleType::Prod)
            {
                continueBundle = false;
                bundleType = JmgJobBundleType::Empty;
            }
            else
            {
                mapIterator = new MapIterator(newJobs);
                while (mapIterator.more())
                {
                    job = mapIterator.value();
                    this.validateBundle(job);
                    mapIterator.next();
                }
                continueBundle = _continueBundle;
            }
        }

        return continueBundle;
    }

]]></Source>
			</Method>
			<Method>
				<Name>emplClockedIn</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the worker that is associated to the <c>JmgJobBundle</c> object is currently
    ///    clocked in.
    /// </summary>
    /// <returns>
    ///    true if the worker is clocked in; otherwise, false.
    /// </returns>
    public boolean emplClockedIn()
    {
        return emplClockedIn;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ensureClockInStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a clock-in registration for the employee associated with the bundle if the employee is not
    ///    currently clocked in.
    /// </summary>
    /// <param name="_allowRestart">
    ///    Allow jobs to be restarted on clock-in.
    /// </param>
    /// <param name="_allowRestoreTeam">
    ///    Allow teams to be restored on clock-in.
    /// </param>
    /// <remarks>
    ///    The <paramref name="_allowRestart" /> and <paramref name="_allowRestoreTeam" /> parameters are
    ///    supplied as arguments to the <see cref="M:JmgJobBundle.makeClockInRegistration" /> method.
    /// </remarks>
    private void ensureClockInStatus(boolean _allowRestart, boolean _allowRestoreTeam)
    {
        if (!emplClockedIn && taEnabled)
        {
            // Create a clock-in registration.
            this.makeClockInRegistration(_allowRestart, _allowRestoreTeam);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>feedbackBundleType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the bundle type of the active jobs bundle.
    /// </summary>
    /// <returns>
    /// See documentation for the <see cref="M:JmgJobBundle.bundleType" /> method for a description of the
    /// different bundle types.
    /// </returns>
    /// <remarks>
    /// If a new bundle was created by using the jobs that the employee is currently working on, the
    /// <c>JmgJobBundle.bundleType</c> method would return the same bundle as this method.
    /// </remarks>
    public JmgJobBundleType feedbackBundleType()
    {
        JmgTermJob       job;
        JmgJobBundleType ret;
        MapIterator      mapIterator;

        ret = JmgJobBundleType::Empty;
        mapIterator = this.getActiveJobsIterator();
        while (mapIterator.more())
        {
            job = mapIterator.value();
            if (job.stampType() != JmgStampTypeEnum::Break)
            {
                ret = this.translateModuleType(job.module());
            }
            mapIterator.next();
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActiveJob</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets a job from the <paramref name="activeJobs" /> map. This method throws an error if the supplied job ID is not present in the <paramref name="activeJobs" /> map.
    /// </summary>
    /// <param name="_jobId">
    ///    The job ID of the active job to retrieve.
    /// </param>
    /// <returns>
    ///    An instance of the <c>JmgTermJob</c> class representing the supplied job ID.
    /// </returns>
    public JmgTermJob getActiveJob(JmgJobId _jobId)
    {
        if (activeJobs.exists(_jobId))
        {
            return activeJobs.lookup(_jobId);
        }
        throw error(strFmt("@SYS39893", _jobId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActiveJobsIterator</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a map iterator of the <paramref name="activeJobs" /> map.
    /// </summary>
    /// <returns>
    ///    A map iterator of the <paramref name="activeJobs" /> map.
    /// </returns>
    public MapIterator getActiveJobsIterator()
    {
        MapIterator ret;

        if (isJmgJobBundleOrderByOprPriorityFlightEnabled)
        {
            ret = new MapIterator(this.getActiveJobsMap());
        }
        else
        {
            ret = new MapIterator(activeJobs);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActiveJobsMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a map of the <paramref name="activeJobs" /> map.
    /// </summary>
    /// <returns>
    ///    A map of the <paramref name="activeJobs" /> map.
    /// </returns>
    public Map getActiveJobsMap()
    {
        return activeJobs;        
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFeedbackParameters</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets feedback parameters for a specific job. If the specified job ID is not one of the active jobs, an error is thrown.
    /// </summary>
    /// <param name="_jobId">
    ///    The job ID that feedback parameters should be returned for.
    /// </param>
    /// <returns>
    ///    The registration parameters currently associated with the specified job ID.
    /// </returns>
    public JmgRegistrationParameters getFeedbackParameters(JmgJobId _jobId)
    {
        JmgRegistrationParameters ret;

        if (activeJobsParameters.exists(_jobId))
        {
            ret = activeJobsParameters.lookup(_jobId);
        }
        else
        {
            ret = new JmgRegistrationParameters();
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJobStartedParameters</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the registration parameters associated to the specified job ID.
    /// </summary>
    /// <param name="_jobId">
    ///    The ID of the job for which to retrieve parameters.
    /// </param>
    /// <returns>
    ///    The registration parameters associated to the specified job ID.
    /// </returns>
    public JmgRegistrationParameters getJobStartedParameters(JmgJobId _jobId)
    {
        JmgRegistrationParameters ret;

        if (activeJobsExistingParameters.exists(_jobId))
        {
            ret = activeJobsExistingParameters.lookup(_jobId);
        }
        else
        {
            ret = new JmgRegistrationParameters();
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewJobsIterator</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a map iterator of the <paramref name="newJobs" /> map.
    /// </summary>
    /// <returns>
    ///    A map iterator of the <paramref name="newJobs" /> map.
    /// </returns>
    public MapIterator getNewJobsIterator()
    {
        MapIterator ret;
        
        if (isJmgJobBundleOrderByOprPriorityFlightEnabled)
        {
            ret = new MapIterator(this.getNewJobsMap());
        }
        else
        {
            ret = new MapIterator(newJobs);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewJobsMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a map of the <paramref name="newJobs" /> map.
    /// </summary>
    /// <returns>
    ///    A map of the <paramref name="newJobs" /> map.
    /// </returns>
    public Map getNewJobsMap()
    {
        return newJobs;        
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJobsOrderIterator</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a map iterator of the ordered jobs based on the specified map iterator,
    /// </summary>
    /// <param name = "_jobsIterator">The iterator of an original map to be ordered.</param>
    /// <returns>A map iterator of the ordered jobs represented by a (sorting string, jobId) pair.</returns>
    internal MapIterator getJobsOrderIterator(MapIterator _jobsIterator)
    {
        Map jobsOrder = new Map(Types::String, Types::String);

        if (_jobsIterator)
        {
            JmgTermJob      job;
            
            while (_jobsIterator.more())
            {
                job = _jobsIterator.value();

                jobsOrder.insert(job.jobOrderSortingKey(), _jobsIterator.key());

                _jobsIterator.next();
            }
        }
        
        return new MapIterator(jobsOrder);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRealizedStartTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the realized starting time of the job that is associated with the specified transaction.
    /// </summary>
    /// <param name="_prodJournalIdRoute">
    /// The ID of the routing journal transaction.
    /// </param>
    /// <returns>
    /// The realized start time of the job that is associated with the specified transaction.
    /// </returns>
    /// <remarks>
    /// The realized starting time of a job is the time of the first Start Job registration.
    /// </remarks>
    private SchedFromTime getRealizedStartTime(ProdJournalIdRoute _prodJournalIdRoute)
    {
        ProdJournalRoute prodJournalRoute;
        JmgTermReg       jmgTermReg;

        ProdRoute prodRoute;
        if (JmgProdParameters::find().StampLevel    == JmgStampLevel::Route)
        {
            select firstonly JobId from prodJournalRoute
                where prodJournalRoute.JournalId == _prodJournalIdRoute
                join * from prodRoute
                where prodJournalRoute.ProdId       == prodRoute.ProdId         &&
                      prodJournalRoute.OprNum       == prodRoute.OprNum         &&
                      prodJournalRoute.OprPriority  == prodRoute.OprPriority
                join JobId, RegType, RegDateTime from jmgTermReg
                    order by RegDateTime asc
                    where jmgTermReg.JobId == prodRoute.JobIdProcess &&
                        jmgTermReg.RegType == JmgTermRegType::JobStart;
        }
        else
        {
            select firstonly JobId from prodJournalRoute
                where prodJournalRoute.JournalId == _prodJournalIdRoute
                join JobId, RegType, RegDateTime from jmgTermReg
                    order by RegDateTime asc
                    where jmgTermReg.JobId == prodJournalRoute.JobId &&
                        jmgTermReg.RegType == JmgTermRegType::JobStart;
        }
        return DateTimeUtil::time(DateTimeUtil::applyTimeZoneOffset(jmgTermReg.RegDateTime, DateTimeUtil::getUserPreferredTimeZone()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStartupParameters</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets startup parameters for a specific job. If the specified job ID is not one of the new jobs, an
    ///    error is thrown.
    /// </summary>
    /// <param name="_jobId">
    ///    The job ID for which the startup parameters can be returned.
    /// </param>
    /// <returns>
    ///    The registration parameters currently associated with the specified job ID.
    /// </returns>
    public JmgRegistrationParameters getStartupParameters(JmgJobId _jobId)
    {
        JmgRegistrationParameters ret;

        ret = new JmgRegistrationParameters();
        if (continueBundle && partialStartupParameters.exists(_jobId))
        {
            ret = partialStartupParameters.lookup(_jobId);
        }
        else if (newJobsParameters.exists(_jobId))
        {
            ret = newJobsParameters.lookup(_jobId);
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>jobsAdded</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves whether jobs have been added to the job bundle.
    /// </summary>
    /// <returns>
    ///    true if jobs have been added; otherwise, false.
    /// </returns>
    public boolean jobsAdded()
    {
        return newJobs.elements() > 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadActiveJobs</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Load the jobs that the employee is currently working on.
    /// </summary>
    /// <remarks>
    ///    Part of the initialization of the <c>JmgJobBundle</c> object.
    /// </remarks>
    protected void loadActiveJobs()
    {
        Query query = new Query();
        QueryBuildDataSource queryBuildDataSource = query.addDataSource(tableNum(JmgTermReg));
        queryBuildDataSource.addRange(fieldNum(JmgTermReg, JobActive)).value(queryValue(NoYes::Yes));
        if (resourceRegistration && wrkCtrIdPilot)
        {
            queryBuildDataSource.addRange(fieldNum(JmgTermReg, WrkCtrIdPilot)).value(queryValue(wrkCtrIdPilot));
            queryBuildDataSource.addRange(fieldNum(JmgTermReg, Worker)).value(SysQuery::valueEmptyString());
        }
        else
        {
            queryBuildDataSource.addRange(fieldNum(JmgTermReg, Worker)).value(queryValue(worker));
        }

        QueryRun queryRun = new QueryRun(query);
        while (queryRun.next())
        {
            JmgTermReg jmgTermReg = queryRun.get(tableNum(JmgTermReg));
            this.insertActiveJob(jmgTermReg);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertActiveJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts an active job.
    /// </summary>
    /// <param name = "_jmgTermReg">The job registration.</param>
    protected void insertActiveJob(JmgTermReg _jmgTermReg)
    {
        JmgTermJob job = JmgTermJob::construct(_jmgTermReg.JobId);

        int infoLine = infologLine();
        try
        {
            this.validateBundle(job, false);
        }
        catch (Exception::Error)
        {
            forceNewBundle = true;
            infolog.clear(infoLine);
        }

        if (job.module() == JmgModuleEnum::PROD && inventDimId == InventDim::inventDimIdBlank())
        {
            JmgTermJob_Prod jobProd = job;
            inventDimId = jobProd.siteInventDimId();
        }

        activeJobs.insert(_jmgTermReg.JobId, job);
        activeJobsParameters.insert(_jmgTermReg.JobId, new JmgRegistrationParameters());
        activeJobsExistingParameters.insert(_jmgTermReg.JobId, JmgRegistrationParameters::newFromJmgTermReg(_jmgTermReg));
    }

]]></Source>
			</Method>
			<Method>
				<Name>makeChangePilotRegistrations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides a change pilot registration. An error is thrown if no new pilot is specified in the
    /// <c>JmgRegistrationParameters</c> object.
    /// </summary>
    /// <param name="_parameters">
    /// A <c>JmgRegistrationParameters</c> object that contains the new pilot ID.
    /// </param>
    /// <remarks>
    /// Creates a stop assistance registration for the employee and the members of his team, and then
    /// creates a start team registration for each team member created that has the specified employee as
    /// pilot.
    /// </remarks>
    private void makeChangePilotRegistrations(JmgRegistrationParameters _parameters)
    {
        JmgAssistance               jmgAssistance;
        JmgTermReg                  jmgTermReg;
        JmgTermJob                  startTeamJob    = JmgTermJob::construct(JmgIpcActivity::findSignTypeJobId(JmgSignInOut::StartTeam,true));
        JmgTermJob                  stopTeamJob     = JmgTermJob::construct(JmgIpcActivity::findSignTypeJobId(JmgSignInOut::StopTeam,true));
        JmgTermJob                  job;
        JmgRegistrationParameters   regParm;

        if (!_parameters.jobPilot())
        {
            throw error("@SYS39885");
        }

        if (!(select RecId
                from jmgTermReg
                where jmgTermReg.WorkerPilot== worker                   &&
                      jmgTermReg.Worker     == _parameters.jobPilot()   &&
                      jmgTermReg.JobActive  == NoYes::Yes               &&
                      jmgTermReg.RegType    == JmgTermRegType::TeamStart).RecId)
        {
            throw error(strFmt("@SYS39886", HcmWorker::find(_parameters.jobPilot()).PersonnelNumber, HcmWorker::find(worker).PersonnelNumber));
        }

        ttsbegin;
        // Stop active jobs using the current pilot.
        this.stopActiveJobs();

        // Change the pilot from the old to the new.
        while select jmgTermReg
            where jmgTermReg.WorkerPilot    == worker   &&
                  jmgTermReg.JobActive      == NoYes::Yes   &&
                  jmgTermReg.RegType        == JmgTermRegType::TeamStart
        {
            stopTeamJob.makeRegistration(jmgTermReg.Worker, registrationDate, registrationTime);
            if (jmgTermReg.Worker != _parameters.jobPilot())
            {
                startTeamJob.makeRegistration(jmgTermReg.Worker, registrationDate, registrationTime, true, _parameters);
            }
        }
        startTeamJob.makeRegistration(worker, registrationDate, registrationTime, true, _parameters);

        // Start the previous active jobs using the new pilot.
        MapIterator mapIterator = new MapIterator(activeJobs);
        while (mapIterator.more())
        {
            job = mapIterator.value();

            // Don't make job registration for pilot if a job is completed
            if (this.isJobCompleted(job.jobId()))
            {
                mapIterator.next();
                continue;
            }

            // If job is a project job, then use the same registration parameters as the original registration (use the same cost category)
            // Else just use a fresh set of parameters.
            if (job.module() == JmgModuleEnum::PROJ)
            {
                regParm = activeJobsExistingParameters.lookup(job.jobId());
            }
            else
            {
                regParm = new JmgRegistrationParameters();
            }
            job.makeRegistration(_parameters.jobPilot(), registrationDate, registrationTime, true, regParm);
            mapIterator.next();
        }

        // SaveTeams : Update record
        while select jmgAssistance
            where jmgAssistance.WorkerPilot == worker
        {
            if (jmgAssistance.WorkerAssistant == _parameters.jobPilot())
            {
                jmgAssistance.delete();
            }
            else
            {
                jmgAssistance.WorkerPilot = _parameters.jobPilot();
                jmgAssistance.update();
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isJobCompleted</Name>
				<Source><![CDATA[
    private boolean isJobCompleted(JmgJobId _jobId)
    {
        JmgRegistrationParameters regParams = this.getFeedbackParameters(_jobId);

        return regParams.reportAsFinished() == JmgFeedbackStatus::Completed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>makeClockInRegistration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides a clock-in registration for the employee.
    /// </summary>
    /// <param name="_allowRestart">
    /// If set to true and the Shop Floor Control parameters allow for it, the jobs upon which the employee
    /// was working at the last clock out is restarted at clock-in. If set to false, no jobs are restarted.
    /// </param>
    /// <param name="_allowRestoreTeam">
    /// If set to true and the Shop Floor Control parameters allow for it, the team which the employee was
    /// a member of on the last clock-out is restored. If set to false, the team is not restored.
    /// </param>
    /// <param name="_jobIdAbsence">
    /// The absence ID that can be specified on the clock-in registration; optional.
    /// </param>
    /// <remarks>
    /// If specified, jobs stopped at the previous clock-out can be restarted or if the employee was member
    /// of a team at the previous clock-out, this team can be restored.
    /// </remarks>
    public void makeClockInRegistration(boolean _allowRestart, boolean _allowRestoreTeam, JmgJobId _jobIdAbsence = '')
    {
        #JmgSignIn

        using(var activityContext = this.initInstrumentationParms(this.getOrCreateLogger().registration().clockIn(worker)))
        {
            if (taEnabled)
            {
                JmgTermJob job = JmgTermJob::construct(JmgIpcActivity::findSignInJobId());
                JmgRegistrationParameters parameters = this.constructClockInParameters(_jobIdAbsence);

                job.makeRegistration(worker, registrationDate, registrationTime, true, parameters);

                showMessage = true;
                messageText = "@SYS38409";

                if (!this.restoreTeam(_allowRestoreTeam))
                {
                    this.restartJobs(_allowRestart);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructClockInParameters</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Constructs clock in registration parameters.
    /// </summary>
    /// <param name="_jobIdAbsence">
    ///     An absence job ID which can be specified on the clock-in registration; optional.
    /// </param>
    /// <returns>
    ///     The <c>JmgRegistrationParameters</c> instance.
    /// </returns>
    protected JmgRegistrationParameters constructClockInParameters(JmgJobId _jobIdAbsence = '')
    {
        JmgRegistrationParameters parameters = new JmgRegistrationParameters();

        parameters.jobIdAbsence(_jobIdAbsence);
        return parameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>makeClockOutRegistration</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Provides a clock out registration for the employee. If the employee is already clocked out, an
    ///    error is thrown.
    /// </summary>
    /// <param name="_jobIdAbsence">
    ///    An absence job ID, which can be associated with the clock out registration; optional.
    /// </param>
    public void makeClockOutRegistration(JmgJobId _jobIdAbsence = '')
    {
        #JmgSignIn
        JmgTermJob                  job;
        JmgRegistrationParameters   parameters;
        MapIterator                 activeJobsIterator;
        if (taEnabled)
        {
            job = JmgTermJob::construct(JmgIpcActivity::findSignOutJobId());
            parameters = this.constructClockOutParameters(_jobIdAbsence);

            job.makeRegistration(worker, registrationDate, registrationTime, true, parameters, autoStamp);

            showMessage = true;
            messageText = "@SYS38411";
        }

        // All active jobs must be stopped. Mark them as stopped, if they are not already
        activeJobsIterator = this.getActiveJobsIterator();
        while (activeJobsIterator.more())
        {
            parameters = this.getFeedbackParameters(activeJobsIterator.key());
            if (parameters.reportAsFinished() == JmgFeedbackStatus::InProgress)
            {
                parameters.reportAsFinished(JmgFeedbackStatus::Stopped);
            }
            activeJobsIterator.next();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructClockOutParameters</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Constructs clock out registration parameters.
    /// </summary>
    /// <param name="_jobIdAbsence">
    ///    An absence job ID which can be associated with the clock out registration; optional.
    /// </param>
    /// <returns>
    ///     The <c>JmgRegistrationParameters</c> instance.
    /// </returns>
    protected JmgRegistrationParameters constructClockOutParameters(JmgJobId _jobIdAbsence = '')
    {
        JmgRegistrationParameters parameters = new JmgRegistrationParameters();

        parameters.jobIdAbsence(_jobIdAbsence);
        return parameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>makeFeedbackOnActiveJobs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides feedback on active jobs without making a stop registration on these jobs.
    /// </summary>
    /// <param name="_registrationDate">
    /// The registration date; optional.
    /// </param>
    /// <param name="_registrationTime">
    /// The registration time; optional.
    /// </param>
    /// <returns>
    /// Returns true if the user accepted the request for feedback. Returns false if the user canceled the
    /// request for feedback.
    /// </returns>
    /// <remarks>
    /// If the <paramref name="askForFeedback" /> parameter in the <c>JmgJobBundle.new</c> method was
    /// specified to true, the user is automatically prompted for feedback on the active jobs. Adding new
    /// jobs to the bundle, and then calling this method has no effect.
    /// </remarks>
    public boolean makeFeedbackOnActiveJobs(JmgDate _registrationDate = registrationDate, JmgTime _registrationTime = registrationTime)
    {
        MapIterator     mapIterator;
        JmgTermJob      job;
        JmgTermJob_Prod jobProd;
        Set             removedActiveJobs;
        Set             removedNewJobs;
        SetEnumerator   setEnumerator;

        registrationDate = _registrationDate;
        registrationTime = _registrationTime;

        // If any new jobs has been selected, then only give feedback on
        // those also in the active jobs map
        removedActiveJobs = new Set(Types::Class);
        removedNewJobs = new Set(Types::Class);

        Map copyOfActiveJobs = cloneMap(activeJobs);

        if (this.jobsAdded())
        {
            // we are going to modify activeJobs map, so we need to iterate over its copy.
            mapIterator = new MapIterator(copyOfActiveJobs);
            while (mapIterator.more())
            {
                job = mapIterator.value();
                if (!newJobs.exists(job.jobId()))
                {
                    activeJobs.remove(job.jobId());
                    removedActiveJobs.add(job);
                }
                else
                {
                    newJobs.remove(job.jobId());
                    removedNewJobs.add(job);
                }
                mapIterator.next();
            }

            // if none of the selected jobs are active jobs, then open the feedback form for all active jobs
            if (activeJobs.empty())
            {
                activeJobs = copyOfActiveJobs;
            }
        }

        boolean ret = this.requestFeedback(NoYes::No, true);

        if (ret)
        {
            if (JmgJobBundleFeedbackPostProcessingErrorHandlingExtensibilityFlight::instance().isEnabled())
            {
                ret = this.tryProcessOnFeedbackReceived();
            }
            else
            {
                try
                {
                    using(var activityContext = this.initInstrumentationParms(this.getOrCreateLogger().registration().makeFeedbackOnActiveJobs()))
                    {
                        ttsbegin;
                        mapIterator = this.getActiveJobsIterator();
                        while (mapIterator.more())
                        {
                            job = mapIterator.value();
                            job.makeFeedback(wrkCtrIdPilot ? 0 : worker, activeJobsParameters.lookup(job.jobId()), registrationDate, registrationTime);
                            mapIterator.next();
                        }

                        if (this.mustPostJournals())
                        {
                            this.postProductionJournals();
                            this.postTime();
                            this.printLabels();
                        }
                        else
                        {
                            this.calculateAndSaveTimeToPost();
                        }

                        ttscommit;
                    }
                }
                catch (Exception::Error)
                {
                    ret = false;
                    boolean requireFeedback = this.requireFeedback(false);
                    ttsbegin;
                    this.cancelProductionPostings(!requireFeedback);
                    ttscommit;
                    if (requireFeedback)
                    {
                        var errorMessage = "@SCM:JobFeedbackError";
                        SysInstrumentationLoggerFactory::CreateLogger(classStr(JmgJobBundle))
                                                    .logError(errorMessage);
                    
                        this.showErrorMessageOnFeedback(errorMessage);
                    }

                    this.reset();
                }
            }
        }
        else
        {
            ttsbegin;
            this.cancelProductionPostings();
            ttscommit;
        }

        // Restore activeJobs map
        setEnumerator = removedActiveJobs.getEnumerator();
        while (setEnumerator.moveNext())
        {
            job = setEnumerator.current();
            if (job.module() == JmgModuleEnum::PROD && inventDimId == InventDim::inventDimIdBlank())
            {
                jobProd = job;
                inventDimId = jobProd.siteInventDimId();
            }
            activeJobs.insert(job.jobId(), job);
        }

        // Restore newJobs map
        setEnumerator = removedNewJobs.getEnumerator();
        while (setEnumerator.moveNext())
        {
            job = setEnumerator.current();
            newJobs.insert(job.jobId(), job);
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tryProcessOnFeedbackReceived</Name>
				<Source><![CDATA[
    private boolean tryProcessOnFeedbackReceived()
    {
        #OCCRetryCount
        int infologLine = infologLine();

        boolean ret = true;

        try
        {
            this.onFeedbackReceived();
        }
        catch (Exception::Error)
        {
            if (ReqTransientSqlConnectionErrorHandlingHelper::isExceptionErrorCausedBySQLError(infologLine)
                && ReqTransientSqlConnectionErrorHandlingHelper::retryTransientSqlConnectionError())
            {
                retry;
            }
            else
            {
                ret = false;
                boolean requireFeedback = this.requireFeedback(false);
                ttsbegin;
                this.cancelProductionPostings(!requireFeedback);
                ttscommit;
                if (requireFeedback)
                {
                    var errorMessage = "@SCM:JobFeedbackError";
                    SysInstrumentationLoggerFactory::CreateLogger(classStr(JmgJobBundle))
                                                    .logError(errorMessage);
                    
                    this.showErrorMessageOnFeedback(errorMessage);
                }

                this.reset();
            }
        }
        catch (Exception::Deadlock)
        {
            retry;
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (ReqTransientSqlConnectionErrorHandlingHelper::retryTransientSqlConnectionError())
            {
                retry;
            }
            else
            {
                throw;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onFeedbackReceived</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes feedback post processing:
    /// - provides feedback on active job
    /// - optinally posts production journals
    /// - optinally posts time journals for the registrations made on this job bundle
    /// - optinally prints labels
    /// - optinally calculates and saves time to post
    /// </summary>
    protected void onFeedbackReceived()
    {
        using(var activityContext = this.initInstrumentationParms(this.getOrCreateLogger().registration().makeFeedbackOnActiveJobs()))
        {
            ttsbegin;
            MapIterator mapIterator = this.getActiveJobsIterator();
            while (mapIterator.more())
            {
                JmgTermJob job = mapIterator.value();
                job.makeFeedback(wrkCtrIdPilot ? 0 : worker, activeJobsParameters.lookup(job.jobId()), registrationDate, registrationTime);
                mapIterator.next();
            }

            if (this.mustPostJournals())
            {
                this.postProductionJournals();
                this.postTime();
                this.printLabels();
            }
            else
            {
                this.calculateAndSaveTimeToPost();
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showErrorMessageOnFeedback</Name>
				<Source><![CDATA[
    /// <summary>
    /// Shows an error message to users if the report progress failed.
    /// </summary>
    /// <param name = "_errorMessage">The error message to show to users.</param>
    protected void showErrorMessageOnFeedback(str _errorMessage)
    {
        if (!this.parmCallerForm() || 
             this.parmCallerForm().name() == formstr(JmgRegistration) ||
             this.parmCallerForm().name() == formstr(JmgRegistrationTouch))
        {
            Box::stop(_errorMessage);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>printLabels</Name>
				<Source><![CDATA[
    private void printLabels()
    {
        if (!jmgProdMultiReportFinished && JmgJobBundlePrintLabelsNullObjectFlight::instance().isEnabled())
        {
            return;
        }

        if (registrationSetup.PrintLabel)
        {
            MapIterator activeJobsIterator = this.getActiveJobsIterator();
            while (activeJobsIterator.more())
            {
                JmgTermJob job = activeJobsIterator.value();

                if (job.module() == JmgModuleEnum::PROD && job.jobRef())
                {
                    JmgTermJob_Prod prodJob = job;
                    ProdRoute prodRoute = prodJob.prodRoute();

                    if (prodRoute.OprPriority == RouteOprPriority::Primary &&
                        prodJob.prodJobType() == RouteJobType::Process &&
                        prodRoute.isLastOpr())
                    {
                        if (JmgPrintLicensePlateLabelCoByProductFlight::instance().isEnabled())
                        {
                            this.printAllLabelsFromProdParmReportFinished(prodJob);
                        }
                        else
                        {
                            ProdParmReportFinished prodParmReportFinished = ProdParmReportFinished::find(jmgProdMultiReportFinished.parmId(), prodJob.jobRef());

                            if (prodParmReportFinished && InventDim::find(prodParmReportFinished.InventDimId).LicensePlateId)
                            {
                                ProdLicensePlateLabelBuild licensePlateLabelBuild = new ProdLicensePlateLabelBuild(prodParmReportFinished, WHSWorkTransType::ProdPut);
                                licensePlateLabelBuild.parmJmgJobId(prodJob.jobId());

                                if (!FeatureStateProvider::isFeatureEnabled(ProdMultiLineReportAsFinishSerialNumFeature::instance()))
                                {
                                    WHSLabelId labelId = licensePlateLabelBuild.buildLicensePlateLabel();
                                    licensePlateLabelBuild.printLicensePlateLabel(labelId);
                                }
                                else if (prodParmReportFinished.QtyGood && !InventTable::find(prodParmReportFinished.ItemId).isItemSerialNumberActivated())
                                {
                                    WHSLabelId labelId = licensePlateLabelBuild.buildLicensePlateLabel(prodParmReportFinished.InventDimId, prodParmReportFinished.QtyGood);
                                    licensePlateLabelBuild.printLicensePlateLabel(labelId);
                                }
                                else if (JmgSerialNumberSpecification::existsByParmIdItemIdProdId(prodParmReportFinished.ParmId, prodParmReportFinished.ItemId, prodParmReportFinished.ProdId))
                                {
                                    this.printLicensePlateWithSerialNumbers(prodParmReportFinished, licensePlateLabelBuild);
                                }
                            }
                        }
                    }
                }
                activeJobsIterator.next();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>printAllLabelsFromProdParmReportFinished</Name>
				<Source><![CDATA[
    private void printAllLabelsFromProdParmReportFinished(JmgTermJob_Prod _prodJob)
    {
        ProdParmReportFinished prodParmReportFinished;
        while select prodParmReportFinished
                where prodParmReportFinished.ParmId  == jmgProdMultiReportFinished.parmId()   &&
                      prodParmReportFinished.ProdId  == _prodJob.jobRef()
        {
            if (prodParmReportFinished && InventDim::find(prodParmReportFinished.InventDimId).LicensePlateId)
            {
                WHSWorkTransType workTransType = (prodParmReportFinished.PmfProductType == PmfProductType::Co_Product || prodParmReportFinished.PmfProductType == PmfProductType::By_Product)? 
                    WHSWorkTransType::ProdProcessPut : WHSWorkTransType::ProdPut;

                ProdLicensePlateLabelBuild licensePlateLabelBuild = new ProdLicensePlateLabelBuild(prodParmReportFinished, workTransType);
                licensePlateLabelBuild.parmJmgJobId(_prodJob.jobId());

                if (!FeatureStateProvider::isFeatureEnabled(ProdMultiLineReportAsFinishSerialNumFeature::instance()))
                {
                    WHSLabelId labelId = licensePlateLabelBuild.buildLicensePlateLabel();
                    licensePlateLabelBuild.printLicensePlateLabel(labelId);
                }
                else if (prodParmReportFinished.QtyGood && !InventTable::find(prodParmReportFinished.ItemId).isItemSerialNumberActivated())
                {
                    WHSLabelId labelId = licensePlateLabelBuild.buildLicensePlateLabel(prodParmReportFinished.InventDimId, prodParmReportFinished.QtyGood);
                    licensePlateLabelBuild.printLicensePlateLabel(labelId);
                }
                else if (JmgSerialNumberSpecification::existsByParmIdItemIdProdId(prodParmReportFinished.ParmId, prodParmReportFinished.ItemId, prodParmReportFinished.ProdId))
                {
                    this.printLicensePlateWithSerialNumbers(prodParmReportFinished, licensePlateLabelBuild);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>printLicensePlateWithSerialNumbers</Name>
				<Source><![CDATA[
    private void printLicensePlateWithSerialNumbers(ProdParmReportFinished _prodParmReportFinished, ProdLicensePlateLabelBuild _licensePlateLabelBuild)
    {
        JmgSerialNumberSpecification jmgSerialNumberSpecification;

        while select InventDimId, QtyGood from  jmgSerialNumberSpecification where
                                       jmgSerialNumberSpecification.ParmId == _prodParmReportFinished.ParmId
                                    && jmgSerialNumberSpecification.ProdId == _prodParmReportFinished.ProdId
                                    && jmgSerialNumberSpecification.ItemId == _prodParmReportFinished.ItemId
                                    && jmgSerialNumberSpecification.QtyGood > 0
        {
            WHSLabelId labelId = _licensePlateLabelBuild.buildLicensePlateLabel(jmgSerialNumberSpecification.InventDimId, jmgSerialNumberSpecification.QtyGood);
            _licensePlateLabelBuild.printLicensePlateLabel(labelId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>makeRegistrations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides registrations on the added jobs.
    /// </summary>
    /// <param name="_registrationDate">
    /// The registration date; optional.
    /// </param>
    /// <param name="_registrationTime">
    /// The registration time; optional.
    /// </param>
    /// <returns>
    /// true if the user accepted feedback and startup prompts. If the user canceled either of the prompts,
    /// false is returned.
    /// </returns>
    /// <remarks>
    /// If the <c>JmgJobBundle.continueBundle</c> parameter is set to false, a stop registration is made
    /// for each active job. If the <paramref name="askForFeedback" /> parameter specified in the
    /// <c>JmgJobBundle.new</c> method is true, the user is automatically prompted for feedback parameters
    /// and startup parameters. If the user cancels either feedback or startup prompts, no registrations
    /// are made. If no jobs were added to the bundle before the makeRegistrations method is called, no
    /// registrations are made, and true is returned. After an invocation of this method, the bundle is
    /// considered to be committed, and no jobs can be added, removed, and no more registrations can be
    /// made.
    /// </remarks>
    public boolean makeRegistrations(JmgDate _registrationDate = registrationDate, JmgTime _registrationTime = registrationTime)
    {
        boolean ret;

        boolean requireFeedback;

        registrationsCancelledByUser = false;

        this.bundleCommitted();

        ret = true;

        if (newJobs.elements() == 0 && partialStartupParameters.elements() == 0)
        {
            return ret;
        }

        registrationDate = _registrationDate;
        registrationTime = _registrationTime;

        this.checkRegistrationTime();
        this.checkPilot();

        ret = this.requestStartupInfo();
        if (ret)
        {
            ret = this.requestFeedback(NoYes::Yes);
        }

        if (ret)
        {
            try
            {
                using(var activityContext = this.initInstrumentationParms(this.getOrCreateLogger().registration().makeRegistrations()))
                {
                    ttsbegin;
                    showMessage = false;
                    activityContext.addCustomProperty(JmgRegistrationInstrumentationActivities::ParmJmgBundleType, enum2Symbol(enumNum(JmgJobBundleType), bundleType));

                    switch (bundleType)
                    {
                        case JmgJobBundleType::IPC:
                            this.makeRegistrationsIPC();
                            break;
                        case JmgJobBundleType::Prod:
                            this.makeRegistrationsProd();
                            break;
                        case JmgJobBundleType::Proj:
                            this.makeRegistrationsProj();
                            break;
                        case JmgJobBundleType::Absence:
                            this.makeRegistrationsAbsence();
                            break;
                        case JmgJobBundleType::BreakReg:
                            this.makeRegistrationsBreak();
                            break;
                        case JmgJobBundleType::EventCode:
                            this.makeRegistrationsEventCode();
                            break;
                        default:
                            break;
                    }

                    if (this.mustPostJournals())
                    {
                        this.postProductionJournals();
                        this.postTime();
                        if (JmgJobBundlePrintLabelsFlight::instance().isEnabled())
                        {
                            this.printLabels();
                        }
                    }
                    else
                    {
                        this.calculateAndSaveTimeToPost();
                    }

                    ttscommit;
                    if (showMessage)
                    {
                        this.showClockInfo();
                    }
                    bundleCommitted = true;

                    // BOM journals:
                    if (jmgProdMultiStartUp)
                    {
                        if (JmgPFEOpenPickingListOnStartUpFlight::instance().isEnabled())
                        {
                            this.afterPostProdMultiStartUp(jmgProdMultiStartUp.parmId(), inventDimId);
                        }
                        else
                        {
                            JmgPostStandardSystem::showBOMJournalOnStartUp(jmgProdMultiStartUp.parmId(), inventDimId);
                        }
                    }
                }
            }
            catch (Exception::Error)
            {
                ret = false;
                requireFeedback = this.requireFeedback(false);
                ttsbegin;
                this.cancelProductionPostings(!requireFeedback);
                ttscommit;
                if (requireFeedback)
                {
                    Box::stop("@SCM:JobFeedbackError");
                }
            }
        }
        else
        {
            ttsbegin;
            this.cancelProductionPostings();
            ttscommit;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustOpenBOMJournalList</Name>
				<Source><![CDATA[
    protected boolean mustOpenBOMJournalList()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>afterPostProdMultiStartUp</Name>
				<Source><![CDATA[
    protected void afterPostProdMultiStartUp(ProdParmId _prodParmId, InventDimId _inventDimId)
    {
        if (this.mustOpenBOMJournalList())
        {
            JmgPostStandardSystem::showBOMJournalOnStartUp(jmgProdMultiStartUp.parmId(), inventDimId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustPostJournals</Name>
				<Source><![CDATA[
    private boolean mustPostJournals()
    {
        return !JmgManufacturingExecutionWorkloadConfigurationProvider::isManufacturingExecutionWorkloadEnabled() ||
                JmgManufacturingExecutionWorkloadConfigurationProvider::isRunningOnHub();
    }

]]></Source>
			</Method>
			<Method>
				<Name>makeRegistrationsAbsence</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a registration on an absence job.
    /// </summary>
    /// <remarks>
    /// Part of the <c>makeRegistrations</c> procedure. If the added job is an absence job, this method is
    /// called when registrations are made. If an absence job was added to the bundle, either a clock in
    /// registration or a clock out registration is made, depending on the employee's clock in status. The
    /// absence job ID is used as the absence job ID on the clock in and clock out registration.
    /// </remarks>
    private void makeRegistrationsAbsence()
    {
        JmgTermJob absenceJob;
        absenceJob = new MapIterator(newJobs).value();
        if (JmgTermReg::getCurSignInTime(worker))
        {
            this.makeClockOutRegistration(absenceJob.jobId());
        }
        else
        {
            this.makeClockInRegistration(true, true, absenceJob.jobId());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>makeRegistrationsBreak</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a registration on a break job ID.
    /// </summary>
    /// <remarks>
    /// Part of the <c>makeRegistrations</c> procedure. If the added job is a break job, this method is
    /// called when registrations are made. Creating a registration on a break job does not stop active
    /// jobs, regardless of the <see cref="M:JmgJobBundle.continueBundle" /> setting.
    /// </remarks>
    private void makeRegistrationsBreak()
    {
        this.ensureClockInStatus(true, true);
        this.stopActiveBreaks();
        this.startNewJobs();
    }

]]></Source>
			</Method>
			<Method>
				<Name>makeRegistrationsEventCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates registrations on a switch code, which has been added to the bundle.
    /// </summary>
    private void makeRegistrationsEventCode()
    {
        this.ensureClockInStatus(true, true);
        this.startNewJobs();
    }

]]></Source>
			</Method>
			<Method>
				<Name>makeRegistrationsIPC</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a registration on an IPC job.
    /// </summary>
    /// <remarks>
    /// Part of the make registration procedure. If the added job is an IPC job, this method is called when
    /// registrations are made. Some IPC jobs represents system jobs, such as clock in, clock out, start
    /// team, stop team, and change pilot. Registrations on these jobs are also handled by this method.
    /// </remarks>
    public void makeRegistrationsIPC()
    {
        #JmgSignIn

        JmgTermJob ipcJob;

        using(var activityContext = this.initInstrumentationParms(this.getOrCreateLogger().registration().makeRegistrationsIPC()))
        {
            ipcJob = new MapIterator(newJobs).value();
            activityContext.addCustomProperty(JmgRegistrationInstrumentationActivities::ParmJmgStampType, enum2Symbol(enumNum(JmgStampTypeEnum), ipcJob.stampType()));

            switch (ipcJob.stampType())
            {
                case JmgStampTypeEnum::Absence:
                    throw error("@SYS39897");
                case JmgStampTypeEnum::Error:
                case JmgStampTypeEnum::EventCode:
                    this.ensureClockInStatus(true, true);
                    this.startNewJobs();
                    break;
                case JmgStampTypeEnum::OnCall:
                    this.ensureClockInStatus(true, true);
                    this.startNewJobs();
                    break;
                case JmgStampTypeEnum::Work:
                    activityContext.addCustomProperty(JmgRegistrationInstrumentationActivities::ParmJmgSignType, enum2Symbol(enumNum(JmgSignInOut), ipcJob.signType()));
                    switch (ipcJob.signType())
                    {
                        case JmgSignInOut::Job:
                        case JmgSignInOut::StartTeam:
                            this.ensureClockInStatus(false, false);
                        case JmgSignInOut::StopTeam:
                            if (this.mustStopActiveJobs(ipcJob.signType()))
                            {
                                this.stopActiveJobs();
                            }
                            this.startNewJobs();
                            break;
                        case JmgSignInOut::SignIn:
                        if (JmgTermReg::getCurSignInTime(worker))
                            {
                                throw error(strFmt("@SYS39332", HcmWorker::find(worker).PersonnelNumber));
                            }
                            this.makeClockInRegistration(true, true, this.getStartupParameters(ipcJob.jobId()).jobIdAbsence());
                            break;
                        case JmgSignInOut::SignOut:
                        if (!JmgTermReg::getCurSignInTime(worker))
                            {
                                throw error(strFmt("@SYS39333", HcmWorker::find(worker).PersonnelNumber));
                            }
                            if (this.mustStopActiveJobs(ipcJob.signType()))
                            {
                                this.stopActiveJobs(!registrationSetup.SignOutFeedback);
                            }
                            this.makeClockOutRegistration(this.getStartupParameters(ipcJob.jobId()).jobIdAbsence());
                            break;
                        case JmgSignInOut::SubmitPilote:
                            this.makeChangePilotRegistrations(newJobsParameters.lookup(ipcJob.jobId()));
                            break;
                        case JmgSignInOut::StopBreak:
                            this.startNewJobs();
                            break;
                        // Do nothing:
                        case JmgSignInOut::Clear:
                        case JmgSignInOut::Info:
                        case JmgSignInOut::Submit:
                        case JmgSignInOut::SwitchBundleMode:
                        case JmgSignInOut::SysIndirect:
                        default:
                            break;
                    }
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustStopAndStartJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the job must be stopped and started.
    /// </summary>
    /// <returns>true if the job must be stopped and started.</returns>
    protected boolean mustStopAndStartJob()
    {
        MapIterator newJobsIterator = new MapIterator(newJobs);
        boolean partialStartup = true;
        while (newJobsIterator.more() && partialStartup)
        {
            JmgTermJob job = newJobsIterator.value();
            partialStartup = activeJobs.exists(job.jobId());
            newJobsIterator.next();
        }

        return !continueBundle && !partialStartup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>makeRegistrationsProd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates registrations on production jobs.
    /// </summary>
    /// <remarks>
    /// Part of the registration procedure. If one or more production jobs were added to the job bundle,
    /// this method is called when it makes registrations. Depending on the <see
    /// cref="M:JmgJobBundle.continueBundle" /> parameter, active jobs are stopped, and the added jobs are
    /// started.
    /// </remarks>
    private void makeRegistrationsProd()
    {
        boolean registerAsWrkCtr = this.registerAsWrkCtr();

        if (registerAsWrkCtr)
        {
            this.setWrkCtrPilot(wrkCtrIdPilot);
        }

        this.ensureClockInStatus(false, false);

        if (this.mustStopAndStartJob())
        {
            // Check startup parameters:
            MapIterator newJobsIterator = new MapIterator(newJobsParameters);
            while (newJobsIterator.more())
            {
                JmgRegistrationParameters regParams = newJobsIterator.value();
                JmgProdStartup::validateStartupQuantity(regParams.startQuantity(), newJobsIterator.key(), this);
                newJobsIterator.next();
            }

            this.stopActiveJobs();
            this.startNewJobs();
        }
        else
        {
            // Stop active breaks
            this.stopActiveBreaks();

            boolean isJmgJobBundleMakeRegistrationsRefactoringFlightEnabled = JmgJobBundleMakeRegistrationsRefactoringFlight::instance().isEnabled();

            MapIterator newJobsIterator = new MapIterator(newJobs);
            while (newJobsIterator.more())
            {
                if (isJmgJobBundleMakeRegistrationsRefactoringFlightEnabled)
                {
                    this.makeOrUpdateRegistrationProdForJob(newJobsIterator.value(), registerAsWrkCtr);
                }
                else
                {
                    JmgTermJob job = newJobsIterator.value();
                    JmgRegistrationParameters regParams = newJobsParameters.lookup(job.jobId());
                    if (activeJobs.exists(job.jobId()))
                    {
                        // Partial started will be processed separately in the loop below
                        if (!partialStartupParameters.exists(job.jobId()))
                        {
                            JmgTermReg jmgTermReg;

                            // Find last active term register on this job, and add the start quantity
                            if (registerAsWrkCtr)
                            {
                                select firstonly forupdate jmgTermReg
                                    where jmgTermReg.WrkCtrIdPilot  == wrkCtrIdPilot
                                        && jmgTermReg.JobId         == job.jobId()
                                        && jmgTermReg.JobActive     == NoYes::Yes;
                            }
                            else
                            {
                                select firstonly forupdate jmgTermReg
                                    where jmgTermReg.Worker     == worker
                                        && jmgTermReg.JobId     == job.jobId()
                                        && jmgTermReg.JobActive == NoYes::Yes;
                            }
                            jmgTermReg.StartItems += regParams.startQuantity();
                            jmgTermReg.PdsCWStartItems += regParams.pdsCWStartQuantity();
                            JmgProdStartup::validateStartupQuantity(regParams.startQuantity(), job.jobId(), this);
                            jmgTermReg.update();
                        }
                    }
                    else
                    {
                    // Make a start registration.
                    JmgProdStartup::validateStartupQuantity(regParams.startQuantity(), job.jobId(), this);
                        job.makeRegistration(registerAsWrkCtr ? 0 : worker, registrationDate, registrationTime, true, regParams);
                    }
                }

                newJobsIterator.next();
            }

            MapIterator partialStartupIterator = new MapIterator(partialStartupParameters);
            while (partialStartupIterator.more())
            {
                JmgRegistrationParameters regParams = partialStartupIterator.value();     
   
                if (isJmgJobBundleMakeRegistrationsRefactoringFlightEnabled)
                {
                    this.udpateRegistrationProd(regParams, partialStartupIterator.key(), registerAsWrkCtr, true);
                }
                else
                {
                    JmgTermReg jmgTermReg;
        
                    // Find last active termreg on this job, and add the start quantity
                    if (registerAsWrkCtr)
                    {
                        select firstonly forupdate jmgTermReg
                            where jmgTermReg.WrkCtrIdPilot  == wrkCtrIdPilot
                                && jmgTermReg.JobId         == partialStartupIterator.key()
                                && jmgTermReg.JobActive     == NoYes::Yes;
                    }
                    else
                    {
                        select firstonly forupdate jmgTermReg
                            where jmgTermReg.Worker     == worker
                                && jmgTermReg.JobId     == partialStartupIterator.key()
                                && jmgTermReg.JobActive == NoYes::Yes;
                    }
                    jmgTermReg.StartItems += regParams.startQuantity();
                    jmgTermReg.PdsCWStartItems += regParams.pdsCWStartQuantity();
                    JmgProdStartup::validateStartupQuantity(jmgTermReg.StartItems, partialStartupIterator.key(), this);
                    jmgTermReg.update();
                }

                partialStartupIterator.next();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>makeOrUpdateRegistrationProdForJob</Name>
				<Source><![CDATA[
    protected void makeOrUpdateRegistrationProdForJob(JmgTermJob _job, boolean _registerAsWrkCtr)
    {
        JmgRegistrationParameters regParams = newJobsParameters.lookup(_job.jobId());
        if (activeJobs.exists(_job.jobId()))
        {
            // Partial started will be processed separately
            if (!partialStartupParameters.exists(_job.jobId()))
            {
                this.udpateRegistrationProd(regParams, _job.jobId(), _registerAsWrkCtr, false);
            }
        }
        else
        {
            // Make a start registration.
            JmgProdStartup::validateStartupQuantity(regParams.startQuantity(), _job.jobId(), this);
            _job.makeRegistration(_registerAsWrkCtr ? 0 : worker, registrationDate, registrationTime, true, regParams);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>udpateRegistrationProd</Name>
				<Source><![CDATA[
    protected void udpateRegistrationProd(
        JmgRegistrationParameters _regParams,
        JmgJobId _jobId,
        boolean _registerAsWrkCtr,
        boolean _validateRegistrationStartItemsQuantity)
    {
        // Find last active termreg on this job, and add the start quantity
        JmgTermReg jmgTermReg = this.findLastActiveRegistrationByJobId(_jobId, _registerAsWrkCtr);
        jmgTermReg.StartItems += _regParams.startQuantity();
        jmgTermReg.PdsCWStartItems += _regParams.pdsCWStartQuantity();

        Qty quantityToValidate = _validateRegistrationStartItemsQuantity ? jmgTermReg.StartItems : _regParams.startQuantity();
        JmgProdStartup::validateStartupQuantity(quantityToValidate, _jobId, this);

        jmgTermReg.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLastActiveRegistrationByJobId</Name>
				<Source><![CDATA[
    protected JmgTermReg findLastActiveRegistrationByJobId(JmgJobId _jobId, boolean _registerAsWrkCtr)
    {
        JmgTermReg jmgTermReg;

        if (_registerAsWrkCtr)
        {
            select firstonly forupdate jmgTermReg
                where jmgTermReg.WrkCtrIdPilot  == wrkCtrIdPilot
                   && jmgTermReg.JobId         == _jobId
                   && jmgTermReg.JobActive     == NoYes::Yes;
        }
        else
        {
            select firstonly forupdate jmgTermReg
                where jmgTermReg.Worker     == worker
                   && jmgTermReg.JobId     == _jobId
                   && jmgTermReg.JobActive == NoYes::Yes;
        }

        return jmgTermReg;
    }

]]></Source>
			</Method>
			<Method>
				<Name>makeRegistrationsProj</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates registrations on project jobs.
    /// </summary>
    /// <remarks>
    /// Part of the registration procedure. If a project job was added to the job bundle, this method is
    /// called when registrations are made. Depending on the <see cref="M:JmgJobBundle.continueBundle" />
    /// parameter, active jobs are stopped and the added job is started. If the employee is currently
    /// clocked out, a clock in registration is made.
    /// </remarks>
    private void makeRegistrationsProj()
    {
        if (this.registerAsWrkCtr())
        {
            this.setWrkCtrPilot(wrkCtrIdPilot);
        }

        this.ensureClockInStatus(false, false);
        this.stopActiveJobs();
        this.startNewJobs();
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>JmgJobBundle</c> class.
    /// </summary>
    /// <param name="_worker">
    /// The worker that is making registrations.
    /// </param>
    /// <param name="_continueBundle">
    /// A Boolean value that specifies whether the bundle must be continued.
    /// </param>
    /// <param name="_askForFeedback">
    /// A Boolean value that specifies whether the worker must be asked for feedback.
    /// </param>
    /// <param name="_showInfo">
    /// true if information about the registration process must be shown to the user; otherwise, false.
    /// </param>
    /// <param name="_registrationSetup">
    /// The ID of the registration setup, which is used when registrations are created.
    /// </param>
    /// <param name="_sysDateTime">
    /// The system date and time.
    /// </param>
    /// <remarks>
    ///  That is, should be shown.There are three situations where feedback from the user is required
    ///  regarding the <paramref name="_askForFeedback" />
    ///   parameter:
    ///  <list type="bullet">
    ///   <item>
    ///   <description>If the user has been clocked in for too long, a missing clock out dialog box is
    ///   shown.</description>
    ///   </item>
    ///   <item>
    ///   <description>If the user stops working on jobs that require feedback information.</description>
    ///   </item>
    ///   <item>
    ///   <description>If the user starts working on jobs that require startup information.</description>
    ///   </item>
    ///  </list>
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    /// The worker is not an active registration worker
    /// </exception>
    public void new(
        JmgWorkerRecId          _worker,
        boolean                 _continueBundle         = false,
        boolean                 _askForFeedback         = true,
        boolean                 _showInfo               = true,
        JmgRegistrationSetup    _registrationSetup      = null,
        utcdatetime             _sysDateTime            = utcDateTimeNull())
    {
        JmgEmployee         jmgEmployee;
        HcmWorker           hcmWorker;

        worker              = _worker;
        sysDateTime         = _sysDateTime;

        // Check that employee is active.
        jmgEmployee         = JmgEmployee::find(worker);
        hcmWorker           = HcmWorker::find(worker);
        if (jmgEmployee    &&
            jmgEmployee.Active == NoYes::No)
        {
            throw error("@SYS327447");
        }
        else if (jmgEmployee    && jmgEmployee.Active == NoYes::Yes)
        {
            taEnabled = isConfigurationkeyEnabled(configurationKeyNum(Jmg));
        }
        else
        {
            throw error("@SYS327448");
        }
        super();

        askForFeedback      = _askForFeedback;
        showInfo            = _showInfo;
        registrationSetup   = _registrationSetup;

        // set the registration time to the specified one, or to the current time if it left unspecified
        if(_sysDateTime == utcDateTimeNull())
        {
            this.resetRegistrationTime();
        }
        else
        {
            registrationDate    = DateTimeUtil::date(sysDateTime);
            registrationTime    = DateTimeUtil::time(sysDateTime);
        }

        this.reset();
        this.continueBundle(_continueBundle);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAutostamp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the autostamp value that is used to determine if registration is done by the system.
    /// </summary>
    /// <param name="_autostamp">
    /// Get's value of the autostamp.
    /// </param>
    /// <returns>
    /// Returns NoYes value of the autostamp value.
    /// </returns>
    public NoYes parmAutostamp(boolean _autostamp = autostamp)
    {
        autostamp = _autostamp;
        return autostamp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCallerForm</Name>
				<Source><![CDATA[
    public FormRun parmCallerForm(FormRun _callerForm = callerForm)
    {
        callerForm = _callerForm;
        return callerForm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmResourceRegistration</Name>
				<Source><![CDATA[
    public boolean parmResourceRegistration(boolean _value = resourceRegistration)
    {
        if (_value != resourceRegistration)
        {
            resourceRegistration = _value;
            activeJobs                      = new Map(Types::String, Types::Class);
            activeJobsParameters            = new Map(Types::String, Types::Class);
            activeJobsExistingParameters    = new Map(Types::String, Types::Class);

            this.loadActiveJobs();
        }
        return resourceRegistration;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postProductionJournals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts any production journals created during the production process.
    /// </summary>
    protected void postProductionJournals()
    {
        ProdJournalCheckPost statusQtyProdJournalCheckPost;
        ListEnumerator enumerator;

        using(var activityContext = this.initInstrumentationParms(this.getOrCreateLogger().registration().postProductionJournals()))
        {
            JmgProdParametersDim jmgProdParametersDim = JmgProdParametersDim::find(inventDimId);

            this.logActivityParms_JmgProdParametersDim(activityContext, jmgProdParametersDim);

            // Status quantity:
            if (statusQtyProdJournalCheckPostList && jmgProdParametersDim.StatusQtyPostAutomatically == NoYes::Yes)
            {
                using(var activityContextChild = this.initInstrumentationParms(this.getOrCreateLogger().registration().autoPostQtyProdJournal()))
                {
                    ProdJournalRoute prodJournalRoute;
                    enumerator = statusQtyProdJournalCheckPostList.getEnumerator();

                    while (enumerator.moveNext())
                    {
                        statusQtyProdJournalCheckPost = enumerator.current();
                        update_recordset prodJournalRoute
                    setting TransDate = registrationDate,
                            FromTime  = this.getRealizedStartTime(statusQtyProdJournalCheckPost.parmJournalId()),
                            ToTime    = registrationTime
                    where prodJournalRoute.JournalId    == statusQtyProdJournalCheckPost.parmJournalId();

                        statusQtyProdJournalCheckPost.runOperation();
                    }
                }
            }

            // BOM journals associated to Status quantity:
            if (jmgProdParametersDim.BOMPostAutomatically  == NoYes::Yes)
            {
                using(var activityContextChild = this.initInstrumentationParms(this.getOrCreateLogger().registration().autoPostPickListJournal()))
                {
                    MapIterator feedbackIterator = new MapIterator(activeJobsParameters);
                    JmgJobBundle::iterateFeedback(feedbackIterator);
                }
            }

            if (jmgProdMultiReportFinished)
            {
                using(var activityContextChild = this.initInstrumentationParms(this.getOrCreateLogger().registration().autoPostRafJournal()))
                {
                    jmgProdMultiReportFinished.runOperation();
                }
            }

            // Post multi-lines RAF journals
            if (!FeatureStateProvider::isFeatureEnabled(ProdMultiLineReportAsFinishSerialNumFeature::instance()) && reportFinishedMultiLineJournalCheckPostList && jmgProdParametersDim.ReportFinishStatus != JmgProdStatusUpdateReportFinished::No)
            {
                using(var activityContextChild = this.initInstrumentationParms(this.getOrCreateLogger().registration().autoPostMultiLineRafJournal()))
                {
                    ProdJournalCheckPost reportFinishedMultiLineJournalCheckPost;
                    enumerator = reportFinishedMultiLineJournalCheckPostList.getEnumerator();

                    using (var context = WHSUseMixedLPPutawayForProductionRAFContext::construct())
                    {
                        while (enumerator.moveNext())
                        {
                            reportFinishedMultiLineJournalCheckPost = enumerator.current();
                            reportFinishedMultiLineJournalCheckPost.runOperation();
                        }
                    }
                }
            }

            if (jmgProdMultiStartUp)
            {
                using(var activityContextChild = this.initInstrumentationParms(this.getOrCreateLogger().registration().autoPostStartUpJournal()))
                {
                    jmgProdMultiStartUp.runOperation();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts time journals for the registrations made on this job bundle.
    /// </summary>
    void postTime()
    {
        this.postOrSaveTime(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateAndSaveTimeToPost</Name>
				<Source><![CDATA[
    private void calculateAndSaveTimeToPost()
    {
        this.postOrSaveTime(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postOrSaveTime</Name>
				<Source><![CDATA[
    private void postOrSaveTime(boolean _postNow)
    {
        JmgPostStandardSystem       jmgPostStandardSystem;
        MapIterator                 activeJobsIterator;
        JmgRegistrationParameters   regParams;
        JmgStampJournalTrans        jmgStampJournalTransTmp;
        JmgTermJob                  job;
        boolean                     registerAsWrkCtr = this.registerAsWrkCtr();

        if (_postNow)
        {
            jmgPostStandardSystem   = JmgPostStandardSystem::construct();
            if (registerAsWrkCtr)
            {
                jmgPostStandardSystem.parmWrkCtrPilot(wrkCtrIdPilot);
            }
            else
            {
                jmgPostStandardSystem.parmWorker(worker);
            }
        }

        jmgStampJournalTransTmp.setTmp();

        // Find all registrations which intersects with the ones made now.
        JmgAllocateTime jmgAllocateTime = this.calculateAllocationForIntersectingRegistrations(jmgStampJournalTransTmp);

        activeJobsIterator      = this.getActiveJobsIterator();
        while (activeJobsIterator.more())
        {
            job = activeJobsIterator.value();

            regParams = this.getFeedbackParameters(activeJobsIterator.key());
            if (this.mustPostTimeForJobRegistrations(regParams, job))
            {
                select firstonly jmgStampJournalTransTmp
                    where jmgStampJournalTransTmp.JobId            == activeJobsIterator.key()
                        && jmgStampJournalTransTmp.Worker          == worker
                        && jmgStampJournalTransTmp.WrkCtrIdPilot   == wrkCtrIdPilot
                        && jmgStampJournalTransTmp.StopDate        == registrationDate
                        && jmgStampJournalTransTmp.StopTime        == registrationTime;

                if (jmgStampJournalTransTmp)
                {
                    if (job.module() == JmgModuleEnum::PROJ)
                    {
                        regParams.costCategory(this.getJobStartedParameters(job.jobId()).costCategory());
                    }

                    Hours allocatedTime = jmgAllocateTime.getTime(jmgStampJournalTransTmp.TableId, jmgStampJournalTransTmp.RecId) * 3600;
                    allocatedTime = allocatedTime < 1.0 && allocatedTime > 0.0 ? 1 : allocatedTime;
                    jmgStampJournalTransTmp.Seconds    = real2int(allocatedTime);
                    
                    if (jmgPostStandardSystem)
                    {
                        jmgPostStandardSystem.addJob(activeJobsIterator.value(), regParams, jmgStampJournalTransTmp);
                    }
                    jmgStampJournalTransTmp.doUpdate();

                    if (jmgStampJournalTransTmp.TermRegStopRecID)
                    {
                        JmgTermReg stopTermReg = JmgTermReg::find(jmgStampJournalTransTmp.TermRegStopRecID, !_postNow);
                        if (_postNow)
                        {
                            int64 timeSpan = DateTimeUtil::getDifference(DateTimeUtil::newDateTime(jmgStampJournalTransTmp.StopDate, jmgStampJournalTransTmp.StopTime),
                                                            DateTimeUtil::newDateTime(jmgStampJournalTransTmp.StartDate, jmgStampJournalTransTmp.StartTime));
                            if (timeSpan)
                            {
                                stopTermReg.updateTeamJournal(jmgStampJournalTransTmp.Seconds / timeSpan);
                            }
                        }
                        else
                        {
                            stopTermReg.updateSeconds(jmgStampJournalTransTmp.Seconds);
                            stopTermReg.update();
                        }
                    }
                }
            }

            activeJobsIterator.next();
        }
        
        if (jmgPostStandardSystem)
        {
            jmgPostStandardSystem.postTime();
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateAllocationForIntersectingRegistrations</Name>
				<Source><![CDATA[
    private JmgAllocateTime calculateAllocationForIntersectingRegistrations(JmgStampJournalTrans _jmgStampJournalTransTmp)
    {
        JmgAllocateTime jmgAllocateTime = JmgAllocateTime::construct();
        JmgDateTime dateTime = DateTimeUtil::newDateTime(registrationDate, registrationTime, DateTimeUtil::getUserPreferredTimeZone());

        JmgTermReg startJob;
        JmgTermReg stopJob;

        // Calculate time for all registrations which are stopped now
        while select startJob
            where (startJob.Worker          == worker
                || (startJob.Worker         == 0
                &&  startJob.WrkCtrIdPilot  == wrkCtrIdPilot))
                && startJob.RegType         == JmgTermRegType::JobStart
                && startJob.RegDateTime     <= dateTime
            join  stopJob
            where startJob.RecId            == stopJob.MatchRecIdStartStop
                && stopJob.RegType          == JmgTermRegType::JobStop
                && stopJob.RegDateTime      >= dateTime

        {
            _jmgStampJournalTransTmp.clear();

            this.initializeJmgStampJournalTransForIntersectingRegistration(_jmgStampJournalTransTmp, startJob, stopJob, dateTime);

            _jmgStampJournalTransTmp.insert();

            jmgAllocateTime.addRegistration(
                _jmgStampJournalTransTmp.TableId,
                _jmgStampJournalTransTmp.RecId,
                startJob.RegDateTime,
                stopJob.RegDateTime ? stopJob.RegDateTime : dateTime,
                JmgTermJob::construct(startJob.JobId).estimatedHours(),
                JmgBundleSlize::findAllocationKey(startJob.ResNo, _jmgStampJournalTransTmp.ProfileDate) - 1);
        }

        // Add any which are still active
        while select startJob
            where (startJob.Worker          == worker
                || (startJob.Worker         == 0
                &&  startJob.WrkCtrIdPilot  == wrkCtrIdPilot))
                && startJob.RegType         == JmgTermRegType::JobStart
                && startJob.RegDateTime     <  dateTime
                && startJob.JobActive       == NoYes::Yes
        {
            _jmgStampJournalTransTmp.clear();

            this.initializeJmgStampJournalTransForCurrentActiveRegistration(_jmgStampJournalTransTmp, startJob, dateTime);

            _jmgStampJournalTransTmp.insert();

            jmgAllocateTime.addRegistration(
                _jmgStampJournalTransTmp.TableId,
                _jmgStampJournalTransTmp.RecId,
                startJob.RegDateTime,
                stopJob.RegDateTime ? stopJob.RegDateTime : dateTime,
                JmgTermJob::construct(startJob.JobId).estimatedHours(),
                JmgBundleSlize::findAllocationKey(startJob.ResNo, _jmgStampJournalTransTmp.ProfileDate) - 1);
        }

        return JmgAllocateTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustPostTimeForJobRegistrations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to continue time posting for a specific job.
    /// </summary>
    /// <param name="_regParams">
    /// The feedback parameters to check.
    /// </param>
    /// <param name="_job">
    /// The active job to check.
    /// </param>
    /// <returns>
    /// true if continue time posting ; otherwise, false.
    /// </returns>
    [SuppressBpWarning("BPParameterNotUsed", "Parameter _job is used by extensions that wrap this method.")]
    protected boolean mustPostTimeForJobRegistrations(JmgRegistrationParameters _regParams, JmgTermJob _job)
    {
        return (_regParams.reportAsFinished() == JmgFeedbackStatus::Stopped
                || _regParams.reportAsFinished() == JmgFeedbackStatus::Completed);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustStopActiveJobs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Decides if we need to stop active jobs.
    /// </summary>
    /// <param name = "_signType">The type of the job.</param>
    /// <returns>Returns true if the stopActiveJobs method must be called; otherwise false.</returns>
    protected boolean mustStopActiveJobs(JmgSignInOut _signType)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeJmgStampJournalTransForIntersectingRegistration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the time journal record for intersecting registration.
    /// </summary>
    /// <param name="_jmgStampJournalTransTmp">
    /// The time journal record, which will be posted.
    /// </param>
    /// <param name="_startJob">
    /// The raw time registration record that has the information when the job started.
    /// </param>
    /// <param name="_stopJob">
    /// The raw time registration record that has the information when the job stopped.
    /// </param>
    /// <param name="_registrationDateTime">
    /// Registration time information for the time journal record, which will be posted.
    /// </param>
    protected void initializeJmgStampJournalTransForIntersectingRegistration(
        JmgStampJournalTrans _jmgStampJournalTransTmp,
        JmgTermReg _startJob,
        JmgTermReg _stopJob,
        JmgDateTime _registrationDateTime)
    {
        _jmgStampJournalTransTmp.Worker         = worker;
        _jmgStampJournalTransTmp.WrkCtrIdPilot  = wrkCtrIdPilot;
        _jmgStampJournalTransTmp.ProfileDate    = _startJob.ProfileDate;
        _jmgStampJournalTransTmp.StartDate      = DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(_startJob.RegDateTime, DateTimeUtil::getUserPreferredTimeZone()));
        _jmgStampJournalTransTmp.StartTime      = DateTimeUtil::time(DateTimeUtil::applyTimeZoneOffset(_startJob.RegDateTime, DateTimeUtil::getUserPreferredTimeZone()));
        _jmgStampJournalTransTmp.StopDate       = DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(_stopJob ? _stopJob.RegDateTime : _registrationDateTime, DateTimeUtil::getUserPreferredTimeZone()));
        _jmgStampJournalTransTmp.StopTime       = DateTimeUtil::time(DateTimeUtil::applyTimeZoneOffset(_stopJob ? _stopJob.RegDateTime : _registrationDateTime, DateTimeUtil::getUserPreferredTimeZone()));
        _jmgStampJournalTransTmp.JobId          = _startJob.JobId;
        _jmgStampJournalTransTmp.TermRegStartRecID = _startJob.RecId;
        _jmgStampJournalTransTmp.TermRegStopRecID  = _stopJob.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeJmgStampJournalTransForCurrentActiveRegistration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the time journal record for current active registration.
    /// </summary>
    /// <param name="_jmgStampJournalTransTmp">
    /// The time journal record, which will be posted.
    /// </param>
    /// <param name="_startJob">
    /// The raw time registration record that has the information when the job started.
    /// </param>
    /// <param name="_registrationDateTime">
    /// Registration time information for the time journal record, which will be posted.
    /// </param>
    protected void initializeJmgStampJournalTransForCurrentActiveRegistration(
        JmgStampJournalTrans _jmgStampJournalTransTmp,
        JmgTermReg _startJob,
        JmgDateTime _registrationDateTime)
    {
        _jmgStampJournalTransTmp.Worker         = worker;
        _jmgStampJournalTransTmp.WrkCtrIdPilot  = wrkCtrIdPilot;
        _jmgStampJournalTransTmp.ProfileDate    = _startJob.ProfileDate;
        _jmgStampJournalTransTmp.StartDate      = DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(_startJob.RegDateTime, DateTimeUtil::getOriginatingTimeZone(_startJob.RegDateTime)));
        _jmgStampJournalTransTmp.StartTime      = DateTimeUtil::time(DateTimeUtil::applyTimeZoneOffset(_startJob.RegDateTime, DateTimeUtil::getOriginatingTimeZone(_startJob.RegDateTime)));
        _jmgStampJournalTransTmp.StopDate       = DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(_registrationDateTime, DateTimeUtil::getOriginatingTimeZone(_registrationDateTime)));
        _jmgStampJournalTransTmp.StopTime       = DateTimeUtil::time(DateTimeUtil::applyTimeZoneOffset(_registrationDateTime, DateTimeUtil::getOriginatingTimeZone(_registrationDateTime)));
        _jmgStampJournalTransTmp.JobId          = _startJob.JobId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prodMultiReportFinished</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the report as finished parameter collection.
    /// </summary>
    /// <returns>
    /// The report as finished parameter collection.
    /// </returns>
    public JmgProdMultiReportFinished prodMultiReportFinished()
    {
        return jmgProdMultiReportFinished;
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerAsWrkCtr</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the registrations that are made must be associated to a resource.
    /// </summary>
    /// <returns>
    ///    true if the registrations must be associated to a resource; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    If the <c>registerAsWrkCtrPilot</c> method returns false, registrations must be associated to a
    ///    worker.
    /// </remarks>
    private boolean registerAsWrkCtr()
    {
        return resourceRegistration && (bundleType == JmgJobBundleType::Prod || JmgJobBundleType::Proj) && wrkCtrIdPilot;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeAllJobs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes all jobs from the bundle.
    /// </summary>
    /// <remarks>
    /// If the bundle has been committed, an error is thrown.
    /// </remarks>
    public void removeAllJobs()
    {
        this.removeNewJobsAndSetEmptyBundleType();
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeNewJobsAndSetEmptyBundleType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes all new jobs from the bundle and sets the bundle type to Empty.
    /// </summary>
    /// <param name="_ignoreBundleSize">
    /// A boolean determining if bundleType should be set to empty if bundleSize is zero,
    /// or if the bundleSize should be ignored and always set bundleType to empty.
    /// </param>
    /// <remarks>
    /// If the bundle has been committed, an error is thrown.
    /// </remarks>
    public void removeNewJobsAndSetEmptyBundleType(boolean _ignoreBundleSize = false)
    {
        this.bundleCommitted();

        newJobs                         = new Map(Types::String, Types::Class);
        newJobsParameters               = new Map(Types::String, Types::Class);
        if (_ignoreBundleSize || this.bundleSize() == 0)
        {
            bundleType = JmgJobBundleType::Empty;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes a job from the bundle. If this method is invoked by using a job not added to the bundle.
    /// </summary>
    /// <param name="_jmgJobTable">
    /// A <c>JmgJobTable</c> record representing the job to remove from the bundle.
    /// </param>
    /// <remarks>
    /// If the bundle has been committed, an error is thrown.
    /// </remarks>
    public void removeJob(JmgJobTable _jmgJobTable)
    {
        this.bundleCommitted();
        if (newJobs.exists(_jmgJobTable.JobId))
        {
            newJobs.remove(_jmgJobTable.JobId);
            newJobsParameters.remove(_jmgJobTable.JobId);
        }

        if (this.bundleSize() == 0)
        {
            bundleType = JmgJobBundleType::Empty;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>requestFeedback</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prompts the user for feedback on already started jobs.
    /// </summary>
    /// <param name="_requireReportAsFinish">
    /// The <c>NoYes::Yes</c> enumeration value if the worker must decide whether a job is completed or
    /// stopped; otherwise the <c>NoYes::No</c> value.
    /// </param>
    /// <param name="_fromFeedback">
    /// A Boolean value that specifies whether the worker is making feedback.
    /// </param>
    /// <returns>
    /// true if the worker provided feedback successfully; otherwise, false.
    /// </returns>
    /// <remarks>
    /// If the <paramref name="_requireReportAsFinished" /> parameter is set to the <c>NoYes::Yes</c>
    /// value, the user is required to mark each job as either finished or not finished. If the <paramref
    /// name="_requireReportAsFinished" /> parameter is set to the <c>NoYes::No</c> value, this field may
    /// be left empty. This is used when it makes feedback on active jobs without stopping them.
    /// </remarks>
    private boolean requestFeedback(NoYes _requireReportAsFinish, boolean _fromFeedback = false)
    {
        boolean ret = true;

        if (this.requireFeedback(_fromFeedback))
        {
            using(var activityContext = this.initInstrumentationParms(this.getOrCreateLogger().registration().requestFeedbackPrompt()))
            {
                if (!_fromFeedback && this.mustShowFeedbackOkCancelDialogBox())
                {
                    DialogButton control = Box::okCancel("@SYS302293",DialogButton::Ok,"@SYS300127");
                    if (control == DialogButton::Cancel)
                    {
                        ret = false;
                        registrationsCancelledByUser = true;
                    }
                }

                if (ret)
                {
                    Args a = new Args();
                    a.record(registrationSetup);
                    a.parmObject(this);
                    a.parmEnum(_requireReportAsFinish);
                    a.caller(callerForm);
                    JmgJobBundleFeedback::main(a);
                    if (a.parmEnum() == NoYes::Yes)
                    {
                        ret = false;
                    }
                }
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustShowFeedbackOkCancelDialogBox</Name>
				<Source><![CDATA[
    /// <summary>
    /// Shows missing feedback OK/cancel dialog box
    /// </summary>
    /// <returns>
    /// true if a dialog should be shown; otherwise, false.
    /// </returns>
    protected boolean mustShowFeedbackOkCancelDialogBox()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>requestStartupInfo</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Requests startup information from the user depending on the type of added jobs.
    /// </summary>
    /// <returns>
    ///    true if the user accepts the startup information form; false if the user cancels the form.
    /// </returns>
    private boolean requestStartupInfo()
    {
        Args        a;
        boolean     requestStartupInfo;
        MapIterator mapIterator;
        JmgTermJob  job;
        boolean     ret;
        ret = true;

        if (askForFeedback)
        {
            requestStartupInfo = false;
            mapIterator = new MapIterator(newJobs);
            while (mapIterator.more() && !requestStartupInfo)
            {
                job = mapIterator.value();
                requestStartupInfo = job.requireStartupInfo(newJobsParameters.lookup(job.jobId()));
                mapIterator.next();
            }

            if (requestStartupInfo)
            {
                a = new Args();
                a.parmObject(this);
                a.record(registrationSetup);
                JmgJobBundleStartup::main(a);
                if (a.parmEnum() == NoYes::Yes)
                {
                    ret = false;
                }
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>requireFeedback</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns whether feedback should be requested from the user.
    /// </summary>
    /// <param name="_fromFeedback">
    ///    true if feedback is requested from the <c>makeFeedbackOnActiveJobs</c> method; false if from the
    ///    <c>makeRegistrations</c> method.
    /// </param>
    /// <returns>
    ///    true if feedback should be requested from the user; otherwise, false.
    /// </returns>
    public boolean requireFeedback(boolean _fromFeedback = false)
    {
        boolean     ret;
        MapIterator newJobsIterator;
        JmgTermJob  job;

        if (askForFeedback && !activeJobs.elements())
        {
            this.loadActiveJobs();
        }

        ret =  askForFeedback && activeJobs.elements() > 0 && (!continueBundle || forceNewBundle || _fromFeedback) && bundleType != JmgJobBundleType::BreakReg && bundleType != JmgJobBundleType::EventCode;

        if (ret)
        {
            // If this is a prod-bundle, then check to see if it is a partial startup, which requires no feedback
            if (bundleType == JmgJobBundleType::Prod)
            {
                newJobsIterator = new MapIterator(newJobs);
                while (newJobsIterator.more() && ret)
                {
                    job = newJobsIterator.value();
                    ret = !activeJobs.exists(job.jobId());
                    newJobsIterator.next();
                }
            }
            else if (bundleType == JmgJobBundleType::IPC) // If clock out, then check to see if feedback is needed on clock out.
            {
                job = this.getNewJobsIterator().value();

                JmgSignInOut     signType  = job.signType();
                JmgStampTypeEnum stampType = job.stampType();

                if (signType  == JmgSignInOut::SignOut ||
                    stampType == JmgStampTypeEnum::Absence)
                {
                    ret = registrationSetup.SignOutFeedback == NoYes::Yes;
                }
                else if (signType  == JmgSignInOut::StartTeam ||
                         signType  == JmgSignInOut::SubmitPilote)
                {
                    ret = true;
                }
                else if (stampType == JmgStampTypeEnum::EventCode)
                {
                    ret = false;
                }
            }

            ret = this.requireFeedbackForActiveJobs(ret, activeJobs);
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>requireFeedbackForActiveJobs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Requests feedback for active jobs
    /// </summary>
    /// <param name = "_requireFeedback"> The boolean value determining if feedback should be asked from the user. </param>
    /// <param name = "_activeJobs"> The list of active jobs. </param>
    /// <returns> true if feedback should be asked from the user; otherwise false. </returns>
    protected boolean requireFeedbackForActiveJobs(boolean _requireFeedback, Map _activeJobs)
    {
        JmgTermJob  job;
        MapIterator activeJobsIterator = new MapIterator(_activeJobs);

        while (activeJobsIterator.more() && _requireFeedback)
        {
            job = activeJobsIterator.value();
            // Ignore breaks:
            if (job.stampType() != JmgStampTypeEnum::Break)
            {
                _requireFeedback = job.requireFeedbackInfo(activeJobsParameters.lookup(job.jobId()));
            }
            activeJobsIterator.next();
        }
        return _requireFeedback;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reset</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Resets the job bundle. All added jobs are removed and the employee's active jobs are reloaded from the database.
    /// </summary>
    /// <remarks>
    ///    Currently this method is only used as a part of the initialization procedure. If it should be possible to reset the bundle, this method should be made public.
    /// </remarks>
    [Hookable(false)]
    internal final void reset()
    {
        JmgTermReg  jmgTermReg;

        activeJobs                      = new Map(Types::String, Types::Class);
        newJobs                         = new Map(Types::String, Types::Class);
        newJobsParameters               = new Map(Types::String, Types::Class);
        activeJobsParameters            = new Map(Types::String, Types::Class);
        activeJobsExistingParameters    = new Map(Types::String, Types::Class);
        partialStartupParameters        = new Map(Types::String, Types::Class);

        forceNewBundle      = false;
        inventDimId         = InventDim::inventDimIdBlank();
        bundleType          = JmgJobBundleType::Empty;

        // Determine if worker is assisting a resource
        select firstonly WrkCtrIdPilot
            from  jmgTermReg
            where jmgTermReg.Worker     == worker
                && jmgTermReg.RegType   == JmgTermRegType::TeamStart
                && jmgTermReg.JobActive == NoYes::Yes;

        wrkCtrIdPilot = jmgTermReg.WrkCtrIdPilot;

        this.loadActiveJobs();

        if (!continueBundle || forceNewBundle)
        {
            bundleType  = JmgJobBundleType::Empty;
        }

        bundleCommitted = false;

        jmgProdMultiStartUp                 = null;
        statusQtyProdJournalCheckPostList   = null;
        jmgProdMultiReportFinished          = null;
        reportFinishedMultiLineJournalCheckPostList = null;

        emplClockedIn                       = JmgTermReg::getCurSignInTime(worker, sysDateTime) != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetRegistrationTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets registration date and time.
    /// </summary>
    public void resetRegistrationTime()
    {
        registrationDate    = JmgProfileSeconds::getSysDate();
        registrationTime    = JmgProfileSeconds::getSysTime();
    }

]]></Source>
			</Method>
			<Method>
				<Name>restartJobs</Name>
				<Source><![CDATA[
    /// <summary>
    /// At clock in, restarts the jobs that were stopped at the previous clock out.
    /// </summary>
    /// <param name="_allowRestart">
    /// A value that represents whether the restart of a job is enabled.
    /// </param>
    /// <remarks>
    /// Jobs are only restarted if the <paramref name="_allowRestart" /> parameter is set to true, and if
    /// the Shop Floor Control parameters (the <c>JmgParameters.RestartOnSignIn</c> field) enables jobs to
    /// be restarted on clock in.
    /// </remarks>
    private void restartJobs(boolean _allowRestart)
    {
        JmgDateTime         lastClockOut;
        JmgTermReg          jobsToRestart;
        JmgTermReg          startJob;
        JmgTermJob          job;
        JmgRegistrationParameters   regParams;

        if (JmgParameters::find().RestartOnSignIn && _allowRestart)
        {
            // Restart jobs at clock in:
            lastClockOut = (select maxof(RegDateTime)
                                from jmgTermReg
                                where jmgTermReg.Worker     == worker                   &&
                                      jmgTermReg.RegType    == JmgTermRegType::ClockOut &&
                                      jmgTermReg.RegDateTime<= DateTimeUtil::newDateTime(registrationDate, registrationTime,DateTimeUtil::getUserPreferredTimeZone())).RegDateTime;
            while select JobId
                from jobsToRestart
                where jobsToRestart.Worker      == worker                   &&
                      jobsToRestart.RegType     == JmgTermRegType::JobStop  &&
                      jobsToRestart.RegDateTime == lastClockOut
                join  startJob
                where startJob.RecId            == jobsToRestart.MatchRecIdStartStop
            {
                job = JmgTermJob::construct(jobsToRestart.JobId);
                if (job.allow() && !job.reportedFinish())
                {
                    regParams   = new JmgRegistrationParameters();
                    regParams.costCategory(startJob.CostCategory);
                    job.makeRegistration(worker, registrationDate, registrationTime, true, regParams);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>restoreTeam</Name>
				<Source><![CDATA[
    /// <summary>
    /// Restores the team that the employee was a member of at the previous clock out.
    /// </summary>
    /// <param name="_allowRestore">
    /// Indicates whether restore of teams is enabled.
    /// </param>
    /// <returns>
    /// true, if the user is now a member of a team. false if the user is now a pilot to a team of
    /// employees, or if no team was restored.
    /// </returns>
    /// <remarks>
    /// Teams are only restored if the <paramref name="_allowRestore" /> parameter is set to true, and if
    /// the Shop Floor Control parameters (the <c>JmgParameters.KeepTeams</c>) enables teams to be
    /// restored. A message is shown to the user informing him about his team membership.
    /// </remarks>
    private boolean restoreTeam(boolean _allowRestore)
    {
        JmgAssistance               jmgAssistance;
        JmgWorkerRecId              workerPilot;
        str                         restartpilotjobs;
        JmgTermJob                  startTeamJob;
        JmgRegistrationParameters   parameters;

        if (JmgParameters::find().KeepAssistance == NoYes::Yes && _allowRestore)
        {
            select firstonly forupdate jmgAssistance where jmgAssistance.WorkerAssistant == worker;
            if (jmgAssistance)
            {
                workerPilot   = jmgAssistance.WorkerPilot;
                if ((workerPilot && JmgEmployee::signedIn(workerPilot)) || jmgAssistance.WrkCtrIdPilot)
                {
                    startTeamJob = JmgTermJob::construct(JmgIpcActivity::findSignTypeJobId(JmgSignInOut::StartTeam));
                    parameters = new JmgRegistrationParameters();
                    parameters.jobPilot(workerPilot);
                    parameters.parmWrkCtrIdPilot(jmgAssistance.WrkCtrIdPilot);
                    startTeamJob.makeRegistration(worker, registrationDate, registrationTime, true, parameters);
                    this.showMessageInfo(strFmt("@SYS38428", workerPilot ? HcmWorker::find(workerPilot).PersonnelNumber : wrkCtrIdPilot));
                    return true;
                }
                while select forupdate jmgAssistance where jmgAssistance.WorkerPilot  == workerPilot
                {
                    if (jmgAssistance.WorkerAssistant != worker)
                    {
                        jmgAssistance.WorkerPilot     = worker;
                    }
                    else
                    {
                        jmgAssistance.WorkerPilot     = worker;
                        jmgAssistance.WorkerAssistant = workerPilot;
                    }
                    restartpilotjobs += (restartpilotjobs ? ', ' : '') + HcmWorker::find(jmgAssistance.WorkerAssistant).PersonnelNumber;
                    jmgAssistance.update();
                }
                if (restartpilotjobs)
                {
                    this.showMessageInfo(strFmt('%1: \n%2',"@SYS38427",restartpilotjobs));
                }
            }
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFeedbackParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the feedback parameters associated with an active job.
    /// </summary>
    /// <param name="_jobId">
    /// The job ID to which the registration parameters should be associated.
    /// </param>
    /// <param name="_regParameters">
    /// The registration parameters, which should be associated to the job ID.
    /// </param>
    /// <remarks>
    /// If the specified job ID is not one of the active jobs, nothing occurs.
    /// </remarks>
    public void setFeedbackParameters(JmgJobId _jobId, JmgRegistrationParameters _regParameters)
    {
        if (activeJobs.exists(_jobId))
        {
            activeJobsParameters.insert(_jobId, _regParameters);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFeedbackStatusOnActiveJobs</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the feedback status for all of the active jobs.
    /// </summary>
    /// <param name="_feedbackStatus">
    ///    The feedback status that all of the jobs should be set to.
    /// </param>
    /// <remarks>
    ///    When a feedback status is set using this method, all of the jobs will be preset to this status when
    ///    the feedback form is opened.
    /// </remarks>
    public void setFeedbackStatusOnActiveJobs(JmgFeedbackStatus _feedbackStatus)
    {
        MapIterator                 mapIterator;
        JmgRegistrationParameters   params;

        mapIterator = new MapIterator(activeJobsParameters);
        while (mapIterator.more())
        {
            params = mapIterator.value();
            params.reportAsFinished(_feedbackStatus);
            mapIterator.next();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setReportFinishedJournalPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the journal used for posting report as finished production journals.
    /// </summary>
    /// <param name="_jmgProdMultiReportFinished">
    /// A reference of the <c>JmgProdMultiReportFinished</c> class, which refers to the report finished journal to post.
    /// </param>
    public void setReportFinishedJournalPosting(JmgProdMultiReportFinished _jmgProdMultiReportFinished)
    {
        jmgProdMultiReportFinished = _jmgProdMultiReportFinished;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setStartUpJournalPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the journal used for posting start of productions.
    /// </summary>
    /// <param name="_jmgProdMultiStartUp">
    /// A reference of the <c>JmgProdMultiStartUp</c> class, which refers to the start production journal
    /// to post.
    /// </param>
    public void setStartUpJournalPosting(JmgProdMultiStartUp _jmgProdMultiStartUp)
    {
        jmgProdMultiStartUp = _jmgProdMultiStartUp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setStartupParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set the startup parameters associated with an added job.
    /// </summary>
    /// <param name="_jobId">
    /// The job ID to which the registration parameters should be associated.
    /// </param>
    /// <param name="_regParameters">
    /// The registration parameters which should be associated to the job ID.
    /// </param>
    /// <remarks>
    /// If the specified job ID is not one of the added jobs, nothing occurs.
    /// </remarks>
    public void setStartupParameters(JmgJobId _jobId, JmgRegistrationParameters _regParameters)
    {
        if (continueBundle && activeJobs.exists(_jobId))
        {
            partialStartupParameters.insert(_jobId, _regParameters);
        }

        if (newJobs.exists(_jobId))
        {
            newJobsParameters.insert(_jobId, _regParameters);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setStatusQtyJournalPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the journals used for posting status and quantity changes to productions.
    /// </summary>
    /// <param name="_statusQtyProdJournalCheckPostList">
    /// A  <c>List</c> of instances of the <c>ProdJournalCheckPost</c> class, which refer to the journals to post.
    /// </param>
    /// <remarks>
    /// It is valid to have multiple journals to post in the list.
    /// Null can be passed in as the argument value instead of the list if there is no journals to post.
    /// </remarks>
    public void setStatusQtyJournalPosting(List _statusQtyProdJournalCheckPostList)
    {
        statusQtyProdJournalCheckPostList = _statusQtyProdJournalCheckPostList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setReportFinishedMultiLineJournalPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the journals used for posting report finished journals with multi-lines to productions.
    /// </summary>
    /// <param name="_reportFinishedMultiLineJournalCheckPostList">
    /// A  <c>List</c> of instances of the <c>ProdJournalCheckPostProd</c> class, which refer to the journals to post.
    /// </param>
    /// <remarks>
    /// It is valid to have multiple journals to post in the list.
    /// Null can be passed in as the argument value instead of the list if there is no journals to post.
    /// </remarks>
    [SysObsolete('Multi-line report as finish journal is taken care of by ProdMultiLineReportAsFinishSerialNumFeature', false, 03\07\2022)]
    public void setReportFinishedMultiLineJournalPosting(List _reportFinishedMultiLineJournalCheckPostList)
    {
        reportFinishedMultiLineJournalCheckPostList = _reportFinishedMultiLineJournalCheckPostList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWrkCtrPilot</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the <c>WrkCtrIdPilot</c> property on all registration parameters in the bundle.
    /// </summary>
    /// <param name="_wrkCtrPilot">
    ///    The ID of the resource to set as pilot.
    /// </param>
    private void setWrkCtrPilot(JmgWrkCtrIdPilot _wrkCtrPilot)
    {
        MapIterator                 mapIterator;
        JmgRegistrationParameters   parameters;

        mapIterator = new MapIterator(activeJobsParameters);
        while (mapIterator.more())
        {
            parameters = mapIterator.value();
            parameters.parmWrkCtrIdPilot(_wrkCtrPilot);
            mapIterator.next();
        }

        mapIterator = new MapIterator(newJobsParameters);
        while (mapIterator.more())
        {
            parameters = mapIterator.value();
            parameters.parmWrkCtrIdPilot(_wrkCtrPilot);
            mapIterator.next();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showClockInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Shows information about the clock in or clock out to the user.
    /// </summary>
    /// <param name="text">
    /// The text to show to the user.
    /// </param>
    protected void showClockInfo(str text = messageText)
    {
        if (showInfo)
        {
            str infoText = text == "@SYS38409" ? "@SYS309981" : text == "@SYS38411" ? "@SYS309982" : '';
            JmgDialogFormClass dlgForm = new JmgDialogFormClass(infoText, text, "@SYS5473", true, this.getClockInTimeout(), this.parmCallerForm());
            dlgForm.openBreakDialog();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getClockInTimeout</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns clock in timeout.
    /// </summary>
    /// <returns>
    ///    The timeout in milliseconds.
    /// </returns>
    protected int getClockInTimeout()
    {
        return 6000;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showMessageInfo</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Shows information to the user.
    /// </summary>
    /// <param name="message">
    ///    The text to show to the user.
    /// </param>
    /// <remarks>
    ///    The message window is only shown if the <paramref name="_showInfo" /> parameter specified in the
    ///    <c>JmgJobBundle.new</c> method is set to true. The message displayed is controlled by the Shop
    ///    Floor Control parameters, which is specifies by the <c>JmgParameters.SplashDelay</c> field.
    /// </remarks>
    protected void showMessageInfo(str message)
    {
        if (showInfo)
        {
            JmgJobBundle::showMessage(message);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>startNewJobs</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a start registration for the employee for each job that is added to the job bundle.
    /// </summary>
    public void startNewJobs()
    {
        MapIterator mapIterator;
        JmgTermJob  job;

        mapIterator = new MapIterator(newJobs);
        while (mapIterator.more())
        {
            job = mapIterator.value();
            job.makeRegistration(this.registerAsWrkCtr() ? 0 : worker, registrationDate, registrationTime, true, newJobsParameters.lookup(job.jobId()));
            mapIterator.next();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>stopActiveBreaks</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a stop break registration for each break that the employee is currently registered for.
    /// </summary>
    private void stopActiveBreaks()
    {
        MapIterator mapIterator;
        JmgTermJob  job;
        mapIterator = new MapIterator(activeJobs);
        while (mapIterator.more())
        {
            job = mapIterator.value();
            if (job.stampType() == JmgStampTypeEnum::Break)
            {
                job.makeRegistration(worker, registrationDate, registrationTime, false, activeJobsParameters.lookup(job.jobId()));
            }
            mapIterator.next();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>stopActiveJobs</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a stop registration for each job that the employee is currently working on.
    /// </summary>
    /// <param name = "_doNotPostQuantity">
    /// Specifies whether posting quantity should be prevented.
    /// </param>
    public void stopActiveJobs(boolean _doNotPostQuantity = false)
    {
        MapIterator mapIterator;
        JmgTermJob  job;
        JmgRegistrationParameters regParams;

        if (!continueBundle || forceNewBundle)
        {
            mapIterator = new MapIterator(activeJobs);

            while (mapIterator.more())
            {
                job = mapIterator.value();

                regParams = this.getFeedbackParameters(job.jobId());

                if (regParams.reportAsFinished() == JmgFeedbackStatus::InProgress)
                {
                    regParams.reportAsFinished(JmgFeedbackStatus::Stopped);
                }

                if (_doNotPostQuantity)
                {
                    regParams.goodQuantity(0);
                    regParams.pdsCWGoodQuantity(0);
                    regParams.errorSpecification('');
                }
                job.makeRegistration(this.registerAsWrkCtr() ? 0 : worker, registrationDate, registrationTime, false, regParams);

                mapIterator.next();
            }
        }
        else
        {
            // Active breaks should always be stopped.
            this.stopActiveBreaks();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>translateModuleType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Translates between job module types to bundle types.
    /// </summary>
    /// <param name="_module">
    ///    The module to translate to a bundle type.
    /// </param>
    /// <returns>
    ///    The bundle type which the specified module corresponds to.
    /// </returns>
    /// <remarks>
    ///       The module a job originates from corresponds to a bundle type. The mapping is as follows:
    ///
    ///    <list type="bullet">
    ///       <item>
    ///          <description>
    ///             <c>JmgModuleEnum::PROD</c> &lt;-&gt; <c>JmgJobBundleType::Prod</c>
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             <c>JmgModuleEnum::PROJ</c> &lt;-&gt; <c>JmgJobBundleType::Proj</c>
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             <c>JmgModuleEnum::IPC</c> &lt;-&gt; <c>JmgJobBundleType::IPC</c>
    ///          </description>
    ///       </item>
    ///    </list>
    /// </remarks>
    private JmgJobBundleType translateModuleType(JmgModuleEnum _module)
    {
        JmgJobBundleType ret;
        switch (_module)
        {
            case JmgModuleEnum::PROD:
                ret = JmgJobBundleType::Prod;
                break;
            case JmgModuleEnum::PROJ:
                ret = JmgJobBundleType::Proj;
                break;
            case JmgModuleEnum::IPC:
                ret = JmgJobBundleType::IPC;
                break;
            default:
                ret = JmgJobBundleType::Empty;
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBundle</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the specified job can be added to the bundle.
    /// </summary>
    /// <param name="_jmgTermJob">
    /// A <c>JmgTermJob</c> object, which refers to the job to validate.
    /// </param>
    /// <param name="_newJob">
    /// A Boolean value that specifies whether the job is a new job.
    /// </param>
    /// <remarks>
    /// This method should be called whenever a job is added to the job bundle. The method also sets the
    /// bundle type according to the jobs added. The <c>JmgJobBundle.continueBundle</c> parameter is
    /// considered during the check.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    /// The worker tries to bundle two project or indirect activities.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    /// The worker tries to bundle jobs from different modules.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    /// The worker tries to bundle jobs from two different sites.
    /// </exception>
    private void validateBundle(JmgTermJob _jmgTermJob, boolean _newJob = true)
    {
        JmgJobBundleType newBundleType;
        JmgTermJob_Prod prodJob;
        if (_jmgTermJob.stampType() == JmgStampTypeEnum::Break)
        {
            if (_newJob)
            {
                newBundleType = JmgJobBundleType::BreakReg;
            }
            else
            {
                return;
            }
        }
        else if (_jmgTermJob.stampType() == JmgStampTypeEnum::EventCode)
        {
            newBundleType = JmgJobBundleType::EventCode;
        }
        else if (_jmgTermJob.stampType() == JmgStampTypeEnum::Absence)
        {
            newBundleType = JmgJobBundleType::Absence;
        }
        else
        {
            newBundleType = this.translateModuleType(_jmgTermJob.module());
        }

        if (bundleType != JmgJobBundleType::Empty   &&
            bundleType != newBundleType)
        {
            throw error(strFmt("@SYS39889", newBundleType, bundleType));
        }

        bundleType = newBundleType;

        if ((bundleType == JmgJobBundleType::IPC        ||
             bundleType == JmgJobBundleType::Proj       ||
             bundleType == JmgJobBundleType::Absence    ||
             bundleType == JmgJobBundleType::EventCode  ||
             bundleType == JmgJobBundleType::BreakReg)  &&
            this.bundleSize() >= 1)
        {
            throw error(strFmt("@SYS39888", bundleType));
        }

        if (bundleType == JmgJobBundleType::Prod)
        {
            if (JmgProdParameters::find().ProdParamInventDimLookup == ProdParamInventDimLookup::Site)
            {
                prodJob = _jmgTermJob;

                if (inventDimId != InventDim::inventDimIdBlank() &&
                    inventDimId != prodJob.siteInventDimId())
                {
                    throw error("@SYS121591");
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>worker</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the worker that is associated with this bundle.
    /// </summary>
    /// <returns>
    ///    The worker that is associated with this bundle.
    /// </returns>
    /// <remarks>
    ///    The worker that is associated to a job bundle cannot be changed. Instead create a new instance of
    ///    the <c>JmgJobBundle</c> class.
    /// </remarks>
    public JmgWorkerRecId worker()
    {
        return worker;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wrkCtrIdPilot</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the ID of the pilot resource that is currently associated to the <c>JmgJobBundle</c> object.
    /// </summary>
    /// <returns>
    /// The ID of the pilot resource that is currently associated to the <c>JmgJobBundle</c> object.
    /// </returns>
    /// <remarks>
    /// The resource pilot value is initialized when the <c>JmgJobBundle</c> object is first initialized.If
    /// the worker is registered as an assistant to a resource, the <c>wrkCtrIdPilot</c> method will return
    /// the ID of that resource.
    /// </remarks>
    public JmgWrkCtrIdPilot wrkCtrIdPilot()
    {
        return wrkCtrIdPilot;
    }

]]></Source>
			</Method>
			<Method>
				<Name>iterateFeedback</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Iterates feedback and posts production journals.
    /// </summary>
    /// <param name="_feedbackIterator">
    ///    A <c>MapIterator</c> object for which iterates the feedback to post production journals.
    /// </param>
    private static void iterateFeedback(MapIterator _feedbackIterator)
    {
        JmgRegistrationParameters   regParams;
        ProdJournalTable            prodJournalTableBOM;
        ProdJournalCheckPostBOM     prodJournalCheckPostBOM;
        while (_feedbackIterator.more())
        {
            regParams = _feedbackIterator.value();
            prodJournalTableBOM = ProdJournalTable::find(regParams.prodJournalIdBOM(), true);
            if (prodJournalTableBOM && prodJournalTableBOM.NumOfLines)
            {
                // Post journal
                if (prodJournalTableBOM.Posted == NoYes::No)
                {
                    prodJournalCheckPostBOM = ProdJournalCheckPostBOM::newPostJournal(prodJournalTableBOM.JournalId, true);
                    prodJournalCheckPostBOM.runOperation();
                }
            }
            else if (prodJournalTableBOM)
            {
                // Delete empty journal
                prodJournalTableBOM.delete();
            }
            _feedbackIterator.next();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showMessage</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Shows information to the user.
    /// </summary>
    /// <param name="message">
    ///    The text to show to the user.
    /// </param>
    /// <remarks>
    ///    If the delay is not specified, it is initialized by the value of the
    ///    <c>JmgParameters.SplashDelay</c> field.
    /// </remarks>
    static void showMessage(str message)
    {
        #JmgSignIn
        #resource
        str                         wrkMessage  = message;
        Form                        form;
        FormRun                     formRun;
        Args                        args;
        FormDesign                  formDesign;
        FormBuildDesign             formBuildDesign;
        FormBuildStringControl      formBuildStaticTextControl;

        form = new Form();
        formBuildDesign = form.addDesign('design');
        formBuildDesign.hideToolbar(true);
        formBuildDesign.windowResize(#WindowResize_Fixed);
        formBuildDesign.columns(1);
        formBuildDesign.frame(2);
        formBuildDesign.topMode(3);         // Center
        formBuildDesign.leftMode(4);        // Center
        formBuildDesign.widthMode(FormWidth::ColumnWidth);         // Auto
        formBuildDesign.heightMode(FormHeight::ColumnHeight);      // Auto

        formBuildStaticTextControl = formBuildDesign.addControl(FormControlType::String, 'Message');
        formBuildStaticTextControl.text(message);
        formBuildStaticTextControl.fontSize(#Message_Fontsize);
        formBuildStaticTextControl.font(#showFont);
        formBuildStaticTextControl.leftMode(#LeftMode_Auto);
        formBuildStaticTextControl.multiLine(NoYes::Yes);
        formBuildStaticTextControl.allowEdit(NoYes::No);
        formBuildStaticTextControl.border(1);

        args = new Args();
        args.object(form);
        formRun = classfactory.formRunClass(args);
        formRun.init();
        formDesign = formRun.design();
        formRun.resetSize();
        formRun.formOnTop();

        formRun.run();
        formRun.detach();
    }

]]></Source>
			</Method>
			<Method>
				<Name>registrationsCancelledByUser</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Check if user has cancelled the registration manually.
    /// </summary>
    /// <returns>
    ///   If user cancels the registrations manually, return true, else false.
    /// </returns>
    public boolean registrationsCancelledByUser()
    {
        return registrationsCancelledByUser;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrCreateLogger</Name>
				<Source><![CDATA[
    private JmgInstrumentationLogger getOrCreateLogger()
    {
        if(!jmgInstrumentationLogger)
        {
            jmgInstrumentationLogger = JmgInstrumentationLogger::createLogger(classStr(JmgJobBundle));
        }
        return jmgInstrumentationLogger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInstrumentationParms</Name>
				<Source><![CDATA[
    private SysInstrumentationActivityContext initInstrumentationParms(SysInstrumentationActivityContext _scenario)
    {
        if (callerForm)
        {
            _scenario.addCustomProperty(JmgRegistrationInstrumentationActivities::ParmFormCaller, JmgRegistrationInstrumentationActivities::callerName(callerForm.name()));
        }

        return _scenario;
    }

]]></Source>
			</Method>
			<Method>
				<Name>logActivityParms_Journals</Name>
				<Source><![CDATA[
    private void logActivityParms_Journals(SysInstrumentationActivityContext _activityContext)
    {
        _activityContext.addCustomProperty(JmgRegistrationInstrumentationActivities::ParmStatusQtyProdJournalCheckPostList, any2Str(statusQtyProdJournalCheckPostList? true:false));
        if (!FeatureStateProvider::isFeatureEnabled(ProdMultiLineReportAsFinishSerialNumFeature::instance()))
        {
            _activityContext.addCustomProperty(JmgRegistrationInstrumentationActivities::ParmReportFinishedMultiLineJournalCheckPostList, any2Str(reportFinishedMultiLineJournalCheckPostList? true:false));
        }
        _activityContext.addCustomProperty(JmgRegistrationInstrumentationActivities::ParmProdMultiReportFinished, any2Str(jmgProdMultiReportFinished? true:false));
        _activityContext.addCustomProperty(JmgRegistrationInstrumentationActivities::ParmProdMultiStartUpJournals, any2Str(jmgProdMultiStartUp? true:false));
    }

]]></Source>
			</Method>
			<Method>
				<Name>logActivityParms_JmgProdParametersDim</Name>
				<Source><![CDATA[
    private void logActivityParms_JmgProdParametersDim(SysInstrumentationActivityContext _activityContext, JmgProdParametersDim _prodParametersDim)
    {
        this.logActivityParms_Journals(_activityContext);
        _activityContext.addCustomProperty(JmgRegistrationInstrumentationActivities::ParmJmgProdParametersDim_StatusQtyPostAutomatically, any2Str(_prodParametersDim.StatusQtyPostAutomatically));
        _activityContext.addCustomProperty(JmgRegistrationInstrumentationActivities::ParmJmgProdParametersDim_BOMPostAutomatically, any2Str(_prodParametersDim.BOMPostAutomatically));
        _activityContext.addCustomProperty(JmgRegistrationInstrumentationActivities::ParmJmgProdParametersDim_ReportFinishStatus, JmgRegistrationInstrumentationActivities::ProdStatusUpdateReportFinished(_prodParametersDim.ReportFinishStatus));
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>