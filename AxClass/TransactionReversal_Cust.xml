<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TransactionReversal_Cust</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>TransactionReversal_Cust</c> class is used to reverse customer transactions.
/// </summary>
/// <remarks>
/// This class is derived from the <see cref="T:TransactionReversal_CustVend" /> class. This class is
/// used for reversing customer transactions. When a customer transaction is reversed, the coherent
/// ledger transactions are also reversed. The actual reversal of the customer transaction is performed
/// in the <see cref="M:TransactionReversal_CustVend.createCustVendTrans" /> class method. Before this,
/// a new instance of the <see cref="T:TransactionReversal_Ledger" /> class is called for reversal of
/// the ledger transactions. If there is an interest note or a collection letter connected to the
/// customer transaction, these can be reversed based on the choice of the user in the dialog box.
/// </remarks>
class TransactionReversal_Cust extends TransactionReversal_CustVend
{
    Dialog dialog;
    CustCollectionLetterJour custCollectionLetterJour;
    CustInterestJour custInterestJour;
    DialogField dialogReverseCollectionLetter;
    DialogField dialogReasonCode;
    DialogField dialogReasonComment;
    DialogRunbase dialogRuntime;

    boolean reverseInterestNote; // Will apeare if there is an interest note to reverse
    boolean reverseCollectionLetter; // Will apeare if there is an collection letter to reverse
    boolean mandatoryReasonCode;

    TransactionReversal_Cust custObject;
    Voucher voucherOrig;
    TransDate transDateOrig;

    #DEFINE.dialogReasonCodeFieldNo(900)
    #DEFINE.dialogReasonCodeCtrlName("Fld900_1")

    #DEFINE.CurrentVersion(6)
    #LOCALMACRO.CurrentList
        reverseInterestNote,
        reasonCode,
        reasonComment,
        reverseCollectionLetter,
        custInterestJour,
        custCollectionLetterJour,
        voucherOrig,
        transDateOrig,
        reasonRefRecId
    #ENDMACRO
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>createInvoiceJournal</Name>
				<Source><![CDATA[
    void createInvoiceJournal(CustVendTrans _custTrans, CustVendTrans _custTransOrig)
    {
        boolean found;
        CustInvoiceJour custInvoiceJour;
        CustInvoiceJour custInvoiceJourOrig;
        CustInvoiceTrans custInvoiceTrans;
        RecordSortedList custInvoiceTransList;

        custInvoiceJourOrig = CustInvoiceJour::findFromCustTransVoucher(_custTransOrig.Invoice,
                                                                        _custTransOrig.Voucher,
                                                                        _custTransOrig.TransDate,
                                                                        _custTransOrig.AccountNum);
        if (custInvoiceJourOrig)
        {
            custInvoiceJour.data(custInvoiceJourOrig);

            custInvoiceJour.euSalesList = "";
            custInvoiceJour.InvoiceDate = _custTrans.TransDate;
            custInvoiceJour.DocumentNum = _custTrans.DocumentNum;
            custInvoiceJour.DocumentDate = _custTrans.DocumentDate;
            custInvoiceJour.LedgerVoucher = _custTrans.Voucher;
            // The SalesId field is being set to the new voucher, so that we can find the
            // correct CustInvoiceTrans records. If this isn't done then the original CustInvoiceJour and
            // this reversal CustInvoiceJour will have the same InvoiceDate, InvoiceId, SalesId and NumberSequenceGroup
            // which are the keys used to find the related CustInvoiceTrans records.
            custInvoiceJour.SalesId = _custTrans.Voucher;

            custInvoiceJour.InvoiceAmount = - custInvoiceJour.InvoiceAmount;
            custInvoiceJour.SumTax = - custInvoiceJour.SumTax;
            custInvoiceJour.Qty = - custInvoiceJour.Qty;
            custInvoiceJour.CashDisc = - custInvoiceJour.CashDisc;
            custInvoiceJour.SalesBalance = - custInvoiceJour.SalesBalance;

            custInvoiceJour.EndDisc = - custInvoiceJour.EndDisc;
            custInvoiceJour.SumLineDisc = - custInvoiceJour.SumLineDisc;
            custInvoiceJour.SumMarkup = - custInvoiceJour.SumMarkup;
            custInvoiceJour.euSalesList = '';
            custInvoiceJour.ReversedRecId = custInvoiceJour.RecId;
            this.createInvoiceJourExtensions(custInvoiceJour, custInvoiceJourOrig);
            custInvoiceJour.insert();

            custInvoiceTransList = new RecordSortedList(tableNum(CustInvoiceTrans));
            custInvoiceTransList.sortOrder(fieldNum(CustInvoiceTrans, RecId));

            while select custInvoiceTrans
                where custInvoiceTrans.SalesId == custInvoiceJourOrig.SalesId &&
                      custInvoiceTrans.InvoiceDate == custInvoiceJourOrig.InvoiceDate &&
                      custInvoiceTrans.InvoiceId == custInvoiceJourOrig.InvoiceId &&
                      custInvoiceTrans.NumberSequenceGroup == custInvoiceJourOrig.NumberSequenceGroup &&
                      (custInvoiceTrans.ParentRecId == custInvoiceJourOrig.RecId || !custInvoiceTrans.ParentRecId)
            {
                custInvoiceTransList.ins(custInvoiceTrans);
            }

            for (found = custInvoiceTransList.first(custInvoiceTrans);
            found;
            found = custInvoiceTransList.next(custInvoiceTrans))
            {
                custInvoiceTrans.initFromCustInvoiceJour(custInvoiceJour);
                custInvoiceTrans.Qty = -custInvoiceTrans.Qty;
                custInvoiceTrans.InventQty = -custInvoiceTrans.InventQty;
                custInvoiceTrans.QtyPhysical = -custInvoiceTrans.QtyPhysical;
                custInvoiceTrans.LineAmount = -custInvoiceTrans.LineAmount;
                custInvoiceTrans.LineAmountMST = -custInvoiceTrans.LineAmountMST;
                custInvoiceTrans.LineAmountTax = -custInvoiceTrans.LineAmountTax;
                custInvoiceTrans.LineAmountTaxMST = -custInvoiceTrans.LineAmountTaxMST;
                custInvoiceTrans.StatLineAmountMST = -custInvoiceTrans.StatLineAmountMST;
                custInvoiceTrans.SumLineDisc = -custInvoiceTrans.SumLineDisc;
                custInvoiceTrans.SumLineDiscMST = -custInvoiceTrans.SumLineDiscMST;
                custInvoiceTrans.TaxAmount = -custInvoiceTrans.TaxAmount;
                custInvoiceTrans.TaxAmountMST = -custInvoiceTrans.TaxAmountMST;
                custInvoiceTrans.CommissAmountCur = -custInvoiceTrans.CommissAmountCur;
                custInvoiceTrans.CommissAmountMST = -custInvoiceTrans.CommissAmountMST;
                custInvoiceTrans.ReversedRecId = custInvoiceTrans.RecId;
                custInvoiceTrans.LineCreationSequenceNumber = 0;
                custInvoiceTrans.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReasonTableRef</Name>
				<Source><![CDATA[
    private boolean createReasonTableRef(
        ReasonCode _reasonCode,
        ReasonComment _reasonComment,
        Voucher _voucher,
        TransDate _transDate,
        LedgerJournalACType _type)
    {
        boolean retValue = true;

        if (_reasonCode)
        {
            LedgerJournalACType accountType;

            if (!ReasonTable::exist(_reasonCode))
            {
                retValue = checkFailed(strFmt("@SYS112224", _reasonCode, fieldId2name(tableNum(ReasonTable), fieldNum(ReasonTable, Reason)), tableId2name(tableNum(ReasonTable)))) && retValue;
            }
            else
            {
                if (GeneralLedgerExtension::findBySubledgerVoucherAccountingDate(_voucher, _transDate).RecId)
                {
                    accountType = LedgerJournalACType::Ledger;
                }
                if (AssetTrans::findByVoucher(_voucher, _transDate).RecId)
                {
                    accountType = LedgerJournalACType::FixedAssets;
                }
                if (VendTrans::findVoucherDate(_voucher, _transDate).RecId)
                {
                    accountType = LedgerJournalACType::Vend;
                }
                if (BankAccountTrans::findByVoucher(_voucher, _transDate).RecId)
                {
                    accountType = LedgerJournalACType::Bank;
                }
            }
            if (!ReasonTable::findReasonByFilter(_reasonCode, _type, true, accountType, true) && retValue)
            {
                retValue = checkFailed("@SYS115522");
            }

            reasonRefRecId = ReasonTableRef::createReasonTableRef(_reasonCode, _reasonComment);
        }
        else if (this.isReasonCodeMandatory())
        {
            retValue = checkFailed(strFmt("@SYS116347", fieldPName(ReasonTableRef, Reason)));
        }
        else if (_reasonComment)
        {
            reasonRefRecId = ReasonTableRef::createFromComment(_reasonComment);
        }

        return retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransOpenLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates open transaction lines for the free text invoice.
    /// </summary>
    /// <param name="_custTransOpen">
    ///    The <c>CustTransOpen</c> table buffer to hold the lines.
    /// </param>
    protected void createTransOpenLine(CustVendTransOpen _custTransOpen)
    {
        CustInvoiceLineIdRef custInvoiceLineIdRef;
        CustTransOpenLine custTransOpenLine;
        CustTrans custTransLocal;
        MarkupTrans markupTrans;
        CustInvoiceJour custInvoiceJourLocal;
        CustInvoiceTrans custInvoiceTrans;

        if (CustParameters::find().MarkOpenInvoiceLine == NoYes::Yes)
        {
            custTransLocal = CustTrans::find(_custTransOpen.RefRecId);

            // Open Transaction lines are created when transaction amount greater than zero,
            // and count for invoice lines must be greater than 1 or invoice lines must have any miscellaneous charges.
            if (custTransLocal.TransType == LedgerTransType::Cust && custTransLocal.AmountCur > 0.0 &&
               CustInvoiceTrans::numOfLines(custTransLocal.Invoice, custTransLocal.TransDate) > 1)
            {
                custInvoiceJourLocal = CustInvoiceJour::findFromCustTransVoucher(custTransLocal.Invoice,
                                                                                custTransLocal.Voucher,
                                                                                custTransLocal.TransDate,
                                                                                custTransLocal.AccountNum);
                if (custInvoiceJourLocal)
                {
                    while select forupdate custInvoiceTrans
                    where custInvoiceTrans.SalesId == custInvoiceJourLocal.SalesId &&
                    custInvoiceTrans.InvoiceDate == custInvoiceJourLocal.InvoiceDate &&
                    custInvoiceTrans.InvoiceId == custInvoiceJourLocal.InvoiceId &&
                    custInvoiceTrans.NumberSequenceGroup == custInvoiceJourLocal.NumberSequenceGroup &&
                    custInvoiceTrans.ReversedRecId == 0
                    {
                        custInvoiceLineIdRef.clear();
                        custInvoiceLineIdRef.EntityType = CustInvoiceLineType::Customer;
                        custInvoiceLineIdRef.insert();

                        custInvoiceTrans.CustInvoiceLineIdRef = custInvoiceLineIdRef.RecId;
                        custInvoiceTrans.update();

                        custTransOpenLine.CustTransOpen = _custTransOpen.RecId;
                        custTransOpenLine.CustInvoiceLineIdRef = custInvoiceLineIdRef.RecId;

                        if (SysCountryRegionCode::isLegalEntityInConsolidatedCountryRegion())
                        {
                            custTransOpenLine.AmountCur = CustOpenTransLineManager::calculateTotalAmountOfCustOpenTransLine(custInvoiceTrans);
                        }
                        else
                        {
                            custTransOpenLine.AmountCur = custInvoiceTrans.LineAmount + custInvoiceTrans.TaxAmount;
                        }
                        custTransOpenLine.insert();
                    }

                    while select forupdate markupTrans
                    where markupTrans.TransTableId == custInvoiceJourLocal.TableId &&
                    markupTrans.TransRecId == custInvoiceJourLocal.RecId &&
                   !markupTrans.IsDeleted
                    {
                        custInvoiceLineIdRef.clear();
                        custInvoiceLineIdRef.EntityType = CustInvoiceLineType::MarkupTrans;
                        custInvoiceLineIdRef.insert();

                        markupTrans.CustInvoiceLineIdRef = custInvoiceLineIdRef.RecId;
                        markupTrans.update();

                        custTransOpenLine.CustTransOpen = _custTransOpen.RecId;
                        custTransOpenLine.CustInvoiceLineIdRef = custInvoiceLineIdRef.RecId;
                        custTransOpenLine.AmountCur = markupTrans.Value + markupTrans.TaxAmount;
                        custTransOpenLine.insert();
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>custInterestCollectionInfo</Name>
				<Source><![CDATA[
    void custInterestCollectionInfo()
    {
        if (custInterestJour && Box::yesNo("@SYS78770", DialogButton::Yes, "@SYS53922"))
        {
            reverseInterestNote = true;
        }
        if (custCollectionLetterJour && Box::yesNo("@SYS78768",DialogButton::Yes, "@SYS53922"))
        {
            reverseCollectionLetter = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Create and add fields to the transaction reversal dialog box.
    /// </summary>
    /// <returns>
    ///    The transaction reversal dialog object.
    /// </returns>
    /// <remarks>
    ///    Allows update on the select control of transaction reversal dialog box.
    /// </remarks>
    public Object dialog()
    {
        dialog = super();

        if (!revoke)
        {
            if (custCollectionLetterJour)
            {
                dialogReverseCollectionLetter = dialog.addFieldValue(enumStr(boolean), reverseCollectionLetter, "@SYS78768", "@SYS88869");
            }
        }
        dialogReasonCode = new DialogField(dialog,extendedTypeStr(ReasonCode),#dialogReasonCodeFieldNo);
        dialog.addCtrlDialogField(dialogReasonCode.name());
        dialogReasonCode.init(dialog);
        dialogReasonCode.label("@SYS111246");
        dialogReasonCode.helpText("@SYS111246");
        dialogReasonCode.value();
        // assert if resulting field name was not set as expected as this must match the method which processes the event, e.g. fld992_1_validate
        Debug::assert(dialogReasonCode.fieldname() == #dialogReasonCodeCtrlName);

        //dialogReasonCode = dialog.addFieldValue(extendedTypeStr(ReasonCode), reasonCode, "@SYS111246", "@SYS111246");
        dialogReasonComment = dialog.addFieldValue(extendedTypeStr(ReasonComment), reasonComment, "@SYS114149", "@SYS114149");
        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogPostRun</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the transaction reversal dialog box properties.
    /// </summary>
    /// <param name="_dialog">
    ///    The <c>Runbase</c> dialog box object.
    /// </param>

    public void dialogPostRun(DialogRunbase _dialog)
    {
        super(_dialog);
        _dialog.dialogForm().formRun().controlMethodOverload(true);
        _dialog.dialogForm().formRun().controlMethodOverloadObject(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogSelectCtrl</Name>
				<Source><![CDATA[
    public void dialogSelectCtrl()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCustVendTransOpen</Name>
				<Source><![CDATA[
    CustVendTransOpen findCustVendTransOpen(RecId _custTransRecId)
    {
        return CustTransOpen::findRefId(_custTransRecId, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findInterestCollection</Name>
				<Source><![CDATA[
    private void findInterestCollection(CustTrans _custTrans)
    {
        CustTransDetails custTransDetails;

        custTransDetails = new CustTransDetails(_custTrans);
        custTransDetails.setCustVendTrans(_custTrans);

        custCollectionLetterJour = CustCollectionLetterJour::find(custTransDetails.collectionLetterNum(), _custTrans.AccountNum);
        custInterestJour = CustInterestJour::find(custTransDetails.interestNote());
    }

]]></Source>
			</Method>
			<Method>
				<Name>fld900_1_lookup</Name>
				<Source><![CDATA[
    // handle the lookup event for the "Reason Code" dialog field
    private void fld900_1_lookup()
    {
        FormControl formControl;
        LedgerJournalACType accountType;

        formControl = dialogReasonCode.control();
        if (GeneralLedgerExtension::findBySubledgerVoucherAccountingDate(voucherOrig, transDateOrig).RecId)
        {
            accountType = LedgerJournalACType::Ledger;
        }
        if (AssetTrans::findByVoucher(voucherOrig, transDateOrig).RecId)
        {
            accountType = LedgerJournalACType::FixedAssets;
        }
        if (VendTrans::findVoucherDate(voucherOrig, transDateOrig).RecId)
        {
            accountType = LedgerJournalACType::Vend;
        }
        if (BankAccountTrans::findByVoucher(voucherOrig, transDateOrig).RecId)
        {
            accountType = LedgerJournalACType::Bank;
        }

        ReasonFormTable::reasonCodeLookup(formControl, LedgerJournalACType::Cust, accountType, true, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fld900_1_modified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the modified event for the "Reason Code" dialog field.    
    /// </summary>
    /// <returns>True if the field was modified; otherwise, false.</returns>    
    protected boolean fld900_1_modified()
    {
        ReasonTable reasonTable;
        Object control;
        boolean valueWasModified;

        control = dialog.formRun().controlCallingMethod();
        valueWasModified = control.modified();
        if (valueWasModified)
        {
            if (dialogReasonCode.value()!='')
            {
                reasonTable = ReasonTable::find(dialogReasonCode.value());
                dialogReasonComment.value(reasonTable.Description);
            }
            else
            {
                dialogReasonComment.value('');
            }
        }

        return valueWasModified;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates and validates the reason code entered by the user in the <see cref="T:ReasonTableRef" />.
    /// </summary>
    /// <returns>
    ///    true if a valid reason code is entered; otherwise, false.
    /// </returns>
    public boolean getFromDialog()
    {
        LedgerJournalACType accountType;
        boolean ret;

        ret = true;
        if (!revoke)
        {
            if (custCollectionLetterJour)
            {
                reverseCollectionLetter = dialogReverseCollectionLetter.value();
            }
        }

        reasonCode = dialogReasonCode.value();
        reasonComment = dialogReasonComment.value();

        ret = this.createReasonTableRef(reasonCode, reasonComment, voucherOrig, transDateOrig, LedgerJournalACType::Cust);

        return super() && ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getModuleCustVend</Name>
				<Source><![CDATA[
    protected ModuleCustVend getModuleCustVend()
    {
        return ModuleCustVend::Cust;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSysModule</Name>
				<Source><![CDATA[
    protected SysModule getSysModule()
    {
        return SysModule::Cust;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Instantiates a new <see cref="T:LedgerVoucher" />.
    /// </summary>
    /// <returns>
    ///    A new <c>LedgerVoucher</c> object.
    /// </returns>
    public LedgerVoucher initLedgerVoucher()
    {
        ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Detail, SysModule::Cust, LedgerParameters::numRefLedgerReversalVoucher().numberSequenceTable().NumberSequence);
        ledgerVoucher.parmReversal(!revoke);

        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReasonCodeMandatory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the reason code is mandatory for a transaction reversal.
    /// </summary>
    /// <returns>
    /// true if the reason code is mandatory; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This is a public method that is used to find records.
    /// </remarks>
    public boolean isReasonCodeMandatory()
    {
        CustParameters custParameters;

        custParameters = CustParameters::find();
        if (custParameters.TransReversalReasonReq == NoYes::Yes)
        {
            mandatoryReasonCode = true;
        }
        else
        {
            mandatoryReasonCode = false;
        }
        return mandatoryReasonCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveCashDisc</Name>
				<Source><![CDATA[
    void moveCashDisc(TableId _custSettlementTableId,
                      RecId _custSettlementRecId,
                      TableId _custTransOpenTableId,
                      RecId _custTransOpenRecId)
    {
        CustTransCashDisc::moveCashDisc(_custSettlementTableId,
                                        _custSettlementRecId,
                                        _custTransOpenTableId,
                                        _custTransOpenRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList] + [super()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReasonRefRecId</Name>
				<Source><![CDATA[
    public ReasonRefRecID parmReasonRefRecId(ReasonRefRecID _reasonRefRecID = reasonRefRecID)
    {
        reasonRefRecID = _reasonRefRecID;

        return reasonRefRecID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransDateOrig</Name>
				<Source><![CDATA[
    public TransDate parmTransDateOrig(TransDate _transDateOrig = transDateOrig)
    {
        transDateOrig = _transDateOrig;

        return transDateOrig;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucherOrig</Name>
				<Source><![CDATA[
    public Voucher parmVoucherOrig(Voucher _voucherOrig = voucherOrig)
    {
        voucherOrig = _voucherOrig;

        return voucherOrig;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeCustVendTransOpen</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Removes one or more <c>CustTransOpen</c> records on a document reversal after first moving any
    ///    <c>CustTransCashDisc</c> records.
    /// </summary>
    /// <param name="_refRecId">
    ///    The <c>RecId</c> of the <c>CustTransOpen</c> that is reversed.
    /// </param>
    /// <param name="_custVendSettlementTableId">
    ///    The <c>TableId</c> to move any cash discounts.
    /// </param>
    /// <param name="_custVendSettlementRecId">
    ///    The <c>RecId</c> to which to move any cash discounts.
    /// </param>
    void removeCustVendTransOpen(RecId _refRecId, TableId _custVendSettlementTableId, RecId _custVendSettlementRecId)
    {
        CustTransOpen custTransOpen;

        while select forupdate custTransOpen
            where custTransOpen.RefRecId == _refRecId
        {
            this.moveCashDisc(custTransOpen.TableId,
                              custTransOpen.RecId,
                              _custVendSettlementTableId,
                              _custVendSettlementRecId);

            custTransOpen.delete();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>promptReversalInterestNote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prompts the end user regarding the reversal of interest notes.
    /// </summary>
    /// <returns>Returns the result of the user prompt.</returns>
    [Replaceable]
    protected DialogButton promptReversalInterestNote()
    {
        return Box::okCancel("@SYS322873", DialogButton::Ok, "@SYS343011");
    }

]]></Source>
			</Method>
			<Method>
				<Name>processReversal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the internal processing for the reversal process.
    /// </summary>
    protected void processReversal()
    {
        if (!custTransOrig) // If custTransOrig is empty, custTrans is the original
        {
            custTransOrig = CustTrans::find(custTrans.RecId, true);
        }
        else
        {
            custTransOrig = CustTrans::find(custTransOrig.RecId, true); // Select must be within the tts
        }

        inputGeneralJournalAccountEntry =
                                GeneralLedgerExtension::findAccountEntryBySubledgerVoucherAccountingDate(custTrans.Voucher, custTrans.TransDate);

        // <GIN>
        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            TaxwithholdTransReverse_IN::checkSettlementProcessRun(custTransOrig.Voucher, custTransOrig.TransDate);
        }
        if (TransactionReversal_CustVend::isSalesTaxSettlementProcessRun_IN(custTransOrig))
        {
            throw error("@GLS62632");
        }
        // </GIN>

        // Create ReasonTableRef from dialog
        if (TransactionReversalExecutionDetail::reversePostingFeatureEnabled())
        {
            TransactionReversalContract localContract = this.parmContract();

            if (localContract && localContract.parmReasonRefRecId())
            {
                reasonRefRecId = localContract.parmReasonRefRecId();
            }
            else if (localContract && localContract.parmReasonCode())
            {
                this.createReasonTableRef(localContract.parmReasonCode(), localContract.parmReasonComment(), voucherOrig, transDateOrig, LedgerJournalACType::Cust);
            }
        }

        RecId custTransOrigRecId = custTransOrig.RecId;
        ReasonRefRecID origReasonRefRecId = custTransOrig.ReasonRefRecId;
        custTransOrig.ReasonRefRecId = reasonRefRecID;

        // Performes the reversal/revoking of the ledger transactions connected to the customer transactions
        this.initLedgerVoucher();
                            
        TransactionReversal_Ledger transactionReversal_Ledger = TransactionReversal_Ledger::construct();
        this.initializeTransactionReversal_Ledger(transactionReversal_Ledger);

        transactionReversal_Ledger.createGeneralJournal(
                                custTransOrig.Voucher,
                                custTransOrig.TransDate,
                                ledgerVoucher,
                                true,
                                false,
                                reversalVoucher,
                                custTransOrig.RecId,
                                custTransOrig.AccountingEvent);

        // Set the reversalTraceNum which has been created in the transactionReversal_Ledger.createGeneralJournal
        reversalTraceNum = transactionReversal_Ledger.parmReversalTraceNum();
        reversalVoucher = transactionReversal_Ledger.parmReversalVoucher();

        this.createCustVendTrans(custTrans, custTransOrig);
        this.reverseInterestNote();
        this.reverseCollectionLetter();

        // Reverse any assets transactions created as a result of the vendor transaction.
        TransactionReversal_Asset transactionReversal_Asset = TransactionReversal_Asset::construct();
        this.initializeTransactionReversal_Asset(transactionReversal_Asset);

        transactionReversal_Asset.createAllAssetTransactions(custTransOrig.Voucher, custTransOrig.TransDate);

        ledgerVoucher.end();

        transactionReversal_Ledger.postReversal();

        if (revoke)
        {
            transactionReversal_Ledger.updateLedgerTransSettlements(reversalVoucher, custTrans, custTransOrig);
        }
        this.updateOriginal(custTransOrig.TransDate, custTransOrig.Voucher);
                            
        transactionReversal_Asset.updateOriginal(custTransOrig.TransDate, custTransOrig.Voucher);

        TransactionLog::create(TransactionLogType::TransactionReversal, "@SYS88954");

        this.updateCollectionsStatus();

        //Refresh the original CustTrans and make sure the original Reason is set on it.
        if (origReasonRefRecId)
        {
            custTransOrig = CustTrans::find(custTransOrig.RecId, true);
            custTransOrig.ReasonRefRecId = origReasonRefRecId;
            custTransOrig.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTransactionTypes</Name>
				<Source><![CDATA[
    private void validateTransactionTypes()
    {
        // AR transaction types
        if (custTrans.BillOfExchangeID)
        {
            throw error(strFmt("@AccountsReceivable:TransactionReversal_BillOfExchangeError", custTrans.Voucher, custTrans.BillOfExchangeID));
        }

        switch (custTrans.TransType)
        {
            case LedgerTransType::Interest:

                throw error(strFmt("@AccountsReceivable:TransactionReversal_InterestNoteError", custTrans.Voucher));
                break;

            case LedgerTransType::CollectionLetter:

                throw error(strFmt("@AccountsReceivable:TransactionReversal_CollectionLetterError", custTrans.Voucher));
                break;

            case LedgerTransType::ExchAdjustment:

                throw error(strFmt("@AccountsReceivable:TransactionReversal_ForeignCurrencyRevaluationError", custTrans.Voucher));
                break;

            case LedgerTransType::AdvanceAdjustment_RU:

                throw error(strFmt("@AccountsReceivable:TransactionReversal_AdvancedAdjustmentError", custTrans.Voucher));
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canReverse</Name>
				<Source><![CDATA[
    private void canReverse()
    {
        this.validateTransactionTypes();

        if (!custTrans.Approved)
        {
            throw error(strFmt("@AccountsReceivable:TransactionReversal_NotApprovedError", custTrans.Voucher));
        }

        // Invoice has been corrected so don't reverse it.
        if (custTrans.isParentOrAdjustingInvoice())
        {
            throw error(strFmt("@AccountsReceivable:TransactionReversal_MultipleTrxForVoucherError", custTrans.Voucher));
        }

        if (!custTrans.CustVendTrans::checkMultiTransByVoucherDate())
        {
            throw error(strFmt("@AccountsReceivable:TransactionReversal_MultipleTrxForVoucherError", custTrans.Voucher));
        }

        if (custTrans.BankLCExportLine != 0)
        {
            throw error(strFmt("@AccountsReceivable:TransactionReversal_BankLCEShipmentError", custTrans.Voucher));
        }

        if (CustTrans::isCashRegisterTrans_W(custTrans))
        {
            throw error(strFmt("@AccountsReceivable:TransactionReversal_VoucherOnCashRegisterTransactionError", custTrans.Voucher));
        }

        CustTransOpen custTransOpen = custTrans.transOpen();
        if (custTransOpen.RecId != 0 
            && specTrans::existByRef(custTransOpen.company(), tableNum(CustTransOpen), custTransOpen.RecId))
        {
            throw error(strFmt("@AccountsReceivable:TransactionReversal_MarkedForSettlementError", custTrans.Voucher));
        }

        TransactionReversalTrans transactionReversalTrans;

        if (custTrans.SettleAmountCur)
        {
            transactionReversalTrans = TransactionReversalTrans::findTransactionReversalTrans(tableNum(CustTrans), custTrans.RecId);

            if (!transactionReversalTrans.Reversed)
            {
                throw error(strFmt("@AccountsReceivable:TransactionReversalCannotReverseSettled", custTrans.Voucher));
            }
        }

        // if there is a vendTrans on the same voucher and it is settled, do not allow reversal
        VendTrans vendTransLocal = VendTrans::findVoucherDate(custTrans.Voucher, custTrans.TransDate);
        if (vendTransLocal.RecId != 0
             && (vendTransLocal.SettleAmountCur != 0))
        {
            if (transactionReversalTrans.RecId == 0)
            {
                transactionReversalTrans = TransactionReversalTrans::findTransactionReversalTrans(tableNum(CustTrans), custTrans.RecId);
            }

            // check if the settled amount is set because it was reversed
            if (!transactionReversalTrans.Reversed)
            {
                throw error(strFmt("@AccountsReceivable:TransactionReversal_VendorTransactionExistsOnVoucherError", custTrans.Voucher));
            }
        }

        if (!TaxWithholdTrans_IN::enableReverseButton(custTrans))
        {
            throw error(strFmt("@AccountsReceivable:TransactionReversal_CorrectingInvoiceError", custTrans.Voucher));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reversal</Name>
				<Source><![CDATA[
    void reversal(Args args)
    {        
        super(args);

        custTrans = args.record();

        this.defaultReversalDate(custTrans.TransDate);

        [custTransOrig, revoke, reversalTraceNum] = TransactionReversalTrans::findCustTransOrig(custTrans); // If custTransOrig is empty, custTrans is the original
        voucherOrig = custTrans.Voucher;
        transDateOrig = custTrans.TransDate;

        if (TransactionReversalExecutionDetail::isReversingWithContract(this.parmContract()))
        {
            this.canReverse();
        }

        if (this.checkLedgerPostingTypeApplicable(custTransOrig ? custTransOrig.Voucher : custTrans.Voucher,
                                                  custTransOrig ? custTransOrig.TransDate : custTrans.TransDate))
        {
            custTrans = TransactionReversalTrans::findLastCustTrans(custTrans, true); // custTrans is now the last/newest customer transaction
            this.findInterestCollection(custTransOrig ? custTransOrig : custTrans);

            minimumDate = custTransOrig.TransDate ? (revoke ? custTrans.TransDate : custTransOrig.TransDate) : custTrans.TransDate;

            this.saveLast();

            if (this.skipDialogPrompt(args) || this.prompt())
            {
                DialogButton dialogReverseInterestNote;
                CustInterestTrans custInterestTrans;

                select firstonly custInterestTrans
                    where custInterestTrans.CustTransId == custTrans.RecId;

                if (custInterestTrans)
                {
                    dialogReverseInterestNote = this.promptReversalInterestNote();
                    reverseInterestNote = true;
                }

                if (!reverseInterestNote || dialogReverseInterestNote == DialogButton::Ok)
                {
                    boolean validPeriod = true;
                    FiscalCalendarID calendarId;
                    AssetTrans assetBookTrans = AssetTrans::findByVoucher(custTrans.Voucher, custTrans.TransDate);

                    if (assetBookTrans)
                    {
                        // Now check any asset transaction calendars and make sure the date is valid within those open periods.
                        [validPeriod, calendarId] = TransactionReversal_Asset::checkValidAssetTranCalendar(assetBookTrans.Voucher, assetBookTrans.TransDate,
                                                      '', 0, reversalDate);
                    }

                    if (!validPeriod)
                    {
                        checkFailed(strFmt("@SYS95697", date2StrUsr(reversalDate, DateFlags::FormatAll), calendarId));
                    }
                    else
                    {
                        if (!this.hasTransferOccurred(custTrans.AccountingEvent))
                        {
                            checkFailed("@SYS344292");
                        }
                        else
                        {
                            ttsbegin;

                            this.processReversal();

                            this.updateDeductionAfterReverse(custTrans.RecId);
                            
                            ttscommit;
                            
                            this.logResult();
                        }
                    }
                }
                else
                {
                    info("@SYS322875");
                    throw Exception::Info;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>logResult</Name>
				<Source><![CDATA[
    private void logResult()
    {
        if (TransactionReversalExecutionDetail::isReversingWithContract(this.parmContract()))
        {
            str message;

            if (revoke)
            {
                message = strFmt("@AccountsReceivable:CustTrans_TransactionReversalRevokeNotification", custTrans.Voucher, custTrans.TransDate);
            }
            else
            {
                message = strFmt("@AccountsReceivable:CustTrans_TransactionReversalNotification", custTrans.Voucher, custTrans.TransDate);
            }

            info(message);

            if (reverseInterestNote)
            {
                info(strFmt("@AccountsReceivable:CustTrans_TransactionReversalInterestReversed", custTrans.Voucher, custTrans.TransDate));
            }
            if (reverseCollectionLetter)
            {
                info(strFmt("@AccountsReceivable:CustTrans_TransactionReveresalCollectionReversed", custTrans.Voucher, CustTrans.TransDate));
            }

            reverseSuccessful = true;
        }
        else
        {
            info(revoke ? "@SYS78559" : "@SYS78560");

            if (reverseInterestNote)
            {
                info("@SYS322871");
            }
            if (reverseCollectionLetter)
            {
                info("@SYS78563");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTransactionReversal_Ledger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>TransactionReversal_Ledger</c> class.
    /// </summary>
    /// <param name="_transactionReversal_Ledger">An instance of the <c>TransactionReversal_Ledger</c> class to be initialized.</param>
    protected void initializeTransactionReversal_Ledger(TransactionReversal_Ledger _transactionReversal_Ledger)
    {
        if (TransactionReversalExecutionDetail::reversePostingFeatureEnabled())
        {
            _transactionReversal_Ledger.parmContract(this.parmContract());
        }

        _transactionReversal_Ledger.parmReversalDate(reversalDate);
        _transactionReversal_Ledger.parmReversalTraceNum(reversalTraceNum);
        _transactionReversal_Ledger.parmSysModule(SysModule::Cust);
        _transactionReversal_Ledger.parmReasonRefRecId(reasonRefRecID);
        _transactionReversal_Ledger.parmRevoke(revoke);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTransactionReversal_Asset</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>TransactionReversal_Asset</c> class.
    /// </summary>
    /// <param name="_transactionReversal_Asset">An instance of the <c>TransactionReversal_Asset</c> class to be initialized.</param>
    protected void initializeTransactionReversal_Asset(TransactionReversal_Asset _transactionReversal_Asset)
    {
        if (TransactionReversalExecutionDetail::reversePostingFeatureEnabled())
        {
            _transactionReversal_Asset.parmContract(this.parmContract());
        }

        _transactionReversal_Asset.parmReversalVoucher(reversalVoucher);
        _transactionReversal_Asset.parmReversalDate(reversalDate);
        _transactionReversal_Asset.parmReversalTraceNum(reversalTraceNum);
        _transactionReversal_Asset.parmRevoke(revoke);
        _transactionReversal_Asset.parmReasonRefRecId(reasonRefRecID);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseCollectionLetter</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs the actual reversal of the collection letter.
    /// </summary>
    void reverseCollectionLetter()
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        LedgerEntry ledgerEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        CustCollectionLetterTrans custCollectionLetterTransSearch;
        CustCollectionLetterTrans custCollectionLetterTransLocal;
        CustCollectionLetterJour custCollectionLetterJourLocal;
        CustTrans custTransLocal;
        CustTrans custTransSearch;
        CustTransOpen custTransOpenSearch;
        LedgerVoucherTransObject ledgerVoucherTransObject;
        // <GEERU>
        GeneralJournalAccountEntry generalJournalAccountEntryOffset;
        GeneralJournalAccountEntry_W generalJournalAccountEntryW;
        LedgerEntry ledgerEntryOffset;
        Set ledgerTransSearchSet = new Set(typeName2Type(extendedtypestr(recId)));
        #isoCountryRegionCodes
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        if (custCollectionLetterJour && reverseCollectionLetter)
        {
            if (custCollectionLetterJour.LedgerVoucher)
            {
                this.getReference(reversalTraceNum);
                this.setTransactionTxt(reversalDate, reversalVoucher, custCollectionLetterJour.CollectionLetterNum, custCollectionLetterJour.AccountNum);

                while select RecId from subledgerVoucherGeneralJournalEntry
                    where subledgerVoucherGeneralJournalEntry.Voucher == custCollectionLetterJour.LedgerVoucher &&
                        subledgerVoucherGeneralJournalEntry.AccountingDate == custCollectionLetterJour.Updated &&
                        subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == custCollectionLetterJour.DataAreaId
                join RecId from generalJournalEntry
                    where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry &&
                        generalJournalEntry.Ledger == Ledger::current()
                join generalJournalAccountEntry
                    where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                // <GEERU>
                outer join * from generalJournalAccountEntryW
                    where generalJournalAccountEntryW.GeneralJournalAccountEntry == generalJournalAccountEntry.RecId &&
                        generalJournalAccountEntryW.GeneralJournalEntry == generalJournalEntry.RecId
                // </GEERU>
                outer join ledgerEntry
                    where ledgerEntry.GeneralJournalAccountEntry == generalJournalAccountEntry.RecId

                {
                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        if (ledgerTransSearchSet.add(generalJournalAccountEntry.RecId))
                        {
                            ledgerVoucherTransObject = LedgerVoucherTransObject::newGeneralJournal(generalJournalAccountEntry, ledgerEntry);
                            ledgerVoucherTransObject.parmTransactionCurrencyAmount(-generalJournalAccountEntry.TransactionCurrencyAmount);
                            ledgerVoucherTransObject.parmAccountingCurrencyAmount(-generalJournalAccountEntry.AccountingCurrencyAmount);
                            ledgerVoucherTransObject.parmReportingCurrencyAmount(-generalJournalAccountEntry.ReportingCurrencyAmount);
                            ledgerVoucherTransObject.parmText(transactionTxt.txt());
                            ledgerVoucher.addTrans(ledgerVoucherTransObject);

                            if (generalJournalAccountEntryW.hasBond_RU())
                            {
                                generalJournalAccountEntryOffset = generalJournalAccountEntryW.bondedLine_RU();
                                ledgerEntryOffset = LedgerEntry::findBygeneralJournalAccountEntry(generalJournalAccountEntryOffset.RecId);
                                ledgerTransSearchSet.add(generalJournalAccountEntryOffset.RecId);
                                ledgerVoucherTransObject = LedgerVoucherTransObject::newGeneralJournal(generalJournalAccountEntryOffset, ledgerEntryOffset);
                                ledgerVoucherTransObject.parmAmountCur(-generalJournalAccountEntryOffset.TransactionCurrencyAmount);
                                ledgerVoucherTransObject.parmAmountMST(-generalJournalAccountEntryOffset.AccountingCurrencyAmount);
                                ledgerVoucherTransObject.parmAmountMSTSecondary(-generalJournalAccountEntryOffset.ReportingCurrencyAmount);
                                ledgerVoucherTransObject.parmTransTxt(transactionTxt.txt());
                                ledgerVoucher.addTrans(ledgerVoucherTransObject);
                                ledgerVoucher.bondLast2_RU();
                            }
                        }
                    }
                    else
                    {
                        // </GEERU>
                        ledgerVoucherTransObject = LedgerVoucherTransObject::newGeneralJournal(generalJournalAccountEntry, ledgerEntry);
                        ledgerVoucherTransObject.parmTransactionCurrencyAmount(-generalJournalAccountEntry.TransactionCurrencyAmount);
                        ledgerVoucherTransObject.parmAccountingCurrencyAmount(-generalJournalAccountEntry.AccountingCurrencyAmount);
                        ledgerVoucherTransObject.parmReportingCurrencyAmount(-generalJournalAccountEntry.ReportingCurrencyAmount);
                        ledgerVoucherTransObject.parmText(transactionTxt.txt());
                        ledgerVoucher.addTrans(ledgerVoucherTransObject);
                        // <GEERU>
                    }
                    // </GEERU>

                    // original stampled
                    TransactionReversalTrans::createTransaction(tablenum(CustCollectionLetterJour),custCollectionLetterJour.RecId,reversalTraceNum);
                }

                while select forupdate custCollectionLetterTransSearch
                    where custCollectionLetterTransSearch.CollectionLetterNum == custCollectionLetterJour.CollectionLetterNum
                       && custCollectionLetterTransSearch.AccountNum == custCollectionLetterJour.AccountNum
                       && custCollectionLetterTransSearch.Voucher == custCollectionLetterJour.LedgerVoucher // has been posted
                {
                    // create reversed custCollectionLetterTrans
                    custCollectionLetterTransLocal = custCollectionLetterTransSearch.data();
                    custCollectionLetterTransLocal.CalculationAmount = custCollectionLetterTransLocal.CalculationAmount * -1;
                    custCollectionLetterTransLocal.RemainAmount = custCollectionLetterTransLocal.RemainAmount * -1;
                    custCollectionLetterTransLocal.Txt = transactionTxt.txt();
                    custCollectionLetterTransLocal.insert();
                    TransactionReversalTrans::createTransaction(tablenum(CustCollectionLetterTrans),custCollectionLetterTransLocal.RecId,reversalTraceNum);

                    // create reversed custTrans
                    select firstonly forupdate custTransSearch
                     where custTransSearch.RecId == custCollectionLetterTransSearch.CustTransId;
                    if (custTransSearch.RecId)
                    {
                        custTransLocal = custTransSearch.data();
                        custTransLocal.AmountCur = custTransSearch.AmountCur * -1;
                        custTransLocal.AmountMST = custTransSearch.AmountMST * -1;
                        custTransLocal.ReportingCurrencyAmount = custTransSearch.ReportingCurrencyAmount * -1;
                        custTransLocal.Txt = transactionTxt.txt();
                        custTransLocal.insert();
                        TransactionReversalTrans::createTransaction(tablenum(CustTrans),custTransLocal.RecId,reversalTraceNum);

                        // original stampled
                        TransactionReversalTrans::createTransaction(tablenum(CustTrans),custTransSearch.RecId,reversalTraceNum);

                        custTransOpenSearch = CustTransOpen::findRefId(custTransSearch.RecId, true);
                        if (custTransOpenSearch.RecId)
                        {
                            custTransOpenSearch.delete();
                        }
                    }
                }
            }

            // cancel custCollectionLetterJour
            custCollectionLetterJourLocal = null;
            custCollectionLetterJourLocal = CustCollectionLetterJour::find(custCollectionLetterJour.CollectionLetterNum,
                                                                           custCollectionLetterJour.AccountNum,
                                                                           true);
            custCollectionLetterJourLocal.setCancelling();
            custCollectionLetterJourLocal.update();
            TransactionReversalTrans::createTransaction(tablenum(CustCollectionLetterJour),custCollectionLetterJourLocal.RecId,reversalTraceNum);

            // cancel custCollectionLetterTrans
            while select forupdate custCollectionLetterTransSearch
             where custCollectionLetterTransSearch.CollectionLetterNum == custCollectionLetterJour.CollectionLetterNum
                && custCollectionLetterTransSearch.AccountNum == custCollectionLetterJour.AccountNum
            {
                TransactionReversalTrans::createTransaction(tablenum(CustCollectionLetterTrans), custCollectionLetterTransSearch.RecId,reversalTraceNum);
            }
            custCollectionLetterJour.cancelCollectionLetterCodeCustTrans();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseInterestNote</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs the actual reversal of the interest note.
    /// </summary>
    void reverseInterestNote()
    {
        CustInterestTrans custInterestTransSearch;
        CustInterestAdjust custInterestAdjust = new CustInterestAdjust();
        CustInterestTransLine custInterestTransLine;
        boolean isBillingClassificationEnabled = CustParameters::isBillingClassificationEnabled();

        if (reverseInterestNote)
        {
            while select custInterestTransSearch
                where custInterestTransSearch.CustTransId == custTrans.RecId
            outer join CustInterestTrans, InterestNote from custInterestTransLine
                where custInterestTransLine.CustInterestTrans == custInterestTransSearch.RecId &&
                        custInterestTransLine.InterestNote == custInterestJour.InterestNote
            {
                while select custInterestJour
                    where custInterestJour.InterestNote == custInterestTransSearch.InterestNote
                            && (custInterestJour.CustBillingClassification != 0
                                || !isBillingClassificationEnabled)
                {
                    if (custInterestJour.Status == PrintPostCancel::Posted)
                    {
                        custInterestAdjust.reverseTransaction(custInterestTransSearch);
                    }
                    else
                    {
                        ttsbegin;
                        custInterestJour = CustInterestJour::find(custInterestJour.InterestNote, true);
                        custInterestJour.Status = PrintPostCancel::Canceled;
                        custInterestJour.update();
                        ttscommit;
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>tableIdNumber</Name>
				<Source><![CDATA[
    TableId tableIdNumber()
    {
        return tableNum(CustTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Version version = RunBase::getVersion(_packedClass);
        container base;
        boolean ret;

        switch (version)
        {
            case #CurrentVersion :
                [version, #CurrentList, base] = _packedClass;
                ret = super(base);
                break;

            default :
                ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOriginal</Name>
				<Source><![CDATA[
    // Sets the original TransactionReversalTrans records to be either reversed or not reversed

    public void updateOriginal(
        TransDate _transDate,
        Voucher _voucher,
        boolean _excludeSubledgerJournalTransfers = false)
    {
        CustTrans custTransLocal;

        while select RecId from custTransLocal
            where custTransLocal.Voucher == _voucher
               && custTransLocal.TransDate == _transDate
        {
            TransactionReversalTrans::updateOriginal(tableNum(CustTrans), custTransLocal.RecId, !revoke);
        }

        super(_transDate, _voucher, _excludeSubledgerJournalTransfers);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    public boolean validate(Object _calledFrom = null)
    {
        boolean ret;
        ret = super(_calledFrom);
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAuxiliaryCustTrans</Name>
				<Source><![CDATA[
    //create cust transactions that are also (except caller transaction) in voucher that is being reverted.
    static void createAuxiliaryCustTrans(CustVendTrans _custVendTrans,
                                         TraceNum _reversalTraceNum,
                                         Voucher _reversalVoucher,
                                         TransDate _reversalDate,
                                         LedgerVoucher _ledgerVoucher,
                                         boolean _revoke = false)
    {
        TransactionReversalOriginalTransactionFinder originalTransactionFinder = TransactionReversalOriginalTransactionFinder::construct(ModuleCustVend::Cust);
        originalTransactionFinder.init(_custVendTrans, _revoke);

        CustTrans custTransLast = originalTransactionFinder.getLastTransaction();
        CustTrans custTransOrig = originalTransactionFinder.getOriginalTransaction();
        boolean revoke = originalTransactionFinder.getRevoke();

        TransactionReversal_Cust transactionReversal = new TransactionReversal_Cust();
        transactionReversal.findInterestCollection(custTransOrig);

        transactionReversal.parmReversalDate(_reversalDate);
        transactionReversal.parmReversalTraceNum(_reversalTraceNum);
        transactionReversal.parmReversalVoucher(_reversalVoucher);
        transactionReversal.parmRevoke(revoke);
        transactionReversal.parmLedgerVoucher(_ledgerVoucher);
        transactionReversal.createCustVendTrans(custTransLast, custTransOrig);

        if (!revoke)
        {
            transactionReversal.custInterestCollectionInfo();
        }

        transactionReversal.reverseInterestNote();
        transactionReversal.reverseCollectionLetter();

        TransactionReversalTrans::updateOriginal(tableNum(CustTrans), custTransOrig.RecId, !revoke);
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    static ClassDescription description()
    {
        return "@SYS78542";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void main(Args args)
    {
        TransactionReversal_Cust transactionReversal = TransactionReversal_Cust::construct();

        transactionReversal.reversal(args);
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static TransactionReversal_Cust construct()
    {
        return new TransactionReversal_Cust();
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        taxTransRecIdMap = new Map(Types::Int64, Types::Int64);

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCollectionsStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the collection status for the current <c>CustTrans</c> record.
    /// </summary>
    protected void updateCollectionsStatus()
    {
        if (CustDisputeHistoryAutomation::doesDisputeExist(custTransOrig.RecId))
        {
            CustDisputeHistoryAutomationPayment::updateCollectionsStatus(
                custTransOrig.RecId,
                CustDisputeHistoryAutomationAction::Reversal,
                reasonCode,
                reasonComment);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDeductionAfterReverse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deny the deduction process after reversal.
    /// </summary>
    /// <param name="_recId">
    ///  Customer transaction record.
    /// </param>
    /// <remarks>
    /// After reverse the payment journal deny the deduction which is attached to payment journal
    /// deduction status should be closed and inserts the deduction events.
    /// </remarks>
    private void updateDeductionAfterReverse(RecId _recId)
    {
        TmpTAMDeductionParmDeny tmpTAMDeductionParmDeny;
        TAMDeductionUpdate_Deny tamDeductionUpdate_Deny;
        TAMDeduction            deduction;
                            
        select deduction
            where deduction.CustTransRecId == _recId
                && deduction.TAMDeductionStatus == TAMDeductionStatus::Open;

        if (deduction)
        {
            tamDeductionUpdate_Deny = TAMDeductionUpdate_Deny::construct(tmpTAMDeductionParmDeny);
            tamDeductionUpdate_Deny.parmSkipPrompt(true);
        
            tmpTAMDeductionParmDeny.DeductionID         = deduction.TAMDeductionID;
            tmpTAMDeductionParmDeny.DeductionDenyReason = "@SCM:JournalReversal";
            tmpTAMDeductionParmDeny.insert();
                            
            tamDeductionUpdate_Deny.run();
        }
        
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInvoiceJourExtensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a reversal records in extension tables.
    /// </summary>
    /// <param name = "_custInvoiceJourNew">The new table buffer of <c>CustInvoiceJour</c> table.</param>
    /// <param name = "_custInvoiceJourOrig">The original table buffer of <c>CustInvoiceJour</c> table.</param>
    protected void createInvoiceJourExtensions(CustInvoiceJour _custInvoiceJourNew, CustInvoiceJour _custInvoiceJourOrig)
    {
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>