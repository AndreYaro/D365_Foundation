<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxPurch</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>TaxPurch</c> class is the tax calculation class for purchase.
/// </summary>
class TaxPurch extends TaxCalculation
{
    // <GEEU>
    #EECountryRegionCodes
    // </GEEU>

    PurchCalcTax            purchCalcTax;
    Common                  line;
    MarkupTrans             markupTrans;

    NoYes                   isMarkupBeingCalculated;

    RefTableId              sourceTableId;
    RefTableId              parentSourceTableId;
    RefRecId                parentSourceRecId;

    ReverseCharge_W         reverseCharge;

    // <GIN>
    PurchLine               purchLinePrevRecord;
    // </GIN>

    // <GEERU>
    boolean                 processExemptTax;
    // </GEERU>

    private container cachedCountryRegionType;
    private Set cachedNonPOInvoiceLine;
    private boolean isCalcWHTInInvoiceEnabled;
    private boolean isCalcWHTInInvoiceWithChargeEnabled;

    #define.CurrentVersion(1)
    #localmacro.CurrentList
        isMarkupBeingCalculated,
        sourceTableId
    #endmacro
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addTaxAdjustmentTypes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a collection of tax adjustment types that can be used to make tax adjustments.
    /// </summary>
    /// <remarks>
    /// By default, all the transactions that use tax adjustment functions support summary tax adjustment
    /// type.
    /// </remarks>
    protected void addTaxAdjustmentTypes()
    {
        super();

        if (purchCalcTax && purchCalcTax.useDetailsSalesTaxAdjustmentType())
        {
            this.addTaxAdjustmentType(TaxAdjustmentType::Detail);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowAdjustBaseAmountForTaxAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the transaction supports adjusting the calculated base amount when tax is
    ///    included in item price and the user adjusts the tax amount.
    /// </summary>
    /// <returns>
    ///    true if adjusting the calculated base amount is supported; otherwise, false.
    /// </returns>
    public boolean allowAdjustBaseAmountForTaxAdjustment()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowSingleLineAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a transaction supports a single line adjustment.
    /// </summary>
    /// <returns>
    /// true if a single line adjustment is supported; otherwise, false.
    /// </returns>
    public boolean allowSingleLineAdjustment()
    {
        boolean allowSingleLineAdjustment;

        if (purchCalcTax)
        {
            allowSingleLineAdjustment = purchCalcTax.allowSingleLineAdjustment();
        }

        return allowSingleLineAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates line specific tax codes for the miscellaneous charges associated with the transaction
    ///    header and transaction lines.
    /// </summary>
    protected void calcMarkup()
    {
        NoYes       moreMarkup;
        TaxBase     baseAmount;
        TaxBase     lineAmount;
        // <GEEU>
        VatDueDate_W        localVatDueDate;
        // </GEEU>

        moreMarkup  = true;
        parentSourceTableId = this.sourceTableId();
        parentSourceRecId = this.sourceRecId();
        while (moreMarkup)
        {
            markupTrans= purchCalcTax.nextMarkupLine();
            if (markupTrans)
            {
                if (markupTrans.isIntercompanyVirtualCharge())
                {
                    continue;
                }

                isMarkupBeingCalculated= NoYes::Yes;

                // <GEEU>
                if (TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
                {
                    this.parmVatRegData_W(purchCalcTax.vatRegData_W());
                    localVatDueDate = purchCalcTax.vendInvoiceInfoTable().vendInvoiceInfoTable_W().VatDueDate_W;
                }
                // </GEEU>

                if (purchCalcTax.markupTaxGroup() && purchCalcTax.markupTaxItemGroup())
                {
                    markupTransTaxableDocumentLines++;
                }
                this.configureTaxForMarkupLine(markupTrans, purchCalcTax.transTransId());
                this.configureWithholdTaxForMarkupLine(markupTrans);

                lineAmount = purchCalcTax.markupAmount();

                // get the line amount excluding tax (base amount)
                if (purchCalcTax.isTaxIncluded())
                {
                    baseAmount = this.amountExclTax(lineAmount, false, false, 0, '', '', markupTrans.RecId, markupTrans.TableId);
                }
                else
                {
                    baseAmount = lineAmount;
                }

                this.initializeTaxForLine(purchCalcTax.isTaxIncluded(),
                                            baseAmount,
                                            lineAmount,
                                            purchCalcTax.markupDefaultDimension(),
                                            purchCalcTax.operationAccountMarkup(),
                                            // <GEEU>
                                            purchCalcTax.operationPostingMarkup(),
                                            0,
                                            '',
                                            0,
                                            '',
                                            0,
                                            localVatDueDate);
                                            // </GEEU>

                this.calculateLineSpecificTaxCodes();
            }
            else
            {
                isMarkupBeingCalculated= NoYes::No;
                moreMarkup  = false;
            }
        }
        parentSourceTableId = 0;
        parentSourceRecId = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Walks through purchase order lines and markup lines for a purchase order to calculate taxes.
    /// </summary>
    /// <returns>
    ///    The tax amount excluding the use tax.
    /// </returns>
    TaxAmount calculateTax()
    {
        TaxAmountCur        taxAmount;
        boolean             moreLines;
        Amount              baseAmount;

        AmountCur           lineAmount;
        Currency            sourceCurrency;
        Percent             endDiscPercent;
        // <GEEU>
        VatDueDate_W        localVatDueDate;
        // </GEEU>
        // <GIN>
        PurchCalcTax_ParmTrans  purchCalcTaxParmTrans;
        boolean                 success = true;
        // </GIN>

        if (!headingRecId)
        {
            return 0;
        }

        if (Tax::isTaxIntegrationEnabledForBusinessProcess(TaxIntegrationBusinessProcess::Purchase))
        {
            return this.calcUsingTaxIntegration();
        }

        if (this.skipTaxCalculations())
        {
            return 0;
        }

        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            return 0;
        }

        Microsoft.Dynamics.Ax.Xpp.ErrorException errorEx;
        Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource taxEventSourceLog = Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource::Log;
        System.Diagnostics.Stopwatch stopWatch;
        guid identifier;
        ReqReaderWriterLock lock = ReqReaderWriterLock::construct();
        str lockName = this.lockName();

        try
        {
            stopWatch = new System.Diagnostics.Stopwatch();
            identifier = newGuid();

            if (TaxCalculationInstrumentationToggle::instance().isEnabled())
            {  
                taxEventSourceLog.CalculateTaxStart(identifier, TaxUncommitted::callStackInfo());
            }
            else
            {
                taxEventSourceLog.CalculateTaxStart(identifier);
            }

            stopWatch.Start();

            this.enterTaxableDocumentLock(lock, lockName);

            // <GIN>
            if (isTaxParametersEnabled && purchCalcTax is PurchCalcTax_ParmTrans)
            {
                purchCalcTaxParmTrans = purchCalcTax as PurchCalcTax_ParmTrans;
            }
            // </GIN>

            sourceCurrency = Currency::find(sourceCurrencyCode);

            // Multiple purchase orders can be posted in one invoice. The discount percentage is retrieved from each
            // purchase order header. When new header fields impact tax calculation, please modify tax integration
            // in the method <c>TaxIntegrationPurchTableDataRetrieval.copyToLineFromHeaderTable</c> to keep
            // the same behavior.
            endDiscPercent = purchCalcTax.endDisc();

            this.initializeCalculation();

            purchCalcTax.initCursor();
            moreLines   = true;
            while (moreLines)
            {
                line = purchCalcTax.nextLine();
                // <GIN>
                if (isCustomsEnabled
                    && this.documentStatus_IN() == DocumentStatus::BillOfEntry_IN
                    && purchCalcTaxParmTrans)
                {
                    parentSourceTableId     = purchCalcTaxParmTrans.parmLineTableId_IN();
                    parentSourceRecId       = purchCalcTaxParmTrans.parmLineRecId_IN();
                }
                // </GIN>
                if (line.RecId)
                {
                    if (!purchCalcTax.isNewLine())
                    {
                        continue;
                    }

                    // Allign unCommittedTax sourceCurrencyCode with the document line currency code.
                    sourceCurrency = this.setsourceLineCurrency(sourceCurrency, line);

                    lineAmount = purchCalcTax.transLineAmount();

                    // Aggregate all lines in the total order balance.
                    purchCalcTax.updateOrderBalance(lineAmount);

                    if (purchCalcTax.skipTaxRecalculationsForLine())
                    {
                        continue;
                    }

                    // <GBR>
                    if (BrazilParameters::isEnabled())
                    {
                        directImport_BR                         = purchCalcTax.directImport_BR();
                        useAndConsumption_BR                    = purchCalcTax.useAndConsumption_BR();
                        assetICMSReceivableLongTerm_BR          = purchCalcTax.assetICMSReceivableLongTerm_BR();
                        assetPISCOFINSReceivableLongTerm_BR     = purchCalcTax.assetPISCOFINSReceivableLongTerm();
                    }
                    // </GBR>

                    // <GEEU>
                    if (TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
                    {
                        this.parmVatRegData_W(purchCalcTax.vatRegData_W());
                        localVatDueDate = purchCalcTax.vendInvoiceInfoTable().vendInvoiceInfoTable_W().VatDueDate_W;
                    }
                    // </GEEU>

                    if (purchCalcTax.transTaxGroup() && purchCalcTax.transTaxItemGroup())
                    {
                        taxableDocumentLines++;
                    }

                    this.configureTaxForPurchLine();
                    this.configureWithholdTaxForPurchLine();

                    // get the line amount excluding tax (base amount)
                    if (purchCalcTax.isTaxIncluded())
                    {
                        baseAmount = this.amountExclTax(lineAmount,
                                                    false,
                                                    true,
                                                    purchCalcTax.transQty(),
                                                    purchCalcTax.transPurchUnit(),
                                                    purchCalcTax.transItemId(),
                                                    this.sourceRecId(),
                                                    this.sourceTableId());
                    }
                    else
                    {
                        baseAmount = lineAmount;
                    }

                    // deduct total discount from the base amount and the line amount
                    if (endDiscPercent && purchCalcTax.lineEndDisc())
                    {
                        baseAmount -= purchCalcTax.lineEndDiscAmount(baseAmount);
                        lineAmount -= purchCalcTax.lineEndDiscAmount(lineAmount);
                    }

                    // <GIN>
                    if (isTaxParametersEnabled)
                    {
                        this.parmAssessableValue_IN(purchCalcTax.assessableValue_IN());
                        this.parmMaximumRetailPrice_IN(purchCalcTax.maximumRetailPrice_IN());
                    }
                    // </GIN>

                    LedgerDimensionDefaultAccount ledgerAccount = 0;
                    
                    if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
                    {
                        // For project PO, get cost account ledger dimension from project category
                        PurchLine purchLine;
                    
                        if (line is PurchLine)
                        {
                            purchLine = line as PurchLine;
                        }
                        else
                        {
                            purchLine = PurchLine::findInventTransId(purchCalcTax.transTransId());
                        }
                    
                        if (purchLine
                            && purchLine.ItemId
                            && purchLine.ProjId
                            && purchLine.ProjCategoryId)
                        {
                            ledgerAccount = ProjPosting::getLedgerDimension(
                            ProjAccountType::CostAccount,
                            purchLine.ProjId,
                            purchLine.ProjCategoryId,
                            0,
                            false,
                            false,
                            purchLine.TaxGroup);
                        }
                    }

                    if (ledgerAccount == 0)
                    {
                        ledgerAccount = purchCalcTax.operationAccount();
                    }

                    this.initializeTaxForLine(purchCalcTax.isTaxIncluded(),
                                                baseAmount,
                                                lineAmount,
                                                purchCalcTax.transDefaultDimension(),
                                                ledgerAccount,
                                                purchCalcTax.operationPosting(),
                                                purchCalcTax.transPcsPrice(),
                                                purchCalcTax.transItemId(),
                                                purchCalcTax.transQty(),
                                                //<GEEU>
                                                purchCalcTax.transPurchUnit(),
                                                0,
                                                localVatDueDate
                                                //</GEEU>
                                                );

                    this.calculateLineSpecificTaxCodes();

                    if (!skipLineMarkup)
                    {
                        this.calcMarkup();
                    }
                }
                else
                    moreLines   = false;
            }

            if (!skipTableMarkup)
            {
                purchCalcTax.initCursorMarkupHeader(purchCalcTax.tableId(),
                                                    purchCalcTax.recID());
                this.calcMarkup();
            }

            this.calculateTotalTaxCodes();

            boolean doIsolateTransactionScopeTrue = this.useSeperateTransactionScopeToMaintainTaxUncommitted();

            taxAmount = this.finalizeCalculation(
                // <GEEU>
                TaxParameters::isBankExchRateEnabled_W() && purchCalcTax.vendInvoiceInfoTable(),
                // </GEEU>
                doIsolateTransactionScopeTrue
                );
        }
        catch (errorEx) // errorEx is the same as Exception::Error
        {
            success = false;
			taxEventSourceLog.TaxProcessError(guid2Str(newGuid()),
											  errorEx.Message,
											  errorEx.StackTrace,
											  methodStr(TaxPurch, calculateTax));
            throw Exception::Error;
        }
        finally
        {
            this.exitTaxableDocumentLock(lock, lockName);

            stopWatch.Stop();
            select count(RecId) from taxWorkTrans;
            taxEventSourceLog.CalculateTaxStop(identifier,
                                               SysCountryRegionCode::countryInfo(),
                                               tableId2Name(headingTableId),
                                               TaxTelemetryConstants::salesTax,
                                               stopWatch.ElapsedMilliseconds,
                                               taxableDocumentLines,
                                               markupTransTaxableDocumentLines,
                                               taxWorkTrans.RecId,
                                               purchCalcTax.isTaxIncluded(),
                                               headingTableId,
                                               tableId2Name(headingTableId),
                                               headingRecId,
                                               success);
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcUsingTaxIntegration</Name>
				<Source><![CDATA[
    private TaxAmount calcUsingTaxIntegration()
    {
        Microsoft.Dynamics.Ax.Xpp.ErrorException errorEx;
        ReqReaderWriterLock lock = ReqReaderWriterLock::construct();
        TaxAmountCur taxAmount;
        str lockName = this.lockName();
        try
        {
            this.enterTaxableDocumentLock(lock, lockName);

            TaxIntegrationDocumentObject document;
            if (TaxIntegrationPurchReqDocumentPerLineFlight::instance().isEnabled()
                && purchCalcTax is PurchCalcTax_PurchReq)
            {
                purchCalcTax.initCursor();
                boolean moreLines = true;
                while (moreLines)
                {
                    line = purchCalcTax.nextLine();
                    if (line.RecId)
                    {
                        if (!purchCalcTax.isNewLine())
                        {
                            continue;
                        }
                        document = TaxIntegrationDocumentObject::constructWithRecord(purchCalcTax.getSource());

                        this.setFieldsForLegacyTax();
                        this.setFieldsForTaxIntegrationDocumentObject(document);

                        TaxIntegrationFacade::calculate(document);

                        var mapIncl = document.getAmountIncludingTax();
                        MapEnumerator enumeratorIncl = new MapEnumerator(mapIncl);
                        while (enumeratorIncl.moveNext())
                        {
                            amountInclTaxMap.insert(enumeratorIncl.currentKey(), enumeratorIncl.currentValue());
                        }

                        var mapExcl = document.getAmountExcludingTax();
                        MapEnumerator enumeratorExcl = new MapEnumerator(mapExcl);
                        while (enumeratorExcl.moveNext())
                        {
                            amountExclTaxMap.insert(enumeratorExcl.currentKey(), enumeratorExcl.currentValue());
                        }
                    }
                    else
                    {
                        moreLines = false;
                    }
                }
            }
            else
            {
                if (this.usingSourceRecordInPurchCalcTax())
                {
                    document = TaxIntegrationDocumentObject::constructWithRecord(purchCalcTax.getSource());
                }
                else
                {
                    document = TaxIntegrationDocumentObject::construct(
                    purchCalcTax.headingTableID(),
                    purchCalcTax.headingRecID());
                }

                if (TaxIntegrationUtils::isTaxIntegrationEnabledForTaxSolutionProvider())
                {
                    if (purchCalcTax is PurchCalcTax_ParmTrans)
                    {
                        PurchCalcTax_ParmTrans parmTrans = purchCalcTax;
                        if (parmTrans.parmDocumentStatus() == DocumentStatus::PurchaseOrder)
                        {
                            // here PO confirmation uses parm table, but the heading table is still purchTable.
                            // and at the point calling tax calculation in confirmation form, the Po status is still purchaseOrder.
                            // While, when we are determining the status, the status should be PO confirmation,
                            // so that we hardcoded here if the it is called from parmTrans, and the status is PurchaseOrder,
                            // it should be in Po confirmation form, the runtime status should be confirmation.
                            document.setDocumentStatus(DocumentStatus::Confirmation);
                        }
                        else
                        {
                            document.setDocumentStatus(parmTrans.parmDocumentStatus());
                        }
                    }
                }

                this.setFieldsForLegacyTax();
                this.setFieldsForTaxIntegrationDocumentObject(document);

                TaxIntegrationFacade::calculate(document);
                amountInclTaxMap = document.getAmountIncludingTax();
                amountExclTaxMap = document.getAmountExcludingTax();
            }

            boolean doIsolateTransactionScopeTrue = this.useSeperateTransactionScopeToMaintainTaxUncommitted();

            taxAmount = this.finalizeCalculationForTaxIntegration(
                purchCalcTax.vendInvoiceInfoTable()
                && (TaxParameters::isBankExchRateEnabled_W()
                    || TaxSpecificExchangeRateHelper::isTaxSpecificExchangeRateEnabled()),
                doIsolateTransactionScopeTrue);
        }
        catch (errorEx) // errorEx is the same as Exception::Error
        {
            throw Exception::Error;
        }
        finally
        {
            this.exitTaxableDocumentLock(lock, lockName);

        }
        return taxAmount;

    }

]]></Source>
			</Method>
			<Method>
				<Name>usingSourceRecordInPurchCalcTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Judge if we can use source record buffer for tax calculation.
    /// </summary>
    /// <returns>
    /// true if use source record for calculation; otherwise false.
    /// </returns>
    /// <remarks>
    /// For RFQ, the buffer in purchCalcTax.getSource() is not consistent with purchCalcTax.headingTableID()
    /// For PurchCalcTax_RFQReply, the getSource also query again from DB.
    /// Note, RFQ case table is OK and not bypassed here.
    /// </remarks>
    private boolean usingSourceRecordInPurchCalcTax()
    {
        boolean ret = false;

        ret = (TaxIntegrationConstructWithSourceRecordPurchaseFlight::instance().isEnabled()
               && purchCalcTax.headingTableID() != tableNum(PurchRFQTable))
               || (purchCalcTax.headingTableId() == tableNum(PurchTable));

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionLineCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the transaction line count.
    /// </summary>
    /// <returns>The transaction line count.</returns>
    protected int getTransactionLineCount()
    {
        int transactionLineCount = 0;

        purchCalcTax.initCursor();
        while (purchCalcTax.nextLine())
        {
            transactionLineCount++;
        }

        purchCalcTax.initCursor();
        return transactionLineCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>finalizeCalculationForTaxIntegration</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finalizes tax calculations by processing tax adjustments and optionally inserting records into the
    ///    <c>TaxUncommitted</c> and <c>SourceDoucmentLine</c> tables.
    /// </summary>
    /// <param name="_calculateTaxDifferenceAmount">
    ///    true if tax difference amount need to be calculated; optional.
    /// </param>
    /// <param name="_doIsolateTransactionScope">
    /// true if <c>TaxUncommitted</c> should be maintained in a independent transaction scope; otherwise false.
    /// </param>
    /// <returns>
    ///    The final tax total amount.
    /// </returns>
    protected TaxAmountCur finalizeCalculationForTaxIntegration(
        boolean _calculateTaxDifferenceAmount = false,
        boolean _doIsolateTransactionScope = false
        )
    {
        return super(_calculateTaxDifferenceAmount, _doIsolateTransactionScope);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFieldsForLegacyTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets fields for legacy tax.
    /// </summary>
    /// <remarks>
    /// This method is called by calcUsingTaxIntegration().
    /// </remarks>
    protected void setFieldsForLegacyTax()
    {
        if (TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
        {
            this.parmVatRegData_W(purchCalcTax.vatRegData_W());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFieldsForTaxIntegrationDocumentObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets fields for tax integration document object.
    /// </summary>
    /// <param name = "_document">The tax integration document object.</param>
    protected void setFieldsForTaxIntegrationDocumentObject(TaxIntegrationDocumentObject _document)
    {
        _document.setTransactionDate(this.taxDate);
        // This deliveryDateMarkup() is for header.
        _document.setDeliveryDate(purchCalcTax.deliveryDateMarkup());
        _document.setDocumentDate(purchCalcTax.documentDate());
        _document.setInvoiceDate(purchCalcTax.invoiceDate());

        _document.setTransactionCurrencyCode(purchCalcTax.currencyCode());

        _document.setCompany(this.getCompany());
        _document.setHeadingTableId(this.headingTableId());
        _document.setHeadingRecId(this.headingRecId());

        _document.setSign(1);
        _document.setSource(TaxModuleType::Purch);
        _document.setBusinessProcess(TaxIntegrationBusinessProcess::Purchase);
        _document.setPrepaid(this.isPrePayment());

        _document.setEUROTriangulation(this.getTriangulation());

        _document.setLegacyTax(this);

        // Refer to PuchCalcTax_PackingSlip.nextMarkupLine(), charge tax is not calculated.
        if (TaxIntegrationSkipChargeForVendPackingSlipFlight::instance().isEnabled()
            && purchCalcTax is PurchCalcTax_PackingSlip)
        {
            _document.setShouldSkipDocumentCharge(true);
            _document.setShouldSkipLineCharge(true);
        }
        else
        {
            _document.setShouldSkipDocumentCharge(skipTableMarkup);
            _document.setShouldSkipLineCharge(skipLineMarkup);
        }

        _document.getQuantityType().setPurchUpdate(this.purchCalcTax().getSpecQty());

        _document.setCashDiscountPercent(cashDiscPercent);
        _document.setCashDiscountAmount(CashDiscAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSourceLineCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set currency code for source lines.
    /// </summary>
    /// <param name = "_sourceCurrency">The currency code.</param>
    /// <param name = "_line">The source line will be set currency code.</param>
    /// <returns>
    /// The currency code.
    /// </returns>
    [Hookable(false)]
    protected Currency setSourceLineCurrency(Currency _sourceCurrency, Common _line)
    {
        // In overrides the actual document line source currency can be returned.
        return _sourceCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCalcEximTax_IN</Name>
				<Source><![CDATA[
    protected boolean canCalcEximTax_IN()
    {
        return (isEximIncentiveSchemEnabled
            && !isEximAdjusted);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIntersection</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Allows transactions to customize error conditions which occur when the tax groups are intersected.
    ///    This method is an override of a base class method.
    /// </summary>
    /// <param name="_found">
    ///    A Boolean value that specifies whether tax codes that match were found in both the tax group and
    ///    the item tax group.
    /// </param>
    /// <param name="_taxGroup">
    ///    The tax group from the transaction line.
    /// </param>
    /// <param name="_taxItemGroup">
    ///    The item tax group from the transaction line.
    /// </param>
    /// <returns>
    ///    true if this is a supported tax scenario; otherwise, false.
    /// </returns>
    protected boolean checkIntersection(boolean _found, TaxGroup _taxGroup, TaxItemGroup _taxItemGroup)
    {
        if (purchCalcTax.checkIntersection())
        {
            return (super(_found, _taxGroup, _taxItemGroup)) &&
                (markupTrans.taxCombinationAllowed()) &&
                (this.taxCombinationAllowed());
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>configureTaxForMarkupLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Configures a <c>Tax</c> object to calculate a miscellaneous charge line.
    /// </summary>
    /// <param name="_markupTrans">
    ///    The miscellaneous charge line to calculate.
    /// </param>
    /// <param name="_inventTransId">
    ///    The inventory ID related to this miscellaneous charge line.
    /// </param>
    protected void configureTaxForMarkupLine(MarkupTrans _markupTrans, InventTransId _inventTransId)
    {
        // <GIN>
        if (isTaxParametersEnabled)
        {
            this.insertIntersection('',
                                    '',
                                    _inventTransId,
                                    markupTrans.Txt,
                                    purchCalcTax.transTaxCalculationDate());
        }
        else
        {
        // </GIN>
            this.insertIntersection(purchCalcTax.markupTaxGroup(),
                                    purchCalcTax.markupTaxItemGroup(),
                                    _inventTransId,
                                    markupTrans.Txt,
                                    purchCalcTax.transTaxCalculationDate());
        // <GIN>
        }
        // </GIN>

        if (! this.checkTaxCodesByLine())
        {
            throw error("@SYS22772");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>configureWithholdTaxForMarkupLine</Name>
				<Source><![CDATA[
    private void configureWithholdTaxForMarkupLine(MarkupTrans _markupTrans)
    {
        if (isCalcWHTInInvoiceWithChargeEnabled)
        {
            TaxWithholdIntersection::checkForIntersectionAndDisplayErrorMessage(TaxWithholdParameters::find().CheckIntersection, purchCalcTax.markupWithholdTaxGroup(), purchCalcTax.markupTaxWithholdItemGroup());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>configureTaxForPurchLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method configures Tax to calculate a Purchase Order line.
    /// </summary>
    private void configureTaxForPurchLine()
    {
        GSTHSTTaxType_CA        gsthstTaxType_CA;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCA]))
        {
            gsthstTaxType_CA = PurchLine::findInventTransId(purchCalcTax.transTransId()).gsthstTaxType_CA;
        }
        
        this.setReasonTableRefRecIdBeingCalculated(purchCalcTax.getLineReasonTableRefRecId(), purchCalcTax.getHeaderReasonTableRefRecId());

        this.insertIntersection(purchCalcTax.transTaxGroup(),
                                purchCalcTax.transTaxItemGroup(),
                                purchCalcTax.transTransId(),
                                this.transTxt(),
                                purchCalcTax.transTaxCalculationDate(),
                                '',
                                gsthstTaxType_CA);

        if (! this.checkTaxCodesByLine())
        {
            throw error("@SYS22772");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>configureWithholdTaxForPurchLine</Name>
				<Source><![CDATA[
    private void configureWithholdTaxForPurchLine()
    {
        if (isCalcWHTInInvoiceEnabled)
        {
            TaxWithholdIntersection::checkForIntersectionAndDisplayErrorMessage(TaxWithholdParameters::find().CheckIntersection, purchCalcTax.transTaxWithholdGroup(), purchCalcTax.transTaxWithholdItemGroup());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineDirectImportBase_BR</Name>
				<Source><![CDATA[
    protected TaxBase determineDirectImportBase_BR(TaxBase _baseAmount)
    {
        TaxBase     taxBaseAmount = _baseAmount;

        TaxValue    pctIPI;
        TaxValue    pctII;
        TaxValue    pctICMS;
        TaxValue    pctPIS;
        TaxValue    pctCOFINS;
        TaxValue    pctISS;
        TaxValue    taxValueICMS;

        TaxValue    factor = 1;

        // Used for ICMS
        TaxBase     basePisCofins;
        TaxAmount   amountIPI;
        TaxAmount   amountII;

        TaxValue taxValueByType(TaxType_BR _taxType_BR, RecId _recId)
        {
            TmpTaxWorkTrans localTaxWorkTrans;
            TaxData         taxData;
            ;
            localTaxWorkTrans.setTmpData(taxWorkTrans);

            select localTaxWorkTrans
                where localTaxWorkTrans.TaxType_BR == _taxType_BR
                        && localTaxWorkTrans.SourceRecId == _recId;

            taxData = TaxData::find(localTaxWorkTrans.TaxCode, localTaxWorkTrans.TransDate, 0);

            if (_taxType_BR == TaxType_BR::ICMS)
            {
                taxValueICMS = taxData.TaxValue;

                if (taxValueICMS >= 100)
                {
                    throw error(strFmt("@Tax:TaxValueError", taxData.TaxCode, 100));
                }
            }

            return taxData.TaxValue * (taxData.TaxReductionPct_BR ? (1 - (taxData.TaxReductionPct_BR/100)) : 1);
        }
        ;
        pctII          = taxValueByType(TaxType_BR::ImportTax,  taxWorkTrans.SourceRecId)/100;
        pctIPI         = taxValueByType(TaxType_BR::IPI,        taxWorkTrans.SourceRecId)/100;
        pctICMS        = taxValueByType(TaxType_BR::ICMS,       taxWorkTrans.SourceRecId)/100;
        pctPIS         = taxValueByType(TaxType_BR::PIS,        taxWorkTrans.SourceRecId)/100;
        pctCOFINS      = taxValueByType(TaxType_BR::COFINS,     taxWorkTrans.SourceRecId)/100;

        switch (taxWorkTrans.TaxType_BR)
        {
            case TaxType_BR::ImportTax :
                _baseAmount = taxBaseAmount;
                break;

            case TaxType_BR::IPI :
                _baseAmount = _baseAmount * (1+pctII);
                break;

            case TaxType_BR::PIS    :
            case TaxType_BR::COFINS :
                if (purchCalcTax.transItemType() == ItemType::Service)
                {
                    if (!(this.isTaxExcludeIssFromAmountOrigin_BRFlightEnabled && TaxTable::find(taxWorkTrans.TaxCode).ExcludeISS_BR))
                    {
                        pctISS = taxValueByType(TaxType_BR::ISS, taxWorkTrans.SourceRecId)/100;
                    }

                    factor = (1+pctISS)/(1-pctPIS-pctCOFINS);
                }
                _baseAmount = _baseAmount * factor;
                break;

            case TaxType_BR::ICMS :
                if (taxWorkTrans.SourceTableId == tableNum(MarkupTrans)
                    && markupTrans.markupTable().MarkupClassification_BR == MarkupClassification_BR::SISCOMEX)
                {
                    _baseAmount = _baseAmount / (1 - pctICMS);
                }
                else
                {
                    amountIPI     = _baseAmount * (pctIPI + pctII*pctIPI);
                    amountII      = _baseAmount * pctII;
                    basePisCofins = _baseAmount * factor;

                    _baseAmount = (_baseAmount + amountII + amountIPI + basePisCofins * (pctPIS + pctCOFINS)) / (1 - taxValueICMS / 100);
                }
                break;

            default : _baseAmount = taxBaseAmount;
        }

        return _baseAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineIntersection_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine intersection of tax combination.
    /// </summary>
    /// <param name="_taxGroup">
    /// The tax group a tax code belongs to.
    /// </param>
    /// <param name="_taxItemGroup">
    /// The tax item group a tax code belongs to.
    /// </param>
    /// <param name="_inventTransId">
    /// The Invent trans id.
    /// </param>
    /// <param name="_txt">
    /// Transaction text.
    /// </param>
    /// <param name="_taxCalculationDate">
    /// The tax calculation date.
    /// </param>
    /// <param name="_taxGroupData">
    /// A <c>TaxGroupData</c> buffer.
    /// </param>
    /// <param name="_taxOnItem">
    /// A <c>TaxOnItem</c> buffer.
    /// </param>
    /// <param name="_taxType">
    /// The type of tax.
    /// </param>
    void determineIntersection_IN(TaxGroup           _taxGroup,
                                  TaxItemGroup       _taxItemGroup,
                                  InventTransId      _inventTransId,
                                  Name               _txt,
                                  TransDate          _taxCalculationDate,
                                  TaxGroupData       _taxGroupData,
                                  TaxOnItem          _taxOnItem,
                                  TaxType_IN         _taxType)
    {
        if (_taxType != TaxType_IN::None)
        {
            this.insertIntersection_IN(_taxGroup, _taxItemGroup, _inventTransId, _txt, _taxCalculationDate);
        }
        else
        {
            taxWorkTrans.HeadingTableId        = headingTableId;
            taxWorkTrans.HeadingRecId          = headingRecId;
            taxWorkTrans.SourceTableId         = this.sourceTableId();
            taxWorkTrans.SourceRecId           = this.sourceRecId();
            taxWorkTrans.Txt                   = _txt;
            taxWorkTrans.Voucher               = voucher;
            taxWorkTrans.TransDate             = taxDate;
            taxWorkTrans.TaxCode               = _taxGroupData.TaxCode;
            taxWorkTrans.TaxGroup              = _taxGroup;
            taxWorkTrans.TaxItemGroup          = _taxItemGroup;
            taxWorkTrans.Source                = taxModuleType;
            taxWorkTrans.InventTransId         = _inventTransId;
            taxWorkTrans.SourceCurrencyCode    = sourceCurrencyCode;
            taxWorkTrans.TaxDirection          = this.determineDirection(_taxGroupData);
            taxWorkTrans.TaxAutogenerated      = NoYes::Yes;
            taxWorkTrans.TaxReports            = NoYes::Yes;
            taxWorkTrans.ExemptTax             = taxWorkTrans.TaxDirection != TaxDirection::UseTax ? _taxGroupData.ExemptTax : NoYes::No;
            taxWorkTrans.CalculationDate       = _taxCalculationDate;

            if (VendParameters::find().IntracomVAT)
            {
               taxWorkTrans.IntracomVAT        = _taxGroupData.IntracomVAT;
            }

            taxWorkTrans.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>emptyBaseForOutgoingTax_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// For the given tax group determine its reverse charge rule and if that rule has an empty base for outgoing tax.
    /// </summary>
    /// <param name = "_taxGroupData">The tax group to find the reverse charge rule for.</param>
    /// <returns>Whether the reverse charge rule for the tax group has an empty base for outgoing tax.</returns>
    protected NoYes emptyBaseForOutgoingTax_W(TaxGroupData _taxGroupData)
    {
        return this.emptyBaseForOutgoingTax_WWithTransRecId(_taxGroupData, purchCalcTax.transRecId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>emptyBaseForOutgoingTax_WWithTransRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// For the given tax group determine its reverse charge rule and if that rule has an empty base for outgoing tax.
    /// </summary>
    /// <param name = "_taxGroupData">The tax group to find the reverse charge rule for.</param>
    /// <param name = "_transRecId">RecId of transaction line.</param>
    /// <returns>Whether the reverse charge rule for the tax group has an empty base for outgoing tax.</returns>
    protected internal NoYes emptyBaseForOutgoingTax_WWithTransRecId(TaxGroupData _taxGroupData, RecId _transRecId)
    {
        ReverseChargeItemGroupId_W  itemGroupId;
        ReverseChargeDocumentType_W documentType;
        ReverseChargeRule_W         rule;
        CountryRegionType           countryRegionType;
        PurchTable                  purchTable;
        VendDocumentLineMap         vendDocumentLine;

        if (_taxGroupData.ReverseCharge_W &&
            TaxTable::find(_taxGroupData.TaxCode).NegativeTax)
        {
            if (!reverseCharge)
            {
                reverseCharge = ReverseCharge_W::newParameters(purchTable, null);
            }

            itemGroupId = reverseCharge.findGroupByItemCategory(
                ReverseChargePurchSales_W::Purch,
                purchCalcTax.transItemId(),
                purchCalcTax.transProcurementCategory());

            switch (purchCalcTax.headingTableID())
            {
                case tableNum(VendInvoiceInfoTable):
                    if (this.isNonPO(_transRecId))
                    {
                        documentType = ReverseChargeDocumentType_W::VendInvoice;
                    }
                    else
                    {
                        documentType = ReverseChargeDocumentType_W::PurchaseOrder;
                    }
                    break;
                case tableNum(PurchTable):
                    documentType = ReverseChargeDocumentType_W::PurchaseOrder;
                    break;
            }

            countryRegionType = this.getCountryRegionType();

            str featureReference = ReverseChargeTaxSetupToggle::getFeatureReference();

            if (featureReference)
            {
                GlobalizationInstrumentationHelper::featureRun(featureReference, funcName());
            }

            select firstOnly EmptyTaxBaseForOutgoingTax from rule
                where rule.DocumentType == documentType    &&
                 (rule.ItemGroupId == itemGroupId || !rule.ItemGroupId) &&
                   ((countryRegionType == CountryRegionType::Domestic &&
                       (rule.PartnerCountryRegionType == ReverseChargePartnerCountryRegionType_W::All        ||
                        rule.PartnerCountryRegionType == ReverseChargePartnerCountryRegionType_W::Domestic)) ||
                    (countryRegionType == CountryRegionType::EFTA &&
                       (rule.PartnerCountryRegionType == ReverseChargePartnerCountryRegionType_W::All       ||
                        rule.PartnerCountryRegionType == ReverseChargePartnerCountryRegionType_W::Foreign)) ||
                    (countryRegionType == CountryRegionType::EU &&
                       (rule.PartnerCountryRegionType == ReverseChargePartnerCountryRegionType_W::All     ||
                        rule.PartnerCountryRegionType == ReverseChargePartnerCountryRegionType_W::Foreign ||
                        rule.PartnerCountryRegionType == ReverseChargePartnerCountryRegionType_W::EU))    ||
                    (countryRegionType == CountryRegionType::SpecialDomestic &&
                       (rule.PartnerCountryRegionType == ReverseChargePartnerCountryRegionType_W::All        ||
                        rule.PartnerCountryRegionType == ReverseChargePartnerCountryRegionType_W::Domestic)) ||
                    (countryRegionType == CountryRegionType::ThirdCountryRegion &&
                       (rule.PartnerCountryRegionType == ReverseChargePartnerCountryRegionType_W::All     ||
                        rule.PartnerCountryRegionType == ReverseChargePartnerCountryRegionType_W::Foreign ||
                        rule.PartnerCountryRegionType == ReverseChargePartnerCountryRegionType_W::ThirdCountry)));
        }

        return rule.EmptyTaxBaseForOutgoingTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exciseTaxCalculationdate_IN</Name>
				<Source><![CDATA[
    protected TransDateTime exciseTaxCalculationdate_IN(RefRecId _sourceRecId,
                                                        TableId _sourceTableId)
    {
        TransDateTime                       vendexciseTaxCalculationDateTime;
        VendorCalculationDateType_IN        vendTaxCalculationDateType;
        VendPackingSlipJour                 vendPackingSlipJour;
        VendInvoiceInfoLine                 vendInvoiceInfoLine;

        if (!(VendParameters::find().UseDocumentDate))
        {
            vendTaxCalculationDateType  = this.taxParameters().VendorCalculationDateType_IN;

            switch (vendTaxCalculationDateType)
            {
                case VendorCalculationDateType_IN::DeliveryDate:
                    vendexciseTaxCalculationDateTime = DateTimeUtil::newDateTime(purchCalcTax.deliveryDate(), 0, DateTimeUtil::getUserPreferredTimeZone());
                    break;

                case VendorCalculationDateType_IN::InvoiceDate:
                    vendexciseTaxCalculationDateTime = DateTimeUtil::newDateTime(purchCalcTax.invoiceDate(), 0, DateTimeUtil::getUserPreferredTimeZone());
                    break;

                case VendorCalculationDateType_IN::DocumentDate:

                    if (this.sourceTableId() == tableNum(VendInvoiceInfoLine))
                    {
                        vendInvoiceInfoLine = line;
                        vendPackingSlipJour = VendPackingSlipJour::findFromPurchId(vendInvoiceInfoLine.vendInvoiceInfoTable().PurchId);

                        if (vendPackingSlipJour.DocumentDate)
                        {
                            vendexciseTaxCalculationDateTime = DateTimeUtil::newDateTime(vendPackingSlipJour.DocumentDate, 0, DateTimeUtil::getUserPreferredTimeZone());
                        }
                        else
                        {
                            vendexciseTaxCalculationDateTime = DateTimeUtil::newDateTime(purchCalcTax.documentDate(), 0, DateTimeUtil::getUserPreferredTimeZone());
                        }
                    }
                    else
                    {
                        vendexciseTaxCalculationDateTime = DateTimeUtil::newDateTime(purchCalcTax.documentDate(), 0, DateTimeUtil::getUserPreferredTimeZone());
                    }
                    break;
            }
        }

        return vendexciseTaxCalculationDateTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxAdjustmentDetailDescription</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a description of a tax adjustment detail for a specified tax source.
    /// </summary>
    /// <param name="_sourceTableId">
    /// The table ID of the specified tax source.
    /// </param>
    /// <param name="_sourceRecId">
    /// The record ID of the specified tax source.
    /// </param>
    /// <returns>
    /// The description of the tax adjustment detail for the specified tax source.
    /// </returns>
    public TaxAdjustmentDetailDescription getTaxAdjustmentDetailDescription(RefTableId _sourceTableId, RefRecId _sourceRecId)
    {
        return purchCalcTax.getTaxAdjustmentDetailDescription(_sourceTableId, _sourceRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxAdjustmentDetailReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a reference of a tax adjustment detail for a specified tax source.
    /// </summary>
    /// <param name="_sourceTableId">
    /// The table ID of the specified tax source.
    /// </param>
    /// <param name="_sourceRecId">
    /// The record ID of the specified tax source.
    /// </param>
    /// <returns>
    /// The reference of the tax adjustment detail for the specified tax source.
    /// </returns>
    public TaxAdjustmentDetailReference getTaxAdjustmentDetailReference(RefTableId _sourceTableId, RefRecId _sourceRecId)
    {
        return purchCalcTax.getTaxAdjustmentDetailReference(_sourceTableId, _sourceRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxAdjustmentDetailType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the type of a tax adjustment detail for a specified tax source.
    /// </summary>
    /// <param name="_sourceTableId">
    /// The table ID of the specified tax source.
    /// </param>
    /// <param name="_sourceRecId">
    /// The record ID of the specified tax source.
    /// </param>
    /// <returns>
    /// The type of the tax adjustment detail for the specified tax source.
    /// </returns>
    public TaxAdjustmentDetailType getTaxAdjustmentDetailType(RefTableId _sourceTableId, RefRecId _sourceRecId)
    {
        return purchCalcTax.getTaxAdjustmentDetailType(_sourceTableId, _sourceRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>ignoreCalculatedSalesTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether only use tax amounts from tax adjustments should be used.
    /// </summary>
    /// <returns>
    ///    true if the calculated sales tax should be ignored and only tax amounts from tax adjustments should
    ///    be used; otherwise, false.
    /// </returns>
    public boolean ignoreCalculatedSalesTax()
    {
        return purchCalcTax.ignoreCalculatedSalesTax();
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the purchase order specific class which contains the transaction
    ///    lines and other information tax requires to calculate taxes.
    /// </summary>
    /// <param name="_initializationClass">
    ///    This object is the purchase order specific class which contains the transaction lines and other
    ///    information tax requires to calculate taxes.
    /// </param>
    public void init(Object _initializationClass)
    {
        purchCalcTax = _initializationClass as PurchCalcTax;
        if (purchCalcTax == null)
        {
            throw error("@SYS95118");
        }

        purchCalcTax        = purchCalcTax;
        purchCalcTax.tax(this);

        taxModuleType       = TaxModuleType::Purch;
        headingTableId      = purchCalcTax.headingTableID();
        headingRecId        = purchCalcTax.headingRecID();
        sourceTableId       = purchCalcTax.transTableId();

        // <GIN>
        if (isTaxParametersEnabled)
        {
            documentStatus  = purchCalcTax.parmDocumentStatus_IN();
        }
        // </GIN>

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            switch (headingTableId)
            {
                case tableNum(PurchTable):
                    processExemptTax = LogisticsAddressCountryRegion::find(PurchTable::findRecId(headingRecId).vendTable_InvoiceAccount().countryRegionId()).MemberOfCustomsUnion_RU;
                    break;

                case tableNum(VendInvoiceInfoTable):
                    processExemptTax = LogisticsAddressCountryRegion::find(VendInvoiceInfoTable::findRecId(headingRecId).vendTable_InvoiceAccount().countryRegionId()).MemberOfCustomsUnion_RU;
                    break;
            }
        }
        // </GEERU>

        taxDate = purchCalcTax.invoiceDate();
        taxIncludedInItemPrice = purchCalcTax.isTaxIncluded();

        this.setExchRates(purchCalcTax.currencyCode(), purchCalcTax.exchRate(taxDate), purchCalcTax.exchRateSecondary(taxDate), Currency::noYes2UnknownNoYes(purchCalcTax.triangulation(taxDate)), taxDate);
        this.parmReportingCurrencyExchRate(purchCalcTax.reportingCurrencyExchangeRate(taxDate));
        this.setCashDiscount(purchCalcTax.taxCashDiscPercent(), 0);

        super(_initializationClass);

        // After the super() method, if the taxWorkTrans loads from TaxUncommitted,
        // it also should setup localization fields without calculation calling.
        if ((useTaxUncommitted && this.useTaxUncommitted() && loadTaxUncommitted)
            && TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
        {
            this.parmVatRegData_W(purchCalcTax.vatRegData_W());
            this.initVatRegData_W(taxWorkTrans);
        }

        if (loadTaxTrans)
        {
            SourceDocumentHeaderRecId sdhRecId = PurchCalcTax.headingTableSourceDocumentRecId();
            // the loadTaxTransForSourceDocument method can be very expensive if called with no SourceDocumentHeader recid,
            // only call if set for the processing transaction.
            if (sdhRecId)
            {
                this.loadFromTaxTrans(sdhRecId);
            }
        }

        isCalcWHTInInvoiceEnabled = TaxWithholdingGlobalFeature::isCalcWHTInInvoiceEnabled();
        isCalcWHTInInvoiceWithChargeEnabled = TaxWithholdingGlobalFeature::isCalcWHTInInvoiceWithChargeEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxTransactionExchangeRate</Name>
				<Source><![CDATA[
    protected void initTaxTransactionExchangeRate()
    {
        if (TaxSpecificExchangeRateHelper::isTaxSpecificExchRateEnabledByBusinessProcess(TaxIntegrationBusinessProcess::Purchase))
        {
            VatDueDate_W vatDueDate = TaxSpecificExchangeRate::getDateOfVATRegister(this.headingTableId(), this.headingRecId());

            if (!vatDueDate)
            {
                vatDueDate = purchCalcTax.vendInvoiceInfoTable().vendInvoiceInfoTable_W().VatDueDate_W;
            }

            if (!vatDueDate)
            {
                vatDueDate = this.parmTaxDate();
            }

            TaxSpecificExchangeRateHelper taxSpecificExchangeRateHelper = new TaxSpecificExchangeRateHelper(
                this.headingTableId(),
                this.headingRecId(),
                TransactionType::Purchase,
                this.getTransactionalCurrency(),
                vatDueDate);

            taxSpecificExchangeRateHelper.maintainAccountingCurrencyTaxSpecificExchangeRate();
            taxSpecificExchangeRateHelper.maintainReportingCurrencyTaxSpecificExchangeRate();

            TmpTaxWorkTrans localTaxWorkTrans;
            localTaxWorkTrans.setTmpData(taxWorkTrans);

            while select CurrencyCode from localTaxWorkTrans
                group by localTaxWorkTrans.CurrencyCode
            {
                taxSpecificExchangeRateHelper.maintainTaxSpecificExchangeRate(localTaxWorkTrans.CurrencyCode);
            }
        }
        else
        {
            SalesTaxTransactionExchangeRate taxExchRate =
                SalesTaxTransactionExchangeRate::findBySourceRecord(this.headingTableId(), this.headingRecId());
            if (!taxExchRate)
            {
                // purchCalcTax.vendInvoiceInfoTable() is validated in \Classes\TaxPurch\calculateTax
                SalesTaxExchangeRateHelper::maintainSalesTaxTransactionExchangeRate(
                    purchCalcTax.vendInvoiceInfoTable(),
                    this.getTransactionalCurrency(),
                    TransactionType::Purchase,
                    this.parmTaxDate());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventProfileTaxTrans_RU</Name>
				<Source><![CDATA[
    protected boolean inventProfileTaxTrans_RU()
    {
        SalesPurchLine      salesPurchLine;
        TaxUpdateMode_RU    taxUpdateMode;
        boolean             ret = super();

        if ((line.TableId == tableNum(PurchLine) ||
             line.TableId == tableNum(VendInvoiceInfoLine)) && line.RecId)
        {
            salesPurchLine = line;
            taxUpdateMode  = salesPurchLine.salesPurchLineInterface().inventDim().inventProfile_RU().taxUpdateIncoming();

            ret = taxUpdateMode == TaxUpdateMode_RU::Standard;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventProfileType_RU</Name>
				<Source><![CDATA[
    protected InventProfileType_RU inventProfileType_RU()
    {
        PurchTable_RU       purchTable_RU;
        PurchLine           purchLine;
        VendInvoiceInfoLine vendInvoiceInfoLine;
        PurchParmSubTable   purchParmSubTable;
        ;
        if (line.TableId == tableNum(PurchLine) && line.RecId)
        {
            purchLine = line;
            return purchLine.inventProfileType_RU();
        }
        if (line.TableId == tableNum(VendInvoiceInfoLine) && line.RecId)
        {
            vendInvoiceInfoLine = line;
            return vendInvoiceInfoLine.vendInvoiceInfoLine_W().InventProfileType_RU;
        }

        if (this.sourceTableId() == tableNum(MarkupTrans))
        {
            switch (markupTrans.TransTableId)
            {
                case tableNum(PurchTable):
                    purchTable_RU = PurchTable_RU::findByPurchTable(markupTrans.TransRecId);
                    if (purchTable_RU.InventProfileType_RU)
                    {
                        return purchTable_RU.InventProfileType_RU;
                    }
                    break;
                case tableNum(PurchParmSubTable):
                    purchParmSubTable = PurchParmSubTable::findRecId(markupTrans.TransRecId);
                    return purchParmSubTable.purchParmTable().InventProfileType_RU;
            }
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>keepSalesTaxAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the sales tax adjustments should be deleted when the sales tax groups are
    ///    changed on the transaction.
    /// </summary>
    /// <returns>
    ///    true if sales tax adjustments should not be deleted when sales tax groups are changed on the
    ///    transaction; otherwise, false.
    /// </returns>
    public boolean keepSalesTaxAdjustments()
    {
        return purchCalcTax.keepSalesTaxAdjustments() || this.ignoreCalculatedSalesTax();
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadFromTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads tax records from the <c>TaxTrans</c> table into the <c>TmpTaxWorkTrans</c> table.
    /// </summary>
    /// <param name="_sourceDocumentHeaderRecId">
    ///    The record ID of the <c>SourceDocumentHeader</c> table.
    /// </param>
    protected void loadFromTaxTrans(RecId _sourceDocumentHeaderRecId)
    {
        taxWorkTrans.loadFromTaxTrans(_sourceDocumentHeaderRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container           packedContainer;

        //Place most of the class objects in the list.
        packedContainer = [#CurrentVersion, #CurrentList, purchCalcTax.pack(), this.taxPack()];

        return packedContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParentSourceRecId</Name>
				<Source><![CDATA[
    public RefRecId parmParentSourceRecId()
    {
        return parentSourceRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParentSourceTableId</Name>
				<Source><![CDATA[
    public RefTableId parmParentSourceTableId()
    {
        return parentSourceTableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingProfile_RU</Name>
				<Source><![CDATA[
    protected PostingProfile postingProfile_RU()
    {
        PurchTable          purchTable;
        PurchLine           purchLine;
        PurchLine_W         purchLine_W;
        PurchParmSubTable   purchParmSubTable;

        if (line.TableId == tableNum(PurchLine) && line.RecId)
        {
            purchLine = line;
            purchLine_W = purchLine.purchLine_W();
            return purchLine_W.PostingProfile_RU ? purchLine_W.PostingProfile_RU : purchLine.purchTable().PostingProfile;
        }

        if (this.sourceTableId() == tableNum(MarkupTrans))
        {
            switch (markupTrans.TransTableId)
            {
                case tableNum(PurchTable):
                    purchTable = PurchTable::findRecId(markupTrans.TransRecId);
                    return purchTable.PostingProfile;
                case tableNum(PurchParmSubTable):
                    purchParmSubTable = PurchParmSubTable::findRecId(markupTrans.TransRecId);
                    return purchParmSubTable.purchParmTable().PostingProfile;
            }
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchCalcTax</Name>
				<Source><![CDATA[
    public PurchCalcTax purchCalcTax(PurchCalcTax _purchCalcTax = purchCalcTax)
    {
        purchCalcTax = _purchCalcTax;
        return purchCalcTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseChargeAmount_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// If the reverse charge feature is enabled find the tax transactions of type Reverse Charge Yes and Tax Direction Incoming Tax.
    /// </summary>
    /// <returns>The sum of the corrected amount in currency for all found tax records.</returns>
    public AmountCur reverseChargeAmount_W()
    {
        TmpTaxWorkTrans localTaxWorkTrans;

        if (ReverseChargeParameters_W::find().Enabled)
        {
            localTaxWorkTrans.setTmpData(taxWorkTrans);

            select sum(SourceRegulateAmountCur) from localTaxWorkTrans
            where localTaxWorkTrans.ReverseCharge_W == NoYes::Yes &&
                  localTaxWorkTrans.TaxDirection  == TaxDirection::IncomingTax;
        }

        return localTaxWorkTrans.SourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceLinesHaveTaxGroups</Name>
				<Source><![CDATA[
    protected boolean sourceLinesHaveTaxGroups()
    {
        return purchCalcTax.doTaxGroupExistsForDocument();
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceRecId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the record ID of the transaction line to calculate.
    /// </summary>
    /// <returns>
    ///    The record ID of the transaction line to calculate.
    /// </returns>
    /// <remarks>
    ///    This method is overridden by derived classes.
    /// </remarks>
    public RecId sourceRecId()
    {
        if (purchCalcTax is PurchCalcTax_PackingSlip)
        {
            if (isMarkupBeingCalculated)
            {
                return markupTrans.RecId;
            }
            else
            {
                return purchCalcTax.transRecId();
            }
        }

        if (isMarkupBeingCalculated)
        {
            return markupTrans.RecId;
        }
        else
        {
            return line.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceTableId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the table ID of the transaction to tax.
    /// </summary>
    /// <returns>
    ///    The table ID of the transaction to tax.
    /// </returns>
    /// <remarks>
    ///    This method is overridden by derived classes.
    /// </remarks>
    public RefTableId sourceTableId()
    {
        if (purchCalcTax is PurchCalcTax_PackingSlip)
        {
            if (isMarkupBeingCalculated)
            {
                return markupTrans.TableId;
            }
            else
            {
                return purchCalcTax.transTableId();
            }
        }

        if (isMarkupBeingCalculated)
        {
            return markupTrans.TableId;
        }
        else
        {
            if (line == null)
            {
                return sourceTableId;
            }
            else
            {
                return line.TableId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxCombinationAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether allow tax combination.
    /// </summary>
    /// <returns>true if the validation is corrcect; otherwise false.</returns>
    protected boolean taxCombinationAllowed()
    {
        MarkupTable markupTable;
        ;

        markupTable = markupTrans.markupTable();

        // Axapta 4.1 Bug#12492 - This combination is not allowed from a tax perspective.  This needs to execute
        // and return false before the tax group check below so that tax error checking will not occur.
        if (markupTable &&
           (markupTable.CustType == MarkupType::Item || markupTable.VendType == MarkupType::LedgerAccount))
            return false;

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxInCostPrice</Name>
				<Source><![CDATA[
    public TaxAmount taxInCostPrice(TableId     _tableId,
                             RecId       _recId)
    {
        TaxAmount       taxAmount;
        PurchTaxOnOperations purchTaxOnOperations = this.taxParameters().PurchTaxOnOperations;
        ;

        while select
            sum (SourceTaxAmountCur),
            sum (TaxInCostPrice),
            sum (SourceRegulateAmountCur),
            sum (TaxInCostPriceRegulated)
        from taxWorkTrans
        group by TaxAutogenerated
        where taxWorkTrans.SourceTableId   == _tableId      &&
              taxWorkTrans.SourceRecId     == _recId
            // <GBR>
            && (!isBrazilEnabled || (taxWorkTrans.IncludedInPrice_BR == false || directImport_BR == true))
            // </GBR>
        {
            if (purchTaxOnOperations)
                taxAmount += taxWorkTrans.TaxAutogenerated ? taxWorkTrans.SourceTaxAmountCur : taxWorkTrans.SourceRegulateAmountCur;
            else
                taxAmount += taxWorkTrans.TaxAutogenerated ? taxWorkTrans.TaxInCostPrice : taxWorkTrans.TaxInCostPriceRegulated;
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the total tax amount.
    /// </summary>
    /// <param name="_includeUseTax">
    /// A Boolean value that indicates whether use tax should be included in the tax total.
    /// </param>
    /// <returns>
    /// The total tax amount in transactional currency.
    /// </returns>
    /// <remarks>
    /// For direct import, the total tax amount is the sum of all taxes because there is no tax included in
    /// the price.
    /// </remarks>

    TaxAmountCur totalTaxAmount(boolean _includeUseTax = false)
    {
        TaxAmountCur totalTaxAmount;

        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            return 0;
        }

        if (BrazilParameters::isEnabled() && purchCalcTax.directImport_BR())
        {
            select sum(SourceRegulateAmountCur)
            from taxWorkTrans
            where taxWorkTrans.TaxOrigin     != TaxOrigin::TaxReversed;

            totalTaxAmount = taxWorkTrans.SourceRegulateAmountCur;
        }
        else
        {
            totalTaxAmount = super();
        }

        return totalTaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transTxt</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the transaction text for the current tax transaction.
    /// </summary>
    /// <returns>
    ///    The item ID of the <c>PurchLine</c> record if present; otherwise, the purchase category of the
    ///    <c>PurchLine</c> record.
    /// </returns>
    private TransTxt transTxt()
    {
        if (purchCalcTax.transItemId())
            return(purchCalcTax.transItemId());
        else
            return(EcoResCategory::find(purchCalcTax.transProcurementCategory()).Name);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Version                 version = RunBase::getVersion(packedClass);

        container               purchCalcTaxPacked;
        container               base;
        VendInvoiceInfoTable    blankVendInvoiceInfoTable;

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList, purchCalcTaxPacked, base] = packedClass;

                this.taxUnpack(base);

                purchCalcTax = new PurchCalcTax_ParmTrans(blankVendInvoiceInfoTable, '', '', DocumentStatus::Invoice, true);
                purchCalcTax.unpack(purchCalcTaxPacked);
                purchCalcTax.tax(this);
                break;
            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxWorkTrans_RU</Name>
				<Source><![CDATA[
    protected void updateTaxWorkTrans_RU(TmpTaxWorkTrans _taxWorkTrans)
    {
        SalesPurchLine       salesPurchLine;

        super(_taxWorkTrans);

        if (line.TableId == tableNum(PurchLine) ||
            line.TableId == tableNum(VendInvoiceInfoLine))
        {
            salesPurchLine = line;

            if (salesPurchLine &&
                salesPurchLine.salesPurchLineInterface().inventDim().inventProfile_RU().taxUpdateIncoming() == TaxUpdateMode_RU::NoCalc)
            {
                _taxWorkTrans.ExemptTax = NoYes::Yes;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>useSalesTaxAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a transaction that is being calculated supports sales tax adjustments.
    /// </summary>
    /// <returns>
    /// true if the transaction supports sales tax adjustment; otherwise, false.
    /// </returns>
    /// <remarks>
    /// By default, the transaction does not support sales tax adjustments.
    /// </remarks>
    public boolean useSalesTaxAdjustments()
    {
        boolean useSalesTaxAdjustment;

        if (purchCalcTax)
        {
            useSalesTaxAdjustment = purchCalcTax.useSalesTaxAdjustments();
        }

        return useSalesTaxAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useSubLedgerJournalLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the current transaction to post supports the <c>SubLedgerDistributions</c> or
    ///    <c>SubLedgerJournalLines</c> records. By default, this base implementation is that they do not
    ///    support them. As the individual transaction support the sub-ledger, they must override this method
    ///    and return true.
    /// </summary>
    /// <returns>
    ///    true if the current transaction to post supports the <c>SubLedgerDistributions</c> or
    ///    <c>SubLedgerJournalLines</c> records; otherwise, false.
    /// </returns>
    public boolean useSubLedgerJournalLines()
    {
        return purchCalcTax.useSubLedgerJournalLines();
    }

]]></Source>
			</Method>
			<Method>
				<Name>useTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the <c>Tax</c> class should use the <c>TaxUncommitted</c> table.
    /// </summary>
    /// <returns>
    ///    true if the <c>Tax</c> class should use the <c>TaxUncommitted</c> table; otherwise, false.
    /// </returns>
    public boolean useTaxUncommitted()
    {
        return purchCalcTax.useTaxUncommitted();
    }

]]></Source>
			</Method>
			<Method>
				<Name>vatOperationCode_RU</Name>
				<Source><![CDATA[
    protected VATOperationCode_RU vatOperationCode_RU()
    {
        PurchLine           purchLine;
        VendInvoiceInfoLine vendInvoiceInfoLine;
        if (line.TableId == tableNum(PurchLine))
        {
            purchLine = line;
            return purchLine.purchTable().purchTable_RU().vatOperationCode_RU;
        }
        else if (line.TableId == tableNum(VendInvoiceInfoLine))
        {
            vendInvoiceInfoLine = line;
            if (vendInvoiceInfoLine.isNonPO())
            {
                return vendInvoiceInfoLine.vendInvoiceInfoTable().vendInvoiceInfoTable_RU().vatOperationCode_RU;
            }
            else
            {
                return vendInvoiceInfoLine.purchTable().purchTable_RU().vatOperationCode_RU;
            }
        }
        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>processExemptTax_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Shows whether to perform the calculation of the exempt tax codes.
    /// </summary>
    /// <returns>
    ///    true if the calculation of the exempt tax codes should be performed; otherwise, false.
    /// </returns>
    protected boolean processExemptTax_RU()
    {
        return processExemptTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useSeperateTransactionScopeToMaintainTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether to use separate transaction scope to maintain <c>TaxUncommitted</c> table.
    /// </summary>
    /// <returns>
    ///    true if use separate transaction scope to maintain <c>TaxUncommitted</c> table; otherwise, false.
    /// </returns>
    protected boolean useSeperateTransactionScopeToMaintainTaxUncommitted()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCountryRegionType</Name>
				<Source><![CDATA[
    private CountryRegionType getCountryRegionType()
    {
        CountryRegionType countryRegionType;

        if (cachedCountryRegionType == conNull())
        {
            switch (purchCalcTax.headingTableID())
            {
                case tableNum(VendInvoiceInfoTable):
                    countryRegionType = IntrastatCountryRegionParameters::getCountryRegionType(VendInvoiceInfoTable::findRecId(purchCalcTax.recID()).vendTable_InvoiceAccount().postalAddress());
                    break;
                case tableNum(PurchTable):
                    countryRegionType = IntrastatCountryRegionParameters::getCountryRegionType(PurchTable::findRecId(purchCalcTax.recID()).vendTable_InvoiceAccount().postalAddress());
                    break;
            }

            cachedCountryRegionType += [countryRegionType];
        }
        else
        {
            countryRegionType = conPeek(cachedCountryRegionType, 1);
        }

        return countryRegionType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNonPO</Name>
				<Source><![CDATA[
    private boolean isNonPO(RefRecId _vendInvoiceInfoLineRecId)
    {
        if (cachedNonPOInvoiceLine == null)
        {
            cachedNonPOInvoiceLine = new Set(Types::Int64);
            VendInvoiceInfoLine vendInvoiceInfoLine;
            VendInvoiceInfoTable vendInvoiceInfoTable;

            while select RecId from vendInvoiceInfoLine
                exists join vendInvoiceInfoTable
                where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLine.ParmId
                    && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLine.TableRefId
                    && vendInvoiceInfoTable.RecId == purchCalcTax.recID()
                    && vendInvoiceInfoLine.OrigPurchId == ''
            {
                cachedNonPOInvoiceLine.add(vendInvoiceInfoLine.RecId);
            }
        }

        return cachedNonPOInvoiceLine.in(_vendInvoiceInfoLineRecId);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>