<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailAssortmentLookupTask</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;

/// <summary>
/// The <c>RetailAssortmentLookupTask</c> class handles all the assortment processing tasks.
/// </summary>
public class RetailAssortmentLookupTask extends RunBaseBatch implements BatchRetryable
{
    private static CommerceHQEventSource eventSource = CommerceHQEventSource::Log;
    RetailAssortmentRefRecId retailAssortmentRefRecId;
    RetailAssortmentID retailAssortmentID;
    int64 numProductExploded, numProductSkipped, numProductError, numInsertNewProduct, numRemovedProduct;
    int64 numProductExplodedByCategory, numVarientExploded, numProductSkipped2;
    private const str transactionModeNameforAssortmentDeltaSync = 'ENABLE_TRANSACTION_MODE_FOR_ASSORTMENT_DELTA_SYNC';

    #define.CurrentVersion(1)
    #localmacro.CurrentList
        retailAssortmentRefRecId,
        retailAssortmentID
    #endmacro

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>createChannelGroups</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates channel groups
    /// </summary>
    protected void createChannelGroups()
    {
        RetailAssortmentChannelLine             channelLine;
        RetailAssortmentLookupChannelGroup      channelGroup;
        RetailAssortmentLookupChannelGroupTmp   channelGroupTmp;
        OMOperatingUnit                         omOperatingUnit;
        OMExplodedOrganizationSecurityGraph     omExplodedGraph;
        utcdatetime                             stepStartTime, stepEndTime;

        stepStartTime = DateTimeUtil::utcNow();

        // Retrieve all Retail channels from the specified hierarchy node.        
        // Here not using a insert_recordset because of platform limitation.
        // please refer to download.microsoft.com/download/4/e/3/4e36b655-568e-4d4a-b161-152b28baaf30/
        // using_date_effective_patterns_ax2012.pdf
        while select AssortmentRecId from channelLine
            group by channelLine.AssortmentRecId, omOperatingUnit.RecId
            where
                channelLine.AssortmentRecId == retailAssortmentRefRecId &&
                channelLine.Status == RetailAssortmentStatusType::Published
            join omExplodedGraph
            where
                omExplodedGraph.AncestorOrganization == channelLine.omInternalOrganizationId &&
                omExplodedGraph.omHierarchyType == channelLine.omHierarchyTypeId
            join RecId from omOperatingUnit
            where
                omOperatingUnit.RecId == omExplodedGraph.Organization &&
                omOperatingUnit.omOperatingUnitType == OMOperatingUnitType::RetailChannel
        {
            channelGroupTmp.AssortmentId = channelLine.AssortmentRecId;
            channelGroupTmp.OMOperatingUnitId = omOperatingUnit.RecId;
            channelGroupTmp.insert();
        }

        stepEndTime = DateTimeUtil::utcNow();
        this.logStep(funcName(), strFmt('inserting %1 channels from OM hierarchy into channelGroupTmp', channelGroupTmp.RowCount()), stepStartTime, stepEndTime);

        stepStartTime = DateTimeUtil::utcNow();

        ttsbegin;
        // Delete removed channels.
        delete_from channelGroup
            where channelGroup.AssortmentId == retailAssortmentRefRecId
            notexists join channelGroupTmp
            where
                channelGroupTmp.AssortmentId == retailAssortmentRefRecId &&
                channelGroupTmp.AssortmentId == channelGroup.AssortmentId &&
                channelGroupTmp.omOperatingUnitId == channelGroup.omOperatingUnitId;

        stepEndTime = DateTimeUtil::utcNow();
        this.logStep(funcName(), strFmt('deleting %1 removed channels from channelGroup', channelGroup.RowCount()), stepStartTime, stepEndTime);

        stepStartTime = DateTimeUtil::utcNow();

        // Insert newly added channels.
        insert_recordset channelGroup (AssortmentId, OMOperatingUnitId)
            select AssortmentId, omOperatingUnitId from channelGroupTmp
            notexists join channelGroup
            where
                channelGroupTmp.AssortmentId == retailAssortmentRefRecId &&
                channelGroupTmp.AssortmentId == channelGroup.AssortmentId &&
                channelGroupTmp.omOperatingUnitId == channelGroup.omOperatingUnitId;

        stepEndTime = DateTimeUtil::utcNow();
        this.logStep(funcName(), strFmt('inserting new channels into channelGroup', channelGroup.RowCount()), stepStartTime, stepEndTime);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deltaSync</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delta Sync computes only the changed rows (inserts/deletes) to the RetailAssortmentLookup table such that only the required rows are touched for SQL change tracking.
    /// </summary>
    /// <remarks>
    /// Sync changes per assortment...
    /// </remarks>
    private void deltaSync()
    {
        RetailAssortmentLookup          lookup;
        RetailAssortmentLookupStaging   lookupTmp;
        utcdatetime                     stepStartTime, stepEndTime;
        boolean transactionScopeEnabledForDeltaSync;

        RetailSharedConfigurationParameters sharedConfigParameter = RetailSharedConfigurationParameters::findByName(transactionModeNameforAssortmentDeltaSync);

        if (sharedConfigParameter)
        {
            transactionScopeEnabledForDeltaSync = (str2Int(sharedConfigParameter.Value) == 1);
        }

        stepStartTime = DateTimeUtil::utcNow();

        if (transactionScopeEnabledForDeltaSync)
        {
            ttsbegin;
        }

        // Remove deleted products for a given assortment.
        delete_from lookup
            where lookup.AssortmentId == retailAssortmentRefRecId
            notexists join lookupTmp
            where
                lookupTmp.AssortmentId == retailAssortmentRefRecId &&
                lookupTmp.AssortmentId == lookup.AssortmentId &&
                lookupTmp.LineType == lookup.LineType &&
                lookupTmp.ProductId == lookup.ProductId &&
                lookupTmp.VariantId == lookup.VariantId &&
                lookupTmp.ValidFrom == lookup.ValidFrom &&
                lookupTmp.ValidTo == lookup.ValidTo;

        numRemovedProduct = lookup.RowCount();
        stepEndTime = DateTimeUtil::utcNow();
        this.logStep(funcName(), strFmt('deleting %1 removed records from lookup', numRemovedProduct), stepStartTime, stepEndTime);

        stepStartTime = DateTimeUtil::utcNow();

        // Insert newly added products for a given assortment.
        insert_recordset lookup (AssortmentId, LineType, ProductId, VariantId, ValidFrom, ValidTo)
            select AssortmentId, LineType, ProductId, VariantId, ValidFrom, ValidTo
            from lookupTmp
            group by lookupTmp.AssortmentId, lookupTmp.LineType, lookupTmp.ProductId, lookupTmp.VariantId, lookupTmp.ValidFrom, lookupTmp.ValidTo
            where lookupTmp.AssortmentId == retailAssortmentRefRecId
            notexists join lookup
            where
                lookupTmp.AssortmentId == retailAssortmentRefRecId &&
                lookupTmp.AssortmentId == lookup.AssortmentId &&
                lookupTmp.LineType == lookup.LineType &&
                lookupTmp.ProductId == lookup.ProductId &&
                lookupTmp.VariantId == lookup.VariantId &&
                lookupTmp.ValidFrom == lookup.ValidFrom &&
                lookupTmp.ValidTo == lookup.ValidTo;

        numInsertNewProduct = lookup.RowCount();
        stepEndTime = DateTimeUtil::utcNow();
        this.logStep(funcName(), strFmt('inserting %1 new records into lookup', numInsertNewProduct), stepStartTime, stepEndTime);

        if (transactionScopeEnabledForDeltaSync)
        {
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsAllKitElementsInAssortment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies if all the Product Kit Components and Substitutes are part of the assortment.
    /// </summary>
    /// <param name="_retailKitRecId">
    /// A reference to retail kit.
    /// </param>
    /// <param name="_retailAssortmentRefRecId">
    /// A reference to Retail Assortment to look for retail kits.
    /// </param>
    /// <param name="_kitProductMaster">
    /// A reference to Kit Master Product.
    /// </param>
    /// <param name="_kitVariantRecId">
    /// The value of record Id in <c>RETAILKITVARIANTCOMPONENT</c> table.
    /// </param>
    /// <returns>
    /// Boolean true if the action is successful; otherwise, false.
    /// </returns>
    public boolean existsAllKitElementsInAssortment(RetailKitRecId _retailKitRecId, RetailAssortmentRefRecId _retailAssortmentRefRecId, EcoresProductMasterRecId _kitProductMaster, RecId _kitVariantRecId)
    {
        RetailKitElements       retailKitElements;
        RetailKitComponent retailKitComponent;
        RetailKitComponentSubstitute retailKitComponentSubstitute;
        RetailAssortmentLookupStaging   lookupTmpStaging;
        EcoResDistinctProductVariant ecoResDistinctProductVariant;
        RetailKitVariantComponent   retailKitVariantComponent;
        boolean existsAllElements = true;

        if (_kitVariantRecId == 0)
        {
            // validate if kit components and substitutes are part of assortment for a kit added to assortment.
            while select Kit,KitElement,KitElementProductMaster from retailKitElements
            where retailKitElements.Kit == _retailKitRecId
                notexists join lookupTmpStaging
                where (lookupTmpStaging.ProductId == retailKitElements.KitElement ||
                lookupTmpStaging.ProductId == retailKitElements.KitElementProductMaster)  &&
                lookupTmpStaging.AssortmentId == _retailAssortmentRefRecId

                //Check if the product exists in an assortment
                if (retailKitElements.KitElement)
            {
                numProductSkipped++;
                warning(strFmt("@REX4161168", retailAssortmentID, EcoResProduct::find(_kitProductMaster).productName(), EcoResProduct::find(retailKitElements.KitElement).productName()));
                existsAllElements= false;
            }
        }
        else
        {
            // validate if kit components and substitutes are part of assortment for a kit CONFIG added to assortment.
            while select Component,KitVariant from retailKitVariantComponent
                where retailKitVariantComponent.KitVariant == _kitVariantRecId
            outer join RecId,productmaster from ecoResDistinctProductVariant
                where ecoResDistinctProductVariant.recid == retailKitVariantComponent.Component
            notexists join lookupTmpStaging
                where (lookupTmpStaging.ProductId == retailKitVariantComponent.Component ||
                lookupTmpStaging.ProductId == ecoResDistinctProductVariant.ProductMaster)  &&
                lookupTmpStaging.AssortmentId == _retailAssortmentRefRecId

            //Check if the product exists in an assortment
            if (retailKitVariantComponent.Component)
            {
                numProductSkipped++;
                warning(strFmt("@REX4161168", retailAssortmentID, EcoResProduct::find(_kitProductMaster).productName(), EcoResProduct::find(retailKitVariantComponent.Component).productName()));
                existsAllElements= false;
            }
        }
        return existsAllElements;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDefaultKitConfiguration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get Default Kit configuration for a given master master
    /// </summary>
    /// <param name = "_kitProductMaster">Kit Master product Id</param>
    /// <returns><c>EcoResDistinctProductVariant</c> record with default configuration for the given Kit.</returns>
    public EcoResDistinctProductVariant GetDefaultKitConfiguration(EcoresProductMasterRecId _kitProductMaster)
    {
        EcoResDistinctProductVariant ecoResDistinctProductVariant;

        if (_kitProductMaster != 0)
        {
            // First variant created for a Kit would be default configuration.
            select firstonly1 RecId, SearchName from ecoResDistinctProductVariant
                order by ecoResDistinctProductVariant.RecId asc
                    where ecoResDistinctProductVariant.ProductMaster == _kitProductMaster;
        }

        return ecoResDistinctProductVariant;
    }

]]></Source>
			</Method>
			<Method>
				<Name>explodeAssortments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Explodes assortments.
    /// </summary>
    protected void explodeAssortments()
    {
        RetailAssortmentTable           assortment;
        RetailAssortmentProductLine     productLine;
        RetailGroupMemberLine           memberLine;
        RetailAllProductCategories      productCategories;
        EcoResDistinctProductVariant    productVariants;
        RetailAssortmentLookupStaging   lookupTmp;
        EcoResCategory                  category, activeCategory;
        utcdatetime                     stepStartTime, stepEndTime;
        
        InventTable                     inventTableSell;
        InventTable                     inventTableDataArea;
        InventItemSalesSetup            inventItemSalesSetup;
        RetailItemsStoppedForSaleTmp    stoppedForSaleTmp, stoppedForSaleTmp1;
        EcoResProductCategory           ecoResProductCategory;

        stepStartTime = DateTimeUtil::utcNow();

        delete_from lookupTmp
            where lookupTmp.AssortmentId == retailAssortmentRefRecId;

        stepEndTime = DateTimeUtil::utcNow();
        this.logStep(funcName(), 'truncating lookupTmp', stepStartTime, stepEndTime);

        stepStartTime = DateTimeUtil::utcNow();

        // Products
        insert_recordset lookupTmp (AssortmentId, ValidFrom, ValidTo, LineType, ProductId)
            select RecId, ValidFrom, ValidTo from assortment
                where assortment.RecId == retailAssortmentRefRecId
            join LineType from productLine
                where
                    productLine.AssortmentRecId == assortment.RecId &&
                    productLine.Status == RetailAssortmentStatusType::Published
            join Product from memberLine
                where
                    memberLine.RecId == productLine.RetailGroupMemberLineId &&
                    memberLine.Product != 0 &&
                    memberLine.Variant == 0
            exists join category
                where
                    memberLine.Category == 0                        // Include product lines that DO NOT have a category
                    || (category.RecId == memberLine.Category &&    // or product lines that DO have a category,
                        category.IsActive == NoYes::Yes);           // ... and the category is Active.

        stepEndTime = DateTimeUtil::utcNow();
        numProductExploded = lookupTmp.RowCount();
        this.logStep(funcName(), strFmt('inserting %1 products into lookupTmp', lookupTmp.RowCount()), stepStartTime, stepEndTime);

        stepStartTime = DateTimeUtil::utcNow();

        // Categories
        insert_recordset lookupTmp (AssortmentId, ValidFrom, ValidTo, LineType, ProductId)
            select RecId, ValidFrom, ValidTo from assortment
                where assortment.RecId == retailAssortmentRefRecId
            join LineType from productLine
                where
                    productLine.AssortmentRecId == assortment.RecId &&
                    productLine.Status == RetailAssortmentStatusType::Published
            join memberLine
                where memberLine.RecId == productLine.RetailGroupMemberLineId
           join category
                where
                    category.RecId == memberLine.Category &&
                    category.IsActive == NoYes::Yes
            join Product from productCategories
                where
                    memberLine.Category == productCategories.Category &&
                    memberLine.Product == 0 &&
                    memberLine.Variant == 0
            // RetailAllProductCategories contains all products associated (directly or indirectly) to a category,
            // need to include products which are part of active categories and the category should be directly linked to a product.
            // Direct link between categories and products is available in EcoResProductCategory table.
            exists join  ecoResProductCategory
                where ecoResProductCategory.Product == productCategories.Product
                exists join  activeCategory
                    where activeCategory.RecId == ecoResProductCategory.Category
                    &&    activeCategory.CategoryHierarchy == category.CategoryHierarchy
                    &&    activeCategory.IsActive == NoYes::Yes;

        EcoResProduct ecoResProductMaster;
        EcoResDistinctProductVariant ecoResDistinctProductVariant;
        RetailAssortmentLookupStaging lookUpStaging,lookUpStagingMaster;

        // Insert the product master if variants are assorted.
        insert_recordset lookupTmp (ProductId, AssortmentId, ValidFrom, ValidTo, LineType)
            select ProductMaster from ecoResDistinctProductVariant group by ecoResDistinctProductVariant.ProductMaster,lookUpStaging.AssortmentId,
                lookUpStaging.ValidFrom,lookUpStaging.ValidTo,lookUpStaging.LineType
                join AssortmentId, ValidFrom, ValidTo, LineType from lookUpStaging
                    where lookUpStaging.ProductId == ecoResDistinctProductVariant.RecId
                    &&    lookUpStaging.AssortmentId == retailAssortmentRefRecId
                notexists join lookUpStagingMaster
                    where lookUpStagingMaster.ProductId == ecoResDistinctProductVariant.ProductMaster
                    &&    lookUpStagingMaster.AssortmentId == retailAssortmentRefRecId;

        stepEndTime = DateTimeUtil::utcNow();
        numProductExplodedByCategory = lookupTmp.RowCount();
        this.logStep(funcName(), strFmt('inserting %1 products via categories into lookupTmp', lookupTmp.RowCount()), stepStartTime, stepEndTime);

        stepStartTime = DateTimeUtil::utcNow();

        // Variants
        insert_recordset lookupTmp (AssortmentId, ValidFrom, ValidTo, LineType, ProductId, VariantId)
            select RecId, ValidFrom, ValidTo from assortment
                where assortment.RecId == retailAssortmentRefRecId
            join LineType from productLine
                where
                    productLine.AssortmentRecId == assortment.RecId &&
                    productLine.Status == RetailAssortmentStatusType::Published
            join memberLine
                where memberLine.RecId == productLine.RetailGroupMemberLineId
            join ProductMaster, RecId from productVariants
                where memberLine.Variant == productVariants.RecId
            exists join category
                where
                    memberLine.Category == 0                        // Include product lines that DO NOT have a category
                    || (category.RecId == memberLine.Category &&    // or product lines that DO have a category,
                        category.IsActive == NoYes::Yes);           // ... and the category is Active.

        stepEndTime = DateTimeUtil::utcNow();
        numVarientExploded = lookupTmp.RowCount();
        this.logStep(funcName(), strFmt('inserting %1 products via variants into lookupTmp', lookupTmp.RowCount()), stepStartTime, stepEndTime);

        // Code below removes products that have been marked as 'Stopped for Sales' in all applicable LEs
        // In AX, this property can be found under Products > Manage Inventory > Default Order Settings > Sales
        // To check if product is released to a LE, use 'Select firstonly' instead 'Select Count(RecId)' to improve performance when flight is enabled.
        if (RetailAssortmentLookupUseSelectFirstOnlyToCheckIfProductReleasedToLEFlight::instance().isEnabled())
        {
            select firstonly crosscompany inventTableDataArea
                exists join lookupTmp
                    where lookupTmp.ProductId == inventTableDataArea.Product;
        }
        else
        {
            select crosscompany count(RecId) from inventTableDataArea
                group by inventTableDataArea.DataAreaId
                exists join lookupTmp
                where lookupTmp.ProductId == inventTableDataArea.Product;
        }

        // If the count is zero it means the product is not released in any LEs,
        // hence it can be concluded that its not stopped for sale in any LE.
        // For this reason we can skip the code which removes the all product which are stopped for sale in all LEs they're released.
        if (inventTableDataArea.RecId == 0)
        {
            return;
        }

        // copy the lookup data to a temp table and remove all items that are not marked as 'Stopped for sales'
        stepStartTime = DateTimeUtil::utcNow();
        insert_recordset stoppedForSaleTmp (ProductId)
            select ProductId from lookupTmp
            group by lookupTmp.ProductId
            where lookupTmp.AssortmentId == retailAssortmentRefRecId;
        
        stepEndTime = DateTimeUtil::utcNow();
        this.logStep(funcName(), strFmt('inserting %1 products into stoppedForSaleTmp', stoppedForSaleTmp.RowCount()), stepStartTime, stepEndTime);
        
        // iterate through the LEs and remove all products which are not marked for stopped (for sale)
        // at the end of the loop stoppedForSaleTmp will contain all products that are marked stopped for sale in all LEs the product is released to,
        // these products will be removed from the lookuptmp as they wont be required in the RetailAssortmentLookup table
        while select crosscompany DataAreaId from inventTableDataArea
            group by inventTableDataArea.DataAreaId
            exists join lookupTmp
            where lookupTmp.ProductId == inventTableDataArea.Product
        
        {
            stepStartTime = DateTimeUtil::utcNow();
            
            changecompany(inventTableDataArea.DataAreaId)
            {
                // setting all references to null to avoid issue with changecompany.
                stoppedForSaleTmp1 = null;
                inventTableSell = null;
                inventItemSalesSetup = null;
                
                // set the reference to the original temp table.
                stoppedForSaleTmp1.linkPhysicalTableInstance(stoppedForSaleTmp);
                
                // remove any product which is not marked as stopped for sale.
                delete_from stoppedForSaleTmp1
                    exists join inventTableSell
                    join inventItemSalesSetup
                    where inventTableSell.ItemId == inventItemSalesSetup.ItemId &&
                          inventItemSalesSetup.stopped == NoYes::No &&
                          stoppedForSaleTmp1.ProductId == inventTableSell.Product;

                numProductSkipped2 = stoppedForSaleTmp1.RowCount();
                
            }
            
            stepEndTime = DateTimeUtil::utcNow();
            this.logStep(funcName(),
                         strFmt('deleting products from stoppedForSaleTmp1 which are not marked as [stopped for sale] in %2 LE', curext()),
                         stepStartTime,
                         stepEndTime);
        }
        
        stepStartTime = DateTimeUtil::utcNow();
        
        // from the lookup table remove all items that are marked as 'Stopped for sales' in all LEs from the original lookupTmp table.
        delete_from lookupTmp
            exists join stoppedForSaleTmp
            where stoppedForSaleTmp.ProductId == lookupTmp.ProductId &&
                  lookupTmp.AssortmentId == retailAssortmentRefRecId;
        
        stepEndTime = DateTimeUtil::utcNow();
        this.logStep(funcName(),
                     strFmt('deleting products from lookupTmp for being marked as stopped for sale in all LEs the products are released to.'),
                     stepStartTime,
                     stepEndTime);

        if (RetailExcludeStoppedVariantsInAssortmentsFlight::instance().isEnabled())
        {
            this.excludeStoppedVariants();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>logStep</Name>
				<Source><![CDATA[
    /// <summary>
    /// log the step.
    /// </summary>
    /// <param name = "methodName">Method where the log was called from.</param>
    /// <param name = "stepName">Description of the step (NOTE: No customer content should be included).</param>
    /// <param name = "startTime">Start time.</param>
    /// <param name = "endTime">End time.</param>
    protected void logStep(str methodName, str stepName, utcdatetime startTime, utcdatetime endTime)
    {
        eventSource.EventWriteProductsRetailAssortmentLookupLogStep(classId2Name(ClassIdGet(this)), methodName, stepName, DateTimeUtil::getDifference(endTime, startTime));
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static RetailAssortmentLookupTask construct()
    {
        return new RetailAssortmentLookupTask();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion,#CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRetailAssortmentID</Name>
				<Source><![CDATA[
    public RetailAssortmentID parmRetailAssortmentID(RetailAssortmentID _retailAssortmentID = retailAssortmentID)
    {
        retailAssortmentID = _retailAssortmentID;
        return retailAssortmentID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRetailAssortmentRecId</Name>
				<Source><![CDATA[
    public RetailAssortmentRefRecId parmRetailAssortmentRecId(RetailAssortmentRefRecId _retailAssortmentRefRecId = retailAssortmentRefRecId)
    {
        retailAssortmentRefRecId = _retailAssortmentRefRecId;
        return retailAssortmentRefRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        utcdatetime totalStartTime = DateTimeUtil::utcNow();
        utcdatetime totalEndTime, stepStartTime, stepEndTime;

        if (!retailAssortmentRefRecId)
        {
            error('RetailAssortmentRecId is a required parameter.');
            return;
        }

        if (!retailAssortmentID)
        {
            error('RetailAssortmentID is a required parameter.');
            return;
        }

        // Create a channel group per assortment.
        stepStartTime = DateTimeUtil::utcNow();
        this.createChannelGroups();
        stepEndTime = DateTimeUtil::utcNow();
        this.logStep(funcName(), 'createChannelGroups()', stepStartTime, stepEndTime);

        // Explode the list of products per channel group and store in a temp table.
        stepStartTime = DateTimeUtil::utcNow();
        this.explodeAssortments();
        stepEndTime = DateTimeUtil::utcNow();
        this.logStep(funcName(), 'explodeAssortments()', stepStartTime, stepEndTime);

        // Validate if all the Kit Components and Substitutes are assorted
        stepStartTime = DateTimeUtil::utcNow();
        this.validateRetailKitsByAssortment(retailAssortmentRefRecId);
        stepEndTime = DateTimeUtil::utcNow();
        this.logStep(funcName(), 'validateRetailKitsByAssortment()', stepStartTime, stepEndTime);

        // Apply only the changed records from the temp table into the new assortment
        // exploded table. We only handle inserts and deletes (no updates).
        stepStartTime = DateTimeUtil::utcNow();
        this.deltaSync();
        stepEndTime = DateTimeUtil::utcNow();
        this.logStep(funcName(), 'deltaSync()', stepStartTime, stepEndTime);

        // Summary of exploded and skipped Products.
        numProductExploded = numProductExploded + numProductExplodedByCategory;
        numProductSkipped = numProductSkipped + numProductSkipped2;
        // Add the product summury to info log.
        info(strFmt("@Retail:RetailProcessProductAssortment", retailAssortmentID, numProductExploded, numProductSkipped, numRemovedProduct, numProductError, numInsertNewProduct, numVarientExploded));

        totalEndTime = DateTimeUtil::utcNow();
        this.logStep(funcName(), 'Assorting took total', totalStartTime, totalEndTime);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Version version = RunBase::getVersion(packedClass);

        switch (version)
        {
            case #CurrentVersion:
                [version,#CurrentList] = packedClass;
                break;
            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateRetailKitsByAssortment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates a retail kit by an assortment.
    /// </summary>
    /// <param name = "_retailAssortmentRecId">The assortment.</param>
    protected void validateRetailKitsByAssortment(RecId _retailAssortmentRecId)
    {
        RetailAssortmentLookupStaging   lookupTmp;
        RetailAssortmentLookupStaging   lookupTmpExclude;
        RetailAssortmentLookupStaging   lookupTmpDelete;
        RetailAssortmentLookupStaging   lookupTmpKit;
        RetailAssortmentLookupStaging   lookupTmpKitMaster;
        RetailKit   retailKit;
        EcoResDistinctProductVariant kitConfig;

        // 1. Check if Kit default configuration is excluded, then don't assort Kit to a channel
        while select ProductId, AssortmentId,LineType, VariantId from lookupTmp
            join ProductMaster from retailKit where
            retailKit.ProductMaster == lookupTmp.ProductId &&
            lookupTmp.AssortmentId == _retailAssortmentRecId &&
            lookupTmp.LineType == RetailAssortmentExcludeIncludeType::Exclude &&
            lookupTmp.VariantId != 0
            notexists join lookupTmpExclude
            where
                lookupTmp.ProductId == lookupTmpExclude.ProductId &&
                lookupTmp.AssortmentId == lookupTmpExclude.AssortmentId
                join lookupTmpKitMaster
                where
                    lookupTmpExclude.ProductId == lookupTmpKitMaster.ProductId &&
                    lookupTmpExclude.AssortmentId == lookupTmpKitMaster.AssortmentId &&
                    lookupTmpKitMaster.LineType == RetailAssortmentExcludeIncludeType::Exclude &&
                    lookupTmpKitMaster.VariantId == 0
        {
            kitConfig = this.GetDefaultKitConfiguration(lookupTmp.ProductId);

            if (kitConfig && (kitConfig.RecId == lookupTmp.VariantId))
            {
                // Remove the product from Assortment lookup staging table
                delete_from lookupTmpDelete where lookupTmpDelete.ProductId == lookupTmp.ProductId && lookupTmpDelete.AssortmentId == _retailAssortmentRecId;
                // Add to Info Log
                warning(strFmt("@REX:KitAssortmentFailedForExcludingDefaultConfig",retailAssortmentID, EcoResProduct::find(lookupTmp.ProductId).productName(), kitConfig.SearchName));
            }
        }

        // 2. Check if explicit Kit configurations are included except Kit default configuration, then don't assort Kit to a channel.

        // First get Kit record which as inclusion type when Master kit is not included but kit variants are included.
        while select ProductId from lookupTmp
            group by lookupTmp.ProductId
            join ProductMaster from retailKit where
            retailKit.ProductMaster == lookupTmp.ProductId &&
            lookupTmp.AssortmentId == _retailAssortmentRecId &&
            lookupTmp.LineType == RetailAssortmentExcludeIncludeType::Include &&
            lookupTmp.VariantId != 0
            notexists join  lookupTmpExclude
            where
                lookupTmp.ProductId == lookupTmpExclude.ProductId &&
                lookupTmp.AssortmentId == lookupTmpExclude.AssortmentId
                join lookupTmpKitMaster
                where
                    lookupTmpExclude.ProductId == lookupTmpKitMaster.ProductId &&
                    lookupTmpExclude.AssortmentId == lookupTmpKitMaster.AssortmentId &&
                    lookupTmpKitMaster.LineType == RetailAssortmentExcludeIncludeType::Include &&
                    lookupTmpKitMaster.VariantId == 0
        {
            kitConfig = this.GetDefaultKitConfiguration(lookupTmp.ProductId);

            // For each Kit master, look for Kit variants which are included explicitly.
            select lookupTmpKit
                where   lookupTmpKit.ProductId == lookupTmp.ProductId &&
                    lookupTmpKit.AssortmentId == _retailAssortmentRecId &&
                    lookupTmpKit.LineType == RetailAssortmentExcludeIncludeType::Include &&
                    lookupTmpKit.VariantId == kitConfig.RecId;

            // If default variant is not found in explicitly included list, then remove Kit and it's variants from assortment lookup staging.
            if (lookupTmpKit.RecId == 0)
            {
                // Remove the product from Assortment lookup staging table
                delete_from lookupTmpDelete where lookupTmpDelete.ProductId == lookupTmp.ProductId && lookupTmpDelete.AssortmentId == _retailAssortmentRecId;
                // Add to Info Log
                warning(strFmt("@REX:KitAssortmentFailedForNotIncludingDefaultConfig",retailAssortmentID, EcoResProduct::find(lookupTmp.ProductId).productName(), kitConfig.SearchName));
            }
        }

        // 3. Check if the components and substitutes of kit exists in assortment.
        while select ProductId, AssortmentId,LineType, VariantId from lookupTmp
            join ProductMaster from retailKit where
            retailKit.ProductMaster == lookupTmp.ProductId &&
            lookupTmp.AssortmentId == _retailAssortmentRecId &&
            lookupTmp.LineType == RetailAssortmentExcludeIncludeType::Include
            notexists join lookupTmpExclude
            where
                lookupTmp.ProductId == lookupTmpExclude.ProductId &&
                lookupTmp.AssortmentId == lookupTmpExclude.AssortmentId &&
                lookupTmpExclude.LineType == RetailAssortmentExcludeIncludeType::Exclude
        {
            if (!this.ExistsAllKitElementsInAssortment(retailKit.RecId, lookupTmp.AssortmentId, retailKit.ProductMaster, lookupTmp.VariantId))
            {
                // Remove the product from Assortment lookup staging table
                delete_from lookupTmpDelete where lookupTmpDelete.ProductId == lookupTmp.ProductId && lookupTmpDelete.AssortmentId == _retailAssortmentRecId;
                // Add to Info Log
                warning(strFmt("@REX4160887",retailAssortmentID, EcoResProduct::find(lookupTmp.ProductId).productName()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>excludeStoppedVariants</Name>
				<Source><![CDATA[
    /// <summary>
    /// Explicitly exclude the stopped variants from assortments when master products are not stopped but some of the
    /// product dimensions of master products are marked as stopped in all legal entities and in no specific site
    /// </summary>
    private void excludeStoppedVariants()
    {
        RetailAssortmentTable                  retailAssortmentTable;
        RetailAssortmentLookupStaging          lookupTmp, lookupTmpCopy;
        RetailItemsStoppedForSaleTmp           stoppedForSaleTmp;
        RetailProductVariantsStoppedForSaleTmp variantsStoppedForSaleTmp;
        EcoResDistinctProductVariant           ecoResDistinctProductVaraint;
        InventItemSalesSetup                   inventItemSalesSetup;
        InventItemOrderSetupMap                inventItemSalesOrderSetupMap;
        EcoResProductMaster                    ecoResProductMaster;
        InventDimCombination                   inventDimCombination, inventDimCombinationDataArea;
        InventTable                            inventTable;
        utcdatetime                            stepStartTime, stepEndTime;
        Counter                                counter = 0;
        
        // truncating temp table to clear any existing data.
        delete_from stoppedForSaleTmp;

        stepStartTime = DateTimeUtil::utcNow();

        // copying the product masters in lookup data whose dimensions are marked as 'Stopped for sales' to temp table RetailItemsStoppedForSaleTmp
        insert_recordset stoppedForSaleTmp (ProductId)
            select ProductId from lookupTmp
                group by lookupTmp.ProductId
                where lookupTmp.AssortmentId == retailAssortmentRefRecId
                && lookupTmp.LineType == RetailAssortmentExcludeIncludeType::Include
            join ecoResProductMaster
                where ecoResProductMaster.RecId == lookupTmp.ProductId
            join inventItemSalesSetup
                where inventItemSalesSetup.ItemId == ecoResProductMaster.DisplayProductNumber
                && inventItemSalesSetup.Override == NoYes::Yes
                && inventItemSalesSetup.Stopped == NoYes::Yes;

        stepEndTime = DateTimeUtil::utcNow();
        this.logStep(funcName(), strFmt('inserting %1 products into stoppedForSaleTmp', stoppedForSaleTmp.RowCount()), stepStartTime, stepEndTime);

        if (!stoppedForSaleTmp.RowCount())
        {
            return;
        }
        
        stepStartTime = DateTimeUtil::utcNow();

        // copying all the variants of product masters in RetailItemsStoppedForSaleTmp to another temp table RetailProductVariantsStoppedForSaleTmp
        insert_recordset variantsStoppedForSaleTmp (ProductId, VariantId)
            select ProductId from stoppedForSaleTmp
            join RecId from ecoResDistinctProductVaraint
                where ecoResDistinctProductVaraint.ProductMaster == stoppedForSaleTmp.ProductId;

        stepEndTime = DateTimeUtil::utcNow();
        this.logStep(funcName(), strFmt('inserting %1 variants into variantsStoppedForSaleTmp', variantsStoppedForSaleTmp.RowCount()), stepStartTime, stepEndTime);

        if (!variantsStoppedForSaleTmp.RowCount())
        {
            return;
        }

        stepStartTime = DateTimeUtil::utcNow();

        // Iterates through all the legal entities in which the product variants in the RetailProductVariantsStoppedForSaleTmp table are released
        // and deletes the variants from table if they are not stopped in at least one legal entity.
        // By the end of the loop RetailProductVariantsStoppedForSaleTmp will contain variants which should be excluded from assortments.
        while select crosscompany DataAreaId from inventDimCombinationDataArea
            join variantsStoppedForSaleTmp
            where inventDimCombinationDataArea.DistinctProductVariant == variantsStoppedForSaleTmp.VariantId
        {
            // Clearing the buffers to avoid issues with 'changecompany'
            inventDimCombination.clear();
            inventTable.clear();
            inventItemSalesOrderSetupMap.clear();

            changecompany(inventDimCombinationDataArea.DataAreaId)
            {
                inventDimCombination = InventDimCombination::findByDistinctProductVariant(variantsStoppedForSaleTmp.VariantId);
                inventTable          = InventTable::find(inventDimCombination.ItemId);

                if (inventDimCombination && inventTable.checkDimensionGroups())
                {
                    inventItemSalesOrderSetupMap = InventItemOrderSetupMap::find(inventDimCombination.ItemId, InventItemOrderSetupType::Sales, inventDimCombination.InventDimId);

                    // Deleting variant from the RetailProductVariantsStoppedForSaleTmp table if it is not stopped in the current legal entity
                    if (inventItemSalesOrderSetupMap && inventItemSalesOrderSetupMap.Stopped() == NoYes::No)
                    {
                        delete_from variantsStoppedForSaleTmp
                            where variantsStoppedForSaleTmp.VariantId == inventDimCombination.DistinctProductVariant;

                        counter++;
                    }
                }
            }
        }

        stepEndTime = DateTimeUtil::utcNow();
        this.logStep(funcName(), strFmt('deleting %1 variants in variantsStoppedForSaleTmp', counter), stepStartTime, stepEndTime);

        stepStartTime = DateTimeUtil::utcNow();

        // Inserting the variants remained in the RetailProductVariantsStoppedForSaleTmp table to staging lookup table with line type as 'Excluded'
        insert_recordset lookupTmp (AssortmentId, ValidFrom, ValidTo, ProductId, VariantId)
            select RecId, ValidFrom, ValidTo from retailAssortmentTable
               join lookupTmpCopy
            where lookupTmpCopy.AssortmentId == retailAssortmentTable.RecId
               join ProductId, VariantId from variantsStoppedForSaleTmp
            where variantsStoppedForSaleTmp.ProductId == lookupTmpCopy.ProductId;

        stepEndTime = DateTimeUtil::utcNow();
        this.logStep(funcName(),
                     strFmt('inserting %1 variants into lookupTmp as excluded for being marked as stopped for sale in all legal entities the variants are released to.', lookupTmp.RowCount()),
                     stepStartTime,
                     stepEndTime);
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the description of the class
    /// </summary>
    /// <returns>
    /// The class description.
    /// </returns>
    public static ClassDescription description()
    {
        return "@RET260929";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        RetailAssortmentLookupTask scheduler = RetailAssortmentLookupTask::construct();

        if (scheduler.prompt())
        {
            scheduler.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Describes whether the class is designed for execution in a new session.
    /// </summary>
    /// <returns>
    /// false.
    /// </returns>
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    final boolean isRetryable()
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>