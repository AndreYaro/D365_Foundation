<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventMov_Virtuel</Name>
	<SourceCode>
		<Declaration><![CDATA[
class InventMov_Virtuel extends InventMovement
{
    InventTransId               inventTransId;
    InventTransOriginId         markingRefInventTransOrigin;

    InventQty                   transqty;
    PdsCWInventQty              cwTransQty;
    ItemId                      itemId;
    InventDimId                 inventDimId;

    TransDate                   transDate;
    SalesShippingDateRequested  salesShippingDateRequested;

    SchedTime                   transSchedTime;

    DimensionDefault            dimension;
    DimensionDefault            dimensionOperation;

    InventQty                   remainPhysical;
    PdsCWInventQty              cwRemainPhysical;

    LedgerDimensionDefaultAccount   accountBalanceSheet;
    LedgerDimensionDefaultAccount   accountOperations;

    InventTransType             transType;

    InventTransRefId            transRefId;
    InventTransOriginId         returnInventTransOrigin;

    NoYes                       mustBeQuarantineControlled;
    NoYes                       mustBeQuotationControlled;

    ProjId                      projId;
    ProjCategoryId              projCategoryId;

    AssetId                     assetId;

    LedgerPostingType           postingOperations;
    LedgerPostingType           postingBalanceSheet;

    InventMov_Virtuel           inventMovVirtuelOrig;

    boolean                     userEnteredPriceAsCost;

    InventTrans                 inventMovTrans;
    InventMovement              inventMovReference;

    boolean                     mustSetProjAdjRefInventTrans;
    boolean                     mustDoAutoLossProfit;
    boolean                     mustSetProjAdjRefInventTransTmp;
    smmActivityNumber           activityNumber;

    ProjTransactionOrigin       projTransactionOrigin;
    ProjLedgerOrigin            projLedgerOrigin;

    boolean                     canCommittedCostBeReversed;

    boolean                     mustBeBookedPhysically;
    LedgerPostingType           postingPhysical;
    LedgerDimensionDefaultAccount   accountPhysical;
    LedgerPostingType           postingOffsetPhysical;
    LedgerDimensionDefaultAccount   offsetAccountPhysical;
    boolean                     mustBeDeducted;
    boolean                     skipReservationForMarkingCreation;

    Voucher                     relatedVoucher;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>accountBalanceSheet</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountBalanceSheet()
    {
        return accountBalanceSheet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountOperations</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountOperations()
    {
        return accountOperations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the physical ledger account.
    /// </summary>
    /// <returns>
    ///    The physical ledger account.
    /// </returns>
    public LedgerDimensionDefaultAccount accountPhysical()
    {
        if (mustBeBookedPhysically)
        {
            return accountPhysical;
        }
        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>activityNumber</Name>
				<Source><![CDATA[
    public ProjActivityNumber activityNumber()
    {
        return activityNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRemainPhysical</Name>
				<Source><![CDATA[
    public void  addRemainPhysical(InventQty  _inventQty)
    {
        remainPhysical += _inventQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetId</Name>
				<Source><![CDATA[
    public AssetId assetId()
    {
        return assetId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeAutoRepAsFinished</Name>
				<Source><![CDATA[
    public boolean  canBeAutoRepAsFinished()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeReserved</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the instance of the <c>InventMovement</c> class, such as a <c>SalesLine</c>
    ///    table, can be reserved.
    /// </summary>
    /// <returns>
    ///    true if the <c>InventMovement</c> instance can be reserved; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method returns a Boolean value from the <c>InventType</c> class. For example, if a
    ///    <c>SalesLine</c> table is entered, a <c>SalesLineType</c> class is initialized. On this class, the
    ///    method can be set to return if the type, for example, the <c>SalesLine</c> table, can be reserved.
    ///    This method is often used together with the <c>mustBeAutoReserved</c> method.
    /// </remarks>
    public boolean  canBeReserved()
    {
        if (this.projId())
        {
            return super();
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCommittedCostBeReversed</Name>
				<Source><![CDATA[
    public boolean canCommittedCostBeReversed()
    {
        return canCommittedCostBeReversed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInventDimForInventDimField</Name>
				<Source><![CDATA[
    protected boolean checkInventDimForInventDimField(
        InventQty                       _qty,
        InventDim                       _inventDim,
        InventDimGroupFieldSetup        _inventDimGroupFieldSetup,
        boolean                         _finalCheck,
        boolean                         _showError
        )
    {
        if (this.projId()
            && !_inventDim.wMSLocationId
            && _inventDimGroupFieldSetup.dimFieldId() == fieldNum(InventDim, wMSLocationId)
            && this.transType() == InventTransType::InventTransaction)
        {                
            if (inventTable.ItemType == ItemType::Service && inventTable.modelGroup().StockedProduct)
            {
                // stocked service items can never have on hand, so accept blank Location values in this scenario
                return true;
            }
        }

        return super(_qty, _inventDim, _inventDimGroupFieldSetup, _finalCheck, _showError);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInventTransBePhysicalUpdated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Verifies whether an inventory transaction can be physically updated.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The inventory transaction that to verify.
    /// </param>
    /// <returns>
    ///    true if the inventory transaction can be physically updated.
    /// </returns>
    /// <remarks>
    ///    This method will be used to determine whether an inventory transaction can be physically updated.
    /// </remarks>
    public boolean canInventTransBePhysicalUpdated(InventTrans _inventTrans)
    {
        InventTrans         inventTrans;
        InventTransOrigin   inventTransOriginQuarantine;
        boolean             ret = super(_inventTrans);

        if (!ret || !this.projId() || !this.mustBeQuarantineControlled())
        {
            return ret;
        }

        InventMovement mov = InventMovement::constructNoThrow(InventTrans::findByInventTransOrigin(_inventTrans.MarkingRefInventTransOrigin));
        if (mov && mov.transType() == InventTransType::QuarantineOrder)
        {
            return true;
        }

        select firstonly RecId from inventTrans
            where   inventTrans.InventTransOrigin                       == _inventTrans.InventTransOrigin
               &&   inventTrans.MarkingRefInventTransOrigin             != _inventTrans.MarkingRefInventTransOrigin
            exists join  inventTransOriginQuarantine
                where   inventTransOriginQuarantine.RecId               == inventTrans.MarkingRefInventTransOrigin
                   &&   inventTransOriginQuarantine.ReferenceCategory   == InventTransType::QuarantineOrder;

        return (inventTrans.RecId == 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNotSubDelivery</Name>
				<Source><![CDATA[
    protected boolean checkNotSubDelivery(
        InventQty       _physicalNow,
        InventQty       _remainPhysicalNow,
        boolean         _isPhysicalUpdate,
        PdsCWInventQty  _pdsCWPhysicalNow,
        PdsCWInventQty  _pdsCWRemainPhysicalNow
        )
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateEstimated</Name>
				<Source><![CDATA[
    public boolean checkUpdateEstimated(
        InventUpd_Estimated     _updateNow,
        InventMovement          _this_Orig)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateFinancial</Name>
				<Source><![CDATA[
    public boolean checkUpdateFinancial(InventUpd_Financial _updateNow)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdatePhysical</Name>
				<Source><![CDATA[
    public boolean checkUpdatePhysical(InventUpd_Physical _updateNow)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultDimension</Name>
				<Source><![CDATA[
    public DimensionDefault defaultDimension()
    {
        return dimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimatedPhysicalValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the estimated physical value for an inventory transaction.
    /// </summary>
    /// <param name="_inventTrans">
    /// The <c>inventTrans</c> record for which to get the estimated physical value.
    /// </param>
    /// <param name="_inventOnhand">
    /// A <c>InventOnHand</c> object.
    /// </param>
    /// <param name="_updateNow">
    /// A <c>InventUpdate</c> object.
    /// </param>
    /// <returns>
    /// The estimated physical value for the inventory transaction.
    /// </returns>
    protected CostAmount estimatedPhysicalValue(
        InventTrans     _inventTrans,
        InventOnhand    _inventOnhand,
        InventUpdate    _updateNow)
    {
        CostAmount      costAmount;
        Qty             qty;

        if (inventMovReference && (!(inventMovReference.projId() && inventMovReference.inventModelGroup().inventModelType().stdCostBased())))
        {           
            [qty,costAmount] = InventTransOrigin::calcMarkedCostValue(this.getVirtualTransMarkingRefBasedOnQuarantineExistence(_inventTrans.MarkingRefInventTransOrigin), 
                                                                      this.itemId(), 
                                                                      true, 
                                                                      _inventTrans.InventTransOrigin);
            costAmount = CurrencyExchangeHelper::amount(costAmount / (qty ? qty : 1) * _inventTrans.Qty);
        }
        else
        {
            costAmount = super(_inventTrans, _inventOnhand, _updateNow);
        }

        return costAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimatedPhysicalValueSecCur_RU</Name>
				<Source><![CDATA[
    CostAmount estimatedPhysicalValueSecCur_RU(
        InventTrans     _inventTrans,
        InventOnhand    _inventOnhand,
        InventUpdate    _updateNow)
    {
        CostAmount      costAmount;

        if (inventMovReference && (!(inventMovReference.projId() && inventMovReference.inventModelGroup().inventModelTypeSecCur_RU().stdCostBased())))
        {
            // For project virtual issue except standard cost, the cost amount will always be negative of the receipt
            InventTrans inventTransReceipt = InventTrans::findByInventTransOrigin(_inventTrans.MarkingRefInventTransOrigin);

            costAmount = -inventTransReceipt.CostAmountSecCurPhysical_RU;
        }
        else
        {
            costAmount = super(_inventTrans, _inventOnhand, _updateNow);
        }

        return costAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventDimForIssueTransFromReceipt</Name>
				<Source><![CDATA[
    public InventDim getInventDimForIssueTransFromReceipt(InventDim _inventDimIssue, InventDim _inventDimReceipt)
    {
        InventDim retInventDim;

        if (this.projId() != ''
            && _inventDimReceipt.InventLocationId
            && _inventDimReceipt.inventLocation().WHSEnabled)
        {
            retInventDim = _inventDimReceipt;
        }
        else
        {
            retInventDim = _inventDimIssue;
        }

        return retInventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initAutoEstimateFromOrig</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the internal variables based on the original inventory movement.
    /// </summary>
    /// <param name="_movement_Orig">
    ///    The original inventory movement.
    /// </param>
    public void initAutoEstimateFromOrig(InventMovement _movement_Orig)
    {
        this.setTransQty(-_movement_Orig.transQty());
        this.parmInventDimId(_movement_Orig.inventDimId());
        this.parmTransDate(_movement_Orig.transDate());
        this.parmShippingDateRequested(_movement_Orig.shippingDateRequested());
        this.parmTransSchedTime(_movement_Orig.transSchedTime());
        this.parmReturnInventTransOrigin(_movement_Orig.returnInventTransOrigin());
        this.parmAssetId(_movement_Orig.assetId());
        this.parmActivityNumber(_movement_Orig.activityNumber());
        this.parmProjCategoryId(_movement_Orig.projCategoryId());
        this.parmMustBeQuotationControlled(_movement_Orig.mustBeQuotationControlled());
        this.parmProjId(_movement_Orig.projId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventTransFinancial</Name>
				<Source><![CDATA[
    public void initInventTransFinancial(
        InventTrans         _inventTrans,
        TransDate           _dateFinancial,
        InvoiceId           _invoiceId,
        CurrencyCode        _currencyCode
        )
    {
        super(_inventTrans, _dateFinancial, _invoiceId, _currencyCode);
        this.setProjAdjustRefId(_inventTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventTransPhysical</Name>
				<Source><![CDATA[
    public void initInventTransPhysical(
        InventTrans     _inventTrans,
        TransDate       _datePhysical,
        PackingSlipId   _packingSlipId
        )
    {
        super(_inventTrans, _datePhysical, _packingSlipId);
        if (!this.parmInventMovReference())
        {
            this.setProjAdjustRefId(_inventTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimId</Name>
				<Source><![CDATA[
    public InventDimId inventDimId()
    {
        return inventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventLocationId</Name>
				<Source><![CDATA[
    public InventLocationId inventLocationId()
    {
        return InventDim::find(inventDimId).InventLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVirtuel</Name>
				<Source><![CDATA[
    public boolean isVirtuel()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemId</Name>
				<Source><![CDATA[
    public ItemId  itemId()
    {
        return itemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markingRefInventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ID of the marked transaction origin.
    /// </summary>
    /// <returns>
    ///    zero if the whole movement is not marked; otherwise, the ID of the transaction origin.
    /// </returns>
    public InventTransOriginId markingRefInventTransOrigin()
    {
        return markingRefInventTransOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeBookedPhysically</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the physical inventory is to be posted to the ledger
    /// </summary>
    /// <returns>
    ///    true if the posting physical inventory to the ledger; otherwise, false
    /// </returns>
    public boolean  mustBeBookedPhysically()
    {
        return mustBeBookedPhysically;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeCostControlled</Name>
				<Source><![CDATA[
    public boolean mustBeCostControlled()
    {
        if (! this.parmInventMovReference())
        {
            return false;
        }
        return this.parmInventMovReference().mustBeCostControlled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeDeducted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether mandatory deduction is required.
    /// </summary>
    /// <returns>
    /// A Boolean value, which indicates whether mandatory deduction is required.
    /// </returns>
    public boolean mustBeDeducted()
    {
        return mustBeDeducted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBePicked</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the transactions that are related to this movement must be picked.
    /// </summary>
    /// <returns>
    ///    true if the transactions must be picked; otherwise, false.
    /// </returns>
    public boolean mustBePicked()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeQuarantineControlled</Name>
				<Source><![CDATA[
    public boolean mustBeQuarantineControlled()
    {
        return mustBeQuarantineControlled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeQuotationControlled</Name>
				<Source><![CDATA[
    public boolean mustBeQuotationControlled()
    {
        return mustBeQuotationControlled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeRegistered</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the transactions that are related to this movement must be registered.
    /// </summary>
    /// <returns>
    ///    true if transactions must be registered; otherwise, false.
    /// </returns>
    public boolean mustBeRegistered()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeRemainControlled</Name>
				<Source><![CDATA[
    public boolean  mustBeRemainControlled()
    {
        // Virtual movement will always return true
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustReserveBasedOnMarkingOnCreation</Name>
				<Source><![CDATA[
    public boolean mustReserveBasedOnMarkingOnCreation()
    {
        return !skipReservationForMarkingCreation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSetProjAdjRefInventTrans</Name>
				<Source><![CDATA[
    public boolean mustSetProjAdjRefInventTrans()
    {
        return mustSetProjAdjRefInventTransTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSetProjAdjustRefInventTrans</Name>
				<Source><![CDATA[
    public boolean mustSetProjAdjustRefInventTrans()
    {
        return mustSetProjAdjRefInventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new(Common _common)
    {
        super(_common);

        remainPhysical = 0;
        cwRemainPhysical = 0;

        mustBeQuarantineControlled = NoYes::No;
        canCommittedCostBeReversed = true;
        projTransactionOrigin = ProjOrigin::None;
        projLedgerOrigin = ProjOrigin::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newMovement_Orig</Name>
				<Source><![CDATA[
    public InventMovement newMovement_Orig()
    {
        if (!inventMovVirtuelOrig)
        {
            return null;
        }
        return inventMovVirtuelOrig;
    }

]]></Source>
			</Method>
			<Method>
				<Name>offsetAccountPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the physical offset ledger account
    /// </summary>
    /// <returns>
    ///    The physical offset ledger account
    /// </returns>
    public LedgerDimensionDefaultAccount offsetAccountPhysical()
    {
        if (mustBeBookedPhysically)
        {
            return offsetAccountPhysical;
        }
        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountBalanceSheet</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount parmAccountBalanceSheet(LedgerDimensionDefaultAccount _accountBalanceSheet = accountBalanceSheet)
    {
        accountBalanceSheet = _accountBalanceSheet;
        return accountBalanceSheet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountOperations</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount parmAccountOperations(LedgerDimensionDefaultAccount _accountOperations = accountOperations)
    {
        accountOperations = _accountOperations;
        return accountOperations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountPhysical</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount parmAccountPhysical(LedgerDimensionDefaultAccount _accountPhysical = accountPhysical)
    {
        accountPhysical = _accountPhysical;
        return accountPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmActivityNumber</Name>
				<Source><![CDATA[
    protected smmActivityNumber parmActivityNumber(smmActivityNumber _activityNumber = activityNumber)
    {
        activityNumber = _activityNumber;
        return activityNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAssetId</Name>
				<Source><![CDATA[
    protected AssetId parmAssetId(AssetId _assetId = assetId)
    {
        assetId=_assetId;
        return assetId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanCommittedCostBeReversed</Name>
				<Source><![CDATA[
    protected boolean parmCanCommittedCostBeReversed(boolean _canCommittedCostBeReversed = canCommittedCostBeReversed)
    {
        canCommittedCostBeReversed = _canCommittedCostBeReversed;
        return canCommittedCostBeReversed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDefaultDimension</Name>
				<Source><![CDATA[
    protected DimensionDefault parmDefaultDimension(DimensionDefault _dimension = dimension)
    {
        dimension = _dimension;
        return dimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDimId</Name>
				<Source><![CDATA[
    protected InventDimId parmInventDimId(InventDimId _inventDimId = inventDimId)
    {
        inventDimId = _inventDimId;
        return inventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventMovReference</Name>
				<Source><![CDATA[
    public InventMovement parmInventMovReference(InventMovement _inventMovReference=inventMovReference)
    {
        inventMovReference = _inventMovReference;
        return inventMovReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventMovVirtuelOrig</Name>
				<Source><![CDATA[
    public InventMovement parmInventMovVirtuelOrig(InventMov_Virtuel _inventMovVirtuelOrig=inventMovVirtuelOrig)
    {
        inventMovVirtuelOrig = _inventMovVirtuelOrig;
        return inventMovVirtuelOrig;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventTransId</Name>
				<Source><![CDATA[
    protected InventTransId parmInventTransId(InventTransId _inventTransId = inventTransId)
    {
        inventTransId = _inventTransId;
        return inventTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItemId</Name>
				<Source><![CDATA[
    protected ItemId  parmItemId(ItemId _itemId = itemId)
    {
        itemId = _itemId;
        return itemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMarkingRefInventTransOrigin</Name>
				<Source><![CDATA[
    protected InventTransOriginId parmMarkingRefInventTransOrigin(InventTransOriginId _markingRefInventTransOrigin = markingRefInventTransOrigin)
    {
        markingRefInventTransOrigin = _markingRefInventTransOrigin;
        return markingRefInventTransOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMustBeBookedPhysically</Name>
				<Source><![CDATA[
    public boolean parmMustBeBookedPhysically(boolean _mustBeBookedPhysically = mustBeBookedPhysically)
    {
        mustBeBookedPhysically = _mustBeBookedPhysically;
        return mustBeBookedPhysically;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMustBeDeducted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets or gets the Boolean that determines whether mandatory deduction is required.
    /// </summary>
    /// <param name="_mustBeDeducted">
    /// Boolean that determines whether mandatory deduction is required.
    /// </param>
    /// <returns>
    /// Boolean that determines whether mandatory deduction is required.
    /// </returns>
    public boolean parmMustBeDeducted(boolean _mustBeDeducted = mustBeDeducted)
    {
        mustBeDeducted = _mustBeDeducted;

        return mustBeDeducted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMustBeQuarantineControlled</Name>
				<Source><![CDATA[
    public NoYes parmMustBeQuarantineControlled(NoYes _noYes = mustBeQuarantineControlled)
    {
        mustBeQuarantineControlled = _noYes;
        return mustBeQuarantineControlled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMustBeQuotationControlled</Name>
				<Source><![CDATA[
    protected NoYes parmMustBeQuotationControlled(NoYes _noYes = mustBeQuotationControlled)
    {
        mustBeQuotationControlled = _noYes;
        return mustBeQuotationControlled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMustSetProjAdjRefInventTrans</Name>
				<Source><![CDATA[
    protected boolean parmMustSetProjAdjRefInventTrans(boolean _mustSetProjAdjRefInventTrans = mustSetProjAdjRefInventTrans)
    {
        mustSetProjAdjRefInventTrans = _mustSetProjAdjRefInventTrans;
        return mustSetProjAdjRefInventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMustSetProjAdjRefInventTransTmp</Name>
				<Source><![CDATA[
    protected boolean parmMustSetProjAdjRefInventTransTmp(boolean _mustSetProjAdjRefInventTransTmp = mustSetProjAdjRefInventTransTmp)
    {
        mustSetProjAdjRefInventTransTmp = _mustSetProjAdjRefInventTransTmp;
        return mustSetProjAdjRefInventTransTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOffsetAccountPhysical</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount parmOffsetAccountPhysical(LedgerDimensionDefaultAccount _offsetAccountPhysical = offsetAccountPhysical)
    {
        offsetAccountPhysical = _offsetAccountPhysical;
        return offsetAccountPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostingBalanceSheet</Name>
				<Source><![CDATA[
    public LedgerPostingType parmPostingBalanceSheet(LedgerPostingType _postingBalanceSheet = postingBalanceSheet)
    {
        postingBalanceSheet = _postingBalanceSheet;
        return postingBalanceSheet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostingOffsetPhysical</Name>
				<Source><![CDATA[
    public LedgerPostingType parmPostingOffsetPhysical(LedgerPostingType _postingOffsetPhysical = postingOffsetPhysical)
    {
        postingOffsetPhysical = _postingOffsetPhysical;
        return postingOffsetPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostingOperations</Name>
				<Source><![CDATA[
    LedgerPostingType parmPostingOperations(LedgerPostingType _postingOperations = postingOperations)
    {
        postingOperations = _postingOperations;
        return postingOperations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostingPhysical</Name>
				<Source><![CDATA[
    public LedgerPostingType parmPostingPhysical(LedgerPostingType _postingPhysical = postingPhysical)
    {
        postingPhysical = _postingPhysical;
        return postingPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjAdjustRefId</Name>
				<Source><![CDATA[
    protected ProjAdjustRefId parmProjAdjustRefId(ProjAdjustRefId _projAdjustRefId = projAdjustRefId)
    {
        projAdjustRefId = _projAdjustRefId;
        return  projAdjustRefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjCategoryId</Name>
				<Source><![CDATA[
    protected ProjCategoryId parmProjCategoryId(ProjCategoryId _projCategoryId = projCategoryId)
    {
        projCategoryId = _projCategoryId;
        return projCategoryId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjId</Name>
				<Source><![CDATA[
    protected ProjId parmProjId(ProjId _projId = projId)
    {
        projId = _projId;
        return projId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjLedgerOrigin</Name>
				<Source><![CDATA[
    protected ProjTransactionOrigin parmProjLedgerOrigin(ProjTransactionOrigin _projLedgerOrigin = projLedgerOrigin)
    {
        projLedgerOrigin = _projLedgerOrigin;
        return projLedgerOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjTransactionOrigin</Name>
				<Source><![CDATA[
    protected ProjTransactionOrigin parmProjTransactionOrigin(ProjTransactionOrigin _projTransactionOrigin = projTransactionOrigin)
    {
        projTransactionOrigin = _projTransactionOrigin;
        return projTransactionOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReturnInventTransOrigin</Name>
				<Source><![CDATA[
    protected InventTransOriginId parmReturnInventTransOrigin(InventTransOriginId _returnInventTransOrigin = returnInventTransOrigin)
    {
        returnInventTransOrigin = _returnInventTransOrigin;
        return returnInventTransOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShippingDateRequested</Name>
				<Source><![CDATA[
    protected SalesShippingDateRequested parmShippingDateRequested(SalesShippingDateRequested _salesShippingDateRequested = salesShippingDateRequested)
    {
        salesShippingDateRequested = _salesShippingDateRequested;
        return salesShippingDateRequested;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipReservationForMarkingCreation</Name>
				<Source><![CDATA[
    public boolean parmSkipReservationForMarkingCreation(boolean _skipReservationForMarkingCreation = skipReservationForMarkingCreation)
    {
        skipReservationForMarkingCreation = _skipReservationForMarkingCreation;

        return skipReservationForMarkingCreation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransDate</Name>
				<Source><![CDATA[
    protected TransDate parmTransDate(TransDate _transDate = transDate)
    {
        transDate = _transDate;
        return transDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransQty</Name>
				<Source><![CDATA[
    public InventQty parmTransQty(InventQty _transQty = transQty)
    {
        transQty = _transQty;
        return transQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransRefId</Name>
				<Source><![CDATA[
    public InventTransRefId parmTransRefId(InventTransRefId _transRefId = transRefId)
    {
        transRefId = _transRefId;
        return transRefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransSchedTime</Name>
				<Source><![CDATA[
    protected SchedTime parmTransSchedTime(SchedTime _transSchedTime = transSchedTime)
    {
        transSchedTime = _transSchedTime;
        return transSchedTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransType</Name>
				<Source><![CDATA[
    public InventTransType parmTransType(InventTransType _transType = transType)
    {
        transType = _transType;
        return transType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseEnteredPriceAsCost</Name>
				<Source><![CDATA[
    public boolean parmUseEnteredPriceAsCost(boolean _userEnteredPriceAsCost = userEnteredPriceAsCost)
    {
        userEnteredPriceAsCost = _userEnteredPriceAsCost;
        return userEnteredPriceAsCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWAddRemainPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the catch weight quantity to remain physical.
    /// </summary>
    /// <param name="_cwQty">
    /// A catch weight quantity to add to remain physical.
    /// </param>
    public void pdsCWAddRemainPhysical(PdsCWInventQty  _cwQty)
    {
        cwRemainPhysical += _cwQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWParmTransQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the catch weight transaction quantity.
    /// </summary>
    /// <param name="_cwTransQty">
    /// The value to set; optional.
    /// </param>
    /// <returns>
    /// The catch weight transaction quantity.
    /// </returns>
    public PdsCWInventQty pdsCWParmTransQty(
        PdsCWInventQty _cwTransQty = cwTransQty)
    {
        cwTransQty = _cwTransQty;
        return cwTransQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWRemainPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the catch weight remain physical quantity.
    /// </summary>
    /// <returns>
    /// The catch weight remain physical quantity.
    /// </returns>
    public PdsCWInventQty pdsCWRemainPhysical()
    {
        return cwRemainPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWSetRemainPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the catch weight remain physical quantity.
    /// </summary>
    /// <param name="_cwRemain">
    /// A catch weight quantity to set to remain physical.
    /// </param>
    public void pdsCWSetRemainPhysical(PdsCWInventQty _cwRemain)
    {
        cwRemainPhysical = _cwRemain;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWSetTransQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the catch weight transaction quantity.
    /// </summary>
    /// <param name="_cwQty">
    /// A catch weight transaction quantity to set.
    /// </param>
    public void pdsCWSetTransQty(PdsCWInventQty _cwQty)
    {
        cwTransQty = _cwQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWTransQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the catch weight transaction quantity.
    /// </summary>
    /// <returns>
    /// The catch weight transaction quantity.
    /// </returns>
    public PdsCWInventQty pdsCWTransQty()
    {
        return cwTransQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingBalanceSheet</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Shows the <c>InventIssueFixedAsset</c> when a fixed asset is part of the inventory movement.
    /// </summary>
    /// <returns>
    ///    A <c>LedgerPostingType</c> enumeration value of transaction type.
    /// </returns>
    public LedgerPostingType postingBalanceSheet()
    {
        if (postingBalanceSheet)
        {
            return postingBalanceSheet;
        }

        if (this.transQty() >= 0)
        {
            return LedgerPostingType::InventReceipt;
        }

        return (this.assetId()) ? LedgerPostingType::InventIssueFixedAsset :
                                  LedgerPostingType::InventIssue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingOffsetPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the physical offset ledger posting type
    /// </summary>
    /// <returns>
    ///    The physical offset ledger posting type
    /// </returns>
    public LedgerPostingType postingOffsetPhysical()
    {
        if (mustBeBookedPhysically)
        {
            return postingOffsetPhysical;
        }
        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingOperations</Name>
				<Source><![CDATA[
    public LedgerPostingType postingOperations()
    {
        if (postingOperations)
        {
            return postingOperations;
        }

        if (transType == InventTransType::Asset)
        {
            if (this.transQty() >= 0)
            {
                return LedgerPostingType::FixedAssetsCredit;
            }
            return LedgerPostingType::FixedAssetsDebit;
        }

        if (projId)
        {
            return LedgerPostingType::ProjCost;
        }

        if (this.transQty() >= 0)
        {
            return LedgerPostingType::InventProfit;
        }
        return LedgerPostingType::InventLoss;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the physical ledger posting type
    /// </summary>
    /// <returns>
    ///    The physical ledger posting type
    /// </returns>
    public LedgerPostingType postingPhysical()
    {
        if (mustBeBookedPhysically)
        {
            return postingPhysical;
        }
        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>projCategoryId</Name>
				<Source><![CDATA[
    public ProjCategoryId projCategoryId()
    {
        return projCategoryId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projId</Name>
				<Source><![CDATA[
    public ProjId projId()
    {
        return projId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projLedgerOrigin</Name>
				<Source><![CDATA[
    public ProjLedgerOrigin projLedgerOrigin()
    {
        return projLedgerOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTransactionOrigin</Name>
				<Source><![CDATA[
    public ProjTransactionOrigin projTransactionOrigin()
    {
        return projTransactionOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainPhysical</Name>
				<Source><![CDATA[
    public InventQty   remainPhysical()
    {
        return remainPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>returnInventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Identifies the original transactions.
    /// </summary>
    /// <returns>
    ///    The ID of the original transaction originator if any; otherwise, zero.
    /// </returns>
    public InventTransOriginId returnInventTransOrigin()
    {
        if (this.projId() &&
            inventMovReference &&
            inventMovReference is InventMov_Purch)
        {
            if (inventMovReference.buffer().TableId == tableNum(PurchLine))
            {
                PurchLine purchLine = inventMovReference.buffer();
                if (purchLine.InventRefTransId)
                {
                    return InventTransOrigin::findMarkingRefInventTransOrigin(
                            InventTransOrigin::findByInventTransId(purchLine.InventRefTransId).RecId,
                            purchLine.ItemId,
                            true,
                            true);
                }
            }
        }

        return returnInventTransOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAutoLossProfitProjectInformation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets several parameters to the specified project relations.
    /// </summary>
    /// <param name="_projAdjustRefId">
    ///    The new value for the <c>projAdjustRefId</c> field.
    /// </param>
    /// <param name="_projId">
    ///    The new value for the <c>projId</c> field.
    /// </param>
    /// <param name="_projCategoryId">
    ///    The new value for the <c>projCategoryId</c> field.
    /// </param>
    public void setAutoLossProfitProjectInformation(
        ProjAdjustRefId     _projAdjustRefId,
        ProjId              _projId,
        ProjCategoryId      _projCategoryId)
    {
        this.parmProjAdjustRefId(_projAdjustRefId);
        this.parmProjId(_projId);
        this.parmProjCategoryId(_projCategoryId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventDimId</Name>
				<Source><![CDATA[
    public void setInventDimId(InventDimId _dimId)
    {
        inventDimId = _dimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventTransMovementData</Name>
				<Source><![CDATA[
    protected InventTrans setInventTransMovementData(InventTrans _inventMovTrans = inventMovTrans)
    {
        inventMovTrans = _inventMovTrans;

        if (inventMovTrans)
        {
            InventTransOrigin inventTransOrigin = inventMovTrans.inventTransOrigin();
            inventTransId = inventTransOrigin.InventTransId;
            markingRefInventTransOrigin = inventMovTrans.MarkingRefInventTransOrigin;
            itemId = inventTransOrigin.ItemId;
            inventDimId = inventMovTrans.InventDimId;
            projId = inventMovTrans.ProjId;
        }
        return inventMovTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setMarkingInventDimParmFixed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the <c>InventDimParm</c> for fixed marking dimensions.
    /// </summary>
    /// <param name="_markingInventDimParmFixed">
    /// <c>InventDimParm</c> to be used for fixed marking dimensions.
    /// </param>
    public void setMarkingInventDimParmFixed(InventDimParm _markingInventDimParmFixed)
    {
        markingInventDimParmFixed = _markingInventDimParmFixed;
        markingInventDimParmFixedCached = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setProjAdjustRefId</Name>
				<Source><![CDATA[
    public void setProjAdjustRefId(InventTrans _inventTrans)
    {
        if (_inventTrans.ProjAdjustRefId)
        {
            projAdjustRefId = _inventTrans.ProjAdjustRefId;
            return;
        }

        if (!projId)
        {
            return;
        }

        if (!projAdjustRefId)
        {
            projAdjustRefId = NumberSeq::newGetNum(CompanyInfo::numRefParmId()).num();
        }
        _inventTrans.ProjAdjustRefId = projAdjustRefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRemainPhysical</Name>
				<Source><![CDATA[
    public void setRemainPhysical(InventQty  _inventQty)
    {
        remainPhysical = _inventQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransQty</Name>
				<Source><![CDATA[
    public void setTransQty(InventQty  _qtyInvent)
    {
        transQty = _qtyInvent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transDate</Name>
				<Source><![CDATA[
    public TransDate transDate()
    {
        return transDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transId</Name>
				<Source><![CDATA[
    public InventTransId transId()
    {
        return inventTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transQty</Name>
				<Source><![CDATA[
    public InventQty  transQty()
    {
        return transQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transRefId</Name>
				<Source><![CDATA[
    public InventTransRefId transRefId()
    {
        return transRefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transSchedTime</Name>
				<Source><![CDATA[
    public SchedTime transSchedTime()
    {
        return transSchedTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transSign</Name>
				<Source><![CDATA[
    public Integer transSign()
    {
        if (this.projId() &&
            inventMovReference &&
            inventMovReference is InventMov_Purch)
        {
            if (inventMovReference.buffer().TableId == tableNum(PurchLine))
            {
                PurchLine purchLine = inventMovReference.buffer();
                if (purchLine.InventRefTransId)
                {
                    return -1;
                }
            }
        }

        if (this.transQty() >= 0)
        {
            return  1;
        }
        return -1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transType</Name>
				<Source><![CDATA[
    public InventTransType transType()
    {
        return transType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBuffer</Name>
				<Source><![CDATA[
    public void updateBuffer(boolean _updateReservation = true)
    {
        InventTransOriginId     temp_InventTransOriginId;
        PdsCWInventQty          cwPreEstimated;
        PdsCWInventQty          cwTransEstimated;

        InventQty preEstimated = InventTrans::qtyTotalOrderPick(this.inventTransOriginId());
        InventQty transEstimated = this.remainPhysical();

        if (this.pdsCWItem())
        {
            cwPreEstimated = InventTrans::pdsCWQtyTotalOrderPick(this.inventTransOriginId());
            cwTransEstimated = this.pdsCWRemainPhysical();
        }

        this.parmInventMovReference(InventTrans::findByInventTransOrigin(this.markingRefInventTransOrigin()).inventMovement(true));
        if (this.parmInventMovReference() && this.parmInventMovReference().parmInventTransOriginIdRef_virtuel())
        {
            temp_InventTransOriginId = this.parmInventMovReference().parmInventTransOriginIdRef_virtuel();
        }
        else
        {
            temp_InventTransOriginId = InventTransOrigin::findMarkingRefInventTransOrigin(this.inventTransOriginId(),this.itemId(),false,false);
        }
        if (!temp_InventTransOriginId)
        {
            temp_InventTransOriginId = this.markingRefInventTransOrigin();
        }
        this.parmMarkingRefInventTransOrigin(temp_InventTransOriginId);
        this.parmInventMovVirtuelOrig(this);

        InventUpd_Estimated estimated = InventUpd_Estimated::newInventMovement(this);

        estimated.parmPreEstimated(preEstimated);
        estimated.parmTransEstimated(transEstimated);
        estimated.parmEstimated(transEstimated-preEstimated);

        estimated.parmCWPreEstimated(cwPreEstimated);
        estimated.parmCWTransEstimated(cwTransEstimated);
        estimated.parmPdsCWEstimated(cwTransEstimated-cwPreEstimated);

        estimated.updateNow();

        if (estimated && _updateReservation)
        {
            estimated.updateReservation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDoBuffer</Name>
				<Source><![CDATA[
    public void updateDoBuffer()
    {
        return;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useEnteredPriceAsCost</Name>
				<Source><![CDATA[
    public boolean useEnteredPriceAsCost()
    {
        return userEnteredPriceAsCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static InventMov_Virtuel construct()
    {
        InventMov_Virtuel   movement_Virtuel = new InventMov_Virtuel(null);

        return movement_Virtuel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newAutoLossAsset</Name>
				<Source><![CDATA[
    public static InventMovement newAutoLossAsset(
        InventUpd_Financial     _financial,
        InventTrans             _inventTrans,
        InventTransOriginId     _inventTransOriginId = 0,
        InventDimId             _inventDimId = _inventTrans.InventDimId
        )
    {
        InventMovement      movementFinancial   = _financial.movement();

        // asset information for the current inventory transaction
        AssetId     assetId     = movementFinancial.assetId();
        AssetBookId assetBookId = movementFinancial.assetBookId();
        AssetTable  assetTable  = AssetTable::find(assetId);
        AssetBook   assetBook   = AssetBook::find(assetId, assetBookId);

        InventMov_Virtuel movement_Virtuel = InventMov_Virtuel::construct();

        PurchLine purchLine = InventTransOriginPurchLine::purchLine(_inventTrans.InventTransOrigin);
        AssetTransType transType = AssetPost::assetTransTypePurch2AssetTransType(purchLine.AssetTransTypePurch);

        movement_Virtuel.parmAccountOperations(assetTable.assetLedgerDimension(assetBook.PostingProfile,
                                                                                    transType,assetBook.BookId));
        movement_Virtuel.parmTransQty(-_inventTrans.Qty);
        movement_Virtuel.pdsCWSetTransQty(-_inventTrans.PdsCWQty);
        movement_Virtuel.parmTransDate(_inventTrans.DateFinancial);
        movement_Virtuel.parmItemId(movementFinancial.itemId());
        movement_Virtuel.parmInventDimId(_inventDimId);
        movement_Virtuel.parmTransType(InventTransType::Asset);
        movement_Virtuel.parmAssetId(purchLine.AssetId);
        movement_Virtuel.parmMarkingRefInventTransOrigin(_inventTrans.InventTransOrigin);
        movement_Virtuel.parmDefaultDimension(movementFinancial.defaultDimension());
        movement_Virtuel.parmTransRefId(assetId);
        movement_Virtuel.parmAccountBalanceSheet(movementFinancial.accountBalanceAutoLossProfit(-_inventTrans.Qty));
        movement_Virtuel.parmRelatedVoucher(_inventTrans.Voucher);

        // create new value
        if (!_inventTransOriginId)
        {
            movement_Virtuel.parmInventTransId(NumberSeq::newGetNum(InventParameters::numRefInventTransId()).num());
        }
        else
        {
            movement_Virtuel.parmInventTransId(InventTransOrigin::find(_inventTransOriginId).InventTransId);
        }

        return movement_Virtuel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRelatedVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get or set the transaction voucher
    /// </summary>
    /// <param name="_relatedVoucher">
    /// A <c>Voucher</c> object
    /// </param>
    /// <returns>
    /// The transaction voucher
    /// </returns>
    protected Voucher parmRelatedVoucher(Voucher _relatedVoucher = relatedVoucher)
    {
        relatedVoucher = _relatedVoucher;
        return relatedVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>relatedVoucher</Name>
				<Source><![CDATA[
    public Voucher relatedVoucher()
    {
        return relatedVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newAutoLossProfit</Name>
				<Source><![CDATA[
    public static InventMovement newAutoLossProfit(
        InventUpd_Financial     _financial,
        InventTrans             _inventTrans,
        InventTransId           _inventTransId = NumberSeq::newGetNum(InventParameters::numRefInventTransId()).num())
    {
        InventMov_Virtuel   movement_Virtuel = InventMov_Virtuel::construct();

        movement_Virtuel.parmTransQty(-_inventTrans.Qty);
        movement_Virtuel.pdsCWSetTransQty(-_inventTrans.PdsCWQty);
        movement_Virtuel.parmTransDate(_inventTrans.DateFinancial);
        movement_Virtuel.parmInventTransId(_inventTransId);
        movement_Virtuel.parmMarkingRefInventTransOrigin(_inventTrans.InventTransOrigin);
        movement_Virtuel.parmItemId(_financial.movement().itemId());
        movement_Virtuel.parmInventDimId(_inventTrans.InventDimId);
        movement_Virtuel.parmTransType(InventTransType::InventTransaction);
        movement_Virtuel.parmProjId(_inventTrans.ProjId);
        movement_Virtuel.parmProjCategoryId(_inventTrans.ProjCategoryId);
        movement_Virtuel.parmActivityNumber(_inventTrans.ActivityNumber);
        movement_Virtuel.parmDefaultDimension(_financial.movement().defaultDimension());
        movement_Virtuel.parmAccountBalanceSheet(_financial.movement().accountBalanceAutoLossProfit(-_inventTrans.Qty));
        movement_Virtuel.parmAccountOperations(_financial.movement().accountOperationsAutoLossProfit(-_inventTrans.Qty));
        movement_Virtuel.parmMustBeQuarantineControlled(movement_Virtuel.inventModelGroup().QuarantineControl);

        if (_financial.movement().mustSetProjAdjRefInventTrans())
        {
            movement_Virtuel.parmMustSetProjAdjRefInventTrans(movement_Virtuel.parmTransQty() > 0);
        }

        movement_Virtuel.parmProjTransactionOrigin(_financial.movement().projTransactionOrigin());
        movement_Virtuel.parmProjLedgerOrigin(_financial.movement().projLedgerOrigin());

        return movement_Virtuel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newAutoLossProfit_Estimate</Name>
				<Source><![CDATA[
    public static InventMovement newAutoLossProfit_Estimate(
        InventUpd_Estimated         _estimate,
        InventMovement              _movement,
        InventTransId               _inventTransId = NumberSeq::newGetNum(InventParameters::numRefInventTransId()).num())
    {
        InventMov_Virtuel   movement_Virtuel = InventMov_Virtuel::construct();

        if (_estimate)
        {
            movement_Virtuel.parmTransQty(-_estimate.updEstimated());
            movement_Virtuel.pdsCWSetTransQty(-_estimate.cwUpdEstimated());
            movement_Virtuel.parmDefaultDimension(_estimate.movement().defaultDimension());
        }

        if (_movement)
        {
            movement_Virtuel.parmInventMovReference(_movement);
            movement_Virtuel.parmProjId(_movement.projId());
            movement_Virtuel.parmProjCategoryId(_movement.projCategoryId());
            movement_Virtuel.parmMarkingRefInventTransOrigin(_movement.inventTransOriginId());
            movement_Virtuel.parmActivityNumber(_movement.activityNumber());
            movement_Virtuel.parmTransDate(_movement.transDate());
            movement_Virtuel.parmInventTransId(_inventTransId);
            movement_Virtuel.parmItemId(_movement.itemId());
            movement_Virtuel.parmInventDimId(_movement.inventDimId());
            movement_Virtuel.parmShippingDateRequested(_movement.shippingDateRequested());
            movement_Virtuel.parmTransSchedTime(_movement.transSchedTime());
            movement_Virtuel.parmReturnInventTransOrigin(_movement.returnInventTransOrigin());
            movement_Virtuel.parmAssetId(_movement.assetId());
            movement_Virtuel.parmMustBeQuotationControlled(_movement.mustBeQuotationControlled());
        }
        movement_Virtuel.parmTransType(InventTransType::InventTransaction);
        return movement_Virtuel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newAutoLossProfit_Physical</Name>
				<Source><![CDATA[
    public static InventMovement newAutoLossProfit_Physical(
        InventUpd_Physical          _physical,
        InventMovement              _movement,
        InventTransId               _inventTransId = NumberSeq::newGetNum(InventParameters::numRefInventTransId()).num())
    {
        InventMov_Virtuel movement_Virtuel = InventMov_Virtuel::construct();

        movement_Virtuel.parmInventMovReference(_movement);

        if (_physical)
        {
            movement_Virtuel.parmTransQty(-_physical.updPhysical());
            movement_Virtuel.pdsCWSetTransQty(-_physical.pdsCWUpdPhysical());
            movement_Virtuel.parmDefaultDimension(_physical.movement().defaultDimension());
        }
        if (_movement)
        {
            movement_Virtuel.parmTransDate(_movement.transDate());
            movement_Virtuel.parmProjId(_movement.projId());
            movement_Virtuel.parmProjCategoryId(_movement.projCategoryId());
            movement_Virtuel.parmActivityNumber(_movement.activityNumber());
            movement_Virtuel.parmItemId(_movement.itemId());
            movement_Virtuel.parmInventDimId(_movement.inventDimId());
            movement_Virtuel.parmUseEnteredPriceAsCost(_movement.useEnteredPriceAsCost());
            movement_Virtuel.parmMustBeQuarantineControlled(movement_Virtuel.inventModelGroup().QuarantineControl);
            movement_Virtuel.parmMarkingRefInventTransOrigin(_movement.inventTransOriginId());
            movement_Virtuel.parmDefaultDimension(_movement.defaultDimension());
            movement_Virtuel.parmAccountBalanceSheet(_movement.accountBalanceSheet());
            movement_Virtuel.parmAccountOperations(_movement.accountOperations());
        }

        movement_Virtuel.parmInventTransId(_inventTransId);
        movement_Virtuel.parmTransType(InventTransType::InventTransaction);

        return movement_Virtuel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventTrans</Name>
				<Source><![CDATA[
    public static InventMovement newInventTrans(Common _common)
    {
        InventMov_Virtuel   movement_Virtuel = InventMov_Virtuel::construct();

        if (_common is InventTrans)
        {
            InventTrans inventTransCommon = _common as InventTrans;
            movement_Virtuel.setInventTransMovementData(inventTransCommon);
        }
        return movement_Virtuel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newItemReqUnderconsume</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new <c>InventMov_Virtuel</c> instance that will be used for underconsumptions.
    /// </summary>
    /// <param name="_salesLine">
    ///    Item requirement with underconsumption.
    /// </param>
    /// <param name="_prodInventTransOriginId">
    ///    The ID of the inventory transactions for the production order of the item requirement.
    /// </param>
    /// <param name="_transDate">
    ///    The transaction date of the inventory movement.
    /// </param>
    /// <param name="_qtyUnderconsumed">
    ///    The quantity of the inventory movement.
    /// </param>
    /// <returns>
    ///    A new <c>InventMov_Virtuel</c> instance.
    /// </returns>
    /// <remarks>
    ///    Creates a new <c>InventMov_Virtuel</c> instance that will be used for underconsumptions when an
    ///    item requirement is invoiced.
    ///    The virtual inventory movement will be used to consume the
    ///    production order items that were underconsumed by the item requirement.
    /// </remarks>
    public static InventMovement newItemReqUnderconsume(
        SalesLine               _salesLine,
        InventTransOriginId     _prodInventTransOriginId,
        TransDate               _transDate,
        InventQty               _qtyUnderconsumed)
    {
        InventMov_Virtuel   movement_Virtuel    = InventMov_Virtuel::construct();

        movement_Virtuel.parmTransQty(_qtyUnderconsumed);
        movement_Virtuel.parmTransDate(_transDate);
        movement_Virtuel.parmInventTransId(NumberSeq::newGetNum(InventParameters::numRefInventTransId()).num());
        movement_Virtuel.parmMarkingRefInventTransOrigin(_prodInventTransOriginId);
        movement_Virtuel.parmItemId(_salesLine.ItemId);
        movement_Virtuel.parmInventDimId(_salesLine.InventDimId);
        movement_Virtuel.parmTransType(InventTransType::Project);
        movement_Virtuel.parmTransRefId(_salesLine.SalesId);
        movement_Virtuel.parmDefaultDimension(_salesLine.DefaultDimension);
        InventMovement movement_salesLine = InventMovement::construct(_salesLine);
        movement_Virtuel.parmProjId(_salesLine.ProjId);
        movement_Virtuel.parmProjCategoryId(_salesLine.ProjCategoryId);
        movement_Virtuel.parmActivityNumber(_salesLine.ActivityNumber);
        movement_Virtuel.parmCanCommittedCostBeReversed(false);
        movement_Virtuel.parmAccountBalanceSheet(movement_salesLine.accountBalanceSheet());
        movement_Virtuel.parmPostingBalanceSheet(movement_salesLine.postingBalanceSheet());
        movement_Virtuel.parmAccountOperations(movement_salesLine.accountBalanceSheet());
        movement_Virtuel.parmPostingOperations(movement_salesLine.postingBalanceSheet());
        movement_Virtuel.parmMustBeQuarantineControlled(NoYes::No);
        movement_Virtuel.parmProjTransactionOrigin(ProjOrigin::ItemRequirement);
        movement_Virtuel.parmProjLedgerOrigin(ProjOrigin::ItemRequirement);

        return movement_Virtuel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newItemReqUnderconsumeProjIncome</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new instance of the <c>InventMov_Virtuel</c> class that will be used.
    /// </summary>
    /// <param name="_salesLine">
    ///    An item requirement.
    /// </param>
    /// <param name="_returnInventTransOrigin">
    ///    The return origin ID.
    /// </param>
    /// <param name="_transDate">
    ///    The transaction date of the inventory movement.
    /// </param>
    /// <param name="_qtyUnderconsumed">
    ///    The quantity of the inventory movement.
    /// </param>
    /// <returns>
    ///    A new instance of the <c>InventMov_Virtuel</c> class.
    /// </returns>
    /// <remarks>
    ///    Creates a new instance of the <c>InventMov_Virtuel</c> class that will be used when it invoices an
    ///    item requirement.The virtual inventory movement is used to post an income to a project.
    /// </remarks>
    public static InventMovement newItemReqUnderconsumeProjIncome(
        SalesLine           _salesLine,
        InventTransOriginId _returnInventTransOrigin,
        TransDate           _transDate,
        InventQty           _qtyUnderconsumed)
    {
        InventMov_Virtuel   movement_Virtuel = InventMov_Virtuel::construct();

        movement_Virtuel.parmTransQty(_qtyUnderconsumed);
        movement_Virtuel.parmTransDate(_transDate);
        movement_Virtuel.parmInventTransId(NumberSeq::newGetNum(InventParameters::numRefInventTransId()).num());
        movement_Virtuel.parmMarkingRefInventTransOrigin(0);
        movement_Virtuel.parmItemId(_salesLine.ItemId);
        movement_Virtuel.parmInventDimId(_salesLine.InventDimId);
        movement_Virtuel.parmTransType(InventTransType::Project);
        movement_Virtuel.parmTransRefId(_salesLine.SalesId);
        movement_Virtuel.parmDefaultDimension(_salesLine.DefaultDimension);

        InventMovement movement_salesLine = InventMovement::construct(_salesLine);
        movement_Virtuel.parmProjId(_salesLine.ProjId);
        movement_Virtuel.parmProjCategoryId(_salesLine.ProjCategoryId);
        movement_Virtuel.parmActivityNumber(_salesLine.ActivityNumber);
        movement_Virtuel.parmMustSetProjAdjRefInventTrans(true);
        movement_Virtuel.parmCanCommittedCostBeReversed(false);

        movement_Virtuel.parmAccountBalanceSheet(movement_salesLine.accountBalanceSheet());
        movement_Virtuel.parmPostingBalanceSheet(movement_salesLine.postingBalanceSheet());
        movement_Virtuel.parmAccountOperations(ProjPosting::getInventLedgerDimension(ProjAccountType::CostAccount,
                                                                        _salesLine.ProjId, _salesLine.ProjCategoryId));
        movement_Virtuel.parmPostingOperations(LedgerPostingType::ProjCost);
        movement_Virtuel.parmMustBeQuarantineControlled(NoYes::No);
        movement_Virtuel.parmProjTransactionOrigin(ProjOrigin::ProductionConsumed);
        movement_Virtuel.parmProjLedgerOrigin(ProjOrigin::ProductionConsumed);
        movement_Virtuel.parmReturnInventTransOrigin(_returnInventTransOrigin);

        return movement_Virtuel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProdAutoLossProfitPhysical</Name>
				<Source><![CDATA[
    public static InventMovement newProdAutoLossProfitPhysical(
        InventQty           _inventQty,
        InventMovement      _movement,
        InventTransId       _inventTransId)
    {
        InventMov_Virtuel   movement_Virtuel = InventMov_Virtuel::construct();

        movement_Virtuel.parmInventMovReference(_movement);
        movement_Virtuel.parmTransQty(_inventQty);
        movement_Virtuel.parmDefaultDimension(_movement.defaultDimension());
        movement_Virtuel.parmTransDate(_movement.transDate());
        movement_Virtuel.parmProjId(_movement.projId());
        movement_Virtuel.parmProjCategoryId(_movement.projCategoryId());
        movement_Virtuel.parmActivityNumber(_movement.activityNumber());
        movement_Virtuel.parmItemId(_movement.itemId());
        movement_Virtuel.parmInventDimId(_movement.inventDimId());
        movement_Virtuel.parmUseEnteredPriceAsCost(_movement.useEnteredPriceAsCost());
        movement_Virtuel.parmMustBeQuarantineControlled(movement_Virtuel.inventModelGroup().QuarantineControl);
        movement_Virtuel.parmInventTransId(_inventTransId);
        movement_Virtuel.parmTransType(InventTransType::InventTransaction);
        movement_Virtuel.parmAccountBalanceSheet(_movement.accountBalanceSheet());
        movement_Virtuel.parmAccountOperations(_movement.accountOperations());

        return movement_Virtuel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProdTableScrap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>InventMov_Virtuel</c> class instance that will be used for scrapping the production output.
    /// </summary>
    /// <param name="_prodTable">
    /// The <c>ProdTable</c> record.
    /// </param>
    /// <param name="_qtyError">
    /// The error quantity.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date.
    /// </param>
    /// <param name="_scrapInventDimId">
    /// The transaction inventory dimensions ID.
    /// </param>
    /// <returns>
    /// The <c>InventMovement</c> class instance.
    /// </returns>
    public static InventMovement newProdTableScrap(
        ProdTable       _prodTable,
        InventQty       _qtyError,
        TransDate       _transDate,
        InventDimId     _scrapInventDimId = '')
    {
        return InventMov_Virtuel::newProdTableItemScrap(_prodTable,
                                                        _prodTable.ItemId,
                                                        _scrapInventDimId ? _scrapInventDimId : _prodTable.InventDimId,
                                                        _qtyError,
                                                        _transDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProdUnderconsume</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new instance of the <c>InventMov_Virtuel</c> class that will be used for
    ///    underconsumptions.
    /// </summary>
    /// <param name="_prodBOM">
    ///    The BOM line with underconsumption.
    /// </param>
    /// <param name="_transDate">
    ///    The transaction date of the inventory movement.
    /// </param>
    /// <param name="_qtyUnderconsumed">
    ///    The quantity of the inventory movement.
    /// </param>
    /// <returns>
    ///    A new instance of the <c>InventMov_Virtuel</c> class.
    /// </returns>
    /// <remarks>
    ///    This method creates a new <c>InventMov_Virtuel</c> instance that will be used for underconsumptions
    ///    when it ends a production order.The virtual inventory movement will be used to consume the
    ///    subproduction items that were underconsumed by the parent production order.
    /// </remarks>
    public static InventMovement newProdUnderconsume(
        ProdBOM     _prodBOM,
        TransDate   _transDate,
        InventQty   _qtyUnderconsumed)
    {
        InventMov_Virtuel   movement_Virtuel = InventMov_Virtuel::construct();

        movement_Virtuel.parmTransQty(_qtyUnderconsumed);
        movement_Virtuel.parmTransDate(_transDate);
        movement_Virtuel.parmInventTransId(_prodBOM.InventTransId);
        movement_Virtuel.parmMarkingRefInventTransOrigin(InventTransOrigin::findByInventTransId(_prodBOM.InventRefTransId).RecId);
        movement_Virtuel.parmItemId(_prodBOM.ItemId);
        movement_Virtuel.parmInventDimId(_prodBOM.InventDimId);
        movement_Virtuel.parmTransType(InventTransType::ProdLine);
        movement_Virtuel.parmTransRefId(_prodBOM.ProdId);
        movement_Virtuel.parmDefaultDimension(_prodBOM.DefaultDimension);

        InventMovement movement_prodBOM = InventMovement::construct(_prodBOM);
        movement_Virtuel.parmProjId(_prodBOM.ProjId);
        movement_Virtuel.parmProjCategoryId(_prodBOM.ProjCategoryId);
        movement_Virtuel.parmActivityNumber(_prodBOM.ActivityNumber);
        movement_Virtuel.parmCanCommittedCostBeReversed(false);
        movement_Virtuel.parmAccountBalanceSheet(movement_prodBOM.accountBalanceSheet());
        movement_Virtuel.parmPostingBalanceSheet(movement_prodBOM.postingBalanceSheet());
        movement_Virtuel.parmAccountOperations(movement_prodBOM.accountBalanceSheet());
        movement_Virtuel.parmPostingOperations(movement_prodBOM.postingBalanceSheet());
        movement_Virtuel.parmMustBeQuarantineControlled(NoYes::No);
        movement_Virtuel.parmProjTransactionOrigin(ProjOrigin::ProductionConsumed);
        movement_Virtuel.parmProjLedgerOrigin(ProjOrigin::ProductionConsumed);

        return movement_Virtuel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProdUnderconsumeProjIncome</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new <c>InventMov_Virtuel</c> instance that will be used for underconsumptions.
    /// </summary>
    /// <param name="_prodBOM">
    ///    The BOM line that will be used to post an income to project.
    /// </param>
    /// <param name="_prodBOMReturn">
    ///    The BOM line with underconsumption.
    /// </param>
    /// <param name="_transDate">
    ///    The transaction date of the inventory movement.
    /// </param>
    /// <param name="_qtyUnderconsumed">
    ///    The quantity of the inventory movement.
    /// </param>
    /// <returns>
    ///    A new <c>InventMov_Virtuel</c> instance.
    /// </returns>
    /// <remarks>
    ///    This method creates a new <c>InventMov_Virtuel</c> instance that will be used for underconsumptions
    ///    when it ends a production order.The virtual inventory movement will be used to post an income to
    ///    project for underconsumptions.
    /// </remarks>
    public static InventMovement newProdUnderconsumeProjIncome(
        ProdBOM     _prodBOM,
        ProdBOM     _prodBOMReturn,
        TransDate   _transDate,
        InventQty   _qtyUnderconsumed)
    {
        InventMov_Virtuel   movement_Virtuel = InventMov_Virtuel::construct();

        movement_Virtuel.parmTransQty(_qtyUnderconsumed);
        movement_Virtuel.parmTransDate(_transDate);
        movement_Virtuel.parmInventTransId(_prodBOM.InventTransId);
        movement_Virtuel.parmMarkingRefInventTransOrigin(InventTransOrigin::findByInventTransId(_prodBOM.InventRefTransId).RecId);
        movement_Virtuel.parmItemId(_prodBOM.ItemId);
        movement_Virtuel.parmInventDimId(_prodBOM.InventDimId);
        movement_Virtuel.parmTransType(InventTransType::ProdLine);
        movement_Virtuel.parmTransRefId(_prodBOM.ProdId);
        movement_Virtuel.parmDefaultDimension(_prodBOM.DefaultDimension);

        InventMovement movement_prodBOM = InventMovement::construct(_prodBOM);

        movement_Virtuel.parmProjId(_prodBOM.ProjId);
        movement_Virtuel.parmProjCategoryId(_prodBOM.ProjCategoryId);
        movement_Virtuel.parmActivityNumber(_prodBOM.ActivityNumber);
        movement_Virtuel.parmMustSetProjAdjRefInventTrans(true);
        movement_Virtuel.parmCanCommittedCostBeReversed(false);
        movement_Virtuel.parmAccountBalanceSheet(movement_prodBOM.accountBalanceSheet());
        movement_Virtuel.parmPostingBalanceSheet(movement_prodBOM.postingBalanceSheet());
        movement_Virtuel.parmAccountOperations(ProjPosting::getInventLedgerDimension(ProjAccountType::CostAccount,
                                                                        _prodBOM.ProjId, _prodBOM.ProjCategoryId));
        movement_Virtuel.parmPostingOperations(LedgerPostingType::ProjCost);
        movement_Virtuel.parmMustBeQuarantineControlled(NoYes::No);
        movement_Virtuel.parmProjTransactionOrigin(ProjOrigin::ProductionConsumed);
        movement_Virtuel.parmProjLedgerOrigin(ProjOrigin::ProductionConsumed);
        movement_Virtuel.parmReturnInventTransOrigin(InventTransOriginProdBOM::findInventTransOriginId(_prodBOMReturn.DataAreaId, _prodBOMReturn.InventTransId));

        return movement_Virtuel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjProductionSplit</Name>
				<Source><![CDATA[
    public static InventMovement newProjProductionSplit(
        InventMovement      _movement,
        InventQty           _transQty)
    {
        InventMov_Virtuel       movement_Virtuel    = InventMov_Virtuel::construct();
        InventTransOriginId     markedOriginId      = InventTrans::findByInventTransOrigin(_movement.inventTransOriginId()).MarkingRefInventTransOrigin;

        movement_Virtuel.parmProjId(_movement.projId());
        movement_Virtuel.parmProjCategoryId(_movement.projCategoryId());
        movement_Virtuel.parmMarkingRefInventTransOrigin(_movement.inventTransOriginId());
        movement_Virtuel.parmTransQty(_transQty);
        movement_Virtuel.parmTransDate(_movement.transDate());
        movement_Virtuel.parmInventTransId(InventTransOrigin::find(markedOriginId).InventTransId);
        movement_Virtuel.parmItemId(_movement.itemId());
        movement_Virtuel.parmInventDimId(_movement.inventDimId());
        movement_Virtuel.parmTransType(InventTransType::InventTransaction);
        movement_Virtuel.parmDefaultDimension(_movement.defaultDimension());
        movement_Virtuel.parmShippingDateRequested(_movement.shippingDateRequested());
        movement_Virtuel.parmTransSchedTime(_movement.transSchedTime());
        movement_Virtuel.parmReturnInventTransOrigin(_movement.returnInventTransOrigin());
        movement_Virtuel.parmAssetId(_movement.assetId());
        movement_Virtuel.addRemainPhysical(_transQty);
        movement_Virtuel.addRemainPhysicalUnit(movement_Virtuel.calcEstimatedUnit(_transQty));
        return movement_Virtuel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newReqTransOnHand</Name>
				<Source><![CDATA[
    public static InventMovement newReqTransOnHand(ReqTrans _reqTrans)
    {
        InventMov_Virtuel   movement_Virtuel = InventMov_Virtuel::construct();

        movement_Virtuel.parmItemId(_reqTrans.ItemId);
        movement_Virtuel.parmInventDimId(_reqTrans.inventDim().InventDimId);

        return movement_Virtuel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPmfCoByProdTableScrap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>InventMov_Virtuel</c> class instance that will be used for scrapping the production co-product.
    /// </summary>
    /// <param name="_prodTable">
    /// The <c>ProdTable</c> record.
    /// </param>
    /// <param name="_pmfProdCoBy">
    /// The <c>PmfProdCoBy</c> record.
    /// </param>
    /// <param name="_qtyError">
    /// The error quantity.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date.
    /// </param>
    /// <returns>
    /// The <c>InventMovement</c> class instance.
    /// </returns>
    public static InventMovement newPmfCoByProdTableScrap(
        ProdTable       _prodTable,
        PmfProdCoBy     _pmfProdCoBy,
        InventQty       _qtyError,
        TransDate       _transDate)
    {
        return InventMov_Virtuel::newProdTableItemScrap(_prodTable,
                                                        _pmfProdCoBy.ItemId,
                                                        _pmfProdCoBy.InventDimId,
                                                        _qtyError,
                                                        _transDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProdTableItemScrap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>InventMov_Virtuel</c> class instance that will be used for scrapping the production output.
    /// </summary>
    /// <param name="_prodTable">
    /// The <c>ProdTable</c> record.
    /// </param>
    /// <param name="_itemId">
    /// The id of the item to be scrapped.
    /// </param>
    /// <param name="_inventDimId">
    /// The inventory dimension of the item to be scrapped.
    /// </param>
    /// <param name="_qtyError">
    /// The error quantity.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date.
    /// </param>
    /// <returns>
    /// The <c>InventMovement</c> class instance.
    /// </returns>
    public static InventMovement newProdTableItemScrap(
        ProdTable       _prodTable,
        ItemId          _itemId,
        InventDimId     _inventDimId,
        InventQty       _qtyError,
        TransDate       _transDate)
    {
        InventMovement      movement_prodTable;
        InventMov_Virtuel   movement_Virtuel = InventMov_Virtuel::construct();

        movement_Virtuel.parmTransQty(_qtyError);
        movement_Virtuel.parmTransDate(_transDate);
        movement_Virtuel.parmInventTransId(NumberSeq::newGetNum(InventParameters::numRefInventTransId()).num());
        movement_Virtuel.parmMarkingRefInventTransOrigin(movement_Virtuel.inventTransOriginId());
        movement_Virtuel.parmItemId(_itemId);
        movement_Virtuel.parmInventDimId(_inventDimId);
        movement_Virtuel.parmTransType(InventTransType::Production);
        movement_Virtuel.parmTransRefId(_prodTable.ProdId);
        movement_Virtuel.parmDefaultDimension(_prodTable.DefaultDimension);

        if (_qtyError > 0 && _prodTable.isProjMethodConsumed())
        {
            movement_prodTable = _prodTable.inventMovementProj(_prodTable.prodTableProj(ProjItemTypeProdTable::ErrorQuantity));
        }
        else
        {
            movement_prodTable = InventMovement::construct(_prodTable);
        }

        if (_qtyError > 0 && _prodTable.isProjMethodConsumed())
        {
            movement_Virtuel.parmProjId(movement_prodTable.projId());
            movement_Virtuel.parmProjCategoryId(movement_prodTable.projCategoryId());
            movement_Virtuel.parmActivityNumber(movement_prodTable.activityNumber());
            movement_Virtuel.parmMustSetProjAdjRefInventTransTmp(movement_prodTable.mustSetProjAdjRefInventTrans());
            movement_Virtuel.parmMustSetProjAdjRefInventTrans(movement_prodTable.mustSetProjAdjustRefInventTrans());
            movement_Virtuel.parmInventMovReference(movement_prodTable);
        }

        movement_Virtuel.parmAccountBalanceSheet(movement_prodTable.accountBalanceSheet());
        movement_Virtuel.parmPostingBalanceSheet(movement_prodTable.postingBalanceSheet());
        movement_Virtuel.parmAccountOperations(movement_prodTable.accountOperations());
        movement_Virtuel.parmPostingOperations(movement_prodTable.postingOperations());
        movement_Virtuel.parmMustBeQuarantineControlled(NoYes::No);
        movement_Virtuel.parmProjTransactionOrigin(movement_prodTable.projTransactionOrigin());
        movement_Virtuel.parmProjLedgerOrigin(movement_prodTable.projLedgerOrigin());

        return movement_Virtuel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDoAutoLossProfitPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Decides whether to do auto loss profit physical.
    /// </summary>
    /// <returns>true if auto loss profit physical must be performed; otherwise, false.</returns>
    public boolean mustDoAutoLossProfitPhysical()
    {
        if (this.parmProjectReturnReceipt())
        {
            return false;
        }
        
        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDoAutoLossProfitEstimate</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Decides whether to do auto loss profit estimate.
    /// </summary>
    /// <returns>true if auto loss profit estimate must be performed; otherwise, false.</returns>
    public boolean mustDoAutoLossProfitEstimate()
    {
        if (this.parmProjectReturnReceipt())
        {
            return true;
        }
    
        return super();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>