<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerEliminationProcessRule</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>LedgerEliminationProcessRule</c> class defines the class variables.
/// </summary>
public class LedgerEliminationProcessRule
{
    TransDate       glPostingDate;
    TransDate       periodFromDate;
    TransDate       periodToDate;

    ExchRate    eliminationExchRate;
    ExchRate    fixedAmountExchRate;

    LedgerEliminationRuleId         ruleId;
    TransactionTxt                  transactionTxt;
    LedgerEliminationProcessMode    processMode;
    LedgerJournalId                 journalNumber;
    LedgerJournalNameId             journalName;

    selectableDataArea              sourceCompany;
    selectableDataArea              destinationCompany;
    CurrencyCode                    currencyCode;
    CurrencyCode                    sourceCurrencyCode;
    ReasonRefRecID                  reasonRefRecID;
    PostReleaseDate                 releaseDate;

    LedgerEliminationRule           ledgerEliminationRule;
    LedgerEliminationRuleLine       ledgerEliminationRuleLine;
    LedgerJournalTrans              ledgerJournalTrans;
    GeneralJournalAccountEntry      generalJournalAccountEntry;

    int                             numberOfDistributions;
    AmountMST                       journalBalance;
    boolean                         first;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calcExchRate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the exchange rate between two amounts.
    /// </summary>
    /// <param name="_amount">
    ///    The computed amount that the original amount was converted to.
    /// </param>
    /// <param name="_amountCur">
    ///    The original amount that was converted.
    /// </param>
    /// <returns>
    ///    The exchange rate that was used to convert the value specified by the <paramref name="_amountCur"
    ///    /> parameter to the value specified by the <paramref name="_amount" /> parameter.
    /// </returns>
    /// <remarks>
    ///    The first amount is divided by the second amount, and the result is multiplied times 100.
    /// </remarks>
    protected ExchRate calcExchRate(AmountMST _amount, AmountMST _amountCur)

    {
        ExchRate    amountRate;
        ;

        if (_amountCur != 0)
        {
            amountRate = _amount / _amountCur * 100;
        }

        return amountRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDistribution</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an entry in the <c>LedgerJournalTrans</c> table for an elimination amount.
    /// </summary>
    /// <param name="_ledgerDimension">
    /// The account number to post to.
    /// </param>
    /// <param name="_dimensionDefault">
    /// The dimension values to post to.
    /// </param>
    /// <param name="_amountCur">
    /// The amount to post.
    /// </param>
    /// <param name="_exchRate">
    /// The exchange rate for the currency of the transaction.
    /// </param>
    /// <param name="_secondaryExchRate">
    /// The secondary currency exchange rate for the company; optional.
    /// </param>
    /// <returns>
    /// true if a valid record was created; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method only tests for valid accounts and dimensions. Any other restrictions must be applied
    /// before use.
    /// </remarks>
    protected boolean createDistribution(
                                LedgerDimensionDefaultAccount _ledgerDimension,
                                DimensionDefault _dimensionDefault,
                                AmountCur _amountCur,
                                ExchRate _exchRate,
                                ExchRate _secondaryExchRate = 0.00)

    {
        boolean             ret = true;
        boolean             isChineseVoucher = LedgerParameters::isChineseVoucher_CN();

        // only create the voucher when processing the first line
        if (first)
        {
            first = false;

            // if we can't create a voucher end now
            if (!this.createVoucher())
            {
                return false;
            }
        }

        // Account and Dimension are valid to post to; proceed with creation of distribution
        ledgerJournalTrans.Company              = destinationCompany;
        ledgerJournalTrans.OffsetCompany        = destinationCompany;

        // Create a ledger dimension using values from the to company
        ledgerJournalTrans.LedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(_ledgerDimension, this.translateDimensions(_dimensionDefault, curext(), destinationCompany));
        ledgerJournalTrans.TransactionType      = LedgerTransType::Elimination;
        ledgerJournalTrans.SkipBlockedForManualEntryCheck = NoYes::Yes;

        // negative posted amounts are credits and positive debits so reverse accordingly
        if (_amountCur > 0)
        {
            ledgerJournalTrans.AmountCurCredit  = _amountCur;
            ledgerJournalTrans.AmountCurDebit   = 0;
        }
        else
        {
            ledgerJournalTrans.AmountCurDebit   = -_amountCur;
            ledgerJournalTrans.AmountCurCredit  = 0;
        }

        ledgerJournalTrans.CurrencyCode         = currencyCode;
        ledgerJournalTrans.TransDate            = glPostingDate;
        ledgerJournalTrans.AcknowledgementDate  = glPostingDate;
        ledgerJournalTrans.ExchRate             = _exchRate;
        ledgerJournalTrans.ExchRateSecond       = _secondaryExchRate;
        ledgerJournalTrans.ReasonRefRecID       = ReasonTableRef::checkCreateInCompany(reasonRefRecID, ledgerJournalTrans.DataAreaId);
        ledgerJournalTrans.ReleaseDate          = releaseDate;

        // if the value is cleared then the insert method on the table will set properly
        ledgerJournalTrans.LineNum              = 0.00;

        if (isChineseVoucher && !ledgerJournalTrans.LedgerVoucherType_CN)
        {
            ledgerJournalTrans.createVoucherType_CN();
        }

        ledgerJournalTrans.insert();

        // count the number of distributions created
        numberOfDistributions++;
        journalBalance += CurrencyExchangeHelper::amountCur2MST(_amountCur, currencyCode, _exchRate, glPostingDate, _secondaryExchRate);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an elimination journal in the <c>LedgerJournalTable</c> table.
    /// </summary>
    /// <returns>
    ///    true if a journal is created; otherwise, false.
    /// </returns>
    protected boolean createJournal()
    {
        LedgerJournalTable              ledgerJournalTable;
        boolean ret = true;

        if (sourceCompany == destinationCompany)
        {
            ledgerJournalTable.JournalName = this.parmJournalName();
            ledgerJournalTable.initFromLedgerJournalName();
            ledgerJournalTable.SystemBlocked = true;
            ledgerJournalTable.insert();
            
            if (ledgerJournalTable.JournalNum == '')
            {
                // would be empty if no number could be generated. Error would be generated in initFromLedgerJournalName
                ret = false;
            }
            else
            {
                this.parmJournalNumber(ledgerJournalTable.JournalNum);
            }
        }
        else
        {
            changecompany(destinationCompany)
            {
                ledgerJournalTable.JournalName = this.parmJournalName();
                ledgerJournalTable.initFromLedgerJournalName();
                ledgerJournalTable.SystemBlocked = true;
                ledgerJournalTable.insert();

                if (ledgerJournalTable.JournalNum == '')
                {
                    // would be empty if no number could be generated. Error would be generated in initFromLedgerJournalName
                    ret = false;
                }
                else
                {
                    this.parmJournalNumber(ledgerJournalTable.JournalNum);
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a voucher in the <c>LedgerJournalTrans</c> table for the elimination journal.
    /// </summary>
    /// <returns>
    ///    true if a voucher was created; otherwise, false.
    /// </returns>
    protected boolean createVoucher()
    {
        LedgerJournalName   ledgerJournalName;
        NumberSeq           numSeq;
        boolean             ret = true;
        ;

        // get the journal definition so we know which voucher series to use
        ledgerJournalName = LedgerJournalName::find(this.parmJournalName());

        numSeq = NumberSeq::newGetVoucherFromId(ledgerJournalName.NumberSequenceTable);
        ledgerJournalTrans.JournalNum = this.parmJournalNumber();
        ledgerJournalTrans.Voucher = numSeq.voucher();

        // none was create but the error was set in newGetVoucherFromCode so just return unsuccessful
        if (ledgerJournalTrans.Voucher == '')
        {
            ret = false;
        }
        else
        {
            // get the text defined for eliminations
            transactionTxt = TransactionTxt::construct(LedgerTransTxt::LedgerElimination);
            transactionTxt.setDate(glPostingDate);
            transactionTxt.setVoucher(ledgerJournalTrans.Voucher);
            ledgerJournalTrans.Txt = transactionTxt.txt();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExchRate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the defined exchange rate based on the <c>GlPostingDate</c> value set for the class instance.
    /// </summary>
    /// <param name="_currencyCode">
    ///    The currency for the amount.
    /// </param>
    /// <param name="_company">
    ///    The company in which the exchange rate is defined; optional.
    /// </param>
    /// <returns>
    ///    The exchange rate found for the currency and date.
    /// </returns>
    /// <remarks>
    ///    This method may not return a value. It is the responsibility of the caller to display any errors.
    /// </remarks>
    protected ExchRate getExchRate(CurrencyCode _currencyCode,
                                     CompanyId _company  = curext())
    {
        ExchRate    newExchRate;
        ;
        // we may need to look in a different company
        if (_company != curext())
        {
            changecompany(_company)
            {
                newExchRate = ExchangeRateHelper::exchRate(_currencyCode, this.parmGLPostingDate());
            }
        }
        else
        {
            newExchRate = ExchangeRateHelper::exchRate(_currencyCode, this.parmGLPostingDate());
        }

        return newExchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a new instance of the class.
    /// </summary>
    /// <remarks>
    /// Always call construct to get a new instance.
    /// </remarks>
    protected void new()
    {
        ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets and sets the currency variable for the class.
    /// </summary>
    /// <param name="_currencyCode">
    ///    The <c>CurrencyCode</c> value to set the variable to; optional.
    /// </param>
    /// <returns>
    ///    The value of the currency variable.
    /// </returns>
    public CurrencyCode parmCurrencyCode(CurrencyCode _currencyCode = currencyCode)
    {
        ;

        currencyCode = _currencyCode;

        return currencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDestinationCompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets and sets the <c>destinationCompany</c> variable for the class.
    /// </summary>
    /// <param name="_destinationCompany">
    ///    The <c>selectableDataArea </c>value to set the variable to; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>destinationCompany</c> variable.
    /// </returns>
    public selectableDataArea parmDestinationCompany(selectableDataArea _destinationCompany = destinationCompany)
    {
        ;

        destinationCompany = _destinationCompany;

        return destinationCompany;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmGLPostingDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets and sets the <c>glPostingDate</c> variable for the class.
    /// </summary>
    /// <param name="_glPostingDate">
    ///    The <c>TransDate </c>value to set the variable to; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>glPostingDate</c> variable.
    /// </returns>
    public TransDate parmGLPostingDate(TransDate _glPostingDate = glPostingDate)
    {
        ;

        glPostingDate = _glPostingDate;

        return glPostingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalName</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets and sets the <c>journalName</c> variable for the class.
    /// </summary>
    /// <param name="_journalName">
    ///    The <c>LedgerJournalNameId </c>value to set the variable to; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>journalName</c> variable.
    /// </returns>
    public LedgerJournalNameId parmJournalName(LedgerJournalNameId _journalName = journalName)
    {
        ;

        journalName = _journalName;

        return journalName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalNumber</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets and sets the <c>JournalNumber</c> variable for the class.
    /// </summary>
    /// <param name="_journalNumber">
    ///    The <c>LedgerJournalId </c>value to set the variable to; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>JournalNumber</c> variable.
    /// </returns>
    public LedgerJournalId parmJournalNumber(LedgerJournalId _journalNumber = journalNumber)
    {
        ;

        journalNumber = _journalNumber;

        return journalNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPeriodFromDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets and sets the <c>periodFromDate</c> variable for the class.
    /// </summary>
    /// <param name="_periodFromDate">
    ///    The <c>TransDate</c> value to set the variable to; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>periodFromDate</c> variable.
    /// </returns>
    public TransDate parmPeriodFromDate(TransDate _periodFromDate = periodFromDate)
    {
        ;

        periodFromDate = _periodFromDate;

        return periodFromDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPeriodToDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets and sets the <c>periodToDate</c> variable for the class.
    /// </summary>
    /// <param name="_periodToDate">
    ///    The <c>TransDate </c>value to set the variable to; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>periodToDate</c> variable.
    /// </returns>
    public TransDate parmPeriodToDate(TransDate _periodToDate = periodToDate)
    {
        ;

        periodToDate = _periodToDate;

        return periodToDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProcessMode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets and sets the <c>processMode</c> variable for the class.
    /// </summary>
    /// <param name="_processMode">
    ///    The <c>LedgerEliminationProcessMode</c> value to set the variable to; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>processMode</c> variable.
    /// </returns>
    public LedgerEliminationProcessMode parmProcessMode(LedgerEliminationProcessMode _processMode = processMode)
    {
        ;

        processMode = _processMode;

        return processMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReasonRefRecId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>reasonRefRecId</c> variable for the class.
    /// </summary>
    /// <param name="_reasonRefRecID">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>reasonRefRecId</c> variable.
    /// </returns>
    public ReasonRefRecID parmReasonRefRecId(ReasonRefRecID _reasonRefRecID  = reasonRefRecID)
    {
        ;

        reasonRefRecID = _reasonRefRecID;

        return reasonRefRecID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReleaseDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>releaseDate</c> variable for the class.
    /// </summary>
    /// <param name="_releaseDate">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>releaseDate</c> variable.
    /// </returns>
    public PostReleaseDate parmReleaseDate(PostReleaseDate _releaseDate  = releaseDate)
    {
        ;

        releaseDate = _releaseDate;

        return releaseDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRuleId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets and sets the <c>ruleId</c> variable for the class.
    /// </summary>
    /// <param name="_ruleId">
    ///    The <c>LedgerEliminationRuleId</c> value to set the variable to; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>ruleId</c> variable.
    /// </returns>
    public LedgerEliminationRuleId parmRuleId(LedgerEliminationRuleId _ruleId = ruleId)
    {
        ;

        ruleId = _ruleId;

        return ruleId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceCompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets and sets the <c>sourceCompany</c> variable for the class.
    /// </summary>
    /// <param name="_sourceCompany">
    ///    The <c>selectableDataArea </c>value to set the variable to; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>sourceCompany</c> variable.
    /// </returns>
    public selectableDataArea parmSourceCompany(selectableDataArea _sourceCompany = sourceCompany)
    {
        ;

        sourceCompany = _sourceCompany;

        return sourceCompany;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets and sets the currency variable for the class.
    /// </summary>
    /// <param name="_sourceCurrencyCode">
    ///    A <c>CurrencyCode</c> value to set the variable to; optional.
    /// </param>
    /// <returns>
    ///    The value of the currency variable.
    /// </returns>
    public CurrencyCode parmSourceCurrencyCode(CurrencyCode _sourceCurrencyCode = sourceCurrencyCode)
    {
        ;

        sourceCurrencyCode = _sourceCurrencyCode;

        return sourceCurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processElimination</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs all the functions that are required to process an elimination rule.
    /// </summary>
    /// <param name="_ruleId">
    /// The rule to process.
    /// </param>
    /// <param name="_periodFromDate">
    /// The start date for the range of general journal records that are used when it is retrieving account
    /// balances.
    /// </param>
    /// <param name="_periodToDate">
    /// The end date for the range of general journal records that are used when it is retrieving account
    /// balances.
    /// </param>
    /// <param name="_glPostingDate">
    /// The transaction date of the journal that is created.
    /// </param>
    /// <param name="_releaseDate">
    /// The date that the transaction can be posted. If the field is blank, the transaction can be posted
    /// immediately.
    /// </param>
    /// <param name="_reasonRefRecID">
    /// The record ID of the record in the <c>ReasonTableRef</c> table that is associated with the
    /// transactions.
    /// </param>
    /// <returns>
    /// A container that has the journal number and the company that the journal is in, in addition to an
    /// error if a failure were to occur.
    /// </returns>
    public LedgerEliminationResult processElimination(LedgerEliminationRuleId _ruleId,
                        TransDate _periodFromDate,
                        TransDate _periodToDate,
                        TransDate _glPostingDate,
                        PostReleaseDate _releaseDate,
                        ReasonRefRecID _reasonRefRecID)
    {
        LedgerEliminationResult ledgerEliminationResult;
        boolean                 success;
        ;

        this.parmRuleId(_ruleId);
        this.parmPeriodFromDate(_periodFromDate);
        this.parmPeriodToDate(_periodToDate);
        this.parmGLPostingDate(_glPostingDate);
        this.parmReleaseDate(_releaseDate);
        this.parmReasonRefRecId(_reasonRefRecID);

        ledgerEliminationRule = LedgerEliminationRule::find(ruleId);

        if (ledgerEliminationRule.RecId == 0)
        {
            // Value %1 in field %2 was not found in relating table %3.
            ledgerEliminationResult = [_ruleId,
                                      this.parmJournalNumber(),
                                      ledgerEliminationRule.DestinationCompany,
                                      false];
            error(strFmt("@SYS97692", ruleId, "@SYS103487", tablePName(LedgerEliminationRule)));
        }
        else
        {
            this.parmJournalName(ledgerEliminationRule.JournalName);
            this.parmSourceCompany(ledgerEliminationRule.SourceCompany);
            this.parmDestinationCompany(ledgerEliminationRule.DestinationCompany);

            // if the rule is valid process it
            if (ledgerEliminationRule.isRuleValidToProcess(periodToDate,
                                                glPostingDate,
                                                destinationCompany))
            {
                ttsbegin;

                success = this.createJournal();

                if (success)
                {
                    // The elimination rule %1 failed during processing.
                    success = this.processRule();

                    if (success)
                    {
                        // the journal is not balanced
                        if (journalBalance != 0.00)
                        {
                            ledgerEliminationResult = [_ruleId,
                                                    this.parmJournalNumber(),
                                                    ledgerEliminationRule.DestinationCompany,
                                                    false];
                            success = checkFailed("@SYS107583");
                            success = checkFailed(strFmt("@SYS108433",ruleId));
                        }

                        else
                        {
                            ledgerEliminationResult = [_ruleId,
                                                    this.parmJournalNumber(),
                                                    ledgerEliminationRule.DestinationCompany,
                                                    true];
                        }
                        ttscommit;
                    }
                    else
                    {
                        ledgerEliminationResult = [_ruleId,
                                                this.parmJournalNumber(),
                                                ledgerEliminationRule.DestinationCompany,
                                                false];
                        throw error("@SYS108432");
                    }
                }

                else
                {
                    // A journal could not be created during elimination processing.
                    throw error("@SYS108432");
                }
            }
            else
            {
                error("@SYS108432");
                error(strFmt("@SYS108433",ruleId));
            }
        }

        return ledgerEliminationResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processFixedAmountLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Processes elimination rule lines that use fixed amounts to produce journal lines.
    /// </summary>
    /// <returns>
    ///    true if the process was successful; otherwise, false.
    /// </returns>
    protected boolean processFixedAmountLine()
    {
        boolean success = true;

        // we don't create 0.00 amount distributions
        if (ledgerEliminationRuleLine.Amount != 0.00)
        {
            // set the currency code for the distribution to the source company currency
            this.parmCurrencyCode(sourceCurrencyCode);

            // create the actual ledgerJournalTrans record for the elimination amount
            success = this.createDistribution(
                                    ledgerEliminationRuleLine.LedgerDimension,
                                    ledgerEliminationRuleLine.DefaultDimension,
                                    -ledgerEliminationRuleLine.Amount,
                                    fixedAmountExchRate);
        }

        return success;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processNetAmountLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes elimination rule lines that use net change amounts to produce journal lines.
    /// </summary>
    /// <returns>
    /// true if the process was successful; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The <c>LedgerTrans</c> table must be queried to arrive at amounts. This requires that a query be
    /// defined. The account and dimensions to use when you are creating the journal line must be
    /// determined based on the values defined on each line.
    /// </remarks>
    protected boolean processNetAmountLine()
    {
        QueryRun                        sourceQueryRun;
        boolean                         success = true;
        LedgerDimensionDefaultAccount   ledgerDimension;
        DimensionDefault                defaultDimension;
        selectableDataArea              dimensionCompany;

        // create the query to read the general journal records to get amounts to eliminate
        sourceQueryRun = LedgerEliminationProcessRule::createQueryOnSource(sourceCompany, ledgerEliminationRuleLine.RecId, ledgerEliminationRuleLine.SourceAccount, periodFromDate, periodToDate);

        // step through all the records in the range
        while (sourceQueryRun.next())
        {
            generalJournalAccountEntry = sourceQueryRun.get(tableNum(GeneralJournalAccountEntry));

            // we never process zero amounts
            if (generalJournalAccountEntry.TransactionCurrencyAmount != 0.00)
            {
                // The account and dimensions come from either the source or user defined so determine which to use
                if (ledgerEliminationRuleLine.DestinationAccount == LedgerEliminationDestination::Source)
                {
                    ledgerDimension = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(generalJournalAccountEntry.LedgerDimension);
                }
                else
                {
                    ledgerDimension = ledgerEliminationRuleLine.LedgerDimension;
                }

                if (ledgerEliminationRuleLine.DestinationDimension == LedgerEliminationDestination::Source)
                {
                    defaultDimension = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(generalJournalAccountEntry.LedgerDimension);
                    dimensionCompany = curext();
                }
                else
                {
                    defaultDimension = ledgerEliminationRuleLine.DefaultDimension;
                    dimensionCompany = ledgerEliminationRule.DestinationCompany;
                }

                // set the currency code for the distribution to the source company currency
                this.parmCurrencyCode(generalJournalAccountEntry.TransactionCurrencyCode);

                // calc the exchange rate based on the actual amounts
                eliminationExchRate = this.calcExchRate(generalJournalAccountEntry.AccountingCurrencyAmount,
                                                        generalJournalAccountEntry.TransactionCurrencyAmount);

                // create the actual ledgerJournalTrans record for the elimination amount
                success = this.createDistribution(
                                       ledgerDimension,
                                       defaultDimension,
                                       generalJournalAccountEntry.TransactionCurrencyAmount,
                                       eliminationExchRate);
            }

            if (!success)
            {
                break;
            }
        }

        return success;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processProposal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Generates <c>LedgerJournalTrans</c> records using an elimination rule for the specified journal.
    /// </summary>
    /// <param name="_ledgerEliminationProposal">
    ///    The proposal class calling the method
    /// </param>
    public void processProposal(LedgerEliminationProposal _ledgerEliminationProposal)
    {
        boolean success;
        ;

        // populate the class variables
        this.parmRuleId(_ledgerEliminationProposal.parmRuleId());
        this.parmPeriodFromDate(_ledgerEliminationProposal.parmFromDate());
        this.parmPeriodToDate(_ledgerEliminationProposal.parmToDate());
        this.parmGLPostingDate(_ledgerEliminationProposal.parmGLPostingDate());
        this.parmJournalName(_ledgerEliminationProposal.parmJournalName());
        this.parmJournalNumber(_ledgerEliminationProposal.parmJournalNum());
        this.parmSourceCompany(_ledgerEliminationProposal.parmSourceCompany());
        this.parmReasonRefRecId(_ledgerEliminationProposal.parmReasonRefRecId());
        this.parmReleaseDate(_ledgerEliminationProposal.parmReleaseDate());

        changecompany(sourceCompany)
        {
            ledgerEliminationRule = LedgerEliminationRule::find(ruleId,true);

            if (ledgerEliminationRule.RecId == 0)
            {
                error("@SYS107562");
            }
            else
            {
                // we don't know the destination company until we get the rule
                this.parmDestinationCompany(ledgerEliminationRule.DestinationCompany);
                // if the rule is valid process it
                if (ledgerEliminationRule.isRuleValidToProcess(periodToDate,
                                                    glPostingDate,
                                                    destinationCompany))
                {
                    ttsbegin;

                    // The elimination rule %1 failed during processing.
                    success = this.processRule();
                    if (success)
                    {
                        // if distributions were created commit the transaction
                        if (numberOfDistributions > 0)
                        {
                            // update the date last run
                            ledgerEliminationRule.DateLastRun = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                            ledgerEliminationRule.update();

                            ttscommit;
                        }
                        else
                        {
                            // There are not any records to create in the journal so abort
                            throw error("@SYS107568");
                        }
                    }
                    else
                    {
                        throw error(strFmt("@SYS108433", ruleId));
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processRule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the actual processing of an elimination rule.
    /// </summary>
    /// <returns>
    /// true if <c>LedgerJournalTrans</c> records are successfully created; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Changing companies can cause a performance problem. The code is structured to change to the
    /// destination company if you must before processing the elimination rule lines. All code called by
    /// this method uses cross-company queries to access source company information.
    /// </remarks>
    protected boolean processRule()
    {
        boolean     success = true;
        ;

        // initialize to default values
        numberOfDistributions = 0;
        journalBalance = 0.00;
        fixedAmountExchRate = 100.00;
        first = true;

        // set the currency to the source company currency.
        this.parmSourceCurrencyCode(CompanyInfoHelper::standardCurrency());

        if (sourceCompany == destinationCompany)
        {
            success = this.processRuleLine();
        }
        else
        {
            changecompany(destinationCompany)
            {
                success = this.processRuleLine();
            }
        }

        return success;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processRuleLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the actual processing of elimination rule lines.
    /// </summary>
    /// <returns>
    /// true if <c>ledgerJournalTrans</c> records are successfully created; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Changing companies can cause a performance problem. The code uses a cross-company query to access
    /// the elimination rule lines when they are in the destination company. This eliminates the must
    /// change to the destination company.
    /// </remarks>
    protected boolean processRuleLine()
    {
        container   companies;
        boolean     success = true;
        ;

        companies = [sourceCompany];

        while select crosscompany:companies ledgerEliminationRuleLine where
                ledgerEliminationRuleLine.RuleId == ruleId
        {
            // each line has additional validation requirements beyond the rule as a whole
            success = ledgerEliminationRuleLine.validateRuleLine();

            if (success)
            {
                // fixed method rule lines don't need to query the general journal so process separate
                if (ledgerEliminationRuleLine.EliminationMethod == LedgerEliminationMethod::FixedAmount)
                {
                    success = this.processFixedAmountLine();
                }
                else
                {
                    success = this.processNetAmountLine();
                }
            }

            // break out of loop and return on error
            if (!success)
            {
                break;
            }
        }

        return success;
    }

]]></Source>
			</Method>
			<Method>
				<Name>translateDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Translates dimension information in one company to dimension information in a different company.
    /// </summary>
    /// <param name="_fromDefaultDimension">
    /// The source default dimension.
    /// </param>
    /// <param name="_fromCompany">
    /// The company that contains the source default dimension.
    /// </param>
    /// <param name="_toCompany">
    /// The destination company for the dimension values.
    /// </param>
    /// <returns>
    /// The ID of a default dimension in the destination company.
    /// </returns>
    /// <remarks>
    /// The dimension attributes and values are matched by name across companies and if either the
    /// attribute or value is not found, it is left out of the destination set.
    /// </remarks>
    private DimensionDefault translateDimensions(DimensionDefault _fromDefaultDimension, selectableDataArea _fromCompany, selectableDataArea _toCompany)
    {
        DimensionAttributeValueSetItem      setItem;
        DimensionAttribute                  dimAttr, destDimAttr;
        DimensionAttributeValue             dimAttrValue, destDimAttrValue;
        DimensionAttributeValueSetStorage   setStorage;

        // Short circuit if company is the same or dimension is not specified
        if (_fromDefaultDimension == 0 || _fromCompany == _toCompany)
        {
            return _fromDefaultDimension;
        }

        setStorage = new DimensionAttributeValueSetStorage();

        while select crosscompany DisplayValue from setItem
            where setItem.DimensionAttributeValue == _fromDefaultDimension
            join RecId from dimAttrValue
                where dimAttrValue.RecId == setItem.DimensionAttributeValue
            join Name from dimAttr
                where dimAttr.RecId == dimAttrValue.DimensionAttribute
        {
            changecompany(_toCompany)
            {
                // Find the destination dimension attribute if it exists
                select destDimAttr where destDimAttr.Name == dimAttr.Name;
                if (destDimAttr)
                {
                    // Find the specified value for that dimension attribute
                    destDimAttrValue = DimensionAttributeValue::findByDimensionAttributeAndValue(destDimAttr, setItem.DisplayValue, false, true);

                    if (destDimAttrValue)
                    {
                        setStorage.addItem(destDimAttrValue);
                    }
                }
            }
        }

        changecompany(_toCompany)
        {
            return setStorage.save();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>LedgerEliminaitonProcessRule</c> class.
    /// </summary>
    /// <returns>
    ///    A new instance of the <c>LedgerEliminaitonProcessRule</c> class.
    /// </returns>
    public static LedgerEliminationProcessRule construct()
    {
        return new LedgerEliminationProcessRule();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createQueryOnSource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>LedgerTransElimination</c> query and a range based on the date, account, and dimension.
    /// </summary>
    /// <param name="_sourceCompany">
    /// The company that contains the source transactions.
    /// </param>
    /// <param name="_eliminationRuleLineId">
    /// The ID of the rule line to process.
    /// </param>
    /// <param name="_sourceAccountCriteria">
    /// The criteria to apply to the main account dimension attribute.
    /// </param>
    /// <param name="_periodFromDate">
    /// The start of the period from which transactions should be selected.
    /// </param>
    /// <param name="_periodToDate">
    /// The end of the period from which transactions should be selected.
    /// </param>
    /// <returns>
    /// The query created.
    /// </returns>
    protected static QueryRun createQueryOnSource(
        dataAreaId                  _sourceCompany,
        recId                       _eliminationRuleLineId,
        DimensionsAccountCriteria   _sourceAccountCriteria,
        date                        _periodFromDate,
        date                        _periodToDate)
    {
        Query                                   query;
        QueryRun                                queryRun;
        QueryBuildDataSource                    qbds, qbdsDimAtt, qbdsDate, dsPeriod, qbdsDavc;
        LedgerEliminationRuleLineCriteria       sourceDimCriteria;
        Map                                     criteriaMap = new Map(Types::Int64, Types::String);
        MapEnumerator                           criteriaMapEnumerator;
        LedgerEliminationTmpJournalLine         tmpJournalLine;
        GeneralJournalAccountEntry              generalJournalAccountEntry;
        DimensionAttribute                      dimAttr;
        DimensionAttributeLevelValue            dimAttrLevelValue;
        DimensionAttributeValue                 dimAttrValue;
        DimensionAttributeValueGroupCombination dimAttrValueGroupCombo;
        GeneralJournalEntry                     generalJournalEntry;
        FiscalCalendarPeriod                    fiscalCalendarPeriod;
        guid                                    uniqueIdentifier = newGuid();

        // Create a query based on the temp values to restrict based on dimension and account
        query = new Query();
        qbds = query.addDataSource(tableNum(GeneralJournalAccountEntry));

        // Sum functional and transaction amounts
        qbds.addSelectionField(fieldNum(GeneralJournalAccountEntry, AccountingCurrencyAmount), SelectionField::Sum);
        qbds.addSelectionField(fieldNum(GeneralJournalAccountEntry, TransactionCurrencyAmount), SelectionField::Sum);
        qbds.addGroupByField(fieldNum(GeneralJournalAccountEntry, TransactionCurrencyCode));
        qbds.addGroupByField(fieldNum(GeneralJournalAccountEntry, LedgerDimension));

        // Read source dimension criteria
        changecompany (_sourceCompany)
        {
            while select SourceDimensionAttribute, SourceCriteria from sourceDimCriteria
                where sourceDimCriteria.SourceCriteria != '' &&
                    sourceDimCriteria.LedgerEliminationRuleLine == _eliminationRuleLineId
            {
                if (criteriaMap.exists(sourceDimCriteria.SourceDimensionAttribute))
                {
                    criteriaMap.insert(
                        sourceDimCriteria.SourceDimensionAttribute,
                        criteriaMap.lookup(sourceDimCriteria.SourceDimensionAttribute) + ',' + sourceDimCriteria.SourceCriteria);
                }
                else
                {
                    criteriaMap.insert(sourceDimCriteria.SourceDimensionAttribute, sourceDimCriteria.SourceCriteria);
                }
            }
        }
    
        qbdsDavc = qbds.addDataSource(tableNum(DimensionAttributeValueCombination));
        qbdsDavc.joinMode(JoinMode::InnerJoin);
        qbdsDavc.addLink(fieldNum(GeneralJournalAccountEntry, LedgerDimension), fieldNum(DimensionAttributeValueCombination, RecId));
        qbdsDavc.fetchMode(QueryFetchMode::One2One);
        DimensionAttribute dimensionAttribute = DimensionAttribute::find(DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount));
        QueryBuildRange qbr = qbdsDavc.addRange(fieldName2Id(tableNum(DimensionAttributeValueCombination), dimensionAttribute.DimensionValueColumnName));
        qbr.value(strFmt('%1', _sourceAccountCriteria));

        LedgerEliminationProcessRule::createDimensionRanges(qbdsDavc, criteriaMap.getEnumerator());

        // Set transaction date range values
        qbdsDate = qbds.addDataSource(tableNum(GeneralJournalEntry));
        qbdsDate.joinMode(JoinMode::InnerJoin);
        qbdsDate.fetchMode(QueryFetchMode::One2One);
        qbdsDate.addLink(fieldNum(GeneralJournalAccountEntry, GeneralJournalEntry), fieldNum(GeneralJournalEntry, RecId));
        qbdsDate.addRange(fieldNum(GeneralJournalEntry, Ledger)).value(SysQuery::value(Ledger::primaryLedger(CompanyInfo::current(_sourceCompany))));
        qbdsDate.addRange(fieldNum(GeneralJournalEntry, AccountingDate)).value(queryRange(_periodFromDate, _periodToDate));
        qbdsDate.addRange(fieldNum(GeneralJournalEntry, PostingLayer)).value(queryValue(CurrentOperationsTax::Current));

        dsPeriod = qbdsDate.addDataSource(tableNum(FiscalCalendarPeriod));
        dsPeriod.addLink(fieldNum(GeneralJournalEntry, FiscalCalendarPeriod), fieldNum(FiscalCalendarPeriod, RecId));

        dsPeriod.addRange(fieldNum(FiscalCalendarPeriod, Type)).value(queryValue(FiscalPeriodType::Operating));

        queryRun = new QueryRun(query);

        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDimensionRanges</Name>
				<Source><![CDATA[
    private static void createDimensionRanges(QueryBuildDataSource _qbdsDavc, MapEnumerator _criteriaMapEnumerator)
    {
        // Range by dimensions as necessary
        while (_criteriaMapEnumerator.moveNext())
        {
            DimensionAttributeRecId keyValue = _criteriaMapEnumerator.currentKey();
            str queryValueStr = _criteriaMapEnumerator.currentValue();

            DimensionRefFieldName dimensionValueColumnName = DimensionAttribute::find(keyValue).DimensionValueColumnName;

            _qbdsDavc.addGroupByField(fieldName2Id(tableNum(DimensionAttributeValueCombination), dimensionValueColumnName));
            QueryBuildRange qbr = _qbdsDavc.addRange(fieldName2Id(tableNum(DimensionAttributeValueCombination), dimensionValueColumnName));
            qbr.value(queryValueStr);
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>