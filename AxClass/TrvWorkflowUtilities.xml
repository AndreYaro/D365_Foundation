<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TrvWorkflowUtilities</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>TrvWorkflowUtilities</c> class is a helper class that contains methods that are all workflow
///    related functionalities used in expense management.
/// </summary>
public class TrvWorkflowUtilities
{
    #TrvMacro
    #OCCRetryCount
    
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>autoPostExpenseDocument</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Journalizes an expense report after it has been approved.
    /// </summary>
    /// <param name="workflowContext">
    ///    The <c>WorkflowContext</c> object of the approved expense report.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    Invalid default ledger name in parameters; a default ledger name or the default ledger does not
    ///    exist.
    /// </exception>
    public static void autoPostExpenseDocument(WorkflowContext workflowContext)
    {
        TrvExpTable trvExpTable = TrvExpTable::findRecId(workflowContext.parmRecId());

        changecompany(CompanyInfo::findRecId(trvExpTable.LegalEntity).DataArea)
        {
            trvExpTable.selectForUpdate(true);
            if (trvExpTable.validatePost())
            {
                if (TrvExpenseHelper::isTrvResetDistributionForAutoPostingFlightEnabled())
                {
                    SourceDocumentLineImplementationList sourceDocumentLineImplementationList = TrvWorkflowUtilities::getSourceDocumentLineItemListForReset(trvExpTable.SourceDocumentHeader);
                    SourceDocumentLineImplementationListEnum sourceDocumentLineImplementationListEnumerator = sourceDocumentLineImplementationList.getEnumerator();

                    while (sourceDocumentLineImplementationListEnumerator.moveNext())
                    {
                        SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(
                        sourceDocumentLineImplementationListEnumerator.current(),
                        false,
                        SourceDocumentLineAccountingStatus::Draft);
                    }

                    sourceDocumentLineImplementationListEnumerator.reset();
                    while (sourceDocumentLineImplementationListEnumerator.moveNext())
                    {
                        SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(
                        sourceDocumentLineImplementationListEnumerator.current(),
                        false,
                        SourceDocumentLineAccountingStatus::FullyDistributed);
                    }
                }

                TrvPost::post(trvExpTable);
            }
            else
            {
                throw error("@SYS328166");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>autoPostExpenseLineItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Journalizes an expense line after it has been approved.
    /// </summary>
    /// <param name="workflowContext">
    /// The workflow context of the approved expense report.
    /// </param>
    /// <exception cref="M:Exception::Error">
    /// A default ledger name or the default ledger does not exist.
    /// </exception>
    public static void autoPostExpenseLineItem(WorkflowContext workflowContext)
    {
        TrvExpTrans trvExpTrans = TrvExpTrans::find(workflowContext.parmRecId());

        changecompany(CompanyInfo::findRecId(trvExpTrans.LegalEntity).DataArea)
        {
            trvExpTrans.selectForUpdate(true);
            if (trvExpTrans.validatePost())
            {
                TrvPost::post(trvExpTrans);
            }
            else
            {
                throw error("@SYS328166");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canActivateAutoPostingWorkflow</Name>
				<Source><![CDATA[
    public static boolean canActivateAutoPostingWorkflow(WorkflowVersionTable versionTable, TableId tableId, RecId recId)
    {
        SysDictWorkflowType     sysDictWorkflowTemplate;
        sysDictWorkflowTemplate = new SysDictWorkflowType(TrvWorkflowUtilities::getAutoPostingWorkflowType(tableId));

        if (versionTable.ActivationConditionType == NoYes::Yes && sysDictWorkflowTemplate.disableActivationConditions() == false)
        {
            return Workflow::evaluateWorkflowActivationCondition(versionTable, recId, tableId);
        }

        //if there is not activation condition set up, allow activation by default
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearPolicyJustifications</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the policy violation justification when a workflow item is rejected or canceled.
    /// </summary>
    /// <param name="_workflowContext">
    /// The workflow context of the work item.
    /// </param>
    /// <param name="_violatingRecord">
    /// The record ID of transaction header or line.
    /// </param>
    /// <param name="_violationJustificationType">
    /// The violation justification type.
    /// </param>
    /// <param name="_clearAll">
    /// A Boolean value that indicates whether all the line justifications are to be cleared with the
    /// header.
    /// </param>
    /// <remarks>
    /// Canceling the header in line item workflow cancels all lines.If an approver rejects an expense
    /// report that contains policy violations where justification have been entered, any manager
    /// justifications that have been entered must be cleared.If an approver rejects an expense report line
    /// that contains policy violations where justification have been entered, any manager justifications
    /// that have been entered must be cleared.If using document level approvals, then all the manager
    /// justifications must be cleared.If using line level approvals, then only the manager justifications
    /// for rejected lines must be cleared.
    /// </remarks>
    public static void clearPolicyJustifications(WorkflowContext _workflowContext, RefRecId _violatingRecord, TrvPolicyViolationJustificationTypeEnum _violationJustificationType,
                                                    boolean _clearAll = false)
    {
        TrvPolicyViolationJustification trvPolicyViolationJustification;
        TrvExpTrans                     trvExpTrans;
        TrvRequisitionLine              trvReqLine;

        delete_from trvPolicyViolationJustification
            where trvPolicyViolationJustification.ViolatingRecord == _violatingRecord &&
                trvPolicyViolationJustification.ViolationJustificationType == _violationJustificationType &&
                trvPolicyViolationJustification.Action == TrvWorkflowAction::Approve;

        // when the expense/travel requisition header is rejected, all the justifications entered for line are also cleared only when line item is not configured
        if (_violationJustificationType == TrvPolicyViolationJustificationTypeEnum::TrvExpHeader)
        {
            if (_clearAll || !TrvWorkflowUtilities::isLineItemApprovalConfigured(_workflowContext.parmRootCorrelationId()))
            {
                while select RecId from trvExpTrans
                    where trvExpTrans.TrvExpTable == _violatingRecord
                {
                    delete_from trvPolicyViolationJustification
                        where trvPolicyViolationJustification.ViolatingRecord == trvExpTrans.RecId &&
                            trvPolicyViolationJustification.ViolationJustificationType == TrvPolicyViolationJustificationTypeEnum::TrvExpLine &&
                            trvPolicyViolationJustification.Action == TrvWorkflowAction::Approve;
                }
            }
        }
        else if (_violationJustificationType == TrvPolicyViolationJustificationTypeEnum::TrvReqHeader)
        {
            while select RecId from trvReqLine
                where trvReqLine.TrvRequisitionTable == _violatingRecord
            {
                delete_from trvPolicyViolationJustification
                    where trvPolicyViolationJustification.ViolatingRecord == trvReqLine.RecId &&
                        trvPolicyViolationJustification.ViolationJustificationType == TrvPolicyViolationJustificationTypeEnum::TrvReqLine &&
                        trvPolicyViolationJustification.Action == TrvWorkflowAction::Approve;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearPolicyViolations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the policy violations log when a workflow item is recalled or rejected.
    /// </summary>
    /// <param name="_recId">
    /// The record ID of the expense report, travel requisition or expense lines.
    /// </param>
    /// <param name="_tableId">
    /// The table ID of either the expense report, travel requisition or expense lines.
    /// </param>
    /// <param name="_clearAll">
    /// A Boolean value that indicates whether all the line violations are to be cleared with the header.
    /// </param>
    /// <remarks>
    /// Canceling the header in line item workflow cancels all lines.
    /// </remarks>
    public static void clearPolicyViolations(RefRecId _recId, TableId _tableId, boolean _clearAll = false)
    {
        TrvPolicyViolationsLog              trvPolicyViolationsLog;

        switch (_tableId)
        {
            case tableNum(TrvExpTable):
                delete_from trvPolicyViolationsLog
                    where trvPolicyViolationsLog.Header == _recId
                    && trvPolicyViolationsLog.Line == 0
                    && trvPolicyViolationsLog.Action != TrvWorkflowAction::Return;

                if (_clearAll || !TrvWorkflowUtilities::isLineItemApprovalForExpenseReport(_recId))
                {
                    delete_from trvPolicyViolationsLog
                        where trvPolicyViolationsLog.Header == _recId
                            && trvPolicyViolationsLog.Line != 0
                            && trvPolicyViolationsLog.Action != TrvWorkflowAction::Return;
                }
                break;

            case tableNum(TrvExpTrans):
                delete_from trvPolicyViolationsLog
                    where trvPolicyViolationsLog.Line == _recId &&
                        trvPolicyViolationsLog.Action != TrvWorkflowAction::Return;
                break;

            case tableNum(TrvRequisitionTable):
                delete_from trvPolicyViolationsLog
                    where trvPolicyViolationsLog.Header == _recId
                        && trvPolicyViolationsLog.Line == 0
                        && trvPolicyViolationsLog.Action != TrvWorkflowAction::Return;

                delete_from trvPolicyViolationsLog
                    where trvPolicyViolationsLog.Header == _recId
                        && trvPolicyViolationsLog.Line != 0
                        && trvPolicyViolationsLog.Action != TrvWorkflowAction::Return;
                break;

            case tableNum(TrvRequisitionLine):
                delete_from trvPolicyViolationsLog
                    where trvPolicyViolationsLog.Line == _recId 
                        && trvPolicyViolationsLog.Action != TrvWorkflowAction::Return;
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearWorkflowLogs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the workflow logs which are approved when a workflow item is recalled or rejected.
    /// </summary>
    /// <param name="_recId">
    /// The record ID of either the expense reports or the expense lines.
    /// </param>
    /// <param name="_tableId">
    /// The table ID of either the expense reports or the expense lines.
    /// </param>
    /// <param name="_clearAll">
    /// A Boolean value that indicates whether all the workflow logs are to be cleared with the header.
    /// </param>
    /// <remarks>
    /// Canceling the header in line item workflow cancels all lines.
    /// </remarks>
    public static void clearWorkflowLogs(RefRecId _recId, TableId _tableId, boolean _clearAll = false)
    {
        TrvWorkflowLog                      trvWorkflowLog;

        switch (_tableId)
        {
            case tableNum(TrvExpTable):
                delete_from trvWorkflowLog
                    where trvWorkflowLog.ExpHeaderRecId == _recId
                        && trvWorkflowLog.ExpLineRecId == 0
                        && trvWorkflowLog.ApprovedByWorker != 0
                        && trvWorkflowLog.RejectedByWorker == 0;

                if (_clearAll || !TrvWorkflowUtilities::isLineItemApprovalForExpenseReport(_recId))
                {
                    delete_from trvWorkflowLog
                        where trvWorkflowLog.ExpHeaderRecId == _recId
                            && trvWorkflowLog.ExpLineRecId != 0
                            && trvWorkflowLog.ApprovedByWorker != 0
                            && trvWorkflowLog.RejectedByWorker == 0;
                }
            break;

            case tableNum(TrvExpTrans):
                delete_from trvWorkflowLog
                    where trvWorkflowLog.ExpLineRecId == _recId
                        && trvWorkflowLog.ApprovedByWorker != 0
                        && trvWorkflowLog.RejectedByWorker == 0;
            break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>expenseLineHasActiveWorkItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the expense line has a pending active workflow work item.
    /// </summary>
    /// <param name="_expenseLineRecId">
    /// The record ID of the expense line.
    /// </param>
    /// <returns>
    /// true if the expense line has an existing workflow item; otherwise, false.
    /// </returns>
    public static boolean expenseLineHasActiveWorkItem(RecId _expenseLineRecId)
    {
        WorkflowWorkItemTable workItemTable;

        select firstonly RecId from workItemTable
                    where workItemTable.RefTableId == tableNum(TrvExpTrans) &&
                          workItemTable.RefRecId == _expenseLineRecId &&
                          workItemTable.Status == WorkflowWorkItemStatus::Pending;

        return (workItemTable.RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAutoPostingWorkflow</Name>
				<Source><![CDATA[
    public static WorkflowVersionTable getAutoPostingWorkflow(TableId tableId, RecId recId)
    {
        return Workflow::findWorkflowConfigToActivateForType(TrvWorkflowUtilities::getAutoPostingWorkflowType(tableId), recId, tableId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAutoPostingWorkflowType</Name>
				<Source><![CDATA[
    public static str getAutoPostingWorkflowType(TableId tableId)
    {
        str workflowType;

        if (tableId == tableNum(TrvExpTable))
        {
            workflowType = #DocumentPostingWorkflowType;
        }
        else
        {
            workflowType = #LineItemPostingWorkflowType;
        }

        return workflowType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertWorkflowLog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a record into the <c>TrvWorkflowLog</c> table.
    /// </summary>
    /// <param name="_actionType">
    /// The work item action type of the current workflow.
    /// </param>
    /// <param name="_workflowEnabledRecord">
    /// A <c>Common</c> record that is located in either the <c>TrvExpTable</c> or the <c>TrvExpTrans</c>
    /// table.
    /// </param>
    public static void insertWorkflowLog(WorkflowWorkItemActionType _actionType, Common _workflowEnabledRecord)
    {
        TrvWorkflowLog trvWorkflowLog;
        TrvWorkflowAction action;
        FieldId fieldIdExpNumber;

        //insert into workflow log only if the work item is an expense header or an expense line
        if (_workflowEnabledRecord.TableId == tableNum(TrvExpTable) || _workflowEnabledRecord.TableId == tableNum(TrvExpTrans))
        {
            if (_actionType == WorkflowWorkItemActionType::Complete || _actionType == WorkflowWorkItemActionType::Return)
            {
                ttsbegin;

                if (_actionType == WorkflowWorkItemActionType::Complete)
                {
                    trvWorkflowLog.ApprovedByWorker = HcmWorkerLookup::currentWorker();
                    trvWorkflowLog.ApprovedDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                    action = TrvWorkflowAction::Approve;
                }
                else if (_actionType == WorkflowWorkItemActionType::Return)
                {
                    trvWorkflowLog.RejectedByWorker = HcmWorkerLookup::currentWorker();
                    trvWorkflowLog.RejectedDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                    action = TrvWorkflowAction::Return;
                }

                if (_workflowEnabledRecord.TableId == tableNum(TrvExpTable))
                {
                    fieldIdExpNumber = fieldNum(TrvExpTable, ExpNumber);
                    trvWorkflowLog.ExpHeaderRecId = _workflowEnabledRecord.RecId;
                    trvWorkflowLog.ApprovalLevel = TrvApprovalLevel::Document;
                }
                else
                {
                    fieldIdExpNumber = fieldNum(TrvExpTrans, ExpNumber);
                    trvWorkflowLog.ExpLineRecId = _workflowEnabledRecord.RecId;
                    trvWorkflowLog.ExpHeaderRecId = _workflowEnabledRecord.(fieldNum(TrvExpTrans, TrvExpTable));
                    trvWorkflowLog.ApprovalLevel = TrvApprovalLevel::LineItem;
                }

                trvWorkflowLog.ExpNumber = _workflowEnabledRecord.(fieldIdExpNumber);

                trvWorkflowLog.insert();

                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateExpMobileWorkflowNotification</Name>
				<Source><![CDATA[
    public static void generateExpMobileWorkflowNotification(TrvExpMobileNotificationEventType _eventType, TableId _refTableId, RefRecId _refRecId, UserId _notifiedUser='')
    {
        Common referenceRecord;
        int approvalStatusField = fieldName2Id(_refTableId, "ApprovalStatus");
        if(_refTableId == tableNum(TrvExpTable))
        {
            referenceRecord = TrvExpTable::findRecId(_refRecId);
        }
        else if (_refTableId == tableNum(TrvExpTrans))
        {
            referenceRecord = TrvExpTrans::find(_refRecId);
        }
        else
        {
            return;
        }

        if(_eventType == TrvExpMobileNotificationEventType::WorkItemAssigned && referenceRecord.(approvalStatusField) == TrvAppStatus::Returned)
        {
            _eventType = TrvExpMobileNotificationEventType::WorkItemReturned;
        }

        TrvExpenseHelper::generateExpMobileNotification(_eventType, referenceRecord, _notifiedUser);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDocumentStateChangeValid</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the document status can be changed.
    /// </summary>
    /// <param name="oldStatus">
    ///    The old document status.
    /// </param>
    /// <param name="newStatus">
    ///    The new document status.
    /// </param>
    /// <param name="tableId">
    ///    The table context when document status is changing. If the table is <c>TrvExpTrans</c>, it may be
    ///    changing status of a whole expense report. Then we have to change the status from approved to
    ///    created.
    /// </param>
    /// <returns>
    ///    true if the status change is valid; otherwise, false.
    /// </returns>
    public static boolean isDocumentStateChangeValid(TrvAppStatus oldStatus, TrvAppStatus newStatus, TableId tableId = 0)
    {
        boolean valid = true;

        if (oldStatus == newStatus)
        {
            return true;
        }

        switch (newStatus)
        {
            case TrvAppStatus::Create:
                if (tableId == tableNum(TrvExpTrans))
                {
                    valid = oldStatus == TrvAppStatus::Pending ||
                            oldStatus == TrvAppStatus::Returned ||
                            oldStatus == TrvAppStatus::Approved;
                }
                else
                {
                    valid = oldStatus == TrvAppStatus::Pending ||
                            oldStatus == TrvAppStatus::Returned;
                }
                break;

            case TrvAppStatus::Pending:
                valid = oldStatus == TrvAppStatus::Create ||
                        oldStatus == TrvAppStatus::Returned;
                break;

            case TrvAppStatus::Returned:
            case TrvAppStatus::Approved:
                valid = oldStatus == TrvAppStatus::Pending;
                break;
        }

        return valid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLineItemApprovalConfigured</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the line item approval is configured for the specified root correlation ID.
    /// </summary>
    /// <param name="_rootCorrelationId">
    /// The correlation ID.
    /// </param>
    /// <returns>
    /// true if the line item approval is configured for the specified root correlation ID; otherwise,
    /// false.
    /// </returns>
    public static boolean isLineItemApprovalConfigured(WorkflowCorrelationId _rootCorrelationId)
    {
        SysWorkflowTable workflowTable = SysWorkflowTable::find(_rootCorrelationId);

        return TrvWorkflowUtilities::isLineItemApprovalForSysWorkflowTable(workflowTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLineItemApprovalForExpenseReport</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether line item approval is configured for an Expense report.
    /// </summary>
    /// <param name = "_trvExptableRecId">The expense report for which the check is performed.</param>
    /// <returns>true if line item approval is configured; otherwise, false.</returns>
    public static boolean isLineItemApprovalForExpenseReport(RecId _trvExptableRecId)
    {
        SysWorkflowTable        workflowTable;

        select firstonly RecId, ConfigurationId from workflowTable
                where workflowTable.ContextTableId == tableNum(TrvExpTable)
                   && workflowTable.ContextRecId   == _trvExptableRecId;

        return TrvWorkflowUtilities::isLineItemApprovalForSysWorkflowTable(workflowTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLineItemApprovalForTravelReq</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether line item approval is configured for a travel requisition.
    /// </summary>
    /// <param name = "_trvTravelReqRecId">The travel requisition record for which the check is performed.</param>
    /// <returns>true if line item approval is configured for the travel req; otherwise, false.</returns>
    public static boolean isLineItemApprovalForTravelReq(RecId _trvTravelReqRecId)
    {
        SysWorkflowTable        workflowTable;

        select firstonly RecId, ConfigurationId from workflowTable
                where workflowTable.ContextTableId == tableNum(TrvRequisitionTable)
                   && workflowTable.ContextRecId   == _trvTravelReqRecId;

        return TrvWorkflowUtilities::isLineItemApprovalForSysWorkflowTable(workflowTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLineItemApprovalForSysWorkflowTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the line item approval is configured for the specified workflow table record.
    /// </summary>
    /// <param name="_workflowTable">
    /// The <c>SysWorkflowTable</c> record.
    /// </param>
    /// <returns>
    /// true if the line item approval is configured for the specified workflow table record; otherwise,
    /// false.
    /// </returns>
    private static boolean isLineItemApprovalForSysWorkflowTable(SysWorkflowTable _workflowTable)
    {
        WorkflowVersionTable    versionTable;
        WorkflowSubWorkflow     subWorkflow;

        if (_workflowTable.RecId)
        {
            select RecId, ConfigurationId from versionTable
                join RecId, WorkflowVersionTable from subWorkflow
                    where versionTable.RecId == subWorkflow.WorkflowVersionTable
                        && subWorkflow.ElementType == WorkflowElementType::LineItemWorkflow
                        && versionTable.ConfigurationId == _workflowTable.ConfigurationId;
        }

        return (versionTable.RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordHasActiveWorkItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether a record buffer has a pending or active workflow work item.
    /// </summary>
    /// <param name="common">
    ///    The record buffer that the method will check for an active workflow work item.
    /// </param>
    /// <returns>
    ///    true if the record has an existing workflow item; otherwise, false.
    /// </returns>
    public static boolean recordHasActiveWorkItem(Common common)
    {
        WorkflowWorkItemTable workItemTable;

        select firstonly RecId from workItemTable
                    where workItemTable.RefTableId == common.TableId &&
                          workItemTable.RefRecId == common.RecId &&
                          workItemTable.Status == WorkflowWorkItemStatus::Pending;

        if (workItemTable.RecId)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordHasLineItemApproval</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the current record buffer has line item approval configured.
    /// </summary>
    /// <param name="common">
    ///    The record buffer to check
    /// </param>
    /// <returns>
    ///    true if record has line item approval; otherwise, false.
    /// </returns>
    public static boolean recordHasLineItemApproval(Common common)
    {
        SysWorkflowTable workflowTable;
        WorkflowCorrelationId rootCorrelationId;

        select firstonly RecId, RootCorrelationId, ConfigurationId, WorkflowCorrelationId from workflowTable
                         where workflowTable.ContextTableId == common.TableId &&
                               workflowTable.ContextRecId == common.RecId;

        if (workflowTable.RecId)
        {
            if (common.TableId == tableNum(TrvExpTrans))
            {
                // find the workflow table for the expense report
                rootCorrelationId = workflowTable.RootCorrelationId;
                workflowTable.clear();
                workflowTable = SysWorkflowTable::find(rootCorrelationId);
            }

            return TrvWorkflowUtilities::isLineItemApprovalForSysWorkflowTable(workflowTable);
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeTrvAccountingDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Remove the expense accounting distributions for given expense report.
    /// </summary>
    /// <param name="_trvExpTable">
    /// The current <c>TrvExpTable</c> record.
    /// </param>
    /// <remarks>
    /// The expense accounting distributions gets removed for given expense report.
    /// </remarks>
    public static void removeTrvAccountingDistributions(TrvExpTable _trvExpTable)
    {
        TrvAccountingDistribution   trvAccountingDistribution;
        AccountingDistribution      accountingDistribution;
        RefRecId                    sourceDocRecId;

        sourceDocRecId = _trvExpTable.SourceDocumentHeader;

        // Retrieve the SourceDocumentHeader if it is not available, as full buffer of trvExpTable will not be available in few workflow scenarios
        if (_trvExpTable.RecId != 0 && sourceDocRecId == 0)
        {
            sourceDocRecId = TrvExpTable::findRecId(_trvExpTable.recId).SourceDocumentHeader;
        }

        delete_from trvAccountingDistribution
            exists join accountingDistribution
                where accountingDistribution.RecId == trvAccountingDistribution.AccountingDistribution
                   && accountingDistribution.SourceDocumentHeader == sourceDocRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDocumentToPosted</Name>
				<Source><![CDATA[
    public static void setDocumentToPosted(RefRecId _trvExpTableRecId)
    {
        TrvExpTrans trvExpTrans,
                    headerTrvExpTrans,
                    headerTrvExpTransChild;
        TrvExpTable trvExpTable;

        select RecId from trvExpTrans where trvExpTrans.TrvExpTable == _trvExpTableRecId
                                         && trvExpTrans.ApprovalStatus != TrvAppStatus::Ledger
                                         && trvExpTrans.ApprovalStatus != TrvAppStatus::Create // these are the lines that were rejected/recalled
                                         && trvExpTrans.LineType != TrvExpLineType::ItemizedHeader
                                         && trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader;

        if (trvExpTrans.RecId == 0)
        {
            select forupdate ApprovalStatus,RecId from trvExpTable where trvExpTable.RecId == _trvExpTableRecId;
            Debug::assert(trvExpTable.RecId != 0);

            if (trvExpTable.ApprovalStatus == TrvAppStatus::Approved)
            {
                trvExpTable.ApprovalStatus = TrvAppStatus::Ledger;
                trvExpTable.doUpdate();

                // When Auto posting workflow is enabled, Itemized header was not updated after posting of all lines
                // Changing the status of itemized header to Process for payment
                update_recordSet headerTrvExpTrans
                    setting ApprovalStatus = TrvAppStatus::Ledger
                        where headerTrvExpTrans.TrvExpTable == trvExpTable.RecId
                        exists join headerTrvExpTransChild
                            where headerTrvExpTransChild.ParentRecId == headerTrvExpTrans.RecId
                                && headerTrvExpTransChild.ApprovalStatus == TrvAppStatus::Ledger;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetUnpostedExpenseLines</Name>
				<Source><![CDATA[
    public static void resetUnpostedExpenseLines(RefRecId _trvExpTableRecId)
    {
        // Reset unposted expense lines to draft status.
        TrvWorkflowUtilities::resetUnpostedExpenseLinesToDraft(_trvExpTableRecId);

        // Detach unposted expense lines from the report.
        TrvWorkflowUtilities::detachUnpostedExpenseLinesFromReport(_trvExpTableRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetUnpostedExpenseLinesToDraft</Name>
				<Source><![CDATA[
    public static void resetUnpostedExpenseLinesToDraft(RefRecId _trvExpTableRecId)
    {
        TrvExpTrans trvExpTrans;
        
        ttsbegin;
        update_recordset trvExpTrans setting ApprovalStatus = TrvAppStatus::Create
            where trvExpTrans.TrvExpTable == _trvExpTableRecid
            && trvExpTrans.ApprovalStatus != TrvAppStatus::Ledger;
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>detachUnpostedExpenseLinesFromReport</Name>
				<Source><![CDATA[
    public static void detachUnpostedExpenseLinesFromReport(RefRecId _trvExpTableRecId)
    {
        TrvExpTrans trvExpTrans;

        ttsbegin;
        while select forupdate trvExpTrans
            where trvExpTrans.TrvExpTable == _trvExpTableRecId
            && trvExpTrans.ApprovalStatus == TrvAppStatus::Create
        {
            trvExpTrans.updateExpenseReport("");
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDocumentToPostedForPostedLines</Name>
				<Source><![CDATA[
    public static void setDocumentToPostedForPostedLines(RefRecId _trvExpTableRecId)
    {
        if (_trvExpTableRecId)
        {
            TrvExpTrans trvExpTrans;
            TrvExpTable trvExpTable;

            // Only set document to 'Posted' when all lines are already posted.
            ttsbegin;
            update_recordset trvExpTable
                setting ApprovalStatus = TrvAppStatus::Ledger
                where trvExpTable.RecId == _trvExpTableRecId
                notexists join trvExpTrans
            where trvExpTrans.TrvExpTable == _trvExpTableRecId
            && trvExpTrans.ApprovalStatus != TrvAppStatus::Ledger;
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setExpenseDocumentStatusInternal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the state of an expense document.
    /// </summary>
    /// <param name="workflowContext">
    ///    The parameter from a workflow event.
    /// </param>
    /// <param name="approvalStatus">
    ///    The new state that will be set to the expense document record.
    /// </param>
    private static void setExpenseDocumentStatusInternal(WorkflowContext workflowContext, TrvAppStatus approvalStatus)
    {
        TrvExpTable trvExpTable;
        TrvExpTrans trvExpTrans;
        TrvExpTrans headerTrvExpTrans, headerTrvExpTransChild;
        WorkflowVersionTable versionTable;
        TrvPostingErrors genericError = "@SYS328166";
        boolean isLineItemApprovalConfigured = false;

        select forupdate RecId, ApprovalStatus from trvExpTable where trvExpTable.RecId == workflowContext.parmRecId();
        trvExpTrans.skipDataMethods(true);

        ttsbegin;
        isLineItemApprovalConfigured = TrvWorkflowUtilities::isLineItemApprovalConfigured(workflowContext.parmRootCorrelationId());
        if (trvExpTable.RecId)
        {
            if (trvExpTable.ApprovalStatus != approvalStatus)
            {
                if (!TrvWorkflowUtilities::isDocumentStateChangeValid(trvExpTable.ApprovalStatus, approvalStatus))
                {
                    throw error(strFmt("@SYS108515",trvExpTable.ApprovalStatus, approvalStatus));
                }

                str logMessage = strFmt("Expense Report Status change: Expense Report %1, Previous Status: %2, New Status: %3", trvExpTable.RecId, trvExpTable.ApprovalStatus, approvalStatus);
                TrvInstrumentationHelper::logExpenseOperationsInformation(logMessage, classStr(TrvWorkflowUtilities));
                trvExpTable.ApprovalStatus = approvalStatus;
                trvExpTable.doUpdate();
            }

            if (!isLineItemApprovalConfigured)
            {
                str logMessage = strFmt("Expense lines Status bulk update: Expense Report %1", trvExpTable.RecId);
                TrvInstrumentationHelper::logExpenseOperationsInformation(logMessage, classStr(TrvWorkflowUtilities));
                TransDate approvedDate;
                TransDate rejectedDate;

                if(approvalStatus == TrvAppStatus::Approved)
                {
                    approvedDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                    rejectedDate = dateNull();
                }
                else if(approvalStatus == TrvAppStatus::Returned)
                {
                    rejectedDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                }
                update_recordset trvExpTrans setting ApprovalStatus = approvalStatus, ApprovedDate = approvedDate, NotApprovedDate = rejectedDate where trvExpTrans.TrvExpTable == trvExpTable.RecId;
            }
            else
            {
                // If the user tries to cancel the document but lines have been posted,
                // throw an error
                // we dont allow canceling of documents if any of the lines have been posted
                if (approvalStatus == TrvAppStatus::Create)
                {
                    select firstonly RecId from trvExpTrans where trvExpTrans.TrvExpTable == trvExpTable.RecId &&
                                                                  trvExpTrans.ApprovalStatus == TrvAppStatus::Ledger;

                    if (trvExpTrans.RecId > 0)
                    {
                        throw error("@SYS317191");
                    }
                    else
                    {
                        str logMessage = strFmt("Expense lines Status bulk update: Expense Report %1", trvExpTable.RecId);
                        TrvInstrumentationHelper::logExpenseOperationsInformation(logMessage, classStr(TrvWorkflowUtilities));
                        update_recordset trvExpTrans setting ApprovalStatus = approvalStatus where trvExpTrans.TrvExpTable == trvExpTable.RecId &&
                                                                                                    trvExpTrans.ApprovalStatus != approvalStatus;
                    }
                }

                // if line workflow is configured and there is itemized lines
                // then we need to update itemized header after updating the expense report header
                if (trvExpTable.ApprovalStatus == TrvAppStatus::Approved)
                {
                    headerTrvExpTrans.skipDataMethods(true);
                    // set header to approved if there is at least one child line that is approved
                    update_recordSet headerTrvExpTrans
                        setting ApprovalStatus = approvalStatus
                            where headerTrvExpTrans.TrvExpTable == trvExpTable.RecId
                               && headerTrvExpTrans.LineType == TrvExpLineType::ItemizedHeader
                            exists join headerTrvExpTransChild
                                where headerTrvExpTransChild.ParentRecId == headerTrvExpTrans.RecId
                                   && (headerTrvExpTransChild.ApprovalStatus == TrvAppStatus::Approved
                                        || headerTrvExpTransChild.ApprovalStatus == TrvAppStatus::Ledger);

                    update_recordset headerTrvExpTrans
                        setting ApprovalStatus = approvalStatus
                            where headerTrvExpTrans.TrvExpTable == trvExpTable.RecId
                                && headerTrvExpTrans.SplitLineType == TrvExpSplitLineType::SplitHeader
                            exists join headerTrvExpTransChild
                                where headerTrvExpTransChild.ParentRecId == headerTrvExpTrans.RecId
                                    && (headerTrvExpTransChild.ApprovalStatus == TrvAppStatus::Approved
                                        || headerTrvExpTransChild.ApprovalStatus == TrvAppStatus::Ledger);

                    // set header to draft, if all child lines are in draft state
                    update_recordSet headerTrvExpTrans
                        setting ApprovalStatus = TrvAppStatus::Create
                            where headerTrvExpTrans.TrvExpTable == trvExpTable.RecId
                               && headerTrvExpTrans.LineType == TrvExpLineType::ItemizedHeader
                            notexists join headerTrvExpTransChild
                                where headerTrvExpTransChild.ParentRecId == headerTrvExpTrans.RecId
                                   && headerTrvExpTransChild.ApprovalStatus != TrvAppStatus::Create;

                    update_recordSet headerTrvExpTrans
                        setting ApprovalStatus = TrvAppStatus::Create
                            where headerTrvExpTrans.TrvExpTable == trvExpTable.RecId
                               && headerTrvExpTrans.SplitLineType == TrvExpSplitLineType::SplitHeader
                            notexists join headerTrvExpTransChild
                                where headerTrvExpTransChild.ParentRecId == headerTrvExpTrans.RecId
                                   && headerTrvExpTransChild.ApprovalStatus != TrvAppStatus::Create;
                }
            }

            if (trvExpTable.ApprovalStatus == TrvAppStatus::Approved)
            {
                TrvExpTrans trvExpTransStatus;
                select firstonly RecId from trvExpTransStatus
                   where trvExpTransStatus.TrvExpTable == trvExpTable.RecId
                      && trvExpTransStatus.ApprovalStatus != TrvAppStatus::Create;

                // Set expense header workflow status to draft, if all expense lines are in draft state
                if (!trvExpTransStatus.RecId)
                {
                    trvExpTable.ApprovalStatus = TrvAppStatus::Create;
                    trvExpTable.update();

                    approvalStatus = trvExpTable.ApprovalStatus;
                }
                else if (!isLineItemApprovalConfigured)
                {
                    // Generate committed costs for the Expense report
                    trvExpTable.postApprove(trvExpTable.RecId);
                }
            }

            if (approvalStatus == TrvAppStatus::Approved)
            {
                versionTable = TrvWorkflowUtilities::getAutoPostingWorkflow(workflowContext.parmTableId(), workflowContext.parmRecId());

                if (versionTable.RecId && TrvWorkflowUtilities::canActivateAutoPostingWorkflow(versionTable, workflowContext.parmTableId(), workflowContext.parmRecId()))
                {
                    // If the autoposting workflow throws an error, then this will be retain
                    // otherwise, we're clearing it when posting is successful
                    update_recordset trvExpTrans setting PostingErrors = genericError where trvExpTrans.TrvExpTable == trvExpTable.RecId;

                    Workflow::activateFromWorkflowConfigurationId(versionTable.ConfigurationId, workflowContext.parmRecId(), '', NoYes::No);
                }

                // Check if all lines have been Posted, change the state of the header to Posted
                TrvWorkflowUtilities::setDocumentToPosted(workflowContext.parmRecId());
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setExpenseDocumentStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Called when you want to change the state of an expense document.
    /// </summary>
    /// <param name="workflowContext">
    ///    The parameter from a workflow event.
    /// </param>
    /// <param name="approvalStatus">
    ///    The new state that will be set to the expense document record.
    /// </param>
    /// <remarks>
    ///    This method will check if line item approval is configured for the current work item. If not, it
    ///    will try to change the state of all the expense lines included in that expense document.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    ///    An exception will be thrown when the state is draft, which would indicate that the document is
    ///    about to be canceled and there are lines that have been posted to the ledger.
    /// </exception>
    public static void setExpenseDocumentStatus(WorkflowContext workflowContext, TrvAppStatus approvalStatus = TrvAppStatus::None)
    {
        str logMessage = strFmt("Set Expense Document Status: Expense report %1, Approval Status %2", workflowContext.parmRecId(), approvalStatus);
        TrvInstrumentationHelper::logExpenseOperationsInformation(logMessage, classStr(TrvWorkflowUtilities));

        // Catch the exception. If it is update conflict, retry. Else rethrow the error.
        try
        {
            boolean currentCompanyDifferentThanExpenseCompany = false;
            DataAreaId expenseLegalEntity;
            [currentCompanyDifferentThanExpenseCompany,expenseLegalEntity] = TrvExpenseHelper::isCurrentCompanyDifferentThanExpenseCompany(workflowContext.parmRecId());
            
            if(currentCompanyDifferentThanExpenseCompany)
            {
                changecompany(expenseLegalEntity)
                {
                    TrvWorkflowUtilities::setExpenseDocumentStatusInternal(workflowContext, approvalStatus);
                }
            }
            else
            {
                TrvWorkflowUtilities::setExpenseDocumentStatusInternal(workflowContext, approvalStatus);
            }
        }
        catch(Exception::Deadlock)
        {
            logMessage = strFmt("@Expense:ExpenseUpdateExceptionLog", "Deadlock", workflowContext.parmRecId());
            TrvInstrumentationHelper::logExpenseOperationsInformation(logMessage, classStr(TrvWorkflowUtilities));
            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::UpdateConflictNotRecovered;
            }
            else
            {
                logMessage = strFmt("@Expense:ExpenseUpdateExceptionLog", "Conflict", workflowContext.parmRecId());
                TrvInstrumentationHelper::logExpenseOperationsInformation(logMessage, classStr(TrvWorkflowUtilities));
                retry;
            }
        }
        catch(Exception::Error)
        {
            throw Exception::Error;
        }

        TrvExpCashAdvanceMappingHelper::populateMappingForExpenseReport(workflowContext.parmRecId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>setExpenseLineItemStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Called when you want to change status of an expense line item.
    /// </summary>
    /// <param name="workflowContext">
    ///    The workflow context from the corresponding workflow event handler.
    /// </param>
    /// <param name="approvalStatus">
    ///    The new state that will be set in the expense line.
    /// </param>
    public static void setExpenseLineItemStatus(WorkflowContext workflowContext, TrvAppStatus approvalStatus = TrvAppStatus::None)
    {
        TrvExpTrans             trvExpTrans;
        WorkflowVersionTable    versionTable;
        TrvPostingErrors        genericError = "@SYS328166";

        select forupdate RecId, ApprovalStatus,SourceDocumentLine from trvExpTrans where trvExpTrans.RecId == workflowContext.parmRecId();

        if (trvExpTrans.RecId && trvExpTrans.ApprovalStatus != approvalStatus)
        {
            if (!TrvWorkflowUtilities::isDocumentStateChangeValid(trvExpTrans.ApprovalStatus, approvalStatus, tableNum(TrvExpTrans)))
            {
                throw error(strFmt("@SYS108515",trvExpTrans.ApprovalStatus, approvalStatus));
            }

            if (trvExpTrans.ApprovalStatus != TrvAppStatus::Ledger)
            {
                trvExpTrans.ApprovalStatus = approvalStatus;

                if(approvalStatus == TrvAppStatus::Returned)
                {
                    trvExpTrans.NotApprovedDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                }
                trvExpTrans.doUpdate();

                // Generate committed costs for the Expense report
                if (trvExpTrans.ApprovalStatus == TrvAppStatus::Approved)
                {
                    trvExpTrans.postApprove(trvExpTrans.RecId);
                }

                if (approvalStatus == TrvAppStatus::Approved)
                {
                    versionTable = TrvWorkflowUtilities::getAutoPostingWorkflow(workflowContext.parmTableId(), workflowContext.parmRecId());

                    if (versionTable.RecId && TrvWorkflowUtilities::canActivateAutoPostingWorkflow(versionTable, workflowContext.parmTableId(), workflowContext.parmRecId()))
                    {                       
                        select forupdate RecId,PostingErrors from trvExpTrans where trvExpTrans.RecId == workflowContext.parmRecId();
                        trvExpTrans.PostingErrors = genericError;
                        trvExpTrans.ApprovedDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                        trvExpTrans.NotApprovedDate = dateNull();
                        trvExpTrans.doUpdate();

                        Workflow::activateFromWorkflowConfigurationId(versionTable.ConfigurationId, workflowContext.parmRecId(), '', NoYes::No);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateViolationsLog</Name>
				<Source><![CDATA[
    public static void updateViolationsLog(RecId _recId, TrvWorkflowAction _action, boolean _isHeader)
    {
        TrvPolicyViolationsLog policyLog;

        if (_isHeader)
        {
            if (!TrvWorkflowUtilities::isLineItemApprovalForExpenseReport(_recId))
            {
                update_recordset policyLog setting Action = _action
                    where policyLog.Header == _recId
                       && policyLog.Action == TrvWorkflowAction::Submit;
            }
            else
            {
                update_recordset policyLog setting Action = _action
                    where policyLog.Header == _recId
                       && policyLog.Line   == 0
                       && policyLog.Action == TrvWorkflowAction::Submit;
            }
        }
        else
        {
            update_recordset policyLog setting Action = _action
                where policyLog.Line == _recId
                   && policyLog.Action == TrvWorkflowAction::Submit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>workflowTypeHasLineItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks the expense document workflow type if line item is configured.
    /// </summary>
    /// <param name="_expenseHeaderRecId">
    ///    The record ID of an existing expense report.
    /// </param>
    /// <returns>
    ///    true if the active workflow for the workflow type has line item configured; otherwise, false
    /// </returns>
    public static boolean workflowTypeHasLineItem(RefRecId _expenseHeaderRecId)
    {
        WorkflowVersionTable versionTable = Workflow::findWorkflowConfigToActivateForType(workFlowTypeStr(TrvDocumentTemplate), _expenseHeaderRecId, tableNum(TrvExpTable));
  
        return TrvWorkflowUtilities::workflowVersionOrNestedWorkflowHasLineItem(versionTable.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>workflowVersionOrNestedWorkflowHasLineItem</Name>
				<Source><![CDATA[
    private static boolean workflowVersionOrNestedWorkflowHasLineItem(RefRecId _workflowVersionRecId)
    {
        WorkflowSubWorkflow subWorkflow;

        if (_workflowVersionRecId == 0)
        {
            return false;
        }
  
        // Check for a direct line item
        select RecId, WorkflowVersionTable, ElementType from subWorkflow where
            subWorkflow.WorkflowVersionTable == _workflowVersionRecId &&
            subWorkflow.ElementType == WorkflowElementType::LineItemWorkflow;

        if (subWorkflow.RecId != 0)
        {
            return true;
        }
        else
        {
            // A workflow can have one or more subworkflows - check to see if any subworkflow has a line item element
            while select RecId, WorkflowVersionTable, WorkflowTable, ElementType from subWorkflow where
                subWorkflow.WorkflowVersionTable == _workflowVersionRecId &&
                subWorkflow.ElementType == WorkflowElementType::Subworkflow
            {
                WorkflowVersionTable version = subWorkflow.workflowTable().getActiveVersion();

                if (TrvWorkflowUtilities::workflowVersionOrNestedWorkflowHasLineItem(version.RecId))
                {
                    return true;
                }
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>workflowContextDataAreaId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>dataAreaId</c> context to use for the execution of a workflow.
    /// </summary>
    /// <param name="_tableId">
    /// The table ID of the record.
    /// </param>
    /// <param name="_recId">
    /// The record ID of the record.
    /// </param>
    /// <returns>
    /// The <c>dataAreaId</c> context to use for the execution of a workflow.
    /// </returns>
    public static DataAreaId workflowContextDataAreaId(TableId _tableId, RecId _recId)
    {
        TrvExpTable             trvExpTable;
        TrvExpTrans             trvExpTrans;
        TrvRequisitionTable     trvRequisitionTable;
        LegalEntityRecId        legalEntityRecId;
        DataAreaId              dataAreaId;

        if (_tableId == tableNum(TrvExpTable))
        {
            select firstOnly LegalEntity from trvExpTable where trvExpTable.RecId == _recId;
            legalEntityRecId = trvExpTable.LegalEntity;
        }
        else if (_tableId == tableNum(TrvExpTrans))
        {
            select firstOnly LegalEntity from trvExpTrans where trvExpTrans.RecId == _recId;
            legalEntityRecId = trvExpTrans.LegalEntity;
        }
        else if (_tableId == tableNum(TrvRequisitionTable))
        {
            select firstOnly LegalEntity from trvRequisitionTable where trvRequisitionTable.RecId == _recId;
            legalEntityRecId = trvRequisitionTable.LegalEntity;
        }

        if (legalEntityRecId)
        {
            dataAreaId = CompanyInfo::findRecId(legalEntityRecId).DataArea;
        }

        if (dataAreaId == '')
        {
            dataAreaId = curext();
        }

        return dataAreaId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCurUserExpenseApprover</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the current user has a pending active workflow work item for expense report or lines.
    /// </summary>
    /// <param name="_expenseReport">
    /// The record of <c>TrvExpTable</c>.
    /// </param>
    /// <returns>
    /// True if the current user has an existing workflow item for expense report or lines; otherwise, false.
    /// </returns>
    public static boolean isCurUserExpenseApprover(TrvExpTable _expenseReport)
    {
        TrvExpTrans             trvExpTrans;
        WorkflowWorkItemTable   workflowWorkItemTable;
        WorkflowElementTable    workflowElementTable;

        if (WorkflowWorkItem::isUserApprovalOwner(_expenseReport) || WorkflowWorkItem::isUserTaskOwner(_expenseReport))
        {
            // First check if expense report is assigned to current user.
            return true;
        }
        else
        {
            // Then check if any expense line is assigned to current user.
            select firstonly RecId, ElementId from workflowWorkItemTable
                    where   workflowWorkItemTable.RefTableId == tableNum(TrvExpTrans) &&
                            workflowWorkItemTable.UserId     == curUserId() &&
                            workflowWorkItemTable.Status     == WorkflowWorkItemStatus::Pending &&
                            workflowWorkItemTable.IsClaimed  == true
                join ElementId, ElementType from workflowElementTable
                    where   workflowElementTable.ElementId   == workflowWorkItemTable.ElementId &&
                            workflowElementTable.ElementType == WorkflowElementType::Approval
                join trvExpTrans
                    where   trvExpTrans.RecId                == workflowWorkItemTable.RefRecId &&
                            trvExpTrans.TrvExpTable          == _expenseReport.RecId;

            return workflowWorkItemTable.RecId != 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCurUserRequisitionApprover</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the current user has a pending active workflow work item for travel requisition or lines.
    /// </summary>
    /// <param name="_requisitionTable">
    /// The record of <c>TrvRequisitionTable</c>.
    /// </param>
    /// <returns>
    /// True if the current user has an existing workflow item for travel requisition or lines; otherwise, false.
    /// </returns>
    public static boolean isCurUserRequisitionApprover(TrvRequisitionTable _requisitionTable)
    {
        TrvRequisitionLine      trvReqLine;
        WorkflowWorkItemTable   workflowWorkItemTable;
        WorkflowElementTable    workflowElementTable;

        if (WorkflowWorkItem::isUserApprovalOwner(_requisitionTable))
        {
            // First check if travel requisition is assigned to current user.
            return true;
        }
        else
        {
            // Then check if any expense line is assigned to current user.
            select firstonly RecId, ElementId from workflowWorkItemTable
                where workflowWorkItemTable.RefTableId == tableNum(TrvExpTrans) &&
                    workflowWorkItemTable.UserId == curUserId() &&
                    workflowWorkItemTable.Status == WorkflowWorkItemStatus::Pending &&
                    workflowWorkItemTable.IsClaimed == true
                join ElementId, ElementType from workflowElementTable
                    where workflowElementTable.ElementId == workflowWorkItemTable.ElementId &&
                        workflowElementTable.ElementType == WorkflowElementType::Approval
                join trvReqLine
                    where trvReqLine.RecId == workflowWorkItemTable.RefRecId &&
                        trvReqLine.TrvRequisitionTable == _requisitionTable.RecId;

            return workflowWorkItemTable.RecId != 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addWorkflowContextToInterimApprovers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the workflow correlation ID to all records in the <c>TrvInterimApprover</c> table that exist
    /// for the expense report.
    /// </summary>
    /// <param name = "workflowContext">The workflow context.</param>
    public static void addWorkflowContextToInterimApprovers(WorkflowContext workflowContext)
    {
        TrvInterimApprover interimApprover;

        ttsbegin;

        while select forupdate interimApprover
            where interimApprover.WorkflowContextRecId == workflowContext.parmRecId()
        {
            interimApprover.WorkflowCorrelationId = workflowContext.parmWorkflowCorrelationId();
            // set the current approver flag for the index = 1 record
            if (interimApprover.ApproverOrder == 1)
            {
                interimApprover.IsCurrentApprover = NoYes::Yes;
            }
            interimApprover.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isHeaderWorkflowContainingApprovalStep</Name>
				<Source><![CDATA[
    /// <summary>
    /// Identifies whether header workflow has approval step configured.
    /// </summary>
    /// <param name = "_workflowWorkItem">
    /// <c>WorkflowWorkItemTable</c> record details of the line level workflow.
    /// </param>
    /// <returns>
    /// True if the header workflow contains approval step; otherwise, false.
    /// </returns>
    public static boolean isHeaderWorkflowContainingApprovalStep(WorkflowWorkItemTable _workflowWorkItem)
    {
        WorkflowElementTable	workflowElementTable;
        SysWorkflowTable		sysWorkflowTable = SysWorkflowTable::find(_workflowWorkItem.RootCorrelationId);

        select RecId from workflowElementTable
            where workflowElementTable.ConfigurationId == sysWorkflowTable.ConfigurationId
                && workflowElementTable.ElementType == WorkflowElementType::Approval;

        return workflowElementTable.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelTrvDocumentTemplateHeaderWorkflow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancels the expense document header workflow.
    /// </summary>
    /// <param name = "_trvExpTrans">
    /// Expense line record details.
    /// </param>
    public static void cancelTrvDocumentTemplateHeaderWorkflow(TrvExpTrans _trvExpTrans)
    {
        TrvExpTable						trvExpTable;
        Args							args			= new Args();
        TrvWorkflowControlContext		context			= new TrvWorkflowControlContext();
        WorkflowTrackingStatusTable		workflowTrackingStatusTable;
        
        trvExpTable = TrvExpTable::findRecId(_trvExpTrans.TrvExpTable);

        workflowTrackingStatusTable = Workflow::findTrackingStatusForDocument(trvExpTable);
        context.parmWorkflowTrackingStatusTable(workflowTrackingStatusTable);
        context.parmWorkflowComment("@Expense:AutoCancelLineLevelWorkflowMessage");

        args.record(trvExpTable);
        args.parmObject(context);
        TrvWorkflowCancelManager::main(args);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSourceDocumentLineItemListForReset</Name>
				<Source><![CDATA[
    private static SourceDocumentLineImplementationList getSourceDocumentLineItemListForReset(SourceDocumentHeaderRecId _sourceDocumentHeaderRecId)
    {
        SourceDocumentLine sourceDocumentLine;
        SourceDocumentLineImplementation sourceDocumentLineImplementation;

        SourceDocumentLineImplementationList sourceDocumentLineImplementationList = SourceDocumentLineImplementationList::construct();

        while select sourceDocumentLine
            where sourceDocumentLine.SourceDocumentHeader == _sourceDocumentHeaderRecId &&
            sourceDocumentLine.ParentSourceDocumentLine == 0 &&
            sourceDocumentLine.AccountingStatus != SourceDocumentLineAccountingStatus::Canceled &&
            sourceDocumentLine.AccountingStatus != SourceDocumentLineAccountingStatus::Completed &&
            sourceDocumentLine.AccountingStatus != SourceDocumentLineAccountingStatus::Finalized
        {
            if (sourceDocumentLine)
            {
                sourceDocumentLineImplementation = sourceDocumentLine.getSourceDocumentLineImplementation();
                if (sourceDocumentLineImplementation)
                {
                    sourceDocumentLineImplementationList.addEnd(sourceDocumentLineImplementation);
                }
            }
        }

        return sourceDocumentLineImplementationList;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>