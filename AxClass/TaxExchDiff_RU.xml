<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxExchDiff_RU</Name>
	<SourceCode>
		<Declaration><![CDATA[
class TaxExchDiff_RU extends TaxReverseTaxAmountDiff_RU
{
    Factor                  factor;
    CustVendExchAdjParm_W   custVendExchAdjParm;
    CustVendTrans           custVendTrans;
    boolean                 vatAdjustment;
    Map                     sourceTransMap;
    DimensionDefault        dimensionDefault;
    EmplAdvLine_RU          emplAdvLine;
    Set                     taxTransRecIDs;
    LedgerVoucherObject     ledgerVoucherObject;
    boolean                 postToReportingCurrency;
    List                    targetLedgerParmsList;

    boolean                 overrideDefaultDimension;
    boolean                 removeProfitLossDimension;

    TmpTaxTransDefaultDimension_RU taxTransDefaultDimensions;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calcAndInsertTaxes</Name>
				<Source><![CDATA[
    public TaxAmount calcAndInsertTaxes(Voucher _originalvoucher, TransDate _originalTransDate)
    {
        TaxAmount                       taxAmount;
        TaxTrans                        taxTrans;
        LedgerDimensionAccount          taxTransLedgerDimension;
        AmountMST                       totalAmount, totalAmountExclTax;
        ExchAdjTaxableType_W            taxable;
        DimensionDefault                defaultDimension;
        MapEnumerator                   me;
        RecId                           sourceRecId;
        TableId                         sourceTableId;
        Factor                          sourceTransFactor   = 1;
        boolean                         sourceIsNull        = true;
        TmpTaxTransLedgerDimension_RU   tmpTaxTransLedgerDimension;
        // Fraction of the given default dimension
        AllocationFactor                dimensionFactor = 1;
        boolean                         allocateTransactions = dimensionDefault && overrideDefaultDimension && taxTransDefaultDimensions.isFilled();

        DimensionDefault removeProfitLossDimension(DimensionDefault _defaultDimension)
        {
            DimensionAttributeValueSetStorage setStorage;
            DimensionDefault                  ret = _defaultDimension;

            if (removeProfitLossDimension && _defaultDimension)
            {
                setStorage = DimensionAttributeValueSetStorage::find(_defaultDimension);
                setStorage.removeDimensionAttribute(RTax25Parameters::find().DimensionAttribute);
                ret = setStorage.save();
            }

            return ret;
        }

        LedgerDimensionAccount overrideDefaultDimension(LedgerDimensionAccount _ledgerDimension)
        {
            return overrideDefaultDimension ?
                LedgerDimensionFacade::serviceCreateLedgerDimension(LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(_ledgerDimension), removeProfitLossDimension(dimensionDefault)) :
                _ledgerDimension;
        }

        LedgerDimensionAccount getTaxLedgerDimension(TaxTransRelationshipType _relationshipType)
        {
            LedgerDimensionAccount taxLedgerDimension;

            if (_relationshipType == TaxTransRelationshipType::Tax)
            {
                taxLedgerDimension = TaxTransGeneralJournalAccountEntry::getTaxLedgerDimensionForTaxTrans(taxTrans.RecId);
            }
            else
            {
                taxLedgerDimension = TaxTransGeneralJournalAccountEntry::getLedgerDimensionForTaxTrans(taxTrans.RecId, _relationshipType);
            }

            if (!taxLedgerDimension)
            {
                taxLedgerDimension = TaxTransGeneralJournalAccountEntry::find_RU(taxTrans.RecId, _relationshipType).LedgerDimension;

                if (!taxLedgerDimension)
                {
                    select firstonly LedgerDimension from tmpTaxTransLedgerDimension
                        where tmpTaxTransLedgerDimension.TaxTrans == taxTrans.RecId
                            && tmpTaxTransLedgerDimension.RelationshipType == _relationshipType;

                    taxLedgerDimension = tmpTaxTransLedgerDimension.LedgerDimension;
                }
            }

            return taxLedgerDimension;
        }

        ttsbegin;
        if (sourceTransMap)
        {
            me = sourceTransMap.getEnumerator();
            if (!me.moveNext())
            {
                me = null;
            }
        }

        if (ledgerVoucherObject)
        {
            tmpTaxTransLedgerDimension.fillFromLedgerVoucherObject(ledgerVoucherObject);
        }

        do
        {
            if (me)
            {
                [sourceTableId, sourceRecId]    = me.currentKey();
                sourceTransFactor               = me.currentValue();
                sourceIsNull                    = false;
            }

            TaxExchDiffParameters_RU parameters = TaxExchDiffParameters_RU::construct();
            parameters.originalVoucher = _originalvoucher;
            parameters.originalTransDate = _originalTransDate;
            parameters.sourceIsNull = sourceIsNull;
            parameters.reverseTaxOrigin = this.reverseTaxOrigin();
            parameters.taxTransSourceTableId = sourceTableId;
            parameters.taxTransSourceTableId = sourceRecId;

            Query query = this.buildTaxTransInsertAndCalcQuery(parameters);

            QueryRun queryRun = new QueryRun(query);

            //Sum tax amount from taxTrans.
            while (queryRun.next())
            {
                taxTrans = queryRun.get(tableNum(TaxTrans));

                taxTransLedgerDimension         = getTaxLedgerDimension(TaxTransRelationshipType::Tax);

                if (allocateTransactions)
                {
                    dimensionFactor = taxTransDefaultDimensions.getDefaultDimensionFactor(taxTrans.RecId, dimensionDefault);

                    if (! dimensionFactor)
                    {
                        continue;
                    }
                }

                sourceCurrencyCode = emplAdvLine ? emplAdvLine.CurrencyCode : custVendTrans.CurrencyCode;
                triangulation      = taxTrans.euroTriangulation;

                taxWorkTrans.clear();
                taxWorkTrans.HeadingRecId       = headingRecId;
                taxWorkTrans.SourceDocumentLine = taxTrans.SourceDocumentLine;
                taxWorkTrans.SourceTableId      = this.sourceTableId();
                taxWorkTrans.SourceRecId        = this.sourceRecId();
                taxWorkTrans.TaxCode            = taxTrans.TaxCode;
                taxWorkTrans.TaxGroup           = taxTrans.TaxGroup;
                taxWorkTrans.TaxItemGroup       = taxTrans.TaxItemGroup;
                taxWorkTrans.Source             = sourceSet ? source : taxTrans.Source;
                taxWorkTrans.Voucher            = voucher;
                taxWorkTrans.TransDate          = taxDate;
                taxWorkTrans.VatDueDate_W       = taxDate;
                taxWorkTrans.TaxDirection       = taxTrans.TaxDirection;
                taxWorkTrans.CurrencyCode       = postToReportingCurrency ? Ledger::reportingCurrency() : Ledger::accountingCurrency();
                taxWorkTrans.SourceCurrencyCode = sourceCurrencyCode;
                taxWorkTrans.TaxAutogenerated   = taxTrans.TaxAutogenerated;
                taxWorkTrans.euroTriangulation  = taxTrans.euroTriangulation;

                if (postToReportingCurrency)
                {
                    totalAmount = CurrencyExchangeHelper::amountMST2MSTSecond_RU((taxTrans.TaxAmount + taxTrans.TaxBaseAmount) * factor * sourceTransFactor * dimensionFactor, _originalTransDate);
                }
                else
                {
                    totalAmount = CurrencyExchangeHelper::amount((taxTrans.TaxAmount + taxTrans.TaxBaseAmount) * factor * sourceTransFactor * dimensionFactor, taxWorkTrans.CurrencyCode);
                }

                totalAmountExclTax              = Tax::baseAmountExclTax(taxTrans.TaxGroup,
                                                                         taxTrans.TaxItemGroup,
                                                                         _originalTransDate,
                                                                         taxWorkTrans.CurrencyCode,
                                                                         totalAmount,
                                                                         taxTrans.Source);

                taxWorkTrans.TaxAmount          = totalAmount - totalAmountExclTax;
                taxWorkTrans.TaxAmountCur       = taxWorkTrans.TaxAmount;

                taxWorkTrans.TaxBaseAmount      = totalAmountExclTax;
                taxWorkTrans.TaxBaseAmountCur   = taxWorkTrans.TaxBaseAmount;

                taxWorkTrans.TaxBaseQty         = taxTrans.TaxBaseQty * factor * sourceTransFactor * dimensionFactor;

                if (overrideDefaultDimension)
                {
                    defaultDimension = removeProfitLossDimension(dimensionDefault);
                }
                else
                {
                    defaultDimension = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(taxTransLedgerDimension);
                }

                taxable = custVendExchAdjParm.taxable(ledgerPostingType);

                if (taxTrans.TaxDirection == TaxDirection::IncomingTax || taxable == ExchAdjTaxableType_W::Expense)
                {
                    taxWorkTrans.LedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(custVendExchAdjParm.taxLedgerDimension(ledgerPostingType, taxTrans.TaxDirection == TaxDirection::IncomingTax ? overrideDefaultDimension(taxTransLedgerDimension) : 0), defaultDimension);
                }
                else
                {
                    taxWorkTrans.LedgerDimension = taxTrans.TaxDirection == TaxDirection::OutgoingTax   ?
                        LedgerDimensionFacade::serviceCreateLedgerDimension(TaxLedgerAccountGroup::taxOutgoingLedgerDimension_RU(taxWorkTrans.TaxCode), defaultDimension)
                                                                                                        : overrideDefaultDimension(taxTransLedgerDimension);
                }

                taxWorkTrans.TaxReports         = NoYes::Yes;
                taxWorkTrans.ExemptTax          = NoYes::No;
                taxWorkTrans.TaxAutogenerated   = taxTrans.TaxAutogenerated;
                taxWorkTrans.TaxOrigin          = TaxOrigin::Tax;
                taxWorkTrans.HeadingTableId     = taxTrans.HeadingTableId;

                taxWorkTrans.OperationLedgerDimension       = overrideDefaultDimension(getTaxLedgerDimension(TaxTransRelationshipType::TransactionLineAccount));
                taxWorkTrans.TaxOffsetUseTaxLedgerDimension = overrideDefaultDimension(getTaxLedgerDimension(TaxTransRelationshipType::UseTaxPayable));

                if (taxTrans.TaxDirection   == TaxDirection::OutgoingTax    &&
                    taxable                 == ExchAdjTaxableType_W::Tax    &&
                    this.taxParameters().TaxSpecPosting_RU)
                {
                    taxWorkTrans.OffsetLedgerDimension_RU = LedgerDimensionFacade::serviceCreateLedgerDimension(custVendExchAdjParm.taxLedgerDimension(ledgerPostingType, LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(getTaxLedgerDimension(TaxTransRelationshipType::Offset_RU))), defaultDimension);
                }

                taxWorkTrans.insert();

                taxAmount += taxWorkTrans.TaxAmount;
            }
        } while (me && me.moveNext());

        ttscommit;

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTaxAmount</Name>
				<Source><![CDATA[
    public TaxAmount calcTaxAmount(Voucher   _originalVoucher,
                                   TransDate _originalTransDate)
    {
        return this.calcAndInsertTaxes(_originalVoucher, _originalTransDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerDimension_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Returns ledger dimension account for given <c>TaxLedgerAccountGroup</c>.
    /// </summary>
    /// <param name="_tmpTaxWorkTrans">
    ///   Parameter from which tax direction is taken.
    /// </param>
    /// <param name="_taxLedgerAccountGroup">
    ///   <c>TaxLedgerAccountGroup</c> record which is the source of ledger dimension.
    /// </param>
    /// <returns>
    ///   Ledger dimension account for given <c>TaxLedgerAccountGroup</c>.
    /// </returns>
    protected LedgerDimensionDefaultAccount ledgerDimension_RU(TmpTaxWorkTrans _tmpTaxWorkTrans, TaxLedgerAccountGroup _taxLedgerAccountGroup)
    {
        LedgerDimensionDefaultAccount ret;
        boolean                       isVendorTax = taxModuleType == TaxModuleType::Purch ||
                                                    taxModuleType == TaxModuleType::PurchInvoice;
        ;
        if (isVendorTax || custVendExchAdjParm.taxable(ledgerPostingType) == ExchAdjTaxableType_W::Expense)
        {
            ret = custVendExchAdjParm.taxLedgerDimension(ledgerPostingType,
                                                         isVendorTax ? _taxLedgerAccountGroup.TaxIncomingLedgerDimension : 0);
            if (! ret)
            {
                throw error(strFmt("@GLS103651", _taxLedgerAccountGroup.TaxAccountGroup));
            }
        }
        else
        {
            ret = super(_tmpTaxWorkTrans, _taxLedgerAccountGroup);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new(Voucher                _voucher,
             TransDate              _transDate,
             LedgerJournalTransTxt  _txt,
             CustVendTrans          _custVendTrans,
             Factor                 _factor,
             EmplAdvLine_RU         _emplAdvLine = null)
    {
        super(_voucher, _transDate, _txt);

        factor        = _factor;
        custVendTrans = _custVendTrans;
        emplAdvLine   = _emplAdvLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>offsetLedgerDimension_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Returns ledger dimension account for given <c>TaxLedgerAccountGroup</c>.
    /// </summary>
    /// <param name="_taxLedgerAccountGroup">
    ///   <c>TaxLedgerAccountGroup</c> record which is the source of ledger dimension
    /// </param>
    /// <returns>
    ///   Ledger dimension account for given <c>TaxLedgerAccountGroup</c>.
    /// </returns>
    protected LedgerDimensionDefaultAccount offsetLedgerDimension_RU(TaxLedgerAccountGroup _taxLedgerAccountGroup)
    {
        LedgerDimensionDefaultAccount defaultAccount;
        ;

        if ((taxModuleType                          == TaxModuleType::Sales         ||
             taxModuleType                          == TaxModuleType::SalesInvoice) &&
             this.taxParameters().TaxSpecPosting_RU == NoYes::Yes                   &&
             custVendExchAdjParm.taxable(ledgerPostingType) == ExchAdjTaxableType_W::Tax)
        {
            defaultAccount = custVendExchAdjParm.taxLedgerDimension(ledgerPostingType, _taxLedgerAccountGroup.TaxOutgoingOffsetLedgerDimension_RU);

            if (!defaultAccount)
            {
                throw error(strFmt("@GLS103651", _taxLedgerAccountGroup.TaxAccountGroup));
            }
        }
        else
        {
            defaultAccount = super(_taxLedgerAccountGroup);
        }

        return defaultAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustVendExchAdjParm</Name>
				<Source><![CDATA[
    public CustVendExchAdjParm_W parmCustVendExchAdjParm(CustVendExchAdjParm_W _custVendExchAdjParm = custVendExchAdjParm)
    {
        custVendExchAdjParm = _custVendExchAdjParm;

        return custVendExchAdjParm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDimensionDefault</Name>
				<Source><![CDATA[
    public DimensionDefault parmDimensionDefault(DimensionDefault _dimensionDefault = dimensionDefault)
    {
        dimensionDefault = _dimensionDefault;

        return dimensionDefault;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFactor</Name>
				<Source><![CDATA[
    public Factor parmFactor(Factor _factor = factor)
    {
        factor = _factor;

        return factor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerPostingType</Name>
				<Source><![CDATA[
    public LedgerPostingType parmLedgerPostingType(LedgerPostingType _ledgerPostingType = ledgerPostingType)
    {
        return super(_ledgerPostingType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerVoucherObject</Name>
				<Source><![CDATA[
    public LedgerVoucherObject parmLedgerVoucherObject(LedgerVoucherObject _ledgerVoucherObject = ledgerVoucherObject)
    {
        ledgerVoucherObject = _ledgerVoucherObject;
        return ledgerVoucherObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOverrideDefaultDimension</Name>
				<Source><![CDATA[
    public boolean parmOverrideDefaultDimension(boolean _value=overrideDefaultDimension)
    {
        overrideDefaultDimension = _value;
        return overrideDefaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostToReportingCurrency</Name>
				<Source><![CDATA[
    public boolean parmPostToReportingCurrency(boolean _postToReportingCurrency = postToReportingCurrency)
    {
        postToReportingCurrency = _postToReportingCurrency;

        return postToReportingCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRemoveProfitLossDimension</Name>
				<Source><![CDATA[
    public boolean parmRemoveProfitLossDimension(boolean _removeProfitLossDimension = removeProfitLossDimension)
    {
        removeProfitLossDimension = _removeProfitLossDimension;
        return removeProfitLossDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceRecId</Name>
				<Source><![CDATA[
    public RecId parmSourceRecId(RecId _sourceRecId)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceTableId</Name>
				<Source><![CDATA[
    public TableId parmSourceTableId(TableId _sourceTableId)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceTransMap</Name>
				<Source><![CDATA[
    public Map parmSourceTransMap(Map _sourceTransMap = sourceTransMap)
    {
        sourceTransMap = _sourceTransMap;
        return sourceTransMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxTransDefaultDimensions</Name>
				<Source><![CDATA[
    public TmpTaxTransDefaultDimension_RU parmTaxTransDefaultDimensions(TmpTaxTransDefaultDimension_RU _value  = taxTransDefaultDimensions)
    {
        taxTransDefaultDimensions = _value;
        return taxTransDefaultDimensions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVATAdjustment</Name>
				<Source><![CDATA[
    public boolean parmVATAdjustment(boolean _vatAdjustment = vatAdjustment)
    {
        vatAdjustment = _vatAdjustment;
        return vatAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>post</Name>
				<Source><![CDATA[
    protected void post(
        LedgerPostingController _ledgerPostingController,
        TaxTrans                _taxTrans,
        TaxAmount               _taxAmount,
        TaxAmount               _chargeAmount,
        CurrencyExchangeHelper  _exchRateHelper,
        LedgerDimensionAccount  _ledgerDimension,
        LedgerDimensionAccount  _transactionLineLedgerDimension,
        LedgerDimensionAccount  _taxOffsetUseTaxLedgerDimension,
        LedgerDetailLevel       _ledgerDetailLevel      = LedgerDetailLevel::AsDefault,
        ProjLedger              _projLedger             = null,
        LedgerDimensionAccount _offsetLedgerDimension   = 0,
        AmountMSTSecondary      _amountMSTSecondary     = 0
        )
    {
        super(
            _ledgerPostingController,
            _taxTrans,
            _taxAmount,
            _chargeAmount,
            _exchRateHelper,
            _ledgerDimension,
            _transactionLineLedgerDimension,
            _taxOffsetUseTaxLedgerDimension,
            _ledgerDetailLevel,
            _projLedger,
            _offsetLedgerDimension,
            _amountMSTSecondary);

        if (postToReportingCurrency                             &&
           (_taxTrans.TaxDirection == TaxDirection::OutgoingTax ||
            !this.taxParameters().PurchTaxOnOperations)         &&
            custVendExchAdjParm.taxable(ledgerPostingType) == ExchAdjTaxableType_W::Tax)
        {
            if (!targetLedgerParmsList)
            {
                targetLedgerParmsList = new List(Types::Container);
            }

            targetLedgerParmsList.addEnd([_taxAmount, _amountMSTSecondary, _ledgerDimension, _offsetLedgerDimension, _taxTrans.TaxCode, _taxTrans.TaxBaseAmount]);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveAndPost</Name>
				<Source><![CDATA[
    void saveAndPost(LedgerPostingController _ledgerPostingController, boolean _posting = true)
    {
        TaxTrans                taxTrans;
        TaxTrans_RU             taxTrans_RU;
        TaxTrans                taxTransVATAdjustment;
        TaxTrans_RU             taxTransVATAdjustment_RU;
        boolean                 correction = _ledgerPostingController.getReference().parmCorrection();
        CurrencyExchangeHelper  exchangeRateHelper = CurrencyExchangeHelper::construct();
        AccountingEvent         accountingEvent;

        boolean                 taxSpecPosting = this.taxParameters().TaxSpecPosting_RU;
        SourceDocumentLine      localSourceDocumentLine = sourceDocumentLine;

        void distributeAmount(TaxTrans               _taxTrans,
                              LedgerDimensionAccount _ledgerDimensionAccount,
                              LedgerDimensionAccount _transactionLineAccount,
                              LedgerDimensionAccount _taxOffsetUseTaxAccount,
                              LedgerDimensionAccount _offsetLedgerDimensionAccount)
        {
            AccountingDistribution              accountingDistribution;
            List                                sourceLineDistributionList = AccountingDistribution::getDistributionList(accountingEvent.RecId, localSourceDocumentLine.RecId);
            DimensionDefault                    distributionDimensionDefault;
            AmountMST                           distributionTaxAmount;
            AmountMST                           remainAmount = _taxTrans.TaxAmount;
            int                                 elements = sourceLineDistributionList.elements();
            ListEnumerator                      le = sourceLineDistributionList.getEnumerator();
            DimensionAttributeValueSetStorage   dimAttrValueSetStorage;
            DimensionAttributeValue             dimensionAttributeValue;
            TaxTrans_RU                         localTaxTrans_RU;

            while (le.moveNext())
            {
                accountingDistribution = le.current();
                elements--;

                if (elements)
                {
                     distributionTaxAmount  = CurrencyExchangeHelper::amount(_taxTrans.TaxAmount * accountingDistribution.AllocationFactor);
                }
                else
                {
                    distributionTaxAmount  = remainAmount;
                }

                distributionDimensionDefault = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(accountingDistribution.LedgerDimension);

                if (taxTrans.TaxDirection                          != TaxDirection::OutgoingTax    ||
                    custVendExchAdjParm.taxable(ledgerPostingType) != ExchAdjTaxableType_W::Tax    ||
                    ! taxSpecPosting)
                    {
                    distributionDimensionDefault = custVendExchAdjParm.rTax25ExchAdjDimension().getDefaultDimension(distributionDimensionDefault);
                }

                localTaxTrans_RU = _taxTrans.taxTrans_RU();
                localTaxTrans_RU.OffsetLedgerDimension_RU = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(LedgerDimensionFacade::serviceCreateLedgerDimension(_offsetLedgerDimensionAccount, distributionDimensionDefault), _offsetLedgerDimensionAccount);
                _taxTrans.packTaxTrans_RU(localTaxTrans_RU);

                this.post(_ledgerPostingController,
                          _taxTrans,
                          postToReportingCurrency ? 0 : distributionTaxAmount,
                          _taxTrans.TaxInCostPriceMST,
                          exchangeRateHelper,
                          LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(LedgerDimensionFacade::serviceCreateLedgerDimension(_ledgerDimensionAccount, distributionDimensionDefault), _ledgerDimensionAccount),
                          LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(LedgerDimensionFacade::serviceCreateLedgerDimension(_transactionLineAccount, distributionDimensionDefault), _transactionLineAccount),
                          LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(LedgerDimensionFacade::serviceCreateLedgerDimension(_taxOffsetUseTaxAccount, distributionDimensionDefault), _taxOffsetUseTaxAccount),
                          LedgerDetailLevel::AsDefault,
                          null,
                          localTaxTrans_RU.OffsetLedgerDimension_RU,
                          postToReportingCurrency ? distributionTaxAmount : 0);

                remainAmount -= distributionTaxAmount;
            }
        }

        taxTransRecIDs = new Set(typeName2Type(extendedTypeStr(RecId)));
        if (CurrencyLedgerGainLossFromNetValueFeature_PL::isEnabled())
        {
            exchRateDiffTaxLedgerVoucherTransObjectTempRecIDs = new Set(typeName2Type(extendedTypeStr(RecId)));
        }

        ttsbegin;

        while select taxWorkTrans
            where taxWorkTrans.HeadingRecId  == headingRecId &&
                  taxWorkTrans.TaxOrigin     != TaxOrigin::TaxReversed
        {
            if (taxWorkTrans.TaxAmount || taxWorkTrans.TaxBaseAmount || taxWorkTrans.TaxBaseQty)
            {
                taxTrans.clear();
                this.initFromTaxWorkTrans(taxTrans, taxWorkTrans, this.taxOrigin(taxWorkTrans.TaxOrigin));

                sourceCurrencyCode           = emplAdvLine ? emplAdvLine.CurrencyCode : custVendTrans.CurrencyCode;

                taxTrans.euroTriangulation   = triangulation;
                taxTrans.Voucher             = voucher;
                taxTrans.JournalNum          = this.journalNum();

                taxTrans.SourceCurrencyCode  = sourceCurrencyCode;
                taxTrans.SourceBaseAmountCur = 0;
                taxTrans.SourceTaxAmountCur  = 0;

                if (_posting && !postToReportingCurrency)
                {
                    this.initTaxTrans(taxTrans, _ledgerPostingController.getJournal().parmVoucherSeriesCode());
                    taxTrans.insert();
                    taxTransRecIDs.add(taxTrans.RecId);
                }

                if (taxWorkTrans.ExemptTax == NoYes::No && taxTrans.TaxAmount)
                {
                    exchangeRateHelper.parmExchangeRate1(exchRate);
                    exchangeRateHelper.parmReportingExchangeRate1(exchRateSecond);
                    exchangeRateHelper.parmExchangeDate(taxTrans.TransDate);

                    if (!sourceDocumentLine)
                    {
                        if (taxTrans.SourceDocumentLine)
                        {
                            localSourceDocumentLine = sourceDocumentLine::find(taxTrans.SourceDocumentLine);
                        }
                        else
                        {
                            localSourceDocumentLine = TaxReverseTaxCustVendSettle_RU::sourceDocumentLine(taxTrans.SourceTableId, taxTrans.SourceRecId);
                        }
                    }

                    accountingEvent = AccountingDistribution::getLastSourceDocumentLineEvent(localSourceDocumentLine.RecId);

                    taxTrans_RU = taxTrans.taxTrans_RU();

                    if (! skipDistribution && AccountingDistribution::existEventAndSourceDocumentLine(accountingEvent.RecId, localSourceDocumentLine.RecId))
                    {
                        distributeAmount(taxTrans,
                                         taxWorkTrans.LedgerDimension,
                                         taxWorkTrans.OperationLedgerDimension,
                                         taxWorkTrans.TaxOffsetUseTaxLedgerDimension,
                                         taxTrans_RU.OffsetLedgerDimension_RU);
                    }
                    else
                    {
                        this.post(_ledgerPostingController,
                                  taxTrans,
                                  postToReportingCurrency ? 0 : taxTrans.TaxAmount,
                                  taxTrans.TaxInCostPriceMST,
                                  exchangeRateHelper,
                                  taxWorkTrans.LedgerDimension,
                                  taxWorkTrans.OperationLedgerDimension,
                                  taxWorkTrans.TaxOffsetUseTaxLedgerDimension,
                                  LedgerDetailLevel::AsDefault,
                                  null,
                                  taxTrans_RU.OffsetLedgerDimension_RU,
                                  postToReportingCurrency ? taxTrans.TaxAmount : 0);
                    }
                }
                else if (!taxTrans.TaxAmount)
                {
                    taxTrans_RU = taxTrans.taxTrans_RU();
                    this.createOrphanLinkInsteadPost_RU(taxTrans,
                                                        taxWorkTrans.LedgerDimension,
                                                        taxWorkTrans.OperationLedgerDimension,
                                                        taxWorkTrans.TaxOffsetUseTaxLedgerDimension,
                                                        taxTrans_RU.OffsetLedgerDimension_RU);
                }

                // posting additional tax transactions
                if (custVendExchAdjParm.vatAdjustment() && vatAdjustment)
                {
                    taxTransVATAdjustment.data(taxTrans);
                    taxTrans_RU = taxTrans.taxTrans_RU();
                    taxTransVATAdjustment_RU = taxTransVATAdjustment.taxTrans_RU();

                    taxTransVATAdjustment.SourceTableId            = tableNum(TaxTrans);
                    taxTransVATAdjustment.SourceRecId              = taxTrans.RecId;
                    taxTransVATAdjustment_RU.OffsetLedgerDimension_RU = taxWorkTrans.LedgerDimension;

                    taxTransVATAdjustment.packTaxTrans_RU(taxTransVATAdjustment_RU);

                    if (!postToReportingCurrency)
                    {
                        taxTransVATAdjustment.insert();
                        taxTransRecIDs.add(taxTransVATAdjustment.RecId);
                    }

                    _ledgerPostingController.getReference().parmCorrection(! correction);

                    exchangeRateHelper.parmExchangeRate1(exchRate);
                    exchangeRateHelper.parmReportingExchangeRate1(exchRateSecond);
                    exchangeRateHelper.parmExchangeDate(taxTransVATAdjustment.TransDate);

                    if (!sourceDocumentLine)
                    {
                        localSourceDocumentLine = TaxReverseTaxCustVendSettle_RU::sourceDocumentLine(taxTrans.SourceTableId, taxTrans.SourceRecId);
                    }

                    taxTransVATAdjustment_RU = taxTransVATAdjustment.taxTrans_RU();

                    if (AccountingDistribution::existEventAndSourceDocumentLine(accountingEvent.RecId, localSourceDocumentLine.RecId))
                    {
                        distributeAmount(taxTransVATAdjustment,
                                         custVendExchAdjParm.vatAdjLedgerDimension(ledgerPostingType),
                                         taxWorkTrans.OperationLedgerDimension,
                                         taxWorkTrans.TaxOffsetUseTaxLedgerDimension,
                                         taxTransVATAdjustment_RU.OffsetLedgerDimension_RU);
                    }
                    else
                    {
                        this.post(_ledgerPostingController,
                                    taxTransVATAdjustment,
                                    postToReportingCurrency ? 0 : taxTransVATAdjustment.TaxAmount,
                                    taxTransVATAdjustment.TaxInCostPriceMST,
                                    exchangeRateHelper,
                                    LedgerDimensionFacade::serviceCreateLedgerDimension(custVendExchAdjParm.vatAdjLedgerDimension(ledgerPostingType)),
                                    taxWorkTrans.OperationLedgerDimension,
                                    taxWorkTrans.TaxOffsetUseTaxLedgerDimension,
                                    LedgerDetailLevel::AsDefault,
                                    null,
                                    taxTransVATAdjustment_RU.OffsetLedgerDimension_RU,
                                    postToReportingCurrency ? taxTransVATAdjustment.TaxAmount : 0);
                    }

                    _ledgerPostingController.getReference().parmCorrection(correction);
                }
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceRecId</Name>
				<Source><![CDATA[
    RecId sourceRecId()
    {
        return custVendTrans.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceTableId</Name>
				<Source><![CDATA[
    TableId sourceTableId()
    {
        return custVendTrans.TableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>targetLedgerParmsList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns list of parameters for tax posting
    /// </summary>
    /// <returns>
    /// List of parameters for tax posting - it holds tax amounts, dimension
    /// </returns>
    public List targetLedgerParmsList()
    {
        return targetLedgerParmsList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountCalculated</Name>
				<Source><![CDATA[
    TaxAmount taxAmountCalculated()
    {
        select sum(TaxAmount) from taxWorkTrans
            where taxWorkTrans.SourceRecId      == this.sourceRecId()   &&
                  taxWorkTrans.SourceTableId    == this.sourceTableId() &&
                 (taxWorkTrans.TaxDirection     != TaxDirection::UseTax ||
                  CurrencyLedgerGainLossFromNetValueFeature_PL::isEnabled()) &&
                  taxWorkTrans.TaxOrigin        != TaxOrigin::TaxReversed;

        return taxWorkTrans.TaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxCalcWithoutSource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates tax without source, based on given parameters
    /// </summary>
    /// <param name="_taxGroup">
    /// Tax group for tax calculation
    /// </param>
    /// <param name="_taxItemGroup">
    /// Tax item group for tax calculation
    /// </param>
    /// <param name="_taxDate">
    /// Date for tax calculation
    /// </param>
    /// <param name="_sourceCurrencyCode">
    /// Tax currency
    /// </param>
    /// <param name="_baseAmountCur">
    /// Base amount for tax in transaction currency
    /// </param>
    /// <param name="_taxModuleType">
    /// <c>TaxModuleType</c> for tax being calculated
    /// </param>
    /// <param name="_baseQty">
    /// Base quantity for tax calculation
    /// </param>
    /// <param name="_baseUnit">
    /// Unit for base quantity
    /// </param>
    /// <param name="_itemId">
    /// Item used for tax calculation
    /// </param>
    /// <param name="_taxDirection">
    /// Direction of tax
    /// </param>
    /// <param name="_gsthstTaxType_CA">
    /// Not used
    /// </param>
    /// <param name="_calculationDate">
    /// Date of tax calculation
    /// </param>
    /// <returns>
    /// Calculated tax amount
    /// </returns>
    TaxAmountCur taxCalcWithoutSource(TaxGroup              _taxGroup,
                                      TaxItemGroup          _taxItemGroup,
                                      TransDate             _taxDate,
                                      CurrencyCode          _sourceCurrencyCode,
                                      AmountCur             _baseAmountCur,
                                      TaxModuleType         _taxModuleType,
                                      TaxBase               _baseQty          = 0,
                                      UnitOfMeasureSymbol   _baseUnit         = '',
                                      ItemId                _itemId           = '',
                                      TaxDirection          _taxDirection     = TaxDirection::OutgoingTax,
                                      GSTHSTTaxType_CA      _gsthstTaxType_CA = GSTHSTTaxType_CA::None,
                                      TransDate             _calculationDate = _taxDate
                                      )
    {
        TaxAmountCur taxAmountCur;

        taxDate = _taxDate;

        if (_taxModuleType == TaxModuleType::Voucher)
        {
            if (_baseAmountCur  > 0)
            {
                taxModuleType = TaxModuleType::Purch;
            }
            else
            {
                taxModuleType = TaxModuleType::Sales;
            }
        }
        else
        {
            taxModuleType = _taxModuleType;
        }

        sourceCurrencyCode = _sourceCurrencyCode;

        this.insertIntersection(_taxGroup,
                                _taxItemGroup,
                                _itemId,
                                '',
                                _calculationDate);

        this.insertLineInInternal(_baseAmountCur,
                                  _baseQty,
                                  _baseUnit,
                                  _itemId,
                                  0,
                                  dimensionDefault,
                                  0);

        taxAmountCur = this.calcTax();
        this.saveInProcessTransaction();

        this.insertTotalInInternal(0);
        taxAmountCur = this.calcTax();
        this.saveTotalInProcessTransaction();

        taxAmountCur = this.totalTaxAmount();
        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxOrigin</Name>
				<Source><![CDATA[
    protected TaxOrigin taxOrigin(TaxOrigin _defaultTaxOrigin)
    {
        return TaxOrigin::Tax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxTransRecIDs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set of TaxTrans recID to be linked with posting log
    /// </summary>
    /// <returns>Set of recIDs</returns>
    public Set taxTransRecIDs()
    {
        return taxTransRecIDs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildTaxTransInsertAndCalcQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds query object for <c>TaxTrans</c>.
    /// </summary>
    /// <param name = "_parameters">The buffer for <c>TaxExchDiff_RU_Parameters</c>.</param>
    /// <returns>Query object for <c>TaxTrans</c>.</returns>
    [Replaceable]
    public Query buildTaxTransInsertAndCalcQuery(TaxExchDiffParameters_RU _parameters)
    {
        Query query = new Query();
        QueryBuildDataSource qbds = query.addDataSource(tableNum(TaxTrans));
        if (_parameters.originalVoucher != '')
        {
            qbds.addRange(fieldNum(TaxTrans, Voucher)).value(strfmt(
                '(%1.%2 == "%3")',
                qbds.name(),
                fieldstr(TaxTrans, Voucher),
                queryValue(_parameters.originalVoucher)));
        }
        else
        {
            qbds.addRange(fieldNum(TaxTrans, Voucher)).value(strfmt(
                '(%1.%2 == %3)',
                qbds.name(),
                fieldstr(TaxTrans, Voucher),
                queryValue(_parameters.originalVoucher)));
        }
        
        qbds.addRange(fieldNum(TaxTrans, TransDate)).value(strfmt(
            '(%1.%2 == %3)',
            qbds.name(),
            fieldstr(TaxTrans, TransDate),
            date2StrXpp(_parameters.originalTransDate)));

        qbds.addRange(fieldNum(TaxTrans, ExemptTax)).value(strfmt(
            '(%1.%2 == %3)',
            qbds.name(),
            fieldstr(TaxTrans, ExemptTax),
            any2Int(NoYes::No)));

        qbds.addRange(fieldNum(TaxTrans, TaxOrigin)).value(strfmt(
            '((%1.%2 == %3) || (%1.%2 == %4))',
            qbds.name(),
            fieldstr(TaxTrans, TaxOrigin),
            any2int(TaxOrigin::CashDisc),
            any2int(queryValue(_parameters.reverseTaxOrigin))));

        if(!_parameters.sourceIsNull)
        {
            qbds.addRange(fieldNum(TaxTrans, SourceTableId)).value(strfmt(
                '((%1.%2 == %3) && (%1.%4 == %5))',
                qbds.name(),
                fieldstr(TaxTrans, SourceTableId),
                queryValue(_parameters.taxTransSourceTableId),
                fieldstr(TaxTrans, SourceRecId),
                queryValue(_parameters.taxTransSourceRecId)));
        }

        if (CurrencyLedgerGainLossFromNetValueFeature_PL::isEnabled() && this.parmIsFromSettlement())
        {
            qbds.addRange(fieldNum(TaxTrans, TaxDirection)).value(strfmt(
                '((%1.%2 != %3) && (%1.%2 != %4))',
                qbds.name(),
                fieldstr(TaxTrans, TaxDirection),
                any2int(TaxDirection::OutgoingTax_W),
                any2int(TaxDirection::IncomingTax_W)));
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRateDiffTaxLedgerVoucherTransObjectTempRecIDs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns set of exchRateDiffTaxLedgerVoucherTransObjectTempRecIDs.
    /// </summary>
    /// <returns>Set of exchRateDiffTaxLedgerVoucherTransObjectTempRecIDs.</returns>
    public Set exchRateDiffTaxLedgerVoucherTransObjectTempRecIDs()
    {
        return exchRateDiffTaxLedgerVoucherTransObjectTempRecIDs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerPostingType</Name>
				<Source><![CDATA[
    protected LedgerPostingType ledgerPostingType()
    {
        LedgerPostingType ret;

        if (CurrencyLedgerGainLossFromNetValueFeature_PL::isEnabled()
            && this.parmIsFromSettlement())
        {
            ret = ledgerPostingType;
        }
        else
        {
            ret = super();
        }

        return ret;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>