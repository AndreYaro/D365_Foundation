<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ServiceTaxRevChargePostingController_IN</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>ServiceTaxRevChargePostingController_IN</c> class handles the service tax reverse charge posting.
/// </summary>
class ServiceTaxRevChargePostingController_IN
{
    Tax                         tax;
    TaxSettlement_IN            taxSettlementIN;
    LedgerJournalTrans          ledgerJournalTrans;
    TaxAmountCur                loadOnInventry;
    LedgerVoucher               ledgerVoucher;
    LedgerPostingType           ledgerPostingType;
    SalesPurchJournalLine       salesPurchJournalLineLoc;
    ExchRate                    exchRate;
    ExchrateSecondary           exchRateSecondary;
    boolean                     isGTAVendor;
    boolean                     isForeignVendor;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    /// Do all necessary initialization.
    /// </summary>
    /// <param name="_taxTrans">
    /// The tax trans.
    /// </param>
    /// <param name="_ledgerPostingType">
    /// The ledger posting type.
    /// </param>
    /// <param name="_tax">
    /// The tax.
    /// </param>
    /// <param name="_salesPurchJournalLine">
    /// The sales purch journal line.
    /// </param>
    /// <param name="_isGTAVendor">
    /// If is GTA vendor or not.
    /// </param>
    /// <param name="_isForeignVendor">
    /// If is foreign vendor or not.
    /// </param>
    public void init(
        TaxTrans                    _taxTrans,
        LedgerPostingType           _ledgerPostingType,
        Tax                         _tax,
        SalesPurchJournalLine       _salesPurchJournalLine,
        boolean                     _isGTAVendor = NoYes::No,
        boolean                     _isForeignVendor = NoYes::No)
    {
        this.parmLedgerPostingType(_ledgerPostingType);
        this.parmIsForeignVendor(_isForeignVendor);
        this.parmIsGTAVendor(_isGTAVendor);
        this.parmTax(_tax);
        this.parmSalesPurchJournalLine(_salesPurchJournalLine);
        ledgerJournalTrans = LedgerJournalTrans::findRecId(_salesPurchJournalLine.SourceRecId, false);
        this.parmLedgerJournalTrans(ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAdvancePayment_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates if is advance payment or not.
    /// </summary>
    /// <returns>
    /// Returns true if is advance payment, otherwise false.
    /// </returns>
    public boolean isAdvancePayment_IN()
    {
        boolean ret;

        if (salesPurchJournalLineLoc.SourceTableId == tablenum(LedgerJournalTrans))
        {
            ledgerJournalTrans = LedgerJournalTrans::findRecId(salesPurchJournalLineLoc.SourceRecId, false);
            if (ledgerJournalTrans.isPaymentJournal_IN()
                && (ServiceTaxRevChargePostingController_IN::isInvoiceFirstThenPayment_IN(ledgerJournalTrans.TableId, ledgerJournalTrans.RecId) == false))
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsForeignVendor</Name>
				<Source><![CDATA[
    public NoYes parmIsForeignVendor(NoYes _isForeignVendor = NoYes::No)
    {
        isForeignVendor = _isForeignVendor;

        return isForeignVendor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsGTAVendor</Name>
				<Source><![CDATA[
    public NoYes parmIsGTAVendor(NoYes _isGTAVendor = NoYes::No)
    {
        isGTAVendor = _isGTAVendor;

        return isGTAVendor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalTrans</Name>
				<Source><![CDATA[
    public LedgerJournalTrans parmLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans = ledgerJournalTrans)
    {
        ledgerJournalTrans = _ledgerJournalTrans;

        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerPostingType</Name>
				<Source><![CDATA[
    public LedgerPostingType parmLedgerPostingType(LedgerPostingType _ledgerPostingType = ledgerPostingType)
    {
        ledgerPostingType = _ledgerPostingType;

        return ledgerPostingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerVoucher</Name>
				<Source><![CDATA[
    public LedgerVoucher parmLedgerVoucher(LedgerVoucher _ledgerVoucher = ledgerVoucher)
    {
        ledgerVoucher = _ledgerVoucher;

        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesPurchJournalLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the sales purch journal line.
    /// </summary>
    /// <param name="_salesPurchJournalLine">
    /// The sales purch journal line.
    /// </param>
    public void  parmSalesPurchJournalLine(SalesPurchJournalLine _salesPurchJournalLine)
    {
        salesPurchJournalLineLoc = _salesPurchJournalLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTax</Name>
				<Source><![CDATA[
    public Tax parmTax(Tax _tax = tax)
    {
        tax = _tax;

        return tax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxSettlementIN</Name>
				<Source><![CDATA[
    public TaxSettlement_IN parmTaxSettlementIN(TaxSettlement_IN _taxSettlementIN = taxSettlementIN)
    {
        taxSettlementIN = _taxSettlementIN;

        return taxSettlementIN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postReverseChargeServiceTaxAdvPay</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts reverse charge service tax advanced payment.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller.
    /// </param>
    /// <param name="_taxTrans">
    /// The tax trans.
    /// </param>
    /// <param name="_exchRateHelper">
    /// The exchange rate helper.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The ledger dimension.
    /// </param>
    /// <param name="_ledgerDimension_IN">
    /// The ledger dimension in IN region.
    /// </param>
    /// <param name="_ledgerDetailLevel">
    /// The ledger detail level.
    /// </param>
    public void postReverseChargeServiceTaxAdvPay(
        LedgerPostingController _ledgerPostingController,
        TaxTrans                _taxTrans,
        CurrencyExchangeHelper  _exchRateHelper,
        LedgerDimensionAccount  _ledgerDimension,
        LedgerDimensionAccount  _ledgerDimension_IN = 0,
        LedgerDetailLevel       _ledgerDetailLevel  = LedgerDetailLevel::AsDefault)
    {
        TaxTrans                   advancePayPayableTax;
        TaxTrans                   advancePayIPTax;
        TaxTable                   taxTableRev = TaxTable::find(_taxTrans.TaxCode);
        LedgerVoucherTransObject   ledgerVoucherTransObject;
        boolean                    relatedVoucherDoneForPayment;
        LedgerVoucher              paymentLedgerVoucher;
        TaxTrans_W                 taxTrans_W;

        if (ledgerJournalTrans.isPaymentJournal_IN() && !(TaxItemGroupHeading::isAccruePayableAtInvoicing_IN(_taxTrans.TaxItemGroup)))
        {
            // For payment LOI will not hit payables.
            if (_taxTrans.SourceRegulateAmountCur)
            {
                //Insert taxTrans and Taxtrans_IN records for above posting.
                if (_ledgerDimension_IN)
                {
                    advancePayPayableTax.data(_taxTrans);
                    taxTrans_W = advancePayPayableTax.taxTrans_W();
                    advancePayPayableTax.packTaxTrans_W(taxTrans_W);
                    tax.taxAmountRegulation(advancePayPayableTax,
                                            advancePayPayableTax.SourceRegulateAmountCur,
                                            _exchRateHelper.parmExchangeRate1(),
                                            _exchRateHelper.parmExchangeRate2());
                    advancePayPayableTax.updateTaxTransByReverseChargePercent_IN(_taxTrans.taxTrans_W().ServiceTaxReverseChargePercentage_IN, 1);
                    advancePayPayableTax.TaxDirection = TaxDirection::OutgoingTax;
                    // No LOI for serviceTax Payment.
                    advancePayPayableTax.TaxInCostPrice           = 0;
                    advancePayPayableTax.TaxInCostPriceCur        = 0;
                    advancePayPayableTax.TaxInCostPriceMST        = 0;
                    advancePayPayableTax.TaxInCostPriceRegulated  = 0;
                    advancePayPayableTax.TaxDirection             = TaxDirection::OutgoingTax;
                    if (advancePayPayableTax.SourceRegulateAmountCur != 0)
                    {
                        advancePayPayableTax.insert();
                        tax.insertTaxTrans_IN(advancePayPayableTax, ledgerJournalTrans, _ledgerDimension_IN);
                    }
                    if (_ledgerDimension_IN && advancePayPayableTax.SourceRegulateAmountCur)
                    {
                        ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                                _ledgerPostingController.getReference(),
                                                                                ledgerPostingType,
                                                                                _ledgerDimension_IN,
                                                                                _taxTrans.SourceCurrencyCode,
                                                                                CurrencyExchangeHelper::amount(advancePayPayableTax.SourceRegulateAmountCur),
                                                                                _exchRateHelper);

                        // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
                        if (advancePayPayableTax)
                        {
                            // TaxTrans will not exist in the case where a transaction is only being validated,
                            // and in that case the tax trans relationship should not be created
                            ledgerVoucherTransObject.addTaxTransRelationship(advancePayPayableTax.RecId, TaxTransRelationshipType::Tax);
                        }

                        ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
                        _ledgerPostingController.addTrans(ledgerVoucherTransObject);
                    }

                    relatedVoucherDoneForPayment = LedgerTransVoucherLink::findVoucherGroupId(ledgerJournalTrans.Voucher, _taxTrans.TransDate)
                                                    && LedgerTransVoucherLink::findVoucherGroupId(_taxTrans.Voucher, _taxTrans.TransDate);
                    if (!relatedVoucherDoneForPayment)
                    {
                        ttsbegin;
                        paymentLedgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Summary,
                                                                            _ledgerPostingController.getJournal().parmSysModuleDefault(),
                                                                            _ledgerPostingController.getJournal().parmVoucherSeriesCode());
                        if (paymentLedgerVoucher != null)
                        {
                            paymentLedgerVoucher.addVoucher(
                                LedgerVoucherObject::newVoucher(_ledgerPostingController.getJournal().lastVoucher(),
                                                                _ledgerPostingController.getJournal().lastTransDate(),
                                                                _ledgerPostingController.getJournal().parmSysModuleDefault(),
                                                                ledgerJournalTrans.TransactionType));
                            paymentLedgerVoucher.createVoucherLinks(ledgerJournalTrans.Voucher, paymentLedgerVoucher.lastTransDate());
                        }
                        ttscommit;
                    }
                }
                if (_ledgerDimension)
                {
                    advancePayIPTax.data(_taxTrans);
                    tax.taxAmountRegulation(advancePayIPTax,
                                            advancePayIPTax.SourceRegulateAmountCur,
                                            _exchRateHelper.parmExchangeRate1(),
                                            _exchRateHelper.parmExchangeRate2());
                    advancePayIPTax.updateTaxTransByReverseChargePercent_IN(_taxTrans.taxTrans_W().ServiceTaxReverseChargePercentage_IN, -1);
                    advancePayIPTax.TaxDirection = TaxDirection::OutgoingTax;
                    advancePayIPTax.TaxInCostPrice           = 0;
                    advancePayIPTax.TaxInCostPriceCur        = 0;
                    advancePayIPTax.TaxInCostPriceMST        = 0;
                    advancePayIPTax.TaxInCostPriceRegulated  = 0;
                    advancePayIPTax.TaxDirection             = TaxDirection::OutgoingTax;
                    if (advancePayIPTax.SourceRegulateAmountCur != 0)
                    {
                        advancePayIPTax.insert();
                        tax.insertTaxTrans_IN(advancePayIPTax, ledgerJournalTrans, _ledgerDimension);
                    }
                    if (_ledgerDimension && advancePayIPTax.SourceRegulateAmountCur)
                    {
                        ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                _ledgerPostingController.getReference(),
                                                                ledgerPostingType,
                                                                _ledgerDimension,
                                                                _taxTrans.SourceCurrencyCode,
                                                                CurrencyExchangeHelper::amount(advancePayIPTax.SourceRegulateAmountCur),
                                                                _exchRateHelper);
                        if (advancePayIPTax)
                        {
                            ledgerVoucherTransObject.addTaxTransRelationship(advancePayIPTax.RecId, TaxTransRelationshipType::Tax);
                        }
                        ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
                        _ledgerPostingController.addTrans(ledgerVoucherTransObject);
                    }
                }
                // Set relation/Direction/TaxOrigin for all siblings.Mark this tax trans of interim payable and used it for final IR-R
                if (advancePayIPTax.RecId && advancePayPayableTax.RecId)
                {
                    taxTrans_W = advancePayPayableTax.taxTrans_W();
                    taxTrans_W.TaxTransRefRecId_IN = advancePayIPTax.RecId;
                    advancePayPayableTax.packTaxTrans_W(taxTrans_W);
                    advancePayPayableTax.update();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postReverseChargeServiceTaxInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts reverse charge service tax invoice.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller.
    /// </param>
    /// <param name="_taxTrans">
    /// The tax trans.
    /// </param>
    /// <param name="_exchRateHelper">
    /// The exchange rate helper.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The ledger dimension.
    /// </param>
    /// <param name="_ledgerDimension_IN">
    /// The ledger dimension in IN region.
    /// </param>
    /// <param name="_ledgerDimensionRev_IN">
    /// The ledger dimension reverse in IN region.
    /// </param>
    /// <param name="_ledgerDetailLevel">
    /// The ledger detail level
    /// </param>
    public void postReverseChargeServiceTaxInvoice(
        LedgerPostingController _ledgerPostingController,
        TaxTrans                _taxTrans,
        CurrencyExchangeHelper  _exchRateHelper,
        LedgerDimensionAccount  _ledgerDimension,
        LedgerDimensionAccount  _ledgerDimension_IN = 0,
        LedgerDimensionAccount  _ledgerDimensionRev_IN = 0,
        LedgerDetailLevel       _ledgerDetailLevel  = LedgerDetailLevel::AsDefault)
    {
        TaxTrans                   taxTransRecoverable;
        TaxTrans                   taxTransPayable;
        TaxTrans                   taxTransIR;
        TaxTrans                   taxTransIP;
        TaxTrans                   taxTransExpense;
        TaxTable                   taxTableRev = TaxTable::find(_taxTrans.TaxCode);
        LedgerVoucherTransObject   ledgerVoucherTransObject;
        TaxTrans_W                 taxTransW;
        AmountCur                  recoverable2Post;
        AmountCur                  IR2Post;
        TaxTrans                   taxTransRecoverableTmp;
        TransTaxInformation        transTaxInformation;

        void insertInterimPayableorPayableTaxTrans(boolean isAccruePayableAtInvoicing = false)
        {
            TaxTrans    taxTransIPorP;
            taxTransW = _taxTrans.taxTrans_W();

            // Insert Interim Payable TaxTrans or Payable TaxTrans then post it to GL after considering LOI if any
            taxTransIPorP.data(_taxTrans);
            tax.taxAmountRegulation(taxTransIPorP,
                                    taxTransIPorP.SourceRegulateAmountCur,
                                    _exchRateHelper.parmExchangeRate1(),
                                    _exchRateHelper.parmExchangeRate2());
            taxTransRecoverableTmp.data(_taxTrans);
            tax.taxAmountRegulation(taxTransRecoverableTmp,
                                    taxTransRecoverableTmp.SourceRegulateAmountCur,
                                    _exchRateHelper.parmExchangeRate1(),
                                    _exchRateHelper.parmExchangeRate2());
            taxTransRecoverableTmp.updateTaxTransByReverseChargePercent_IN(100 - taxTransW.ServiceTaxReverseChargePercentage_IN);
            taxTransIPorP.updateTaxTransByForInterim_IN(taxTransRecoverableTmp, false, -1);
            if (taxTransIPorP.SourceRegulateAmountCur != 0)
            {
                taxTransIPorP.TaxDirection = TaxDirection::OutgoingTax;
                taxTransIPorP.insert();
                tax.insertTaxTrans_IN(taxTransIPorP, ledgerJournalTrans, _ledgerDimension_IN);
                if (_ledgerDimension_IN && taxTransIPorP.SourceRegulateAmountCur)// No LOI for payables.
                {
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                        _ledgerPostingController.getReference(),
                                                                        ledgerPostingType,
                                                                        _ledgerDimension_IN,
                                                                        _taxTrans.SourceCurrencyCode,
                                                                        taxTransIPorP.SourceRegulateAmountCur,
                                                                        _exchRateHelper);
                    if (taxTransIPorP)
                    {
                        ledgerVoucherTransObject.addTaxTransRelationship(taxTransIPorP.RecId, TaxTransRelationshipType::Tax);
                    }
                    ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
                    _ledgerPostingController.addTrans(ledgerVoucherTransObject);
                }
            }

            if (isAccruePayableAtInvoicing)
            {
                taxTransPayable.data(taxTransIPorP);
            }
            else
            {
                taxTransIP.data(taxTransIPorP);
            }
        }

        taxTransW = _taxTrans.taxTrans_W();

        transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(ledgerJournalTrans);
        if (transTaxInformation.ServiceTaxGTAServiceCategory == GTAServiceCategory_IN::Others)
        {
            // Insert Expense TaxTrans then post it to GL after considering LOI if any.
            taxTransExpense.data(_taxTrans);
            tax.taxAmountRegulation(taxTransExpense,
                                    taxTransExpense.SourceRegulateAmountCur,
                                    _exchRateHelper.parmExchangeRate1(),
                                    _exchRateHelper.parmExchangeRate2());
            if (taxTransExpense.SourceRegulateAmountCur != 0)
            {
                taxTransExpense.TaxDirection = TaxDirection::IncomingTax;
                taxTransExpense.insert();// Expense
                tax.insertTaxTrans_IN(taxTransExpense, ledgerJournalTrans,_ledgerDimensionRev_IN);
                recoverable2Post = (taxTransExpense.SourceRegulateAmountCur - taxTransExpense.TaxInCostPriceRegulated);
                if (_ledgerDimensionRev_IN && recoverable2Post)
                {
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                    _ledgerPostingController.getReference(),
                                                                    ledgerPostingType,
                                                                    _ledgerDimensionRev_IN,
                                                                    _taxTrans.SourceCurrencyCode,
                                                                    recoverable2Post,
                                                                    _exchRateHelper);
                    if (taxTransExpense)
                    {
                        ledgerVoucherTransObject.addTaxTransRelationship(taxTransExpense.RecId, TaxTransRelationshipType::Tax);
                    }
                    ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
                    _ledgerPostingController.addTrans(ledgerVoucherTransObject);
                }
            }
        }
        else
        {
            // Insert Recoverable TaxTrans then post it to GL after considering LOI if any.
            taxTransRecoverable.data(_taxTrans);
            tax.taxAmountRegulation(taxTransRecoverable,
                                    taxTransRecoverable.SourceRegulateAmountCur,
                                    _exchRateHelper.parmExchangeRate1(),
                                    _exchRateHelper.parmExchangeRate2());
            taxTransRecoverable.updateTaxTransByReverseChargePercent_IN(100 - taxTransW.ServiceTaxReverseChargePercentage_IN);
            if (taxTransRecoverable.SourceRegulateAmountCur != 0)
            {
                taxTransRecoverable.TaxDirection = TaxDirection::IncomingTax;
                taxTransRecoverable.insert();// Recoverable
                tax.insertTaxTrans_IN(taxTransRecoverable, ledgerJournalTrans,_ledgerDimensionRev_IN);
                recoverable2Post = (taxTransRecoverable.SourceRegulateAmountCur - taxTransRecoverable.TaxInCostPriceRegulated);
                if (_ledgerDimensionRev_IN && recoverable2Post)
                {
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                    _ledgerPostingController.getReference(),
                                                                    ledgerPostingType,
                                                                    _ledgerDimensionRev_IN,
                                                                    _taxTrans.SourceCurrencyCode,
                                                                    recoverable2Post,
                                                                    _exchRateHelper);
                    if (taxTransRecoverable)
                    {
                        ledgerVoucherTransObject.addTaxTransRelationship(taxTransRecoverable.RecId, TaxTransRelationshipType::Tax);
                    }
                    ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
                    _ledgerPostingController.addTrans(ledgerVoucherTransObject);
                }
            }
            // Insert Interim Recoverable TaxTrans then post it to GL after considering LOI if any
            taxTransIR.data(_taxTrans);
            tax.taxAmountRegulation(taxTransIR,
                                    taxTransIR.SourceRegulateAmountCur,
                                    _exchRateHelper.parmExchangeRate1(),
                                    _exchRateHelper.parmExchangeRate2());
            taxTransIR.updateTaxTransByForInterim_IN(taxTransRecoverable, true);
            if (taxTransIR.SourceRegulateAmountCur != 0)
            {
                taxTransIR.TaxDirection = TaxDirection::IncomingTax;
                taxTransIR.insert();
                tax.insertTaxTrans_IN(taxTransIR, ledgerJournalTrans,_ledgerDimension);
                IR2Post = (taxTransIR.SourceRegulateAmountCur - taxTransIR.TaxInCostPriceRegulated);
                if (_ledgerDimension && IR2Post)
                {
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                        _ledgerPostingController.getReference(),
                                                                        ledgerPostingType,
                                                                        _ledgerDimension,
                                                                        _taxTrans.SourceCurrencyCode,
                                                                        IR2Post,
                                                                        _exchRateHelper);
                    if (taxTransIR)
                    {
                        ledgerVoucherTransObject.addTaxTransRelationship(taxTransIR.RecId, TaxTransRelationshipType::Tax);
                    }
                    ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);
                    _ledgerPostingController.addTrans(ledgerVoucherTransObject);
                }
            }
        }

        insertInterimPayableorPayableTaxTrans(TaxItemGroupHeading::isAccruePayableAtInvoicing_IN(ledgerJournalTrans.TaxItemGroup));

        this.updateTaxTransSiblings(taxTransIP, taxTransIR, taxTransRecoverable, taxTransPayable, _taxTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>serviceTaxReversePostingController</Name>
				<Source><![CDATA[
    /// <summary>
    /// Desides service tax reverse posting way.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller.
    /// </param>
    /// <param name="_taxTrans">
    /// The tax trans.
    /// </param>
    /// <param name="_exchRateHelper">
    /// The exchange rate helper.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The ledger dimension.
    /// </param>
    /// <param name="_ledgerDimension_IN">
    /// The ledger dimension in IN region.
    /// </param>
    /// <param name="_ledgerDimensionRev_IN">
    /// The ledger dimension rev in IN region.
    /// </param>
    /// <param name="_ledgerDetailLevel">
    /// The ledger detail level
    /// </param>
    public void serviceTaxReversePostingController(
        LedgerPostingController _ledgerPostingController,
        TaxTrans                _taxTrans,
        CurrencyExchangeHelper  _exchRateHelper,
        LedgerDimensionAccount  _ledgerDimension,
        LedgerDimensionAccount  _ledgerDimension_IN = 0,
        LedgerDimensionAccount  _ledgerDimensionRev_IN = 0,
        LedgerDetailLevel       _ledgerDetailLevel  = LedgerDetailLevel::AsDefault
    )
    {
        ttsbegin;
        // Advance payment only.
        if (ledgerJournalTrans.RecId
            && ledgerJournalTrans.isPaymentJournal_IN())
        {
            this.postReverseChargeServiceTaxAdvPay(
                                        _ledgerPostingController,
                                        _taxTrans,
                                        _exchRateHelper,
                                        _ledgerDimension,
                                        _ledgerDimension_IN,
                                        _ledgerDetailLevel
                                        );
        }
        // Plain Invoice/settlement.
        else if (ledgerJournalTrans.RecId
            && ledgerJournalTrans.isPaymentJournal_IN() == false// No Payment
            )
        {
            this.postReverseChargeServiceTaxInvoice(
                                        _ledgerPostingController,
                                        _taxTrans,
                                        _exchRateHelper,
                                        _ledgerDimension,
                                        _ledgerDimension_IN,
                                        _ledgerDimensionRev_IN,
                                        _ledgerDetailLevel);
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxTransSiblings</Name>
				<Source><![CDATA[
    /// <summary>
    /// Can be used only for service tax Reverse charge mechanism for updating TaxTrans with important information.
    /// Set TaxTrans sibling relations.
    /// Siblings are created by splitting the Tax generated by the tax code after applying reverse percentage defined on item sales tax group.
    /// IP is the only sibbling that is guarenteed to be present in all Reverse Charge entries.
    /// there can be a maxof 3 siblings IP,IR, R during invoice and a minimum of one (IP alone). Eg, 100 LOI on Invoice.
    /// This method also sets the TaxDirection and TaxOrigin, which are the key to succesful settlement and Authority Payment.
    /// </summary>
    /// <param name="_taxTransIP">
    /// Interim Payable taxtrans
    /// </param>
    /// <param name="_taxTransIR">
    /// Interim Recoverable taxtrans
    /// </param>
    /// <param name="_taxTransRecoverable">
    /// Recoverable taxtrans
    /// </param>
    /// <param name="_taxTransPayable">
    /// Payable taxtrans
    /// </param>
    /// <param name="_taxTrans">
    /// Original taxtrans
    /// </param>
    public void updateTaxTransSiblings(
        TaxTrans _taxTransIP,// IP is mandatory as its always present.
        TaxTrans _taxTransIR = null,
        TaxTrans _taxTransRecoverable = null,
        TaxTrans _taxTransPayable = null,
        TaxTrans _taxTrans = null)
    {
        SpecTrans               specTransRev;
        VendTransOpen           vendTransOpenRev;
        VendTrans               vendTransRev;
        LedgerTransVoucherLink  ledgerTransVoucherLink;
        LedgerTransVoucherLink  ledgerTransVoucherLinkLoc;
        TaxTrans                taxTransPaymentPayable;
        TaxTrans                nonInterimTaxTrans;// Either Payable or Recoverable
        TaxLedgerAccounts_IN    taxLedgerAccountRev;
        TaxTrans_W              taxTrans_W;
        TaxTrans_IN             taxTransIN;
        TaxTrans_W              taxTransPayment_W;

        ttsbegin;

        // Service Tax Interim Payable.
        if (_taxTransIP.RecId)
        {
            taxTrans_W = TaxTrans_W::findByTaxTrans(_taxTransIP.RecId,true);
            taxTrans_W.TaxTransRefRecId_IN = _taxTransIP.RecId;
            taxTrans_W.update();
        }
        // Service Tax Payable.
        if (_taxTransPayable.RecId)
        {
            taxTrans_W = TaxTrans_W::findByTaxTrans(_taxTransPayable.RecId,true);
            taxTrans_W.TaxTransRefRecId_IN = TaxItemGroupHeading::isAccruePayableAtInvoicing_IN(_taxTransPayable.TaxItemGroup) ? _taxTransPayable.RecId : _taxTransIP.RecId; //mark this tax trans of payable and used for final IR-R
            taxTrans_W.update();
        }
        // Service Tax Recoverable.
        if (_taxTransRecoverable.RecId)
        {
            taxTrans_W = TaxTrans_W::findByTaxTrans(_taxTransRecoverable.RecId,true);
            taxTrans_W.TaxTransRefRecId_IN = _taxTransIP.RecId;
            taxTrans_W.update();
        }
        // Service Tax Interim Recoverable.
        if (_taxTransIR.RecId)
        {
            // Invoice time IR needs to be reversed during Authority payment, and shown using related voucher.
            // we create the link to this here, using which we find which IR to be reversed during authPay.
            taxTrans_W = TaxTrans_W::findByTaxTrans(_taxTransIR.RecId,true);
            taxTrans_W.TaxTransRefRecId_IN = _taxTransIP.RecId;

            if (ledgerJournalTrans.RecId)
            {
                select firstonly RefCompany, RefTableId, RefRecId from specTransRev
                    where specTransRev.SpecRecId              == ledgerJournalTrans.RecId
                        && specTransRev.SpecTableId            == ledgerJournalTrans.TableId
                    join AccountNum, RefRecId from vendTransOpenRev
                        where specTransRev.RefCompany             == vendTransOpenRev.dataAreaId
                            && specTransRev.RefTableId             == vendTransOpenRev.TableId
                            && specTransRev.RefRecId               == vendTransOpenRev.RecId
                    join Voucher, TransDate from vendTransRev
                        where vendTransOpenRev.AccountNum         == vendTransRev.AccountNum
                            && vendTransOpenRev.RefRecId           == vendTransRev.RecId
                    join VoucherGroupId, TransDate from ledgerTransVoucherLink
                        where ledgerTransVoucherLink.Voucher      == vendTransRev.Voucher
                            && ledgerTransVoucherLink.TransDate    == vendTransRev.TransDate
                    // Get Payment attached to the running invoice.
                    join RecId, Voucher, TransDate from ledgerTransVoucherlinkLoc
                        where ledgerTransVoucherlinkLoc.VoucherGroupId  == ledgerTransVoucherLink.VoucherGroupId
                            && ledgerTransVoucherlinkLoc.TransDate       == ledgerTransVoucherLink.TransDate
                            && ledgerTransVoucherlinkLoc.Voucher         != vendTransRev.Voucher
                    join RecId from taxTransPaymentPayable// No recoverable in payment for Rev-charge.
                        where taxTransPaymentPayable.Voucher   == ledgerTransVoucherlinkLoc.Voucher
                            && taxTransPaymentPayable.TransDate == ledgerTransVoucherlinkLoc.TransDate
                            && taxTransPaymentPayable.TaxCode   == _taxTrans.TaxCode
                    exists join taxTransPayment_W
                        where taxTransPayment_W.TaxTrans   == taxTransPaymentPayable.RecId
                            && taxTransPayment_W.TaxType_IN == TaxType_IN::ServiceTax
                            && taxTransPayment_W.ServiceTaxReverseChargePercentage_IN != 0;
                if (ledgerTransVoucherlinkLoc.RecId)
                {
                    select firstonly RecId from nonInterimTaxTrans
                        where nonInterimTaxTrans.Voucher   == ledgerTransVoucherlinkLoc.Voucher
                           && nonInterimTaxTrans.TransDate == ledgerTransVoucherlinkLoc.TransDate
                           && nonInterimTaxTrans.TaxCode   == _TaxTrans.TaxCode
                        join PayableLedgerDimension from taxTransIN
                            where taxTransIN.RefRecId          == nonInterimTaxTrans.RecId
                        exists join taxLedgerAccountRev
                             where taxLedgerAccountRev.LedgerDimension == taxTransIN.PayableLedgerDimension
                                && taxLedgerAccountRev.AccountType   == TaxAccountType_IN::ServiceTaxPayableAccount;
                }
                // For GTA/Foreign, store Payable RecId, else Recoverable recId.
                if (nonInterimTaxTrans.RecId)
                {
                    taxTrans_W.TaxTransRefRecId_IN = nonInterimTaxTrans.RecId;
                }
            }
            taxTrans_W.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs an instance of <C>ServiceTaxRevChargePostingController_IN</C> and initializes it.
    /// </summary>
    /// <param name="_taxTrans">
    /// The tax trans.
    /// </param>
    /// <param name="_ledgerPostingType">
    /// The ledger posting type.
    /// </param>
    /// <param name="_tax">
    /// The tax.
    /// </param>
    /// <param name="_salesPurchJournalLine">
    /// The sales purch journal line.
    /// </param>
    /// <returns>
    /// Returns an instance of <C>ServiceTaxRevChargePostingController_IN</C>
    /// </returns>
    public static ServiceTaxRevChargePostingController_IN construct(
        TaxTrans                  _taxTrans,
        LedgerPostingType         _ledgerPostingType,
        Tax                       _tax,
        SalesPurchJournalLine     _salesPurchJournalLine)
    {
        boolean                                  isGTAVendor;
        boolean                                  isForeignVendor;
        boolean                                  canCreate = true;
        LedgerJournalTrans                       ledgerJournalTrans;
        TaxParameters                            taxParameters = TaxParameters::find();
        ServiceTaxRevChargePostingController_IN  serviceTaxRevChargePostingController;

        // Make sure that this object is created only for ServiceTax reverse charge feature.[POT + Puchase only]
        if ((taxParameters.ServiceTax_IN == NoYes::Yes)
            && _taxTrans.taxTrans_W().ServiceTaxReverseChargePercentage_IN)
        {
            ledgerJournalTrans = LedgerJournalTrans::findRecId(_taxTrans.SourceRecId,_taxTrans.SourceTableId);
            isGTAVendor = ledgerJournalTrans.isGTAVendorAccount_IN();
            isForeignVendor = ledgerJournalTrans.isForeignVendorAccount_IN();

            if (canCreate)// Stop @ begining only an invalid GTA.
            {
                serviceTaxRevChargePostingController = new ServiceTaxRevChargePostingController_IN();
                if (serviceTaxRevChargePostingController)
                {
                    serviceTaxRevChargePostingController.init(
                        _taxTrans,
                        _ledgerPostingType,
                        _tax,
                        _salesPurchJournalLine,
                        isGTAVendor,
                        isForeignVendor
                        );
                }
            }
        }

        return serviceTaxRevChargePostingController;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInvoiceFirstThenPayment_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates if is invoice first then payment or not.
    /// </summary>
    /// <param name="_specTableId">
    /// The spec table id.
    /// </param>
    /// <param name="_specRecId">
    /// The spec record id.
    /// </param>
    /// <returns>
    /// Returns true if is invoice first then payment.
    /// </returns>
    public static boolean isInvoiceFirstThenPayment_IN(
        RefTableId _specTableId,
        RefRecId   _specRecId)
    {
        SpecTrans               specTrans;
        VendTransOpen           vendTransOpen;
        VendTrans               vendTrans;
        TaxTrans                taxTransInvoice;
        TaxItemGroupHeading     taxItemGroupHeading;
        TaxTable                taxTable;
        TaxTrans_W              taxTrans_W;

        if (_specRecId)
        {
            select firstonly RefCompany, RefTableId, RefRecId from specTrans
                where specTrans.SpecRecId               == _specRecId
                   && specTrans.SpecTableId             == _specTableId
                join AccountNum, RefRecId from vendTransOpen
                    where specTrans.RefCompany              == vendTransOpen.dataAreaId
                       && specTrans.RefTableId              == vendTransOpen.TableId
                       && specTrans.RefRecId                == vendTransOpen.RecId
                join Voucher, TransDate from vendTrans
                    where vendTransOpen.AccountNum          == vendTrans.AccountNum
                       && vendTransOpen.RefRecId            == vendTrans.RecId
                join RecId, TaxCode, TaxItemGroup, SourceRegulateAmountCur from taxTransInvoice
                    where taxTransInvoice.Voucher           == vendTrans.Voucher
                       && taxTransInvoice.TransDate         == vendTrans.TransDate
                       && taxTransInvoice.SourceRegulateAmountCur != 0   // If RCR% is  100% the Recoverable record exists with 0 tax amounts. then the method returns false
                exists join taxTrans_W
                    where taxTrans_W.TaxTrans               == taxTransInvoice.RecId
                        && taxTrans_W.ServiceTaxReverseChargePercentage_IN != 0
                exists join taxTable
                    where taxTable.TaxType_IN               == TaxType_IN::ServiceTax
                       && taxTable.TaxCode                  == taxTransInvoice.TaxCode
                exists join taxItemGroupHeading
                    where taxItemGroupHeading.ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis
                       && taxItemGroupHeading.TaxItemGroup == taxTransInvoice.TaxItemGroup
                       && taxItemGroupHeading.ReverseChargePercentage_IN != 0;
        }

        return taxTransInvoice.SourceRegulateAmountCur != 0;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>