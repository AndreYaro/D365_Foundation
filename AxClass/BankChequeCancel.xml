<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BankChequeCancel</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>BankChequeCancel</c> class cancels a check and all its related information in the system.
/// </summary>
public class BankChequeCancel extends RunBase
{
    CompanyBankAccountId accountID;
    BankChequeNum chequeNum;
    TransDate cancelDate;
    BankChequeRecipientType recipientType;
    ReasonCode reason;
    ReasonComment reasonComment;
    NoYes reconcileBankTrans;
    LedgerJournalNameId journalName;

    BankChequeTable chequeToCancel;
    BankAccountTrans bankAccountTransToCancel;
    CustVendTrans custVendTransToCancel;
    SysModule custVendTransModule;
    RecId cashBridgeGeneralJournalAccountEntryToCancel;
    RecId offsetGeneralJournalAccountEntryToCancel;
    RecId interCompanyDebitGeneralJournalAccountEntryToCancel;
    RecId interCompanyCreditGeneralJournalAccountEntryToCancel;
    RecId payToLedgerAccountTransToCancel;

    boolean isChequeInterCompany;
    NumberSeq chequeCancelVoucherSequence;
    NumberSeq interCompanyCancelVoucherSequence;
    NumberSequenceReference chequeCancelNumberSeqRef;
    NumberSequenceCode interCompanyCancelNumberSeqCode;
    Voucher cancelTransVoucher;
    Voucher cancelInterCompanyTransVoucher;

    ReasonRefRecID cancelReasonRef;
    TransTxt cancelTransTxt;
    TransTxt cancelInterCompanyTransTxt;
    LedgerVoucherGroup cancelLedgerVoucherGroup;
    LedgerVoucher cancelLedgerVoucher;
    LedgerVoucherObject cancelLedgerVoucherObject;
    LedgerVoucher cancelInterCompanyLedgerVoucher;
    LedgerVoucherObject cancelInterCompanyLedgerVoucherObject;

    CustVendTable recipientCustVendTable;
    CustVendTrans cancellingCustVendTrans;

    // <GEERU>
    LedgerBondClient_RU     ledgerBondClient_RU;
    LedgerBondClient_RU     ledgerBondClientInterCompany_RU;
    // </GEERU>

    #DEFINE.CurrentVersion(6)
    #LOCALMACRO.CurrentList
        accountID,
        chequeNum,
        cancelDate,
        recipientType,
        reason,
        reasonComment,
        journalName,
        reconcileBankTrans
    #ENDMACRO
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkTaxWithholdFeeType_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reads the record from the table and check for existence of the record.
    /// </summary>
    /// <param name="_voucher">
    /// The field used to find the record.
    /// </param>
    /// <param name="_transDate">
    /// The field used to find the record.
    /// </param>
    /// <returns>
    /// Return the boolean value.
    /// </returns>
    private boolean checkTaxWithholdFeeType_IN(Voucher      _voucher,
                                               TransDate    _transDate)
    {
        LedgerJournalTrans      ledgerJournalTransLoc;
        CustVendPaymJournalFee  custVendPaymJournalFeeLoc;
        boolean                 checkStatus = false;
        TaxWithholdFeeType_IN   taxWithholdFeeType;

        while select Voucher, TransDate, TransactionType, RecId from ledgerJournalTransLoc
            where ledgerJournalTransLoc.Voucher         == _voucher
               && ledgerJournalTransLoc.TransDate       == _transDate
               && ledgerJournalTransLoc.TransactionType == LedgerTransType::Fee
            join FeeTransRecId, FeeId from custVendPaymJournalFeeLoc
                where custVendPaymJournalFeeLoc.FeeTransRecId == ledgerJournalTransLoc.RecId
        {
            taxWithholdFeeType = VendPaymFee::find(custVendPaymJournalFeeLoc.FeeId).TaxWithholdFeeType_IN;
            if (taxWithholdFeeType == TaxWithholdFeeType_IN::Interest || taxWithholdFeeType == TaxWithholdFeeType_IN::Others)
            {
                checkStatus = true;
                break;
            }
        }

        return checkStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeCancellingSettlements</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the settlements created from the customer or vendor transactions so that they cannot be
    ///    reversed.
    /// </summary>
    protected void closeCancellingSettlements()
    {
        CustSettlement custSettlementToClose;
        VendSettlement vendSettlementToClose;

        // Settlement records being updated are in the current company.
        switch (chequeToCancel.RecipientType)
        {
            case BankChequeRecipientType::Vend:
                // Update status of settlement records to prevent subsequent settlement reversals
                update_recordset vendSettlementToClose
                    setting CanBeReversed = NoYes::No
                    where (vendSettlementToClose.TransRecId == custVendTransToCancel.RecId ||
                        (vendSettlementToClose.OffsetRecid == custVendTransToCancel.RecId &&
                         vendSettlementToClose.OffsetCompany == custVendTransToCancel.company())) &&
                        vendSettlementToClose.CanBeReversed == NoYes::Yes;
                break;

            case BankChequeRecipientType::Cust:
                // Update status of settlement records to prevent subsequent settlement reversals
                update_recordset custSettlementToClose
                    setting CanBeReversed = NoYes::No
                    where (custSettlementToClose.TransRecId == custVendTransToCancel.RecId ||
                        (custSettlementToClose.OffsetRecid == custVendTransToCancel.RecId &&
                         custSettlementToClose.OffsetCompany == custVendTransToCancel.company())) &&
                        custSettlementToClose.CanBeReversed == NoYes::Yes;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCancelInterCompanyLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a <c>LedgerVoucher</c> object for the intercompany transactions that will be created for
    ///    the recipient company and adds it to the current <c>LedgerVoucherGroup</c> object.
    /// </summary>
    protected void createCancelInterCompanyLedgerVoucher()
    {
        changecompany(chequeToCancel.RecipientCompany)
        {
            // Create LedgerVoucher for customer/vendor transaction company
            cancelInterCompanyLedgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Detail, custVendTransModule, interCompanyCancelNumberSeqCode);

            cancelInterCompanyLedgerVoucher.parmCompanyId(chequeToCancel.RecipientCompany);
            cancelInterCompanyLedgerVoucher.parmCheckBlockedDimensions(false);

            // Initialize LedgerVoucherObject & set parms
            cancelInterCompanyLedgerVoucherObject = LedgerVoucherObject::newVoucher(
                                            cancelInterCompanyTransVoucher,
                                            cancelDate,
                                            custVendTransModule,
                                            custVendTransModule == SysModule::Cust ? LedgerTransType::Cust : LedgerTransType::Vend,
                                            LedgerParameters::find().TransactionReversalCorrection);

            // Set the correction parm if needed
            if (LedgerParameters::find().TransactionReversalCorrection)
            {
                cancelLedgerVoucherObject.parmCorrection(true);
            }

            cancelLedgerVoucherObject.lastTransTxt(cancelInterCompanyTransTxt);

            // Add LedgerVoucherObject to cancelling LedgerVoucher
            cancelInterCompanyLedgerVoucher.addVoucher(cancelInterCompanyLedgerVoucherObject);
        }

        // Add cancelling LedgerVoucher to LedgerVoucherGroup
        cancelLedgerVoucherGroup.addLedgerVoucher(cancelInterCompanyLedgerVoucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCancelLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a <c>LedgerVoucher</c> object for the transactions that will be created for the check
    ///    company and adds it to the current <c>LedgerVoucherGroup</c> object.
    /// </summary>
    protected void createCancelLedgerVoucher()
    {
        // Create LedgerVoucher for cheque company
        cancelLedgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Detail, custVendTransModule, chequeCancelNumberSeqRef.numberSequenceTable().NumberSequence);

        cancelLedgerVoucher.parmCompanyId(chequeToCancel.company());
        cancelLedgerVoucher.parmCheckBlockedDimensions(false);
        cancelLedgerVoucher.parmReversal(true);

        // Initialize LedgerVoucherObject & set parms
        cancelLedgerVoucherObject = LedgerVoucherObject::newVoucher(
                                        cancelTransVoucher,
                                        cancelDate,
                                        custVendTransModule,
                                        custVendTransModule == SysModule::Cust ? LedgerTransType::Cust : LedgerTransType::Vend,
                                        LedgerParameters::find().TransactionReversalCorrection);

        // Set the correction parm if needed
        if (LedgerParameters::find().TransactionReversalCorrection)
        {
            cancelLedgerVoucherObject.parmCorrection(true);
        }

        cancelLedgerVoucherObject.lastTransTxt(cancelTransTxt);

        // Add LedgerVoucherObject to cancelling LedgerVoucher
        cancelLedgerVoucher.addVoucher(cancelLedgerVoucherObject);

        // Add cancelling LedgerVoucher to LedgerVoucherGroup
        cancelLedgerVoucherGroup.addLedgerVoucher(cancelLedgerVoucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCancellingBankAccountTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the bank account transaction that cancels the bank account transaction that corresponds to
    ///    the check.
    /// </summary>
    protected void createCancellingBankAccountTrans()
    {
        BankAccountTrans cancellingBankAccountTrans;

        cancellingBankAccountTrans = bankAccountTransToCancel.data();
        cancellingBankAccountTrans.Voucher = cancelTransVoucher;
        cancellingBankAccountTrans.TransDate = cancelDate;
        cancellingBankAccountTrans.AmountMST = -bankAccountTransToCancel.AmountMST;
        cancellingBankAccountTrans.AmountReportingCurrency = -bankAccountTransToCancel.AmountReportingCurrency;
        cancellingBankAccountTrans.AmountCur = -bankAccountTransToCancel.AmountCur;
        cancellingBankAccountTrans.BankTransAmountCur = -bankAccountTransToCancel.BankTransAmountCur;
        cancellingBankAccountTrans.BankTransType = BankParameters::find().NSFTransactionType;
        cancellingBankAccountTrans.Included = reconcileBankTrans;
        cancellingBankAccountTrans.Reconciled = reconcileBankTrans;
        cancellingBankAccountTrans.Cancel = NoYes::Yes;
        cancellingBankAccountTrans.AccountStatementDate = reconcileBankTrans ? cancelDate : dateNull();
        cancellingBankAccountTrans.ReasonRefRecID = ReasonTableRef::checkCreateInCompany(cancelReasonRef, cancellingBankAccountTrans.DataAreaId);

        if (BankAccountTable::isAdvancedBankReconciliationEnabled(cancellingBankAccountTrans.AccountId)
            && FeatureStateProvider::isFeatureEnabled(BankTransClearedDateAdvancedBankReconciliationFeature::instance()))
        {
            cancellingBankAccountTrans.ClearedDate = cancelDate;
        }

        cancellingBankAccountTrans.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCancellingCashBridgeLedgerTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a new transaction to the current <c>LedgerVoucher</c> object that cancels the cash or
    ///    cash-in-transit account posting.
    /// </summary>
    protected void createCancellingCashBridgeLedgerTrans()
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        LedgerEntry ledgerEntry;
        LedgerEntryJournal ledgerEntryJournal;
        GeneralJournalEntry generalJournalEntry;
        LedgerJournalTable journalToCancel;
        LedgerVoucherTransObject postingTransaction;

        [ generalJournalAccountEntry, ledgerEntryJournal, generalJournalEntry, ledgerEntry] =
            GeneralLedgerExtension::findRelated(cashBridgeGeneralJournalAccountEntryToCancel);

        // Find the original journal voucher series
        select firstonly NumberSequenceTable from journalToCancel
            where journalToCancel.JournalNum == ledgerEntryJournal.JournalNumber;

        if (journalToCancel == null)
        {
            cancelLedgerVoucherObject.parmLedgerPostingJournalId(generalJournalEntry.LedgerPostingJournal);
        }
        else
        {
            cancelLedgerVoucher.parmVoucherSeriesCode(NumberSequenceTable::find(journalToCancel.NumberSequenceTable).NumberSequence);
        }

        postingTransaction = LedgerVoucherTransObject::newBasicDefault(
            cancelLedgerVoucherObject,
            generalJournalAccountEntry.PostingType,
            generalJournalAccountEntry.LedgerDimension,
            generalJournalAccountEntry.TransactionCurrencyCode,
            -generalJournalAccountEntry.TransactionCurrencyAmount,
            -generalJournalAccountEntry.AccountingCurrencyAmount,
            -generalJournalAccountEntry.ReportingCurrencyAmount);

        postingTransaction.parmSourceTableId(generalJournalAccountEntry.TableId);
        postingTransaction.parmSourceRecId(generalJournalAccountEntry.RecId);
        postingTransaction.parmQuantity(-generalJournalAccountEntry.Quantity);
        postingTransaction.parmFinTag(generalJournalAccountEntry.FinTag);

        // Add transaction to LedgerVoucher
        cancelLedgerVoucher.addTrans(postingTransaction);

        // <GIN>
        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            if (isChequeInterCompany)
            {
                this.reverseLedgerTrans_IN();
                isChequeInterCompany = isChequeInterCompany;
            }
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCancellingCustVendTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the customer or vendor transaction that cancels the customer or vendor transaction from the
    ///    recipient of the check.
    /// </summary>
    protected void createCancellingCustVendTrans()
    {
        GeneralJournalAccountEntry generaljournalaccountEntry;
        CustVendVoucher cancellingCustVendVoucher;
        CustVoucher cancellingCustVoucher;

        //<GIN>
        boolean     isSettlementProcess;
        CompanyId   companyId;
        str         message;
        //</GIN>

        switch (chequeToCancel.RecipientType)
        {
            case BankChequeRecipientType::Cust:
                if (isChequeInterCompany)
                {
                    changecompany(chequeToCancel.RecipientCompany)
                    {
                        generaljournalaccountEntry = GeneralJournalAccountEntry::find(this.getGeneralJournalAcctEntryByVoucherAndPostingType(
                            chequeToCancel.RecipientTransVoucher,
                            chequeToCancel.TransDate,
                            chequeToCancel.RecipientCompany,
                            chequeToCancel.ChequeNum,
                            LedgerPostingType::CustBalance));
                    }
                }
                else
                {
                    generaljournalaccountEntry = GeneralJournalAccountEntry::find(this.getGeneralJournalAcctEntryByPostingType(LedgerPostingType::CustBalance));
                }

                // Create CustVoucher in order to set the TransRefId & Type
                cancellingCustVoucher = CustVendVoucher::construct(
                                                custVendTransModule,
                                                custVendTransToCancel.AccountNum,
                                                -custVendTransToCancel.AmountCur,
                                                custVendTransToCancel.CurrencyCode,
                                                LedgerTransTxt::None,
                                                custVendTransToCancel.DefaultDimension,
                                                custVendTransToCancel.PostingProfile,
                                                LedgerPostingType::CustBalance);

                cancellingCustVoucher.parmPaymMode(custVendTransToCancel.PaymMode);
                cancellingCustVoucher.parmPaymSpec(custVendTransToCancel.PaymSpec);
                cancellingCustVoucher.parmTransTxt(isChequeInterCompany ? cancelInterCompanyTransTxt : cancelTransTxt);
                cancellingCustVoucher.parmTransDate(cancelDate);
                cancellingCustVoucher.parmExchRate(custVendTransToCancel.ExchRate);
                cancellingCustVoucher.parmExchRateSecondary(custVendTransToCancel.ExchRateSecond);
                cancellingCustVoucher.parmReportingCurrencyExchRate(custVendTransToCancel.ReportingCurrencyExchRate);
                cancellingCustVoucher.parmReportingCurrencyExchRateSecondary(custVendTransToCancel.ReportingCurrencyExchRateSecondary);
                cancellingCustVoucher.parmCancelledPayment(true);
                cancellingCustVoucher.parmCancelledLedgerDimension(generaljournalaccountEntry.LedgerDimension);
                cancellingCustVoucher.parmTransRefId(isChequeInterCompany ? cancelInterCompanyTransVoucher : cancelTransVoucher);
                cancellingCustVoucher.parmTransRefType(CustTransRefType::Other);
                cancellingCustVoucher.parmReasonRefRecID(cancelReasonRef);
                cancellingCustVoucher.parmFinTag(generaljournalaccountEntry.Fintag);

                // Copy cancelled to cancelling to maintain references to both for subsequent updates
                cancellingCustVendTrans = custVendTransToCancel.data();

                // <GIN>
                if (TaxWithholdParameters_IN::checkTaxParameters())
                {
                    cancellingCustVoucher.taxWithholdReversal_IN(BankChequeTable::find(accountID, chequeNum, true).Voucher,
                                                                bankAccountTransToCancel.TransDate,
                                                                cancellingCustVendTrans.TableId,
                                                                cancellingCustVendTrans.RecId,
                                                                cancelLedgerVoucher,
                                                                cancelDate,
                                                                isChequeInterCompany);
                }
                // </GIN>

                // Post cancelling customer/vendor transaction
                if (isChequeInterCompany)
                {
                    // Change to recipient company to post
                    changecompany(chequeToCancel.RecipientCompany)
                    {
                        cancellingCustVoucher.post(
                            isChequeInterCompany ? cancelInterCompanyLedgerVoucher : cancelLedgerVoucher,
                            cancellingCustVendTrans);
                    }
                }
                else
                {
                    cancellingCustVoucher.post(
                        isChequeInterCompany ? cancelInterCompanyLedgerVoucher : cancelLedgerVoucher,
                        cancellingCustVendTrans);
                }

                break;

            case BankChequeRecipientType::Vend:
                if (isChequeInterCompany)
                {
                    changecompany(chequeToCancel.RecipientCompany)
                    {
                        generaljournalaccountEntry = GeneralJournalAccountEntry::find(this.getGeneralJournalAcctEntryByVoucherAndPostingType(
                            chequeToCancel.RecipientTransVoucher,
                            chequeToCancel.TransDate,
                            chequeToCancel.RecipientCompany,
                            chequeToCancel.ChequeNum,
                            LedgerPostingType::VendBalance));
                    }
                }
                else
                {
                    generaljournalaccountEntry = GeneralJournalAccountEntry::find(this.getGeneralJournalAcctEntryByPostingType(LedgerPostingType::VendBalance));
                }

                cancellingCustVendVoucher = CustVendVoucher::construct(
                                                custVendTransModule,
                                                custVendTransToCancel.AccountNum,
                                                -custVendTransToCancel.AmountCur,
                                                custVendTransToCancel.CurrencyCode,
                                                LedgerTransTxt::None,
                                                custVendTransToCancel.DefaultDimension,
                                                custVendTransToCancel.PostingProfile,
                                                LedgerPostingType::VendBalance);

                cancellingCustVendVoucher.parmPaymMode(custVendTransToCancel.PaymMode);
                cancellingCustVendVoucher.parmPaymSpec(custVendTransToCancel.PaymSpec);
                cancellingCustVendVoucher.parmTransTxt(isChequeInterCompany ? cancelInterCompanyTransTxt : cancelTransTxt);
                cancellingCustVendVoucher.parmTransDate(cancelDate);
                cancellingCustVendVoucher.parmExchRate(custVendTransToCancel.ExchRate);
                cancellingCustVendVoucher.parmExchRateSecondary(custVendTransToCancel.ExchRateSecond);
                cancellingCustVendVoucher.parmReportingCurrencyExchRate(custVendTransToCancel.ReportingCurrencyExchRate);
                cancellingCustVendVoucher.parmReportingCurrencyExchRateSecondary(custVendTransToCancel.ReportingCurrencyExchRateSecondary);
                cancellingCustVendVoucher.parmCancelledPayment(true);
                cancellingCustVendVoucher.parmCancelledLedgerDimension(generaljournalaccountEntry.LedgerDimension);
                cancellingCustVendVoucher.parmReasonRefRecID(cancelReasonRef);
                cancellingCustVendVoucher.parmFinTag(generaljournalaccountEntry.Fintag);

                // Copy cancelled to cancelling to maintain references to both for subsequent updates
                cancellingCustVendTrans = custVendTransToCancel.data();

                // <GIN>

                if (TaxWithholdParameters_IN::checkTaxParameters())
                {
                    [isSettlementProcess, companyId] = this.isSettlementProcessRun_IN(cancellingCustVendTrans);
                    if (isSettlementProcess)
                    {
                        message = strfmt("@GLS50985",companyId);
                        if (Box::yesNo(message, DialogButton::No) == DialogButton::No)
                        {
                            throw error("@GLS6279");
                        }
                    }

                    cancellingCustVendVoucher.taxWithholdReversal_IN(BankChequeTable::find(accountID, chequeNum, true).Voucher,
                                                                                       bankAccountTransToCancel.TransDate,
                                                                                        cancellingCustVendTrans.TableId,
                                                                                        cancellingCustVendTrans.RecId,
                                                                                        cancelLedgerVoucher,
                                                                                        cancelDate,
                                                                                        isChequeInterCompany);
                }

                if (TaxParameters::checkTaxParameters_IN())
                {
                    if (BankChequeCancel::isSalesTaxSettlementProcessRun_IN(cancellingCustVendTrans))
                    {
                        throw error("@GLS62632");
                    }
                }
                // </GIN>

                // Post cancelling customer/vendor transaction
                if (isChequeInterCompany)
                {
                    // Change to recipient company to post
                    changecompany(chequeToCancel.RecipientCompany)
                    {
                        cancellingCustVendVoucher.post(
                            isChequeInterCompany ? cancelInterCompanyLedgerVoucher : cancelLedgerVoucher,
                            cancellingCustVendTrans);
                    }
                }
                else
                {
                    cancellingCustVendVoucher.post(
                        isChequeInterCompany ? cancelInterCompanyLedgerVoucher : cancelLedgerVoucher,
                        cancellingCustVendTrans);
                }

                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCancellingInterCompanyTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds new transactions to the current <c>LedgerVoucher</c> objects that cancel the intercompany
    ///    account postings.
    /// </summary>
    protected void createCancellingInterCompanyTrans()
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        LedgerEntry ledgerEntry;
        LedgerEntryJournal ledgerEntryJournal;
        GeneralJournalEntry generalJournalEntry;
        LedgerVoucherTransObject postingTransaction;

        [ generalJournalAccountEntry, ledgerEntryJournal, generalJournalEntry, ledgerEntry] =
            GeneralLedgerExtension::findRelated(interCompanyDebitGeneralJournalAccountEntryToCancel);

        cancelLedgerVoucherObject.lastTransTxt(cancelTransTxt);

        postingTransaction = LedgerVoucherTransObject::newBasicDefault(
            cancelLedgerVoucherObject,
            LedgerPostingType::InterCompany,
            generalJournalAccountEntry.LedgerDimension,
            generalJournalAccountEntry.TransactionCurrencyCode,
            -generalJournalAccountEntry.TransactionCurrencyAmount,
            -generalJournalAccountEntry.AccountingCurrencyAmount,
            -generalJournalAccountEntry.ReportingCurrencyAmount);

        postingTransaction.parmSourceTableId(generalJournalAccountEntry.TableId);
        postingTransaction.parmSourceRecId(generalJournalAccountEntry.RecId);
        postingTransaction.parmQuantity(-generalJournalAccountEntry.Quantity);
        postingTransaction.parmFinTag(generaljournalaccountEntry.FinTag);

        // Add transaction to LedgerVoucher to offset cash transaction
        cancelLedgerVoucher.addTrans(postingTransaction);

        // Add transaction to intercompany LedgerVoucher to offset customer/vendor transaction
        // Must be in recipient company for calculations to lookup rates in correct company
        changecompany(chequeToCancel.RecipientCompany)
        {
            [generalJournalAccountEntry, ledgerEntryJournal, generalJournalEntry, ledgerEntry] =
                GeneralLedgerExtension::findRelated(interCompanyCreditGeneralJournalAccountEntryToCancel);

            cancelInterCompanyLedgerVoucherObject.lastTransTxt(cancelInterCompanyTransTxt);

            postingTransaction = LedgerVoucherTransObject::newBasicDefault(
                cancelInterCompanyLedgerVoucherObject,
                LedgerPostingType::InterCompany,
                generalJournalAccountEntry.LedgerDimension,
                generalJournalAccountEntry.TransactionCurrencyCode,
                -generalJournalAccountEntry.TransactionCurrencyAmount,
                -generalJournalAccountEntry.AccountingCurrencyAmount,
                -generalJournalAccountEntry.ReportingCurrencyAmount);

            postingTransaction.parmSourceTableId(generalJournalAccountEntry.TableId);
            postingTransaction.parmSourceRecId(generalJournalAccountEntry.RecId);
            postingTransaction.parmQuantity(-generalJournalAccountEntry.Quantity);

            cancelInterCompanyLedgerVoucher.addTrans(postingTransaction);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCancellingPayToLedgerAccountTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the ledger transaction that cancels the ledger transaction from the recipient of the check.
    /// </summary>
    protected void createCancellingPayToLedgerAccountTrans()
    {
        GeneralJournalAccountEntry      generalJournalAccountEntry;
        LedgerEntry                     ledgerEntry;
        LedgerEntryJournal              ledgerEntryJournal;
        GeneralJournalEntry            generalJournalEntry;
        LedgerJournalTable              journalToCancel;
        LedgerVoucherTransObject        postingTransaction;

        if (chequeToCancel.RecipientType == BankChequeRecipientType::Ledger && payToLedgerAccountTransToCancel != 0)
        {
            [ generalJournalAccountEntry, ledgerEntryJournal, generalJournalEntry, ledgerEntry] =
                GeneralLedgerExtension::findRelated(payToLedgerAccountTransToCancel);

            // Find the original journal voucher series
            select firstonly NumberSequenceTable from journalToCancel
                where journalToCancel.JournalNum == ledgerEntryJournal.JournalNumber;

            if (journalToCancel == null)
            {
                cancelLedgerVoucherObject.parmLedgerPostingJournalId(generalJournalEntry.LedgerPostingJournal);
            }
            else
            {
                cancelLedgerVoucher.parmVoucherSeriesCode(NumberSequenceTable::find(journalToCancel.NumberSequenceTable).NumberSequence);
            }

            postingTransaction = LedgerVoucherTransObject::newBasicDefault(
                cancelLedgerVoucherObject,
                generalJournalAccountEntry.PostingType,
                generalJournalAccountEntry.LedgerDimension,
                generalJournalAccountEntry.TransactionCurrencyCode,
                -generalJournalAccountEntry.TransactionCurrencyAmount,
                -generalJournalAccountEntry.AccountingCurrencyAmount,
                -generalJournalAccountEntry.ReportingCurrencyAmount);

            postingTransaction.parmSourceTableId(generalJournalAccountEntry.TableId);
            postingTransaction.parmSourceRecId(generalJournalAccountEntry.RecId);
            postingTransaction.parmQuantity(-generalJournalAccountEntry.Quantity);
            postingTransaction.parmFinTag(generaljournalaccountEntry.FinTag);

            // Add transaction to LedgerVoucher
            cancelLedgerVoucher.addTrans(postingTransaction);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCancellingTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the transactions that cancel the transactions that correspond to the check.
    /// </summary>
    protected void createCancellingTrans()
    {
        // <GEERU><GIN>
        #ISOCountryRegionCodes
        // </GIN></GEERU>
        // <GEERU>
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        // <GIN>
        boolean countryRegion_IN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        // </GIN>

        // Create LedgerVoucherGroup
        cancelLedgerVoucherGroup = LedgerVoucherGroup::construct();

        // Create LedgerVoucher & LedgerVoucherObject for cheque company transactions
        this.createCancelLedgerVoucher();

        // <GEERU>
        if (countryRegion_RU)
        {
            ledgerBondClient_RU = cancelLedgerVoucherObject.ledgerBondClient_RU();
            if (ledgerBondClient_RU)
            {
                ledgerBondClient_RU.addNewLogObject();
            }
        }
        // </GEERU>

        // Create cancelling bank account transaction, if needed
        if (bankAccountTransToCancel.RecId != 0)
        {
            // <GIN>
            if (countryRegion_IN
                && TaxWithholdParameters_IN::checkTaxParameters()
                && this.checkTaxWithholdFeeType_IN(bankAccountTransToCancel.Voucher, bankAccountTransToCancel.TransDate))
            {
                this.taxWithholdCancelPaymentFee_IN(bankAccountTransToCancel.TransDate,
                                                    bankAccountTransToCancel.Voucher,
                                                    bankAccountTransToCancel.ChequeNum);
            }
            else
            {
                // </GIN>
                this.createCancellingBankAccountTrans();
                // <GIN>
            }
            // </GIN>
        }

        // Create cancelling cash or bridging ledger transaction as cancelling does not use BankVoucher

        // <GIN>
        if (countryRegion_IN
            && TaxWithholdParameters_IN::checkTaxParameters()
            && this.checkTaxWithholdFeeType_IN(bankAccountTransToCancel.Voucher, bankAccountTransToCancel.TransDate))
        {
            this.taxWithholdReverseLedgerTrans_IN();
        }
        else
        {
            // </GIN>
            this.createCancellingCashBridgeLedgerTrans();
            // <GIN>
        }
        // </GIN>

        // If cheque was intercompany, create LedgerVoucher for intercompany transactions
        if (isChequeInterCompany)
        {
            this.createCancelInterCompanyLedgerVoucher();

            // <GEERU>
            if (countryRegion_RU)
            {
                changecompany(chequeToCancel.RecipientCompany)
                {
                    ledgerBondClientInterCompany_RU = cancelInterCompanyLedgerVoucherObject.ledgerBondClient_RU();
                    if (ledgerBondClientInterCompany_RU)
                    {
                        ledgerBondClientInterCompany_RU.addNewLogObject();
                    }
                }
            }
            // </GEERU>
        }

        // Create & post cancelling customer/vendor transaction - ledger transaction will be included
        this.createCancellingCustVendTrans();

        // Create & post cancelling ledger transation
        this.createCancellingPayToLedgerAccountTrans();

        // If cheque was intercompany, create cancelling IC ledger transactions for both companies
        if (isChequeInterCompany)
        {
            this.createCancellingInterCompanyTrans();

            // <GEERU>
            if (ledgerBondClientInterCompany_RU)
            {
                changecompany(chequeToCancel.RecipientCompany)
                {
                    ledgerBondClientInterCompany_RU.bondLastVRef2CurrentLog();
                    ledgerBondClientInterCompany_RU.removeCurrentLogObject();
                }
            }
            // </GEERU>
        }

        // <GEERU>
        if (ledgerBondClient_RU)
        {
            ledgerBondClient_RU.bondLastVRef2CurrentLog();
            ledgerBondClient_RU.removeCurrentLogObject();
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteBankChequePaymTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the <c>BankChequePaymTrans</c> records created when settling the canceled customer or
    ///    vendor transactions.
    /// </summary>
    protected void deleteBankChequePaymTrans()
    {
        BankChequePaymTrans deleteBankChequePaymTrans;

        // Delete records linking the cancelled and cancelling transactions
        delete_from deleteBankChequePaymTrans
            where (deleteBankChequePaymTrans.TransDate == custVendTransToCancel.TransDate &&
                deleteBankChequePaymTrans.Voucher == custVendTransToCancel.Voucher &&
                deleteBankChequePaymTrans.ChequeNum == chequeToCancel.ChequeNum) ||
                (deleteBankChequePaymTrans.TransDate == cancellingCustVendTrans.TransDate &&
                deleteBankChequePaymTrans.Voucher == cancellingCustVendTrans.Voucher &&
                deleteBankChequePaymTrans.ChequeNum == chequeToCancel.ChequeNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteLedgerTransFurtherPosting</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes <c>LedgerTransFurtherPosting</c> records if the check was printed based on a
    ///    cash-in-transit account.
    /// </summary>
    /// <remarks>
    ///    There will be <c>LedgerTransFurtherPosting</c> records after the payment is posted, but before the
    ///    transaction has been transferred from the cash-in-transit to the bank account.
    /// </remarks>
    protected void deleteLedgerTransFurtherPosting()
    {
        LedgerTransFurtherPosting deleteLedgerTransFurtherPosting;

        if (BankChequeCancelDeleteLedgerTransFurtherPostingFlight::instance().isEnabled())
        {
            LedgerEntry ledgerEntry;
            delete_from deleteLedgerTransFurtherPosting
                exists join ledgerEntry
                    where ledgerEntry.RecId == deleteLedgerTransFurtherPosting.RefRecId
                        && ledgerEntry.GeneralJournalAccountEntry == cashBridgeGeneralJournalAccountEntryToCancel;
        }
        else
        {
            // Delete the LedgerTransFurtherPosting record(s) associated with the ledger transaction
            delete_from deleteLedgerTransFurtherPosting
                where deleteLedgerTransFurtherPosting.RefRecId == cashBridgeGeneralJournalAccountEntryToCancel;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    ///    interface.
    /// </summary>
    /// <returns>
    ///    A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    ///    A dialog can be either built by using the <c>Dialog</c> class or by using a class that is created
    ///    in the Application Object Tree (AOT).
    /// </remarks>
    public Object dialog()
    {
        DialogRunbase   dialog = Dialog::newFormnameRunbase(formStr(BankChequeCancel),this);

        dialog.caption("@SYS22512");
        dialog = this.dialogInternal(dialog);

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCancelTransTxt</Name>
				<Source><![CDATA[
    protected void getCancelTransTxt()
    {
        cancelTransTxt = strFmt('%1: %2, %3',"@SYS1068", chequeToCancel.Voucher, reasonComment);
        cancelInterCompanyTransTxt = strFmt('%1: %2, %3',"@SYS1068", chequeToCancel.RecipientTransVoucher, reasonComment);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashBridgeLedgerTransToCancel</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the general journal transaction that corresponds to the cash or cash-in-transit account
    ///    posting for the check.
    /// </summary>
    protected void getCashBridgeLedgerTransToCancel()
    {
        Debug::assert(chequeToCancel != null);

        cashBridgeGeneralJournalAccountEntryToCancel = this.getGeneralJournalAcctEntryByPostingType(LedgerPostingType::Bank);

        if (!cashBridgeGeneralJournalAccountEntryToCancel)
        {
            cashBridgeGeneralJournalAccountEntryToCancel = this.getGeneralJournalAcctEntryByPostingType(LedgerPostingType::LedgerJournal);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendTransToCancel</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the customer or vendor transaction that was paid by the check.
    /// </summary>
    protected void getCustVendTransToCancel()
    {
        Debug::assert(chequeToCancel != null);

        if (custVendTransToCancel.RecId == 0)
        {
            // If the customer/vendor transaction to cancel wasn't passed in via the dialog, find it.
            custVendTransToCancel = BankChequeCancel::findCustVendTransForCheque(chequeToCancel);
        }

        if (custVendTransToCancel.TableId == tableNum(CustTrans))
        {
            custVendTransModule = SysModule::Cust;
        }
        else
        {
            custVendTransModule = SysModule::Vend;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGeneralJournalAcctEntryByPostingType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Get RecId of general journal transaction for a specific posting type.
    /// </summary>
    /// <param name="_postingType">
    ///     posting type of LedgerPostingType type, eg. Bank, LedgerJournal, etc.
    /// </param>
    /// <returns>
    ///     RecId of table generalJournalAccountEntry.
    /// </returns>
    private RefRecId getGeneralJournalAcctEntryByPostingType(LedgerPostingType _postingType)
    {
        RefRecId generalJournalAccountEntryRecId;

        Debug::assert(chequeToCancel != null);

        generalJournalAccountEntryRecId = this.getGeneralJournalAcctEntryByVoucherAndPostingType(chequeToCancel.Voucher,
            chequeToCancel.TransDate,
            chequeToCancel.DataAreaId,
            chequeToCancel.ChequeNum,
            _postingType);

        if (generalJournalAccountEntryRecId == 0 && bankAccountTransToCancel)
        {
            generalJournalAccountEntryRecId = this.getGeneralJournalAcctEntryByVoucherAndPostingType(bankAccountTransToCancel.Voucher,
                bankAccountTransToCancel.TransDate,
                bankAccountTransToCancel.DataAreaId,
                bankAccountTransToCancel.ChequeNum,
                _postingType);
        }

        if (generalJournalAccountEntryRecId == 0)
        {
            generalJournalAccountEntryRecId = this.getGeneralJournalAcctEntryByVoucherWithBridging(chequeToCancel.Voucher,
                chequeToCancel.TransDate,
                chequeToCancel.DataAreaId,
                chequeToCancel.ChequeNum);
        }

        return generalJournalAccountEntryRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGeneralJournalAcctEntryByVoucherAndPostingType</Name>
				<Source><![CDATA[
    private RefRecId getGeneralJournalAcctEntryByVoucherAndPostingType(Voucher _voucher,
        TransDate _transDate,
        DataAreaId _dataAreadId,
        BankChequeNum _chequeNum,
        LedgerPostingType _postingType)
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;

        select firstonly RecId from subledgerVoucherGeneralJournalEntry
            where subledgerVoucherGeneralJournalEntry.Voucher == _voucher
                && subledgerVoucherGeneralJournalEntry.AccountingDate == _transDate
                && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == _dataAreadId
                join RecId from generalJournalEntry
                    where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
                        && generalJournalEntry.Ledger == Ledger::current()
                join RecId from generalJournalAccountEntry
                    where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                        && generalJournalAccountEntry.PaymentReference == _chequeNum
                        && generalJournalAccountEntry.PostingType == _postingType;

        return generalJournalAccountEntry.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGeneralJournalAcctEntryByVoucherWithBridging</Name>
				<Source><![CDATA[
    private RefRecId getGeneralJournalAcctEntryByVoucherWithBridging(
        Voucher _voucher,
        TransDate _transDate,
        DataAreaId _dataAreadId,
        BankChequeNum _chequeNum)
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        LedgerEntry ledgerEntry;
        GeneralJournalEntry generalJournalEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;

        select firstonly RecId from subledgerVoucherGeneralJournalEntry
            where subledgerVoucherGeneralJournalEntry.Voucher == _voucher
                && subledgerVoucherGeneralJournalEntry.AccountingDate == _transDate
                && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == _dataAreadId
            join RecId from generalJournalEntry
                where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
                    && generalJournalEntry.Ledger == Ledger::current()
            join RecId from generalJournalAccountEntry
                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                    && generalJournalAccountEntry.PaymentReference == _chequeNum
                    && generalJournalAccountEntry.IsCredit == NoYes::Yes
            join RecId from ledgerEntry
                where ledgerEntry.GeneralJournalAccountEntry == generalJournalAccountEntry.RecId
                    && ledgerEntry.IsBridgingPosting == NoYes::Yes;

        return generalJournalAccountEntry.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInterCompanyLedgerTransToCancel</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the general journal transactions for the intercompany account postings for the check.
    /// </summary>
    protected void getInterCompanyLedgerTransToCancel()
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;

        container recipientCompany;

        Debug::assert(chequeToCancel != null);

        if (isChequeInterCompany)
        {
            select firstonly RecId from subledgerVoucherGeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.Voucher == chequeToCancel.Voucher &&
                    subledgerVoucherGeneralJournalEntry.AccountingDate == chequeToCancel.TransDate &&
                    subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == chequeToCancel.DataAreaId
            join RecId from generalJournalEntry
                where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry &&
                      generalJournalEntry.Ledger == Ledger::current()
            join RecId from generalJournalAccountEntry
                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry &&
                    generalJournalAccountEntry.PostingType == LedgerPostingType::InterCompany &&
                    generalJournalAccountEntry.IsCredit == false;

            interCompanyDebitGeneralJournalAccountEntryToCancel = generalJournalAccountEntry.RecId;

            recipientCompany += [chequeToCancel.RecipientCompany];

            select firstonly crossCompany:recipientCompany RecId from subledgerVoucherGeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.Voucher == chequeToCancel.RecipientTransVoucher &&
                    subledgerVoucherGeneralJournalEntry.AccountingDate == chequeToCancel.TransDate &&
                    subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == chequeToCancel.RecipientCompany
            join RecId from generalJournalEntry
                where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry &&
                    generalJournalEntry.Ledger == Ledger::primaryLedger(CompanyInfo::findDataArea(chequeToCancel.RecipientCompany).RecId)
            join RecId from generalJournalAccountEntry
                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry &&
                    generalJournalAccountEntry.PostingType == LedgerPostingType::InterCompany &&
                    generalJournalAccountEntry.IsCredit == true;

            interCompanyCreditGeneralJournalAccountEntryToCancel = generalJournalAccountEntry.RecId;
        }
        else
        {
            interCompanyDebitGeneralJournalAccountEntryToCancel = 0;
            interCompanyCreditGeneralJournalAccountEntryToCancel = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets class values to what is stored in <c>SysLastValue</c> records.
    /// </summary>
    /// <remarks>
    ///    This method does not call the <c>super</c> method so that values are not retrieved when a new
    ///    <c>BankChequeCancel</c> instance is created.
    /// </remarks>
    public void getLast()
    {
        return;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPayToLedgerAccountTransToCancel</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the general journal transaction that is the recipient of the check.
    /// </summary>
    /// <remarks>
    ///    The payment can be made to the ledger account. It is possible to have payment and cash accounts as
    ///    ledger accounts. Since the payment and cash account may both be ledger accounts, we want the
    ///    general journal account entry that is a ledger account and is not the cash account.
    /// </remarks>
    protected void getPayToLedgerAccountTransToCancel()
    {
        GeneralJournalAccountEntry          generalJournalAccountEntry;
        GeneralJournalEntry                 generalJournalEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;

        Debug::assert(chequeToCancel != null);
        Debug::assert(cashBridgeGeneralJournalAccountEntryToCancel != 0);

        while select RecId from subledgerVoucherGeneralJournalEntry
            where subledgerVoucherGeneralJournalEntry.Voucher == chequeToCancel.Voucher &&
                subledgerVoucherGeneralJournalEntry.AccountingDate == chequeToCancel.TransDate &&
                subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == chequeToCancel.DataAreaId
        join RecId from generalJournalEntry
            where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry &&
                generalJournalEntry.Ledger == Ledger::current()
        join RecId from generalJournalAccountEntry
            where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry &&
                generalJournalAccountEntry.PaymentReference == chequeToCancel.ChequeNum &&
                generalJournalAccountEntry.PostingType == LedgerPostingType::LedgerJournal
        {
            if (generalJournalAccountEntry.RecId != cashBridgeGeneralJournalAccountEntryToCancel)
            {
                payToLedgerAccountTransToCancel = generalJournalAccountEntry.RecId;
                break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRecipientCustVendTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the customer or vendor who is the recipient of the check.
    /// </summary>
    protected void getRecipientCustVendTable()
    {
        // Get customer/vendor record
        switch (chequeToCancel.RecipientType)
        {
            case BankChequeRecipientType::Cust:
                if (isChequeInterCompany)
                {
                    recipientCustVendTable = CustTable::findByCompany(chequeToCancel.RecipientCompany, chequeToCancel.RecipientAccountNum);
                }
                else
                {
                    recipientCustVendTable = CustTable::findByCompany(chequeToCancel.company(), chequeToCancel.RecipientAccountNum);
                }

                break;

            case BankChequeRecipientType::Vend:
                if (isChequeInterCompany)
                {
                    recipientCustVendTable = VendTable::findByCompany(chequeToCancel.RecipientCompany, chequeToCancel.RecipientAccountNum);
                }
                else
                {
                    recipientCustVendTable = VendTable::findByCompany(chequeToCancel.company(), chequeToCancel.RecipientAccountNum);
                }

                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransToCancel</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the transactions to cancel that correspond to the check.
    /// </summary>
    protected void getTransToCancel()
    {
        // Get BankChequeTable
        chequeToCancel = BankChequeTable::find(accountID, chequeNum, false);

        if (chequeToCancel.RecipientCompany != '' && chequeToCancel.company() != chequeToCancel.RecipientCompany)
        {
            isChequeInterCompany = true;
        }
        else
        {
            isChequeInterCompany = false;
        }

        // Get BankAccountTrans
        bankAccountTransToCancel = BankAccountTrans::findByAccountIDAndChequeNum(accountID, chequeNum, true);

        // Get CustVendTrans
        this.getCustVendTransToCancel();

        // Get cash or bridging LedgerTrans
        this.getCashBridgeLedgerTransToCancel();

        // Get payment ledger account
        this.getPayToLedgerAccountTransToCancel();

        // Get intercompany LedgerTrans
        this.getInterCompanyLedgerTransToCancel();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVouchersForCancellingTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the number sequences and voucher numbers that will be used for posting the transactions that
    ///    cancel the transaction that correspond to the check.
    /// </summary>
    protected void getVouchersForCancellingTrans()
    {
        LedgerInterCompany interCompanySetup;
        LedgerJournalName interCompanyJournalSetup;

        // <GEERU>
        #ISOCountryRegionCodes
        boolean     countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        // Get voucher for cancelling cheque company transactions
        if (chequeToCancel.RecipientType == BankChequeRecipientType::Cust)
        {
            chequeCancelNumberSeqRef = CustParameters::numRefCustCloseVoucher();
            chequeCancelVoucherSequence = NumberSeq::newGetVoucher(chequeCancelNumberSeqRef);
        }
        else
        {
            chequeCancelNumberSeqRef = VendParameters::numRefVendCloseVoucher();
            chequeCancelVoucherSequence = NumberSeq::newGetVoucher(chequeCancelNumberSeqRef);
        }

        cancelTransVoucher = chequeCancelVoucherSequence.voucher();

        // Get voucher for cancelling intercompany transactions, if needed
        if (isChequeInterCompany)
        {
            interCompanySetup = LedgerInterCompany::findCompanyPair(chequeToCancel.company(), chequeToCancel.RecipientCompany);

            changecompany(chequeToCancel.RecipientCompany)
            {
                // Get the LedgerIntercompany & intercompany journal records from the recipient company for the cheque company

                // <GEERU>
                if (countryRegion_RU)
                {
                    changecompany(chequeToCancel.company())
                    {
                        interCompanyJournalSetup = LedgerJournalName::find(interCompanySetup.JournalName);

                        // Get voucher number for cancelling recipient company transactions
                        interCompanyCancelNumberSeqCode = NumberSequenceTable::find(interCompanyJournalSetup.NumberSequenceTable).NumberSequence;
                        interCompanyCancelVoucherSequence = NumberSeq::newGetVoucherFromCode(interCompanyCancelNumberSeqCode);

                        cancelInterCompanyTransVoucher = interCompanyCancelVoucherSequence.voucher();
                    }
                }
                else
                {
                    // </GEERU>
                    interCompanyJournalSetup = LedgerJournalName::find(interCompanySetup.JournalName);

                    // Get voucher number for cancelling recipient company transactions
                    interCompanyCancelNumberSeqCode = NumberSequenceTable::find(interCompanyJournalSetup.NumberSequenceTable).NumberSequence;
                    interCompanyCancelVoucherSequence = NumberSeq::newGetVoucherFromCode(interCompanyCancelNumberSeqCode);

                    cancelInterCompanyTransVoucher = interCompanyCancelVoucherSequence.voucher();
                    // <GEERU>
                }
                // </GEERU>
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParms</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets fields on the class that are presented to the user on the <c>BankChequeCancel</c> form.
    /// </summary>
    /// <param name="_transDate">
    ///    The date of the payment reversal.
    /// </param>
    /// <param name="_reason">
    ///    A <c>ReasonCode</c> for why the Cheque was canceled.
    /// </param>
    /// <param name="_reasonComment">
    ///    A description of why the Cheque was canceled.
    /// </param>
    /// <param name="_reconcile">
    ///    A <c>NoYes</c> enumeration value that indicates whether the transaction should be reconciled.
    /// </param>
    /// <param name="_journalName">
    ///    The name of a journal.
    /// </param>
    /// <remarks>
    ///    The <c>BankChequeCancel</c> form calls this method to tell the class what the user has entered on
    ///    the form.
    /// </remarks>
    public void initParms(TransDate _transDate,
        ReasonCode _reason,
        ReasonComment _reasonComment,
        NoYes _reconcile,
        LedgerJournalNameId _journalName)
    {
        this.parmTransDate(_transDate);
        this.parmReason(_reason);
        this.parmReasonComment(_reasonComment);
        this.parmReconcile(_reconcile);
        this.parmJournalName(_journalName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProcessRunInDifferentCompany_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reads the table buffer.
    /// </summary>
    /// <param name="_taxWithholdTransCrossCompany">
    /// The table buffer used to find the record.
    /// </param>
    /// <returns>
    /// Returns the table.
    /// </returns>
    public TaxWithholdSettleTrans_IN isProcessRunInDifferentCompany_IN(TaxWithholdTrans_IN _taxWithholdTransCrossCompany)
    {
        TaxWithholdSettleTrans_IN   taxSettleTrans;

        changecompany(_taxWithholdTransCrossCompany.company())
        {
            select  taxSettleTrans
                where taxSettleTrans.OrigVoucher    == _taxWithholdTransCrossCompany.Voucher
                   && taxSettleTrans.TransDate      == _taxWithholdTransCrossCompany.TransDate;
        }

        return  taxSettleTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSettlementProcessRun_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reads the table buffer and used a container for specific record.
    /// </summary>
    /// <param name="_vendTrans">
    /// The table buffer used to find the record.
    /// </param>
    /// <returns>
    /// Returns the container.
    /// </returns>
    public container isSettlementProcessRun_IN(VendTrans  _vendTrans)
    {
        TaxWithholdSettleTrans_IN   taxSettleTrans;
        TaxWithholdTrans_IN         taxWithholdTransCrossCompany;
        container                   isSettlementProcess;

        while select Voucher, TransDate from taxWithholdTransCrossCompany
            where (taxWithholdTransCrossCompany.Voucher             == _vendTrans.Voucher
                || taxWithholdTransCrossCompany.SettlementVoucher   == _vendTrans.Voucher)
                && taxWithholdTransCrossCompany.TransDate           == _vendTrans.TransDate
        {
            taxSettleTrans = this.isProcessRunInDifferentCompany_IN(taxWithholdTransCrossCompany);
            if (taxSettleTrans)
            {
                isSettlementProcess += true;
                isSettlementProcess += taxWithholdTransCrossCompany.DataAreaId;
                return isSettlementProcess;
            }
        }

        return isSettlementProcess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountId</Name>
				<Source><![CDATA[
    public CompanyBankAccountId parmAccountId(CompanyBankAccountId _accountID = accountID)
    {
        accountID = _accountID;

        return accountID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmChequeNum</Name>
				<Source><![CDATA[
    public BankChequeNum parmChequeNum(BankChequeNum _chequeNum = chequeNum)
    {
        chequeNum = _chequeNum;

        return chequeNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustVendTrans</Name>
				<Source><![CDATA[
    public CustVendTrans parmCustVendTrans(CustVendTrans _custVendTrans = custVendTransToCancel)
    {
        custVendTransToCancel = _custVendTrans;

        return custVendTransToCancel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalName</Name>
				<Source><![CDATA[
    public LedgerJournalNameId parmJournalName(LedgerJournalNameId _journalName = journalName)
    {
        journalName = _journalName;

        return journalName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReason</Name>
				<Source><![CDATA[
    public ReasonCode parmReason(ReasonCode _reason = reason)
    {
        reason = _reason;

        return reason;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReasonComment</Name>
				<Source><![CDATA[
    public ReasonComment parmReasonComment(ReasonComment _reasonComment = reasonComment)
    {
        reasonComment = _reasonComment;

        return reasonComment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRecipientType</Name>
				<Source><![CDATA[
    public BankChequeRecipientType parmRecipientType(BankChequeRecipientType _recipientType = recipientType)
    {
        recipientType = _recipientType;

        return recipientType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReconcile</Name>
				<Source><![CDATA[
    public boolean parmReconcile(boolean _reconcile = reconcileBankTrans)
    {
        reconcileBankTrans = _reconcile;

        return reconcileBankTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransDate</Name>
				<Source><![CDATA[
    public TransDate parmTransDate(TransDate _transDate = cancelDate)
    {
        cancelDate = _transDate;

        return cancelDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCancellingTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts all the ledger transactions that are created by the process.
    /// </summary>
    protected void postCancellingTrans()
    {
        cancelLedgerVoucherGroup.end();
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeChequeNumLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Removes the check number from all of the <c>LedgerJournalTrans</c> records that correspond to the
    ///    check.
    /// </summary>
    protected void removeChequeNumLedgerJournalTrans()
    {
        // Remove the cheque number from the originating journal transaction
        LedgerJournalTrans::revertBankChequeNum(chequeToCancel.TransDate, chequeToCancel.Voucher, chequeToCancel.ChequeNum);

        // Remove the cheque number from the intercompany journal transactions
        if (isChequeInterCompany)
        {
            changecompany(chequeToCancel.RecipientCompany)
            {
                LedgerJournalTrans::revertBankChequeNum(chequeToCancel.TransDate, chequeToCancel.RecipientTransVoucher, chequeToCancel.ChequeNum);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseLedgerTrans_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reverses ledgers of transaction
    /// </summary>
    public void reverseLedgerTrans_IN()
    {
        TaxWithholdTrans_IN        taxWithholdTransLoc;
        TaxWithholdTrans_IN        taxWithholdTransAjustedAmount;
        TaxWithholdTrans_IN        taxWithholdFetchTaxType;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry        generalJournalEntry;
        CurrencyExchangeHelper     exchangeRateHelper;
        LedgerEntry                ledgerEntry;
        LedgerEntryJournal         ledgerEntryJournal;
        LedgerJournalTable         journalToCancel;
        int                        sign = 1;
        LedgerInterCompany         interCompany;
        AmountCur                  totalTaxAmount;
        LedgerVoucherTransObject   postingTransaction;

        [generalJournalAccountEntry, ledgerEntryJournal, generalJournalEntry, ledgerEntry] =
            GeneralLedgerExtension::findRelated(cashBridgeGeneralJournalAccountEntryToCancel);
        // Find the original journal voucher series
        select firstonly NumberSequenceTable from journalToCancel
            where journalToCancel.JournalNum == ledgerEntryJournal.JournalNumber;

        if (journalToCancel == null)
        {
            cancelLedgerVoucherObject.parmLedgerPostingJournalId(generalJournalEntry.LedgerPostingJournal);
        }
        else
        {
            cancelLedgerVoucher.parmVoucherSeriesCode(NumberSequenceTable::find(journalToCancel.NumberSequenceTable).NumberSequence);
        }

        exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(
            Ledger::primaryLedger(CompanyInfo::findDataArea(generalJournalAccountEntry.company()).RecId),
            cancelLedgerVoucherObject.parmAccountingDate());

        exchangeRateHelper.parmExchangeRate1(generalJournalAccountEntry.getAccountingExchangeRate());
        exchangeRateHelper.parmReportingExchangeRate1(generalJournalAccountEntry.getSecondaryExchangeRate());

        select crosscompany sum(TaxWithholdAmountCur) from  taxWithholdTransLoc
                order by VendAccount, CustAccount, TaxType
                where (taxWithholdTransLoc.Voucher                  == chequeToCancel.Voucher
                   || taxWithholdTransLoc.SettlementVoucher         == chequeToCancel.Voucher)
                   && taxWithholdTransLoc.TransDate                 == chequeToCancel.TransDate
                   && taxWithholdTransLoc.AdjustedTaxWithholdAmount == 0 ;

        select crosscompany sum(AdjustedTaxWithholdAmount) from  taxWithholdTransAjustedAmount
                order by VendAccount, CustAccount, TaxType
                where (taxWithholdTransAjustedAmount.Voucher                  == chequeToCancel.Voucher
                   || taxWithholdTransAjustedAmount.SettlementVoucher         == chequeToCancel.Voucher)
                   && taxWithholdTransAjustedAmount.TransDate                 == chequeToCancel.TransDate
                   && taxWithholdTransAjustedAmount.AdjustedTaxWithholdAmount;

        totalTaxAmount = taxWithholdTransAjustedAmount.AdjustedTaxWithholdAmount + taxWithholdTransLoc.TaxWithholdAmountCur;
        select crosscompany PaymCompany, DataAreaId, VendAccount, CustAccount,TaxType  from  taxWithholdFetchTaxType
            where (taxWithholdFetchTaxType.Voucher             == chequeToCancel.Voucher
               || taxWithholdFetchTaxType.SettlementVoucher    == chequeToCancel.Voucher)
               && taxWithholdFetchTaxType.TransDate            == chequeToCancel.TransDate;
        interCompany = TaxWithholdCalculation_IN::findLedgerInterCompany(taxWithholdFetchTaxType.PaymCompany, taxWithholdFetchTaxType.DataAreaId);

        if (taxWithholdFetchTaxType.VendAccount && taxWithholdFetchTaxType.TaxType == TaxWithholdCodeType_IN::TCS)
        {
            sign = sign * -1;
        }

        if (taxWithholdFetchTaxType.CustAccount && taxWithholdFetchTaxType.TaxType == TaxWithholdCodeType_IN::TDS)
        {
            sign = sign * -1;
        }

        if (taxWithholdTransLoc.TaxWithholdAmountCur)
        {
            postingTransaction = LedgerVoucherTransObject::newTransactionAmountDefault(
            cancelLedgerVoucherObject,
            generalJournalAccountEntry.PostingType,
            generalJournalAccountEntry.LedgerDimension,
            generalJournalAccountEntry.TransactionCurrencyCode,
            -generalJournalAccountEntry.TransactionCurrencyAmount,
            exchangeRateHelper);

            postingTransaction.parmSourceTableId(generalJournalAccountEntry.TableId);
            postingTransaction.parmSourceRecId(generalJournalAccountEntry.RecId);
            postingTransaction.parmQuantity(-generalJournalAccountEntry.Quantity);

            // Add transaction to LedgerVoucher
            cancelLedgerVoucher.addTrans(postingTransaction);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reverses settlements that correspond to transactions paid by check.
    /// </summary>
    protected void reverseSettlement()
    {
        CustSettlement reverseCustSettlement;
        VendSettlement reverseVendSettlement;
        SpecTransManager specTransManager;
        CompanyId recipientCompany;

        Debug::assert(recipientCustVendTable.RecId != 0);

        if (isChequeInterCompany)
        {
            recipientCompany = chequeToCancel.RecipientCompany;
        }
        else
        {
            recipientCompany = chequeToCancel.company();
        }

        switch (chequeToCancel.RecipientType)
        {
            case BankChequeRecipientType::Cust:
                changecompany(recipientCompany)
                {
                    // Create SpecTransManager
                    specTransManager = SpecTransManager::newFromSpec(recipientCustVendTable);

                    // Mark settlements for reversal
                    while select reverseCustSettlement
                        where reverseCustSettlement.TransCompany == custVendTransToCancel.DataAreaId &&
                            reverseCustSettlement.TransRecId == custVendTransToCancel.RecId &&
                            reverseCustSettlement.CanBeReversed == NoYes::Yes
                    {
                        reverseCustSettlement.CustVendSettlement::markThisAndRelatedOffsets(specTransManager, custVendTransToCancel.CurrencyCode);
                    }

                    if (specTransManager.getSpecTransCount() > 0)
                    {
                        // <GBR>
                        if (BrazilParameters::isEnabled())
                        {
                            CustTrans::reverseTransact(recipientCustVendTable,
                                                       isChequeInterCompany ? cancelInterCompanyLedgerVoucher : cancelLedgerVoucher,
                                                       SettleDatePrinc::SelectDate,
                                                       this.parmTransDate());
                        }
                        else
                        {
                            // </GBR>
                            // Reverse settlements
                            CustTrans::reverseTransact(recipientCustVendTable,
                                                   isChequeInterCompany ? cancelInterCompanyLedgerVoucher : cancelLedgerVoucher,
                                                   SettleDatePrinc::SelectDate,
                                                   // <GEERU>
                                                   this.parmTransDate(),
                                                   false);
                            // </GEERU>
                            // <GBR>
                        }
                        // </GBR>

                        // Clean up SpecTrans records for reversal
                        specTransManager.deleteAll();
                    }
                }

                break;

            case BankChequeRecipientType::Vend:
                changecompany(recipientCompany)
                {
                    // Create SpecTransManager
                    specTransManager = SpecTransManager::newFromSpec(recipientCustVendTable);

                    // Mark settlements for reversal
                    while select reverseVendSettlement
                        where reverseVendSettlement.TransCompany == custVendTransToCancel.DataAreaId &&
                            reverseVendSettlement.TransRecId == custVendTransToCancel.RecId &&
                            reverseVendSettlement.CanBeReversed == NoYes::Yes
                    {
                        reverseVendSettlement.CustVendSettlement::markThisAndRelatedOffsets(specTransManager, custVendTransToCancel.CurrencyCode);

                        // <GBR>
                        if (BrazilParameters::isEnabled() &&
                                reverseVendSettlement.SettlementGroup != 0)
                        {
                            // Mark withholding tax settlement transactions when exists
                            TaxWithhold::markRelatedVouchers_BR(custVendTransToCancel.CurrencyCode, reverseVendSettlement, specTransManager);
                        }
                        // </GBR>
                    }

                    if (specTransManager.getSpecTransCount() > 0)
                    {
                        // <GBR>
                        if (BrazilParameters::isEnabled())
                        {
                            VendTrans::reverseTransact(recipientCustVendTable,
                                                       isChequeInterCompany ? cancelInterCompanyLedgerVoucher : cancelLedgerVoucher,
                                                       SettleDatePrinc::SelectDate,
                                                       this.parmTransDate(),
                                                       true,
                                                       custVendTransToCancel.Voucher);
                        }
                        else
                        {
                            // </GBR>

                            // Reverse settlements
                            VendTrans::reverseTransact(recipientCustVendTable,
                                                   isChequeInterCompany ? cancelInterCompanyLedgerVoucher : cancelLedgerVoucher,
                                                   SettleDatePrinc::SelectDate,
                                                   // <GEERU>
                                                   this.parmTransDate(),
                                                   false);
                            // </GEERU>
                            // <GBR>
                        }
                        // </GBR>
                        // Clean up SpecTrans records for reversal
                        specTransManager.deleteAll();
                    }
                }

                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseTaxWithhold</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reverses withholding taxes that correspond to transactions paid by the check.
    /// </summary>
    protected void reverseTaxWithhold()
    {
        VendTrans vendTrans;
        VendTable vendTable;
        VendSettlement reverseVendSettlement;
        SpecTransManager specTransManager;
        TaxWithholdTrans taxWithholdTrans;

        // <GBR>
        // Reversing of Brazil withholding tax is processed in class CustVendReversePosting,
        // so don't need to do anything here.
        if (BrazilParameters::isEnabled())
        {
            return;
        }
        // </GBR>

        if (chequeToCancel.RecipientType == BankChequeRecipientType::Vend)
        {
            // Find the TaxWithholdingTrans record based on the payment voucher since
            // the Tax Withholding voucher in the VendTrans table does not have to match
            // the payment voucher.  The crosscompany statement is unbounded because it
            // is not possible to predetermine exactly where the TaxWithholdTrans records
            // will exist. The where restrictions will retrieve the appropriate records
            // across all companies where they exist.

            while select crosscompany taxWithholdTrans
                where taxWithholdTrans.Voucher == custVendTransToCancel.Voucher
                    && taxWithholdTrans.TransDate == custVendTransToCancel.TransDate
                    && taxWithholdTrans.PaymCompany == custVendTransToCancel.company()
            {
                // Get the Tax Withholding VendTrans record based upon the SettlementVoucher
                // which is set at settlement time. The only way to create withholding records
                // is during settlements so we know it will always be set correctly.

                // The vendTrans table must be reset since it is not part of a cross company
                // query.  This ensures the appropriate company will be used.
                vendTrans = null;
                reverseVendSettlement = null;

                changecompany(taxWithholdTrans.company())
                {
                    // Find all the vendTrans records for the tax withholding settlement
                    while select vendTrans
                        where vendTrans.Voucher == taxWithholdTrans.SettlementVoucher
                            && vendTrans.TransDate == taxWithholdTrans.TransDate
                            && vendTrans.RecId != custVendTransToCancel.RecId
                    {
                        // Use the settlement reversal code to reverse the tax withholding settlement
                        // To do this, mark the tax withhold settlement records and then call the reversal code
                        vendTable = VendTable::find(vendTrans.AccountNum);
                        Debug::assert(vendTable.RecId != 0);

                        specTransManager = SpecTransManager::newFromSpec(vendTable);
                        while select reverseVendSettlement
                            where reverseVendSettlement.TransCompany == vendTrans.DataAreaId
                               && reverseVendSettlement.TransRecId == vendTrans.RecId
                               && reverseVendSettlement.CanBeReversed == NoYes::Yes
                        {
                            reverseVendSettlement.CustVendSettlement::markThisAndRelatedOffsets(specTransManager, vendTrans.CurrencyCode);
                        }

                        if (specTransManager.getSpecTransCount() > 0)
                        {
                            // Reverse tax withholding settlements
                            VendTrans::reverseTransact(vendTable,
                                isChequeInterCompany ? cancelInterCompanyLedgerVoucher : cancelLedgerVoucher,
                                SettleDatePrinc::SelectDate,

                                // <GEERU>
                                this.parmTransDate(),
                                false);
                            // </GEERU>

                            // Clean up SpecTrans records for reversal
                            specTransManager.deleteAll();
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        #OCCRetryCount

        setPrefix(BankChequeCancel::description());

        if (ChequeReversalValidateClearedFlight::instance().isEnabled()
            && BankAccountTrans::findByAccountIDAndChequeNum(accountID, chequeNum).Included)
        {
            throw error("@CashManagement:BankChequeReconciled");
        }

        if (journalName != '' && !CustVendPDCRegister::existsPostedPDC(accountID, chequeNum))
        {
            // The process will occur through a bank cheque reversal journal.
            BankChequeCreateReversalJour::newChequeReversalJournal(accountID,
                                                                   chequeNum,
                                                                   cancelDate,
                                                                   reconcileBankTrans,
                                                                   journalName,
                                                                   reason,
                                                                   reasonComment);
        }
        else
        {
            try
            {
                // Get records to be cancelled
                this.getTransToCancel();

                // Validate records for reversal
                if (this.validateToCancelCheque())
                {
                    ttsbegin;

                    // Get vouchers for cancel process
                    this.getVouchersForCancellingTrans();

                    // Get transaction text for cancel process
                    this.getCancelTransTxt();

                    // Get reason code reference for cancel process
                    cancelReasonRef = ReasonTableRef::createReasonTableRef(reason, reasonComment);

                    // Create cancelling transactions
                    this.createCancellingTrans();

                    // Update related records
                    this.updateRelatedRecords();

                    // Finalize cancellation - post cancelling transactions
                    this.postCancellingTrans();

                    TransactionLog::create(TransactionLogType::PaymReversal, strFmt("@SYS82243", chequeNum));

                    // create audit trail records for other companies.
                    cancelLedgerVoucherGroup.createTransactionLog(TransactionLogType::PaymReversal, "@SYS82247");

                    ttscommit;

                    // Add messages to infolog - Payment cancelled & cheque voided
                    info("@SYS26915");
                    info("@SYS53490");
                }
                else
                {
                    throw error("@SYS18447");
                }
            }
            catch (Exception::Error)
            {
                throw error("@SYS21628");
            }
            catch (Exception::Deadlock)
            {
                retry;
            }
            catch (Exception::UpdateConflict)
            {
                if (appl.ttsLevel() == 0)
                {
                    if (xSession::currentRetryCount() >= #RetryNum)
                    {
                        throw Exception::UpdateConflictNotRecovered;
                    }
                    else
                    {
                        retry;
                    }
                }
                else
                {
                    throw Exception::UpdateConflict;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleCancellingCustVendTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Settles the customer or vendor transaction that corresponds to the check with the customer or
    ///    vendor transaction that canceled it.
    /// </summary>
    /// <exception cref="M:Exception::Error">
    ///    The open transactions for the customer transactions are not found.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    ///    The open transactions for the vendor transactions are not found.
    /// </exception>
    protected void settleCancellingCustVendTrans()
    {
        SpecTransManager specTransManager;
        CompanyId recipientCompany;
        CustTransOpen custTransOpenToSettle;
        VendTransOpen vendTransOpenToSettle;

        Debug::assert(recipientCustVendTable.RecId != 0);

        if (isChequeInterCompany)
        {
            recipientCompany = chequeToCancel.RecipientCompany;
        }
        else
        {
            recipientCompany = chequeToCancel.company();
        }


        switch (chequeToCancel.RecipientType)
        {
            case BankChequeRecipientType::Cust:
                changecompany(recipientCompany)
                {
                    SpecTransExecutionContext specTransExecutionContext = SpecTransExecutionContext::newFromSource(recipientCustVendTable);
                    specTransManager = SpecTransManager::newFromSpec(specTransExecutionContext.parmSpecContext());

                    // Get open record for cancelled payment & mark for settlement
                    while select custTransOpenToSettle
                        where custTransOpenToSettle.RefRecId == custVendTransToCancel.RecId
                    {
                        specTransManager.insert(custTransOpenToSettle.company(), custTransOpenToSettle.TableId, custTransOpenToSettle.RecId, custTransOpenToSettle.AmountCur, custVendTransToCancel.CurrencyCode);
                    }

                    // Get open record for cancelling transaction & mark for settlement
                    while select custTransOpenToSettle
                        where custTransOpenToSettle.RefRecId == cancellingCustVendTrans.RecId
                    {
                        specTransManager.insert(custTransOpenToSettle.company(), custTransOpenToSettle.TableId, custTransOpenToSettle.RecId, custTransOpenToSettle.AmountCur, cancellingCustVendTrans.CurrencyCode);
                    }

                    if (specTransManager.getSpecTransCount() == 0)
                    {
                        throw error(strFmt("@SYS18598", funcName()));
                    }

                    // Settle transactions & close cancelling settlements
                    CustTransSettleTransactionParameters custTransSettleTransactionParameters = CustTransSettleTransactionParameters::construct();
                    custTransSettleTransactionParameters.ledgerVoucher = isChequeInterCompany ? cancelInterCompanyLedgerVoucher : cancelLedgerVoucher;
                    CustTrans::settleTransaction(specTransExecutionContext, custTransSettleTransactionParameters);

                    this.closeCancellingSettlements();

                    // Clean up SpecTrans records
                    specTransManager.deleteAll();
                }
                break;

            case BankChequeRecipientType::Vend:
                changecompany(recipientCompany)
                {
                    // The vendor side has not been enabled for SpecTransExecutionContext, so we use recipientCustVendTable.
                    specTransManager = SpecTransManager::newFromSpec(recipientCustVendTable);

                    // Get open record for cancelled payment & mark for settlement
                    while select vendTransOpenToSettle
                        where vendTransOpenToSettle.RefRecId == custVendTransToCancel.RecId
                    {
                        specTransManager.insert(vendTransOpenToSettle.company(), vendTransOpenToSettle.TableId, vendTransOpenToSettle.RecId, vendTransOpenToSettle.AmountCur, custVendTransToCancel.CurrencyCode);
                    }

                    // Get open record for cancelling transaction & mark for settlement
                    while select vendTransOpenToSettle
                        where vendTransOpenToSettle.RefRecId == cancellingCustVendTrans.RecId
                    {
                        specTransManager.insert(vendTransOpenToSettle.company(), vendTransOpenToSettle.TableId, vendTransOpenToSettle.RecId, vendTransOpenToSettle.AmountCur, cancellingCustVendTrans.CurrencyCode);
                    }

                    if (specTransManager.getSpecTransCount() == 0)
                    {
                        throw error(strFmt("@SYS18598", funcName()));
                    }

                    // Settle transactions & close cancelling settlements
                    VendTrans::settleTransact(recipientCustVendTable,
                        isChequeInterCompany ? cancelInterCompanyLedgerVoucher : cancelLedgerVoucher);

                    this.closeCancellingSettlements();

                    // Clean up SpecTrans records
                    specTransManager.deleteAll();
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithholdCancelPaymentFee_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a record in the table by using the parameter.
    /// </summary>
    /// <param name="_transDate">
    /// The field is used to find the record.
    /// </param>
    /// <param name="_oldVoucher">
    /// The field is used to find the record.
    /// </param>
    /// <param name="_bankChequeNum">
    /// The field is used to find the record.
    /// </param>
    protected void taxWithholdCancelPaymentFee_IN(TransDate        _transDate,
                                                  Voucher          _oldVoucher,
                                                  BankChequeNum    _bankChequeNum)
    {
        LedgerJournalTrans          ledgerJournalTransLoc;
        CustVendPaymJournalFee      custVendPaymJournalFeeLoc;
        TaxWithholdFeeType_IN       taxWithholdFeeType;
        BankAccountTrans            cancellingBankAccountTrans;
        Amount                      taxWithholdAmount;
        TaxWithholdCalculation_IN   taxWithholdCalculation = new TaxWithholdCalculation_IN();

        void createNewBankAccountTrans(AmountMST    _amountMST,
                                       AmountCur    _amountCur,
                                       AmountCur    _bankTransAmount)
        {
            cancellingBankAccountTrans                      = bankAccountTransToCancel.data();
            cancellingBankAccountTrans.Voucher              = cancelTransVoucher;
            cancellingBankAccountTrans.TransDate            = cancelDate;
            cancellingBankAccountTrans.AmountMST            = -_amountMST;
            cancellingBankAccountTrans.AmountCur            = -_amountCur;
            cancellingBankAccountTrans.BankTransAmountCur   = -_bankTransAmount;
            cancellingBankAccountTrans.BankTransType        = BankParameters::find().NSFTransactionType;
            cancellingBankAccountTrans.Reconciled           = reconcileBankTrans;
            cancellingBankAccountTrans.Cancel               = NoYes::Yes;
            cancellingBankAccountTrans.AccountStatementDate = reconcileBankTrans ? cancelDate : dateNull();
            cancellingBankAccountTrans.ReasonRefRecID       = ReasonTableRef::checkCreateInCompany(cancelReasonRef, cancellingBankAccountTrans.DataAreaId);
            cancellingBankAccountTrans.insert();
        }

        while select ledgerJournalTransLoc
            where ledgerJournalTransLoc.Voucher        == _oldVoucher
               && ledgerJournalTransLoc.TransDate      == _transDate
           join custVendPaymJournalFeeLoc
                where custVendPaymJournalFeeLoc.FeeTransRecId == ledgerJournalTransLoc.RecId
        {
            taxWithholdFeeType = VendPaymFee::find(custVendPaymJournalFeeLoc.FeeId).TaxWithholdFeeType_IN;
            // For Fee Lines...
            if (taxWithholdFeeType == TaxWithholdFeeType_IN::Interest || taxWithholdFeeType == TaxWithholdFeeType_IN::Others)
            {
                createNewBankAccountTrans(-custVendPaymJournalFeeLoc.FeeValue,
                                          -custVendPaymJournalFeeLoc.FeeValue,
                                          -custVendPaymJournalFeeLoc.FeeValue);
                this.taxWithholdFeeReversal_IN(custVendPaymJournalFeeLoc);
            }
            // For Payment Lines.....
            if (ledgerJournalTransLoc.TransactionType == LedgerTransType::Payment && this.checkTaxWithholdFeeType_IN(_oldVoucher, _transDate))
            {
                taxWithholdAmount = taxWithholdCalculation.setTaxWithholdAmount(ledgerJournalTransLoc, custVendPaymJournalFeeLoc.parmCustVendAccount(ledgerJournalTransLoc.parmAccount(),custVendPaymJournalFeeLoc.LedgerJournalACType));
                createNewBankAccountTrans((ledgerJournalTransLoc.AmountCurDebit == 0 ? (ledgerJournalTransLoc.AmountCurCredit - taxWithholdAmount) : (ledgerJournalTransLoc.AmountCurDebit * -1) + taxWithholdAmount),
                                          (ledgerJournalTransLoc.AmountCurDebit == 0 ? (ledgerJournalTransLoc.AmountCurCredit - taxWithholdAmount) : (ledgerJournalTransLoc.AmountCurDebit * -1) + taxWithholdAmount),
                                          (ledgerJournalTransLoc.AmountCurDebit == 0 ? (ledgerJournalTransLoc.AmountCurCredit - taxWithholdAmount) : (ledgerJournalTransLoc.AmountCurDebit * -1) + taxWithholdAmount));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithholdFeeReversal_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create an object and add transaction by passing the record.
    /// </summary>
    /// <param name="_custVendPaymJournalFee">
    /// the table buffer used to find the record.
    /// </param>
    private void taxWithholdFeeReversal_IN(CustVendPaymJournalFee    _custVendPaymJournalFee)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject;
        LedgerDimensionAccount basSettlementDimAccount;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        LedgerEntry ledgerEntry;
        LedgerEntryJournal ledgerEntryJournal;
        CurrencyExchangeHelper exchangeRateHelper;
        LedgerRecId primaryLedger;

        [generalJournalAccountEntry, ledgerEntryJournal, generalJournalEntry, ledgerEntry] =
            GeneralLedgerExtension::findRelated(cashBridgeGeneralJournalAccountEntryToCancel);

        primaryLedger = GeneralJournalEntry::findByGeneralJournalAccountEntry(generalJournalAccountEntry.RecId).Ledger;

        basSettlementDimAccount = LedgerDimensionDefaultingEngine::getLedgerDimensionFromAccountAndDim(_custVendPaymJournalFee.LedgerDimension, DimensionHierarchy::getAccountStructure(_custVendPaymJournalFee.LedgerDimension, primaryLedger), _custVendPaymJournalFee.DefaultDimension);

        exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(
            primaryLedger,
            cancelLedgerVoucherObject.parmAccountingDate());

        ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
            cancelLedgerVoucherObject,
            LedgerPostingType::VendBalance,
            basSettlementDimAccount,
            _custVendPaymJournalFee.FeeCurrency,
            -_custVendPaymJournalFee.FeeValue,
            exchangeRateHelper);

        cancelLedgerVoucherObject.parmTransDate(cancelDate);
        cancelLedgerVoucher.addTrans(ledgerVoucherTransObject);
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithholdReverseLedgerTrans_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a new transaction to the current <c>LedgerVoucher</c> object that cancels the cash or
    /// cash-in-transit account posting.
    /// </summary>
    protected void taxWithholdReverseLedgerTrans_IN()
    {
        LedgerJournalTable                  journalToCancel;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        GeneralJournalAccountEntry          generalJournalAccountEntry;
        LedgerEntry                         ledgerEntry;
        LedgerEntryJournal                  ledgerEntryJournal;
        GeneralJournalEntry                 generalJournalEntry;
        CurrencyExchangeHelper              exchangeRateHelper;
        LedgerVoucherTransObject            postingTransaction;

        [generalJournalAccountEntry, ledgerEntryJournal, generalJournalEntry, ledgerEntry] =
            GeneralLedgerExtension::findRelated(cashBridgeGeneralJournalAccountEntryToCancel);

        // Find the original journal voucher series
        select firstonly NumberSequenceTable from journalToCancel
            where journalToCancel.JournalNum == ledgerEntryJournal.JournalNumber;

        while select firstonly generalJournalAccountEntry
            where generalJournalAccountEntry.RecId == cashBridgeGeneralJournalAccountEntryToCancel
               && generalJournalAccountEntry.PostingType == LedgerPostingType::Bank
            join GeneralJournalAccountEntry, IsBridgingPosting from ledgerEntry
                where ledgerEntry.GeneralJournalAccountEntry == generalJournalAccountEntry.RecId
                   && ledgerEntry.IsBridgingPosting == NoYes::Yes
                join RecId from subledgerVoucherGeneralJournalEntry
                    where subledgerVoucherGeneralJournalEntry.Voucher == chequeToCancel.Voucher
                       && subledgerVoucherGeneralJournalEntry.AccountingDate == chequeToCancel.TransDate
                       && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == chequeToCancel.DataAreaId
                join LedgerPostingJournal, Ledger from generalJournalEntry
                    where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
                       && generalJournalEntry.Ledger == Ledger::current()
        {
            if (journalToCancel == null)
            {
                cancelLedgerVoucherObject.parmLedgerPostingJournalId(generalJournalEntry.LedgerPostingJournal);
            }
            else
            {
                cancelLedgerVoucher.parmVoucherSeriesCode(NumberSequenceTable::find(journalToCancel.NumberSequenceTable).NumberSequence);
            }

            exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(
            Ledger::primaryLedger(CompanyInfo::findDataArea(generalJournalAccountEntry.company()).RecId),
            cancelLedgerVoucherObject.parmAccountingDate());

            exchangeRateHelper.parmExchangeRate1(generalJournalAccountEntry.getAccountingExchangeRate());
            exchangeRateHelper.parmReportingExchangeRate1(generalJournalAccountEntry.getSecondaryExchangeRate());

            postingTransaction = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                        cancelLedgerVoucherObject,
                                                        generalJournalAccountEntry.PostingType,
                                                        generalJournalAccountEntry.LedgerDimension,
                                                        generalJournalAccountEntry.TransactionCurrencyCode,
                                                        -generalJournalAccountEntry.TransactionCurrencyAmount,
                                                        exchangeRateHelper);

            postingTransaction.parmSourceTableId(generalJournalAccountEntry.TableId);
            postingTransaction.parmSourceRecId(generalJournalAccountEntry.RecId);
            postingTransaction.parmQuantity(-generalJournalAccountEntry.Quantity);
            postingTransaction.parmFinTag(generalJournalAccountEntry.FinTag);

            // Add transaction to LedgerVoucher
            cancelLedgerVoucher.addTrans(postingTransaction);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Version version = RunBase::getVersion(packedClass);

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList] = packedClass;
                break;

            default :
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBankAccountTransStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the status of the canceled bank account transaction.
    /// </summary>
    protected void updateBankAccountTransStatus()
    {
        bankAccountTransToCancel.BankTransType = BankParameters::find().NSFTransactionType;
        bankAccountTransToCancel.Included = reconcileBankTrans;
        bankAccountTransToCancel.Reconciled = reconcileBankTrans;
        bankAccountTransToCancel.Cancel = NoYes::Yes;
        bankAccountTransToCancel.AccountStatementDate = reconcileBankTrans ? cancelDate : dateNull();
        bankAccountTransToCancel.ReasonRefRecID = ReasonTableRef::checkCreateInCompany(cancelReasonRef, bankAccountTransToCancel.DataAreaId);

        if (BankAccountTable::isAdvancedBankReconciliationEnabled(bankAccountTransToCancel.AccountId)
            && FeatureStateProvider::isFeatureEnabled(BankTransClearedDateAdvancedBankReconciliationFeature::instance()))
        {
            bankAccountTransToCancel.ClearedDate = cancelDate;
        }

        bankAccountTransToCancel.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateChequeStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the status of the canceled bank account transaction.
    /// </summary>
    protected void updateChequeStatus()
    {
        chequeToCancel = BankChequeTable::find(accountID, chequeNum, true);

        chequeToCancel.updateChequeStatusToCancelled(cancelReasonRef, chequeToCancel.DataAreaId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustVendTransCancelReason</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the customer or vendor transaction being canceled with the reason for the cancellation.
    /// </summary>
    protected void updateCustVendTransCancelReason()
    {
        changecompany(custVendTransToCancel.company())
        {
            custVendTransToCancel.selectForUpdate(true);
            custVendTransToCancel.reread();
            custVendTransToCancel.ReasonRefRecId = cancelReasonRef;

            custVendTransToCancel.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRelatedRecords</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates records related to the canceled check.
    /// </summary>
    protected void updateRelatedRecords()
    {
        if (custVendTransToCancel.RecId != 0)
        {
            // Get recipient customer/vendor - will be used for reversals & settlements
            this.getRecipientCustVendTable();

            // Reverse settlements involving the payment being cancelled
            this.reverseSettlement();

            // Reverse withholding tax transactions
            this.reverseTaxWithhold();

            // Settle cancelled & cancelling transactions
            this.settleCancellingCustVendTrans();

            // Delete BankChequePaymTrans records linking cheques with transactions paid by cheque
            this.deleteBankChequePaymTrans();

            // Set the reason on the cancelled customer/vendor transaction
            this.updateCustVendTransCancelReason();
        }

        // Delete further posting records from bridging not yet transferred to bank transactions
        this.deleteLedgerTransFurtherPosting();

        // Remove cheque number from journal transactions
        this.removeChequeNumLedgerJournalTrans();

        // Update status on cancelled cheque
        this.updateChequeStatus();

        // Update status on cancelled bank transaction
        if (bankAccountTransToCancel.RecId != 0)
        {
            this.updateBankAccountTransStatus();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateToCancelCheque</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that the check can be canceled.
    /// </summary>
    /// <returns>
    ///    true if the check can be canceled; otherwise, false.
    /// </returns>
    protected boolean validateToCancelCheque()
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        LedgerEntry ledgerEntry;
        LedgerEntry payToLedgerAccountLedgerEntry;
        GeneralJournalEntry generalJournalEntry;
        boolean isValid = true;
        TransDate originalTransDate;
        boolean isBridgingUsed;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;

        if (accountID)
        {
            isValid = BankAccountTable::checkIsActive(accountID, bankAccountTransToCancel.TransDate);
        }

        // Transaction & offset sub-ledger transactions must exist
        if (cashBridgeGeneralJournalAccountEntryToCancel == 0)
        {
            isValid = checkFailed("@SYS120316");
        }

        // There will not be a BankAccountTrans if a bridging method of payment was used and
        // the transaction has not been transferred from the cash-in-transit account.
        if (bankAccountTransToCancel.RecId == 0)
        {
            ledgerEntry = LedgerEntry::findByGeneralJournalAccountEntry(cashBridgeGeneralJournalAccountEntryToCancel);
            if (!ledgerEntry.IsBridgingPosting)
            {
                isBridgingUsed = true;
                if (payToLedgerAccountTransToCancel != 0)
                {
                    payToLedgerAccountLedgerEntry = LedgerEntry::findByGeneralJournalAccountEntry(payToLedgerAccountTransToCancel);
                    if (!payToLedgerAccountLedgerEntry.IsBridgingPosting)
                    {
                        isBridgingUsed = false;
                    }
                }
                else
                {
                    isBridgingUsed = false;
                }

                if (isBridgingUsed == false)
                {
                    isValid = checkFailed("@SYS120320");
                }
            }
        }

        if (custVendTransToCancel.RecId == 0)
        {
            // If the offset sub-ledger transaction is not a cust or vend trans,
            // look for general journal offset to the bank transaction
            select firstonly RecId from subledgerVoucherGeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.Voucher ==  chequeToCancel.Voucher &&
                      subledgerVoucherGeneralJournalEntry.AccountingDate == chequeToCancel.TransDate &&
                      subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == chequeToCancel.DataAreaId
            join RecId from generalJournalEntry
                where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry &&
                      generalJournalEntry.Ledger == Ledger::current()
            join RecId from generalJournalAccountEntry
                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry &&
                    generalJournalAccountEntry.PostingType == LedgerPostingType::LedgerJournal &&
                    generalJournalAccountEntry.PaymentReference == chequeToCancel.ChequeNum;

            offsetGeneralJournalAccountEntryToCancel = generalJournalAccountEntry.RecId;

            if (offsetGeneralJournalAccountEntryToCancel == 0)
            {
                if (chequeToCancel.RecipientType == BankChequeRecipientType::Cust)
                {
                    isValid = checkFailed("@SYS120326");
                }
                else if (chequeToCancel.RecipientType == BankChequeRecipientType::Vend)
                {
                    isValid = checkFailed("@SYS120327");
                }

                isValid = checkFailed("@SYS120350");
            }
        }

        // If the check & recipient are in different companies, intercompany transactions have to be found
        if (isChequeInterCompany)
        {
            if (interCompanyDebitGeneralJournalAccountEntryToCancel == 0 || interCompanyCreditGeneralJournalAccountEntryToCancel == 0)
            {
                isValid = checkFailed("@SYS120325");
            }
        }

        // Get original transaction date
        if (bankAccountTransToCancel.RecId != 0)
        {
            // BankAccountTrans will have the latest original date if bridging posting has been transferred.
            originalTransDate = bankAccountTransToCancel.TransDate;
        }
        else if (cashBridgeGeneralJournalAccountEntryToCancel != 0)
        {
            // The general journal transaction from original cash/bridging posting will
            // have the original date if bridging posting has not been transferred.
            generalJournalEntry = GeneralJournalEntry::findByGeneralJournalAccountEntry(cashBridgeGeneralJournalAccountEntryToCancel);

            originalTransDate = generalJournalEntry.AccountingDate;
        }

        // Latest posting date cannot be before cancellation date
        if (originalTransDate > cancelDate)
        {
            isValid = checkFailed("@SYS91442");
        }

        // Bank transaction cannot be in a reconciled state.
        if (bankAccountTransToCancel.RecId != 0 && bankAccountTransToCancel.Reconciled == NoYes::Yes)
        {
            if (bankAccountTransToCancel.ChequeNum)
            {
                isValid = checkFailed(strfmt("@SYS23526", bankAccountTransToCancel.ChequeNum));
            }
            else
            {
                isValid = checkFailed("@GLS222233");
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS22512";
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCustVendTransForCheque</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the customer or vendor transaction that corresponds to the check.
    /// </summary>
    /// <param name="_chequeToCancel">
    ///    The check for which to find the customer or vendor transaction.
    /// </param>
    /// <returns>
    ///    The customer or vendor transaction that corresponds to the check.
    /// </returns>
    public static CustVendTrans findCustVendTransForCheque(BankChequeTable _chequeToCancel)
    {
        CustVendTrans custVendTransForCheque;
        CustTrans custTrans;
        VendTrans vendTrans;
        Voucher custVendTransVoucher;
        container recipientCompany;

        // Get the custVendTrans voucher number & company
        if (_chequeToCancel.RecipientCompany != '' && _chequeToCancel.company() != _chequeToCancel.RecipientCompany)
        {
            // Cheque is from an intercompany payment, use the Recipient fields
            custVendTransVoucher = _chequeToCancel.RecipientTransVoucher;
            recipientCompany += [_chequeToCancel.RecipientCompany];
        }
        else
        {
            // Cheque is from a single company payment, use the Cheque fields
            custVendTransVoucher = _chequeToCancel.Voucher;
            recipientCompany += [_chequeToCancel.company()];
        }

        // Find the CustVendTrans record corresponding to the cheque to be cancelled
        switch (_chequeToCancel.RecipientType)
        {
            case BankChequeRecipientType::Vend :
                select firstonly crossCompany:recipientCompany vendTrans order by RecId asc
                    where vendTrans.Voucher == custVendTransVoucher &&
                        vendTrans.PaymReference == _chequeToCancel.ChequeNum;

                custVendTransForCheque = vendTrans;
                break;

            case BankChequeRecipientType::Cust :
                select firstonly crossCompany:recipientCompany custTrans order by RecId asc
                    where custTrans.Voucher == custVendTransVoucher &&
                        custTrans.PaymReference == _chequeToCancel.ChequeNum;

                custVendTransForCheque = custTrans;
                break;
        }

        return custVendTransForCheque;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCustVendTransForCheque_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reads the table buffer and get the required table.
    /// </summary>
    /// <param name="_chequeToCancel">
    /// The table buffer used to find the record.
    /// </param>
    /// <returns>
    /// returns the table.
    /// </returns>
    public static CustVendTrans findCustVendTransForCheque_IN(BankChequeTable _chequeToCancel)
    {
        CustVendTrans custVendTransForCheque;
        CustTrans custTrans;
        VendTrans vendTrans;
        Voucher custVendTransVoucher;
        container recipientCompany;

        // Get the custVendTrans voucher number & company
        if (_chequeToCancel.RecipientCompany != '' && _chequeToCancel.company() != _chequeToCancel.RecipientCompany)
        {
            // Cheque is from an intercompany payment, use the Recipient fields
            custVendTransVoucher = _chequeToCancel.RecipientTransVoucher;
            recipientCompany += [_chequeToCancel.RecipientCompany];
        }
        else
        {
            // Cheque is from a single company payment, use the Cheque fields
            custVendTransVoucher = _chequeToCancel.Voucher;
            recipientCompany += [_chequeToCancel.company()];
        }

        // Find the CustVendTrans record corresponding to the cheque to be cancelled
        switch (_chequeToCancel.RecipientType)
        {
            case BankChequeRecipientType::Vend :
                select firstonly crossCompany:recipientCompany vendTrans order by RecId asc
                    where vendTrans.LastSettleVoucher == custVendTransVoucher &&
                        vendTrans.PaymReference == _chequeToCancel.ChequeNum;

                custVendTransForCheque = vendTrans;
                break;

            case BankChequeRecipientType::Cust :
                select firstonly crossCompany:recipientCompany custTrans order by RecId asc
                    where custTrans.LastSettleVoucher == custVendTransVoucher &&
                        custTrans.PaymReference == _chequeToCancel.ChequeNum;

                custVendTransForCheque = custTrans;
                break;
        }

        return custVendTransForCheque;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPartialTaxSettlementProcessRun_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether any partially settled customer or vendor transactions exists
    /// </summary>
    /// <param name="_custVendTrans">
    /// The customer/vendor map
    /// </param>
    /// <returns>
    /// True if any partially settled customer or vendor transactions exists
    /// </returns>
    public static boolean isPartialTaxSettlementProcessRun_IN(CustVendTrans  _custVendTrans)
    {
        ComponentTransactions_IN componentTransactions;
        TaxTrans taxTrans;
        boolean ret;

        while select sum(UtilizedAmount), sum(RecoverableAmount), sum(PaidAmount), sum(PayableAmount)
        from componentTransactions
            group by TransRecid
                exists join taxTrans
                    where componentTransactions.TransRecid == taxTrans.RecId
                exists join  _custVendTrans
                     where taxTrans.Transdate == _custVendTrans.transdate
                           && taxTrans.Voucher   == _custVendTrans.voucher
        {
            if (_custVendTrans.TableId == tablenum(VendTrans))
            {
                if (componentTransactions.UtilizedAmount != 0 &&
                    componentTransactions.UtilizedAmount < componentTransactions.RecoverableAmount)
                {
                    ret = true;
                    break;
                }
            }
            if (_custVendTrans.TableId == tablenum(CustTrans))
            {
                if (componentTransactions.PaidAmount != 0 &&
                    abs(componentTransactions.PaidAmount) < abs(componentTransactions.PayableAmount))//Payable amount & paid amount may have -ve values.So taking abs().
                {
                    ret = true;
                    break;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSalesTaxSettlementProcessRun_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether any partially settled vendor transactions exists
    /// </summary>
    /// <param name="_vendTrans">
    /// The vendor buffer
    /// </param>
    /// <returns>
    /// True if any partially settled vendor transactions exists
    /// </returns>
    public static boolean isSalesTaxSettlementProcessRun_IN(CustVendTrans  _vendTrans)
    {
        ComponentTransactions_IN componentTransactions;
        #ISOCountryRegionCodes

        if ((SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])) && TaxParameters::checkTaxParametersExcludingCustoms_IN())
        {
            while select UtilizedAmount, RecoverableAmount from componentTransactions
                 where componentTransactions.Voucher   == _vendTrans.LastSettleVoucher &&
                       componentTransactions.TransDate == _vendTrans.TransDate
            {
                if (componentTransactions.UtilizedAmount != 0 &&
                    componentTransactions.UtilizedAmount < componentTransactions.RecoverableAmount)
                {
                    return true;
                }
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args args)
    {
        // <GBR>
        BankChequeTable bankChequeTable;
        // </GBR>

        BankChequeCancel chequeCancel;
        Args localArgs = new Args();
        CustVendPDCManager  custVendPDCManager;

        if (args.record())
        {
            switch (args.dataset())
            {
                case tableNum(BankChequeTable) :
                    // <GBR>
                    if (BrazilParameters::isEnabled())
                    {
                        bankChequeTable = args.record();

                        if (bankChequeTable.RecipientType == BankChequeRecipientType::Vend)
                        {
                            chequeCancel = BankChequeCancel_BR::newBankChequeTable(args.record());
                        }
                        else
                        {
                            // setting the same value as SYS code
                            chequeCancel = BankChequeCancel::newBankChequeTable(args.record());
                        }
                    }
                    else
                    {
                        // </GBR>
                        chequeCancel = BankChequeCancel::newBankChequeTable(args.record());
                        // <GBR>
                    }
                    // </GBR>
                    break;

                default :
                    throw error(strFmt("@SYS22828","@SYS22512"));
            }

            if (chequeCancel.prompt())
            {
                localArgs.caller(chequeCancel);
                localArgs.record(args.record());

                // <GBR>
                if (BrazilParameters::isEnabled())
                {
                    BankChequeCancel_BR::serverRun(localArgs);
                }
                else
                {
                    // </GBR>
                    BankChequeCancel::serverRun(localArgs);
                    // <GBR>
                }
                // </GBR>

                custVendPDCManager = args.parmObject();
                if (custVendPDCManager)
                {
                    custVendPDCManager.parmCheckCancelStatus(true);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newBankChequeTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new instance of the <c>BankChequeCancel</c> class and initializes several internal
    ///    variables with information from a <c>Cheque</c> definition.
    /// </summary>
    /// <param name="_chequeTable">
    ///    The <c>BankChequeTable</c> record buffer that represents the <c>Cheque</c> definition.
    /// </param>
    /// <returns>
    ///    A new instance of the <c>BankChequeCancel</c> class that is initialized with values from the passed
    ///    in record buffer.
    /// </returns>
    public static BankChequeCancel newBankChequeTable(BankChequeTable _chequeTable)
    {
        BankChequeCancel chequeCancel;

        chequeCancel = new BankChequeCancel();

        chequeCancel.parmAccountId(_chequeTable.AccountID);
        chequeCancel.parmChequeNum(_chequeTable.ChequeNum);
        chequeCancel.parmRecipientType(_chequeTable.RecipientType);
        chequeCancel.parmReconcile(true);
        chequeCancel.parmCustVendTrans(BankChequeCancel::findCustVendTransForCheque(_chequeTable));

        if (chequeCancel.parmCustVendTrans().RecId != 0)
        {
            chequeCancel.parmTransDate(chequeCancel.parmCustVendTrans().TransDate);
        }
        else
        {
            chequeCancel.parmTransDate(_chequeTable.TransDate);
        }

        return chequeCancel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>serverRun</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an instance of the <c>BankChequeCancel</c> class from a pack and calls its <c>Run</c>
    ///    method on the server tier.
    /// </summary>
    /// <param name="args">
    ///    The arguments that contain the <c>BankChequeTable</c> record and an instance of the
    ///    <c>BankChequeCancel</c> class.
    /// </param>
    private static void serverRun(Args args)
    {
        BankChequeCancel chequeCancel;

        chequeCancel = BankChequeCancel::newBankChequeTable(args.record());
        chequeCancel.unpack(args.caller().pack());
        chequeCancel.runOperation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>