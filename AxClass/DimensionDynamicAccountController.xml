<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>DimensionDynamicAccountController</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>DimensionDynamicAccountController</c> class provides support for multiple account types in the segmented entry control.
/// </summary>
/// This is a framework class. Customizing this class may cause problems with future upgrades to the software.
public class DimensionDynamicAccountController extends LedgerDimensionController implements DimensionDynamicController
{
    DimensionHierarchyType dimensionHierarchyType, lastDimensionHierarchyType;
    Common backingValue;
    LedgerDimensionAccountController ledgerDimensionAccountController;
    LedgerDimensionDefaultAccountController ledgerDimensionDefaultAccountController;
    int lastAccountType;
    ModuleInventCustVend lastCustVend;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getDefaultValue</Name>
				<Source><![CDATA[
    public DimensionValue getDefaultValue(
        DimensionAttributeRecId         _dimensionAttributeId,
        int                             _segmentIndex,
        DataAreaId                      _originalCompany)
    {
        DimensionValue defaultedValue = '';

        if (!this.parmIsDefaultAccount())
        {
            defaultedValue = ledgerDimensionAccountController.getDefaultValue(_dimensionAttributeId, _segmentIndex, _originalCompany);
        }

        return defaultedValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowClearReference</Name>
				<Source><![CDATA[
    public boolean allowClearReference(LedgerDimensionBase _ledgerDimension)
    {
        boolean allowClear = true;

        if (_ledgerDimension)
        {
            // Determine the system generated account structure intended to be used and the one actually used in the combination
            DimensionHierarchyType dimHierarchyType = this.getHierarchyType();

            DimensionAttributeValueGroup dimAttributeValueGroup;
            DimensionAttributeValueGroupCombination dimAttributeValueGroupCombo;

            select firstonly DimensionHierarchy from dimAttributeValueGroup
                exists join dimAttributeValueGroupCombo
                where dimAttributeValueGroupCombo.DimensionAttributeValueCombination == _ledgerDimension
                    && dimAttributeValueGroupCombo.Ordinal == 1
                    && dimAttributeValueGroupCombo.DimensionAttributeValueGroup == dimAttributeValueGroup.RecId;

            if (dimAttributeValueGroup.DimensionHierarchy)
            {
                if (this.isNonLedgerAccount())
                {
                    DimensionHierarchyId dimHierarchyRecId = DimensionHierarchy::getHierarchyIdByHierarchyType(dimHierarchyType);
                    if (dimAttributeValueGroup.DimensionHierarchy == dimHierarchyRecId)
                    {
                        // If the hierarchy of the combination matches the type expected for the multi type, assume it was set by code and don't clear it
                        allowClear = false;
                    }
                }
                else
                {
                    // Any combinations using multi-typed (system generated) hierarchies must clear when type is set to Ledger, otherwise leave what's there
                    DimensionHierarchy dimHierarchy = DimensionHierarchy::find(dimAttributeValueGroup.DimensionHierarchy);
                    if (!dimHierarchy.IsSystemGenerated)
                    {
                        allowClear = false;
                    }
                }
            }
        }

        return allowClear;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears the reference to the ledger dimension.
    /// </summary>
    public void clearReference()
    {
        if (this.isNonLedgerAccount())
        {
            super();
        }
        else if (this.parmIsDefaultAccount())
        {
            ledgerDimensionDefaultAccountController.clearReference();
        }
        else
        {
            ledgerDimensionAccountController.clearReference();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSingleSegment</Name>
				<Source><![CDATA[
    public boolean isSingleSegment()
    {
        return (this.isNonLedgerAccount() || this.parmIsDefaultAccount());
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadLookupDataNonLedger</Name>
				<Source><![CDATA[
    private void loadLookupDataNonLedger(Array _elements, str _filterValue, str _lastPagedValue)
    {
        DimensionControlInfo    state = this.getLastProcessedState();
        DimensionAttributeRecId dimensionAttributeId = state.getDimensionAttributeByIndex(1).RecId;

        this.getAutoCompleteDataFromDatabase(
                    _elements,
                    AutoCompleteDataMode::AllValues,
                    _filterValue,
                    dimensionAttributeId,
                    _lastPagedValue,
                    1,
                    this.parmDataAreaId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadLookupData</Name>
				<Source><![CDATA[
    public void loadLookupData(Array _elements, int _currentSegment, AutoCompleteDataMode _autoCompleteMode, str _filterValue, str _lastPagedValue, str _lastPagedTag)
    {
        changecompany(dataAreaId)
        {
            if (this.isNonLedgerAccount())
            {
                this.loadLookupDataNonLedger(_elements, _filterValue, _lastPagedValue);
            }
            else if (this.parmIsDefaultAccount())
            {
                ledgerDimensionDefaultAccountController.loadLookupData(_elements, _currentSegment, _autoCompleteMode, _filterValue, _lastPagedValue, _lastPagedTag);
            }
            else
            {
                ledgerDimensionAccountController.loadLookupData(_elements, _currentSegment, _autoCompleteMode, _filterValue, _lastPagedValue, _lastPagedTag);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isValidForNonLedgerAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that there is a non-ledger account value for the current account type.
    /// </summary>
    /// <param name="_value">
    /// The value to validate.
    /// </param>
    /// <param name="_errorMessages">
    /// A list of error messages.
    /// </param>
    /// <returns>
    /// A container that contains a Boolean value and a <c>DimensionValue</c> value.
    /// </returns>
    /// <remarks>
    /// The container that is returned holds the following items:
    ///     A Boolean validation result: true if there is a specified value for the current account type; otherwise, false.
    ///     The actual value: returns the value stored in the database so we can use the same casing.
    /// </remarks>
    private container isValidForNonLedgerAccount(DimensionValue _value, List _errorMessages)
    {
        DimensionAttribute dimAttr;
        DimensionAttributeValue dimAttrValue;
        DictField dictField;
        str tableLabel, fieldLabel;
        boolean isValid = true;
        DimensionValue actualValue = '';

        if (_value != '')
        {
            changecompany(this.parmDataAreaId())
            {
                dimAttr = DimensionAttribute::getAttributeByHierarchyType(dimensionHierarchyType);
                dimAttrValue = DimensionAttributeValue::findByDimensionAttributeAndValue(dimAttr, _value);

                if (dimAttrValue)
                {
                    // Do not call getValue on an empty buffer, there are debug asserts and telemetry logging that will get hit
                    actualValue = dimAttrValue.getValue();

                    isValid = actualValue != '';
                }
                else
                {
                    isValid = false;
                }

                if (!isValid)
                {
                    tableLabel = DimensionCache::getBackingEntityTableLabel(dimAttr.BackingEntityType);

                    dictField = new DictField(dimAttr.BackingEntityType, dimAttr.ValueAttribute);
                    fieldLabel = dictField.label();

                    // The value was not found
                    _errorMessages.addEnd(strFmt("@SYS112224", _value, fieldLabel, tableLabel));
                }
            }
        }

        return [isValid, actualValue];
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    public boolean validate(List _errorMessages, boolean _isStructureChangedRetry = false)
    {
        DimensionValue value;
        boolean isValid = true;
        DimensionControlSegment segment;
        str actualValue;

        changecompany(dataAreaId)
        {
            if (this.isNonLedgerAccount() && currentSegments && currentSegments.lastIndex() > 0)
            {
                // Start by assuming combination is valid.
                segment = currentSegments.value(1);
                value = segment.parmValue();
                segment.parmValidationStatus(SegmentValidationStatus::Valid);

                [isValid, actualValue] = this.isValidForNonLedgerAccount(value, _errorMessages);

                if (isValid)
                {
                    value = actualValue;
                    segment.parmValue(value);
                }
                else
                {
                    this.parmCombinationState(SegmentedEntryState::Invalid);

                    segment.parmValidationStatus(SegmentValidationStatus::ValueNotFound);
                }
            }
            else
            {
                if (this.parmIsDefaultAccount())
                {
                    isValid = ledgerDimensionDefaultAccountController.validate(_errorMessages);
                }
                else
                {
                    isValid = ledgerDimensionAccountController.validate(_errorMessages);
                }
            }

            return isValid;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCombination</Name>
				<Source><![CDATA[
    public DimensionValidationStatus validateCombination(DataAreaId _originalCompany, List _errorMessages)
    {
        DimensionValidationStatus dimensionValidationStatus;

        if (this.isSingleSegment())
        {
            dimensionValidationStatus = DimensionValidationStatus::Invalid;
        }
        else
        {
            dimensionValidationStatus = ledgerDimensionAccountController.validateCombination(_originalCompany, _errorMessages);
        }

        return dimensionValidationStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDimensionSpecifiers</Name>
				<Source><![CDATA[
    public boolean setDimensionSpecifiers(Map _dimensionSpecifiers, List _errorMessages, boolean _overwriteValues = false)
    {
        if (this.isSingleSegment())
        {
            // This method should only be called for ledger dimensions.
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        changecompany(this.parmDataAreaId())
        {
            return ledgerDimensionAccountController.setDimensionSpecifiers(_dimensionSpecifiers, _errorMessages, _overwriteValues);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDimensionAlias</Name>
				<Source><![CDATA[
    public DimensionAlias parmDimensionAlias(DimensionAlias _dimensionAlias = dimensionAlias)
    {
        if (!prmisDefault(_dimensionAlias))
        {
            if (this.isSingleSegment())
            {
                // This method should only be called for ledger dimensions.
                throw error(Error::wrongUseOfFunction(funcName()));
            }

            dimensionAlias = _dimensionAlias;
            ledgerDimensionAccountController.parmDimensionAlias(dimensionAlias);
            ledgerDimensionDefaultAccountController.parmDimensionAlias(dimensionAlias);
        }

        return dimensionAlias;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDataAreaId</Name>
				<Source><![CDATA[
    public dataAreaId parmDataAreaId(dataAreaId _dataAreaId = dataAreaId)
    {
        if (!prmisdefault(_dataAreaId))
        {
            dataAreaId = _dataAreaId;
            ledgerDimensionAccountController.parmDataAreaId(_dataAreaId);
            ledgerDimensionDefaultAccountController.parmDataAreaId(_dataAreaId);
        }

        return dataAreaId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsDefaultAccount</Name>
				<Source><![CDATA[
    public boolean parmIsDefaultAccount(boolean _isDefaultAccount = isDefaultAccount)
    {
        if (!prmisdefault(_isDefaultAccount))
        {
            isDefaultAccount = _isDefaultAccount;
            ledgerDimensionAccountController.parmIsDefaultAccount(_isDefaultAccount);
            ledgerDimensionDefaultAccountController.parmIsDefaultAccount(_isDefaultAccount);
        }

        return isDefaultAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountTypeEnumType</Name>
				<Source><![CDATA[
    public EnumName parmAccountTypeEnumType(EnumName _accountTypeEnumType = accountTypeEnumType)
    {
        if (!prmisdefault(_accountTypeEnumType))
        {
            accountTypeEnumType = _accountTypeEnumType;
            ledgerDimensionAccountController.parmAccountTypeEnumType(_accountTypeEnumType);
            ledgerDimensionDefaultAccountController.parmAccountTypeEnumType(_accountTypeEnumType);
        }

        return accountTypeEnumType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmValidateBlockedForManualEntry</Name>
				<Source><![CDATA[
    public NoYes parmValidateBlockedForManualEntry(NoYes _validateBlockedForManualEntry = validateBlockedForManualEntry)
    {
        if (!prmisDefault(_validateBlockedForManualEntry))
        {
            validateBlockedForManualEntry = _validateBlockedForManualEntry;
            ledgerDimensionAccountController.parmValidateBlockedForManualEntry(_validateBlockedForManualEntry);
            ledgerDimensionDefaultAccountController.parmValidateBlockedForManualEntry(_validateBlockedForManualEntry);
        }

        return validateBlockedForManualEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmControlDate</Name>
				<Source><![CDATA[
    public TransDate parmControlDate(TransDate _controlDate = controlDate)
    {
        if (!prmisDefault(_controlDate))
        {
            controlDate = _controlDate;
            ledgerDimensionAccountController.parmControlDate(_controlDate);
            ledgerDimensionDefaultAccountController.parmControlDate(_controlDate);
        }

        return controlDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDimensionAccountStorageUsageType</Name>
				<Source><![CDATA[
    public DimensionAccountStorageUsage parmDimensionAccountStorageUsageType(DimensionAccountStorageUsage _dimensionAccountStorageUsageType = dimensionAccountStorageUsageType)
    {
        if (!prmisdefault(_dimensionAccountStorageUsageType))
        {
            dimensionAccountStorageUsageType = _dimensionAccountStorageUsageType;
            ledgerDimensionAccountController.parmDimensionAccountStorageUsageType(_dimensionAccountStorageUsageType);
            ledgerDimensionDefaultAccountController.parmDimensionAccountStorageUsageType(_dimensionAccountStorageUsageType);
        }

        return dimensionAccountStorageUsageType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDimensionAutoCompleteFilter</Name>
				<Source><![CDATA[
    public DimensionAutocompleteFilterable parmDimensionAutoCompleteFilter(DimensionAutocompleteFilterable _dimensionAutoCompleteFilter = dimensionAutoCompleteFilter)
    {
        if (!prmisdefault(_dimensionAutoCompleteFilter))
        {
            dimensionAutoCompleteFilter = _dimensionAutoCompleteFilter;
            ledgerDimensionAccountController.parmDimensionAutoCompleteFilter(_dimensionAutoCompleteFilter);
            ledgerDimensionDefaultAccountController.parmDimensionAutoCompleteFilter(_dimensionAutoCompleteFilter);
        }

        return dimensionAutoCompleteFilter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalName</Name>
				<Source><![CDATA[
    public JournalNameId parmJournalName(JournalNameId _journalName = journalName)
    {
        if (!prmisdefault(_journalName))
        {
            journalName = _journalName;
            ledgerDimensionAccountController.parmJournalName(_journalName);
            ledgerDimensionDefaultAccountController.parmJournalName(_journalName);
        }

        return journalName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLockMainAccountSegment</Name>
				<Source><![CDATA[
    public NoYes parmLockMainAccountSegment(NoYes _lockMainAccountSegment = lockMainAccountSegment)
    {
        dimensionHierarchyType = this.getHierarchyType();

        if (DimensionHierarchy::isMultiTypeStructureHierarchyType(dimensionHierarchyType))
        {
            // By definition, multi-typed (dynamic) accounts don't contain a main account so this method should not be called in those cases.
            // However, no harm is done so just assert.
            Debug::assert(false);
        }
        else if (this.isNonLedgerAccount())
        {
            // Non-ledger accounts should never have a non-multitype structure
            Debug::assert(false);
        }
        else if (this.parmIsDefaultAccount())
        {
            lockMainAccountSegment = _lockMainAccountSegment;

            if (!prmisDefault(_lockMainAccountSegment) && ledgerDimensionDefaultAccountController)
            {
                ledgerDimensionDefaultAccountController.parmLockMainAccountSegment(lockMainAccountSegment);
            }
        }
        else
        {
            lockMainAccountSegment = _lockMainAccountSegment;

            if (!prmisDefault(_lockMainAccountSegment) && ledgerDimensionAccountController)
            {
                ledgerDimensionAccountController.parmLockMainAccountSegment(lockMainAccountSegment);
            }
        }

        return lockMainAccountSegment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostingType</Name>
				<Source><![CDATA[
    public LedgerPostingType parmPostingType(LedgerPostingType _postingType = postingType)
    {
        if (!prmisdefault(_postingType))
        {
            postingType = _postingType;
            ledgerDimensionAccountController.parmPostingType(_postingType);
            ledgerDimensionDefaultAccountController.parmPostingType(_postingType);
        }

        return postingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountStructure</Name>
				<Source><![CDATA[
    public DimensionHierarchyId getAccountStructure()
    {
        DimensionHierarchyId accountStructureId;

        if (this.isNonLedgerAccount())
        {
            accountStructureId = super();
        }
        else if (this.parmIsDefaultAccount())
        {
            accountStructureId = ledgerDimensionDefaultAccountController.getAccountStructure();
        }
        else
        {
            accountStructureId = ledgerDimensionAccountController.getAccountStructure();
        }

        return accountStructureId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAccountStructure</Name>
				<Source><![CDATA[
    public void setAccountStructure(DimensionHierarchyId _accountStructure = accountStructure, boolean _raiseEvent = true)
    {
        if (this.isNonLedgerAccount())
        {
            super(_accountStructure, _raiseEvent);
        }
        else if (this.parmIsDefaultAccount())
        {
            ledgerDimensionDefaultAccountController.setAccountStructure(_accountStructure, _raiseEvent);
        }
        else
        {
            ledgerDimensionAccountController.setAccountStructure(_accountStructure, _raiseEvent);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeFinancialAccounts</Name>
				<Source><![CDATA[
    public NoYes parmIncludeFinancialAccounts(NoYes _includeFinancialAccounts = includeFinancialAccounts)
    {
        if (!prmisdefault(_includeFinancialAccounts))
        {
            includeFinancialAccounts = _includeFinancialAccounts;
            ledgerDimensionAccountController.parmIncludeFinancialAccounts(_includeFinancialAccounts);
            ledgerDimensionDefaultAccountController.parmIncludeFinancialAccounts(_includeFinancialAccounts);
        }

        return includeFinancialAccounts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeTotalAccounts</Name>
				<Source><![CDATA[
    public NoYes parmIncludeTotalAccounts(NoYes _includeTotalAccounts = includeTotalAccounts)
    {
        if (!prmisdefault(_includeTotalAccounts))
        {
            includeTotalAccounts = _includeTotalAccounts;
            ledgerDimensionAccountController.parmIncludeTotalAccounts(_includeTotalAccounts);
            ledgerDimensionDefaultAccountController.parmIncludeTotalAccounts(_includeTotalAccounts);
        }

        return includeTotalAccounts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCurrency</Name>
				<Source><![CDATA[
    public CurrencyCode parmCurrency(CurrencyCode _currency = currency)
    {
        if (!prmisdefault(_currency))
        {
            currency = _currency;
            ledgerDimensionAccountController.parmCurrency(_currency);
            ledgerDimensionDefaultAccountController.parmCurrency(_currency);
        }

        return currency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBackingEntityValueFieldAbsoluteFieldBinding</Name>
				<Source><![CDATA[
    public AbsoluteFieldBinding getBackingEntityValueFieldAbsoluteFieldBinding()
    {
        AbsoluteFieldBinding fieldBinding;
        dimensionHierarchyType = this.getHierarchyType();

        if (DimensionHierarchy::isMultiTypeStructureHierarchyType(dimensionHierarchyType))
        {
            // Use the table and field from the dimensionAttribute to create the field binding
            DimensionAttribute dimensionAttribute = DimensionAttribute::getAttributeByHierarchyType(dimensionHierarchyType);
            str backingTableName = dimensionAttribute.BackingEntityTableName;
            str backingFieldName = dimensionAttribute.BackingEntityValueFieldName;

            fieldBinding = AbsoluteFieldBinding::construct(backingFieldName, backingTableName);
        }
        else if (this.isNonLedgerAccount())
        {
            // Non-ledger accounts should never have a non-multitype structure
            Debug::assert(false);
        }

        return fieldBinding;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getHierarchyType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the hierarchy type of the current account type.
    /// </summary>
    /// <returns>
    /// The hierarchy type of the current account type.
    /// </returns>
    /// <remarks>
    /// The account type is derived from the values of the fields that are specified when they are created.
    /// </remarks>
    public DimensionHierarchyType getHierarchyType()
    {
        if (this.parmIsDefaultAccount())
        {
            this.parmLedgerDimensionType(LedgerDimensionType::DefaultAccount);
        }
        else
        {
            this.parmLedgerDimensionType(LedgerDimensionType::Account);
        }

        lastDimensionHierarchyType = dimensionHierarchyType;
        dimensionHierarchyType = DimensionHierarchyHelper::getHierarchyTypeByAccountType(accountType, enumName2Id(accountTypeEnumType), custVend);

        return dimensionHierarchyType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getControllerByHierarchyType</Name>
				<Source><![CDATA[
    private DimensionController getControllerByHierarchyType()
    {
        dimensionHierarchyType = this.getHierarchyType();
        DimensionController dimensionController;

        if (DimensionHierarchy::isMultiTypeStructureHierarchyType(dimensionHierarchyType))
        {
            // There is no controller type to return for multi-type accounts.
            Debug::assert(false);
        }
        else if (this.isNonLedgerAccount())
        {
            // Non-ledger accounts should never have a non-multitype structure
            Debug::assert(false);
        }
        else if (this.parmIsDefaultAccount())
        {
            dimensionController = ledgerDimensionDefaultAccountController;
        }
        else
        {
            dimensionController = ledgerDimensionAccountController;
        }

        return dimensionController;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimensionAttributeByIndex</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the record ID of the <c>DimensionAttribute</c> record for the segment.
    /// </summary>
    /// <param name="_index">
    /// The segment index.
    /// </param>
    /// <returns>
    /// The record ID of the <c>DimensionAttribute</c> record for the segment.
    /// </returns>
    public DimensionAttributeRecId getDimensionAttributeByIndex(int _index)
    {
        DimensionAttributeRecId dimensionAttributeRecId;
        dimensionHierarchyType = this.getHierarchyType();

        if (DimensionHierarchy::isMultiTypeStructureHierarchyType(dimensionHierarchyType))
        {
            dimensionAttributeRecId = DimensionAttribute::getAttributeByHierarchyType(dimensionHierarchyType).RecId;
        }
        else if (this.isNonLedgerAccount())
        {
            // Non-ledger accounts should never have a non-multitype structure
            Debug::assert(false);
        }
        else if (this.parmIsDefaultAccount())
        {
            dimensionAttributeRecId = ledgerDimensionDefaultAccountController.getDimensionAttributeByIndex(_index);
        }
        else
        {
            dimensionAttributeRecId = ledgerDimensionAccountController.getDimensionAttributeByIndex(_index);
        }

        return dimensionAttributeRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIndexByDimensionAttribute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the index of the specified dimension attribute.
    /// </summary>
    /// <param name="_dimensionAttributeId">
    /// The record ID of the dimension attribute.
    /// </param>
    /// <returns>
    /// The index of the specified dimension attribute if it is in the segment list; otherwise, zero.
    /// </returns>
    public int getIndexByDimensionAttribute(DimensionAttributeRecId _dimensionAttributeId)
    {
        int segmentIndex = 0;
        dimensionHierarchyType = this.getHierarchyType();

        if (DimensionHierarchy::isMultiTypeStructureHierarchyType(dimensionHierarchyType))
        {
            DimensionAttributeRecId dimensionAttributeRecId = DimensionAttribute::getAttributeByHierarchyType(dimensionHierarchyType).RecId;

            if ((_dimensionAttributeId == dimensionAttributeRecId) && currentSegments && (currentSegments.lastIndex() == 1))
            {
                segmentIndex = 1;
            }
            else
            {
                segmentIndex = 0;
            }
        }
        else
        {
            DimensionController dimensionController = this.getControllerByHierarchyType();

            if (dimensionController)
            {
                segmentIndex = dimensionController.getIndexByDimensionAttribute(_dimensionAttributeId);
            }
        }

        return segmentIndex;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSegmentForDimensionAttribute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the segment for the specified dimension attribute.
    /// </summary>
    /// <param name="_dimensionAttributeId">
    /// The record ID of the dimension attribute.
    /// </param>
    /// <returns>
    /// The segment for the specified dimension attribute if it is in the segment list; otherwise, zero.
    /// </returns>
    public DimensionControlSegment getSegmentForDimensionAttribute(DimensionAttributeRecId _dimensionAttributeId)
    {
        DimensionControlSegment segment;

        dimensionHierarchyType = this.getHierarchyType();

        if (DimensionHierarchy::isMultiTypeStructureHierarchyType(dimensionHierarchyType))
        {
            DimensionAttributeRecId dimensionAttributeRecId = DimensionAttribute::getAttributeByHierarchyType(dimensionHierarchyType).RecId;

            if ((_dimensionAttributeId == dimensionAttributeRecId) && currentSegments && (currentSegments.lastIndex() == 1))
            {
                segment = currentSegments.value(1);
            }
        }
        else
        {
            DimensionController dimensionController = this.getControllerByHierarchyType();

            if (dimensionController)
            {
                segment = dimensionController.getSegmentForDimensionAttribute(_dimensionAttributeId);
            }
        }

        return segment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimAttrValueForDimensionAttribute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the record ID of the <c>DimensionAttributeValue</c> record for the specified <c>DimensionAttribute</c> record.
    /// </summary>
    /// <param name = "_dimensionAttributeId">
    /// The record ID of the <c>DimensionAttribute</c> record.
    /// </param>
    /// <returns>
    /// The record ID of the <c>DimensionAttributeValue</c> record for the specified <c>DimensionAttribute</c> record.
    /// </returns>
    public DimensionAttributeValueRecId getDimAttrValueForDimensionAttribute(DimensionAttributeRecId _dimensionAttributeId)
    {
        DimensionAttributeValueRecId dimensionAttributeValueId = 0;
        dimensionHierarchyType = this.getHierarchyType();

        if (DimensionHierarchy::isMultiTypeStructureHierarchyType(dimensionHierarchyType))
        {
            DimensionAttributeRecId dimensionAttributeRecId = DimensionAttribute::getAttributeByHierarchyType(dimensionHierarchyType).RecId;

            if ((_dimensionAttributeId == dimensionAttributeRecId) && currentSegments && (currentSegments.lastIndex() == 1))
            {
                DimensionControlSegment segment = currentSegments.value(1);
                dimensionAttributeValueId = segment.parmDimensionAttributeValue().RecId;
            }
        }
        else
        {
            DimensionController dimensionController = this.getControllerByHierarchyType();

            if (dimensionController)
            {
                dimensionAttributeValueId = dimensionController.getDimAttrValueForDimensionAttribute(_dimensionAttributeId);
            }
        }

        return dimensionAttributeValueId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSegmentByIndex</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the segment pointed to by the specified index.
    /// </summary>
    /// <param name = "_index">
    /// The segment index.
    /// </param>
    /// <returns>
    /// The segment pointed to by the specified index.
    /// </returns>
    public DimensionControlSegment getSegmentByIndex(int _index)
    {
        DimensionControlSegment segment = null;

        if (_index < 1)
        {
            throw error(Error::wrongUseOfFunction(funcname()));
        }

        dimensionHierarchyType = this.getHierarchyType();

        if (DimensionHierarchy::isMultiTypeStructureHierarchyType(dimensionHierarchyType))
        {
            if ((_index == 1) && currentSegments && currentSegments.lastIndex() == 1)
            {
                segment = currentSegments.value(1);
            }
        }
        else
        {
            DimensionController dimensionController = this.getControllerByHierarchyType();

            if (dimensionController)
            {
                segment = dimensionController.getSegmentByIndex(_index);
            }
        }

        return segment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getValueForDimensionAttribute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets record ID of the backing entity record for the specified dimension attribute.
    /// </summary>
    /// <param name="_dimensionAttributeId">
    /// The record ID of the dimension attribute.
    /// </param>
    /// <returns>
    /// The record ID of the entity instance set for the specified dimension attribute.
    /// </returns>
    /// <remarks>
    /// If a value has not been set or the specified dimension attribute is not available, returns 0.
    /// </remarks>
    public RecId getValueForDimensionAttribute(DimensionAttributeRecId _dimensionAttributeId = DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount))
    {
        RefRecId entityInstance;

        dimensionHierarchyType = this.getHierarchyType();

        if (DimensionHierarchy::isMultiTypeStructureHierarchyType(dimensionHierarchyType))
        {
            DimensionAttributeRecId dimensionAttributeRecId = DimensionAttribute::getAttributeByHierarchyType(dimensionHierarchyType).RecId;

            if ((_dimensionAttributeId == dimensionAttributeRecId) && currentSegments && (currentSegments.lastIndex() == 1))
            {
                DimensionControlSegment segment = currentSegments.value(1);
                entityInstance = segment.parmDimensionAttributeValue().EntityInstance;
            }
        }
        else
        {
            DimensionController dimensionController = this.getControllerByHierarchyType();

            if (dimensionController)
            {
                entityInstance = dimensionController.getValueForDimensionAttribute(_dimensionAttributeId);
            }
        }

        return entityInstance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        super();

        firstInput = true;

        ledgerDimensionAccountController = new LedgerDimensionAccountController();
        ledgerDimensionDefaultAccountController = new LedgerDimensionDefaultAccountController();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastProcessedState</Name>
				<Source><![CDATA[
    public DimensionControlInfo getLastProcessedState()
    {
        return lastProcessedState;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processUserInput</Name>
				<Source><![CDATA[
    public DimensionControlInfo processUserInput(str _userInput)
    {
        changecompany(this.parmDataAreaId())
        {
            // Decide which controller will handle the request
            if (this.isNonLedgerAccount())
            {
                this.setAccountStructure(DimensionHierarchy::getHierarchyIdByHierarchyType(dimensionHierarchyType), true);

                // If nothing has changed, no need to reprocess
                if (firstInput ||
                    _userInput != lastUserInput ||
                    lastAccountType != this.parmAccountType() ||
                    lastCustVend != this.parmCustVend())
                {
                    // First input is to avoid a case where lastUserInput defaults to empty
                    // string, but the user also passes in empty string
                    firstInput = false;
                    lastUserInput = _userInput;

                    lastProcessedState = this.processNewUserInputNonLedger(_userInput);

                    lastAccountType = this.parmAccountType();
                    lastCustVend = this.parmCustVend();
                }
            }
            else
            {
                if (lastDimensionHierarchyType != DimensionHierarchyType::AccountStructure
                    && dimensionHierarchyType == DimensionHierarchyType::AccountStructure)
                {
                    // If we went from non-ledger to ledger account type, clear the account structure since
                    // it will no longer be valid. Also, raise the event associated with setting account structure
                    // to ensure the controller state is reset
                    this.setAccountStructure(0, true);
                }

                if (this.parmIsDefaultAccount())
                {
                    lastProcessedState = ledgerDimensionDefaultAccountController.processUserInput(_userInput);
                }
                else
                {
                    lastProcessedState = ledgerDimensionAccountController.processUserInput(_userInput);
                }
            }

            return lastProcessedState;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processNewUserInputNonLedger</Name>
				<Source><![CDATA[
    private DimensionControlInfo processNewUserInputNonLedger(str _userInput)
    {
        DimensionAttribute      dimAttr;
        DimensionAttributeValue dav;
        DimensionControlInfo    controlInfo;
        DictTable               dictTable;
        boolean                 isValid;
        int                     compareResult;
        DimensionValue          actualValue;
        DimensionControlSegment segment;
        Array                   resultSegments;

        // Non-ledger accounts always have one segment
        segment = new DimensionControlSegment();
        segment.parmStartIndex(1);
        segment.parmEndIndex(1 + strlen(_userInput));
        segment.parmValidationStatus(SegmentValidationStatus::Valid); // Assume valid until proven otherwise
        segment.parmValue(_userInput);

        dimAttr = DimensionAttribute::getAttributeByHierarchyType(dimensionHierarchyType);
        segment.parmDimensionAttribute(dimAttr);
        segment.parmName(DimensionAttribute::getDynamicAccountAttributeName(dimAttr.ViewName));
        dictTable = new DictTable(dimAttr.BackingEntityType);
        backingValue = dictTable.makeRecord();

        if (_userInput)
        {
            // Read entire buffer as the (dimAttr.ValueAttribute) column is needed (and cannot be specified as a field list)
            select firstonly backingValue where backingValue.(dimAttr.ValueAttribute) == _userInput;
            isValid = (backingValue.RecId != 0);

            if (isValid)
            {
                compareResult = strCmp(backingValue.(dimAttr.ValueAttribute), _userInput);
                if (compareResult != 0)
                {
                    actualValue = backingValue.(dimAttr.ValueAttribute);
                    segment.parmValue(actualValue);
                }
                dav = DimensionAttributeValue::findByDimensionAttributeAndEntityInst(dimAttr.RecId, backingValue.RecId, false, true);
                segment.parmDimensionAttributeValue(dav);
            }
            else
            {
                segment.parmValidationStatus(SegmentValidationStatus::ValueNotFound);
            }
        }

        resultSegments = new Array(Types::Class);
        resultSegments.Value(1, segment);

        controlInfo = new DimensionControlInfo();
        controlInfo.parmSegments(resultSegments);
        currentSegments = resultSegments;

        if (actualValue)
        {
            controlInfo.parmNewInputString(actualValue);
            lastUserInput = actualValue;
        }

        return controlInfo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNonLedgerAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the current account type is a non-ledger account.
    /// </summary>
    /// <returns>
    /// true if the current account type is not a ledger account; otherwise, false.
    /// </returns>
    private boolean isNonLedgerAccount()
    {
        dimensionHierarchyType = this.getHierarchyType();

        return DimensionHierarchy::isMultiTypeStructureHierarchyType(dimensionHierarchyType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>resolveReference</Name>
				<Source><![CDATA[
    public DimensionAttributeValueCombination resolveReference()
    {
        if (this.isNonLedgerAccount())
        {
            return this.resolveReferenceNonLedger();
        }
        else if (this.parmIsDefaultAccount())
        {
            return ledgerDimensionDefaultAccountController.resolveReference();
        }
        else
        {
            return ledgerDimensionAccountController.resolveReference();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resolveReferenceNonLedger</Name>
				<Source><![CDATA[
    private DimensionAttributeValueCombination resolveReferenceNonLedger()
    {
        DimensionAttributeValueCombination davc;
        LedgerDimensionAccount ledgerDimension;

        changecompany(this.parmDataAreaId())
        {
            if (lastUserInput && backingValue)
            {
                ledgerDimension = LedgerDynamicAccountHelper::getDynamicAccountFromAccountNumberEnumModule(lastUserInput, accountType, enumName2Id(accountTypeEnumType), custVend);
                davc = DimensionAttributeValueCombination::find(ledgerDimension);
            }
        }

        return davc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAccountTypeEnumValue</Name>
				<Source><![CDATA[
    public void setAccountTypeEnumValue(int _value)
    {
        this.parmAccountType(_value);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSecondaryAccountTypeEnumValue</Name>
				<Source><![CDATA[
    public void setSecondaryAccountTypeEnumValue(int _value)
    {
        this.parmCustVend(_value);
    }

]]></Source>
			</Method>
			<Method>
				<Name>jumpRef</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides view details functionality. The form that opens is based on the <c>DimensionHierarchyType</c>
    /// instance for this controller.
    /// </summary>
    /// <param name = "_mainAccountSegment">The main account segment from the Segmented Entry control.</param>
    /// <remarks>
    /// The value in the Segmented Entry control will be selected on the form that opens.
    /// If the value is empty or invalid, the first element will be selected, and the form will
    /// be opened in grid view.
    /// </remarks>
    public void jumpRef(DimensionControlSegment _mainAccountSegment)
    {
        changecompany(dataAreaId)
        {
            DimensionHierarchyType hierarchyType = this.getHierarchyType();

            if (hierarchyType == DimensionHierarchyType::AccountStructure)
            {
                if (this.isNonLedgerAccount())
                {
                    // Non-ledger accounts should never have the type of "AccountStructure"
                    Debug::assert(false);
                }
                else
                {
                    ledgerDimensionAccountController.jumpRef(_mainAccountSegment);
                }

                return;
            }

            DimensionAttributeValueCombination combination = this.resolveReference();
            MenuFunction menuFunction;
            Args args = new Args();

            switch (hierarchyType)
            {
                case DimensionHierarchyType::BankAccount:
                    menuFunction = new MenuFunction(menuitemDisplayStr(BankAccountTable), MenuItemType::Display);
                    if (combination)
                    {
                        args.lookupRecord(BankAccountTable::findByLedgerDimension(combination.RecId));
                    }
                    break;

                case DimensionHierarchyType::Customer:
                    menuFunction = new MenuFunction(menuitemDisplayStr(CustTable), MenuItemType::Display);
                    if (combination)
                    {
                        args.lookupRecord(CustTable::findByLedgerDimension(combination.RecId));
                    }
                    break;

                case DimensionHierarchyType::Employee:
                    menuFunction = new MenuFunction(menuitemdisplaystr(HcmWorker), MenuItemType::Display);
                    if (combination)
                    {
                        args.lookupRecord(HcmWorker::findByPersonnelNumber(combination.DisplayValue));
                    }
                    break;

                case DimensionHierarchyType::FixedAsset:
                    menuFunction = new MenuFunction(menuitemDisplayStr(AssetTableDetails), MenuItemType::Display);
                    if (combination)
                    {
                        args.lookupRecord(AssetTable::findByLedgerDimension(combination.RecId));
                    }
                    break;

                case DimensionHierarchyType::Item:
                    menuFunction = new MenuFunction(menuitemDisplayStr(EcoResProductDetailsExtended), MenuItemType::Display);
                    if (combination)
                    {
                        args.lookupRecord(InventTable::find(combination.DisplayValue));
                    }
                    break;

                case DimensionHierarchyType::Project:
                    menuFunction = new MenuFunction(menuitemDisplayStr(ProjTable), MenuItemType::Display);
                    if (combination)
                    {
                        args.lookupRecord(ProjTable::findByLedgerDimension(combination.RecId));
                        args.refField(fieldNum(ProjTable, ProjId));
                    }
                    break;

                case DimensionHierarchyType::Vendor:
                    menuFunction = new MenuFunction(menuitemDisplayStr(VendTable), MenuItemType::Display);
                    if (combination)
                    {
                        args.lookupRecord(VendTable::findByLedgerDimension(combination.RecId));
                    }
                    break;

                // <GEERU> // TODO: should we have an Edit form?
                case DimensionHierarchyType::FixedAssets_RU:
                    menuFunction = new MenuFunction(menuitemdisplaystr(RAssetTable), MenuItemType::Display);
                    if (combination)
                    {
                        args.lookupRecord(RAssetTable::findByLedgerDimension(combination.RecId));
                    }
                    break;

                case DimensionHierarchyType::RDeferrals:
                    menuFunction = new MenuFunction(menuitemdisplaystr(RDeferralsTable), MenuItemType::Display);
                    if (combination)
                    {
                        args.lookupRecord(RDeferralsTable::findByLedgerDimension(combination.RecId));
                    }
                    break;

                case DimensionHierarchyType::RCash:
                    menuFunction = new MenuFunction(menuitemdisplaystr(RCashTable), MenuItemType::Display);
                    if (combination)
                    {
                        args.lookupRecord(RCashTable::findByLedgerDimension(combination.RecId));
                    }
                    break;

                case DimensionHierarchyType::Employee_RU:
                    menuFunction = new MenuFunction(menuitemdisplaystr(HcmWorkerAdvHolderTable_RU), MenuItemType::Display);
                    if (combination)
                    {
                        args.lookupRecord(EmployeeTable_RU::findByEmployeeId(combination.DisplayValue));
                    }
                    break;
                // </GEERU>

                default:
                    throw error(Error::wrongUseOfFunction(funcName()));
            }

            // Make sure no queries get passed to the jumpRef form
            menuFunction.copyCallerQuery(CopyCallerQuery::No);
            menuFunction.run(args);
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>