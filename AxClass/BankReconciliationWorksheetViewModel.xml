<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BankReconciliationWorksheetViewModel</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>BankReconciliationWorksheetViewModel</c> is the view model for bank reconciliation work sheet.
/// </summary>
class BankReconciliationWorksheetViewModel
{
    // Form view
    BankReconciliationWorksheetFormView worksheetFormView;

    // Data sources
    FormDataSource dsOpenStatement;
    FormDataSource dsMatchedStatement;
    FormDataSource dsOpenDocument;
    FormDataSource dsMatchedDocument;
    FormDataSource dsMatchedDocumentSecondary;
    FormDataSource dsMatchedStatementSecondary;
    FormDataSource dsNewStatement;

    // Records
    BankReconciliationHeader reconciliation;

    BankReconciliationDataManager dataManager;
    BankReconciliationMatchingMaxDiffDays maxDiffDays;

    private boolean isBankReconWorksheetFilterAndSplitNewFeatureEnabled = FeatureStateProvider::isFeatureEnabled(BankReconWorksheetFilterAndSplitNewFeature::instance());
    private boolean isBankStatementPostInBatchFeatureEnabled = FeatureStateProvider::isFeatureEnabled(BankStatementPostInBatchFeature::instance());

    #BankElectronicReconciliation
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>dsStatementOpenActivePost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post action of active of open statement line.
    /// </summary>
    public void dsStatementOpenActivePost()
    {
        BankReconciliationStatementOpenTmp  statementTmpLocal;

        if (dsOpenStatement.recordsMarked().lastIndex() > 1)
        {
            // Don't do anything if multiple statement lines are marked.
            return;
        }
        else if (dsOpenStatement.recordsMarked().lastIndex() == 1)
        {
            if (!dsOpenStatement.getFirst(1).equal(dsOpenStatement.cursor()))
            {
                // Don't do anything if other statement line is already marked
                return;
            }
        }

        statementTmpLocal.data(dsOpenStatement.cursor());

        if (statementTmpLocal)
        {
            this.unmarkAllOpenDocument();
        }

        dsOpenDocument.refreshEx();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getImpactedEntriesOfUnmatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets impacted entries by the unmatching.
    /// </summary>
    /// <param name="_entryMatched">
    /// The entry to unmatch.
    /// </param>
    /// <returns>
    /// A container containning all the impacted entries.
    /// </returns>
    private container getImpactedEntriesOfUnmatch(Common _entryMatched)
    {
        BankReconciliationStatementOpenTmp  statementMatched;
        BankReconciliationDocumentOpenTmp   documentmatched;
        BankReconciliationStatementOpenTmp  statementFocused;
        BankReconciliationDocumentOpenTmp   documentFocused;
        BankReconciliationMatchingItem      matchingItem;

        List                                allMatchingItemitemsList;
        ListEnumerator                      enumerator;

        BankReconciliationMatchingEntryType entryType;
        RecId                               entryRecId;

        List                                impactedStatementIdList = new List(Types::Int64);
        List                                impactedDocumentIdList = new List(Types::Int64);

        if (_entryMatched.TableId == tableNum(BankReconciliationStatementOpenTmp))
        {
            statementFocused = _entryMatched;
            matchingItem = BankReconciliationMatchingItem::findValidByStatementLineRecId(statementFocused.BankStmtISOReportEntry);
        }
        else
        {
            documentFocused = _entryMatched;
            matchingItem = BankReconciliationMatchingItem::findValidByDocumentRecId(documentFocused.BankDocumentTableView);
        }
        allMatchingItemitemsList    = BankReconciliationMatching::getAllMatchingItemsList(matchingItem.BankReconciliationMatching);

        enumerator = allMatchingItemitemsList.getEnumerator();

        statementMatched.linkPhysicalTableInstance(dsMatchedStatement.cursor());
        documentmatched.linkPhysicalTableInstance(dsMatchedDocument.cursor());

        while (enumerator.moveNext())
        {
            [entryType, entryRecId] = enumerator.current();

            if (entryType == BankReconciliationMatchingEntryType::BankStatement)
            {
                select RecId from statementMatched
                    where statementMatched.BankStmtISOReportEntry == entryRecId;

                impactedStatementIdList.addEnd(statementMatched.RecId);
            }
            else if (entryType == BankReconciliationMatchingEntryType::BankDocument)
            {
                select RecId from documentmatched
                    where documentmatched.BankDocumentTableView == entryRecId;

                impactedDocumentIdList.addEnd(documentmatched.RecId);
            }
        }

        return [impactedStatementIdList.pack(), impactedDocumentIdList.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDataSource</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes data sources.
    /// </summary>
    private void initDataSource()
    {
        dsOpenStatement = worksheetFormView.parmDSOpenStatement();
        dsOpenDocument = worksheetFormView.parmDSOpenDocument();
        dsMatchedStatement = worksheetFormView.parmDSMatchedStatement();
        dsMatchedDocument = worksheetFormView.parmDSMatchedDocument();
        dsMatchedDocumentSecondary = worksheetFormView.parmDSMatchedDocumentSecondary();
        dsMatchedStatementSecondary = worksheetFormView.parmDSMatchedStatementSecondary();

        if (isBankReconWorksheetFilterAndSplitNewFeatureEnabled)
        {
            dsNewStatement = worksheetFormView.getDSNewStatement();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initialize</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the bank statement view model.
    /// </summary>
    public void initialize()
    {
        maxDiffDays = BankParameters::find().AllowedReconciliationMatchingMaxDiffDays;

        this.initDataSource();
        this.initReconciliationBuffer();
        this.loadData();

        dataManager = BankReconciliationDataManager::construct(
            reconciliation,
            dsOpenStatement.cursor(),
            dsOpenDocument.cursor());
    }

]]></Source>
			</Method>
			<Method>
				<Name>initReconciliationBuffer</Name>
				<Source><![CDATA[
    private void initReconciliationBuffer()
    {
        reconciliation = worksheetFormView.parmWorksheetFormRun().args().record();
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads the reconciliation data.
    /// </summary>
    private void loadData()
    {
        BankReconciliationDataInitializer dataInit;

        if (reconciliation)
        {
            dataInit = this.createBankReconciliationDataInitializer(reconciliation);

            dataInit.loadData();
            this.setDocumentTmpData(dataInit.getDocumentData());
            this.setStatementTmpData(dataInit.getStatementData());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBankReconciliationDataInitializer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>BankReconciliationDataInitializer</c> instance.
    /// </summary>
    /// <param name = "_reconciliation">The <c>BankReconciliationHeader</c> buffer.</param>
    /// <returns>A new instance of the <c>BankReconciliationDataInitializer</c> class.</returns>
    protected BankReconciliationDataInitializer createBankReconciliationDataInitializer(BankReconciliationHeader _reconciliation)
    {
        return BankReconciliationDataInitializer::construct(reconciliation);
    }

]]></Source>
			</Method>
			<Method>
				<Name>matchMarkedStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Match marked statement.
    /// </summary>
    /// <param name="_reportEntry">
    /// The report entry.
    /// </param>
    /// <param name="_statement">
    /// The statement information.
    /// </param>
    /// <param name="_partyIdentification">
    /// The party identification.
    /// </param>
    /// <param name="_isMatched">
    /// The isMatched flag.
    /// </param>
    /// <param name="_matchingType">
    /// The matching type.
    /// </param>
    /// <returns>
    /// Returns true if the marked statement match.
    /// </returns>
    protected boolean matchMarkedStatement(
        BankStmtISOReportEntry              _reportEntry,
        BankStmtISOAccountStatement         _statement,
        BankStmtISOPartyIdentification      _partyIdentification,
        NoYesId                             _isMatched,
        BankReconciliationMatchingType      _matchingType)
    {
        BankReconciliationMatchingMatchProcessor matchProcessor;
        boolean isMarkUpdated;

        if (!reconciliation.IsReconciled)
        {
            if (_reportEntry.IsNewBankDocument() && !_isMatched)
            {
                matchProcessor = BankReconciliationMatchingMatchProcessor::construct(reconciliation);
                matchProcessor.addEntry(BankReconciliationMatchingEntry::construct(BankReconciliationMatchingEntryType::BankStatement, _reportEntry.RecId));
                matchProcessor.processMatch();

                isMarkUpdated = true;
            }
        }

        return isMarkUpdated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankReconciliationDataManager</Name>
				<Source><![CDATA[
    public BankReconciliationDataManager parmBankReconciliationDataManager()
    {
        return dataManager;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankReconciliationHeader</Name>
				<Source><![CDATA[
    public BankReconciliationHeader parmBankReconciliationHeader(BankReconciliationHeader _reconciliation = reconciliation)
    {
        reconciliation = _reconciliation;

        return reconciliation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWorksheetFormView</Name>
				<Source><![CDATA[
    public BankReconciliationWorksheetFormView parmWorksheetFormView(BankReconciliationWorksheetFormView _worksheetFormView = worksheetFormView)
    {
        worksheetFormView = _worksheetFormView;

        return worksheetFormView;
    }

]]></Source>
			</Method>
			<Method>
				<Name>performMarkingStatementProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs marking new statement.
    /// </summary>
    public void performMarkingStatementProcess()
    {
        BankReconciliationMatchingMatchProcessor    matchingMatchProcessor;
        BankReconciliationMatchingEntry             matchingEntry;

        BankReconciliationStatementOpenTmp          statementTmpLocal;
        List                                        impactedBankDocumentList = new List(Types::Int64);
        List                                        impactedStatementList = new List(Types::Int64);

        boolean                                     isValidMatchOperation = true;
        boolean                                     isMatchingSuccess;
        boolean                                     isAnyMatchingSuccess;

        if (dsOpenDocument.anyMarked())
        {
            isValidMatchOperation = checkFailed("@GLS222653");
        }

        if (isValidMatchOperation)
        {
            ttsBegin;
            boolean isMarked = dsOpenStatement.anyMarked();
            statementTmpLocal = isMarked ? dsOpenStatement.getFirst(1) : dsOpenStatement.cursor();

            if (statementTmpLocal)
            {
                while (statementTmpLocal)
                {
                    matchingEntry = BankReconciliationMatchingEntry::construct(BankReconciliationMatchingEntryType::BankStatement, statementTmpLocal.BankStmtISOReportEntry);
                    matchingMatchProcessor = BankReconciliationMatchingMatchProcessor::construct(reconciliation);
                    matchingMatchProcessor.addEntry(matchingEntry);

                    isMatchingSuccess = matchingMatchProcessor.processMatch();

                    if (isMatchingSuccess)
                    {
                        isAnyMatchingSuccess = true;
                        impactedStatementList.addEnd(statementTmpLocal.RecId);
                    }

                    if (!isMarked)
                    {
                        break;
                    }

                    statementTmpLocal = dsOpenStatement.getNext();
                }
                
                if (isAnyMatchingSuccess)
                {
                    dataManager.refreshMatchStatus(impactedStatementList, impactedBankDocumentList);
                }
            }
            ttsCommit;

            if (isMatchingSuccess)
            {
                this.reQuery();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>performMatchingProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs manual matching.
    /// </summary>
    public void performMatchingProcess()
    {
        BankReconciliationMatchingMatchProcessor    matchingMatchProcessor;
        BankReconciliationMatchingEntry             matchingEntry;

        BankReconciliationDocumentOpenTmp           documentTmpLocal;
        BankReconciliationStatementOpenTmp          statementTmpLocal;
        BankReconciliationDocumentOpenTmp           documentTmpUpdate;
        BankReconciliationStatementOpenTmp          statementTmpUpdate;
        boolean                                     isValidMatchOperation = true;
        boolean                                     isMatchingSuccess;

        List    impactedBankDocumentList = new List(Types::Int64);
        List    impactedStatementList = new List(Types::Int64);

        matchingMatchProcessor = BankReconciliationMatchingMatchProcessor::construct(reconciliation);

        ttsBegin;
        statementTmpUpdate.linkPhysicalTableInstance(dsOpenStatement.cursor());

        statementTmpLocal = dsOpenStatement.getFirst(1);
        if (statementTmpLocal)
        {
            while (statementTmpLocal)
            {
                matchingEntry = BankReconciliationMatchingEntry::construct(
                    BankReconciliationMatchingEntryType::BankStatement,
                    statementTmpLocal.BankStmtISOReportEntry);
                matchingMatchProcessor.addEntry(matchingEntry);

                impactedStatementList.addEnd(statementTmpLocal.RecId);
                statementTmpLocal = dsOpenStatement.getNext();
            }
        }

        documentTmpUpdate.linkPhysicalTableInstance(dsOpenDocument.cursor());

        documentTmpLocal = dsOpenDocument.getFirst(1);
        if (documentTmpLocal)
        {
            while (documentTmpLocal)
            {
                matchingEntry = BankReconciliationMatchingEntry::construct(
                    BankReconciliationMatchingEntryType::BankDocument,
                    documentTmpLocal.BankDocumentTableView);
                matchingMatchProcessor.addEntry(matchingEntry);

                impactedBankDocumentList.addEnd(documentTmpLocal.RecId);
                documentTmpLocal = dsOpenDocument.getNext();
            }
        }

        // it is invalid operation if single or none statement is selected when no document is selected
        // when no statement is selected, only the matching of two document lines with opposite value is supported
        if ((impactedStatementList.elements() == 0 || impactedStatementList.elements() == 1) 
            && impactedBankDocumentList.elements() == 0)
        {
            isValidMatchOperation = checkFailed("@Bank:BankReconcileNoDataForMatchingError");
        }
        else if (impactedStatementList.elements() == 0 && impactedBankDocumentList.elements() != 2)
        {
            isValidMatchOperation = checkFailed("@Bank:BankReconcileTransactionLineNumberError");
        }

        if (isValidMatchOperation)
        {
            isMatchingSuccess = matchingMatchProcessor.processMatch();
        }

        if (isMatchingSuccess)
        {
            dataManager.refreshMatchStatus(impactedStatementList, impactedBankDocumentList);
        }
        ttsCommit;

        if (isMatchingSuccess)
        {
            this.reQuery();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>performUnmatchingProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs unmatching process.
    /// </summary>
    public void performUnmatchingProcess()
    {
        Common                              entryMatched;
        FieldId                             entryMatchedReferenceField;
        BankReconciliationMatchingEntryType entryMatchedType;

        boolean                             isMarked;
        container                           impactedStatementOpenCon;
        container                           impactedDocumentOpenCon;
        List                                impactedBankDocumentList;
        List                                impactedStatementList;
        FormDataSource                      currentDataSource;

        if (worksheetFormView.parmShowPrimaryMatchGroup())
        {
            currentDataSource   = dsMatchedStatement;
            entryMatchedType    = BankReconciliationMatchingEntryType::BankStatement;
            entryMatchedReferenceField = fieldNum(BankReconciliationStatementOpenTmp, BankStmtISOReportEntry);
        }
        else
        {
            currentDataSource = dsMatchedDocumentSecondary;
            entryMatchedType    = BankReconciliationMatchingEntryType::BankDocument;
            entryMatchedReferenceField = fieldNum(BankReconciliationDocumentOpenTmp, BankDocumentTableView);
        }

        if (currentDataSource.anyMarked())
        {
            entryMatched = currentDataSource.getFirst(1);
            isMarked = true;
        }
        else
        {
            entryMatched = currentDataSource.cursor();
            isMarked = false;
        }

        ttsBegin;
        while (entryMatched)
        {
            [impactedStatementOpenCon, impactedDocumentOpenCon] = this.getImpactedEntriesOfUnmatch(entryMatched);

            BankReconciliationMatchingMatchProcessor::processUnmatch(
                reconciliation.RecId,
                entryMatched.(entryMatchedReferenceField),
                entryMatchedType);

            impactedStatementList = List::create(impactedStatementOpenCon);
            impactedBankDocumentList = List::create(impactedDocumentOpenCon);

            dataManager.refreshMatchStatus(impactedStatementList, impactedBankDocumentList);

            if (!isMarked)
            {
                break;
            }

            entryMatched = currentDataSource.getNext();
        }
        ttsCommit;

        this.reQuery();
    }

]]></Source>
			</Method>
			<Method>
				<Name>performUnmatchingAllProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs unmatching all process.
    /// </summary>
    public void performUnmatchingAllProcess()
    {
        BankStmtISOAccountStatement statement;
        BankStmtISOReportEntry statementLine;
        BankReconciliationMatching matching;
        BankReconciliationMatchingItem matchingItem;

        List statementList = new List(Types::Record);

        while select statement
            exists join statementLine
                where statementLine.BankStmtISOAccountStatement == statement.RecId
            exists join matchingItem
                where matchingItem.BankStmtISOReportEntry == statementLine.RecId
            exists join matching
                where matching.RecId == matchingItem.BankReconciliationMatching
                    && matching.BankReconciliationHeader == reconciliation.RecId
        {
            statementList.addEnd(statement);
        }

        ttsBegin;

        if (!isBankReconWorksheetFilterAndSplitNewFeatureEnabled)
        {
            while select statementLine
                where statementLine.IsNewBankDocument == NoYes::Yes
                exists join matchingItem
                    where matchingItem.BankStmtISOReportEntry == statementLine.RecId
                exists join matching
                    where matching.RecId == matchingItem.BankReconciliationMatching
                        && matching.BankReconciliationHeader == reconciliation.RecId
            {
                BankStmtISOReportEntry::markNewBankDocument(statementLine.RecId, false);
            }
        }

        BankDocumentTable bankDocumentTable;
        bankDocumentTable.skipDatabaseLog(true);
        bankDocumentTable.skipDataMethods(true);
        bankDocumentTable.skipEvents(true);

        update_recordset bankDocumentTable
            setting CorrectionBankCurrencyAmount = 0
            exists join matchingItem
                where matchingItem.BankDocumentTable == bankDocumentTable.RecId
            exists join matching
                where matching.RecId == matchingItem.BankReconciliationMatching
                    && matching.BankReconciliationHeader == reconciliation.RecId;

        BankReconciliationStatementOpenTmp statementMatched;
        statementMatched.linkPhysicalTableInstance(dsMatchedStatement.cursor());
        statementMatched.skipDatabaseLog(true);
        statementMatched.skipDataMethods(true);
        statementMatched.skipEvents(true);

        BankReconciliationDocumentOpenTmp documentMatched;
        documentMatched.linkPhysicalTableInstance(dsMatchedDocument.cursor());
        documentMatched.skipDatabaseLog(true);
        documentMatched.skipDataMethods(true);
        documentMatched.skipEvents(true);

        if (!isBankReconWorksheetFilterAndSplitNewFeatureEnabled)
        {
            update_recordset statementMatched
                setting IsMatched = NoYes::No,
                    IsNewBankDocument = NoYes::No
                exists join matchingItem
                    where matchingItem.BankStmtISOReportEntry == statementMatched.BankStmtISOReportEntry
                exists join matching
                    where matching.RecId == matchingItem.BankReconciliationMatching
                        && matching.BankReconciliationHeader == reconciliation.RecId;
        }
        else
        {
            update_recordset statementMatched
                setting IsMatched = NoYes::No
                where statementMatched.IsNewBankDocument == NoYes::No
                exists join matchingItem
                    where matchingItem.BankStmtISOReportEntry == statementMatched.BankStmtISOReportEntry
                exists join matching
                    where matching.RecId == matchingItem.BankReconciliationMatching
                        && matching.BankReconciliationHeader == reconciliation.RecId;
        }

        update_recordset documentMatched
            setting IsMatched = NoYes::No,
                CorrectionBankCurrencyAmount = 0
            exists join matchingItem
                where matchingItem.BankDocumentTable == documentMatched.BankDocumentTableView
            exists join matching
                where matching.RecId == matchingItem.BankReconciliationMatching
                    && matching.BankReconciliationHeader == reconciliation.RecId;

        if (FeatureStateProvider::isFeatureEnabled(BankTransClearedDateAdvancedBankReconciliationFeature::instance()))
        {
            BankAccountTrans bankAccountTrans;
            bankAccountTrans.skipDatabaseLog(true);
            bankAccountTrans.skipDataMethods(true);
            bankAccountTrans.skipEvents(true);

            update_recordset bankAccountTrans
                setting ClearedDate = dateNull()
                exists join bankDocumentTable
                    where bankDocumentTable.SourceRelationType == bankAccountTrans.SourceTableId
                        && bankDocumentTable.SourceRecId == bankAccountTrans.SourceRecId
                exists join matchingItem
                    where matchingItem.BankDocumentTable == bankDocumentTable.RecId
                exists join matching
                    where matching.RecId == matchingItem.BankReconciliationMatching
                        && matching.BankReconciliationHeader == reconciliation.RecId;

            update_recordset bankAccountTrans
                setting ClearedDate = dateNull()
                exists join bankDocumentTable
                    where bankDocumentTable.SourceRelationType == bankAccountTrans.TableId
                        && bankDocumentTable.SourceRecId == bankAccountTrans.RecId
                exists join matchingItem
                    where matchingItem.BankDocumentTable == bankDocumentTable.RecId
                exists join matching
                    where matching.RecId == matchingItem.BankReconciliationMatching
                        && matching.BankReconciliationHeader == reconciliation.RecId;
        }

        matchingItem.skipDatabaseLog(true);
        matchingItem.skipDataMethods(true);
        matchingItem.skipEvents(true);

        if (!isBankReconWorksheetFilterAndSplitNewFeatureEnabled)
        {
            delete_from matchingItem
                exists join matching
                    where matching.RecId == matchingItem.BankReconciliationMatching
                        && matching.BankReconciliationHeader == reconciliation.RecId;
        }
        else
        {
            delete_from matchingItem
                exists join matching
                    where matching.RecId == matchingItem.BankReconciliationMatching
                        && matching.BankReconciliationHeader == reconciliation.RecId
                        && matching.BankReconciliationMatchingType != BankReconciliationMatchingType::SingleStatement;
        }

        matching.skipDatabaseLog(true);
        matching.skipDataMethods(true);
        matching.skipEvents(true);

        if (!isBankReconWorksheetFilterAndSplitNewFeatureEnabled)
        {
            delete_from matching
                where matching.BankReconciliationHeader == reconciliation.RecId;
        }
        else
        {
            delete_from matching
                where matching.BankReconciliationHeader == reconciliation.RecId
                    && matching.BankReconciliationMatchingType != BankReconciliationMatchingType::SingleStatement;
        }
        ttsCommit;

        ListEnumerator enumerator = statementList.getEnumerator();
        while (enumerator.moveNext())
        {
            statement = enumerator.current();
            statement.refreshMatchingStatus();
        }

        this.reQuery();
    }

]]></Source>
			</Method>
			<Method>
				<Name>performUnmarkAllProcess</Name>
				<Source><![CDATA[
    public void performUnmarkAllProcess()
    {
        BankStmtISOAccountStatement statement;
        BankStmtISOReportEntry statementLine;
        BankReconciliationMatching matching;
        BankReconciliationMatchingItem matchingItem;

        List statementList = new List(Types::Record);

        while select statement
            exists join statementLine
                where statementLine.BankStmtISOAccountStatement == statement.RecId
                    && statementLine.IsNewBankDocument == NoYes::Yes
            exists join matchingItem
                where matchingItem.BankStmtISOReportEntry == statementLine.RecId
            exists join matching
                where matching.RecId == matchingItem.BankReconciliationMatching
                    && matching.BankReconciliationHeader == reconciliation.RecId
        {
            statementList.addEnd(statement);
        }

        ttsbegin;
        while select statementLine
            where statementLine.IsNewBankDocument == NoYes::Yes
            exists join matchingItem
                where matchingItem.BankStmtISOReportEntry == statementLine.RecId
            exists join matching
                where matching.RecId == matchingItem.BankReconciliationMatching
                    && matching.BankReconciliationHeader == reconciliation.RecId
        {
            BankStmtISOReportEntry::markNewBankDocument(statementLine.RecId, false);
        }

        BankReconciliationStatementOpenTmp statementMarked;
        statementMarked.linkPhysicalTableInstance(dsMatchedStatement.cursor());
        statementMarked.skipDatabaseLog(true);
        statementMarked.skipDataMethods(true);
        statementMarked.skipEvents(true);

        update_recordset statementMarked
            setting IsMatched = NoYes::No,
                IsNewBankDocument = NoYes::No
            where statementMarked.IsNewBankDocument == NoYes::Yes
            exists join matchingItem
                where matchingItem.BankStmtISOReportEntry == statementMarked.BankStmtISOReportEntry
            exists join matching
                where matching.RecId == matchingItem.BankReconciliationMatching
                    && matching.BankReconciliationHeader == reconciliation.RecId;

        matchingItem.skipDatabaseLog(true);
        matchingItem.skipDataMethods(true);
        matchingItem.skipEvents(true);

        delete_from matchingItem
            exists join matching
                where matching.RecId == matchingItem.BankReconciliationMatching
                    && matching.BankReconciliationHeader == reconciliation.RecId
                    && matching.BankReconciliationMatchingType == BankReconciliationMatchingType::SingleStatement;

        matching.skipDatabaseLog(true);
        matching.skipDataMethods(true);
        matching.skipEvents(true);

        delete_from matching
            where matching.BankReconciliationHeader == reconciliation.RecId
                && matching.BankReconciliationMatchingType == BankReconciliationMatchingType::SingleStatement;
        ttscommit;

        ListEnumerator enumerator = statementList.getEnumerator();
        while (enumerator.moveNext())
        {
            statement = enumerator.current();
            statement.refreshMatchingStatus();
        }

        this.reQuery();
    }

]]></Source>
			</Method>
			<Method>
				<Name>performUnmarkProcess</Name>
				<Source><![CDATA[
   public void performUnmarkProcess()
    {
        boolean isMarked = dsNewStatement.anyMarked();
        BankReconciliationStatementOpenTmp entryUnmarked = isMarked ? dsNewStatement.getFirst(1) : dsNewStatement.cursor();

        ttsbegin;
        while (entryUnmarked)
        {
            BankBatchProcessingTracking batchProcessingTracking = isBankStatementPostInBatchFeatureEnabled ? this.findBatchJobProcessingOnStatementLine(entryUnmarked) : null;
            if (!batchProcessingTracking)
            {
                container impactedStatementOpenCon;
                container impactedDocumentOpenCon;

                [impactedStatementOpenCon, impactedDocumentOpenCon] = this.getImpactedEntriesOfUnmatch(entryUnmarked);

                BankReconciliationMatchingMatchProcessor::processUnmatch(
                    reconciliation.RecId,
                    entryUnmarked.BankStmtISOReportEntry,
                    BankReconciliationMatchingEntryType::BankStatement);

                List impactedStatementList = List::create(impactedStatementOpenCon);
                List impactedBankDocumentList = List::create(impactedDocumentOpenCon);

                dataManager.refreshMatchStatus(impactedStatementList, impactedBankDocumentList);

                if (!isMarked)
                {
                    break;
                }
            }
            else
            {
                warning(strFmt(
                    "@Bank:BankBatchProcessingTrackingOnRecordWarning",
                    batchProcessingTracking.BatchJob,
                    BankStatementPostController::concatenateBatchJobCaption(batchProcessingTracking.BankReconciliationOperationType),
                    strFmt("@Bank:SpaceConcatenateString", entryUnmarked.BookingDate, entryUnmarked.BankCurrencyAmount)));
            }
            entryUnmarked = dsNewStatement.getNext();
        }
        ttscommit;

        this.reQuery();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reconciliationInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays reconciliation information.
    /// </summary>
    /// <returns>
    /// The reconciliation information.
    /// </returns>
    public Caption reconciliationInfo()
    {
        return reconciliation.dispReconciliationInfo();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reLoadData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reloads the reconciliation data and refresh.
    /// </summary>
    public void reLoadData()
    {
        this.loadData();

        dataManager = BankReconciliationDataManager::construct(
            reconciliation,
            dsOpenStatement.cursor(),
            dsOpenDocument.cursor());

        this.reQuery();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Re-query all the data sources.
    /// </summary>
    public void reQuery()
    {
        dsOpenDocument.research(true);
        dsOpenStatement.research(true);
        dsMatchedDocument.research(true);
        dsMatchedStatement.research(true);
        dsMatchedDocumentSecondary.research(true);
        dsMatchedStatementSecondary.research(true);

        if (isBankReconWorksheetFilterAndSplitNewFeatureEnabled)
        {
            dsNewStatement.research(true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDocumentTmpData</Name>
				<Source><![CDATA[
    private void setDocumentTmpData(BankReconciliationDocumentOpenTmp _documentTmp)
    {
        dsOpenDocument.cursor().linkPhysicalTableInstance(_documentTmp);
        dsMatchedDocument.cursor().linkPhysicalTableInstance(_documentTmp);
        dsMatchedDocumentSecondary.cursor().linkPhysicalTableInstance(_documentTmp);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setStatementTmpData</Name>
				<Source><![CDATA[
    private void setStatementTmpData(BankReconciliationStatementOpenTmp _statementTmp)
    {
        dsOpenStatement.cursor().linkPhysicalTableInstance(_statementTmp);
        dsMatchedStatement.cursor().linkPhysicalTableInstance(_statementTmp);
        dsMatchedStatementSecondary.cursor().linkPhysicalTableInstance(_statementTmp);

        if (isBankReconWorksheetFilterAndSplitNewFeatureEnabled)
        {
            dsNewStatement.cursor().linkPhysicalTableInstance(_statementTmp);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>tableFieldIdReconciliationId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the field Id for reconciliation Id.
    /// </summary>
    /// <returns>
    ///     Field Id for reconciliation Id.
    /// </returns>
    private FieldId tableFieldIdReconciliationId()
    {
        return fieldNum(BankReconciliationHeader, ReconciliationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unmarkAllOpenDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unmark existing marked document after statement cursor get changed.
    /// </summary>
    public void unmarkAllOpenDocument()
    {
        BankReconciliationDocumentOpenTmp   documentTmpLocal;

        documentTmpLocal = dsOpenDocument.getFirst(true);
        while (documentTmpLocal)
        {
            dsOpenDocument.markRecord(documentTmpLocal, false);
            documentTmpLocal = dsOpenDocument.getNext();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates an instance of <c>BankReconciliationWorksheetViewModel</c> class.
    /// </summary>
    /// <returns>
    ///     The <c>BankReconciliationWorksheetViewModel</c> instance.
    /// </returns>
    protected static BankReconciliationWorksheetViewModel construct()
    {
        return new BankReconciliationWorksheetViewModel();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromWorksheetView</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates an instance of <c>BankReconciliationHeaderViewModel</c> class.
    /// </summary>
    /// <param name="_worksheetFormView">
    ///     The instance of <c>BankReconciliationWorksheetFormView</c> class.
    /// </param>
    /// <returns>
    ///     The instance of <c>BankReconciliationHeaderViewModel</c> class.
    /// </returns>
    public static BankReconciliationWorksheetViewModel newFromWorksheetView(BankReconciliationWorksheetFormView _worksheetFormView)
    {
        BankReconciliationWorksheetViewModel  worksheetViewModel;

        Debug::assert(_worksheetFormView != null);

        worksheetViewModel = BankReconciliationWorksheetViewModel::construct();
        worksheetViewModel.parmWorksheetFormView(_worksheetFormView);

        worksheetViewModel.initialize();

        Debug::assert(worksheetViewModel != null);

        return worksheetViewModel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMarkedOrCurrentNewStatement</Name>
				<Source><![CDATA[
    private BankReconciliationStatementOpenTmp getMarkedOrCurrentNewStatement()
    {
        boolean isMarked = dsNewStatement.anyMarked();
        return isMarked ? dsNewStatement.getFirst(1) : dsNewStatement.cursor();
    }

]]></Source>
			</Method>
			<Method>
				<Name>performPostPerLineProcess</Name>
				<Source><![CDATA[
    internal void performPostPerLineProcess()
    {
        Map statementHeaderLinesMap = this.generatePostingStatementLinesMap();
        if (isBankStatementPostInBatchFeatureEnabled)
        {
            if (BankStatementPost::validateBankStatementLinesBeforePost(statementHeaderLinesMap))
            {
                BankStatementPost::postBankStatementLines(statementHeaderLinesMap);
            }
        }
        else
        {
            BankStatementPost::postBankStatementLines(statementHeaderLinesMap);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>performPostPerLineInBatchProcess</Name>
				<Source><![CDATA[
    internal void performPostPerLineInBatchProcess()
    {
        Map statementHeaderLinesMap = this.generatePostingStatementLinesMap();
        BankStatementPost::postBankStatementLinesInBatch(statementHeaderLinesMap);
    }

]]></Source>
			</Method>
			<Method>
				<Name>generatePostingStatementLinesMap</Name>
				<Source><![CDATA[
    private Map generatePostingStatementLinesMap()
    {
        BankReconciliationStatementOpenTmp statementNew = this.getMarkedOrCurrentNewStatement();
        Map statementHeaderLinesMap = new Map(Types::Int64, Types::Class);

        while (statementNew)
        {
            RecId currentHeaderRecId = statementNew.BankStmtISOAccountStatement;

            if (!statementNew.Posted)
            {
                if (statementHeaderLinesMap.exists(currentHeaderRecId))
                {
                    List statementLineRecIds = statementHeaderLinesMap.lookup(currentHeaderRecId);
                    statementLineRecIds.addEnd(statementNew.BankStmtISOReportEntry);
                }
                else
                {
                    List statementLineRecIds = new List(Types::Int64);
                    statementLineRecIds.addEnd(statementNew.BankStmtISOReportEntry);
                    statementHeaderLinesMap.insert(currentHeaderRecId, statementLineRecIds);
                }
            }

            statementNew = dsNewStatement.getNext();
        }

        return statementHeaderLinesMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSelectNewStatement</Name>
				<Source><![CDATA[
    internal BankStmtISOReportEntry getSelectNewStatement()
    {
        BankReconciliationStatementOpenTmp statementNewSelect = this.getMarkedOrCurrentNewStatement();
        return BankStmtISOReportEntry::find(statementNewSelect.BankStmtISOReportEntry);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNewStatementSelectPosted</Name>
				<Source><![CDATA[
    internal boolean isNewStatementSelectPosted()
    {
        BankReconciliationStatementOpenTmp statementNewSelect = this.getMarkedOrCurrentNewStatement();
        return statementNewSelect.Posted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNewStatementAllSelectUnposted</Name>
				<Source><![CDATA[
    internal boolean isNewStatementAllSelectUnposted()
    {
        BankReconciliationStatementOpenTmp statementNewSelect = this.getMarkedOrCurrentNewStatement();
        boolean res = statementNewSelect.Voucher == '';

        if (dsNewStatement.anyMarked())
        {
            while (statementNewSelect)
            {
                if (statementNewSelect.Voucher)
                {
                    return false;
                }

                statementNewSelect = dsNewStatement.getNext();
            }
        }

        return res;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAllNewStatementUnposted</Name>
				<Source><![CDATA[
    internal boolean isAllNewStatementUnposted()
    {
        BankReconciliationStatementOpenTmp statementNewSelect = dsNewStatement.getFirst();

        while (statementNewSelect)
        {
            if (statementNewSelect.Voucher)
            {
                return false;
            }

            statementNewSelect = dsNewStatement.getNext();
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNewStatementAllSelectUnpostedAndNotInBatchProcessing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the selected statement lines unposted and not in batch processing.
    /// </summary>
    /// <returns>true if the selected statement lines unposted and not in batch processing; otherwise, false.</returns>
    internal boolean isNewStatementAllSelectUnpostedAndNotInBatchProcessing()
    {
        BankReconciliationStatementOpenTmp statementNewSelect = this.getMarkedOrCurrentNewStatement();
        boolean res = statementNewSelect.Voucher == '' && !this.findBatchJobProcessingOnStatementLine(statementNewSelect).RecId;

        if (res && dsNewStatement.anyMarked())
        {
            statementNewSelect = dsNewStatement.getNext();

            while (statementNewSelect)
            {
                if (statementNewSelect.Voucher || this.findBatchJobProcessingOnStatementLine(statementNewSelect).RecId)
                {
                    res = false;
                    break;
                }

                statementNewSelect = dsNewStatement.getNext();
            }
        }

        return res;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAllNewStatementUnpostedAndNotInBatchProcessing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether all statement lines unposted and not in batch processing.
    /// </summary>
    /// <returns>true if all statement lines unposted and not in batch processing; otherwise, false.</returns>
    internal boolean isAllNewStatementUnpostedAndNotInBatchProcessing()
    {
        BankReconciliationStatementOpenTmp statementNewSelect = dsNewStatement.getFirst();
        boolean res = true;

        while (statementNewSelect)
        {
            if (statementNewSelect.Voucher || this.findBatchJobProcessingOnStatementLine(statementNewSelect).RecId)
            {
                res = false;
                break;
            }

            statementNewSelect = dsNewStatement.getNext();
        }

        return res;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBatchJobProcessingOnStatementLine</Name>
				<Source><![CDATA[
    private BankBatchProcessingTracking findBatchJobProcessingOnStatementLine(BankReconciliationStatementOpenTmp _statementLine)
    {
        BankBatchProcessingTracking batchProcessingTracking = BankBatchProcessingTracking::findAnyTypeFirstProcessingBySource(tableNum(BankStmtISOReportEntry), _statementLine.BankStmtISOReportEntry);
        if (!batchProcessingTracking.RecId && _statementLine.IsNewBankDocument)
        {
            batchProcessingTracking = BankBatchProcessingTracking::findAnyTypeFirstProcessingBySource(tableNum(BankStmtISOAccountStatement), _statementLine.BankStmtISOAccountStatement);
        }
        return batchProcessingTracking;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>