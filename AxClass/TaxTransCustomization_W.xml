<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxTransCustomization_W</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Class that contains country specific extensions to the functionality of the <c>TaxTrans</c> table.
/// </summary>
class TaxTransCustomization_W
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>createTaxTransExcludeFromInvoiceFromTaxTrans</Name>
				<Source><![CDATA[
    // <GEEU>
    public static void createTaxTransExcludeFromInvoiceFromTaxTrans(TaxTrans _taxTrans)
    {
        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoHU, #isoLT]))
        {
            if (TaxTable::find(_taxTrans.TaxCode).ExcludeFromInvoice)
            {
                TaxTransExcludeFromInvoice::createForTaxTrans(_taxTrans.RecId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDataSource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds one of the <c>TaxTrans</c> table extensions as a child data source.
    /// </summary>
    /// <param name="_parentDataSource">
    /// The data source for the <c>TaxTrans</c> table.
    /// </param>
    /// <param name="_tableId">
    /// The child table identifier.
    /// </param>
    /// <param name="_joinMode">
    /// The join mode for the new data source; optional.
    /// </param>
    /// <returns>
    /// The added data source.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// The parent data source is null.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// The parent data source's table is not <c>TaxTrans</c>.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// The child datasorce's table is not among <c>TaxTrans_W</c>, <c>TaxTrans_RU</c> and <c>TaxTrans_IT</c>.
    /// </exception>
    public static QueryBuildDataSource addDataSource(
        QueryBuildDataSource _parentDataSource, 
        TableId _tableId, 
        JoinMode _joinMode = JoinMode::InnerJoin)
    {
        QueryBuildDataSource ds;

        if (_parentDataSource == null || _parentDataSource.table() != tableNum(TaxTrans))
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        switch (_tableId)
        {
            case tableNum(TaxTrans_W):
                ds = _parentDataSource.addDataSource(tableNum(TaxTrans_W));
                ds.addLink(fieldNum(TaxTrans, RecId), fieldNum(TaxTrans_W, TaxTrans));
                break;

            case tableNum(TaxTrans_RU):
                ds = _parentDataSource.addDataSource(tableNum(TaxTrans_RU));
                ds.addLink(fieldNum(TaxTrans, RecId), fieldNum(TaxTrans_RU, TaxTrans));
                break;

            case tableNum(TaxTrans_IT):
                ds = _parentDataSource.addDataSource(tableNum(TaxTrans_IT));
                ds.addLink(fieldNum(TaxTrans, RecId), fieldNum(TaxTrans_IT, TaxTrans));
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        ds.fetchMode(QueryFetchMode::One2One);
        ds.joinMode(_joinMode);

        return ds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExcludeFromInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates if the tax trans record is not included in the invoice.
    /// </summary>
    /// <returns>
    /// true if the tax trans record is not included in the invoice; otherwise, false.
    /// </returns>
    public static boolean parmExcludeFromInvoice(TaxTrans _taxTrans)
    {
        #ISOCountryRegionCodes
        boolean excludeFromInvoice;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoHU, #isoLT]))
        {
            excludeFromInvoice = TaxTransExcludeFromInvoice::existForTaxTrans(_taxTrans.RecId);
        }

        return excludeFromInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxBaseAmountRegulatedMST_BR</Name>
				<Source><![CDATA[
    // </GEEU>

    // <GBR>
    /// <summary>
    /// Returns the regulated tax base amount converted to the company s currency code
    /// </summary>
    /// <param name ="_taxTrans">The tax trans record to get the tax base amount regulated MST from.</param>
    /// <returns>
    /// If the tax trans currency code is the same of the company s currency code, then, the raw value of SourceBaseAmountCurRegulated will be returned.
    /// Otherwise, the SourceBaseAmountCurRegulated converted value will be returned.
    /// </returns>
    public static TaxAmountCur getTaxBaseAmountRegulatedMST_BR(TaxTrans _taxTrans)
    {
        if (_taxTrans.taxBaseAmountHasBeenAdjusted_BR())
        {
            if (_taxTrans.SourceCurrencyCode != CompanyInfoHelper::standardCurrency())
            {
                return CurrencyExchangeHelper::mstAmount(_taxTrans.SourceBaseAmountCurRegulated, _taxTrans.SourceCurrencyCode, _taxTrans.TransDate);
            }
            else
            {
                return _taxTrans.SourceBaseAmountCurRegulated;
            }
        }
        else
        {
            return _taxTrans.TaxBaseAmount;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRefundableVATFromTaxTrans_HU</Name>
				<Source><![CDATA[
    // </GBR>

    // <GHU>
    public static void createRefundableVATFromTaxTrans_HU(TaxTrans _taxTrans)
    {
        #ISOCountryRegionCodes
        TaxTransRefundableVAT   taxTransRefundableVAT;
        VendTrans vendTrans;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoHU]))
        {
            taxTransRefundableVAT.clear();

            if ((_taxTrans.TaxDirection == TaxDirection::IncomingTax ||
                _taxTrans.TaxDirection == TaxDirection::UseTax)     &&
                (_taxTrans.Source       == TaxModuleType::Purch      ||
                _taxTrans.Source       == TaxModuleType::PurchInvoice))
            {
                taxTransRefundableVAT.SettleDate = dateNull();
            }
            else
            {
                if ((_taxTrans.TaxDirection == TaxDirection::IncomingTax ||
                     _taxTrans.TaxDirection == TaxDirection::UseTax )    &&
                    _taxTrans.Source == TaxModuleType::Voucher)
                {
                    vendTrans = VendTrans::findVoucherDate(_taxTrans.Voucher, _taxTrans.TransDate);
                }

                if (vendTrans)
                {
                    taxTransRefundableVAT.SettleDate = vendTrans.Closed;
                }
                else
                {
                    taxTransRefundableVAT.SettleDate = _taxTrans.TransDate;
                }
            }

            taxTransRefundableVAT.TaxTrans = _taxTrans.RecId;
            taxTransRefundableVAT.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createHungaryDeferredTransactions_HU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the two additional transactions needed for Hungarian Deferred tax.
    /// The transaction already existing:
    /// 1) Insertion into Hungarian Tax Account on the TransDate
    /// The two transactions needed:
    /// 1) Reversal from the Hungarian Tax Account on VAT due date
    /// 2) Insertion into Sales Tax Account on VAT due date
    /// </summary>
    /// <param name ="_taxTrans">The tax trans record to use to create the hungary deferred transactions..</param>
    /// <param name="_ledgerVoucherObject">
    /// The LedgerVoucherObject to which the two transactions should be added
    /// </param>
    /// <param name="_ledgerAccount">
    /// The default sales tax account
    /// </param>
    /// <param name="_offsetAccount">
    /// The Hungarian Deferred tax account
    /// </param>
    public static void createHungaryDeferredTransactions_HU(TaxTrans _taxTrans, LedgerVoucherObject _ledgerVoucherObject, LedgerDimensionAccount _ledgerAccount, LedgerDimensionAccount _offsetAccount)
    {
        LedgerVoucherTransObject    voucherTransObjectReversal;
        LedgerVoucherTransObject    voucherTransObjectCorrection;
        CurrencyExchangeHelper      currExchangeHelper;

        currExchangeHelper = CurrencyExchangeHelper::newLedger(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));
        currExchangeHelper.parmExchangeRate1(_taxTrans.TaxBaseAmount * 100/_taxTrans.SourceBaseAmountCur);
        voucherTransObjectReversal = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerVoucherObject,
                                                                                    LedgerPostingType::Tax,
                                                                                    _offsetAccount,
                                                                                    _taxTrans.SourceCurrencyCode,
                                                                                    -_taxTrans.SourceTaxAmountCur + _taxTrans.TaxInCostPrice,
                                                                                    currExchangeHelper);

        // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
        if (_taxTrans)
        {
            // TaxTrans will not exist in the case where a transaction is only being validated,
            // and in that case the tax trans relationship should not be created
            voucherTransObjectReversal.addTaxTransRelationship(_taxTrans.RecId, TaxTransRelationshipType::Tax);
        }
        _ledgerVoucherObject.addTrans(voucherTransObjectReversal);

        voucherTransObjectCorrection = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerVoucherObject,
                                                                                    LedgerPostingType::Tax,
                                                                                     _ledgerAccount,
                                                                                    _taxTrans.SourceCurrencyCode,
                                                                                    _taxTrans.SourceTaxAmountCur - _taxTrans.TaxInCostPrice,
                                                                                    currExchangeHelper);

        // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
        if (_taxTrans)
        {
            // TaxTrans will not exist in the case where a transaction is only being validated,
            // and in that case the tax trans relationship should not be created
            voucherTransObjectCorrection.addTaxTransRelationship(_taxTrans.RecId, TaxTransRelationshipType::Tax);
        }

        _ledgerVoucherObject.addTrans(voucherTransObjectCorrection);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postponeLedgerTrans_HU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the appropriate variables and calls the method to create the two additional transactions
    /// for HungarianDeferredTax
    /// Information on the two transactions is provided in the comments for createAddTrans
    /// </summary>
    /// <param name ="_taxTrans">The tax trans record to use to create the hungary deffered transactions.</param>
    /// <param name="_ledgerVoucherObject">
    /// The LedgerVoucherObject to which the two transactions should be added
    /// </param>
    /// <param name="_ledgerDimension">
    /// The ledgerDimension stored on the initial transaction as entered by the user
    /// </param>
    public static void postponeLedgerTrans_HU(TaxTrans _taxTrans, LedgerVoucherObject _ledgerVoucherObject, DimensionDefault _ledgerDimension)
    {
        TaxLedgerAccountGroup           taxLedgerAccountGroup;
        LedgerDimensionDefaultAccount   ledgerAccount;
        LedgerDimensionDefaultAccount   offsetAccount;

        taxLedgerAccountGroup = TaxLedgerAccountGroup::find(TaxTable::findAccountGroup(_taxTrans.TaxCode));
        ledgerAccount = taxLedgerAccountGroup.taxLedgerDimension(_taxTrans.TaxDirection);
        offsetAccount = taxLedgerAccountGroup.taxLedgerDimension_HU(_taxTrans.TaxDirection);

        _taxTrans.createHungaryDeferredTransactions(_ledgerVoucherObject,
                            LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerAccount, _ledgerDimension),
                            LedgerDimensionFacade::serviceCreateLedgerDimension(offsetAccount, _ledgerDimension));

        if (_taxTrans.TaxDirection == TaxDirection::UseTax)
        {
            ledgerAccount = taxLedgerAccountGroup.taxLedgerDimension_HU(TaxDirection::OutgoingTax);
            offsetAccount = TaxLedgerAccountGroup::offsetUseTaxLedgerDimension(_taxTrans.TaxCode);

            _taxTrans.createHungaryDeferredTransactions(_ledgerVoucherObject,
                                LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerAccount, _ledgerDimension),
                                LedgerDimensionFacade::serviceCreateLedgerDimension(offsetAccount, _ledgerDimension));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayCustomsAssessableValue_IN</Name>
				<Source><![CDATA[
    // </GHU>

    /// <summary>
    /// Display the customs assessable value.
    /// </summary>
    /// <param name ="_taxTrans">The tax trans record to display the customs assessable value for.</param>
    /// <returns>
    /// The customs assessable amount.
    /// </returns>
    public static CustomsAmount_IN displayCustomsAssessableValue_IN(TaxTrans _taxTrans)
    {
        CustomsAmount_IN amount;
        TableId          sourceTableId;

        if (TaxTable::find(_taxTrans.TaxCode).TaxType_IN == TaxType_IN::Customs)
        {
            if (_taxTrans.SourceTableId)
            {
                sourceTableId = _taxTrans.SourceTableId;
            }
            else
            {
                switch (_taxTrans.Source)
                {
                    case TaxModuleType::Purch,
                         TaxModuleType::PurchInvoice :
                         sourceTableId = tableNum(PurchLine);
                        break;
                    case TaxModuleType::Sales,
                         TaxModuleType::SalesInvoice,
                         TaxModuleType::CustCollectionLetter,
                         TaxModuleType::CustInterestNote,
                         TaxModuleType::FreeTxtInvoice :
                         sourceTableId = tableNum(SalesLine);
                        break;
                    case TaxModuleType::Voucher:
                        sourceTableId = tableNum(LedgerJournalTrans);
                        break;
                }
            }

            amount =  CurrencyHelper_IN::customsMSTAmount_IN(_taxTrans.SourceBaseAmountCur,
                                                    _taxTrans.SourceCurrencyCode,
                                                    CurrencyHelper_IN::sourceTable2CustomsDirection_New_IN(sourceTableId, _taxTrans.SourceRecId),
                                                    _taxTrans.TransDate);
        }
        return amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTaxReporting_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to insert info into the <c>TaxReportPeriod_IN</c> table from given parameters.
    /// </summary>
    /// <param name ="_taxTrans">The tax trans record to insert the tax report period for..</param>
    /// <param name="_periodStartDate">
    /// The period start date is used to find record.
    /// </param>
    /// <param name="_taxRegistrationNumberTableRecId">
    /// The record id of tax registration number is used to find record.
    /// </param>
    public static void insertTaxReporting_IN(TaxTrans   _taxTrans,
                                            TransDate   _periodStartDate,
                                            RefRecId    _taxRegistrationNumberTableRecId)
    {
        TaxReportPeriod_IN taxReportPeriod;

        if (!_taxTrans.TaxPeriod)
        {
            _taxTrans.TaxPeriod = TaxTable::taxPeriod(_taxTrans.TaxCode);
        }

        if (_taxTrans.TaxOrigin != TaxOrigin::TaxReporting)
            _taxTrans.TaxRepCounter = TaxReportPeriod_IN::version(_taxTrans.TaxPeriod,
                                                             _taxRegistrationNumberTableRecId,
                                                             _taxTrans.TransDate);

        if (!TaxReportPeriod_IN::findByTaxPeriod(_taxTrans.TaxPeriod,
                                                _taxRegistrationNumberTableRecId,
                                                _periodStartDate))
        {
            ttsbegin;
            taxReportPeriod.TaxPeriod                   = _taxTrans.TaxPeriod;
            taxReportPeriod.TaxRegistrationNumberTable  = _taxRegistrationNumberTableRecId;
            taxReportPeriod.FromDate                    = TaxReportPeriod::find(_taxTrans.TaxPeriod,_periodStartDate).FromDate;
            taxReportPeriod.ToDate                      = TaxReportPeriod::find(_taxTrans.TaxPeriod,_periodStartDate).ToDate;
            taxReportPeriod.Availed                     = NoYes::Yes;
            taxReportPeriod.insert();
            ttscommit;
        }

        _taxTrans.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReverseChargeApplicable_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns true if reverse charge is applicable.
    /// </summary>
    /// <param name ="_taxTrans">The tax trans record to check to see if reverse charge is applicable.</param>
    /// <returns>
    /// Returns true if reverse charge is applicable.
    /// </returns>
    public static boolean isReverseChargeApplicable_IN(TaxTrans _taxTrans)
    {
        boolean  ret;
        TaxTable taxTableRev = TaxTable::find(_taxTrans.TaxCode);
        TaxItemGroupHeading taxItemGroupHeadingRev = TaxItemGroupHeading::find(_taxTrans.TaxItemGroup);

        if (taxTableRev.TaxType_IN == TaxType_IN::ServiceTax
            && taxItemGroupHeadingRev.ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis
            && taxItemGroupHeadingRev.ReverseChargePercentage_IN > 0)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxTransByForInterim_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method finds populates the TaxTrans with the offset entries, to be generated during service tax reverse charge posting.
    /// </summary>
    /// <param name="_taxTransDestination">
    /// Tax trans buffer to update.
    /// </param>
    /// <param name="_taxTransSource">
    /// Tax trans buffer passed.
    /// </param>
    /// <param name="_isLOIAllowed">
    /// Flag to check if load on inventory is allowed or not.
    /// </param>
    /// <param name="_sign">
    /// The sign of the Tax entry
    /// </param>
    /// <remarks>
    /// // Values are found by subtracting split entry from total tax, to avoid rounding isuue.
    /// </remarks>
    public static void updateTaxTransByForInterim_IN(
        TaxTrans _taxTransDestination,
        TaxTrans _taxTransSource,
        boolean  _isLOIAllowed,
        Sign     _sign = 1)
    {
        _taxTransDestination.TaxAmount               = _sign * (_taxTransDestination.TaxAmount - _taxTransSource.TaxAmount);
        _taxTransDestination.TaxAmountCur            = _sign * (_taxTransDestination.TaxAmountCur - _taxTransSource.TaxAmountCur);
        _taxTransDestination.SourceTaxAmountCur      = _sign * (_taxTransDestination.SourceTaxAmountCur - _taxTransSource.SourceTaxAmountCur);
        _taxTransDestination.SourceRegulateAmountCur = _sign * (_taxTransDestination.SourceRegulateAmountCur - _taxTransSource.SourceRegulateAmountCur);
        if (_isLOIAllowed)
        {
            _taxTransDestination.TaxInCostPrice          = _sign * (_taxTransDestination.TaxInCostPrice - _taxTransSource.TaxInCostPrice);
            _taxTransDestination.TaxInCostPriceCur       = _sign * (_taxTransDestination.TaxInCostPriceCur - _taxTransSource.TaxInCostPriceCur);
            _taxTransDestination.TaxInCostPriceMST       = _sign * (_taxTransDestination.TaxInCostPriceMST - _taxTransSource.TaxInCostPriceMST);
            _taxTransDestination.TaxInCostPriceRegulated = _sign * (_taxTransDestination.TaxInCostPriceRegulated - _taxTransSource.TaxInCostPriceRegulated);
        }
        else
        {
            _taxTransDestination.TaxInCostPrice          = 0;
            _taxTransDestination.TaxInCostPriceCur       = 0;
            _taxTransDestination.TaxInCostPriceMST       = 0;
            _taxTransDestination.TaxInCostPriceRegulated = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxTransByReverseChargePercent_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method finds populates the TaxTrans with the offset entries, to be generated during service tax reverse charge feature.
    /// </summary>
    /// <param name ="_taxTrans">The tax trans record to update by reverse charge percent.</param>
    /// <param name="_reverseChargePercentage">
    /// The reverse charge percentage flowing from ItemSalestaxGroup.
    /// </param>
    /// <param name="_sign">
    /// The sign of the Tax entry
    /// </param>
    /// <remarks>
    /// Method exclusively for service tax reverse charge feature.
    /// </remarks>
    public static void updateTaxTransByReverseChargePercent_IN(
        TaxTrans _taxTrans,
        Percent _reverseChargePercentage,
        Sign _sign = 1)
    {
        _taxTrans.TaxAmount               = _sign * CurrencyExchangeHelper::amount(_taxTrans.TaxAmount                  - CurrencyExchangeHelper::amount(_taxTrans.TaxAmount                * (100 - _reverseChargePercentage) / 100));
        _taxTrans.TaxAmountCur            = _sign * CurrencyExchangeHelper::amount(_taxTrans.TaxAmountCur               - CurrencyExchangeHelper::amount(_taxTrans.TaxAmountCur             * (100 - _reverseChargePercentage) / 100));
        _taxTrans.SourceTaxAmountCur      = _sign * CurrencyExchangeHelper::amount(_taxTrans.SourceTaxAmountCur         - CurrencyExchangeHelper::amount(_taxTrans.SourceTaxAmountCur       * (100 - _reverseChargePercentage) / 100));
        _taxTrans.SourceRegulateAmountCur = _sign * CurrencyExchangeHelper::amount(_taxTrans.SourceRegulateAmountCur    - CurrencyExchangeHelper::amount(_taxTrans.SourceRegulateAmountCur  * (100 - _reverseChargePercentage) / 100));
        _taxTrans.TaxInCostPrice          = _sign * CurrencyExchangeHelper::amount(_taxTrans.TaxInCostPrice             - CurrencyExchangeHelper::amount(_taxTrans.TaxInCostPrice           * (100 - _reverseChargePercentage) / 100));
        _taxTrans.TaxInCostPriceCur       = _sign * CurrencyExchangeHelper::amount(_taxTrans.TaxInCostPriceCur          - CurrencyExchangeHelper::amount(_taxTrans.TaxInCostPriceCur        * (100 - _reverseChargePercentage) / 100));
        _taxTrans.TaxInCostPriceMST       = _sign * CurrencyExchangeHelper::amount(_taxTrans.TaxInCostPriceMST          - CurrencyExchangeHelper::amount(_taxTrans.TaxInCostPriceMST        * (100 - _reverseChargePercentage) / 100));
        _taxTrans.TaxInCostPriceRegulated = _sign * CurrencyExchangeHelper::amount(_taxTrans.TaxInCostPriceRegulated    - CurrencyExchangeHelper::amount(_taxTrans.TaxInCostPriceRegulated  * (100 - _reverseChargePercentage) / 100));
    }

]]></Source>
			</Method>
			<Method>
				<Name>eximTaxAmounts_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the EXIM tax amounts for given parameter.
    /// </summary>
    /// <param name="_query">
    /// A buffer of query.
    /// </param>
    /// <param name="_changeDisplaySign">
    /// This param is used to check whether change dispaly sign; optional.
    /// </param>
    /// <returns>
    /// Returns a container with the expected EXIM tax amounts.
    /// </returns>
    public static container eximTaxAmounts_IN(
        Query   _query,
        boolean _changeDisplaySign = false)
    {
        TaxTrans             taxTrans;
        EximTaxTrans_IN      eximTaxTrans;
        int                  sign;
        Query                taxQuery;
        QueryRun             taxQueryRun;
        QueryBuildDataSource qB;
        QueryBuildDataSource qbEximTaxTrans;
        TaxAmount            eximTaxAmount;
        TaxAmount            eximBalanceTaxAmount;
        TaxAmount            eximCorrectedAmount;
        TaxAmount            eximBalanceTaxCorrectedAmount;
        boolean              isTaxRegulated;

        taxQuery = new Query();
        SysQuery::mergeRanges(taxQuery, _query);
        qB = taxQuery.dataSourceTable(tableNum(TaxTrans));

        qB.addSortField(fieldNum(TaxTrans, CurrencyCode));
        qB.addSortField(fieldNum(TaxTrans, TaxDirection));

        qbEximTaxTrans = qB.addDataSource(tableNum(EximTaxTrans_IN));
        qbEximTaxTrans.addLink(fieldNum(TaxTrans, RecId), fieldNum(EximTaxTrans_IN, TaxTransRecId));

        taxQueryRun = new QueryRun(taxQuery);

        while (taxQueryRun.next())
        {
            taxTrans     = taxQueryRun.get(tableNum(TaxTrans));
            eximTaxTrans = taxQueryRun.get(tableNum(EximTaxTrans_IN));

            sign = _changeDisplaySign ? Tax::changeDisplaySign(taxTrans.TaxDirection) : 1;

            eximTaxAmount                 += eximTaxTrans.TaxAmount * sign;
            eximBalanceTaxAmount          += eximTaxTrans.BalanceTaxAmount * sign;
            eximCorrectedAmount           += (eximTaxTrans.TaxCorrectedAmount ? eximTaxTrans.TaxCorrectedAmount : eximTaxTrans.TaxAmount) * sign ;
            eximBalanceTaxCorrectedAmount += (eximTaxTrans.BalanceTaxCorrectedAmount ? eximTaxTrans.BalanceTaxCorrectedAmount : eximTaxTrans.BalanceTaxAmount) * sign;

            if (eximTaxTrans.TaxCorrectedAmount || eximTaxTrans.BalanceTaxCorrectedAmount)
            {
                isTaxRegulated = true;
            }
        }

        eximCorrectedAmount = isTaxRegulated == true ? eximCorrectedAmount : 0;
        eximBalanceTaxCorrectedAmount = isTaxRegulated == true ? eximBalanceTaxCorrectedAmount : 0;

        return [eximTaxAmount, eximBalanceTaxAmount, eximCorrectedAmount, eximBalanceTaxCorrectedAmount];
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByGeneralJournalAccountEntry_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>TaxTrans</c> record.
    /// </summary>
    /// <param name="_generalJournalAccountEntryRecId">
    /// The record ID of a <c>GeneralJournalAccountEntry</c> record.
    /// </param>
    /// <param name="_forupdate">
    /// If true, then read the record for updating.
    /// </param>
    /// <returns>
    /// A <c>TaxTrans</c> record.
    /// </returns>
    public static TaxTrans findByGeneralJournalAccountEntry_IN(
        GeneralJournalAccountEntryRecId     _generalJournalAccountEntryRecId,
        boolean                             _forupdate = false)
    {
        TaxTrans                            taxTrans;
        TaxTransGeneralJournalAccountEntry  taxTransGeneralJournalAccountEntry;

        if (_generalJournalAccountEntryRecId)
        {
            taxTrans.selectForUpdate(_forupdate);

            select firstonly taxTrans
                exists join TaxTrans from taxTransGeneralJournalAccountEntry
                    where taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry == _generalJournalAccountEntryRecId
                       && taxTrans.RecId == taxTransGeneralJournalAccountEntry.TaxTrans;
        }

        return taxTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRecId_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the rec id of the tax transaction.
    /// </summary>
    /// <param name="_recId">
    /// The rec id.
    /// </param>
    /// <param name="_forupdate">
    /// True if the record will be update.
    /// </param>
    /// <param name="_concurrencyModel">
    /// The concurrency model.
    /// </param>
    /// <returns>
    /// The finding results of the tax transaction.
    /// </returns>
    public static TaxTrans findRecId_IN(
        RefRecId                _recId,
        boolean                 _forupdate = false,
        ConcurrencyModel        _concurrencyModel = ConcurrencyModel::Auto)
    {
        TaxTrans taxTrans;

        taxTrans.selectForUpdate(_forupdate);
        if (_forupdate  && _concurrencyModel != ConcurrencyModel::Auto)
        {
            taxTrans.concurrencyModel(_concurrencyModel);
        }
        select firstonly taxTrans
            where taxTrans.RecId == _recId;

        return taxTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getServiceTaxSign_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets service tax sign.
    /// </summary>
    /// <param name="_isServiceTax">
    /// Indicates if is service tax.
    /// </param>
    /// <param name="_taxTrans">
    /// The tax trans
    /// </param>
    /// <param name="_checkGTAVendor">
    /// Indicates if check GTA vendor or not.
    /// </param>
    /// <param name="_isGTAVendor">
    /// Indicates if is GTA vendor or not.
    /// </param>
    /// <param name="_sign">
    /// The sign
    /// </param>
    /// <returns>
    /// Returns the service tax info in a containers.
    /// </returns>
    static container getServiceTaxSign_IN(boolean _isServiceTax, TaxTrans _taxTrans, boolean _checkGTAVendor, boolean _isGTAVendor, int _sign)
    {
        boolean    checkGTAVendor = _checkGTAVendor;
        int        sign           = _sign;
        boolean    isGTAVendor    = _isGTAVendor;
        TaxTrans_W taxTrans_W;

        if (_isServiceTax && TaxTable::find(_taxTrans.TaxCode).TaxType_IN == TaxType_IN::ServiceTax)
        {
            if (!checkGTAVendor)
            {
                isGTAVendor = VendTable::find(VendTrans::findVoucherDate(_taxTrans.Voucher, _taxTrans.TransDate).AccountNum).isGTA();
                checkGTAVendor  = true;
            }
            taxTrans_W = TaxTrans_W::findByTaxTrans(_taxTrans.RecId);
            if (_taxTrans.TaxDirection == TaxDirection::OutgoingTax
                &&
                    (taxTrans_W.ServiceTaxReverseChargePercentage_IN > 0 || isGTAVendor)
                )

            {
                sign = 1;
            }
        }

        return [checkGTAVendor, isGTAVendor, sign];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxAmountIncludedInInvoice_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Extracts and returns the tax amount included in the invoice amount for India.
    /// </summary>
    /// <param name="_sourceTableId">
    /// The sourceTable id
    /// </param>
    /// <param name="_sourceRecId">
    /// Source RecId
    /// </param>
    /// <returns>
    /// The cumulative tax amount (considers adjustment also) against which the payment can be made.
    /// That means (ServiceTax + VAT + Excise + SalesTax). Does not consider Standard Tax, Customs.
    /// WHT does not come here.
    /// </returns>
    public static TaxAmountCur getTaxAmountIncludedInInvoice_IN(
        RefTableId _sourceTableId,
        RefRecId   _sourceRecId)
    {
        TaxTrans taxTrans;
        TaxTable taxTable;
        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            if (_sourceRecId != 0)
            {
                select sum(SourceRegulateAmountCur)
                    from taxTrans
                       where taxTrans.SourceTableId == _sourceTableId
                          && taxTrans.SourceRecId   == _sourceRecId
                     exists join RecId from taxTable
                        where taxTable.TaxCode    == taxTrans.TaxCode
                           &&
                              (taxTable.TaxType_IN != TaxType_IN::None
                               && taxTable.TaxType_IN != TaxType_IN::Customs);// Exclude Customs & STD taxes from India Invoice amount.
            }
        }

        return taxTrans.SourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountCustoms_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax amount for given parameter.
    /// </summary>
    /// <param name="_query">
    /// A buffer of query.
    /// </param>
    /// <param name="_changeDisplaySign">
    /// This param is used to check whether change dispaly sign; optional.
    /// </param>
    /// <param name="_generalJournalEntryId">
    /// The record id of general journal entry is used to add range; optional.
    /// </param>
    /// <returns>
    /// The tax amount.
    /// </returns>
    public static TaxAmount taxAmountCustoms_IN(
        Query    _query,
        boolean  _changeDisplaySign = false,
        RefRecId _generalJournalEntryId = 0)
    {
        TaxTrans                taxTrans;
        Query                   taxQuery;
        QueryRun                taxQueryRun;
        AmountCur               taxAmountCur;
        QueryBuildDataSource    qbdTaxTrans;
        QueryBuildDataSource    qbdTaxTrans_W;
        QueryBuildDataSource    qbdSubledgerVoucherGeneralJournalEntry;
        int                     sign;
        TaxTrans_W              taxTrans_W;

        taxQuery = new Query();
        SysQuery::mergeRanges(taxQuery, _query);
        qbdTaxTrans = taxQuery.dataSourceNo(1);

        qbdTaxTrans.orderMode(OrderMode::GroupBy);
        qbdTaxTrans.addSortField(fieldNum(TaxTrans, CurrencyCode));
        qbdTaxTrans.addSortField(fieldNum(TaxTrans, TaxDirection));

        qbdTaxTrans_W = TaxTrans::addDataSource(qbdTaxTrans,tableNum(TaxTrans_W));
        qbdTaxTrans_W.addSelectionField(fieldNum(TaxTrans_W, CustomsDuty_IN), SelectionField::Sum);
        qbdTaxTrans.addRange(fieldNum(TaxTrans, TaxAutogenerated)).value(queryValue(NoYes::Yes));

        if (_generalJournalEntryId)
        {
            //Adding the join to the SubledgerVoucherGeneralJournalEntry table
            taxQuery = SubledgerVoucherGeneralJournalEntry::addJoinForNaturalKey(taxQuery, tableNum(TaxTrans),
                                        fieldNum(TaxTrans, TransDate),
                                        fieldNum(TaxTrans, Voucher),
                                        fieldNum(TaxTrans, DataAreaId));

            qbdSubledgerVoucherGeneralJournalEntry = taxQuery.dataSourceTable(tableNum(SubledgerVoucherGeneralJournalEntry));
            qbdSubledgerVoucherGeneralJournalEntry.addRange(fieldNum(SubledgerVoucherGeneralJournalEntry, GeneralJournalEntry)).value(int642str(_generalJournalEntryId));
        }

        taxQueryRun = new QueryRun(taxQuery);
        while (taxQueryRun.next())
        {
            taxTrans = taxQueryRun.getNo(1);
            taxTrans_W = taxQueryRun.get(tableNum(TaxTrans_W));

            sign = _changeDisplaySign ? Tax::changeDisplaySign(taxTrans.TaxDirection) : 1;
            taxAmountCur += taxTrans_W.CustomsDuty_IN * sign;
        }

        qbdTaxTrans_W.addSelectionField(fieldNum(TaxTrans_W, TaxAmountCustoms_IN), SelectionField::Sum);
        qbdTaxTrans.findRange(fieldNum(TaxTrans, TaxAutogenerated)).value(queryValue(NoYes::No));
        taxQueryRun = new QueryRun(taxQuery);
        while (taxQueryRun.next())
        {
            taxTrans = taxQueryRun.getNo(1);
            taxTrans_W = taxQueryRun.get(tableNum(TaxTrans_W));
            sign = _changeDisplaySign ? Tax::changeDisplaySign(taxTrans.TaxDirection) : 1;
            taxAmountCur += taxTrans_W.TaxAmountCustoms_IN * sign;
        }
        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTaxServiceTariffForNewParent_PL</Name>
				<Source><![CDATA[
    // </GIN>

    // <GPL>
    public static void insertTaxServiceTariffForNewParent_PL(TaxTrans _taxTrans)
    {
        #ISOCountryRegionCodes

        // <GEEPL>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            TaxServiceTariff::insertTaxServiceTariffForNewParent(_taxTrans.SourceTableId, _taxTrans.SourceRecId, _taxTrans.TableId, _taxTrans.RecId);
        }
        // </GEEPL>
    }

]]></Source>
			</Method>
			<Method>
				<Name>setExciseAmount_PL</Name>
				<Source><![CDATA[
    public static void setExciseAmount_PL(TaxTrans _taxTrans)
    {
        #ISOCountryRegionCodes
        if (SysExtensionSerializerExtensionMap::isExtensionEnabled(tableNum(TaxTrans_W))
            && SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoPL])
            && TaxTable::find(_taxTrans.TaxCode).TaxType_W == TaxType_W::Excise)
        {
            TaxTrans_W taxTrans_W = _taxTrans.taxTrans_W();
            taxTrans_W.ExciseAmount_PL = CurrencyExchangeHelper::amount(TaxData::find(_taxTrans.TaxCode, _taxTrans.TransDate, _taxTrans.TaxBaseAmount).ExciseDuty_PL / 100 * _taxTrans.TaxBaseAmount);
            _taxTrans.packTaxTrans_W(taxTrans_W);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseTaxAmounts_RU</Name>
				<Source><![CDATA[
    // </GPL>

    // <GRU>
    /// <summary>
    /// Reverse the tax amounts on the tax transaction.
    /// </summary>
    /// <param name = "_taxTrans">The tax transaction that is to have its tax amounts reversed.</param>
    /// <returns></returns>
    public static void reverseTaxAmounts_RU(TaxTrans _taxTrans)
    {
        _taxTrans.TaxBaseAmount                   = - _taxTrans.TaxBaseAmount;
        _taxTrans.TaxAmount                       = - _taxTrans.TaxAmount;
        _taxTrans.TaxInCostPrice                  = - _taxTrans.TaxInCostPrice;
        _taxTrans.TaxAmountCur                    = - _taxTrans.TaxAmountCur;
        _taxTrans.TaxAmountRep                    = - _taxTrans.TaxAmountRep;
        _taxTrans.SourceBaseAmountCur             = - _taxTrans.SourceBaseAmountCur;
        _taxTrans.TaxBaseAmountCur                = - _taxTrans.TaxBaseAmountCur;
        _taxTrans.TaxBaseAmountRep                = - _taxTrans.TaxBaseAmountRep;
        _taxTrans.SourceTaxAmountCur              = - _taxTrans.SourceTaxAmountCur;
        _taxTrans.SourceRegulateAmountCur         = - _taxTrans.SourceRegulateAmountCur;
        _taxTrans.TaxInCostPriceRegulated         = - _taxTrans.TaxInCostPriceRegulated;
        _taxTrans.TaxInCostPriceMST               = - _taxTrans.TaxInCostPriceMST;
        _taxTrans.TaxInCostPriceCur               = - _taxTrans.TaxInCostPriceCur;
        _taxTrans.TaxInCostPriceRep               = - _taxTrans.TaxInCostPriceRep;
        _taxTrans.SourceBaseAmountCurRegulated    = - _taxTrans.SourceBaseAmountCurRegulated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAndValidateFields_TH</Name>
				<Source><![CDATA[
    // </GRU>

    // <GTH>
    public static void setAndValidateFields_TH(TaxTrans _taxTrans)
    {
        //<GTH>
        if (TaxThaiGovCertificationFeatureChecker::isUnrealizedVATEnabled()
            && TaxTransCustomization_W::isSourceTableRestricted_TH(_taxTrans))
        {
            TaxTransCustomization_W::setFieldsValue_TH(_taxTrans);
            TaxTransCustomization_W::validateTaxInvoiceDetails_TH(_taxTrans);
        }
        //</GTH>
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSourceTableRestricted_TH</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates if the record is in restricted tables.
    /// </summary>
    /// <returns>
    /// True if the record is in restricted tables, otherwise false.
    /// </returns>
    private static boolean isSourceTableRestricted_TH(TaxTrans _taxTrans)
    {
        boolean     ret;
        SysModule   sysModule;

        switch (_taxTrans.SourceTableId)
        {
            case tableNum(LedgerJournalTrans):
                sysModule = LedgerJournalTrans::findRecId(_taxTrans.SourceRecId, false).ledgerJournalTable().ledgerJournalName().getSysModuleForJournal();
                switch (sysModule)
                {
                    case SysModule::Vend:
                    case SysModule::Cust:
                    case SysModule::Ledger:
                        ret = true;
                        break;
                }
                break;
            case tableNum(VendInvoiceTrans):
            case tableNum(VendInvoiceInfoLine):
            case tableNum(VendTrans):
            case tableNum(MarkupTrans):
            case tableNum(CustInvoiceTrans):
            case tableNum(CustInvoiceLine):
            case tableNum(CustTrans):
            case tableNum(ProjInvoiceEmpl):
            case tableNum(ProjInvoiceCost):
            case tableNum(ProjInvoiceItem):
            case tableNum(ProjInvoiceOnAcc):
            case tableNum(ProjInvoiceRevenue):
                ret = true;
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFieldsValue_TH</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets values of Thailand fields.
    /// </summary>
    private static void setFieldsValue_TH(TaxTrans _taxTrans)
    {
        TaxTable                taxTable;
        boolean                 isTaxInvoiceCanBeSet = TaxTransCustomization_W::isTaxInvoiceCanBeSet_TH(_taxTrans);
        TaxTransExtensionTH     taxTransExtensionTH;

        taxTable                = TaxTable::find(_taxTrans.TaxCode);
        taxTransExtensionTH     = _taxTrans.taxTransExtensionTH();

        taxTransExtensionTH.TaxType         = taxTable.TaxType_TH;
        taxTransExtensionTH.PaymTaxCode     = taxTable.PaymentTaxCode;
        _taxTrans.SysExtensionSerializerMap::packExtensionTable(taxTransExtensionTH);

        switch (_taxTrans.TaxDirection)
        {
            case TaxDirection::IncomingTax:
                TaxTransCustomization_W::setTaxInvoiceForIncomingTax_TH(_taxTrans);
                break;
            case TaxDirection::OutgoingTax:
                TaxTransCustomization_W::setTaxInvoiceForOutgoingTax_TH(_taxTrans);
                break;
            case TaxDirection::UseTax:
                TaxTransCustomization_W::setTaxInvoiceForUseTax_TH(_taxTrans);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTaxInvoiceDetails_TH</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates tax invoice details according to whether tax is realized or not.
    /// </summary>
    /// <exception cref="Exception::Error">
    ///     Throws error if realized tax without tax invoice details.
    ///     Throws error if unrealized tax with tax invoice details.
    /// </exception>
    [Replaceable]
    protected static void validateTaxInvoiceDetails_TH(TaxTrans _taxTrans)
    {
        boolean                             isRealizedVAT;
        TaxUnrealizedSalesNoteFormat        noteFormat;
        TaxTransExtensionTH                 taxTransExtensionTH;

        if (_taxTrans.TaxOrigin == TaxOrigin::Tax
            || _taxTrans.TaxOrigin == TaxOrigin::Transfer)
        {
            isRealizedVAT = TaxTable::isRealizedVAT(_taxTrans.TaxCode);

            taxTransExtensionTH = _taxTrans.taxTransExtensionTH();

            if (_taxTrans.TaxDirection == TaxDirection::IncomingTax)
            {
                if (isRealizedVAT)
                {
                    if (!taxTransExtensionTH.TaxInvoiceId
                        || !taxTransExtensionTH.TaxInvoiceDate
                        || !taxTransExtensionTH.TaxInvoiceReceiptDate)
                    {
                        // To post the realized VAT transactions, enter the tax invoice number, tax invoice date and tax invoice receipt date.
                        throw error("@SYS4082741");
                    }
                }
                else if (taxTransExtensionTH.TaxInvoiceId
                    || taxTransExtensionTH.TaxInvoiceDate
                    || taxTransExtensionTH.TaxInvoiceReceiptDate
                    || !taxTransExtensionTH.InvoiceDate
                    || !taxTransExtensionTH.InvoiceReceiptDate)
                {
                    // To post the unrealized VAT transactions, enter the invoice number, invoice date and invoice receipt date.
                    throw error("@SYS4082742");
                }
            }
            else if (_taxTrans.TaxDirection == TaxDirection::OutgoingTax)
            {
                if (!isRealizedVAT
                    && _taxTrans.SourceTableId == tableNum(CustInvoiceTrans))
                {
                    noteFormat = CustInvoiceTrans::findRecId(_taxTrans.SourceRecId).custInvoiceJour().custInvoiceJourExtensionTH().NoteFormat;
                    if (noteFormat != TaxUnrealizedSalesNoteFormat::None)
                    {
                        // Item sales tax code must be set to realized for Debit and Credit notes..
                        throw error("@SYS4082940");
                    }
                }
                else if (!isRealizedVAT
                    && _taxTrans.SourceTableId   == tableNum(CustInvoiceLine))
                {
                    noteFormat = CustInvoiceTrans::findBySourceDocumentLine(CustInvoiceLine::find(_taxTrans.SourceRecId).SourceDocumentLine).custInvoiceJour().custInvoiceJourExtensionTH().NoteFormat;
                    if (noteFormat != TaxUnrealizedSalesNoteFormat::None)
                    {
                        // Item sales tax code must be set to realized for Debit and Credit notes..
                        throw error("@SYS4082940");
                    }
                }
                // add project proposal invoice for Taxtrans with unreal tax
                else if (!isRealizedVAT
                    && ( _taxTrans.SourceTableId == tableNum(ProjInvoiceEmpl)
                        || _taxTrans.SourceTableId == tableNum(ProjInvoiceItem)
                        || _taxTrans.SourceTableId == tableNum(ProjInvoiceOnAcc)
                        || _taxTrans.SourceTableId == tableNum(ProjInvoiceCost)
                        || _taxTrans.SourceTableId == tableNum(ProjInvoiceRevenue)))
                {
                    ProjInvoiceJour projInvoiceJour;

                    select PackedExtensions,RecId from projInvoiceJour
                        where projInvoicejour.LedgerVoucher == _taxTrans.Voucher
                            && projInvoiceJour.InvoiceDate == _taxTrans.TransDate;

                    noteFormat = projInvoiceJour.projInvoiceJourExtension_TH().NoteFormat;

                    if (noteFormat != TaxUnrealizedSalesNoteFormat::None)
                    {
                        // Item sales tax code must be set to realized for Debit and Credit notes.
                        throw error("@SYS4082940");
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTaxType_TH</Name>
				<Source><![CDATA[
    /// <summary>
    ///     The method validates the tax type according to whether tax is realized or not.
    /// </summary>
    private static void validateTaxType_TH(TaxTrans _taxTrans)
    {
        boolean     isRealizedVATLocal;
        boolean     isRealizedVATExsiting;
        TaxTrans    taxTransLocal;

        select firstonly RecId, TaxCode from taxTransLocal
            where taxTransLocal.Voucher == _taxTrans.Voucher
                && taxTransLocal.TransDate == _taxTrans.TransDate
                && taxTransLocal.TaxOrigin != TaxOrigin::TaxReversed
                && taxTransLocal.TaxOrigin != TaxOrigin::Payment;

        if (taxTransLocal.RecId)
        {
            isRealizedVATLocal = TaxTable::isRealizedVAT(_taxTrans.TaxCode);
            isRealizedVATExsiting = TaxTable::isRealizedVAT(taxTransLocal.TaxCode);

            if (isRealizedVATLocal != isRealizedVATExsiting)
            {
                // Both realized VAT and unrealized VAT exist in current posting invoice.
                throw error("@SYS4082809");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxInvoiceCanBeSet_TH</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether tax invoice information can be set to current tax transaction.
    /// </summary>
    /// <returns>
    ///     Returns true when
    ///     1) Tax is realized at the time of posting invoice.
    ///     2) Tax is realized at the time of posting payment journal or reversal journal.
    /// </returns>
    private static boolean isTaxInvoiceCanBeSet_TH(TaxTrans _taxTrans)
    {
        TaxTransExtensionTH     taxTransExtensionTH;

        if (TaxTable::isRealizedVAT(_taxTrans.TaxCode))
        {
            if (_taxTrans.TaxOrigin == TaxOrigin::Tax
                || _taxTrans.TaxOrigin == TaxOrigin::Transfer)
            {
                return true;
            }

            if (_taxTrans.TaxOrigin == TaxOrigin::Payment)
            {
                taxTransExtensionTH = _taxTrans.taxTransExtensionTH();
                if (!TaxTrans::findTaxTransRecId(taxTransExtensionTH.TaxUnrealizedRefRecId).taxTransExtensionTH().TaxInvoiceId)
                {
                    return true;
                }
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxInvoiceForIncomingTax_TH</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets tax invoice information for incoming tax.
    /// </summary>
    private static void setTaxInvoiceForIncomingTax_TH(TaxTrans _taxTrans)
    {
        LedgerJournalTrans              ledgerJournalTrans;
        LedgerJournalTransExtensionTH   ledgerJournalTransExtensionTH;
        VendInvoiceJour                 vendInvoiceJour;
        VendInvoiceJour                 prePaymVendInvJour;
        VendInvoiceInfoTable            vendInvoiceInfoTable;
        VendInvoiceInfoTableExtensionTH vendInvoiceInfoTableExtensionTH;
        VendTrans                       vendTrans;
        VendTrans                       vendTransInvoice;
        VendSettlement                  vendSettlement;
        VendSettlementExtensionTH       vendSettlementExtensionTH;
        VendUnrealizedRev               vendUnrealizedRev;
        TaxTrans                        taxTransOrig;
        TaxTransExtensionTH             taxTransExtensionTHOrig;
        TaxTransExtensionTH             taxTransExtensionTH;
        boolean                         isRealizedVAT = TaxTable::isRealizedVAT(_taxTrans.TaxCode);

        // Assume that all other methods, called by code below before the last line, will not update the content
        // of the packed extension record where below extension record comes from. Otherwise, some update will lost.
        taxTransExtensionTH = _taxTrans.taxTransExtensionTH();

        switch (_taxTrans.SourceTableId)
        {
            case tableNum(LedgerJournalTrans)   :
                // TaxTrans is created when posting vendor invoice journal.
                ledgerJournalTrans = LedgerJournalTrans::findRecId(_taxTrans.SourceRecId, false);
                ledgerJournalTransExtensionTH = LedgerJournalTransExtensionTH::findByLedgerJournalTrans(ledgerJournalTrans.RecId);

                if (isRealizedVAT)
                {
                    taxTransExtensionTH.TaxInvoiceId            = ledgerJournalTrans.DocumentNum;
                    taxTransExtensionTH.TaxInvoiceDate          = ledgerJournalTrans.DocumentDate;
                    taxTransExtensionTH.TaxInvoiceReceiptDate   = ledgerJournalTransExtensionTH.TaxInvoiceReceiptDate;
                }
                taxTransExtensionTH.RealVendName            = ledgerJournalTransExtensionTH.RealVendName;
                taxTransExtensionTH.InvoiceDate             = ledgerJournalTransExtensionTH.InvoiceDate;
                taxTransExtensionTH.InvoiceReceiptDate      = ledgerJournalTransExtensionTH.InvoiceReceiptDate;
                break;

            case tableNum(VendInvoiceTrans)     :
                // TaxTrans is created when posting PO invoice.
                vendInvoiceJour = VendInvoiceJour::findFromTaxTrans(_taxTrans.Voucher, _taxTrans.TransDate);

                if (vendInvoiceJour.PurchId)
                {
                    vendInvoiceInfoTable = VendInvoiceInfoTable::findPurchId(vendInvoiceJour.PurchId, vendInvoiceJour.ParmId);
                }

                TaxTransCustomization_W::initThailandFieldFromVendInvoiceInfoTable(vendInvoiceInfoTable, taxTransExtensionTH, isRealizedVAT);
                break;

            case tableNum(VendInvoiceInfoLine)  :
                vendInvoiceInfoTable = VendInvoiceInfoLine::findRecId(_taxTrans.SourceRecId).vendInvoiceInfoTable();
                if (TaxTransCustomization_W::needGenerateThailandFieldInterCompany(vendInvoiceInfoTable, taxTransExtensionTH, isRealizedVAT))
                {
                    TaxTransCustomization_W::initThailandFieldFromInterCompanySalesOrder(vendInvoiceInfoTable, taxTransExtensionTH);
                }
                else
                {
                    TaxTransCustomization_W::initThailandFieldFromVendInvoiceInfoTable(vendInvoiceInfoTable, taxTransExtensionTH, isRealizedVAT);
                }

                break;

            case tableNum(MarkupTrans)          :
                // TaxTrans is created when posting PO invoice.
                vendInvoiceJour = VendInvoiceJour::findFromTaxTrans(_taxTrans.Voucher, _taxTrans.TransDate);

                if (vendInvoiceJour.PurchId)
                {
                    vendInvoiceInfoTable = VendInvoiceInfoTable::findPurchId(vendInvoiceJour.PurchId, vendInvoiceJour.ParmId);
                }
                else
                {
                    MarkupTrans markupTrans = MarkupTrans::findRecId(_taxTrans.SourceRecId);
                    vendInvoiceInfoTable = TaxTransCustomization_W::getVendInvoiceInfoTableFromMarkupTrans(markupTrans);
                }

                TaxTransCustomization_W::initThailandFieldFromVendInvoiceInfoTable(vendInvoiceInfoTable, taxTransExtensionTH, isRealizedVAT);
                break;

            case tableNum(VendTrans)            :
                // TaxTrans is created when reversing original tax transaction.
                if (_taxTrans.TaxOrigin == TaxOrigin::Payment)
                {
                    taxTransOrig = TaxTrans::findByUnrealizedRefRecId(taxTransExtensionTH.TaxUnrealizedRefRecId);
                    if (TaxTable::isRealizedVAT(taxTransOrig.TaxCode))
                    {
                        // Tax is realized at time of invoice.
                        taxTransExtensionTHOrig = taxTransOrig.taxTransExtensionTH();

                        taxTransExtensionTH.TaxInvoiceId                = taxTransExtensionTHOrig.TaxInvoiceId;
                        taxTransExtensionTH.TaxInvoiceDate              = taxTransExtensionTHOrig.TaxInvoiceDate;
                        taxTransExtensionTH.TaxInvoiceReceiptDate       = taxTransExtensionTHOrig.TaxInvoiceReceiptDate;
                        taxTransExtensionTH.RealVendName                = taxTransExtensionTHOrig.RealVendName;
                    }
                    else
                    {
                        vendTrans           = VendTrans::find(_taxTrans.SourceRecId);
                        vendTransInvoice    = VendTrans::findVoucherDate(taxTransOrig.Voucher, taxTransOrig.TransDate);

                        select firstonly VendUnrealizedRev from vendSettlementExtensionTH
                            exists join vendSettlement
                            where vendSettlement.RecId          == vendSettlementExtensionTH.VendSettlement
                                && vendSettlement.TransRecId    == vendTrans.RecId
                                && vendSettlement.OffsetRecid   == vendTransInvoice.RecId;

                        if (vendSettlementExtensionTH.VendUnrealizedRev)
                        {
                            // Tax is reversed via reversal journal.
                            vendUnrealizedRev = VendUnrealizedRev::find(vendSettlementExtensionTH.VendUnrealizedRev);

                            if (vendUnrealizedRev)
                            {
                                taxTransExtensionTH.TaxInvoiceId            = vendUnrealizedRev.TaxInvoiceId;
                                taxTransExtensionTH.TaxInvoiceDate          = vendUnrealizedRev.TaxInvoiceDate;
                                taxTransExtensionTH.TaxInvoiceReceiptDate   = vendUnrealizedRev.TaxInvoiceReceiptDate;
                                taxTransExtensionTH.RealVendName            = vendUnrealizedRev.RealVendName;
                            }
                        }
                        else
                        {
                            // Tax is reversed via payment journal.
                            ledgerJournalTrans = LedgerJournalTrans::findJournalForVoucher(vendTrans.Voucher, vendTrans.TransDate);
                            ledgerJournalTransExtensionTH = LedgerJournalTransExtensionTH::findByLedgerJournalTrans(ledgerJournalTrans.RecId);

                            if (ledgerJournalTrans)
                            {
                                taxTransExtensionTH.TaxInvoiceId            = ledgerJournalTrans.DocumentNum;
                                taxTransExtensionTH.TaxInvoiceDate          = ledgerJournalTrans.DocumentDate;
                                taxTransExtensionTH.TaxInvoiceReceiptDate   = ledgerJournalTransExtensionTH.TaxInvoiceReceiptDate;
                                taxTransExtensionTH.RealVendName            = ledgerJournalTransExtensionTH.RealVendName;
                                taxTransExtensionTH.InvoiceDate             = ledgerJournalTransExtensionTH.InvoiceDate;
                                taxTransExtensionTH.InvoiceReceiptDate      = ledgerJournalTransExtensionTH.InvoiceReceiptDate;
                            }
                        }
                    }
                }
                break;
        }

        _taxTrans.SysExtensionSerializerMap::packExtensionTable(taxTransExtensionTH);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxInvoiceForOutgoingTax_TH</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets tax invoice information for outgoing tax.
    /// </summary>
    private static void setTaxInvoiceForOutgoingTax_TH(TaxTrans _taxTrans)
    {
        LedgerJournalTrans              ledgerJournalTrans;
        LedgerJournalTransExtensionTH   ledgerJournalTransExtensionTH;
        CustInvoiceTrans                custInvoiceTrans;
        CustTrans                       custTrans;
        TaxTransExtensionTH             taxTransExtensionTH;
        ProjInvoiceJour                 projInvoiceJour;
        boolean                         isRealizedVAT = TaxTable::isRealizedVAT(_taxTrans.TaxCode);

        switch (_taxTrans.SourceTableId)
        {
            case tableNum(LedgerJournalTrans)   :
                // TaxTrans is created when posting cust invoice journal.
                ledgerJournalTrans = LedgerJournalTrans::findRecId(_taxTrans.SourceRecId, false);
                ledgerJournalTransExtensionTH = LedgerJournalTransExtensionTH::findByLedgerJournalTrans(ledgerJournalTrans.RecId);

                taxTransExtensionTH = _taxTrans.taxTransExtensionTH();
                if (isRealizedVAT)
                {
                    taxTransExtensionTH.TaxInvoiceId            = ledgerJournalTrans.DocumentNum;
                    taxTransExtensionTH.TaxInvoiceDate          = ledgerJournalTrans.DocumentDate;
                    taxTransExtensionTH.TaxInvoiceReceiptDate   = ledgerJournalTransExtensionTH.TaxInvoiceReceiptDate;
                }
                taxTransExtensionTH.RealVendName            = ledgerJournalTransExtensionTH.RealVendName;
                taxTransExtensionTH.InvoiceDate             = ledgerJournalTransExtensionTH.InvoiceDate;
                taxTransExtensionTH.InvoiceReceiptDate      = ledgerJournalTransExtensionTH.InvoiceReceiptDate;
                _taxTrans.SysExtensionSerializerMap::packExtensionTable(taxTransExtensionTH);
                break;

            case tableNum(CustInvoiceTrans)     :
                // TaxTrans is created when posting PO invoice.
                custInvoiceTrans = CustInvoiceTrans::findRecId(_taxTrans.SourceRecId);
                if (custInvoiceTrans && isRealizedVAT)
                {
                    taxTransExtensionTH = _taxTrans.taxTransExtensionTH();
                    taxTransExtensionTH.TaxInvoiceId    = custInvoiceTrans.InvoiceId;
                    taxTransExtensionTH.TaxInvoiceDate  = custInvoiceTrans.InvoiceDate;
                    _taxTrans.SysExtensionSerializerMap::packExtensionTable(taxTransExtensionTH);
                }
                break;

            case tableNum(MarkupTrans)          :
                taxTransExtensionTH = _taxTrans.taxTransExtensionTH();

                MarkupTrans markupTrans;
                select firstonly TransRecId, TransTableId from markupTrans
                    where markupTrans.RecId == _taxTrans.SourceRecId;

                switch (markupTrans.TransTableId)
                {
                    case tableNum(CustInvoiceJour)   :
                        CustInvoiceJour custInvoiceJour;
                        select firstonly InvoiceDate, InvoiceId from custInvoiceJour
                            where custInvoiceJour.RecId == markupTrans.TransRecId;

                        taxTransExtensionTH.TaxInvoiceId    = custInvoiceJour.InvoiceId;
                        taxTransExtensionTH.TaxInvoiceDate  = custInvoiceJour.InvoiceDate;
                        break;

                    case tableNum(CustInvoiceTrans)  :
                        select firstonly InvoiceDate, InvoiceId from custInvoiceTrans
                            where custInvoiceTrans.RecId == markupTrans.TransRecId;

                        taxTransExtensionTH.TaxInvoiceId    = custInvoiceTrans.InvoiceId;
                        taxTransExtensionTH.TaxInvoiceDate  = custInvoiceTrans.InvoiceDate;
                        break;
                }
                _taxTrans.SysExtensionSerializerMap::packExtensionTable(taxTransExtensionTH);
                break;

            case tableNum(CustInvoiceLine)     :
                // TaxTrans is created when posting PO invoice.
                custInvoiceTrans = CustInvoiceTrans::findBySourceDocumentLine(CustInvoiceLine::find(_taxTrans.SourceRecId).SourceDocumentLine);
                if (custInvoiceTrans && isRealizedVAT)
                {
                    taxTransExtensionTH = _taxTrans.taxTransExtensionTH();
                    taxTransExtensionTH.TaxInvoiceId    = custInvoiceTrans.InvoiceId;
                    taxTransExtensionTH.TaxInvoiceDate  = custInvoiceTrans.InvoiceDate;
                    _taxTrans.SysExtensionSerializerMap::packExtensionTable(taxTransExtensionTH);
                }
                break;

            case tableNum(CustTrans)            :
                // TaxTrans is created when reversing original tax transaction.
                if (_taxTrans.TaxOrigin == TaxOrigin::Payment)
                {
                    custTrans = CustTrans::find(_taxTrans.SourceRecId);
                    if (custTrans && isRealizedVAT)
                    {
                        taxTransExtensionTH = _taxTrans.taxTransExtensionTH();
                        taxTransExtensionTH.TaxInvoiceId    = custTrans.DocumentNum;
                        if (custTrans.DocumentDate)
                        {
                            taxTransExtensionTH.TaxInvoiceDate  = custTrans.DocumentDate;
                        }
                        else
                        {
                            taxTransExtensionTH.TaxInvoiceDate  = custTrans.TransDate;
                        }
                        _taxTrans.SysExtensionSerializerMap::packExtensionTable(taxTransExtensionTH);
                    }
                }
                break;

            case tableNum(ProjInvoiceEmpl)       :
            case tableNum(ProjInvoiceItem)       :
            case tableNum(ProjInvoiceCost)       :
            case tableNum(ProjInvoiceOnAcc)      :
            case tableNum(ProjInvoiceRevenue)    :
                taxTransExtensionTH = _taxTrans.taxTransExtensionTH();
                select ProjInvoiceId from projInvoiceJour
                    where projInvoiceJour.LedgerVoucher == _taxTrans.Voucher
                        && projInvoiceJour.InvoiceDate == _taxTrans.TransDate;
                taxTransExtensionTH.TaxInvoiceId    = projInvoiceJour.ProjInvoiceId;
                taxTransExtensionTH.TaxInvoiceDate  = _taxTrans.TransDate;
                _taxTrans.SysExtensionSerializerMap::packExtensionTable(taxTransExtensionTH);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxInvoiceForUseTax_TH</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets tax invoice information for use tax.
    /// </summary>
    private static void setTaxInvoiceForUseTax_TH(TaxTrans _taxTrans)
    {
        LedgerJournalTrans              ledgerJournalTrans;
        LedgerJournalTransExtensionTH   ledgerJournalTransExtensionTH;
        TaxTransExtensionTH             taxTransExtensionTH;
        boolean                         isRealizedVAT = TaxTable::isRealizedVAT(_taxTrans.TaxCode);

        ledgerJournalTrans = LedgerJournalTrans::findRecId(_taxTrans.SourceRecId, false);

        if (LedgerJournalTrans)
        {
            // TaxTrans is created when posting to ledger through general journal
            ledgerJournalTransExtensionTH = LedgerJournalTransExtensionTH::findByLedgerJournalTrans(ledgerJournalTrans.RecId);

            if (isRealizedVAT)
            {
                taxTransExtensionTH.TaxInvoiceId            = ledgerJournalTrans.DocumentNum;
                taxTransExtensionTH.TaxInvoiceDate          = ledgerJournalTrans.DocumentDate;
                taxTransExtensionTH.TaxInvoiceReceiptDate   = ledgerJournalTransExtensionTH.TaxInvoiceReceiptDate;
            }
            taxTransExtensionTH.RealVendName            = ledgerJournalTransExtensionTH.RealVendName;
            taxTransExtensionTH.InvoiceDate             = ledgerJournalTransExtensionTH.InvoiceDate;
            taxTransExtensionTH.InvoiceReceiptDate      = ledgerJournalTransExtensionTH.InvoiceReceiptDate;
            _taxTrans.SysExtensionSerializerMap::packExtensionTable(taxTransExtensionTH);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initThailandFieldFromVendInvoiceInfoTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initialize Thailand fields from <c>VendInvoiceInfoTable</c>.
    /// </summary>
    /// <param name = "_vendInvoiceInfoTable">The <c>VendInvoiceInfoTable</c> record.</param>
    /// <param name = "_taxTransExtensionTH">The <c>TaxTransExtensionTH</c> record.</param>
    /// <param name = "_isRealizedVAT">Whether the tax code is realized VAT.</param>
    private static void initThailandFieldFromVendInvoiceInfoTable(
        VendInvoiceInfoTable _vendInvoiceInfoTable,
        TaxTransExtensionTH _taxTransExtensionTH,
        boolean _isRealizedVAT)
    {
        VendInvoiceInfoTableExtensionTH vendInvoiceInfoTableExtensionTH = _vendInvoiceInfoTable.vendInvoiceInfoTableExtensionTH();

        if (_isRealizedVAT)
        {
            _taxTransExtensionTH.TaxInvoiceId            = _vendInvoiceInfoTable.DocumentNum;
            _taxTransExtensionTH.TaxInvoiceDate          = _vendInvoiceInfoTable.DocumentDate;
            _taxTransExtensionTH.TaxInvoiceReceiptDate   = vendInvoiceInfoTableExtensionTH.TaxInvoiceReceiptDate;
        }
        _taxTransExtensionTH.RealVendName            = vendInvoiceInfoTableExtensionTH.RealVendName;
        _taxTransExtensionTH.InvoiceDate             = vendInvoiceInfoTableExtensionTH.InvoiceDate;
        _taxTransExtensionTH.InvoiceReceiptDate      = vendInvoiceInfoTableExtensionTH.InvoiceReceiptDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initThailandFieldFromInterCompanySalesOrder</Name>
				<Source><![CDATA[
    private static void initThailandFieldFromInterCompanySalesOrder(
        VendInvoiceInfoTable _vendInvoiceInfoTable,
        TaxTransExtensionTH _taxTransExtensionTH)
    {
        VendInvoiceInfoTableExtensionTH vendInvoiceInfoTableExtensionTH = _vendInvoiceInfoTable.vendInvoiceInfoTableExtensionTH();
        SalesId interCompanySalesId = PurchTable::find(_vendInvoiceInfoTable.PurchId).InterCompanySalesId;

        CustInvoiceJour custInvoiceJour;
        select firstonly crosscompany InvoiceId, InvoiceDate from custInvoiceJour
            where custInvoiceJour.SalesId == interCompanySalesId;

        CustPackingSlipJour custPackingSlipJour;
        select firstonly crosscompany DeliveryDate from custPackingSlipJour
            where custPackingSlipJour.SalesId == interCompanySalesId;
        
        _taxTransExtensionTH.TaxInvoiceId = custInvoiceJour.InvoiceId;
        _taxTransExtensionTH.TaxInvoiceDate = custInvoiceJour.InvoiceDate;

        if (custPackingSlipJour.DeliveryDate)
        {
            _taxTransExtensionTH.TaxInvoiceReceiptDate = custPackingSlipJour.DeliveryDate;
        }
        else
        {
            _taxTransExtensionTH.TaxInvoiceReceiptDate = custInvoiceJour.InvoiceDate;
        }

        _taxTransExtensionTH.RealVendName            = vendInvoiceInfoTableExtensionTH.RealVendName;
        _taxTransExtensionTH.InvoiceDate             = vendInvoiceInfoTableExtensionTH.InvoiceDate;
        _taxTransExtensionTH.InvoiceReceiptDate      = vendInvoiceInfoTableExtensionTH.InvoiceReceiptDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>needGenerateThailandFieldInterCompany</Name>
				<Source><![CDATA[
    private static boolean needGenerateThailandFieldInterCompany(
        VendInvoiceInfoTable _vendInvoiceInfoTable,
        TaxTransExtensionTH _taxTransExtensionTH,
        boolean _isRealizedVAT)
    {
        boolean ret = false;

        if (_isRealizedVAT 
            && _vendInvoiceInfoTable.PurchId
            && TaxTransExtensionTHAutoGenerateInvoiceField_THFlight::instance().isEnabled()
            && !TaxAutoGeneratePurchInvoiceField_THFlight::instance().isEnabled())
        {
            PurchTable purchTable = PurchTable::find(_vendInvoiceInfoTable.PurchId);
            if (purchTable
                &&(!_taxTransExtensionTH.TaxInvoiceId || !_taxTransExtensionTH.TaxInvoiceDate || !_taxTransExtensionTH.TaxInvoiceReceiptDate)
                && purchTable.isInterCompanyOrder()
                && purchTable.interCompanyEndpointActionPolicy().PostPurchInvoice)
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVendInvoiceInfoTableFromMarkupTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>VendInvoiceInfoTable</c> record from <c>MarkupTrans</c>.
    /// </summary>
    /// <param name = "_markupTrans">The <c>MarkupTrans</c> record.</param>
    /// <returns><c>VendInvoiceInfoTable</c> record.</returns>
    private static VendInvoiceInfoTable getVendInvoiceInfoTableFromMarkupTrans(MarkupTrans _markupTrans)
    {
        VendInvoiceInfoTable vendInvoiceInfoTable;

        switch (_markupTrans.TransTableId)
        {
            case tableNum(VendInvoiceInfoLine) :
                vendInvoiceInfoTable = VendInvoiceInfoLine::findRecId(_markupTrans.TransRecId).vendInvoiceInfoTable();
                break;
            case tableNum(VendInvoiceInfoTable) :
                vendInvoiceInfoTable = VendInvoiceInfoTable::findRecId(_markupTrans.TransRecId);
                break;
            case tableNum(VendInvoiceInfoSubTable) :
                vendInvoiceInfoTable = VendInvoiceInfoSubTable::findRecId(_markupTrans.TransRecId).vendInvoiceInfoTable();
                break;
            default :
                break;
        }

        return vendInvoiceInfoTable;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>