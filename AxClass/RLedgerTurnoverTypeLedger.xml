<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RLedgerTurnoverTypeLedger</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>RLedgerTurnoverTypeLedger</c> class implements logic for ledger turnover statements.
/// </summary>
class RLedgerTurnoverTypeLedger extends RLedgerTurnoverType
{
    const int appModule = 1;
    const int corrAccount = 2;
    const int facture = 3;
    const int transType = 4;

    const str appModuleParamName = "@SYS9941";
    const str corrAccountParamName = "@GLS102172";
    const str factureParamName = "@GLS104582";
    const str transTypeParamName = "@SYS21201";

    boolean                    isFactureSelected;

    Map                        mapTransCorrAccountCache;
    Map                        mapLedgerDimensionCorr;

    TmpMainAccount             tmpMainAccount;
    container                  groupParamNames;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addMainAccountRange</Name>
				<Source><![CDATA[
    public void addMainAccountRange(MainAccountRange _accountRange, boolean _offset = false)
    {
        SetEnumerator   setEnumerator;

        super(_accountRange, _offset);

        if (accountNumSet.elements() && ! _offset && ! tmpMainAccount)
        {
            setEnumerator = accountNumSet.getEnumerator();
            while (setEnumerator.moveNext())
            {
                tmpMainAccount.MainAccount = MainAccount::findByMainAccountId(setEnumerator.current()).RecId;
                tmpMainAccount.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createEntryModule</Name>
				<Source><![CDATA[
    private RLedgerJournalAccountEntryModule createEntryModule(GeneralJournalAccountEntryRecId   _refAccountEntry,
                                                                  SysModule                         _module,
                                                                  GeneralJournalAccountEntry        _accountEntry,
                                                                  RefRecId                          _refRecID)
    {
        RLedgerJournalAccountEntryModule RLedgerJournalAccountEntryModule;

        RLedgerJournalAccountEntryModule.GeneralJournalAccountEntry = _refAccountEntry;
        RLedgerJournalAccountEntryModule.Module                     = _module;
        RLedgerJournalAccountEntryModule.AccountingCurrencyAmount   = _accountEntry.AccountingCurrencyAmount;
        RLedgerJournalAccountEntryModule.ReportingCurrencyAmount    = _accountEntry.ReportingCurrencyAmount;
        RLedgerJournalAccountEntryModule.TransactionCurrencyAmount  = _accountEntry.TransactionCurrencyAmount;
        RLedgerJournalAccountEntryModule.IsCorrection               = _accountEntry.IsCorrection;
        RLedgerJournalAccountEntryModule.RefRecId                   = _refRecID;
        RLedgerJournalAccountEntryModule.insert();

        return RLedgerJournalAccountEntryModule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPrecalcData</Name>
				<Source><![CDATA[
    public void createPrecalcData(Common _trans,
                                  Common _transHeader,
                                  Common _transSplit)
    {
        int                                  idx, i;
        str                                  value;
        str                                  paramName;
        container                            valueCon;
        container                            recIdCon;
        SysModule                            module;
        RecId                                combinationRecId;
        boolean                              newCombination;
        boolean                              found;
        RLedgerTurnoverParamTransLink        paramTransLink;
        Map                                  mapParamValues;
        MapEnumerator                        mapEnumerator;
        RLedgerTurnoverParamHashKey          paramHashKey;

        RLedgerJournalAccountEntryModule  accountEntryModule;
        LedgerDimensionAccount               ledgerDimensionCorr;
        GeneralJournalAccountEntry           accountEntry        = _trans;
        GeneralJournalEntry                  generalJournalEntry = _transHeader;
        container                            paramNames          = this.groupParamNames();

        paramHashKey = new RLedgerTurnoverParamHashKey();

        ttsBegin;

        for (idx = 1; idx <= conlen(paramNames); idx++)
        {
            paramName = conpeek(paramNames, idx);
            switch (paramName)
            {
                case conpeek(paramNames, appModule) :
                    module = this.getTransModule(accountEntry);

                    accountEntryModule = RLedgerJournalAccountEntryModule::find(accountEntry.RecId, _transSplit.RecId);
                    if (! accountEntryModule)
                    {
                        accountEntryModule = this.createEntryModule(accountEntry.RecId,
                                                                    module,
                                                                    _transSplit.RecId ? _transSplit : _trans,
                                                                    _transSplit.RecId);
                    }
                    else
                    {
                        paramTransLink = RLedgerTurnoverParamTransLink::find(accountEntryModule.TableId, accountEntryModule.RecId, true);
                        if (paramTransLink)
                        {
                            mapParamValues = RLedgerTurnoverParamValue::getValues(paramTransLink.ParamValueCombination);
                        }
                    }
                    break;

                case conpeek(paramNames, corrAccount) :
                    if (! mapParamValues)
                    {
                        if (mapTransCorrAccountCache.exists(_trans.RecId))
                        {
                            value = mapTransCorrAccountCache.lookup(_trans.RecId);
                        }
                        else
                        {
                            if (mapLedgerDimensionCorr.exists(_trans.RecId))
                            {
                                ledgerDimensionCorr = mapLedgerDimensionCorr.lookup(_trans.RecId);
                            }
                            else
                            {
                                ledgerDimensionCorr = RLedgerTurnoverTypeLedger::getLedgerDimensionCorrByAccountEntry(accountEntry);
                                mapLedgerDimensionCorr.insert(_trans.RecId, ledgerDimensionCorr);
                            }

                            value = LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(ledgerDimensionCorr);
                            mapTransCorrAccountCache.insert(accountEntry.RecId, value);
                        }
                    }
                    break;

                case conpeek(paramNames, facture) :
                    recIdCon = conNull();

                    if (this.getTransModule(accountEntry) != SysModule::Tax)
                    {
                        value = '';
                        break;
                    }

                    if (! mapTransFactureCache.exists([_trans.RecId, _transSplit.RecId]))
                    {
                        factureSourceRecId = _trans.RecId;
                        factureSplitTransRecId = _transSplit.RecId;

                        switch (this.getTransModule(accountEntry))
                        {
                            case SysModule::Cust :
                                found = this.findFactureModule(accountEntry.GeneralJournalEntry, SysModule::Cust);
                                break;
                            case SysModule::Vend :
                                found = this.findFactureModule(accountEntry.GeneralJournalEntry, SysModule::Vend);
                                break;
                            case SysModule::Employee_RU :
                                found = this.findFactureModule(accountEntry.GeneralJournalEntry, SysModule::Employee_RU);
                                break;
                            default :
                                found = this.findFactureModule(accountEntry.GeneralJournalEntry, SysModule::Ledger);
                        }

                        if (! found)
                        {
                            this.findFactureGeneralJournal(accountEntry.GeneralJournalEntry);
                        }
                    }

                    if (mapTransFactureCache.exists([_trans.RecId, _transSplit.RecId]))
                    {
                        valueCon = mapTransFactureCache.lookup([_trans.RecId, _transSplit.RecId]);
                        for (i = 1; i <= conLen(valueCon); i++)
                        {
                            value       = con2Str(conDel(conPeek(valueCon, i), 1, 1), ', ');
                            recIdCon   += conPeek(conPeek(valueCon, i), 1);
                            paramHashKey.addParamValue(paramName, value);
                        }
                    }
                    break;

                case conpeek(paramNames, transType) :
                    if (! mapParamValues)
                    {
                        value = enum2str(generalJournalEntry.JournalCategory);
                    }
                    break;

                default :
                    if (! mapParamValues)
                    {
                        value = RLedgerTurnoverType::getLedgerDimensionDisplayValue(accountEntry.LedgerDimension, mapDimAttrRecId.lookup(paramName));
                    }
            }

            if (paramName != conpeek(paramNames, facture) &&
                paramName != conpeek(paramNames, appModule))
            {
                if (mapParamValues)
                {
                    if (! mapParamValues.exists(paramName))
                    {
                        throw error("@SYS4081708");
                    }

                    value = con2Str(mapParamValues.lookup(paramName));
                }

                paramHashKey.addParamValue(paramName, value);
            }
        }

        [combinationRecId, newCombination] = RLedgerTurnoverParamValueCombination::findOrCreate(this.reportType(), paramHashKey.getParamStr());

        paramTransLink.ParamValueCombination = combinationRecId;
        if (paramTransLink.RecId)
        {
            paramTransLink.update();
        }
        else
        {
            paramTransLink.RefRecId     = accountEntryModule.RecId;
            paramTransLink.RefTableId   = accountEntryModule.TableId;
            paramTransLink.insert();
        }

        if (newCombination)
        {
            mapEnumerator = paramHashKey.mapParamValues().getEnumerator();
            while (mapEnumerator.moveNext())
            {
                if (mapEnumerator.currentKey() == conpeek(paramNames, facture))
                {
                    for (i = 1; i <= conLen(mapEnumerator.currentValue()); i++)
                    {
                        RLedgerTurnoverParamValue::create(mapEnumerator.currentKey(),
                                                          conPeek(mapEnumerator.currentValue(), i),
                                                          combinationRecId,
                                                          conPeek(recIdCon, i),
                                                          tableNum(FactureJour_RU));
                    }
                }
                else
                {
                    RLedgerTurnoverParamValue::create(mapEnumerator.currentKey(),
                                                      con2Str(mapEnumerator.currentValue()),
                                                      combinationRecId);
                }
            }
        }

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public ClassDescription description()
    {
        return "@SYS4081698";
    }

]]></Source>
			</Method>
			<Method>
				<Name>drillThroughAction</Name>
				<Source><![CDATA[
    public void drillThroughAction(Query _query, int _amountType, TmpRecIdFilter _tmpRecIdFilter)
    {
        GeneralJournalEntry     generalJournalEntry;
        FormRun                 formRun;
        FormDataSource          formDataSource;
        FormComboBoxControl     ctrlShowMode;
        int                     idx;
        QueryBuildDataSource    qbds;
        Args                    args    = new Args();
        Query                   query   = new Query(_query.pack());
        const str ctrlShowModeName = 'ShowTransMode';

        qbds = query.dataSourceTable(tableNum(GeneralJournalAccountEntry));
        qbds = qbds.addDataSource(tableNum(ReasonTableRef));
        qbds.relations(true);
        qbds.joinMode(JoinMode::OuterJoin);

        qbds = query.dataSourceTable(tableNum(GeneralJournalEntry));
        qbds = qbds.addDataSource(tableNum(LedgerEntryJournal));
        qbds.relations(true);
        qbds.joinMode(JoinMode::OuterJoin);

        qbds = query.dataSourceTable(tableNum(GeneralJournalEntry));
        qbds = qbds.addDataSource(tableNum(GeneralJournalEntry_W));
        qbds.relations(true);
        qbds.joinMode(JoinMode::OuterJoin);

        qbds = query.dataSourceTable(tableNum(GeneralJournalAccountEntry));
        qbds = qbds.addDataSource(tableNum(TransactionLog));
        qbds.relations(true);
        qbds.joinMode(JoinMode::OuterJoin);

        qbds = query.dataSourceTable(tableNum(GeneralJournalAccountEntry));
        qbds = qbds.addDataSource(tableNum(LedgerEntry));
        qbds.relations(true);
        qbds.joinMode(JoinMode::OuterJoin);

        qbds = query.dataSourceTable(tableNum(GeneralJournalAccountEntry));
        qbds = qbds.addDataSource(tableNum(FinTag));
        qbds.relations(true);
        qbds.joinMode(JoinMode::OuterJoin);

        qbds = query.dataSourceTable(tableNum(GeneralJournalAccountEntry));
        qbds = qbds.addDataSource(tableNum(GeneralJournalAccountEntry_W));
        qbds.addLink(fieldNum(GeneralJournalAccountEntry, RecId), fieldNum(GeneralJournalAccountEntry_W, GeneralJournalAccountEntry));
        qbds.joinMode(JoinMode::OuterJoin);

        qbds = query.dataSourceTable(tableNum(RLedgerJournalAccountEntryModule));
        if (qbds)
        {
            qbds.joinMode(JoinMode::ExistsJoin);
        }

        args = new Args(this.transForm());
        args.record(generalJournalEntry);
        args.caller(this);

        formRun = classfactory.formRunClass(args);
        formRun.init();

        for (idx = 1; idx <= formRun.dataSourceCount(); idx++)
        {
            if (formRun.dataSource(idx).cursor().TableId == tableNum(GeneralJournalEntry))
            {
                formDataSource = formRun.dataSource(idx);
                formDataSource.query(query);
                break;
            }
        }

        ctrlShowMode = formRun.design().controlName(ctrlShowModeName);
        ctrlShowMode.selection(LedgerBondShowTransMode_RU::ShowAll);

        formRun.run();
        this.addRecIdFilter(formRun, _tmpRecIdFilter);

        formRun.detach();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldAmountCur</Name>
				<Source><![CDATA[
    protected fieldId fieldAmountCur()
    {
        return fieldnum(GeneralJournalAccountEntry, TransactionCurrencyAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldAmountMST</Name>
				<Source><![CDATA[
    protected fieldId fieldAmountMST()
    {
        return fieldnum(GeneralJournalAccountEntry, AccountingCurrencyAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldAmountMSTSec</Name>
				<Source><![CDATA[
    protected fieldId fieldAmountMSTSec()
    {
        return fieldnum(GeneralJournalAccountEntry, ReportingCurrencyAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldCorrection</Name>
				<Source><![CDATA[
    public container fieldCorrection(CurrencyType_RU _currencyType = CurrencyType_RU::Standard)
    {
        return [tableNum(GeneralJournalAccountEntry), fieldnum(GeneralJournalAccountEntry, IsCorrection)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldCurrencyCode</Name>
				<Source><![CDATA[
    public container fieldCurrencyCode()
    {
        return [tablenum(GeneralJournalAccountEntry), fieldnum(GeneralJournalAccountEntry, TransactionCurrencyCode)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldLedgerDimension</Name>
				<Source><![CDATA[
    public container fieldLedgerDimension()
    {
        return [tablenum(GeneralJournalAccountEntry), fieldnum(GeneralJournalAccountEntry, LedgerDimension)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldMainAccount</Name>
				<Source><![CDATA[
    public container fieldMainAccount()
    {
        return [tablenum(MainAccount), fieldnum(MainAccount, MainAccountId)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldOperationsTax</Name>
				<Source><![CDATA[
    public container fieldOperationsTax()
    {
        return [tablenum(GeneralJournalEntry), fieldnum(GeneralJournalEntry, PostingLayer)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldTransDate</Name>
				<Source><![CDATA[
    public container fieldTransDate()
    {
        return [tablenum(GeneralJournalEntry), fieldnum(GeneralJournalEntry, AccountingDate)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFactureGeneralJournal</Name>
				<Source><![CDATA[
    private void findFactureGeneralJournal(GeneralJournalEntryRecId _generalJournalEntryRecId)
    {
        SubledgerVoucherGeneralJournalEntry journalEntry;

        if (! mapTransFactureCache)
        {
            return;
        }

        while select journalEntry
            where journalEntry.GeneralJournalEntry == _generalJournalEntryRecId
        {
            this.findFacture(journalEntry.AccountingDate, journalEntry.Voucher);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFactureModule</Name>
				<Source><![CDATA[
    private boolean findFactureModule(GeneralJournalEntryRecId _generalJournalEntryRecId, SysModule _module)
    {
        boolean                             ret;
        boolean                             notFound;
        CustTrans                           custTrans;
        VendTrans                           vendTrans;
        EmplTrans_RU                        emplTrans;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;

        if (! mapTransFactureCache)
        {
            return true;
        }

        if (_module == SysModule::Cust || _module == SysModule::Ledger)
        {
            while select * from custTrans
                exists join subledgerVoucherGeneralJournalEntry
                    where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == _generalJournalEntryRecId
                        && subledgerVoucherGeneralJournalEntry.Voucher             == custTrans.Voucher
                        && subledgerVoucherGeneralJournalEntry.AccountingDate      == custTrans.TransDate
            {
                ret = this.findFactureInvoice(custTrans);
                if (! ret)
                {
                    notFound = true;
                }
            }
        }

        if (_module == SysModule::Vend || _module == SysModule::Ledger)
        {
            while select * from vendTrans
                exists join subledgerVoucherGeneralJournalEntry
                    where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == _generalJournalEntryRecId
                        && subledgerVoucherGeneralJournalEntry.Voucher             == vendTrans.Voucher
                        && subledgerVoucherGeneralJournalEntry.AccountingDate      == vendTrans.TransDate
            {
                ret = this.findFactureInvoice(vendTrans);
                if (! ret)
                {
                    notFound = true;
                }
            }
        }

        if (_module == SysModule::Employee_RU || _module == SysModule::Ledger)
        {
            while select * from emplTrans
                exists join subledgerVoucherGeneralJournalEntry
                    where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == _generalJournalEntryRecId
                        && subledgerVoucherGeneralJournalEntry.Voucher             == emplTrans.Voucher
                        && subledgerVoucherGeneralJournalEntry.AccountingDate      == emplTrans.TransDate
            {
                ret = this.findFactureAdvReport(emplTrans);
                if (! ret)
                {
                    notFound = true;
                }
            }
        }

        return ret && ! notFound;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransModule</Name>
				<Source><![CDATA[
    private SysModule getTransModule(GeneralJournalAccountEntry _trans)
    {
        SysModule ret;

        switch (_trans.PostingType)
        {
            case LedgerPostingType::CustBalance             :
            case LedgerPostingType::CustSettlement          :
            case LedgerPostingType::CustCollectionLetterFee :
                ret = SysModule::Cust;
                break;
            case LedgerPostingType::VendBalance             :
            case LedgerPostingType::VendSettlement          :
                ret = SysModule::Vend;
                break;
            case LedgerPostingType::EmplBalance_RU          :
                ret = SysModule::Employee_RU;
                break;
            case LedgerPostingType::Bank                    :
                ret = SysModule::Bank;
                break;
            case LedgerPostingType::FixedAssetsDebit        :
            case LedgerPostingType::FixedAssetsCredit       :
                ret = SysModule::FixedAssets;
                break;
            case LedgerPostingType::RCash                   :
                ret = SysModule::RCash;
                break;
            case LedgerPostingType::Tax                     :
            case LedgerPostingType::TaxReport               :
                ret = SysModule::Tax;
                break;
            default :
                ret = SysModule::Ledger;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupKeyData</Name>
				<Source><![CDATA[
    public container groupKeyData(container _key)
    {
        return [fieldnum(GeneralJournalAccountEntry, RecId)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupParamDefault</Name>
				<Source><![CDATA[
    public container groupParamDefault()
    {
        return this.groupParamNames();
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupParamLabels</Name>
				<Source><![CDATA[
    public container groupParamLabels(container _key)
    {
        int         idx;
        container   paramLabels;

        for (idx = 1; idx <= conLen(_key); idx++)
        {
            paramLabels = conins(paramLabels, conlen(paramLabels) + 1, [conpeek(_key, idx)]);
        }

        return paramLabels;
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupParamNames</Name>
				<Source><![CDATA[
    public container groupParamNames()
    {
        DimensionAttributeSetItem   dimAttrSetItem;
        DimensionAttribute          dimAttr;

        if (groupParamNames)
        {
            return groupParamNames;
        }

        groupParamNames = [appModuleParamName,
                           corrAccountParamName,
                           factureParamName,
                           transTypeParamName];

        // Add all dimensions from the current ledger
        while select DimensionAttribute from dimAttrSetItem
            where dimAttrSetItem.DimensionAttributeSet == DimensionCache::getDimensionAttributeSetForLedger()
        join Name, RecId from dimAttr
            where dimAttr.RecId == dimAttrSetItem.DimensionAttribute
        {
            groupParamNames += dimAttr.Name;
            mapDimAttrRecId.insert(dimAttr.Name, dimAttr.RecId);
        }

        return groupParamNames;
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupParamValueName</Name>
				<Source><![CDATA[
    public Name groupParamValueName(Name _paramName, container _paramValue, Common _common = null)
    {
        Name ret;

        switch (_paramName)
        {
            case conpeek(this.groupParamNames(), appModule) :
            case conpeek(this.groupParamNames(), facture)   :
            case conpeek(this.groupParamNames(), transType) :
                ret = super(_paramName, _paramValue);
                break;

            case this.keyMainAccount()                         :
            case conpeek(this.groupParamNames(), corrAccount) :
                ret = MainAccount::getLocalizedNameByMainAccountId(conPeek(_paramValue, 1));
                break;

            default :
                ret = RLedgerTurnoverType::getLedgerDimensionAttributeName(_common.(conPeek(this.fieldLedgerDimension(), 2)),
                                                                           _paramName,
                                                                           conPeek(_paramValue, 1));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupParamValues</Name>
				<Source><![CDATA[
    public container groupParamValues(Common    _trans,
                                      container _key,
                                      Common    _transHeader = null,
                                      Common    _transSplit  = null)
    {
        int                         idx, i;
        boolean                     found;
        container                   value, valueList;
        container                   paramValues;
        str                         paramName;
        MainAccountNum              corrMainAccount;
        LedgerDimensionAccount      ledgerDimensionCorr;
        GeneralJournalEntry         generalJournalEntry        = _transHeader;
        GeneralJournalAccountEntry  generalJournalAccountEntry = _trans;
        container                   paramNames                 = this.groupParamNames();

        for (idx = 1; idx <= conlen(_key); idx++)
        {
            paramName = conpeek(_key, idx);
            switch (paramName)
            {
                case conpeek(paramNames, appModule) :
                    value = [enum2str(this.getTransModule(generalJournalAccountEntry))];
                    break;

                case conpeek(paramNames, corrAccount) :
                    if (mapTransCorrAccountCache.exists(_trans.RecId))
                    {
                        corrMainAccount = mapTransCorrAccountCache.lookup(_trans.RecId);
                    }
                    else
                    {
                        if (mapLedgerDimensionCorr.exists(_trans.RecId))
                        {
                            ledgerDimensionCorr = mapLedgerDimensionCorr.lookup(_trans.RecId);
                        }
                        else
                        {
                            ledgerDimensionCorr = RLedgerTurnoverTypeLedger::getLedgerDimensionCorrByAccountEntry(generalJournalAccountEntry);
                            mapLedgerDimensionCorr.insert(_trans.RecId, ledgerDimensionCorr);
                        }

                        corrMainAccount = LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(ledgerDimensionCorr);
                        mapTransCorrAccountCache.insert(generalJournalAccountEntry.RecId, corrMainAccount);
                    }

                    value = [corrMainAccount];
                    break;

                case conpeek(paramNames, facture) :
                    if (this.getTransModule(generalJournalAccountEntry) != SysModule::Tax)
                    {
                        value = [''];
                        break;
                    }

                    if (! mapTransFactureCache.exists([_trans.RecId, _transSplit.RecId]))
                    {
                        factureSourceRecId = _trans.RecId;
                        factureSplitTransRecId = _transSplit.RecId;

                        found = this.findFactureModule(generalJournalAccountEntry.GeneralJournalEntry, SysModule::Ledger);

                        if (! found)
                        {
                            this.findFactureGeneralJournal(generalJournalAccountEntry.GeneralJournalEntry);
                        }
                    }

                    if (mapTransFactureCache.exists([_trans.RecId, _transSplit.RecId]))
                    {
                        value = mapTransFactureCache.lookup([_trans.RecId, _transSplit.RecId]);
                        for (i = 1; i <= conLen(value); i++)
                        {
                            valueList += con2Str(conDel(conPeek(value, i), 1, 1), ', ');
                        }
                    }
                    value = [con2Str(valueList, newLine)];
                    break;

                case conpeek(paramNames, transType) :
                    value = [enum2str(generalJournalEntry.JournalCategory)];
                    break;

                default :
                    value = [ RLedgerTurnoverType::getLedgerDimensionDisplayValue(generalJournalAccountEntry.LedgerDimension, mapDimAttrRecId.lookup(conpeek(_key, idx))) ];
            }

            paramValues = conins(paramValues, conlen(paramValues) + 1, value);
        }

        return paramValues;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransIncluded</Name>
				<Source><![CDATA[
    public boolean isTransIncluded(Common           _trans,
                                   Common           _subtrans,
                                   CurrencyType_RU  _currencyType,
                                   TransDate        _fromDate = dateNull(),
                                   TransDate        _toDate   = dateNull())
    {
        MainAccountNum             corrMainAccount;
        LedgerDimensionAccount     ledgerDimensionCorr;
        GeneralJournalAccountEntry generalJournalAccountEntry = _trans;

        if (! super(_trans, _subtrans, _currencyType, _fromDate, _toDate))
        {
            return false;
        }

        if (offsetAccountNumSet.elements())
        {
            if (mapTransCorrAccountCache.exists(_trans.RecId))
            {
                corrMainAccount = mapTransCorrAccountCache.lookup(_trans.RecId);
            }
            else
            {
                if (mapLedgerDimensionCorr.exists(_trans.RecId))
                {
                    ledgerDimensionCorr = mapLedgerDimensionCorr.lookup(_trans.RecId);
                }
                else
                {
                    ledgerDimensionCorr = RLedgerTurnoverTypeLedger::getLedgerDimensionCorrByAccountEntry(generalJournalAccountEntry);
                    mapLedgerDimensionCorr.insert(_trans.RecId, ledgerDimensionCorr);
                }

                corrMainAccount = LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(ledgerDimensionCorr);
                mapTransCorrAccountCache.insert(generalJournalAccountEntry.RecId, corrMainAccount);
            }

            if (! offsetAccountNumSet.in(corrMainAccount))
            {
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>keyMainAccount</Name>
				<Source><![CDATA[
    public str keyMainAccount()
    {
        return DimensionAttribute::find(DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount)).Name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        super();

        mapTransCorrAccountCache = new Map(Types::Int64, Types::String);
        mapLedgerDimensionCorr   = new Map(Types::Int64, Types::Int64);
    }

]]></Source>
			</Method>
			<Method>
				<Name>query</Name>
				<Source><![CDATA[
    public container query()
    {
        Query query = new Query();
        QueryBuildDataSource qBdAccountEntry,
                             qBdEntry,
                             qBdFiscalPeriod;
        QueryBuildRange      qBr;

        // Entry
        qBdEntry = query.addDataSource(tablenum(GeneralJournalEntry));

        qBr = qBdEntry.addRange(fieldnum(GeneralJournalEntry, Ledger));
        qBr.value(queryValue(Ledger::current()));
        qBr.status(RangeStatus::Hidden);

        qBr = qBdEntry.addRange(fieldnum(GeneralJournalEntry, AccountingDate));
        qBr.status(RangeStatus::Hidden);

        qBr = qBdEntry.addRange(fieldnum(GeneralJournalEntry, JournalNumber));

        qBdFiscalPeriod = qBdEntry.addDataSource(tableNum(FiscalCalendarPeriod));
        qBdFiscalPeriod.fetchMode(QueryFetchMode::One2One);
        qBdFiscalPeriod.addLink(fieldNum(GeneralJournalEntry, FiscalCalendarPeriod), fieldNum(FiscalCalendarPeriod, RecId));

        qBr = qBdFiscalPeriod.addRange(fieldnum(FiscalCalendarPeriod, Type));
        qBr.status(RangeStatus::Hidden);
        qBr.value(queryRange(FiscalPeriodType::Operating, FiscalPeriodType::Closing));

        qBr = qBdFiscalPeriod.addRange(fieldnum(FiscalCalendarPeriod, StartDate));

        qBdAccountEntry = qBdEntry.addDataSource(tableNum(GeneralJournalAccountEntry));
        qBdAccountEntry.fetchMode(QueryFetchMode::One2One);
        qBdAccountEntry.relations(true);

        qBr = qBdAccountEntry.addRange(fieldnum(GeneralJournalAccountEntry, PostingType));
        qBr.status(RangeStatus::Hidden);
        qBr.value(SysQuery::valueNot(LedgerPostingType::TransferOpeningClosing));

        qBr = qBdAccountEntry.addRange(fieldnum(GeneralJournalAccountEntry, IsCredit));

        // Dim comb
        qBdAccountEntry = qBdAccountEntry.addDataSource(tablenum(DimensionAttributeValueCombination));
        qBdAccountEntry.fetchMode(QueryFetchMode::One2One);
        qBdAccountEntry.relations(true);

        // Main account
        qBdAccountEntry = qBdAccountEntry.addDataSource(tableNum(MainAccount));
        qBdAccountEntry.addLink(fieldNum(DimensionAttributeValueCombination, MainAccount), fieldNum(MainAccount, RecId));
        qBdAccountEntry.fetchMode(QueryFetchMode::One2One);
        qBr = qBdAccountEntry.addRange(fieldNum(MainAccount, MainAccountId));
        qBr.status(RangeStatus::Hidden);

        qBr = qBdAccountEntry.addRange(fieldNum(MainAccount, Type));

        return query.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    public QueryRun queryRun(Query _query, container _key = conNull())
    {
        QueryRun             queryRun;
        QueryBuildDataSource queryDataSource;

        if (conFind(_key, factureParamName))
        {
            isFactureSelected = true;
        }

        queryRun = new queryRun(_query);

        if (tmpMainAccount)
        {
            queryDataSource = queryRun.query().dataSourceTable(tableNum(MainAccount));
            queryDataSource = queryDataSource.addDataSource(tableNum(TmpMainAccount));
            queryDataSource.addLink(fieldNum(MainAccount, RecId), fieldNum(TmpMainAccount, MainAccount));
            queryDataSource.joinMode(JoinMode::ExistsJoin);
            queryRun.setCursor(tmpMainAccount);
        }

        if (isFactureSelected && ! updateMode)
        {
            queryDataSource = queryRun.query().dataSourceTable(tableNum(GeneralJournalAccountEntry));

            findOrCreateRange_W(queryDataSource,
                                fieldNum(GeneralJournalAccountEntry, PostingType),
                                con2Str([LedgerPostingType::Tax, LedgerPostingType::TaxReport]));
        }

        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reportType</Name>
				<Source><![CDATA[
    protected RLedgerTurnoverSheetType reportType()
    {
        return RLedgerTurnoverSheetType::LedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showBalanceTrans</Name>
				<Source><![CDATA[
    public boolean showBalanceTrans()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showOrigin</Name>
				<Source><![CDATA[
    public boolean showOrigin()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitTrans</Name>
				<Source><![CDATA[
    public Common splitTrans(Common _trans)
    {
        SalesPurchBookDataMap_RU                processLogTrans;
        SalesPurchBookVATProcessLogTransOper_RU processLogTransOper;
        Common                                  processLogTable;
        SalesBookVATProcessLogTable_RU          salesProcessLogTable;
        PurchBookVATProcessLogTable_RU          purchProcessLogTable;
        FactureJour_RU                          factureJour;
        FieldId                                 fieldVoucher;
        FieldId                                 fieldTransDate;
        int                                     sign;
        real                                    factor;
        SubledgerVoucherGeneralJournalEntry     subledgerVoucherGeneralJournalEntry;
        GeneralJournalAccountEntry              accountEntryTmp, accountEntryTmpSum;
        GeneralJournalAccountEntry              generalJournalAccountEntry = _trans;
        LedgerDimensionAccount                  ledgerDimensionCorr;
        LedgerDimensionAccount                  ledgerDimension;
        LedgerDimensionAccount                  offsetLedgerDimension;

        void initBuffers(ModuleCustVend _module)
        {
            switch (_module)
            {
                case ModuleCustVend::Cust :
                    processLogTable     = salesProcessLogTable;
                    processLogTrans     = new DictTable(tablenum(SalesBookVATProcessLogTrans_RU)).makeRecord();
                    processLogTransOper = new DictTable(tablenum(SalesBookVATProcessLogTransOper_RU)).makeRecord();
                    fieldVoucher        = fieldnum(SalesBookVATProcessLogTable_RU, Voucher);
                    fieldTransDate      = fieldnum(SalesBookVATProcessLogTable_RU, TransDate);
                    break;
                case ModuleCustVend::Vend :
                    processLogTable     = purchProcessLogTable;
                    processLogTrans     = new DictTable(tablenum(PurchBookVATProcessLogTrans_RU)).makeRecord();
                    processLogTransOper = new DictTable(tablenum(PurchBookVATProcessLogTransOper_RU)).makeRecord();
                    fieldVoucher        = fieldnum(PurchBookVATProcessLogTable_RU, Voucher);
                    fieldTransDate      = fieldnum(PurchBookVATProcessLogTable_RU, TransDate);
                    break;
            }
        }

        if (! isFactureSelected || this.getTransModule(generalJournalAccountEntry) != SysModule::Tax)
        {
            return super(_trans);
        }

        accountEntryTmp.setTmp();

        buf2Buf(generalJournalAccountEntry, accountEntryTmp);

        while select subledgerVoucherGeneralJournalEntry
            where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalAccountEntry.GeneralJournalEntry
        {
            select firstonly salesProcessLogTable
                where salesProcessLogTable.Voucher   == subledgerVoucherGeneralJournalEntry.Voucher &&
                      salesProcessLogTable.TransDate == subledgerVoucherGeneralJournalEntry.AccountingDate;

            if (salesProcessLogTable)
            {
                initBuffers(ModuleCustVend::Cust);
            }
            else
            {
                select firstonly purchProcessLogTable
                    where purchProcessLogTable.Voucher   == subledgerVoucherGeneralJournalEntry.Voucher &&
                          purchProcessLogTable.TransDate == subledgerVoucherGeneralJournalEntry.AccountingDate;

                if (purchProcessLogTable)
                {
                    initBuffers(ModuleCustVend::Vend);
                }
            }

            if (! processLogTable)
            {
                continue;
            }

            if (! ledgerDimensionCorr)
            {
                if (mapLedgerDimensionCorr.exists(_trans.RecId))
                {
                    ledgerDimensionCorr = mapLedgerDimensionCorr.lookup(_trans.RecId);
                }
                else
                {
                    ledgerDimensionCorr = RLedgerTurnoverTypeLedger::getLedgerDimensionCorrByAccountEntry(generalJournalAccountEntry);
                    mapLedgerDimensionCorr.insert(_trans.RecId, ledgerDimensionCorr);
                }
            }

            while select processLogTransOper
                order by RefRecId
                where  processLogTransOper.LogTableRefRecId  == processLogTable.RecId                   &&
                     ((processLogTransOper.TaxAmount > 0 && ! generalJournalAccountEntry.IsCorrection)  ||
                      (processLogTransOper.TaxAmount < 0 &&   generalJournalAccountEntry.IsCorrection)) &&
                       processLogTransOper.Blocked           == NoYes::No                               &&
                       processLogTransOper.BlockedAuto       == NoYes::No                               &&
                       processLogTransOper.CanceledRefRecId  == 0
                join processLogTrans
                    where processLogTrans.RecId == processLogTransOper.RefRecId
            {
                ledgerDimension       = LedgerDimensionFacade::serviceCreateLedgerDimension(processLogTransOper.LedgerDimension, processLogTransOper.DefaultDimension);
                offsetLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(processLogTransOper.OffsetLedgerDimension, processLogTransOper.DefaultDimension);

                if (! ((generalJournalAccountEntry.LedgerDimension  == ledgerDimension        &&
                        ledgerDimensionCorr                         == offsetLedgerDimension) ||
                       (generalJournalAccountEntry.LedgerDimension  == offsetLedgerDimension  &&
                        ledgerDimensionCorr                         == ledgerDimension)))
                {
                    continue;
                }

                sign = (generalJournalAccountEntry.LedgerDimension == ledgerDimension) ? 1 : -1;
                accountEntryTmp.AccountingCurrencyAmount = sign * processLogTransOper.TaxAmount;

                factor = accountEntryTmp.AccountingCurrencyAmount / generalJournalAccountEntry.AccountingCurrencyAmount;
                accountEntryTmp.TransactionCurrencyAmount = CurrencyExchangeHelper::amount(factor * generalJournalAccountEntry.TransactionCurrencyAmount, generalJournalAccountEntry.TransactionCurrencyCode);
                accountEntryTmp.ReportingCurrencyAmount   = CurrencyExchangeHelper::amount(factor * generalJournalAccountEntry.ReportingCurrencyAmount, CompanyInfoHelper::secondaryCurrency_RU());
                accountEntryTmp.insert();

                factureSourceRecId = generalJournalAccountEntry.RecId;
                factureSplitTransRecId = accountEntryTmp.RecId;

                if (factureJour.FactureId         != processLogTrans.FactureID   ||
                    factureJour.FactureDate       != processLogTrans.FactureDate ||
                    factureJour.FactureExternalId != processLogTrans.FactureExternalId)
                {
                    select firstonly factureJour
                        where factureJour.FactureId         == processLogTrans.FactureID   &&
                                factureJour.FactureDate       == processLogTrans.FactureDate &&
                                factureJour.FactureExternalId == processLogTrans.FactureExternalId;
                }

                if (factureJour)
                {
                    this.addToFactureMap(factureJour);
                }
            }
        }

        if (accountEntryTmp.RecId)
        {
            accountEntryTmpSum.setTmp();
            accountEntryTmpSum.setTmpData(accountEntryTmp);

            select sum(TransactionCurrencyAmount),
                   sum(AccountingCurrencyAmount),
                   sum(ReportingCurrencyAmount) from accountEntryTmpSum;

            generalJournalAccountEntry.TransactionCurrencyAmount    -= accountEntryTmpSum.TransactionCurrencyAmount;
            generalJournalAccountEntry.AccountingCurrencyAmount     -= accountEntryTmpSum.AccountingCurrencyAmount;
            generalJournalAccountEntry.ReportingCurrencyAmount      -= accountEntryTmpSum.ReportingCurrencyAmount;

            if (generalJournalAccountEntry.TransactionCurrencyAmount ||
                generalJournalAccountEntry.AccountingCurrencyAmount  ||
                generalJournalAccountEntry.ReportingCurrencyAmount)
            {
                buf2Buf(generalJournalAccountEntry, accountEntryTmp);
                accountEntryTmp.insert();
            }
        }

        return accountEntryTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transDetailLabels</Name>
				<Source><![CDATA[
    public container transDetailLabels()
    {
        return ["@SYS7402", "@SYS318716", "@SYS98540", "@SYS2587", "@SYS13566"];
    }

]]></Source>
			</Method>
			<Method>
				<Name>transDetails</Name>
				<Source><![CDATA[
    public container transDetails(Common _trans, Common _transHeader = null)
    {
        GeneralJournalEntry         generalJournalEntry        = _transHeader;
        GeneralJournalAccountEntry  generalJournalAccountEntry = _trans;

        return [generalJournalEntry.AccountingDate,
                generalJournalEntry.JournalNumber,
                generalJournalEntry.DocumentNumber,
                generalJournalEntry.DocumentDate,
                generalJournalAccountEntry.Text,
                generalJournalAccountEntry.RecId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>transForm</Name>
				<Source><![CDATA[
    protected str transForm()
    {
        return formstr(LedgerTransVoucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>transHeaderTableId</Name>
				<Source><![CDATA[
    public TableId transHeaderTableId()
    {
        return tablenum(GeneralJournalEntry);
    }

]]></Source>
			</Method>
			<Method>
				<Name>transKeyData</Name>
				<Source><![CDATA[
    public container transKeyData()
    {
        return this.groupKeyData(connull());
    }

]]></Source>
			</Method>
			<Method>
				<Name>transTableId</Name>
				<Source><![CDATA[
    public TableId transTableId()
    {
        return tablenum(GeneralJournalAccountEntry);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionCorrByAccountEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the offset ledger dimension.
    /// </summary>
    /// <param name="_accountEntry">
    /// The <c>GeneralJournalAccountEntry</c> table buffer.
    /// </param>
    /// <returns>
    /// The offset ledger dimension.
    /// </returns>
    static LedgerDimensionAccount getLedgerDimensionCorrByAccountEntry(GeneralJournalAccountEntry _accountEntry)
    {
        GeneralJournalAccountEntry   offsetAccountEntry;
        GeneralJournalAccountEntry_W offsetAccountEntryW;
        GeneralJournalAccountEntry_W accountEntryW;

        select firstOnly LedgerDimension from offsetAccountEntry
            where offsetAccountEntry.GeneralJournalEntry == _accountEntry.GeneralJournalEntry
               && offsetAccountEntry.IsCredit != _accountEntry.IsCredit
        exists join offsetAccountEntryW
            where offsetAccountEntryW.GeneralJournalAccountEntry == offsetAccountEntry.RecId
               && offsetAccountEntryW.BondBatchTrans_RU
        exists join TableId from accountEntryW
            where accountEntryW.GeneralJournalAccountEntry == _accountEntry.RecId
               && accountEntryW.BondBatchTrans_RU == offsetAccountEntryW.BondBatchTrans_RU;

        return offsetAccountEntry.LedgerDimension;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>