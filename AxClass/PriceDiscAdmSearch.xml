<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PriceDiscAdmSearch</Name>
	<SourceCode>
		<Declaration><![CDATA[
class PriceDiscAdmSearch extends RunBase
{
    QueryRun                    inventQueryRun, inventModuleQueryRun, custQueryRun, vendQueryRun;
    Query                       qCust, qVend, qInvent, qInventModule;

    FromDate                    fromDate;
    ToDate                      toDate;

    CurrencyCode                currencyCode;
    SalesGenericCurrency        genericCurrency;

    PriceDiscJournalNum         journalNum;
    InventVendCust              type;

    TmpPriceDiscAdmSearch                   discAdmSearchVendor;
    TmpPriceDiscAdmSearch                   discAdmSearchCustomer;
    TmpPriceDiscAdmSearch                   discAdmSearchInvent;
    PriceDiscAdmSearchTmpPriceTypeCriteria  discPriceTypeCriteria;
    PriceDiscAdmSearchTmpPriceTypeCriteria  discPriceTypeCriteriaAll;
    RecordInsertList                        insertList;
    PriceDiscAdmTrans                       priceDiscAdmTransIns;
    PriceDiscAdmTable                       priceDiscAdmTable;
    PriceDiscTableRefTmp                    priceDiscTableRefTmp;
    PriceDiscAdmTrans                       priceDiscAdmTransCheckDup;
    PriceDiscTable                          priceDiscTable;

    container conPriceTypeCriteria;

    #define.CurrentVersion(7)
    #localmacro.CurrentList
        fromDate,
        toDate,
        currencyCode,
        genericCurrency,
        discAdmSearchVendor,
        discAdmSearchCustomer,
        discAdmSearchInvent,
        discPriceTypeCriteria,
        conPriceTypeCriteria,
        journalNum
    #endmacro

        // <GEERU>
        #ISOCountryRegionCodes
        boolean countryRegion_RU;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    Object  dialog(DialogRunbase _dialog = null, boolean _forceOnClient = false)
        {
            DialogRunbase   dialog = Dialog::newFormnameRunbase(formStr(PriceDiscAdmSearch),this);
            dialog = this.dialogInternal(dialog);
            return dialog;
        }

]]></Source>
			</Method>
			<Method>
				<Name>dialogClosedWithOk</Name>
				<Source><![CDATA[
    public void dialogClosedWithOk(Object _dialog)
        {
            if (!PriceDiscAdmTable::emptyJournal(journalNum))
            {
                Integer  deleteJournal = Box::yesNoCancel(strFmt("@SYS58999", journalNum), 1);
                switch (deleteJournal)
                {
                    case DialogButton::Yes      :
                    {
                        PriceDiscAdmTable::deleteJournal(journalNum);
                        break;
                    }

                case DialogButton::Cancel   :
                    return;
                }
            }

            super(_dialog);
        }

]]></Source>
			</Method>
			<Method>
				<Name>findPurchPriceDisc</Name>
				<Source><![CDATA[
    /// <summary>
        ///     Determines whether purchase prices and discounts should be transferred to the journal.
        /// </summary>
        /// <returns>
        ///     true if purchase prices and discounts should be transferred; otherwise false.
        /// </returns>
        public boolean findPurchPriceDisc()
        {
            return discAdmSearchVendor.AccountCode == PriceDiscPartyCodeType::All
            || (discAdmSearchVendor.AccountRelation
                && (discAdmSearchVendor.AccountCode == PriceDiscPartyCodeType::Table
                || discAdmSearchVendor.AccountCode == PriceDiscPartyCodeType::GroupId));
        }

]]></Source>
			</Method>
			<Method>
				<Name>findSalesPriceDisc</Name>
				<Source><![CDATA[
    /// <summary>
        ///     Determines whether the sales prices and discounts should be transferred to the journal.
        /// </summary>
        /// <returns>
        ///     true if the sales prices and discounts should be transferred; otherwise false.
        /// </returns>
        public boolean findSalesPriceDisc()
        {
            return discAdmSearchCustomer.AccountCode == PriceDiscPartyCodeType::All
            || (discAdmSearchCustomer.AccountRelation
                && (discAdmSearchCustomer.AccountCode == PriceDiscPartyCodeType::Table
                || discAdmSearchCustomer.AccountCode == PriceDiscPartyCodeType::GroupId));
        }

]]></Source>
			</Method>
			<Method>
				<Name>checkPriceTypeCriteriaIsSelected</Name>
				<Source><![CDATA[
    /// <summary>
        ///     Determines if the given <c>PriceType</c> was selected as search criteria.
        /// </summary>
        /// <returns>
        ///     true  if the given <c>PriceType</c> was selected as search criteria; otherwise false.
        /// </returns>
        protected boolean checkPriceTypeCriteriaIsSelected(PriceType _priceType)
        {
            if(!_priceType)
            {
                return false;
            }

            select firstonly RecId from discPriceTypeCriteria
            where discPriceTypeCriteria.PriceType == _priceType
            && discPriceTypeCriteria.IsChecked;

            return discPriceTypeCriteria.RecId != 0;
        }

]]></Source>
			</Method>
			<Method>
				<Name>initJournalNum</Name>
				<Source><![CDATA[
    void  initJournalNum(PriceDiscJournalNum  _journalNum)
        {
            journalNum = _journalNum;
        }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    /// <summary>
        ///    Initializes the internal variables.
        /// </summary>
        /// <remarks>
        ///    This method is called when no <c>SysLastValue</c> record can be found when calling the
        ///    <c>SysLastValue.GetLast</c> method. Remember to call the <c>super</c> method.
        /// </remarks>
        public void initParmDefault()
        {
            super();

            qInvent = new Query(queryStr(PriceDiscAdmSearchInvent));
            qVend   = new Query(queryStr(PriceDiscAdmSearchVend));
            qCust   = new Query(queryStr(PriceDiscAdmSearchCust));

            qInventModule = new Query();
            qInventModule.addDataSource(tableNum(InventTableModule));

            custQueryRun    = new QueryRun(qCust);
            vendQueryRun    = new QueryRun(qVend);
            inventQueryRun  = new QueryRun(qInvent);
            inventModuleQueryRun = new QueryRun(qInventModule);
        }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void  new()
        {
            super();

            this.initParmDefault();
            insertList = new RecordInsertList(tableNum(PriceDiscAdmTrans), true, true, true);
            // <GEERU>
            countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
            // </GEERU>
        }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container  pack()
        {
            return [#CurrentVersion,#CurrentList];
        }

]]></Source>
			</Method>
			<Method>
				<Name>parmCurrencyCode</Name>
				<Source><![CDATA[
    public CurrencyCode parmCurrencyCode(CurrencyCode _currencyCode = currencyCode)
        {
            currencyCode = _currencyCode;

            return currencyCode;
        }

]]></Source>
			</Method>
			<Method>
				<Name>parmFromDate</Name>
				<Source><![CDATA[
    public FromDate parmFromDate(FromDate _fromDate = fromDate)
        {
            fromDate = _fromDate;

            return fromDate;
        }

]]></Source>
			</Method>
			<Method>
				<Name>parmGenericCurrency</Name>
				<Source><![CDATA[
    public boolean parmGenericCurrency(boolean _genericCurrency = genericCurrency)
        {
            genericCurrency = _genericCurrency;

            return genericCurrency;
        }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalNum</Name>
				<Source><![CDATA[
    [Hookable(false)]
        public PriceDiscJournalNum parmJournalNum()
        {
           return journalNum;
        }

]]></Source>
			</Method>
			<Method>
				<Name>parmPriceDiscTableRefTmp</Name>
				<Source><![CDATA[
    [Hookable(false)]
        public PriceDiscTableRefTmp parmPriceDiscTableRefTmp()
        {
            return priceDiscTableRefTmp;
        }

]]></Source>
			</Method>
			<Method>
				<Name>parmPriceDiscAdmTrans</Name>
				<Source><![CDATA[
    [Hookable(false)]
        public final PriceDiscAdmTrans parmPriceDiscAdmTrans()
        {
            return priceDiscAdmTransIns;
        }

]]></Source>
			</Method>
			<Method>
				<Name>parmTmpPriceDiscAdmSearchCust</Name>
				<Source><![CDATA[
    public TmpPriceDiscAdmSearch parmTmpPriceDiscAdmSearchCust(TmpPriceDiscAdmSearch _discAdmSearchCustomer = discAdmSearchCustomer)
        {
            discAdmSearchCustomer = _discAdmSearchCustomer;

            return discAdmSearchCustomer;
        }

]]></Source>
			</Method>
			<Method>
				<Name>parmTmpPriceDiscAdmSearchInvent</Name>
				<Source><![CDATA[
    public TmpPriceDiscAdmSearch parmTmpPriceDiscAdmSearchInvent(TmpPriceDiscAdmSearch _discAdmSearchInvent = discAdmSearchInvent)
        {
            discAdmSearchInvent = _discAdmSearchInvent;

            return discAdmSearchInvent;
        }

]]></Source>
			</Method>
			<Method>
				<Name>parmTmpPriceDiscAdmSearchVend</Name>
				<Source><![CDATA[
    public TmpPriceDiscAdmSearch parmTmpPriceDiscAdmSearchVend(TmpPriceDiscAdmSearch _discAdmSearchVendor = discAdmSearchVendor)
        {
            discAdmSearchVendor = _discAdmSearchVendor;

            return discAdmSearchVendor;
        }

]]></Source>
			</Method>
			<Method>
				<Name>parmDiscPriceTypeCriteria</Name>
				<Source><![CDATA[
    [Hookable(false)]
         public final PriceDiscAdmSearchTmpPriceTypeCriteria parmDiscPriceTypeCriteria()
         {
             return discPriceTypeCriteria;
         }

]]></Source>
			</Method>
			<Method>
				<Name>parmPriceTypeCriteria</Name>
				<Source><![CDATA[
    public container parmPriceTypeCriteria(container _conPriceTypeCriteria = conPriceTypeCriteria)
        {
            conPriceTypeCriteria = _conPriceTypeCriteria;

            this.populateDiscPriceTypeCriteria();

            return conPriceTypeCriteria;
        }

]]></Source>
			</Method>
			<Method>
				<Name>parmToDate</Name>
				<Source><![CDATA[
    ToDate parmToDate(ToDate _toDate = toDate)
        {
            toDate = _toDate;

            return toDate;
        }

]]></Source>
			</Method>
			<Method>
				<Name>processCust</Name>
				<Source><![CDATA[
    void  processCust()
        {
            if (!discAdmSearchCustomer.AccountRelation && discAdmSearchCustomer.AccountCode == PriceDiscPartyCodeType::Table)
            {
                return;
            }

            CustTable  custTable;
            QueryBuildDataSource qbds;

            switch (discAdmSearchCustomer.AccountCode)
            {
                case PriceDiscPartyCodeType::Table:
                    qbds = qCust.dataSourceTable(tableNum(CustTable));
                    qbds.findRange(fieldNum(CustTable,AccountNum)).value(discAdmSearchCustomer.AccountRelation);
                    custQueryRun = new QueryRun(qCust);

                    //for each customer matching the query range
                    while (custQueryRun.next())
                    {
                        custTable = custQueryRun.get(tableNum(CustTable));

                        this.searchCustomerVendorPriceDiscAccount(custTable.AccountNum 
                        ,ModuleInventCustVend::Cust
                        // <GEERU>
                        ,discAdmSearchCustomer.AgreementHeaderExt_RU
                        // </GEERU>
                        );

                        if (discAdmSearchCustomer.IncludeAdditionalRelations)
                        {
                            this.searchCustGroups(
                                custTable,
                                discAdmSearchCustomer.AgreementHeaderExt_RU);
                        }
                    }

                    if (discAdmSearchCustomer.IncludeAdditionalRelations)
                    {
                        this.searchCustVendPriceDiscAll(ModuleInventCustVend::Cust);
                    }
                    break;

                case PriceDiscPartyCodeType::GroupId:
                    PriceType custPriceType = PriceGroupTypeTradeAgreementMapping::newPriceGroupTypeTradeAgreementMapping(discAdmSearchCustomer.PriceDiscGroupType).priceDiscType(ModuleInventCustVend::Cust);
                    this.searchCustVendPriceDiscGroup(
                        custPriceType,
                        ModuleInventCustVend::Cust,
                        discAdmSearchCustomer.PriceDiscGroupType,
                        discAdmSearchCustomer.AccountRelation);

                    if (discAdmSearchCustomer.IncludeAdditionalRelations)
                    {
                        qbds = qCust.dataSourceTable(tableNum(CustTable));

                        qbds.addRange(PriceTypeTradeAgreementMapping::newPriceTypeTradeAgreementMapping(custPriceType).custVendTableField()).value(discAdmSearchCustomer.AccountRelation);

                        custQueryRun = new QueryRun(qCust);

                        while (custQueryRun.next())
                        {
                            custTable = custQueryRun.get(tableNum(CustTable));

                            if (discAdmSearchCustomer.AccountRelation
                            || this.validateCustTablePriceDiscFields(custTable))
                            {
                                this.searchCustomerVendorPriceDiscAccount(custTable.AccountNum, ModuleInventCustVend::Cust);
                            }
                        }

                        this.searchCustVendPriceDiscAll(ModuleInventCustVend::Cust);
                    }
                    break;

                case PriceDiscPartyCodeType::All:
                    this.searchCustVendPriceDiscAll(ModuleInventCustVend::Cust);

                    if (discAdmSearchCustomer.IncludeAdditionalRelations)
                    {
                        this.searchCustAllAdditionalRelations(discAdmSearchCustomer.AgreementHeaderExt_RU);

                        PriceDiscAdmSearchTmpPriceTypeCriteria discPriceTypeCriteriaCust;
                        discPriceTypeCriteriaCust.linkPhysicalTableInstance(discPriceTypeCriteria);

                        while select PriceType from discPriceTypeCriteriaCust
                            where discPriceTypeCriteriaCust.module == ModuleInventCustVend::Cust
                                && discPriceTypeCriteriaCust.IsChecked
                        {
                            this.searchCustVendPriceDiscGroup(
                                discPriceTypeCriteriaCust.PriceType,
                                ModuleInventCustVend::Cust,
                                discAdmSearchCustomer.PriceDiscGroupType);
                        }
                    }
                    break;
            }
        }

]]></Source>
			</Method>
			<Method>
				<Name>validateCustTablePriceDiscFields</Name>
				<Source><![CDATA[
    /// <summary>
        /// Validates the <c>Customer</c> record for the price discount fields.
        /// </summary>
        /// <param name="_custTable">The <c>CustTable</c> record.</param>
        /// <returns>true if there are any price discount values in the <c>CustTable</c> record; otherwise false.</returns>
        public boolean validateCustTablePriceDiscFields(CustTable _custTable)
        {
            PriceDiscAdmSearchTmpPriceTypeCriteria discPriceTypeCriteriaCust;
            discPriceTypeCriteriaCust.linkPhysicalTableInstance(discPriceTypeCriteria);

            while select PriceType from discPriceTypeCriteriaCust
            where discPriceTypeCriteriaCust.Module == ModuleInventCustVend::Cust
            {
                if (_custTable.(PriceTypeTradeAgreementMapping::newPriceTypeTradeAgreementMapping(discPriceTypeCriteriaCust.PriceType).custVendTableField()) != 0)
                {
                    return true;
                }
            }

            return false;
        }

]]></Source>
			</Method>
			<Method>
				<Name>processInvent</Name>
				<Source><![CDATA[
    void  processInvent()
        {
            if (!discAdmSearchInvent.ItemRelation && discAdmSearchInvent.ItemCode == PriceDiscProductCodeType::Table)
            {
                return;
            }

            InventTable  inventTable;
            InventTableModule inventTableModule;

            QueryBuildDataSource qbds;

            switch (discAdmSearchInvent.ItemCode)
            {
                case PriceDiscProductCodeType::Table:
                    qbds = qInvent.dataSourceTable(tableNum(InventTable));
                    qbds.findRange(fieldNum(InventTable,ItemId)).value(discAdmSearchInvent.ItemRelation);
                    inventQueryRun = new QueryRun(qInvent);

                    //for each item matching the query range
                    while (inventQueryRun.next())
                    {
                        inventTable = inventQueryRun.get(tableNum(InventTable));

                        this.searchInventPriceDiscItem(inventTable);

                        if (discAdmSearchInvent.IncludeAdditionalRelations)
                        {
                            this.searchInventGroups(inventTable);
                        }
                    }

                    if (discAdmSearchInvent.IncludeAdditionalRelations)
                    {
                        this.searchInventPriceDiscAll();
                    }
                    break;

                case PriceDiscProductCodeType::GroupId:
                    if (this.findSalesPriceDisc())
                    {
                        PriceType custPriceType = PriceGroupTypeTradeAgreementMapping::newPriceGroupTypeTradeAgreementMapping(discAdmSearchInvent.PriceDiscGroupType).priceDiscType(ModuleInventCustVend::Cust);
                        if (PriceTypeTradeAgreementMapping::newPriceTypeTradeAgreementMapping(custPriceType).isDiscGroupApplicable())
                        {
                            this.searchInventPriceDiscGroup(
                                custPriceType,
                                discAdmSearchInvent.PriceDiscGroupType,
                                discAdmSearchInvent.ItemRelation);
                        }
                    }

                    if (this.findPurchPriceDisc())
                    {
                        PriceType vendPriceType = PriceGroupTypeTradeAgreementMapping::newPriceGroupTypeTradeAgreementMapping(discAdmSearchInvent.PriceDiscGroupType).priceDiscType(ModuleInventCustVend::Vend);
                        if (PriceTypeTradeAgreementMapping::newPriceTypeTradeAgreementMapping(vendPriceType).isDiscGroupApplicable())
                        {
                            this.searchInventPriceDiscGroup(
                                vendPriceType,
                                discAdmSearchInvent.PriceDiscGroupType,
                                discAdmSearchInvent.ItemRelation);
                        }
                    }

                    if (discAdmSearchInvent.IncludeAdditionalRelations)
                    {
                        qbds = qInventModule.dataSourceTable(tableNum(InventTableModule));

                        PriceTypeTradeAgreementMapping priceTypeTradeAgreementMapping = PriceTypeTradeAgreementMapping::newPriceTypeTradeAgreementMapping(
                        PriceGroupTypeTradeAgreementMapping::newPriceGroupTypeTradeAgreementMapping(discAdmSearchInvent.PriceDiscGroupType).priceDiscType(ModuleInventCustVend::Cust));
                        
                        this.addInventTableModuleRangeCorrespondingToPriceType(priceTypeTradeAgreementMapping, qbds);

                        inventModuleQueryRun = new QueryRun(qInventModule);

                        while (inventModuleQueryRun.next())
                        {
                            inventTableModule = inventModuleQueryRun.get(tableNum(InventTableModule));
                            inventTable = InventTable::find(inventTableModule.ItemId);
                            this.searchInventPriceDiscItem(inventTable);
                        }

                        this.searchInventPriceDiscAll();
                    }
                    break;

                case PriceDiscProductCodeType::All:
                    this.searchInventPriceDiscAll();
                    if (discAdmSearchInvent.IncludeAdditionalRelations)
                    {
                        this.searchInventAllAdditionalRelations();

                        PriceDiscAdmSearchTmpPriceTypeCriteria discPriceTypeCriteriaInvent;
                        discPriceTypeCriteriaInvent.linkPhysicalTableInstance(discPriceTypeCriteria);

                        while select PriceType from discPriceTypeCriteriaInvent
                        where discPriceTypeCriteriaInvent.IsChecked
                        {
                            PriceTypeTradeAgreementMapping priceTypeTradeAgreementMapping = PriceTypeTradeAgreementMapping::newPriceTypeTradeAgreementMapping(discPriceTypeCriteriaInvent.PriceType);
                            if (priceTypeTradeAgreementMapping.isDiscGroupApplicable()
                            && ((priceTypeTradeAgreementMapping.partyRoleModule() == ModuleInventCustVend::Cust
                                    && this.findSalesPriceDisc())
                                || (priceTypeTradeAgreementMapping.partyRoleModule() == ModuleInventCustVend::Vend
                                    && this.findPurchPriceDisc())))
                            {
                                this.searchInventPriceDiscGroup(discPriceTypeCriteriaInvent.PriceType, priceTypeTradeAgreementMapping.priceGroupType());
                            }
                        }
                    }

                    break;
            }
        }

]]></Source>
			</Method>
			<Method>
				<Name>addInventTableModuleRangeCorrespondingToPriceType</Name>
				<Source><![CDATA[
        /// <summary>
        /// Adds the range on the InventTableModule field.
        /// </summary>
        /// <param name = "_priceTypeTradeAgreementMapping">Price type trade agreement mapping with <t>InventTableModule</t> field to add range.</param>
        /// <param name = "_qbds"><c>QueryBuildDataSource</c> instance to add ranges.</param>
        protected void addInventTableModuleRangeCorrespondingToPriceType(PriceTypeTradeAgreementMapping _priceTypeTradeAgreementMapping, QueryBuildDataSource _qbds)
        {
            if (_priceTypeTradeAgreementMapping.isDiscGroupApplicable())
            {
                _qbds.addRange(_priceTypeTradeAgreementMapping.inventTableModuleField()).value(discAdmSearchInvent.ItemRelation);
            }
        }

]]></Source>
			</Method>
			<Method>
				<Name>processVend</Name>
				<Source><![CDATA[
    void  processVend()
        {
            if (!discAdmSearchVendor.AccountRelation && discAdmSearchVendor.AccountCode == PriceDiscPartyCodeType::Table)
            {
                return;
            }

            VendTable  vendTable;
            QueryBuildDataSource qbds;

            switch (discAdmSearchVendor.AccountCode)
            {
                case PriceDiscPartyCodeType::Table:
                    qbds = qVend.dataSourceTable(tableNum(VendTable));
                    qbds.findRange(fieldNum(VendTable,AccountNum)).value(discAdmSearchVendor.AccountRelation);
                    vendQueryRun = new QueryRun(qVend);

                    //for each vendor matching the query range
                    while (vendQueryRun.next())
                    {
                        vendTable = vendQueryRun.get(tableNum(VendTable));

                        this.searchCustomerVendorPriceDiscAccount(
                        vendTable.AccountNum
                        ,ModuleInventCustVend::Vend
                        // <GEERU>
                        ,discAdmSearchVendor.AgreementHeaderExt_RU
                        // </GEERU>
                        );

                        if (discAdmSearchVendor.IncludeAdditionalRelations)
                        {
                            this.searchVendGroups(
                                vendTable,
                                discAdmSearchCustomer.AgreementHeaderExt_RU);
                        }
                    }

                    if (discAdmSearchVendor.IncludeAdditionalRelations)
                    {
                        this.searchCustVendPriceDiscAll(
                        ModuleInventCustVend::Vend,
                        discAdmSearchCustomer.AgreementHeaderExt_RU
                        );
                    }
                    break;

                case PriceDiscPartyCodeType::GroupId:
                    this.searchCustVendPriceDiscGroup(
                        PriceGroupTypeTradeAgreementMapping::newPriceGroupTypeTradeAgreementMapping(discAdmSearchVendor.PriceDiscGroupType).priceDiscType(ModuleInventCustVend::Vend),
                        ModuleInventCustVend::Vend,
                        discAdmSearchVendor.PriceDiscGroupType,
                        discAdmSearchVendor.AccountRelation);

                    if (discAdmSearchVendor.IncludeAdditionalRelations)
                    {
                        qbds = qVend.dataSourceTable(tableNum(VendTable));

                        PriceType priceType = PriceGroupTypeTradeAgreementMapping::newPriceGroupTypeTradeAgreementMapping(discAdmSearchVendor.PriceDiscGroupType).priceDiscType(ModuleInventCustVend::Vend);
                        qbds.addRange(PriceTypeTradeAgreementMapping::newPriceTypeTradeAgreementMapping(priceType).custVendTableField()).value(discAdmSearchVendor.AccountRelation);

                        vendQueryRun = new QueryRun(qVend);
                        while (vendQueryRun.next())
                        {
                            vendTable = vendQueryRun.get(tableNum(VendTable));

                            if (discAdmSearchVendor.AccountRelation
                            || this.validateVendTablePriceDiscFields(vendTable))
                            {
                                this.searchCustomerVendorPriceDiscAccount(vendTable.AccountNum, ModuleInventCustVend::Vend);
                            }
                        }

                        this.searchCustVendPriceDiscAll(ModuleInventCustVend::Vend);
                    }
                    break;

                case PriceDiscPartyCodeType::All:
                    this.searchCustVendPriceDiscAll(ModuleInventCustVend::Vend);

                    if (discAdmSearchVendor.IncludeAdditionalRelations)
                    {
                        this.searchVendAllAdditionalRelations(discAdmSearchVendor.AgreementHeaderExt_RU);

                        PriceDiscAdmSearchTmpPriceTypeCriteria discPriceTypeCriteriaVend;
                        discPriceTypeCriteriaVend.linkPhysicalTableInstance(discPriceTypeCriteria);

                        while select priceType from discPriceTypeCriteriaVend
                        where discPriceTypeCriteriaVend.module == ModuleInventCustVend::Vend
                            && discPriceTypeCriteriaVend.IsChecked
                        {
                            this.searchCustVendPriceDiscGroup(
                                discPriceTypeCriteriaVend.PriceType,
                                ModuleInventCustVend::Vend,
                                discAdmSearchVendor.PriceDiscGroupType);
                        }
                    }
                    break;
            }
        }

]]></Source>
			</Method>
			<Method>
				<Name>validateVendTablePriceDiscFields</Name>
				<Source><![CDATA[
    /// <summary>
        /// Validates the <c>VendTable</c> record for the price discount fields.
        /// </summary>
        /// <param name="_vendTable">The <c>VendTable</c> record.</param>
        /// <returns>true if there are any price discount values in the <c>VendTable</c> record; otherwise false.</returns>
        public boolean validateVendTablePriceDiscFields(VendTable _vendTable)
        {
            PriceDiscAdmSearchTmpPriceTypeCriteria discPriceTypeCriteriaVend;
            discPriceTypeCriteriaVend.linkPhysicalTableInstance(discPriceTypeCriteria);

            while select PriceType from discPriceTypeCriteriaVend
            where discPriceTypeCriteriaVend.Module == ModuleInventCustVend::Vend
            {
                if (_vendTable.(PriceTypeTradeAgreementMapping::newPriceTypeTradeAgreementMapping(discPriceTypeCriteriaVend.PriceType).custVendTableField()) != 0)
                {
                    return true;
                }
            }

            return false;
        }

]]></Source>
			</Method>
			<Method>
				<Name>queryCust</Name>
				<Source><![CDATA[
    Query queryCust()
        {
            Query       q = new Query(queryStr(PriceDiscAdmSearchCust));
            return q;
        }

]]></Source>
			</Method>
			<Method>
				<Name>queryInvent</Name>
				<Source><![CDATA[
    Query queryInvent()
        {
            Query       q = new Query(queryStr(PriceDiscAdmSearchInvent));
            return q;
        }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    /// <summary>
        /// Retrieves the instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
        /// </summary>
        /// <returns>
        /// The instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
        /// </returns>
        /// <remarks>
        /// This method is used if a query prompt is the dialog, and if a Select command is added to a dialog
        /// box. Do not create the instance of the <c>QueryRun</c> class when this method is called. Do it in
        /// the <c>unpack</c> method and the <c>initParmDefault</c> method, or in the <c>init</c> method.
        /// </remarks>
        QueryRun  queryRun()
        {
            QueryRun queryRun;

            switch (type)
            {
                case InventVendCust::Invent :
                    queryRun = inventQueryRun;
                    break;

                case InventVendCust::Vendor :
                    queryRun = vendQueryRun;
                    break;

                case InventVendCust::Customer :
                    queryRun = custQueryRun;
                    break;
            }

            queryRun.title("@SYS58997");

            return queryRun;
        }

]]></Source>
			</Method>
			<Method>
				<Name>queryVend</Name>
				<Source><![CDATA[
    Query queryVend()
        {
            Query       q = new Query(queryStr(PriceDiscAdmSearchVend));
            return q;
        }

]]></Source>
			</Method>
			<Method>
				<Name>reNumberLines</Name>
				<Source><![CDATA[
    /// <summary>
        ///     Sorts the journal lines and updates the line numbers accordingly.
        /// </summary>
        protected void reNumberLines()
        {
            DictTable                       dictPriceDiscAdmTrans = new DictTable(tableNum(PriceDiscAdmTrans));
            str                             sqlStmt;
            SqlSystem                       sqlSystem = new SqlSystem();
            str                             dataareaid;

            /* Test run dump from the debugger  -  this is what the direct sql is doing.

            IF OBJECT_ID(N'TEMPDB..#PRICEDISCTABLEREFTMP_3_34130') IS NOT NULL
            DROP TABLE #PRICEDISCTABLEREFTMP_3_34130

            SELECT  RECID AS PriceDiscTableRefRecId,
            Identity(int,1,1) AS LineNum
            INTO #PRICEDISCTABLEREFTMP_3_34130
            FROM PRICEDISCADMTRANS
            WHERE DATAAREAID = N'dmo'
            AND   JOURNALNUM = N'DMO-000006'
            AND   PARTITION = 5637144576
            ORDER BY ItemCode, ItemRelation, UnitId, Relation, AccountCode, FromDate

            UPDATE PRICEDISCADMTRANS
            SET    LINENUM = S1.LineNum
            FROM   PRICEDISCADMTRANS S,
            #PRICEDISCTABLEREFTMP_3_34130 S1
            WHERE  S.RECID = S1.PriceDiscTableRefRecId
            AND    S.JOURNALNUM = N'DMO-000006'
            AND    S.DATAAREAID = N'dmo'
            AND    S.PARTITION = 5637144576

            IF OBJECT_ID(N'TEMPDB..#PRICEDISCTABLEREFTMP_3_34130') IS NOT NULL
            DROP TABLE #PRICEDISCTABLEREFTMP_3_34130
            */

            sqlStmt     =   'IF OBJECT_ID(N\'TEMPDB..#PRICEDISCTABLEREFTMP_%1\') IS NOT NULL\n';
            sqlStmt     +=  '   DROP TABLE #PRICEDISCTABLEREFTMP_%1\n';
            sqlStmt     +=  '\n';
            sqlStmt     +=  ' SELECT  '+dictPriceDiscAdmTrans.fieldName(fieldNum(PriceDiscAdmTrans,RecId),DbBackend::Sql)+' AS PriceDiscTableRefRecId,\n';
            sqlStmt     +=  '        Identity(int,1,1) AS LineNum\n';
            sqlStmt     +=  '        INTO #PRICEDISCTABLEREFTMP_%1\n';
            sqlStmt     +=  '        FROM '+ dictPriceDiscAdmTrans.name(DbBackend::Sql)+'\n';
            sqlStmt     +=  '        WHERE '+ dictPriceDiscAdmTrans.fieldName(fieldNum(PriceDiscAdmTrans,DataAreaId),DbBackend::Sql)+' = %2\n';
            sqlStmt     +=  '        AND   '+ dictPriceDiscAdmTrans.fieldName(fieldNum(PriceDiscAdmTrans,JournalNum),DbBackend::Sql)+' = %3\n';
            sqlStmt     +=  '        AND   '+ dictPriceDiscAdmTrans.fieldName(fieldNum(PriceDiscAdmTrans,Partition),DbBackend::Sql)+' = %4\n';
            sqlStmt     +=  '        ORDER BY ITEMCODE, ITEMRELATION, UNITID, RELATION, ACCOUNTCODE, FROMDATE\n';
            sqlStmt     +=  '\n';
            sqlStmt     +=  'UPDATE '+ dictPriceDiscAdmTrans.name(DbBackend::Sql)+'\n';
            sqlStmt     +=  '       SET    '+dictPriceDiscAdmTrans.fieldName(fieldNum(PriceDiscAdmTrans,LineNum),DbBackend::Sql)+ ' = S1.LineNum\n';
            sqlStmt     +=  '       FROM   '+dictPriceDiscAdmTrans.name(DbBackend::Sql)+' S,\n';
            sqlStmt     +=  '       #PRICEDISCTABLEREFTMP_%1 S1\n';
            sqlStmt     +=  '       WHERE  S.'+dictPriceDiscAdmTrans.fieldName(fieldNum(PriceDiscAdmTrans,RecId),DbBackend::Sql)+' = S1.PriceDiscTableRefRecId\n';
            sqlStmt     +=  '       AND    S.'+dictPriceDiscAdmTrans.fieldName(fieldNum(PriceDiscAdmTrans,JournalNum),DbBackend::Sql)+' = %3\n';
            sqlStmt     +=  '       AND    S.'+dictPriceDiscAdmTrans.fieldName(fieldNum(PriceDiscAdmTrans,DataAreaId),DbBackend::Sql)+' = %2\n';
            sqlStmt     +=  '       AND    S.'+dictPriceDiscAdmTrans.fieldName(fieldNum(PriceDiscAdmTrans,Partition),DbBackend::Sql)+' = %4\n';
            sqlStmt     +=  '\n';
            sqlStmt     +=  'IF OBJECT_ID(N\'TEMPDB..#PRICEDISCTABLEREFTMP_%1\') IS NOT NULL\n';
            sqlStmt     +=  '   DROP TABLE #PRICEDISCTABLEREFTMP_%1\n';

            dataareaid = sqlSystem.sqlLiteral(curext());

            sqlStmt = strFmt(sqlStmt,
                         strFmt('%1_%2', sessionId(), DateTimeUtil::getTimeNow(DateTimeUtil::getUserPreferredTimeZone())),   // %1
            dataareaid,                                // %2
            sqlSystem.sqlLiteral(journalNum),          // %3
            getcurrentpartitionrecid());               // %4

            PriceDiscAdmSearch::executeStatement(sqlStmt);
        }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    void  run()
    {
        priceDiscAdmTransIns.skipDataMethods(true);

            ttsbegin;
            this.populateDiscPriceTypeCriteria();

            this.runSearch();

            this.reNumberLines();
            ttscommit;
        }

]]></Source>
			</Method>
			<Method>
				<Name>runSearch</Name>
				<Source><![CDATA[
    [Hookable]
        private void runSearch()
        {
            this.processCust();

            this.processVend();

            this.processInvent();
        }

]]></Source>
			</Method>
			<Method>
				<Name>populateDiscPriceTypeCriteria</Name>
				<Source><![CDATA[
    /// <summary>
        /// Populates the price type search criteria from the container <c>conPriceTypeCriteria</c> provided to the class;
        /// if the container with price type to filter is not set, then the table is populated with all pricetypes,
        /// so that the search includes all.
        /// </summary>
        public void populateDiscPriceTypeCriteria()
        {
            select firstonly RecId from discPriceTypeCriteria;

            if (!discPriceTypeCriteria.RecId)
            {
                Set priceTypeCriteriaAll = PriceTypesForSearch::retrievePriceTypes();

                SetEnumerator priceTypeEnumerator = priceTypeCriteriaAll.getEnumerator();

                while (priceTypeEnumerator.moveNext())
                {
                    discPriceTypeCriteria.PriceType = priceTypeEnumerator.current();
                    discPriceTypeCriteria.Module = PriceTypeTradeAgreementMapping::newPriceTypeTradeAgreementMapping(priceTypeEnumerator.current()).partyRoleModule();
                    discPriceTypeCriteria.IsChecked = conLen(conPriceTypeCriteria) > 0?
                    (conFind(conPriceTypeCriteria, discPriceTypeCriteria.PriceType) != 0):
                    true;
                    discPriceTypeCriteria.insert();
                }
            }
        }

]]></Source>
			</Method>
			<Method>
				<Name>searchCustAllAdditionalRelations</Name>
				<Source><![CDATA[
    /// <summary>
        /// Finds and inserts account specific relations for all customers.
        /// </summary>
        /// <param name="_agreementHeaderExtRecId">
        /// An <c>AgreementHeaderExtRecId_RU</c> type.
        /// </param>
        protected void searchCustAllAdditionalRelations(AgreementHeaderExtRecId_RU _agreementHeaderExtRecId)
        {
            PriceDiscAdmTransPartyTableCopy priceDiscAdmTransPartyTableCopy = PriceDiscAdmTransPartyCopy::newPriceDiscAdmTransPartyCopy(PriceDiscPartyCodeType::Table, ModuleInventCustVend::Cust, this);
            priceDiscAdmTransPartyTableCopy.parmAgreementHeaderExtRecId_RU(_agreementHeaderExtRecId);
            priceDiscAdmTransPartyTableCopy.parmSearchAll(true);
            priceDiscAdmTransPartyTableCopy.search();
        }

]]></Source>
			</Method>
			<Method>
				<Name>searchCustGroups</Name>
				<Source><![CDATA[
    void  searchCustGroups(CustTable  _custTable, AgreementHeaderExtRecId_RU _agreementHeaderExtRecId = 0)
        {
            this.searchCustVendGroups(_custTable, ModuleInventCustVend::Cust, _agreementHeaderExtRecId);
        }

]]></Source>
			</Method>
			<Method>
				<Name>searchCustVendPriceDiscAccount</Name>
				<Source><![CDATA[
    [SysObsolete("Prefer to use searchCustVendPriceDiscAccountV2", false, 31\03\2019)]
        void  searchCustVendPriceDiscAccount(
        PriceDiscAccountRelation _accountRelation = '',
        AgreementHeaderExtRecId_RU _agreementHeaderExtRecId = 0)
        {
            this.searchCustomerVendorPriceDiscAccount(_accountRelation, ModuleInventCustVend::Invent, _agreementHeaderExtRecId);
        }

]]></Source>
			</Method>
			<Method>
				<Name>searchCustomerVendorPriceDiscAccount</Name>
				<Source><![CDATA[
    public void  searchCustomerVendorPriceDiscAccount(
            PriceDiscAccountRelation _accountRelation,
            ModuleInventCustVend _partyRoleModule,
            AgreementHeaderExtRecId_RU _agreementHeaderExtRecId = 0)
        {
            PriceDiscAdmTransPartyTableCopy priceDiscAdmTransPartyTableCopy = PriceDiscAdmTransPartyCopy::newPriceDiscAdmTransPartyCopy(PriceDiscPartyCodeType::Table, _partyRoleModule, this);
            priceDiscAdmTransPartyTableCopy.parmAccountRelation(_accountRelation);
            priceDiscAdmTransPartyTableCopy.parmAgreementHeaderExtRecId_RU(_agreementHeaderExtRecId);
            priceDiscAdmTransPartyTableCopy.search();
        }

]]></Source>
			</Method>
			<Method>
				<Name>searchCustVendPriceDiscAll</Name>
				<Source><![CDATA[
    void searchCustVendPriceDiscAll(ModuleInventCustVend _module,
                                    AgreementHeaderExtRecId_RU _agreementHeaderExtRecId = 0)
        {
            if ((_module == ModuleInventCustVend::Cust && this.findSalesPriceDisc())
                || (_module == ModuleInventCustVend::Vend && this.findPurchPriceDisc()))
            {
                PriceDiscAdmTransPartyCopy priceDiscAdmTransCopy = PriceDiscAdmTransPartyCopy::newPriceDiscAdmTransPartyCopy(PriceDiscPartyCodeType::All, _module, this);
                priceDiscAdmTransCopy.parmAgreementHeaderExtRecId_RU(_agreementHeaderExtRecId);
                priceDiscAdmTransCopy.search();
            }
        }

]]></Source>
			</Method>
			<Method>
				<Name>searchCustVendPriceDiscGroup</Name>
				<Source><![CDATA[
    /// <summary>
        /// Searches for <c>PriceDiscTable</c> records for specified customer or vendor discount groups.
        /// Saves the results in <c>PriceDiscTableRefTmp</c> temporary table.
        /// </summary>
        /// <param name="priceType">
        /// Price type to search by.
        /// </param>
        /// <param name="_module">
        /// Price discount module to search by.
        /// </param>
        /// <param name="_groupType">
        /// Price group type to search by.
        /// </param>
        /// <param name="accountRelation">
        /// Vendor or customer account relation to search by; optional.
        /// </param>
        /// <param name="_agreementHeaderExtRecId">
        /// <c>AgreementHeaderExtRec</c> record ID to search by; optional.
        /// </param>
        public void searchCustVendPriceDiscGroup(PriceType                  _priceType,
                                                PriceDiscModule             _module,
                                                PriceGroupType              _groupType,
                                                PriceDiscAccountRelation    accountRelation = '',
                                                AgreementHeaderExtRecId_RU  _agreementHeaderExtRecId = 0)
        {
            PriceDiscAdmTransPartyGroupCopy priceDiscAdmTransPartyGroupCopy = PriceDiscAdmTransPartyCopy::newPriceDiscAdmTransPartyCopy(PriceDiscPartyCodeType::GroupId, _module, this);
            priceDiscAdmTransPartyGroupCopy.parmPriceGroupType(_groupType);
            PriceDiscAdmTransPartyGroupCopy.parmPriceType(_priceType);
            priceDiscAdmTransPartyGroupCopy.parmPriceGroupId(accountRelation);
            priceDiscAdmTransPartyGroupCopy.parmAgreementHeaderExtRecId_RU(_agreementHeaderExtRecId);
            priceDiscAdmTransPartyGroupCopy.search();
        }

]]></Source>
			</Method>
			<Method>
				<Name>searchInventAllAdditionalRelations</Name>
				<Source><![CDATA[
    /// <summary>
        /// Finds and inserts item specific relations for all items.
        /// Saves the results in <c>PriceDiscAdmTrans</c> table.
        /// </summary>
        protected void searchInventAllAdditionalRelations()
        {
            PriceDiscAdmTransProductTableCopy priceDiscAdmTransProductTableCopy = PriceDiscAdmTransProductCopy::newPriceDiscAdmTransProductCopy(PriceDiscProductCodeType::Table, this);
            priceDiscAdmTransProductTableCopy.parmSearchAll(true);
            priceDiscAdmTransProductTableCopy.search();
        }

]]></Source>
			</Method>
			<Method>
				<Name>searchInventGroups</Name>
				<Source><![CDATA[
    void  searchInventGroups(InventTable  _inventTable)
        {
            SysDictEnum moduleEnum = SysDictEnum::newName(enumStr(ModuleInventPurchSales));
            Counter moduleEnumValues = moduleEnum.values();

            for (int i = 1; i <= moduleEnumValues; i++)
            {
                ModuleInventPurchSales moduleType = any2Enum(moduleEnum.index2Value(i));
                if (TradeModuleType::isApplicableForModule(moduleType))
                {
                    InventTableModule inventTableModule = InventTableModule::find(_inventTable.ItemId, moduleType);

                    PriceDiscAdmSearchTmpPriceTypeCriteria discPriceTypeCriteriaInvent;
                    discPriceTypeCriteriaInvent.linkPhysicalTableInstance(discPriceTypeCriteria);

                    TradeModuleType tradeModuleType = TradeModuleType::newFromModule(moduleType);
                    ModuleInventCustVend module = tradeModuleType.toTradePartyModuleType();

                    while select PriceType from discPriceTypeCriteriaInvent
                    where discPriceTypeCriteriaInvent.IsChecked
                        && discPriceTypeCriteriaInvent.Module == module
                    {
                        PriceTypeTradeAgreementMapping priceTypeTradeAgreementMapping = PriceTypeTradeAgreementMapping::newPriceTypeTradeAgreementMapping(discPriceTypeCriteriaInvent.PriceType);

                    if (priceTypeTradeAgreementMapping.isDiscGroupApplicable()
                        && inventTableModule.(priceTypeTradeAgreementMapping.inventTableModuleField())
                        && !this.skipSearch(moduleType, module, discPriceTypeCriteriaInvent.PriceType))
                        {
                            this.searchInventPriceDiscGroup(discPriceTypeCriteriaInvent.PriceType,
                                                        priceTypeTradeAgreementMapping.priceGroupType(),
                                                        inventTableModule.(priceTypeTradeAgreementMapping.inventTableModuleField()));
                        }
                    }
                }
            }
        }

]]></Source>
			</Method>
			<Method>
				<Name>skipSearch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Skip searches for <c>PriceDiscTable</c> records for specified customer or vendor discount groups.
    /// </summary>
    /// <param name="_moduleType">
    /// Module type to search by.
    /// </param>
    /// <param name="_module">
    /// Module to search by.
    /// </param>
    /// <param name="_priceType">
    /// Price type to search by.
    /// </param>
    /// <returns>
    /// Always returns false.
    /// </returns>
    protected boolean skipSearch(ModuleInventPurchSales  _moduleType,
                                ModuleInventCustVend    _module,
                                PriceType               _priceType)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchInventPriceDiscAll</Name>
				<Source><![CDATA[
    /// <summary>
        /// Searches for <c>PriceDiscTable</c> records that apply for all items.
        /// Saves the results in <c>PriceDiscAdmTrans</c> table.
        /// </summary>
        public void searchInventPriceDiscAll()
        {
            PriceDiscAdmTransProductCopy priceDiscAdmTransProductCopy = PriceDiscAdmTransProductCopy::newPriceDiscAdmTransProductCopy(PriceDiscProductCodeType::All, this);
            priceDiscAdmTransProductCopy.search();
        }

]]></Source>
			</Method>
			<Method>
				<Name>searchInventPriceDiscGroup</Name>
				<Source><![CDATA[
    /// <summary>
        /// Searches for <c>PriceDiscTable</c> records for specified customer or vendor discount groups.
        /// Saves the results in <c>PriceDiscAdmTrans</c> table.
        /// </summary>
        /// <param name="priceType">
        /// Price type to search by.
        /// </param>
        /// <param name="_groupType">
        /// Price group type to search by.
        /// </param>
        /// <param name="itemRelation">
        /// Item relation to search by; optional.
        /// </param>
        public void  searchInventPriceDiscGroup(PriceType               _priceType,
                                               PriceGroupType           _groupType,
                                               PriceDiscItemRelation    itemRelation = '')
        {
            PriceDiscAdmTransProductGroupCopy priceDiscAdmTransProductGroupCopy = PriceDiscAdmTransProductCopy::newPriceDiscAdmTransProductCopy(PriceDiscProductCodeType::GroupId, this);
            priceDiscAdmTransProductGroupCopy.parmPriceType(_priceType);
            priceDiscAdmTransProductGroupCopy.parmPriceGroupType(_groupType);
            priceDiscAdmTransProductGroupCopy.parmPriceGroupId(itemRelation);
            priceDiscAdmTransProductGroupCopy.search();
        }

]]></Source>
			</Method>
			<Method>
				<Name>searchInventPriceDiscItem</Name>
				<Source><![CDATA[
    /// <summary>
        /// Searches for <c>PriceDiscTable</c> records for specified item.
        /// Saves the results in <c>PriceDiscAdmTrans</c> table.
        /// </summary>
        /// <param name="_inventTable">
        /// Item to search for.
        /// </param>
        public void searchInventPriceDiscItem(InventTable  _inventTable)
        {
            PriceDiscAdmTransProductTableCopy priceDiscAdmTransProductTableCopy = PriceDiscAdmTransProductCopy::newPriceDiscAdmTransProductCopy(PriceDiscProductCodeType::Table, this);
            priceDiscAdmTransProductTableCopy.parmItemRelation(_inventTable.ItemId);
            priceDiscAdmTransProductTableCopy.search();
        }

]]></Source>
			</Method>
			<Method>
				<Name>searchVendAllAdditionalRelations</Name>
				<Source><![CDATA[
    /// <summary>
        /// Finds and inserts account specific relations for all customers.
        /// </summary>
        /// <param name="_agreementHeaderExtRecId">
        /// An <c>AgreementHeaderExtRecId_RU</c> type.
        /// </param>
        protected void searchVendAllAdditionalRelations(AgreementHeaderExtRecId_RU  _agreementHeaderExtRecId)
        {
            PriceDiscAdmTransPartyTableCopy priceDiscAdmTransPartyTableCopy = PriceDiscAdmTransPartyCopy::newPriceDiscAdmTransPartyCopy(PriceDiscPartyCodeType::Table, ModuleInventCustVend::Vend, this);
            priceDiscAdmTransPartyTableCopy.parmSearchAll(true);
            priceDiscAdmTransPartyTableCopy.search();
        }

]]></Source>
			</Method>
			<Method>
				<Name>searchVendGroups</Name>
				<Source><![CDATA[
    void  searchVendGroups(
            VendTable  _vendTable,
            AgreementHeaderExtRecId_RU _agreementHeaderExtRecId = 0)
        {
            this.searchCustVendGroups(_vendTable, ModuleInventCustVend::Vend, _agreementHeaderExtRecId);
        }

]]></Source>
			</Method>
			<Method>
				<Name>searchCustVendGroups</Name>
				<Source><![CDATA[
    void  searchCustVendGroups(
            Common                      _custVendTable,
            ModuleInventCustVend        _module,
            AgreementHeaderExtRecId_RU  _agreementHeaderExtRecId = 0)
        {
            PriceDiscAdmSearchTmpPriceTypeCriteria discPriceTypeCriteriaCustVendTable;
            discPriceTypeCriteriaCustVendTable.linkPhysicalTableInstance(discPriceTypeCriteria);

            while select PriceType, Module from discPriceTypeCriteriaCustVendTable
            where discPriceTypeCriteriaCustVendTable.Module == _module
                && discPriceTypeCriteriaCustVendTable.IsChecked
            {
                FieldId custVendTableFieldId = PriceTypeTradeAgreementMapping::newPriceTypeTradeAgreementMapping(discPriceTypeCriteriaCustVendTable.PriceType).custVendTableField();
            
                if (_custVendTable.(custVendTableFieldId))
                {
                    PriceDiscAdmTransPartyGroupCopy priceDiscAdmTransPartyGroupCopy = PriceDiscAdmTransPartyCopy::newPriceDiscAdmTransPartyCopy(PriceDiscPartyCodeType::GroupId, _module, this);
                    priceDiscAdmTransPartyGroupCopy.parmPriceType(discPriceTypeCriteriaCustVendTable.PriceType);
                    priceDiscAdmTransPartyGroupCopy.parmAccountRelation(_custVendTable.(custVendTableFieldId));
                    priceDiscAdmTransPartyGroupCopy.search();
                }
            }
        }

]]></Source>
			</Method>
			<Method>
				<Name>showQueryValues</Name>
				<Source><![CDATA[
    /// <summary>
        /// Determines whether to add a Select button to the dialog box.
        /// </summary>
        /// <returns>
        /// Always returns true.
        /// </returns>
        /// <remarks>
        /// If you click this button, it will show the query form. Therefore, the <c>queryRun</c> method has to
        /// return a valid <c>queryRun</c> .If you change the return value to false the button will no longer
        /// be added.
        /// </remarks>
        public boolean showQueryValues()
        {
            return false;
        }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    boolean  unpack(container  packedClass)
        {
            Integer     version = RunBase::getVersion(packedClass);

            switch (version)
            {
                case #CurrentVersion:
                    [version,#CurrentList] = packedClass;
                    discAdmSearchCustomer.setRelation();
                    discAdmSearchVendor.setRelation();
                    discAdmSearchInvent.setRelation();
                    break;

                default:
                    return false;
            }
            return true;
        }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    boolean  validate(Object _calledFrom = null)
        {
            return true;
        }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static PriceDiscAdmSearch construct()
        {
            return new PriceDiscAdmSearch();
        }

]]></Source>
			</Method>
			<Method>
				<Name>executeStatement</Name>
				<Source><![CDATA[
    /// <summary>
        /// Executes a direct SQL statement.
        /// </summary>
        /// <param name="_sqlStmt">
        /// A string that contains the SQL statement to be executed.
        /// </param>
        /// <exception cref="M:Exception::Error">
        /// Error executing SQL statement.
        /// </exception>
        public static void executeStatement(str _sqlStmt)
        {
            SqlStatementExecutePermission permission;
            Connection connection;
            Statement statement;

            try
            {
                connection = new Connection();
                statement = connection.createStatement();
                connection.ttsbegin();
                permission = new SqlStatementExecutePermission(_sqlStmt);
                permission.assert();
                statement.executeUpdate(_sqlStmt);
                CodeAccessPermission::revertAssert();
                connection.ttscommit();

                if (connection)
                {
                    connection.finalize();
                }
            }
            catch (Exception::Error)
            {
                if (statement)
                {
                    statement.close();
                }

                if (connection)
                {
                    connection.finalize();
                }

                throw error("@SYS99562");
            }
        }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
        {
            return "@SCM:CopyTradeAgreementRecordsToNewJournal";
        }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void  main(Args  args)
        {
            if (!(args.dataset() == tableNum(PriceDiscAdmTrans)))
            {
                throw error("@SYS18626");
            }

            PriceDiscAdmTrans   priceDiscAdmTrans = args.record();
            PriceDiscAdmSearch  priceDiscAdmSearch = PriceDiscAdmSearch::construct();
            priceDiscAdmSearch.getLast();
            if (!priceDiscAdmTrans.JournalNum)
            {
                FormRun         priceDiscTransForm = args.caller();
                if (   !(priceDiscTransForm is FormRun)
                   || !(priceDiscTransForm.args().caller() is FormRun))
                {
                    throw error("@SYS18626");
                }

                FormRun         priceDiscTableForm = priceDiscTransForm.args().caller();
                FormDataSource  tableDataSource    = priceDiscTableForm.dataSource();

                if (tableDataSource.table() != tableNum(PriceDiscAdmTable))
                {
                    throw error("@SYS18626");
                }
                else
                {
                    PriceDiscAdmTable priceDiscAdmTable = tableDataSource.cursor();
                    priceDiscAdmSearch.initJournalNum(priceDiscAdmTable.JournalNum);
                }
            }
            else
            {
                priceDiscAdmSearch.initJournalNum(priceDiscAdmTrans.JournalNum);
            }

            if (priceDiscAdmSearch.prompt())
            {
                priceDiscAdmSearch.runOperation();
            }
        }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
        {
            return true;
        }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>