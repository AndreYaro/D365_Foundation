<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PurchFormLetter</Name>
	<SourceCode>
		<Declaration><![CDATA[
abstract class   PurchFormLetter
extends FormLetterServiceController implements BatchRetryable, SysErrorMessageHelpScopeIBatchProvider, SysErrorMessageHelpScopeIBatchShowLink
{
    FormletterService           formletterService;
    PurchFormLetterContract     purchFormLetterContract;
    FormRun                     purchEditLinesForm;

    PurchQuantity               purchQuantity;
    PdsCWInventQty              pdsCWUpdateNow;
    VendDocumentTableMap        parmTable;
    FormDataSource              wmsJournalTable_ds;
    boolean                     wmsJournalTableDsIsSet;
    boolean                     editLinesChanged;
    boolean                     enableUpdateNow;
    FormDataSource              purchEditLinesDatasource;
    boolean                     updateSalesLines;

    // Parameter used to indicate if interCompanyMarkupAllocation should be performed for invoices.
    boolean                     doInterCompanyMarkupAllocation;
    RefRecId                    lastParmTableRecId;
    container                   packedOutputContract;

    boolean                     runFromSCS;
    // <GIN>
    RecordSortedList                journalList;
    CustomsImporterInvoiceNumber_IN customsImporterInvoiceNumber;
    CustomsBillOfEntryNumber_IN     customsBillOfEntryNumber;
    TaxAmountCur                    customsLoadOnInventoryMST;
    TaxAmountCur                    customsLoadOnInventory;
    CustomsImportOrderType_IN       customsImportOrderType;
    boolean                         printGoodsReceiptNote;
    GoodsReceiptNote_IN             grnNumber;
    AmountCur                       withholdTaxAmount;
    TaxRegistrationNumber_IN        eccNumber;
    TaxRegistrationNumber_IN        serviceTaxNumber;
    TaxRegistrationNumber_IN        iecNumber;
    NoYesId                         taxesMarked;
    boolean                         splitPackSlipOrInvoice;
    PurchLine                       purchLineSearch;

    NoYes                           mcrUseVendPrintOptions;
    boolean                         mcrIsWirelessPostArrivalJournal;

    // </GIN>
    // <GIN><GEERU>
    #ISOcountryRegionCodes
    // </GEERU></GIN>

    //List of parameters common for PurchFormLetter_* classes that needs to be packed
    //for the correct class transition between client and server.
    //If you need some additional parameters on the client, add them to this list.
    //All variables in the parmListCommonCS must also be added to the method resetParmListCommonCS.
    //After any changes, please increase both versions.
    #define.ParentVersion(12)
    #define.CurrentVersion(13)
    #LOCALMACRO.ParmListCommonCS
        editLinesChanged,
        reArrangeNow,
        enableUpdateNow,
        validateAll,
        callerFormName,
        packedOutputContract
    #ENDMACRO
    #define.SumVersion24(24)
    #LOCALMACRO.ParmListCommonCS_24
        editLinesChanged,
        reArrangeNow,
        enableUpdateNow,
        validateAll,
        callerFormName
    #ENDMACRO

    //List of parameters extracted from arguments for the transfer from main() to mainOnServer()
    #LOCALMACRO.CachedArgsList
        parmEnum,
        callerFormName,
        isProforma,
        callerMenuItem,
        className,
        methodName,
        mode
    #ENDMACRO

    VendPostingProfile          currentPostingProfile;
    InventProfileType_RU        currentInventProfileType;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>afterOperationBody</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes the main logic after an operation before cleanup.
    /// </summary>
    protected void afterOperationBody()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>afterOperationEnd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs after operation closure.
    /// </summary>
    protected void afterOperationEnd()
    {
        super();
        this.deleteParmUpdate();
        this.endUpdate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcLastPurchPrice</Name>
				<Source><![CDATA[
    public void  calcLastPurchPrice()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBeforePost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether validation should be performed before posting.
    /// </summary>
    /// <returns>
    /// true if check should be performed before post; Otherwise, false.
    /// </returns>
    public boolean checkBeforePost()
    {
        return PurchFormletterParmData::newReSelect(this.packDataContract(purchFormLetterContract)).checkBeforePost(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkConsignmentNoteNum_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// returns true for all the purchase document other than invoice.
    /// </summary>
    /// <returns>
    /// returns true if the consignment number is entered otherwise false
    /// </returns>
    public boolean checkConsignmentNoteNum_IN()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkFormLetterId</Name>
				<Source><![CDATA[
    boolean  checkFormLetterId()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkFundingLimit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the purchase order for limit errors
    /// </summary>
    /// <returns>
    /// <c>False</c> if there is a funding limit error, otherwise <c>true</c>.
    /// </returns>
    protected boolean checkFundingLimit()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInterCompany</Name>
				<Source><![CDATA[
    protected boolean  checkInterCompany()  // overridden in PurchFormLetter_Invoice
    {
        PurchParmTable  purchParmTableLocal;
        PurchTable      purchTableLocal;

        Counter         recordCount         = 0;
        boolean         interCompanyFound   = false;
        boolean         ok                  = true;
        PurchParmUpdate purchParmUpdate     = this.purchParmUpdate();

        if (purchParmUpdate.SumBy == AccountOrder::Order)
        {
            while select RecId from purchParmTableLocal
                where purchParmTableLocal.ParmId == purchParmUpdate.ParmId
                    join  InterCompanyOrder from purchTableLocal
                        where purchTableLocal.PurchId == purchParmTableLocal.PurchId
            {
                recordCount++;

                if (purchTableLocal.InterCompanyOrder)
                {
                    interCompanyFound = true;
                }

                if (interCompanyFound  &&  recordCount > 1)
                {
                    ok = checkFailed(strFmt("@SYS75337", "@SYS57755"));
                    break;
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIntrastat</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if vend transaction line fulfills Intrastat requirements.
    /// </summary>
    /// <param name="_parmLine">
    /// The <c>VendDocumentLineMap</c> that carries related information.
    /// </param>
    /// <param name="_purchLine">
    /// The <c>PurchLine</c> that carries vend transaction information.
    /// </param>
    /// <returns>
    /// true if Intrastat requirements are fulfilled; otherwise, false.
    /// </returns>
    protected boolean checkIntrastat(VendDocumentLineMap _parmLine, PurchLine _purchLine)
    {
        boolean ok = true;

        if (IntrastatParameters::isLegalEntityInEEU() && this.mustCheckIntrastat())
        {
            ok = _purchLine.checkIntrastat();
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLateSelection</Name>
				<Source><![CDATA[
    protected boolean  checkLateSelection()
    {
        boolean  ok = true;
        PurchParmUpdate purchParmUpdate = this.purchParmUpdate();

        if (purchParmUpdate.LateSelection  &&  !purchParmUpdate.LateSelectionQuery)
        {
            ok = checkFailed("@SYS72782");
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPackingSlip</Name>
				<Source><![CDATA[
    protected boolean  checkPackingSlip()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPrepayCrossPurchOrder</Name>
				<Source><![CDATA[
    protected boolean checkPrepayCrossPurchOrder()
    {
        return PurchPrepayTable::validatePrepayCrossPurchOrder(this.purchParmUpdate().ParmId, this.documentStatus());
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPurchLineChanged</Name>
				<Source><![CDATA[
    protected boolean checkPurchLineChanged(VendDocumentLineMap _parmLine, PurchLine _purchLine, boolean _checkQtys = true)
    {
        boolean         ok = true;
        PurchQty        remainBefore;
        InventQty       remainBeforeInvent;
        Qty             dummy;
        // <GEEU>
        #ISOCountryRegionCodes
        // </GEEU>

        if (_checkQtys)
        {
            [dummy, remainBefore      , dummy] = this.qtyPurch (_purchLine, naReal());
            [dummy, remainBeforeInvent, dummy] = this.qtyInvent(_purchLine, naReal());

            if (remainBefore       != _parmLine.RemainBefore ||
                remainBeforeInvent != _parmLine.RemainBeforeInvent)
            {
                ok = checkFailed(strFmt("@SYS78923", _parmLine.OrigPurchId));
            }
        }

        ok = ok && this.checkIntrastat(_parmLine, _purchLine);

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPurchLinesChanged</Name>
				<Source><![CDATA[
    protected boolean  checkPurchLinesChanged()  // overridden in PurchFormLetter_Invoice
    {
        PurchParmLine   purchParmLineLocal;
        PurchLine       purchLineLocal;
        PurchParmUpdate purchParmUpdate = this.purchParmUpdate();
        boolean         ok = true;
        // <GIN>
        PurchParmLine   previouspurchParmLineLocal;
        PurchTable      purchTableCopy = this.purchTable();
        boolean         isCustomsMarked = TaxParameters::isCustomsEnable_IN();
        // </GIN>

        while select purchParmLineLocal
            where purchParmLineLocal.ParmId == purchParmUpdate.ParmId
            outer join purchLineLocal
                where purchLineLocal.InventTransId == purchParmLineLocal.InventTransId
                   && !purchLineLocal.IsDeleted
        {
            // <GIN>
            if (isCustomsMarked
                && VendDocumentLineMap::isTransactionRelatedToBOE_IN(PurchPackingSlipCorrectionConsiderMultipleBOE_INFlight::instance().isEnabled() 
                ? purchLineLocal.purchTable() : purchTableCopy, purchParmUpdate)
                && purchLineLocal)
            {
                if (purchParmLineLocal.InventTransId != previouspurchParmLineLocal.InventTransId)
                {
                    purchParmLineLocal.revertPreviousVersionChanges(purchLineLocal);
                    previouspurchParmLineLocal = purchParmLineLocal;
                    if (!this.checkPurchLineChanged(purchParmLineLocal, purchLineLocal) )
                    {
                        ok = false;
                    }
                }
                else
                {
                    continue;
                }
            }
            else
            {
                // </GIN>
                purchParmLineLocal.revertPreviousVersionChanges(purchLineLocal);
                if (!this.checkPurchLineChanged(purchParmLineLocal, purchLineLocal) )
                {
                    ok = false;
                }
                // <GIN>
            }
            // </GIN>
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLineName_PL</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the length of the transaction line name is less than or equals to 256 characters.
    /// </summary>
    /// <param name="_vendDocumentLineMap">
    /// An instance of <c>VendDocumentLineMap</c>.
    /// </param>
    /// <returns>
    /// true if the name is less than or equals to 256 characters for all lines; otherwise, false.
    /// </returns>
    protected boolean validateLineName_PL(VendDocumentLineMap _vendDocumentLineMap)
    {
        boolean ret = true;

        if (_vendDocumentLineMap.ItemId 
            && strLen(_vendDocumentLineMap.VendDocumentLineMap::name()) > TransactionLineNameLengthLimit)
        {
            return checkFailed(strFmt("@StandardAuditFile_SAFT_W:SAFInventoryDescriptionValidationLabel", _vendDocumentLineMap.ItemId));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSumBy</Name>
				<Source><![CDATA[
    protected boolean  checkSumBy()
    {
        PurchParmUpdate purchParmUpdate = this.purchParmUpdate();
        PurchSummary checkPurchSummary = PurchSummary::construct(purchParmUpdate.SumBy,
                                                                 purchParmUpdate.ParmId,
                                                                 purchParmUpdate.SumPurchId,
                                                                 this.documentStatus(),
                                                                 this.parmNumber());
        return checkPurchSummary.checkUpdateAllowed();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSumNum</Name>
				<Source><![CDATA[
    protected boolean  checkSumNum()
    {
        boolean  ok = true;
        PurchParmUpdate purchParmUpdate = this.purchParmUpdate();

        if (purchParmUpdate.SumBy == AccountOrder::Order)
        {
            if (!PurchParmLine::existPurch(this.parmId(), purchParmUpdate.SumPurchId))
                ok = checkFailed(strFmt("@SYS26185", purchParmUpdate.SumPurchId));
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkW9Received</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method is overridden in an extended class.
    /// </summary>
    /// <param name="_purchParmTable">
    ///    The <c>PurchParmTable</c> record that contains the <c>VendorAccount</c> object.
    /// </param>
    /// <returns>
    ///    Always returns true.
    /// </returns>
    public boolean checkW9Received(VendDocumentTableMap _purchParmTable)
    {
        return true;  // Overridden in PurchFormLetter_Invoice
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a record from the <c>PurchParmTable</c> or <c>VendInvoiceInfoTable</c> table that is based
    /// on the <c>chooseLines</c> query.
    /// </summary>
    /// <param name="_processAdditional">
    /// A Boolean value that indicates whether additional data sources should be processed by the
    /// <c>chooseLines</c> query.
    /// </param>
    /// <param name="_parmTable">
    /// A record from the <c>PurchParmTable</c> or <c>VendInvoiceInfoTable</c> table.
    /// </param>
    /// <param name="_append">
    /// A Boolean value that indicates whether existing records should be removed.
    /// </param>
    public void chooseLines(boolean                 _processAdditional      = false,
                            VendDocumentTableMap    _parmTable              = this.initParmTable(),
                            boolean                 _append                 = false
                            )
    {
        container               outputContainer;
        this.parmProcessAdditional(_processAdditional); // parameter is packed

        parmTable  = _parmTable;
        purchFormLetterContract.parmParmTable(parmTable);

        outputContainer = this.chooseLinesServer(_append);

        this.getValuesFormletterParmData(this.unpackFormletterParmDataOutputContract(outputContainer));
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLines_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates <c>PurchParmTable</c> or <c>VendInvoiceInfoTable</c> table records based on the chooseLines query.
    /// </summary>
    /// <param name="_customsImportOrderType">
    /// A CustomsImportOrderType_IN enum value which determines which type of orders to be queried by the chooseLines query.
    /// </param>
    /// <param name="_parmTable">
    /// The <c>PurchParmTable</c> or <c>VendInvoiceInfoTable</c> table record.
    /// </param>
    /// <param name="_append">
    /// A Boolean value which determines whether existing records should be removed.
    /// </param>
    public void chooseLines_IN(CustomsImportOrderType_IN _customsImportOrderType,
                               VendDocumentTableMap      _parmTable = null,
                               boolean                   _append = false)
    {
        container               outputContainer;
        // parameter is packed
        this.parmProcessAdditional(false);

        parmTable       = _parmTable;
        outputContainer = PurchFormletterParmData::chooseLinesServer_IN(this.packDataContract(purchFormLetterContract),
                                                                        _append,
                                                                        _customsImportOrderType,
                                                                        this.parmId() ? true : false);

        this.getValuesFormletterParmData(this.unpackFormletterParmDataOutputContract(outputContainer));
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLinesServer</Name>
				<Source><![CDATA[
    protected container chooseLinesServer(boolean    _append = false)
    {
        return PurchFormletterParmData::chooseLinesServer(this.packDataContract(purchFormLetterContract),
                                                          _append,
                                                          this.parmId() ? true : false,
                                                          false,
                                                          false,
                                                          this.showQueryForm());
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupDialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides a way to clean up after a dialog box has been canceled.
    /// </summary>
    protected void  cleanupDialog()
    {
        if (!currentBatch)
        {
            PurchParmUpdate::deleteWithoutUpdate(this.purchParmUpdate().ParmId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeParmLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Closes <c>PurchParmLine</c> records based on select criteria.
    /// </summary>
    /// <param name="_parmId">
    ///  A select criteria; optional.
    /// </param>
    public void closeParmLines(ParmId _parmId = this.parmId())
    {
        PurchParmTable  purchParmTable;
        PurchParmLine   purchParmLine;

        ttsBegin;
        while select forUpdate purchParmLine
            join purchParmTable
                where purchParmTable.ParmId == purchParmLine.ParmId
                    && purchParmTable.TableRefId == purchParmLine.TableRefId
                    && purchParmLine.ParmId == _parmId
        {
            purchParmLine.closed = NoYes::Yes;
            purchParmLine.modifiedClosed();
            purchParmLine.update();
        }
        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createParmUpdateFromParmUpdateRecord</Name>
				<Source><![CDATA[
    public void createParmUpdateFromParmUpdateRecord(PurchParmUpdate _purchParmUpdate)
    {
        PurchParmUpdate purchParmUpdate;
        purchParmUpdate.data(_purchParmUpdate);

        if (this.parmId())
        {
            purchParmUpdate.ParmId = this.parmId();
        }
        else
        {
            this.parmId(purchParmUpdate.ParmId);
        }

        if (! PurchParmUpdate::exist(purchParmUpdate.ParmId))
        {
            purchParmUpdate.insert();
        }
        this.purchParmUpdate(purchParmUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditRemaining</Name>
				<Source><![CDATA[
    public boolean  creditRemaining(boolean  _creditRemaining = purchFormLetterContract.parmCreditRemaining())
    {
        PurchParmUpdate purchParmUpdate = this.purchParmUpdate();
        purchParmUpdate.CreditRemaining = _creditRemaining;
        this.purchParmUpdate(purchParmUpdate);
        purchFormLetterContract.parmCreditRemaining(_creditRemaining);
        return purchParmUpdate.CreditRemaining;
    }

]]></Source>
			</Method>
			<Method>
				<Name>currentPurchParmTable</Name>
				<Source><![CDATA[
    public VendDocumentTableMap  currentPurchParmTable()
    {
        Common localParmTable = parmTable;
        if (parmTable.TableId == tableNum(VendDocumentTableMap))
        {
            // do not allow an uninitialized map to be passed back the the caller as a runtime violation will occur.

            localParmTable = this.initParmTable();
        }
        purchFormLetterContract.parmParmTable(localParmTable);

        return parmTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteParmUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs the necessary cleanup when the process encounters a failure.
    /// </summary>
    public void deleteParmUpdate()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteWithoutUpdate</Name>
				<Source><![CDATA[
    protected void deleteWithoutUpdate(ParmId _parmId)
    {
        PurchParmTable::deleteWithoutUpdate(_parmId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    /// interface.
    /// </summary>
    /// <returns>
    /// A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    /// A dialog box can be either built by using the <c>Dialog</c> class or by using a class that is
    /// created in the Application Object Tree (AOT).
    /// </remarks>
    public IDialogable  dialog()
    {
        // Overridden in PurchFormLetter_Invoice

        this.prePromptInitForBatchTask();

        if (showDialog)
        {
            if (!purchEditLinesForm)
            {
                purchEditLinesForm = classfactory.formRunClass(FormLetterServiceController::newClientArgs(formStr(PurchEditLines), this));
                purchEditLinesForm.init();
            }

            return purchEditLinesForm as IDialogable;
        }
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogRun</Name>
				<Source><![CDATA[
    protected SysOperationStartResult dialogRun()
    {
        if (!this.parmCallerFormName()
            && !this.isInBatch()
            && !this.parmId()
            && PurchFormLetterCreateFromBatchFlight::instance().isEnabled())
        {
            this.parmLoadFromSysLastValue(false);
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>doCheckAdvancePaymentsOnValidate_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether advance payments should be checked when validate preformed
    /// </summary>
    /// <returns>
    /// True, but can be overridden in descendants
    /// </returns>
    protected boolean doCheckAdvancePaymentsOnValidate_RU()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentDate</Name>
				<Source><![CDATA[
    public DocumentDate documentDate()
    {
        VendDocumentTableMap localParmTable = this.initParmTable();

        localParmTable.Ordering = this.documentStatus();
        localParmTable.defaultField(VendDocumentUtil::fieldNum(fieldNum(VendDocumentTableMap, DocumentDate), localParmTable.TableId));
        return localParmTable.DocumentDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentPostMessaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides message to user if a set of documents successfully post
    /// </summary>
    /// <param name = "_parmIds">ParmId of the record that was posted</param>
    /// <param name = "_numberOfRecords">Number of records which were posted</param>
    /// <returns>True if message posted to user; false otherwise</returns>
    public boolean documentPostMessaging(container _parmIds, Counter _numberOfRecords = 0)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doRefreshCallerDataSource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if datasource caller should be refreshed.
    /// </summary>
    /// <returns>
    /// Always returns false.
    /// </returns>
    public boolean doRefreshCallerDataSource()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editLinesChanged</Name>
				<Source><![CDATA[
    public boolean  editLinesChanged(boolean  _editLinesChanged = editLinesChanged)
    {
        editLinesChanged = _editLinesChanged;
        return editLinesChanged;
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableUpdateNowField</Name>
				<Source><![CDATA[
    public boolean enableUpdateNowField(boolean _enableUpdateNow = enableUpdateNow)
    {
        enableUpdateNow = _enableUpdateNow;

        return enableUpdateNow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>endUpdate</Name>
				<Source><![CDATA[
    public void  endUpdate()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPurchFormLetterContract</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to return the current PurchFormLetterContract object.
    /// </summary>
    /// <returns>
    /// Return the current PurchFormLetterContract object.
    /// </returns>
    public PurchFormLetterContract getPurchFormLetterContract()
    {
        return purchFormLetterContract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getValuesFormletterParmData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves various values from the <c>FormLetterParmDataOutputContract</c>.
    /// </summary>
    /// <param name="_outputContract">
    /// The <c>FormLetterParmDataOutputContract</c> to retrieve the values from.
    /// </param>
    protected void getValuesFormletterParmData(FormLetterParmDataOutputContract _outputContract)
    {
        QueryRun queryRun;
        if (_outputContract.parmChooseLinesQueryPacked())
        {
            queryRun = new QueryRun(SysOperationHelper::base64Decode(_outputContract.parmChooseLinesQueryPacked()));
        }

        this.parmId(_outputContract.parmParmId());
        this.parmDataSourceRecordsPacked(conNull());
        if (queryRun)
        {
            this.parmQueryUsed(queryRun.query());
        }
        this.purchParmUpdate(_outputContract.parmParmUpdate());
        lastParmTableRecId = _outputContract.parmLastParmTableRecId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBOEParmLines_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the BOE parameter lines.
    /// </summary>
    /// <param name="_purchParmTable">
    /// The purch parameter table.
    /// </param>
    public void initBOEParmLines_IN(PurchParmTable _purchParmTable)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLinesQuery</Name>
				<Source><![CDATA[
    public void initLinesQuery(boolean _deletePending = true)
    {
        this.chooseLines(_deletePending);// if _deletePending then re-process additional lines to recreate from saved invoices
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLinesQuery_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize lines query.
    /// </summary>
    /// <param name="_customsImportOrderType">
    /// The import customs order type.
    /// </param>
    public void initLinesQuery_IN(CustomsImportOrderType_IN _customsImportOrderType)
    {
        this.chooseLines_IN(_customsImportOrderType);// if _deletePending then re-process additional lines to recreate from saved invoices
    }

]]></Source>
			</Method>
			<Method>
				<Name>initNewPurchParmUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of <c>PurchParmUpdate</c> internally.
    /// </summary>
    public void initNewPurchParmUpdate()
    {
        PurchParmUpdate purchParmUpdate = PurchFormletterParmData::initpurchParmUpdateFormletter(this.documentStatus(), this.pack());
        this.parmId(purchParmUpdate.ParmId);

        purchParmUpdate.SpecQty = PurchUpdate::All;

        this.createParmUpdateFromParmUpdateRecord(purchParmUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOfficials_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes officials for current update
    /// </summary>
    /// <param name="_parmTable">
    /// <c>VendDocumentTableMap</c> record to create officials for
    /// </param>
    public void initOfficials_RU(VendDocumentTableMap _parmTable = null)
    {
        PurchFormletterParmData purchFormletterParmData;
        FormDataSource          formDataSource;
        PurchParmTable purchParmTable;

        purchParmTable = _parmTable.getTableInInstanceHierarchy(PurchParmTable.TableId);

        purchFormletterParmData = PurchFormLetterParmData::newReSelect(this.packDataContract(purchFormLetterContract), purchParmTable);
        purchFormletterParmData.initOfficials_RU(_parmTable);

        if (this.isInBatch() != true)
        {
            // Assuming UI bound execution of this code:
            formDataSource = FormDataUtil::getFormDataSource( _parmTable);
            if (formDataSource)
            {
                formDataSource.reread();
                formDataSource.refresh();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParameters</Name>
				<Source><![CDATA[
    public void  initParameters(PurchParmUpdate    _purchParmUpdate        = this.purchParmUpdate(),
                                Printout           _printout               = this.printout(),
                                NoYes              _printFormLetter        = this.printFormLetter(),
                                NoYes              _usePrintManagement     = this.usePrintManagement(),
                                NoYes              _useVendPrintOptions    = mcrUseVendPrintOptions)
    {
        this.purchParmUpdate(_purchParmUpdate);
        this.parmNumber(_purchParmUpdate.SumNum);
        this.printout(_printout);
        this.printFormLetter(_printFormLetter);
        this.usePrintManagement(_usePrintManagement);

        mcrUseVendPrintOptions = _useVendPrintOptions;

        if (this.purchParmUpdate().SumBy)
        {
            ttsbegin;

            parmTable.reread();

            this.udpateNum(_purchParmUpdate);

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmPurchTable</Name>
				<Source><![CDATA[
    protected void  initParmPurchTable(PurchTable  _purchTable)
    {
        this.purchTable(_purchTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmTable</Name>
				<Source><![CDATA[
    protected VendDocumentTableMap initParmTable()
    {
        PurchParmTable localPurchParmTable; // Overridden in PurchFormLetter_Invoice
        return localPurchParmTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmUpdate</Name>
				<Source><![CDATA[
    protected void  initParmUpdate(boolean  _createNew = false)
    {
        PurchParmUpdate purchParmUpdate = this.purchParmUpdate();

        if (_createNew)
        {
            purchParmUpdate.clear();

            purchParmUpdate.ParmId          = this.parmId();
            purchParmUpdate.DocumentStatus  = this.documentStatus();
        }
        else
        {
            purchParmUpdate = PurchParmUpdate::find(this.parmId());
        }
        this.purchParmUpdate(purchParmUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertDraft</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts a draft copy of the document from the current <c>PurchParmTable</c> table.
    /// </summary>
    /// <exception cref="M:exception::error">
    ///    The method is not overridden by the derived class.
    /// </exception>
    public void insertDraft()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyNoSalesFormletterUpdate</Name>
				<Source><![CDATA[
    public boolean interCompanyNoSalesFormletterUpdate(boolean _noSalesFormletterUpdate = purchFormLetterContract.parmIntercompanyNoSalesFormletterUpdate())
    {
        return purchFormLetterContract.parmIntercompanyNoSalesFormletterUpdate(_noSalesFormletterUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanySelectFromJournal</Name>
				<Source><![CDATA[
    public boolean interCompanySelectFromJournal()
    {
        boolean ret;

        ret = super();

        if (this.purchParmUpdate().SpecQty == PurchUpdate::PackingSlip)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyVoucher</Name>
				<Source><![CDATA[
    public InterCompanyVoucher  interCompanyVoucher(InterCompanyVoucher  _interCompanyVoucher = purchFormLetterContract.parmIntercompanyVoucher())
    {
        return purchFormLetterContract.parmIntercompanyVoucher(_interCompanyVoucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceAccountInQuery</Name>
				<Source><![CDATA[
    public boolean  invoiceAccountInQuery()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBatchProcess</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the current process will be executed in a batch.
    /// </summary>
    /// <returns>
    ///    true if the process will be executed in a batch; otherwise, false.
    /// </returns>
    public boolean isBatchProcess()
    {
        return this.batchInfo() && (this.batchInfo().parmBatchExecute() );
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEGAISPosting_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Detemines if the current posting is EGAIS posting, i.e. posting that has been called from EGAIS waybill journal.
    /// </summary>
    /// <returns>
    ///    true, if the current posting is EGAIS posting; otherwise, false.
    /// </returns>
    public boolean isEGAISPosting_RU()
    {
        return this.parmCallerTable().TableId == tableNum(EGAISWaybillJour_RU);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lateSelection</Name>
				<Source><![CDATA[
    public boolean lateSelection()
    {
        return this.purchParmUpdate().LateSelection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lateSelectionRemoveLines</Name>
				<Source><![CDATA[
    public boolean  lateSelectionRemoveLines()
    {
        boolean  ok = true;   // Overridden in PurchFormLetter_Invoice
        PurchParmUpdate purchParmUpdate = this.purchParmUpdate();
        if (purchParmUpdate.LateSelection  &&  purchParmUpdate.numberOfTables() > 0)
        {
            if (Box::yesNo("@SYS72909", DialogButton::Yes))
            {
                this.deleteWithoutUpdate(purchParmUpdate.ParmId);
            }
            else
            {
                purchParmUpdate.LateSelection = false;
                ok = false;
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrEmailDialogPrompt</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Prompts the user for applicable email information.
    /// </summary>
    /// <returns>
    ///     The input give by the user to the prompt.
    /// </returns>
    public container mcrEmailDialogPrompt()
    {
        Dialog              theDialog;
        DialogField         fieldEmailAddress;
        DialogText          fieldText;

        theDialog          = new Dialog("@MCR10633");
        fieldText          = theDialog.addText("@MCR10634");
        fieldEmailAddress  = theDialog.addField(extendedtypestr(Email));

        if (! theDialog.run())
        {
            return conNull();
        }

        return [fieldEmailAddress.value()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrShowVendPrintOptionsCheckBox</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates that the vendor print options checkbox should not be shown.
    /// </summary>
    /// <returns>
    /// false to indicate that the vendor print options checkbox should not be shown.
    /// </returns>
    public boolean mcrShowVendPrintOptionsCheckBox()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrUseVendPrintOptions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets whether the vendor print options should be used.
    /// </summary>
    /// <param name="_useVendPrintOptions">
    /// Indicates whether the vendor print options should be used.
    /// </param>
    /// <returns>
    /// true if the vendor print options should be used; otherwise, false.
    /// </returns>
    public boolean mcrUseVendPrintOptions(boolean _useVendPrintOptions = mcrUseVendPrintOptions)
    {
        mcrUseVendPrintOptions = _useVendPrintOptions;
        return mcrUseVendPrintOptions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrValidatePrinterSetting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the printer settings.
    /// </summary>
    /// <param name="_PurchTable">
    /// The purchase order record.
    /// </param>
    /// <param name="_PrinterSettings">
    /// The printer settings to be validated.
    /// </param>
    /// <returns>
    /// true if the printer settings are valid; otherwise, false.
    /// </returns>
    public PrintJobSettings mcrValidatePrinterSetting(PurchTable _PurchTable,
                                            PrintJobSettings    _PrinterSettings)
    {
        container           dialogVal;
        Email               Email;

        switch (_PrinterSettings.getTarget())
        {
            case PrintMedium::Mail:
                if (!_PrinterSettings.mailTo())
                {
                    // If not run in batch, prompt the
                    //  user to enter an email address
                    if (! this.purchParmUpdate().lateSelection)
                    {
                        dialogVal = this.MCREmailDialogPrompt();
                        [Email] = dialogVal;
                        if (Email)
                        {
                            _PrinterSettings.mailTo(Email );
                            _PrinterSettings.mailSubject("@MCR10735");
                        }
                        else
                        {
                            throw error("@MCR10734");
                        }
                    }
                }
                break;
            default:
                break;
        }

        return _PrinterSettings;
    }

]]></Source>
			</Method>
			<Method>
				<Name>missingNumber</Name>
				<Source><![CDATA[
    public str  missingNumber()
    {
        return "@SYS24729";
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifyVoucherDate</Name>
				<Source><![CDATA[
    public void  modifyVoucherDate(TransDate  _transDate)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckIntrastat</Name>
				<Source><![CDATA[
    /// <summary>
    /// Signifies if Intrastat needs to be checked.
    /// </summary>
    /// <returns>
    /// true if Intrastat related logic must be checked when purch line is changed; otherwise, false.
    /// </returns>
    protected boolean mustCheckIntrastat()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>needVarianceApproval</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified record in the <c>PurchParmTable</c> or <c>VendInvoiceInfoTable</c>
    /// table allows for variance approval.
    /// </summary>
    /// <param name="_parmTable">
    /// The record to check.
    /// </param>
    /// <returns>
    /// true if the provided record allows for variance approval; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by derived classes.
    /// </remarks>
    public boolean needVarianceApproval(VendDocumentTableMap _parmTable)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void  new(
        IdentifierName _className='',
        IdentifierName _methodName='',
        SysOperationExecutionMode _executionMode = SysOperationExecutionMode::Synchronous)
    {
        super(_className, _methodName, _executionMode);
        purchFormLetterContract = contract;

        purchQuantity = PurchQuantity::construct(this.documentStatus());

        this.reArrangeNow(true);

        updateSalesLines    = false;

        doInterCompanyMarkupAllocation = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        if (formletterOutputContract)
        {
            packedOutputContract = formletterOutputContract.pack();
        }
        return [#CurrentVersion + #parentVersion, #ParmListCommonCS] + [super()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAutoConsolidate</Name>
				<Source><![CDATA[
    public boolean parmAutoConsolidate(boolean _autoConsolidate = false)
    {
        // Only used for invoice.
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmClearTotals</Name>
				<Source><![CDATA[
    public boolean parmClearTotals(boolean _clearTotals = purchFormLetterContract.parmClearTotals())
    {
        return purchFormLetterContract.parmClearTotals(_clearTotals);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDeletePurchLineRecIdSet</Name>
				<Source><![CDATA[
    public container parmDeletePurchLineRecIdSet(container _packedDeletePurchLineRecIdSet = SysOperationHelper::base64Decode(purchFormLetterContract.parmDeletePurchLineRecIdSet()))
    {
        purchFormLetterContract.parmDeletePurchLineRecIdSet(SysOperationHelper::base64Encode(_packedDeletePurchLineRecIdSet));
        return _packedDeletePurchLineRecIdSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDeletePurchTablePurchIdSet</Name>
				<Source><![CDATA[
    public container parmDeletePurchTablePurchIdSet(container _packedDeletePurchTablePurchIdSet = SysOperationHelper::base64Decode(purchFormLetterContract.parmDeletePurchTablePurchIdSet()))
    {
        purchFormLetterContract.parmDeletePurchTablePurchIdSet(SysOperationHelper::base64Encode(_packedDeletePurchTablePurchIdSet));
        return _packedDeletePurchTablePurchIdSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDocumentOrigin</Name>
				<Source><![CDATA[
    public DocumentOrigin parmDocumentOrigin(DocumentOrigin _documentOrigin = purchFormLetterContract.parmDocumentOrigin())
    {
        return purchFormLetterContract.parmDocumentOrigin(_documentOrigin);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventLocationId_PL</Name>
				<Source><![CDATA[
    public InventLocationId parmInventLocationId_PL(
        InventLocationId _inventLocationId = purchFormLetterContract.parmInventLocationId_PL())
    {
        return purchFormLetterContract.parmInventLocationId_PL(_inventLocationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInvoiceType</Name>
				<Source><![CDATA[
    public PurchInvoiceType parmInvoiceType(PurchInvoiceType _invoiceType = purchFormLetterContract.parmInvoiceType())
    {
        return purchFormLetterContract.parmInvoiceType(_invoiceType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLastParmTableRecId</Name>
				<Source><![CDATA[
    public RefRecId parmLastParmTableRecId()
    {
        return lastParmTableRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalTrans</Name>
				<Source><![CDATA[
    public LedgerJournalTrans parmLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans = purchFormLetterContract.parmLedgerJournalTrans())
    {
        return purchFormLetterContract.parmLedgerJournalTrans(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNewPurchLineRecIdSet</Name>
				<Source><![CDATA[
    public container parmNewPurchLineRecIdSet(container _packedNewPurchLineRecIdSet = SysOperationHelper::base64Decode(purchFormLetterContract.parmNewPurchLineRecIdSet()))
    {
        purchFormLetterContract.parmNewPurchLineRecIdSet(SysOperationHelper::base64Encode(_packedNewPurchLineRecIdSet));
        return _packedNewPurchLineRecIdSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNumber</Name>
				<Source><![CDATA[
    public Num parmNumber(Num _number = purchFormLetterContract.parmNumber())
    {
        return purchFormLetterContract.parmNumber(_number);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParmTableNum</Name>
				<Source><![CDATA[
    public Num parmParmTableNum(Num _parmTableNum = purchFormLetterContract.parmParmTableNum())
    {
        return purchFormLetterContract.parmParmTableNum(_parmTableNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPreserveReceiptStatement</Name>
				<Source><![CDATA[
    public boolean parmPreserveReceiptStatement(boolean _preserveReceiptStatement = purchFormLetterContract.parmPreserveReceiptStatement())
    {
        return purchFormLetterContract.parmPreserveReceiptStatement(_preserveReceiptStatement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProcessAdditional</Name>
				<Source><![CDATA[
    public boolean parmProcessAdditional(boolean _processAdditional = purchFormLetterContract.parmProcessAdditional())
    {
        return purchFormLetterContract.parmProcessAdditional(_processAdditional);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQueryChooseLinesPendingInvoice</Name>
				<Source><![CDATA[
    public QueryRun parmQueryChooseLinesPendingInvoice(QueryRun _chooseLinesPendingInvoice = null)
    {
        // Only used for invoice.
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReceiptListDeviationType_RU</Name>
				<Source><![CDATA[
    public ReceiptListDeviationType_RU parmReceiptListDeviationType_RU(ReceiptListDeviationType_RU _receiptListDeviationType = purchFormLetterContract.parmReceiptListDeviationType_RU())
    {
        return purchFormLetterContract.parmReceiptListDeviationType_RU(_receiptListDeviationType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSADCurrencyCode_PL</Name>
				<Source><![CDATA[
    public CurrencyCode parmSADCurrencyCode_PL(
        CurrencyCode _sadCurrencyCode = purchFormLetterContract.parmSADCurrencyCode_PL())
    {
        return purchFormLetterContract.parmSADCurrencyCode_PL(_sadCurrencyCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSADExchRate_PL</Name>
				<Source><![CDATA[
    public ExchRate parmSADExchRate_PL(
        ExchRate _sadExchRate = purchFormLetterContract.parmSADExchRate_PL())
    {
        return purchFormLetterContract.parmSADExchRate_PL(_sadExchRate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSADNumberCode_PL</Name>
				<Source><![CDATA[
    public PlSADNumberCode parmSADNumberCode_PL(
        PlSADNumberCode _sadNumberCode = purchFormLetterContract.parmSADNumberCode_PL())
    {
        return purchFormLetterContract.parmSADNumberCode_PL(_sadNumberCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSaveChanges</Name>
				<Source><![CDATA[
    public boolean parmSaveChanges(boolean _saveChanges = false)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceTable</Name>
				<Source><![CDATA[
    public PurchTable parmSourceTable(Common _purchTable = contract.parmSourceTable())
    {
        return contract.parmSourceTable(_purchTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWQtyInvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method calls purchQuantity.pdsCWQtyInvent and
    /// returns the resulting container.
    /// </summary>
    /// <param name="_purchLine">
    /// PurchLine record for which to calculate CW inventory.
    /// </param>
    /// <param name="_qty">
    /// Qty to calculate.
    /// </param>
    /// <returns>
    /// Resulting calculated values for
    /// RemainBefore, RemainAfter and ReceiveNow calculated from purchLine
    /// parameter.
    /// </returns>
    public container pdsCWQtyInvent(
        PurchLine   _purchLine,
        PurchQty    _qty = naReal())
    {
        PurchParmUpdate purchParmUpdate = this.purchParmUpdate();

        return purchQuantity.pdsCWQtyInvent(
                                _purchLine,
                                purchParmUpdate.SpecQty,
                                _qty,
                                purchParmUpdate.CreditRemaining);
    }

]]></Source>
			</Method>
			<Method>
				<Name>prePromptInit</Name>
				<Source><![CDATA[
    public void prePromptInit()
    {
        container outputContainer;

        if ((this.parmCallerTable() && this.parmCallerTable().TableId != tableNum(VendTable))
            || this.purchTable() || this.parmLedgerJournalTrans().Voucher || wmsJournalTable_ds)
        {
            this.showQueryForm(this.mustShowQueryForm());

            this.initLinesQuery();
        }
        else
        {
            this.showQueryForm(true);
            this.currentPurchParmTable();
            outputContainer = PurchFormletterParmData::chooseLinesServer(this.packDataContract(purchFormLetterContract),
                                                                         false,
                                                                         false,
                                                                         true);

            this.getValuesFormletterParmData(this.unpackFormletterParmDataOutputContract(outputContainer));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustShowQueryForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if query form must be shown.
    /// </summary>
    /// <returns>
    /// true if the query form must be shown; otherwise, false.
    /// </returns>
    protected boolean mustShowQueryForm()
    {
        return this.parmLedgerJournalTrans().Voucher && !(this.parmLedgerJournalTrans().PurchIdRange || callerFormName == formStr(VendInvoiceInfoListPage) || callerFormName == formStr(VendUnpostedInvoiceJournal));
    }

]]></Source>
			</Method>
			<Method>
				<Name>prePromptInitForBatchTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calling prePromptInit method to initialize purchParmUpdate record if this batch is created from batch task.
    /// </summary>
    protected void prePromptInitForBatchTask()
    {
        if (this.parmCurrentBatch() && !PurchParmUpdate::exist(purchFormLetterContract.parmParmId()))
        {
            this.prePromptInit();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>prePromptModifyData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Pre-prompts modified data.
    /// </summary>
    public void prePromptModifyData()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>printGRN_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prints goods receipt note.
    /// </summary>
    /// <param name="_printGoodsReceiptNote">
    /// The goods receipt note.
    /// </param>
    /// <returns>
    /// true if the goods receipt note is printed.
    /// </returns>
    public boolean printGRN_IN(boolean _printGoodsReceiptNote = purchFormLetterContract.parmPrintGRN_IN())
    {
        return purchFormLetterContract.parmPrintGRN_IN(_printGoodsReceiptNote);
    }

]]></Source>
			</Method>
			<Method>
				<Name>printMgmtNodeType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Identifies the print management node type.
    /// </summary>
    /// <returns>
    /// The print management node type for purchase.
    /// </returns>
    protected PrintMgmtNodeType printMgmtNodeType()
    {
        return PrintMgmtNodeType::Purch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>printout</Name>
				<Source><![CDATA[
    public Printout  printout(Printout _printout = purchFormLetterContract.parmPrintOut())
    {
        if (this.proforma())
        {
            return purchFormLetterContract.parmPrintOut(Printout::Current);
        }
        
        if (this.mustPrintInAfterOperation())
        {
            return purchFormLetterContract.parmPrintOut(Printout::After);
        }

        return purchFormLetterContract.parmPrintOut(_printout);
    }

]]></Source>
			</Method>
			<Method>
				<Name>printPosted</Name>
				<Source><![CDATA[
    public void  printPosted()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>printProductLabels</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets a value indicating whether to print product labels.
    /// </summary>
    /// <param name="_printProductLabels">
    /// A value indicating to print product labels.
    /// </param>
    /// <returns>
    /// true if product labels should be printed; otherwise, false.
    /// </returns>
    public boolean printProductLabels(boolean _printProductLabels = purchFormLetterContract.parmPrintProductLabel())
    {
        return purchFormLetterContract.parmPrintProductLabel(_printProductLabels);
    }

]]></Source>
			</Method>
			<Method>
				<Name>printSalesFormLetter</Name>
				<Source><![CDATA[
    public boolean  printSalesFormLetter(boolean  _printSalesFormLetter = purchFormLetterContract.parmPrintSalesFormLetter())
    {
        return purchFormLetterContract.parmPrintSalesFormLetter(_printSalesFormLetter);
    }

]]></Source>
			</Method>
			<Method>
				<Name>printShelfLabels</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or Sets the parameter to indicate whether to print labels for shelf.
    /// </summary>
    /// <param name="_PrintShelfLabels">
    /// A Boolean value that is used for setting the value on the parameter.
    /// </param>
    /// <returns>
    /// true if labels for shelf should be printed; otherwise, false.
    /// </returns>
    public boolean printShelfLabels(boolean _PrintShelfLabels = purchFormLetterContract.parmPrintShelfLabel())
    {
        return purchFormLetterContract.parmPrintShelfLabel(_PrintShelfLabels);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processProjectItemRequirements</Name>
				<Source><![CDATA[
    /// <summary>
    /// Consume the item automatically for the project item requirements.
    /// </summary>
    /// <param name = "_outputContract">
    /// A <c>FormletterOutputContract</c> object.
    /// </param>
    protected void processProjectItemRequirements(FormletterOutputContract _outputContract)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>finalProcessing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes final processing after the main operation has completed.
    /// </summary>
    protected void finalProcessing()
    {
        if (Project::Enabled())
        {
            this.processProjectItemRequirements(this.getOutputContract());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>proforma</Name>
				<Source><![CDATA[
    public boolean  proforma(boolean  _proforma = this.purchParmUpdate().Proforma)
    {
        PurchParmUpdate purchParmUpdate = this.purchParmUpdate();
        purchParmUpdate.Proforma = _proforma;
        this.purchParmUpdate(purchParmUpdate);
        purchFormLetterContract.parmProforma(_proforma);
        return purchParmUpdate.Proforma;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchEditLinesExecuteQuery</Name>
				<Source><![CDATA[
    public void  purchEditLinesExecuteQuery()
    {
        purchEditLinesDatasource.executeQuery();
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchParmUpdate</Name>
				<Source><![CDATA[
    public PurchParmUpdate  purchParmUpdate(PurchParmUpdate  _purchParmUpdate = purchFormLetterContract.parmParmUpdate() as PurchParmUpdate)
    {
        if (!prmisDefault(_purchParmUpdate))
        {
            purchFormLetterContract.parmLateSelection(_purchParmUpdate.LateSelection);
        }
        return purchFormLetterContract.parmParmUpdate(_purchParmUpdate) as PurchParmUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTable</Name>
				<Source><![CDATA[
    public PurchTable  purchTable(PurchTable  _purchTable = purchFormLetterContract.parmPurchTable())
    {
        this.parmSourceTable(_purchTable);
        return purchFormLetterContract.parmPurchTable(_purchTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyInvent</Name>
				<Source><![CDATA[
    public container  qtyInvent(PurchLine     _purchLine,
                                InventQty     _qty = naReal())
    {
        PurchParmUpdate purchParmUpdate = this.purchParmUpdate();
        return purchQuantity.qtyInvent(_purchLine, purchParmUpdate.SpecQty, _qty, purchParmUpdate.CreditRemaining);
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyPurch</Name>
				<Source><![CDATA[
    public container  qtyPurch(PurchLine     _purchLine,
                               PurchQty      _qty     = naReal(),
                               PurchUpdate   _specQty = this.purchParmUpdate().SpecQty)
    {
        PurchParmUpdate purchParmUpdate = this.purchParmUpdate();
        return purchQuantity.qtyPurch(_purchLine, _specQty, _qty, purchParmUpdate.CreditRemaining);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reArrange</Name>
				<Source><![CDATA[
    public boolean  reArrange(boolean   _clearTotals = false,
                              boolean   _validate    = true,
                              boolean   _logErrors   = false)
    {
        boolean                     ok = true;
        container                   outputContainer;

        if (_validate  &&  !this.validate())
        {
            ok = false;
        }

        if (!this.reArrangeValidate(_logErrors))
        {
            ok = false;
        }

        if (ok)
        {
            purchFormLetterContract.parmClearTotals(_clearTotals); // parameter is packed
            outputContainer = PurchFormletterParmData::reArrangeServer(this.packDataContract(purchFormLetterContract), this.isInBatch());
            this.reArrangeNow(false);
            this.getValuesFormletterParmData(this.unpackFormletterParmDataOutputContract(outputContainer));
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reArrangeNow</Name>
				<Source><![CDATA[
    public boolean  reArrangeNow(boolean  _reArrangeNow = reArrangeNow)
    {
        reArrangeNow = _reArrangeNow;
        return reArrangeNow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reArrangeValidate</Name>
				<Source><![CDATA[
    protected boolean reArrangeValidate(boolean _logErrors = false)
    {
        if (! this.checkPrepayCrossPurchOrder())
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recommendedSpecQty</Name>
				<Source><![CDATA[
    public PurchUpdate recommendedSpecQty()
    {
        return PurchParameters::find().recommendedSpecQty(this.documentStatus());
    }

]]></Source>
			</Method>
			<Method>
				<Name>reSelect</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reselects the order lines by a quantity specification.
    /// </summary>
    /// <param name="_purchParmUpdate">
    /// A <c>PurchParmUpdate</c> record.
    /// </param>
    /// <param name="_inventLocationId">
    /// Inventory location ID for Documents numbering by warehouse
    /// </param>
    public void  reSelect(
        PurchParmUpdate  _purchParmUpdate
        ,InventLocationId _inventLocationId = this.parmInventLocationId_PL()
        )
    {
        container outputContainer;
        
        if (this.mustReselectOrderLine(_purchParmUpdate, _inventLocationId))
        {
            PurchParmUpdate purchParmUpdate = _purchParmUpdate;
            this.purchParmUpdate(purchParmUpdate);
            this.creditRemaining(purchParmUpdate.CreditRemaining);
            // <GEEPL>
            this.parmInventLocationId_PL(_inventLocationId);
            // </GEEPL>

            outputContainer = PurchFormletterParmData::reSelectServer(this.packDataContract(purchFormLetterContract));
            this.getValuesFormletterParmData(this.unpackFormletterParmDataOutputContract(outputContainer));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustReselectOrderLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the order line reselection must be done.
    /// </summary>
    /// <param name = "_purchParmUpdate">
    /// A <c>PurchParmUpdate</c> record.
    /// </param>
    /// <param name = "_inventLocationId">
    /// Inventory location ID for Documents numbering by warehouse.
    /// </param>
    /// <returns>
    /// true if the reselection must be done; otherwise, false.
    /// </returns>
    protected boolean mustReselectOrderLine(PurchParmUpdate _purchParmUpdate, InventLocationId _inventLocationId)
    {
        PurchParmUpdate purchParmUpdate = this.purchParmUpdate();

        return (purchParmUpdate.SpecQty           != _purchParmUpdate.SpecQty
               || purchParmUpdate.CreditRemaining != _purchParmUpdate.CreditRemaining
               // <GEEPL>
               || this.parmInventLocationId_PL()  != _inventLocationId);
               // </GEEPL>
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetParmListCommonCS</Name>
				<Source><![CDATA[
    public void resetParmListCommonCS()
    {
        List    list = new List(Types::Record);
        InterCompanyMapRecord interCompanyMapRecord = InterCompanyMapRecord::construct();

        super();

        this.parmId('');
        this.editLinesChanged(false);
        this.reArrangeNow(true);
        this.initAllowEmptyTable(false);
        this.allowEmptyTable(false);
        this.enableUpdateNowField(false);
        this.showQueryForm(false);
        this.multiForm(false);
        this.transDate(dateNull());
        this.wmsJournalTableDsIsSet(false);
        this.parmNumber('');
        this.parmCallerMenuItem('');
        this.purchTable(null);
        this.parmIdSynched('');
        this.chooseLinesQuery(null);
        this.parmInterCompanyCompanyId('');
        this.creditRemaining(false);
        this.parmDataSourceRecordsPacked(conNull());
        this.parmHistoryList(conNull());
        this.parmCallerTable(null);
        this.parmProcessAdditional(false);
        this.parmClearTotals(false);
        purchFormLetterContract.parmSpecQtyIsSet(false);
        this.interCompanyParmId('');
        this.interCompanyMap(interCompanyMapRecord.map());
        this.parmLineList(list.pack());
        this.parmParmTableNum('');
        this.interCompanyParmSelectFromJournal(false);
        this.interCompanyPosted(false);
        this.interCompanyNoSalesFormletterUpdate(false);
        this.interCompanyVoucher('');
        this.parmNewPurchLineRecIdSet(conNull());
        this.parmDeletePurchTablePurchIdSet(conNull());
        this.parmDeletePurchLineRecIdSet(conNull());
        this.parmLedgerJournalTrans(null);
        this.parmVersioningUpdateType(VersioningUpdateType::Initial);
        this.parmCreateFromHistory(false);
        this.createFromLines(false);
        this.validateAll(true);
        this.parmBatchJobId(0);
        this.parmBatchGroupId('');
        this.parmBatchCreatedBy('');
        this.parmDocumentOrigin(DocumentOrigin::Manual);
        this.parmInvoiceType(PurchInvoiceType::Standard);

        parmTable = this.initParmTable();
        packedOutputContract = conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Contains the code that does the actual job of the class.
    /// </summary>
    public void  run()
    {
        boolean reArrangeOK;
        Counter numberOfOrdersPosted, numberOfOrderLinesPosted;
        Microsoft.Dynamics.Application.Instrumentation.ApplicationEventSource::EventWritePurchFormLetterRunStart(className, methodName, 0, 0, 0, this.isInBatch());

        TradeInstrumentationStopwatch timer = TradeInstrumentationStopwatch::newStopwatch();

        using (SysErrorMessageHelpScope scope = SysErrorMessageHelpScope::newErrorContextBatchServerAndController(this))
        {
            if (reArrangeNow)
            {
                reArrangeOK = this.reArrange(false, false, true);
                if (!reArrangeOK)
                {
                    this.deleteParmUpdate();
                    throw error("@SYS21533");
                }
            }

            if (this.isInBatch())
            {
                this.init();
                this.parmBatchCreatedBy(this.parmCurrentBatch().CreatedBy);

                this.updateParametersForLateSelection();

                this.parmBatchJobId(this.parmCurrentBatch().BatchJobId);
                this.parmBatchGroupId(this.parmCurrentBatch().GroupId);
            }

            purchFormLetterContract.parmIsPrintingInAfterOperation(this.mustPrintInAfterOperation());
            super();
        }

        // Record the number of orders that were updated, as well as the total number of lines
        numberOfOrdersPosted = this.getOutputContract().parmNumberOfOrdersPosted();
        container journalLinesPacked = this.getOutputContract().parmJournalLinesPacked();
        if (journalLinesPacked)
        {
            numberOfOrderLinesPosted = List::create(journalLinesPacked).elements();
        }

        Microsoft.Dynamics.Application.Instrumentation.ApplicationEventSource::EventWritePurchFormLetterRunStop(className, methodName, numberOfOrdersPosted, numberOfOrderLinesPosted, timer.elapsedMilliseconds(), this.isInBatch());
    }

]]></Source>
			</Method>
			<Method>
				<Name>runShipCarrier</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes sales ShipCarrier functionality that will require user interaction.
    /// </summary>
    public void runShipCarrier()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setForUpdatePurchParmTable</Name>
				<Source><![CDATA[
    public void  setForUpdatePurchParmTable()
    {
        parmTable = PurchParmTable::findRecId(parmTable.RecId, true);  // Overridden in PurchFormLetter_Invoice
    }

]]></Source>
			</Method>
			<Method>
				<Name>setNewContract</Name>
				<Source><![CDATA[
    protected void setNewContract(FormLetterContract _contract)
    {
        super(_contract);
        if (!contractIsFromPreviousVersion)
        {
            purchFormLetterContract = _contract;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPurchEditLinesDataSource</Name>
				<Source><![CDATA[
    public void  setPurchEditLinesDataSource(FormDataSource  _datasource)
    {
        purchEditLinesDatasource = _datasource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSkipPrompt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether prompt should be skipped.
    /// </summary>
    /// <returns>
    /// true, if prompt should be skipped; otherwise, false.
    /// </returns>
    protected boolean shouldSkipPrompt()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>specQty</Name>
				<Source><![CDATA[
    public PurchUpdate  specQty(PurchUpdate  _specQty = this.purchParmUpdate().SpecQty)
    {
        PurchParmUpdate purchParmUpdate = this.purchParmUpdate();
        purchFormLetterContract.parmSpecQtyIsSet(true);
        purchFormLetterContract.parmSpecQty(_specQty);
        purchParmUpdate.SpecQty = _specQty;
        this.purchParmUpdate(purchParmUpdate);
        return purchParmUpdate.SpecQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumBy</Name>
				<Source><![CDATA[
    public AccountOrder  sumBy(AccountOrder  _sumBy = this.purchParmUpdate().SumBy)
    {
        PurchParmUpdate purchParmUpdate = this.purchParmUpdate();
        purchParmUpdate.SumBy = _sumBy;
        this.purchParmUpdate(purchParmUpdate);
        return purchParmUpdate.SumBy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumNum</Name>
				<Source><![CDATA[
    public Num sumNum(Num  _sumNum = this.purchParmUpdate().SumNum)
    {
        PurchParmUpdate purchParmUpdate = this.purchParmUpdate();
        purchParmUpdate.SumNum = _sumNum;
        this.purchParmUpdate(purchParmUpdate);
        return purchParmUpdate.SumNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumPurchId</Name>
				<Source><![CDATA[
    public PurchId  sumPurchId(PurchId  _sumPurchId = this.purchParmUpdate().SumPurchId)
    {
        PurchParmUpdate purchParmUpdate = this.purchParmUpdate();
        purchParmUpdate.SumPurchId = _sumPurchId;
        this.purchParmUpdate(purchParmUpdate);
        return purchParmUpdate.SumPurchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>templateForm</Name>
				<Source><![CDATA[
    protected FormName templateForm()
    {
        return formStr(PurchEditLines);
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmsParmRunFromSCS</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets a value for indicating whether the posting is done on the basis of warehouse load lines.
    /// </summary>
    /// <param name="_runFromSCS">
    /// A Boolean value that indicates whether posting is done on the basis of warehouse load lines.
    /// </param>
    /// <returns>
    /// true if posting is done on the basis of warehouse load lines; otherwise, false.
    /// </returns>
    public boolean tmsParmRunFromSCS(boolean _runFromSCS = runFromSCS)
    {
        if (_runFromSCS)
        {
            runFromSCS = _runFromSCS;
        }

        return runFromSCS;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transDate</Name>
				<Source><![CDATA[
    public TransDate transDate(TransDate _transDate = purchFormLetterContract.parmTransDate())
    {
        VendDocumentTableMap localParmTable = this.initParmTable();

        if (!_transDate)
        {
            localParmTable.Ordering = this.documentStatus();
            localParmTable.defaultField(VendDocumentUtil::fieldNum(fieldNum(VendDocumentTableMap, TransDate), localParmTable.TableId), this.purchTable());
            _transDate = localParmTable.TransDate;
        }

        return purchFormLetterContract.parmTransDate(_transDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>udpateNum</Name>
				<Source><![CDATA[
    protected void udpateNum(PurchParmUpdate    _purchParmUpdate)  // Overridden in PurchFormLetter_Invoice
    {
        PurchParmTable  purchParmTable;

        update_recordset purchParmTable
                setting Num = _purchParmUpdate.SumNum
                where purchParmTable.ParmId     == _purchParmUpdate.ParmId
                   && purchParmTable.PurchId    == _purchParmUpdate.SumPurchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean  unpack(container  _packedClass)
    {
        Integer  version = conPeek(_packedClass,1);
        container packedBase;

        switch (version)
        {
            case #CurrentVersion + #ParentVersion:
                [version, #ParmListCommonCS, packedBase] = _packedClass;
                if (packedOutputContract)
                {
                    formletterOutputContract.unpack(packedOutputContract);
                }
                return super(packedBase);

            case #SumVersion24:
                [version, #ParmListCommonCS_24, packedBase] = _packedClass;
                return super(packedBase);

            default :
                return super(_packedClass);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    public void  update(Common         _source,
                        Num           _number,
                        TransDate     _transDate          = this.transDate(),
                        PurchUpdate   _specQty            = PurchUpdate::All,
                        AccountOrder  _accountOrder       = AccountOrder::None,
                        NoYes         _proforma           = this.proforma(),
                        NoYes         _printFormLetter    = this.printFormLetter(),
                        NoYes         _usePrintManagement = false,
                        NoYes         _creditRemaining    = this.creditRemaining(),
                        container     _packedTmpFrmVirtualList = conNull(),
                        boolean       _runInSandbox = false)
    {
        PurchParmUpdate purchParmUpdate;

        switch (_source.TableId)
        {
            case tableNum(PurchTable)       :   this.purchTable(_source);
                this.initParmPurchTable(this.purchTable());
                break;
        }

        if (!_transDate)
        {
            _transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        }

        this.parmParmTableNum   (_number);
        this.transDate          (_transDate);
        this.specQty            (_specQty);
        this.proforma           (_proforma);
        this.printFormLetter    (_printFormLetter);
        this.usePrintManagement (_usePrintManagement);
        this.creditRemaining    (_creditRemaining);
        purchParmUpdate = this.purchParmUpdate();
        purchParmUpdate.SumNum = _number;

        this.initParameters(purchParmUpdate,
                            Printout::Current);  // Printout

        this.chooseLines(true);

        if (_packedTmpFrmVirtualList)
        {
            this.selectFromJournal(_packedTmpFrmVirtualList);
        }

        if (_runInSandbox)
        {
            this.runOperation();
        }
        else
        {
            this.run();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePurchParmTableNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates <c>PurchParmTable</c> posting number.
    /// </summary>
    /// <param name="_num">
    /// An invoice number.
    /// </param>
    /// <param name="_parmId">
    /// A select criteria; optional.
    /// </param>
    public void updatePurchParmTableNum(Num _num, ParmId _parmId = this.parmId())
    {
        PurchParmTable          purchParmTable;

        ttsBegin;
        while select forupdate purchParmTable
            where purchParmTable.ParmId == _parmId
        {
            purchParmTable.Num  = _num;
            purchParmTable.update();
        }
        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if it is OK to continue.
    /// </summary>
    /// <param name="_calledFrom">
    /// Identifies the object from which this method is called. Default value is null.
    /// </param>
    /// <returns>
    /// true if the ok to continue; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The validate method is used for validating if it is ok to close the purchase posting form, when posting purchase orders.
    /// </remarks>
    public boolean validate(Object _calledFrom = null)
    {
        // <GEEU>
        #EECountryRegionCodes
        // </GEEU>

        // <GEERU>
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        if (!this.checkFundingLimit())
        {
            return false;
        }

        if (!this.checkSumBy())
        {
            return false;
        }

        if (!this.checkSumNum())
        {
            return false;
        }

        if (!this.checkFormLetterId())
        {
            return false;
        }

        if (!this.checkLateSelection())
        {
            return false;
        }

        if (!this.checkInterCompany())
        {
            return false;
        }

        if (!PurchFormLetter::checkPurchLinesChangedServer(this.documentStatus(), this.pack()))
        {
            return false;
        }

        // <GIN>
        if (TaxParameters::isExciseEnable_IN() && !this.checkConsignmentNoteNum_IN())
        {
            return false;
        }
        // </GIN>
        // <GEERU><GEEU>
        if ((countryRegion_RU && this.doCheckAdvancePaymentsOnValidate_RU()) ||
                SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeCZHUPL))
        {
            if (!PurchFormletterParmData::newReSelect(this.packDataContract(purchFormLetterContract)).checkAdvancePayments_W(true))
            {
                return false;
            }
        }
        // </GEERU></GEEU>

        PurchTable purchTable = this.purchTable();
        if (purchTable.ProjId)
        {
            //Validation to check for project stage before posting product receipt. The check is done for each item of the PO at line level
            //and not at header level
            PurchParmLine   purchParmLineLocal;
            PurchLine       purchLineLocal;
            PurchParmUpdate purchParmUpdate = this.purchParmUpdate();
            
            while select purchParmLineLocal
            where purchParmLineLocal.ParmId == purchParmUpdate.ParmId
            join purchLineLocal
                where purchLineLocal.InventTransId == purchParmLineLocal.InventTransId
                   && !purchLineLocal.IsDeleted && !purchLineLocal.IsFinalized && purchLineLocal.ProjId != ''
            {
                ProjStatusType projStatusType = this.getProjStatusType(purchLineLocal);
                boolean ret = projStatusType.journalCheckStatus();
                boolean overdelivery = this.checkForOverDelivery(purchParmLineLocal, purchLineLocal);
                if (!ret || overdelivery)
                {
                    return false;
                }
            }
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForOverDelivery</Name>
				<Source><![CDATA[
    private boolean checkForOverDelivery( PurchParmLine   purchParmLineLocal, PurchLine       purchLineLocal)
    {
        InventMovement movement = InventMovement::construct(purchLineLocal);
        boolean val = movement.checkNotOverDelivery(purchParmLineLocal.InventNow, true, purchParmLineLocal.PdsCWReceiveNow);
        return !val;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjStatusType</Name>
				<Source><![CDATA[
    protected ProjStatusType getProjStatusType(PurchLine _purchLine)
    {
        ProjStatusType projStatusType = ProjTable::find(_purchLine.ProjId).status();
        return projStatusType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateNum</Name>
				<Source><![CDATA[
    public boolean validateNum(VendDocumentTableMap _parmTable = parmTable)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vendAccountInQuery</Name>
				<Source><![CDATA[
    public boolean  vendAccountInQuery()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wmsJournalTable_ds</Name>
				<Source><![CDATA[
    public FormDataSource  wmsJournalTable_ds(FormDataSource  _wmsJournalTable_ds = wmsJournalTable_ds)
    {
        //wmsJournalTable_ds can not be transferred from server to client by pack/unpack mechanism.
        //However, the only actions with it on the client side is setting it to null and checking whether it is not null.
        //wmsJournalTableDsIsSet parameter is used to transfer the information about its state to the client and back.
        if (wmsJournalTable_ds != _wmsJournalTable_ds)
        {
            wmsJournalTableDsIsSet = (_wmsJournalTable_ds != null);
        }

        wmsJournalTable_ds = _wmsJournalTable_ds;
        return wmsJournalTable_ds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wmsJournalTableDsIsSet</Name>
				<Source><![CDATA[
    public boolean wmsJournalTableDsIsSet(boolean _wmsJournalTableDsIsSet = wmsJournalTableDsIsSet)
    {
        wmsJournalTableDsIsSet = _wmsJournalTableDsIsSet;
        return wmsJournalTableDsIsSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>callPrintersettingsFormletter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allows the user to modify the printer settings using the standard print job settings dialog box.
    /// </summary>
    /// <param name="_purchFormLetter">
    /// The <c>PurchFormLetter</c> class where the printer settings are modified.
    /// </param>
    /// <param name="_originalCopy">
    /// Indicates if it is the printer settings for the original or a copy that are modified; optional.
    /// </param>
    /// <returns>
    /// true if the settings were modified; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The <c>callPrinterSettingsFormLetter</c> method is static so that users can select AOS printers.
    /// Selecting AOS printers requires that the <c>SysPrintForm</c> is called from the server.
    /// </remarks>
    static boolean  callPrintersettingsFormletter(PurchFormLetter _purchFormLetter, PrintSetupOriginalCopy _originalCopy = PrintSetupOriginalCopy::Original)
    {
        #PrintMgmtSetup
        SRSPrintDestinationSettings printSettings = new SRSPrintDestinationSettings(_purchFormLetter.printerSettingsFormletter(_originalCopy));
        boolean ok = SrsReportRunUtil::showSettingsDialog(printSettings, #SRSPrintDestinationTokenPrintMgmt, enum2Symbol(enumNum(PrintMgmtDocumentType), enum2int(_purchFormLetter.printMgmtDocumentType())));
        _purchFormLetter.updatePrinterSettingsFormLetter(printSettings.pack(), _originalCopy);

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkParmTable</Name>
				<Source><![CDATA[
    static container checkParmTable(Num      parmId,
                                           boolean  vendAccountInQuery,
                                           boolean  invoiceAccountInQuery)
    {
        PurchParmTable  purchParmT;
        Counter         numOfAccounts = 0;
        Counter         numOfCurrency = 0;

        if (vendAccountInQuery)
        {
            while select purchParmT
                      group by OrderAccount
                      where purchParmT.ParmId == parmId
            {
                numOfAccounts++;
            }
        }

        if (invoiceAccountInQuery)
        {
            while select purchParmT
                      group by InvoiceAccount
                      where purchParmT.ParmId == parmId
            {
                numOfAccounts++;
            }
        }

        while select purchParmT
                  group by CurrencyCode
                  where purchParmT.ParmId == parmId
        {
            numOfCurrency++;
        }

        return [numOfAccounts, numOfCurrency];
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPurchLinesChangedServer</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Checks whether purchase lines has been updated since the posting was started.
    /// </summary>
    /// <param name="_documentStatus">
    ///   An element from the <c>DocumentStatus</c> enumeration.
    /// </param>
    /// <param name="_packedFormletter">
    ///   A packed version of the posting class.
    /// </param>
    /// <returns>
    ///  true if the validation passes; otherwise, false.
    /// </returns>
    static private boolean  checkPurchLinesChangedServer(
        DocumentStatus _documentStatus,
        container _packedFormletter)
    {
        PurchFormletter purchFormletter = PurchFormLetter::construct(_documentStatus);
        purchFormletter.unpack(_packedFormletter);
        return purchFormletter.checkPurchLinesChanged();
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructFromClassNameMethodName</Name>
				<Source><![CDATA[
    private static PurchFormLetter constructFromClassNameMethodName(
        DocumentStatus              _document,
        IdentifierName              _className  = '',
        IdentifierName              _methodName = '',
        SysOperationExecutionMode   _executionMode = SysOperationExecutionMode::Synchronous,
        MenuItemNameAction          _callerMenuItem = '')
    {
        PurchFormLetter purchFormLetter;
        if (_className && _methodName)
        {
            switch (_document)
            {
                case  DocumentStatus::PurchaseOrder         :
                    if (_callerMenuItem == menuitemActionStr(PurchFormLetter_Confirm))
                    {
                        purchFormLetter = PurchFormLetter_Confirmation::newConfirmation(_className, _methodName, _executionMode);
                    }
                    else
                    {
                        purchFormLetter = PurchFormLetter_PurchOrder::newPurchOrder(_className, _methodName, _executionMode);
                    }
                    break;
                case  DocumentStatus::ConfirmationRequest   :
                    purchFormLetter = PurchFormLetter_ConfirmationRequest::newConfirmationRequest(_className, _methodName, _executionMode);
                    break;
                case  DocumentStatus::PackingSlip           :
                    purchFormLetter = PurchFormLetter_PackingSlip::newPackingSlip(_className, _methodName, _executionMode);
                    break;
                case  DocumentStatus::ReceiptsList          :
                    purchFormLetter = PurchFormLetter_ReceiptsList::newReceiptList(_className, _methodName, _executionMode);
                    break;
                case  DocumentStatus::Invoice               :
                    purchFormLetter = PurchFormLetter_Invoice::newInvoice(_className, _methodName, _executionMode);
                    break;
                case  DocumentStatus::ApproveJournal        :
                    purchFormLetter = PurchFormLetter_ApproveJournal::newApproveJournal(_className, _methodName, _executionMode);
                    break;
                // <GIN>
                case  DocumentStatus::BillOfEntry_IN        :
                    if (TaxParameters::isCustomsEnable_IN())
                    {
                        purchFormLetter = PurchFormLetter_BillOfEntry_IN::newBillOfEntry(_className, _methodName, _executionMode);
                    }
                    break;
                // </GIN>
                // <GEERU>
                case  DocumentStatus::Facture_RU            :
                    purchFormLetter = PurchFormLetter_Facture_RU::newFacture(_className, _methodName, _executionMode);
                    break;
                case  DocumentStatus::Invoice4Paym_RU       :
                    purchFormLetter = PurchFormLetter_Invoice4Paym_RU::newInvoice4Paym(_className, _methodName, _executionMode);
                    break;
                // </GEERU>
                // <GEEPL>
                case  DocumentStatus::PlSAD                 :
                    purchFormLetter = PurchFormLetter_SADInvoice_PL::newSADInvoice(_className, _methodName, _executionMode);
                    break;
                // </GEEPL>
                default:
                    DocumentStatusFactoryAttribute      attribute       = new DocumentStatusFactoryAttribute(_document);
                    SysExtensionGenericInstantiation    instantiation   = new SysExtensionGenericInstantiation(_className, _methodName, _executionMode);
                    purchFormLetter = SysExtensionAppClassFactory::getClassFromSysAttributeWithInstantiationStrategy(classStr(PurchFormLetter), attribute, instantiation) as PurchFormLetter;

                    if (classIdGet(purchFormLetter) == classNum(PurchFormLetter))
                    {
                        return null;
                    }
                    break;
            }
        }
        else
        {
            switch (_document)
            {
                case  DocumentStatus::PurchaseOrder         :
                    if (_callerMenuItem == menuitemActionStr(PurchFormLetter_Confirm))
                    {
                        purchFormLetter = PurchFormLetter_Confirmation::newConfirmation();
                    }
                    else
                    {
                        purchFormLetter = PurchFormLetter_PurchOrder::newPurchOrder();
                    }
                    break;
                case  DocumentStatus::ConfirmationRequest   :
                    purchFormLetter = PurchFormLetter_ConfirmationRequest::newConfirmationRequest();
                    break;
                case  DocumentStatus::PackingSlip           :
                    purchFormLetter = PurchFormLetter_PackingSlip::newPackingSlip();
                    break;
                case  DocumentStatus::ReceiptsList          :
                    purchFormLetter = PurchFormLetter_ReceiptsList::newReceiptList();
                    break;
                case  DocumentStatus::Invoice               :
                    purchFormLetter = PurchFormLetter_Invoice::newInvoice();
                    break;
                case  DocumentStatus::ApproveJournal        :
                    purchFormLetter = PurchFormLetter_ApproveJournal::newApproveJournal();
                    break;
                // <GIN>
                case  DocumentStatus::BillOfEntry_IN        :
                    if (TaxParameters::isCustomsEnable_IN())
                    {
                        purchFormLetter = PurchFormLetter_BillOfEntry_IN::newBillOfEntry();
                    }
                    break;
                // </GIN>
                // <GEERU>
                case  DocumentStatus::Facture_RU            :
                    purchFormLetter = PurchFormLetter_Facture_RU::newFacture();
                    break;
                case  DocumentStatus::Invoice4Paym_RU       :
                    purchFormLetter = PurchFormLetter_Invoice4Paym_RU::newInvoice4Paym();
                    break;
                // </GEERU>
                // <GEEPL>
                case  DocumentStatus::PlSAD                 :
                    purchFormLetter = PurchFormLetter_SADInvoice_PL::newSADInvoice();
                    break;
                // </GEEPL>
                default:
                    DocumentStatusFactoryAttribute attribute = new DocumentStatusFactoryAttribute(_document);
                    purchFormLetter = SysExtensionAppClassFactory::getClassFromSysAttribute(classStr(PurchFormLetter), attribute) as PurchFormLetter;

                    if (classIdGet(purchFormLetter) == classNum(PurchFormLetter))
                    {
                        return null;
                    }
                    break;
            }
        }

        return purchFormLetter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Construct a new instance of <c>PurchFormLetter</c> class based on <c>DocumentStatus</c> enum value.
    /// </summary>
    /// <param name = "_document">Document status to be updated.</param>
    /// <param name = "_className">Class name; optional.</param>
    /// <param name = "_methodName">Method name; optional.</param>
    /// <param name = "_executionMode">Operation execution mode; optional.</param>
    /// <param name = "_callerMenuItem">The caller menu item; optional.</param>
    /// <returns>A new <c>PurchFormLetter</c> class instance.</returns>
    public static PurchFormLetter construct(
        DocumentStatus              _document,
        IdentifierName              _className      = '',
        IdentifierName              _methodName     = '',
        SysOperationExecutionMode   _executionMode  = SysOperationExecutionMode::Synchronous,
        MenuItemNameAction          _callerMenuItem = '')
    {
        PurchFormLetter purchFormLetter = PurchFormLetter::constructFromClassNameMethodName(_document, _className, _methodName, _executionMode, _callerMenuItem);

        if (purchFormLetter)
        {
            return purchFormLetter;
        }

        throw error(strFmt("@SYS19306", funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructFromCache</Name>
				<Source><![CDATA[
    static PurchFormLetter constructFromCache(DocumentStatus documentStatus, ParmId parmId)
    {
        SysGlobalCache      cache = classfactory.globalCache();

        if (cache.isSet(classStr(PurchFormLetter), parmId))
        {
            return cache.get(classStr(PurchFormLetter), parmId);
        }
        else
        {
            return PurchFormLetter::construct(documentStatus);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPrinterSettingsFormletter</Name>
				<Source><![CDATA[
    static container getPrinterSettingsFormletter(DocumentStatus  _document, PrintSetupOriginalCopy _originalCopy = PrintSetupOriginalCopy::Original)
    {
        PurchFormLetter purchFormLetterPrint;

        purchFormLetterPrint = PurchFormLetter::construct(_document);

        return purchFormLetterPrint.printerSettingsFormletter(_originalCopy);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOfficialsServer_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes the <c>initOfficials_RU</c> method on the server tier.
    /// </summary>
    /// <param name="_documentStatus">
    /// The document status.
    /// </param>
    /// <param name="_packedPurchFormletter">
    /// The packed <c>PurchFormLetter</c> class object to be used.
    /// </param>
    /// <param name="_parmTable">
    /// A <c>PurchParmTable</c> record.
    /// </param>
    /// <returns>
    /// container with member variables.
    /// </returns>
    protected static container initOfficialsServer_RU(
        DocumentStatus        _documentStatus,
        container             _packedPurchFormletter,
        VendDocumentTableMap  _parmTable)
    {
        PurchFormLetter purchFormLetter = PurchFormLetter::construct(_documentStatus);

        purchFormLetter.unpack(_packedPurchFormletter);
        purchFormLetter.initOfficials_RU(_parmTable);

        return purchFormLetter.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void main(Args  args)
    {
        Common              record;
        int                 parmEnum;
        Object              callerForm;
        FormName            callerFormName;
        MenuItemNameAction  callerMenuItem;
        FormDataSource      recordDataSource;
        container           dataSourceRecordsPacked;
        str                 className, methodName;
        SysOperationExecutionMode mode;
        PurchFormLetter     purchFormLetter;

        if (!PurchFormLetter::isValidArgs(args))
        {
            throw error("@SYS25407");
        }
        [className, methodName, mode] = FormLetterServiceController::parseServiceInfo(args);
        record            = args.record();
        parmEnum          = args.parmEnum();
        callerForm        = args.caller();
        callerMenuItem    = args.menuItemName();

        if (callerForm)
        {
            callerFormName    = args.caller().name();
        }

        boolean isProforma = FormLetterServiceController::isMenuItemProforma(callerMenuItem);

        if (record)
        {
            VendAccount accountNum = PurchFormLetter::getVendorAccount(record);

            PurchFormLetter::validateVendorBlocked(accountNum, callerMenuItem);

            recordDataSource  = FormDataUtil::getFormDataSource(record);

            if (callerForm is PurchFormLetterISelectedOrderDataProvider)
            {
                var dataProvider = callerForm as PurchFormLetterISelectedOrderDataProvider;
                dataSourceRecordsPacked = dataProvider.getSelectedOrders();
                if (record is PurchOrderApprovedView)
                {
                    var purchApprovedViewRecord = record as PurchOrderApprovedView;
                    record = PurchTable::find(purchApprovedViewRecord.PurchId) as Common;
                }
            }
            else if (recordDataSource)
            {
                dataSourceRecordsPacked = FormLetter::getFormRecord(recordDataSource);
            }
        }

        container cachedArgs = [#CachedArgsList];

        try
        {
            purchFormLetter = PurchFormLetter::constructAndInitialize(cachedArgs, record, callerForm, dataSourceRecordsPacked);

            if (purchFormLetter || !PurchFormLetterCheckInstanceFlight::instance().isEnabled())
            {
                purchFormLetter.parmOpenedWithArgs(true);
                
                purchFormLetter.prePromptModifyData();

                if (purchFormletter.shouldSkipPrompt())
                {
                    purchFormletter.parmShowDialog(false);
                }

                purchFormLetter.startOperation();
                purchFormLetter.runRemainUpdates();
            }
        }
        catch (Exception::Error)
        {
            exceptionTextFallThrough();
        }
        finally
        {
            if (purchFormLetter)
            {
                purchFormLetter.finalProcessing();

                FormletterOutputContract outputContract  = purchFormLetter.getOutputContract();
                Counter numberOfRecords = outputContract.parmNumberOfOrdersPosted();
                
                if (numberOfRecords
                // <GEERU>
                || (purchFormLetter.doRefreshCallerDataSource())
                // </GEERU>
                )
                {
                    if (!purchFormLetter.proforma())
                    {
                        purchFormLetter.documentPostMessaging([purchFormLetter.parmId()], numberOfRecords);
                    }

                    if (callerForm && formHasMethod(callerForm, identifierStr(interCompanyRefreshCache)))
                    {
                        callerForm.interCompanyRefreshCache();
                    }

                    if (!recordDataSource)
                    {
                        // in the case that a record wasn't passed to the child form, attempt to cast caller as FormRun and grab datasource
                        FormRun callerAsFormRun = callerForm as FormRun;
                        if (callerAsFormRun)
                        {
                            recordDataSource = callerAsFormRun.datasource();
                        }
                    }

                    if (recordDataSource)
                    {
                        FormLetter::reFreshCallerDataSource(recordDataSource,
                                                            PurchFormLetter::doesRecordExist(record, callerMenuItem, numberOfRecords),
                                                            (numberOfRecords > 1));

                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVendorAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Extracts the vendor account number.
    /// </summary>
    /// <param name = "_common">Table record</param>
    /// <returns>returns the vendor account</returns>
    public static AccountNum getVendorAccount(Common _common)
    {
        VendAccount vendAccount;

		switch(_common.TableId)
        {
            case tableNum(VendTable):
                vendAccount = FormDataUtil::getFieldValueAsString(_common, fieldNum(VendTable, AccountNum));
                break;
                
            case tableNum(PurchTable):
                vendAccount = FormDataUtil::getFieldValueAsString(_common, fieldNum(PurchTable, OrderAccount));
				break;
        }

        return vendAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isValidArgs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if passed <c>Args</c> is valid.
    /// </summary>
    /// <param name = "_args">
    /// The <c>Args</c> object.
    /// </param>
    /// <returns>
    /// true if passed <c>Args</c> is valid; otherwise, false.
    /// </returns>
    protected static boolean isValidArgs(Args _args)
    {
        return _args != null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesRecordExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves whether the record exists; typically called before refreshing the caller data source.
    /// </summary>
    /// <param name = "_record">A <c>Common</c> record.</param>
    /// <param name = "_callerMenuItem">The caller <c>MenuItemNameAction</c>.</param>
    /// <param name = "_numberOfRecords">The number of records.</param>
    /// <returns>true if the record exists; otherwise, false.</returns>
    public static boolean doesRecordExist(Common _record, MenuItemNameAction _callerMenuItem, Counter _numberOfRecords)
    {
        boolean recordExists;

        if (_record)
        {
            switch (_record.TableId)
            {
                case tableNum(PurchTable):
                    if (_numberOfRecords && _callerMenuItem == menuItemDisplayStr(VendWorkspacePurchFormLetter_Invoice))
                    {
                        // When posting is successful from the vendor invoice workspace, force a datasource research
                        recordExists = false;
                    }
                    else
                    {
                        PurchTable purchTable = _record as PurchTable;
                        recordExists = PurchTable::exist(purchTable.PurchId);
                    }
                    break;
                case tableNum(PurchParmTable):
                    recordExists = false;
                    break;
                case tableNum(VendPackingSlipJour):
                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
                    {
                        recordExists = VendPackingSlipJour::findRecId(_record.RecId).RecId;
                    }
                    break;
                case tableNum(PlSADTable):
                    recordExists = PlSADTable::findRecId(_record.RecId).RecId;
                    break;
                case tableNum(WMSJournalTable):
                    WMSJournalTable wmsJournalTable = _record as WMSJournalTable;
                    recordExists = WMSJournalTable::exist(wmsJournalTable.journalId);
                    break;
            }
        }

        EventHandlerResult result = EventHandlerResult::newSingleResponse();
        PurchFormLetter::doesRecordExistDelegate(_record, _callerMenuItem, _numberOfRecords, result);
        if (result.hasResult())
        {
            return result.result();
        }

        return recordExists;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesRecordExistDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves whether the record exists; typically called before refreshing the caller data source.
    /// </summary>
    /// <param name = "_record">A <c>Common</c> record.</param>
    /// <param name = "_callerMenuItem">The caller <c>MenuItemNameAction</c>.</param>
    /// <param name = "_numberOfRecords">The number of records.</param>
    /// <param name = "_eventHandlerResult">Subscribers can use this to return a boolean value, indicating if the record exists.</param>
    static delegate void doesRecordExistDelegate(
        Common _record,
        MenuItemNameAction _callerMenuItem,
        Counter _numberOfRecords,
        EventHandlerResult _eventHandlerResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructAndInitialize</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs and initializes a <c>PurchFormLetter</c> instance.
    /// </summary>
    /// <param name = "_cachedArgs">A <c>container with the cached arguments</c></param>
    /// <param name = "_record">A <c>common</c> record.</param>
    /// <param name = "_callerForm">The caller form instance.</param>
    /// <param name = "_dataSourceRecordsPacked">A container with the data source records packed.</param>
    /// <returns></returns>
    protected static PurchFormLetter constructAndInitialize(container _cachedArgs,
                                                   Common    _record,
                                                   Object    _callerForm,
                                                   container _dataSourceRecordsPacked)
    {
        //Cached args
        int                     parmEnum;
        IdentifierName          callerFormName;
        boolean                 isProforma;
        str                     className, methodName;
        SysOperationExecutionMode mode;
        MenuItemNameAction      callerMenuItem;

        if (_cachedArgs == conNull())
        {
            throw error("@SYS25407");
        }

        [#CachedArgsList] = _cachedArgs;
        mode = SysOperationExecutionMode::Synchronous;

        PurchFormLetter purchFormLetter = PurchFormLetter::construct(any2Enum(parmEnum), className, methodName, mode, callerMenuItem);
        purchFormLetter.initialize(callerFormName, callerMenuItem, isProforma);

        if (_record)
        {
            if (!purchFormLetter.initializeBasedOnDocument(_record, callerMenuItem, _dataSourceRecordsPacked))
            {
                return null;
            }
        }

        purchFormLetter.prePromptInit();
        purchFormLetter.forceSaveLast();

        purchFormLetter.init();

        return purchFormLetter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runServer</Name>
				<Source><![CDATA[
    static container runServer(container _packedFormletter, DocumentStatus _documentStatus)
    {
        container                   outputContainer;
        PurchFormLetter             formletter = PurchFormLetter::construct(_documentStatus);
        FormletterOutputContract    formletterOutputContract;

        formletter.unpack(_packedFormletter);
        formletter.init();
        formletter.run();
        formletterOutputContract = formletter.operationReturnValue();
        outputContainer = formletterOutputContract.pack();

        return outputContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initialize</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>PurchFormLetter</c> instance.
    /// </summary>
    /// <param name = "_callerFormName">The caller form name.</param>
    /// <param name = "_callerMenuItem">The caller <c>MenuItemNameAction</c>.</param>
    /// <param name = "_isProforma">A boolean value.</param>
    protected void initialize(IdentifierName _callerFormName, MenuItemNameAction _callerMenuItem, boolean _isProforma)
    {
        this.parmCallerFormName(_callerFormName);
        this.getLastFromCallerFormName();

        if (_callerMenuItem)
        {
            this.parmCallerMenuItem(_callerMenuItem);
        }

        if (this.parmDocumentOrigin() == DocumentOrigin::EnterprisePortal)
        {
            //if this is the EPVendInvoice feature then set an identifier to the Num field so that you
            //can identify which invoice to grab later.
            this.parmParmTableNum(_callerFormName);
            this.specQty(PurchUpdate::All);
        }

        this.transDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));

        if (callerFormName != '' && (callerFormName == formStr(PurchTable)
            || callerFormName == formstr(VendInvoiceInfoListPage)))
        {
            this.proforma(_isProforma);
            this.enableUpdateNowField(!_isProforma);
        }
        else
        {
            this.enableUpdateNowField(true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeBasedOnDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>PurchFormLetter</c> instance based on the document.
    /// </summary>
    /// <param name = "_record">A <c>common</c> record, which is the document being posted.</param>
    /// <param name = "_callerMenuItem">The caller <c>MenuItemNameAction</c></param>
    /// <param name = "_dataSourceRecordsPacked">A <c>container</c> holding the data source records.</param>
    /// <returns>true, if the <c>PurchFormLetter</c> was initialized for the given document; otherwise, false. </returns>
    protected boolean initializeBasedOnDocument(Common _record, MenuItemNameAction _callerMenuItem, container _dataSourceRecordsPacked)
    {
        switch (_record.TableId)
        {
            case tableNum(PurchTable):
                PurchTable purchTable = _record as PurchTable;
                this.parmCallerTable(_record);
                this.initParmPurchTable(purchTable);
                this.parmDataSourceRecordsPacked(_dataSourceRecordsPacked);
                this.parmCallerMenuItem(_callerMenuItem);
                // <GIN>
                if (TaxParameters::isCustomsEnable_IN() && purchTable.purchTable_W().CustomsImportOrder_IN)
                {
                    if (this.name() == classStr(PurchFormLetter_PackingSlip)
                        || this.name() == classStr(PurchFormLetter_Invoice))
                    {
                        this.specQty(PurchUpdate::BillOfEntryQuantity_IN);
                    }
                }
                // </GIN>

                if (#PdsApprovedVendorListEnabled
                    && this.documentStatus() != DocumentStatus::ReceiptsList)
                {
                    if (!purchTable.pdsCheckApprovedVendorList())
                    {
                        return false;
                    }
                }

                switch (_callerMenuItem)
                {
                    case menuitemDisplayStr(PurchFormLetter_PrepayInvoice_Display):
                        this.parmInvoiceType(PurchInvoiceType::VendorAdvance);
                        break;
                    case menuitemDisplayStr(VendWorkspacePurchFormLetter_Invoice):
                        this.parmAutoConsolidate(true);
                        break;
                    case menuitemactionstr(PurchFormLetter_Confirm):
                        this.parmAutoConsolidate(true);
                        break;
                }
                break;

            case tableNum(VendPackingSlipJour):
                // <GIN>
                VendPackingSlipJour vendPackingSlipJour = _record as VendPackingSlipJour;
                // </GIN>

                PurchTable localPurchTable = vendPackingSlipJour.purchTable();
                if (localPurchTable.isConsignmentOrder())
                {
                    throw error("@Consignment:MessageValidation_ConsumptionProductReceiptChanges");
                }

                this.parmCallerTable(_record);
                this.parmCallerMenuItem(_callerMenuItem);

                switch (_callerMenuItem)
                {
                    case menuitemActionStr(PurchFormLetter_PackingSlipCancel):
                        this.parmVersioningUpdateType(VersioningUpdateType::Cancel);
                        break;
                    default:
                        this.parmVersioningUpdateType(VersioningUpdateType::Correction);
                        break;
                }

                this.reArrangeNow(false);
                // <GIN>
                if (TaxParameters::isCustomsEnable_IN() && localPurchTable.purchTable_W().CustomsImportOrder_IN)
                {
                    if (this.name() == classStr(PurchFormLetter_PackingSlip))
                    {
                        if (this.parmVersioningUpdateType() != VersioningUpdateType::Cancel
                            || (CustomsVendPackingSlipBOETransLink_IN::existByVendPackingSlipJour(vendPackingSlipJour.RecId)))
                        {
                            this.specQty(PurchUpdate::BillOfEntryQuantity_IN);
                        }
                    }
                }
                // </GIN>
                break;

            case tableNum(LedgerJournalTrans):
                LedgerJournalTrans ledgerJournalTrans = _record as LedgerJournalTrans;
                this.parmLedgerJournalTrans(ledgerJournalTrans);
                break;

            case tableNum(WMSJournalTable):
                this.parmLineRecords(_dataSourceRecordsPacked);
                this.wmsJournalTable_ds(FormDataUtil::getFormDataSource(_record));
                if (this.wmsJournalTable_ds())
                {
                    this.specQty(PurchUpdate::Recorded);
                }
                break;

            case tableNum(VendInvoiceInfoTable):
                this.parmDataSourceRecordsPacked(_dataSourceRecordsPacked);
                this.parmCallerMenuItem(_callerMenuItem);

                switch (_callerMenuItem)
                {
                    case menuitemDisplayStr(PurchFormLetter_NewInvoiceDisplay):
                    case menuitemDisplayStr(VendEditInvoiceFromPackingSlip):
                    case menuitemDisplayStr(VendEditInvoiceFromPurchaseOrder):
                        this.parmCallerTable(null);
                        break;
                    default:
                        this.parmCallerTable(_record);
                        break;
                }

                break;

            case tableNum(PurchParmTable):
                this.parmCreateFromHistory(true);
                this.parmHistoryRecords(_dataSourceRecordsPacked);

                if (this.parmCallerFormName() == formStr(PurchPostingHistory))
                {
                    PurchParmTable purchParmTable = _record as PurchParmTable;

                    this.parmHistoryReadOnly(purchParmTable.ParmJobStatus != ParmJobStatus::ContainErrors);
                }
                break;

            case tableNum(VendTable):
                this.parmCallerMenuItem(_callerMenuItem);
                this.parmCallerTable(_record);
                break;

            // <GEEPL>
            case tableNum(PlSADTable):
                PlSADTable sadTable = _record as PlSADTable;
                this.parmSADNumberCode_PL    (sadTable.sadNumberCode);
                this.parmSADCurrencyCode_PL  (sadTable.CurrencyCode);
                this.parmSADExchRate_PL      (sadTable.ExchRate);
                this.transDate               (sadTable.TransDate);
                this.parmCallerTable         (_record);
                this.parmCallerMenuItem      (_callerMenuItem);
                break;
            // </GEEPL>
        }

        this.allowEmptyTable(this.initAllowEmptyTable(true));
        this.multiForm(true);

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runRemainUpdates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes the remain updates after the main service operation.
    /// </summary>
    protected void runRemainUpdates()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    public boolean isRetryable()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateParametersForLateSelection</Name>
				<Source><![CDATA[
    private void updateParametersForLateSelection()
    {
        if (purchFormLetterContract.isParallelismAllowed())
        {
            if (this.lateSelection())
            {
                this.updatePurchParmId();
            }
            else
            {
                this.transDate(parmTable.Transdate);
            }
        }
        else
        {
            if (this.lateSelection())
            {
                this.transDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>errorMessageHelpScopeFormName</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public FormName errorMessageHelpScopeFormName()
    {
        return classStr(PurchFormLetter);
    }

]]></Source>
			</Method>
			<Method>
				<Name>errorMessageHelpScopeActionName</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public str errorMessageHelpScopeActionName()
    {
        return methodName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>errorMessageHelpScopeShowLink</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the fix issues link should be shown.
    /// </summary>
    /// <returns>true if the fix issues link should be shown, otherwise; false.</returns>
    [Hookable(false)]
    public boolean errorMessageHelpScopeShowLink()
    {
        return PurchFormLetterErrorMessageHelpScopeFlight::instance().isEnabled()
            && purchFormLetterContract
            && purchFormLetterContract.parmCallerMenuItem();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePurchParmId</Name>
				<Source><![CDATA[
    private void updatePurchParmId()
    {
        this.resetParmListCommonCS();
        this.transDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));

        ttsBegin;
        PurchParmUpdate purchParmUpdate = purchFormLetterContract.parmParmUpdate() as PurchParmUpdate;
        purchParmUpdate.ParmId = formletterParmData::getNewParmId();
        purchParmUpdate.doInsert();
        purchFormLetterContract.parmParmUpdate(purchParmUpdate);
        purchFormLetterContract.parmParmId(purchParmUpdate.ParmId);
        Batch batch = Batch::findRecId(this.parmCurrentBatch().RecId, true);
        batch.Parameters = this.pack();
        batch.doUpdate();
        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateVendorBlocked</Name>
				<Source><![CDATA[
    protected static void validateVendorBlocked(VendAccount _accountNum, MenuItemNameAction  _callerMenuItem)
    {
        if (PurchFormLetterValidateVendAccountFlight::instance().isEnabled())
        {
            if (!VendTable::find(_accountNum, false).checkAccountIsNotBlockedForAllDocuments())
            {
                throw Exception::Warning;
            }
        }
        else
        {
            if (VendTable::blocked(_accountNum) == CustVendorBlocked::All)
            {
                throw warning(strFmt("@SYS128411", _accountNum, CustVendorBlocked::All));
            }
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>