<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
  <Name>AuditPolicyExecutionTask</Name>
  <SourceCode>
    <Declaration><![CDATA[
/// <summary>
///    The <c>AuditPolicyExecutionTask</c> class executes the audit policy rule and create the violation
///    record.
/// </summary>
// This is a framework class. Customizing this class may cause problems with future upgrades to the software.
class AuditPolicyExecutionTask extends RunBaseBatch implements BatchRetryable
{
    Array                               legalEntityList;
    boolean                             aggregateMode;
    boolean                             duplicateMode;
    boolean                             isSourceDocumentLine;
    boolean                             listMode;
    boolean                             samplingMode;
    boolean                             testMode;
    container                           packedLegalEntityList;
    FieldName                           sdFieldName;
    Map                                 tableKeywordFieldList;
    NumberSeq                           instanceNumSeq;
    Query                               query;
    QueryRun                            queryRun;
    RefRecId                            instanceNumSeqId;
    RefRecId                            ruleRecId;
    RefRecId                            sourceRecId;
    SysPolicySourceDocumentRule         sdRule;
    SysPolicySourceDocumentRuleType     sdRuleType;
    TableId                             sourceRelationTypeId;
    utcdatetime                         executionTime;
    utcdatetime                         documentSelectionFromDate;
    utcdatetime                         documentSelectionToDate;

    #DEFINE.CurrentVersion(2)
    #LOCALMACRO.CurrentList
        ruleRecId,
        sourceRecId,
        instanceNumSeqId,
        documentSelectionFromDate,
        documentSelectionToDate,
        packedLegalEntityList,
        executionTime
    #ENDMACRO
}
]]></Declaration>
    <Methods>
      <Method>
        <Name>addSearchFieldsToQuery</Name>
        <Source><![CDATA[
    /// <summary>
    /// Modifies the keyword query to include the field attributes in the selection list.
    /// </summary>
    /// <remarks>
    /// Grabs the list of fields for a certain table and adds it to the selection list of that table in the
    /// query.
    /// </remarks>
    private void addSearchFieldsToQuery()
    {
        AuditPolicyRuleDetail       auditPolicyRuleDetail;
        AuditPolicyRuleDetail       auditPolicyRuleDetailInner;
        container                   keywordFieldList;
        TableId                     sourceTableId;
        int                         i = 1;
        QueryBuildDataSource        qbds;

        tableKeywordFieldList = new Map(Types::Integer, Types::Container);

        // For distinct SourceRelationType values add the SourceAttribute to the resp. table's query selection list
        while select SourceRelationType from auditPolicyRuleDetail
            group by SourceRelationType
            where auditPolicyRuleDetail.PolicySourceDocumentRule == sdRule.RecId
        {
            sourceTableId = tableName2id(auditPolicyRuleDetail.SourceRelationType);
            qbds = query.dataSourceTable(sourceTableId);
            if (qbds)
            {
                while select SourceAttribute from auditPolicyRuleDetailInner
                    where auditPolicyRuleDetailInner.PolicySourceDocumentRule == sdRule.RecId &&
                          auditPolicyRuleDetailInner.SourceRelationType == auditPolicyRuleDetail.SourceRelationType
                {
                    qbds.addSelectionField(fieldName2id(sourceTableId, auditPolicyRuleDetailInner.SourceAttribute));
                    keywordFieldList = conIns(keywordFieldList, i, auditPolicyRuleDetailInner.SourceAttribute);
                    i++;
                }
                tableKeywordFieldList.insert(sourceTableId, keywordFieldList);
            }
            // Clear field list and reset index
            keywordFieldList = conDel(keywordFieldList, 1, conLen(keywordFieldList));
            i = 1;
        }
    }

]]></Source>
      </Method>
      <Method>
        <Name>buildAggregateDuplicateSamplingQuery</Name>
        <Source><![CDATA[
    /// <summary>
    /// Builds a query that selects each root document record that violated the aggregate, duplicate, or
    /// sampling audit rule.
    /// </summary>
    /// <param name="_queryResult">
    /// The query run object.
    /// </param>
    /// <returns>
    /// The query that was built.
    /// </returns>
    /// <remarks>
    /// The query is primarily built to get each record that comprises the group by the record that is
    /// returned by the original query.Since such a record does not contain the root table record IDs, we
    /// must re-create the query without the group-by clause and add that clause as a range onto the new
    /// select query. By doing this we receive all the records that were grouped by the original query.
    /// </remarks>
    private Query buildAggregateDuplicateSamplingQuery(QueryRun _queryResult)
    {
        int                     groupbyCnt;
        int                     i;
        int                     dataSourceCount;
        Common                  localRecord;
        Query                   localQuery;
        QueryBuildDataSource    localQbds;
        QueryGroupByField       queryGroupByField;

        localQuery = new Query(query);
        dataSourceCount = localQuery.dataSourceCount();

        // Clear the selection fields on each datasource
        for (i = 1; i <= dataSourceCount; i++)
        {
            localQbds = localQuery.dataSourceNo(i);
            localQbds.fields().clearFieldList();
        }

        localQbds = localQuery.dataSourceNo(1);

        // Add SourceDocument* and RecId to the selection field list
        localQbds.addSelectionField(fieldName2id(localQbds.table(), sdFieldName));
        localQbds.addSelectionField(fieldName2id(localQbds.table(), 'RecId'));

        groupbyCnt = query.groupByFieldCount();
        for (i = 1; i <= groupbyCnt; i++)
        {
            queryGroupByField = query.groupByField(i);
            localRecord = _queryResult.get(queryGroupByField.dataSource().table());
            localQbds = localQuery.dataSourceTable(queryGroupByField.dataSource().table());
            localQbds.joinMode(JoinMode::InnerJoin);
            localQbds.addRange(queryGroupByField.fieldID()).value(queryValue(localRecord.getFieldValue(fieldId2name(queryGroupByField.dataSource().table(), queryGroupByField.fieldID()))));
            localQbds.addSelectionField(queryGroupByField.fieldID());
        }
        localQuery.clearGroupBy();
        localQuery.clearHavingFilters();

        return  localQuery;
    }

]]></Source>
      </Method>
      <Method>
        <Name>canGoBatch</Name>
        <Source><![CDATA[
    /// <summary>
    ///    Determines whether the job can be executed in batch.
    /// </summary>
    /// <returns>
    ///    true if the job can be executed in batch; otherwise, false.
    /// </returns>
    public boolean canGoBatch()
    {
        return true;
    }

]]></Source>
      </Method>
      <Method>
        <Name>convertMapToArray</Name>
        <Source><![CDATA[
    /// <summary>
    /// Convert the supplied map into an array of containers.
    /// </summary>
    /// <param name="_sourceMap">
    /// The <c>Map</c> to be converted.
    /// </param>
    /// <returns>
    /// An <c>Array</c> of containers where each container holds a key/value pair from the supplied <c>Map</c>.
    /// </returns>
    private Array convertMapToArray(Map _sourceMap)
    {
        MapEnumerator   mapEnumerator = _sourceMap.getEnumerator();
        Array           destinationArray = new Array(Types::Container);
        int             i;

        while (mapEnumerator.moveNext())
        {
            i++;
            destinationArray.value(i, [any2Int64(mapEnumerator.currentKey()), any2Int64(mapEnumerator.currentValue())]);
        }

        return destinationArray;
    }

]]></Source>
      </Method>
      <Method>
        <Name>createRuleViolation</Name>
        <Source><![CDATA[
    /// <summary>
    ///     Creates the violation record in the <c>SysPolicySourceDocumentRuleViolation</c> and <c>AuditPolicyRuleViolation</c> table.
    /// </summary>
    /// <param name="_rootDocument">
    ///     The record of the document that violated the audit rule.
    /// </param>
    /// <param name="_instanceID">
    ///     The violation sequence number.
    /// </param>
    /// <remarks>
    ///     The violation instance number is the same for aggregate and duplicate violation records.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void createRuleViolation(Common _rootDocument, Num _instanceID)
    {
        RefRecId    sourceDocumentRecId;

        if (sdFieldName)
        {
            // Get the field related to either SourceDocumentHeader or SourceDocumentLine
            // on the root document
            sourceDocumentRecId = _rootDocument.getFieldValue(sdFieldName);

            if (sourceDocumentRecId)
            {
                this.createRuleViolationForSourceDocument(sourceDocumentRecId, _instanceID);
            }
        }
    }

]]></Source>
      </Method>
      <Method>
        <Name>createRuleViolationForSourceDocument</Name>
        <Source><![CDATA[
    /// <summary>
    ///     Creates the violation record in the <c>SysPolicySourceDocumentRuleViolation</c> and <c>AuditPolicyRuleViolation</c> table.
    /// </summary>
    /// <param name="_sourceDocumentRecId">
    ///     The id of the <c>SourceDocumentHeader</c> or <c>SourceDocumentLine</c> record that violated the audit rule.
    /// </param>
    /// <param name="_instanceID">
    ///     The violation sequence number.
    /// </param>
    /// <remarks>
    ///     The violation instance number is the same for aggregate and duplicate violation records.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void createRuleViolationForSourceDocument(RefRecId _sourceDocumentRecId, Num _instanceID)
    {
        AuditPolicyRuleViolation                auditRuleViolation;
        SysPolicySourceDocumentRuleViolation    sdRuleViolation;

        if (_sourceDocumentRecId)
        {
            // Initialize the Source document violation record
            sdRuleViolation.LastEvaluationDate          = documentSelectionToDate;
            sdRuleViolation.PolicySourceDocumentRule    = ruleRecId;

            if (isSourceDocumentLine)
            {
                sdRuleViolation.SourceDocumentLine      = _sourceDocumentRecId;
                sdRuleViolation.IsForSourceDocumentLine = true;
            }
            else
            {
                sdRuleViolation.SourceDocumentHeader    = _sourceDocumentRecId;
            }

            sdRuleViolation.insert();

            if (sdRuleViolation)
            {
                auditRuleViolation.PolicySourceDocumentRuleViolation = sdRuleViolation.RecId;
                auditRuleViolation.InstanceID = _instanceID;
                auditRuleViolation.BatchJob = this.parmCurrentBatch().BatchJobId;
                auditRuleViolation.PolicyExecutionTimestamp = this.parmExecutionTime();
                auditRuleViolation.insert();
            }
        }
    }

]]></Source>
      </Method>
      <Method>
        <Name>executeAggregateRule</Name>
        <Source><![CDATA[
    /// <summary>
    /// Executes the aggregate audit rule.
    /// </summary>
    /// <remarks>
    /// Runs the query on the <c>SysPolicySourceDocumentRule</c> table. The records that are returned by
    /// the query execution are in violation of the rule. The source documents on the records returned are
    /// added to the <c>SysPolicySourceDocumentViolation</c> table. Miscellaneous information that is
    /// related to Audit is stored on the <c>AuditPolicyRuleViolation</c> table.
    /// </remarks>
    private void executeAggregateRule()
    {
        Query       localQuery;
        QueryRun    localQueryRun;
        Map         insertedRecIdList = new Map(Types::Int64, Types::Int64);
        Num         aggregateInstanceId;

        queryRun = new QueryRun(query);
        if (queryRun)
        {
            ttsbegin;
            while (queryRun.next())
            {
                localQuery      = this.buildAggregateDuplicateSamplingQuery(queryRun);
                localQueryRun   = new QueryRun(localQuery);
                aggregateInstanceId = instanceNumSeq.num();

                while (localQueryRun.next())
                {
                    if (!insertedRecIdList.exists(localQueryRun.getNo(1).RecId))
                    {
                        insertedRecIdList.insert(localQueryRun.getNo(1).RecId, localQueryRun.getNo(1).RecId);
                        this.createRuleViolation(localQueryRun.getNo(1), aggregateInstanceId);
                    }
                }
            }
            ttscommit;
        }
    }

]]></Source>
      </Method>
      <Method>
        <Name>executeConditionalListRule</Name>
        <Source><![CDATA[
    /// <summary>
    ///    Executes the conditional or list rule and creates violation records.
    /// </summary>
    private void executeConditionalListRule()
    {
        queryRun = new QueryRun(query);
        if (queryRun && queryRun.next())
        {
            ttsbegin;
            this.createRuleViolation(queryRun.getNo(1), instanceNumSeq.num());
            ttscommit;
        }
    }

]]></Source>
      </Method>
      <Method>
        <Name>executeDuplicateRule</Name>
        <Source><![CDATA[
    /// <summary>
    /// Executes the duplicate audit rule.
    /// </summary>
    /// <remarks>
    /// Runs the query on the <c>SysPolicySourceDocumentRule</c> table. The records that are returned by
    /// the query execution are in violation of the rule. The source documents on the records that are
    /// returned are added to the <c>SysPolicySourceDocumentViolation</c> table. Miscellaneous information
    /// that is related to audit is stored on the <c>AuditPolicyRuleViolation</c> table.
    /// </remarks>
    private void executeDuplicateRule()
    {
        Common      rootTable;
        Num         duplicateInstanceId;
        Query       localQuery;
        QueryRun    localQueryRun;
        int         cnt = 0;

        queryRun = new QueryRun(query);

        if (queryRun)
        {
            ttsbegin;
            while (queryRun.next())
            {
                rootTable = queryRun.getNo(1);
                cnt = rootTable.getFieldValue('RecId');

                if (cnt > 1)
                {
                    localQuery = this.buildAggregateDuplicateSamplingQuery(queryRun);
                    localQueryRun = new QueryRun(localQuery);
                    duplicateInstanceId = instanceNumSeq.num();

                    while (localQueryRun.next())
                    {
                        // Create the violation with the same instance ID for duplicate rule
                        this.createRuleViolation(localQueryRun.getNo(1), duplicateInstanceId);
                    }
                }
            }
            ttscommit;
        }
    }

]]></Source>
      </Method>
      <Method>
        <Name>executeKeywordRule</Name>
        <Source><![CDATA[
    /// <summary>
    /// Executes the audit rule of type keyword.
    /// </summary>
    /// <remarks>
    /// Runs the query on the <c>SysPolicySourceDocumentRule</c> table. The records returned by the query
    /// execution are in violation of the rule. The source documents on the records returned are added to
    /// the <c>SysPolicySourceDocumentViolation</c> table. Miscellaneous information related to Audit is
    /// stored on the <c>AuditPolicyRuleViolation</c> table.
    /// </remarks>
    private void executeKeywordRule()
    {
        AuditPolicyListKeywordView              auditPolicyListKeywordView;
        AuditPolicyFullTextSearchTransient      apFTSTransient;
        int64                                   apFTSTransientCreatedTransactionId;
        Common                                  dataSourceRecord;
        container                               keywordFieldList;
        int                                     dataSourceCnt;
        int                                     i;
        int                                     k;

        this.addSearchFieldsToQuery();
        queryRun = new QueryRun(query);
        dataSourceCnt = query.dataSourceCount();

        // place the value of each "keyword field" from the tables involved in the query into the full text search transient table
        ttsbegin;
        while (queryRun.next())
        {
            for (k = 1; k <= dataSourceCnt; k++)
            {
                dataSourceRecord = queryRun.getNo(k);
                if (tableKeywordFieldList.exists(dataSourceRecord.TableId))
                {
                    keywordFieldList = tableKeywordFieldList.lookup(dataSourceRecord.TableId);
                    // Insert the values of the select list into the Full text search index enabled table.
                    for (i = 1; i <= conLen(keywordFieldList); i++)
                    {
                        if (dataSourceRecord && dataSourceRecord.getFieldValue(conPeek(keywordFieldList, i)))
                        {
                            apFTSTransient.FullTextSearchString = dataSourceRecord.getFieldValue(conPeek(keywordFieldList, i));
                            apFTSTransient.insert();
                        }
                    }
                }
            }
        }
        ttscommit;

        apFTSTransientCreatedTransactionId = apFTSTransient.CreatedTransactionId;

        if (apFTSTransient)
        {
            ttsbegin;

            // check for existance of any keyword in the text search table
            select firstonly KeywordWildcard from auditPolicyListKeywordView
                join FullTextSearchString from apFTSTransient
                where auditPolicyListKeywordView.SysPolicySourceDocumentRule == sdRule.RecId &&
                      apFTSTransient.CreatedTransactionId == apFTSTransientCreatedTransactionId &&
                      apFTSTransient.FullTextSearchString like auditPolicyListKeywordView.KeywordWildcard;

            if (apFTSTransient)
            {
                // Create violation if the select returned ANY record
                queryRun = new QueryRun(query);
                queryRun.next();
                this.createRuleViolation(queryRun.getNo(1), instanceNumSeq.num());
            }

            ttscommit;

            // remove the values we added to the AuditPolicyFullTextSearchTransient table
            delete_from apFTSTransient
                where apFTSTransient.CreatedTransactionId == apFTSTransientCreatedTransactionId;
        }
    }

]]></Source>
      </Method>
      <Method>
        <Name>executeSamplingRule</Name>
        <Source><![CDATA[
    /// <summary>
    ///    Executes the sampling rule and creates violation records.
    /// </summary>
    /// <remarks>
    ///    Selects a portion of candidate documents identified by the <c>Query</c> associated with the <c>PolicyRule</c>.
    ///    The selection algorithm calculates a stepping pattern based on the number of candidate documents and a
    ///    percentage specified by the user.
    /// </remarks>
    private void executeSamplingRule()
    {
        Query           localQuery;
        QueryRun        localQueryRun;
        Map             rootDocuments = new Map(Types::Int64, Types::Int64);
        Array           rootDocumentsArray = new Array(Types::Container);
        RefRecId        rootDocumentRecId;
        RefRecId        sourceDocumentRecId;
        int             rootDocumentCount;
        int             numberOfViolationsToCreate;
        real            sampleStep;
        real            currentSampleStep;
        int             samplePositionShift;
        int             currentSampleIndex;
        int             violationCount;
        int             lastViolationIndex;

        // check that we can generate violations before doing any expensive work
        if (sdRule.SamplePercent <= 0 || !sdFieldName)
        {
            return;
        }

        // identify the set of unique root documents included in the query
        queryRun = new QueryRun(query);
        while (queryRun.next())
        {
            if (queryRun.changedNo(1))
            {
                if (query.groupByFieldCount())
                {
                    // if there is grouping in the query, ensure we identify the individual root documents involved
                    localQuery      = this.buildAggregateDuplicateSamplingQuery(queryRun);
                    localQueryRun   = new QueryRun(localQuery);
                    while (localQueryRun.next())
                    {
                        // add each root document and associated source document field value to the collection
                        if (!rootDocuments.exists(localQueryRun.getNo(1).RecId))
                        {
                            rootDocuments.insert(localQueryRun.getNo(1).RecId, localQueryRun.getNo(1).getFieldValue(sdFieldName));
                        }
                    }
                }
                else
                {
                    // add the root document and associated source document field value to the collection
                    if (!rootDocuments.exists(queryRun.getNo(1).RecId))
                    {
                        rootDocuments.insert(queryRun.getNo(1).RecId, queryRun.getNo(1).getFieldValue(sdFieldName));
                    }
                }
            }
        }

        // determine the number of violations to be generated from the documents in the set, round up to nearest whole number
        rootDocumentCount = rootDocuments.elements();
        numberOfViolationsToCreate = any2int(roundUp((sdRule.SamplePercent / 100) * rootDocumentCount, 1));

        if (rootDocumentCount > 0 && numberOfViolationsToCreate > 0)
        {
            // transition the map contents to an array to allow the selection algorithm to pick specific entries
            rootDocumentsArray = this.convertMapToArray(rootDocuments);

            // calculate the incrementor used to determine documents to target
            sampleStep = rootDocumentCount / numberOfViolationsToCreate;

            // a position shift value is used to drive small sample results away from the first/last documents in the collection
            samplePositionShift = any2int(sampleStep / 2);

            ttsBegin;

            // step through the collection, creating violations for the documents identified by the selection algorithm
            while (violationCount < numberOfViolationsToCreate
                && lastViolationIndex < rootDocumentCount
                && currentSampleIndex < rootDocumentCount)
            {
                currentSampleStep += sampleStep;
                currentSampleIndex = any2int(roundDown(currentSampleStep, 1) - samplePositionShift);
                if (currentSampleIndex > lastViolationIndex && currentSampleIndex <= rootDocumentCount)
                {
                    // create a violation for the source document
                    [rootDocumentRecId, sourceDocumentRecId] = rootDocumentsArray.value(currentSampleIndex);
                    this.createRuleViolationForSourceDocument(sourceDocumentRecId, instanceNumSeq.num());
                    lastViolationIndex = currentSampleIndex;
                    violationCount ++;
                }
            }

            ttsCommit;
        }
    }

]]></Source>
      </Method>
      <Method>
        <Name>modifyRuleQuery</Name>
        <Source><![CDATA[
    /// <summary>
    /// Modifies the selection list and range of the rule query.
    /// </summary>
    /// <remarks>
    /// Adds the field referencing <c>SourceDocumentHeader</c> or <c>SourceDocumentLine</c> table to the
    /// select list of the specified query.Also, adds the record ID of the document being audited to the
    /// range clause.Because having more than one field related to SourceDocument* tables would create
    /// ambiguity as to which field to pick for creating an audit violation, such a document is ignored.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void modifyRuleQuery()
    {
        QueryBuildDataSource    qbds;
        QueryBuildDataSource    qbdsList;

        [sdFieldName, isSourceDocumentLine] = AuditPolicyExecutionTask::getSourceDocumentFieldAndFlag(query.dataSourceNo(1).table());

        if (sdFieldName)
        {
            qbds = query.dataSourceNo(1);
            if (qbds)
            {
                // Add Date and LE range since these types do not go through pre-screening in the AuditPolicyExecution class
                if (samplingMode || aggregateMode || duplicateMode)
                {
                    AuditPolicyExecution::addDateAndLegalEntityRange(query, legalEntityList, documentSelectionFromDate, documentSelectionToDate, sourceRelationTypeId, sdRuleType);
                }
                else
                {
                    // Add 'SourceDocumentHeader' or 'SourceDocumentLine' field to the selection list.
                    // In case of aggregate, duplicate and sampling, this field is added to a different query later on (see method: buildAggregateDuplicateSelectQuery)
                    qbds.addSelectionField(fieldName2id(query.dataSourceNo(1).table(), sdFieldName));
                    // Add RecId value to the range
                    query.addQueryFilter(qbds, 'RecId').value(queryValue(sourceRecId));
                }

                // Add count(RecId) to the query selection list
                if (duplicateMode)
                {
                    qbds.addSelectionField(fieldName2id(query.dataSourceNo(1).table(), 'RecId'), SelectionField::Count);
                }

                // Add date range to the AuditPolicyListParty table
                if (listMode)
                {
                    qbdsList = query.dataSourceTable(tableNum(AuditPolicyListParty));
                    if (qbdsList)
                    {
                        query.validTimeStateDateTimeRange(documentSelectionToDate, documentSelectionToDate);
                    }
                }
            }
        }
    }

]]></Source>
      </Method>
      <Method>
        <Name>new</Name>
        <Source><![CDATA[
    /// <summary>
    /// Creates the instance of <c>AuditPolicyExecutionTask</c> class.
    /// </summary>
    /// <param name="_ruleRecordID">
    /// The record id of the policy rule.
    /// </param>
    /// <param name="_sourceRecId">
    /// The record id of the document.
    /// </param>
    /// <param name="_numberSeqTableRecId">
    ///  The record id of the <c>NumberSequenceTable</c> table record.
    /// </param>
    protected void new(RefRecId _ruleRecordID, RefRecId _sourceRecId, RefRecId _numberSeqTableRecId)
    {
        super();

        ruleRecId           = _ruleRecordID;
        sourceRecId         = _sourceRecId;
        instanceNumSeqId    = _numberSeqTableRecId;
        legalEntityList     = new Array(Types::String);
    }

]]></Source>
      </Method>
      <Method>
        <Name>pack</Name>
        <Source><![CDATA[
    public container pack()
    {
        packedLegalEntityList = legalEntityList.pack();
        return [#CurrentVersion, #CurrentList];
    }

]]></Source>
      </Method>
      <Method>
        <Name>parmExecutionTime</Name>
        <Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public utcdatetime parmExecutionTime(utcdatetime _executionTime = executionTime)
    {
        executionTime = _executionTime;
        return executionTime;
    }

]]></Source>
      </Method>
      <Method>
        <Name>run</Name>
        <Source><![CDATA[
    /// <summary>
    /// Executes the policy rules.
    /// </summary>
    public void run()
    {
        utcdatetime     minDateValue = DateTimeUtil::minValue();
        utcdatetime     maxDateValue = DateTimeUtil::maxValue();

        if (!testMode)
        {
            // Initialize Rule and RuleType records
            select validTimeState(minDateValue, maxDateValue) QueryPacked, Policy, PolicyRuleType, DuplicateSinceDays, SamplePercent from sdRule
                where sdRule.RecId == ruleRecId
                join QueryClassification, DateAttribute from sdRuleType
                    where sdRuleType.RecId == sdRule.PolicyRuleType;
        }

        if ((sdRule || testMode) && sdRuleType)
        {
            query = new Query(sdRule.QueryPacked);
            if (query && query.dataSourceCount())
            {
                sourceRelationTypeId = query.dataSourceNo(1).table();

                // Initialize the number sequence class
                instanceNumSeq = new NumberSeq();
                instanceNumSeq.parmNumberSequenceId(instanceNumSeqId);

                switch (sdRuleType.QueryClassification)
                {
                    case QueryClassification::Sampling:
                        samplingMode = true;
                        this.modifyRuleQuery();
                        this.executeSamplingRule();
                         break;
                    case QueryClassification::Conditional:
                        this.modifyRuleQuery();
                        this.executeConditionalListRule();
                        break;
                    case QueryClassification::ListSearch:
                        listMode = true;
                        this.modifyRuleQuery();
                        this.executeConditionalListRule();
                        break;
                    case QueryClassification::Aggregate:
                        aggregateMode = true;
                        this.modifyRuleQuery();
                        this.executeAggregateRule();
                        break;
                    case QueryClassification::Duplicate:
                        duplicateMode = true;
                        if (sdRule.DuplicateSinceDays)
                        {
                            documentSelectionFromDate = DateTimeUtil::addDays(documentSelectionFromDate, -sdRule.DuplicateSinceDays);
                        }
                        this.modifyRuleQuery();
                        this.executeDuplicateRule();
                        break;
                    case QueryClassification::KeywordSearch:
                        this.modifyRuleQuery();
                        this.executeKeywordRule();
                        break;
                }
            }
        }
    }

]]></Source>
      </Method>
      <Method>
        <Name>runsImpersonated</Name>
        <Source><![CDATA[
    /// <summary>
    ///    Determines whether the job can be executed in impersonate mode.
    /// </summary>
    /// <returns>
    ///    true if the job can be executed in impersonate mode; otherwise, false.
    /// </returns>
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
      </Method>
      <Method>
        <Name>setDocumentSelectionFromDate</Name>
        <Source><![CDATA[
    /// <summary>
    ///    Sets the from data of the document selection.
    /// </summary>
    /// <param name="_documentSelectionFromDate">
    ///    The from date value.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void setDocumentSelectionFromDate(utcdatetime _documentSelectionFromDate)
    {
        documentSelectionFromDate = _documentSelectionFromDate;
    }

]]></Source>
      </Method>
      <Method>
        <Name>setDocumentSelectionToDate</Name>
        <Source><![CDATA[
    /// <summary>
    ///    Sets the to date of the document selection.
    /// </summary>
    /// <param name="_documentSelectionToDate">
    ///    The to date value.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void setDocumentSelectionToDate(utcdatetime _documentSelectionToDate)
    {
        documentSelectionToDate = _documentSelectionToDate;
    }

]]></Source>
      </Method>
      <Method>
        <Name>setLegalEntityList</Name>
        <Source><![CDATA[
    /// <summary>
    ///    Sets the legal entity list that is used to filter the documents for the current policy that is
    ///    being executed.
    /// </summary>
    /// <param name="_legalEntityList">
    ///    The array that contains the list of legal entities.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void setLegalEntityList(Array _legalEntityList)
    {
        legalEntityList = _legalEntityList;
    }

]]></Source>
      </Method>
      <Method>
        <Name>setTestMode</Name>
        <Source><![CDATA[
    /// <summary>
    ///    Sets the test mode variable value to true.
    /// </summary>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void setTestMode()
    {
        testMode = true;
    }

]]></Source>
      </Method>
      <Method>
        <Name>setTestSourceDocumentRule</Name>
        <Source><![CDATA[
    /// <summary>
    ///     Sets the <c>SysPolicySourceDocumentRule</c> table test buffer for test mode.
    /// </summary>
    /// <param name="_sdRuleTest">
    ///     The <c>SysPolicySourceDocumentRule</c> table test buffer.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void setTestSourceDocumentRule(SysPolicySourceDocumentRule _sdRuleTest)
    {
        sdRule = _sdRuleTest;
    }

]]></Source>
      </Method>
      <Method>
        <Name>setTestSourceDocumentRuleType</Name>
        <Source><![CDATA[
    /// <summary>
    ///     Sets the <c>SysPolicySourceDocumentRuleType</c> table test buffer for test mode.
    /// </summary>
    /// <param name="_sdRuleTypeTest">
    ///     The <c>SysPolicySourceDocumentRuleType</c> table test buffer.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void setTestSourceDocumentRuleType(SysPolicySourceDocumentRuleType _sdRuleTypeTest)
    {
        sdRuleType = _sdRuleTypeTest;
    }

]]></Source>
      </Method>
      <Method>
        <Name>unpack</Name>
        <Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Integer version = RunBase::getVersion(_packedClass);

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList] = _packedClass;
                break;

            default:
                return false;
        }

        // Create LegalEntity array from the container
        if (packedLegalEntityList != conNull())
        {
            legalEntityList = Array::create(packedLegalEntityList);
        }

        return true;
    }

]]></Source>
      </Method>
      <Method>
        <Name>construct</Name>
        <Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>AuditPolicyExecutionTask</c> class.
    /// </summary>
    /// <param name="_ruleRecordID">
    /// The record ID of the policy rule.
    /// </param>
    /// <param name="_sourceRecId">
    /// The record ID of the document.
    /// </param>
    /// <param name="_numberSeqTableRecId">
    /// The record ID of an <c>NumberSequenceTable</c> table record.
    /// </param>
    /// <returns>
    /// An instance of <c>AuditPolicyExecutionTask</c> class.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static AuditPolicyExecutionTask construct(RefRecId _ruleRecordID,
                                                     RefRecId _sourceRecId,
                                                     RefRecId _numberSeqTableRecId)
    {
        return new AuditPolicyExecutionTask(_ruleRecordID, _sourceRecId, _numberSeqTableRecId);
    }

]]></Source>
      </Method>
      <Method>
        <Name>create</Name>
        <Source><![CDATA[
    /// <summary>
    ///    Creates the object of the <c>AuditPolicyExecutionTask</c> class.
    /// </summary>
    /// <param name="_packedObject">
    ///    A container that has the serialized data of the <c>AuditPolicyExecutionTask</c> class.
    /// </param>
    /// <returns>
    ///    An object of the <c>AuditPolicyExecutionTask</c> class
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static AuditPolicyExecutionTask create(container _packedObject)
    {
        AuditPolicyExecutionTask auditPolicyExecutionTask = new AuditPolicyExecutionTask(0,0,0);

        // Init. the object with last save value which come from base class.
        auditPolicyExecutionTask.unpack(_packedObject);
        return auditPolicyExecutionTask;
    }

]]></Source>
      </Method>
      <Method>
        <Name>description</Name>
        <Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static ClassDescription description()
    {
        return "@SYS323738";
    }

]]></Source>
      </Method>
      <Method>
        <Name>getSourceDocumentField</Name>
        <Source><![CDATA[
    /// <summary>
    ///    Determines if any field on the specified document is related to the <c>SourceDocumentHeader</c> or
    ///    <c>SourceDocumentLine</c> table.
    /// </summary>
    /// <param name="_tableId">
    ///    The ID of the document to check.
    /// </param>
    /// <returns>
    ///    The name of the field that is related to either the <c>SourceDocumentHeader</c> or
    ///    <c>SourceDocumentLine</c> table.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static FieldName getSourceDocumentField(TableId _tableId)
    {
        FieldName sdFieldName;
        boolean   isSourceDocumentLine;

        [sdFieldName, isSourceDocumentLine] = AuditPolicyExecutionTask::getSourceDocumentFieldAndFlag(_tableId);

        return sdFieldName;
    }

]]></Source>
      </Method>
      <Method>
        <Name>getSourceDocumentFieldAndFlag</Name>
        <Source><![CDATA[
    /// <summary>
    ///    Determines the type of the specified document based on whether it is related to the
    ///    <c>SourceDocumentHeader</c> or <c>SourceDocumentLine</c> table.
    /// </summary>
    /// <param name="_tableId">
    ///    The ID of the document for which to determine the type.
    /// </param>
    /// <returns>
    ///    A container with the field that is related to either the <c>SourceDocumentHeader</c> or
    ///    <c>SourceDocumentLine</c> table and a true if the field is related to the <c>SourceDocumentLine</c>
    ///    table; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method returns the name of the field that is related to either the <c>SourceDocumentHeader</c>
    ///    or <c>SourceDocumentLine</c> table.Although the <c>foreignKeyFieldList</c> of the
    ///    <c>SysTableFieldLookup</c> class may return more than one field that is related to
    ///    <c>SourceDocument*</c> tables, only the fields are related to either the
    ///    <c>SourceDocumentHeader</c> or <c>SourceDocumentLine</c> table are considered.Because more than one
    ///    field related to <c>SourceDocument*</c> tables would create ambiguity as to which field to use to
    ///    create an audit violation, such a document is ignored.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static container getSourceDocumentFieldAndFlag(TableId _tableId)
    {
        boolean     isSourceDocumentLine;
        container   sdField;
        DictTable   dictTable;
        FieldName   sdFieldName;

        dictTable = new DictTable(_tableId);
        if (dictTable)
        {
            // Find the Source document header/line field on the document passed in
            sdField = SysTableFieldLookup::foreignKeyFieldList(dictTable.name(), tableStr(SourceDocumentHeader));
            if (!conLen(sdField))
            {
                sdField = SysTableFieldLookup::foreignKeyFieldList(dictTable.name(), tableStr(SourceDocumentLine));
                isSourceDocumentLine = true;
            }
        }

        if (conLen(sdField) == 1)
        {
            sdFieldName = conPeek(sdField, 1);
        }
        else
        {
            sdFieldName = '';
        }
        return [sdFieldName, isSourceDocumentLine];
    }

]]></Source>
      </Method>
      <Method>
        <Name>isSourceDocumentLine</Name>
        <Source><![CDATA[
    /// <summary>
    /// Indicates the type of the specified document based on its relation to the
    /// <c>SourceDocumentHeader</c> or <c>SourceDocumentLine</c> table.
    /// </summary>
    /// <param name="_tableId">
    /// The ID of the document whose type is to be determined.
    /// </param>
    /// <returns>
    /// true if the document is related to <c>SourceDocumentLine</c> table; otherwise, false.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static boolean isSourceDocumentLine(TableId _tableId)
    {
        RefRecId sdField;
        boolean  isSourceDocumentLine;

        [sdField, isSourceDocumentLine] = AuditPolicyExecutionTask::getSourceDocumentFieldAndFlag(_tableId);

        return isSourceDocumentLine;
    }

]]></Source>
      </Method>
      <Method>
        <Name>canRunInNewSession</Name>
        <Source><![CDATA[
    /// <summary>
    /// Describes whether the class is designed for execution in a new session.
    /// </summary>
    /// <returns>
    /// true if the class is designed for executing the operation in a new session; otherwise, false.
    /// </returns>
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
      </Method>
      <Method>
        <Name>isRetryable</Name>
        <Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    public final boolean isRetryable() 
    {
        return false;
    }
]]></Source>
      </Method>
    </Methods>
  </SourceCode>
</AxClass>