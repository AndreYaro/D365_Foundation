<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailCDXDataFilterManager</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>RetailCDXDataFilterManager</c> class is for using new cache based query.
/// </summary>
internal class RetailCDXDataFilterManager extends RetailCDXDataFilterManagerBase
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>projectFields</Name>
				<Source><![CDATA[
    protected Query projectFields(Query query)
    {
        query.clearAllFields();

        // add source table fields
        QueryBuildDataSource souceTableDS = RetailCDXCodeGen::getSourceTableDS(query);
        QueryBuildFieldList sourceTableFieldList = souceTableDS.fields();
        sourceTableFieldList.addField(fieldName2id(souceTableDS.table(), 'RecId'));

        if (this.hasRetailTmpCDXNodeConstTableDataSource(query))
        {
            // add nodeCostTempTable fields
            QueryBuildDataSource nodeConstDS = query.dataSourceTable(tableNum(RetailTmpCDXNodeConstTable));
            QueryBuildFieldList nodeCostFieldList = nodeConstDS.fields();
            nodeCostFieldList.addField(fieldNum(RetailTmpCDXNodeConstTable, NodeID));
            nodeCostFieldList.addField(fieldNum(RetailTmpCDXNodeConstTable, SkipRecord));
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildFieldMapping</Name>
				<Source><![CDATA[
    protected Map buildFieldMapping(Query query)
    {
        Map fieldMap = new Map(Types::String, Types::Container);

        // map source table fields
        QueryBuildDataSource souceTableDS = RetailCDXCodeGen::getSourceTableDS(query);
        fieldMap.insert(fieldStr(RetailTmpCDXDataDistributionFilteredRecords, RefRecId), [souceTableDS.uniqueId(), 'RecId']);

        if (this.hasRetailTmpCDXNodeConstTableDataSource(query))
        {
            // map nodeCostTempTable fields
            QueryBuildDataSource nodeConstDS = query.dataSourceTable(tableNum(RetailTmpCDXNodeConstTable));
            fieldMap.insert(fieldStr(RetailTmpCDXDataDistributionFilteredRecords, NodeID), [nodeConstDS.uniqueId(), fieldStr(RetailTmpCDXNodeConstTable, NodeID)]);
            fieldMap.insert(fieldStr(RetailTmpCDXDataDistributionFilteredRecords, SkipRecord), [nodeConstDS.uniqueId(), fieldStr(RetailTmpCDXNodeConstTable, SkipRecord)]);
        }

        return fieldMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runInitQueryForTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs the full sync query for the table.
    /// </summary>
    /// <param name = "dataDistributionQuery">The <c>RetailCdxDataDistributionQuery</c> table buffer.</param>
    /// <param name = "isBaselineFullSync">Flag indicating if the full sync is for baseline data which will be used when handling new channels.</param>
    protected void runInitQueryForTable(RetailCdxDataDistributionQuery dataDistributionQuery, boolean isBaselineFullSync)
    {
        RetailTmpCDXTargetLegalEntity targetLegalEntities = this.dataSyncContext.openTargetLegalEntityTempTable();
        this.runFullSyncQueryForTable(dataDistributionQuery, isBaselineFullSync, targetLegalEntities);
    }

]]></Source>
			</Method>
			<Method>
				<Name>runFullSyncQueryForTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs the full sync query for the table using the specified list of legal entities in the RetailTmpCDXTargetLegalEntity table buffer.
    /// </summary>
    /// <param name = "dataDistributionQuery">The <c>RetailCdxDataDistributionQuery</c> table buffer.</param>
    /// <param name = "isBaselineFullSync">If the full sync is for baseline data which will be used when handling new channels.</param>
    /// <param name = "targetLegalEntities">The <c>RetailTmpCDXTargetLegalEntity</c> table buffer.</param>
    protected void runFullSyncQueryForTable(RetailCdxDataDistributionQuery dataDistributionQuery, boolean isBaselineSync, RetailTmpCDXTargetLegalEntity targetLegalEntities)
    {
        // if the node is not processed then get cache data for the current node and all parent nodes
        if (!dataSyncContext.isFullSyncProcessedForTableNode(dataDistributionQuery.QueryId, isBaselineSync))
        {
            this.getFullSyncCacheDataForNode(dataDistributionQuery, isBaselineSync, targetLegalEntities);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runDeltaQueryForTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes the delta sync queries for the cache based delta sync approach.
    /// </summary>
    /// <param name = "dataDistributionQuery">The table distribution node.</param>
    /// <param name = "isBaselineSync">True if this is delta sync to calculate baseline data set; otherwise, false.</param>
    /// <remarks>Overriden from the base class implementation to support cache based query pattern.</remarks>
    protected void runDeltaQueryForTable(RetailCdxDataDistributionQuery dataDistributionQuery, boolean isBaselineSync)
    {
        this.getDeltaSyncCacheDataForNode(dataDistributionQuery, isBaselineSync);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUseCacheBasedQuery</Name>
				<Source><![CDATA[
    protected boolean shouldUseCacheBasedQuery()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFullSyncCacheDataForNode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the full sync records for the specified table distribution node and caches the resulting data into the <c>RetailTmpCDXDataDistributionFilteredRecords</c> temp table
    /// so that the result is later used to calculate the full sync of the child table distribution nodes.
    /// </summary>
    /// <param name = "dataDistributionQuery">The table distribution node.</param>
    /// <param name = "isBaselineSync">The flag is used to calculate effective delta sync when a new store is introduced to an existing datastore.
    /// It indicates if the current full sync specific calculation is being made for the baseline stores, i.e. the preexistng stores excluding the newly added stores.
    /// </param>
    /// <param name = "targetLegalEntities">The <c>RetailTmpCDXTargetLegalEntity</c> table buffer containing the list of target legal entities.</param>
    private void getFullSyncCacheDataForNode(RetailCdxDataDistributionQuery dataDistributionQuery, boolean isBaselineSync, RetailTmpCDXTargetLegalEntity targetLegalEntities)
    {
        if (!targetLegalEntities)
        {
            targetLegalEntities = this.dataSyncContext.openTargetLegalEntityTempTable();
        }

        Query query = new Query(dataDistributionQuery.PackedQuery);
        int parentNodeId;

        QueryBuildDataSource fullSyncFilteredRecordsTempTableDS = query.dataSourceTable(tableNum(RetailTmpCDXDataDistributionFilteredRecords));

        // if the node does not have parent node then it will not have filteredRecordsTempTableDS
        if (fullSyncFilteredRecordsTempTableDS)
        {
            parentNodeId = str2Int(fullSyncFilteredRecordsTempTableDS.rangeField(fieldNum(RetailTmpCDXDataDistributionFilteredRecords, NodeID)).value());

            // if parent node is not processed then get the cache data recursively
            if (!dataSyncContext.isFullSyncProcessedForTableNode(parentNodeId, isBaselineSync))
            {
                RetailCdxDataDistributionQuery parentDataDistributionQuery = RetailCdxDataDistributionQuery::find(parentNodeId, dataSyncContext.getChannelSchema(), this.shouldUseCacheBasedQuery());

                if (parentDataDistributionQuery)
                {
                    this.getFullSyncCacheDataForNode(parentDataDistributionQuery, isBaselineSync, targetLegalEntities);
                }
            }
        }

        this.insertIntoFullSyncFilteredRecordsTempTable(dataDistributionQuery, isBaselineSync, targetLegalEntities);

        if (this.isPropagationOptimizationEnabled(parentNodeId))
        {
            this.initializePropagatedHistoryTable(dataDistributionQuery, isBaselineSync);
        }

        dataSyncContext.markTableNodeAsProcessedForFullSync(dataDistributionQuery.QueryId, isBaselineSync);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDeltaSyncCacheDataForNode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the delta sync records for the specified table distribution node and caches the resulting data into the <c>RetailTmpCDXDataDistributionDeltaSyncFilteredRecords</c> temp table
    /// so that the result is later used to calculate the delta sync of the child table distribution nodes.
    /// </summary>
    /// <param name = "dataDistributionQuery">The table distribution node.</param>
    /// <param name = "isBaselineSync">The flag is used to calculate delta sync when a new store is introduced to an existing datastore.
    /// It indicates if the current delta sync specific calculation is being made for the baseline stores, i.e. the preexistng stores excluding the newly added stores.</param>
    private void getDeltaSyncCacheDataForNode(RetailCdxDataDistributionQuery dataDistributionQuery, boolean isBaselineSync)
    {
        // if the current node is not yet processed then call getDeltaSyncCacheDataForNode on the node to calculate the delta sync records from that node and cache the resulting 
        // data so as to later use it to calculate the delta sync of the child node.
        if (!dataSyncContext.isDeltaSyncProcessedForTableNode(dataDistributionQuery.QueryId, isBaselineSync))
        {
            boolean useCacheBasedNodeLevelChangeSelection = false || isBaselineSync; //for baseline sync we can leverage the cacheBasedNodeLevelValueChangeSelectorQuery to generate both the delta and full sync.

            Query cacheBasedNodeLevelValueChangeSelectorQuery = new Query(dataDistributionQuery.CacheBasedNodeLevelValueChangeSelectorQuery);

            // if PropagatedChangeSelectorQuery is not empty then it has parent node
            if (dataDistributionQuery.PropagatedChangeSelectorQuery)
            {
                // main table changed records join parent node full sync result
                QueryBuildDataSource parentDS = cacheBasedNodeLevelValueChangeSelectorQuery.dataSourceTable(tableNum(RetailTmpCDXDataDistributionFilteredRecords)); // since the last datasource is nodeCostTable, get the 2nd last datasource
                RetailCDXSqlQueryID parentNodeId = str2Int(parentDS.range(1).value());

                RetailCdxDataDistributionQuery parentDataDistributionQuery = RetailCdxDataDistributionQuery::find(parentNodeId, dataSyncContext.getChannelSchema(), this.shouldUseCacheBasedQuery());

                if (useCacheBasedNodeLevelChangeSelection && !dataSyncContext.isFullSyncProcessedForTableNode(parentNodeId, isBaselineSync))
                {
                    RetailTmpCDXTargetLegalEntity targetLegalEntities = this.dataSyncContext.openTargetLegalEntityTempTable();
                    this.getFullSyncCacheDataForNode(parentDataDistributionQuery, isBaselineSync, targetLegalEntities);
                }

                // main table join parent node delta sync result where IsLinkChanged = true
                Query propagatedChangeSelectorQuery = new Query(dataDistributionQuery.PropagatedChangeSelectorQuery);

                // if the parent node is not yet processed then call getDeltaSyncCacheDataForNode on the parent node to calculate the delta sync records for the parent node and cache the resulting 
                // data so as to later use it to calculate the delta sync of the child node.
                if (!dataSyncContext.isDeltaSyncProcessedForTableNode(parentNodeId, isBaselineSync))
                {
                    this.getDeltaSyncCacheDataForNode(parentDataDistributionQuery, isBaselineSync);
                }
            }

            this.insertIntoDeltaSyncFilteredRecordsTempTable(dataDistributionQuery, isBaselineSync, useCacheBasedNodeLevelChangeSelection);

            dataSyncContext.markTableNodeAsProcessedForDeltaSync(dataDistributionQuery.QueryId, isBaselineSync);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertIntoFullSyncFilteredRecordsTempTable</Name>
				<Source><![CDATA[
    private void insertIntoFullSyncFilteredRecordsTempTable(RetailCdxDataDistributionQuery dataDistributionQuery, boolean isBaselineSync, RetailTmpCDXTargetLegalEntity targetLegalEntities)
    {
        RetailTmpCDXDataDistributionFilteredRecords targetFilteredRecordsTempTable = dataSyncContext.getFullSyncFilteredRecordsTempTableInstance(dataDistributionQuery.RefTableId, isBaselineSync);

        Query query = new Query(dataDistributionQuery.PackedQuery);
        QueryBuildDataSource sourceTableDS = RetailCDXCodeGen::getSourceTableDS(query);

        if (dataSyncContext.paramIsDateFilterEnabled())
        {
            // only need to set date filter value for the source table, since for cached based query other joined table is temp table
            this.setDSDateFilterField(sourceTableDS);
        }

        query = this.projectFields(query);

        query.skipAutoOrderBy(true);
        query.forceSelectOrder(RetailCdxFeatureControl::isCacheBasedFullSyncQueryForceOrderEnabled());

        QueryRun queryRun = new QueryRun(query);

        QueryBuildDataSource targetChannelTempTableDS = query.dataSourceName(#TargetChannelDSName);

        RetailTmpCDXDataDistributionFilteredRecords parentFilteredRecordsTempTable;

        if (targetChannelTempTableDS)
        {
            queryRun.setRecord(targetChannelTempTable);
        }
        else
        {
            QueryBuildDataSource filteredRecordsTempTableDS = query.dataSourceTable(tableNum(RetailTmpCDXDataDistributionFilteredRecords));

            if (filteredRecordsTempTableDS)
            {
                parentFilteredRecordsTempTable = dataSyncContext.getFullSyncFilteredRecordsTempTableInstance(tableName2Id(filteredRecordsTempTableDS.name()), isBaselineSync);
                queryRun.setRecord(parentFilteredRecordsTempTable);
            }
        }

        Map fieldMap = new Map(Types::String, Types::Container);
        fieldMap.insert(fieldStr(RetailTmpCDXDataDistributionFilteredRecords, RefRecId), [sourceTableDS.uniqueId(), 'RecId']);

        if (this.hasRetailTmpCDXNodeConstTableDataSource(query))
        {
            RetailTmpCDXNodeConstTable nodeConstTempTable;
            nodeConstTempTable.NodeId = dataDistributionQuery.QueryId;
            nodeConstTempTable.SkipRecord = dataDistributionQuery.shouldSkipDataSync();
            nodeConstTempTable.insert();

            queryRun.setRecord(nodeConstTempTable);
            
            // map nodeCostTempTable fields
            QueryBuildDataSource nodeConstDS = query.dataSourceTable(tableNum(RetailTmpCDXNodeConstTable));
            fieldMap.insert(fieldStr(RetailTmpCDXDataDistributionFilteredRecords, NodeID), [nodeConstDS.uniqueId(), fieldStr(RetailTmpCDXNodeConstTable, NodeID)]);
            fieldMap.insert(fieldStr(RetailTmpCDXDataDistributionFilteredRecords, SkipRecord), [nodeConstDS.uniqueId(), fieldStr(RetailTmpCDXNodeConstTable, SkipRecord)]);
        }
        else
        {
            fieldMap.insert(fieldStr(RetailTmpCDXDataDistributionFilteredRecords, NodeID), [0, 'int', int2Str(dataDistributionQuery.QueryId)]);
            fieldMap.insert(fieldStr(RetailTmpCDXDataDistributionFilteredRecords, SkipRecord), [0, 'int', int2Str(any2Int(dataDistributionQuery.shouldSkipDataSync()))]);
        }

        // set recordLevelSecurity to false to prevent downgrading to row by row operation
        targetFilteredRecordsTempTable.recordLevelSecurity(false);

        // if the destination table used in the Query::insert_recordset is the same as the table used in the query object then use a third/intermediate temp table as Query::insert_recordset does not support
        // inserting into the same table which also appears in the query object.
        // One example of it is the LogisticsLocation node has parent node with the same table LogisticsLocation (see AX7 table distribution).
        if (parentFilteredRecordsTempTable.getPhysicalTableName() == targetFilteredRecordsTempTable.getPhysicalTableName())
        {
            RetailTmpCDXDataDistributionFilteredRecords interTempTable;

            this.insert_QueryRecordset(interTempTable, fieldMap, queryRun, targetLegalEntities);

            insert_recordset targetFilteredRecordsTempTable (NodeID, RefRecID, SkipRecord)
                select NodeID, RefRecID, SkipRecord from interTempTable;
        }
        else
        {
            this.insert_QueryRecordset(targetFilteredRecordsTempTable, fieldMap, queryRun, targetLegalEntities);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertIntoDeltaSyncFilteredRecordsTempTable</Name>
				<Source><![CDATA[
    private void insertIntoDeltaSyncFilteredRecordsTempTable(RetailCdxDataDistributionQuery dataDistributionQuery, boolean isBaselineSync, boolean useCacheBasedNodeLevelChangeSelection)
    {        
        this.insertNodeLevelChangesIntoDeltaSyncFilteredRecordsTempTable(dataDistributionQuery, isBaselineSync, useCacheBasedNodeLevelChangeSelection);

        // process propagatedChangeSelectorQuery
        if (dataDistributionQuery.PropagatedChangeSelectorQuery)
        {
            this.insertPropagatedChangeIntoDeltaSyncFilterRecordsTempTable(dataDistributionQuery, isBaselineSync);
        }   
     
        if(!this.dataSyncContext.paramNewLESet().empty() & !isBaselineSync)
        {
            // if there is a new LE detected during a delta sync then a full sync record from the new LE will be generated for the non global tables and saved to the full sync cache.
            // And these records need to be added to the final delta sync result.
            RetailTmpCDXDataDistributionDeltaSyncFilteredRecords deltaSyncRecords = dataSyncContext.getDeltaSyncFilteredRecordsTempTableInstance(dataDistributionQuery.RefTableId, isBaselineSync);
            RetailTmpCDXDataDistributionFilteredRecords fullSyncRecordsForNewLEs = dataSyncContext.getFullSyncFilteredRecordsTempTableInstance(dataDistributionQuery.RefTableId, isBaselineSync);

            insert_recordset deltaSyncRecords (NodeID, SkipRecord, RefRecId)
                select NodeID, SkipRecord, RefRecId from fullSyncRecordsForNewLEs;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertNodeLevelChangesIntoDeltaSyncFilteredRecordsTempTable</Name>
				<Source><![CDATA[
    private void insertNodeLevelChangesIntoDeltaSyncFilteredRecordsTempTable(RetailCdxDataDistributionQuery dataDistributionQuery,
        boolean isBaselineSync,
        boolean useCacheBasedNodeLevelChangeSelection)
    {
        RetailTmpCDXDataDistributionDeltaSyncFilteredRecords targetDeltaSyncFilteredRecordsTempTable = dataSyncContext.getDeltaSyncFilteredRecordsTempTableInstance(dataDistributionQuery.RefTableId, isBaselineSync);

        if (useCacheBasedNodeLevelChangeSelection)
        {
            Query cacheBasedNodeLevelValueChangeSelectorQuery = new Query(dataDistributionQuery.CacheBasedNodeLevelValueChangeSelectorQuery);

            cacheBasedNodeLevelValueChangeSelectorQuery.clearAllFields();
            
            QueryBuildDataSource nodeConstDS;
            if (this.hasRetailTmpCDXNodeConstTableDataSource(cacheBasedNodeLevelValueChangeSelectorQuery))
            {
                // add nodeCostTempTable to the last datasource.
                nodeConstDS = cacheBasedNodeLevelValueChangeSelectorQuery.dataSourceTable(tableNum(RetailTmpCDXNodeConstTable));
                QueryBuildFieldList fieldList = nodeConstDS.fields();
                fieldList.addField(fieldNum(RetailTmpCDXNodeConstTable, NodeID));
                fieldList.addField(fieldNum(RetailTmpCDXNodeConstTable, SkipRecord));
            }

            QueryBuildDataSource sourceTableDs = cacheBasedNodeLevelValueChangeSelectorQuery.dataSourceTable(tableNum(RetailCDXChangeRefTable1));
            QueryBuildFieldList fieldList = sourceTableDs.fields();
            fieldList.addField(fieldNum(RetailCDXChangeRefTable1, RefRecId));
            fieldList.addField(fieldNum(RetailCDXChangeRefTable1, NodeID));

            cacheBasedNodeLevelValueChangeSelectorQuery.skipAutoOrderBy(true);
            cacheBasedNodeLevelValueChangeSelectorQuery.forceSelectOrder(RetailCdxFeatureControl::isNodeLevelChangeSelectorQueryForceOrderEnabled());

            QueryRun queryRun = new QueryRun(cacheBasedNodeLevelValueChangeSelectorQuery);

            QueryBuildDataSource targetChannelTempTableDS = cacheBasedNodeLevelValueChangeSelectorQuery.dataSourceName(#TargetChannelDSName);

            if (targetChannelTempTableDS)
            {
                queryRun.setRecord(targetChannelTempTable);
            }

            Map insertFieldMap = new Map(Types::String, Types::Container);
            insertFieldMap.insert(fieldStr(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, RefRecId), [sourceTableDS.uniqueId(), 'RefRecId']);
            insertFieldMap.insert(fieldStr(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, ChildNodeID), [sourceTableDS.uniqueId(), 'NodeID']);

            if (this.hasRetailTmpCDXNodeConstTableDataSource(cacheBasedNodeLevelValueChangeSelectorQuery))
            {
                RetailTmpCDXNodeConstTable nodeConstTempTable;
                nodeConstTempTable.NodeId = dataDistributionQuery.QueryId;
                nodeConstTempTable.SkipRecord = dataDistributionQuery.shouldSkipDataSync();
                nodeConstTempTable.insert();
                queryRun.setRecord(nodeConstTempTable);
         
                insertFieldMap.insert(fieldStr(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, NodeID), [nodeConstDS.uniqueId(), fieldStr(RetailTmpCDXNodeConstTable, NodeID)]);
                insertFieldMap.insert(fieldStr(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, SkipRecord), [nodeConstDS.uniqueId(), fieldStr(RetailTmpCDXNodeConstTable, SkipRecord)]);
            }
            else
            {
                insertFieldMap.insert(fieldStr(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, NodeID), [0, 'int', int2Str(dataDistributionQuery.QueryId)]);
                insertFieldMap.insert(fieldStr(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, SkipRecord), [0, 'int', int2Str(any2Int(dataDistributionQuery.shouldSkipDataSync()))]);
            }

            queryRun.setRecord(changeTrackingTempTable);

            if (dataDistributionQuery.PropagatedChangeSelectorQuery)
            {
                QueryBuildDataSource parentFullSyncResultDS = cacheBasedNodeLevelValueChangeSelectorQuery.dataSourceTable(tableNum(RetailTmpCDXDataDistributionFilteredRecords));
                TableId parentTableId = tableName2Id(parentFullSyncResultDS.name());
                RetailTmpCDXDataDistributionFilteredRecords fullSyncFilteredRecordsTempTable = dataSyncContext.getFullSyncFilteredRecordsTempTableInstance(parentTableId, isBaselineSync);
                queryRun.setRecord(fullSyncFilteredRecordsTempTable);
            }

            // set recordLevelSecurity to false to prevent downgrading to row by row operation
            targetDeltaSyncFilteredRecordsTempTable.recordLevelSecurity(false);

            this.insert_QueryRecordset(targetDeltaSyncFilteredRecordsTempTable, insertFieldMap, queryRun);
        }
        else
        {
            // use default query to detect node level value changes.
            container packedQuery = dataDistributionQuery.NodeLevelValueChangeSelectorQuery;
            RetailCDXSqlQueryID queryID = dataDistributionQuery.QueryId;

            Query query = new Query(packedQuery);

            if (dataSyncContext.paramIsDateFilterEnabled())
            {
                this.setQueryDateFilterField(query);
            }

            query.clearAllFields();
            QueryBuildDataSource sourceTableDS = RetailCDXCodeGen::getSourceTableDS(query); //query.dataSourceNo(query.dataSourceCount() - 2);
            QueryBuildFieldList fieldList = sourceTableDS.fields();
            fieldList.addField(fieldName2id(sourceTableDS.table(), 'RecId'));

            QueryBuildDataSource nodeConstDS;
            if (this.hasRetailTmpCDXNodeConstTableDataSource(query))
            {
                nodeConstDS = query.dataSourceTable(tableNum(RetailTmpCDXNodeConstTable));
                fieldList = nodeConstDS.fields();
                fieldList.addField(fieldNum(RetailTmpCDXNodeConstTable, NodeID));
                fieldList.addField(fieldNum(RetailTmpCDXNodeConstTable, SkipRecord));
            }

            QueryBuildDataSource queryRunChangeTrackingTempTableDS = query.dataSourceName(#Ref1DSName);
            fieldList = queryRunChangeTrackingTempTableDS.fields();
            fieldList.addField(fieldName2id(queryRunChangeTrackingTempTableDS.table(), 'NodeId'));

            query.skipAutoOrderBy(true);
            query.forceSelectOrder(RetailCdxFeatureControl::isNodeLevelChangeSelectorQueryForceOrderEnabled());

            QueryRun queryRun = new QueryRun(query);

            QueryBuildDataSource targetChannelTempTableDS = queryRun.query().dataSourceName(#TargetChannelDSName);

            if (targetChannelTempTableDS)
            {
                queryRun.setRecord(targetChannelTempTable);
            }

            queryRun.setRecord(changeTrackingTempTable);

            Map fieldMap = new Map(Types::String, Types::Container);
            fieldMap.insert(fieldStr(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, ChildNodeID), [queryRunChangeTrackingTempTableDS.uniqueId(), 'NodeID']);
            fieldMap.insert(fieldStr(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, RefRecId), [sourceTableDS.uniqueId(), 'RecId']);

            if (this.hasRetailTmpCDXNodeConstTableDataSource(query))
            {
                RetailTmpCDXNodeConstTable nodeConstTempTable;
                nodeConstTempTable.NodeId = dataDistributionQuery.QueryId;
                nodeConstTempTable.SkipRecord = dataDistributionQuery.shouldSkipDataSync();
                nodeConstTempTable.insert();
                queryRun.setRecord(nodeConstTempTable);

                fieldMap.insert(fieldStr(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, NodeID), [nodeConstDS.uniqueId(), fieldStr(RetailTmpCDXNodeConstTable, NodeID)]);
                fieldMap.insert(fieldStr(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, SkipRecord), [nodeConstDS.uniqueId(), fieldStr(RetailTmpCDXNodeConstTable, SkipRecord)]);
            }
            else
            {
                fieldMap.insert(fieldStr(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, NodeID), [0, 'int', int2Str(dataDistributionQuery.QueryId)]);
                fieldMap.insert(fieldStr(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, SkipRecord), [0, 'int', int2Str(any2Int(dataDistributionQuery.shouldSkipDataSync()))]);
            }

            // set recordLevelSecurity to false to prevent downgrading to row by row operation
            targetDeltaSyncFilteredRecordsTempTable.recordLevelSecurity(false);

            this.insert_QueryRecordset(targetDeltaSyncFilteredRecordsTempTable, fieldMap, queryRun);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertPropagatedChangeIntoDeltaSyncFilterRecordsTempTable</Name>
				<Source><![CDATA[
    private void insertPropagatedChangeIntoDeltaSyncFilterRecordsTempTable(RetailCdxDataDistributionQuery dataDistributionQuery, boolean isBaselineSync)
    {
        RetailTmpCDXDataDistributionDeltaSyncFilteredRecords targetDeltaSyncFilteredRecordsTempTable = dataSyncContext.getDeltaSyncFilteredRecordsTempTableInstance(dataDistributionQuery.RefTableId, isBaselineSync);

        Query propagatedChangeSelectorQuery = new Query(dataDistributionQuery.propagatedChangeSelectorQuery);

        propagatedChangeSelectorQuery.clearAllFields();

        QueryBuildDataSource nodeConstDS;
        if (this.hasRetailTmpCDXNodeConstTableDataSource(propagatedChangeSelectorQuery))
        {
        // add nodeCostTempTable fields
            nodeConstDS = propagatedChangeSelectorQuery.dataSourceTable(tableNum(RetailTmpCDXNodeConstTable));
            QueryBuildFieldList nodeCostFieldList = nodeConstDS.fields();
            nodeCostFieldList.addField(fieldNum(RetailTmpCDXNodeConstTable, NodeID));
            nodeCostFieldList.addField(fieldNum(RetailTmpCDXNodeConstTable, ChildNodeID));
            nodeCostFieldList.addField(fieldNum(RetailTmpCDXNodeConstTable, SkipRecord));
        }

        QueryBuildDataSource sourceTableDS = RetailCDXCodeGen::getSourceTableDS(propagatedChangeSelectorQuery);
        QueryBuildFieldList sourceTableFieldList = sourceTableDS.fields();
        sourceTableFieldList.addField(fieldName2id(sourceTableDS.table(), 'RecId'));

        propagatedChangeSelectorQuery.skipAutoOrderBy(true);
        propagatedChangeSelectorQuery.forceSelectOrder(RetailCdxFeatureControl::isPropagationQueryForceOrderEnabled());

        QueryBuildDataSource parentDeltaSyncResultDS = propagatedChangeSelectorQuery.dataSourceTable(tableNum(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords));
        TableId parentTableId = tableName2Id(parentDeltaSyncResultDS.name());
        RetailTmpCDXDataDistributionDeltaSyncFilteredRecords deltaSyncFilteredRecordsTempTable = dataSyncContext.getDeltaSyncFilteredRecordsTempTableInstance(parentTableId, isBaselineSync);

        int parentNodeId = str2Int(parentDeltaSyncResultDS.rangeField(fieldNum(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, NodeID)).value());        
        QueryRun queryRun = new QueryRun(propagatedChangeSelectorQuery);
        queryRun.setRecord(deltaSyncFilteredRecordsTempTable);

        Map fieldMap = new Map(Types::String, Types::Container);
        fieldMap.insert(fieldStr(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, RefRecId), [sourceTableDS.uniqueId(), 'RecId']);

        if (this.hasRetailTmpCDXNodeConstTableDataSource(propagatedChangeSelectorQuery))
        {
            RetailTmpCDXNodeConstTable nodeConstTempTable;
            nodeConstTempTable.NodeId = dataDistributionQuery.QueryId;
            nodeConstTempTable.ChildNodeId = -1;
            nodeConstTempTable.SkipRecord = dataDistributionQuery.shouldSkipDataSync();
            nodeConstTempTable.insert();
            queryRun.setRecord(nodeConstTempTable);
            
            fieldMap.insert(fieldStr(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, NodeID), [nodeConstDS.uniqueId(), fieldStr(RetailTmpCDXNodeConstTable, NodeID)]);
            fieldMap.insert(fieldStr(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, ChildNodeID), [nodeConstDS.uniqueId(), fieldStr(RetailTmpCDXNodeConstTable, ChildNodeID)]);
            fieldMap.insert(fieldStr(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, SkipRecord), [nodeConstDS.uniqueId(), fieldStr(RetailTmpCDXNodeConstTable, SkipRecord)]);
        }
        else
        {
            fieldMap.insert(fieldStr(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, NodeID), [0, 'int', int2Str(dataDistributionQuery.QueryId)]);
            fieldMap.insert(fieldStr(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, ChildNodeID), [0, 'int', int2Str(-1)]);
            fieldMap.insert(fieldStr(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, SkipRecord), [0, 'int', int2Str(any2Int(dataDistributionQuery.shouldSkipDataSync()))]);
        }

        // add propagated history data filter when the feature enabled
        if (this.isPropagationOptimizationEnabled(parentNodeId))
        {
            subjobContext.parmIsOptimizedPropagation(true);

            RefRecId dataGroupRefId = dataSyncContext.paramDataGroupRecID();
            RefTableId nodeTableId = dataDistributionQuery.RefTableId;
            
            // initialize the propagated history data when the history not exists            
            if (!RetailCDXPropagatedHistoryTable::exist(dataGroupRefId, nodeTableId))
            {
                this.runInitQueryForTable(dataDistributionQuery, isBaselineSync);
            }
            
            RetailTmpCDXDataDistributionDeltaSyncFilteredRecords interTempTable;
            this.insert_QueryRecordset(interTempTable, fieldMap, queryRun);
            RetailCDXPropagatedHistoryTable historyTable;

            insert_recordset targetDeltaSyncFilteredRecordsTempTable (NodeID, RefRecID, ChildNodeID, SkipRecord)
                select NodeID, RefRecID, ChildNodeID, SkipRecord from interTempTable
                    notexists join historyTable
                        where historyTable.DataGroup == dataGroupRefId
                            && historyTable.RefTableId == nodeTableId
                            && historyTable.RefRecId == interTempTable.RefRecID
                            && historyTable.SyncRowVersion < dataSyncContext.ParamCurrentSyncVer();

            this.insertDeltaPropagatedHistory(dataDistributionQuery, isBaselineSync);
        }
        // if the destination table used in the Query::insert_recordset is the same as the table used in the query object then use a third/intermediate temp table as Query::insert_recordset does not support
        // inserting into the same table which also appears in the query object.
        // One example of it is the LogisticsLocation node has parent node with the same table LogisticsLocation (see AX7 table distribution).
        else if (deltaSyncFilteredRecordsTempTable.getPhysicalTableName() == targetDeltaSyncFilteredRecordsTempTable.getPhysicalTableName())
        {
            RetailTmpCDXDataDistributionDeltaSyncFilteredRecords interTempTable;

            this.insert_QueryRecordset(interTempTable, fieldMap, queryRun);

            insert_recordset targetDeltaSyncFilteredRecordsTempTable (NodeID, RefRecID, ChildNodeID, SkipRecord)
            select NodeID, RefRecID, ChildNodeID, SkipRecord from interTempTable;
        }
        else
        {
            this.insert_QueryRecordset(targetDeltaSyncFilteredRecordsTempTable, fieldMap, queryRun);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeBaselineDataSetExclusion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Exclude baseline data from data set.
    /// </summary>
    /// <param name = "subJobAXSourceTables">The collection of the main table and its related tables for cases where the source table is a temp table.</param>
    internal void executeBaselineDataSetExclusion(container subJobAXSourceTables = conNull())
    {
        for (int i = 1; i <= conLen(subJobAXSourceTables); ++i)
        {
            TableId tid = tableName2Id(conPeek(subJobAXSourceTables, i));
            RetailTmpCDXDataDistributionDeltaSyncFilteredRecords deltaSyncFilteredRecords = dataSyncContext.getDeltaSyncFilteredRecordsTempTableInstance(tid, /*isBaselineSync*/ false);
            RetailTmpCDXDataDistributionDeltaSyncFilteredRecords baselineDeltaSyncFilteredRecords = this.dataSyncContext.getDeltaSyncFilteredRecordsTempTableInstance(tid, /*isBaselineSync*/ true);
            RetailTmpCDXDataDistributionFilteredRecords baselineFullSyncFilteredRecords = dataSyncContext.getFullSyncFilteredRecordsTempTableInstance(tid, /*isBaselineSync*/ true);

            // delta sync which includes the newly mapped store will likely have more dataset as CDX will pick all relevant data for the newly mapped stores.
            // but some of the records which are picked as relevant for the new stores may have already been synced to the datastore. So to reduce the datasize we
            // calculate deltasync(oldStores & newStores) - FullSync(OldStores) + DeltaSync(oldStores) -- this will give us the delta of the old stores and all records required
            // by the new stores excluding the records that are already synced to the existing datastore because the same data is also used by the oldStores
            delete_from deltaSyncFilteredRecords
                exists join baselineFullSyncFilteredRecords
                 where baselineFullSyncFilteredRecords.RefRecID == deltaSyncFilteredRecords.RefRecID
                notexists join baselineDeltaSyncFilteredRecords
                 where baselineDeltaSyncFilteredRecords.RefRecID == deltaSyncFilteredRecords.RefRecID;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleNewlyMappedChannels</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles data synchronization for channels that are mapped to an existing data group since the previous incremental sync.
    /// The channels are considered as newly mapped to a datagroup if
    ///    - they are added to an existing datastore for a given datagroup or
    ///    - new datastore containing the channels is added to an existing datagroup 
    ///    - or an existing datastore is moved from one datagroup to another datagroup.
    /// </summary>
    /// <param name = "subJobAXSourceTables">A collection including the main source table for the data synchronization and all related tables if the source is a temp table.</param>
    internal void handleNewlyMappedChannels(container subJobAXSourceTables)
    {
        RetailCdxChannelSpecificTable channelSpecificTable;
        str tableName;

        // for each table in axSourceTables && in RetailCdxChannelSpecificTable, run baseline incremental and full sync on existing channels
        for (int i = 1; i <= conLen(subJobAXSourceTables); ++i)
        {
            tableName = conPeek(subJobAXSourceTables, i);

            select firstonly RecId from channelSpecificTable
                    where channelSpecificTable.RetailConnChannelSchema == this.dataSyncContext.getChannelSchema()
                       && channelSpecificTable.AXTableName == tableName;

            if (channelSpecificTable)
            {
                // run full sync on existing channels
                this.runQueryForTable(tableName, true, true);

                // run delta sync on existing channels
                this.runQueryForTable(tableName, false, true);
            }
        }

        this.executeBaselineDataSetExclusion(subJobAXSourceTables);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDataDistributionQueries</Name>
				<Source><![CDATA[
    internal container getDataDistributionQueries(TableId tableId)
    {
        return RetailCdxDataDistributionQuery::getCacheBasedDataDistributionQueries(tableId, dataSyncContext.getChannelSchema());
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePropagatedHistoryTable</Name>
				<Source><![CDATA[
    private void initializePropagatedHistoryTable(RetailCdxDataDistributionQuery dataDistributionQuery, boolean isBaselineSync)
    {
        RefRecId dataGroupRecID = dataSyncContext.paramDataGroupRecID();
        TableId tableId = dataDistributionQuery.RefTableId;
        RetailCDXSqlQueryID nodeId = dataDistributionQuery.QueryId;
        RetailTmpCDXDataDistributionFilteredRecords fullSyncFilteredRecordsTempTable = dataSyncContext.getFullSyncFilteredRecordsTempTableInstance(tableId, isBaselineSync);
        
        Query query = new Query();
        QueryBuildDataSource nodeFullSyncResultDS = query.addDataSource(tableNum(RetailTmpCDXDataDistributionFilteredRecords));
        nodeFullSyncResultDS.fields().dynamic(NoYes::No);

        QueryBuildDataSource propagatedHistoryDS = nodeFullSyncResultDS.addDataSource(tableNum(RetailCDXPropagatedHistoryTable));
        propagatedHistoryDS.fields().dynamic(NoYes::No);

        QueryBuildDataSource nodeDeltaSyncResultDS;
        if (!dataSyncContext.paramIsInitSync())
        {
            nodeDeltaSyncResultDS = nodeFullSyncResultDS.addDataSource(tableNum(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords));
            nodeDeltaSyncResultDS.fields().dynamic(NoYes::No);
        }
        
        query.clearAllFields();

        nodeFullSyncResultDS.fields().addField(fieldNum(RetailTmpCDXDataDistributionFilteredRecords, RefRecID));
        nodeFullSyncResultDS.addRange(fieldNum(RetailTmpCDXDataDistributionFilteredRecords, NodeID)).value(int2Str(nodeId));

        propagatedHistoryDS.joinMode(JoinMode::NoExistsJoin);
        propagatedHistoryDS.relations(false);
        propagatedHistoryDS.addLink(fieldNum(RetailTmpCDXDataDistributionFilteredRecords, RefRecID), fieldNum(RetailCDXPropagatedHistoryTable, RefRecID));
        propagatedHistoryDS.addRange(fieldNum(RetailCDXPropagatedHistoryTable, DataGroup)).value(int642Str(dataGroupRecID));
        propagatedHistoryDS.addRange(fieldNum(RetailCDXPropagatedHistoryTable, RefTableId)).value(int2Str(tableId));

        // remove the delta change records when initialize the propagated history data during delta sync
        if (!dataSyncContext.paramIsInitSync())
        {
            nodeDeltaSyncResultDS.joinMode(JoinMode::NoExistsJoin);
            nodeDeltaSyncResultDS.relations(false);
            nodeDeltaSyncResultDS.addLink(fieldNum(RetailTmpCDXDataDistributionFilteredRecords, NodeID), fieldNum(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, NodeID));
            nodeDeltaSyncResultDS.addLink(fieldNum(RetailTmpCDXDataDistributionFilteredRecords, RefRecID), fieldNum(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, RefRecID));
        }
        
        QueryRun queryRun = new QueryRun(query);
        queryRun.setRecord(fullSyncFilteredRecordsTempTable);

        if (!dataSyncContext.paramIsInitSync())
        {
            RetailTmpCDXDataDistributionDeltaSyncFilteredRecords deltaSyncFilteredRecordsTempTable = dataSyncContext.getDeltaSyncFilteredRecordsTempTableInstance(tableId, isBaselineSync);
            queryRun.setRecord(deltaSyncFilteredRecordsTempTable);
        }

        Map fieldMap = new Map(Types::String, Types::Container);
        fieldMap.insert(fieldStr(RetailCDXPropagatedHistoryTable, DataGroup), [0, 'int64', int642str(dataGroupRecID)]);
        fieldMap.insert(fieldStr(RetailCDXPropagatedHistoryTable, RefTableId), [0, 'int', int2Str(tableId)]);
        fieldMap.insert(fieldStr(RetailCDXPropagatedHistoryTable, RefRecId), [nodeFullSyncResultDS.uniqueId(), fieldStr(RetailTmpCDXDataDistributionFilteredRecords, RefRecID)]);
        fieldMap.insert(fieldStr(RetailCDXPropagatedHistoryTable, SyncRowVersion), [0, 'int64', int642str(dataSyncContext.ParamCurrentSyncVer())]);

        RetailCDXPropagatedHistoryTable historyTable;
        historyTable.recordLevelSecurity(false);
        this.insert_QueryRecordset(historyTable, fieldMap, queryRun);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertDeltaPropagatedHistory</Name>
				<Source><![CDATA[
    private void insertDeltaPropagatedHistory(RetailCdxDataDistributionQuery dataDistributionQuery, boolean isBaselineSync)
    {
        TableId tableId = dataDistributionQuery.RefTableId;
        RefRecId dataGroupRecID =  dataSyncContext.paramDataGroupRecID();
        RetailCDXSqlQueryID nodeId = dataDistributionQuery.QueryId;
        
        Query query = new Query();
        QueryBuildDataSource nodeDeltaSyncResultDS = query.addDataSource(tableNum(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords));
        nodeDeltaSyncResultDS.fields().dynamic(NoYes::No);
        QueryBuildDataSource propagatedHistoryDS = nodeDeltaSyncResultDS.addDataSource(tableNum(RetailCDXPropagatedHistoryTable));
        propagatedHistoryDS.fields().dynamic(NoYes::No);

        query.clearAllFields();

        nodeDeltaSyncResultDS.fields().addField(fieldNum(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, RefRecId));
        nodeDeltaSyncResultDS.addRange(fieldNum(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, NodeID)).value(int2Str(nodeId));

        propagatedHistoryDS.joinMode(JoinMode::NoExistsJoin);
        propagatedHistoryDS.relations(false);
        propagatedHistoryDS.addLink(fieldNum(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, RefRecID), fieldNum(RetailCDXPropagatedHistoryTable, RefRecID));
        propagatedHistoryDS.addRange(fieldNum(RetailCDXPropagatedHistoryTable, DataGroup)).value(int642Str(dataGroupRecID));
        propagatedHistoryDS.addRange(fieldNum(RetailCDXPropagatedHistoryTable, RefTableId)).value(int2Str(tableId));
        
        QueryRun queryRun = new QueryRun(query);
        RetailTmpCDXDataDistributionDeltaSyncFilteredRecords deltaSyncFilteredRecordsTempTable = dataSyncContext.getDeltaSyncFilteredRecordsTempTableInstance(tableId, isBaselineSync);
        queryRun.setRecord(deltaSyncFilteredRecordsTempTable);

        Map fieldMap = new Map(Types::String, Types::Container);
        fieldMap.insert(fieldStr(RetailCDXPropagatedHistoryTable, DataGroup), [0, 'int64', int642str(dataGroupRecID)]);
        fieldMap.insert(fieldStr(RetailCDXPropagatedHistoryTable, RefTableId), [0, 'int', int2Str(tableId)]);
        fieldMap.insert(fieldStr(RetailCDXPropagatedHistoryTable, RefRecId), [nodeDeltaSyncResultDS.uniqueId(), fieldStr(RetailTmpCDXDataDistributionDeltaSyncFilteredRecords, RefRecID)]);
        fieldMap.insert(fieldStr(RetailCDXPropagatedHistoryTable, SyncRowVersion), [0, 'int64', int642str(dataSyncContext.ParamCurrentSyncVer())]);

        RetailCDXPropagatedHistoryTable historyTable;
        historyTable.recordLevelSecurity(false);
        this.insert_QueryRecordset(historyTable, fieldMap, queryRun);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPropagationOptimizationEnabled</Name>
				<Source><![CDATA[
    private boolean isPropagationOptimizationEnabled(RetailCDXDataDistributionNodeID _parentNodeId)
    {
        if (!RetailCDXFeatureControl::isOptimizedPropagationEnabled())
        {
            return false;
        }
        
        RetailCdxDataDistributionQuery parentDataDistributionQuery = RetailCdxDataDistributionQuery::find(_parentNodeId, dataSyncContext.getChannelSchema(), this.shouldUseCacheBasedQuery());

        return parentDataDistributionQuery.IsOptimizedPropagation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasRetailTmpCDXNodeConstTableDataSource</Name>
				<Source><![CDATA[
    private boolean hasRetailTmpCDXNodeConstTableDataSource(Query query)
    {
        QueryBuildDataSource nodeConstDS = query.dataSourceTable(tableNum(RetailTmpCDXNodeConstTable));
        return nodeConstDS != null;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>