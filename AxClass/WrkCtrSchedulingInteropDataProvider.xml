<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WrkCtrSchedulingInteropDataProvider</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>WrkCtrSchedulingInteropDataProvider</c> class implements the interface for a job scheduling
/// engine data provider that uses AOS services over WCF.
/// </summary>
class WrkCtrSchedulingInteropDataProvider implements Microsoft.Dynamics.AX.Planning.JobScheduling.IWrkCtrSchedulingInteropDataProvider
{
    WrkCtrSchedulerRuntimes wrkCtrSchedulerRuntimes;

    #define.GetCapacityReservations('GetCapacityReservations')
    #define.GetWorkingTimes('GetWorkingTimes')

    WrkCtrCapResHandler wrkCtrCapResHandler;

    private WrkCtrParmSchedule wrkCtrParmSchedule;
    private readonly boolean scheduleEngineApplicableResourcesPeriodFlightIsEnabled;

    #WrkCtrScheduler

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calendarAsContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a container with the calendar information.
    /// </summary>
    /// <param name="_resourceId">
    /// The resource ID.
    /// </param>
    /// <param name="_validFrom">
    /// The start date for the validity of the calendar.
    /// </param>
    /// <param name="_validTo">
    /// The end date for the validity of the calendar.
    /// </param>
    /// <param name="_calendarId">
    /// The calendar ID.
    /// </param>
    /// <returns>
    /// A container with the calendar data.
    /// </returns>
    protected container calendarAsContainer(WrkCtrId    _resourceId,
                                            Date        _validFrom,
                                            Date        _validTo,
                                            CalendarId  _calendarId)
    {
        return [_resourceId, _validFrom, _validTo, _calendarId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>capabilityAsContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a container with the capability information.
    /// </summary>
    /// <param name="_resourceId">
    /// The resource ID.
    /// </param>
    /// <param name="_validFrom">
    /// The start date for the capability being available.
    /// </param>
    /// <param name="_validTo">
    /// The end date for the capability being available.
    /// </param>
    /// <param name="_propertyId">
    /// The capability ID.
    /// </param>
    /// <param name="_propertyGrade">
    /// The capability grade.
    /// </param>
    /// <param name="_priority">
    /// The priority.
    /// </param>
    /// <returns>
    /// A container with the capability data.
    /// </returns>
    protected container capabilityAsContainer(WrkCtrId      _resourceId,
                                              UtcDateTime   _validFrom,
                                              UtcDateTime   _validTo,
                                              str           _propertyId,
                                              real          _propertyGrade,
                                              int           _priority)
    {
        return [_resourceId, _validFrom, _validTo, _propertyId, _propertyGrade, _priority];
    }

]]></Source>
			</Method>
			<Method>
				<Name>computeResourceCapabilities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Computes the resource capabilities for one resource.
    /// </summary>
    /// <param name="_wrkCtrTable">
    /// A <c>WrkCtrTable</c> record with the resource data.
    /// </param>
    /// <param name="_wrkCtrResourceGroup">
    /// A <c>WrkCtrResourceGroup</c> record with the group data.
    /// </param>
    /// <returns>
    /// A container with the capabilities in the format of the <c>resourceId</c>, <c>StartDate</c>,
    /// <c>EndDate</c>, <c>PropertyId</c>, <c>PropertyGrade</c>, and <c>Priority</c> data types.
    /// </returns>
    protected container computeResourceCapabilities(WrkCtrTable                 _wrkCtrTable,
                                                    WrkCtrResourceGroup         _wrkCtrResourceGroup = null)
    {
        container                       result;
        HcmWorker                       hcmWorker;
        HcmWorkerTitle                  hcmWorkerTitle;
        HcmPersonCourse                 hcmPersonCourse;
        HcmPersonCertificate            hcmPersonCertificate;
        HcmPersonSkill                  hcmPersonSkill;
        HcmSkill                        hcmSkill;
        HcmRatingLevel                  hcmRatingLevel;
        HcmTitle                        hcmTitle;
        HcmCertificateType              hcmCertificateType;
        HRMCourseTable                  hrmCourseTable;
        utcDateTime minDateUtc          = utcDateTimeNull();
        utcDateTime maxDateUtc          = this.getValidToDateUtc(dateMax());
        WrkCtrResourceGroup             wrkCtrResourceGroup = _wrkCtrResourceGroup;

        result += this.capabilityAsContainer(_wrkCtrTable.WrkCtrId,
                                             minDateUtc,
                                             maxDateUtc,
                                             WrkCtrSchedulingProperty::wrkCtrTypeSchedulingProperty(_wrkCtrTable.WrkCtrType),
                                             0.0,
                                             0);

        result += this.capabilityAsContainer(_wrkCtrTable.WrkCtrId,
                                             minDateUtc,
                                             maxDateUtc,
                                             WrkCtrSchedulingProperty::getWrkCtrSchedulingProperty(_wrkCtrTable.WrkCtrId),
                                             0.0,
                                             0);

        if (!_wrkCtrTable.IsIndividualResource)
        {
            if (!wrkCtrResourceGroup)
            {
                wrkCtrResourceGroup = WrkCtrResourceGroup::findWrkCtrId(_wrkCtrTable.WrkCtrId);
            }

            result += this.computeResourceGroupCapabilities(_wrkCtrTable.WrkCtrId,
                                                            dateNull(),
                                                            dateMax(),
                                                            wrkCtrResourceGroup);
        }

        // HRM properties
        if (_wrkCtrTable.Worker != 0)
        {
            hcmWorker = HcmWorker::find(_wrkCtrTable.Worker);
            if (HcmWorkerLookup::newCustomOptions(true, true, true, false, false, false, true, true, false).validateWorker(hcmWorker.RecId))
            {
                // add courses with infinite date range
                while select HrmCourseId    from hrmCourseTable
                    join     RecId          from hcmPersonCourse
                    where    hrmCourseTable.HrmCourseId == hcmPersonCourse.CourseId
                    &&       hrmCourseTable.DataAreaId  == hcmPersonCourse.CourseDataAreaId
                    &&       hcmPersonCourse.Person     == hcmWorker.Person
                {
                    result += this.capabilityAsContainer(_wrkCtrTable.WrkCtrId,
                                                         minDateUtc,
                                                         maxDateUtc,
                                                         WrkCtrSchedulingProperty::hrmCourseSchedulingProperty(hrmCourseTable.HrmCourseId),
                                                         0.0,
                                                         0);
                }

                // Add the person title property with infinite date range
                while select validtimestate(minDateUtc, maxDateUtc)  ValidFrom, ValidTo from hcmWorkerTitle
                    join     TitleId from hcmTitle
                    where    hcmWorkerTitle.Worker == hcmWorker.RecId
                    &&       hcmWorkerTitle.Title  == hcmTitle.RecId
                {
                    result += this.capabilityAsContainer(_wrkCtrTable.WrkCtrId,
                                                         hcmWorkerTitle.ValidFrom,
                                                         hcmWorkerTitle.ValidTo,
                                                         WrkCtrSchedulingProperty::hcmTitleSchedulingProperty(hcmTitle.TitleId),
                                                         0.0,
                                                         0);
                }

                // load the certificate properties if any
                while select CertificateTypeId          from hcmCertificateType
                    join     IssueDate, ExpirationDate  from hcmPersonCertificate
                    where    hcmCertificateType.RecId       == hcmPersonCertificate.CertificateType
                    &&       hcmPersonCertificate.Person    == hcmWorker.Person
                {
                    result += this.capabilityAsContainer(_wrkCtrTable.WrkCtrId,
                                                         DateTimeUtil::newDateTime(hcmPersonCertificate.IssueDate, 0),
                                                         (hcmPersonCertificate.ExpirationDate ? this.getValidToDateUtc(hcmPersonCertificate.ExpirationDate) : maxDateUtc),
                                                         WrkCtrSchedulingProperty::hrmCertificateTypeSchedulingProperty(hcmCertificateType.CertificateTypeId),
                                                         0.0,
                                                         0);
                }

                // load the skill properties if any
                while select SkillId                from hcmSkill
                    join     RatingLevelId, Factor  from hcmRatingLevel
                    join     RatingLevelDate        from hcmPersonSkill
                    where    hcmPersonSkill.Person      == hcmWorker.Person
                    &&       hcmPersonSkill.Skill       == hcmSkill.RecId
                    &&       hcmPersonSkill.RatingLevel == hcmRatingLevel.RecId
                    &&       hcmPersonSkill.RatingLevelType == HRMSkillLevelType::Actual
                {
                    result += this.capabilityAsContainer(_wrkCtrTable.WrkCtrId,
                                                         DateTimeUtil::newDateTime(hcmPersonSkill.RatingLevelDate, 0),
                                                         maxDateUtc,
                                                         WrkCtrSchedulingProperty::hrmSkillSchedulingProperty(hcmSkill.SkillId),
                                                         any2real(hcmRatingLevel.Factor),
                                                         0);
                }
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>computeResourceGroupCapabilities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Computes the resource group bound capabilities for a given resource.
    /// </summary>
    /// <param name="_resourceId">
    /// The resource ID for which to compute the capabilities.
    /// </param>
    /// <param name="_validFrom">
    /// Start validity date for the capabilities.
    /// </param>
    /// <param name="_validTo">
    /// End validity date for the capabilities.
    /// </param>
    /// <param name="_wrkCtrResourceGroup">
    /// A <c>WrkCtrResourceGroup</c> record with the group information.
    /// </param>
    /// <returns>
    /// A container with the capabilities.
    /// </returns>
    protected container computeResourceGroupCapabilities(WrkCtrId               _resourceId,
                                                         Date                   _validFrom,
                                                         Date                   _validTo,
                                                         WrkCtrResourceGroup    _wrkCtrResourceGroup)
    {
        InventLocationIdInput   inputWarehouse;
        container               result;
        utcDateTime             validFromUtc = DateTimeUtil::newDateTime(_validFrom, 0);
        utcDateTime             validToUtc = this.getValidToDateUtc(_validTo);

        result += this.capabilityAsContainer(_resourceId,
                                             validFromUtc,
                                             validToUtc,
                                             WrkCtrSchedulingProperty::resourceGroupSchedulingProperty(_wrkCtrResourceGroup.RecId),
                                             0.0,
                                             0);
        result += this.capabilityAsContainer(_resourceId,
                                             validFromUtc,
                                             validToUtc,
                                             WrkCtrSchedulingProperty::inventSiteSchedulingProperty(_wrkCtrResourceGroup.SiteId),
                                             0.0,
                                             0);
        if (_wrkCtrResourceGroup.ProdUnitId)
        {
            result += this.capabilityAsContainer(_resourceId,
                                                 validFromUtc,
                                                 validToUtc,
                                                 WrkCtrSchedulingProperty::prodUnitSchedulingProperty(_wrkCtrResourceGroup.ProdUnitId),
                                                 0.0,
                                                 0);
        }
        inputWarehouse = _wrkCtrResourceGroup.inputInventLocationIdFallback();
        if (inputWarehouse)
        {
            result += this.capabilityAsContainer(_resourceId,
                                                 validFromUtc,
                                                 validToUtc,
                                                 WrkCtrSchedulingProperty::inputWarehouseSchedulingProperty(inputWarehouse),
                                                 0.0,
                                                 0);
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getApplicableResources</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets a list of the resources that satisfy the given requirements.
    /// </summary>
    /// <param name="requirements">
    ///    A list of the requirements.
    /// </param>
    /// <returns>
    ///    A list of the applicable resources.
    /// </returns>
    public container getApplicableResources(container requirements)
    {
        str                         reqStr;
        int                         i;
        str                         resourceGroupId;
        WrkCtrTable                 wrkCtrTable;
        WrkCtrResourceGroupResource wrkCtrResourceGroupResource;
        RecId                       resourceGroupRecId;
        container                   result;
        date                        fromDate = dateNull();
        date                        toDate = dateMax();
        
        for (i = 1; i <= conlen(requirements); ++i)
        {
            reqStr = conpeek(requirements, i);
            if (strStartsWith(reqStr, WrkCtrSchedulingProperty::resourceGroupPropertyPrefix()))
            {
                resourceGroupId = substr(reqStr, strlen(WrkCtrSchedulingProperty::resourceGroupPropertyPrefix())+1, strlen(reqStr));
                resourceGroupRecId = str2int64(resourceGroupId);
            }            
        }

        if (scheduleEngineApplicableResourcesPeriodFlightIsEnabled && this.parmWrkCtrParmSchedule()
            && this.parmWrkCtrParmSchedule().schedDate()
            && this.parmWrkCtrParmSchedule().schedDirection() != SchedDirection::Backward
            && this.parmWrkCtrParmSchedule().synchronizeReference() == NoYes::No
            && this.parmWrkCtrParmSchedule().schedReference() == NoYes::No)
        {
            fromDate = min(this.parmWrkCtrParmSchedule().schedDate(), this.parmWrkCtrParmSchedule().minimumSchedDate());            
        }

        while select validtimestate(fromDate, toDate) WrkCtrId, CapLimited, Exclusive, OperationSchedPct, EffectivityPct from wrkCtrTable
            exists join ResourceGroup from wrkCtrResourceGroupResource
            where   (wrkCtrTable.WrkCtrId == wrkCtrResourceGroupResource.WrkCtrId) &&
                    (wrkCtrResourceGroupResource.ResourceGroup == resourceGroupRecId)
        {
            result += [wrkCtrTable.WrkCtrId, wrkCtrTable.CapLimited, wrkCtrTable.Exclusive, 1.0, wrkCtrTable.EffectivityPct / 100];
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCapacityReservations</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the capacity reservations for a certain date or time interval for a specified resource.
    /// </summary>
    /// <param name="_engineResourceId">
    ///    A string that specifies the resource for which to retrieve the capacity reservations.
    /// </param>
    /// <param name="_workingTimesType">
    ///    The type of resource for which to get the working times.
    /// </param>
    /// <param name="_loadJobSchedulingCapacity">
    ///    true if the job scheduled capacity is to be loaded; otherwise, false.
    /// </param>
    /// <param name="_loadOperationSchedulingCapacity">
    ///    true if the operation scheduled capacity is to be loaded; otherwise, false.
    /// </param>
    /// <param name="_startDate">
    ///    The start date of the interval.
    /// </param>
    /// <param name="_startTime">
    ///    The start time of the interval.
    /// </param>
    /// <param name="_endDate">
    ///    The end date of the interval.
    /// </param>
    /// <param name="_endTime">
    ///    The end time of the interval.
    /// </param>
    /// <returns>
    ///    A container with the retrieved capacity reservations.
    /// </returns>
    /// <remarks>
    ///    The <paramref name="_engineResourceID" /> parameter is a string that can contain either a
    ///    <c>WrkCtrId</c> or a <c>CalendarId</c> valueEach capacity reservation is stored as a container with
    ///    the format <c>[startTime, endTime, capacitySeconds, resourceLoadPct]</c>.
    /// </remarks>
    public container getCapacityReservations(str        _engineResourceId,
                                             int        _workingTimesType,
                                             boolean    _loadJobSchedulingCapacity,
                                             boolean    _loadOperationSchedulingCapacity,
                                             date       _startDate,
                                             timeOfDay  _startTime,
                                             date       _endDate,
                                             timeOfDay  _endTime)
    {
        container       result;
        WrkCtrSchedulerWorkingTimesType workingTimesType = _workingTimesType;

        if (!wrkCtrCapResHandler)
        {
            throw error("@SYS329762");
        }

        wrkCtrSchedulerRuntimes.startMeasurement(#GetCapacityReservations);

        switch (workingTimesType)
        {
            case WrkCtrSchedulerWorkingTimesType::Resource:
            case WrkCtrSchedulerWorkingTimesType::ResourceGroup:
                result = wrkCtrCapResHandler.loadCapacityReservations(_engineResourceId,
                                                                      _startDate,
                                                                      _startTime,
                                                                      _endDate,
                                                                      _endTime,
                                                                      _loadJobSchedulingCapacity,
                                                                      _loadOperationSchedulingCapacity,
                                                                      workingTimesType == WrkCtrSchedulerWorkingTimesType::ResourceGroup);
                break;

            case WrkCtrSchedulerWorkingTimesType::CalendarDetails:
            case WrkCtrSchedulerWorkingTimesType::Calendar:
                // no capacity reservations to fetch in case we got a calendar Id
                break;

            default:
                throw error(strfmt("@SYS54195", funcname()));
        }

        wrkCtrSchedulerRuntimes.endMeasurement(#GetCapacityReservations);

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGroupMembersCalendars</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the resource calendars for all resources in a group.
    /// </summary>
    /// <param name="_resourceGroupId">
    ///    The ID of the resource group.
    /// </param>
    /// <returns>
    ///    A container with the calendars for all resources in the group.
    /// </returns>
    public container getGroupMembersCalendars(WrkCtrId _resourceGroupId)
    {
        container result;

        WrkCtrResourceGroup wrkCtrResourceGroup = WrkCtrResourceGroup::findWrkCtrId(_resourceGroupId);

        WrkCtrResourceGroupResource wrkCtrResourceGroupResource;
        WrkCtrResourceCalendar wrkCtrResourceCalendar;

        date fromDate = dateNull();
        date toDate = dateMax();

        while select forceselectorder validTimeState(fromDate, toDate) WrkCtrId from wrkCtrResourceGroupResource
            where wrkCtrResourceGroupResource.ResourceGroup == wrkCtrResourceGroup.RecId
            join ValidFrom, ValidTo, CalendarId from wrkCtrResourceCalendar
                where wrkCtrResourceCalendar.WrkCtrId == wrkCtrResourceGroupResource.WrkCtrId
        {
            result += this.calendarAsContainer(wrkCtrResourceGroupResource.WrkCtrId,
                                            wrkCtrResourceCalendar.ValidFrom,
                                            wrkCtrResourceCalendar.ValidTo,
                                            wrkCtrResourceCalendar.CalendarId);
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGroupMembersCapabilities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the resource capabilities for all the resources in a group.
    /// </summary>
    /// <param name="_resourceGroupId">
    /// The ID of the resource group.
    /// </param>
    /// <returns>
    /// A map with the capabilities for all resources in the group.
    /// </returns>
    public container getGroupMembersCapabilities(WrkCtrId _resourceGroupId)
    {
        WrkCtrCapabilityResource        wrkCtrCapabilityResource;
        WrkCtrTable                     wrkCtrTable;
        container                       result;
        date fromDate                   = dateNull();
        date toDate                     = dateMax();
        WrkCtrResourceGroupResource     wrkCtrResourceGroupResource;
        WrkCtrResourceGroup             wrkCtrResourceGroup;
        WrkCtrResourceGroupResource     wrkCtrResourceGroupResourceFilter;
        WrkCtrResourceGroup             wrkCtrResourceGroupFilter;
        WrkCtrId                        lastResourceId;

        // select all groups that the resource belongs to
        while select validTimeState(fromDate, toDate) wrkCtrResourceGroup
            order by wrkCtrResourceGroupResource.WrkCtrId
        join ValidFrom, ValidTo, WrkCtrId from wrkCtrResourceGroupResource
            where   wrkCtrResourceGroupResource.ResourceGroup == wrkCtrResourceGroup.RecId
        join wrkCtrTable
            where   wrkCtrTable.WrkCtrId == wrkCtrResourceGroupResource.WrkCtrId
        exists join wrkCtrResourceGroupResourceFilter
            where wrkCtrResourceGroupResourceFilter.WrkCtrId == wrkCtrTable.WrkCtrId
        exists join wrkCtrResourceGroupFilter
            where   wrkCtrResourceGroupFilter.RecId     == wrkCtrResourceGroupResourceFilter.ResourceGroup
            &&      wrkCtrResourceGroupFilter.WrkCtrId  == _resourceGroupId
        {
            if (wrkCtrTable.WrkCtrId != lastResourceId)
            {
                lastResourceId = wrkCtrTable.WrkCtrId;

                result += this.computeResourceCapabilities(wrkCtrTable,
                                                           wrkCtrResourceGroup);
            }

            result += this.computeResourceGroupCapabilities(wrkCtrResourceGroupResource.WrkCtrId,
                                                            wrkCtrResourceGroupResource.ValidFrom,
                                                            wrkCtrResourceGroupResource.ValidTo,
                                                            wrkCtrResourceGroup);
        }

        // compute capability properties
        // [fromDate, toDate, capabilityId, grade, priority]

        while select validTimeState(fromDate, toDate) ValidFrom, ValidTo, Capability, Level, Priority, WrkCtrId from wrkCtrCapabilityResource
        exists join wrkCtrResourceGroupResource
            where   wrkCtrResourceGroupResource.WrkCtrId == wrkCtrCapabilityResource.WrkCtrId
            &&      wrkCtrResourceGroupResource.DataAreaId == wrkCtrCapabilityResource.ResourceDataAreaId
        exists join wrkCtrResourceGroup
            where   wrkCtrResourceGroup.RecId == wrkCtrResourceGroupResource.ResourceGroup
            &&      wrkCtrResourceGroup.WrkCtrId == _resourceGroupId
        {
            result += this.capabilityAsContainer(wrkCtrCapabilityResource.WrkCtrId,
                                                 DateTimeUtil::newDateTime(wrkCtrCapabilityResource.ValidFrom, 0),
                                                 this.getValidToDateUtc(wrkCtrCapabilityResource.ValidTo),
                                                 WrkCtrSchedulingProperty::capabilitySchedulingProperty(wrkCtrCapabilityResource.Capability),
                                                 wrkCtrCapabilityResource.Level,
                                                 wrkCtrCapabilityResource.Priority);
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResourceCalendars</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets a list of resource calendars.
    /// </summary>
    /// <param name="_resourceId">
    ///    The ID of the resource.
    /// </param>
    /// <returns>
    ///    A list of resource calendars.
    /// </returns>
    public container getResourceCalendars(WrkCtrId _resourceId)
    {
        container                       result;
        date fromDate                   = dateNull();
        date toDate                     = dateMax();
        WrkCtrTable                     wrkCtr;
        WrkCtrResourceCalendar          wrkCtrResourceCalendar;

        wrkCtr = WrkCtrTable::find(_resourceId);
        if (!wrkCtr)
        {
            return result;
        }

        while select validTimeState(fromDate, toDate) ValidFrom, ValidTo, CalendarId from wrkCtrResourceCalendar
                where wrkCtrResourceCalendar.WrkCtrId == _resourceId
        {
            result += this.calendarAsContainer(_resourceId,
                                               wrkCtrResourceCalendar.ValidFrom,
                                               wrkCtrResourceCalendar.ValidTo,
                                               wrkCtrResourceCalendar.CalendarId);
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResourceCapabilities</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the list of the resource capabilities.
    /// </summary>
    /// <param name="_resourceId">
    ///    The ID of the resource.
    /// </param>
    /// <returns>
    ///    The list of the resource capabilities.
    /// </returns>
    public container getResourceCapabilities(WrkCtrId _resourceId)
    {
        WrkCtrCapabilityResource        wrkCtrCapabilityResource;
        WrkCtrTable                     wrkCtrTable;
        container                       result;
        date fromDate                   = dateNull();
        date toDate                     = dateMax();
        Map                             hrmProperties = new Map(Types::String, Types::Real);
        WrkCtrResourceGroupResource     wrkCtrResourceGroupResource;
        WrkCtrResourceGroup             wrkCtrResourceGroup;

        wrkCtrTable = WrkCtrTable::find(_resourceId);
        if (!wrkCtrTable)
        {
            return result;
        }

        result += this.computeResourceCapabilities(wrkCtrTable);

        while select validTimeState(fromDate, toDate) ValidFrom, ValidTo, WrkCtrId from wrkCtrResourceGroupResource
            where wrkCtrResourceGroupResource.WrkCtrId == _resourceId
        join wrkCtrResourceGroup
            where wrkCtrResourceGroup.RecId == wrkCtrResourceGroupResource.ResourceGroup
        {
            result += this.computeResourceGroupCapabilities(wrkCtrResourceGroupResource.WrkCtrId,
                                                            wrkCtrResourceGroupResource.ValidFrom,
                                                            wrkCtrResourceGroupResource.ValidTo,
                                                            wrkCtrResourceGroup);
        }

        // compute capability properties
        // [fromDate, toDate, capabilityId, grade, priority]

        while select validTimeState(fromDate, toDate) ValidFrom, ValidTo, Capability, Level, Priority from wrkCtrCapabilityResource
            where   wrkCtrCapabilityResource.WrkCtrId   == _resourceId &&
                    wrkCtrCapabilityResource.ResourceDataAreaId == wrkCtrTable.DataAreaId
        {
            result += this.capabilityAsContainer(_resourceId,
                                                 DateTimeUtil::newDateTime(wrkCtrCapabilityResource.ValidFrom, 0),
                                                 this.getValidToDateUtc(wrkCtrCapabilityResource.ValidTo),
                                                 WrkCtrSchedulingProperty::capabilitySchedulingProperty(wrkCtrCapabilityResource.Capability),
                                                 wrkCtrCapabilityResource.Level,
                                                 wrkCtrCapabilityResource.Priority);
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkingTimes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a section of working times that are enclosed in a time interval.
    /// </summary>
    /// <param name="_calendarId">
    /// A string that specifies the calendar for which to retrieve the working times.
    /// </param>
    /// <param name="_workingTimesType">
    /// The type of resource to fetch working times for.
    /// </param>
    /// <param name="_startDate">
    /// Start date for the interval.
    /// </param>
    /// <param name="_startTime">
    /// Start time for the interval.
    /// </param>
    /// <param name="_endDate">
    /// End date for the interval.
    /// </param>
    /// <param name="_endTime">
    /// End time for the interval.
    /// </param>
    /// <param name="_workingTimesCount">
    /// The number of working time records to retrieve.
    /// </param>
    /// <param name="_forward">
    /// A Boolean value that indicates which direction to use to look for working times. true to look
    /// forward, starting at the start date and start time. false to look backward, starting at the end
    /// date and end time.
    /// </param>
    /// <returns>
    /// A container that stores the working time records. Each element in the container is another
    /// container that has the start date time, end date time, effectivity, and the property ID, in that
    /// order.
    /// </returns>
    /// <remarks>
    /// Each element in the container is another container that has the <c>startDateTime</c>,
    /// <c>endDateTime</c>, <c>effectivity</c>, and <c>propertyId</c> elements.
    /// </remarks>
    public container getWorkingTimes(str        _calendarId,
                                     int        _workingTimesType,
                                     date       _startDate,
                                     timeOfDay  _startTime,
                                     date       _endDate,
                                     timeOfDay  _endTime,
                                     int        _workingTimesCount,
                                     boolean    _forward)
    {
        container           result;
        WrkCtrWorkingTimes  wrkCtrWorkingTimes;
        WrkCtrSchedulerWorkingTimesType workingTimesType = _workingTimesType;
        str calendarId = this.removeCalendarPrefix(_calendarId);

        wrkCtrSchedulerRuntimes.startMeasurement(#GetWorkingTimes);

        switch (workingTimesType)
        {
            case WrkCtrSchedulerWorkingTimesType::CalendarDetails:
                wrkCtrWorkingTimes = WrkCtrWorkingTimesCalendarDetail::newCalendarId(calendarId,
                                                                               _startDate,
                                                                               _startTime,
                                                                               _endDate,
                                                                               _endTime,
                                                                               _workingTimesCount,
                                                                               _forward);
                break;

            case WrkCtrSchedulerWorkingTimesType::Calendar:
                wrkCtrWorkingTimes = WrkCtrWorkingTimesCalendar::newCalendarId(calendarId,
                                                                               _startDate,
                                                                               _startTime,
                                                                               _endDate,
                                                                               _endTime,
                                                                               _workingTimesCount,
                                                                               _forward);
                break;

            default:
                throw error(strfmt("@SYS54195",funcname()));
        }

        result = wrkCtrWorkingTimes.getWorkingTimes();

        wrkCtrSchedulerRuntimes.endMeasurement(#GetWorkingTimes);

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeCalendarPrefix</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes the calendar prefix from id that is added while inserting a lead time job for routeless orders.
    /// </summary>
    /// <param name = "_calendarId">
    /// A string that specifies the calendar for which to retrieve the working times.
    /// </param>
    /// <returns>The calendar id without prefix</returns>
    private str removeCalendarPrefix(str _calendarId)
    {
        return subStr(_calendarId, 1, strlen(#CalendarResourceIdPrefix)) == #CalendarResourceIdPrefix ?
            subStr(_calendarId, strlen(#CalendarResourceIdPrefix) + 1, strLen(_calendarId)) :
            _calendarId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasNewCapacityReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether a capacity reservation exists for a list of given intervals.
    /// </summary>
    /// <param name="_conflictCheckSessionId">
    /// The ID to check for capacity reservation conflicts.
    /// </param>
    /// <returns>
    /// true if a capacity reservation exists in the intervals; otherwise, false.
    /// </returns>
    public boolean hasNewCapacityReservation(guid _conflictCheckSessionId)
    {
        return wrkCtrCapResHandler.hasNewCapacityReservation(_conflictCheckSessionId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructWrkCtrCapResConflictCheckIntervals</Name>
				<Source><![CDATA[
    public Microsoft.Dynamics.AX.Planning.JobScheduling.IWrkCtrCapResConflictCheckIntervals constructWrkCtrCapResConflictCheckIntervals()
    {
        return WrkCtrCapResConflictCheckIntervals::construct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dispose</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Releases resources held by this instance.
    /// </summary>
    public void dispose()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        scheduleEngineApplicableResourcesPeriodFlightIsEnabled = ScheduleEngineApplicableResourcesPeriodFlight::instance().isEnabled();
        wrkCtrSchedulerRuntimes = WrkCtrSchedulerRuntimes::construct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWrkCtrCapResHandler</Name>
				<Source><![CDATA[
    protected WrkCtrCapResHandler parmWrkCtrCapResHandler(WrkCtrCapResHandler _wrkCtrCapResHandler = wrkCtrCapResHandler)
    {
        wrkCtrCapResHandler = _wrkCtrCapResHandler;
        return wrkCtrCapResHandler;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWrkCtrParmSchedule</Name>
				<Source><![CDATA[
    public WrkCtrParmSchedule parmWrkCtrParmSchedule(WrkCtrParmSchedule _wrkCtrParmSchedule = wrkCtrParmSchedule)
    {
        wrkCtrParmSchedule = _wrkCtrParmSchedule;
        return wrkCtrParmSchedule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static WrkCtrSchedulingInteropDataProvider construct()
    {
        return new WrkCtrSchedulingInteropDataProvider();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newOrderType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>WrkCtrSchedulingInteropDataProvider</c> class based on a
    ///    specified order type.
    /// </summary>
    /// <param name="_refType">
    ///    An <c>WrkCtrCapRefType</c> enumeration value that indicates what scheduling engine type to use in
    ///    the newly created data provider.
    /// </param>
    /// <returns>
    ///    A new instance of the <c>WrkCtrSchedulingInteropDataProvider</c> class.
    /// </returns>
    public static WrkCtrSchedulingInteropDataProvider newOrderType(WrkCtrCapRefType _refType)
    {
        WrkCtrSchedulingInteropDataProvider dataProvider = WrkCtrSchedulingInteropDataProvider::construct();

        dataProvider.parmWrkCtrCapResHandler(WrkCtrCapResHandler::construct());

        return dataProvider;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newWrkCtrCapResHandler</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>WrkCtrSchedulingInteropDataProvider</c> class.
    /// </summary>
    /// <param name="_wrkCtrCapResHandler">
    ///    An instance of the <c>WrkCtrCapResHandler</c> class that is used by the data provider to retrieve capacity reservation information.
    /// </param>
    /// <returns>
    ///    A new instance of the <c>WrkCtrSchedulingInteropDataProvider</c> class.
    /// </returns>
    public static WrkCtrSchedulingInteropDataProvider newWrkCtrCapResHandler(WrkCtrCapResHandler _wrkCtrCapResHandler)
    {
        WrkCtrSchedulingInteropDataProvider dataProvider = WrkCtrSchedulingInteropDataProvider::construct();

        dataProvider.parmWrkCtrCapResHandler(_wrkCtrCapResHandler);

        return dataProvider;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getValidToDateUtc</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates the upper bound for date comparison.
    /// </summary>
    /// <param name = "_date">The date value for which to calculate the upper bound.</param>
    /// <returns></returns>
    private utcdatetime getValidToDateUtc(date _date)
    {
        #TimeConstants

        boolean     isMaxDate   = _date == maxDate();
        date        resultDate  = isMaxDate ? _date : _date + 1;
        TimeOfDay   resultTime  = isMaxDate ? #secondsPerDay - 1 : 0;

        return DateTimeUtil::newDateTime(resultDate, resultTime);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>