<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjInvoiceProposalRuleCreateLines</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// This class is responsible for creating invoice proposal lines based billing rules.
/// </summary>
class ProjInvoiceProposalRuleCreateLines extends ProjInvoiceProposalCreateLinesBase
{
    // <GIN>
    #ISOcountryRegionCodes
    // <GIN>
    #Define.star('*')


    Amount                                  deductionAmount;
    boolean                                 cdsLockingOptionCreateInvoiceProposals;
    private boolean filterbyProjIdEnabled;
    private static ProjOpsFinancialsLogger logger = ProjOpsFinancialsLogger::createLogger(classStr(ProjInvoiceProposalRuleCreateLines));

    PSATmpProjProposalSummary               projProposalSummary;

    ProjType                                projType;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calFeeLineInvoiceAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculated fee amount.
    /// </summary>
    /// <param name="_sContractLineNum">
    /// Identifier of the billing rule.
    /// </param>
    /// <returns>
    /// Fee amount.
    /// </returns>
    protected Amount calFeeLineInvoiceAmount(PSAContractLineNum _sContractLineNum)
    {
        Amount                              invoiceAmounts;

        PSAContractLineItemsSetup           psaContractLineItemsSetup;
        PSAContractLineNum                  psaContractLineNumRef;
        PSAContractLineItems                psaContractLineItemsRef;
        PSATmpProjProposalSummary           projProposalSummaryLocal;
        PSAContractLineItems                psaContractLineItems;

        psaContractLineItems = PSAContractLineItems::find(_sContractLineNum);
        projProposalSummaryLocal.setTmpData(projProposalSummary);
        while select ContractLineNumReferred from psaContractLineItemsSetup
            where psaContractLineItemsSetup.ContractLineNum == _sContractLineNum
               && psaContractLineItemsSetup.ContractLineNumReferred != ''
        {
            psaContractLineNumRef = psaContractLineItemsSetup.ContractLineNumReferred;
            psaContractLineItemsRef = PSAContractLineItems::find(psaContractLineNumRef);

            if (psaContractLineItemsRef.LineType == PSAContractLineType::Fee)
            {
                invoiceAmounts += this.calFeeLineInvoiceAmount(psaContractLineNumRef) * psaContractLineItems.FeePercentage/100;
            }
            else
            {
                select firstonly projProposalSummaryLocal
                    where projProposalSummaryLocal.ContractLineNum == psaContractLineNumRef;
                if (projProposalSummaryLocal.Selected)
                {
                    invoiceAmounts += projProposalSummaryLocal.InvoiceAmount * psaContractLineItems.FeePercentage/100;
                }

            }
        }

        return invoiceAmounts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProposalForOnAccTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates on account transactions and invoice proposal based on Invoice proposal summary
    /// </summary>
    /// <param name="_psaContractLineItems">
    /// Billing Rule for which the on account transaction is created
    /// </param>
    /// <returns>
    /// Returns OnAccount Transaction that was created
    /// </returns>
    protected ProjOnAccTrans createProposalForOnAccTrans(PSAContractLineItems _psaContractLineItems)
    {
        ProjOnAccTrans                      projOnAccTrans;
        ProjOnAccTransSale                  projOnAccTransSale;
        ProjFundingSource                   projFundingSource;
        Amount                              remainingAmount;
        ProjOnAccTrans                      remainingOnAccTrans;
        ProjOnAccTrans                      projOnAccTransToBeDeleted;
        ProjOnAccTransSale                  projOnAccTransSaleToBeDeleted;
        boolean                             hasCreditNoteTrans = false;

        if (projProposalSummary.InvoiceAmount == 0.0)
        {
            return null;
        }

        // Check if on account transaction is marked for credit note
        while select projOnAccTrans
            where projOnAccTrans.psaContractLineNum == projProposalSummary.ContractLineNum
            exists join projOnAccTransSale
            where projOnAccTransSale.TransId == projOnAccTrans.TransId &&
                (projOnAccTransSale.TransStatus == ProjTransStatus::Posted ||
                projOnAccTransSale.TransStatus == ProjTransStatus::MarkedCreditnote)
            exists join projFundingSource
            where projFundingSource.RecId == projOnAccTransSale.FundingSource &&
                (projFundingSource.FundingType == ProjFundingType::Customer
                || projFundingSource.FundingType == ProjFundingType::Grant)
        {
            hasCreditNoteTrans = true;
            this.doOnAccount(projOnAccTrans, projProposalSummary.ContractLineNum);
        }

        if (hasCreditNoteTrans == false)
        {
            ProjOnAccTransSale		projOnAccTransSaleInvoiced;
            ProjOnAccTransSale		projOnAccTransSaleRegistered;
            ProjOnAccTrans			tprojOnAccTrans;

            // Delete the initial on account transactions created as part of the billing rule whose child transactions do not have invoiced status.
            // If there are multiple funding sources and there exist any invoiced transactions of any of them in on account transactions sale, we should not delete on account transaction.
            delete_from projOnAccTransToBeDeleted
                where projOnAccTransToBeDeleted.psaContractLineNum == _psaContractLineItems.ContractLineNum
                    exists join projOnAccTransSaleToBeDeleted
                        where projOnAccTransSaleToBeDeleted.TransId == projOnAccTransToBeDeleted.TransId
                           && projOnAccTransSaleToBeDeleted.TransStatus == ProjTransStatus::Registered
                        notexists join projOnAccTransSaleInvoiced
                            where projOnAccTransSaleInvoiced.TransId == projOnAccTransToBeDeleted.TransId
                               && projOnAccTransSaleInvoiced.TransStatus == ProjTransStatus::Invoiced;

            // Delete the on account transaction sale registered status records who could have invoiced status records also under the same transaction Id.
            delete_from projOnAccTransSaleRegistered
                where projOnAccTransSaleRegistered.TransStatus == ProjTransStatus::Registered
                    exists join tprojOnAccTrans
                        where tprojOnAccTrans.psaContractLineNum == _psaContractLineItems.ContractLineNum
                           && tprojOnAccTrans.TransId == projOnAccTransSaleRegistered.TransId
                        exists join projOnAccTransSaleInvoiced
                            where projOnAccTransSaleInvoiced.TransId == tprojOnAccTrans.TransId
                               && projOnAccTransSaleInvoiced.TransStatus == ProjTransStatus::Invoiced;

            projOnAccTrans.initFromBillingRule(_psaContractLineItems);
            ProjOnAccTrans::createOnAccTrans(projOnAccTrans, projProposalSummary.InvoiceAmount);
            projOnAccTrans = ProjOnAccTrans::find(projOnAccTrans.TransId);
            this.doOnAccount(projOnAccTrans, projProposalSummary.ContractLineNum);            

            // Create on account transactions for remaining amount
            remainingAmount = _psaContractLineItems.LineValue - projProposalSummary.InvoiceAmount - projProposalSummary.InvoiceAmountToDate;
            if (remainingAmount > 0)
            {
                remainingOnAccTrans.initFromBillingRule(_psaContractLineItems);
                ProjOnAccTrans::createOnAccTrans(remainingOnAccTrans, remainingAmount);
                remainingOnAccTrans = ProjOnAccTrans::find(remainingOnAccTrans.TransId);
            }
        }

        return projOnAccTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProposalForRevenueTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates invoice proposal with the fee transaction that is posted based on billing rule
    /// </summary>
    /// <returns>
    /// Revenue transaction that was posted from Fee journal
    /// </returns>
    private ProjRevenueTrans createProposalForRevenueTrans()
    {
        ProjRevenueTrans        projRevenueTrans;
        ProjRevenueTransSale    projRevenueTransSale;
        ProjFundingSource       projFundingSource;
        ProjRevenueTrans        reversalProjRevTrans;
        ProjRevenueTrans        correctedProjRevTrans;
        boolean                 hasRevenueTrans = false;
        AmountCur               totalAmountInvoiced = 0;
        PSAContractLineItems    psaContractLineItems;

        while select forupdate projRevenueTrans
            where projRevenueTrans.psaContractLineNum == projProposalSummary.ContractLineNum
            // newly calculated fee summary would not have referenced transaction
            // this check is to skip the counting for the case when we have adjusted fee transaction (associated with a ProjRevenueTrans record) as well as calculated fee
            join psaContractLineItems
                where psaContractLineItems.ContractLineNum == projRevenueTrans.PSAContractLineNum
                    join TransStatus from projRevenueTransSale
                        where projRevenueTransSale.TransId == projRevenueTrans.TransId
                            && (projRevenueTransSale.TransStatus == ProjTransStatus::Posted
                            || projRevenueTransSale.TransStatus == ProjTransStatus::MarkedCreditnote)
                                exists join projFundingSource
                                    where projFundingSource.RecId == projRevenueTransSale.FundingSource
                                        && (projFundingSource.FundingType == ProjFundingType::Customer
                                        || projFundingSource.FundingType == ProjFundingType::Grant)
        {
            if(projProposalSummary.HasReferencedTransaction || (!projProposalSummary.HasReferencedTransaction && psaContractLineItems.isLineTypeNotFee()))
            {
                // Update the revenue transaction line when flight <c>ProjCorrectInvAmtAfterCreditNoteIssuedFlight</c> is enabled.
                if (projRevenueTransSale.TransStatus == ProjTransStatus::MarkedCreditnote
                    && !this.canRevenueTransLineBeUpdated(psaContractLineItems))
                {
                    hasRevenueTrans = true;
                    totalAmountInvoiced += projRevenueTrans.TotalSalesAmountCur;
                    this.doRevenue(projRevenueTrans, projProposalSummary.ContractLineNum);
                }
                else
                {
                    hasRevenueTrans = true;
                    projRevenueTrans = ProjInvoiceProposalRuleCreateLines::generateFeeJournalAndPost(projProposalSummary.ContractLineNum, projProposalSummary.InvoiceAmount);
                    totalAmountInvoiced += projRevenueTrans.TotalSalesAmountCur;
                    this.doRevenue(projRevenueTrans, projProposalSummary.ContractLineNum);
                }
            }
        }

        if (hasRevenueTrans == false && projProposalSummary.InvoiceAmount != 0.0)
        {
            projRevenueTrans = ProjInvoiceProposalRuleCreateLines::generateFeeJournalAndPost(projProposalSummary.ContractLineNum, projProposalSummary.InvoiceAmount);
            this.doRevenue(projRevenueTrans, projProposalSummary.ContractLineNum);
        }
        else if (hasRevenueTrans && (abs(totalAmountInvoiced) != abs(projProposalSummary.InvoiceAmount)))
        {
            // When a fee transaction was already created and is ready to be posted, but its amount is different than the current amount
            // defined in the contract status, we need to reverse it and create a new one with the correct amount.
            reversalProjRevTrans = ProjInvoiceProposalRuleCreateLines::generateFeeJournalAndPost(projProposalSummary.ContractLineNum, -totalAmountInvoiced);
            this.doRevenue(reversalProjRevTrans, projProposalSummary.ContractLineNum);

            correctedProjRevTrans = ProjInvoiceProposalRuleCreateLines::generateFeeJournalAndPost(projProposalSummary.ContractLineNum, projProposalSummary.InvoiceAmount);
            this.doRevenue(correctedProjRevTrans, projProposalSummary.ContractLineNum);
        }

        return projRevenueTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSummary</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates summary transactions corresponding to a record in <c>PSAContractLineItems</c> table.
    /// </summary>
    /// <param name="_lineItems">
    /// A record in <c>PSAContractLineItems</c> table.
    /// </param>
    public void createSummary(PSAContractLineItems _lineItems)
    {
        using (var activityContext = logger.projOpsFinActivity().featureInstrumentationContext(methodStr(ProjInvoiceProposalRuleCreateLines, createSummary)))
        {
            switch (_lineItems.LineType)
            {
                case PSAContractLineType::LumpSum:
                    this.createSummaryForLumpSumLine(_lineItems);
                    break;

                case PSAContractLineType::Progress:
                    this.createSummaryForProgressLine(_lineItems);
                    break;

                case PSAContractLineType::TAndM:
                    this.createSummaryForTAndMLine(_lineItems);
                    break;

                case PSAContractLineType::UOD:
                    this.createSummaryForUODLine(_lineItems);
                    break;

                case PSAContractLineType::Fee:
                    this.createSummaryForFeeLine(_lineItems);
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSummaryForLumpSumLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates summary for lines of type Lumpsum.
    /// </summary>
    /// <param name="_lineItems">
    /// A record in <c>PSAContractLineItems</c> table.
    /// </param>
    protected void createSummaryForLumpSumLine(PSAContractLineItems _lineItems)
    {
        boolean		summaryCreated;

        void createSummary(boolean _isPositive)
        {
            projProposalSummary.clear();

            while select proposalTransDisplay where
                proposalTransDisplay.ContractLineNum == _lineItems.ContractLineNum &&
                ((_isPositive && proposalTransDisplay.LineAmount >= 0) || (!_isPositive && proposalTransDisplay.LineAmount < 0))
            {
                if (!projProposalSummary)
                {
                    select forupdate firstonly projProposalSummary where
                        projProposalSummary.ContractLineNum == _lineItems.ContractLineNum;

                    if (!projProposalSummary)
                    {
                        this.createSummaryRecord(_lineItems, proposalTransDisplay);
                        summaryCreated = true;
                    }
                }

                projProposalSummary.InvoiceAmount += proposalTransDisplay.LineAmount;
                projProposalSummary.InvoiceAmount += proposalTransDisplay.IndirectAmount;
                projProposalSummary.update();

                proposalTransDisplay.RefRecId = projProposalSummary.RecId;
                proposalTransDisplay.update();
            }

            if (!filterbyProjIdEnabled && !summaryCreated)
            {
                select forupdate firstonly projProposalSummary where
                        projProposalSummary.ContractLineNum == _lineItems.ContractLineNum &&
                        ((_isPositive && projProposalSummary.InvoiceAmount >= 0) || (!_isPositive && projProposalSummary.InvoiceAmount <= 0));

                if (!projProposalSummary)
                {
                    this.createSummaryRecord(_lineItems);
                    summaryCreated = true;
                }
            }
        }

        createSummary(true);
        createSummary(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSummaryForProgressLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates summary for lines of type progress.
    /// </summary>
    /// <param name="_lineItems">
    /// A record in <c>PSAContractLineItems</c> table.
    /// </param>
    protected void createSummaryForProgressLine(PSAContractLineItems _lineItems)
    {
        PSAContractLineItemsSetup           tpsaContractLineItemsSetupProj, tpsaContractLineItemsSetuCate;
        ProjId                              projId;
        ProjCategoryId                      categoryId;
        Amount                              budgetedAmounts;
        Amount                              transAmounts;
        PSAPercentUpdateLog                 psaPercentUpdateLog;
        Amount                              indirectAmounts;
        Amount                              progressPercent;
        ProjProposalOnAcc                   projProposalOnAcc;
        ProjOnAccTransSale                  projOnAccTransSaleLocal;
        ProjProposalRevenue                 projProposalRevenue;
        ProjRevenueTransSale                projRevenueTransSaleLocal;
        ProjBudgetLine                      projBudgetLine;
        boolean                             shouldSkipContractLineSpecificCategorySetup;
       
        select forupdate firstonly projProposalSummary
            index ContractLineIdx
            where projProposalSummary.ContractLineNum == _lineItems.ContractLineNum;

        if (!projProposalSummary.RecId)
        {
            this.createSummaryRecord(_lineItems, proposalTransDisplay);
        }

        if (_lineItems.IsCrossReference == NoYes::Yes)
        {
            shouldSkipContractLineSpecificCategorySetup = this.shouldSkipContractLineSpecificCategorySetup(_lineItems.ContractLineNum);

            while select tpsaContractLineItemsSetupProj
                where tpsaContractLineItemsSetupProj.ContractLineNum == _lineItems.ContractLineNum
                    && tpsaContractLineItemsSetupProj.ProjId != ''
                    && tpsaContractLineItemsSetupProj.CategoryId == ''
            {
                projId = tpsaContractLineItemsSetupProj.ProjId;

                if (projId)
                {
                    if (shouldSkipContractLineSpecificCategorySetup)
                    {
                        while select CategoryId from projBudgetLine
                            group by CategoryId
                            where projBudgetLine.ProjId == projId
                                && projBudgetLine.ProjBudgetLineType == ProjBudgetLineType::Cost
                                && projBudgetLine.CategoryId != ''
                        {
                            categoryId = projBudgetLine.CategoryId;
                            [budgetedAmounts, transAmounts, indirectAmounts] = this.calculateAmountsForCategory(projId, categoryId, budgetedAmounts, transAmounts, indirectAmounts);
                        }
                    }
                    else
                    {
                        while select CategoryId from tpsaContractLineItemsSetuCate
                            where tpsaContractLineItemsSetuCate.ContractLineNum == _lineItems.ContractLineNum
                                && tpsaContractLineItemsSetuCate.ProjId == projId
                                && tpsaContractLineItemsSetuCate.CategoryId != ''
                            {
                                categoryId = tpsaContractLineItemsSetuCate.CategoryId;
                                [budgetedAmounts, transAmounts, indirectAmounts] = this.calculateAmountsForCategory(projId, categoryId, budgetedAmounts, transAmounts, indirectAmounts);
                            }
                    }
                }
            }

            if (budgetedAmounts != 0)
            {
                progressPercent = transAmounts/budgetedAmounts;
            }

            projProposalSummary.InvoiceAmount = progressPercent
                                                * _lineItems.LineValue
                                                - PSAContractLineItemsServer::getContractLineInvoicedAmounts(_lineItems.ContractLineNum)
                                                + indirectAmounts;

            if (_lineItems.isBillingRuleForFixedPriceProject())
            {
                select sum(Amount) from projOnAccTransSaleLocal where
                        projOnAccTransSaleLocal.TransStatus  == ProjTransStatus::InvoiceProposal
                    join TableId from projProposalOnAcc where
                        projProposalOnAcc.psaContractLineNum == _lineItems.ContractLineNum &&
                        projProposalOnAcc.TransId            == projOnAccTransSaleLocal.TransId;
                projProposalSummary.InvoiceAmount -= projOnAccTransSaleLocal.Amount;
            }
            else
            {
                select sum(LineAmount) from projRevenueTransSaleLocal where
                       projRevenueTransSaleLocal.TransStatus  == ProjTransStatus::InvoiceProposal
                    join TableId from projProposalRevenue where
                        projProposalRevenue.psaContractLineNum == _lineItems.ContractLineNum &&
                        projProposalRevenue.IsRetained         == NoYes::No                  &&
                        projProposalRevenue.IsReleased         == NoYes::No                  &&
                        projProposalRevenue.TransId            == projRevenueTransSaleLocal.TransId;

                projProposalSummary.InvoiceAmount -= projRevenueTransSaleLocal.LineAmount;
            }
        }
        else
        {
            psaPercentUpdateLog = PSAPercentUpdateLog::find(_lineItems.ContractLineNum);

            if (psaPercentUpdateLog.RecId)
            {
                progressPercent = psaPercentUpdateLog.getCurrentInvoicePercentage()/100;
            }
            projProposalSummary.InvoiceAmount = progressPercent * _lineItems.LineValue;
        }

        projProposalSummary.update();

        while select proposalTransDisplay
            where proposalTransDisplay.ContractLineNum == _lineItems.ContractLineNum
        {
            proposalTransDisplay.RefRecId = projProposalSummary.RecId;
            proposalTransDisplay.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateAmountsForCategory</Name>
				<Source><![CDATA[
    private container calculateAmountsForCategory(ProjId _projId, ProjCategoryId _categoryId, Amount _budgetedAmounts, Amount _transAmounts, Amount _indirectAmounts)
    {
        ProjCostTrans                       projCostTrans;
        ProjEmplTrans                       projEmplTrans;
        ProjItemTrans                       projItemTrans;
        ProjEmplTransSale                   projEmplTransSale;
        ProjCategory                        projCategory;
        ProjCostTransCost                   projCostTransCost;
        ProjEmplTransCost                   projEmplTransCost;
        ProjItemTransCost                   projItemTransCost;

        Amount                              budgetAmountsForCategory;

        if (_categoryId)
        {
            projCategory = ProjCategory::find(_categoryId);
            switch (projCategory.CategoryType)
            {
                case ProjCategoryType::Hour :
                    budgetAmountsForCategory = PSAContractLineItemsServer::calProjCurrentBudgetEmplAmounts(_projId, _categoryId);

                    // Only compute actuals if there exists a budget line item for the category
                    if (budgetAmountsForCategory != 0.00)
                    {
                        _budgetedAmounts += budgetAmountsForCategory;

                        while select TransId, Qty from projEmplTrans
                                            where projEmplTrans.ProjId == _projId
                                                && projEmplTrans.CategoryId == _categoryId
                                        join CostPrice from projEmplTransCost
                                        where projEmplTransCost.TransId == projEmplTrans.TransId
                                            && (projEmplTransCost.TransStatus == ProjTransStatus::Posted ||
                                                projEmplTransCost.TransStatus == ProjTransStatus::Estimated)
                                            && (proposalCreateLinesParams.parmEndDate() == dateNull() || projEmplTrans.TransDate <= proposalCreateLinesParams.parmEndDate())
                        {
                            _transAmounts += projEmplTrans.Qty * projEmplTransCost.CostPrice;

                            //Add indirect invoice amount
                            select psaIndirectInvoice from projEmplTransSale where projEmplTransSale.TransId == projEmplTrans.TransId;
                            _indirectAmounts += projEmplTransSale.psaIndirectInvoice;
                        }
                    }
                    break;

                case ProjCategoryType::Cost:
                    budgetAmountsForCategory = PSAContractLineItemsServer::calProjCurrentBudgetCostAmounts(_projId, _categoryId);

                    // Only compute actuals if there exists a budget line item for the category
                    if (budgetAmountsForCategory != 0.00)
                    {
                        _budgetedAmounts += budgetAmountsForCategory;

                        while select TransId, Qty from projCostTrans
                                            where projCostTrans.ProjId == _projId
                                                && projCostTrans.CategoryId == _categoryId
                                        join CostPrice from projCostTransCost
                                        where projCostTransCost.TransId == projCostTrans.TransId
                                            && (projCostTransCost.TransStatus == ProjTransStatus::Posted ||
                                                projCostTransCost.TransStatus == ProjTransStatus::Estimated)
                                            && (proposalCreateLinesParams.parmEndDate() == dateNull() || projCostTrans.TransDate <= proposalCreateLinesParams.parmEndDate())
                        {
                            _transAmounts += projCostTrans.Qty * projCostTransCost.CostPrice;
                        }
                    }
                    break;

                case ProjCategoryType::Item :
                    budgetAmountsForCategory = PSAContractLineItemsServer::calProjCurrentBudgetItemAmounts(_projId, _categoryId);
                    // Only compute actuals if there exists a budget line item for the category
                    if (budgetAmountsForCategory != 0.00)
                    {
                        _budgetedAmounts += budgetAmountsForCategory;

                        while select InventTransId, ProjAdjustRefId from projItemTrans
                                            where projItemTrans.ProjId == _projId
                                                && projItemTrans.CategoryId == _categoryId
                                        join LineAmount from projItemTransCost
                                            where projItemTransCost.InventTransId == projItemTrans.InventTransId
                                                && projItemTransCost.ProjAdjustRefId == projItemTrans.ProjAdjustRefId
                                                && (projItemTransCost.TransStatus == ProjTransStatus::Posted ||
                                                    projItemTransCost.TransStatus == ProjTransStatus::Estimated)
                                                && (proposalCreateLinesParams.parmEndDate() == dateNull() || projItemTrans.TransDate <= proposalCreateLinesParams.parmEndDate())
                        {
                            _transAmounts += projItemTransCost.LineAmount;
                        }
                    }
                    break;
            }
        }

        return [_budgetedAmounts, _transAmounts, _indirectAmounts];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSummaryForTAndMLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates summary for lines of type Time and material.
    /// </summary>
    /// <param name="_lineItems">
    /// A record in <c>PSAContractLineItems</c> table.
    /// </param>
    protected void createSummaryForTAndMLine(PSAContractLineItems _lineItems)
    {
        this.createSummaryForLumpSumLine(_lineItems);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSummaryForFeeLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates summary for lines of type Fee.
    /// </summary>
    /// <param name="_lineItems">
    /// A record in <c>PSAContractLineItems</c> table.
    /// </param>
    protected void createSummaryForFeeLine(PSAContractLineItems _lineItems)
    {
        this.createSummaryForLumpSumLine(_lineItems);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSummaryForUODLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates summary for lines of type Unit of Delivery.
    /// </summary>
    /// <param name="_lineItems">
    /// A record in <c>PSAContractLineItems</c> table.
    /// </param>
    protected void createSummaryForUODLine(PSAContractLineItems _lineItems)
    {
        Amount                  percentComplete;
        ProjRevenueTrans        projRevenueTransLoc;
        ProjRevenueTransSale    projRevenueTransSaleLoc;
        ProjOnAccTrans          projOnAccTrans;
        ProjOnAccTransSale      projOnAccTransSale;
        Amount invoiceAmount;

        ProjProposalRevenue projProposalRevenue;
        select firstonly projRevenueTransLoc
            where projRevenueTransLoc.psaContractLineNum == _lineItems.ContractLineNum
            join RecId from projRevenueTransSaleLoc
                where projRevenueTransSaleLoc.TransId == projRevenueTransLoc.TransId
                    && projRevenueTransSaleLoc.TransStatus == ProjTransStatus::InvoiceProposal
            notexists join projProposalRevenue
                where projProposalRevenue.TransId == projRevenueTransLoc.TransId;

        if (!projRevenueTransLoc)
        {
            select forupdate firstonly projProposalSummary
                index ContractLineIdx
                where projProposalSummary.ContractLineNum == _lineItems.ContractLineNum;

            if (!projProposalSummary.RecId)
            {
                this.createSummaryRecord(_lineItems, proposalTransDisplay);
            }

            if (_lineItems.Units != 0)
            {
                percentComplete = PSAUnitsUpdateLog::find(_lineItems.ContractLineNum).getCurrentInvoiceUnits()/ _lineItems.Units;
            }
            else
            {
                percentComplete = 0;
            }

            projProposalSummary.InvoiceAmount = _lineItems.LineValue * percentComplete;
            projProposalSummary.update();

            invoiceAmount = projProposalSummary.InvoiceAmount;
        }

        if (projRevenueTransLoc)
        {
            select forupdate firstonly projProposalSummary
                index ContractLineIdx
                where projProposalSummary.ContractLineNum == _lineItems.ContractLineNum;

            if (!projProposalSummary.RecId)
            {
                this.createSummaryRecord(_lineItems, proposalTransDisplay);
            }

            projProposalSummary.InvoiceAmount -= projRevenueTransLoc.TotalSalesAmountCur;
            projProposalSummary.update();

            invoiceAmount = projProposalSummary.InvoiceAmount;
        }

        PSAUnitsUpdateLog psaUnitsUpdateLog;
        select firstonly psaUnitsUpdateLog
            where psaUnitsUpdateLog.ContractLineNum == _lineItems.ContractLineNum
                && psaUnitsUpdateLog.IsInvoiced == NoYes::No
                && psaUnitsUpdateLog.IsProposal == NoYes::No;

        // Added code to select the invoice proposal to be updated after the credit note is issued so that no error is thrown
        // when flight <c>ProjCorrectInvAmtAfterCreditNoteIssuedFlight</c> is enabled.
        if (!invoiceAmount || (invoiceAmount && psaUnitsUpdateLog))
        {
            select sum(LineAmount) from projRevenueTransSaleLoc where
                projRevenueTransSaleLoc.TransStatus == ProjTransStatus::MarkedCreditnote
            exists join projRevenueTransLoc where
                projRevenueTransLoc.psaContractLineNum == _lineItems.ContractLineNum &&
                projRevenueTransLoc.TransId     == projRevenueTransSaleLoc.TransId;

            if (projRevenueTransSaleLoc.LineAmount)
            {
                select forupdate firstonly projProposalSummary
                    index ContractLineIdx
                    where projProposalSummary.ContractLineNum == _lineItems.ContractLineNum;

                if (!projProposalSummary.RecId)
                {
                    this.createSummaryRecord(_lineItems, proposalTransDisplay);
                }

                projProposalSummary.InvoiceAmount -= projRevenueTransSaleLoc.LineAmount;
                // this is not a normal scenario and even when this code path his hit, it will result into very few updates.
                // not worth creating a new variable to consolidate into a single update.
                projProposalSummary.update();

                if (psaUnitsUpdateLog)
                {
                    psaUnitsUpdateLog.selectForUpdate(true);
                    real percentCompleted = projProposalSummary.InvoiceAmount / _lineItems.LineValue;
                    psaUnitsUpdateLog.AdditionalUnits = _lineItems.Units * percentCompleted;
                    psaUnitsUpdateLog.doUpdate();
                }
            }
        }

        // for fixed Price projects Credit Note
        select sum(Amount) from projOnAccTransSale where
                projOnAccTransSale.TransStatus == ProjTransStatus::MarkedCreditnote
            exists join ProjOnAccTrans where
                ProjOnAccTrans.psaContractLineNum == _lineItems.ContractLineNum &&
                ProjOnAccTrans.TransId     == projOnAccTransSale.TransId;

        if (projOnAccTransSale.Amount)
        {
            projProposalSummary.InvoiceAmount -= projOnAccTransSale.Amount;
            projProposalSummary.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSummaryRecord</Name>
				<Source><![CDATA[
    private void createSummaryRecord(PSAContractLineItems _lineItems, PSATmpProjProposalTrans _tProposalTrans = null)
    {
        projProposalSummary.initFromContractLine(_lineItems);

        if (_tProposalTrans)
        {
            projProposalSummary.initFromProposalTrans(_tProposalTrans);
            // newly calculated fee summary would not have referenced transction
            projProposalSummary.HasReferencedTransaction = true;
        }

        projProposalSummary.ProjInvoiceProjId   = proposalCreateLinesParams.parmProjInvoiceProjId();
        projProposalSummary.StartDate           = proposalCreateLinesParams.parmStartDate();
        projProposalSummary.EndDate             = proposalCreateLinesParams.parmEndDate();
        projProposalSummary.Summary             = true;
        projProposalSummary.ProjCategoryId      = '';
        projProposalSummary.InvoiceAmountToDate = PSAContractLineItemsServer::getContractLineInvoicedAmounts(_lineItems.ContractLineNum);

        projProposalSummary.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates transactions corresponding to a record in PSAContractLineItems table.
    /// </summary>
    /// <param name="_contractLineNum">
    /// An identifier for a row in <c>PSAContractLineItems</c> table.
    /// </param>
    /// <param name="_lineType">
    /// Type of line.
    /// </param>
    public void createTransactions(PSAContractLineNum _contractLineNum, PSAContractLineType _lineType)
    {
        using (var activityContext = logger.projOpsFinActivity().featureInstrumentationContext(methodStr(ProjInvoiceProposalRuleCreateLines, createTransactions)))
        {
            switch (_lineType)
            {
                case PSAContractLineType::LumpSum:
                    this.createTransactionsForLumpSumLine(_contractLineNum);
                    break;

                case PSAContractLineType::Progress:
                    this.createTransactionsForProgressLine(_contractLineNum);
                    break;

                case PSAContractLineType::TAndM:
                    this.createTransactionsForTAndMLine(_contractLineNum);
                    break;

                case PSAContractLineType::Fee:
                    this.createTransactionsForFeeLine(_contractLineNum);
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransactionsV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates transactions corresponding to a record in PSAContractLineItems table for a project.
    /// </summary>
    /// <param name="_contractLineNum">
    /// An identifier for a row in <c>PSAContractLineItems</c> table.
    /// </param>
    /// <param name="_lineType">
    /// Type of line.
    /// </param>
    /// <param name="_projId">
    /// Project ID.
    /// </param>
    public void createTransactionsV2(PSAContractLineNum _contractLineNum, PSAContractLineType _lineType, ProjId _projId)
    {
        using (var activityContext = logger.projOpsFinActivity().featureInstrumentationContext(methodStr(ProjInvoiceProposalRuleCreateLines, createTransactionsV2)))
        {
            switch (_lineType)
            {
                case PSAContractLineType::LumpSum:
                    this.createTransactionsForLumpSumLineV2(_contractLineNum, _projId);
                    break;

                case PSAContractLineType::Progress:
                    this.createTransactionsForProgressLine(_contractLineNum);
                    break;

                case PSAContractLineType::TAndM:
                    this.createTransactionsForTAndMLineV2(_contractLineNum, _projId);
                    break;

                case PSAContractLineType::Fee:
                    this.createTransactionsForFeeLine(_contractLineNum);
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransactionsForDeductionAndOnAcc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create transactions for deductions.
    /// </summary>
    /// <param name="_projInvoiceProjId">
    /// Identifier of the contract.
    /// </param>
    protected void createTransactionsForDeductionAndOnAcc(ProjInvoiceProjId _projInvoiceProjId)
    {
        using (var activityContext = logger.projOpsFinActivity().featureInstrumentationContext(methodStr(ProjInvoiceProposalRuleCreateLines, createTransactionsForDeductionAndOnAcc)))
        {
            int doDeductionCallCount = 0;
            int doOnAccCallCount = 0;

            if (!ProjInvoiceProposalRulePeriodicTransTypeFilterFlight::instance().isEnabled()
            || proposalCreateLinesParams.parmIsQueryOnAccTrans())
            {
                ProjTable projTable;
                ProjOnAccTrans projOnAccTrans;

                while select projOnAccTrans
                join ProjInvoiceProjId from projTable
                    where projTable.ProjId == projOnAccTrans.ProjID
                        && projTable.ProjInvoiceProjId == _projInvoiceProjId
                        && (projOnAccTrans.TransactionOrigin == ProjOrigin::Deduction || projOnAccTrans.TransactionOrigin == ProjOrigin::Prepayment)
                        && (proposalCreateLinesParams.parmStartDate() == dateNull() || projOnAccTrans.TransDate >= proposalCreateLinesParams.parmStartDate())
                        && (proposalCreateLinesParams.parmEndDate()   == dateNull() || projOnAccTrans.TransDate <= proposalCreateLinesParams.parmEndDate())
                {
                    if (projOnAccTrans.ProjID && !this.createInvoiceProposalProjStatusTypeRule(projOnAccTrans.ProjID))
                    {
                        continue;
                    }

                    if (projOnAccTrans.TransactionOrigin  == ProjOrigin::Deduction)
                    {
                        doDeductionCallCount++;
                        this.doDeduction(projOnAccTrans);
                    }
                    else
                    {
                        doOnAccCallCount++;
                        this.doOnAcc(projOnAccTrans);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProjectOrContractExternal</Name>
				<Source><![CDATA[
    private boolean isProjectOrContractExternal(ProjId _projId)
    {
        boolean ret = false;

        if (cdsLockingOptionCreateInvoiceProposals)
        {
            ProjTable projTable = ProjTable::find(_projId);
            if (Project::isProjectExternallyManaged(projTable.ProjId))
            {
                ret = true;
            }
            else if (Project::isContractExternallyManaged(projTable.ProjInvoiceProjId))
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransactionsForLumpSumLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create transactions for lump sum line.
    /// </summary>
    /// <param name="_contractLineNum">
    /// Identifier of the billing rule.
    /// </param>
    protected void createTransactionsForLumpSumLine(PSAContractLineNum _contractLineNum)
    {
        using (var activityContext = logger.projOpsFinActivity().featureInstrumentationContext(methodStr(ProjInvoiceProposalRuleCreateLines, createTransactionsForLumpSumLine)))
        {
            int psaContractLineItemsSetupCount = 0;
            int doOnAccountCallCount = 0;

            if (!ProjInvoiceProposalRulePeriodicTransTypeFilterFlight::instance().isEnabled()
            || proposalCreateLinesParams.parmIsQueryOnAccTrans())
            {
                PSAContractLineItemsSetup psaContractLineItemsSetup;
                ProjOnAccTrans projOnAccTrans;
                ProjOnAccTransSale projOnAccTransSale;

                while select ProjOnAccTransId from psaContractLineItemsSetup
                where psaContractLineItemsSetup.ContractLineNum == _contractLineNum
                    join firstonly projOnAccTrans
                        where projOnAccTrans.TransId == psaContractLineItemsSetup.ProjOnAccTransId
                            exists join firstonly projOnAccTransSale
                                where projOnAccTransSale.TransId == projOnAccTrans.TransId
                                    && projOnAccTrans.IsMilestoneComplete == NoYes::Yes
                                    && (projOnAccTransSale.TransStatus == ProjTransStatus::Registered
                                        || projOnAccTransSale.TransStatus == ProjTransStatus::MarkedCreditnote)
                                    && (proposalCreateLinesParams.parmStartDate() == dateNull() || projOnAccTrans.TransDate >= proposalCreateLinesParams.parmStartDate())
                                    && (proposalCreateLinesParams.parmEndDate() == dateNull()   || projOnAccTrans.TransDate <= proposalCreateLinesParams.parmEndDate())
                {
                    psaContractLineItemsSetupCount++;
                    ProjTable projTable = ProjTable::find(projOnAccTrans.ProjID);
                    if (!this.isProjectOrContractExternal(projOnAccTrans.ProjID) && ProjStatusTypeRule::exist(projTable.Status, projTable.Type, ProjStatusRule::CreateInvoiceProposal))
                    {
                        doOnAccountCallCount++;
                        this.doOnAccount(projOnAccTrans, _contractLineNum);
                    }
                }
            }
  
            this.addSalesOrderTransactionsForFixedPriceContractLine(_contractLineNum);

            activityContext.addCustomProperty('psaContractLineItemsSetupCount', any2Str(psaContractLineItemsSetupCount));
            activityContext.addCustomProperty('doOnAccountCallCount', any2Str(doOnAccountCallCount));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransactionsForLumpSumLineV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create transactions for lump sum line.
    /// </summary>
    /// <param name="_contractLineNum">
    /// Identifier of the billing rule.
    /// </param>
    /// <param name="_projId">
    /// Current project id
    /// </param>
    protected void createTransactionsForLumpSumLineV2(PSAContractLineNum _contractLineNum, ProjId _projId)
    {
        using (var activityContext = logger.projOpsFinActivity().featureInstrumentationContext(methodStr(ProjInvoiceProposalRuleCreateLines, createTransactionsForLumpSumLineV2)))
        {
            int psaContractLineItemsSetupCount = 0;
            int doOnAccountCallCount = 0;

            if (!ProjInvoiceProposalRulePeriodicTransTypeFilterFlight::instance().isEnabled()
            || proposalCreateLinesParams.parmIsQueryOnAccTrans())
            {
                PSAContractLineItemsSetup psaContractLineItemsSetup;
                ProjOnAccTrans projOnAccTrans;
                ProjOnAccTransSale projOnAccTransSale;
                boolean includeSubProjects = proposalCreateLinesParams.parmIncludeSubProjects();

                while select ProjOnAccTransId from psaContractLineItemsSetup
                where psaContractLineItemsSetup.ContractLineNum == _contractLineNum
                    join projOnAccTrans
                        where projOnAccTrans.TransId == psaContractLineItemsSetup.ProjOnAccTransId
                            exists join projOnAccTransSale
                                where projOnAccTransSale.TransId == projOnAccTrans.TransId
                                    && projOnAccTrans.IsMilestoneComplete == NoYes::Yes
                                    && (projOnAccTransSale.TransStatus == ProjTransStatus::Registered
                                        || projOnAccTransSale.TransStatus == ProjTransStatus::MarkedCreditnote)
                                    && (proposalCreateLinesParams.parmStartDate() == dateNull() || projOnAccTrans.TransDate >= proposalCreateLinesParams.parmStartDate())
                                    && (proposalCreateLinesParams.parmEndDate() == dateNull() || projOnAccTrans.TransDate <= proposalCreateLinesParams.parmEndDate())
                                    && ((!includeSubProjects && projOnAccTrans.ProjID == _projId) || (includeSubProjects && projOnAccTrans.ProjID like _projId + #star))
                {
                    psaContractLineItemsSetupCount++;
                    ProjTable projTable = ProjTable::find(projOnAccTrans.ProjID);
                    if (!this.isProjectOrContractExternal(projOnAccTrans.ProjID) && ProjStatusTypeRule::exist(projTable.Status, projTable.Type, ProjStatusRule::CreateInvoiceProposal))
                    {
                        doOnAccountCallCount++;
                        this.doOnAccount(projOnAccTrans, _contractLineNum);
                    }
                }
            }
  
            this.addSalesOrderTransactionsForFixedPriceContractLine(_contractLineNum, _projId);

            activityContext.addCustomProperty('psaContractLineItemsSetupCount', any2Str(psaContractLineItemsSetupCount));
            activityContext.addCustomProperty('doOnAccountCallCount', any2Str(doOnAccountCallCount));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSalesOrderTransactionsForFixedPriceContractLine</Name>
				<Source><![CDATA[
    private void addSalesOrderTransactionsForFixedPriceContractLine(PSAContractLineNum _contractLineNum, ProjId _projId = '')
    {
        ProjOnAccTrans              projOnAccTrans;

        using (var activityContext = logger.projOpsFinActivity().featureInstrumentationContext(methodStr(ProjInvoiceProposalRuleCreateLines, addSalesOrderTransactionsForFixedPriceContractLine)))
        {
            int projOnAccTransactionCount = 0;
            int addUninvoicedSalesOrderTransactionsCallCount = 0;
            Set projects = new Set(Types::String);
            
            if (isMultipleContractLinesForProjectEnabled && proposalCreateLinesParams.parmIsQuerySalesLine())
            {
                boolean skipProjId = true;
                if (_projId != '')
                {
                    skipProjId = false;
                }

                while select ProjId from projOnAccTrans
                where projOnAccTrans.PSAContractLineNum == _contractLineNum
                    && (skipProjId || projOnAccTrans.ProjID == _projId)
                {
                    projOnAccTransactionCount++;
                    ProjId currentProjId = projOnAccTrans.ProjID;

                    if (!this.isProjectOrContractExternal(currentProjId)
                    && !projects.in(currentProjId))
                    {
                        projects.add(currentProjId);
                    
                        if (ProjMultipleContractLinesForProjectFeatureHelper::hasFixedPriceBillingForItemTransactions(currentProjId))
                        {
                            addUninvoicedSalesOrderTransactionsCallCount++;
                            this.addUninvoicedSalesOrderTransactions(currentProjId, _contractLineNum);
                        }
                    }
                }
            }

            activityContext.addCustomProperty('projOnAccTransactionCount', any2Str(projOnAccTransactionCount));
            activityContext.addCustomProperty('addUninvoicedSalesOrderTransactionsCallCount', any2Str(addUninvoicedSalesOrderTransactionsCallCount));
            activityContext.addCustomProperty('projectsCount', any2Str(projects.elements()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addUninvoicedSalesOrderTransactions</Name>
				<Source><![CDATA[
    private void addUninvoicedSalesOrderTransactions(ProjId _projId, PSAContractLineNum _contractLineNum)
    {
        ProjProposalItem            projProposalItem;
        SalesTable                  salesTable;
        SalesLine                   salesLine;

        using (var activityContext = logger.projOpsFinActivity().featureInstrumentationContext(methodStr(ProjInvoiceProposalRuleCreateLines, addUninvoicedSalesOrderTransactions)))
        {
            int doSalesLineCallCount = 0;

            while select RecId from salesTable
                            join salesLine where
                                salesTable.SalesId       == salesLine.SalesId   &&
                                salesTable.ProjId        == _projId &&
                                (proposalCreateLinesParams.parmStartDate() == dateNull()  || salesLine.ConfirmedDlv >= proposalCreateLinesParams.parmStartDate()) &&
                                (proposalCreateLinesParams.parmEndDate() == dateNull()    || salesLine.ConfirmedDlv <= proposalCreateLinesParams.parmEndDate())
                                    notexists join projProposalItem where
                                        projProposalItem.ItemType == ProjItemType::SalesOrder   &&
                                        projProposalItem.InventTransId == salesLine.InventTransId
            {
                doSalesLineCallCount++;
                this.doSalesLine(salesLine, PSAContractLineItems::find(_contractLineNum).ProjInvoiceProjId, true, _contractLineNum);
            }

            activityContext.addCustomProperty('doSalesLineCallCount', any2Str(doSalesLineCallCount));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransactionsForProgressLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create transactions for progress.
    /// </summary>
    /// <param name="_contractLineNum">
    /// Identifier of the billing rule.
    /// </param>
    protected void createTransactionsForProgressLine(PSAContractLineNum _contractLineNum)
    {
        PSAContractLineItemsSetup           psaContractLineItemsSetupProj;
        PSAContractLineItemsSetup           psaContractLineItemsSetuCate;
        ProjId                              projId;
        ProjCategoryId                      categoryId;
        PSAContractLineItems                psaContractLineItems;
        ProjBudgetLine                      projBudgetLine;

        boolean shouldSkipContractLineSpecificCategorySetup = this.shouldSkipContractLineSpecificCategorySetup(_contractLineNum);

        using (var activityContext = logger.projOpsFinActivity().featureInstrumentationContext(methodStr(ProjInvoiceProposalRuleCreateLines, createTransactionsForProgressLine)))
        {
            int psaContractLineItemsSetupProjCount = 0;
            int createAllTransactionsForProgressLineCallCount = 0;

            while select psaContractLineItemsSetupProj
            where psaContractLineItemsSetupProj.ContractLineNum == _contractLineNum
               && psaContractLineItemsSetupProj.ProjId != ''
               && psaContractLineItemsSetupProj.CategoryId == ''
            {
                psaContractLineItemsSetupProjCount++;
                projId = psaContractLineItemsSetupProj.ProjId;
                if (projId && !this.isProjectOrContractExternal(projId))
                {
                    if (shouldSkipContractLineSpecificCategorySetup)
                    {
                        while select CategoryId from projBudgetLine
                            group by CategoryId
                            where projBudgetLine.ProjId == projId
                                && projBudgetLine.ProjBudgetLineType == ProjBudgetLineType::Cost
                                && projBudgetLine.CategoryId != ''
                        {
                            createAllTransactionsForProgressLineCallCount++;
                            categoryId = projBudgetLine.CategoryId;
                            this.createAllTransactionsForProgressLine(_contractLineNum, projId, categoryId);
                        }
                    }
                    else
                    {
                        while select CategoryId from psaContractLineItemsSetuCate
                            where psaContractLineItemsSetuCate.ContractLineNum == _contractLineNum
                                && psaContractLineItemsSetuCate.ProjId == projId
                                && psaContractLineItemsSetuCate.CategoryId != ''
                        {
                            createAllTransactionsForProgressLineCallCount++;
                            categoryId = psaContractLineItemsSetuCate.CategoryId;
                            this.createAllTransactionsForProgressLine(_contractLineNum, projId, categoryId);
                        }
                    }

                }
            }

            activityContext.addCustomProperty('psaContractLineItemsSetupProjCount', any2Str(psaContractLineItemsSetupProjCount));
            activityContext.addCustomProperty('createAllTransactionsForProgressLineCallCount', any2Str(createAllTransactionsForProgressLineCallCount));
            activityContext.addCustomProperty('shouldSkipContractLineSpecificCategorySetup', any2Str(shouldSkipContractLineSpecificCategorySetup));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransactionsForTAndMLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create transactions for time and material.
    /// </summary>
    /// <param name="_contractLineNum">
    /// Identifier of the contract.
    /// </param>
    protected void createTransactionsForTAndMLine(PSAContractLineNum _contractLineNum)
    {
        PSAContractLineItemsSetup           psaContractLineItemsSetupProj;
        ProjId                              projId;

        using (var activityContext = logger.projOpsFinActivity().featureInstrumentationContext(methodStr(ProjInvoiceProposalRuleCreateLines, createTransactionsForTAndMLine)))
        {
            boolean shouldSkipContractLineSpecificCategorySetup = this.shouldSkipContractLineSpecificCategorySetup(_contractLineNum);

            int createTransactionsForTAndMLineProjCallCount = 0;

            while select psaContractLineItemsSetupProj
            where psaContractLineItemsSetupProj.ContractLineNum == _contractLineNum
               && psaContractLineItemsSetupProj.ProjId != ''
               && psaContractLineItemsSetupProj.CategoryId == ''
            {
                createTransactionsForTAndMLineProjCallCount++;
                projId = psaContractLineItemsSetupProj.ProjId;
                this.createTransactionsForTAndMLineProj(_contractLineNum, projId, shouldSkipContractLineSpecificCategorySetup);
            }

            activityContext.addCustomProperty('shouldSkipContractLineSpecificCategorySetup', any2Str(shouldSkipContractLineSpecificCategorySetup));
            activityContext.addCustomProperty('createTransactionsForTAndMLineProjCallCount', any2Str(createTransactionsForTAndMLineProjCallCount));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransactionsForTAndMLineV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create transactions for time and material for project.
    /// </summary>
    /// <param name="_contractLineNum">
    /// Identifier of the contract.
    /// </param>
    /// <param name="_projId">
    /// Current project id.
    /// </param>
    protected void createTransactionsForTAndMLineV2(PSAContractLineNum _contractLineNum, ProjId _projId)
    {
        PSAContractLineItemsSetup           psaContractLineItemsSetupProj;

        using (var activityContext = logger.projOpsFinActivity().featureInstrumentationContext(methodStr(ProjInvoiceProposalRuleCreateLines, createTransactionsForTAndMLine)))
        {
            boolean shouldSkipContractLineSpecificCategorySetup = this.shouldSkipContractLineSpecificCategorySetup(_contractLineNum);

            int createTransactionsForTAndMLineProjCallCount = 0;

            if (proposalCreateLinesParams.parmIncludeSubProjects() && ProjTable::child(_projId))
            {
                // Project transactions should be created for sub projects in case when no posted transaction available for parent project.
                while select psaContractLineItemsSetupProj
                where psaContractLineItemsSetupProj.ContractLineNum == _contractLineNum
                   && psaContractLineItemsSetupProj.CategoryId == ''
                   && psaContractLineItemsSetupProj.ProjId like _projId + #star
                {
                    createTransactionsForTAndMLineProjCallCount++;
                    ProjId projId = psaContractLineItemsSetupProj.ProjId;
                    this.createTransactionsForTAndMLineProj(_contractLineNum, projId, shouldSkipContractLineSpecificCategorySetup);
                }
            }
            else
            {
                while select psaContractLineItemsSetupProj
                where psaContractLineItemsSetupProj.ContractLineNum == _contractLineNum
                   && psaContractLineItemsSetupProj.ProjId == _projId
                   && psaContractLineItemsSetupProj.CategoryId == ''
                {
                    createTransactionsForTAndMLineProjCallCount++;
                    this.createTransactionsForTAndMLineProj(_contractLineNum, _projId, shouldSkipContractLineSpecificCategorySetup);
                }
            }

            activityContext.addCustomProperty('shouldSkipContractLineSpecificCategorySetup', any2Str(shouldSkipContractLineSpecificCategorySetup));
            activityContext.addCustomProperty('createTransactionsForTAndMLineProjCallCount', any2Str(createTransactionsForTAndMLineProjCallCount));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransactionsForTAndMLineProj</Name>
				<Source><![CDATA[
    private void createTransactionsForTAndMLineProj(PSAContractLineNum _contractLineNum, ProjId _projId, boolean _shouldSkipContractLineSpecificCategorySetup)
    {
        PSAContractLineItemsSetup psaContractLineItemsSetuCate;
        ProjCategoryId categoryId;

        using (var activityContext = logger.projOpsFinActivity().featureInstrumentationContext(methodStr(ProjInvoiceProposalRuleCreateLines, createTransactionsForTAndMLineProj)))
        {

            if (_projId
            && this.createInvoiceProposalProjStatusTypeRule(_projId)
            && !this.isProjectOrContractExternal(_projId))
            {
                if (_shouldSkipContractLineSpecificCategorySetup)
                {
                    this.createAllTransactionsForTandMLine(_contractLineNum, _projId);
                }
                else
                {
                    while select psaContractLineItemsSetuCate
                    where psaContractLineItemsSetuCate.ContractLineNum == _contractLineNum
                        && psaContractLineItemsSetuCate.ProjId == _projId
                        && psaContractLineItemsSetuCate.CategoryId != ''
                    {
                        categoryId = psaContractLineItemsSetuCate.CategoryId;
                        if (categoryId)
                        {
                            this.createAllTransactionsForTandMLine(_contractLineNum, _projId, categoryId);
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCostTransactionsForTandMLine</Name>
				<Source><![CDATA[
    private int createCostTransactionsForTandMLine(PSAContractLineNum _contractLineNum, ProjId _projId, boolean _skipCategoryFilter, ProjCategoryId _categoryId)
    {
        int doCostCallCount = 0;

        if (!ProjInvoiceProposalRulePeriodicTransTypeFilterFlight::instance().isEnabled()
            || proposalCreateLinesParams.parmIsQueryCostTrans())
        {
            ProjCostTrans projCostTrans;
            ProjCostTransSale projCostTransSale;

            while select projCostTrans
                where projCostTrans.ProjId == _projId
                    && (_skipCategoryFilter || projCostTrans.CategoryId == _categoryId)
                    && (proposalCreateLinesParams.parmStartDate() == dateNull() || projCostTrans.TransDate >= proposalCreateLinesParams.parmStartDate())
                    && (proposalCreateLinesParams.parmEndDate() == dateNull()   || projCostTrans.TransDate <= proposalCreateLinesParams.parmEndDate())
            {
                if (proposalCreateLinesParams.parmInvoiceTypeSelection() == ProjInvoiceTypeSelection::Creditnotes)
                {
                    select firstonly projCostTransSale
                        where projCostTransSale.TransId == projCostTrans.TransId
                            && projCostTransSale.TransStatus == ProjTransStatus::MarkedCreditnote;
                }
                else if (proposalCreateLinesParams.parmInvoiceTypeSelection() == ProjInvoiceTypeSelection::Invoices)
                {
                    select firstonly projCostTransSale
                        where projCostTransSale.TransId == projCostTrans.TransId
                            && projCostTransSale.TransStatus == ProjTransStatus::Posted;
                }
                else
                {
                    select firstonly projCostTransSale
                        where projCostTransSale.TransId == projCostTrans.TransId
                            && (projCostTransSale.TransStatus == ProjTransStatus::Posted
                            || projCostTransSale.TransStatus == ProjTransStatus::MarkedCreditnote);
                }

                if (ProjTrans::newProjCostTransSale(projCostTrans, projCostTransSale).canBeInvoiced())
                {
                    doCostCallCount++;
                    this.doCost(projCostTrans, true, _contractLineNum);
                }
            }
        }

        return doCostCallCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createEmplTransactionsForTandMLine</Name>
				<Source><![CDATA[
    private int createEmplTransactionsForTandMLine(boolean _isCreate, PSAContractLineNum _contractLineNum, ProjId _projId, boolean _skipCategoryFilter, ProjCategoryId _categoryId)
    {
        int doEmplCallCount = 0;

        if (!ProjInvoiceProposalRulePeriodicTransTypeFilterFlight::instance().isEnabled()
            || proposalCreateLinesParams.parmIsQueryEmplTrans())
        {
            ProjEmplTrans projEmplTrans;
            ProjEmplTransSale projEmplTransSale;

            while select projEmplTrans
                where projEmplTrans.ProjId == _projId
                    && (_skipCategoryFilter || projEmplTrans.CategoryId == _categoryId)
                    && (proposalCreateLinesParams.parmStartDate() == dateNull() || projEmplTrans.TransDate >= proposalCreateLinesParams.parmStartDate())
                    && (proposalCreateLinesParams.parmEndDate() == dateNull()   || projEmplTrans.TransDate <= proposalCreateLinesParams.parmEndDate())
            {
                if (proposalCreateLinesParams.parmInvoiceTypeSelection() == ProjInvoiceTypeSelection::Creditnotes)
                {
                    select firstonly projEmplTransSale
                    where projEmplTransSale.TransId == projEmplTrans.TransId
                        && projEmplTransSale.TransStatus == ProjTransStatus::MarkedCreditnote;
                }
                else if (proposalCreateLinesParams.parmInvoiceTypeSelection() == ProjInvoiceTypeSelection::Invoices)
                {
                    select firstonly projEmplTransSale
                    where projEmplTransSale.TransId == projEmplTrans.TransId
                        && projEmplTransSale.TransStatus == ProjTransStatus::Posted;
                }
                else
                {
                    select firstonly projEmplTransSale
                    where projEmplTransSale.TransId == projEmplTrans.TransId
                        && (projEmplTransSale.TransStatus == ProjTransStatus::Posted
                        || projEmplTransSale.TransStatus == ProjTransStatus::MarkedCreditnote);
                }

                if (ProjTrans::newProjEmplTransSale(projEmplTrans, projEmplTransSale).canBeInvoiced())
                {
                    doEmplCallCount++;
                    this.doEmpl(projEmplTrans, _isCreate, _contractLineNum);
                }
            }
        }

        return doEmplCallCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createItemTransactionsForTandMLine</Name>
				<Source><![CDATA[
    private int createItemTransactionsForTandMLine(boolean _isCreate, PSAContractLineNum _contractLineNum, ProjId _projId, boolean _skipCategoryFilter, ProjCategoryId _categoryId)
    {
        int doItemCallCount = 0;

        if (!ProjInvoiceProposalRulePeriodicTransTypeFilterFlight::instance().isEnabled()
            || proposalCreateLinesParams.parmIsQueryItemTrans())
        {
            ProjItemTrans projItemTrans;
            ProjItemTransSale projItemTransSale;

            while select projItemTrans
                where projItemTrans.ProjId == _projId
                    && (_skipCategoryFilter || projItemTrans.CategoryId == _categoryId)
                    && (proposalCreateLinesParams.parmStartDate() == dateNull() || projItemTrans.TransDate >= proposalCreateLinesParams.parmStartDate())
                    && (proposalCreateLinesParams.parmEndDate() == dateNull()   || projItemTrans.TransDate <= proposalCreateLinesParams.parmEndDate())
            {
                if (proposalCreateLinesParams.parmInvoiceTypeSelection() == ProjInvoiceTypeSelection::Creditnotes)
                {
                    select firstonly projItemTransSale
                        where projItemTransSale.ProjTransId == projItemTrans.ProjTransId
                            && projItemTransSale.TransStatus == ProjTransStatus::MarkedCreditnote;
                }
                else if (proposalCreateLinesParams.parmInvoiceTypeSelection() == ProjInvoiceTypeSelection::Invoices)
                {
                    select firstonly projItemTransSale
                        where projItemTransSale.ProjTransId == projItemTrans.ProjTransId
                            && projItemTransSale.TransStatus == ProjTransStatus::Posted;
                }
                else
                {
                    select firstonly projItemTransSale
                        where projItemTransSale.ProjTransId == projItemTrans.ProjTransId
                            && (projItemTransSale.TransStatus == ProjTransStatus::Posted
                            || projItemTransSale.TransStatus == ProjTransStatus::MarkedCreditnote);
                }

                if (ProjTrans::newProjItemTransSale(projItemTrans, projItemTransSale).canBeInvoiced())
                {
                    doItemCallCount++;
                    this.doItem(projItemTrans, _isCreate, _contractLineNum);
                }
            }
        }

        return doItemCallCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjRevenueTransQuery</Name>
				<Source><![CDATA[
    protected QueryBuildDataSource getProjRevenueTransQuery(Query _query, PSAContractLineNum _contractLineNum, ProjId _projId,
        boolean _skipCategoryFilter, ProjCategoryId _categoryId)
    {
        QueryBuildDataSource projRevenueTransQbds = _query.addDataSource(tableNum(ProjRevenueTrans));
        projRevenueTransQbds.addRange(fieldNum(ProjRevenueTrans, ProjId)).value(queryValue(_projId));

        if (!_skipCategoryFilter)
        {
            projRevenueTransQbds.addRange(fieldNum(ProjRevenueTrans, CategoryId)).value(queryValue(_categoryId));
        }
        
        if (proposalCreateLinesParams.parmStartDate() != dateNull() && proposalCreateLinesParams.parmEndDate() != dateNull())
        {
            projRevenueTransQbds.addRange(fieldNum(ProjRevenueTrans, TransDate))
                .value(queryRange(proposalCreateLinesParams.parmStartDate(), proposalCreateLinesParams.parmEndDate()));
        }
        else if (proposalCreateLinesParams.parmStartDate() != dateNull())
        {
            projRevenueTransQbds.addRange(fieldNum(ProjRevenueTrans, TransDate))
                .value(queryRange(proposalCreateLinesParams.parmStartDate(), dateMax()));
        }
        else if (proposalCreateLinesParams.parmEndDate() != dateNull())
        {
            projRevenueTransQbds.addRange(fieldNum(ProjRevenueTrans, TransDate))
                .value(queryRange(dateNull(), proposalCreateLinesParams.parmEndDate()));
        }

        if (!proposalCreateLinesParams.parmIsQuerySubscriptionTrans()
            && ProjInvoiceProposalRulePeriodicTransTypeFilterFlight::instance().isEnabled())
        {
            projRevenueTransQbds.addRange(fieldNum(ProjRevenueTrans, TransactionOrigin))
                .value(SysQuery::valueNot(ProjOrigin::Subscription));
        }

        // PSAContractLineNum = '' or PSAContractLineNum = _contractLineNum
        projRevenueTransQbds.addRange(fieldNum(ProjRevenueTrans, PSAContractLineNum))
            .value(SysQuery::valueEmptyString());
        projRevenueTransQbds.addRange(fieldNum(ProjRevenueTrans, PSAContractLineNum))
            .value(queryValue(_contractLineNum));

        return projRevenueTransQbds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRevenueTransactionsForTandMLine</Name>
				<Source><![CDATA[
    private int createRevenueTransactionsForTandMLine(PSAContractLineNum _contractLineNum, ProjId _projId, boolean _skipCategoryFilter, ProjCategoryId _categoryId)
    {
        int doRevenueCallCount = 0;

        if (!ProjInvoiceProposalRulePeriodicTransTypeFilterFlight::instance().isEnabled()
            || proposalCreateLinesParams.parmIsQueryRevenueTrans())
        {
            Query query = new Query();
            this.getProjRevenueTransQuery(query, _contractLineNum, _projId, _skipCategoryFilter, _categoryId);

            QueryRun queryRun = new QueryRun(query);

            while (queryRun.next())
            {
                ProjRevenueTrans projRevenueTrans = queryRun.get(tablenum(ProjRevenueTrans));
            
                ProjRevenueTransSale projRevenueTransSale;

                if (proposalCreateLinesParams.parmInvoiceTypeSelection() == ProjInvoiceTypeSelection::Creditnotes)
                {
                    select firstonly projRevenueTransSale
                        where projRevenueTransSale.TransId == projRevenueTrans.TransId
                            && projRevenueTransSale.TransStatus == ProjTransStatus::MarkedCreditnote;
                }
                else if (proposalCreateLinesParams.parmInvoiceTypeSelection() == ProjInvoiceTypeSelection::Invoices)
                {
                    select firstonly projRevenueTransSale
                        where projRevenueTransSale.TransId == projRevenueTrans.TransId
                            && projRevenueTransSale.TransStatus == ProjTransStatus::Posted;
                }
                else
                {
                    select firstonly projRevenueTransSale
                        where projRevenueTransSale.TransId == projRevenueTrans.TransId
                            && (projRevenueTransSale.TransStatus == ProjTransStatus::Posted
                            || projRevenueTransSale.TransStatus == ProjTransStatus::MarkedCreditnote);
                }

                if (ProjTrans::newProjRevenueTransSale(projRevenueTrans, projRevenueTransSale).canBeInvoiced())
                {
                    doRevenueCallCount++;
                    this.doRevenue(projRevenueTrans, _contractLineNum);
                }
            }
        }

        return doRevenueCallCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSalesLineTransactionsForTandMLine</Name>
				<Source><![CDATA[
    private int createSalesLineTransactionsForTandMLine(PSAContractLineNum _contractLineNum, ProjId _projId, boolean _skipCategoryFilter, ProjCategoryId _categoryId)
    {
        int doSalesLineCallCount = 0;

        if (!ProjInvoiceProposalRulePeriodicTransTypeFilterFlight::instance().isEnabled()
            || proposalCreateLinesParams.parmIsQuerySalesLine())
        {
            SalesTable salesTable;
            SalesLine salesLine;
            ProjProposalItem projProposalItem;

            while select RecId from salesTable
                join salesLine where
                    salesTable.SalesId == salesLine.SalesId
                        && salesTable.ProjId == _projId
                        && salesTable.MCROrderStopped == NoYes::No
                        && (_skipCategoryFilter || salesLine.ProjCategoryId == _categoryId)
                        && (salesLine.SalesStatus != SalesStatus::Invoiced || salesLine.SalesStatus != SalesStatus::Canceled)
            {
                if (this.checkSalesLineWithInDateRange(salesLine))
                {
                    doSalesLineCallCount++;
                    this.doSalesLine(salesLine, PSAContractLineItems::find(_contractLineNum).ProjInvoiceProjId, true, _contractLineNum);
                }
            }
        }

        return doSalesLineCallCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAllTransactionsForTandMLine</Name>
				<Source><![CDATA[
    private void createAllTransactionsForTandMLine(PSAContractLineNum _contractLineNum, ProjId _projId, ProjCategoryId _categoryId = '')
    {
        boolean skipCategoryFilter = (_categoryId == '');

        using (var activityContext = logger.projOpsFinActivity().featureInstrumentationContext(methodStr(ProjInvoiceProposalRuleCreateLines, createAllTransactionsForTandMLine)))
        {
            int costTransactionCount = this.createCostTransactionsForTandMLine(_contractLineNum, _projId, skipCategoryFilter, _categoryId);
            int emplTransactionCount = this.createEmplTransactionsForTandMLine(true, _contractLineNum, _projId, skipCategoryFilter, _categoryId);
            int itemTransactionCount = this.createItemTransactionsForTandMLine(true, _contractLineNum, _projId, skipCategoryFilter, _categoryId);
            int revenueTransactionCount = this.createRevenueTransactionsForTandMLine(_contractLineNum, _projId, skipCategoryFilter, _categoryId);
            int salesLineTransactionCount = this.createSalesLineTransactionsForTandMLine(_contractLineNum, _projId, skipCategoryFilter, _categoryId);

            activityContext.addCustomProperty('costTransactionCount', any2Str(costTransactionCount));
            activityContext.addCustomProperty('emplTransactionCount', any2Str(emplTransactionCount));
            activityContext.addCustomProperty('itemTransactionCount', any2Str(itemTransactionCount));
            activityContext.addCustomProperty('revenueTransactionCount', any2Str(revenueTransactionCount));
            activityContext.addCustomProperty('salesLineTransactionCount', any2Str(salesLineTransactionCount));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAllTransactionsForProgressLine</Name>
				<Source><![CDATA[
    private void createAllTransactionsForProgressLine(PSAContractLineNum _contractLineNum, ProjId _projId, ProjCategoryId _categoryId)
    {
        int emplTransactionCount = 0;
        int itemTransactionCount = 0;

        using (var activityContext = logger.projOpsFinActivity().featureInstrumentationContext(methodStr(ProjInvoiceProposalRuleCreateLines, createAllTransactionsForProgressLine)))
        {
            if (_categoryId)
            {
                emplTransactionCount = this.createEmplTransactionsForTandMLine(false, _contractLineNum, _projId, false, _categoryId);
                itemTransactionCount = this.createItemTransactionsForTandMLine(false, _contractLineNum, _projId, false, _categoryId);
            }

            activityContext.addCustomProperty('emplTransactionCount', any2Str(emplTransactionCount));
            activityContext.addCustomProperty('itemTransactionCount', any2Str(itemTransactionCount));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSkipContractLineSpecificCategorySetup</Name>
				<Source><![CDATA[
    private boolean shouldSkipContractLineSpecificCategorySetup(PSAContractLineNum _contractLineNum)
    {
        PSAContractLineItems contractLine;
        boolean skip = false; // if feature is disabled we never skip, we always use category setup associated with the contract line 

        if (this.isMultipleContractLinesForProjectEnabled)
        {
            select firstonly OverrideChargeableCategories from contractLine
                where contractLine.ContractLineNum == _contractLineNum;

            skip = !contractLine.OverrideChargeableCategories;
        }
        return skip;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransactionsForFeeLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create transactions for Fee.
    /// </summary>
    /// <param name="_contractLineNum">
    /// Identifier of the contract.
    /// </param>
    protected void createTransactionsForFeeLine(PSAContractLineNum _contractLineNum)
    {
        using (var activityContext = logger.projOpsFinActivity().featureInstrumentationContext(methodStr(ProjInvoiceProposalRuleCreateLines, createTransactionsForFeeLine)))
        {
            int candidateTransactionCount = 0;
            int doRevenueCallCount = 0;

            if (!ProjInvoiceProposalRulePeriodicTransTypeFilterFlight::instance().isEnabled()
            || proposalCreateLinesParams.parmIsQueryRevenueTrans())
            {
                ProjRevenueTrans projRevenueTrans;
                ProjRevenueTransSale projRevenueTransSale;
        
                PSAContractLineItems psaContractLineItems = PSAContractLineItems::find(_contractLineNum);
        
                while select projRevenueTrans
                where projRevenueTrans.ProjId == psaContractLineItems.FeeProjId
                      && projRevenueTrans.CategoryId == psaContractLineItems.FeeCategoryId
                      && projRevenueTrans.PSAContractLineNum == _contractLineNum
                      && (proposalCreateLinesParams.parmStartDate() == dateNull() || projRevenueTrans.TransDate >= proposalCreateLinesParams.parmStartDate())
                      && (proposalCreateLinesParams.parmEndDate() == dateNull()   || projRevenueTrans.TransDate <= proposalCreateLinesParams.parmEndDate())
                {
                    candidateTransactionCount++;

                    select firstonly projRevenueTransSale
                    where projRevenueTransSale.TransId == projRevenueTrans.TransId
                            && projRevenueTransSale.TransStatus == ProjTransStatus::Posted;

                    if (ProjTrans::newProjRevenueTransSale(projRevenueTrans, projRevenueTransSale).canBeInvoiced())
                    {
                        doRevenueCallCount++;
                        this.doRevenue(projRevenueTrans, _contractLineNum);
                    }
                }
            }

            activityContext.addCustomProperty('candidateTransactionCount', any2Str(candidateTransactionCount));
            activityContext.addCustomProperty('doRevenueCallCount', any2Str(doRevenueCallCount));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTmpProjProposalSummary</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the records that have been created in <c>PSATmpProjProposalSummary</c> table.
    /// </summary>
    /// <returns>
    /// Records that have been created in <c>PSATmpProjProposalSummary</c> table.
    /// </returns>
    PSATmpProjProposalSummary getTmpProjProposalSummary()
    {
        return projProposalSummary;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTmpProjProposalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the records that have been created in <c>PSATmpProjProposalTrans</c> table.
    /// </summary>
    /// <returns>
    /// Records that have been created in <c>PSATmpProjProposalTrans</c> table.
    /// </returns>
    PSATmpProjProposalTrans getTmpProjProposalTrans()
    {
        return proposalTransDisplay;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTmpProjProposalTransPreBill</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the deduction records that have been created in <c>PSATmpProjProposalTrans</c> table.
    /// </summary>
    /// <returns>
    /// Deduction records that have been created in <c>PSATmpProjProposalTrans</c> table.
    /// </returns>
    PSATmpProjProposalTrans getTmpProjProposalTransPreBill()
    {
        return proposalTransDisplayDeduction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates summary and transactions for a project contract.
    /// </summary>
    void run()
    {
        PSAContractLineItems        contractLineItems;
        Amount                      amount;

        using (SysInstrumentationActivityContext activityContext = logger.projOpsFinActivity().featureInstrumentationContext(methodStr(ProjInvoiceProposalRuleCreateLines, run)))
        {

            cdsLockingOptionCreateInvoiceProposals = ProjCDSLockingOptionTable::get(ProjCDSLockingOption::CreateInvoiceProposals);
            isMultipleContractLinesForProjectEnabled = ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled();
            filterbyProjIdEnabled = FeatureStateProvider::isFeatureEnabled(ProjBillingRulesInvoiceFilterbyProjIDFeature::instance());

            ttsbegin;

            int candidateContractLineItemCount = 0;
            int nonFeeLinesCount = 0;
            int feeLinesCount = 0;

            while select contractLineItems
            where contractLineItems.ProjInvoiceProjId == proposalCreateLinesParams.parmProjInvoiceProjId()
            {
                candidateContractLineItemCount++;

                if (contractLineItems.isLineTypeNotFee() && (!contractLineItems.FeeProjId || this.createInvoiceProposalProjStatusTypeRule(contractLineItems.FeeProjId)))
                {
                    nonFeeLinesCount++;

                    this.createProposalTransactions(contractLineItems);

                    this.createSummary(contractLineItems);
                }

            }

            this.createTransactionsForDeductionAndOnAcc(proposalCreateLinesParams.parmProjInvoiceProjId());

            while select contractLineItems
            where contractLineItems.ProjInvoiceProjId == proposalCreateLinesParams.parmProjInvoiceProjId() &&
                  contractLineItems.LineType          == PSAContractLineType::Fee
            {
                if (contractLineItems.FeeProjId && !this.createInvoiceProposalProjStatusTypeRule(contractLineItems.FeeProjId))
                {
                    continue;
                }

                feeLinesCount++;

                this.createProposalTransactions(contractLineItems);

                select firstonly RecId from proposalTransDisplay
                where proposalTransDisplay.ContractLineNum == contractLineItems.ContractLineNum;
                if (proposalTransDisplay)
                {
                    this.createSummary(contractLineItems);
                }

                amount = this.calFeeLineInvoiceAmount(contractLineItems.ContractLineNum);

                if (amount)
                {
                    projProposalSummary.clear();
                    this.createSummaryRecord(contractLineItems);
                    projProposalSummary.InvoiceAmount = amount;
                    projProposalSummary.update();
                }
            }

            ttscommit;

            activityContext.addCustomProperty('candidateContractLineItemCount', any2Str(candidateContractLineItemCount));
            activityContext.addCustomProperty('nonFeeLinesCount', any2Str(nonFeeLinesCount));
            activityContext.addCustomProperty('feeLinesCount', any2Str(feeLinesCount));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProposalTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create proposal transaction for existing project transactions.	
	/// </summary>
    /// <param name="contractLineItems">
    /// Instance of <c>PSAContractLineItems</c>
    /// </param>
    private void createProposalTransactions(PSAContractLineItems contractLineItems)
    {
        using (var activityContext = logger.projOpsFinActivity().featureInstrumentationContext(methodStr(ProjInvoiceProposalRuleCreateLines, createProposalTransactions)))
        {
            activityContext.addCustomProperty('filterbyProjIdEnabled', any2Str(filterbyProjIdEnabled));
            activityContext.addCustomProperty('isMultipleContractLinesForProjectEnabled', any2Str(isMultipleContractLinesForProjectEnabled));

            // Create proposal transactions for the selected project when multiple contract lines for project feature is enabled.
            if (proposalCreateLinesParams.parmProjId() && (filterbyProjIdEnabled || isMultipleContractLinesForProjectEnabled))
            {
                this.createTransactionsV2(contractLineItems.ContractLineNum, contractLineItems.LineType, proposalCreateLinesParams.parmProjId());
            }
            else
            {
                this.createTransactions(contractLineItems.ContractLineNum, contractLineItems.LineType);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateContractLineNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates revenue records, updates contact line number.
    /// </summary>
    public void updateContractLineNum()
    {
        ProjEmplTrans                       projEmplTrans;
        ProjCostTrans                       projCostTrans;
        ProjItemTrans                       projItemTrans;
        SalesLine                           salesLine;
        ProjRevenueTrans                    projRevenueTrans;
        ProjOnAccTrans                      projOnAccTrans;
        PSAContractLineItems                psaContractLineItems;

        using (var activityContext = logger.projOpsFinActivity().featureInstrumentationContext(methodStr(ProjInvoiceProposalRuleCreateLines, updateContractLineNum)))
        {
            int projProposalSummaryCount = 0;
            int createProposalForOnAccTransCallCount = 0;
            int createProposalForRevenueTransCallCount = 0;
            int proposalTransCreateCount = 0;

            while select projProposalSummary
            order by ContractLineNum
            where projProposalSummary.Selected == NoYes::Yes
            {
                projProposalSummaryCount++;

                psaContractLineItems = PSAContractLineItems::find(projProposalSummary.ContractLineNum);

                if (psaContractLineItems.LineType == PSAContractLineType::Progress ||
                psaContractLineItems.LineType == PSAContractLineType::Fee      ||
                psaContractLineItems.LineType == PSAContractLineType::UOD)
                {
                    if (psaContractLineItems.isBillingRuleForFixedPriceProject())
                    {
                        createProposalForOnAccTransCallCount++;
                        projOnAccTrans = this.createProposalForOnAccTrans(psaContractLineItems);
                    }
                    else
                    {
                        createProposalForRevenueTransCallCount++;
                        projRevenueTrans = this.createProposalForRevenueTrans();
                    }
                }
                else
                {
                    while select proposalTransCreate
                    where proposalTransCreate.ContractLineNum == projProposalSummary.ContractLineNum
                       && proposalTransCreate.Selected == NoYes::Yes
                    {
                        proposalTransCreateCount++;

                        switch (proposalTransCreate.TransType)
                        {
                            case ProjTransType::Cost:
                                projCostTrans = ProjCostTrans::find(proposalTransCreate.RefTransId, true);
                                if (projCostTrans)
                                {
                                    projCostTrans.psaContractLineNum = projProposalSummary.ContractLineNum;
                                    projCostTrans.update();
                                }
                                break;

                            case ProjTransType::Hour:
                                projEmplTrans = ProjEmplTrans::find(proposalTransCreate.RefTransId, true);
                                if (projEmplTrans)
                                {
                                    projEmplTrans.psaContractLineNum = projProposalSummary.ContractLineNum;
                                    projEmplTrans.update();
                                }
                                break;

                            case ProjTransType::Item:
                                projItemTrans = ProjItemTrans::find(proposalTransCreate.RefTransId, true);
                                if (projItemTrans)
                                {
                                    projItemTrans.psaContractLineNum = projProposalSummary.ContractLineNum;
                                    projItemTrans.update();
                                }
                                salesLine = SalesLine::findInventTransId(proposalTransCreate.RefTransId, true);
                                if (salesLine)
                                {
                                    salesLine.psaContractLineNum = projProposalSummary.ContractLineNum;
                                    salesLine.update();
                                }
                                break;

                            case ProjTransType::Revenue:
                                projRevenueTrans = ProjRevenueTrans::find(proposalTransCreate.RefTransId, true);
                                if (projRevenueTrans)
                                {
                                    projRevenueTrans.psaContractLineNum = projProposalSummary.ContractLineNum;
                                    projRevenueTrans.update();
                                }
                                break;

                            case ProjTransType::OnAccount:
                                projOnAccTrans = ProjOnAccTrans::find(proposalTransCreate.RefTransId, true);
                                if (projOnAccTrans)
                                {
                                    projOnAccTrans.psaContractLineNum = projProposalSummary.ContractLineNum;
                                    projOnAccTrans.update();
                                }
                                break;
                        }

                        PSAContractLineItemsServer::updateUnitsOrPercentProposal(projProposalSummary.ContractLineNum, NoYes::Yes);
                    }
                }
            }

            activityContext.addCustomProperty('projProposalSummaryCount', any2Str(projProposalSummaryCount));
            activityContext.addCustomProperty('createProposalForOnAccTransCallCount', any2Str(createProposalForOnAccTransCallCount));
            activityContext.addCustomProperty('createProposalForRevenueTransCallCount', any2Str(createProposalForRevenueTransCallCount));
            activityContext.addCustomProperty('proposalTransCreateCount', any2Str(proposalTransCreateCount));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static ProjInvoiceProposalRuleCreateLines construct()
    {
        return new ProjInvoiceProposalRuleCreateLines();
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateFeeJournalAndPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Generate one fee journal and post the fee journal.
    /// </summary>
    /// <param name="_sContractLineNum">
    /// An identifier representing a record in <c>PSAContractLineItems</c> table.
    /// </param>
    /// <param name="_rInvoiceAmount">
    /// Amount to be invoiced.
    /// </param>
    /// <returns>
    /// A record in <c>ProjRevenueTrans</c> table.
    /// </returns>
    public static ProjRevenueTrans generateFeeJournalAndPost(PSAContractLineNum _sContractLineNum, Amount _rInvoiceAmount)
    {
        ProjJournalTable                    projJournalTable;
        ProjJournalTrans                    projJournalTrans;
        ProjJournalName                     projJournalName;
        ProjParameters                      projParameters;
        ProjJournalNameId                   projJournalNameId;
        NumberSeq                           numberSeq;
        ProjJournalCheckPost                projJournalCheckPost;
        PSAContractLineItems                tpsaContractLineItems;

        ProjRevenueTrans                    projRevenueTrans;
        ProjTable                           projTable;
        List                                dimensionSources = new List(Types::Class);

        using (var activityContext = logger.projOpsFinActivity().featureInstrumentationContext(staticMethodStr(ProjInvoiceProposalRuleCreateLines, generateFeeJournalAndPost)))
        {
            if (_rInvoiceAmount == 0.0)
            {
                return null;
            }

            //Get initial parameters
            projParameters = ProjParameters::find();
            projJournalNameId = projParameters.ContractLineFeeJournalNameId;
            if (!projJournalNameId)
            {
                throw error("@PSA3116");
            }
            projJournalName = ProjJournalName::find(projJournalNameId);

            tpsaContractLineItems = PSAContractLineItems::find(_sContractLineNum);
            if (tpsaContractLineItems)
            {
                if (!tpsaContractLineItems.FeeProjId)
                {
                    throw error("@PSA3117");
                }
                if (!tpsaContractLineItems.FeeCategoryId)
                {
                    throw error("@PSA3118");
                }
                dimensionSources.addEnd(LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(tpsaContractLineItems.DefaultDimension));
            }
            else
            {
                throw error("@PSA3119");
            }

            //create the fee journal
            projJournalTable.initFromProjJournalName(projJournalName);

            projJournalTable.insert();

            //create the fee transaction line
            projJournalTrans.initFromProjJournalTable(projJournalTable);

            numberSeq = NumberSeq::newGetVoucherFromCode(projJournalTable.getNumberSequenceTable().NumberSequence);
            projJournalTrans.Voucher = numberSeq.voucher();
            projJournalTrans.ProjTransDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
            projJournalTrans.TransDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
            projJournalTrans.ProjId = tpsaContractLineItems.FeeProjId;
            projTable = ProjTable::find(tpsaContractLineItems.FeeProjId);
            if (projTable)
            {
                projJournalTrans.initFromProjTable(projTable);
                dimensionSources.addEnd(LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(projTable.DefaultDimension));
            }

            // Defaulting Dimensions from Billing rule and then project.
            projJournalTrans.DefaultDimension = LedgerDimensionDefaultingEngine::getDefaultDimension(dimensionSources);

            // To get line property from Project/Category group
            projJournalTrans.LinePropertyId = ProjLinePropertySetup::findLinePropertyId(tpsaContractLineItems.FeeProjId, tpsaContractLineItems.FeeCategoryId);

            //
            // Do not use the standard call of ProjParameters::taxItemGroupItem(tpsaContractLineItems.FeeCategoryId, '');
            // to get the taxItemGroup.  ProjParameters may indicate to retrieve the value from the item which is not
            // valid for a billing rule fee transaction.
            //
            projJournalTrans.TaxItemGroupId = ProjCategory::find(tpsaContractLineItems.FeeCategoryId).TaxItemGroupId;
            projJournalTrans.TaxGroupId     = tpsaContractLineItems.SalesTaxGroup;
            projJournalTrans.CategoryId     = tpsaContractLineItems.FeeCategoryId;
            projJournalTrans.SalesPrice     = _rInvoiceAmount;
            projJournalTrans.Qty            = 1;
            projJournalTrans.Txt            = tpsaContractLineItems.LineDesc;

            // Create the fee transaction extension line
            if (TaxParameters::checkTaxParameters_IN())
            {
                ProjJournalTransTaxExtensionIN      projJournalTrans_IN;
                PSAContractLineItemsTaxExtensionIN  psaContractLineItemsTaxExtensionIN;

                psaContractLineItemsTaxExtensionIN  = PSAContractLineItemsTaxExtensionIN::findByPSAContractLineItems(tpsaContractLineItems.RecId);
                projJournalTrans_IN                 = projJournalTrans.projJournalTransTaxExtensionIN();

                projJournalTrans_IN.TDSGroup           = psaContractLineItemsTaxExtensionIN.TDSGroup;
                projJournalTrans_IN.TCSGroup           = psaContractLineItemsTaxExtensionIN.TCSGroup;
                projJournalTrans_IN.MaximumRetailPrice = psaContractLineItemsTaxExtensionIN.MaximumRetailPrice;

                projJournalTrans_IN.assessableValue(projJournalTrans);
                projJournalTrans.packProjJournalTrans_IN(projJournalTrans_IN);
            }

            projJournalTrans.insert();

            if (TaxIntegrationUtils::isTaxInformationEnabled())
            {
                TransTaxInformationHelper::copyTransTaxInformation(tpsaContractLineItems, projJournalTrans);
            }

            //update the fee journal
            ProjJournalTable::initTotal(projJournalTable);
            projJournalTable.update();

            //Post the fee journal
            projJournalCheckPost = ProjJournalCheckPost::newJournalCheckPost(true,
                                                                          false,
                                                                          JournalCheckPostType::Post,
                                                                          tableNum(ProjJournalTable),
                                                                          projJournalTable.JournalId);
            projJournalCheckPost.parmPsaContractLineNum(_sContractLineNum);
            projJournalCheckPost.runOperation();

            select firstonly projRevenueTrans
            where projRevenueTrans.VoucherJournal == projJournalTrans.Voucher;
        }

        return projRevenueTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newStandard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create and returns an instance of <c>ProjInvoiceProposalRuleCreateLines</c> class.
    /// </summary>
    /// <param name="_params">
    /// A packed instance of <c>ProjInvoiceProposalCreateLinesParams</c> class.
    /// </param>
    /// <returns>
    /// Returns an instance of <c>ProjInvoiceProposalRuleCreateLines</c> class.
    /// </returns>
    public static ProjInvoiceProposalRuleCreateLines newStandard(container _params)
    {
        ProjInvoiceProposalRuleCreateLines   createLines       = ProjInvoiceProposalRuleCreateLines::construct();
        ProjInvoiceProposalCreateLinesParams createLinesParams = ProjInvoiceProposalCreateLinesParams::construct();

        createLinesParams.unpack(_params);

        createLines.parmProposalCreateLinesParams(createLinesParams);

        return createLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recalcFeeLineAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Recalculates fee amount.
    /// </summary>
    /// <param name="_contractLineNum">
    /// Identifier of the billing rule.
    /// </param>
    /// <returns>
    /// Fee amount.
    /// </returns>
    public Amount recalcFeeLineAmount(PSAContractLineNum _contractLineNum)
    {
        return this.calFeeLineInvoiceAmount(_contractLineNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInvoiceProposalProjStatusTypeRule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check for invoice proposal rule if it is available for the project or not.
    /// If invoice proposal rule is enabled then creates create the invoice proposal lines.
    /// </summary>
    /// <param name="_projId">
    /// Identifier of the Project.
    /// </param>
    /// <returns>
    /// Returns true when record exists in <c>ProjStatusTypeRule</c> table; otherwise false.
    /// </returns>
    private boolean createInvoiceProposalProjStatusTypeRule(ProjId _projId)
    {
        if (_projId)
        {
            ProjTable projTable = ProjTable::find(_projId);
            projType = projTable.Type;

            if (ProjStatusTypeRule::exist(projTable.Status, projTable.Type, ProjStatusRule::CreateInvoiceProposal))
            {
                return true;
            }
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRevenueTransLineBeUpdated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a revenue transaction can be updated.
    /// </summary>
    /// <param name = "_contractLineItems">
    /// An instance of <c>PSAContractLineItems</c> table buffer.
    /// </param>
    /// <returns>
    /// true if the transaction can be updated; otherwise, false.
    /// </returns>
    private boolean canRevenueTransLineBeUpdated(PSAContractLineItems _contractLineItems)
    {
        PSAUnitsUpdateLog psaUnitsUpdateLog;
        PSAPercentUpdateLog psaPercentUpdateLog;
        boolean ret;

        if (_contractLineItems.LineType == PSAContractLineType::UOD)
        {
            select firstonly RecId from psaUnitsUpdateLog
                where psaUnitsUpdateLog.ContractLineNum == _contractLineItems.ContractLineNum
                    && psaUnitsUpdateLog.IsInvoiced == NoYes::No
                    && psaUnitsUpdateLog.IsProposal == NoYes::No;

            if (psaUnitsUpdateLog.RecId)
            {
                ret = true;
            }
        }
        else if (_contractLineItems.LineType == PSAContractLineType::Progress)
        {
            select firstonly RecId from psaPercentUpdateLog
                where psaPercentUpdateLog.ContractLineNum == _contractLineItems.ContractLineNum
                    && psaPercentUpdateLog.IsInvoiced == NoYes::No
                    && psaPercentUpdateLog.IsProposal == NoYes::No;

            if (psaPercentUpdateLog.RecId)
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>