<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>JmgTermJob_Prod</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>JmgTermJob_Prod</c> class represents production type jobs.
/// </summary>
/// <remarks>
///    Depending on the shop floor control parameter setup, these jobs originate from either the
///    <c>ProdRoute</c> table, which has a job level of route, or the <c>ProdRouteJob</c> table, which has
///    a job level of job.Instances of this class represent production type jobs.
/// </remarks>
class JmgTermJob_Prod extends JmgTermJob
{
    ProdRoute       prodRoute;
    ProdRouteJob    prodRouteJob;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>actOprId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Used to retrieve the operation or activity ID of the job.
    /// </summary>
    /// <returns>
    ///    The operation or activity ID of the job.
    /// </returns>
    /// <remarks>
    ///    For production jobs, this is the operation ID.
    /// </remarks>
    public JmgActOprID actOprId()
    {
        JmgActOprID ret;

        ret = super();

        ret = prodRoute.operationName();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allow</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves whether employees can create registrations on the job.
    /// </summary>
    /// <returns>
    ///    true if employees can make registrations on the job; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    For production jobs, the return value is determined by the Shop Floor Control parameter setup. Here
    ///    you can specify which types of production jobs the parameter setup can register on.
    /// </remarks>
    boolean allow()
    {
        JmgProdParameters   jmgProdParameters;
        ProdTable           prodTable       = ProdTable::find(prodRoute.ProdId);

        if (prodTable.status().isBefore(ProdStatus::Released) || prodTable.status().isAfter(ProdStatus::StartedUp))
        {
            return false;
        }

        if (prodRouteJob && prodRouteJob.JobStatus == ProdJobStatus::Completed)
        {
            return false;
        }

        jmgProdParameters = JmgProdParameters::find();
        if (jmgProdParameters.StampLevel == JmgStampLevel::Job)
        {
            return JmgProdParametersDim::find(this.siteInventDimId()).allowJobType(prodRouteJob.JobType);
        }

        if (jmgProdParameters.StampLevel == JmgStampLevel::Route)
        {
            if (jobid == prodRoute.JobIdSetup)
            {
                return JmgProdParametersDim::find(this.siteInventDimId()).allowJobType(RouteJobType::Setup);
            }

            if (jobid == prodRoute.JobIdProcess)
            {
                return JmgProdParametersDim::find(this.siteInventDimId()).allowJobType(RouteJobType::Process);
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the calculated quantity for this production job.
    /// </summary>
    /// <returns>
    ///    The calculated quantity for this production job.
    /// </returns>
    public RouteOprQtyToOpr calcQty()
    {
        return prodRoute.CalcQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTimeHours</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the calculated time in hours for this production job.
    /// </summary>
    /// <returns>
    ///    The calculated time in hours for this production job.
    /// </returns>
    public RouteJobCalcTimeHours calcTimeHours()
    {
        if (prodRouteJob)
        {
            return prodRouteJob.CalcTimeHours;
        }

        if (prodRoute.JobIdProcess  == jobid)
        {
            return prodRoute.CalcProc;
        }

        if (prodRoute.JobIdSetup    == jobid)
        {
            return prodRoute.CalcSetUp;
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimatedHours</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the estimated job time.
    /// </summary>
    /// <returns>
    ///    The estimated job time.
    /// </returns>
    public Hours estimatedHours()
    {
        return this.calcTimeHours();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSourceData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads the source data into memory. The job is based either on a <c>ProdRouteJob</c> record or a
    ///    <c>ProdRoute</c> record. This method is part of the initialization procedure of an instance.
    /// </summary>
    /// <param name="_jmgJobTable">
    ///    The <c>JmgJobTable</c> record that has the corresponding job ID.
    /// </param>
    /// <param name="_sourceData">
    ///    If the source data has already been fetched from the database, the source data can be supplied as a
    ///    parameter; optional.
    /// </param>
    /// <remarks>
    ///    For a code example that uses the <c>initSourceData</c> method, see the <see
    ///    cref="M:JmgTermJob.initSourceData" />.
    /// </remarks>
    protected void initSourceData(JmgJobTable _jmgJobTable, Common _sourceData = null)
    {
        if (_sourceData && _sourceData.TableId == tablenum(ProdRoute))
        {
            prodRoute = _sourceData;
        }
        else if (_sourceData && _sourceData.TableId == tablenum(ProdRouteJob))
        {
            prodRouteJob = _sourceData;
            prodRoute = prodRouteJob.prodRoute(selectSourceDataForUpdate);
        }
        else
        {
            switch (JmgProdParameters::find().StampLevel)
            {
                case JmgStampLevel::Route:
                    prodRoute       = ProdRoute::findJobId(_jmgJobTable.JobId, selectSourceDataForUpdate);
                    break;
                case JmgStampLevel::Job:
                    prodRouteJob    = ProdRouteJob::findJobId(_jmgJobTable.JobId, selectSourceDataForUpdate);
                    prodRoute       = prodRouteJob.prodRoute(selectSourceDataForUpdate);
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>jobDescription</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a job description, which is the route name associated with the production job.
    /// </summary>
    /// <returns>
    ///    The description associated with the job.
    /// </returns>
    public JmgDescription jobDescription()
    {
        return RouteOprTable::find(prodRoute.OprId).Name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>jobRef</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the job reference for this job. For a production job, this is the production ID.
    /// </summary>
    /// <returns>
    ///    The production ID associated with the job.
    /// </returns>
    JmgJobRef jobRef()
    {
        return prodRoute.ProdId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>jobStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the status of the job.
    /// </summary>
    /// <returns>
    ///    The status of the job.
    /// </returns>
    public JmgJobStatus jobStatus()
    {
        JmgJobStatus ret;

        ret = super();

        if (ret == JmgJobStatus::NotAvailable)
        {
            if (this.reportedFinish())
            {
                ret = JmgJobStatus::Completed;
            }
            else if (this.reportedStarted())
            {
                ret = JmgJobStatus::Started;
            }
            else if (this.reportedWaiting())
            {
                ret = JmgJobStatus::Waiting;
            }
            else
            {
                ret = JmgJobStatus::Created;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>jobStatusByWorker</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Returns job status for the specified worker.
    /// </summary>
    /// <param name = "_worker">
    ///  The Worker of the <c>JmgEmployee</c> record.
    /// </param>
    /// <returns>
    ///  Return JmgJobStatus::InProgress if an Active <c>JmgTermJob</c> record for the specified worker and Job is found, otherwise return JmgJobStatus::NotAvailable.
    /// </returns>
    public JmgJobStatus jobStatusByWorker(JmgWorkerRecId _worker)
    {
        JmgTermReg   jmgTermReg;

        jmgTermReg.recordLevelSecurity(true);

        select firstonly RecId
            from  jmgTermReg
            where jmgTermReg.JobId      == jmgJobTable.JobId   &&
                  jmgTermReg.Worker     == _worker             &&
                  jmgTermReg.JobActive  == NoYes::Yes;

        if (jmgTermReg.RecId != 0)
        {
            return JmgJobStatus::InProgress;
        }

        return JmgJobStatus::NotAvailable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>jourRegType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the journal registration type that this kind of job corresponds to. For production jobs,
    ///    the job type is translated to the corresponding journal registration type.
    /// </summary>
    /// <returns>
    ///    The type of journal line to create when registering on this kind of job.
    /// </returns>
    /// <remarks>
    ///    For a code example that uses the <c>jourRegType</c> method, see <see
    ///    cref="M:JmgTermJob.jourRegType" />.
    /// </remarks>
    public JmgJourRegType jourRegType()
    {
        JmgJourRegType ret;

        switch (this.prodJobType())
        {
            case RouteJobType::Overlap:
                ret = JmgJourRegTypeEnum::MrpOverlap;
                break;
            case RouteJobType::Process:
                ret = JmgJourRegTypeEnum::MrpProcess;
                break;
            case RouteJobType::QueueAfter:
                ret = JmgJourRegTypeEnum::MrpQueueAfter;
                break;
            case RouteJobType::QueueBefore:
                ret = JmgJourRegTypeEnum::MrpQueueBefore;
                break;
            case RouteJobType::Setup:
                ret = JmgJourRegTypeEnum::MrpSetup;
                break;
            case RouteJobType::Transport:
                ret = JmgJourRegTypeEnum::MrpTransport;
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>makeFeebackProceedPerWorker</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reports feedback based on the selected worker on the selected date and time.
    /// </summary>
    /// <param name="_worker">
    /// A reference <c>JmgWorkerRecId</c> to the specified worker
    /// </param>
    /// <param name="_registrationParameters">
    /// An instance of <c>JmgRegistrationParameters</c> class that contains all feedback information.
    /// </param>
    /// <param name="_regDate">
    /// An expected <c>JmgDate</c> date of registration.
    /// </param>
    /// <param name="_regTime">
    /// An expected <c>JmgTime</c> time of registration.
    /// </param>
    protected void makeFeebackProceedPerWorker(JmgWorkerRecId _worker, JmgRegistrationParameters _registrationParameters, JmgDate _regDate, JmgTime _regTime)
    {
        JmgTermReg  startJobRegistration;

        select firstonly forupdate startJobRegistration
            where startJobRegistration.JobId    == this.jobid()
            &&  startJobRegistration.Worker     == _worker
            &&  startJobRegistration.RegType    == JmgTermRegType::JobStart
            &&  startJobRegistration.JobActive  == NoYes::Yes;

        if (startJobRegistration)
        {
            if (_registrationParameters.reportAsFinished() == JmgFeedbackStatus::InProgress)
            {
                this.updateTermReg(startJobRegistration, _registrationParameters);
            }
            else
            {
                this.makeRegistration(_worker, _regDate, _regTime, false, _registrationParameters);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>makeFeedback</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reports feedback for the current job
    /// </summary>
    /// <param name="_worker">
    /// A reference <c>JmgWorkerRecId</c> value of the specified worker who is working on the current job.
    /// </param>
    /// <param name="_registrationParameters">
    /// An instance of the <c>JmgRegistrationParameters</c> class, which holds all feedback information.
    /// </param>
    /// <param name="_regDate">
    /// An expected <c>JmgDate</c> date of registration.
    /// </param>
    /// <param name="_regTime">
    /// An expected <c>JmgTime</c> time of registration.
    /// </param>
    /// <remarks>
    /// Use this method to enter feedback regarding the number of good items that are produced, the number
    /// of scrap items, and whether the job is finished. If the user has indicated that they are no longer
    /// working on the job, a stop job registration will be inserted.This method is only used with
    /// production jobs because these are the only type of jobs on which feedback can be made.
    /// </remarks>
    public void makeFeedback(JmgWorkerRecId _worker, JmgRegistrationParameters _registrationParameters, JmgDate _regDate, JmgTime _regTime)
    {
        JmgTermReg                  jmgTermReg;
        JmgJobBundle                jmgJobBundleLocal;
        JmgRegistrationParameters   regParamLocal;

        ttsbegin;

        // make feedback for the current worker first
        this.makeFeebackProceedPerWorker(_worker, _registrationParameters, _regDate, _regTime);

        if (_registrationParameters.reportAsFinished() == JmgFeedbackStatus::Completed)
        {
            // find all "in progress" activities for the other workers for the current job
            while select Worker from jmgTermReg
            where jmgTermReg.JobId      == this.jobid()
            &&    jmgTermReg.Worker     != _worker
            &&    jmgTermReg.JobActive  == NoYes::Yes
            {
                jmgJobBundleLocal = new JmgJobBundle(jmgTermReg.Worker, false, false, false);
                regParamLocal = jmgJobBundleLocal.getFeedbackParameters(this.jobid());
                regParamLocal.reportAsFinished(JmgFeedbackStatus::Stopped);
                jmgJobBundleLocal.makeFeedbackOnActiveJobs(_regDate, _regTime);
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>makeRegistration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a start or a stop job registration on this job.
    /// </summary>
    /// <param name="_worker">
    /// The worker that is making the registration.
    /// </param>
    /// <param name="_date">
    /// The date of the registration.
    /// </param>
    /// <param name="_time">
    /// The time of the registration.
    /// </param>
    /// <param name="_start">
    /// Boolean indicates whether it should be a start registration; optional.
    /// </param>
    /// <param name="_registrationParameters">
    /// An additional registration parameter that is used to make the registration; optional.
    /// </param>
    /// <param name="_autoStamp">
    /// A <c>NoYes</c> indicates whether this registration is made by an employee; optional.
    /// </param>
    public void makeRegistration(
        JmgWorkerRecId              _worker,
        JmgDate                     _date,
        JmgTime                     _time,
        boolean                     _start = true,
        JmgRegistrationParameters   _registrationParameters = new JmgRegistrationParameters(),
        NoYes                       _autoStamp = NoYes::No)
    {
        ttsbegin;
        this.insertTermReg(_worker, _date, _time, _start, _registrationParameters, _autoStamp);
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTermReg</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a start or a stop job registration on this job.
    /// </summary>
    /// <param name="_worker">
    /// The worker that is making the registration.
    /// </param>
    /// <param name="_date">
    /// The date of the registration.
    /// </param>
    /// <param name="_time">
    /// The time of the registration.
    /// </param>
    /// <param name="_start">
    /// Boolean indicates whether it should be a start registration.
    /// </param>
    /// <param name="_registrationParameters">
    /// An additional registration parameter that is used to make the registration.
    /// </param>
    /// <param name="_autoStamp">
    /// A <c>NoYes</c> indicates whether this registration is made by an employee.
    /// </param>
    /// <returns>
    /// The inserted <c>JmgTermReg</c> buffer.
    /// </returns>
    protected internal JmgTermReg insertTermReg(
        JmgWorkerRecId              _worker,
        JmgDate                     _date,
        JmgTime                     _time,
        boolean                     _start,
        JmgRegistrationParameters   _registrationParameters,
        NoYes                       _autoStamp)
    {
        JmgTermReg jmgTermReg;

        this.initCommon(jmgTermReg, _worker, _date, _time, _autoStamp, _registrationParameters);
        if (_start)
        {
            jmgTermReg.RegType              = JmgTermRegType::JobStart;
            jmgTermReg.StartItems           = _registrationParameters.startQuantity();
            jmgTermReg.PdsCWStartItems      = _registrationParameters.pdsCWStartQuantity();

            if (this.canUpdateProdRouteJob(jobid))
            {
                JmgTermJob_Prod::setProdRouteJobStatusToStarted(jobid);
            }
        }
        else
        {
            jmgTermReg.RegType = JmgTermRegType::JobStop;
            jmgTermReg.updateFeedbackData(_registrationParameters);
        }
        jmgTermReg.ResNo                = _registrationParameters.wrkCtrId();
        jmgTermReg.insert();

        return jmgTermReg;
    }

]]></Source>
			</Method>
			<Method>
				<Name>module</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the module where the job originated. Always returns <c>JmgModuleEnum::Prod</c>.
    /// </summary>
    /// <returns>
    ///    The module where the job originated, which is <c>JmgModuleEnum::Prod</c>.
    /// </returns>
    /// <remarks>
    ///    For a code example that uses the <c>module</c> method, see <see cref="M:JmgTermJob.module" />.
    /// </remarks>
    JmgModuleEnum module()
    {
        return JmgModuleEnum::PROD;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new instance of the <see cref="T:JmgTermJob_Prod" />.
    /// </summary>
    /// <param name="_forUpdate">
    ///    Denotes whether to select the <c>ProdRoute</c> or <c>ProdRouteJob</c> for update.
    /// </param>
    /// <remarks>
    ///    The <c>new</c> method of the <c>JmgTermJob_Prod</c> class should not be used. Instead, use either
    ///    the <see cref="M:JmgTermJob::construct" /> method or the <see
    ///    cref="M:JmgTermJob::constructJobTable" /> method to create instances of the <c>JmgTermReg_Prod</c>
    ///    class.
    /// </remarks>
    void new(boolean _forUpdate = false)
    {
        super();
        selectSourceDataForUpdate = _forUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>oprPriority</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the operation priority that is associated with the production job.
    /// </summary>
    /// <returns>
    ///    The operation priority that is associated with the production job.
    /// </returns>
    public RouteOprPriority oprPriority()
    {
        if (prodRouteJob)
        {
            return prodRouteJob.OprPriority;
        }
        return prodRoute.OprPriority;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWCalcQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the calculated quantity for this production job.
    /// </summary>
    /// <returns>
    ///    The calculated quantity for this production job.
    /// </returns>
    public PdsCWInventQty pdsCWCalcQty()
    {
        return PdsCatchWeight::cwQty(prodRoute.prodTable().ItemId, prodRoute.CalcQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWQtyError</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the number of catch weight error items reported on the production job.
    /// </summary>
    /// <returns>
    ///    The number of catch weight  error items reported on the production job.
    /// </returns>
    /// <remarks>
    ///    The information is fetched from the shop floor control module, not the production module.
    /// </remarks>
    public PdsCWBatchErr pdsCWQtyError()
    {
        PdsCWBatchErr               ret = 0;
        JmgStampJournalTrans        stampJournalTrans;
        JmgStampTrans               stampTrans;

        while select JobId, ErrorSpecification from stampJournalTrans
            where stampJournalTrans.JobId == jobid
        {
            ret += JmgErrorSpecificationForm::getTotalPdsCWErrorQuantity(stampJournalTrans.ErrorSpecification);
        }

        while select JobId, ErrorSpecification from stampTrans
            where stampTrans.JobId == jobid
        {
            ret += JmgErrorSpecificationForm::getTotalPdsCWErrorQuantity(stampTrans.ErrorSpecification);
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWQtyGood</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the number of catch weight good items reported on the production job.
    /// </summary>
    /// <returns>
    ///    The number of catch weight good items reported on the production job.
    /// </returns>
    /// <remarks>
    ///    The information is fetched from the shop floor control module, not the production module.
    /// </remarks>
    public PdsCWBatchGood pdsCWQtyGood()
    {
        PdsCWBatchGood ret;

        ret = (select firstonly sum(PdsCWQtyGood) from jmgStampJournalTrans
                   where jmgStampJournalTrans.JobId == jobid).PdsCWQtyGood;

        ret += (select firstonly sum(PdsCWQtyGood) from jmgStampTrans
                    where jmgStampTrans.JobId == jobid).PdsCWQtyGood;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfCanHaveCoProducts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the job can have co-product outputs.
    /// </summary>
    /// <returns>
    /// true if the job can have co-product outputs; otherwise, false .
    /// </returns>
    public boolean pmfCanHaveCoProducts()
    {
        return InventTable::find(jmgJobTable.ItemId).isFormulaAllowed();
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasCoByProducts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether there are any co- and/or by-products associated with the order.
    /// </summary>
    /// <returns>true if there are co- and/or by-products associated with the order; otherwise, false.</returns>
    [Hookable(false)]
    public boolean hasCoByProducts()
    {
        if (this.pmfCanHaveCoProducts())
        {
            return PmfProdCoBy::existProdId(this.jobRef());
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPmfCoByProductVariationAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates the current production order allows for variations of the co-products as outputs of
    /// the production.
    /// </summary>
    /// <returns>true if the order allows for variations of the outputs; otherwise, false.</returns>
    [Hookable(false)]
    public boolean isPmfCoByProductVariationAllowed()
    {
        return this.prodRoute().prodTable().PmfCoByVarAllow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prodJobType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the job type of this production job.
    /// </summary>
    /// <returns>
    ///    The job type of this production job.
    /// </returns>
    public RouteJobType prodJobType()
    {
        RouteJobType ret;
        if (prodRouteJob)
        {
            ret = prodRouteJob.JobType;
        }
        else if (prodRoute.JobIdSetup == this.jobId())
        {
            ret = RouteJobType::Setup;
        }
        else
        {
            ret = RouteJobType::Process;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a item Id, which is associated with the production job.
    /// </summary>
    /// <returns>
    ///    The Item Id associated with the job.
    /// </returns>
    [Hookable(false)]
    internal ItemId itemId()
    {
        return jmgJobTable.ItemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prodRoute</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the <c>ProdRoute</c> record that this job is associated with.
    /// </summary>
    /// <returns>
    ///    The <c>ProdRoute</c> record that this job is associated with.
    /// </returns>
    /// <remarks>
    ///    If the job originates from a <c>ProdRouteJob</c> record, the value of the <see
    ///    cref="M:ProdRouteJob.ProdRoute" /> method is returned. If the returned <c>ProdRoute</c> record
    ///    should be selected for update, set the <paramref name="_forUpdate" /> parameter when you use either
    ///    the <c>JmgTermJob::construct</c> method or the <c>JmgTermJob::constructJobTable</c> method.
    /// </remarks>
    ProdRoute prodRoute()
    {
        return prodRoute;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prodRouteJob</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the <c>ProdRouteJob</c> record that this job is associated with.
    /// </summary>
    /// <returns>
    ///    The <c>ProdRouteJob</c> record that this job is associated with.
    /// </returns>
    ProdRouteJob prodRouteJob()
    {
        return prodRouteJob;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyError</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the number of error items reported on the production job.
    /// </summary>
    /// <returns>
    ///    The number of error items reported on the production job.
    /// </returns>
    /// <remarks>
    ///    The information is fetched from the shop floor control module, not the production module.
    /// </remarks>
    public ProdReportedError qtyError()
    {
        return (JmgJobStatusFactory::buildJmgJobStatusInstance()).calculateErrorQty(jobid);
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyGood</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the number of good items reported on the production job.
    /// </summary>
    /// <returns>
    ///    The number of good items reported on the production job.
    /// </returns>
    /// <remarks>
    ///    The information is fetched from the shop floor control module, not the production module.
    /// </remarks>
    public ProdReportedGood qtyGood()
    {
        return (JmgJobStatusFactory::buildJmgJobStatusInstance()).calculateGoodQty(jobid);
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyStarted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the reported started quantity for the production job.
    /// </summary>
    /// <returns>
    /// The reported started quantity for the production job.
    /// </returns>
    public ProdQtyStUp qtyStarted()
    {
        return (JmgJobStatusFactory::buildJmgJobStatusInstance()).calculateStartQty(jobid);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reportedFinish</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves whether the job is reported as finished.
    /// </summary>
    /// <returns>
    ///    true if an employee has reported the job as finished; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    For a code example that uses the <c>reportedFinish</c> method, see the <see
    ///    cref="M:JmgTermJob.reportedFinish" />.
    /// </remarks>
    boolean reportedFinish()
    {
        boolean ret;

        ret = super();

        if (ret)
            return true;

        if (prodRouteJob && (prodRouteJob.JobStatus == ProdJobStatus::Completed))
            return true;

        return (prodRoute.OprFinished == NoYes::Yes);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reportedStarted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves whether the job has been reported as started.
    /// </summary>
    /// <returns>
    ///    true if the job has been started; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    For a production job to be reported as started, the production that the production job is
    ///    associated with must be in the Released or Started status.For a code example that uses the
    ///    <c>reportedStarted</c> method, see the <see cref="M:JmgTermJob.reportedStarted" />.
    /// </remarks>
    boolean reportedStarted()
    {
        return (JmgJobStatusFactory::buildJmgJobStatusInstance()).reportedStarted(prodRoute, jobid);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reportedWaiting</Name>
				<Source><![CDATA[
    private boolean reportedWaiting()
    {
        return (JmgJobStatusFactory::buildJmgJobStatusInstance()).reportedWaiting(prodRouteJob, jobid);
    }

]]></Source>
			</Method>
			<Method>
				<Name>requireFeedbackInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves whether additional feedback information is needed before a stop registration can be made.
    /// </summary>
    /// <param name="_regParameters">
    /// The registration parameters already given; optional.
    /// </param>
    /// <returns>
    /// true if additional feedback is required to make a registration; otherwise, false.
    /// </returns>
    /// <remarks>
    ///  A set of feedback parameters is supplied to the
    ///  <c>
    ///  requireFeedbackInfo
    ///  </c>
    ///   method. The set determines whether additional feedback is required to make a stop registration on
    ///  the job. Additional feedback is not needed if any of the following data has been specified in the
    ///  <c>
    ///  JmgRegistrationParameters
    ///  </c>
    ///   object:
    ///  <list type="bullet">
    ///   <item>
    ///    <description>
    ///    <c>JmgRegistrationParameters.goodQuantity</c>
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <description>
    ///    <c>JmgRegistrationParameters.errorSpecification</c>
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <description>
    ///    <c>JmgRegistrationParameters.reportAsFinished</c>
    ///    </description>
    ///   </item>
    ///  </list>
    ///
    ///  For a code example that uses the
    ///  <c>
    ///  requireFeedbackInfo
    ///  </c>
    ///   method, see the <see cref="M:JmgTermJob.requireFeedbackInfo" />
    ///  .
    /// </remarks>
    public boolean requireFeedbackInfo(JmgRegistrationParameters _regParameters = new JmgRegistrationParameters())
    {
    /*    if (_regParameters.errorSpecification() || _regParameters.goodQuantity() || _regParameters.reportAsFinished() != JmgNoneNoYesEnum::None)
        {
            return false;
        }*/
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>requireStartupInfo</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves whether additional startup information is required to create a start job registration.
    /// </summary>
    /// <param name="_regParameters">
    ///    The registration parameters already given; optional.
    /// </param>
    /// <returns>
    ///    true if additional startup information is required to make a registration; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    A set of startup parameters is supplied to the <c>requireStartupInfo</c> method. The set determines
    ///    whether additional feedback is required to make a start registration on the job. For production
    ///    jobs, startup information is required if the job of type Process and no startup quantity has been
    ///    given.For a code example that uses the <c>requireStartupInfo</c> method, see the <see
    ///    cref="M:JmgTermJob.requireStartupInfo" />.
    /// </remarks>
    public boolean requireStartupInfo(JmgRegistrationParameters _regParameters = new JmgRegistrationParameters())
    {
    /*    if ((prodRouteJob                                           &&
             prodRouteJob.JobType       == RouteJobType::Process    &&
             _regParameters.startQuantity())                        ||
            (prodRoute                                              &&
             prodRoute.JobIdProcess     == jobid                    &&
             _regParameters.startQuantity()))
        {
            return false;
        }*/
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>siteInventDimId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the inventory dimension ID to which the production job is linked.
    /// </summary>
    /// <returns>
    ///    The inventory dimension ID to which the production job is linked.
    /// </returns>
    public InventDimId siteInventDimId()
    {
        InventDim   inventDim;

        inventDim.InventSiteId  = jmgJobTable.InventSiteId;
        inventDim               = InventDim::findOrCreate(inventDim);

        return inventDim.InventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the source data record that the job originated from.
    /// </summary>
    /// <returns>
    ///    The source record that the job originated from.
    /// </returns>
    /// <remarks>
    ///    Production jobs originate from either the <c>ProdRoute</c> record or the <c>ProdRouteJob</c>
    ///    record, depending on shop floor control parameter setup. If the returned record is updated, the
    ///    <see cref="M:JmgTermJob::construct" /> or the <see cref="M:JmgTermJob::constructJobTable" /> is
    ///    invoked by using the <paramref name="_forUpdate" /> parameter set to true.
    /// </remarks>
    public Common sourceData()
    {
        Common ret;

        if (prodRouteJob)
        {
            ret = prodRouteJob;
        }
        else
        {
            ret = prodRoute;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>stampType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the <c>JmgStampTypeEnum::Work</c> stamp type that is associated with this job.
    /// </summary>
    /// <returns>
    ///    <c>JmgStampTypeEnum::Work</c>.
    /// </returns>
    /// <remarks>
    ///    For a code example that uses the <c>stampType</c> method, see <see cref="M:JmgTermJob.stampType" />.
    /// </remarks>
    public JmgStampTypeEnum stampType()
    {
        JmgStampTypeEnum ret;

        ret = JmgStampTypeEnum::Work;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJobRegistration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the specified <c>JmgTermReg</c> registration.
    /// </summary>
    /// <param name="_jmgTermReg">
    /// An instance of <c>JmgTermReg</c> which should be updated.
    /// </param>
    /// <param name="_goodItems">
    /// The good items quantity for the current registration.
    /// </param>
    /// <param name="_errorSpecification">
    /// The error specification for the current registration.
    /// </param>
    /// <param name="_finishCode">
    /// The finish code for the current registration.
    /// </param>
    /// <param name="_cwGoodItems">
    /// The catch weight good item quantity for the current registration.
    /// </param>
    protected void updateJobRegistration(JmgTermReg  _jmgTermReg, Qty _goodItems, JmgErrorSpecification _errorSpecification, JmgTermFinishedCode _finishCode
        , PdsCWInventQty _cwGoodItems
    )
    {
        _jmgTermReg.PdsCWGoodItems       += _cwGoodItems;

        _jmgTermReg.GoodItems            += _goodItems;
        _jmgTermReg.ErrorSpecification   += _errorSpecification;
        _jmgTermReg.FinishedCode         = _finishCode;

        _jmgTermReg.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTermReg</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the specified <c>JmgTermReg</c> registration.
    /// </summary>
    /// <param name="_jmgTermReg">
    /// An instance of <c>JmgTermReg</c> which should be updated.
    /// </param>
    /// <param name="_registrationParameters">
    /// The <c>JmgRegistrationParameters</c> used to update the registration.
    /// </param>
    protected internal void updateTermReg(JmgTermReg  _jmgTermReg, JmgRegistrationParameters _registrationParameters)
    {
        this.updateJobRegistration(_jmgTermReg, 
                                   _registrationParameters.goodQuantity(), 
                                   _registrationParameters.errorSpecification(), 
                                   (_registrationParameters.reportAsFinished() == JmgFeedbackStatus::Completed ? 2 : 1),
                                   _registrationParameters.pdsCWGoodQuantity());
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateStampJournalTransWrite</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates a <c>JmgStampJournalTrans</c> record.
    /// </summary>
    /// <param name="_jmgStampJournalTrans">
    /// The <c>JmgStampJournalTrans</c> record to be validated.
    /// </param>
    /// <returns>
    /// true if validation passes; otherwise, false.
    /// </returns>
    public boolean validateStampJournalTransWrite(JmgStampJournalTrans _jmgStampJournalTrans)
    {
        boolean ret = true;

        // if JobRef is empty, then it will be set correctly later on insert
        if (_jmgStampJournalTrans.JobRef != '' && _jmgStampJournalTrans.JobRef != this.jobRef())
        {
            ret = checkFailed(strfmt("@SYS39813", _jmgStampJournalTrans.JobId));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWhsLicensePlateId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a <c>WHSLicensePlateId</c>, associated with the job reference of this job.
    /// </summary>
    /// <returns>
    ///    The <c>WHSLicensePlateId</c> associated with the job.
    /// </returns>
    public WHSLicensePlateId getWhsLicensePlateId()
    {
        WHSLicensePlateId licensePlateId;
        ProdTable prodTable = ProdTable::find(this.JobRef());

        if (prodTable)
        {
            licensePlateId = InventDim::find(prodTable.InventDimId).LicensePlateId;
        }

        return licensePlateId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventBatchId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a <c>InventBatchId</c>, associated with the production order of this job.
    /// </summary>
    /// <returns>
    ///    The <c>InventBatchId</c> associated with the job.
    /// </returns>
    internal InventBatchId getInventBatchId()
    {
        InventBatchId inventBatchId;
        ProdTable prodTable = ProdTable::find(this.JobRef());

        if (prodTable)
        {
            inventBatchId = InventDim::find(prodTable.InventDimId).inventBatchId;
        }

        return inventBatchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventSerialId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a <c>InventSerialId</c>, associated with the production order of this job.
    /// </summary>
    /// <returns>
    ///    The <c>InventSerialId</c> associated with the job.
    /// </returns>
    [Hookable(false)]
    internal InventSerialId getInventSerialId()
    {
        InventSerialId inventSerialId;
        ProdTable prodTable = ProdTable::find(this.JobRef());

        if (prodTable)
        {
            inventSerialId = InventDim::find(prodTable.InventDimId).inventSerialId;
        }

        return inventSerialId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setProdRouteJobStatusToStarted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the JobStatus value of a <c>ProdRouteJob</c> record to started.
    /// </summary>
    /// <param name = "_jobId">
    /// Job id for which the status should be set to started.
    /// </param>
    internal static void setProdRouteJobStatusToStarted(JmgJobId _jobId)
    {
        ProdRouteJob prodRouteJob;
        prodRouteJob  = ProdRouteJob::findJobId(_jobId, true);
        if (prodRouteJob && prodRouteJob.JobStatus == ProdJobStatus::Stopped)
        {
            prodRouteJob.JobStatus = ProdJobStatus::Started;
            prodRouteJob.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUpdateProdRouteJob</Name>
				<Source><![CDATA[
    private boolean canUpdateProdRouteJob(JmgJobId _jobId)
    {
        return !JmgManufacturingExecutionWorkloadConfigurationProvider::isJobDeployedOnSpoke(JmgJobTable::find(_jobId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>jobOrderSortingKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a sort string to determine the processing order of the jobs in a bundle.
    /// </summary>
    /// <returns>The generated sort string.</returns>
    internal str jobOrderSortingKey()
    {
        str     key;
        int     intMaxVal = intMax();
        int     intMaxValLen = strLen(int2Str(intMaxVal));
        
        // ProdId
        key = this.addToKey(key, this.jobRef());
        
        // Level in reverse order
        key = this.addToKey(key, int2Str(intMaxVal - prodRoute.Level), intMaxValLen);
        
        key = this.addToKey(key, int2Str(prodRoute.OprNum), intMaxValLen);
        
        // Job type
        key = this.addToKey(key, int2Str(this.prodJobType()), 3);
                
        if (prodRouteJob)
        {
            // Primary job number
            key = this.addToKey(key, int2Str(prodRouteJob.NumPrimary), intMaxValLen);
        }
        
        // Priority
        key = this.addToKey(key, int2Str(this.oprPriority()), 3);
        
        if (prodRouteJob)
        {
            // Secondary job number
            key = this.addToKey(key, int2Str(prodRouteJob.NumSecondary), intMaxValLen);
        }

        // JobId
        key = this.addToKey(key, this.jobId());

        return key;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>