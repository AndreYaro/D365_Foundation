<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSPostEngineBase</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>WhsPostEngineBase</c> class contains the base methods to be executed during wave processing.
/// </summary>
public class WhsPostEngineBase extends WHSPostEngine
{
    protected WHSLoadTable                  whsLoadTable;
    protected int                           lastUpdateTime;
    protected int                           steps;
    protected boolean                       canSkipCreateLoads;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static WhsPostEngineBase construct()
    {
        return new WHSPostEngineBase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>allocateWave</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Allocate a wave.
    /// </summary>
    /// <param name="_setHasReplenishment">
    ///    A Boolean value; true indicates we need to determine if the wave template contains a replenishment step.
    /// </param>
    /// <param name="_setReleaseToWarehouse">
    ///    A Boolean value that indicates if the release to warehouse ID must be set.
    /// </param>
    /// <returns>
    ///    true if the allocation succeeded.
    /// </returns>
    [WHSWavePostMethodAttribute(true)]
    public boolean allocateWave(
        boolean _setHasReplenishment   = true,
        boolean _setReleaseToWarehouse = true)
    {
        using (var perfTask = WHSInstrumentationWaveProcessingPerformanceTask::newWaveStepBase(waveTable, waveExecutionId, funcName()))
        using (var appInsightsActivity = WHSWaveProcessingAllocateWaveApplicationInsightsActivity::construct())
        {
            // Begin allocation for current wave
            var workCreate = WHSWorkCreateWave::construct(waveTable);
            workCreate.parmPostEngine(this);
            workCreate.parmWaveExecutionId(waveExecutionId);
            workCreate.parmCreatedBy(curUserId());
            workCreate.parmParmWaveId(waveTable.WaveId);
            workCreate.parmWaveMethodStatusHandler(waveMethodStatusHandler);

            if (_setReleaseToWarehouse)
            {
                workCreate.parmReleaseToWarehouseId(releaseToWarehouseId);
                appInsightsActivity.addReleaseToWarehouseId(releaseToWarehouseId);
            }

            if (_setHasReplenishment)
            {
                workCreate.parmHasReplen(waveTable.waveTemplate().hasReplenishmentStep());
            }

            workCreate.createTempTable();
            perfTask.setAllocatedLoadLines(workCreate.allocatedLoadLines());
            appInsightsActivity.addAllocatedLines(workCreate.allocatedLoadLines());

            // Clean up shipments that failed allocation.
            workCreate.killFailedShipments();

            waveTable = WhsPostEngineBase::setWorkBuildIdAndWaveProcessingStatus(waveTable.WaveId, workCreate.parmWorkCreateId());
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>waveLabelPrinting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the wave step for creating and printing labels during wave execution.
    /// </summary>
    /// <returns>True</returns>
    [Hookable(false), WHSWavePostMethodAttribute(true)]
    public boolean waveLabelPrinting()
    {
        using (var perfTask = WHSInstrumentationWaveProcessingPerformanceTask::newWaveStepBase(waveTable, waveExecutionId, funcName()))
        using (var appInsightsActivity = WHSWaveProcessingWaveLabelPrintingApplicationInsightsActivity::construct())
        {
            WHSPrintLabels printLabels = WHSPrintLabels::newFromWave(waveTable.WaveId, waveTemplateLine.WaveStepCode, waveMethodStatusHandler);

            printLabels.printLabels();
        }
        
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sorting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the wave step for sorting during wave execution.
    /// </summary>
    /// <returns>True if sorting is done successfully.</returns>
    [Hookable(false)]
    public boolean sorting()
    {
        using (var perfTask = WHSInstrumentationWaveProcessingPerformanceTask::newWaveStepBase(waveTable, waveExecutionId, funcName()))
        using (var appInsightsActivity = WHSWaveProcessingSortingApplicationInsightsActivity::construct())
        {
            WHSOutboundSortingWaveDemand outboundSortingWaveDemand = WHSOutboundSortingWaveDemand::newFromWave(waveTable.WaveId, waveExecutionId, waveTemplateLine.WaveStepCode);

            outboundSortingWaveDemand.sortWaveDemand();
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSkipCreateLoads</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current template line is createLoads and if the method should be skipped.
    /// </summary>
    /// <param name="_waveTemplateLine">
    /// The template line about to be run.
    /// </param>
    /// <returns>
    /// true if the createLoads method should be skipped; otherwise, false.
    /// </returns>
    private boolean shouldSkipCreateLoads(WHSWaveTemplateLine _waveTemplateLine)
    {
        WHSWaveTemplateLine buildLoadsTemplateLine;

        if (_waveTemplateLine.PostMethodName == methodStr(WhsPostEngineBase, createLoads))
        {
            select firstOnly RecId from buildLoadsTemplateLine
                where buildLoadsTemplateLine.WaveTemplateName   == _waveTemplateLine.WaveTemplateName
                &&    buildLoadsTemplateLine.PostMethodName     == methodStr(WhsPostEngineBase, buildLoads);

            // setting this back to false will prevent calling this method for every wave template line after createLaods.
            canSkipCreateLoads = false;
        }

        return buildLoadsTemplateLine.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLoads</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds loads for the wave.
    /// </summary>
    /// <returns>True if load building is done successfully.</returns>
    [Hookable(false)]
    public boolean buildLoads()
    {
        if (waveMethodStatusHandler)
        {
            waveMethodStatusHandler.setTotalSteps(waveTable.numberOfShipmentLinesToBuild());
        }

        using (var perfTask = WHSInstrumentationWaveProcessingPerformanceTask::newWaveStepBase(waveTable, waveExecutionId, funcName()))
        {
            WHSLoadBuild loadBuild = WHSLoadBuild::newFromWave(waveTable, waveExecutionId);
            
            loadBuild.buildLoads(waveTemplateLine.WaveStepCode);

            canSkipCreateLoads = true;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>containerization</Name>
				<Source><![CDATA[
    /// <summary>
    /// Containerizes the wave during posting.
    /// </summary>
    /// <returns>
    /// True if containerization is done successfully.
    /// </returns>
    public boolean containerization()
    {
        using (var perfTask = WHSInstrumentationWaveProcessingPerformanceTask::newWaveStepBase(waveTable, waveExecutionId, funcName()))
        using (var appInsightsActivity = WHSWaveProcessingContainerizationApplicationInsightsActivity::construct())
        {
            var containerization = new WHSContainerization();
            containerization.parmWaveTemplateLine(waveTemplateLine);
            containerization.parmParmWaveId(waveTable.WaveId);
            containerization.parmWorkCreateId(waveTable.getWorkBuildId());
            containerization.parmWaveExecutionId(waveExecutionId);
            containerization.containerize();
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLoadForSalesOrder</Name>
				<Source><![CDATA[
    private void createLoadForSalesOrder(
        WHSWaveLine             waveLine,
        SalesTable              salesTable,
        SalesLine               salesLine,
        WHSLoadLine             loadLine,
        LogisticsPostalAddress  address,
        WHSPostEngineCreateLoadManagement_Sales _whsPostEngineCreateLoadManagement)
    {
        boolean                 consolidate = WHSParameters::find().ConsolidateLoads;

        this.createLoadFromShipment(
            WHSShipmentTable::find(waveLine.ShipmentId, true),
            loadLine,
            consolidate,
            _whsPostEngineCreateLoadManagement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLoadForTransfers</Name>
				<Source><![CDATA[
    private void createLoadForTransfers()
    {
        WHSLoadLine             loadLine;
        WHSWaveLine             waveLine;
        InventTransferLine      inventTransferLine;
        InventTransferTable     inventTransferTable;
        boolean                 consolidate = WHSParameters::find().ConsolidateLoads;

        WHSPostEngineCreateLoadManagement_Transfer createLoadManagement;
        createLoadManagement = WHSPostEngineCreateLoadManagement_Transfer::construct();

        ttsbegin;

        while select forupdate loadLine
            where loadLine.LoadId                       == ''
                && loadLine.ShipmentId
            join ShipmentId from waveLine
                where waveLine.WaveId                   == waveTable.WaveId
                    && waveLine.ShipmentId              == loadLine.ShipmentId
            join inventTransferLine
                where inventTransferLine.InventTransId  == loadLine.InventTransId
            join TransferId, DlvTermId, InventLocationIdFrom, InventLocationIdTo from inventTransferTable
                order by inventTransferTable.InventLocationIdFrom, inventTransferTable.InventLocationIdTo, inventTransferTable.TransferId
                where inventTransferTable.TransferId    == inventTransferLine.TransferId
        {
            createLoadManagement.initConsolidationCriteria(inventTransferTable);

            this.createLoadFromShipment(
                WHSShipmentTable::find(waveLine.ShipmentId, true),
                loadLine,
                consolidate,
                createLoadManagement);

            WHSWaveMethodStatusHandler::makeOneStepForward(waveMethodStatusHandler);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLoadFromShipment</Name>
				<Source><![CDATA[
    protected void createLoadFromShipment(
        WHSShipmentTable                        _shipmentTable,
        WHSLoadLine                             _loadLine,
        boolean                                 _consolidate,
        WHSPostEngineCreateLoadManagement       _loadManagement)
    {
        using (var appInsightsActivity = WHSWaveProcessingCreateLoadFromShipmentApplicationInsightsActivity::newFromParameters(_shipmentTable.ShipmentId, _shipmentTable.OrderNum))
        {
            WHSShipmentTable shipmentTable = _shipmentTable;
            WHSLoadTable     whsLoadTableLocal;

            if (!shipmentTable.LoadId)
            {
                if (this.hasLoadManagementSourceDocIdChanged(_loadManagement))
                {
                    if (_consolidate)
                    {
                        if (_loadManagement.variablesDifferentThanPrevious())
                        {
                            whsLoadTable = this.createLoadRecordFromShipment(_loadLine.ItemId, whsLoadTable.LoadTemplateId, shipmentTable, _loadManagement.parmLoadPaysFreight());
                            _loadManagement.initPrevVariablesForConsolidateCondition();
                            appInsightsActivity.addLoadConsolidatedProperty();
                        }
                    }
                    else
                    {
                        whsLoadTable = this.createLoadRecordFromShipment(_loadLine.ItemId, whsLoadTable.LoadTemplateId, shipmentTable, _loadManagement.parmLoadPaysFreight());
                    }
                }

                shipmentTable.LoadId = whsLoadTable.LoadId;
                shipmentTable.update();

                whsLoadTableLocal = whsLoadTable;
            }
            else
            {
                whsLoadTableLocal = whsLoadTable.LoadId == shipmentTable.LoadId ? whsLoadTable : WHSLoadTable::find(shipmentTable.LoadId);
            }
        
            appInsightsActivity.addLoadIdProperty(whsLoadTableLocal.LoadId);
            this.setLoadLineDetails(_loadLine, whsLoadTableLocal, shipmentTable);
            _loadLine.update();

            this.updateLoadOnWaveLine(waveTable.WaveId, shipmentTable.ShipmentId, _loadLine.LoadId);

            _loadManagement.initPrevId();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasLoadManagementSourceDocIdChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the source doc id of the <c>WHSPostEngineCreateLoadManagement</c> instance has changed.
    /// </summary>
    /// <param name = "_loadManagement">
    /// A <c>WHSPostEngineCreateLoadManagement</c> instance.
    /// </param>
    /// <returns>
    /// true if the source doc id of the <c>WHSPostEngineCreateLoadManagement</c> instance; otherwise, false.
    /// </returns>
    protected boolean hasLoadManagementSourceDocIdChanged(WHSPostEngineCreateLoadManagement _loadManagement)
    {
        return _loadManagement.sourceDocIdDifferentThanPrevious();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLoadLineDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the load line fields based on a given load header record, as well as a shipment header record.
    /// </summary>
    /// <param name = "_loadLine">Load line record to update.</param>
    /// <param name = "_loadTable">Load header record.</param>
    /// <param name = "_shipmentTable">Shipment header record.</param>
    protected void setLoadLineDetails(WHSLoadLine _loadLine, WHSLoadTable _loadTable, WHSShipmentTable _shipmentTable)
    {
        _loadLine.LoadId = _loadTable.LoadId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLoadRecordFromShipment</Name>
				<Source><![CDATA[
    private WHSLoadTable createLoadRecordFromShipment(
        ItemId              _itemId,
        WHSLoadTemplateId   _loadTemplateId,
        WHSShipmentTable    _shipmentTable,
        TMSLoadPaysFreight  _loadPaysFreight)
    {
        WhsPostLoadTableInitializationParameters parameters = WhsPostLoadTableInitializationParameters::construct();
        
        parameters.itemId = _itemId;
        parameters.loadTemplateId = _loadTemplateId;
        parameters.shipmentTable = _shipmentTable;
        parameters.loadPaysFreight = _loadPaysFreight;

        WHSLoadTable loadTable = this.initializeLoadTable(parameters);
        loadTable.write();

        WHSWaveCreatedLoad::createRecord(loadTable.LoadId, this.parmWaveTable().WaveId);

        return loadTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeLoadTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a load table from parameters.
    /// </summary>
    /// <param name = "_parameters">The initialization parameters.</param>
    /// <returns>The initialized load table.</returns>
    protected WHSLoadTable initializeLoadTable(WhsPostLoadTableInitializationParameters _parameters)
    {
        WHSLoadTable loadTable;

        loadTable.initFromItem(_parameters.itemId);
        loadTable.initFromLoadTemplateId(_parameters.loadTemplateId ? _parameters.loadTemplateId : loadTable.LoadTemplateId);

        loadTable.LoadDirection             = WHSLoadDirection::Outbound;
        loadTable.LoadStatus                = WHSExecuteWaveInitializeLoadPostedStatusV2Flight::instance().isEnabled() ? WHSLoadStatus::Posted : WHSLoadStatus::Waved;
        loadTable.InventSiteId              = _parameters.shipmentTable.InventSiteId;
        loadTable.InventLocationId          = _parameters.shipmentTable.InventLocationId;
        loadTable.CarrierCode               = _parameters.shipmentTable.CarrierCode;
        loadTable.CarrierServiceCode        = _parameters.shipmentTable.CarrierServiceCode;
        loadTable.LoadArrivalUTCDateTime    = _parameters.shipmentTable.dropOffDateTime();
        loadTable.LoadPaysFreight           = _parameters.loadPaysFreight;

        return loadTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLoadOnWaveLine</Name>
				<Source><![CDATA[
    private void updateLoadOnWaveLine(
        WHSWaveId       _whsWaveId,
        WHSShipmentId   _shipmentId,
        WHSLoadId       _newLoadId)
    {
        WHSWaveLine     waveLine;

        update_recordset waveLine
        setting LoadId = _newLoadId
        where waveLine.WaveId        == _whsWaveId
           && waveLine.ShipmentId    == _shipmentId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLoads</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates load during posting.
    /// </summary>
    /// <returns>
    /// True if loads are created successfully.
    /// </returns>
    public boolean createLoads()
    {                
        if (waveMethodStatusHandler)
        {
            waveMethodStatusHandler.setTotalSteps(waveTable.numberOfLoadLinesToAllocate());
        }

        using (var perfTask = WHSInstrumentationWaveProcessingPerformanceTask::newWaveStepBase(waveTable, waveExecutionId, funcName()))
        using (var appInsightsActivity = WHSWaveProcessingCreateLoadsApplicationInsightsActivity::construct())
        {
            ttsbegin;
            this.createLoadsForSourceDocuments();
            ttscommit;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLoadsForSourceDocuments</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal void createLoadsForSourceDocuments()
    {                
        if (isConfigurationkeyEnabled(configurationKeyNum(TradeMultiShipTo)))
        {
            this.createLoadsWithMultipleShippingAddresses();
        }
        else
        {
            this.createLoadsWithSingleShippingAddress();
        }

        whsLoadTable.clear();

        this.createLoadForTransfers();        
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLoadsWithMultipleShippingAddresses</Name>
				<Source><![CDATA[
    private void createLoadsWithMultipleShippingAddresses()
    {
        WHSLoadLine             loadLine;
        WHSWaveLine             waveLine;
        SalesTable              salesTable;
        SalesLine               salesLine;
        LogisticsPostalAddress  address;

        WHSPostEngineCreateLoadManagement_Sales createLoadManagement;

        createLoadManagement = WHSPostEngineCreateLoadManagement_Sales::construct();

        while select forupdate loadLine
            join forupdate waveLine
            join salesLine
            join salesTable
            join address
            order by salesTable.ShipCarrierId,
                     salesLine.DeliveryName,
                     address.Street,
                     address.City,
                     address.County,
                     address.State,
                     address.CountryRegionId,
                     address.Address,
                     salesLine.SalesId
            where loadLine.ShipmentId              == waveLine.ShipmentId
               && waveLine.WaveId                  == waveTable.WaveId
               && loadLine.InventTransId           == salesLine.InventTransId
               && salesLine.SalesId                == salesTable.SalesId
               && loadLine.LoadId                  == ''
               && salesLine.DeliveryPostalAddress  == address.RecId
        {
            createLoadManagement.initConsolidationCriteria(salesTable, salesLine, address);

            this.createLoadForSalesOrder(waveLine, salesTable, salesLine, loadLine, address, createLoadManagement);

            WHSWaveMethodStatusHandler::makeOneStepForward(waveMethodStatusHandler);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLoadsWithSingleShippingAddress</Name>
				<Source><![CDATA[
    private void createLoadsWithSingleShippingAddress()
    {
        WHSLoadLine             loadLine;
        WHSWaveLine             waveLine;
        SalesTable              salesTable;
        SalesLine               salesLine;
        LogisticsPostalAddress  address;

        WHSPostEngineCreateLoadManagement_Sales createLoadManagement;

        createLoadManagement = WHSPostEngineCreateLoadManagement_Sales::construct();

        while select forupdate loadLine
        join forupdate waveLine
        join salesLine
        join salesTable
        join address
        order by salesTable.ShipCarrierId,
                 salesLine.DeliveryName,
                 address.Street,
                 address.City,
                 address.County,
                 address.State,
                 address.CountryRegionId,
                 address.Address,
                 salesLine.SalesId
        where loadLine.ShipmentId              == waveLine.ShipmentId
           && waveLine.WaveId                  == waveTable.WaveId
           && loadLine.InventTransId           == salesLine.InventTransId
           && salesLine.SalesId                == salesTable.SalesId
           && loadLine.LoadId                  == ''
           && salesTable.DeliveryPostalAddress == address.RecId
        {
            createLoadManagement.initConsolidationCriteria(salesTable, salesLine, address);

            this.createLoadForSalesOrder(waveLine, salesTable, salesLine, loadLine, address, createLoadManagement);

            WHSWaveMethodStatusHandler::makeOneStepForward(waveMethodStatusHandler);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWorkBuildIdAndWaveProcessingStatus</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute, Wrappable(true), Replaceable(true)]
    internal static WHSWaveTable setWorkBuildIdAndWaveProcessingStatus(WHSWaveId _waveId, WHSWorkBuildId _workBuildId)
    {
        WHSWaveTable waveTable = WHSWaveTable::find(_waveId, true);

        waveTable.WorkBuildId = _workBuildId;

        waveTable.update();

        WHSWaveProcessingStatus::findOrCreateFromWave(waveTable);

        return waveTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWaveProcessingStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method only updated the wave status during work create steps. (default, kanban and production)
    /// </summary>
    /// <param name = "_workBuildId">The work build id</param>
    /// <param name = "_autoRelease">Boolean value indication if wave is do be auto released.</param>
    /// <returns>The count of work created.</returns>
    private WHSNumWorkCreated updateWaveProcessingStatus(
        WHSWorkBuildId  _workBuildId,
        boolean         _autoRelease)
    {
        waveTable = WHSWaveTable::find(waveTable.WaveId, true);

        WHSNumWorkCreated numWorkCreated = WHSPostEngineBase::updateWaveProcessingStatusOnWorkCreated(waveTable, _workBuildId, true, _autoRelease);

        return numWorkCreated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWaveProcessingStatusOnWorkCreated</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static WHSNumWorkCreated updateWaveProcessingStatusOnWorkCreated(
        WHSWaveTable    _waveTable,
        WHSWorkBuildId  _workBuildId,
        boolean         _updateWave,
        boolean         _autoRelease)
    {
        WHSNumWorkCreated numWorkCreated;

        if (_waveTable)
        {
            if (!_waveTable.selectForUpdate())
            {
                throw error(Error::wrongUseOfFunction(funcName()));
            }

            _waveTable.WorkBuildId = _workBuildId;

            numWorkCreated = _waveTable.numWorkCreated();

            if (numWorkCreated > 0)
            {
                if (_updateWave)
                {
                    WhsPostEngine::setWaveStatusAfterProcessing(_waveTable, numWorkCreated, _autoRelease);
                }

                if (_workBuildId)
                {
                    info(strFmt("@WAX1791", _workBuildId));
                }
            }
                
            _waveTable.update();

            WHSWaveProcessingStatus::findOrCreateFromWave(_waveTable);
        }

        return numWorkCreated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWork</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates work for a wave.
    /// </summary>
    /// <returns>
    ///    true if the creation succeeded.
    /// </returns>
    public boolean createWork()
    {
        using (var perfTask = WHSInstrumentationWaveProcessingPerformanceTask::newWaveStepBase(waveTable, waveExecutionId, funcName()))
        using (var appInsightsActivity = WHSWaveProcessingShippingCreateWorkApplicationInsightsActivity::construct())
        {
            ttsbegin;

            WHSWaveWorkCreator waveWorkCreator = WHSWaveWorkCreator::newFromPostEngine(this);
            waveWorkCreator.parmWorkCreateWorkOrderType(WHSWorkCreateWorkOrderType::WorkOrder);
            waveWorkCreator.parmWaveMethodStatusHandler(waveMethodStatusHandler);

            WHSWorkBuildId workBuildId = waveWorkCreator.createWorkForWave();
            appInsightsActivity.addWorkCreationNumberProperty(workBuildId);

            WHSWorkCreateReplenishment::createReplenLinkRecords(workBuildId);
            WhsWorkCreateReplenishment::cancelUnnecessaryReplenWorkForWave(waveTable.WaveId, waveExecutionId, workBuildId);

            waveWorkCreator.blockWorkDuringWorkCreation();

            if (WhsPostEngineBase::shouldFinalizeWorkCreation())
            {
                WHSNumWorkCreated numWorkCreated = this.updateWaveProcessingStatus(workBuildId, waveTable.waveTemplate().AutoReleaseWave);
                appInsightsActivity.addWorksCreatedProperty(numWorkCreated);

                WHSWaveWorkCreationFinalizer workCreationCompletionFinalizer = WHSWaveWorkCreationFinalizer::newFromParameters(waveTable.WaveId, workBuildId);
                workCreationCompletionFinalizer.finalizeWorkCreation();
            }

            ttscommit;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldRemoveExecutingWaveBlocking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Controls if wave work should be unblocked by ExecutingWave reason after wave processing.
    /// </summary>
    /// <returns>true if wave work should be unblocked by ExecutingWave reason; otherwise, false.</returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute, Wrappable(true)]
    protected boolean shouldRemoveExecutingWaveBlocking()
    {
        return waveTable.useTaskBasedWaveProcessing(methodStr(WhsPostEngineBase, waveLabelPrinting), this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldFinalizeWorkCreation</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static boolean shouldFinalizeWorkCreation()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeWaveSteps</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calls wave post methods in the order provided by the wave template.
    /// </summary>
    /// <returns>
    /// A container with a boolean value that informs if the wave ran successfully or not
    /// </returns>
    /// <exception cref="Exception::Error">
    /// An error is thrown when a previously called wave post method returns false, meaning it did not complete a valid run.
    /// </exception>
    public container executeWaveSteps()
    {
        WHSWaveTemplateLine             templateLine;
        SysDictClass                    baseClass = new SysDictClass(classNum(WHSPostEngineBase));
        boolean                         valid = true;
        boolean                         currentStepCalledAsynchronously;
        container                       conResult = [true];

        using (var perfTask = WHSInstrumentationWaveProcessingPerformanceTask::newWaveStepsExecution(waveTable, waveExecutionId))
        using (var waveLockManagerContext = WHSWaveLockManagerContext::newWaveLockManagerContext(this.parmWaveLockManager()))
        using (var appInsightsActivity = WHSWaveProcessingProcessWaveMethodsApplicationInsightsActivity::construct())
        {
            perfTask.setAsync(false);
            
            // Attempt a lock on the current wave.
            this.tryLockWaveId(true);

            this.validateWaveInExecutingStatus(perfTask);

            // Only initialize wave method status records at the start of a wave.
            if (!lastRunWaveStep)
            {
                //this is to harden the process - if any data is left we will clean it up here
                WHSWaveProcessingDataCleanup::cleanupBeforeWaveExecution(waveTable);

                this.initWaveMethodStatus();
            }

            ttsBegin;
                
            WHSWaveExecutionFailureHandler::newFromWaveId(waveTable.WaveId);

            boolean isPostEngineBaseReacquireWaveLockFlightEnabled = WhsPostEngineBaseReacquireWaveLockFlight::instance().isEnabled();

            // Run wave steps based on the wave template that are after the last run wave step.
            // If there is no last run wave step then the first step should be run.
            while select templateLine
                order by templateLine.WaveStep
                where templateLine.WaveTemplateName == waveTable.WaveTemplateName
                        && templateLine.WaveStep      >  lastRunWaveStep
            {
                if (canSkipCreateLoads
                &&  this.shouldSkipCreateLoads(templateLine))
                {
                    continue;
                }

                this.parmCurrentRunningWaveStep(templateLine.RecId);

                if (isPostEngineBaseReacquireWaveLockFlightEnabled)
                {
                    this.ensureLockWaveId();
                }

                [currentStepCalledAsynchronously, valid] = this.executeCurrentWaveStep(templateLine, valid, baseClass);
                appInsightsActivity.waveMethodProcessed();

                if (currentStepCalledAsynchronously)
                {
                    perfTask.setAsync(true);

                    // Don't run any more steps because we must wait for asynchronous wave steps to run and call back into the post engine.
                    break;
                }
    
            }

            if (isPostEngineBaseReacquireWaveLockFlightEnabled)
            {
                this.ensureLockWaveId();
            }

            this.finalizeWaveExcutionSteps(currentStepCalledAsynchronously, valid);

            ttscommit;
        }

        return conResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateNextWaveStepCanBeScheduled</Name>
				<Source><![CDATA[
    private void validateNextWaveStepCanBeScheduled(WHSWaveTemplateLine _templateLine)
    {
        WHSWaveStepController controllerRecord = WHSWaveStepController::findUnlockedRecordByWaveIdWithNoDelay(waveTable.WaveId);
        
        if (controllerRecord.RecId != 0)
        {
            throw Error(strFmt("@WAX:WHSWaveProcessingPostMethodCannotBeScheduledError", _templateLine.PostMethodName, waveTable.WaveId, controllerRecord.PostMethodName));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeCurrentWaveStep</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute, Replaceable(true)]
    protected container executeCurrentWaveStep(WHSWaveTemplateLine _templateLine, boolean _valid, SysDictClass _baseClass)
    {
        boolean currentStepCalledAsynchronously = false;
        boolean valid = _valid;

        this.validateNextWaveStepCanBeScheduled(_templateLine);
        
        // If we can not multi thread the wave step then just execute it in this thread.
        if (!this.useTaskBasedProcessing(_templateLine))
        {
            valid = this.runPostMethod(_templateLine, _baseClass) && valid;
            this.parmLastRunWaveStep(_templateLine.WaveStep);
        }
        else // If we can multi thread then create new batch tasks and end this thread.
        {
            var waveTaskCreator = WHSWaveTaskCreatorFactory::newFromPostMethodName(_templateLine.PostMethodName);
            this.parmWaveTemplateLine(_templateLine);
            waveTaskCreator.parmPostEngine(this);
            waveTaskCreator.createTasks();

            var waveStepMethod = WHSWaveStepMethodFactory::newMethodFromName(_templateLine.PostMethodName);
            if (waveStepMethod && waveStepMethod is WHSCustomWaveStepMethod)
            {
                this.updateWaveStepProgressToStarted(_templateLine);
            }

            currentStepCalledAsynchronously = true;
        }

        return [currentStepCalledAsynchronously, valid];
    }

]]></Source>
			</Method>
			<Method>
				<Name>finalizeWaveExcutionSteps</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is responsible for finalizing the execution of the wave steps.
    /// </summary>
    /// <param name = "_currentStepCalledAsynchronously">Boolean indicating whether the current step has been called asynchronously.</param>
    /// <param name = "_valid">Boolean indication whether the wave is valid.</param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute, Replaceable(true)]
    protected void finalizeWaveExcutionSteps(boolean _currentStepCalledAsynchronously, boolean _valid)
    {
        boolean waveProcessComplete = false;
        
        // We should only update wave table once all wave steps have been completed
        if (!_currentStepCalledAsynchronously
                && WHSWaveTemplateLine::findByRecId(this.parmCurrentRunningWaveStep()).isLastWaveStep())
        {
            var lockedControlRecord = WHSWaveStepController::createAndLockControlRecord(waveTable.WaveId, waveExecutionId, 'AfterWaveLastStep', waveTable.InventLocationId);

            if (!_valid)
            {                
                WHSPostEngine::createWaveExecutionHistoryLine(waveTable.WaveId, waveExecutionId, strFmt("@WAX3160", waveTable.WaveId), true);                                
                throw this.creationOfWaveFailed(strFmt("@WAX1616", waveTable.WaveId), waveTable);
            }

            this.runReplenishmentAutoCorrection();
            this.assertAllTmpWorkLinesProcessed();
            this.assertWorkCreatedQuantityInSyncWithWorkQuantities();

            this.updateWaveTableAfterProcessing();            

            lockedControlRecord.delete();

            this.onWaveProcessCompleted();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>creationOfWaveFailed</Name>
				<Source><![CDATA[
    private Exception creationOfWaveFailed(SysInfoLogStr _text, WHSWaveTable _waveTable)
    {
        Message::AddAction(MessageSeverity::Error, _text, "@WAX3135", MessageActionType::DisplayMenuItem, 
            MenuItemMessageActionProvider::createMenuItemWithFilterActionData(MenuItemType::Display, menuitemDisplayStr(WHSWaveExecutionHistory), MenuItemMessageActionFilterType::CallerRecord, _waveTable));

        return Exception::Error;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onWaveProcessCompleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method acts as a hook for logic that needs to run at the end of wave processing.
    /// </summary>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void onWaveProcessCompleted()
    {
        // Finalize the wave steps
        var waveProcessingDataFinalize = WHSWaveProcessingFinalizer::newForWaveExecution(waveTable.WaveId, waveExecutionId);
        waveProcessingDataFinalize.finalizeExecutedWave();

        // We do this inside the tts scope of the actual wave process so we are sure work etc. is rolled back
        //in case an error inside the clean up is thrown.
        var waveProcessingDataCleanup = WHSWaveProcessingDataCleanup::newForWaveExecution(waveTable.WaveId, waveExecutionId);
        waveProcessingDataCleanup.parmWaveCleanupType('SuccessfulWaveCleanup');
        waveProcessingDataCleanup.cleanupExecutedWave();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWaveInExecutingStatus</Name>
				<Source><![CDATA[
    private void validateWaveInExecutingStatus(WHSInstrumentationWaveProcessingPerformanceTask _perfTask)
    {
        if (waveTable.waveStatus != WHSWaveStatus::Executing)
        {
            WHSPostEngine::createWaveExecutionHistoryLine(waveTable.WaveId, waveExecutionId, "@WAX:WaveDoesNotHaveExecutingStatus_ErrorMessage", true);
            _perfTask.logInformation(strfmt('method %1 will throw because wave is in state %2', funcName(), waveTable.waveStatus));
            throw error("@WAX:WaveDoesNotHaveExecutingStatus_ErrorMessage");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runReplenishmentAutoCorrection</Name>
				<Source><![CDATA[
    private void runReplenishmentAutoCorrection()
    {
        WHSWaveProcessingReplenishmentAutoCorrector replenishmentCorrector = WHSWaveProcessingReplenishmentAutoCorrector::newFromWaveTable(waveTable);
        replenishmentCorrector.runAutoCorrection();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkCenterFromProdBom</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a <c>WrkCtrTable</c> record based on the <c>prodBom</c> record.
    /// </summary>
    /// <param name="_prodBOM">
    /// A <c>ProdBOM</c> record.
    /// </param>
    /// <returns>
    /// A <c>WrkCtrTable</c> record.
    /// </returns>
    protected WrkCtrTable getWorkCenterFromProdBom(ProdBOM _prodBOM)
    {
        return WHSProdTable::getWorkCenterFromProdId(_prodBOM.ProdId, _prodBOM.OprNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>kanbanAllocateWave</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Allocate a kanban wave.
    /// </summary>
    /// <returns>
    ///    true if the allocation succeeded.
    /// </returns>
    public boolean kanbanAllocateWave()
    {
        const boolean EvaluateReplenishment = true;
        const boolean SetReleaseToWarehouseId = false;

        return this.allocateWave(EvaluateReplenishment, SetReleaseToWarehouseId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>kanbanCreateWork</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates work for a kanban wave.
    /// </summary>
    /// <param name="_validate">
    ///    A Boolean value that indicates if the creation should be for validation only.
    /// </param>
    /// <returns>
    ///    true if the creation succeeded; otherwise, false.
    /// </returns>
    public boolean kanbanCreateWork(boolean _validate = false)
    {
        using (var perfTask = WHSInstrumentationWaveProcessingPerformanceTask::newWaveStepBase(waveTable, waveExecutionId, funcName()))
        using (var appInsightsActivity = WHSWaveProcessingKanbanCreateWorkApplicationInsightsActivity::construct())
        {
            ttsbegin;

            WHSWorkCreateWave workCreate = WHSWorkCreateWave::construct(waveTable, waveTable.WorkBuildId);
            workCreate.parmOrginType(WHSOriginType::Wave);
            workCreate.parmWaveExecutionId(waveExecutionId);
            workCreate.parmCreatedBy(curUserId());
            workCreate.parmWorkTransType(WHSWaveTable::getWorkTransType(waveTable.WaveId));
            workCreate.parmParmWaveId(waveTable.WaveId);
            WHSWorkBuildId workBuildId = workCreate.processTempTable();
            workCreate.parmWorkCreateId(workBuildId);
            workCreate.cleanupTempTable();

            WhsWorkCreateReplenishment::createReplenLinkRecords(workBuildId);

            WHSWaveWorkCreator waveWorkCreator = WHSWaveWorkCreator::newFromWaveTable(waveTable);
            waveWorkCreator.parmWorkBuildId(workBuildId);

            waveWorkCreator.unBlockImmediateReplenWork();
            waveWorkCreator.blockWorkByWorkBuildId(_validate);
            
            if (_validate)
            {
                ttsabort;
            }
            else
            {
                WHSNumWorkCreated numWorkCreated = this.updateWaveProcessingStatus(workBuildId, waveTable.waveTemplate().AutoReleaseWave);
                appInsightsActivity.addWorksCreatedProperty(numWorkCreated);

                WHSKanbanJobPickingListPool kanbanJobPickingListPool;
                WHSKanbanWaveLine           kanbanWaveLine;
                boolean                     incompleteWork = false;
    
                // Check to see if all bom lines on the wave were fulfilled
                while select InventTransId from kanbanWaveLine
                    where kanbanWaveLine.WaveId == waveTable.WaveId
                    join kanbanJobPickingListPool
                    where kanbanJobPickingListPool.InventTransId == kanbanWaveLine.InventTransId
                {
                    WHSPoolKanbanJobPickingList whsPool = kanbanJobPickingListPool.whsPoolKanbanJobPickingList();

                    if (this.hasKanbanQtyLeftToWave(whsPool))
                    {
                        warning(strFmt("@WAX3382", whsPool.inventTransId()));           
                        incompleteWork = true;
                    }
                }

                appInsightsActivity.addWorkCompletedProperty(!incompleteWork);
                if (incompleteWork)
                {
                    throw error(strFmt("@SYS4010259", waveTable.WaveId));
                }

                if (waveTable.waveTemplate().AutoReleaseWave && numWorkCreated > 0)
                {
                    WHSWaveTable::releaseWave(waveTable.WaveId);
                }

                ttscommit;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasKanbanQtyLeftToWave</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the kanban picking list pool has quantity left to wave.
    /// </summary>
    /// <param name = "_whsPoolKanbanJobPickingList">The kanban picking list pool.</param>
    /// <returns>true if the kanban picking list pool has quantity left to wave; otherwise, false.</returns>
    protected boolean hasKanbanQtyLeftToWave(WHSPoolKanbanJobPickingList _whsPoolKanbanJobPickingList)
    {
        return _whsPoolKanbanJobPickingList.handlingQtyLeftToWave();
    }

]]></Source>
			</Method>
			<Method>
				<Name>kanbanPickQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Picks and reserves kanban job picking list quantities for the wave.
    /// </summary>
    /// <returns>
    ///   true if the pick succeeded.
    /// </returns>
    /// <exception cref="Exception::Error">
    ///   The warehouse is not allowed.
    /// </exception>
    public boolean kanbanPickQty()
    {
        WHSKanbanJobPickingListPool kanbanJobPickingListPool;
        WHSKanbanWaveLine           kanbanWaveLine;
        KanbanJobPickingList        pickingList;
        KanbanJobPickingListAll     kanbanJobPickingListAll;
        WrkCtrResourceGroup         wrkCtrResourceGroup;
        InventDimParm               inventDimParm;
        InventTransIdSum            inventTransIdSum;
        InventQty                   reserveQty;
        InventQty                   alreadyReservedQty;
        boolean                     checkWorkCellInventory;
        InventDim                   inventDim;
        WHSPoolKanbanJobPickingList whsPoolKanbanJobPickingList;

        using (var perfTask = WHSInstrumentationWaveProcessingPerformanceTask::newWaveStepBase(waveTable, waveExecutionId, funcName()))
        using (var appInsightsActivity = WHSWaveProcessingKanbanPickQuantityApplicationInsightsActivity::construct())
        {
            // strategy:
            // - reserve & pick as much as possible on the specified wmsLocation
            // - change movement inventory dimension to just the warehouse level
            // - reserve the remainder at warehouse level
            while select ItemId from kanbanWaveLine
                where kanbanWaveLine.WaveId == waveTable.WaveId
                join kanbanJobPickingListPool
                    where kanbanJobPickingListPool.InventTransId == kanbanWaveLine.InventTransId
                join kanbanJobPickingListAll
                    where kanbanJobPickingListAll.InventTransId == kanbanJobPickingListPool.InventTransId
                        && kanbanJobPickingListAll.Quantity      >  kanbanJobPickingListPool.WavedQty
            {
                whsPoolKanbanJobPickingList = kanbanJobPickingListPool.whsPoolKanbanJobPickingList();
                pickingList                 = KanbanJobPickingListAll.kanbanJobPickingList(true);
                inventDim                   = kanbanJobPickingListAll.inventDim();
  
                if (inventDim.wmsLocationId && pickingList)
                {
                    // reserve
                    inventDimParm.initFromInventDim(inventDim);
                    inventTransIdSum = InventTransIdSum::newTransOriginIdDimension(
                                                                    kanbanJobPickingListAll.inventTransOriginId(),
                                                                    inventDim,
                                                                    inventDimParm);
                    alreadyReservedQty = inventTransIdSum.reservPhysical();

                    reserveQty = max(-whsPoolKanbanJobPickingList.handlingQtyLeftToWave(), -kanbanJobPickingListAll.Quantity - alreadyReservedQty);
                    if (reserveQty < 0)
                    {
                        InventUpd_Reservation::newInventDim(kanbanJobPickingListAll.inventMovement(),inventDim,reserveQty).updateNow();
                    }

                    inventTransIdSum.clearTotals();
                    alreadyReservedQty = inventTransIdSum.reservPhysical();

                    // pick
                    if (alreadyReservedQty < 0)
                    {
                        whsPoolKanbanJobPickingList.pickFromWorkCenterHandlingQty(kanbanJobPickingListAll.inventDim(), -alreadyReservedQty, -alreadyReservedQty, true);
                        WHSPostEngine::createWaveExecutionHistoryLine(
                                                        waveTable.WaveId,
                                                        waveExecutionId,
                                                        strFmt("@WAX4755",
                                                        whsPoolKanbanJobPickingList.displayOrderIdAndItemId(),
                                                        inventDim.wmsLocationId),
                                                        false);
                    }
                }

                if (whsPoolKanbanJobPickingList.handlingQtyLeftToWave() > 0)
                {
                    // check at work cell location
                    wrkCtrResourceGroup = kanbanJobPickingListAll.kanbanJob().wrkCtrResourceGroup();

                    checkWorkCellInventory =    wrkCtrResourceGroup
                                                && wrkCtrResourceGroup.InputInventLocationId
                                                && wrkCtrResourceGroup.InputWMSLocationId
                                                && (wrkCtrResourceGroup.InputInventLocationId != inventDim.InventLocationId
                                                ||  wrkCtrResourceGroup.InputWMSLocationId    != inventDim.wmsLocationId);

                    if (checkWorkCellInventory && pickingList)
                    {
                        pickingList.clearWMSLocationFromMovement();

                        if (InventLocation::find(wrkCtrResourceGroup.InputInventLocationId).InventSiteId != inventDim.InventSiteId)
                        {
                            throw error(strFmt("@WAX4756",
                                                wrkCtrResourceGroup.InputInventLocationId,
                                                inventDim.InventSiteId));
                        }

                        inventDim.InventLocationId = wrkCtrResourceGroup.InputInventLocationId;
                        inventDim.wmsLocationId    = wrkCtrResourceGroup.InputWMSLocationId;
                        inventDim                  = InventDim::findOrCreate(inventDim);

                        // reserve
                        inventDimParm.initFromInventDim(inventDim);
                        inventTransIdSum = InventTransIdSum::newTransOriginIdDimension(
                                                                        kanbanJobPickingListAll.inventTransOriginId(),
                                                                        inventDim,
                                                                        inventDimParm);
                        alreadyReservedQty = inventTransIdSum.reservPhysical();

                        reserveQty = max(-whsPoolKanbanJobPickingList.handlingQtyLeftToWave(), -kanbanJobPickingListAll.Quantity - alreadyReservedQty);
                        if (reserveQty < 0)
                        {
                            InventUpd_Reservation::newInventDim(kanbanJobPickingListAll.inventMovement(),inventDim,reserveQty,true).updateNow();
                        }

                        inventTransIdSum.clearTotals();
                        alreadyReservedQty = inventTransIdSum.reservPhysical();

                        // pick
                        if (alreadyReservedQty < 0)
                        {
                            whsPoolKanbanJobPickingList.pickFromWorkCenterHandlingQty(kanbanJobPickingListAll.inventDimNoLoc(), -alreadyReservedQty, -alreadyReservedQty, true);
                            WHSPostEngine::createWaveExecutionHistoryLine(
                                                                waveTable.WaveId,
                                                                waveExecutionId,
                                                                strFmt("@WAX4755",
                                                                whsPoolKanbanJobPickingList.displayOrderIdAndItemId(),
                                                                inventDim.wmsLocationId),
                                                                false);
                        }
                    }

                    if (whsPoolKanbanJobPickingList.handlingQtyLeftToWave() > 0)
                    {
                        pickingList.clearWMSLocationFromMovement();

                        // reserve at warehouse level
                        inventDim = kanbanJobPickingListAll.inventDimNoLoc();
                        inventDimParm.initFromInventDim(inventDim);

                        inventTransIdSum = InventTransIdSum::newTransOriginIdDimension(
                                                                        kanbanJobPickingListAll.inventTransOriginId(),
                                                                        inventDim,
                                                                        inventDimParm);

                        alreadyReservedQty = inventTransIdSum.reservPhysical();

                        reserveQty = max(-whsPoolKanbanJobPickingList.handlingQtyLeftToWave(), -kanbanJobPickingListAll.Quantity - alreadyReservedQty);

                        if (reserveQty < 0)
                        {
                            InventUpd_Reservation::newInventDim(kanbanJobPickingListAll.inventMovement(),inventDim,reserveQty,true).updateNow();

                            inventTransIdSum.clearTotals();
                            alreadyReservedQty = inventTransIdSum.reservPhysical();

                            if (-alreadyReservedQty < whsPoolKanbanJobPickingList.handlingQtyLeftToWave())
                            {
                                warning(strFmt("@WAX4758",
                                                whsPoolKanbanJobPickingList.displayOrderIdAndItemId(),
                                                inventDim.InventLocationId));
                            }
                        }
                    }
                }
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prodAllocateWave</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Allocate a production wave.
    /// </summary>
    /// <returns>
    ///    true if the allocation succeeded.
    /// </returns>
    public boolean prodAllocateWave()
    {
        const boolean EvaluateReplenishment = true;
        const boolean SetReleaseToWarehouseId = false;

        return this.allocateWave(EvaluateReplenishment, SetReleaseToWarehouseId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>prodCreateWork</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates work for a production wave.
    /// </summary>
    /// <param name="_validate">
    ///    A Boolean value that indicates if the creation should be for validation only.
    /// </param>
    /// <returns>
    ///    true if the creation succeeded; otherwise, false.
    /// </returns>
    public boolean prodCreateWork(boolean _validate = false)
    {
        using (var perfTask = WHSInstrumentationWaveProcessingPerformanceTask::newWaveStepBase(waveTable, waveExecutionId, funcName()))
        using (var appInsightsActivity = WHSWaveProcessingProductionCreateWorkApplicationInsightsActivity::construct())
        {
            ttsbegin;

            WHSWorkCreateWave workCreate = WHSWorkCreateWave::construct(waveTable, waveTable.WorkBuildId);
            workCreate.parmOrginType(WHSOriginType::Wave);
            workCreate.parmWaveExecutionId(waveExecutionId);
            workCreate.parmCreatedBy(curUserId());
            workCreate.parmWorkTransType(WHSWaveTable::getWorkTransType(waveTable.WaveId));
            workCreate.parmParmWaveId(waveTable.WaveId);
            WHSWorkBuildId workBuildId = workCreate.processTempTable();
            workCreate.parmWorkCreateId(workBuildId);
            workCreate.cleanupTempTable();

            WhsWorkCreateReplenishment::createReplenLinkRecords(workBuildId);

            WHSWaveWorkCreator waveWorkCreator = WHSWaveWorkCreator::newFromWaveTable(waveTable);
            waveWorkCreator.parmWorkBuildId(workBuildId);

            waveWorkCreator.unBlockImmediateReplenWork();
            waveWorkCreator.blockWorkByWorkBuildId(_validate);

            if (_validate)
            {
                ttsabort;
            }
            else
            {
                WHSNumWorkCreated numWorkCreated = this.updateWaveProcessingStatus(workBuildId, false);
                appInsightsActivity.addWorksCreatedProperty(numWorkCreated);

                if (waveTable.waveTemplate().AutoReleaseWave && numWorkCreated > 0)
                {
                    WHSWaveTable::releaseWave(waveTable.WaveId);
                }

                ttscommit;
            }

            WHSProdBOMPool  prodBOMPool;
            WHSProdWaveLine prodWaveLine;

            // Check to see if all bom lines on the wave where fulfilled
            while select prodBOMPool
                exists join prodWaveLine
                where prodBOMPool.InventTransId == prodWaveLine.InventTransId
                &&    prodWaveLine.WaveId       == waveTable.WaveId
            {
                // Qty left could be negative if handling unit was used during work creation.
                this.validateFulfilledWavedQtyForProduction(prodBOMPool);
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFulfilledWavedQtyForProduction</Name>
				<Source><![CDATA[
    private void validateFulfilledWavedQtyForProduction(WHSProdBOMPool _prodBOMPool)
    {
        WHSWavedQty totalWavedQty = _prodBOMPool.WavedQty + _prodBOMPool.getFrozenHandlingQty();

        if (this.canTotalQuantityForProductionBOMBeFulfilled(_prodBOMPool, totalWavedQty))
        {
            warning(strFmt("@WAX:QtyForProdBomCouldNotBeFulfilled", _prodBOMPool.ProdId, _prodBOMPool.InventTransId, _prodBOMPool.ItemId));
            WHSPostEngine::createWaveExecutionHistoryLine(waveTable.WaveId, this.parmWaveExecutionId(), strFmt("@WAX:QtyForProdBomCouldNotBeFulfilled", _prodBOMPool.ProdId, _prodBOMPool.InventTransId, _prodBOMPool.ItemId), true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canTotalQuantityForProductionBOMBeFulfilled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the total quantity for a production BOM can be fulfilled.
    /// </summary>
    /// <param name = "_prodBOMPool">The production BOM pool.</param>
    /// <param name = "_totalWavedQty">The total quantity.</param>
    /// <returns>true if the total quantity can be fulfilled; otherwise, false.</returns>
    protected boolean canTotalQuantityForProductionBOMBeFulfilled(WHSProdBOMPool _prodBOMPool, WHSWavedQty _totalWavedQty)
    {
        if (_prodBOMPool.ReleasedInventQty > _totalWavedQty)
        {
            WHSPool whsPool = this.newWHSPoolFromProdBomPool(_prodBOMPool);
            
            if (whsPool.handlingQtyLeftToWave() > 0)
            {
                return true;
            }
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newWHSPoolFromProdBomPool</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>WHSPool</c> class based on the passed <c>WHSProdBOMPool</c> record.
    /// </summary>
    /// <param name="_prodBOMPool">
    /// A <c>WHSProdBOMPool</c> record.
    /// </param>
    /// <returns>
    /// <c>WHSPool</c> instance.
    /// </returns>
    //  <remarks>This is an extension point to control instantiation of <c>WHSPool</c>.</remarks>
    protected WHSPool newWHSPoolFromProdBomPool(WHSProdBOMPool _prodBOMPool)
    {
        return _prodBOMPool.whsPoolProdBOM();
    }

]]></Source>
			</Method>
			<Method>
				<Name>prodPickQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Picks production BOM quantities for the wave.
    /// </summary>
    /// <returns>
    ///   true if the pick succeeded.
    /// </returns>
    /// <exception cref="Exception::Error">
    ///   On hand inventory is insufficient.
    /// </exception>
    public boolean prodPickQty()
    {      
        return this.prodPickQtyByProdId();        
    }

]]></Source>
			</Method>
			<Method>
				<Name>prodPickQtyByInventTransOrigin</Name>
				<Source><![CDATA[
    private boolean prodPickQtyByInventTransOrigin()
    {
        WHSProdBOMPool          prodBOMPool;
        WHSProdWaveLine         prodWaveLine;
        ProdBOM                 prodBOM;
        InventTransOrigin       inventTransOrigin;
        WHSPoolProdBOM          whsPoolProdBOM;
        InventTrans             inventTrans;
        JournalId				bomJournalId;
        InventTransOriginId		prevInventTransOriginId;

        using (var perfTask = WHSInstrumentationWaveProcessingPerformanceTask::newWaveStepBase(waveTable, waveExecutionId, funcName()))
        using (var prodPickQtyAllocationContext = WHSProdPickQtyAllocationContext::construct(waveTable.WaveId, waveExecutionId))
        using (var appInsightsActivity = WHSWaveProcessingProductionPickQuantityApplicationInsightsActivity::construct())
        {
            while select InventDimId, InventTransOrigin, ItemId, StatusIssue, sum(Qty), sum(PdsCWQty) from inventTrans
                group by InventDimId, InventTransOrigin, ItemId, StatusIssue
                where inventTrans.StatusIssue   == StatusIssue::ReservPhysical
                &&    inventTrans.StatusReceipt == StatusReceipt::None
                    exists join inventTransOrigin
                        where inventTransOrigin.RecId == inventTrans.InventTransOrigin
                    exists join prodWaveLine
                        where prodWaveLine.InventTransId    == inventTransOrigin.InventTransId
                        &&    prodWaveLine.WaveId           == waveTable.WaveId
            {
                if (prevInventTransOriginId != inventTrans.InventTransOrigin)
                {
                    if (prevInventTransOriginId
                    &&  bomJournalId
                    &&	prodBOM.prodTable().ProdStatus == ProdStatus::StartedUp
                    &&	prodBOM.flushingPrinciple()	   == ProdFlushingPrincipBOM::Picked)
                    {
                        WHSPostProdJournal::postJournalFromJournalId(bomJournalId);
                        bomJournalId = '';
                    }

                    prevInventTransOriginId = inventTrans.InventTransOrigin;

                    prodBOMPool = WHSProdBOMPool::find(InventTransOrigin::find(inventTrans.InventTransOrigin).InventTransId, true);
                    whsPoolProdBOM = WHSPoolProdBOM::newStandard(prodBOMPool);
                    prodBOM = ProdBOM::findTransId(prodBOMPool.InventTransId);
                }

                if (this.mustExecuteProductionPickQuantity(prodBOMPool, prodBOM, whsPoolProdBOM, inventTrans, bomJournalId))
                {
                    this.executeProdPickQty(prodBOMPool, prodWaveLine, prodBOM, whsPoolProdBOM, inventTrans, bomJournalId);
                    bomJournalId = whsPoolProdBOM.parmProdJournalId();
                }
            }

            if (bomJournalId
            &&	prodBOM.prodTable().ProdStatus == ProdStatus::StartedUp
            &&	prodBOM.flushingPrinciple()	   == ProdFlushingPrincipBOM::Picked)
            {
                WHSPostProdJournal::postJournalFromJournalId(bomJournalId);
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prodPickQtyByProdId</Name>
				<Source><![CDATA[
    private boolean prodPickQtyByProdId()
    {
        WHSProdBOMPool          prodBOMPool;
        WHSProdWaveLine         prodWaveLine;
        ProdBOM                 prodBOM;
        InventTransOrigin       inventTransOrigin;
        WHSPoolProdBOM          whsPoolProdBOM;
        InventTrans             inventTrans;
        JournalId				bomJournalId;
        ProdId		            prevProdId;
        InventTransOriginId		prevInventTransOriginId;

        using (var perfTask = WHSInstrumentationWaveProcessingPerformanceTask::newWaveStepBase(waveTable, waveExecutionId, funcName()))
        using (var prodPickQtyAllocationContext = WHSProdPickQtyAllocationContext::construct(waveTable.WaveId, waveExecutionId))
        using (var appInsightsActivity = WHSWaveProcessingProductionPickQuantityApplicationInsightsActivity::construct())
        {
            while select ProdId from prodWaveLine
                group by ProdId
                order by ProdId
                where prodWaveLine.WaveId  == waveTable.WaveId
                    join InventDimId, InventTransOrigin, ItemId, StatusIssue, sum(Qty), sum(PdsCWQty) from inventTrans
                    group by InventDimId, InventTransOrigin, ItemId, StatusIssue
                    order by InventTransOrigin
                    where inventTrans.StatusIssue   == StatusIssue::ReservPhysical
                       && inventTrans.StatusReceipt == StatusReceipt::None
                    exists join inventTransOrigin
                        where inventTransOrigin.RecId == inventTrans.InventTransOrigin
                           && inventTransOrigin.InventTransId == prodWaveLine.InventTransId
            {

                if (prevProdId != prodWaveLine.ProdId)
                {
                    if (prevProdId && bomJournalId)
                    {
                        WHSPostProdJournal::postJournalFromJournalId(bomJournalId);
                        bomJournalId = '';
                    }

                    prevProdId = prodWaveLine.ProdId;
                }

                if (prevInventTransOriginId != inventTrans.InventTransOrigin)
                {
                    prevInventTransOriginId = inventTrans.InventTransOrigin;

                    prodBOMPool = WHSProdBOMPool::find(InventTransOrigin::find(inventTrans.InventTransOrigin).InventTransId, true);
                    whsPoolProdBOM = WHSPoolProdBOM::newStandard(prodBOMPool);
                    prodBOM = ProdBOM::findTransId(prodBOMPool.InventTransId);
                }

                if (this.mustExecuteProductionPickQuantity(prodBOMPool, prodBOM, whsPoolProdBOM, inventTrans, bomJournalId))
                {
                    this.executeProdPickQty(prodBOMPool, prodWaveLine, prodBOM, whsPoolProdBOM, inventTrans, bomJournalId);
                    bomJournalId = whsPoolProdBOM.parmProdJournalId();
                }
            }

            if (bomJournalId)
            {
                WHSPostProdJournal::postJournalFromJournalId(bomJournalId);
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustExecuteProductionPickQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if picking production BOM quantities for the wave must be executed.
    /// </summary>
    /// <param name="_prodBOMPool">
    /// <c>WHSProdBOMPool</c> instance.
    /// </param>
    /// <param name="_prodBOM">
    /// <c>ProdBOM</c> record.
    /// </param>
    /// <param name="_whsPoolProdBOM">
    /// <c>WHSPoolProdBOM</c> instance.
    /// </param>
    /// <param name="_inventTrans">
    /// <c>InventTrans</c> record.
    /// </param>
    /// <param name="_bomJournalId">
    /// BOM journal id.
    /// </param>
    /// <returns>true if execution must occur; otherwise, false.</returns>
    protected boolean mustExecuteProductionPickQuantity(
        WHSProdBOMPool  _prodBOMPool,
        ProdBOM         _prodBOM,
        WHSPoolProdBOM  _whsPoolProdBOM,
        InventTrans     _inventTrans,
        JournalId	    _bomJournalId)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeProdPickQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes Picking production BOM quantities for the wave.
    /// </summary>
    /// <param name="_prodBOMPool">
    /// <c>WHSProdBOMPool</c> instance.
    /// </param>
    /// <param name="_prodWaveLine">
    /// <c>WHSProdWaveLine</c> record.
    /// </param>
    /// <param name="_prodBOM">
    /// <c>ProdBOM</c> record.
    /// </param>
    /// <param name="_whsPoolProdBOM">
    /// <c>WHSPoolProdBOM</c> instance.
    /// </param>
    /// <param name="_inventTrans">
    /// <c>InventTrans</c> record.
    /// </param>
    /// <param name="_bomJournalId">
    /// BOM journal id.
    /// </param>
    protected void executeProdPickQty(WHSProdBOMPool _prodBOMPool,
                                     WHSProdWaveLine _prodWaveLine,
                                     ProdBOM _prodBOM,
                                     WHSPoolProdBOM _whsPoolProdBOM,
                                     InventTrans _inventTrans,
                                     JournalId	_bomJournalId)
    {
        Qty wrkCtrAvailQty;
        InventDim wrkCtrInventDim;
        boolean isCWItem = PdsGlobal::pdsIsCWItem(_prodBOMPool.ItemId);
        InventHandlingQty positiveTransHandlingQty = isCWItem ? -_inventTrans.PdsCWQty : -_inventTrans.Qty;

        InventDim prodBomInventDim = _whsPoolProdBOM.inventDim();
        _whsPoolProdBOM.parmProdJournalId(_bomJournalId);

        // Location has been specified on the prodBom line so we directly consume inventory from this location.
        if (prodBomInventDim.wmsLocationId)
        {
            // If reservation was not reserved to location level and the item or location doesn't allow negative then we need to check availability.
            if (!_inventTrans.inventDim().wmsLocationId
                && (!_prodBOM.inventTable().whsAllowPhysNeg()
                ||  !prodBomInventDim.wmsLocation().whsLocationProfile().AllowNegative))
            {
                wrkCtrInventDim = _inventTrans.inventDim();
                wrkCtrInventDim.wmsLocationId = prodBomInventDim.wmsLocationId;
                wrkCtrInventDim = InventDim::findOrCreate(wrkCtrInventDim);

             
                using (var waveLockManager = WHSWaveLockManager::newStandard())
                {
                    // Throws error on lock acquisition failure.
                    waveLockManager.lockForProdPickQtyAllocation(_prodBOM.ItemId, wrkCtrInventDim.InventDimId, waveTable.WaveId, whsParameters.WaveLockWait);
                        
                    wrkCtrAvailQty = WHSInventOnHand::getWorkPhysicalAvailHandlingQty(_prodBOMPool.ItemId, wrkCtrInventDim.InventDimId, false)
                        - WHSProdPickQtyAllocation::calculateAllocatedHandlingQty(_prodBOMPool.ItemId, wrkCtrInventDim.InventDimId, waveTable.WaveId, waveExecutionId);

                    this.checkQtyForProdBOMPicking(wrkCtrAvailQty, positiveTransHandlingQty, wrkCtrInventDim, _prodBOM, _whsPoolProdBOM, _inventTrans);

                    // Do not allocate more than we have left to wave / available
                    InventHandlingQty qtyToAllocate = min(positiveTransHandlingQty, _whsPoolProdBOM.handlingQuantityLeftToWave());
                    WHSProdPickQtyAllocation::allocateQty(_prodBOM.ItemId, qtyToAllocate, wrkCtrInventDim.InventDimId, waveTable.WaveId, waveExecutionId);
                    positiveTransHandlingQty = qtyToAllocate;
                }

            }
            else
            {
                wrkCtrInventDim = _inventTrans.inventDim();
            }

            _whsPoolProdBOM.executeWarehousePolicyHandlingQty(
                _inventTrans,
                waveTable.WaveId,
                waveExecutionId,
                wrkCtrInventDim,
                false,
                !InventLocation::find(wrkCtrInventDim.InventLocationId).ProdReserveOnlyWhse,
                positiveTransHandlingQty);
        }
        else
        {
            // Location has not been specified so we try to consume inventory in the work center if available.
            WMSLocationId workCenterInputLocationId = WHSProdTable::getWorkCenterLocationFromProdId(_prodBOM.ProdId, _prodBOM.OprNum, _prodBOM.InventDimId);
            wrkCtrInventDim = _inventTrans.inventDim();

            // Ensure we were able to find a location based on the work center
            if (!workCenterInputLocationId)
            {
                throw error ("@SYP4881949");
            }

            wrkCtrInventDim.wmsLocationId = workCenterInputLocationId;
            wrkCtrInventDim = InventDim::findOrCreate(wrkCtrInventDim);

            // If the item allows it, pick the full qty from the work center even it it means driving it negative.
            if (_prodBOM.inventTable().whsAllowPhysNeg()
                    &&  wrkCtrInventDim.wmsLocation().whsLocationProfile().AllowNegative
                    &&  WHSInventTable::find(_prodBOM.ItemId).PickWCNeg)
            {
                _whsPoolProdBOM.executeWarehousePolicyHandlingQty(
                        _inventTrans,
                        waveTable.WaveId,
                        waveExecutionId,
                        wrkCtrInventDim,
                        true,
                        false,
                        positiveTransHandlingQty);
            }
            else
            {
                
                using (WHSWaveLockManager waveLockManager = WHSWaveLockManager::newStandard())
                {
                    // Throws error on lock acquisition failure.
                    waveLockManager.lockForProdPickQtyAllocation(_prodBOM.ItemId, wrkCtrInventDim.InventDimId, waveTable.WaveId, whsParameters.WaveLockWait);

                    wrkCtrAvailQty = WHSInventOnHand::getWorkPhysicalAvailHandlingQty(_prodBOM.ItemId, wrkCtrInventDim.InventDimId, false);

                    if (wrkCtrAvailQty > 0)
                    {
                        wrkCtrAvailQty -= WHSProdPickQtyAllocation::calculateAllocatedHandlingQty(_prodBOM.ItemId, wrkCtrInventDim.InventDimId, waveTable.WaveId, waveExecutionId);
                        // Do not allocate more than we have left to wave / available
                        InventHandlingQty qtyToAllocate = min(wrkCtrAvailQty, _whsPoolProdBOM.handlingQuantityLeftToWave());
                        WHSProdPickQtyAllocation::allocateQty(_prodBOM.ItemId, qtyToAllocate, wrkCtrInventDim.InventDimId, waveTable.WaveId, waveExecutionId);
                        positiveTransHandlingQty = qtyToAllocate;
                    }
                }
 

                if (wrkCtrAvailQty > 0)
                {
                    if (positiveTransHandlingQty > 0)
                    {
                        _whsPoolProdBOM.executeWarehousePolicyHandlingQty(
                            _inventTrans,
                            waveTable.WaveId,
                            waveExecutionId,
                            wrkCtrInventDim,
                            true,
                            false,
                            positiveTransHandlingQty);
                    }
                    else
                    {
                        _whsPoolProdBOM.executeWarehousePolicyHandlingQty(
                            _inventTrans,
                            waveTable.WaveId,
                            waveExecutionId,
                            wrkCtrInventDim,
                            true,
                            false,
                            wrkCtrAvailQty);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkQtyForProdBOMPicking</Name>
				<Source><![CDATA[
    private void checkQtyForProdBOMPicking(Qty _wrkCtrAvailQty, InventHandlingQty _positiveTransHandlingQty, InventDim _wrkCtrInventDim, ProdBOM _prodBOM, WHSPoolProdBOM _whsPoolProdBOM, InventTrans _inventTrans)
    {
        if (_wrkCtrAvailQty < _positiveTransHandlingQty)
        {
            WHSPostEngine::createWaveExecutionHistoryLine(waveTable.WaveId, waveExecutionId, strFmt("@WAX3335", _whsPoolProdBOM.displayOrderIdAndItemId(), _prodBOM.inventDim().wmsLocationId), false);
            throw error(strFmt("@WAX1815", _wrkCtrInventDim.wmsLocationId, _inventTrans.ItemId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>replenish</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates replenishment work during posting.
    /// </summary>
    /// <returns>
    /// true if replenishment work is created successfully.
    /// </returns>
    [WHSWavePostMethodAttribute(true)]
    public boolean replenish()
    {
        return this.runDemandReplen();
    }

]]></Source>
			</Method>
			<Method>
				<Name>prodReplenish</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates replenishment work during production pick posting.
    /// </summary>
    /// <returns>
    /// true if replenishment work is created successfully.
    /// </returns>
    public boolean prodReplenish()
    {
        return this.runDemandReplen();
    }

]]></Source>
			</Method>
			<Method>
				<Name>kanbanReplenish</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates replenishment work during kanban pick posting.
    /// </summary>
    /// <returns>
    /// true if replenishment work is created successfully.
    /// </returns>
    public boolean kanbanReplenish()
    {
        return this.runDemandReplen();
    }

]]></Source>
			</Method>
			<Method>
				<Name>runDemandReplen</Name>
				<Source><![CDATA[
    private boolean runDemandReplen()
    {
        WHSReplenishmentTemplateLine    templateLine;

        using (var workCreate = new WHSWorkCreateReplenishment(templateLine, waveTable.getWorkBuildId()))
        using (var perfTask = WHSInstrumentationWaveProcessingPerformanceTask::newWaveStepBase(waveTable, waveExecutionId, funcName()))
        using (var appInsightsActivity = WHSWaveProcessingWaveDemandReplenishmentApplicationInsightsActivity::newFromParameters(waveTemplateLine.WaveStepCode))
        {
            workCreate.parmParmWaveId(waveTable.WaveId);
            workCreate.parmReleaseToWarehouseId(releaseToWarehouseId);
            workCreate.parmWaveExecutionId(waveExecutionId);
            workCreate.parmWhsWaveLockManager(whsWaveLockManager);
            workCreate.parmWaveMethodStatusHandler(waveMethodStatusHandler);
            workCreate.runDemandReplen(waveTemplateLine.WaveStepCode);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useTaskBasedProcessing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the wave execution can use task based processing.
    /// </summary>
    /// <param name = "_templateLine">The <c>WHSWaveTemplateLine</c> to check if it should run asynchronously.</param>
    /// <returns>True if the wave template line should executed asynchronously; otherwise false.</returns>
    internal protected final boolean useTaskBasedProcessing(WHSWaveTemplateLine _templateLine)
    {
        boolean useTaskBasedProcessing =
            waveTable.canProcessInBatch() &&
            _templateLine.shouldUseTaskBasedProcessing() &&
            WhsPostEngineBase::taskBasedProcessingThresholdExceeded(_templateLine.PostMethodName, this);
        
        return useTaskBasedProcessing;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taskBasedProcessingThresholdExceeded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines task processing based on threshold limit.
    /// </summary>
    /// <param name = "_postMethodName">The post method name for the wave step.</param>
    /// <param name = "_postEngine">The post engine used for execution of wave processing.</param>
    /// <returns>true if task based processing limit is exceeded; otherwise, false.</returns>
    [Hookable(false)]
    internal static boolean taskBasedProcessingThresholdExceeded(WHSPostMethodName _postMethodName, WHSPostEngine _postEngine)
    {
        var threshold = WHSWaveTaskProcessingThresholdFactory::newFromPostMethodName(_postMethodName);
        threshold.initFromPostEngine(_postEngine);

        return threshold.thresholdExceeded();
    }

]]></Source>
			</Method>
			<Method>
				<Name>runPostMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs the current wave post method.
    /// </summary>
    /// <param name="_waveTemplateLine">
    /// The wave template line for the wave post method to be run.
    /// </param>
    /// <param name="_sysDictClass">
    /// An instance of <c>SysDictClass</c> for the post engine class which contains the wave post method.
    /// </param>
    /// <returns>
    /// true if the post method runs successfully, otherwise, false.
    /// </returns>
    private boolean runPostMethod(
        WHSWaveTemplateLine     _waveTemplateLine,
        SysDictClass            _sysDictClass)
    {
        boolean                 valid;

        WHSWaveStepMethod waveStepMethod = WHSWaveStepMethodFactory::newMethodFromName(_waveTemplateLine.PostMethodName);

        if (waveStepMethod)
        {
            WHSInstrumentationWaveProcessingPerformanceTask perfTask = null;

            // Only track custom wave steps. All base wave steps have their own tracking.
            if (waveStepMethod is WHSCustomWaveStepMethod)
            {
                perfTask = WHSInstrumentationWaveProcessingPerformanceTask::newWaveStepCustom(waveTable, waveExecutionId, waveStepMethod.name());
            }

            try
            {
                valid = this.processWaveStepMethod(waveStepMethod, _waveTemplateLine);
            }
            catch
            {
                // This is a noop catch block, should never be entered, as the call should be within a transaction.
                // This ensures exception handling is consistent regardless of type of exception thrown (kernel or application).
                throw error(Error::wrongUseOfFunction(funcName()));
            }
            finally
            {
                if (perfTask != null)
                {
                    perfTask.endTask();
                }
            }
        }

        return valid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processWaveStepMethod</Name>
				<Source><![CDATA[
    private boolean processWaveStepMethod(WHSWaveStepMethod _waveStepMethod, WHSWaveTemplateLine _waveTemplateLine)
    {
        this.parmWaveTemplateLine(_waveTemplateLine);

        // Create and lock the wave step controller record.
        var lockedControlRecord = WHSWaveStepController::createAndLockControlRecord(waveTable.WaveId, waveExecutionId, _waveTemplateLine.PostMethodName, waveTable.InventLocationId);

        this.updateWaveStepProgressToStarted(_waveTemplateLine);
                
        WHSWaveStepMethodProcessor processor = WHSWaveStepMethodProcessor::newForMethod(_waveStepMethod, this);
        boolean valid = processor.process();

        // Delete control record
        lockedControlRecord.delete();

        this.updateWaveStepProgressToComplete(_waveTemplateLine);

        return valid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWaveStepProgressToComplete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>WHSWaveMethodStatus</c> record for the current wave step to indicate that the step is completed.
    /// </summary>
    /// <param name="_waveTemplateLine">
    /// The waveTemplateLine of the current running wave step.
    /// </param>
    /// <remarks>
    /// The <c>WHSWaveMethodStatus</c> record should be selected already.
    /// </remarks>
    protected void updateWaveStepProgressToComplete(WHSWaveTemplateLine _waveTemplateLine)
    {
        if (createWaveProgressLog)
        {
            // Update wave method status of the current method to completed.
            if (waveMethodStatusHandler)
            {
                waveMethodStatusHandler.updateWaveStepProgressToCompleted();
            }
            else
            {
                WHSWaveMethodStatus::createOrUpdateWaveMethodStatus(waveMethodStatus.WaveId, waveMethodStatus.PostMethodName, false, 0, waveMethodStatus.TotalSteps);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWaveStepProgressToStarted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>WHSWaveMethodStatus</c> record for the current wave step to indicate that the step has started.
    /// </summary>
    /// <param name="_waveTemplateLine">
    /// The waveTemplateLine of the current running wave step.
    /// </param>
    protected void updateWaveStepProgressToStarted(WHSWaveTemplateLine _waveTemplateLine)
    {
        if (createWaveProgressLog)
        {
            waveMethodStatusHandler = WHSWaveMethodStatusHandler::newWaveMethodStatusHandler(waveTable.WaveId, _waveTemplateLine.PostMethodName);
            waveMethodStatusHandler.updateWaveStepProgressToStarted();
            waveMethodStatus = waveMethodStatusHandler.parmWaveMethodStatus();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>workCreationSucceeded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the work creation succeeded.
    /// </summary>
    /// <param name = "_numWorkCreated">The number of work created.</param>
    /// <param name = "_waveTemplate">The wave template record.</param>
    /// <returns>true if the work creation was successful; otherwise, false.</returns>
    protected boolean workCreationSucceeded(WHSNumWorkCreated _numWorkCreated, WHSWaveTemplateTable _waveTemplate)
    {
        switch (_waveTemplate.WaveTemplateType)
        {
            case WHSWaveTemplateType::Production:
            case WHSWaveTemplateType::Kanban:

                if (_numWorkCreated > 0 || waveTable.hasSuccessfulLine())
                {
                    return true;
                }

                return false;
        }

        return _numWorkCreated > 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assertAllTmpWorkLinesProcessed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate that no data is left behind unprocessed at the end of wave processing.
    /// Fail the process if that is the case.
    /// </summary>
    private void assertAllTmpWorkLinesProcessed()
    {
        WHSTmpWorkLine tmpWorkLine;
        select firstonly RecId from tmpWorkLine
            where tmpWorkLine.WaveId == waveTable.WaveId;

        if (tmpWorkLine.RecId != 0)
        {
            throw error(strFmt("@WAX:OrphanTmpWorkLinesFoundAfterWaveProcessing", waveTable.WaveId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>assertWorkCreatedQuantityInSyncWithWorkQuantities</Name>
				<Source><![CDATA[
    private void assertWorkCreatedQuantityInSyncWithWorkQuantities()
    {
        WHSWaveWorkCreatedQuantityValidator validator = WHSWaveWorkCreatedQuantityValidator::newFromWaveTable(waveTable);
        validator.setWaveExecutionId(this.waveExecutionId);
        validator.validate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWaveTableAfterProcessing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the wave appropriately at the end of wave processing.
    /// </summary>
    /// <returns>
    /// The updated <c>WHSWaveTable</c> record.
    /// </returns>
    protected WHSWaveTable updateWaveTableAfterProcessing()
    {
        ttsBegin;

        waveTable = WHSWaveTable::find(waveTable.WaveId, true);
        WHSWaveTemplateTable waveTemplate = waveTable.waveTemplate();
        WHSNumWorkCreated numWorkCreated = waveTable.numWorkCreated();

        if (this.workCreationSucceeded(numWorkCreated, waveTemplate))
        {
            WhsPostEngine::setWaveStatusAfterProcessing(waveTable, numWorkCreated, waveTemplate.AutoReleaseWave);

            waveTable.Execute = NoYes::No;
            waveTable.update();

            if (this.shouldRemoveExecutingWaveBlocking())
            {
                WHSWaveWorkUnblocker::unblockWaveWorkBlockedByReason(waveTable.WaveId, WHSWorkBlockingReasonType::ExecutingWave);
            }

            WHSPostEngine::createWaveExecutionHistoryLine(waveTable.WaveId, waveExecutionId, strFmt("@WAX1617", waveTable.WaveId), false);
            info(strFmt("@WAX1617", waveTable.WaveId));

            WhsWaveNotificationManager::instance().handleNotificationsOnWaveExecuted(waveTable, waveExecutionId, numWorkCreated);
        }
        else
        {
            this.validateNoWorkShouldHaveBeenCreated();

            waveTable.resetToStatusCreated();

            WHSPostEngine::createWaveExecutionHistoryLine(waveTable.WaveId, waveExecutionId, strFmt("@WAX1973", waveTable.WaveId), true);
            Message::AddAction(MessageSeverity::Warning, strFmt("@WAX4777", waveTable.WaveId), "@WAX1710", MessageActionType::DisplayMenuItem, 
                MenuItemMessageActionProvider::createMenuItemWithFilterActionData(MenuItemType::Display, menuitemDisplayStr(WHSWorkCreateHistory), MenuItemMessageActionFilterType::CallerRecord, waveTable));

            WhsWaveNotificationManager::instance().handleNotificationsOnWaveExecuted(waveTable, waveExecutionId, 0, strFmt("@WAX1973", waveTable.WaveId));

            if (waveTemplate.WaveTemplateType == WHSWaveTemplateType::Production
                && waveTemplate.AutoCreateWave
                && waveTemplate.AutoReleaseWave
                && !waveTable.numWorkCreated())
            {
                waveTable.delete();
            }
        }

        ttsCommit;

        return waveTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateNoWorkShouldHaveBeenCreated</Name>
				<Source><![CDATA[
    private void validateNoWorkShouldHaveBeenCreated()
    {
        WHSWaveUpdatedLoadLine waveUpdatedLoadLine = WHSWaveUpdatedLoadLine::findFirstForWave(waveTable.WaveId);
        if (waveUpdatedLoadLine)
        {
            WHSLoadLine loadLineErr = WHSLoadLine::findbyRecId(waveUpdatedLoadLine.LoadLineRefRecId);

            throw error(strFmt("@WAX:WaveProcessingShouldHaveCreatedWorkError", waveTable.WaveId, loadLineErr.InventTransId, loadLineErr.LoadId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWave</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the wave.
    /// </summary>
    /// <returns>
    ///    true if the validation succeeded; otherwise, false.
    /// </returns>
    /// <exception cref="Exception::Error">
    ///    The wave cannot be posted, because it has one or more invalid loads.
    /// </exception>
    public boolean validateWave()
    {
        using (var perfTask = WHSInstrumentationWaveProcessingPerformanceTask::newWaveStepBase(waveTable, waveExecutionId, funcName()))
        using (var appInsightsActivity = WHSWaveProcessingValidateWaveApplicationInsightsActivity::construct())
        {
            this.validateLoads();
            appInsightsActivity.validateWaveSucceeded();
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>immediatelyStartNextBatchTaskForWave</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs the manual system check for new batch jobs to run.
    /// </summary>
    /// <remarks>
    /// This is intended to be run for batch waves in which several dependent batch jobs are created and run during the waving process.
    /// To avoid unnecessary delays we don't want to wait for the normal batch polling for the next task to start.
    /// </remarks>
    public static void immediatelyStartNextBatchTaskForWave()
    {
        // To avoid unnecessary delays we call into a manual check for open batch tasks.
        xApplication::checkForNewBatchJobs();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of <c>WHSPostEngineBase</c> based on the provided parameters.
    /// </summary>
    /// <param name="_waveId">
    /// The wave Id of the wave the post engine will be processing.
    /// </param>
    /// <param name="_waveExecutionId">
    /// The wave execution Id that uniquely identifies this run of the wave.
    /// </param>
    /// <param name="_releaseToWarehouseId">
    /// The release to warehouse Id that trigged this wave process; optional.
    /// </param>
    /// <param name="_lastRunWaveStep">
    /// The last wave step in the wave template that has ben run by the wave process prior to this instance of the post engine.
    /// </param>
    /// <returns>
    /// An instance of the <c>WHSPostEngineBase</c> class.
    /// </returns>
    public static WHSPostEngineBase newFromParameters(
        WHSWaveId               _waveId,
        WHSWaveExecutionID      _waveExecutionId,
        WHSReleaseToWarehouseId _releaseToWarehouseId = '',
        WHSWaveStep             _lastRunWaveStep = 0)
    {
        WHSPostEngineBase   baseEngine;

        baseEngine = WHSPostEngineBase::construct();
        //We may be in a situation where the wave was updated on a different AOS so we must read it inside tts due the the WHSWaveTable cache setting to avoid getting stale data.
        WHSWaveTable waveTable = WHSWaveTable::findEnsureRecordIsReadInsideTTS(_waveId);
        baseEngine.parmWaveTable(waveTable);
        baseEngine.parmWaveExecutionId(_waveExecutionId);
        baseEngine.parmReleaseToWarehouseId(_releaseToWarehouseId);
        baseEngine.parmLastRunWaveStep(_lastRunWaveStep);

        return baseEngine;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>