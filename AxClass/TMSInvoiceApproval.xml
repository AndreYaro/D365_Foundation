<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TMSInvoiceApproval</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>TMSInvoiceApproval</c> class is used to submit, approve, reject invoices and reconcile freight bills with matched invoice lines.
/// </summary>
public class TMSInvoiceApproval
{
    protected Dialog        dlg;
    protected DialogField   invoiceTotal;
    protected DialogField   totalMatched;
    protected DialogField   totalRecon;
    protected DialogField   totalNotRecon;
    protected DialogField   dlgReasonCode;
    protected DialogField   payAmount;
    protected RecId         invoiceLineRecId;
    protected Voucher       voucherId;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>approveInvoiceLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates journal lines for all reconciled and matched amounts and then insures the invoice is of approved status.
    /// </summary>
    /// <param name="_invoiceLine">
    /// The <c>TMSInvoiceLine</c> record.
    /// </param>
    /// <param name="_journalId">
    /// The journal ID.
    /// </param>
    /// <returns>
    /// The journal ID that was passed in the parameters or a newly created journal ID if the passed one was empty
    /// </returns>
    public JournalId approveInvoiceLine(TMSInvoiceLine _invoiceLine, JournalId _journalId = '')
    {
        LedgerJournalId                     journalId;
        TMSInvoiceLineReconcile             invoiceRec;
        TMSFBInvMatch                       freightDetailMatched;

        journalId = _journalId ?
                    _journalId :
                    this.createLedgerJournalTable(_InvoiceLine.InternalInvNumber);

        ttsBegin;

        // Update reconciled status
        while select forUpdate invoiceRec
            where invoiceRec.InvoiceLineRecId    == _invoiceLine.RecId   &&
                  invoiceRec.Amount              != 0                    &&
                  invoiceRec.WorkflowStatus      == TMSWorkflowStatus::Submitted
        {
            invoiceRec.WorkflowStatus = TMSWorkflowStatus::Approved;
            invoiceRec.update();
        }

        // Update match status
        while select forUpdate freightDetailMatched
            where freightDetailMatched.InvoiceLineRecId      == _invoiceLine.RecId   &&
                  freightDetailMatched.RateCur               != 0                    &&
                  freightDetailMatched.WorkflowStatus        == TMSWorkflowStatus::Submitted
        {
            freightDetailMatched.WorkflowStatus = TMSWorkflowStatus::Approved;
            freightDetailMatched.update();
        }

        _invoiceLine.selectForUpdate(true);

        // Update invoice line status
        switch (_invoiceLine.InvoiceLineStatus)
        {
            case TMSInvoiceLineStatus::Rejected:
                break;

            default:
                if (_invoiceLine.NetAmount <= _invoiceLine.amountApproved())
                {
                    _invoiceLine.InvoiceLineStatus = TMSInvoiceLineStatus::Approved;
                    break;
                }
                _invoiceLine.InvoiceLineStatus = TMSInvoiceLineStatus::PartiallyApproved;
                break;
        }

        _invoiceLine.InvoiceStatus = TMSInvoiceTable::find(_invoiceLine.InternalInvNumber).InvoiceStatus;
        _invoiceLine.update();

        // Create reference
        this.createJournalReference(_invoiceLine.RecId, _invoiceLine.TableId, journalId);

        ttsCommit;

        return journalId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>changeMatchReconcileStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Changes Reconcile and Matched records' workflow status for the specified invoice line.
    /// </summary>
    /// <param name="_invoiceLine">
    /// The <c>TMSInvoiceLine</c> record of the invoice line to change.
    /// </param>
    /// <param name="_status">
    /// The workflow new status.
    /// </param>
    public void changeMatchReconcileStatus(TMSInvoiceLine _invoiceLine, TMSWorkflowStatus _status)
    {
        TMSFBInvMatch            fbMatched;
        TMSInvoiceLineReconcile  reconcile;

        switch (_status)
        {
            // Submitted
            case TMSWorkflowStatus::Submitted:
                while select forUpdate reconcile
                    where reconcile.InvoiceLineRecId     == _invoiceLine.RecId           &&
                          reconcile.WorkflowStatus       < TMSWorkflowStatus::Submitted
                {
                    reconcile.WorkflowStatus = TMSWorkflowStatus::Submitted;
                    reconcile.update();
                }

                while select forUpdate fbMatched
                    where fbMatched.InvoiceLineRecId     == _invoiceLine.RecId           &&
                          fbMatched.WorkflowStatus       < TMSWorkflowStatus::Submitted
                {
                    fbMatched.WorkflowStatus = TMSWorkflowStatus::Submitted;
                    fbMatched.update();
                }
                break;

            // Reviewed
            case TMSWorkflowStatus::Reviewed:
                while select forUpdate reconcile
                    where reconcile.InvoiceLineRecId     == _invoiceLine.RecId           &&
                          (reconcile.WorkflowStatus      == TMSWorkflowStatus::None      ||
                          reconcile.WorkflowStatus       == TMSWorkflowStatus::PendingReview)
                {
                    reconcile.WorkflowStatus = TMSWorkflowStatus::Reviewed;
                    reconcile.update();

                    info(strFmt("@TRX1305", reconcile.FreightReasonCode, reconcile.Amount));
                }

                while select forUpdate fbMatched
                    where fbMatched.InvoiceLineRecId    == _invoiceLine.RecId           &&
                          (fbMatched.WorkflowStatus     == TMSWorkflowStatus::None      ||
                          fbMatched.WorkflowStatus      == TMSWorkflowStatus::PendingReview)
                {
                    fbMatched.WorkflowStatus = TMSWorkflowStatus::Reviewed;
                    fbMatched.update();

                    info(strFmt("@TRX1306", fbMatched.RateCur));
                }
                break;

            // Pending Review
            case TMSWorkflowStatus::PendingReview:
                while select forUpdate reconcile
                    where reconcile.InvoiceLineRecId     == _invoiceLine.RecId           &&
                          reconcile.WorkflowStatus       == TMSWorkflowStatus::Submitted
                {
                    reconcile.WorkflowStatus = TMSWorkflowStatus::PendingReview;
                    reconcile.update();
                }

                while select forUpdate fbMatched
                    where fbMatched.InvoiceLineRecId    == _invoiceLine.RecId           &&
                          fbMatched.WorkflowStatus      == TMSWorkflowStatus::Submitted
                {
                    fbMatched.WorkflowStatus = TMSWorkflowStatus::PendingReview;
                    fbMatched.update();
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInvoiceLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks to see if all detail lines are either matched or reconciled 100%
    /// If not, run reconcile invoice form
    /// </summary>
    /// <param name="_invoiceTable">
    /// The record of <c>TMSInvoiceTable</c> to be checked
    /// </param>
    /// <returns>
    /// true if all detail lines are either matched or reconciled 100%; otherwise, false
    /// </returns>
    boolean checkInvoiceLines(TMSInvoiceTable _invoiceTable)
    {
        TMSInvoiceLine  invoiceLine;
        boolean         ret = true;

        while select invoiceLine
            where invoiceLine.InternalInvNumber  == _invoiceTable.InternalInvNumber &&
                  (invoiceLine.InvoiceLineStatus == TMSInvoiceLineStatus::Open         ||
                  invoiceLine.InvoiceLineStatus  == TMSInvoiceLineStatus::PartiallyApproved)
        {
            if (this.shouldRunFormTMSReconcileInvoice(invoiceLine))
            {
                ret = this.runFormTMSReconcileInvoice(_invoiceTable);

                break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runFormTMSReconcileInvoice</Name>
				<Source><![CDATA[
    private boolean runFormTMSReconcileInvoice(TMSInvoiceTable _invoiceTable)
    {
        Args args = new Args();
        args.record(_invoiceTable);
        MenuFunction menuFunction = new MenuFunction(menuItemDisplayStr(TMSReconcileInvoice), MenuItemType::Display);
        FormRun formRun = menuFunction.create(args);
        formRun.run();
        formRun.wait();
        formRun.close();

        boolean ret = formRun.closedOk();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldRunFormTMSReconcileInvoice</Name>
				<Source><![CDATA[
    private boolean shouldRunFormTMSReconcileInvoice(TMSInvoiceLine _invoiceLine)
    {
        boolean ret = true;

        
        ret =  (abs(_invoiceLine.NetAmount) > (abs(_invoiceLine.amountMatched()) + abs(_invoiceLine.amountReconciled())));
        

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createComment</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates docuref record for Invoice Line Reconciliation.
    /// </summary>
    /// <param name="_invLineReconcile">
    ///     The record of <c>TMSInvoiceLineReconcile</c>.
    /// </param>
    /// <param name="_comment">
    ///     The comment.
    /// </param>
    void createComment(TMSInvoiceLineReconcile _invLineReconcile,
                       Description             _comment)
    {
        DocuRef docuRef;

        ttsBegin;

        docuRef.RefRecId        = _invLineReconcile.RecId;
        docuRef.RefTableId      = _invLineReconcile.TableId;
        docuRef.RefCompanyId    = _invLineReconcile.dataAreaId;
        docuRef.TypeId          = TMSParameters::find().DefaultNoteType;
        docuRef.Name            = TMSParameters::find().DefaultNoteName;
        docuRef.Notes           = _comment;
        docuRef.insert();

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInvoiceText</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Append line number onto Invoice Id if more than one invoice journal exists
    /// </summary>
    /// <param name="_journalNum">
    ///     The Journal Number for the invoice text.
    /// </param>
    /// <param name="_invoiceTable">
    ///     The invoice table to evaluate against.
    /// </param>
    /// <param name="_lineNum">
    ///     The Line number of the invoice.
    /// </param>
    /// <returns>
    ///     The invoice text that will be displayed for Invoice approvals.
    /// </returns>
    str createInvoiceText(
        LedgerJournalId _journalNum,
        TMSInvoiceTable _invoiceTable = null,
        LineNum         _lineNum = 0.0)
    {
        str     ret;

        if (_invoiceTable)
        {
            ret = _lineNum ? strFmt("@SYS309930", _invoiceTable.VendInvoiceId, _lineNum) : _invoiceTable.VendInvoiceId;
        }

        else
        {
            ret = _journalNum;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalReference</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates reference record between invoice line and journal num.
    /// </summary>
    /// <param name="_recId">
    ///     The ID of the record.
    /// </param>
    /// <param name="_tableId">
    ///     The ID of the table.
    /// </param>
    /// <param name="_journalId">
    ///     The ID of the journal.
    /// </param>
    void createJournalReference(RecId       _recId,
                                TableId     _tableId,
                                JournalId   _journalId)
    {
        TMSLedgerJourRef ledgerJourRef;

        ttsBegin;

        ledgerJourRef.RefRecId          = _recId;
        ledgerJourRef.RefTableId        = _tableId;
        ledgerJourRef.RefJournalNum     = _journalId;
        ledgerJourRef.insert();

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a ledger journal record for TMS invoice.
    /// </summary>
    /// <param name="_invNum">
    /// TMS internal invoice number.
    /// </param>
    /// <param name="_name">
    /// Name of the journal.
    /// </param>
    /// <returns>
    /// The ledger journal id.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Vendor journal name should be set in TMS parameters.
    /// </exception>
    LedgerJournalId createLedgerJournalTable(TMSInternalInvNumber   _invNum = '',
                                             Name                   _name   = '')
    {
        LedgerJournalTable      ledgerJournalTable;
        Name                    journalName = TMSParameters::find().VendJournalName;
        TMSInvoiceTable         invoiceTable = TMSInvoiceTable::find(_invNum);
        LedgerJournalTable      journalTable;
        CurrencyCode            currencyCode;

        if (journalName == '')
        {
            throw error(strFmt("@SYS133253", strFmt('%1 (%2)', "@TRX813","@TRX29")));
        }

        currencyCode = invoiceTable ? invoiceTable.CurrencyCode : CompanyInfoHelper::standardCurrency();

        journalTable.JournalName = journalName;
        journalTable.Name = strFmt("@TRX1252", _invNum, invoiceTable.LoadId, invoiceTable.RelatedOrderNum);
        journalTable.JournalType = LedgerJournalType::VendInvoiceRegister;
        journalTable.VoucherAllocatedAtPosting = LedgerJournalName::find(journalName).VoucherAllocatedAtPosting;
        journalTable.CurrencyCode = invoiceTable.CurrencyCode;

        journalTable.DelayTaxCalculation = TaxParameters::find().DelayTaxCalculation;

        journalTable.initValue();
        journalTable.defaultRow();

        if (journalTable.VoucherAllocatedAtPosting && TMSAllowFreightInvoiceJournalUseTempVoucherToggle::instance().isEnabled())
        {
            journalTable.NumberSequenceTable = LedgerParameters::numRefLedgerTempVoucher().numberSequenceTable().RecId;
        }

        journalTable.insert();

        ttsbegin;

        ledgerJournalTable = ledgerJournalTable::find(journalTable.JournalNum);
        ledgerJournalTable.selectForUpdate(true);
        ledgerJournalTable.Name             = _name ? _name : strFmt("@TRX1252", _invNum, invoiceTable.LoadId, invoiceTable.RelatedOrderNum);
        ledgerJournalTable.CurrencyCode     = currencyCode;
        ledgerJournalTable.write();

        ttscommit;

        return ledgerJournalTable.JournalNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Create the ledger Journal trans and update the num of lines on header.
    /// </summary>
    /// <param name="_journalNum">
    ///     The journal ID of the ledger journal transaction.
    /// </param>
    /// <param name="_creditAmount">
    ///     The credit amount for the ledger journal transaction.
    /// </param>
    /// <param name="_debitAdmount">
    ///     The debit amount for the ledger journal transaction.
    /// </param>
    /// <param name="_dynamicAccount">
    ///     The associated account for the ledger journal transaction.
    /// </param>
    /// <param name="_currencyCode">
    ///     The currency of the ledger journal transaction.
    /// </param>
    /// <param name="_acType">
    ///     The ac type of the ledger journal transaction.
    /// </param>
    /// <param name="_txt">
    ///     The transaction text of the ledger journal transaction.
    /// </param>
    /// <param name="_invoiceTable">
    ///     The associated invoice table.
    /// </param>
    /// <param name="_lineNum">
    ///     The associated line number of the invoice.
    /// </param>
    /// <param name="_taxGroup">
    ///     The tax group for the journal transaction.
    /// </param>
    /// <param name="_taxItemGroup">
    ///     The tax item group for the journal transaction.
    /// </param>
    /// <param name="_transactionType">
    ///     The transaction type of the journal transaction.
    /// </param>
    /// <param name="_useCreditVoucher">
    ///     Determine wheter journal transaction would use voucher from credit line.
    /// </param>
    /// <param name="_markUpTrans">
    ///     A record of journal transaction.
    /// </param>
    void createLedgerJournalTrans(
        LedgerJournalId          _journalNum,
        AmountCurCredit          _creditAmount,
        AmountCurDebit           _debitAdmount,
        DimensionDynamicAccount  _dynamicAccount,
        CurrencyCode             _currencyCode,
        LedgerJournalACType      _acType             = LedgerJournalACType::Vend,
        str                      _txt                = '',
        TMSInvoiceTable          _invoiceTable       = null,
        LineNum                  _lineNum            = 0.0,
        TaxGroup                 _taxGroup           = '',
        TaxItemGroup             _taxItemGroup       = '',
        LedgerTransType          _transactionType    = LedgerTransType::None,
        boolean                  _useCreditVoucher   = false,
        MarkupTrans              _markUpTrans        = null)
    {
        LedgerJournalTable                  ledgerJournalTable;
        LedgerJournalTrans                  ledgerJournalTrans;
        VendTable                           vendTable;
        Tax1099Fields                       tax1099;
        DimensionAttributeValueCombination  davc;
        RecId                               ledgerJournalTransRecId;

        AccountNum                          account;
        int                                 numOfLines;
        LedgerJournalEngine_VendInvoice     ledgerJournalEngine;

        if (_creditAmount == 0 && _debitAdmount == 0)
        {
            return; // no need for ledger journal lines with zero amounts
        }

        ledgerJournalTable  = LedgerJournalTable::find(_journalNum, true);
        numOfLines          = ledgerJournalTable.numOfLines() + 1;

        davc = DimensionAttributeValueCombination::find(_dynamicAccount);

        if (davc.LedgerDimensionType == LedgerDimensionType::DefaultAccount
            || davc.LedgerDimensionType == LedgerDimensionType::Account)
        {
            account     = LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_dynamicAccount);
            if (_acType == LedgerJournalACType::Vend)
            {
                vendTable   = vendTable::find(account);
                ledgerJournalEngine = new LedgerJournalEngine_VendInvoice();
                tax1099             = Tax1099Fields::find(vendTable.Tax1099Fields);
            }
        }

        ledgerJournalTrans.DelayTaxCalculation = TaxParameters::find().DelayTaxCalculation;
        ledgerJournalTrans.JournalNum = _journalNum;
        ledgerJournalTrans.LineNum = numOfLines;
        ledgerJournalTrans.OffsetAccountType = LedgerJournalACType::Ledger;
        ledgerJournalTrans.AccountType = _acType;
        ledgerJournalTrans.LedgerDimension = _dynamicAccount;
        if (_invoiceTable.DocumentDate)
        {
            ledgerJournalTrans.TransDate = _invoiceTable.DocumentDate;
        }
        else
        {
            ledgerJournalTrans.TransDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        }
        ledgerJournalTrans.AmountCurCredit = abs(_creditAmount);
        ledgerJournalTrans.AmountCurDebit = abs(_debitAdmount);
        ledgerJournalTrans.Txt = _txt;
        ledgerJournalTrans.DocumentNum = _invoiceTable.DocumentNum;
        ledgerJournalTrans.DocumentDate = _invoiceTable.InvoiceDate;
        ledgerJournalTrans.CashDiscCode = _invoiceTable.CashDiscCode ? _invoiceTable.CashDiscCode : vendTable.CashDisc;
        ledgerJournalTrans.DateCashDisc = DateTimeUtil::date(_invoiceTable.CashDiscUTCDateTime);
        ledgerJournalTrans.CashDiscAmount = _invoiceTable.DiscAmount;
        ledgerJournalTrans.Tax1099Fields = tax1099.RecId;
        ledgerJournalTrans.Invoice = this.createInvoiceText(_journalNum, _invoiceTable, _lineNum);
        ledgerJournalTrans.Company = curext();

        if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
        {
            if (!_invoiceTable.CashDiscCode)
            {
                ledgerJournalEngine.accountModified(ledgerJournalTrans);
            }

            ledgerJournalTrans.PostingProfile = VendParameters::find().PostingProfile;
            ledgerJournalTrans.Payment = vendTable.PaymTermId;
            ledgerJournalTrans.PaymMode = vendTable.PaymMode;
            if (vendTable.PaymSpec)
            {
                ledgerJournalTrans.PaymSpec = vendTable.PaymSpec;
            }
            else
            {
                ledgerJournalTrans.PaymSpec = VendPaymModeSpec::find(vendTable.PaymMode).Specification;
            }
            ledgerJournalTrans.CustVendBankAccountId = vendTable.BankAccount;
        }

        ledgerJournalTrans.CurrencyCode = _currencyCode;
        ledgerJournalTrans.ExchRate = ExchangeRateHelper::exchRate(_currencyCode);
        ledgerJournalTrans.ReportingCurrencyExchRate = ExchangeRateHelper::exchRate(_currencyCode);

        if (_invoiceTable.DueUTCDateTime)
        {
            ledgerJournalTrans.Due = DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(_invoiceTable.DueUTCDateTime, DateTimeUtil::getCompanyTimeZone()));
        }

        ledgerJournalTrans.Approver = DirPersonUserEx::worker(DirPersonUser::find(TMSParameters::find().WorkflowUser));
        ledgerJournalTrans.Approved = this.computeLedgerJournalTransApprovedStatus(_invoiceTable);
        
        ledgerJournalTrans.TaxGroup = ledgerJournalTrans.AccountType == LedgerJournalACType::Vend ? vendTable.TaxGroup : _taxGroup;

        if (_taxItemGroup)
        {
            ledgerJournalTrans.TaxItemGroup = _taxItemGroup;
        }
        else if (_markUpTrans.RecId)
        {
            MarkupTable markUpTable = MarkupTable::find(_markUpTrans.ModuleType, _markUpTrans.MarkupCode);
            ledgerJournalTrans.TaxItemGroup = markUpTable.TaxItemGroup;
        }

        ledgerJournalTrans.TransactionType = _transactionType;

        if (ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger)
        {
            MainAccountLegalEntity mainAccountLegalEntity = MainAccountLegalEntity::findByMainAccountLegalEntity(ledgerJournalTrans.findMainAccount().RecId, CompanyInfo::current());
            if (!ledgerJournalTrans.TaxItemGroup)
            {
                ledgerJournalTrans.TaxItemGroup = mainAccountLegalEntity.TaxItemGroup;
            }
                
            if (mainAccountLegalEntity.DefaultDimension && TMSInvoiceJournalApplyDefaultDimensionFlight::instance().isEnabled())
            {
                ledgerJournalTrans.LedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerJournalTrans.LedgerDimension, mainAccountLegalEntity.DefaultDimension);
            }
        }

        if (ledgerJournalEngine
            && ledgerJournalTrans.CashDiscCode
            && _taxGroup != vendTable.TaxGroup)
        {
            ledgerJournalEngine.correctTaxAmount(ledgerJournalTrans, 0); // clear manual tax regulation
            ledgerJournalEngine.clearTaxAmountCache(ledgerJournalTrans);
            ledgerJournalEngine.cashDiscCodeModified(ledgerJournalTrans);
        }

        if (ledgerJournalTrans.listCodeAllowed())
        {
            ledgerJournalTrans.setListCode();
        }
        else
        {
            ledgerJournalTrans.Listcode = Listcode::IncludeNot;
        }

        if (voucherId && TMSInvoiceJournalInitVoucherFlight::instance().isEnabled())
        {
            ledgerJournalTrans.Voucher = voucherId;
            ledgerJournalTrans.fieldState(fieldNum(LedgerJournalTrans, Voucher), FieldState::Defaulted);
        }

        ledgerJournalTrans.initValue();
        ledgerJournalTrans.defaultRow();

        ledgerJournalTrans.insert();

        // update lines for ledgerJournalTable
        ledgerJournalTable.NumOfLines = numOfLines;
        ledgerJournalTable.update();

        boolean reuseVoucher = TMSInvoiceJournalReuseVoucherFlight::instance().isEnabled();

        if (reuseVoucher)
        {
            voucherId = ledgerJournalTrans.Voucher;
        }

        if ((_lineNum > 1 && !voucherId) || (_useCreditVoucher && voucherId) || (_lineNum == 0 && !_useCreditVoucher && !voucherId))
        {
            ttsBegin;

            ledgerJournalTransRecId = ledgerJournalTrans.RecId;

            select forUpdate ledgerJournalTrans
                where ledgerJournalTrans.RecId == ledgerJournalTransRecId;

            ledgerJournalTrans.Voucher = _useCreditVoucher ? voucherId : this.createNewVoucher(_journalNum);
            ledgerJournalTrans.write();

            ttsCommit;
        }

        if (!reuseVoucher)
        {
            voucherId = ledgerJournalTrans.Voucher;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>computeLedgerJournalTransApprovedStatus</Name>
				<Source><![CDATA[
    private Approved computeLedgerJournalTransApprovedStatus(TMSInvoiceTable _invoiceTable)
    {
        return _invoiceTable.InvoiceStatus == TMSInvoiceStatus::Approved
            || _invoiceTable.InvoiceStatus == TMSInvoiceStatus::PartiallyApproved;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Create a new voucher for a given ledger journal
    /// </summary>
    /// <param name="_ledgerJournalId">
    ///     The journal ID of the voucher to be created.
    /// </param>
    /// <returns>
    ///     Voucher ID
    /// </returns>
    public LedgerJournalId createNewVoucher(LedgerJournalId _ledgerJournalId)
    {
        LedgerJournalTable  ledgerJournalTable;
        LedgerJournalName   ledgerJournalName;
        LedgerJournalTrans  ledgerJournalTrans;
        Voucher             ret;
        boolean             reuseVoucher = TMSInvoiceJournalReuseVoucherFlight::instance().isEnabled();

        select firstonly JournalNum from ledgerJournalTable
            where ledgerJournalTable.JournalNum == _ledgerJournalId
        join firstonly NewVoucher from ledgerJournalName
            where ledgerJournalName.JournalName == ledgerJournalTable.JournalName;

        if (!reuseVoucher)
        {
            ret = new JournalVoucherNum(JournalTableData::newTable(LedgerJournalTable::find(_ledgerJournalId))).getNew(false);
        }

        if (ledgerJournalName.NewVoucher == NewVoucher::OneVoucher)
        {
            select firstonly Voucher from ledgerJournalTrans
                where ledgerJournalTrans.JournalNum == _ledgerJournalId;

            if (ledgerJournalTrans)
            {
                ret = ledgerJournalTrans.Voucher;
            }
        }

        if (reuseVoucher && !ret)
        {
            ret = new JournalVoucherNum(JournalTableData::newTable(LedgerJournalTable::find(_ledgerJournalId))).getNew(false);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets freight bill detail id as transaction text.
    /// </summary>
    /// <param name="_source">
    /// The source record.
    /// </param>
    /// <returns>
    /// The transaction text.
    /// </returns>
    /// <remarks>
    /// The source record can only be a record from <c>TMSInvoiceLine</c> table,
    /// <c>TMSFreightBillDetail</c> table or <c>TMSFBInvMatch</c> table.
    /// </remarks>
    str createTransText(Common _source)
    {
        str                     ret;
        TMSInvoiceLine          invoiceLine;
        TMSFreightBillDetail    fbDetail;
        TMSFBInvMatch           fbMatch;

        switch (_source.TableId)
        {
            case tableNum(TMSInvoiceLine):
                invoiceLine = _source;
                ret         = TMSInvoiceLine::findRelatedFreightBill(invoiceLine.RecId).FreightBillId;
                break;

            case tableNum(TMSFreightBillDetail):
                fbDetail    = _source;
                ret         = fbDetail.FreightBillId;
                break;

            case tableNum(TMSFBInvMatch):
                fbMatch     = _source;
                fbDetail    = TMSFreightBillDetail::find(fbMatch.FreightBillDetailRecId);
                ret         = fbDetail.FreightBillId;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrCreateDynamicDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds or creates dynamic dimension account combining account and dimensions.
    /// </summary>
    /// <param name="_account">
    /// The account to be combined.
    /// </param>
    /// <param name="_dimensions">
    /// The dimensions to be combined.
    /// </param>
    /// <returns>
    /// The dynamic dimension account.
    /// </returns>
    DimensionDynamicAccount findOrCreateDynamicDimension(DimensionDynamicAccount _account, DimensionDynamicAccount _dimensions)
    {
        DimensionAttributeValueCombination  davc;
        DimensionAttributeValueSetItem      dimAttValueSetItem;
        DimensionAttributeValueSet          dimAttValueSet;
        DimensionAttributeValue             dimAttValue;
        DimensionAttribute                  dimAtt;
        DimensionDynamicAccount             dynamicDimension;
        AccountNum                          account;

        DefaultDimensionIntegrationValues   dimensionNames;
        DimensionDisplayValue               dimensionValues;

        davc = DimensionAttributeValueCombination::find(_account);

        // The dimension combination has to be of type Account (indicating account and possibiity of dims)
        // Misc. Charge references a default account
        if (davc.LedgerDimensionType == LedgerDimensionType::DefaultAccount)
        {
            dimensionNames = DimensionAttribute::find(DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount)).Name;
            dimensionValues = LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_account);
            str delimiter = DimensionParameters::getDimensionSegmentDelimiter();

            // Add order line dimensions
            while select dimAttValueSetItem
                join RecId from dimAttValueSet
                where dimAttValueSet.RecId                          == _dimensions &&
                      dimAttValueSetItem.DimensionAttributeValueSet == dimAttValueSet.RecId
                    join RecId, DimensionAttribute from dimAttValue
                    where dimAttValue.RecId == dimAttValueSetItem.DimensionAttributeValue
                        join RecId, Name from dimAtt
                        where dimAtt.RecId == dimAttValue.DimensionAttribute
            {
                // Add the dimension name and dimension value
                dimensionNames += delimiter;
                dimensionValues += delimiter;

                dimensionNames += dimAtt.Name;
                dimensionValues += strReplace(dimAttValueSetItem.DisplayValue, delimiter, '\\' + delimiter);
            }

            LedgerAccountDimensionResolver ledgerAccountDimensionResolver = LedgerAccountDimensionResolver::newResolver(dimensionValues);
            ledgerAccountDimensionResolver.parmDimensionFormat(dimensionNames);
            dynamicDimension = ledgerAccountDimensionResolver.resolve();
        }

        return dynamicDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrCreateLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates both the credit and debit transactions.
    /// </summary>
    /// <param name="_journalNum">
    ///     The journal ID of the ledger journal transactions.
    /// </param>
    /// <param name="_amount">
    ///     the amount of the ledger journal transactions.
    /// </param>
    /// <param name="_credit">
    ///     The credit amount for the ledger journal transactions.
    /// </param>
    /// <param name="_debit">
    ///     The debit amount for the ledger journal transactions.
    /// </param>
    /// <param name="_acType">
    ///     The ac type of the ledger journal transactions.
    /// </param>
    /// <param name="_txt">
    ///     The transaction text of the ledger journal transactions.
    /// </param>
    /// <param name="_currencyCode">
    ///     The currency of the ledger journal transactions.
    /// </param>
    /// <param name="_invoiceLineRecId">
    ///     The associated record Id of the invoice table.
    /// </param>
    /// <param name="_invoiceTable">
    ///     The associated invoice table.
    /// </param>
    /// <param name="_vendTxt">
    ///     The Transaction text for vendor records.
    /// </param>
    /// <param name="_lineNum">
    ///     The associated line number of the invoice.
    /// </param>
    /// <param name="_newInvoiceLine">
    ///     Reference a new invoice line.
    /// </param>
    /// <param name="_taxGroup">
    ///     The tax group for the journal transaction.
    /// </param>
    /// <param name="_taxItemGroup">
    ///     The tax item group for the journal transaction.
    /// </param>
    /// <param name="_markUpTrans">
    ///     A record of journal transaction.
    /// </param>
    /// <remarks>
    ///     Find journal with same account, account type, offset account, and offset dimensions
    ///     If record update qty, else create new journal line
    /// </remarks>
    public void findOrCreateLedgerJournalTrans(
        LedgerJournalId         _journalNum,
        AmountCurCredit         _amount,
        DimensionDynamicAccount _credit,
        DimensionDynamicAccount _debit,
        LedgerJournalACType     _acType,
        str                     _txt,
        CurrencyCode            _currencyCode,
        RecId                   _invoiceLineRecId,
        TMSInvoiceTable         _invoiceTable = null,
        str                     _vendTxt = '',
        LineNum                 _lineNum = 0.0,
        boolean                 _newInvoiceLine = false,
        TaxGroup                _taxGroup = '',
        TaxItemGroup            _taxItemGroup = '',
        MarkupTrans             _markUpTrans = null)
    {
        boolean         useVoucherId = true;
        InvoiceId       invoiceId = this.createInvoiceText(_journalNum, _invoiceTable, _lineNum);

        ttsbegin;

        // Create ledger credit line
        if (_acType == LedgerJournalACType::Vend)
        {
            // Create vendor line
            if (!this.updateLedgerJournalTrans(_journalNum, _credit, _amount, _txt, _invoiceLineRecId, invoiceId, true))
            {
                this.createLedgerJournalTrans(_journalNum,
                                                _amount < 0 ? 0 : _amount,
                                                _amount < 0 ? _amount : 0,
                                                _credit,
                                                _currencyCode,
                                                LedgerJournalACType::Vend,
                                                _vendTxt,
                                                _invoiceTable,
                                                _lineNum,
                                                _taxGroup,
                                                _taxItemGroup,
                                                LedgerTransType::Vend,
                                                false,_markUpTrans);
                // Due to limitation of impact, using voucher id would happen for debit lines only while the credit lines are updated.
                useVoucherId = false;
            }
        }
        else
        {
            // find or create line
            if (!this.updateLedgerJournalTrans(_journalNum, _credit, _amount, _txt, _invoiceLineRecId, invoiceId, true))
            {
                this.createLedgerJournalTrans(_journalNum,
                                              _amount,
                                              0,
                                              _credit,
                                              _currencyCode,
                                              LedgerJournalACType::Ledger,
                                              _txt,
                                              _invoiceTable,
                                              _lineNum,
                                              _taxGroup,
                                              _taxItemGroup);
                // Due to limitation of impact, using voucher id would happen for debit lines only while the credit lines are updated.
                useVoucherId = false;
            }
        }

        // find or create line ledger debit line
        this.createLedgerJournalTrans(_journalNum,
                                        _amount < 0 ? _amount : 0,
                                        _amount < 0 ? 0 : _amount,
                                        _debit,
                                        _currencyCode,
                                        LedgerJournalACType::Ledger,
                                        _txt,
                                        _invoiceTable,
                                        _lineNum,
                                        _taxGroup,
                                        _taxItemGroup,
                                        LedgerTransType::None,
                                        useVoucherId,
                                        _markUpTrans);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts journal.
    /// </summary>
    /// <param name="_journalId">
    /// Id of the journal to be posted.
    /// </param>
    void postJournal(JournalId _journalId)
    {
        LedgerJournalTable      journalTable = LedgerJournalTable::find(_journalId);
        LedgerJournalCheckPost  journalCheckPost;

        ttsBegin;

        journalCheckPost = LedgerJournalCheckPost::newLedgerJournalTable(journalTable, NoYes::Yes);
        LedgerJournalCheckPost::processOperation(journalCheckPost);

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processFreightBills</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates journal reference record and updates status of a freight bill if it is fully matched.
    /// </summary>
    /// <param name="_freightBillRecId">
    /// Record id of the freight bill.
    /// </param>
    /// <param name="_journalId">
    /// Journal id.
    /// </param>
    void processFreightBills(RecId _freightBillRecId, JournalId _journalId)
    {
        TMSFreightBillDetail        fbDetail;
        str                         transText;

        transText   = TMSParameters::find().FBGLJourLineTransTxt;
        fbDetail    = TMSFreightBillDetail::find(_freightBillRecId, true);

        // Update freight bill
        if (fbDetail)
        {
            ttsBegin;

            this.createJournalReference(fbDetail.RecId, fbDetail.TableId, _journalId);

            // Update match status
            if (!fbDetail.amountRemaining())
            {
                fbDetail.FreightBillMatchStatus = TMSFreightBillMatchStatus::FullyMatched;
                fbDetail.update();
            }

            ttsCommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processFreightBillsWithoutJournalId</Name>
				<Source><![CDATA[
    private void processFreightBillsWithoutJournalId(RecId _freightBillRecId, JournalId _journalId)
    {
        TMSFreightBillDetail fbDetail = TMSFreightBillDetail::find(_freightBillRecId, true);
        str transText = TMSParameters::find().FBGLJourLineTransTxt;

        // Update freight bill
        if (fbDetail)
        {
            ttsBegin;

            if (_journalId)
            {
                this.createJournalReference(fbDetail.RecId, fbDetail.TableId, _journalId);
            }

            // Update match status
            if (!fbDetail.amountRemaining())
            {
                fbDetail.FreightBillMatchStatus = TMSFreightBillMatchStatus::FullyMatched;
                fbDetail.update();
            }

            ttsCommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reconcileRemainingLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reconciles remaining amounts of invoice lines.
    /// </summary>
    /// <param name="_source">
    /// Source containing <c>TMSInvoiceLine</c> records.
    /// </param>
    /// <param name="_reasonCode">
    /// Freight reason code of reconciliation.
    /// </param>
    /// <param name="_comment">
    /// Comment of reconciliation.
    /// </param>
    void reconcileRemainingLines(Common                 _source,
                                 TMSFreightReasonCode   _reasonCode,
                                 Description            _comment = '')
    {
        TMSInvoiceLineReconcile invoiceLineRec;
        TMSInvoiceLine          invoiceLine;
        TMSInvoiceTable         invoiceTable;

        ttsBegin;

        switch (_source.TableId)
        {
            case tableNum(TMSInvoiceTable):
                invoiceTable = _source;

                while select invoiceLine
                    where invoiceLine.InternalInvNumber == invoiceTable.InternalInvNumber &&
                          invoiceLine.InvoiceLineStatus == TMSInvoiceLineStatus::Open
                {
                    if (invoiceLine.amountRemaining())
                    {
                        invoiceLineRec.FreightReasonCode     = _reasonCode;
                        invoiceLineRec.InvoiceLineRecId      = invoiceLine.RecId;
                        invoiceLineRec.Amount                = invoiceLine.amountRemaining();
                        invoiceLineRec.insert();

                        if (_comment)
                        {
                            this.createComment(invoiceLineRec, _comment);
                        }
                    }
                }
                break;

            // Single line rejection
            case tableNum(TMSInvoiceLine):
                invoiceLine = _source;

                if (!invoiceLine.amountMatched() && !invoiceLine.amountReconciled())
                {
                    invoiceLine.InvoiceLineStatus = TMSInvoiceLineStatus::Rejected;
                }

                invoiceLineRec.FreightReasonCode        = _reasonCode;
                invoiceLineRec.InvoiceLineRecId         = invoiceLine.RecId;
                invoiceLineRec.Amount                   = invoiceLine.amountRemaining();
                invoiceLineRec.insert();

                if (_comment)
                {
                    this.createComment(invoiceLineRec, _comment);
                }

                invoiceLine.update();
                break;
        }

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAccounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds account that the transaction is to be paid to.
    /// </summary>
    /// <param name="_vendAcct">
    /// The vendor ledger account.
    /// </param>
    /// <param name="_transType">
    /// The transaction type.
    /// </param>
    /// <param name="_matchReason">
    /// The freight match reason.
    /// </param>
    /// <param name="_markupTable">
    /// The markup table.
    /// </param>
    /// <param name="_isFBD">
    /// Determines whether freight bill details record is created.
    /// </param>
    /// <param name="_dimension">
    /// The dynamics account dimensions.
    /// </param>
    /// <param name="_acType">
    /// The ledger journal AC type.
    /// </param>
    /// <returns>
    /// The account information.
    /// </returns>
    container setAccounts(LedgerAccount             _vendAcct,
                          InventTransType           _transType,
                          TMSFreightMatchReason     _matchReason,
                          MarkupTable               _markupTable,
                          boolean                   _isFBD      = false,
                          DimensionDynamicAccount   _dimension  = 0,
                          LedgerJournalACType       _acType     = LedgerJournalACType::Ledger)
    {
        DimensionDynamicAccount account;
        DimensionDynamicAccount offset;
        DimensionDynamicAccount vendorAccount;
        DimensionDynamicAccount matchReasonVendAcct;
        DimensionDynamicAccount dynamicAcct;
        MarkupType              debitType;
        MarkupType              creditType;
        boolean                 pay;

        debitType           = _markupTable.CustType;
        creditType          = _markupTable.VendType;
        pay                 = _matchReason.PayAmount;
        vendorAccount       = LedgerDynamicAccountHelper::getDynamicAccountFromAccountNumber(_vendAcct, LedgerJournalACType::Vend);

        if (_matchReason.LedgerAccount)
        {
            LedgerAccountDimensionResolver ledgerAccountDimensionResolver = LedgerAccountDimensionResolver::newResolver(_matchReason.LedgerAccount);
            ledgerAccountDimensionResolver.parmDimensionFormat(DimensionAttribute::find(DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount)).Name);
            matchReasonVendAcct = ledgerAccountDimensionResolver.resolve();
        }

        if (_matchReason.OverrideAccts)
        {
            if (_matchReason.PayAmount)
            {
                account = vendorAccount;
                offset  = _matchReason.OffAcctLedgerDimension;
            }

            else
            {
                account = matchReasonVendAcct;
                offset  = _matchReason.OffAcctLedgerDimension;
            }
        }

        else if (_isFBD)
        {
            account = vendorAccount;
            offset  = _markupTable.VendorLedgerDimension;
        }

        else if (_transType == InventTransType::Purch || _transType == InventTransType::TransferOrderShip)
        {
            switch (true)
            {
                case debitType == MarkupType::Item && creditType == MarkupType::LedgerAccount && pay:
                    account = vendorAccount;
                    offset  = _markupTable.VendorLedgerDimension;
                    break;

                case debitType == MarkupType::LedgerAccount && creditType == MarkupType::LedgerAccount && pay:
                    account = vendorAccount;
                    offset  = _markupTable.CustomerLedgerDimension;
                    break;

                case debitType == MarkupType::CustVend && creditType == MarkupType::LedgerAccount && pay:
                    account = vendorAccount;
                    offset  = _matchReason.OffAcctLedgerDimension;
                    break;

                case debitType == MarkupType::Item && creditType == MarkupType::LedgerAccount && !pay:
                    account = matchReasonVendAcct;
                    offset  = _markupTable.VendorLedgerDimension;
                    break;

                case debitType == MarkupType::LedgerAccount && creditType == MarkupType::LedgerAccount && !pay:
                    account = matchReasonVendAcct;
                    offset  = _markupTable.CustomerLedgerDimension;
                    break;

                case debitType == MarkupType::CustVend && creditType == MarkupType::LedgerAccount && !pay:
                    account = matchReasonVendAcct;
                    offset  = _matchReason.OffAcctLedgerDimension;
                    break;
            }
        }

        else
        {
            switch (true)
            {
                case debitType == MarkupType::LedgerAccount && creditType == MarkupType::LedgerAccount && pay:
                    account = vendorAccount;
                    offset  = _markupTable.CustomerLedgerDimension;
                    break;

                case debitType == MarkupType::CustVend && creditType == MarkupType::LedgerAccount && pay:
                    account = vendorAccount;
                    offset  = _matchReason.OffAcctLedgerDimension;
                    break;

                case debitType == MarkupType::LedgerAccount && creditType == MarkupType::LedgerAccount && !pay:
                    account = matchReasonVendAcct;
                    offset  = _markupTable.CustomerLedgerDimension;
                    break;

                case debitType == MarkupType::CustVend && creditType == MarkupType::LedgerAccount && !pay:
                    account = matchReasonVendAcct;
                    offset  = _matchReason.OffAcctLedgerDimension;
                    break;
            }
        }

        // Add order lines to offset
        if (!_matchReason.OverrideAccts)
        {
            dynamicAcct = this.findOrCreateDynamicDimension(offset, _dimension);
            offset = dynamicAcct ? dynamicAcct : offset;
        }

        return [account, offset];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates amount on ledger trans if possible.
    /// </summary>
    /// <param name="_journalNum">
    ///     The journal ID of the ledger journal transaction.
    /// </param>
    /// <param name="_account">
    ///     The associated account for the ledger journal transaction.
    /// </param>
    /// <param name="_amount">
    ///     The amount.
    /// </param>
    /// <param name="_transText">
    ///     The transaction text of the ledger journal transaction.
    /// </param>
    /// <param name="_invoiceLineRecId">
    ///     The invoice line ID
    /// </param>
    /// <param name="_invoice">
    ///     The associated invoice ID.
    /// </param>
    /// <param name="_noPay">
    ///     indicates if credit or debit amount should be used.
    /// </param>
    /// <returns>
    ///  true if the amount on ledger trans was updated; otherwise, false.
    /// </returns>
    public boolean updateLedgerJournalTrans(
        LedgerJournalId         _journalNum,
        DimensionDynamicAccount _account,
        Amount                  _amount,
        str                     _transText,
        RecId                   _invoiceLineRecId,
        InvoiceId               _invoice,
        boolean                 _noPay = false)
    {
        boolean ret;

        boolean isCreditAmount = (_amount > 0 && _noPay) || (_amount < 0 && !_noPay);

        ttsbegin;

        LedgerJournalTrans journalTrans = this.findLedgerJournalTransForUpdate(_journalNum, _account, _invoice, isCreditAmount);

        if (journalTrans)
        {
            journalTrans.DelayTaxCalculation = TaxParameters::find().DelayTaxCalculation;

            if (journalTrans.Txt != _transText)
            {
                journalTrans.Txt = "@TRX1650";
            }

            if (isCreditAmount)
            {
                journalTrans.AmountCurCredit += abs(_amount);
            }
            else
            {
                journalTrans.AmountCurDebit += abs(_amount);
            }

            this.initializeLedgerJournalTransFromEngine(journalTrans);
            journalTrans.defaultRow();
            journalTrans.update();
            voucherId = journalTrans.Voucher;
            ret = true;
        }

        ttscommit;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLedgerJournalTransForUpdate</Name>
				<Source><![CDATA[
    private LedgerJournalTrans findLedgerJournalTransForUpdate(
        LedgerJournalId         _journalNum,
        DimensionDynamicAccount _account,
        InvoiceId               _invoice,
        boolean                 _isCreditAmount)
    {
        LedgerJournalTrans journalTrans;

        if (_isCreditAmount)
        {
            select firstonly forupdate journalTrans
                where journalTrans.JournalNum       == _journalNum
                    && journalTrans.Invoice         == _invoice
                    && journalTrans.LedgerDimension == _account
                    && journalTrans.AmountCurCredit != 0;
        }
        else
        {
            select firstonly forupdate journalTrans
                where journalTrans.JournalNum       == _journalNum
                    && journalTrans.Invoice         == _invoice
                    && journalTrans.LedgerDimension == _account
                    && journalTrans.AmountCurDebit  != 0;
        }

        return journalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeLedgerJournalTransFromEngine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a ledger journal line using a ledger journal engine.
    /// </summary>
    /// <param name = "_journalTrans">The ledger journal line.</param>
    protected void initializeLedgerJournalTransFromEngine(LedgerJournalTrans _journalTrans)
    {
        LedgerJournalEngine ledgerJournalEngine = this.initializeLedgerJournalEngine(_journalTrans);
        if (!ledgerJournalEngine)
        {
            throw Error(Error::wrongUseOfFunction(funcName()));
        }
        ledgerJournalEngine.calculateCashDisc(_journalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeLedgerJournalEngine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new <c>LedgerJournalEngine</c> for a ledger journal line.
    /// </summary>
    /// <param name = "_journalTrans">The ledger journal line.</param>
    /// <returns>A ledger journal engine instance.</returns>
    protected LedgerJournalEngine initializeLedgerJournalEngine(LedgerJournalTrans _journalTrans) 
    {
        return LedgerJournalEngine::construct(_journalTrans.ledgerJournalTable().JournalType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>approveInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for approval of a <c>TMSInvoiceTable</c> record.
    /// </summary>
    /// <param name="_source">
    /// Source containing <c>TMSInvoiceTable</c> record.
    /// </param>
    public static void approveInvoice(Common _source)
    {
        TMSInvoiceTable invoiceTable = _source;

        ttsBegin;
        
        TMSInvoiceApproval invoiceApproval = new TMSInvoiceApproval();
        JournalId journalId = invoiceApproval.createLedgerJournalTable(invoiceTable.InternalInvNumber);
        invoiceTable.RefJournalNum = invoiceTable.RefJournalNum ? '' : journalId;
        invoiceTable.InvoiceStatus = invoiceTable.allMatchedOrReconciled() ? TMSInvoiceStatus::Approved : TMSInvoiceStatus::PartiallyApproved;
        invoiceTable.update();

        TMSInvoiceApproval::runApportionmentByDimension(invoiceTable.InternalInvNumber, journalId);
        
        TMSInvoiceLine invoiceLine;
        while select forUpdate invoiceLine
            where invoiceLine.InternalInvNumber  == invoiceTable.InternalInvNumber      &&
                  (invoiceLine.InvoiceLineStatus == TMSInvoiceLineStatus::Submitted     ||
                  invoiceLine.InvoiceLineStatus  == TMSInvoiceLineStatus::Resubmitted   ||
                  invoiceLine.InvoiceLineStatus  == TMSInvoiceLineStatus::Rejected)
        {
            // Ensure invoice line that is rejected is only invoiced once.
            if (invoiceLine.InvoiceLineStatus    == TMSInvoiceLineStatus::Rejected &&
                invoiceLine.amountApproved()     == invoiceLine.NetAmount)
            {
                continue;
            }

            else
            {
                invoiceApproval.approveInvoiceLine(invoiceLine, journalId);
            }
        }

        LedgerJournalTable ledgerJournal = LedgerJournalTable::find(journalId, true);

        // Check for auto-posting and journal lines needs to exist
        if (   TMSParameters::find().PostJournal 
            && TMSInvoiceApproval::mustPostJournalForInvoiceApproval(ledgerJournal))
        {
            invoiceApproval.postJournal(journalId);
        }

        ledgerJournal.reread();

        if (ledgerJournal.numOfLines() == 0)
        {
            ledgerJournal.delete();
        }

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustPostJournalForInvoiceApproval</Name>
				<Source><![CDATA[
    private static boolean mustPostJournalForInvoiceApproval(LedgerJournalTable _ledgerJournal)
    {
        return _ledgerJournal.numOfLines() > 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assumeWorkflowControl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assumes workflow control on a <c>TMSInvoiceTable</c> record.
    /// </summary>
    /// <param name="_invoiceTable">
    /// <c>TMSInvoiceTable</c> record to be workflow controlled.
    /// </param>
    public static void assumeWorkflowControl(TMSInvoiceTable _invoiceTable)
    {
        UserId                  userId;
        WorkflowWorkItemTable   workflowWorkItem;

        ttsBegin;

        userId = TMSParameters::find().WorkflowUser;

        select firstOnly forUpdate workflowWorkItem
                    where workflowWorkItem.RefRecId     == _invoiceTable.RecId      &&
                          workflowWorkItem.RefTableId   == _invoiceTable.TableId    &&
                          workflowWorkItem.CompanyId    == curExt()                 &&
                          workflowWorkItem.UserId       == userId                   &&
                          workflowWorkItem.Status       == WorkflowWorkItemStatus::Pending;

        if (workflowWorkItem)
        {
            workflowWorkItem.UserId = curUserId();
            workflowWorkItem.update();
        }

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if an invoice is reconciled.
    /// </summary>
    /// <param name="_source">
    /// Source containing a <c>TMSInvoiceTable</c> record.
    /// </param>
    /// <returns>
    /// True if invoice is reconciled.
    /// </returns>
    public static boolean checkInvoice(Common _source)
    {
        TMSInvoiceTable     invoiceTable;
        boolean             reconciled;
        TMSInvoiceApproval  invoiceApproval = new TMSInvoiceApproval();

        invoiceTable = _source;

        reconciled = invoiceApproval.checkInvoiceLines(invoiceTable);

        return reconciled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Adjusts invoiced purchase order by specified amount.
    /// </summary>
    /// <param name="_vendInvoiceJour">
    ///     The record of <c>VendInvoiceJour</c>.
    /// </param>
    public static void invoiceAdjustment(vendInvoiceJour _vendInvoiceJour)
    {
        TMSMarkupAdjustment         tmsMarkupAdj;

        tmsMarkupAdj = new TMSMarkupAdjustment();
        tmsMarkupAdj.vendInvoiceJour(_vendInvoiceJour);
        tmsMarkupAdj.run();
    }

]]></Source>
			</Method>
			<Method>
				<Name>popTmpInvReconcile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates temporary table for invoice lines waiting to be reconciled.
    /// </summary>
    /// <param name="_source">
    /// The invoice header as source record.
    /// </param>
    /// <param name="_range">
    /// Set containing freight bill detail ids.
    /// </param>
    /// <returns>
    /// Temporary record.
    /// </returns>
    public static TMSTmpInvReconcile popTmpInvReconcile(Common _source, Set _range = null)
    {
        TMSTmpInvReconcile      tmpInvReconcile;
        TMSInvoiceLine          invoiceLine;
        TMSInvoiceLineReconcile lineRec;
        TMSInvoiceTable         invoiceTable;
        TMSFreightBillDetail    fbDetail;
        SetEnumerator           s;

        ttsBegin;

        if (_source.TableId == tableNum(TMSInvoiceTable))
        {
            invoiceTable = _source;
            while select invoiceLine
                where invoiceLine.InternalInvNumber == invoiceTable.InternalInvNumber
            {
                if (invoiceLine.amountRemaining())
                {
                    tmpInvReconcile.RefRecId                = invoiceLine.RecId;
                    tmpInvReconcile.RefTableId              = invoiceLine.TableId;
                    tmpInvReconcile.Amount                  = invoiceLine.amountRemaining();
                    tmpInvReconcile.CurrentRecord           = NoYes::No;
                    tmpInvReconcile.FreightReasonCode       = '';
                    tmpInvReconcile.insert();
                }

                while select lineRec
                    where Linerec.InvoiceLineRecId == invoiceLine.RecId
                {
                    tmpInvReconcile.RefRecId                = lineRec.InvoiceLineRecId;
                    tmpInvReconcile.RefTableId              = invoiceLine.TableId;
                    tmpInvReconcile.Amount                  = lineRec.Amount;
                    tmpInvReconcile.CurrentRecord           = NoYes::Yes;
                    tmpInvReconcile.FreightReasonCode       = lineRec.FreightReasonCode;
                    tmpInvReconcile.insert();
                }
            }
        }

        else if (_range)
        {
            //range of rec Ids
            s = _range.getEnumerator();

            while (s.moveNext())
            {
                fbDetail = TMSFreightBillDetail::find(s.current());
                tmpInvReconcile.RefRecId    = fbDetail.RecId;
                tmpInvReconcile.RefTableId  = fbDetail.TableId;
                tmpInvReconcile.Amount      = fbDetail.RateCur - fbDetail.amountMatched();
                tmpInvReconcile.insert();
            }
        }

        ttsCommit;

        return tmpInvReconcile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reconcileFreightBills</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reconciles freight bills.
    /// </summary>
    /// <param name="_numOfRecords">
    /// Number of records to be reconciled.
    /// </param>
    /// <param name="_autoReconcile">
    /// Boolean indicating that auto reconciliation is set.
    /// </param>
    public static void reconcileFreightBills(int _numOfRecords, boolean _autoReconcile = false)
    {
        TMSInvoiceApproval          invoiceApproval = new TMSInvoiceApproval();
        TMSFBDetailReconcile        fbRec;
        TMSFreightBillMarkupTrans   fbMarkup;
        TMSFreightMatchReason       matchReason;
        MarkupTable                 markupTable;
        markupTrans                 markupTrans;

        JournalId                   journalId;
        Set                         fbSet           = new Set(Types::Int64);
        Set                         fbDetailSet     = new Set(Types::Int64);

        ttsBegin;

        if (_numOfRecords)
        {
            journalId = invoiceApproval.createLedgerJournalTable('', "@TRX1591");
            boolean processFBDetailReconcileWithoutMarkup = TMSFBDetailReconcileProcessWithoutMarkupToggle::instance().isEnabled();

            TMSInvoiceApproval::runApportionmentByDimension('', journalId, true, _autoReconcile);

            // Aggregate totals by unique combinations of ledger accounts
            // order by the markup vend account and reason code offset account
            while select forUpdate fbRec
                join matchReason order by OffAcctLedgerDimension
                    where matchReason.FreightReasonCode == fbRec.FreightReasonCode
                    &&    ((fbRec.CurrentSession == NoYes::Yes // Session through reconcile form
                            &&          !_autoReconcile)
                        ||     (fbRec.AutoReconciled == NoYes::Yes // Session through batch job
                            &&          _autoReconcile))
                    join fbMarkup
                        where fbMarkup.FreightBillDetailRecId == fbRec.FreightBillDetailRecId
                        join markupTrans
                            where markupTrans.RecId == fbMarkup.MarkupTransRecId
                            join markupTable order by VendorLedgerDimension
                                where markupTable.MarkupCode == markupTrans.MarkupCode &&
                                      markupTable.ModuleType == markupTrans.ModuleType
            {
                // For each unique reconcile, add to set, turn off flags
                if (!fbSet.in(fbRec.RecId))
                {
                    fbSet.add(fbRec.RecId);

                    if (!processFBDetailReconcileWithoutMarkup || !fbDetailSet.in(fbRec.FreightBillDetailRecId))
                    {
                        invoiceApproval.processFreightBills(fbRec.FreightBillDetailRecId, journalId);
                        if (processFBDetailReconcileWithoutMarkup)
                        {
                            fbDetailSet.add(fbRec.FreightBillDetailRecId);
                        }
                    }

                    fbRec.CurrentSession = NoYes::No;
                    fbRec.AutoReconciled = NoYes::No;
                    fbRec.update();
                }
            }


            // Some fbRec does not have corresponding markup records.
            // E.g., user can delete from UI: sales orders -> lines -> maintain charges
            // See bug #535260 for more details.
            if (processFBDetailReconcileWithoutMarkup)
            {
                while select forUpdate fbRec
                join matchReason order by OffAcctLedgerDimension
                    where matchReason.FreightReasonCode == fbRec.FreightReasonCode
                    &&    ((fbRec.CurrentSession == NoYes::Yes // Session through reconcile form
                            && !_autoReconcile)
                        ||     (fbRec.AutoReconciled == NoYes::Yes // Session through batch job
                            && _autoReconcile))
                {
                    // For each unique reconcile, add to set, turn off flags
                    if (!fbSet.in(fbRec.RecId))
                    {
                        fbSet.add(fbRec.RecId);

                        if (!fbDetailSet.in(fbRec.FreightBillDetailRecId))
                        {
                            invoiceApproval.processFreightBills(fbRec.FreightBillDetailRecId, journalId);
                            fbDetailSet.add(fbRec.FreightBillDetailRecId);
                        }

                        fbRec.CurrentSession = NoYes::No;
                        fbRec.AutoReconciled = NoYes::No;
                        fbRec.update();
                    }
                }
            }
            if (TMSParameters::find().PostJournal)
            {
                invoiceApproval.postJournal(journalId);
            }
        }

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reconcileFreightBillsWithPayCheck</Name>
				<Source><![CDATA[
    public static void reconcileFreightBillsWithPayCheck(int _numOfRecords, boolean _autoReconcile = false, boolean _payVendor = true)
    {
        TMSInvoiceApproval          invoiceApproval = new TMSInvoiceApproval();
        TMSFBDetailReconcile        fbRec;
        TMSFreightBillMarkupTrans   fbMarkup;
        TMSFreightMatchReason       matchReason;
        MarkupTable                 markupTable;
        markupTrans                 markupTrans;

        JournalId                   journalId;
        Set                         fbSet           = new Set(Types::Int64);
        Set                         fbDetailSet     = new Set(Types::Int64);

        ttsBegin;

        if (_numOfRecords)
        {
            if (_payVendor)
            {
                journalId = invoiceApproval.createLedgerJournalTable('', "@TRX1591");
                TMSInvoiceApproval::runApportionmentByDimension('', journalId, true, _autoReconcile);
            }
            boolean processFBDetailReconcileWithoutMarkup = TMSFBDetailReconcileProcessWithoutMarkupToggle::instance().isEnabled();

            // Aggregate totals by unique combinations of ledger accounts
            // order by the markup vend account and reason code offset account
            while select forUpdate fbRec
                join matchReason order by OffAcctLedgerDimension
                    where matchReason.FreightReasonCode == fbRec.FreightReasonCode
                    &&    ((fbRec.CurrentSession == NoYes::Yes // Session through reconcile form
                            &&          !_autoReconcile)
                        ||     (fbRec.AutoReconciled == NoYes::Yes // Session through batch job
                            &&          _autoReconcile))
                     join fbMarkup
                        where fbMarkup.FreightBillDetailRecId == fbRec.FreightBillDetailRecId
                        join markupTrans
                            where markupTrans.RecId == fbMarkup.MarkupTransRecId
                            join markupTable order by VendorLedgerDimension
                                where markupTable.MarkupCode == markupTrans.MarkupCode &&
                                      markupTable.ModuleType == markupTrans.ModuleType
            {
                // For each unique reconcile, add to set, turn off flags
                if (!fbSet.in(fbRec.RecId))
                {
                    fbSet.add(fbRec.RecId);

                    if (!processFBDetailReconcileWithoutMarkup || !fbDetailSet.in(fbRec.FreightBillDetailRecId))
                    {
                        invoiceApproval.processFreightBillsWithoutJournalId(fbRec.FreightBillDetailRecId, journalId);
                        if (processFBDetailReconcileWithoutMarkup)
                        {
                            fbDetailSet.add(fbRec.FreightBillDetailRecId);
                        }
                    }

                    fbRec.CurrentSession = NoYes::No;
                    fbRec.AutoReconciled = NoYes::No;
                    fbRec.update();
                }
            }


            // Some fbRec does not have corresponding markup records.
            // E.g., user can delete from UI: sales orders -> lines -> maintain charges
            // See bug #535260 for more details.
            if (processFBDetailReconcileWithoutMarkup)
            {
                while select forUpdate fbRec
                exists join matchReason order by OffAcctLedgerDimension
                    where matchReason.FreightReasonCode == fbRec.FreightReasonCode
                    &&    ((fbRec.CurrentSession == NoYes::Yes // Session through reconcile form
                            && !_autoReconcile)
                        ||     (fbRec.AutoReconciled == NoYes::Yes // Session through batch job
                            && _autoReconcile))
                {
                    // For each unique reconcile, add to set, turn off flags
                    if (!fbSet.in(fbRec.RecId))
                    {
                        fbSet.add(fbRec.RecId);

                        if (!fbDetailSet.in(fbRec.FreightBillDetailRecId))
                        {
                            invoiceApproval.processFreightBillsWithoutJournalId(fbRec.FreightBillDetailRecId, journalId);
                            fbDetailSet.add(fbRec.FreightBillDetailRecId);
                        }

                        fbRec.CurrentSession = NoYes::No;
                        fbRec.AutoReconciled = NoYes::No;
                        fbRec.update();
                    }
                }
            }
            if (TMSParameters::find().PostJournal && _payVendor)
            {
                invoiceApproval.postJournal(journalId);
            }
            
        }

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>rejectInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rejects an invoice record, resets workflow status on matched and reconciled lines.
    /// </summary>
    /// <param name="_source">
    /// Source invoice record to be rejected.
    /// </param>
    /// <param name="_workflow">
    /// Determines whether workflow is enabled, false by default.
    /// </param>
    public static void rejectInvoice(Common _source, boolean _workflow = false)
    {
        TMSInvoiceLine          invoiceLine;
        TMSInvoiceTable         invoiceTable;
        TMSInvoiceApproval      invoiceApproval = new TMSInvoiceApproval();

        ttsBegin;

        switch (_source.TableId)
        {
            case tableNum(TMSInvoiceTable):
                invoiceTable = _source;

                while select forUpdate invoiceLine
                    where (invoiceLine.InvoiceLineStatus    == TMSInvoiceLineStatus::Submitted      ||
                          invoiceLine.InvoiceLineStatus     == TMSInvoiceLineStatus::Resubmitted)   &&
                          invoiceLine.InvoiceLineStatus     != TMSInvoiceLineStatus::Rejected       && // All that aren't manually rejected back to open
                          invoiceLine.InternalInvNumber     == invoiceTable.InternalInvNumber
                {
                    invoiceLine.InvoiceLineStatus = invoiceLine.amountApproved()            ?
                                                    TMSInvoiceLineStatus::PartiallyApproved :
                                                    TMSInvoiceLineStatus::Open;
                    invoiceLine.InvoiceStatus = TMSInvoiceStatus::Rejected;
                    invoiceLine.update();

                    // Reset status on match and reconcile
                    invoiceApproval.changeMatchReconcileStatus(invoiceLine, TMSWorkflowStatus::PendingReview);
                }

                invoiceTable.InvoiceStatus = TMSInvoiceStatus::Rejected;
                invoiceTable.update();
                break;

            case tableNum(TMSInvoiceLine):
                invoiceLine = _source;
                invoiceLine.InvoiceLineStatus = TMSInvoiceLineStatus::Rejected;
                invoiceLine.update();
                break;
        }

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runApportionmentByDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs apportionment by dimension.
    /// </summary>
    /// <param name="_invoiceNum">
    /// The invoice number.
    /// </param>
    /// <param name="_journalId">
    /// The journal id.
    /// </param>
    /// <param name="_isFreightBillDetail">
    /// Determines whether freight bill details are created, false by default.
    /// </param>
    /// <param name="_autoReconcile">
    /// Determines whether to run auto reconcile, false by default.
    /// </param>
    public static void runApportionmentByDimension(TMSInternalInvNumber _invoiceNum,
                                                   JournalId            _journalId,
                                                   boolean              _isFreightBillDetail    = false,
                                                   boolean              _autoReconcile          = false)

    {
        TMSXMLApportionment_Dimension processXML = TMSXMLApportionment_Dimension::construct();

        processXML.parmIsFreightBillDetail(_isFreightBillDetail);
        processXML.parmAutoReconcile(_autoReconcile);
        processXML.parmJournalId(_journalId);
        processXML.parmInvoiceNumber(_invoiceNum);
        processXML.parmCommunicationType(TMSCommunicationType::AdhocApportionment);

        processXML.execute();
    }

]]></Source>
			</Method>
			<Method>
				<Name>submitInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Submits invoice to workflow.
    /// </summary>
    /// <param name="_source">
    /// Source invoice record to be submitted.
    /// </param>
    /// <param name="_autoApprove">
    /// Determines whether the invoice is approved automatically, false by default.
    /// </param>
    /// <param name="_reconcile">
    /// Determines whether the invoice is reconciled automatically, false by default.
    /// </param>
    /// <param name="_sendMsg">
    /// Determines whether to send message, false by default.
    /// </param>
    /// <returns>
    /// True if the invoice is submitted successfully, false otherwise.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// No amount ready to submit in invoice.
    /// </exception>
    public static boolean submitInvoice(Common  _source,
                                        boolean _autoApprove    = false,
                                        boolean _reconcile      = false,
                                        boolean _sendMsg        = false)
    {
        TMSInvoiceTable         invoiceTable;
        TMSInvoiceLine          invoiceLine;
        boolean                 reconciled;
        TMSInvoiceApproval      invoiceApproval = new TMSInvoiceApproval();
        boolean                 ret;
        TMSInvoiceStatus        headerStatus;
        boolean                 submitted;

        invoiceTable = _source;

        try
        {
            if (_reconcile)
            {
                reconciled = invoiceApproval.checkInvoiceLines(invoiceTable);
            }

            ttsBegin;

            invoiceTable.selectForUpdate(true);

            if ((_reconcile && reconciled) || !_reconcile)
            {
                headerStatus = invoiceTable.InvoiceStatus == TMSInvoiceStatus::Open          ||
                               invoiceTable.InvoiceStatus == TMSInvoiceStatus::Pending       ||
                               invoiceTable.InvoiceStatus == TMSInvoiceStatus::PartiallyApproved    ?
                               TMSInvoiceStatus::Submitted                                          :
                               TMSInvoiceStatus::Resubmitted;

                while select forUpdate invoiceLine
                    where (invoiceLine.InvoiceLineStatus == TMSInvoiceLineStatus::Open                ||
                          invoiceLine.InvoiceLineStatus  == TMSInvoiceLineStatus::Rejected            ||
                          invoiceLine.InvoiceLineStatus  == TMSInvoiceLineStatus::PartiallyApproved)  &&
                          invoiceLine.InternalInvNumber  == invoiceTable.InternalInvNumber
                {
                    // Make sure invoice line has something matched or reconciled to submit
                    if (invoiceLine.amountReadyToSubmit())
                    {
                        switch (invoiceLine.InvoiceLineStatus)
                        {
                            case TMSInvoiceLineStatus::Open:
                                invoiceLine.InvoiceLineStatus = TMSInvoiceLineStatus::Submitted;
                                break;

                            case TMSInvoiceLineStatus::PartiallyApproved:
                                invoiceLine.InvoiceLineStatus = TMSInvoiceLineStatus::Submitted;
                                break;

                            case TMSInvoiceLineStatus::Rejected: // keep lines with rejected status rejected
                                break;

                            default:
                                invoiceLine.InvoiceLineStatus = TMSInvoiceLineStatus::Resubmitted;
                                break;
                        }

                        invoiceLine.InvoiceStatus = invoiceTable.InvoiceStatus;
                        invoiceLine.update();
                        
                        invoiceApproval.changeMatchReconcileStatus(invoiceLine, TMSWorkflowStatus::Submitted);

                        submitted = true;
                    }
                }

                invoiceTable.InvoiceStatus = submitted ? headerStatus : invoiceTable.InvoiceStatus;
                invoiceTable.update();

                ret = true;

                if (!submitted)
                {
                    throw error("@TRX1288");
                }

                if (_autoApprove && submitted)
                {
                    TMSInvoiceApproval::approveInvoice(invoiceTable);

                    if (_sendMsg)
                    {
                        info("@TRX1743");
                    }
                }
            }
            else
            {
                info("@TRX1311");
            }

            ttsCommit;
        }

        catch
        {
            error("@TRX1668");
        }

        return ret;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>