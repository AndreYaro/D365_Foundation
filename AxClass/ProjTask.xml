<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjTask</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class ProjTask
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getCorrespondingTaskElementNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the element number of a task in a project hierarchy (WBS).
    /// </summary>
    /// <param name = "_hierarchyId">A hierarchy ID.</param>
    /// <param name = "_taskId">A task ID.</param>
    /// <returns>The element number of the task in the hierarchy.</returns>
    public static ElementNumber getCorrespondingTaskElementNumber(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _taskId)
    {
        ProjPlanVersion projPlanVersion;
        HierarchyTreeTable hierarchyTreeTable;

        select firstonly ElementNumber from hierarchyTreeTable
            exists join projPlanVersion
                where hierarchyTreeTable.RecId == projPlanVersion.HierarchyTreeTableRefRecId
                    && projPlanVersion.HierarchyId == _hierarchyId
                    && projPlanVersion.HierarchyTaskId == _taskId;

        return hierarchyTreeTable.ElementNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQuotationTableByHierarchyId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get <c>SalesQuotationTable</c> record ID, ID and name from hierarchy ID.
    /// </summary>
    /// <param name = "_hierarchyId">This quotation hierarchy ID.</param>
    /// <returns><c>SalesQuotationTable</c> buffer.</returns>
    public static SalesQuotationTable getQuotationTableByHierarchyId(HierarchyIdBase _hierarchyId)
    {
        HierarchyLinkTable hierarchyLinkTable;
        salesQuotationTable salesQuotationTable;

        if (_hierarchyId)
        {
            select RefRecId from hierarchyLinkTable
                where hierarchyLinkTable.HierarchyId == _hierarchyId
                    && hierarchyLinkTable.RefTableId == tableNum(SalesQuotationTable)
                join salesQuotationTable
                    where salesQuotationTable.RecId == hierarchyLinkTable.RefRecId;
        }
        return salesQuotationTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTasks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deleted the specified task from the ProjPlanVersion table.
    /// </summary>
    /// <param name = "_hierarchyId">ID of the hierarchy the task belongs to.</param>
    /// <param name = "_taskId">The task ID.</param>
    /// <returns></returns>
    public static void deleteTasks(HierarchyIdBase _hierarchyId, ProjWBSType _wbsType, str _taskId)
    {
        // Look up the current task
        ProjPlanVersion task = ProjPlanVersion::findByHierarchyAndTaskId(_hierarchyId, str2Int64(_taskId), true);

        // Perform actual deletion (don't care about invalidated successors, as client logic handles that)
        ProjTask::deleteTasksV2(task, _wbsType, new Set(Types::Int64));
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTasksV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deleted the specified task from the ProjPlanVersion table.
    /// </summary>
    /// <param name = "_task">The task to be deleted.</param>
    /// <param name = "_taskId">The type of WBS the task is being deleted from.</param>
    /// <param name = "_outdatedSuccessors">The set of tasks who's start date must be recalculated.</param>
    public static void deleteTasksV2(
        ProjPlanVersion _task,
        ProjWBSType _wbsType,
        Set _outdatedSuccessors)
    {
        // Save data for the task
        HierarchyIdBase hierarchyId = _task.HierarchyId;
        ProjHierarchyTaskId parentTaskId = _task.ParentHierarchyTaskId;
        LineNumber siblingNumber = _task.TaskSiblingNumber;

        ttsbegin;
        // Delete it
        ProjTask::deleteTasksRecursive(_task, _wbsType, _outdatedSuccessors);

        // Move lower siblings up
        ProjPlanVersion lowerSibling;
        update_recordset lowerSibling setting
            TaskSiblingNumber = lowerSibling.TaskSiblingNumber - 1.0
        where
            lowerSibling.HierarchyId == hierarchyId
            && lowerSibling.ParentHierarchyTaskId == parentTaskId
            && lowerSibling.TaskSiblingNumber > siblingNumber;
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTasksRecursive</Name>
				<Source><![CDATA[
    private static boolean deleteTasksRecursive(
        ProjPlanVersion _task,
        ProjWBSType _wbsType,
        Set _outdatedSuccessors)
    {
        // If the activity is used as a dimension value, this task may not be deleted
        ActivityRecId activity = ProjPlanVersion::getActivityRecId(_task.HierarchyId, _task.HierarchyTaskId);
        smmActivities smmActivities = smmActivities::findWithRecId(activity);
        if (smmActivities && !DimensionValidation::canDeleteEntityValue(smmActivities))
        {
            return checkFailed(strFmt("@SYS134392", _task.TaskName ? _task.TaskName : smmActivities.ActivityNumber));
        }

        boolean deletedAllChildren = true;
        int nextSiblingNumber = 1;
        ttsbegin;
        // Recursively delete children
        ProjPlanVersion projPlanVersion;
        while select forupdate projPlanVersion 
        order by TaskSiblingNumber asc
        where
            projPlanVersion.ParentHierarchyTaskId == _task.HierarchyTaskId
            && projPlanVersion.HierarchyId == _task.HierarchyId
        {
            if (!ProjTask::deleteTasksRecursive(ProjPlanVersion, _wbsType, _outdatedSuccessors))
            {
                projPlanVersion.TaskSiblingNumber = nextSiblingNumber;
                projPlanVersion.update();
                
                nextSiblingNumber += 1;
                deletedAllChildren = false;
            }
        }
    
        // If the children of this task could not be deleted, you cannot delete this task
        if (deletedAllChildren)
        {
            // Remove draft assignment from ProjPlanVersionAssignment table.
            ProjPlanVersionAssignment::deleteByProjPlanVersion(_task.RecId);

            PSAActivityEstimates::deleteEstimatesForTask(_task.HierarchyId, _task.HierarchyTaskId);

            ProjTask::deleteDependencyLinks(_task.HierarchyId, _task.HierarchyTaskId, _outdatedSuccessors);

            if (_wbsType == ProjWBSType::ProjectQuotation)
            {
                ElementNumber taskElementNumber = ProjTask::getCorrespondingTaskElementNumber(_task.HierarchyId, _task.HierarchyTaskId);
                ProjTaskNormalized::deleteTasks(_task.HierarchyId, taskElementNumber);
            }

            _outdatedSuccessors.remove(_task.HierarchyTaskId);
            _task.delete();
        }

        ttscommit;

        return deletedAllChildren;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteDependencyLinks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes any dependencies that include the given task as a successor or a predecessor.
    /// </summary>
    /// <param name = "_hierarchyId">ID of the hierarchy.</param>
    /// <param name = "_taskId">The task ID.</param>
    /// <param name = "_outdatedSuccessors">The set of currently outdated successor tasks.</param>
    private static void deleteDependencyLinks(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _taskId, Set _outdatedSuccessors)
    {
        // Delete dependency edges where the deleted task is the successor
        ProjDependency dependency;
        delete_from dependency where
            dependency.ProjPlanHierarchyId == _hierarchyId
            && dependency.SuccessorHierarchyTaskId == _taskId;            

        // Delete dependencies where the deleted task is the predecessor, adding the successor to the set of outdated successors
        while select PredecessorHierarchyTaskId from dependency where
            dependency.ProjPlanHierarchyId == _hierarchyId
            && dependency.PredecessorHierarchyTaskId == _taskId
        {
            _outdatedSuccessors.add(dependency.SuccessorHierarchyTaskId);
            dependency.delete();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertStrToSchedDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts a string to a SchedDate object.
    /// </summary>
    /// <param name = "_date">The date to convert as a string representing the number of seconds since January 1, 1970.</param>
    /// <returns>A scheduling date with time set to midnight.</returns>
    public static SchedDate convertStrToSchedDate(str _date)
    {
        const int64 InvalidTimeFromEpoch = -2209046400;
        int64 timeFromEpoch = str2int64(_date);
        utcdatetime dateTimeUTC, referenceDateTimeUTC = DateTimeUtil::parse("1970-01-01T00:00:00");
        SchedDate result;

        if (timeFromEpoch <= InvalidTimeFromEpoch)
        {
            info(strfmt("@ProjPlan:StartDateWarning"));
        }
        else
        {
            dateTimeUTC = DateTimeUtil::addSeconds(referenceDateTimeUTC, timeFromEpoch);
            result = DateTimeUtil::date(dateTimeUTC);
        }
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearTaskAttributesForNewlyCreatedParent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears fields in the projPlanVersion table for a task that is now a parent task.
    /// </summary>
    /// <param name = "_hierarchyId">ID of the hierarchy.</param>
    /// <param name = "_taskId">The task ID.</param>
    /// <returns></returns>
    public static void clearTaskAttributesForNewlyCreatedParent(HierarchyIdBase _hierarchyId, str _taskId)
    {
        ProjHierarchyTaskId     taskId = str2int64(_taskId);

        ttsbegin;
        ProjPlanVersion version;
        update_recordset version
            setting
                TaskEffort = 0,
                TaskEffortAtComplete = 0,
                TaskDuration = 0,
                NumberOfResources = 0,
                ResourceCategory = 0,
                TaskCategory = "",
                EndNode = FalseTrue::False
            where version.HierarchyId == _hierarchyId
                && version.HierarchyTaskId == taskId;

        ProjTask::updatePredecessors(_hierarchyId, taskId, new List(Types::String));
        //Delete any estimates for this task, summary tasks cannot have estimates
        PSAActivityEstimates::deleteEstimatesForTask(_hierarchyId, taskId);
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a new task to the projPlanVersion table for a specific hierarchy.
    /// </summary>
    /// <param name = "_hierarchyId">The Hierarchy ID that the task belongs to</param>
    /// <param name = "_taskId">The ID of the task to update.</param>
    /// <param name = "_parentTaskId">The ID of the parent task.</param>
    /// <param name = "_name">The description of the task.</param>
    /// <param name = "_effort">The effort on the task.</param>
    /// <param name = "_startDate">The tasks startDate.</param>
    /// <param name = "_endDate">The tasks endDate.</param>
    /// <param name = "_duration">The duration in days for the task.</param>
    /// <param name = "_numOfResources">The number of resources assigned to the task.</param>
    /// <param name = "_resourceCategory">The resource category assigned to the task.</param>
    /// <param name = "_projCategory">The project category for the task.</param>
    /// <param name = "_predecessors">The list of this tasks predecessors.</param>
    /// <param name = "_clearRoot">A flag to determine if we need to clear the estimates from the hierarchy's root task after adding this task</param>
    /// <returns></returns>
    public static void addTask(HierarchyIdBase _hierarchyId, ProjWBSType _wbsType, str _taskId, str _parentTaskId, str _name, str _siblingNumber, str _effort, str _startDate, str _endDate,
        str _duration, str _numOfResources, str _resourceCategory, str _projCategory, List _predecessors = new List(Types::String), str _clearRoot = '')
    {
        Hours                       effort = str2num(_effort);
        DaysAsReal                  duration = str2num(_duration);
        SchedFromDate               startDate;
        SchedToDate                 endDate;
        ProjHierarchyTaskId         parentTaskId = str2int64(_parentTaskId);
        real                        numOfResources = str2num(_numOfResources);
        ResourceCategoryRecId       resourceCategoryRecId = str2int64(_resourceCategory);
        ProjCategoryId              projCategory = _projCategory;
        int                         siblingNumber = str2Int(_siblingNumber);
        int                         clearRoot = str2Int(_clearRoot);

        // Dates are not stored for templates.
        // In that case, ignore any passed in values which may not be valid dates and use today's date.
        if (_wbsType != ProjWBSType::Template)
        {
            startDate = ProjTask::convertStrToSchedDate(_startDate);
            endDate   = ProjTask::convertStrToSchedDate(_endDate);
        }
        else
        {
            startDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
            endDate = startDate;
        }

        ProjPlanVersion version;
        ProjHierarchyTaskId newTaskId = ProjPlanVersion::getNextTaskId(_hierarchyId, _wbsType == ProjWBSType::Project);
        version.HierarchyId = _hierarchyId;
        version.HierarchyTaskId = newTaskId;
        version.ParentHierarchyTaskId = parentTaskId;
        version.TaskSiblingNumber = siblingNumber;
        version.TaskName = _name;
        version.TaskEffort = effort;
        version.TaskEffortAtComplete = effort;
        version.TaskEffortToComplete = effort;
        version.TaskDuration = duration;
        version.TaskStartDate = startDate;
        version.TaskFinishDate = endDate;
        version.NumberOfResources = numOfResources;
        version.ResourceCategory = resourceCategoryRecId;
        version.TaskCategory = projCategory;

        if (_wbsType == ProjWBSType::ProjectQuotation)
        {
            ElementNumber parentTaskElementNumber = ProjTask::getCorrespondingTaskElementNumber(_hierarchyId, parentTaskId);
            version.HierarchyTreeTableRefRecId = ProjTaskNormalized::addTask(_hierarchyId, parentTaskElementNumber, _name, effort, startDate, endDate, duration, numOfResources);
        }

        ttsbegin;
        if (version.validateWrite())
        {
            ProjPlanVersion projPlanVersion;
            //Bump the siblings below this task down.
            update_recordset projPlanVersion
                setting
                    TaskSiblingNumber = projPlanVersion.TaskSiblingNumber + 1
                where projPlanVersion.TaskSiblingNumber >= siblingNumber
                && projPlanVersion.HierarchyId == _hierarchyId
                && projPlanVersion.ParentHierarchyTaskId == parentTaskId;
            //Insert new Row
            version.insert();
        }

        ProjTask::updatePredecessors(_hierarchyId, newTaskId, _predecessors);
        ProjEstimate::syncEstimateLinesFromTask(_hierarchyId, version.HierarchyTaskId , _wbsType);        
        ttscommit;

        // Clear cache used when a hierarchy was updated
        // this will clear all data in the cache for a given hierarchy id
        SysGlobalObjectCache objectCache = ClassFactory.globalObjectCache();
        objectCache.clear(strFmt('%1#%2', classStr(ProjWBSDataEntityHelper), _hierarchyId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearEstimatesFromRoot</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears estimates from a projects root task.
    /// </summary>
    /// <param name = "_hierarchyId">ID of the hierarchy.</param>
    /// <param name = "_wbsType">The type of the WBS.</param>
    /// <returns></returns>
    public static void clearEstimatesFromRoot(HierarchyIdBase _hierarchyId, ProjWBSType _wbsType = ProjWBSType::Project)
    {
        ProjPlanVersion         projPlanVersion;

        select firstonly HierarchyTaskId from projPlanVersion
                where projPlanVersion.HierarchyId == _hierarchyId;

        PSAActivityEstimates::deleteHourEstimatesForTask(_hierarchyId, projPlanVersion.HierarchyTaskId, false, false, _wbsType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaskinfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the fields on a task in the ProjPlanVersion table and then syncs the estimate lines for the task to match the updated information.
    /// </summary>
    /// <param name = "_hierarchyId">The Hierarchy ID that the task belongs to</param>
    /// <param name = "_taskId">The ID of the task to update.</param>
    /// <param name = "_name">The description of the task.</param>
    /// <param name = "_effort">The effort on the task.</param>
    /// <param name = "_startDate">The tasks startDate.</param>
    /// <param name = "_endDate">The tasks endDate.</param>
    /// <param name = "_duration">The duration in days for the task.</param>
    /// <param name = "_numOfResources">The number of resources assigned to the task.</param>
    /// <param name = "_resourceCategory">The resource category assigned to the task.</param>
    /// <param name = "_projCategory">The project category for the task.</param>
    /// <param name = "_predecessors">The list of this tasks predecessors.</param>
    /// <returns></returns>
    public static void setTaskinfo(HierarchyIdBase _hierarchyId, ProjWBSType _wbsType, str _taskId, str _name, str _siblingNumber, str _effort, str _startDate, str _endDate,
        str _duration, str _numOfResources, str _resourceCategory, str _projCategory, List _predecessors = new List(Types::String))

    {
        ProjHierarchyTaskId     taskId = str2int64(_taskId);
        Hours                   effort = str2num(_effort);
        DaysAsReal              duration = str2num(_duration);
        SchedFromDate           startDate;
        SchedToDate             endDate;
        real                    numOfResources = str2num(_numOfResources);
        ResourceCategoryRecId   resourceCategoryRecId = str2int64(_resourceCategory);
        ProjCategoryId          projCategory = _projCategory;
        int                     siblingNumber = str2Int(_siblingNumber);

        // Dates are not stored for templates.
        // In that case, ignore any passed in values which may not be valid dates and use today's date.
        if (_wbsType != ProjWBSType::Template)
        {
            startDate = ProjTask::convertStrToSchedDate(_startDate);
            endDate   = ProjTask::convertStrToSchedDate(_endDate);
        }
        else
        {
            startDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
            endDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        }

        ttsbegin;

        ProjPlanVersion projPlanVersion;
        select forupdate projPlanVersion
        where projPlanVersion.HierarchyId == _hierarchyId
            && projPlanVersion.HierarchyTaskId == taskId;

        if (projPlanVersion)
        {
            // User entered cost and sales prices will be overwritten by default value if syncEstimates is set to true.
            boolean syncEstimates = projPlanVersion.TaskEffort != effort 
                || ProjPlanVersion.TaskCategory != ProjCategory 
                || ProjPlanVersion.ResourceCategory != resourceCategoryRecId;


            ProjTask::setProjPlanVersionFieldsForUpdate(projPlanVersion,
                                                        _name,
                                                        effort,
                                                        startDate,
                                                        endDate,
                                                        duration,
                                                        numOfResources,
                                                        resourceCategoryRecId,
                                                        projCategory,
                                                        siblingNumber);

            projPlanVersion.update();

            ProjTask::updatePredecessors(_hierarchyId, taskId, _predecessors);

            if (syncEstimates)
            {
                ProjEstimate::syncEstimateLinesFromTask(_hierarchyId, taskId, _wbsType);
            }
        } 
        
        ttscommit;

	    if (_wbsType == ProjWBSType::ProjectQuotation)
        {
            ElementNumber taskElementNumber = ProjTask::getCorrespondingTaskElementNumber(_hierarchyId, taskId);
            ProjTaskNormalized::setTaskinfo(_hierarchyId, taskElementNumber, _name, effort, startDate, endDate, duration, numOfResources, taskId == ProjPlanVersionDetail::rootTaskId());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setProjPlanVersionFieldsForUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets <c>ProjPlanversion</c> fields in preparation for updates.
    /// </summary>
    /// <param name = "_projPlanversion"><c>ProjPlanVersion</c> buffer</param>
    /// <param name = "_name">Name of the task</param>
    /// <param name = "_effort">Effort hours</param>
    /// <param name = "_startDate">Start date of the task</param>
    /// <param name = "_endDate">End date of the task</param>
    /// <param name = "_duration">Task duration</param>
    /// <param name = "_numOfResources">Number of resources for the task</param>
    /// <param name = "_resourceCategoryRecId">Resource role</param>
    /// <param name = "_projCategory">Task category</param>
    /// <param name = "_siblingNumber">Task sibling number</param>
    protected static void setProjPlanVersionFieldsForUpdate(ProjPlanVersion _projPlanversion,
                                                            str _name, 
                                                            Hours _effort,
                                                            SchedFromDate _startDate,
                                                            SchedFromDate _endDate,
                                                            DaysAsReal _duration,
                                                            real _numOfResources,
                                                            ResourceCategoryRecId _resourceCategoryRecId,
                                                            ProjCategoryId _projCategory,
                                                            int _siblingNumber)
    {
        _projPlanversion.TaskName                = _name;
        _projPlanversion.TaskEffort              = _effort;
        _projPlanversion.TaskEffortAtComplete    = _effort;
        _projPlanversion.TaskStartDate           = _startDate;
        _projPlanversion.TaskFinishDate          = _endDate;
        _projPlanversion.TaskDuration            = _duration;
        _projPlanversion.NumberOfResources       = _numOfResources;
        _projPlanversion.ResourceCategory        = _resourceCategoryRecId;
        _projPlanversion.TaskCategory            = _projCategory;
        _projPlanversion.TaskSiblingNumber       = _siblingNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>indentTasks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indent a task in the ProjPlanVersion table.
    /// </summary>
    /// <param name = "_hierarchyId">The Hierarchy ID that the task belongs to.</param>
    /// <param name = "_wbsType">The WBS type enum to specify whether it is a project, quotation or template type.</param>
    /// <param name = "_taskId">The ID of the task to update.</param>
    /// <param name = "_aboveSiblingTaskId">The ID of the parent task.</param>
    /// <param name = "_clearParent">If the parent task is a first time parent, then this parameter should be set to 1.</param>
    /// <param name = "_parentHierarchyTaskId">Hierarchy task ID of this task's parent task.</param>
    /// <param name = "_oldSiblingNumber">Previous line number of this task's sibling.</param>
    /// <param name = "_newSiblingNumber">New line number of this task.</param>
    public static void indentTasks(HierarchyIdBase _hierarchyId, ProjWBSType _wbsType, str _taskId, str _aboveSiblingTaskId, str _clearParent,
        str _parentHierarchyTaskId = "", str _oldSiblingNumber = "", str _newSiblingNumber = "")
    {
        LineNum             newSiblingNumber;
        LineNum             oldSiblingNumber;
        ProjHierarchyTaskId parentHierarchyTaskId;
        ProjHierarchyTaskId taskId = str2int64(_taskId);
        ProjHierarchyTaskId aboveSiblingTaskId = str2int64(_aboveSiblingTaskId);
        boolean             clearParent = (_clearParent == "1");

        if (_oldSiblingNumber && _parentHierarchyTaskId && _newSiblingNumber)
        {
            oldSiblingNumber = str2num(_oldSiblingNumber);
            parentHierarchyTaskId = str2int64(_parentHierarchyTaskId);
            newSiblingNumber = str2num(_newSiblingNumber);
        }
        else
        {
            ProjPlanVersion projPlanVersion;
            select firstonly TaskSiblingNumber, ParentHierarchyTaskId from projPlanVersion
                where projPlanVersion.HierarchyTaskId == taskId
                && projPlanVersion.HierarchyId == _hierarchyId;
            oldSiblingNumber = projPlanVersion.TaskSiblingNumber;
            parentHierarchyTaskId = projPlanVersion.ParentHierarchyTaskId;
            newSiblingNumber = ProjPlanVersion::getNextSiblingNumber(_hierarchyId, aboveSiblingTaskId);
        }

        ProjPlanVersion version;
        update_recordset version
            setting
            ParentHierarchyTaskId = aboveSiblingTaskId,
            TaskSiblingNumber = newSiblingNumber
        where version.HierarchyTaskId == taskId &&
            version.HierarchyId == _hierarchyId;

        update_recordset version
            setting
            TaskSiblingNumber = version.TaskSiblingNumber - 1
        where version.HierarchyId == _hierarchyId
            && version.TaskSiblingNumber > oldSiblingNumber
            && version.ParentHierarchyTaskId == parentHierarchyTaskId;

        if (clearParent)
        {
            ProjTask::clearTaskAttributesForNewlyCreatedParent(_hierarchyId, _aboveSiblingTaskId);
        }

        if (_wbsType == ProjWBSType::ProjectQuotation)
        {
            ElementNumber taskElementNumber = ProjTask::getCorrespondingTaskElementNumber(_hierarchyId, taskId);
            ElementNumber aboveSiblingElementNumber = ProjTask::getCorrespondingTaskElementNumber(_hierarchyId, aboveSiblingTaskId);
            ProjTaskNormalized::indentTasks(_hierarchyId, taskElementNumber, aboveSiblingElementNumber, newSiblingNumber);
            if (clearParent)
            {
                ProjTaskNormalized::clearTaskAttributesForNewlyCreatedParent(_hierarchyId, aboveSiblingElementNumber);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>outdentTasks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Outdent a task in the ProjPlanVersion table.
    /// </summary>
    /// <param name = "_hierarchyId">The Hierarchy ID that the task belongs to.</param>
    /// <param name = "_wbsType">The WBS type.</param>
    /// <param name = "_taskId">The ID of the task to update.</param>
    /// <param name = "_parentTaskId">The hierarchy task ID of this task's parent.</param>
    /// <param name = "_grandParentTaskId">The hierarchy task ID of this task's grand parent.</param>
    /// <param name = "_newSiblingNumber">The new line number of this task's sibling.</param>
    /// <param name = "_oldSiblingNumber">The previous line number of this task's sibling.</param>
    /// <param name = "_newStartSiblingNumberForBelowSiblingsMerge">The new line number of this task's sibling after indent.</param>
    public static void outdentTasks(HierarchyIdBase _hierarchyId, ProjWBSType _wbsType, str _taskId, str _parentTaskId, str _grandParentTaskId,
        str _newSiblingNumber = "", str _oldSiblingNumber = "", str _newStartSiblingNumberForBelowSiblingsMerge = "")
    {
        LineNum         oldSiblingNumber, newSiblingNumber, oldStartSiblingNumberForBelowSiblingsMerge, newStartSiblingNumberForBelowSiblingsMerge, parentSiblingNumber;

        ProjHierarchyTaskId targetTaskId          = str2int64(_taskId);
        ProjHierarchyTaskId parentTaskId          = str2int64(_parentTaskId);
        ProjHierarchyTaskId grandParentTaskId     = str2int64(_grandParentTaskId);

        if (_newSiblingNumber && _oldSiblingNumber)
        {
            newSiblingNumber = str2num(_newSiblingNumber);
            oldSiblingNumber = str2num(_oldSiblingNumber);// Implement getting the newSiblingNumber on the client side.
        }
        else
        {
            ProjPlanVersion projPlanVersion;
            select firstonly TaskSiblingNumber from projPlanVersion
                where projPlanVersion.HierarchyId == _hierarchyId
                    && projPlanVersion.HierarchyTaskId == parentTaskId;
            newSiblingNumber = projPlanVersion.TaskSiblingNumber + 1;

            select firstonly TaskSiblingNumber from projPlanVersion
                where projPlanVersion.HierarchyTaskId == targetTaskId
                    && projPlanVersion.HierarchyId == _hierarchyId;
            oldSiblingNumber = projPlanVersion.TaskSiblingNumber;
        }

        if (_newStartSiblingNumberForBelowSiblingsMerge)
        {
            newStartSiblingNumberForBelowSiblingsMerge = str2num(_newStartSiblingNumberForBelowSiblingsMerge);  // Implement getting the _newStartSiblingNumberForBelowSiblingsMerge on the client side.
        }
        else
        {
            newStartSiblingNumberForBelowSiblingsMerge = ProjPlanVersion::getNextSiblingNumber(_hierarchyId, targetTaskId);
        }

        ttsbegin;

        ProjPlanVersion projPlanVersion;
        update_recordset projPlanVersion
            setting
            TaskSiblingNumber = projPlanVersion.TaskSiblingNumber + 1
        where projPlanVersion.TaskSiblingNumber >= newSiblingNumber
            && projPlanVersion.HierarchyId == _hierarchyId
            && projPlanVersion.ParentHierarchyTaskId == grandParentTaskId;

        update_recordset projPlanVersion
            setting
            ParentHierarchyTaskId = grandParentTaskId,
            TaskSiblingNumber = newSiblingNumber
        where projPlanVersion.HierarchyId == _hierarchyId &&
            projPlanVersion.HierarchyTaskId == targetTaskId;

        ProjPlanVersion firstBelowSiblingVersion;
        select firstonly TaskSiblingNumber from firstBelowSiblingVersion
            order by TaskSiblingNumber
            where firstBelowSiblingVersion.HierarchyId == _hierarchyId
                  && firstBelowSiblingVersion.ParentHierarchyTaskId == parentTaskId
                  && firstBelowSiblingVersion.TaskSiblingNumber > oldSiblingNumber;
        oldStartSiblingNumberForBelowSiblingsMerge = firstBelowSiblingVersion.TaskSiblingNumber;

        real belowSiblingsMergeDelta = newStartSiblingNumberForBelowSiblingsMerge - oldStartSiblingNumberForBelowSiblingsMerge;
        update_recordset projPlanVersion
            setting
            ParentHierarchyTaskId = targetTaskId,
            TaskSiblingNumber = projPlanVersion.TaskSiblingNumber + belowSiblingsMergeDelta
        where projPlanVersion.HierarchyId == _hierarchyId
              && projPlanVersion.ParentHierarchyTaskId == parentTaskId
              && projPlanVersion.TaskSiblingNumber > oldSiblingNumber;

        ttscommit;

        if (!ProjPlanVersion::isSummaryTask(_hierarchyId, targetTaskId))
        {
            ProjEstimate::syncEstimateLinesFromTask(_hierarchyId, targetTaskId);
        }

        if (!projPlanVersion::isSummaryTask(_hierarchyId, parentTaskId))
        {
            var defaultCategory = ProjParameters::find().EmplCategory;
            update_recordset projPlanVersion
            setting
                TaskCategory =  defaultCategory,
                NumberofResources = 1,
                TaskEffort = 0
            where projPlanVersion.HierarchyId == _hierarchyId &&
                projPlanVersion.HierarchyTaskId == parentTaskId;
        }

        if (_wbsType == ProjWBSType::ProjectQuotation)
        {
            ElementNumber taskElementNumber = ProjTask::getCorrespondingTaskElementNumber(_hierarchyId, targetTaskId);
            ElementNumber parentElementNumber = ProjTask::getCorrespondingTaskElementNumber(_hierarchyId, parentTaskId);
            ElementNumber grandParentElementNumber = ProjTask::getCorrespondingTaskElementNumber(_hierarchyId, grandParentTaskId);
            ProjTaskNormalized::outdentTasks(_hierarchyId, taskElementNumber, parentElementNumber, grandParentElementNumber);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveTaskUp</Name>
				<Source><![CDATA[
    public static void moveTaskUp(HierarchyIdBase _hierarchyId, ProjWBSType _wbsType, str _taskId, str _aboveSiblingTaskId, str _siblingNumber = "", str _aboveSiblingNumber = "")
    {
        ProjHierarchyTaskId taskId = str2int64(_taskId);
        ProjHierarchyTaskId aboveSiblingTaskId = str2int64(_aboveSiblingTaskId);

        LineNum taskSiblingNumber = _siblingNumber ? str2num(_siblingNumber) : ProjPlanVersion::getTaskSiblingNumber(_hierarchyId, taskId);
        LineNum aboveSiblingNumber = _aboveSiblingNumber ? str2num(_aboveSiblingNumber) : ProjPlanVersion::getTaskSiblingNumber(_hierarchyId, aboveSiblingTaskId);

        ProjTask::swapTasks(_hierarchyId, taskId, aboveSiblingTaskId, taskSiblingNumber, aboveSiblingNumber);
        if (_wbsType == ProjWBSType::ProjectQuotation)
        {
            ElementNumber taskElementNumber = ProjTask::getCorrespondingTaskElementNumber(_hierarchyId, taskId);
            ElementNumber aboveSiblingElementNumber = ProjTask::getCorrespondingTaskElementNumber(_hierarchyId, aboveSiblingTaskId);
            ProjTaskNormalized::moveTaskUp(_hierarchyId, taskElementNumber, aboveSiblingElementNumber, taskSiblingNumber, aboveSiblingNumber);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveTaskDown</Name>
				<Source><![CDATA[
    public static void moveTaskDown(HierarchyIdBase _hierarchyId, ProjWBSType _wbsType, str _taskId, str _belowSiblingTaskId, str _siblingNumber = "", str _belowSiblingNumber = "")
    {
        ProjHierarchyTaskId taskId = str2int64(_taskId);
        ProjHierarchyTaskId belowSiblingTaskId = str2int64(_belowSiblingTaskId);

        LineNum taskSiblingNumber = _siblingNumber ? str2num(_siblingNumber) : ProjPlanVersion::getTaskSiblingNumber(_hierarchyId, taskId);
        LineNum belowSiblingNumber = _belowSiblingNumber ? str2num(_belowSiblingNumber) : ProjPlanVersion::getTaskSiblingNumber(_hierarchyId, belowSiblingTaskId);

        ProjTask::swapTasks(_hierarchyId, taskId, belowSiblingTaskId, taskSiblingNumber, belowSiblingNumber);
        if (_wbsType == ProjWBSType::ProjectQuotation)
        {
            ElementNumber taskElementNumber = ProjTask::getCorrespondingTaskElementNumber(_hierarchyId, taskId);
            ElementNumber belowSiblingElementNumber = ProjTask::getCorrespondingTaskElementNumber(_hierarchyId, belowSiblingTaskId);
            ProjTaskNormalized::moveTaskDown(_hierarchyId, taskElementNumber, belowSiblingElementNumber, taskSiblingNumber, belowSiblingNumber);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>swapTasks</Name>
				<Source><![CDATA[
    private static void swapTasks(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _taskId1, ProjHierarchyTaskId _taskId2, LineNum _siblingNumber1, LineNum _siblingNumber2)
    {
        ProjPlanVersion version;

        ttsbegin;
        update_recordset version
            setting TaskSiblingNumber = _siblingNumber1
            where version.HierarchyId == _hierarchyId
                  && version.HierarchyTaskId == _taskId2;

        update_recordset version
            setting TaskSiblingNumber = _siblingNumber2
            where version.HierarchyId == _hierarchyId
                  && version.HierarchyTaskId == _taskId1;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjDependencyPredecessor</Name>
				<Source><![CDATA[
    private static List getProjDependencyPredecessor(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _hierarchyTaskId)
    {
        ProjPlanVersion projPlanVersionPredecessor;
        ProjDependency  projDependency;
        List            predecessorData = new List(Types::Int64);

        while select PredecessorHierarchyTaskId from projDependency
            where projDependency.ProjPlanHierarchyId == _hierarchyId
                && projDependency.SuccessorHierarchyTaskId == _hierarchyTaskId
            exists join projPlanVersionPredecessor
                where projPlanVersionPredecessor.HierarchyId == _hierarchyId
                    && projPlanVersionPredecessor.HierarchyTaskId == projDependency.PredecessorHierarchyTaskId
        {
            predecessorData.addEnd(projDependency.PredecessorHierarchyTaskId);
        }

        return predecessorData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTasks</Name>
				<Source><![CDATA[
    public static CollectionDataContract getTasks(HierarchyIdBase _hierarchyId, boolean _showDiff = false)
    {
        List                        items = new List(Types::Class);
        ProjTaskDataContract        taskData;
        HierarchyTreeTable          hierarchyTreeTable;
        ProjPlanVersion             projPlanVersion, publishedProjPlanVersion;
        smmActivities               smmActivities;
        Map                         assignedResourceNameMap = new Map(Types::Int64, Types::String);
        Map                         assignedResourceRecIdMap = new Map(Types::Int64, Types::String);
        ProjHierarchyTaskId         curTask = 0, prevTask = -1;
        int                         counter = 0;

        void copyActivityData(ProjPlanVersion _projPlanVersion)
        {
            taskData.parmId(int642str(_projPlanVersion.HierarchyTaskId));
            taskData.parmParentId(int642str(_projPlanVersion.ParentHierarchyTaskId));
            taskData.parmName(_projPlanVersion.TaskName);
            taskData.parmUserMemo(_projPlanVersion.UserMemo);
            taskData.parmCategory(_projPlanVersion.TaskCategory);
            taskData.parmEffort(_projPlanVersion.TaskEffort);
            taskData.parmStartDate(_projPlanVersion.TaskStartDate);
            taskData.parmEndDate(_projPlanVersion.TaskFinishDate);
            taskData.parmDuration(_projPlanVersion.TaskDuration);
            taskData.parmNumResources(real2int(_projPlanVersion.NumberOfResources));
            taskData.parmResourceCategoryRecId(_projPlanVersion.ResourceCategory);
            taskData.parmEffortAtComplete(_projPlanVersion.TaskEffortAtComplete);
            taskData.parmCostAtComplete(_projPlanVersion.TaskCostAtComplete);
            taskData.parmSiblingNumber(real2int(_projPlanVersion.TaskSiblingNumber));
            taskData.parmPredecessorsData(ProjTask::getProjDependencyPredecessor(_hierarchyId, _projPlanVersion.HierarchyTaskId));
        }

        Set draftTasks = new Set(Types::Int64);

        ProjTask::getAssignedResource(_hierarchyId, assignedResourceNameMap, assignedResourceRecIdMap);
        ResCommitType commitType = ProjPlanVersionDetail::isQuotationHierarchy(_hierarchyId) ? ResCommitType::SoftBook : ResCommitType::HardBook;
        HierarchyIdBase publishedHierarchyId = ProjPlanVersionDetail::getNewDataModelPublishedHierarchyId(_hierarchyId);

        while select forupdate HierarchyId, TaskSiblingNumber, HierarchyTaskId, ParentHierarchyTaskId,
                TaskName, TaskCategory, TaskEffort, TaskStartDate, TaskFinishDate, TaskDuration,
                TaskEffortAtComplete, TaskCostAtComplete, NumberOfResources, ResourceCategory, UserMemo,
                TaskSchedulingStatus, TaskAssignedHours, RecId from projPlanVersion
            order by TaskSiblingNumber asc
                where projPlanVersion.HierarchyId == _hierarchyId
            outer join hierarchyTreeTable
                where projPlanVersion.HierarchyTreeTableRefRecId == hierarchyTreeTable.RecId
            outer join smmActivities
                where hierarchyTreeTable.RefRecId == smmActivities.RecId
            outer join publishedProjPlanVersion
                where publishedProjPlanVersion.HierarchyId == publishedHierarchyId
                    && publishedProjPlanVersion.HierarchyTaskId == projPlanVersion.HierarchyTaskId
        {
            curTask = projPlanVersion.HierarchyTaskId;
            draftTasks.add(projPlanVersion.HierarchyTaskId);

            if (curTask != prevTask)
            {
                if (counter > 0)
                {
                    items.addEnd(taskData);
                }
                taskData = ProjTaskDataContract::construct();
                taskData.parmHierarchyId(_hierarchyId);
                copyActivityData(projPlanVersion);

                if (_showDiff && !publishedProjPlanVersion)
                {
                    taskData.parmDifferenceType(ProjTaskDiffType::Added);
                }

                if (assignedResourceNameMap.exists(projPlanVersion.RecId))
                {
                    taskData.parmAssignedResourcesStr(assignedResourceNameMap.lookup(projPlanVersion.RecId));
                }
                if (assignedResourceRecIdMap.exists(projPlanVersion.RecId))
                {
                    taskData.parmAssignedResourcesRecId(assignedResourceRecIdMap.lookup(projPlanVersion.RecId));
                    taskData.parmAssignedResourcesOriginalRecId(assignedResourceRecIdMap.lookup(projPlanVersion.RecId));
                }

                ProjTaskDataContract activityAttributes = ProjTask::getActivitySchedulingAttributes(_hierarchyId, projPlanVersion, 0, commitType);
                taskData.parmRemainingHours(activityAttributes.parmRemainingHours());
                taskData.parmSchedulingStatus(activityAttributes.parmSchedulingStatus());
                taskData.parmHasDraftAssignment(activityAttributes.parmHasDraftAssignment());
                taskData.parmTotalAssignedActivityResources(activityAttributes.parmTotalAssignedActivityResources());
                taskData.parmTotalAssignedPlannedResources(activityAttributes.parmTotalAssignedPlannedResources());
                taskData.parmAssignedHours(activityAttributes.parmAssignedHours());
                
                counter++;
            }

            prevTask = projPlanVersion.HierarchyTaskId;
        }

        if (taskData != null)
        {
            items.addEnd(taskData);
        }

        boolean noDifference = true;

        if (_showDiff)
        {
            Map newParents = new Map(Types::Int64, Types::Class);

            ProjItemTrans       projItemTrans;
            ProjEmplTrans       projEmplTrans;
            ProjCostTrans       projCostTrans;

            while select publishedProjPlanVersion
                where publishedProjPlanVersion.HierarchyId == publishedHierarchyId
            join RefRecId from HierarchyTreeTable
                where HierarchyTreeTable.RecId == publishedProjPlanVersion.HierarchyTreeTableRefRecId
            join ActivityNumber from smmActivities
                where smmActivities.recId == HierarchyTreeTable.RefRecId
            outer join projItemTrans
                where projItemTrans.ActivityNumber == smmActivities.ActivityNumber
            outer join projEmplTrans
                where projEmplTrans.ActivityNumber == smmActivities.ActivityNumber
            outer join projCostTrans
                where projCostTrans.ActivityNumber == smmActivities.ActivityNumber
            notexists join projPlanVersion
                where projPlanVersion.HierarchyId == _hierarchyId
                    && projPlanVersion.HierarchyTaskId == publishedProjPlanVersion.HierarchyTaskId
            {
                noDifference = false;
                taskData = ProjTaskDataContract::construct();
                copyActivityData(publishedProjPlanVersion);
                taskData.parmHierarchyId(_hierarchyId);
                taskData.parmDifferenceType(ProjTaskDiffType::Deleted);

                if (projItemTrans || projEmplTrans || projCostTrans)
                {
                    taskData.parmDifferenceType(ProjTaskDiffType::DeletedWithActuals);
                }
                var parentTaskId = publishedProjPlanVersion.ParentHierarchyTaskId;
                if (draftTasks.in(parentTaskId))
                {
                    Set newChildren;
                    if (newParents.exists(parentTaskId))
                    {
                        newChildren = newParents.lookup(parentTaskId);
                    }
                    else
                    {
                        newChildren = new Set(Types::Class);
                        newParents.insert(parentTaskId, newChildren);
                    }
                    newChildren.add(taskData);
                }
                else
                {
                    items.addEnd(taskData);
                }
            }

            // If tasks are added after publishing avoid displaying the warning message
            if (noDifference)
            {
                select firstonly RecId from projPlanVersion
                    where projPlanVersion.HierarchyId == _hierarchyId
                notexists join publishedProjPlanVersion
                    where publishedProjPlanVersion.HierarchyId == publishedHierarchyId
                        && publishedProjPlanVersion.HierarchyTaskId == projPlanVersion.HierarchyTaskId;
                if (projPlanVersion.RecId != 0)
                {
                    noDifference = false;
                }
            }

            MapEnumerator newParentsEnumerator = newParents.getEnumerator();
            while (newParentsEnumerator.moveNext())
            {
                ProjHierarchyTaskId currentNewParent    = newParentsEnumerator.currentKey();
                Set                 newChildren         = newParentsEnumerator.currentValue();
                SetEnumerator       childrenEnumerator  = newChildren.getEnumerator();
                int siblingsCounter = 0;
                LineNumber firstNewSiblingNumber = ProjPlanVersion::getNextSiblingNumber(_hierarchyId, currentNewParent);
                while (childrenEnumerator.moveNext())
                {
                    ProjTaskDataContract currentTaskData = childrenEnumerator.current();
                    currentTaskData.parmSiblingNumber(real2int(firstNewSiblingNumber + counter));
                    items.addEnd(currentTaskData);
                    counter++;
                }
            }

            if (noDifference)
            {
                warning("@ProjPlan:NoDifferenceDetected");
            }
        }

        CollectionDataContract collection = CollectionDataContract::construct();
        collection.parmItems(items);

        return collection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>restoreTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Restore deleted task with its children and ancestors in the draft version.
    /// </summary>
    /// <param name = "_hierarchyId">Draft hierarchy ID.</param>
    /// <param name = "_taskId">Task ID in the published version.</param>
    /// <param name = "_skipParentCleanup">Flag that detemines if new parent task category and predecessors should be cleaned.</param>
    public static void restoreTask(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _taskId, boolean _skipParentCleanup = false)
    {
        HierarchyIdBase publishedHierarchyIdNewDataModel = ProjPlanVersionDetail::getNewDataModelPublishedHierarchyId(_hierarchyId);
        HierarchyIdBase publishedHierarchyIdOldDataModel = ProjPlanVersionDetail::getOldDataModelPublishedHierarchyId(_hierarchyId);
        var projPlanVersionInsertList = new RecordInsertList(tablenum(ProjPlanVersion), true, true, true, true, true);
        HierarchyTreeTable hierarchyTreeTable;

        ProjPlanVersion draftProjPlanVersion, publishedProjPlanVersion;
        select firstonly publishedProjPlanVersion
            where publishedProjPlanVersion.HierarchyId == publishedHierarchyIdNewDataModel
                && publishedProjPlanVersion.HierarchyTaskId == _taskId
        join Path, ElementNumber from hierarchyTreeTable
            where publishedProjPlanVersion.HierarchyTreeTableRefRecId == hierarchyTreeTable.RecId;
        HierarchyPath publishedTaskPath = hierarchyTreeTable.Path;
        ElementNumber piblishedTaskElementNumber = hierarchyTreeTable.ElementNumber;

        while (!ProjPlanVersion::findByHierarchyAndTaskId(_hierarchyId, publishedProjPlanVersion.ParentHierarchyTaskId))
        {
            draftProjPlanVersion.data(publishedProjPlanVersion);
            draftProjPlanVersion.HierarchyId = _hierarchyId;
            draftProjPlanVersion.TaskSiblingNumber = 1;
            projPlanVersionInsertList.add(draftProjPlanVersion);
            publishedProjPlanVersion = ProjPlanVersion::findByHierarchyAndTaskId(publishedHierarchyIdNewDataModel, publishedProjPlanVersion.ParentHierarchyTaskId);
        }

        draftProjPlanVersion.data(publishedProjPlanVersion);
        draftProjPlanVersion.HierarchyId = _hierarchyId;
        draftProjPlanVersion.TaskSiblingNumber = ProjPlanVersion::getNextSiblingNumber(_hierarchyId, publishedProjPlanVersion.ParentHierarchyTaskId);
        projPlanVersionInsertList.add(draftProjPlanVersion);

        ttsbegin;
        projPlanVersionInsertList.insertDatabase();

        if (_skipParentCleanup)
        {
            ProjPlanVersion parentProjPlanVersion;
            update_recordset parentProjPlanVersion
            setting
                TaskCategory = ''
            where parentProjPlanVersion.HierarchyId == _hierarchyId
                && parentProjPlanVersion.HierarchyTaskId == publishedProjPlanVersion.ParentHierarchyTaskId;

            ProjDependency parentDependency;
            delete_from parentDependency
            where parentDependency.ProjPlanHierarchyId == _hierarchyId
                && parentDependency.SuccessorHierarchyTaskId == publishedProjPlanVersion.ParentHierarchyTaskId;
        }
        insert_recordset draftProjPlanVersion (HierarchyId, HierarchyTaskId, TaskName, TaskCategory, NumberOfResources, ResourceCategory,
            TaskStartDate, TaskFinishDate, TaskDuration, TaskEffort, TaskCostAtComplete, TaskEffortAtComplete, TaskEffortToComplete,
            TaskProjectedEndDate, TaskProjectedCost, TaskProjectedRevenue, HierarchyTreeTableRefRecId, TaskSiblingNumber,
            TaskPriority, ActivityTaskTimeType, UserMemo, IsCategoryMandatory, ParentHierarchyTaskId)
        select _hierarchyId, HierarchyTaskId, TaskName, TaskCategory, NumberOfResources, ResourceCategory,
            TaskStartDate, TaskFinishDate, TaskDuration, TaskEffort, TaskCostAtComplete, TaskEffortAtComplete, TaskEffortToComplete,
            TaskProjectedEndDate, TaskProjectedCost, TaskProjectedRevenue, HierarchyTreeTableRefRecId, TaskSiblingNumber,
            TaskPriority, ActivityTaskTimeType, UserMemo, IsCategoryMandatory, ParentHierarchyTaskId
        from publishedProjPlanVersion
            where publishedProjPlanVersion.HierarchyId == publishedHierarchyIdNewDataModel
        exists join hierarchyTreeTable
            where hierarchyTreeTable.HierarchyId == publishedHierarchyIdOldDataModel
                && hierarchyTreeTable.Path like publishedTaskPath + "*"
                && hierarchyTreeTable.Path != publishedTaskPath
                && hierarchyTreeTable.RecId == publishedProjPlanVersion.HierarchyTreeTableRefRecId;

        PSAActivityEstimates draftPSAActivityEstimates, publishedPSAActivityEstimates;
        smmActivities smmActivities;
        insert_recordset draftPSAActivityEstimates (ProjPlanHierarchyId, ProjPlanHierarchyTaskId, Description,
            InventDimId, ItemId, LinePropertyId, ProjCategoryId, ProjTransType, Quantity, Resource, ResourceCategory,
            SalesCategory, TotalCostPrice, TotalSalesPrice, UnitCostPrice, UnitSalesPrice)
        select _hierarchyId, ProjPlanHierarchyTaskId, Description,
            InventDimId, ItemId, LinePropertyId, ProjCategoryId, ProjTransType, Quantity, Resource, ResourceCategory,
            SalesCategory, TotalCostPrice, TotalSalesPrice, UnitCostPrice, UnitSalesPrice
        from publishedPSAActivityEstimates
            where publishedPSAActivityEstimates.ProjPlanHierarchyId == publishedHierarchyIdNewDataModel
        join smmActivities
        join hierarchyTreeTable
            where hierarchyTreeTable.HierarchyId == publishedHierarchyIdOldDataModel
                && hierarchyTreeTable.Path like publishedTaskPath + "*"
                && (hierarchyTreeTable.Path != publishedTaskPath || hierarchyTreeTable.ElementNumber == piblishedTaskElementNumber)
                && hierarchyTreeTable.RefRecId == smmActivities.RecId
                && publishedPSAActivityEstimates.ActivityNumber == smmActivities.ActivityNumber;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResourceCategories</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get collection of resource categories for thie LE.
    /// </summary>
    /// <returns>
    /// Collection of resource categories.
    /// </returns>
    public static CollectionDataContract getResourceCategories()
    {
        CollectionDataContract          collection;
        List                            items = new List(Types::Class);
        ResResourceCategoryDataContract taskData;
        QueryRun                        queryRun;
        Query                           query = new Query();
        QueryBuildDataSource            queryBuildDataSource;
        TableId                         collectionRootDataSourceId = tablenum(PSASchedRole);
        PSASchedRole                    resourceCategory;

        taskData = ResResourceCategoryDataContract::construct();
        taskData.parmResourceCategoryRecId(0);
        taskData.parmResourceCategoryId("@Res:NoRole");
        items.addEnd(taskData);

        queryBuildDataSource = query.addDataSource(collectionRootDataSourceId);
        queryBuildDataSource.addRange(fieldnum(PSASchedRole, Disable)).value(queryValue(false));
        queryBuildDataSource.addSortField(fieldnum(PSASchedRole, RoleId), SortOrder::Ascending);

        queryRun = new QueryRun(query);

        while (queryRun.next())
        {
            resourceCategory = queryRun.get(tablenum(PSASchedRole));
            taskData = ResResourceCategoryDataContract::construct();
            taskData.parmResourceCategoryRecId(resourceCategory.RecId);
            taskData.parmResourceCategoryId(resourceCategory.RoleId);
            items.addEnd(taskData);
        }
        collection = CollectionDataContract::construct();
        collection.parmItems(items);

        return collection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPublishedHierarchyId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the published version Hierarchy ID from the hierarchy ID from ProjPlanVersion table.
    /// </summary>
    /// <param name = "_projPlanVersionHierarchyId"><c>ProjPlanVersion</c> hierarchy ID.</param>
    /// <returns>Published version hierarchy ID.</returns>
    public static HierarchyIdBase getPublishedHierarchyId(HierarchyIdBase _projPlanVersionHierarchyId)
    {
        return ProjPlanVersionDetail::getOldDataModelPublishedHierarchyId(_projPlanVersionHierarchyId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivityRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get <c>smmActivities</c> record ID by <c>ProjPlanVersion</c> hierarchy ID and task ID.
    /// </summary>
    /// <param name = "_hierarchyId"><c>ProjPlanVersion</c> hierarchy ID.</param>
    /// <param name = "_taskElementNumber"><c>ProjPlanVersion</c> hierarchy task ID.</param>
    /// <returns><c>smmActivities</c> record ID.</returns>
    public static ActivityRecId getActivityRecId(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _taskId)
    {
        return ProjPlanVersion::getActivityRecId(_hierarchyId, _taskId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivityRecIdByProjPlanVersionRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get <c>smmActivities</c> record ID by <c>ProjPlanVersion</c> record ID.  User should first
    /// validate if the planning hierarchy is already published before calling this method.
    /// </summary>
    /// <param name = "_projPlanVersionRecId">
    /// <c>ProjPlanVersion</c> table record ID.
    /// </param>
    /// <returns>
    /// <c>smmActivities</c> record ID.
    ///</returns>
    protected static ActivityRecId getActivityRecIdByProjPlanVersionRecId(ProjPlanVersionRecId _projPlanVersionRecId)
    {
        HierarchyTreeTable      hierarchyTreeTable;
        ProjPlanVersion         projPlanVersion;

        select RefRecId from hierarchyTreeTable
            join projPlanVersion
                where projPlanVersion.HierarchyTreeTableRefRecId == HierarchyTreeTable.RecId
                    && projPlanVersion.RecId == _projPlanVersionRecId;

        return hierarchyTreeTable ? hierarchyTreeTable.RefRecId : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivitySchedulingAttributes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate the following parameters for the specified activity regardless of it is in draft or published:
    /// 1. Remaining hours
    /// 2. Scheduling status
    /// 3. For draft activity, boolean to represent if it has draft assignment.
    /// 4. Number of assigned resources if the activity has draft assignment.
    /// 5. Number of assigned planned resources if the activity has draft assignment.
    /// 6. Calculate assigned hours.
    /// This also performs calculation of the ProjPlanVersion.TaskSchedulingStatus and ProjPlanVersion.AssignedHours fields, if they have not been touched yet.
    /// </summary>
    /// <param name = "_hierarchyId">
    /// The field value of <c>ProjPlanVersion</c> table hierarchy ID.
    /// </param>
    /// <param name = "_projPlanVersion">
    /// The <c>ProjPlanVersion</c> table buffer.
    /// </param>
    /// <param name = "_activitySetupRecId">
    /// The record ID of the <c>PSAActivitySetup</c> table record (Deprecated field, value should be 0).
    /// </param>
    /// <param name = "_commitType">
    /// CommitType by default is hard, but for quotation should be soft bookings.
    /// </param>
    /// <returns>
    /// Return an instance of ProjTaskDataContract to contains various parameters which specified in summary.
    /// </returns>
    public static ProjTaskDataContract getActivitySchedulingAttributes(HierarchyIdBase _hierarchyId, ProjPlanVersion _projPlanVersion, 
        RefRecId _activitySetupRecId, ResCommitType _commitType = ResCommitType::HardBook)
    {
        PSAActivitySetup activitySetup = PSAActivitySetup::findRecId(_activitySetupRecId);

        ProjPlanVersionDetail planVersionDetail = ProjPlanVersionDetail::findByHierarchyId(_hierarchyId);
        boolean isProject = ProjPlanVersionDetail::isProjectHierarchy(_hierarchyId);
        boolean activityIsDraft = isProject && (planVersionDetail.VersionType == ProjPlanVersionType::Draft);
        
        str assignedResourceNames, assignedResourceRecIds;
        Hours                       remainingHours, assignedHours;
        int                         totalActivityResources, totalPlannedResources;
        ResActivityResourcesType    activityResourcesType;
        boolean                     hasDraftAssignment;
        
        if (activityIsDraft && ProjPlanVersionAssignment::hasProjPlanVersion(_projPlanVersion.RecId))
        {
            [assignedResourceNames, assignedResourceRecIds] = ProjTask::getAssignedResourcesPerDraftActivity(_projPlanVersion.RecId);

            if (assignedResourceRecIds)
            {
                [activityResourcesType, totalActivityResources, totalPlannedResources] = ProjTask::getActivityResourcesType(assignedResourceRecIds);
            
                if (activityResourcesType != ResActivityResourcesType::HasInvalidResources)
                {
                    hasDraftAssignment = true;

                    switch (activityResourcesType)
                    {
                        case ResActivityResourcesType::AllPlannedResources:
                            remainingHours = _projPlanVersion.TaskEffort;
                            assignedHours = 0;
                            break;
                        case ResActivityResourcesType::AllStaffedResources:
                            remainingHours = 0;
                            assignedHours = _projPlanVersion.TaskEffort;
                            break;
                        case ResActivityResourcesType::SomePlannedResources:
                            remainingHours = _projPlanVersion.TaskEffort / totalActivityResources * totalPlannedResources;
                            assignedHours = _projPlanVersion.TaskEffort - remainingHours;
                            break;
                    }
                }
            }
            else
            {
                // For the scenario of no resource is assigned to the task in draft mode and this task has cancelation assignment.
                remainingHours = _projPlanVersion.TaskEffort;
                assignedHours = 0;
            }
        }
        // Execute whether if this is published or if it had been published.
        else if (planVersionDetail.VersionType == ProjPlanVersionType::PublishedCurrent || planVersionDetail.VersionId > 1.0)
        {
            ActivityRecId taskActivityRecId = ProjPlanVersion::getActivityRecId(_projPlanVersion.HierarchyId, _projPlanVersion.HierarchyTaskId);
            [assignedResourceNames, assignedResourceRecIds] = ProjTask::getAssignedResourcePerActivity(taskActivityRecId, _commitType);

            if (assignedResourceRecIds)
            {
                [activityResourcesType, totalActivityResources, totalPlannedResources] = ProjTask::getActivityResourcesType(assignedResourceRecIds);
            }

            ProjPlanVersionDetail lastPublishedPlanVersionDetail;
            ProjPlanVersion lastPublishedPlanVersion;
            if (activityIsDraft)
            {
                lastPublishedPlanVersionDetail = ProjPlanVersionDetail::findLatestByHierarchyId(_projPlanVersion.HierarchyId, false, false, ProjPlanVersionType::PublishedCurrent);
                lastPublishedPlanVersion = ProjPlanVersion::findByHierarchyAndTaskId(lastPublishedPlanVersionDetail.HierarchyId, _projPlanVersion.HierarchyTaskId);
            }

            if (activityIsDraft && (_projPlanVersion.TaskEffort != lastPublishedPlanVersion.TaskEffort))
            {
                HierarchyTreeTable hierarchyTreeTable = HierarchyTreeTable::findActivityRecId(taskActivityRecId);
                if (!hierarchyTreeTable::childNodeCount(hierarchyTreeTable.HierarchyId, HierarchyTreeTable.ElementNumber))
                {
                    // For the case of user has only updated the effort hours on WBS with no activity resources assigned to the task in draft mode.
                    real tmpRemainingHours = (_projPlanVersion.TaskEffort - lastPublishedPlanVersion.TaskEffort) + lastPublishedPlanVersion.getRemainingEffortHours();
                    remainingHours = max(tmpRemainingHours, 0);
                    assignedHours = _projPlanVersion.TaskEffort - remainingHours;
                }
            }
            else if (activityIsDraft && !assignedResourceRecIds)
            {
                // For the scenario of no resource is assigned to the task in draft mode.
                remainingHours = _projPlanVersion.TaskEffort;
                assignedHours = 0;
            }
            else
            {
                remainingHours = _projPlanVersion.getRemainingEffortHours();
                assignedHours = _projPlanVersion.TaskAssignedHours;
            }
        }

        // Validate if <c>ProjPlanVersion</c> table TaskSchedulingStatus field is valid. Else recalculate it.
        // This validation is needed because design has been changed to use <c>ProjPlanVersion</c> table TaskSchedulingStatus field
        // to store scheduling status value instead of <c>PSAActivitySetup</c> table PSAScheduled field.
        // However, this condition is expected to run only once when user launches WBS for the very first time
        // which  <c>ProjPlanVersion</c> table TaskSchedulingStatus and TaskAssignedHours have not been set yet.
        int totalStaffedResources = totalActivityResources - totalPlannedResources;
        if (_projPlanVersion.TaskSchedulingStatus == PSAScheduled::NotScheduled && totalStaffedResources > 0)
        {
            _projPlanVersion.selectForUpdate(true);

            ttsbegin;
            if (activityIsDraft)
            {
                // Set both task status and task assigned hours fields.
                ProjTask::getDraftTaskStatusAndAssignedHours(activityResourcesType,
                    _projPlanVersion, totalActivityResources, totalPlannedResources);
            }
            else
            {
                _projPlanVersion.TaskSchedulingStatus = ProjActivityCapacity::GetPSAScheduleStatus(_projPlanVersion.TaskEffort, assignedHours);
                _projPlanVersion.TaskAssignedHours = assignedHours;
            }
            _projPlanVersion.update();

            // Update parent task scheduling status and task assigned hours.
            if (_projPlanVersion.ParentHierarchyTaskId)
            {
                ProjPlanVersion parentTask = ProjPlanVersion::findByHierarchyAndTaskId(_projPlanVersion.HierarchyId, _projPlanVersion.ParentHierarchyTaskId, true);
                ProjActivityCapacity::updateSummaryTaskSchedulingStatus(parentTask);
            }
            ttscommit;
        }

        ProjTaskDataContract projTaskContract = ProjTaskDataContract::construct();
        projTaskContract.parmRemainingHours(remainingHours);
        projTaskContract.parmSchedulingStatus(enum2str(_projPlanVersion.TaskSchedulingStatus));
        projTaskContract.parmHasDraftAssignment(hasDraftAssignment);
        projTaskContract.parmTotalAssignedActivityResources(totalActivityResources);
        projTaskContract.parmTotalAssignedPlannedResources(totalPlannedResources);
        projTaskContract.parmAssignedHours(assignedHours);
            
        return projTaskContract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAssignedResource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates two maps with lookup information of assigned resource for a particular hierarchy.
    /// </summary>
    /// <param name = "_projPlanVersionHierarchyId">
    /// <c>ProjPlanVersion</c> hierarchy ID.
    /// </param>
    /// <param name = "_assignedResourceNameMap">
    /// The first map to be populated. It stores the entire WBS assigned resources string or activity
    /// resource record ID  per <c>ProjPlanVersion</c> record ID of the specified hierarchy ID.
    /// </param>
    /// <param name = "_assignedResourceRecIdMap">
    /// The second map to be populated. It stores the entire WBS assigned resources activity
    /// resource record ID per <c>ProjPlanVersion</c> record ID of the specified hierarchy ID.
    /// </param>
    public static void getAssignedResource(HierarchyIdBase _projPlanVersionHierarchyId, Map _assignedResourceNameMap, Map _assignedResourceRecIdMap, ResCommitType _commitType = ResCommitType::AnyType)
    {
        ProjPlanVersionDetail projPlanVersionDetail = ProjPlanVersionDetail::findByHierarchyId(_projPlanVersionHierarchyId);
        
        if (ProjTask::getPublishedHierarchyId(_projPlanVersionHierarchyId))
        {
            //Get assigned resources maps for published tasks according to ResAssignment table.
            HierarchyTreeTable  hierarchyTreeTable;
            smmActivities       smmActivities;
            ResAssignment       resAssignment;
            PSAProjSchedRole    projectTeam;
            ProjPlanVersion     projPlanVersion;

            while select resAssignment group by resAssignment.ActivityResource, projPlanVersion.RecId, projectTeam.Name, projectTeam.RecId
                where (_commitType  == ResCommitType::AnyType || resAssignment.CommitType == _commitType)
                join Name, RecId from projectTeam
                    where projectTeam.RecId == resAssignment.ActivityResource
                join smmActivities
                    where smmActivities.RecId == resAssignment.Activity
                join hierarchyTreeTable
                    where hierarchyTreeTable.RefRecId == smmActivities.RecId
                join RecId from projPlanVersion
                    where projPlanVersion.HierarchyId == _projPlanVersionHierarchyId
                        && projPlanVersion.HierarchyTreeTableRefRecId == hierarchyTreeTable.RecId
            {
                if (!(projPlanVersionDetail.VersionType == ProjPlanVersionType::Draft && ProjPlanVersionAssignment::hasProjPlanVersion(projPlanVersion.RecId)))
                {
                    // In the case of Quotation, ProjPlanVersionType will always be Published and hence the following code will be executed.
                    // In the case of Project, if ProjPlanVersionType is draft and this ProjPlanVersion.RecId exists in ProjPlanVersionAssignment table,
                    // then the following code should not be executed.
                    str resourceName = projectTeam.Name;
                    str activityResourceRecIdStr = int642str(projectTeam.RecId);

                    ProjTask::getAssignedResourceMaps(
                        _assignedResourceNameMap, _assignedResourceRecIdMap, projPlanVersion.RecId, resourceName, activityResourceRecIdStr);
                }
            }
        }

        if (projPlanVersionDetail.VersionType == ProjPlanVersionType::Draft)
        {
            //Get assigned resources maps for draft tasks according to ProjPlanVersionAssignment table.
            ProjPlanVersion             projPlanVersion;
            ProjPlanVersionAssignment   projPlanVersionAssignment;
            PSAProjSchedRole            projectTeam;

            while select ActivityResource from projPlanVersionAssignment
                where projPlanVersionAssignment.ReservationType == ProjPlanVersionAssignmentType::Reserve
                join RecId from projPlanVersion
                    where projPlanVersion.HierarchyId == _projPlanVersionHierarchyId
                        && projPlanVersion.RecId == projPlanVersionAssignment.ProjPlanVersion
                join Name from projectTeam
                    where projectTeam.RecId == projPlanVersionAssignment.ActivityResource
            {
                str resourceName = projectTeam.Name;
                str activityResourceRecIdStr = int642str(projPlanVersionAssignment.ActivityResource);

                ProjTask::getAssignedResourceMaps(
                    _assignedResourceNameMap, _assignedResourceRecIdMap, projPlanVersion.RecId, resourceName, activityResourceRecIdStr);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAssignedResourceMaps</Name>
				<Source><![CDATA[
    private static void getAssignedResourceMaps(Map _assignedResourceNameMap, Map _assignedResourceRecIdMap, 
        ProjPlanVersionRecId _projPlanVersionRecId, str _resourceName, str _activityResourceRecIdStr)
    {
        str tmpAssignedResoureName = '';
        str tmpAssignedResoureRecId = '';
        if (_assignedResourceNameMap.exists(_projPlanVersionRecId) && _assignedResourceRecIdMap.exists(_projPlanVersionRecId))
        {
            tmpAssignedResoureName = _assignedResourceNameMap.lookup(_projPlanVersionRecId);
            _assignedResourceNameMap.remove(_projPlanVersionRecId);
            tmpAssignedResoureRecId = _assignedResourceRecIdMap.lookup(_projPlanVersionRecId);
            _assignedResourceRecIdMap.remove(_projPlanVersionRecId);
        }
        if (tmpAssignedResoureName && tmpAssignedResoureRecId)
        {
            _assignedResourceNameMap.insert(_projPlanVersionRecId, tmpAssignedResoureName + ', ' + _resourceName);
            _assignedResourceRecIdMap.insert(_projPlanVersionRecId, tmpAssignedResoureRecId + ',' + _activityResourceRecIdStr);
        }
        else
        {
            _assignedResourceNameMap.insert(_projPlanVersionRecId, _resourceName);
            _assignedResourceRecIdMap.insert(_projPlanVersionRecId, _activityResourceRecIdStr);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivityAssignedHours</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the assigned hours of the activity based on the <c>ProjPlanVersion</c> record ID.
    /// </summary>
    /// <param name = "_projPlanVersionRecId">
    /// The RecId of the <c>ProjPlanVersion</c> table record.
    /// </param>
    /// <param name = "_commitType">
    /// The Commit Type of the reservation which by default is hard booking, but for quotation should be soft booking.
    /// </param>
    /// <returns>
    /// Returns the total resource assigned hours for the task if the task is published, otherwise returns 0.
    /// </returns>
    public static Hours getActivityAssignedHours(ProjPlanVersionRecId _projPlanVersionRecId, ResCommitType _commitType = ResCommitType::HardBook)
    {
        ActivityRecId       activity;
        PSAActivitySetup    psaActivitySetup;
        Hours               assignedHours;

        activity = ProjTask::getActivityRecIdByProjPlanVersionRecId(_projPlanVersionRecId);

        if (activity)
        {
            psaActivitySetup = PSAActivitySetup::findActivityNumber(smmActivities::findWithRecId(activity).ActivityNumber);
            assignedHours = psaActivitySetup.sumHours(_commitType, false);
        }

        return assignedHours;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcActivityAssignedHours</Name>
				<Source><![CDATA[
    public static Hours calcActivityAssignedHours(PSAActivitySetup activitySetup, ResCommitType _commitType = ResCommitType::HardBook)
    {
        Hours assignedHours;

        if (activitySetup)
        {
            assignedHours = activitySetup.sumHours(_commitType, false);
        }

        return assignedHours;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAssignedResourcePerActivity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get two strings.  The first one store the activity WBS assigned resources string or activity
    /// resource record ID per <c>smmActivities</c> record ID.
    /// The second one stroe the entire WBS assigned resources activity resource record ID per
    /// <c>smmActivities</c> record ID.
    /// </summary>
    /// <param name = "_activity">
    /// smmActivities record ID.
    /// </param>
    /// <returns>
    /// Container which contains the assigned reosurce names and activity resources.
    /// </returns>
    public static container getAssignedResourcePerActivity(ActivityRecId _activity, ResCommitType _commitType = ResCommitType::AnyType)
    {
        smmActivities           smmActivities;
        ResAssignment           resAssignment;
        PSAProjSchedRole        projectTeam;
        str                     tmpAssignedResoureName;
        str                     tmpAssignedResoureRecId;

        while select resAssignment group by resAssignment.ActivityResource, projectTeam.Name, projectTeam.RecId
            where (_commitType  == ResCommitType::AnyType || resAssignment.CommitType == _commitType)
            join Name, RecId from projectTeam
                where projectTeam.RecId == resAssignment.ActivityResource
                join smmActivities
                    where smmActivities.RecId == resAssignment.Activity
                        && smmActivities.RecId == _activity
        {
            if (tmpAssignedResoureName && tmpAssignedResoureRecId)
            {
                tmpAssignedResoureName += ', ' + projectTeam.Name;
                tmpAssignedResoureRecId += ',' + int642str(projectTeam.RecId);
            }
            else
            {
                tmpAssignedResoureName = projectTeam.Name;
                tmpAssignedResoureRecId = int642str(projectTeam.RecId);
            }
        }

        return [tmpAssignedResoureName, tmpAssignedResoureRecId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAssignedResourcesPerDraftActivity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get draft task assigned resources by the specified <c>ProjPlanVersion</c> record ID.
    /// </summary>
    /// <param name = "_projPlanVersion"><c>ProjPlanVersion</c> table record ID of the specified draft task.</param>
    /// <returns>Container which contains activity resources name and record ID in string.</returns>
    public static container getAssignedResourcesPerDraftActivity(ProjPlanVersionRecId _projPlanVersion)
    {
        str tmpAssignedResoureName;
        str tmpAssignedResoureRecId;

        if (_projPlanVersion)
        {
            //Get assigned resources for draft tasks according to ProjPlanVersionAssignment table.
            ProjPlanVersionAssignment   projPlanVersionAssignment;
            PSAProjSchedRole            projectTeam;

            while select ActivityResource from projPlanVersionAssignment
                where projPlanVersionAssignment.ProjPlanVersion == _projPlanVersion
                    && projPlanVersionAssignment.ReservationType == ProjPlanVersionAssignmentType::Reserve
                join Name from projectTeam
                    where projectTeam.RecId == projPlanVersionAssignment.ActivityResource
            {
                str resourceName = projectTeam.Name;
                str activityResourceRecIdStr = int642str(projPlanVersionAssignment.ActivityResource);

                if (tmpAssignedResoureName && tmpAssignedResoureRecId)
                {
                    tmpAssignedResoureName += ', ' + resourceName;
                    tmpAssignedResoureRecId += ',' + activityResourceRecIdStr;
                }
                else
                {
                    tmpAssignedResoureName = resourceName;
                    tmpAssignedResoureRecId = activityResourceRecIdStr;
                }
            }
        }

        return [tmpAssignedResoureName, tmpAssignedResoureRecId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignResourcesToDraftTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assign the specified resources to the specified draft task. Also update the WBS scheduling status.
    /// </summary>
    /// <param name = "_projPlanVersion"><c>ProjPlanVersion</c> table record ID of the specified draft task.</param>
    /// <param name = "_assignedResourceRecId">The list of activity resource record ID.</param>
    public static void assignResourcesToDraftTask(ProjPlanVersionRecId _projPlanVersion, str _assignedResourcesRecId)
    {
        if (_projPlanVersion)
        {
            ProjPlanVersion planVersion = ProjPlanVersion::findByRecId(_projPlanVersion, true);
            PSAScheduled originalSchedulingStatus = planVersion.TaskSchedulingStatus;

            ttsbegin;
            if (_assignedResourcesRecId)
            {
                ResActivityResourcesType activityResourcesType;
                int totalActivityResources, totalPlannedResources;
                [activityResourcesType, totalActivityResources, totalPlannedResources] = ProjTask::getActivityResourcesType(_assignedResourcesRecId);

                if (activityResourcesType != ResActivityResourcesType::HasInvalidResources && totalActivityResources)
                {
                    
                    List assignedResourcesList = Global::strSplit(_assignedResourcesRecId, ',');
                    ListEnumerator assignedResourcesListEnum = assignedResourcesList.getEnumerator();

                    ProjPlanVersionAssignment projPlanVersionAssignment;
                    RecordInsertList projPlanVersionRecordsToBeInserted = new RecordInsertList(tableNum(ProjPlanVersionAssignment));
                    ProjTask::callInsertUpdateRelatedSkipMethods(projPlanVersionAssignment);
                
                    while (assignedResourcesListEnum.moveNext())
                    {
                        projPlanVersionAssignment.clear();
                        projPlanVersionAssignment.ProjPlanVersion = _projPlanVersion;
                        projPlanVersionAssignment.ActivityResource = assignedResourcesListEnum.current();
                        projPlanVersionAssignment.ReservationType = ProjPlanVersionAssignmentType::Reserve;
                        projPlanVersionRecordsToBeInserted.add(projPlanVersionAssignment);
                    }

                    projPlanVersionRecordsToBeInserted.insertDatabase();

                    ProjTask::getDraftTaskStatusAndAssignedHours(activityResourcesType, planVersion, totalActivityResources, totalPlannedResources);
                }
            }
            else
            {
                planVersion.TaskSchedulingStatus = PSAScheduled::NotScheduled;
                planVersion.TaskAssignedHours = 0;
            }

            planVersion.update();

            // Only update the project scheduling status for the summary task if the scheduling status has been changed.
            if ((planVersion.TaskSchedulingStatus != originalSchedulingStatus))
            {
                if (planVersion.ParentHierarchyTaskId)
                {
                    ProjPlanVersion parentTask = ProjPlanVersion::findByHierarchyAndTaskId(planVersion.HierarchyId, planVersion.ParentHierarchyTaskId, true);
                    ProjActivityCapacity::updateSummaryTaskSchedulingStatus(parentTask);
                }

                // Only update project scheduling status if this is a project.
                ProjTable projTable = ProjPlanVersionDetail::getProjTableByHierarchyId(planVersion.HierarchyId);
                if (projTable.ProjId)
                {
                    ProjActivityCapacity::updateScheduleStatusByProject(projTable.ProjId);
                }
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDraftTaskStatusAndAssignedHours</Name>
				<Source><![CDATA[
    private static void getDraftTaskStatusAndAssignedHours(ResActivityResourcesType _activityResourcesType, ProjPlanVersion _planVersion,
        int _totalActivityResources, int _totalPlannedResources)
    {
        switch (_activityResourcesType)
        {
            case ResActivityResourcesType::AllPlannedResources:
                _planVersion.TaskSchedulingStatus = PSAScheduled::NotScheduled;
                _planVersion.TaskAssignedHours = 0;
                break;
            case ResActivityResourcesType::AllStaffedResources:
                _planVersion.TaskSchedulingStatus = PSAScheduled::FullyScheduled;
                _planVersion.TaskAssignedHours = _planVersion.TaskEffort;
                break;
            case ResActivityResourcesType::SomePlannedResources:
                _planVersion.TaskSchedulingStatus = PSAScheduled::PartiallyScheduled;
                _planVersion.TaskAssignedHours = decRound(((_planVersion.TaskEffort / _totalActivityResources) * (_totalActivityResources - _totalPlannedResources)), 4);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeResourcesFromDraftTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Remove resources from the specified draft task.
    /// </summary>
    /// <param name = "_projPlanVersion"><c>ProjPlanVersion</c> table record ID of the specified draft task.</param>
    /// <param name = "_assignedResourceRecId">The list of original activity resource record ID to be removed.</param>
    public static void removeResourcesFromDraftTask(ProjPlanVersionRecId _projPlanVersion, str _assignedResourceOriginalRecId)
    {
        if (_projPlanVersion)
        {
            ProjPlanVersionAssignment projPlanVersionAssignment;

            ProjTask::callInsertUpdateRelatedSkipMethods(projPlanVersionAssignment);

            ttsbegin;
            delete_from projPlanVersionAssignment
                where projPlanVersionAssignment.ProjPlanVersion == _projPlanVersion
                    && projPlanVersionAssignment.ReservationType == ProjPlanVersionAssignmentType::Reserve;
            
            if (!ProjPlanVersionAssignment::hasCancelation(_projPlanVersion) && _assignedResourceOriginalRecId)
            {
                ResActivityResourcesType activityResourcesType;
                int totalActivityResources, totalPlannedResources;
                [activityResourcesType, totalActivityResources, totalPlannedResources] = ProjTask::getActivityResourcesType(_assignedResourceOriginalRecId);

                if (activityResourcesType != ResActivityResourcesType::HasInvalidResources && totalActivityResources)
                {
                    List assignedResourcesOriginalList = strSplit(_assignedResourceOriginalRecId, ',');
                    ListEnumerator assignedResourcesOriginalListEnum = assignedResourcesOriginalList.getEnumerator();
                    
                    while (assignedResourcesOriginalListEnum.moveNext())
                    {
                        // Only add a reservation cancelation record in ProjPlanVersionAssignment if there is at least
                        // one activity resource is assigned to this activity according to ResAssignment table.
                        if (ProjTask::isActivityResourceAssigned(_projPlanVersion, str2Int64(assignedResourcesOriginalListEnum.current())))
                        {
                            projPlanVersionAssignment.clear();
                            projPlanVersionAssignment.ProjPlanVersion = _projPlanVersion;
                            projPlanVersionAssignment.ActivityResource = 0;
                            projPlanVersionAssignment.ReservationType = ProjPlanVersionAssignmentType::Cancel;
                            projPlanVersionAssignment.insert();
                            break;
                        }
                    }
                }
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isActivityResourceAssigned</Name>
				<Source><![CDATA[
    private static boolean isActivityResourceAssigned(ProjPlanVersionRecId _projPlanVersion, activityresourcerecid _activityResource)
    {
        ProjPlanVersion     projPlanVersion;
        HierarchyTreeTable  hierarchyTreeTable;
        smmActivities       smmActivity;
        ResAssignment       resAssignment;

        select firstonly RecId from resAssignment
            where resAssignment.ActivityResource == _activityResource
            exists join smmActivity
                where smmActivity.RecId == resAssignment.Activity
            exists join hierarchyTreeTable
                where hierarchyTreeTable.RefRecId == smmActivity.RecId
            exists join projPlanVersion
                where projPlanVersion.HierarchyTreeTableRefRecId == hierarchyTreeTable.RecId
                    && projPlanVersion.RecId == _projPlanVersion;

        return ResAssignment.RecId ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQuotationTeamMembers</Name>
				<Source><![CDATA[
    /// <summary>
    /// When a resource is selected to get unassigned form a quotation task, and if this resource is not
    /// assigned to any other task in this quotation, then remove this resource from this quotation team.
    /// </summary>
    /// <param name = "_activity">Activity record ID.</param>
    /// <param name = "_assignedResourceOriginalRecId">The list of originally assigned activity resource record ID.</param>
    /// <param name = "_assignedResourcesRecId">The list of newly assigned activity resource record ID.</param>
    public static void updateQuotationTeamMembers(ActivityRecId _activity, str _assignedResourceOriginalRecId, str _assignedResourcesRecId)
    {
        if (ActivityFacade::getActivityType(_activity) == PSARSEntityType::Quotation)
        {
            ListEnumerator originalAssignedResourceListEnum = Global::strSplit(_assignedResourceOriginalRecId, ',').getEnumerator();
            ListEnumerator currentSelectedResourceListEnum = Global::strSplit(_assignedResourcesRecId, ',').getEnumerator();
            Set currentSelectedResourceSet = new Set(Types::String);

            while (currentSelectedResourceListEnum.moveNext())
            {
                currentSelectedResourceSet.add(currentSelectedResourceListEnum.current());
            }

            ResProjTeamController projTeamController = ResProjTeamController::getInstanceFromActivityRecId(_activity);

            int listLength = ProjTask::getListEnumLength(originalAssignedResourceListEnum);
            boolean updateRollUpAsync = listLength <= ResUtil::numberOfAsyncProcessAllow;

            while (originalAssignedResourceListEnum.moveNext())
            {
                str current = originalAssignedResourceListEnum.current();
                ActivityResourceRecId activityResourceRecId = str2Int64(current);
                if (!currentSelectedResourceSet.in(current) && PSAProjSchedRole::findByRecId(activityResourceRecId).assignedHrs() <= 0)
                {
                    projTeamController.removeV2(activityResourceRecId, updateRollUpAsync);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getListLength</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get list length.
    /// </summary>
    /// <param name = "_list">Target list.</param>
    /// <returns>Length</returns>
    protected static int getListLength(List _list)
    {
        ListEnumerator  listEnum;
        int             listCounter = 0;

        listEnum = _list.getEnumerator();

        while (listEnum.moveNext())
        {
            listCounter++;
        }
        return listCounter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getListEnumLength</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get list enumerator length.
    /// </summary>
    /// <param name = "_listEnum">Target list enum.</param>
    /// <returns>Length of the list enum.</returns>
    private static int getListEnumLength(ListEnumerator _listEnum)
    {
        int listCounter = 0;

        while (_listEnum.moveNext())
        {
            listCounter++;
        }

        _listEnum.reset();

        return listCounter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivityResourcesType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get activity resoruces type from the specified string of activity resources record IDs.
    /// </summary>
    /// <param name = "_activityResourcesRecIds">The list of activity resources record ID to be validated.</param>
    /// <returns>
    /// Container which contains <c>ResActivityResourcesType</c> enum type, 
    /// the total number of activity resources and the total number of planned resources.
    /// </returns>
    private static container getActivityResourcesType(str _activityResourcesRecIds)
    {
        ResActivityResourcesType activityResourcesType;
        boolean allStaffedResources = true;
        boolean allPlannedResources = true;
        boolean somePlannedResources = true;
        boolean invalidResource = false;
        int     totalResources, totalPlannedResources;

        if (_activityResourcesRecIds)
        {
            List activityResourcesList = Global::strSplit(_activityResourcesRecIds, ',');
            ListEnumerator activityResourcesListEnum = activityResourcesList.getEnumerator();
    
            while (activityResourcesListEnum.moveNext())
            {
                totalResources++;
                if (!PSAProjSchedRole::findByRecId(activityResourcesListEnum.current()))
                {
                    invalidResource = true;
                    break;
                }

                boolean isPlannedResource = ActivityResourceFacade::isGenericResource(activityResourcesListEnum.current());
                if (isPlannedResource)
                {
                    totalPlannedResources++;
                }
            }
            allPlannedResources = totalResources == totalPlannedResources ? true : false;
            allStaffedResources = totalPlannedResources == 0 ? true : false;
        }

        if (invalidResource)
        {
            activityResourcesType = ResActivityResourcesType::HasInvalidResources;
        }
        else if (!allPlannedResources && !allStaffedResources)
        {
            activityResourcesType = ResActivityResourcesType::SomePlannedResources;
        }
        else if (allPlannedResources)
        {
            activityResourcesType = ResActivityResourcesType::AllPlannedResources;
        }
        else if (allStaffedResources)
        {
            activityResourcesType = ResActivityResourcesType::AllStaffedResources;
        }

        return [activityResourcesType, totalResources, totalPlannedResources];
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserveResourceActivity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reserve resources to activity and distribute the activity hours evenly.
    /// </summary>
    /// <param name = "_activity">The specified activity record ID.</param>
    /// <param name = "_assignedResourceRecId">The list of activity resource record ID.</param>
    /// <param name = "_startDate">Start date of the activity.</param>
    /// <param name = "_endDate">end date of the activity.</param>
    /// <param name = "_effort">Effort hours of the activity.</param>
    /// <param name = "_skipResourceFeedback">True will bypass the resoruce request creation confirmation message box and resource request submission feedback.</param>
    public static void reserveResourceActivity(ActivityRecId _activity, str _assignedResourcesRecId,
        TransDate _startDate, TransDate _endDate, real _effort, boolean _skipResourceFeedback = false)
    {
        #TimeConstants

        if (_activity && _assignedResourcesRecId)
        {
            ResActivityResourcesType activityResourcesType;
            int totalActivityResources, totalPlannedResources;
            [activityResourcesType, totalActivityResources, totalPlannedResources] = ProjTask::getActivityResourcesType(_assignedResourcesRecId);

            if (activityResourcesType != ResActivityResourcesType::HasInvalidResources && totalActivityResources)
            {
                boolean isWorkflowEnabled = ResRequestHelper::isWorkflowEnabled();
                if (isWorkflowEnabled)
                {
                    try
                    {
                        ResRequestHelper::validateWorkflowConfiguration();
                    }
                    catch (Exception::Error)
                    {
                        return;
                    }
                }

                List assignedResourcesList = Global::strSplit(_assignedResourcesRecId, ',');
                int listLength = ProjTask::getListLength(assignedResourcesList);
                
                // Only allow update rollup in async if size of the list is less than 3.
                boolean updateRollUpAsync = listLength < ResUtil::numberOfAsyncProcessAllow;

                utcdatetime startDateTime = DateTimeUtil::newDateTime(_startDate, 0);
                utcdatetime endDateTime = DatetimeUtil::newDateTime(_endDate, #LastSecondOfTheDay);

                int effortInSeconds = real2int(_effort * #SecondsPerHour);
                real capacity = System.Math::Floor(effortInSeconds / listLength);
                // Compute the difference caused by the rounding errors. This value is always less than listLength.
                real difference = effortInSeconds - capacity * listLength;
                ResIResourceManager resourceManager = ResResourceManager::construct();
                ResIReserveProcessor reserveProcessor = ResReserveProcessor::getProcessor(ResBookingType::DistributeCapacityEvenly);
                resourceManager.ReserveProcessor(reserveProcessor);

                ListEnumerator assignedResourcesListEnum = assignedResourcesList.getEnumerator();

                while (assignedResourcesListEnum.moveNext())
                {
                    utcdatetime systemDateTime = DateTimeUtil::getSystemDateTime();

                    // Distribute any difference caused by rounding errors among the resources.
                    real actualCapacity = difference > 0 ? capacity + 1 : capacity;
                    difference--;
                    resourceManager.Capacity(actualCapacity);

                    ResReservationSchedule resSchedule = ResReservationSchedule::construct();
                    resSchedule.ReservationType(ResReservationType::Assignment);

                    PSARSEntityType activityType = ActivityFacade::getActivityType(_activity);
                    ResCommitType commitment;
                    if (activityType == PSARSEntityType::Quotation)
                    {
                        commitment = ResCommitType::SoftBook;
                    }
                    else
                    {
                        commitment = ResCommitType::HardBook;
                    }
                    resSchedule.Commitment(commitment);

                    resSchedule.activity(_activity);
                    ResourceRecId resourceRecId = ActivityResourceFacade::getResource(assignedResourcesListEnum.current());
                    resSchedule.parmIsExistingTeamMember(true);
                    resSchedule.resource(resourceRecId);
                    resSchedule.activityResource(assignedResourcesListEnum.current());
                    resSchedule.start(startDateTime);
                    resSchedule.end(endDateTime);

                    // If resource workflow is enabled and the condition is right, then reservation process will not update
                    // <c>ResRollUp</c> table during reservation. This process will be done after resource request is submitted.
                    if (isWorkflowEnabled && commitment == ResCommitType::HardBook && resourceRecId != 0)
                    {
                        resSchedule.parmProcessRollUpByAssignmentRequest(true);
                    }

                    List schedulesList = new List(Types::Class);
                    schedulesList.addEnd(resSchedule);

                    // If the schedules contain soft reservation, request feedback from user if these reservation should be removed.
                    ResCancelSoftReservation cancelSoftReservation = ResCancelSoftReservation::construct(schedulesList);
                    if (cancelSoftReservation.hasSoftReservation() &&
                        (_skipResourceFeedback || cancelSoftReservation.getUserFeedBackOnSoftReservationCancelling()))
                    {
                        cancelSoftReservation.cancelSoftReservation(true);
                    }

                    // reserve the scheduling collection
                    resourceManager.Schedules(schedulesList);
                    resourceManager.Reserve(updateRollUpAsync);
                    
                    // If resource workflow is enabled, then reservation will be done in soft assignment first. By comparing with the existing
                    // hard booking records, the system will submit assignment records which does not have a backing up booking record in the same hour.
                    if (isWorkflowEnabled)
                    {
                        ResValidateAndSubmitAssignmentRequest resourceRequest =
                            ResValidateAndSubmitAssignmentRequest::construct(schedulesList, systemDateTime);
                        resourceRequest.validateAndSubmitRequest(_skipResourceFeedback);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelActivityAssignment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancel all assignments in the specified activity.
    /// </summary>
    /// <param name = "_activity">The specified activity record ID.</param>
    public static void cancelActivityAssignment(ActivityRecId _activity)
    {
        #TimeConstants

        ResReservationSchedule  resSchedule;
        ResCancelProcessor      cancelProcessor = ResCancelProcessor::getProcessor(ResCancelationType::EntireDay);
        ResIResourceManager     resourceManager = ResResourceManager::construct();
        List                    schedulesList = new List(Types::Class);

        if (_activity)
        {
            ResAssignment assignments;
            PSAProjSchedRole activityResources;

            select minof(Hour) from assignments
                group by assignments.Activity
                where assignments.Activity == _activity;
            utcdatetime start = DateTimeUtil::newDateTime(DateTimeUtil::date(assignments.Hour), 0);

            select maxof(Hour) from assignments
                group by assignments.Activity
                where assignments.Activity == _activity;
            utcdatetime end = DateTimeUtil::newDateTime(DateTimeUtil::date(assignments.Hour), #LastSecondOfTheDay);

            while select ActivityResource from assignments
                group by assignments.ActivityResource, activityResources.Resource
                where assignments.Activity == _activity
                join Resource from activityResources
                    where activityResources.RecId == assignments.ActivityResource
            {
                resSchedule = ResReservationSchedule::construct();
                resSchedule.activity(_activity);
                resSchedule.resource(activityResources.Resource);
                resSchedule.activityResource(assignments.ActivityResource);
                resSchedule.start(start);
                resSchedule.end(end);
                resSchedule.reservationType(ResReservationType::Assignment);
                resSchedule.commitment(ResCommitType::AnyType);
                schedulesList.addEnd(resSchedule);
            }

            cancelProcessor = ResCancelProcessor::getProcessor(ResCancelationType::EntireDay);
            resourceManager.CancelProcessor(cancelProcessor);
            resourceManager.Schedules(schedulesList);
            resourceManager.Cancel(true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePredecessors</Name>
				<Source><![CDATA[
    public static void updatePredecessors(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _task, List _predecessors)
    {
        ProjDependency projDependency;
        Enumerator     predEnumerator;

        ttsbegin;

        delete_from projDependency where
            projDependency.SuccessorHierarchyTaskId == _task
            && projDependency.ProjPlanHierarchyId == _hierarchyId;

        predEnumerator = _predecessors.getEnumerator();

        while (predEnumerator.moveNext())
        {
            projDependency.clear();
            projDependency.SuccessorHierarchyTaskId = _task;
            projDependency.PredecessorHierarchyTaskId = predEnumerator.current();
            projDependency.ProjPlanHierarchyId = _hierarchyId;
            projDependency.insert();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>callInsertUpdateRelatedSkipMethods</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calls the <c>skip</c> methods that are relevant when doing inserts or updates.
    /// </summary>
    /// <param name="_buffer">
    /// The buffer on which to call the methods.
    /// </param>
    private static void callInsertUpdateRelatedSkipMethods(Common _buffer)
    {
        _buffer.skipAosValidation(true);
        _buffer.skipDatabaseLog(true);
        _buffer.skipDataMethods(true);
        //needed in case of crossCompany
        _buffer.skipEvents(true);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>