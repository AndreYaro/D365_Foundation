<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BudgetControlConfigurationManager</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>BudgetControlConfigurationManager</c> class manages the budget control configurations
///    including the activation, editing, and validation of the budget control configuration and the
///    dependent data.
/// </summary>
public class BudgetControlConfigurationManager
{
    protected const UserId EmptyUserId = '';
    protected const UserGroupId EmptyUserGroupId = '';

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>activateConfiguration</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Activates the specified <c>BudgetControlConfiguration</c> record.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <returns>
    ///    true if the record was activated; otherwise, false.
    /// </returns>
    public static boolean activateConfiguration(BudgetControlConfigurationRecId _controlConfigurationRecId)
    {
        boolean activated;
        boolean isActiveConfigurationReplaced;
        boolean isUntrackedDraftRemovalRequired;
        Set     disabledSourceIntegratorsSet;

        BudgetControlConfiguration draftControlConfiguration = BudgetControlConfiguration::find(_controlConfigurationRecId);

        if (draftControlConfiguration
            && !draftControlConfiguration.IsActive
            && BudgetControlConfigurationManager::validateConfiguration(_controlConfigurationRecId))
        {
            if (BudgetControlSQLObjects::createAll())
            {
                if (BudgetControlConfigurationManager::isConfigurationEditPermitted(_controlConfigurationRecId))
                {
                    // Set the configuration to be in use by the current user to ensure no other activation or editing
                    // occurs during the current activation process.
                    BudgetControlConfigurationManager::setInUse(_controlConfigurationRecId);

                    ttsbegin;

                    draftControlConfiguration = BudgetControlConfiguration::find(_controlConfigurationRecId, true);
                    LedgerRecId primaryLedgerRecId = draftControlConfiguration.PrimaryLedger;

                    if (draftControlConfiguration)
                    {
                        // The draft configuration is valid.
                        // Clear the in use fields as part of the transaction scope committing the activated configuration.
                        draftControlConfiguration.InUseBy = EmptyUserId;
                        draftControlConfiguration.InUseSinceDateTime = utcDateTimeNull();

                        // Cleanup invalid user groups for the message levels before activation.
                        // Validation will not be performed to ensure the user groups are still valid
                        // as the user does not have the ability to remove the user group selection in this state.
                        BudgetControlUserGroupManager::cleanupForDeletedUserGroups();

                        // Get the active configuration to update.
                        BudgetControlConfiguration activeControlConfiguration;

                        select firstonly forupdate activeControlConfiguration
                            where activeControlConfiguration.PrimaryLedger == primaryLedgerRecId
                                && activeControlConfiguration.IsActive == NoYes::Yes;

                        if (activeControlConfiguration)
                        {
                            isActiveConfigurationReplaced = true;

                            // Get the disabled budget control source integrators before modifying any data.
                            disabledSourceIntegratorsSet = BudgetControlConfigurationManager::getSourceIntegratorsDisabled(
                                draftControlConfiguration.RecId,
                                activeControlConfiguration.RecId);

                            isUntrackedDraftRemovalRequired = BudgetControlTrackBFAOnlyFeature::isEnabled() && BudgetControlConfigurationManager::isBudgetFundsAvailableCalcChanged(draftControlConfiguration, activeControlConfiguration);

                            BudgetControlConfigChangeHistory::insertBudgetControlConfigurationChanges(activeControlConfiguration, draftControlConfiguration);

                            // Copy the draft configuration data.
                            buf2Buf(draftControlConfiguration, activeControlConfiguration);

                            // Remove the references to the active configuration.
                            BudgetControlConfigurationManager::removeConfigurationReferences(activeControlConfiguration.RecId);

                            // Move the references from the draft configuration to the active one.
                            BudgetControlConfigurationManager::moveConfigurationReferences(
                                draftControlConfiguration.RecId,
                                activeControlConfiguration.RecId);

                            // Remove the draft configuration.
                            draftControlConfiguration.delete();

                            // Update the active version to draft to reset the ModifiedBy and ModifiedDateTime
                            // in case the draft data did not change any other settings.
                            activeControlConfiguration.update();

                            // Set the configuration to active.
                            activeControlConfiguration.IsActive = NoYes::Yes;
                            activeControlConfiguration.update();
                        }
                        else
                        {
                            // Set the draft configuration to active.
                            draftControlConfiguration.IsActive = NoYes::Yes;
                            draftControlConfiguration.update();
                        }

                        // Get the new active configuration.
                        activeControlConfiguration.clear();
                        activeControlConfiguration = BudgetControlConfiguration::findActiveByPrimaryLedger(primaryLedgerRecId);

                        // Clear the configuration cache before creating budget group ledger dimensions to ensure the cache is reset.
                        BudgetControlConfigurationManager::clearConfigurationCache();

                        // Create the BudgetGroupLedgerDimension records for new active configuration.
                        BudgetControlConfigurationManager::createBudgetGroupLedgerDimensions(activeControlConfiguration.RecId);

                        // Create the BudgetControlRuleLedgerDimension records for new active configuration.
                        BudgetControlConfigurationManager::createBudgetControlRuleLedgerDimensions(activeControlConfiguration.RecId);

                        // Set the budget transaction source integrators that are always enabled.
                        BudgetControlConfigurationManager::setSourceIntegratorsAlwaysEnabled(activeControlConfiguration.RecId);

                        if (isActiveConfigurationReplaced)
                        {
                            // Remove the draft budget source tracking data for all disabled source integrators.
                            BudgetControlConfigurationManager::cleanupDraftBudgetTrackingForIntegrators(
                                primaryLedgerRecId,
                                disabledSourceIntegratorsSet);
                        }

                        if (isUntrackedDraftRemovalRequired)
                        {
                            // Remove amounts that do not affect budget funds available as these may incorrectly credit back funds.
                            BudgetControlProcessor::Instance().addLedgerToCleanupUntrackedDrafts(primaryLedgerRecId);
                        }

                        activated = true;
                    }

                    ttscommit;
                }
            }
            else
            {
                error("@SYS331201");
            }
        }

        return activated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupControlDimensionAttributes</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Removes the <c>BudgetControlDimensionAttribute</c> records and all of the budget control rule and
    ///    budget group records that are no longer valid for the specified budget control configuration and
    ///    account structure.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <param name="_accountStructureRecId">
    ///    The record ID of the <c>DimensionHierarchy</c> record.
    /// </param>
    /// <remarks>
    ///    A warning is provided to the user for each record that is removed and was referenced by a
    ///    <c>BudgetControlRule</c> record or a <c>BudgetGroupMember</c> record.
    /// </remarks>
    public static void cleanupControlDimensionAttributes(
        BudgetControlConfigurationRecId _controlConfigurationRecId,
        DimensionHierarchyId _accountStructureRecId)
    {
        if (_accountStructureRecId
            && BudgetControlConfigurationManager::isConfigurationEditPermitted(_controlConfigurationRecId))
        {
            ttsbegin;

            BudgetPrimaryLedgerDimensionAttribute budgetDimensionAttribute;
            BudgetControlDimensionAttribute controlDimensionAttribute;
            BudgetControlDimensionAttribute controlDimensionAttributeDelete;

            DimensionAttribute dimensionAttribute;
            DimensionHierarchyLevel dimensionHierarchyLevel;

            while select RecId, Name from dimensionAttribute
                order by Name
                join RecId from budgetDimensionAttribute
                    where budgetDimensionAttribute.DimensionAttribute == dimensionAttribute.RecId
                exists join controlDimensionAttribute
                    where controlDimensionAttribute.BudgetPrimaryLedgerDimensionAttribute == budgetDimensionAttribute.RecId &&
                        controlDimensionAttribute.BudgetControlConfiguration == _controlConfigurationRecId
                notexists join dimensionHierarchyLevel
                    where dimensionHierarchyLevel.DimensionAttribute == dimensionAttribute.RecId &&
                        dimensionHierarchyLevel.DimensionHierarchy == _accountStructureRecId
            {
                // Remove all the rules and groups for the dimension attribute.
                BudgetControlConfigurationManager::removeControlDimAttributeReferences(_controlConfigurationRecId, dimensionAttribute.RecId);

                controlDimensionAttributeDelete.skipDataMethods(true);
                controlDimensionAttributeDelete.skipDeleteActions(true);

                delete_from controlDimensionAttributeDelete
                    where controlDimensionAttributeDelete.BudgetControlConfiguration == _controlConfigurationRecId &&
                        controlDimensionAttributeDelete.BudgetPrimaryLedgerDimensionAttribute == budgetDimensionAttribute.RecId;
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupControlMainAccounts</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Removes the <c>BudgetControlMainAccount</c> records that are no longer valid for the specified
    ///    budget control configuration.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    public static void cleanupControlMainAccounts(BudgetControlConfigurationRecId _controlConfigurationRecId)
    {
        if (BudgetControlConfigurationManager::isConfigurationEditPermitted(_controlConfigurationRecId)
            && BudgetControlDimensionAttribute::isMainAccountInBudgetControlDimAttrbs(_controlConfigurationRecId))
        {
            // Remove all the reference of the budget control main account when
            // the main account dimension attribute is a control dimension attribute.
            ttsbegin;

            BudgetControlMainAccount controlMainAccount;
            controlMainAccount.skipDataMethods(true);
            controlMainAccount.skipDeleteActions(true);

            delete_from controlMainAccount
                where controlMainAccount.BudgetControlConfiguration == _controlConfigurationRecId;

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupDimAttributeNotExistReferences</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes the <c>BudgetControlRule</c> records and the <c>BudgetGroup</c> records that are no longer
    /// valid for the specified budget control configuration caused by no budget control dimension
    /// attributes being configured.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    /// The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    public static void cleanupDimAttributeNotExistReferences(BudgetControlConfigurationRecId _controlConfigurationRecId)
    {
        if (_controlConfigurationRecId
            && !BudgetControlDimensionAttribute::existByBudgetControlConfiguration(_controlConfigurationRecId))
        {
            ttsbegin;

            // Delete budget control rules when no control dimension attributes exist.
            // The budget control rule criterias get cascade deleted.
            BudgetControlRule budgetControlRule;

            delete_from budgetControlRule
                where budgetControlRule.BudgetControlConfiguration == _controlConfigurationRecId;

            // Delete budget groups when no control dimension attributes exist.
            // The budget group members and budget group members criterias get cascade deleted.
            BudgetGroup budgetGroup;

            delete_from budgetGroup
                where budgetGroup.BudgetControlConfiguration == _controlConfigurationRecId;

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupDraftBudgetTracking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes the draft budget source tracking data that is associated with the primary ledger.
    /// </summary>
    /// <param name="_primaryLedgerRecId">
    /// The record ID of the primary <c>Ledger</c> record.
    /// </param>
    private static void cleanupDraftBudgetTracking(LedgerRecId _primaryLedgerRecId)
    {
        if (_primaryLedgerRecId)
        {
            BudgetControlProcessor budgetControlProcessor = BudgetControlProcessor::Instance();
            budgetControlProcessor.addLedgerToCleanupDrafts(_primaryLedgerRecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupDraftBudgetTrackingForIntegrators</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Removes the draft budget source tracking data that is associated to a budget control source
    ///    integrator that is no longer enabled for budget control.
    /// </summary>
    /// <param name="_primaryLedgerRecId">
    ///    The record ID of the primary <c>Ledger</c> record.
    /// </param>
    /// <param name="_disabledSourceIntegratorsSet">
    ///    A container that contains the <c>Set</c> class of disabled budget control source integrators.
    /// </param>
    private static void cleanupDraftBudgetTrackingForIntegrators(LedgerRecId _primaryLedgerRecId, Set _disabledSourceIntegratorsSet)
    {
        if (_primaryLedgerRecId
            && _disabledSourceIntegratorsSet
            && _disabledSourceIntegratorsSet.elements() > 0)
        {
            BudgetControlProcessor budgetControlProcessor = BudgetControlProcessor::Instance();
            budgetControlProcessor.addLedgerToCleanupDrafts(_primaryLedgerRecId, _disabledSourceIntegratorsSet);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearConfigurationCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears the budget cache for the budget control configuration data.
    /// </summary>
    public static void clearConfigurationCache()
    {
        BudgetCache::clearScope(BudgetCacheScope::BudgetControlLedgerDimension);
        BudgetCache::clearScope(BudgetCacheScope::BudgetControlRuleByLedgerDimension);
        BudgetCache::clearScope(BudgetCacheScope::BudgetGroupByLedgerDimension);
        BudgetCache::clearScope(BudgetCacheScope::MainAccountInBudgetControlDimAttrbs);
        BudgetCache::clearScope(BudgetCacheScope::TopBudgetGroupMember);
        BudgetCache::clearScope(BudgetCacheScope::BudgetControlIsConfigured);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearInUse</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears the value of the <c>InUseBy</c> and <c>InUseSinceDateTime</c> fields of a budget control
    ///    configuration to indicate it is no longer being used.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    public static void clearInUse(BudgetControlConfigurationRecId _controlConfigurationRecId)
    {
        if (_controlConfigurationRecId)
        {
            ttsbegin;

            BudgetControlConfiguration draftControlConfiguration = BudgetControlConfiguration::find(_controlConfigurationRecId, true);

            if (draftControlConfiguration
                && !draftControlConfiguration.IsActive)
            {
                draftControlConfiguration.InUseBy = EmptyUserId;
                draftControlConfiguration.InUseSinceDateTime = utcDateTimeNull();
                draftControlConfiguration.doUpdate();
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>confirmBudgetFundsAvailableCalcChanged</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Confirms whether the budget funds available calculation change is allowed.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <returns>
    ///    true if the change is confirmed; otherwise, false.
    /// </returns>
    public static boolean confirmBudgetFundsAvailableCalcChanged(BudgetControlConfigurationRecId _controlConfigurationRecId)
    {
        boolean isUpdateConfirmed = true;

        BudgetControlConfiguration draftControlConfiguration = BudgetControlConfiguration::find(_controlConfigurationRecId);

        if (draftControlConfiguration
            && !draftControlConfiguration.IsActive)
        {
            BudgetControlConfiguration activeControlConfiguration = BudgetControlConfiguration::findActiveByPrimaryLedger(draftControlConfiguration.PrimaryLedger);

            if (activeControlConfiguration
                && activeControlConfiguration.budgetFundsAvailableCalculationText() != draftControlConfiguration.budgetFundsAvailableCalculationText())
            {
                // The draft configuration changed the budget funds available calculation.
                if (Box::yesNo("@SYS127910", DialogButton::Yes) == DialogButton::No)
                {
                    isUpdateConfirmed = false;
                }
            }
        }

        return isUpdateConfirmed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBudgetFundsAvailableCalcChanged</Name>
				<Source><![CDATA[
    private static boolean isBudgetFundsAvailableCalcChanged(BudgetControlConfiguration _draftControlConfiguration, BudgetControlConfiguration _activeControlConfiguration)
    {
        return _activeControlConfiguration
            && _draftControlConfiguration
            && _activeControlConfiguration.budgetFundsAvailableCalculationText() != _draftControlConfiguration.budgetFundsAvailableCalculationText();
    }

]]></Source>
			</Method>
			<Method>
				<Name>confirmSourceIntegratorDisabled</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Confirms whether the budget control source integrators can be disabled.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <returns>
    ///    true if the budget control source integrators can be disabled; otherwise, false.
    /// </returns>
    public static boolean confirmSourceIntegratorDisabled(BudgetControlConfigurationRecId _controlConfigurationRecId)
    {
        boolean isConfirmed = true;

        BudgetControlConfiguration draftControlConfiguration = BudgetControlConfiguration::find(_controlConfigurationRecId);

        if (draftControlConfiguration
            && !draftControlConfiguration.IsActive)
        {
            BudgetControlConfiguration activeControlConfiguration = BudgetControlConfiguration::findActiveByPrimaryLedger(draftControlConfiguration.PrimaryLedger);

            if (activeControlConfiguration)
            {
                BudgetControlSourceIntegratorEnabled draftControlSourceIntegratorEnabled;
                BudgetControlSourceIntegratorEnabled activeControlSourceIntegratorEnabled;

                select firstonly RecId from activeControlSourceIntegratorEnabled
                    where activeControlSourceIntegratorEnabled.BudgetControlConfiguration == activeControlConfiguration.RecId
                    notexists join draftControlSourceIntegratorEnabled
                        where draftControlSourceIntegratorEnabled.BudgetControlConfiguration == draftControlConfiguration.RecId &&
                            draftControlSourceIntegratorEnabled.BudgetControlSourceIntegrator == activeControlSourceIntegratorEnabled.BudgetControlSourceIntegrator;

                if (activeControlSourceIntegratorEnabled
                    && Box::yesNo("@SYS329429", DialogButton::Yes) == DialogButton::No)
                {
                    // A source integrator is being disabled and the change is not confirmed.
                    isConfirmed = false;
                }
            }
        }

        return isConfirmed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyConfigurationReferences</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Copies the dependent data references from the active configuration to the draft configuration.
    /// </summary>
    /// <param name="_draftControlConfigurationRecId">
    ///    The record ID of the draft <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <param name="_activeControlConfigurationRecId">
    ///    The record ID of the active <c>BudgetControlConfiguration</c> record.
    /// </param>
    private static void copyConfigurationReferences(
        BudgetControlConfigurationRecId _draftControlConfigurationRecId,
        BudgetControlConfigurationRecId _activeControlConfigurationRecId)
    {
        BudgetControlDimensionAttribute draftControlDimensionAttribute;
        BudgetControlDimensionAttribute activeControlDimensionAttribute;

        BudgetControlRule draftControlRule;
        BudgetControlRule activeControlRule;
        BudgetControlRuleCriteria draftControlRuleCriteria;
        BudgetControlRuleCriteria activeControlRuleCriteria;

        BudgetGroup draftGroup;
        BudgetGroup activeGroup;
        BudgetGroupMember draftGroupMember;
        BudgetGroupMember draftParentGroupMember;
        BudgetGroupMember activeGroupMember;
        BudgetGroupMemberCriteria draftGroupMemberCriteria;
        BudgetGroupMemberCriteria activeGroupMemberCriteria;

        BudgetOverrideUserGroupOption draftOverrideUserGroupOption;
        BudgetOverrideUserGroupOption activeOverrideUserGroupOption;
        BudgetControlRuleUserGroupOption draftControlRuleUserGroupOption;
        BudgetControlRuleUserGroupOption activeControlRuleUserGroupOption;
        BudgetGroupUserGroupOption draftGroupUserGroupOption;
        BudgetGroupUserGroupOption activeGroupUserGroupOption;

        BudgetControlMainAccount draftControlMainAccount;
        BudgetControlMainAccount activeControlMainAccount;

        BudgetControlBudgetCycle draftControlBudgetCycle;
        BudgetControlBudgetCycle activeControlBudgetCycle;

        BudgetControlSourceIntegratorEnabled draftControlSourceIntegratorEnabled;
        BudgetControlSourceIntegratorEnabled activeControlSourceIntegratorEnabled;

        BudgetControlUserGroupSuppressWarnings draftUserGroupSuppressWarnings;
        BudgetControlUserGroupSuppressWarnings activeUserGroupSuppressWarnings;

        if (BudgetControlConfiguration::exist(_draftControlConfigurationRecId)
            && BudgetControlConfiguration::exist(_activeControlConfigurationRecId))
        {
            ttsbegin;

            // Copy the BudgetControlDimensionAttribute table references.
            insert_recordset draftControlDimensionAttribute (Ordinal, BudgetPrimaryLedgerDimensionAttribute, BudgetControlConfiguration)
                select Ordinal, BudgetPrimaryLedgerDimensionAttribute, _draftControlConfigurationRecId from activeControlDimensionAttribute
                    where activeControlDimensionAttribute.BudgetControlConfiguration == _activeControlConfigurationRecId;

            // Copy the BudgetControlRule table references.
            insert_recordset draftControlRule (BudgetCycleTimeSpan, TemporaryBudgetControlRule, OverrideResponsibleUser, Name, Description, Interval, ThresholdPercent, BudgetControlConfiguration)
                select BudgetCycleTimeSpan, RecId, OverrideResponsibleUser, Name, Description, Interval, ThresholdPercent, _draftControlConfigurationRecId from activeControlRule
                    where activeControlRule.BudgetControlConfiguration == _activeControlConfigurationRecId;

            // Copy the BudgetControlRuleCriteria table references.
            insert_recordset draftControlRuleCriteria (WildCardString, RangeFrom, RangeTo, IsFromOpen, IsToOpen, BudgetControlDimensionAttribute, BudgetControlRule)
                select WildCardString, RangeFrom, RangeTo, IsFromOpen, IsToOpen from activeControlRuleCriteria
                    join RecId from draftControlDimensionAttribute
                        where draftControlDimensionAttribute.BudgetControlConfiguration == _draftControlConfigurationRecId
                    join RecId from draftControlRule
                        where draftControlRule.BudgetControlConfiguration == _draftControlConfigurationRecId
                            && draftControlRule.TemporaryBudgetControlRule == activeControlRuleCriteria.BudgetControlRule
                    exists join activeControlDimensionAttribute
                        where activeControlDimensionAttribute.RecId == activeControlRuleCriteria.BudgetControlDimensionAttribute
                            && activeControlDimensionAttribute.BudgetControlConfiguration == _activeControlConfigurationRecId
                            && activeControlDimensionAttribute.BudgetPrimaryLedgerDimensionAttribute == draftControlDimensionAttribute.BudgetPrimaryLedgerDimensionAttribute
                    exists join activeControlRule
                        where activeControlRule.BudgetControlConfiguration == _activeControlConfigurationRecId
                            && activeControlRule.RecId == activeControlRuleCriteria.BudgetControlRule;

            // Copy the BudgetGroup table references.
            insert_recordset draftGroup (BudgetCycleTimeSpan, OverrideResponsibleUser, TemporaryBudgetGroup, Interval, ThresholdPercent, Ordinal, BudgetControlConfiguration)
                select BudgetCycleTimeSpan, OverrideResponsibleUser, RecId, Interval, ThresholdPercent, Ordinal, _draftControlConfigurationRecId from activeGroup
                    where activeGroup.BudgetControlConfiguration == _activeControlConfigurationRecId;

            // Copy the BudgetGroupMember table references.
            insert_recordset draftGroupMember (TemporaryBudgetGroupMember, ParentBudgetGroupMember, Name, Description, BudgetGroup)
                select RecId, ParentBudgetGroupMember, Name, Description from activeGroupMember
                    join RecId from draftGroup
                        where draftGroup.BudgetControlConfiguration == _draftControlConfigurationRecId
                            && draftGroup.TemporaryBudgetGroup == activeGroupMember.BudgetGroup;

            // Update the BudgetGroupMember table ParentBudgetGroupMember values.
            update_recordset draftGroupMember
                setting ParentBudgetGroupMember = draftParentGroupMember.RecId
                    where draftGroupMember.ParentBudgetGroupMember != 0
                join RecId from draftParentGroupMember
                    where draftParentGroupMember.TemporaryBudgetGroupMember == draftGroupMember.ParentBudgetGroupMember
                exists join draftGroup
                    where draftGroup.RecId == draftGroupMember.BudgetGroup
                        && draftGroup.BudgetControlConfiguration == _draftControlConfigurationRecId;

            // Copy the BudgetGroupMemberCriteria table references.
            insert_recordset draftGroupMemberCriteria (WildCardString, RangeFrom, RangeTo, IsFromOpen, IsToOpen, BudgetControlDimensionAttribute, BudgetGroupMember)
                select WildCardString, RangeFrom, RangeTo, IsFromOpen, IsToOpen from activeGroupMemberCriteria
                    join RecId from draftControlDimensionAttribute
                        where draftControlDimensionAttribute.BudgetControlConfiguration == _draftControlConfigurationRecId
                    join RecId from draftGroupMember
                        where draftGroupMember.TemporaryBudgetGroupMember == activeGroupMemberCriteria.BudgetGroupMember
                    exists join draftGroup
                        where draftGroup.RecId == draftGroupMember.BudgetGroup
                            && draftGroup.BudgetControlConfiguration == _draftControlConfigurationRecId
                    exists join activeControlDimensionAttribute
                        where activeControlDimensionAttribute.RecId == activeGroupMemberCriteria.BudgetControlDimensionAttribute
                            && activeControlDimensionAttribute.BudgetControlConfiguration == _activeControlConfigurationRecId
                            && activeControlDimensionAttribute.BudgetPrimaryLedgerDimensionAttribute == draftControlDimensionAttribute.BudgetPrimaryLedgerDimensionAttribute
                    exists join activeGroupMember
                        where activeGroupMember.RecId == activeGroupMemberCriteria.BudgetGroupMember
                    exists join activeGroup
                        where activeGroup.RecId == activeGroupMember.BudgetGroup
                            && activeGroup.BudgetControlConfiguration == _activeControlConfigurationRecId;

            // Copy the BudgetOverrideUserGroupOption table references.
            insert_recordset draftOverrideUserGroupOption (UserGroupInfo, DefaultOverBudgetOption, BudgetControlConfiguration)
                select UserGroupInfo, DefaultOverBudgetOption, _draftControlConfigurationRecId from activeOverrideUserGroupOption
                    where activeOverrideUserGroupOption.BudgetControlConfiguration == _activeControlConfigurationRecId;

            // Copy the BudgetControlRuleUserGroupOption table references.
            insert_recordset draftControlRuleUserGroupOption (OverrideOverbudgetOption, OverbudgetBudgetGroupCheckOption, BudgetControlRule, BudgetOverrideUserGroupOption)
                select OverrideOverbudgetOption, OverbudgetBudgetGroupCheckOption from activeControlRuleUserGroupOption
                    join RecId from draftControlRule
                        where draftControlRule.BudgetControlConfiguration == _draftControlConfigurationRecId
                            && draftControlRule.TemporaryBudgetControlRule == activeControlRuleUserGroupOption.BudgetControlRule
                    join RecId from draftOverrideUserGroupOption
                        where draftOverrideUserGroupOption.BudgetControlConfiguration == _draftControlConfigurationRecId
                    exists join activeOverrideUserGroupOption
                        where activeOverrideUserGroupOption.BudgetControlConfiguration == _activeControlConfigurationRecId
                            && activeOverrideUserGroupOption.RecId == activeControlRuleUserGroupOption.BudgetOverrideUserGroupOption
                            && activeOverrideUserGroupOption.UserGroupInfo == draftOverrideUserGroupOption.UserGroupInfo;

            // Copy the BudgetGroupUserGroupInfo table references.
            insert_recordset draftGroupUserGroupOption (OverrideOverbudgetOption, BudgetGroup, BudgetOverrideUserGroupOption)
                select OverrideOverbudgetOption from activeGroupUserGroupOption
                    join RecId from draftGroup
                        where draftGroup.BudgetControlConfiguration == _draftControlConfigurationRecId
                            && draftGroup.TemporaryBudgetGroup == activeGroupUserGroupOption.BudgetGroup
                    join RecId from draftOverrideUserGroupOption
                        where draftOverrideUserGroupOption.BudgetControlConfiguration == _draftControlConfigurationRecId
                    exists join activeOverrideUserGroupOption
                        where activeOverrideUserGroupOption.BudgetControlConfiguration == _activeControlConfigurationRecId
                            && activeOverrideUserGroupOption.RecId == activeGroupUserGroupOption.BudgetOverrideUserGroupOption
                            && activeOverrideUserGroupOption.UserGroupInfo == draftOverrideUserGroupOption.UserGroupInfo;

            // Remove the TemporaryBudgetControlRule value from the BudgetControlRule table.
            update_recordset draftControlRule
                setting TemporaryBudgetControlRule = 0
                where draftControlRule.BudgetControlConfiguration == _draftControlConfigurationRecId;

            // Remove the TemporaryBudgetGroup value from the BudgetGroup table.
            update_recordset draftGroup
                setting TemporaryBudgetGroup = 0
                where draftGroup.BudgetControlConfiguration == _draftControlConfigurationRecId;

            // Remove the TemporaryBudgetGroupMember value from the BudgetGroupMember table.
            update_recordset draftGroupMember
                setting TemporaryBudgetGroupMember = 0
                exists join draftGroup
                    where draftGroup.RecId == draftGroupMember.BudgetGroup
                        && draftGroup.BudgetControlConfiguration == _draftControlConfigurationRecId;

            // Copy the BudgetControlMainAccount table references.
            insert_recordset draftControlMainAccount (MainAccount, BudgetControlConfiguration)
                select MainAccount, _draftControlConfigurationRecId from activeControlMainAccount
                    where activeControlMainAccount.BudgetControlConfiguration == _activeControlConfigurationRecId;

            // Copy the BudgetControlBudgetCycle table references.
            insert_recordset draftControlBudgetCycle (BudgetCycle, BudgetModelType, BudgetModelId, BudgetModelSubModelId, BudgetModelDataAreaId, BudgetControlConfiguration)
                select BudgetCycle, BudgetModelType, BudgetModelId, BudgetModelSubModelId, BudgetModelDataAreaId, _draftControlConfigurationRecId from activeControlBudgetCycle
                    where activeControlBudgetCycle.BudgetControlConfiguration == _activeControlConfigurationRecId;

            // Copy the BudgetControlSourceIntegratorEnabled table references.
            insert_recordset draftControlSourceIntegratorEnabled (BudgetControlSourceIntegrator, DoBudgetCheckOnEntry, BudgetControlConfiguration, BudgetControlSourceIntegratorQuery)
                select BudgetControlSourceIntegrator, DoBudgetCheckOnEntry, _draftControlConfigurationRecId, BudgetControlSourceIntegratorQuery from activeControlSourceIntegratorEnabled
                    where activeControlSourceIntegratorEnabled.BudgetControlConfiguration == _activeControlConfigurationRecId;

            // Copy the BudgetControlUserGroupSuppressWarnings table references.
            insert_recordset draftUserGroupSuppressWarnings (UserGroupInfo, BudgetControlConfiguration)
                select UserGroupInfo, _draftControlConfigurationRecId from activeUserGroupSuppressWarnings
                    where activeUserGroupSuppressWarnings.BudgetControlConfiguration == _activeControlConfigurationRecId;

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBudgetControlRuleLedgerDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the <c>BudgetControlRuleLedgerDimension</c> records for the specified budget control configuration.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    public static void createBudgetControlRuleLedgerDimensions(BudgetControlConfigurationRecId _controlConfigurationRecId)
    {
        DimensionAttributeValueCombination controlLedgerDimension;
        BudgetControlConfiguration controlConfiguration;

        if (BudgetControlConfiguration::exist(_controlConfigurationRecId))
        {
            var logger = BudgetControlInstrumentationLogger::createLogger(classStr(BudgetControlConfigurationManager));
            int dimensionCount = 0;
            using (var activityContext = logger.activation().budgetControlRuleLedgerDimensions(_controlConfigurationRecId))
            {
                ttsbegin;

                while select RecId from controlLedgerDimension
                where controlLedgerDimension.LedgerDimensionType == LedgerDimensionType::BudgetControl
                join PrimaryLedger from controlConfiguration
                    where controlConfiguration.RecId == _controlConfigurationRecId &&
                        controlConfiguration.DimensionHierarchyAccountStructure == controlLedgerDimension.AccountStructure
                {
                    BudgetControlLedgerDimensionHelper::createBudgetControlRuleLedgerDimensionForExistingDimension(
                    controlConfiguration.PrimaryLedger,
                    controlLedgerDimension.RecId);

                    dimensionCount++;
                }

                ttscommit;

                logger.logBucketizedCount(activityContext, dimensionCount);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBudgetGroupLedgerDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the <c>BudgetGroupLedgerDimension</c> records for the specified budget control
    ///    configuration.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> draft record.
    /// </param>
    internal static void createBudgetGroupLedgerDimensions(BudgetControlConfigurationRecId _controlConfigurationRecId)
    {
        if (BudgetControlConfiguration::exist(_controlConfigurationRecId))
        {
            var logger = BudgetControlInstrumentationLogger::createLogger(classStr(BudgetControlConfigurationManager));
            int dimensionCount = 0;
            using (var activityContext = logger.activation().budgetGroupLedgerDimensions(_controlConfigurationRecId))
            {
                ttsbegin;

                DimensionAttributeValueCombination controlLedgerDimension;
                BudgetControlConfiguration controlConfiguration;

                while select RecId from controlLedgerDimension
                where controlLedgerDimension.LedgerDimensionType == LedgerDimensionType::BudgetControl
                join PrimaryLedger from controlConfiguration
                    where controlConfiguration.RecId == _controlConfigurationRecId
                        && controlConfiguration.DimensionHierarchyAccountStructure == controlLedgerDimension.AccountStructure
                {
                    // The find of the budget group will create the BudgetGroupLedgerDimension record.
                    BudgetControlLedgerDimensionHelper::findBudgetGroupByMemberLedgerDimension(
                        controlConfiguration.PrimaryLedger,
                        controlLedgerDimension.RecId);

                    dimensionCount++;
                }

                ttscommit;

                logger.logBucketizedCount(activityContext, dimensionCount);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDraftConfiguration</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a <c>BudgetControlConfiguration</c> draft record for the specified primary ledger.
    /// </summary>
    /// <param name="_primaryLedgerRecId">
    ///    The record ID of the primary <c>Ledger</c> record.
    /// </param>
    /// <remarks>
    ///    A record is created only if a draft configuration does not already exist.If an active configuration
    ///    exists then the details of the active configuration are copied to the new draft configuration.
    /// </remarks>
    public static void createDraftConfiguration(LedgerRecId _primaryLedgerRecId)
    {
        if (!BudgetControlConfiguration::existDraftForPrimaryLedger(_primaryLedgerRecId))
        {
            ttsbegin;

            BudgetControlConfiguration activeControlConfiguration = BudgetControlConfiguration::findActiveByPrimaryLedger(_primaryLedgerRecId);
            BudgetControlConfiguration draftControlConfiguration;

            if (activeControlConfiguration)
            {
                // Copy the data from the active configuration.
                buf2Buf(activeControlConfiguration, draftControlConfiguration);
            }
            else
            {
                // No active configuration exists for the primary ledger.
                // Set the default values.
                draftControlConfiguration.initValue();
                draftControlConfiguration.PrimaryLedger = _primaryLedgerRecId;
            }

            draftControlConfiguration.IsActive = NoYes::No;
            draftControlConfiguration.insert();

            if (activeControlConfiguration && draftControlConfiguration)
            {
                // Copy the active configuration reference data.
                BudgetControlConfigurationManager::copyConfigurationReferences(
                    draftControlConfiguration.RecId,
                    activeControlConfiguration.RecId);
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>disableBudgetControl</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Disables budget control for the specified primary ledger.
    /// </summary>
    /// <param name="_primaryLedgerRecId">
    ///    The record ID of the primary <c>Ledger</c> record.
    /// </param>
    public static void disableBudgetControl(LedgerRecId _primaryLedgerRecId)
    {
        ttsbegin;

        Ledger ledger = Ledger::find(_primaryLedgerRecId, true);

        if (!ledger)
        {
            throw error(Error::wrongUseOfFunction(funcname()));
        }

        if (ledger.IsBudgetControlEnabled)
        {
            ledger.IsBudgetControlEnabled = NoYes::No;
            ledger.update();

            // Remove the draft budget source tracking data.
            BudgetControlConfigurationManager::cleanupDraftBudgetTracking(_primaryLedgerRecId);

            BudgetControlConfigChangeHistory::insertBudgetControlConfigStatusChange(false);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableBudgetControl</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Enables budget control for the specified primary ledger.
    /// </summary>
    /// <param name="_primaryLedgerRecId">
    ///    The record ID of the primary <c>Ledger</c> record.
    /// </param>
    /// <returns>
    ///    true if budget control was enabled; otherwise, false.
    /// </returns>
    public static boolean enableBudgetControl(LedgerRecId _primaryLedgerRecId)
    {
        boolean isValid = true;

        Ledger ledger = Ledger::find(_primaryLedgerRecId, true);

        if (!ledger)
        {
            throw error(Error::wrongUseOfFunction(funcname()));
        }

        CompanyInfo companyInfo = CompanyInfo::findRecId(ledger.PrimaryForLegalEntity);

        if (companyInfo.IsConsolidationCompany)
        {
            // Budget control is not allowed for the consolidated company.
            isValid = checkFailed(strFmt("@SYS343034", companyInfo.DataArea));
        }

        if (isValid && !ledger.IsBudgetControlEnabled)
        {
            if (!BudgetControlConfiguration::existActiveForPrimaryLedger(_primaryLedgerRecId))
            {
                isValid = checkFailed("@SYS315241");
            }

            isValid = BudgetControlConfigurationManager::validateCreateCompletedBudgetParameters() && isValid;
        }

        if (isValid)
        {
            ttsbegin;

            if (ledger && !ledger.IsBudgetControlEnabled)
            {
                ledger.IsBudgetControlEnabled = NoYes::Yes;
                ledger.update();
            }

            BudgetControlConfigChangeHistory::insertBudgetControlConfigStatusChange(true);

            ttscommit;
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findConfigurationCacheDisabled</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the specified record in the <c>BudgetControlConfiguration</c> table that have cache disabled.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record to find.
    /// </param>
    /// <returns>
    ///    A record in the <c>BudgetControlConfiguration</c> table; otherwise, an empty record.
    /// </returns>
    /// <remarks>
    ///    The <c>BudgetControlConfiguration</c> record must be found with cache disable to ensure the record
    ///    is not locked for editing by another client accessing a different AOS.If this is not done the
    ///    locked for editing check could return a cached result that differs from the database and could
    ///    cause data damage.This method should only be called by using the configuration locked for edit
    ///    checks.
    /// </remarks>
    private static BudgetControlConfiguration findConfigurationCacheDisabled(BudgetControlConfigurationRecId _controlConfigurationRecId)
    {
        BudgetControlConfiguration budgetControlConfiguration;

        budgetControlConfiguration.disableCache(true);

        select firstonly budgetControlConfiguration
            where budgetControlConfiguration.RecId == _controlConfigurationRecId;

        return budgetControlConfiguration;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDraftConfigurationRecIdCacheDisabled</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the <c>BudgetControlConfiguration</c> record ID for the specified primary ledger with cache
    ///    disabled.
    /// </summary>
    /// <param name="_primaryLedgerRecId">
    ///    The record ID of the primary <c>Ledger</c> record.
    /// </param>
    /// <returns>
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </returns>
    /// <remarks>
    ///    The <c>BudgetControlConfiguration</c> record must be found with cache disable to ensure the record
    ///    has not been restored or activated by another client accessing a different AOS.If this is not done,
    ///    the locked for editing check could return a cached result that differs from the database and could
    ///    cause data damage.This method should only be called by using the configuration locked for edit
    ///    checks.
    /// </remarks>
    public static BudgetControlConfigurationRecId getDraftConfigurationRecIdCacheDisabled(LedgerRecId _primaryLedgerRecId)
    {
        BudgetControlConfiguration budgetControlConfiguration;

        budgetControlConfiguration.disableCache(true);

        select firstonly RecId from budgetControlConfiguration
            where budgetControlConfiguration.PrimaryLedger == _primaryLedgerRecId
                && budgetControlConfiguration.IsActive == NoYes::No;

        return budgetControlConfiguration.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSourceIntegratorsDisabled</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the budget control source integrators that are disabled by the draft budget control
    ///    configuration.
    /// </summary>
    /// <param name="_draftControlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> draft record.
    /// </param>
    /// <param name="_activeControlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> active record.
    /// </param>
    /// <returns>
    ///    A container that contains the set of disabled budget control source integrators.
    /// </returns>
    private static Set getSourceIntegratorsDisabled(
        recId _draftControlConfigurationRecId,
        recId _activeControlConfigurationRecId)
    {
        Set disabledSourceIntegrators = new Set(Types::Enum);

        BudgetControlSourceIntegratorEnabled draftControlSourceIntegratorEnabled;
        BudgetControlSourceIntegratorEnabled activeControlSourceIntegratorEnabled;

        while select BudgetControlSourceIntegrator from activeControlSourceIntegratorEnabled
            where activeControlSourceIntegratorEnabled.BudgetControlConfiguration == _activeControlConfigurationRecId
            notexists join draftControlSourceIntegratorEnabled
                where draftControlSourceIntegratorEnabled.BudgetControlConfiguration == _draftControlConfigurationRecId
                    && draftControlSourceIntegratorEnabled.BudgetControlSourceIntegrator == activeControlSourceIntegratorEnabled.BudgetControlSourceIntegrator
        {
            disabledSourceIntegrators.add(activeControlSourceIntegratorEnabled.BudgetControlSourceIntegrator);
        }

        return disabledSourceIntegrators;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAccountStructureDimensionsInUse</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether any of the dimension attribute of the specified <c>DimensionHierarchy</c> record
    ///    ID is referenced by a budget control rule or a budget group member.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <param name="_accountStructureRecId">
    ///    The record ID of the <c>DimensionHierarchy</c> record.
    /// </param>
    /// <returns>
    ///    true if the dimension attribute is referenced; otherwise, false.
    /// </returns>
    public static boolean isAccountStructureDimensionsInUse(
        BudgetControlConfigurationRecId _controlConfigurationRecId,
        DimensionHierarchyId _accountStructureRecId)
    {
        BudgetPrimaryLedgerDimensionAttribute budgetDimensionAttribute;
        BudgetControlDimensionAttribute controlDimensionAttribute;

        DimensionAttribute dimensionAttribute;
        DimensionHierarchyLevel dimensionHierarchyLevel;

        boolean inUse = false;

        while select RecId, Name from dimensionAttribute
            order by Name
            join RecId from budgetDimensionAttribute
                where budgetDimensionAttribute.DimensionAttribute == dimensionAttribute.RecId
            exists join controlDimensionAttribute
                where controlDimensionAttribute.BudgetPrimaryLedgerDimensionAttribute == budgetDimensionAttribute.RecId
                    && controlDimensionAttribute.BudgetControlConfiguration == _controlConfigurationRecId
            notexists join dimensionHierarchyLevel
                where dimensionHierarchyLevel.DimensionAttribute == dimensionAttribute.RecId
                    && dimensionHierarchyLevel.DimensionHierarchy == _accountStructureRecId
        {
            if (BudgetControlConfigurationManager::isDimensionAttributeInUse(_controlConfigurationRecId, dimensionAttribute.RecId))
            {
                inUse = true;
                break;
            }
        }

        return inUse;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isConfigurationEditPermitted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the edit of the budget control configuration is permitted.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <returns>
    ///    true if the edit of the budget control configuration is permitted; otherwise, false.
    /// </returns>
    public static boolean isConfigurationEditPermitted(BudgetControlConfigurationRecId _controlConfigurationRecId)
    {
        boolean isUserPermittedToEdit;

        if (_controlConfigurationRecId)
        {
            // Find the configuration with cache disabled to ensure the latest in use information is read from the database.
            BudgetControlConfiguration controlConfiguration = BudgetControlConfigurationManager::findConfigurationCacheDisabled(_controlConfigurationRecId);

            if (controlConfiguration
                && !controlConfiguration.IsActive
                && (controlConfiguration.InUseBy == EmptyUserId || controlConfiguration.InUseBy == curuserid()))
            {
                isUserPermittedToEdit = true;
            }
        }

        return isUserPermittedToEdit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDimensionAttributeInUse</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the specified dimension attribute is referenced by a budget control rule or a
    ///    budget group member.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <param name="_dimensionAttributeRecId">
    ///    The record ID of the <c>DimensionAttribute</c> record.
    /// </param>
    /// <returns>
    ///    true if the dimension attribute is referenced; otherwise, false.
    /// </returns>
    public static boolean isDimensionAttributeInUse(BudgetControlConfigurationRecId _controlConfigurationRecId, recId _dimensionAttributeRecId)
    {
        boolean isInUse = false;

        BudgetPrimaryLedgerDimensionAttribute budgetDimensionAttribute;
        BudgetControlDimensionAttribute controlDimensionAttribute;

        BudgetControlRule controlRule;
        BudgetControlRuleCriteria controlRuleCriteria;

        // Check if the dimension attribute is referenced by a control rule.
        select firstonly RecId from controlRuleCriteria
            exists join controlRule
                where controlRule.RecId == controlRuleCriteria.BudgetControlRule
                    && controlRule.BudgetControlConfiguration == _controlConfigurationRecId
            exists join controlDimensionAttribute
                where controlDimensionAttribute.RecId == controlRuleCriteria.BudgetControlDimensionAttribute
            exists join budgetDimensionAttribute
                where budgetDimensionAttribute.RecId == controlDimensionAttribute.BudgetPrimaryLedgerDimensionAttribute
                    && budgetDimensionAttribute.DimensionAttribute == _dimensionAttributeRecId;

        if (controlRuleCriteria)
        {
            isInUse = true;
        }

        if (!isInUse)
        {
            BudgetGroup budgetGroup;
            BudgetGroupMember groupMember;
            BudgetGroupMemberCriteria groupMemberCriteria;

            // Check if the dimension attribute is referenced by a group member.
            select firstonly RecId from groupMemberCriteria
                exists join groupMember
                    where groupMember.RecId == groupMemberCriteria.BudgetGroupMember
                exists join budgetGroup
                    where budgetGroup.RecId == groupMember.BudgetGroup
                        && budgetGroup.BudgetControlConfiguration == _controlConfigurationRecId
                exists join controlDimensionAttribute
                    where controlDimensionAttribute.RecId == groupMemberCriteria.BudgetControlDimensionAttribute
                exists join budgetDimensionAttribute
                    where budgetDimensionAttribute.RecId == controlDimensionAttribute.BudgetPrimaryLedgerDimensionAttribute
                        && budgetDimensionAttribute.DimensionAttribute == _dimensionAttributeRecId;

            if (groupMemberCriteria)
            {
                isInUse = true;
            }
        }

        return isInUse;
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveConfigurationReferences</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Moves the dependent data references from the draft configuration to the active configuration.
    /// </summary>
    /// <param name="_draftControlConfigurationRecId">
    ///    The record ID of the draft <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <param name="_activeControlConfigurationRecId">
    ///    The record ID of the active <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <remarks>
    ///    The active configuration is expected to have the existing dependent data removed before this method
    ///    is called.
    /// </remarks>
    private static void moveConfigurationReferences(
        BudgetControlConfigurationRecId _draftControlConfigurationRecId,
        BudgetControlConfigurationRecId _activeControlConfigurationRecId)
    {
        if (BudgetControlConfiguration::exist(_draftControlConfigurationRecId) &&
            BudgetControlConfiguration::exist(_activeControlConfigurationRecId))
        {
            ttsbegin;

            // Update the BudgetOverrideUserGroupOption table references.
            BudgetOverrideUserGroupOption defaultUserGroupOption;

            update_recordset defaultUserGroupOption
                setting BudgetControlConfiguration = _activeControlConfigurationRecId
                where defaultUserGroupOption.BudgetControlConfiguration == _draftControlConfigurationRecId;

            // Update the BudgetControlRule table references.
            BudgetControlRule controlRule;

            update_recordset controlRule
                setting BudgetControlConfiguration = _activeControlConfigurationRecId
                where controlRule.BudgetControlConfiguration == _draftControlConfigurationRecId;

            // Update the BudgetGroup table references.
            BudgetGroup budgetGroup;

            update_recordset budgetGroup
                setting BudgetControlConfiguration = _activeControlConfigurationRecId
                where budgetGroup.BudgetControlConfiguration == _draftControlConfigurationRecId;

            // Update the BudgetControlDimensionAttribute table references.
            BudgetControlDimensionAttribute controlDimensionAttribute;

            update_recordset controlDimensionAttribute
                setting BudgetControlConfiguration = _activeControlConfigurationRecId
                where controlDimensionAttribute.BudgetControlConfiguration == _draftControlConfigurationRecId;

            // Cleanup the BudgetControlMainAccount table before moving the references.
            BudgetControlConfigurationManager::cleanupControlMainAccounts(_draftControlConfigurationRecId);

            // Update the BudgetControlMainAccount table references.
            BudgetControlMainAccount controlMainAccount;

            update_recordset controlMainAccount
                setting BudgetControlConfiguration = _activeControlConfigurationRecId
                where controlMainAccount.BudgetControlConfiguration == _draftControlConfigurationRecId;

            // Update the BudgetControlBudgetCycle table references.
            BudgetControlBudgetCycle controlBudgetCycle;

            update_recordset controlBudgetCycle
                setting BudgetControlConfiguration = _activeControlConfigurationRecId
                where controlBudgetCycle.BudgetControlConfiguration == _draftControlConfigurationRecId;

            // Update the BudgetControlSourceIntegratorEnabled table references.
            BudgetControlSourceIntegratorEnabled controlSourceIntegratorEnabled;

            update_recordset controlSourceIntegratorEnabled
                setting BudgetControlConfiguration = _activeControlConfigurationRecId
                where controlSourceIntegratorEnabled.BudgetControlConfiguration == _draftControlConfigurationRecId;

            // Update the BudgetControlUserGroupSuppressWarnings table references.
            BudgetControlUserGroupSuppressWarnings controlUserGroupSuppressWarnings;

            update_recordset controlUserGroupSuppressWarnings
                setting BudgetControlConfiguration = _activeControlConfigurationRecId
                where controlUserGroupSuppressWarnings.BudgetControlConfiguration == _draftControlConfigurationRecId;

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeConfigurationReferences</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the dependent data records for the specified budget control configuration.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    private static void removeConfigurationReferences(BudgetControlConfigurationRecId _controlConfigurationRecId)
    {
        if (BudgetControlConfiguration::exist(_controlConfigurationRecId))
        {
            ttsbegin;

            // Remove the BudgetOverrideUserGroupOption table references.
            BudgetOverrideUserGroupOption defaultUserGroupOption;
            BudgetControlRuleUserGroupOption controlUserGroupOption;

            controlUserGroupOption.skipDataMethods(true);
            controlUserGroupOption.skipDeleteActions(true);

            delete_from controlUserGroupOption
                exists join defaultUserGroupOption
                    where defaultUserGroupOption.RecId == controlUserGroupOption.BudgetOverrideUserGroupOption
                        && defaultUserGroupOption.BudgetControlConfiguration == _controlConfigurationRecId;

            defaultUserGroupOption.skipDataMethods(true);
            defaultUserGroupOption.skipDeleteActions(true);

            delete_from defaultUserGroupOption
                where defaultUserGroupOption.BudgetControlConfiguration == _controlConfigurationRecId;

            // Remove the BudgetControlRule table references.
            BudgetControlRule controlRule;
            BudgetControlRuleCriteria controlRuleCriteria;
            BudgetControlRuleLedgerDimension controlRuleLedgerDimension;

            controlRuleCriteria.skipDataMethods(true);
            controlRuleCriteria.skipDeleteActions(true);

            controlRuleLedgerDimension.skipDataMethods(true);
            controlRuleLedgerDimension.skipDeleteActions(true);

            delete_from controlRuleLedgerDimension
                exists join controlRule
                    where controlRule.RecId == controlRuleLedgerDimension.BudgetControlRule &&
                        controlRule.BudgetControlConfiguration == _controlConfigurationRecId;

            delete_from controlRuleCriteria
                exists join controlRule
                    where controlRule.RecId == controlRuleCriteria.BudgetControlRule
                        && controlRule.BudgetControlConfiguration == _controlConfigurationRecId;

            controlRule.skipDataMethods(true);
            controlRule.skipDeleteActions(true);

            delete_from controlRule
                where controlRule.BudgetControlConfiguration == _controlConfigurationRecId;

            // Remove the BudgetGroup table references.
            BudgetGroup budgetGroup;
            BudgetGroupMember budgetGroupMember;
            BudgetGroupMemberCriteria budgetGroupMemberCriteria;

            budgetGroupMemberCriteria.skipDataMethods(true);
            budgetGroupMemberCriteria.skipDeleteActions(true);

            delete_from budgetGroupMemberCriteria
                exists join budgetGroupMember
                    where budgetGroupMember.RecId == budgetGroupMemberCriteria.BudgetGroupMember
                exists join budgetGroup
                    where budgetGroup.RecId == budgetGroupMember.BudgetGroup
                        && budgetGroup.BudgetControlConfiguration == _controlConfigurationRecId;

            budgetGroupMember.skipDataMethods(true);
            budgetGroupMember.skipDeleteActions(true);

            delete_from budgetGroupMember
                exists join budgetGroup
                    where budgetGroup.RecId == budgetGroupMember.BudgetGroup
                        && budgetGroup.BudgetControlConfiguration == _controlConfigurationRecId;

            BudgetGroupLedgerDimension budgetGroupLedgerDimension;

            budgetGroupLedgerDimension.skipDataMethods(true);
            budgetGroupLedgerDimension.skipDeleteActions(true);

            delete_from budgetGroupLedgerDimension
                exists join budgetGroup
                    where budgetGroup.RecId == budgetGroupLedgerDimension.BudgetGroup
                        && budgetGroup.BudgetControlConfiguration == _controlConfigurationRecId;

            budgetGroup.skipDataMethods(true);
            budgetGroup.skipDeleteActions(true);

            delete_from budgetGroup
                where budgetGroup.BudgetControlConfiguration == _controlConfigurationRecId;

            // Remove the BudgetControlDimensionAttribute table references.
            BudgetControlDimensionAttribute controlDimensionAttribute;

            controlDimensionAttribute.skipDataMethods(true);
            controlDimensionAttribute.skipDeleteActions(true);

            delete_from controlDimensionAttribute
                where controlDimensionAttribute.BudgetControlConfiguration == _controlConfigurationRecId;

            // Remove the BudgetControlMainAccount table references.
            BudgetControlMainAccount controlMainAccount;

            controlMainAccount.skipDataMethods(true);
            controlMainAccount.skipDeleteActions(true);

            delete_from controlMainAccount
                where controlMainAccount.BudgetControlConfiguration == _controlConfigurationRecId;

            // Remove the BudgetControlBudgetCycle table references.
            BudgetControlBudgetCycle controlBudgetCycle;

            controlBudgetCycle.skipDataMethods(true);
            controlBudgetCycle.skipDeleteActions(true);

            delete_from controlBudgetCycle
                where controlBudgetCycle.BudgetControlConfiguration == _controlConfigurationRecId;

            // Remove the BudgetControlSourceIntegratorEnabled table references.
            BudgetControlSourceIntegratorEnabled controlSourceIntegratorEnabled;

            controlSourceIntegratorEnabled.skipDataMethods(true);
            controlSourceIntegratorEnabled.skipDeleteActions(true);

            delete_from controlSourceIntegratorEnabled
                where controlSourceIntegratorEnabled.BudgetControlConfiguration == _controlConfigurationRecId;

            // Remove the BudgetControlUserGroupSuppressWarnings table references.
            BudgetControlUserGroupSuppressWarnings controlUserGroupSuppressWarnings;

            controlUserGroupSuppressWarnings.skipDataMethods(true);
            controlUserGroupSuppressWarnings.skipDeleteActions(true);

            delete_from controlUserGroupSuppressWarnings
                where controlUserGroupSuppressWarnings.BudgetControlConfiguration == _controlConfigurationRecId;

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeControlDimAttributeReferences</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the budget control rule and group records for the specified budget control configuration
    ///    and the dimension attribute.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <param name="_dimensionAttributeRecId">
    ///    The record ID of the <c>DimensionAttribute</c> record.
    /// </param>
    public static void removeControlDimAttributeReferences(BudgetControlConfigurationRecId _controlConfigurationRecId, DimensionAttributeRecId _dimensionAttributeRecId)
    {
        ttsbegin;

        BudgetControlConfigurationManager::removeDimensionAttributeRuleReferences(_controlConfigurationRecId, _dimensionAttributeRecId);
        BudgetControlConfigurationManager::removeDimensionAttributeGroupReferences(_controlConfigurationRecId, _dimensionAttributeRecId);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeDimensionAttributeGroupReferences</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the budget group records for the specified budget control configuration and the dimension
    ///    attribute.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <param name="_dimensionAttributeRecId">
    ///    The record ID of the <c>DimensionAttribute</c> record.
    /// </param>
    public static void removeDimensionAttributeGroupReferences(BudgetControlConfigurationRecId _controlConfigurationRecId, DimensionAttributeRecId _dimensionAttributeRecId)
    {
        BudgetGroup budgetGroup;
        BudgetGroupMember budgetGroupMember;
        BudgetControlDimensionAttribute controlDimensionAttribute;
        BudgetGroupMemberCriteria budgetGroupMemberCriteria;
        BudgetPrimaryLedgerDimensionAttribute   budgetDimensionAttribute;

        // Delete budget groups referenced by the dimension attribute.
        select firstonly RecId from budgetGroupMember
                order by ParentBudgetGroupMember asc
            exists join budgetGroup
                where budgetGroup.BudgetControlConfiguration == _controlConfigurationRecId
                    && budgetGroupMember.BudgetGroup == budgetGroup.RecId
            exists join budgetGroupMemberCriteria
                where budgetGroupMemberCriteria.BudgetGroupMember == budgetGroupMember.RecId
            exists join controlDimensionAttribute
                where controlDimensionAttribute.RecId == budgetGroupMemberCriteria.BudgetControlDimensionAttribute
            exists join budgetDimensionAttribute
                where budgetDimensionAttribute.RecId == controlDimensionAttribute.BudgetPrimaryLedgerDimensionAttribute
                    && budgetDimensionAttribute.DimensionAttribute == _dimensionAttributeRecId;

        if (budgetGroupMember)
        {
            BudgetControlGroupManager::deleteBudgetGroupMember(budgetGroupMember.RecId);

            // Check whether there are some more budget group member
            // which needs to be deleted by calling the method recursively.
            BudgetControlConfigurationManager::removeDimensionAttributeGroupReferences(_controlConfigurationRecId, _dimensionAttributeRecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeDimensionAttributeRuleReferences</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the budget control rule records for the specified budget control configuration and the
    ///    dimension attribute.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <param name="_dimensionAttributeRecId">
    ///    The record ID of the <c>DimensionAttribute</c> record.
    /// </param>
    public static void removeDimensionAttributeRuleReferences(BudgetControlConfigurationRecId _controlConfigurationRecId, DimensionAttributeRecId _dimensionAttributeRecId)
    {
        BudgetControlRule budgetControlRule;
        BudgetControlRuleCriteria budgetControlRuleCriteria;
        BudgetControlDimensionAttribute controlDimensionAttribute;
        BudgetPrimaryLedgerDimensionAttribute budgetDimensionAttribute;

        ttsbegin;

        // Delete budget control rules which has rule criteria for the dimension attribute.
        // The budget control rule criterias get cascade deleted.
        delete_from budgetControlRule
            where budgetControlRule.BudgetControlConfiguration == _controlConfigurationRecId
            exists join budgetControlRuleCriteria
                where budgetControlRuleCriteria.BudgetControlRule == budgetControlRule.RecId
            exists join controlDimensionAttribute
                where controlDimensionAttribute.RecId == budgetControlRuleCriteria.BudgetControlDimensionAttribute
            exists join budgetDimensionAttribute
                where budgetDimensionAttribute.RecId == controlDimensionAttribute.BudgetPrimaryLedgerDimensionAttribute
                    && budgetDimensionAttribute.DimensionAttribute == _dimensionAttributeRecId;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>restoreActiveConfiguration</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Restores the active budget control configuration for the specified primary ledger.
    /// </summary>
    /// <param name="_primaryLedgerRecId">
    ///    The record ID of the primary <c>Ledger</c> record.
    /// </param>
    /// <remarks>
    ///    This method will remove the draft budget control configuration.
    /// </remarks>
    public static void restoreActiveConfiguration(LedgerRecId _primaryLedgerRecId)
    {
        ttsbegin;

        // Get the draft record.
        BudgetControlConfiguration draftControlConfiguration = BudgetControlConfiguration::findDraftByPrimaryLedger(_primaryLedgerRecId, true);

        if (draftControlConfiguration)
        {
            // Remove the draft configuration references.
            BudgetControlConfigurationManager::removeConfigurationReferences(draftControlConfiguration.RecId);

            draftControlConfiguration.delete();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInUse</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the value of the <c>InUseBy</c> and <c>InUseSinceDateTime</c> fields of a budget control
    ///    configuration to indicate it is being used.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    public static void setInUse(BudgetControlConfigurationRecId _controlConfigurationRecId)
    {
        ttsbegin;

        BudgetControlConfiguration draftControlConfiguration = BudgetControlConfiguration::find(_controlConfigurationRecId, true);

        if (!draftControlConfiguration.IsActive)
        {
            // Set the configuration to in use by the current user.
            draftControlConfiguration.InUseBy = curuserid();
            draftControlConfiguration.InUseSinceDateTime = DateTimeUtil::utcNow();
            draftControlConfiguration.doUpdate();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSourceIntegratorDoBudgetCheckOnEntry</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets whether the specified budget control source integrator does a budget check on entry.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <param name="_sourceIntegrator">
    ///    The budget control source integrator for which to set the do check on entry state.
    /// </param>
    /// <param name="_doBudgetCheckOnEntry">
    ///    A Boolean value that indicates whether to do a budget check on entry.
    /// </param>
    /// <returns>
    ///    true if the set completed successfully; otherwise, false.
    /// </returns>
    public static boolean setSourceIntegratorDoBudgetCheckOnEntry(
        BudgetControlConfigurationRecId _controlConfigurationRecId,
        BudgetControlSourceIntegrator _sourceIntegrator,
        boolean _doBudgetCheckOnEntry)
    {
        boolean isSet;

        if (BudgetControlConfigurationManager::isConfigurationEditPermitted(_controlConfigurationRecId)
            && BudgetControlSourceIntegratorEnabled::isModifyDoBudgetCheckOnEntryAllowed(_sourceIntegrator))
        {
            ttsbegin;

            BudgetControlSourceIntegratorEnabled controlSourceIntegratorEnabled = BudgetControlSourceIntegratorEnabled::findByConfigurationSourceIntegrator(
                _controlConfigurationRecId,
                _sourceIntegrator,
                true);

            if (controlSourceIntegratorEnabled)
            {
                controlSourceIntegratorEnabled.DoBudgetCheckOnEntry = _doBudgetCheckOnEntry;
                controlSourceIntegratorEnabled.update();

                isSet = true;
            }

            ttscommit;
        }

        return isSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSourceIntegratorQuery</Name>
				<Source><![CDATA[
    internal static boolean setSourceIntegratorQuery(
        BudgetControlConfigurationRecId _controlConfigurationRecId,
        BudgetControlSourceIntegrator _sourceIntegrator,
        Query _query)
    {
        boolean isSet;

        if (BudgetControlConfigurationManager::isConfigurationEditPermitted(_controlConfigurationRecId))
        {
            ttsbegin;

            BudgetControlSourceIntegratorEnabled controlSourceIntegratorEnabled = BudgetControlSourceIntegratorEnabled::findByConfigurationSourceIntegrator(
                _controlConfigurationRecId,
                _sourceIntegrator,
                true);

            if (controlSourceIntegratorEnabled)
            {
                container packedQuery = conNull();
                if (_query)
                {
                    packedQuery = _query.pack();
                }

                controlSourceIntegratorEnabled.BudgetControlSourceIntegratorQuery = packedQuery;
                controlSourceIntegratorEnabled.update();

                isSet = true;
            }

            ttscommit;
        }

        return isSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSourceIntegratorEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets whether the specified budget control source integrator is enabled for budget control.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <param name="_sourceIntegrator">
    ///    The budget control source integrator for which to set the enabled state.
    /// </param>
    /// <param name="_isEnabled">
    ///    A Boolean value that specifies whether budget control is enabled.
    /// </param>
    /// <returns>
    ///    true if the set completed successfully; otherwise, false.
    /// </returns>
    public static boolean setSourceIntegratorEnabled(
        BudgetControlConfigurationRecId _controlConfigurationRecId,
        BudgetControlSourceIntegrator _sourceIntegrator,
        boolean _isEnabled)
    {
        boolean isSetValid = BudgetControlConfigurationManager::validateSourceIntegratorEnabled(
            _controlConfigurationRecId,
            _sourceIntegrator,
            _isEnabled);

        if (isSetValid)
        {
            if (BudgetControlConfigurationManager::isConfigurationEditPermitted(_controlConfigurationRecId))
            {
                BudgetControlSourceIntegratorEnabled controlSourceIntegratorEnabled;

                if (_isEnabled)
                {
                    if (!BudgetControlSourceIntegratorEnabled::existByConfigurationSourceIntegrator(_controlConfigurationRecId, _sourceIntegrator))
                    {
                        // Create the BudgetControlSourceIntegratorEnabled record to enable the source integrator for budget control.
                        controlSourceIntegratorEnabled.BudgetControlConfiguration = _controlConfigurationRecId;
                        controlSourceIntegratorEnabled.BudgetControlSourceIntegrator = _sourceIntegrator;
                        controlSourceIntegratorEnabled.DoBudgetCheckOnEntry = BudgetControlSourceIntegratorEnabled::getDefaultDoBudgetCheckOnEntry(_sourceIntegrator);
                        controlSourceIntegratorEnabled.insert();
                    }

                    Map requiredSourceIntegrators = BudgetControlSourceIntegratorEnabled::getRequiredSourceIntegrators(_sourceIntegrator);

                    if (requiredSourceIntegrators && requiredSourceIntegrators.elements() > 0)
                    {
                        MapEnumerator requiredSourceIntegratorsEnumerator = requiredSourceIntegrators.getEnumerator();

                        while (requiredSourceIntegratorsEnumerator.moveNext())
                        {
                            BudgetControlSourceIntegrator requiredIntegrator = requiredSourceIntegratorsEnumerator.currentKey();
                            NoYes requiredIntegratorDoCheckOnEntry = requiredSourceIntegratorsEnumerator.currentValue();
                            BudgetControlSourceIntegratorEnabled budgetControlSourceIntegratorEnabled = BudgetControlSourceIntegratorEnabled::findByConfigurationSourceIntegrator(_controlConfigurationRecId, requiredIntegrator, true);

                            if (budgetControlSourceIntegratorEnabled)
                            {
                                if (!budgetControlSourceIntegratorEnabled.DoBudgetCheckOnEntry
                                    && requiredIntegratorDoCheckOnEntry)
                                {
                                    ttsbegin;
                                    // The integrator being set requires budget check on entry to be set by default for the dependent integrators.
                                    budgetControlSourceIntegratorEnabled.DoBudgetCheckOnEntry = requiredIntegratorDoCheckOnEntry;
                                    budgetControlSourceIntegratorEnabled.update();
                                    ttscommit;
                                }
                            }
                            else
                            {
                                // Create the BudgetControlSourceIntegratorEnabled record to enable the source integrator for budget control.
                                controlSourceIntegratorEnabled.BudgetControlConfiguration = _controlConfigurationRecId;
                                controlSourceIntegratorEnabled.BudgetControlSourceIntegrator = requiredIntegrator;
                                controlSourceIntegratorEnabled.DoBudgetCheckOnEntry = requiredIntegratorDoCheckOnEntry;
                                controlSourceIntegratorEnabled.insert();
                            }
                        }
                    }
                }
                else
                {
                    controlSourceIntegratorEnabled.skipDataMethods(true);
                    controlSourceIntegratorEnabled.skipDeleteActions(true);

                    delete_from controlSourceIntegratorEnabled
                        where controlSourceIntegratorEnabled.BudgetControlConfiguration == _controlConfigurationRecId &&
                            controlSourceIntegratorEnabled.BudgetControlSourceIntegrator == _sourceIntegrator;
                }

                isSetValid = true;
            }
            else
            {
                isSetValid = false;
            }
        }

        return isSetValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSourceIntegratorsAlwaysEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the budget control source integrators that are always enabled for budget control.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    private static void setSourceIntegratorsAlwaysEnabled(BudgetControlConfigurationRecId _controlConfigurationRecId)
    {
        Set integratorsAlwaysEnabled = BudgetControlSourceIntegratorEnabled::getSourceIntegratorsAlwaysEnabled();

        if (integratorsAlwaysEnabled.elements() > 0
            && BudgetControlConfiguration::exist(_controlConfigurationRecId))
        {
            SetEnumerator integratorsAlwaysEnabledEnumerator = integratorsAlwaysEnabled.getEnumerator();

            while (integratorsAlwaysEnabledEnumerator.moveNext())
            {
                ttsbegin;

                BudgetControlSourceIntegrator integratorAlwaysEnabled = integratorsAlwaysEnabledEnumerator.current();
                BudgetControlSourceIntegratorEnabled controlSourceIntegratorEnabled = BudgetControlSourceIntegratorEnabled::findByConfigurationSourceIntegrator(
                    _controlConfigurationRecId,
                    integratorAlwaysEnabled,
                    true);

                if (!controlSourceIntegratorEnabled)
                {
                    // Create the BudgetControlSourceIntegratorEnabled record to enable the source integrator for budget control.
                    controlSourceIntegratorEnabled.BudgetControlConfiguration = _controlConfigurationRecId;
                    controlSourceIntegratorEnabled.BudgetControlSourceIntegrator = integratorAlwaysEnabled;
                    controlSourceIntegratorEnabled.DoBudgetCheckOnEntry = NoYes::Yes;
                    controlSourceIntegratorEnabled.insert();
                }
                else if (!controlSourceIntegratorEnabled.DoBudgetCheckOnEntry)
                {
                    // The BudgetControlSourceIntegratorEnabled record must do the budget check on entry.
                    controlSourceIntegratorEnabled.DoBudgetCheckOnEntry = NoYes::Yes;
                    controlSourceIntegratorEnabled.update();
                }

                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setUserGroupSuppressWarnings</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets whether the specified user group has budget control warning messages suppressed.
    /// </summary>
    /// <param name = "_controlConfigurationRecId">
    /// The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <param name = "_userGroupId">
    /// The <c>UserGroupId</c> of the <c>UserGroupInfo</c> record.
    /// </param>
    /// <param name = "_doSuppressWarnings">
    /// A Boolean value that specifies whether budget control messages should be suppressed for the user group.
    /// </param>
    /// <returns>
    /// true if the user group has budget control warning messages suppressed; otherwise, false.
    /// </returns>
    public static boolean setUserGroupSuppressWarnings(
        BudgetControlConfigurationRecId _controlConfigurationRecId,
        UserGroupId _userGroupId,
        NoYes _doSuppressWarnings)
    {
        BudgetControlUserGroupSuppressWarnings userGroupSuppressWarnings;
        boolean hasUserGroupSuppressWarnings = BudgetControlUserGroupSuppressWarnings::existByUserGroupAndConfiguration(_userGroupId, _controlConfigurationRecId);

        if (_doSuppressWarnings == NoYes::Yes && !hasUserGroupSuppressWarnings)
        {
            if (hasTableAccess(tablenum(BudgetControlUserGroupSuppressWarnings), AccessType::Add))
            {
                ttsbegin;

                userGroupSuppressWarnings.UserGroupInfo = _userGroupId;
                userGroupSuppressWarnings.BudgetControlConfiguration = _controlConfigurationRecId;
                userGroupSuppressWarnings.insert();

                ttscommit;

                hasUserGroupSuppressWarnings = NoYes::Yes;
            }
        }
        else if (_doSuppressWarnings == NoYes::No && hasUserGroupSuppressWarnings)
        {
            if (hasTableAccess(tablenum(BudgetControlUserGroupSuppressWarnings), AccessType::Delete))
            {
                ttsbegin;

                delete_from userGroupSuppressWarnings
                    where userGroupSuppressWarnings.UserGroupInfo == _userGroupId
                        && userGroupSuppressWarnings.BudgetControlConfiguration == _controlConfigurationRecId;

                ttscommit;

                hasUserGroupSuppressWarnings = NoYes::No;
            }
        }

        return hasUserGroupSuppressWarnings;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSourceIntegratorEnabledTmp</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets an instance of the <c>BudgetControlSourceIntegratorEnabledTmp</c> table containing the source integrator enablement for budget control.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <returns>
    ///    An instance of the <c>BudgetControlSourceIntegratorEnabledTmp</c> table containing the source integrator enablement for budget control.
    /// </returns>
    public static BudgetControlSourceIntegratorEnabledTmp getSourceIntegratorEnabledTmp(BudgetControlConfigurationRecId _controlConfigurationRecId)
    {
        BudgetControlSourceIntegratorEnabledTmp controlSourceIntegratorEnabledTmp;

        Set integratorsAllowed = BudgetControlConfigurationManager::getSourceIntegratorsAllowed();
        Enumerator integratorsAllowedEnumerator = integratorsAllowed.getEnumerator();

        while (integratorsAllowedEnumerator.moveNext())
        {
            BudgetControlSourceIntegrator sourceIntegrator = integratorsAllowedEnumerator.current();

            controlSourceIntegratorEnabledTmp.BudgetControlConfiguration = _controlConfigurationRecId;
            controlSourceIntegratorEnabledTmp.BudgetControlSourceIntegrator = sourceIntegrator;
            controlSourceIntegratorEnabledTmp.BudgetControlSourceIntegratorValue = enum2Str(sourceIntegrator);

            BudgetControlSourceIntegratorEnabled controlSourceIntegratorEnabled = BudgetControlSourceIntegratorEnabled::findByConfigurationSourceIntegrator(
                _controlConfigurationRecId,
                sourceIntegrator);

            if (controlSourceIntegratorEnabled)
            {
                controlSourceIntegratorEnabledTmp.IsEnabled = true;
                controlSourceIntegratorEnabledTmp.DoBudgetCheckOnEntry = controlSourceIntegratorEnabled.DoBudgetCheckOnEntry;

                NoYes isFiltered = controlSourceIntegratorEnabled.BudgetControlSourceIntegratorQuery != conNull() ? NoYes::Yes : NoYes::No;
                controlSourceIntegratorEnabledTmp.IsFiltered = enum2Str(isFiltered);
            }
            else
            {
                controlSourceIntegratorEnabledTmp.IsEnabled = false;
                controlSourceIntegratorEnabledTmp.DoBudgetCheckOnEntry = false;
                controlSourceIntegratorEnabledTmp.IsFiltered = enum2Str(NoYes::No);
            }

            controlSourceIntegratorEnabledTmp.insert();
        }

        return controlSourceIntegratorEnabledTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSourceIntegratorsAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a set containing the source integrators available for enablement for budget control.
    /// </summary>
    /// <returns>
    /// An instance of the <c>Set</c> class that contains the source integrators that are available for enablement for budget control.
    /// </returns>
    public static Set getSourceIntegratorsAllowed()
    {
        Set sourceIntegratorsAllowed = new Set(Types::Enum);

        Set integratorsAlwaysEnabled = BudgetControlSourceIntegratorEnabled::getSourceIntegratorsAlwaysEnabled();

        DictEnum sourceIntegrators = new DictEnum(enumnum(BudgetControlSourceIntegrator));
        int sourceIntegratorIndex;

        for (sourceIntegratorIndex = 0; sourceIntegratorIndex < sourceIntegrators.values(); sourceIntegratorIndex++)
        {
            BudgetControlSourceIntegrator sourceIntegrator = any2Enum(sourceIntegrators.index2Value(sourceIntegratorIndex));
            configurationKeyId sourceIntegratorConfigKeyId = sourceIntegrators.index2ConfigurationKey(sourceIntegratorIndex);

            boolean sourceIntegratorSetupAllowed = true;

            if (integratorsAlwaysEnabled.in(sourceIntegrator))
            {
                // Integrators that are always enabled are not allowed for setup.
                sourceIntegratorSetupAllowed = false;
            }
            else if (sourceIntegratorConfigKeyId
                && !isConfigurationkeyEnabled(sourceIntegratorConfigKeyId))
            {
                // Integrator configuration key is not enabled.
                sourceIntegratorSetupAllowed = false;
            }
            else if (sourceIntegrator == BudgetControlSourceIntegrator::PurchCommitment_PSN
                && !PublicSectorUtils::isFrenchRegulatoryEnabled())
            {
                // Only enable the commitment document if the French Regulatory features are enabled.
                sourceIntegratorSetupAllowed = false;
            }

            if (sourceIntegratorSetupAllowed)
            {
                container countryRegionCodes = sourceIntegrators.index2CountryRegionCodes(sourceIntegratorIndex);

                if (conLen(countryRegionCodes) > 0 && !SysCountryRegionCode::isLegalEntityInCountryRegion(countryRegionCodes))
                {
                    // The integrator country region codes are not configured for the legal entity.
                    sourceIntegratorSetupAllowed = false;
                }
            }

            if (sourceIntegratorSetupAllowed)
            {
                sourceIntegratorsAllowed.add(sourceIntegrator);
            }
        }

        return sourceIntegratorsAllowed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBudgetControlConfigDimHierarchy</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether the dimension hierarchy account structure associated with the <c>BudgetControlConfiguration</c> record
    ///     is still associated to the primary ledger.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///     The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <returns>
    ///     true if the dimension hierarchy account structure is associated to the primary ledger; otherwise, false.
    /// </returns>
    public static boolean validateBudgetControlConfigDimHierarchy(BudgetControlConfigurationRecId _controlConfigurationRecId)
    {
        boolean isValid = true;

        if (_controlConfigurationRecId)
        {
            BudgetControlConfiguration budgetControlConfiguration = budgetControlConfiguration::find(_controlConfigurationRecId);

            // Check whether the ledger has valid structure association.
            if (!LedgerStructure::findByLedgerStructure(budgetControlConfiguration.PrimaryLedger, budgetControlConfiguration.DimensionHierarchyAccountStructure))
            {
                error("@SYS335520");
                isValid = false;
            }
        }
        else
        {
            isValid = false;
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBudgetControlDimensionAttributes</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the <c>BudgetControlDimensionAttribute</c> records are valid for the specified
    ///    budget control configuration.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <returns>
    ///    true if the <c>BudgetControlDimensionAttribute</c> records are valid; otherwise, false.
    /// </returns>
    public static boolean validateBudgetControlDimensionAttributes(BudgetControlConfigurationRecId _controlConfigurationRecId)
    {
        boolean isValid = true;

        BudgetControlDimensionAttribute controlDimensionAttribute;

        select firstonly RecId from controlDimensionAttribute
            where controlDimensionAttribute.BudgetControlConfiguration == _controlConfigurationRecId;

        if (controlDimensionAttribute)
        {
            // Check whether the budget control dimensions are valid for activation.
            BudgetControlConfiguration budgetControlConfiguration = BudgetControlConfiguration::find(_controlConfigurationRecId);

            BudgetControlDimensionAttribute nonExistingBudgetControlDimensionAttribute;
            BudgetPrimaryLedgerDimensionAttribute budgetPrimaryLedgerDimensionAttribute;
            DimensionHierarchyLevel dimensionHierarchyLevel;

            select firstOnly RecId from nonExistingBudgetControlDimensionAttribute
                where nonExistingBudgetControlDimensionAttribute.BudgetControlConfiguration == _controlConfigurationRecId
                exists join DimensionAttribute from budgetPrimaryLedgerDimensionAttribute
                    where budgetPrimaryLedgerDimensionAttribute.RecId == nonExistingBudgetControlDimensionAttribute.BudgetPrimaryLedgerDimensionAttribute
                notExists join dimensionHierarchyLevel
                    where dimensionHierarchyLevel.DimensionHierarchy == budgetControlConfiguration.DimensionHierarchyAccountStructure
                        && dimensionHierarchyLevel.DimensionAttribute == budgetPrimaryLedgerDimensionAttribute.DimensionAttribute;

            if (nonExistingBudgetControlDimensionAttribute)
            {
                error(strFmt("@SYS335518", DimensionHierarchy::find(budgetControlConfiguration.DimensionHierarchyAccountStructure).Name));
                isValid = false;
            }
        }
        else
        {
            error("@SYS315245");
            isValid = false;
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBudgetControlRules</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the <c>BudgetControlRule</c> records are valid for the specified budget control
    ///    configuration.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <returns>
    ///    true if the <c>BudgetControlRule</c> records are valid; otherwise, false.
    /// </returns>
    public static boolean validateBudgetControlRules(BudgetControlConfigurationRecId _controlConfigurationRecId)
    {
        boolean isValid = true;

        BudgetControlRule budgetControlRule;

        select firstonly RecId from budgetControlRule
                where budgetControlRule.BudgetControlConfiguration == _controlConfigurationRecId;

        if (!budgetControlRule)
        {
            // At least one budget control rule must exist.
            error("@SYS321392");
            isValid = false;
        }

        var logger = BudgetControlInstrumentationLogger::createLogger(classStr(BudgetControlConfigurationManager));

        using (var activityContext = logger.activation().validateBudgetControlRules(_controlConfigurationRecId, true))
        {
            isValid = BudgetControlRuleValidation::validateBudgetControlRules(_controlConfigurationRecId) && isValid;
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBudgetCycleTimeSpan</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the <c>BudgetCycleTimeSpan</c> record is valid.
    /// </summary>
    /// <param name="_budgetCycleTimeSpanRecId">
    ///    The budget cycle time span record ID which must be validated.
    /// </param>
    /// <param name="_isInActivation">
    ///    A Boolean value which specifies that the validation occurs during configuration activation;
    ///    optional.
    /// </param>
    /// <returns>
    ///    true if the <c>BudgetCycleTimeSpan</c> record is valid; otherwise, false.
    /// </returns>
    public static boolean validateBudgetCycleTimeSpan(recId _budgetCycleTimeSpanRecId, boolean _isInActivation = false)
    {
        boolean isValid = true;

        if (_budgetCycleTimeSpanRecId)
        {
            str budgetCycleTimeSpanError;

            if (BudgetCycleTimeSpan::exist(_budgetCycleTimeSpanRecId))
            {
                if (!BudgetCycleTimeSpan::hasBudgetCycle(_budgetCycleTimeSpanRecId))
                {
                    budgetCycleTimeSpanError = strfmt("@SYS314440", BudgetCycleTimeSpan::find(_budgetCycleTimeSpanRecId).Name);

                    if (_isInActivation)
                    {
                        error(budgetCycleTimeSpanError);
                        isValid = false;
                    }
                    else
                    {
                        isValid = checkFailed(budgetCycleTimeSpanError);
                    }
                }
            }
            else
            {
                budgetCycleTimeSpanError = strfmt("@SYS342115", "@SYS342116");

                if (_isInActivation)
                {
                    error(budgetCycleTimeSpanError);
                    isValid = false;
                }
                else
                {
                    isValid = checkFailed(budgetCycleTimeSpanError);
                }
            }
        }
        // else, system level error message is shown if the field is mandatory.

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBudgetCycleTimeSpanReferences</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the <c>BudgetCycleTimeSpan</c> table references are valid for the specified
    ///    budget control configuration.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <returns>
    ///    true if the <c>BudgetCycleTimeSpan</c> references are valid; otherwise, false.
    /// </returns>
    public static boolean validateBudgetCycleTimeSpanReferences(BudgetControlConfigurationRecId _controlConfigurationRecId)
    {
        boolean isValid = true;

        BudgetCycle cycle;
        BudgetControlBudgetCycle controlBudgetCycle;
        BudgetModel cycleModel;

        date currentDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());

        BudgetControlConfiguration controlConfiguration = BudgetControlConfiguration::find(_controlConfigurationRecId);

        // Create the valid and invalid sets to avoid processing the same time span for multiple records.
        Set validBudgetCycleTimeSpans = new Set(Types::Int64);
        Set invalidBudgetCycleTimeSpans = new Set(Types::Int64);

        BudgetControlRule controlRule;

        while select BudgetCycleTimeSpan, Name from controlRule
            where controlRule.BudgetControlConfiguration == controlConfiguration.RecId
        {
            if (!validBudgetCycleTimeSpans.in(controlRule.BudgetCycleTimeSpan)
                && !invalidBudgetCycleTimeSpans.in(controlRule.BudgetCycleTimeSpan))
            {
                if (BudgetControlConfigurationManager::validateBudgetCycleTimeSpan(controlRule.BudgetCycleTimeSpan, true))
                {
                    // The BudgetCycleTimeSpan has not been processed and it has budget cycle.
                    // Find the cycle for the current date.
                    cycle = BudgetCycle::findBudgetCycleByDate(controlRule.BudgetCycleTimeSpan, currentDate);

                    // Set cycleModel variable to null so it will reset when changing companies over the loop
                    cycleModel = null;

                    if (cycle)
                    {
                        // Get the budget model associated with the budget cycle.
                        select firstonly cycleModel
                            exists join controlBudgetCycle
                                where controlBudgetCycle.BudgetModelId == cycleModel.ModelId
                                    && controlBudgetCycle.BudgetModelSubModelId == cycleModel.SubModelId
                                    && controlBudgetCycle.BudgetModelType == cycleModel.Type
                                    && controlBudgetCycle.BudgetModelDataAreaId == cycleModel.DataAreaId
                                    && controlBudgetCycle.BudgetControlConfiguration == controlConfiguration.RecId
                                    && controlBudgetCycle.BudgetCycle == cycle.RecId;

                        if (cycleModel)
                        {
                            // Add the BudgetCycleTimeSpan to the valid set.
                            validBudgetCycleTimeSpans.add(controlRule.BudgetCycleTimeSpan);
                        }
                        else
                        {
                            warning(strfmt("@SYS329663", BudgetCycleTimeSpan::find(controlRule.BudgetCycleTimeSpan).Name, cycle.Name));

                            // Add the BudgetCycleTimeSpan to the invalid set since there is no budget model association for current period.
                            invalidBudgetCycleTimeSpans.add(controlRule.BudgetCycleTimeSpan);
                        }
                    }
                    else
                    {
                        warning(strfmt("@SYS329664", BudgetCycleTimeSpan::find(controlRule.BudgetCycleTimeSpan).Name));

                        // Add the BudgetCycleTimeSpan to the invalid set since there is no cycle for current period.
                        invalidBudgetCycleTimeSpans.add(controlRule.BudgetCycleTimeSpan);
                    }
                }
                else
                {
                    // Add the BudgetCycleTimeSpan to the invalid set since there is no cycle at all.
                    invalidBudgetCycleTimeSpans.add(controlRule.BudgetCycleTimeSpan);

                    isValid = false;
                }
            }
        }

        BudgetGroup budgetGroup;

        while select BudgetCycleTimeSpan from budgetGroup
            where budgetGroup.BudgetControlConfiguration == controlConfiguration.RecId
        {
            if (!validBudgetCycleTimeSpans.in(budgetGroup.BudgetCycleTimeSpan)
                && !invalidBudgetCycleTimeSpans.in(budgetGroup.BudgetCycleTimeSpan))
            {
                if (BudgetControlConfigurationManager::validateBudgetCycleTimeSpan(budgetGroup.BudgetCycleTimeSpan, true))
                {
                    // The BudgetCycleTimeSpan has not been processed and it has budget cycle.
                    // Find the cycle for the current date.
                    cycle = BudgetCycle::findBudgetCycleByDate(budgetGroup.BudgetCycleTimeSpan, currentDate);

                    // Set cycleModel variable to null so it will reset when changing companies over the loop
                    cycleModel = null;

                    if (cycle)
                    {
                        // Get the budget model associated with the budget cycle.
                        select firstonly cycleModel
                            exists join controlBudgetCycle
                                where controlBudgetCycle.BudgetModelId == cycleModel.ModelId
                                    && controlBudgetCycle.BudgetModelSubModelId == cycleModel.SubModelId
                                    && controlBudgetCycle.BudgetModelType == cycleModel.Type
                                    && controlBudgetCycle.BudgetModelDataAreaId == cycleModel.DataAreaId
                                    && controlBudgetCycle.BudgetControlConfiguration == controlConfiguration.RecId
                                    && controlBudgetCycle.BudgetCycle == cycle.RecId;

                        if (cycleModel)
                        {
                            // Add the BudgetCycleTimeSpan to the valid set.
                            validBudgetCycleTimeSpans.add(budgetGroup.BudgetCycleTimeSpan);
                        }
                        else
                        {
                            warning(strfmt("@SYS329663", BudgetCycleTimeSpan::find(budgetGroup.BudgetCycleTimeSpan).Name, cycle.Name));

                            // Add the BudgetCycleTimeSpan to the invalid set since there is no budget model association for current period.
                            invalidBudgetCycleTimeSpans.add(budgetGroup.BudgetCycleTimeSpan);
                        }
                    }
                    else
                    {
                        warning(strfmt("@SYS329664", BudgetCycleTimeSpan::find(budgetGroup.BudgetCycleTimeSpan).Name));

                        // Add the BudgetCycleTimeSpan to the invalid set since there is no cycle for current period.
                        invalidBudgetCycleTimeSpans.add(budgetGroup.BudgetCycleTimeSpan);
                    }
                }
                else
                {
                    // Add the BudgetCycleTimeSpan to the invalid set since there is no cycle at all.
                    invalidBudgetCycleTimeSpans.add(budgetGroup.BudgetCycleTimeSpan);

                    isValid = false;
                }
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBudgetOverrideUserGroupOptions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the <c>BudgetOverrideUserGroupOption</c> records reference a valid user group
    ///    for the specified budget control configuration.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <returns>
    ///    true if the <c>BudgetOverrideUserGroupOption</c> records are valid; otherwise, false.
    /// </returns>
    public static boolean validateBudgetOverrideUserGroupOptions(BudgetControlConfigurationRecId _controlConfigurationRecId)
    {
        boolean isValid = true;

        BudgetOverrideUserGroupOption userGroupOption;
        UserGroupInfo userGroupInfo;

        while select UserGroupInfo from userGroupOption
            where userGroupOption.UserGroupInfo != EmptyUserGroupId
                && userGroupOption.BudgetControlConfiguration == _controlConfigurationRecId
            notexists join userGroupInfo
                where userGroupInfo.Id == userGroupOption.UserGroupInfo
        {
            error(strfmt("@SYS127911", userGroupOption.UserGroupInfo));
            isValid = false;
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateConfiguration</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the specified budget control configuration is valid.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <returns>
    ///    true if the configuration is valid; otherwise, false.
    /// </returns>
    public static boolean validateConfiguration(BudgetControlConfigurationRecId _controlConfigurationRecId)
    {
        boolean isValid = true;
        BudgetControlConfiguration controlConfiguration;

        controlConfiguration = BudgetControlConfiguration::find(_controlConfigurationRecId);

        if (controlConfiguration)
        {
            isValid = BudgetControlConfigurationManager::validateConfigurationEditPermitted(_controlConfigurationRecId);
            isValid = isValid && BudgetControlConfigurationManager::validateBudgetControlConfigDimHierarchy(_controlConfigurationRecId);
            isValid = isValid && BudgetControlConfigurationManager::validateBudgetControlDimensionAttributes(_controlConfigurationRecId);

            if (isValid)
            {
                isValid = BudgetControlConfigurationManager::validateBudgetControlRules(_controlConfigurationRecId) && isValid;

                isValid = BudgetControlConfigurationManager::validateBudgetGroupMembers(_controlConfigurationRecId) && isValid;

                isValid = BudgetControlConfigurationManager::validateBudgetCycleTimeSpanReferences(_controlConfigurationRecId) && isValid;

                isValid = BudgetControlConfigurationManager::validateResponsibleUsers(_controlConfigurationRecId) && isValid;

                isValid = BudgetControlConfigurationManager::validateBudgetOverrideUserGroupOptions(_controlConfigurationRecId) && isValid;
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateConfigurationEditPermitted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the edit of the budget control configuration is permitted.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <param name="_isInActivation">
    ///    A Boolean value that indicates whether the validation is in the activation process; optional.
    /// </param>
    /// <returns>
    ///    true if the edit of the budget control configuration is permitted; otherwise, false.
    /// </returns>
    public static boolean validateConfigurationEditPermitted(BudgetControlConfigurationRecId _controlConfigurationRecId, boolean _isInActivation = false)
    {
        boolean isValid = true;

        // Find the configuration with cache disabled to ensure the latest in use information is read from the database.
        BudgetControlConfiguration controlConfiguration = BudgetControlConfigurationManager::findConfigurationCacheDisabled(_controlConfigurationRecId);

        if (controlConfiguration)
        {
            if (controlConfiguration.IsActive)
            {
                if (_isInActivation)
                {
                    error("@SYS329732");
                    isValid = false;
                }
                else
                {
                    isValid = checkFailed("@SYS329732");
                }
            }
            else if (!BudgetControlConfigurationManager::isConfigurationEditPermitted(_controlConfigurationRecId))
            {
                LabelString configurationInUseError = strfmt("@SYS329733", controlConfiguration.InUseBy);

                if (_isInActivation)
                {
                    error(configurationInUseError);
                    isValid = false;
                }
                else
                {
                    isValid = checkFailed(configurationInUseError);
                }
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCreateCompletedBudgetParameters</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether any create completed budget transactions are enabled in the
    ///    <c>BudgetParameters</c> table when a budget is transferred from group fields.
    /// </summary>
    /// <returns>
    ///    true if no create completed fields are enabled; otherwise, false.
    /// </returns>
    public static boolean validateCreateCompletedBudgetParameters()
    {
        boolean isValid = true;
        BudgetParameters budgetParameters = BudgetParameters::find(false);

        if (budgetParameters.isBudgetTransCreateAsCompletedEnabled())
        {
            isValid = checkFailed(strfmt("@SYS340057", "@SYS327515"));
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateResponsibleUserReference</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the <c>BudgetResponsibleUser</c> value is valid.
    /// </summary>
    /// <param name="_responsibleUser">
    ///    The <c>BudgetResponsibleUser</c> value which must be validated.
    /// </param>
    /// <returns>
    ///    true if the <c>BudgetResponsibleUser</c> value is valid; otherwise, false.
    /// </returns>
    public static boolean validateResponsibleUserReference(BudgetResponsibleUser _responsibleUser)
    {
        boolean isValid = true;

        if (BudgetResponsibleUserManager::existResponsibleUser_User(_responsibleUser) == false)
        {
            isValid = checkFailed(strfmt("@SYS135006", _responsibleUser));
        }

        if (isValid && BudgetResponsibleUserManager::existResponsibleUser_Empl(_responsibleUser) == false)
        {
            isValid = checkFailed(strfmt("@SYS135008", _responsibleUser));
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateResponsibleUsers</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the budget responsible user references are valid for the specified budget
    ///    control configuration.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <returns>
    ///    true if the budget responsible user references are valid; otherwise, false.
    /// </returns>
    public static boolean validateResponsibleUsers(BudgetControlConfigurationRecId _controlConfigurationRecId)
    {
        boolean isValid = true;

        BudgetControlConfiguration controlConfiguration;

        while select DefaultResponsibleUser from controlConfiguration
            where controlConfiguration.DefaultResponsibleUser != EmptyUserId
                && controlConfiguration.RecId == _controlConfigurationRecId
        {
            isValid = BudgetControlConfigurationManager::validateResponsibleUserReference(controlConfiguration.DefaultResponsibleUser) && isValid;
        }

        BudgetControlRule controlRule;

        while select OverrideResponsibleUser from controlRule
            where controlRule.OverrideResponsibleUser != EmptyUserId
                && controlRule.BudgetControlConfiguration == _controlConfigurationRecId
        {
            isValid = BudgetControlConfigurationManager::validateResponsibleUserReference(controlRule.OverrideResponsibleUser) && isValid;
        }

        BudgetGroup budgetGroup;

        while select OverrideResponsibleUser from budgetGroup
            where budgetGroup.OverrideResponsibleUser != EmptyUserId
                && budgetGroup.BudgetControlConfiguration == _controlConfigurationRecId
        {
            isValid = BudgetControlConfigurationManager::validateResponsibleUserReference(budgetGroup.OverrideResponsibleUser) && isValid;
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSourceIntegratorEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the set operation for the <c>BudgetControlSourceIntegratorEnabled</c> record.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <param name="_sourceIntegrator">
    ///    The budget control source integrator for which to set the enabled state.
    /// </param>
    /// <param name="_isEnabled">
    ///    A Boolean value that specifies whether budget control is enabled.
    /// </param>
    /// <returns>
    ///    true if the set operation is valid; otherwise, false.
    /// </returns>
    public static boolean validateSourceIntegratorEnabled(
        BudgetControlConfigurationRecId _controlConfigurationRecId,
        BudgetControlSourceIntegrator _sourceIntegrator,
        boolean _isEnabled)
    {
        boolean isValid = true;

        if (!BudgetControlConfigurationManager::isConfigurationEditPermitted(_controlConfigurationRecId))
        {
            isValid = false;
        }
        else if (!_isEnabled)
        {
            Set sourceIntegratorsAlwaysEnabled = BudgetControlSourceIntegratorEnabled::getSourceIntegratorsAlwaysEnabled();

            if (sourceIntegratorsAlwaysEnabled.in(_sourceIntegrator)
                || !BudgetControlSourceIntegratorEnabled::isModifyEnabledAllowed(_controlConfigurationRecId, _sourceIntegrator))
            {
                isValid = checkFailed(strFmt("@Budget:BudgetControlSourceIntegratorModifyNotAllowed", enum2Str(_sourceIntegrator)));
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBudgetGroupMembers</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the <c>BudgetGroupMember</c> records are valid for the specified budget control
    ///    configuration.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    ///    The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    /// <returns>
    ///    true if the <c>BudgetGroupMember</c> records are valid; otherwise, false.
    /// </returns>
    public static boolean validateBudgetGroupMembers(BudgetControlConfigurationRecId _controlConfigurationRecId)
    {
        return BudgetControlGroupValidation::validateBudgetGroupMembers(_controlConfigurationRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deactivateConfiguration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deactivates the specified <c>BudgetControlConfiguration</c> record, when budget control is disabled for all legal entiites.
    /// </summary>
    /// <param name="_controlConfigurationRecId">
    /// The record ID of the <c>BudgetControlConfiguration</c> record.
    /// </param>
    internal static void deactivateConfiguration(BudgetControlConfigurationRecId _controlConfigurationRecId)
    {
        // Check budget control is disabled for all legal entities
        if (!BudgetControlConfiguration::isAnyBudgetControlEnabled())
        {
            BudgetControlConfiguration activeControlConfiguration = BudgetControlConfiguration::find(_controlConfigurationRecId);

            if (activeControlConfiguration.IsActive)
            {
                ttsbegin;
                // Delete draft configuration if exists against the ledger, before deactiving the existing active configuration
                BudgetControlConfigurationManager::restoreActiveConfiguration(activeControlConfiguration.PrimaryLedger);

                // Deactivate existing active configuration
                activeControlConfiguration.selectForUpdate(true);
                activeControlConfiguration.IsActive = NoYes::No;
                activeControlConfiguration.InUseBy = '';
                activeControlConfiguration.InUseSinceDateTime = utcDateTimeNull();
                activeControlConfiguration.update();
                ttscommit;

                // Clear the configuration cache
                BudgetControlConfigurationManager::clearConfigurationCache();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPurchaseRequisitionBudgetControlEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether the purchase requisition is budget controlled or not.
    /// </summary>
    /// <param name = "_primaryLedger">Primary ledger recId</param>
    /// <returns>true if the condition matches; otherwise false </returns>
    internal static boolean isPurchaseRequisitionBudgetControlEnabled(LedgerRecId _primaryLedger)
    {
        return BudgetControlConfiguration::isControlConfigured()
            && Ledger::isLedgerBudgetControlEnabled(_primaryLedger)
            && BudgetControlConfiguration::isSourceIntegratorEnabled(_primaryLedger, BudgetControlSourceIntegrator::PurchaseRequisition);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBudgetControlEnabledAndConfigured</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the budget control is enabled and active.
    /// </summary>
    internal static boolean isBudgetControlEnabledAndConfigured()
    {
        return Ledger::isLedgerBudgetControlEnabled() && BudgetControlConfiguration::existActiveForPrimaryLedger(Ledger::current());
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>