<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PurchOrderLineSourceDocumentLineItem</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>PurchOrderLineSourceDocLineItem</c> class provides the information to handle the
///    distributions and sub-ledger journal account entries for a purchase order line.
/// </summary>
[SourceDocumentEnumExtensionAttribute(enumStr(SourceDocumentLine_ProductOrder), SourceDocumentLine_ProductOrder::PurchaseOrderLine)]
public class PurchOrderLineSourceDocumentLineItem extends SourceDocumentLineItem
    implements SourceDocumentLineItemIProductQuantity,
               SourceDocumentLineItemIProduct,
               SourceDocumentLineItemIInventory,
               SourceDocumentIChargeSource,
               SourceDocumentLineItemIProjectRevenue,
               SourceDocumentLineItemIFixedAsset,
               SourceDocumentIDataProvider,
               SourceDocumentLineItemIProductionFlow,
               SourceDocumentLineItemIFinalize,
               SourceDocumentIPurchaseOrder,
               SourceDocumentLineItemIAccDateUpdateable,
               SourceDocumentLineItemIFixedAsset_RU,
               AccountingFinTagIDistributionTaggable
{
    PurchLine       purchLine;
    PurchTable      purchTable;
    InventTable     inventTable;
    AssetTable      assetTable;
    AssetGroup      assetGroup;
    MarkupTrans     markupTrans;
    AccountingDate  openingDate;
    AccountingDate  closingDate;

    boolean         isoRU;
    boolean         isoIN;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calculateDefaultDimension</Name>
				<Source><![CDATA[
    protected DimensionDefault calculateDefaultDimension()
    {
        return purchLine.DefaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateLegalEntityRecId</Name>
				<Source><![CDATA[
    protected LegalEntityRecId calculateLegalEntityRecId()
    {
        return this.parmLegalEntity().RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSourceDocumentAmountMap</Name>
				<Source><![CDATA[
    protected SourceDocumentAmountMap calculateSourceDocumentAmountMap()
    {
        boolean includesTax;
        TaxModelTaxable taxModelTaxable;

        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            taxModelTaxable = TaxModelDocLineFactory::newTaxModelDocLine(purchLine);
        }

        if (!purchTable)
        {
            this.initPurchTable();
        }

        // Do amounts include tax?
        if (purchTable.InclTax
            || (taxModelTaxable && taxModelTaxable.isPriceInclTax()))
        {
            includesTax = true;
        }

        return this.calculateSourceDocumentAmountMapValues(includesTax);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSourceDocumentAmountMapValues</Name>
				<Source><![CDATA[
    private sourceDocumentAmountMap calculateSourceDocumentAmountMapValues(boolean _includesTax)
    {
        SourceDocumentAmountMap sourceDocumentAmountMap = SourceDocumentAmountMap::construct();

        if (purchLine.LineDeliveryType == LineDeliveryType::OrderLineWithMultipleDeliveries)
        {
            this.insertZeroAmountsToDocumentAmountMap(sourceDocumentAmountMap, _includesTax);
        }
        else
        {
            this.insertDocumentAmountsToDocumentAmountMap(sourceDocumentAmountMap, _includesTax, this.calculateMonetaryAmountValue(_includesTax));
        }

        return sourceDocumentAmountMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertZeroAmountsToDocumentAmountMap</Name>
				<Source><![CDATA[
    private void insertZeroAmountsToDocumentAmountMap(SourceDocumentAmountMap _sourceDocumentAmountMap, boolean _includesTax)
    {
        _sourceDocumentAmountMap.insert(SourceDocumentAmount::newFromParameters(sourceDocumentLine, 0, MonetaryAmount::ExtendedPrice, _includesTax));

        if (purchLine.LineDisc || purchLine.MultiLnDisc)
        {
            _sourceDocumentAmountMap.insert(SourceDocumentAmount::newFromParameters(sourceDocumentLine, 0, MonetaryAmount::PriceAdjustment, _includesTax));
        }
        if (purchLine.PurchMarkup)
        {
            _sourceDocumentAmountMap.insert(SourceDocumentAmount::newFromParameters(sourceDocumentLine, 0, MonetaryAmount::Charge, _includesTax));
        }
        if (purchLine.LinePercent || purchLine.MultiLnPercent)
        {
            _sourceDocumentAmountMap.insert(SourceDocumentAmount::newFromParameters(sourceDocumentLine, 0, MonetaryAmount::Discount, _includesTax));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateMonetaryAmountValue</Name>
				<Source><![CDATA[
    private PurchOrderLineSourceDocumentLineItemMonetaryAmount calculateMonetaryAmountValue(boolean _includesTax)
    {
        PurchOrderLineSourceDocumentLineItemMonetaryAmount monetaryAmountValue = PurchOrderLineSourceDocumentLineItemMonetaryAmount::construct();

        if (purchTable.DiscPercent)
        {
            monetaryAmountValue.totalDiscountAmount = -purchLine.totalDiscountAmount();
        }

        if (!purchLine.PurchPrice &&
            !purchLine.PurchMarkup &&
            !purchLine.discAmount() &&
            !purchLine.discPercent())
        {
            monetaryAmountValue.extendedPriceAmount = CurrencyExchangeHelper::amount(purchLine.LineAmount, purchLine.CurrencyCode);
        }
        else
        {
            this.initMonetaryAmountValue(monetaryAmountValue);
        }

        this.includeTaxInMonetaryAmountValue(_includesTax, monetaryAmountValue);

        return monetaryAmountValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>includeTaxInMonetaryAmountValue</Name>
				<Source><![CDATA[
    private void includeTaxInMonetaryAmountValue(boolean _includesTax, PurchOrderLineSourceDocumentLineItemMonetaryAmount _monetaryAmountValue)
    {
        InventProfile_RU inventProfile = purchLine.inventDim().inventProfile_RU();

        if (_includesTax)
        {
            if (!isoRU || inventProfile.taxUpdateIncoming() == TaxUpdateMode_RU::Standard)
            {
                this.initMonetaryAmountValueBasedOnTax(_monetaryAmountValue);
            }
        }
        else if (isoRU && inventProfile.taxUpdateIncoming() == TaxUpdateMode_RU::NoPost)
        {
            this.initMonetaryAmountValueBasedOnTax_RU(_monetaryAmountValue);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculatePriceAdjustmentAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the monetary price adjustment amount.
    /// </summary>
    /// <param name = "_priceUnit">The price unit for the calculation.</param>
    /// <returns>An amount value.</returns>
    protected Amount calculatePriceAdjustmentAmount(PriceUnit _priceUnit)
    {
        return -CurrencyExchangeHelper::amount(purchLine.PurchQty * purchLine.discAmount() / _priceUnit, purchLine.CurrencyCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMonetaryAmountValue</Name>
				<Source><![CDATA[
    private void initMonetaryAmountValue(PurchOrderLineSourceDocumentLineItemMonetaryAmount _monetaryAmountValue)
    {
        PriceUnit priceUnit = purchLine.PriceUnit ? purchLine.PriceUnit : 1;

        Amount priceAdjustmentAmount;
        Amount discountAmount;
        _monetaryAmountValue.extendedPriceAmount = this.calculateExtendedPriceAmount(priceUnit);
        _monetaryAmountValue.chargeAmount = this.calculateChargeAmount();

        if (purchLine.discPercent())
        {
            _monetaryAmountValue.priceAdjustmentAmount = this.calculatePriceAdjustmentAmount(priceUnit);
            _monetaryAmountValue.discountAmount = purchLine.LineAmount - _monetaryAmountValue.extendedPriceAmount - _monetaryAmountValue.priceAdjustmentAmount - _monetaryAmountValue.chargeAmount;
        }
        else
        {
            _monetaryAmountValue.priceAdjustmentAmount = purchLine.LineAmount - _monetaryAmountValue.extendedPriceAmount - _monetaryAmountValue.chargeAmount;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateExtendedPriceAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the extended price amount.
    /// </summary>
    /// <param name = "_priceUnit">
    /// The <c>PriceUnit</c> used in the calculation.
    /// </param>
    /// <returns>
    /// The calculated extended price amount.
    /// </returns>
    protected Amount calculateExtendedPriceAmount(PriceUnit _priceUnit)
    {
        Amount extendedPriceAmount = CurrencyExchangeHelper::amount(purchLine.PurchQty * purchLine.PurchPrice / _priceUnit, purchLine.CurrencyCode);
        return extendedPriceAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateChargeAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the charge amount.
    /// </summary>
    /// <returns>
    /// The calculated charge amount.
    /// </returns>
    protected Amount calculateChargeAmount()
    {
        Amount chargeAmount = CurrencyExchangeHelper::amount(purchLine.PurchQty >= 0 ? purchLine.PurchMarkup : -purchLine.PurchMarkup, purchLine.CurrencyCode);
        return chargeAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMonetaryAmountValueBasedOnTax</Name>
				<Source><![CDATA[
    private void initMonetaryAmountValueBasedOnTax(PurchOrderLineSourceDocumentLineItemMonetaryAmount _monetaryAmountValue)
    {
        LineAmount lineAmount = purchLine.LineAmount ? purchLine.LineAmount : 1;
        TaxBase taxBase = purchLine.lineAmountExcludingTax(purchTable.AccountingDate, null, false);

        _monetaryAmountValue.extendedPriceAmount = CurrencyExchangeHelper::amount(_monetaryAmountValue.extendedPriceAmount * taxBase / lineAmount, purchLine.CurrencyCode);
        _monetaryAmountValue.chargeAmount = CurrencyExchangeHelper::amount(_monetaryAmountValue.chargeAmount * taxBase / lineAmount, purchLine.CurrencyCode);

        if (purchLine.discPercent())
        {
            _monetaryAmountValue.priceAdjustmentAmount = CurrencyExchangeHelper::amount(_monetaryAmountValue.PriceAdjustmentAmount * taxBase / lineAmount, purchLine.CurrencyCode);
            _monetaryAmountValue.discountAmount = CurrencyExchangeHelper::amount(taxBase - _monetaryAmountValue.extendedPriceAmount - _monetaryAmountValue.priceAdjustmentAmount - _monetaryAmountValue.chargeAmount, purchLine.CurrencyCode);
        }
        else
        {
            _monetaryAmountValue.priceAdjustmentAmount = CurrencyExchangeHelper::amount(taxBase - _monetaryAmountValue.extendedPriceAmount - _monetaryAmountValue.chargeAmount, purchLine.CurrencyCode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMonetaryAmountValueBasedOnTax_RU</Name>
				<Source><![CDATA[
    private void initMonetaryAmountValueBasedOnTax_RU(PurchOrderLineSourceDocumentLineItemMonetaryAmount _monetaryAmountValue)
    {
        LineAmount lineAmount = purchLine.LineAmount ? purchLine.LineAmount : 1;
        Amount taxAmount = Tax::calcTaxAmount(purchLine.TaxGroup,
                                              purchLine.TaxItemGroup,
                                              purchLine.taxDate(purchTable.AccountingDate),
                                              purchLine.CurrencyCode,
                                              purchLine.LineAmount,
                                              TaxModuleType::Purch,
                                              purchLine.PurchQty,
                                              purchLine.PurchUnit,
                                              purchLine.ItemId);

        _monetaryAmountValue.extendedPriceAmount = CurrencyExchangeHelper::amount(_monetaryAmountValue.extendedPriceAmount + _monetaryAmountValue.extendedPriceAmount * taxAmount / lineAmount, purchLine.CurrencyCode);
        _monetaryAmountValue.chargeAmount = CurrencyExchangeHelper::amount(_monetaryAmountValue.chargeAmount + _monetaryAmountValue.chargeAmount * taxAmount / lineAmount, purchLine.CurrencyCode);

        if (purchLine.discPercent())
        {
            _monetaryAmountValue.priceAdjustmentAmount = CurrencyExchangeHelper::amount(_monetaryAmountValue.priceAdjustmentAmount + _monetaryAmountValue.priceAdjustmentAmount * taxAmount / lineAmount, purchLine.CurrencyCode);
            _monetaryAmountValue.discountAmount = CurrencyExchangeHelper::amount(purchLine.LineAmount + taxAmount - _monetaryAmountValue.extendedPriceAmount - _monetaryAmountValue.priceAdjustmentAmount - _monetaryAmountValue.chargeAmount, purchLine.CurrencyCode);
        }
        else
        {
            _monetaryAmountValue.priceAdjustmentAmount = CurrencyExchangeHelper::amount(purchLine.LineAmount + taxAmount - _monetaryAmountValue.extendedPriceAmount - _monetaryAmountValue.chargeAmount, purchLine.CurrencyCode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertDocumentAmountsToDocumentAmountMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the <c>SourceDocumentAmount</c> objects to the passed <c>SourceDocumentAmountMap</c> instance based on the given arguments.
    /// </summary>
    /// <param name = "_sourceDocumentAmountMap">
    /// The <c>SourceDocumentAmountMap</c> instance.
    /// </param>
    /// <param name = "_includesTax">
    /// A boolean value that indicates whether the amount of money includes tax.
    /// </param>
    /// <param name = "_monetaryAmountValue">
    /// The <c>MonetaryAmountValue</c> object which contains the amounts to be inserted.
    /// </param>
    protected void insertDocumentAmountsToDocumentAmountMap(SourceDocumentAmountMap _sourceDocumentAmountMap,
                                                            boolean _includesTax,
                                                            PurchOrderLineSourceDocumentLineItemMonetaryAmount _monetaryAmountValue)
    {
        if (!purchLine.IsDeleted)
        {
            _sourceDocumentAmountMap.insert(SourceDocumentAmount::newFromParameters(sourceDocumentLine, _monetaryAmountValue.extendedPriceAmount, MonetaryAmount::ExtendedPrice, _includesTax));
        }

        if (_monetaryAmountValue.priceAdjustmentAmount)
        {
            _sourceDocumentAmountMap.insert(SourceDocumentAmount::newFromParameters(sourceDocumentLine, _monetaryAmountValue.priceAdjustmentAmount, MonetaryAmount::PriceAdjustment, _includesTax));
        }

        if (_monetaryAmountValue.chargeAmount)
        {
            _sourceDocumentAmountMap.insert(SourceDocumentAmount::newFromParameters(sourceDocumentLine, _monetaryAmountValue.chargeAmount, MonetaryAmount::Charge, _includesTax));
        }

        if (_monetaryAmountValue.discountAmount)
        {
            _sourceDocumentAmountMap.insert(SourceDocumentAmount::newFromParameters(sourceDocumentLine, _monetaryAmountValue.discountAmount, MonetaryAmount::Discount, _includesTax));
        }

        if (_monetaryAmountValue.totalDiscountAmount)
        {
            _sourceDocumentAmountMap.insert(SourceDocumentAmount::newFromParameters(sourceDocumentLine, _monetaryAmountValue.totalDiscountAmount, MonetaryAmount::TotalDiscount, _includesTax));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canLineMatchAmountExceedReferenceDist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if the total line match amount can exceed the reference distribution amount.
    /// </summary>
    /// <returns>
    /// true if the total line match amount can exceed the reference distribution; otherwise, false.
    /// </returns>
    public boolean canLineMatchAmountExceedReferenceDist()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUpdateAccountingDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if the accounting date can be updated when it lies in a closed period.
    /// </summary>
    /// <returns>
    /// always returns true.
    /// </returns>
    public boolean canUpdateAccountingDate()
    {
        boolean ret = true;

        if (PurchSourceDocumentLineCanUpdateAccDateFlight::instance().isEnabled())
        {
            SysPluginMetadataCollection metadataCollection = new SysPluginMetadataCollection();
            metadataCollection.SetManagedValue("SourceDocumentIFiscalCalendarProvider", "PrimaryLedgerFiscalCalendar");
            SourceDocumentIFiscalCalendarProvider fiscalCalendarProvider = SysPluginFactory::Instance("Dynamics.AX.Application", 
                classStr(SourceDocumentIFiscalCalendarProvider), metadataCollection);

            if (fiscalCalendarProvider)
            {
                FiscalCalendarAccountingDateResolver accountingDateResolver = FiscalCalendarAccountingDateResolver::construct();
                accountingDateResolver.parmLegalEntityRecId(this.parmLegalEntityRecId());
                accountingDateResolver.parmAccountingDateProvidedOnDocument(this.parmAccountingDate());
                accountingDateResolver.parmDocumentLegalEntityPrimaryLedgerFiscalCalendar(fiscalCalendarProvider.getFiscalCalendarForPrimaryLedger(this.parmLegalEntityRecId()));
                accountingDateResolver.parmSysModule(this.parmSourceDocument().parmSourceDocumentType().parmModule());
                
                ret = accountingDateResolver.getAccountingDateResolution().parmIsAccountingDateInFiscalPeriodWithOpenStatusFound();
            }
            else
            {
                ret = false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUseOriginLineDistForChildAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if origin line distributions can be used for child monetary amount like discount.
    /// </summary>
    /// <returns>
    /// true if origin line distributions can be used for child monetary amount; otherwise, false.
    /// </returns>
    public boolean canUseOriginLineDistForChildAmount()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentsBusinessEvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates if the <c>SourceDocumentLineItem</c> documents a business event.
    /// </summary>
    /// <returns>
    /// true if the <c>SourceDocumentLineItem</c> documents a business event; otherwise, false.
    /// </returns>
    public BusinessEvent documentsBusinessEvent()
    {
        BusinessEvent       businessEvent;

        businessEvent = new BusinessEvent(enumNum(BusinessEvent_ProductOrder),BusinessEvent_ProductOrder::ObligateBudgetFundsForExpensedProducts);

        return businessEvent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existRAssets_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// performs check of asset existence in purchase line
    /// </summary>
    /// <returns>
    /// a boolean sign, true - if there is a RAssetPurchTrans record linked to the current purchase line
    /// </returns>
    public boolean existRAssets_RU()
    {
        return RAssetPurchTrans::exist(purchLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionFromPurchLine</Name>
				<Source><![CDATA[
    private LedgerDimensionDefaultAccount getLedgerDimensionFromPurchLine()
    {
        LedgerDimensionDefaultAccount ledgerDimensionDefaultAccount = 0;

        if (purchLine.canEditLedgerDimensionDefaultAccount())
        {
            ledgerDimensionDefaultAccount = purchLine.LedgerDimension;
        }

        return ledgerDimensionDefaultAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeImplementation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the instance variables.
    /// </summary>
    /// <param name="_sourceDocumentLineImplementation">
    /// A source document line implementation table.
    /// </param>
    /// <param name="_additionalInformation">
    /// A map to hold buffers of pre initiliazed objects need by the framework to the source document.
    /// </param>
    protected void initializeImplementation(SourceDocumentLineImplementation _sourceDocumentLineImplementation, Map _additionalInformation = null)
    {
        #ISOCountryRegionCodes

        PurchLineAllVersions purchLineAllVersions;

        if (_sourceDocumentLineImplementation.TableId == tableNum(PurchLineAllVersions))
        {
            purchLineAllVersions = _sourceDocumentLineImplementation;
            purchLine = PurchLine::findInventTransId(purchLineAllVersions.InventTransId);
        }
        else
        {
            purchLine = _sourceDocumentLineImplementation;
        }

        isoRU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        isoIN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOriginSourceDocumentLineItem</Name>
				<Source><![CDATA[
    protected void initOriginSourceDocumentLineItem()
    {
        SourceDocumentLine          originSourceDocumentLine;
        PurchLineOrigin             purchLineOrigin;

        select firstonly originSourceDocumentLine
    exists join purchLineOrigin
    where originSourceDocumentLine.RecId            == purchLineOrigin.OriginSourceDocumentLine
    &&    purchLineOrigin.PurchLineDataAreaId       == purchLine.DataAreaId
    &&    purchLineOrigin.PurchLineInventTransId    == purchLine.InventTransId;

        if (originSourceDocumentLine)
        {
            originSourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(originSourceDocumentLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPurchTable</Name>
				<Source><![CDATA[
    private void initPurchTable()
    {
        if (purchLine)
        {
            // PO line has been saved - use it to get the related header
            purchTable = purchLine.purchTable();
        }
        else
        {
            // PO line is being inserted - need to find the header via source document header
            purchTable = PurchTable::findSourceDocumentHeader(sourceDocumentLine.SourceDocumentHeader);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSourceDocumentLineMatchingList</Name>
				<Source><![CDATA[
    protected void initSourceDocumentLineMatchingList()
    {
        PurchReqLine                        purchReqLine;
        PurchLine                           orderLine;
        PurchReqLineRefId                   purchReqLineRefId;
        PurchDeliverySchedule               purchDeliverySchedule;

        if (purchLine.PurchCommitmentLine_PSN && PublicSectorUtils::isFrenchRegulatoryEnabled())
        {
            sourceDocumentLineMatchingList = SourceDocumentLineMatchingFacade::addSourceDocLineItemToList(this,
                                         purchLine.getPurchCommitmentLine_PSN());
        }
        else if (BudgetReservationLine_PSN::doAllowPurchOrderLineRefBudgetResLine(PurchLine))
        {
            sourceDocumentLineMatchingList = SourceDocumentLineMatchingFacade::addSourceDocLineItemToList(this,
                                            BudgetReservationLine_PSN::find(purchLine.BudgetReservationLine_PSN));
        }
        
        else if (purchLine.LineDeliveryType == LineDeliveryType::DeliveryLine && purchLine.PurchReqId != '')
        {
            // for delivery schedule line need to find the commercial order line to get
            // reference to purchase requisition line
            select RecId from purchDeliverySchedule
            where purchDeliverySchedule.DeliveryLine == purchLine.InventTransId
            join PurchReqLineRefId from orderLine
                where orderLine.InventTransId == purchDeliverySchedule.OrderLine;

            if (orderLine)
            {
                purchReqLineRefId = orderLine.PurchReqLineRefId;
            }
        }
        else if (purchLine.PurchReqLineRefId)
        {
            purchReqLineRefId = purchLine.PurchReqLineRefId;
        }

        if (purchReqLineRefId)
        {
            purchReqLine = PurchReqLine::findLineRefId(purchReqLineRefId);

            sourceDocumentLineMatchingList = SourceDocumentLineMatchingFacade::addSourceDocLineItemToList(this, purchReqLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmClosingDate</Name>
				<Source><![CDATA[
    public AccountingDate parmClosingDate(AccountingDate _closingDate = closingDate)
    {
        closingDate = _closingDate;

        return closingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerDimensionDefaulAccountFromMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds default main account used for posting in ledger.
    /// </summary>
    /// <returns>
    /// <c>LedgerDimensionDefaultAccount</c> object.
    /// </returns>
    protected LedgerDimensionDefaultAccount ledgerDimensionDefaulAccountFromMarkup()
    {
        PurchLine_W     purchLine_W = purchLine.purchLine_W();

        return purchLine_W.MarkupCode_RU ?
        MarkupTable::find(MarkupModuleType::Vend, purchLine_W.MarkupCode_RU).CustomerLedgerDimension:
        0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountingDate</Name>
				<Source><![CDATA[
    public AccountingDate parmAccountingDate()
    {
        // Not using super due to performance
        AccountingDate accountingDate;
        
        if (closingDate)        
        {
            accountingDate = closingDate;
            
        }
        else if (openingDate)
        {
            accountingDate = openingDate;
            
        }
        else        
        {
            if (!purchTable)
            {
                this.initPurchTable();
            }

            accountingDate = purchTable.AccountingDate;
        }

        return accountingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAssetDataAreaId</Name>
				<Source><![CDATA[
    public DataAreaId parmAssetDataAreaId()
    {
        DataAreaId      dataAreaId;

        if (purchLine.AssetId)
        {
            dataAreaId = purchLine.DataAreaId;
        }

        return dataAreaId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAssetGroupDataAreaId</Name>
				<Source><![CDATA[
    public DataAreaId parmAssetGroupDataAreaId()
    {
        DataAreaId      dataAreaId;

        if (purchLine.AssetGroup)
        {
            dataAreaId = purchLine.DataAreaId;
        }

        return dataAreaId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAssetGroupId</Name>
				<Source><![CDATA[
    public AssetGroupId parmAssetGroupId()
    {
        return purchLine.AssetGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAssetId</Name>
				<Source><![CDATA[
    public AssetId parmAssetId()
    {
        return purchLine.AssetId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAssetTransactionType</Name>
				<Source><![CDATA[
    public AssetTransType parmAssetTransactionType()
    {
        AssetTransType      assetTransType;

        switch (purchLine.AssetTransTypePurch)
        {
            case AssetTransTypePurch::Acquisition:
                assetTransType = AssetTransType::Acquisition;
                break;
            case AssetTransTypePurch::AcquisitionAdj:
                assetTransType = AssetTransType::AcquisitionAdj;
                break;
        }
        return assetTransType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBusinessEventDate</Name>
				<Source><![CDATA[
    public DocumentDate parmBusinessEventDate()
    {
        DocumentDate documentDate;

        documentDate = super();

        return documentDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCategory</Name>
				<Source><![CDATA[
    public Common parmCategory()
    {
        return EcoResCategory::find(purchLine.ProcurementCategory);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCategoryName</Name>
				<Source><![CDATA[
    public str parmCategoryName()
    {
        return EcoResCategory::find(purchLine.ProcurementCategory).Name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmChargeInputAmount</Name>
				<Source><![CDATA[
    public Amount parmChargeInputAmount()
    {
        Amount      chargeInputAmount;

        chargeInputAmount = purchLine.calcLineAmountExclTax();

        return chargeInputAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmChargeQuantity</Name>
				<Source><![CDATA[
    public Qty parmChargeQuantity()
    {
        return purchLine.PurchQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmChargeSource</Name>
				<Source><![CDATA[
    public Common parmChargeSource(Common _markupTrans = markupTrans)
    {
        markupTrans = _markupTrans;
        return markupTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCopyDistributionReferenceOfOriginal</Name>
				<Source><![CDATA[
    public boolean parmCopyDistributionReferenceOfOriginal()
    {
        boolean copyReferenceOfOriginal;

        if (purchLine.LineDeliveryType == LineDeliveryType::DeliveryLine)
        {
            copyReferenceOfOriginal = true;
        }
        else
        {
            copyReferenceOfOriginal = false;
        }

        return copyReferenceOfOriginal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDefaultDimension</Name>
				<Source><![CDATA[
    public DimensionDefault parmDefaultDimension()
    {
        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDistributionTemplateRecId</Name>
				<Source><![CDATA[
    public AccountingDistributionTemplateRecId parmDistributionTemplateRecId()
    {
        return purchLine.AccountingDistributionTemplate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventoryDimensionId</Name>
				<Source><![CDATA[
    public InventDimId parmInventoryDimensionId()
    {
        return purchLine.InventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventTable</Name>
				<Source><![CDATA[
    public Common parmInventTable()
    {
        if (purchLine.ItemId && !inventTable.RecId)
        {
            inventTable = purchLine.inventTable();
        }
        return inventTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsDocumentLineEditable</Name>
				<Source><![CDATA[
    public boolean parmIsDocumentLineEditable()
    {
        boolean                     isDocumentLineEditable;
        PurchTable                  currentPurchTable;

        isDocumentLineEditable = super();

        if (isDocumentLineEditable)
        {
            currentPurchTable = purchLine.purchTable();

            isDocumentLineEditable = currentPurchTable.editAllowed();
        }

        return isDocumentLineEditable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsTaxInChargeInputAmountIncluded</Name>
				<Source><![CDATA[
    public boolean parmIsTaxInChargeInputAmountIncluded()
    {
        if (!purchTable)
        {
            this.initPurchTable();
        }

        return purchTable.InclTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItemDataAreaId</Name>
				<Source><![CDATA[
    public DataAreaId parmItemDataAreaId()
    {
        DataAreaId      dataAreaId;

        if (purchLine.ItemId)
        {
            dataAreaId = purchLine.DataAreaId;
        }

        return dataAreaId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItemId</Name>
				<Source><![CDATA[
    public ItemId parmItemId()
    {
        return purchLine.ItemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getItemName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the resovled item name on the purchase order line based
    /// on the item being a catalog or non-catalog item.
    /// </summary>
    /// <returns>
    /// The item name on the purchase order line.
    /// </returns>
    /// <remarks>
    /// This is a read-only method.
    /// </remarks>
    public Name getItemName()
    {
        return purchLine.itemName();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOpeningDate</Name>
				<Source><![CDATA[
    public AccountingDate parmOpeningDate(AccountingDate _openingDate = openingDate)
    {
        openingDate = _openingDate;

        return openingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerDimensionDefaultAccount</Name>
				<Source><![CDATA[
    [Hookable()]
    public LedgerDimensionDefaultAccount parmLedgerDimensionDefaultAccount(LegalEntityRecId _legalEntityRecId = this.parmLegalEntityRecId())
    {
        return this.getLedgerDimensionFromPurchLine();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerDimensionOverrideAccount</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount parmLedgerDimensionOverrideAccount()
    {
        return this.getLedgerDimensionFromPurchLine();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLegalEntity</Name>
				<Source><![CDATA[
    public CompanyInfo parmLegalEntity()
    {
        return purchLine.companyInfo();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineNum</Name>
				<Source><![CDATA[
    public LineNum parmLineNum()
    {
        return int642int(purchLine.LineNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLotId</Name>
				<Source><![CDATA[
    public InventTransId parmLotId()
    {
        return purchLine.InventTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPlanReference</Name>
				<Source><![CDATA[
    public LeanProductionFlowReferenceRefRecId parmPlanReference()
    {
        return purchLine.PlanReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectActivityNumber</Name>
				<Source><![CDATA[
    public ProjActivityNumber parmProjectActivityNumber()
    {
        return purchLine.ActivityNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectCategoryId</Name>
				<Source><![CDATA[
    public ProjCategoryId parmProjectCategoryId()
    {
        return purchLine.ProjCategoryId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectFundingSourceRecId</Name>
				<Source><![CDATA[
    public ProjFundingSourceRefId parmProjectFundingSourceRecId()
    {
        //Accounting distribution for PO linked to Item requiement
        if (ProjItemRequirementMultipleFundingSourcesFeatureHelper::isFeatureEnabled() && purchLine.isPurchLineLinkedToItemRequirement())
        {
            SalesLine salesLine = SalesLine::findInventTransId(purchLine.InventRefTransId);
            if (salesLine.ProjFundingSource)
            {
                return salesLine.ProjFundingSource;
            }
            //For legacy data which does not have funding source stamped on the line, return funding source on header or funding source on the project
            if (salesLine.salesTable().FundingSource)
            {
                return salesLine.salesTable().FundingSource;
            }
        }
        
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectId</Name>
				<Source><![CDATA[
    public ProjId parmProjectId()
    {
        return purchLine.ProjId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectItemSalesTaxGroup</Name>
				<Source><![CDATA[
    public ProjTaxItemGroup parmProjectItemSalesTaxGroup()
    {
        return purchLine.ProjTaxItemGroupId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectLineProperty</Name>
				<Source><![CDATA[
    public ProjLinePropertyId parmProjectLineProperty()
    {
        return purchLine.ProjLinePropertyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectResourceCategoryRecId</Name>
				<Source><![CDATA[
    public ResourceCategoryRecId parmProjectResourceCategoryRecId()
    {
        return ResourceFacade::getResourceCategory(this.parmProjectResourceRecId(), this.parmAccountingDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectResourceRecId</Name>
				<Source><![CDATA[
    public ResourceRecId parmProjectResourceRecId()
    {
        return purchLine.getProjResourceRecId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectSalesCurrencyCode</Name>
				<Source><![CDATA[
    public ProjSalesCurrencyCode parmProjectSalesCurrencyCode()
    {
        return purchLine.ProjSalesCurrencyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectSalesPrice</Name>
				<Source><![CDATA[
    public SalesPrice parmProjectSalesPrice()
    {
        SalesPrice      salesPrice;
        InventMovement  inventMovement;

        if (purchLine.ItemId && !purchLine.IsDeleted)
        {
            inventMovement = InventMovement::construct(purchLine);
            salesPrice = inventMovement.projSalesPrice();
        }
        else
        {
            salesPrice = purchLine.ProjSalesPrice;
        }

        return salesPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectSalesTaxGroup</Name>
				<Source><![CDATA[
    public ProjTaxGroup parmProjectSalesTaxGroup()
    {
        return purchLine.ProjTaxGroupId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectSalesUnit</Name>
				<Source><![CDATA[
    public SalesUnit parmProjectSalesUnit()
    {
        return purchLine.ProjSalesUnitId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectTransactionId</Name>
				<Source><![CDATA[
    public ProjTransIdBase parmProjectTransactionId()
    {
        return purchLine.ProjTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPurchTable</Name>
				<Source><![CDATA[
    public Common parmPurchTable(PurchTable _purchTable = purchTable)
    {
        purchTable = _purchTable;

        return purchTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQuantity</Name>
				<Source><![CDATA[
    public Qty parmQuantity()
    {
        return purchLine.PurchQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQuantityDecimalPlaces</Name>
				<Source><![CDATA[
    public Decimals parmQuantityDecimalPlaces()
    {
        Decimals inventDecimalPlaces;

        inventTable = this.parmInventTable();

        if (inventTable)
        {
            inventDecimalPlaces = InventTable::inventDecimals(purchLine.ItemId);
        }

        return inventDecimalPlaces;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocLineFinalizedDate</Name>
				<Source><![CDATA[
    public AccountingDate parmSourceDocLineFinalizedDate()
    {
        if (!purchTable)
        {
            this.initPurchTable();
        }

        return purchTable.FinalizeClosingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmStocked</Name>
				<Source><![CDATA[
    public TradeStockedProduct parmStocked()
    {
        return purchLine.StockedProduct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxGroup</Name>
				<Source><![CDATA[
    public TaxGroup parmTaxGroup(TaxGroup _taxGroup = purchLine.TaxGroup)
    {
        purchLine.TaxGroup = _taxGroup;

        return purchLine.TaxGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransactionCurrencyCode</Name>
				<Source><![CDATA[
    public CurrencyCode parmTransactionCurrencyCode()
    {
        return purchLine.CurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmValueModel</Name>
				<Source><![CDATA[
    public AssetBookId parmValueModel()
    {
        return purchLine.AssetBookId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useOriginalDistributionAmount</Name>
				<Source><![CDATA[
    public boolean useOriginalDistributionAmount()
    {
        boolean useOriginalDistributionAmount = true;

        // Do not use original distribution amount if the current purchase order line is a credit note
        if (purchLine.InventRefId && purchLine.InventRefTransId && purchLine.PurchQty < 0)
        {
            useOriginalDistributionAmount = false;
        }

        return useOriginalDistributionAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountFromMarkupEventHandler</Name>
				<Source><![CDATA[
    [PostHandlerFor(classStr(PurchOrderLineSourceDocumentLineItem), methodStr(PurchOrderLineSourceDocumentLineItem, parmLedgerDimensionDefaultAccount))]
    /// <summary>
    /// Sets account and populates with data from _args.
    /// </summary>
    /// <param name="_args">
    /// <c>XppPrePostArgs</c> instance.
    /// </param>
    public static void parmAccountFromMarkupEventHandler(XppPrePostArgs _args)
    {
        #isoCountryRegionCodes
        LedgerDimensionDefaultAccount           account;
        PurchOrderLineSourceDocumentLineItem    item;
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            item = _args.getThis();
            account = item.ledgerDimensionDefaulAccountFromMarkup();
            if (account)
            {
                _args.setReturnValue(account);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>doUseMatchListOnCheckMainAccDervInputChg</Name>
				<Source><![CDATA[
    protected boolean doUseMatchListOnCheckMainAccDervInputChg()
    {
        boolean ret = false;

        if (purchLine.AssetId || purchLine.CreateFixedAsset)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountingDistributionListForDoc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes any lines associated with a period closing event from the <c>Map</c> object created by the base class if
    /// there is a commitment associated with purchline.
    /// </summary>
    /// <returns>
    /// A <c>Map</c> object of distributions for the current source document.
    /// </returns>
    protected Map getAccountingDistributionListForDoc()
    {
        Map                                     docAmountMap, localDocAmountMap;
        MapEnumerator                           docAmountMapEnum;
        AccountingDistribution                  accountingDistribution;
        AccountingDistributionList              accDistList, localAccDistList;
        AccountingDistributionListEnumerator    accDistListEnum;
        RecId                                   sourceDocLineRecId;
        boolean                                 hasChanged;
        
        docAmountMap = super();
        
        if (docAmountMap
            && purchLine.PurchCommitmentLine_PSN
            && isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
            && PublicSectorUtils::isFrenchRegulatoryEnabled())
        {
            // The PO line has an associated commitment. We need to make sure that the accounting distribution list does not
            // contain any closing entries otherwise the invoice generated from the PO will have incorrect distributions.
            
            docAmountMapEnum = docAmountMap.getEnumerator();
            localDocAmountMap = new Map(Types::Int64, Types::Class);
            
            while (docAmountMapEnum.moveNext())
            {
                sourceDocLineRecId = docAmountMapEnum.currentKey();
                accDistList = docAmountMapEnum.currentValue();
                localAccDistList = AccountingDistributionList::construct();
                
                accDistListEnum = accDistList.getEnumerator();
                while (accDistListEnum.moveNext())
                {
                    accountingDistribution = accDistListEnum.current();
                    if (accountingDistribution.accountingEventType() != AccountingEventType::PeriodClose)
                    {
                        localAccDistList.addEnd(accountingDistribution);
                    }
                    else
                    {
                        hasChanged = true;
                    }
                }
                
                if (!localAccDistList.empty())
                {
                    localDocAmountMap.insert(sourceDocLineRecId, localAccDistList);
                }
            }
        }
        else
        {
            localDocAmountMap = docAmountMap;
        }

        if (hasChanged)
        {
            // Our map was changed so we need to update the cache to have the new map
            SysTransactionScopeCache::remove(classStr(SourceDocumentLineItem), [#distributionListForDocument, this.parmSourceDocumentHeaderRecId()]);
            SysTransactionScopeCache::set(classStr(SourceDocumentLineItem), [#distributionListForDocument, this.parmSourceDocumentHeaderRecId()], localDocAmountMap);
        }
        
        return localDocAmountMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSourceDocumentStatus</Name>
				<Source><![CDATA[
    internal VersioningDocumentState getSourceDocumentStatus()
    {
        if (!purchTable)
        {
            this.initPurchTable();
        }

        return purchTable.DocumentState;
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyTagsToAllocations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Applies financial tags to a list of allocations for the current source document line.
    /// </summary>
    /// <param name = "_allocations">The list of allocations.</param>
    /// <returns>The list of allocations with financial tags applied.</returns>
    public LedgerDimensionAllocationList applyTagsToAllocations(LedgerDimensionAllocationList _allocations)
    {
        LedgerDimensionAllocationListEnumerator ledgerDimensionAllocationListEnumerator = _allocations.getEnumerator();
        LedgerDimensionAllocationList returnList = LedgerDimensionAllocationList::construct();

        while (ledgerDimensionAllocationListEnumerator.moveNext())
        {
            LedgerDimensionAllocation currentItem = ledgerDimensionAllocationListEnumerator.current();
            currentItem.parmFinTag(purchLine.FinTag);
            returnList.addEnd(currentItem);
        }

        return returnList;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>