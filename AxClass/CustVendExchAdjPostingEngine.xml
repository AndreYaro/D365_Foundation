<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendExchAdjPostingEngine</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>CustVendExchAdjPostingEngine</c> class is responsible for posting exchange adjustments.
/// </summary>
abstract class CustVendExchAdjPostingEngine
{
    CustVendTrans custVendTrans;
    CustVendTransOpen custVendTransOpen;
    CustVendSettlement custVendSettlement;
    CustVendExchAdj exchangeAdjustmentController;
    TransDate exchangeRateDate;
    DimensionDefault defaultDimension;
    TransStatusCode postingProfile;
    LedgerDimensionAccount previousAccountingCurrencyAdjustmentLedgerDimension;
    LedgerDimensionAccount previousReportingCurrencyAdjustmentLedgerDimension;
    NoneTableTrans previousDimensionSpecification;
    TransStatusCode previousPostingProfile;
    CreatedTransactionId previousCreatedTransactionId;
    TransDate lastExchAdjDate;
    LedgerVoucher ledgerVoucher;
    CustVendTransDistributionController distributionController;
    boolean doesLedgerEntryIsExchangeAdjustmentExist;
    // <GEERU>
    #ISOCountryRegionCodes
    // </GEERU>
    boolean countryRegion_RUCZ;
    CustVendExchPrinciples previousExchangePrinciple;
    boolean skipUseLedgerVoucherChanged;
    private boolean fromSettle;
    private boolean isCustVendExchAdjLedgerDimensionFlightEnabled;


}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmFromSettle</Name>
				<Source><![CDATA[
    internal boolean parmFromSettle(boolean _fromSettle = fromSettle)
    {
        fromSettle = _fromSettle;

        return fromSettle;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipUseLedgerVoucherChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Used to indicate if the From or the To voucher and transaction date should be used to generate account and dimension factors. 
    /// </summary>
    /// <param name="_skipUseLedgerVoucherChanged">
    /// True indicates that the From voucher voucher and transaction date will be used; otherwise false.
    /// </param>
    /// <returns>
    /// True indicates that the From voucher voucher and transaction date will be used; otherwise false.
    /// </returns>
    public boolean parmSkipUseLedgerVoucherChanged(boolean _skipUseLedgerVoucherChanged = skipUseLedgerVoucherChanged)
    {
        skipUseLedgerVoucherChanged = _skipUseLedgerVoucherChanged;

        return skipUseLedgerVoucherChanged;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initExchangeRateHelperForExchangeAdjustment</Name>
				<Source><![CDATA[
	/// <summary>
    /// Initializes a new <c>ExchangeRateHelper</c> class instance to be used for the current exchange adjustment.
    /// </summary>
    /// <param name = "_originalCustVendTrans">The original <c>CustVendTrans</c> buffer.</param>
    /// <returns>A newly initialized <c>ExchangeRateHelper</c> class instance to be used for the current exchange adjustment.</returns>
    protected ExchangeRateHelper initExchangeRateHelperForExchangeAdjustment(CustVendTrans _originalCustVendTrans)
    {
        ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newExchangeDate(
            Ledger::primaryLedger(CompanyInfo::current()),
            _originalCustVendTrans.CurrencyCode,
            exchangeRateDate);

        exchangeRateHelper.parmErrorType(AifErrorType::None);

        return exchangeRateHelper;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateOriginalCustVendTransForExchangeAdjustment</Name>
				<Source><![CDATA[
	/// <summary>
    /// Populates the original <c>CustVendTrans</c> buffer with values for the current exchange adjustment.
    /// </summary>
    /// <param name="_accountingCurrencyExchangeAdjustmentAmount"> The accounting currency exchange adjustment.</param>
    /// <param name="_reportingCurrencyExchangeAdjustmentAmount">The reporting currency exchange adjustment.</param>
    /// <param name="_settlementDate">The date used to create the new settlement record.</param>
    /// <returns>The newly populated original <c>CustVendTrans</c> buffer with values for the current exchange adjustment.</returns>
	protected CustVendTrans populateOriginalCustVendTransForExchangeAdjustment(
        AmountMST _accountingCurrencyExchangeAdjustmentAmount,
        AmountMSTSecondary _reportingCurrencyExchangeAdjustmentAmount,
        TransDate _settlementDate)
    {
        // bind the map to the correct table
        CustVendTrans originalCustVendTrans = custVendTrans.data();

        select forupdate originalCustVendTrans
            where originalCustVendTrans.RecId == custVendTrans.RecId
                && originalCustVendTrans.TableId == custVendTrans.TableId;

        originalCustVendTrans.ExchAdjustmentUnrealized += _accountingCurrencyExchangeAdjustmentAmount;
        originalCustVendTrans.ReportingExchAdjustmentUnrealized += _reportingCurrencyExchangeAdjustmentAmount;
        originalCustVendTrans.ExchAdjustment += _accountingCurrencyExchangeAdjustmentAmount;
        originalCustVendTrans.ExchAdjustmentReporting += _reportingCurrencyExchangeAdjustmentAmount;

        // <GEERU><GEECZ>
        if (!countryRegion_RUCZ)
        {
            // </GEECZ></GEERU>
            originalCustVendTrans.LastSettleDate = exchangeAdjustmentController.postingDate();
            // <GEERU>
        }
        // </GEERU>
        originalCustVendTrans.LastSettleVoucher = ledgerVoucher.lastVoucher();
        originalCustVendTrans.LastSettleAccountNum = originalCustVendTrans.AccountNum;
        originalCustVendTrans.LastSettleCompany = originalCustVendTrans.DataAreaId;

        originalCustVendTrans.LastExchAdjVoucher = ledgerVoucher.lastVoucher();

        ExchangeRateHelper exchangeRateHelper = this.initExchangeRateHelperForExchangeAdjustment(originalCustVendTrans);

        if (_accountingCurrencyExchangeAdjustmentAmount || _reportingCurrencyExchangeAdjustmentAmount)
        {
            // Always save the last rate used since it is important when calculating back out amounts
            // in the settlement case. If the old rate is not there, there is no way to determine how
            // the accounting currency amount was originally calculated.
            originalCustVendTrans.LastExchAdjRate = exchangeRateHelper.getCrossRate();

            if (Ledger::reportingCurrency(CompanyInfo::current()))
            {
                // Only calculate the reporting rate when the reporting currency exists
                exchangeRateHelper.parmExchangeRateTypeRecId(Ledger::reportingCurrencyExchangeRateType());
                exchangeRateHelper.parmToCurrency(Ledger::reportingCurrency());
                originalCustVendTrans.LastExchAdjRateReporting = exchangeRateHelper.getCrossRate();
            }
        }

        // <GEERU><GEECZ>
        if (countryRegion_RUCZ)
        {
            originalCustVendTrans.LastExchAdj = custVendSettlement.TransDate; // for correct date in settlement
        }
        else
        {
            // </GEECZ></GEERU>
            originalCustVendTrans.LastExchAdj = exchangeAdjustmentController.postingDate();
            // <GEERU><GEECZ>
        }
        if (countryRegion_RUCZ)
        {
            originalCustVendTrans.LastSettleDate = originalCustVendTrans.LastExchAdj;
        }
        // </GEECZ></GEERU>

        // Create settlement records corresponding with the exchange adjustment. This
        // ensures open balances on a given date are accurate.
        if (custVendTransOpen)
        {
            CustVendTransData::construct(originalCustVendTrans).updateSettlement(
                custVendTransOpen,
                0,
                0,
                NoYes::No,
                false,
                false,
                originalCustVendTrans.DefaultDimension,
                _settlementDate);
        }
        else
        {
            CustVendTransData::construct(originalCustVendTrans).updateWithCustVendSettlement(custVendSettlement, _settlementDate);
        }

        // <GEERU><GEECZ>
        if (countryRegion_RUCZ)
        {
            originalCustVendTrans.LastExchAdj = exchangeAdjustmentController.postingDate();
        }
        // </GEECZ></GEERU>

        return originalCustVendTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateNewCustVendTransForExhangeAdjustment</Name>
				<Source><![CDATA[
	/// <summary>
    /// Populates a new <c>CustVendTrans</c> buffer with values for the current exchange adjustment.
    /// </summary>
    /// <param name="_accountingCurrencyExchangeAdjustmentAmount"> The accounting currency exchange adjustment.</param>
    /// <param name="_reportingCurrencyExchangeAdjustmentAmount">The reporting currency exchange adjustment.</param>
    /// <param name="_exchangeAdjustmentTransDate">The date used to create the new adjustment.</param>
    /// <param name="_isReversing">Indicates if this is a reversing adjustment.</param>
    /// <param name="_useSettingsFromPreviousAdjustment">
	/// true if the exchange adjustment settings from the previous adjustment should be used;otherwise, false.
	/// </param>
    /// <param name = "_originalCustVendTrans">
	/// The original <c>CustVendTrans</c> buffer to be used to populate the new <c>CustVendTrans</c> buffer for the exchange adjustment.
	/// </param>
    /// <returns>The newly populated <c>CustVendTrans</c> buffer with values for the current exchange adjustment.</returns>
    protected CustVendTrans populateNewCustVendTransForExhangeAdjustment(
        AmountMST _accountingCurrencyExchangeAdjustmentAmount,
        AmountMSTSecondary _reportingCurrencyExchangeAdjustmentAmount,
        TransDate _exchangeAdjustmentTransDate,
        boolean _isReversing,
        boolean _useSettingsFromPreviousAdjustment,
		CustVendTrans _originalCustVendTrans)
    {
        //<GEE>
        boolean countryRegion_EE = SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoCZ, #isoEE, #isoHU, #isoLT, #isoLV, #isoPL, #isoRU ]);
        // </GEE>

        TransactionTxt transTxt = TransactionTxt::construct();
        transTxt.setType(this.getSubledgerTransactionText());
        transTxt.setLanguage(custVendTrans.languageId());
        transTxt.setVoucher(ledgerVoucher.lastVoucher());
        transTxt.setFormLetter(custVendTrans.Invoice);
        transTxt.setKey1(custVendTrans.AccountNum);

        // bind the map to the correct table
        CustVendTrans newCustVendTrans = custVendTrans.data();

        newCustVendTrans.clear();
        newCustVendTrans.AccountNum = custVendTrans.AccountNum;
        newCustVendTrans.Invoice = custVendTrans.Invoice;
        newCustVendTrans.CurrencyCode = custVendTrans.CurrencyCode;

        newCustVendTrans.TransDate = _exchangeAdjustmentTransDate;

        newCustVendTrans.Closed = CustVendTransData::construct(newCustVendTrans).maxSettlementDate(newCustVendTrans.TransDate);
        newCustVendTrans.Voucher = ledgerVoucher.lastVoucher();
        newCustVendTrans.Approved = NoYes::Yes;
        newCustVendTrans.TransType = LedgerTransType::ExchAdjustment;
        newCustVendTrans.Txt = transTxt.txt(exchangeAdjustmentController.transExchAdjTxt());
        newCustVendTrans.LastExchAdj = exchangeAdjustmentController.postingDate();

        newCustVendTrans.AmountMST = _accountingCurrencyExchangeAdjustmentAmount;
        newCustVendTrans.ReportingCurrencyAmount = _reportingCurrencyExchangeAdjustmentAmount;
        newCustVendTrans.AmountCur = 0;
        newCustVendTrans.ExchRate = 100;
        newCustVendTrans.ExchAdjustmentUnrealized = -_accountingCurrencyExchangeAdjustmentAmount;
        newCustVendTrans.ExchAdjustment = -_accountingCurrencyExchangeAdjustmentAmount;
        newCustVendTrans.ReportingExchAdjustmentUnrealized = -_reportingCurrencyExchangeAdjustmentAmount;
        newCustVendTrans.ExchAdjustmentReporting = -_reportingCurrencyExchangeAdjustmentAmount;

        newCustVendTrans.ReportingCurrencyCrossRate = 100.0;
        newCustVendTrans.ReportingCurrencyExchRate = 100.0;

        newCustVendTrans.SettleAmountMST = _accountingCurrencyExchangeAdjustmentAmount;
        newCustVendTrans.SettleAmountReporting = _reportingCurrencyExchangeAdjustmentAmount;

        newCustVendTrans.LastSettleDate = _originalCustVendTrans.LastExchAdj;
        newCustVendTrans.LastSettleVoucher = _originalCustVendTrans.Voucher;
        newCustVendTrans.LastSettleAccountNum = _originalCustVendTrans.AccountNum;
        newCustVendTrans.LastSettleCompany = _originalCustVendTrans.DataAreaId;

        newCustVendTrans.OffsetRecId = _originalCustVendTrans.RecId;

        newCustVendTrans.DefaultDimension = defaultDimension;
        newCustVendTrans.initFromPostingProfile(this.getPostingProfile(_useSettingsFromPreviousAdjustment));

        // <GEERU><GEECZ>
        if (countryRegion_EE)
        {
            newCustVendTrans.Correct = _isReversing;
        }

        if (countryRegion_RUCZ)
        {
            newCustVendTrans.Correct = _isReversing;
            CustVendTrans_W custVendTrans_W = newCustVendTrans.CustVendTrans::getCustVendTrans_W();
            custVendTrans_W.CorrectReporting_RU = _isReversing;
            newCustVendTrans.CustVendTrans::packCustVendTrans_W(custVendTrans_W);
        }
        // </GEECZ></GEERU>

        return newCustVendTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addExchangeAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds an unrealized exchange adjustment to post.
    /// </summary>
    /// <param name="_accountingCurrencyExchangeAdjustmentAmount">
    /// The accounting currency exchange adjustment.
    /// </param>
    /// <param name="_reportingCurrencyExchangeAdjustmentAmount">
    /// The reporting currency exchange adjustment.
    /// </param>
    /// <param name="_settlementDate">
    /// The date used to create the new settlement record.
    /// </param>
    /// <param name="_exchangeAdjustmentTransDate">
    /// The date used to create the new adjustment.
    /// </param>
    /// <param name="_isReversing">
    /// Indicates if this is a reversing adjustment.
    /// </param>
    /// <param name="_useSettingsFromPreviousAdjustment">
    /// True if the exchange adjustment settings from the previous adjustment should be used.
    /// </param>
    public void addExchangeAdjustment(
        AmountMST _accountingCurrencyExchangeAdjustmentAmount,
        AmountMSTSecondary _reportingCurrencyExchangeAdjustmentAmount,
        TransDate _settlementDate,
        TransDate _exchangeAdjustmentTransDate,
        boolean _isReversing,
        boolean _useSettingsFromPreviousAdjustment)
    {
        CustTrans custTrans;
        VendTrans vendTrans;
                
        if (_accountingCurrencyExchangeAdjustmentAmount || _reportingCurrencyExchangeAdjustmentAmount)
        {
            if (custVendTransOpen)
            {
                custVendTransOpen.ExchAdjUnrealized += _accountingCurrencyExchangeAdjustmentAmount;
                custVendTransOpen.ExchAdjUnrealizedReporting += _reportingCurrencyExchangeAdjustmentAmount;
                custVendTransOpen.AmountMST += _accountingCurrencyExchangeAdjustmentAmount;
                custVendTransOpen.ReportingCurrencyAmount += _reportingCurrencyExchangeAdjustmentAmount;
                custVendTransOpen.update();
            }

            CustVendTrans originalCustVendTrans = this.populateOriginalCustVendTransForExchangeAdjustment(
				_accountingCurrencyExchangeAdjustmentAmount,
				_reportingCurrencyExchangeAdjustmentAmount,
				_settlementDate);

            // This update must be called AFTER the creation of the settlement records because those methods
            // depend upon the original value of the originalCustVendTrans table buffer.
            originalCustVendTrans.update();

            TransactionTxt transTxt = this.initExchangeAdjustmentTxt(_settlementDate);

            CustVendTrans newCustVendTrans = this.populateNewCustVendTransForExhangeAdjustment(
				_accountingCurrencyExchangeAdjustmentAmount,
				_reportingCurrencyExchangeAdjustmentAmount,
				_exchangeAdjustmentTransDate,
				_isReversing,
				_useSettingsFromPreviousAdjustment,
				originalCustVendTrans);

            newCustVendTrans.insert();

            if (newCustVendTrans.TableId == tableNum(CustTrans))
            {
                CustTransIdRef::insertForCustTrans(newCustVendTrans, newCustVendTrans.Voucher, CustTransRefType::Other);
            }

            if (newCustVendTrans.SettleAmountCur != 0
                || newCustVendTrans.SettleAmountMST != 0
                || newCustVendTrans.SettleAmountReporting != 0)
            {
                CustVendSettlement newCustVendSettlement = custVendSettlement.data();
                newCustVendSettlement.clear();

                if (newCustVendTrans.TableId == tableNum(CustTrans))
                {
                    // This assignment is necessary because of a kernel bug in IL that
                    // can't handle the implicit cast.
                    custTrans = newCustVendTrans;
                    newCustVendSettlement.initFromCustTrans(custTrans);
                }
                else
                {
                    // This assignment is necessary because of a kernel bug in IL that
                    // can't handle the implicit cast.
                    vendTrans = newCustVendTrans;
                    newCustVendSettlement.initFromVendTrans(vendTrans);
                }

                newCustVendSettlement.insert();
            }

            LedgerDimensionDefaultAccount accountingCurrencyProfitLossAccount = this.getProfitLossAccount(
                _isReversing,
                _accountingCurrencyExchangeAdjustmentAmount,
                newCustVendTrans,
                previousAccountingCurrencyAdjustmentLedgerDimension);

            LedgerDimensionDefaultAccount reportingCurrencyProfitLossAccount = this.getProfitLossAccount(
                _isReversing,
                _reportingCurrencyExchangeAdjustmentAmount,
                newCustVendTrans,
                previousReportingCurrencyAdjustmentLedgerDimension);
            
            this.postToGeneralJournal(
                ledgerVoucher,
                _accountingCurrencyExchangeAdjustmentAmount,
                accountingCurrencyProfitLossAccount,
                _reportingCurrencyExchangeAdjustmentAmount,
                reportingCurrencyProfitLossAccount,
                newCustVendTrans,
                _isReversing,
                _useSettingsFromPreviousAdjustment);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initExchangeAdjustmentTxt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the values of the transaction text.
    /// </summary>
    /// <param name="_settlementDate">
    /// The Settlement Date.
    /// </param>
    /// <returns>
    /// The Adjustment transaction text.
    /// </returns>
    protected TransactionTxt initExchangeAdjustmentTxt(TransDate _settlementDate)
    {
        TransactionTxt transTxt = TransactionTxt::construct();
        transTxt.setType(this.getSubledgerTransactionText());
        transTxt.setLanguage(custVendTrans.languageId());
        transTxt.setVoucher(ledgerVoucher.lastVoucher());
        transTxt.setFormLetter(custVendTrans.Invoice);
        transTxt.setKey1(custVendTrans.AccountNum);

        return transTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addReversalExchangeAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a reversal of an unrealized exchange adjustment.
    /// </summary>
    /// <param name="_accountingCurrencyExchangeAdjustmentAmount">
    /// The accounting currency exchange adjustment.
    /// </param>
    /// <param name="_accountingCurrencyLedgerDimensionProfitLoss">
    /// The accounting currency gain loss ledger dimension default account.
    /// </param>
    /// <param name="_reportingCurrencyExchangeAdjustmentAmount">
    /// The reporting currency exchange adjustment.
    /// </param>
    /// <param name="_reportingCurrencyLedgerDimensionProfitLoss">
    /// The reporting currency gain loss ledger dimension default account.
    /// </param>
    public void addReversalExchangeAdjustment(
        AmountMST _accountingCurrencyExchangeAdjustmentAmount = 0.0,
        LedgerDimensionDefaultAccount _accountingCurrencyLedgerDimensionProfitLoss = 0,
        AmountMST _reportingCurrencyExchangeAdjustmentAmount = 0.0,
        LedgerDimensionDefaultAccount _reportingCurrencyLedgerDimensionProfitLoss = 0)
    {
        LedgerTransType ledgerTransType;
        CustVendTrans localCustVendTrans;
        CustTrans custTrans;
        VendTrans vendTrans;

        switch (exchangeAdjustmentController.module())
        {
            case SysModule::Cust:
                ledgerTransType = LedgerTransType::Cust;
                localCustVendTrans = custTrans;
                break;

            case SysModule::Vend:
                ledgerTransType = LedgerTransType::Vend;
                localCustVendTrans = vendTrans;
                break;
        }

        localCustVendTrans.TransDate = exchangeRateDate;
        localCustVendTrans.CurrencyCode = custVendTrans.CurrencyCode;

        this.postToGeneralJournal(
            ledgerVoucher,
            _accountingCurrencyExchangeAdjustmentAmount,
            _accountingCurrencyLedgerDimensionProfitLoss,
            _reportingCurrencyExchangeAdjustmentAmount,
            _reportingCurrencyLedgerDimensionProfitLoss,
            localCustVendTrans,
            true,
            true,
            ledgerTransType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateFallBackLedgerDimension</Name>
				<Source><![CDATA[
    private LedgerDimensionAccount calculateFallBackLedgerDimension(LedgerDimensionDefaultAccount _currentAdjustmentLedgerDimension)
    {
        LedgerDimensionAccount ledgerDimensionMerged;
        DimensionDefault dimensionsToDefault;
        DimensionDefault defaultDimensionToMerge;

        if (previousDimensionSpecification == NoneTableTrans::Table)
        {
            if (exchangeAdjustmentController.dimSpec() == NoneTableTrans::Table)
            {
                defaultDimensionToMerge = defaultDimension;
            }
            else
            {
                defaultDimensionToMerge = CustVendTransData::construct(custVendTrans).custVendTable().DefaultDimension;
            }

            dimensionsToDefault = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(defaultDimensionToMerge, MainAccountLegalEntity::findByMainAccountLegalEntity(MainAccount::findByLedgerDimension(_currentAdjustmentLedgerDimension).RecId, CompanyInfo::current()).DefaultDimension);
        }
        else
        {
            dimensionsToDefault = 0;
        }

        ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(_currentAdjustmentLedgerDimension, dimensionsToDefault);

        return ledgerDimensionMerged;
    }

]]></Source>
			</Method>
			<Method>
				<Name>end</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts all of the exchange adjustments to the ledger.
    /// </summary>
    public void end()
    {
        ledgerVoucher.end();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldForceSummarySingleDistribution</Name>
				<Source><![CDATA[
    private boolean shouldForceSummarySingleDistribution(boolean _useSettingsFromPreviousAdjustment, boolean _voucherContainsMultipleSummaryEntries)
    {
        boolean forceSummarySingleDistribution;

        if (_voucherContainsMultipleSummaryEntries)
        {
            return true;
        }
        forceSummarySingleDistribution = (this.getDimensionSpecification(_useSettingsFromPreviousAdjustment) != NoneTableTrans::Transaction);

        return forceSummarySingleDistribution;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateDistributionDetails</Name>
				<Source><![CDATA[
    private void generateDistributionDetails(
        List _distributions,
        LedgerPostingType _postToLedgerPostingType,
        LedgerVoucherObject _ledgerVoucherObject,
        LedgerPostingController _ledgerPostingController,
        boolean _skipDimensionValidation,
        CustVendExchAdjType _custVendExchAdjType,
        boolean _applyDefaultDimensions = false)
    {
        CustVendTransDistribution distribution;
        LedgerVoucherTransObject ledgerVoucherTransObject;

        DimensionDefault custVendDefaultDimension;
        if (_applyDefaultDimensions)
        {
            custVendDefaultDimension = CustVendTable::getDefaultDimension(this.getModule(), custVendTrans.AccountNum);
        }

        // Generate a trans for each of the distributions
        ListEnumerator distributionEnumerator = _distributions.getEnumerator();
        while (distributionEnumerator.moveNext())
        {
            distribution = distributionEnumerator.current();
            LedgerDimensionAccount ledgerDimension = distribution.ledgerDimension();

            if (_applyDefaultDimensions)
            {
                DimensionDefault mainAccountDefaultDimension = MainAccountLegalEntity::findByMainAccountLegalEntity(
                    LedgerDimensionFacade::getMainAccountRecIdFromLedgerDimension(ledgerDimension),
                    CompanyInfo::current()).DefaultDimension;

                ledgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(
                    ledgerDimension,
                    custVendTrans.DefaultDimension,
                    custVendDefaultDimension,
                    mainAccountDefaultDimension);
            }

            if (distribution.accountingAmount())
            {
                ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(
                    _ledgerVoucherObject,
                    _postToLedgerPostingType,
                    ledgerDimension,
                    custVendTrans.CurrencyCode,
                    distribution.accountingAmount(),
                    0);

                // It is possible that the account structure and/or allowable dimensions could have changed
                // since the summary account was first posted. As a result it is necessary to disable dimension
                // validation.
                ledgerVoucherTransObject.parmSkipDimensionValidation(_skipDimensionValidation);

                if (_custVendExchAdjType == CustVendExchAdjType::NewAdjustment)
                {
                    ledgerVoucherTransObject.parmIsExchangeAdjustment(NoYes::Yes);
                }

                _ledgerPostingController.addTrans(ledgerVoucherTransObject);
            }

            if (distribution.reportingAmount())
            {
                ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(
                    _ledgerVoucherObject,
                    _postToLedgerPostingType,
                    ledgerDimension,
                    custVendTrans.CurrencyCode,
                    0,
                    distribution.reportingAmount());

                // It is possible that the account structure and/or allowable dimensions could have changed
                // since the summary account was first posted. As a result it is necessary to disable dimension
                // validation.
                ledgerVoucherTransObject.parmSkipDimensionValidation(_skipDimensionValidation);

                if (_custVendExchAdjType == CustVendExchAdjType::NewAdjustment)
                {
                    ledgerVoucherTransObject.parmIsExchangeAdjustment(NoYes::Yes);
                }

                _ledgerPostingController.addTrans(ledgerVoucherTransObject);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateDistributionsForPostingTypes</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Generates distributions.
    /// </summary>
    /// <param name="_ledgerPostingTypes">
    ///  The ledger posting types to find the expense or summary accounting entries of the document that is being revalued.
    /// </param>
    /// <param name="_postToLedgerPostingType">
    ///  The ledger posting type for the new accounting entries that are created from the currency revaluation.
    /// </param>
    /// <param name="_accountingCurrencyExchangeAdjustmentAmount">
    ///  The accounting currency exchange adjustment.
    /// </param>
    /// <param name="_reportingCurrencyExchangeAdjustmentAmount">
    ///  The reporting currency exchange adjustment.
    /// </param>
    /// <param name="_ledgerVoucherObject">
    ///  The ledger voucher object to post the new currency revaluation.
    /// </param>
    /// <param name="_ledgerPostingController">
    ///  The ledger posting control to post the new currency revaluation.
    /// </param>
    /// <param name="_defaultLedgerDimension">
    ///  The default ledger dimension to post the new currency revaluation.
    /// </param>
    /// <param name="_forceSingleDistribution">
    ///  True if the exchange adjustment should be posted to the _defaultLedgerDimension; otherwise the accounting entries of the
    ///  document that is being revalued will be used.
    /// </param>
    /// <param name="_mergeDefaultWithOriginalDimension">
    ///  True if the _defaultLedgerDimension should be merged with the dimensions from the document that is being revalued.
    /// </param>
    /// <param name="_skipDimensionValidation">
    ///  True will turn off dimension validation; otherwise dimensions will be validated.
    /// </param>
    /// <param name="_custVendExchAdjType">
    ///  Identfies new currency revaluation adjustments and the reversal of a prior currency revaluation.
    /// </param>
    /// <param name="_applyDefaultDimensions">
    ///  Specifies whether default dimensions should be applied; optional.
    /// </param>
    protected void generateDistributionsForPostingTypes(
        List _ledgerPostingTypes,
        LedgerPostingType _postToLedgerPostingType,
        AmountMST _accountingCurrencyExchangeAdjustmentAmount,
        AmountMST _reportingCurrencyExchangeAdjustmentAmount,
        LedgerVoucherObject _ledgerVoucherObject,
        LedgerPostingController _ledgerPostingController,
        LedgerDimensionAccount _defaultLedgerDimension,
        boolean _forceSingleDistribution,
        boolean _mergeDefaultWithOriginalDimension,
        boolean _skipDimensionValidation,
        CustVendExchAdjType _custVendExchAdjType,
        boolean _applyDefaultDimensions = false)
    {
        // get the set of LedgerDimension/Amount values to be posted
        List distributions = distributionController.generateDistributionsForPostingTypes(
            custVendTrans,
            _ledgerPostingTypes,
            0, // currency adjustments do not affect transaction currency value
            _accountingCurrencyExchangeAdjustmentAmount,
            _reportingCurrencyExchangeAdjustmentAmount,
            _defaultLedgerDimension,
            _forceSingleDistribution,
            _mergeDefaultWithOriginalDimension);

        this.generateDistributionDetails(distributions,
            _postToLedgerPostingType,
            _ledgerVoucherObject,
            _ledgerPostingController,
            _skipDimensionValidation,
            _custVendExchAdjType,
            _applyDefaultDimensions);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendExchAdjType</Name>
				<Source><![CDATA[
    private CustVendExchAdjType getCustVendExchAdjType(
        boolean _useSettingsFromPreviousAdjustment,
        boolean _isReversing)
    {
        CustVendExchAdjType custVendExchAdjType;

        if (_useSettingsFromPreviousAdjustment || _isReversing)
        {
            custVendExchAdjType = CustVendExchAdjType::ReversalAdjustment;
        }
        else
        {
            custVendExchAdjType = CustVendExchAdjType::NewAdjustment;
        }

        // invoice approval journal will add a new currency revaluation.
        // it wants to use the settings from the previous adjustment, but it is not reversing. 
        if (_useSettingsFromPreviousAdjustment && !_isReversing && !skipUseLedgerVoucherChanged)
        {
            custVendExchAdjType = CustVendExchAdjType::NewAdjustment;
        }

        return custVendExchAdjType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimensionSpecification</Name>
				<Source><![CDATA[
    private NoneTableTrans getDimensionSpecification(boolean _useSettingsFromPreviousAdjustment)
    {
        if (_useSettingsFromPreviousAdjustment)
        {
            return previousDimensionSpecification;
        }
        else
        {
            return exchangeAdjustmentController.dimSpec();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the last voucher.
    /// </summary>
    /// <returns>
    /// The last voucher.
    /// </returns>
    public Voucher getLastVoucher()
    {
        return ledgerVoucher.lastVoucher();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrencyGainLossAccountTypeForExchangeAdjustment</Name>
				<Source><![CDATA[
	/// <summary>
    /// Gets the <c>CurrencyGainLossAccountType</c> enumeration value for the exchange adjustment.
    /// </summary>
    /// <param name = "_exchangeAdjustment">The exchange adjustment amount.</param>
    /// <param name = "_isReversing">true if the current exchange adjustment is a reversing transaction; otherwise, false.</param>
    /// <returns>The <c>CurrencyGainLossAccountType</c> enumeration value for the exchange adjustment.</returns>
    protected CurrencyGainLossAccountType getCurrencyGainLossAccountTypeForExchangeAdjustment(Amount _exchangeAdjustment, boolean _isReversing)
    {
        CurrencyGainLossAccountType accountType;

        if (this.getLedgerPostingType(_exchangeAdjustment, _isReversing) == LedgerPostingType::ExchRateGain)
        {
            accountType = CurrencyGainLossAccountType::UnrealizedGain;
        }
        else
        {
            accountType = CurrencyGainLossAccountType::UnrealizedLoss;
        }

        return accountType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionUnrealizedProfitLoss</Name>
				<Source><![CDATA[
	/// <summary>
    /// Gets the <c>LedgerDimensionDefaultAccount</c> value for the unrealized profit/loss on the exchange adjustment.
    /// </summary>
    /// <param name = "_exchangeAdjustment">The exchange adjustment amount.</param>
    /// <param name = "_currencyCode">The currency code for the exchange adjustment.</param>
    /// <param name = "_isReversing">true if the current exchange adjustment is a reversing transaction; otherwise, false.</param>
    /// <returns>The <c>LedgerDimensionDefaultAccount</c> value for the unrealized profit/loss on the exchange adjustment.</returns>
    protected LedgerDimensionDefaultAccount getLedgerDimensionUnrealizedProfitLoss(
        Amount _exchangeAdjustment,
        CurrencyCode _currencyCode,
        boolean _isReversing)
    {
        LedgerDimensionDefaultAccount defaultLedgerDimension;

        if (_exchangeAdjustment)
        {
            CurrencyGainLossAccountType accountType = this.getCurrencyGainLossAccountTypeForExchangeAdjustment(_exchangeAdjustment, _isReversing);

            defaultLedgerDimension = this.getDefaultLedgerDimensionUnrealizedProfitLoss(
                _exchangeAdjustment,
                _currencyCode,
                accountType);

            if (!defaultLedgerDimension)
            {
                checkFailed(strFmt("@SYS26452", _currencyCode));
            }
        }

        return defaultLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultLedgerDimensionUnrealizedProfitLossFromPostingProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension account for unrealized profit loss from posting profile.
    /// </summary>
    /// <param name = "_isCustTrans">True, if the current exchange adjustment is for CustTrans; False, otherwise.</param>
    /// <param name = "_exchangeAdjustment">The exchange adjustment amount.</param>
    /// <param name = "_isReversing">True, if the current exchange adjustment is a reversing transaction; False, otherwise.</param>
    /// <param name = "_currencyCode">The currency code for the exchange adjustment.</param>
    /// <param name = "_accountNum">The account number for the exchange adjustment.</param>
    /// <returns>
    /// The ledger dimension account.
    /// </returns>
    protected LedgerDimensionDefaultAccount getDefaultLedgerDimensionUnrealizedProfitLossFromPostingProfile(
        boolean _isCustTrans,
        Amount _exchangeAdjustment,
        boolean _isReversing,
        CurrencyCode _currencyCode, 
        CustVendAC _accountNum)
    {
        LedgerDimensionDefaultAccount defaultLedgerDimension;

        if (_exchangeAdjustment)
        {
            LedgerExchAdjPostingModule module = _isCustTrans ? LedgerExchAdjPostingModule::AccountsReceivable : LedgerExchAdjPostingModule::AccountsPayable;
            CurrencyGainLossAccountType accountType = this.getCurrencyGainLossAccountTypeForExchangeAdjustment(_exchangeAdjustment, _isReversing);

            defaultLedgerDimension = LedgerExchAdjPosting::getLedgerDimensionFromParameters(
                LedgerExchAdjPostingSearchParameters::newFromParameters(
                    module,
                    accountType,
                    _currencyCode,
                    _accountNum));
        }

        return defaultLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultLedgerDimensionUnrealizedProfitLoss</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension account for unrealized profit loss.
    /// </summary>
    /// <param name="_exchangeAdjustment">
    /// The exchange rate adjustment amount.
    /// </param>
    /// <param name="_currencyCode">
    /// The Currency code.
    /// </param>
    /// <param name="_accountType">
    /// The Account type.
    /// </param>
    /// <returns>
    /// The ledger dimension account.
    /// </returns>
    protected LedgerDimensionDefaultAccount getDefaultLedgerDimensionUnrealizedProfitLoss(Amount _exchangeAdjustment, CurrencyCode _currencyCode, CurrencyGainLossAccountType _accountType)
    {
        return CurrencyLedgerGainLossAccount::ledgerDimension(
            Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
            _currencyCode,
            _accountType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerPostingController</Name>
				<Source><![CDATA[
    private LedgerPostingController getLedgerPostingController(LedgerVoucher _ledgerVoucher, TransDate _transDate, LedgerTransType _ledgerTransType)
    {
        LedgerPostingController ledgerPostingController = LedgerPostingController::newForLedgerPostingJournal(_ledgerVoucher);
        LedgerVoucherObject ledgerVoucherObject = ledgerPostingController.getReference();

        Voucher originalReferenceNumber = ledgerVoucherObject.parmReferenceNumber();
        TransDate originalAccountingDate = ledgerVoucherObject.parmAccountingDate();
        TransTxt originalTransTxt = ledgerVoucherObject.lastTransTxt();

        if (originalAccountingDate != _transDate)
        {
            // Search for and update the posting reference (LedgerVoucherObject).
            boolean isFound = ledgerPostingController.findReference(originalReferenceNumber, _transDate);

            if (!isFound)
            {
                // No posting reference exists, so it needs to be created.
                ledgerVoucherObject = LedgerVoucherObject::newVoucher(
                    originalReferenceNumber,
                    _transDate,
                    exchangeAdjustmentController.module(),
                    _ledgerTransType);

                ledgerPostingController.addReference(ledgerVoucherObject);
            }
            // Transaction text on the LedgerVoucherObject is normally set in the calling method.
            // Because a different posting reference is used, make sure this has the correct transaction text.
            ledgerVoucherObject.lastTransTxt(originalTransTxt);
        }

        return ledgerPostingController;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerPostingType</Name>
				<Source><![CDATA[
    protected LedgerPostingType getLedgerPostingType(Amount _exchangeAdjustment, boolean _isReversing)
    {
        LedgerPostingType ledgerPostingType;

        // The following logic works for both AR and AP because of the fact that the customer balance is
        // a positive amount and the vendor balance is a negative amount.

        // A customer example is an invoice posted on 1/1 for 100. If the exchange rate changes such that
        // on 2/1 it was now worth 250, that would be a 150 gain in what we would get from the customer.
        // This is calculated by taking 250 - 100. The result here would be 150 which would increase the
        // amount of money we would receive from the customer.

        // A vendor example is an invoice posted on 1/1 for -100. (Notice the negative balance.) If the
        // exchange rate changes such that on 2/1 it was now worth -250, that would be a 150 loss in what
        // we have to pay the vendor. This is calculated by taking -250 - (-100). The result here would be
        //  -150 which would increase the amount we need to pay to the vendor.

        if (_exchangeAdjustment)
        {
            if (_isReversing)
            {
                ledgerPostingType = _exchangeAdjustment > 0 ? LedgerPostingType::ExchRateLoss : LedgerPostingType::ExchRateGain;
            }
            else
            {
                ledgerPostingType = _exchangeAdjustment > 0 ? LedgerPostingType::ExchRateGain : LedgerPostingType::ExchRateLoss;
            }
        }

        return ledgerPostingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerTransactionText</Name>
				<Source><![CDATA[
    abstract protected LedgerTransTxt getLedgerTransactionText()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getModule</Name>
				<Source><![CDATA[
    protected abstract ModuleCustVend getModule()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumberSequence</Name>
				<Source><![CDATA[
    abstract protected NumberSequenceReference getNumberSequence()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOriginalGainLossPostingAccountTypes</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Gets a list of ledger posting types from the original document.
    /// </summary>
    /// <returns>
    ///  A list of ledger posting types.
    /// </returns>
    protected abstract List getOriginalGainLossPostingAccountTypes()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPostingProfile</Name>
				<Source><![CDATA[
    protected PostingProfile getPostingProfile(boolean _useSettingsFromPreviousAdjustment)
    {
        if (_useSettingsFromPreviousAdjustment)
        {
            return previousPostingProfile;
        }
        else
        {
            return postingProfile;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSubledgerTransactionText</Name>
				<Source><![CDATA[
    abstract protected LedgerTransTxt getSubledgerTransactionText()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSummaryLedgerDimension</Name>
				<Source><![CDATA[
    protected abstract LedgerDimensionDefaultAccount getSummaryLedgerDimension(CustVendAC _custVendAC, PostingProfile _postingProfile)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSummaryPostingAccountType</Name>
				<Source><![CDATA[
    protected abstract LedgerPostingType getSummaryPostingAccountType()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Initializes the <c>CustVendExchAdjPostingEngine</c> instance.
    /// </summary>
    /// <param name="_exchangeAdjustmentController">
    ///  The exchange adjustment controller.
    /// </param>
    /// <param name="_exchangeRateDate">
    ///  The date of the exchange rate.
    /// </param>
    /// <param name="_custVendTrans">
    ///  The original document that is being revalued.
    /// </param>
    /// <param name="_custVendTransOpen">
    ///  The open transaction information for the original document that is being revalued.
    /// </param>
    /// <param name="_custVendSettlement">
    ///  The settlement information for the original document that is being revalued.
    /// </param>
    /// <param name="_lastExchangeAdjustmentHistory">
    ///  A map that tracks the last exchagne adjustment information.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///  The <c>LedgerVoucher</c> object to use for posting.
    /// </param>
    /// <param name="_isSettleByLineEnabled">
    ///  A boolean value that identifies when line level settlement should be performed; optional.
    /// </param>
    /// <param name="_debitSpecTransRecId">
    ///  Identfies the invoice line that is being settled; optional.
    /// </param>
    protected void init(
        CustVendExchAdj _exchangeAdjustmentController,
        TransDate _exchangeRateDate,
        CustVendTrans _custVendTrans,
        CustVendTransOpen _custVendTransOpen,
        CustVendSettlement _custVendSettlement,
        Map _lastExchangeAdjustmentHistory,
        LedgerVoucher _ledgerVoucher,
        boolean _isSettleByLineEnabled = false,
        RefRecId _debitSpecTransRecId = 0)
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        LedgerPostingType previousAccountingCurrencyAdjustmentLedgerPostingType, previousReportingCurrencyAdjustmentLedgerPostingType;
        CurrencyExchangeRate lastTransactionToAccountingCrossRate;
        AmountMST lastAccountingCurrencyAmount;
        AmountMSTSecondary lastReportingCurrencyAmount;
        AmountMST lastAccountingCurrencyAdjustmentEstimation;
        AmountMSTSecondary lastReportingCurrencyAdjustmentEstimation;
        Voucher lastExchAdjVoucher;
        CurrencyExchangeRate lastExchAdjRate;
        CurrencyExchangeRate lastExchAdjRateReporting;
        CurrencyExchangeHelper currencyExchangeHelper;
        LedgerRecId currentLedgerRecId;
        CustVendTransSettleDistController settleDistributionController;
        CustTransMarkedOpenLine custTransMarkedOpenLine;

        // Set class variables
        exchangeAdjustmentController = _exchangeAdjustmentController;

        exchangeRateDate = _exchangeRateDate;

        custVendTrans = _custVendTrans;
        custVendTransOpen = _custVendTransOpen;
        custVendSettlement = _custVendSettlement;

        currentLedgerRecId = Ledger::current();

        isCustVendExchAdjLedgerDimensionFlightEnabled = CustVendExchAdjLedgerDimensionFlight::instance().isEnabled();

        previousAccountingCurrencyAdjustmentLedgerDimension = 0;
        previousReportingCurrencyAdjustmentLedgerDimension = 0;

        if (countryRegion_RUCZ)
        {
            distributionController = CustVendTransDistributionController::construct();
        }
        else
        {
            if (_isSettleByLineEnabled)
            {
                select firstonly RecId from custTransMarkedOpenLine
                    where custTransMarkedOpenLine.SpecTrans == _debitSpecTransRecId;

                if (custTransMarkedOpenLine)
                {
                    settleDistributionController = CustVendTransSettleDistController::construct(_isSettleByLineEnabled);
                    settleDistributionController.parmSpecTransId(_debitSpecTransRecId);

                    distributionController = settleDistributionController;
                }
            }

            if (!distributionController)
            {
                distributionController = CustVendTransExchAdjDistController::construct();
            }
        }

        if (exchangeAdjustmentController.postingSpec() == TransactionSelect::Transaction)
        {
            postingProfile = custVendTrans.PostingProfile;
        }
        else
        {
            postingProfile = exchangeAdjustmentController.postingProfile();
        }

        switch (exchangeAdjustmentController.dimSpec())
        {
            case NoneTableTrans::None:
                defaultDimension = 0;
                break;

            case NoneTableTrans::Table:
                defaultDimension = CustVendTransData::construct(custVendTrans).custVendTable().DefaultDimension;
                break;

            case NoneTableTrans::Transaction:
                defaultDimension = custVendTrans.DefaultDimension;
                break;
        }

        ledgerVoucher = _ledgerVoucher;
        if (!ledgerVoucher)
        {
            // Create ledgerVoucher controller
            NumberSeq numberSequence = NumberSeq::newGetVoucher(this.getNumberSequence());
            Voucher voucher = numberSequence.voucher();

            TransactionTxt transactionTextVoucher = TransactionTxt::construct();
            transactionTextVoucher.setType(this.getLedgerTransactionText());
            transactionTextVoucher.setVoucher(voucher);
            transactionTextVoucher.setFormLetter(_custVendTrans.Invoice);
            transactionTextVoucher.setKey1(_custVendTrans.AccountNum);

            ledgerVoucher = LedgerVoucher::newLedgerPost(
                DetailSummary::Detail,
                exchangeAdjustmentController.module(),
                numberSequence.parmVoucherSequenceCode());

            ledgerVoucher.parmCheckBlockedDimensions(false);

            ledgerVoucher.addVoucher(
                LedgerVoucherObject::newVoucher(
                    voucher,
                    exchangeAdjustmentController.postingDate(),
                    exchangeAdjustmentController.module(),
                    LedgerTransType::ExchAdjustment));

            ledgerVoucher.findLedgerVoucherObject().lastTransTxt(transactionTextVoucher.txt(exchangeAdjustmentController.transExchAdjTxt()));
        }

        // Determine what parameters were used on the last adjustment for this transaction. This information can be used
        // to short-circuit certain logic and save time. Also determine the previous ledger dimension that was used
        // so it can be properly reversed.

        // We can't rely on the LastExch* information on custVendTrans since it can be updated multiple times throughout
        // the exchange adjustment process in a partial settlement scenario. (The same transaction is processed as part
        // of the settlement logic and then the open logic.)  The following code will cache the information from the first
        // touch to ensure the original LastExch* information is always used.
        if (_lastExchangeAdjustmentHistory.exists(custVendTrans.RecId))
        {
            [lastExchAdjVoucher, lastExchAdjDate, lastExchAdjRate, lastExchAdjRateReporting] =
                _lastExchangeAdjustmentHistory.lookup(custVendTrans.RecId);
        }
        else
        {
            lastExchAdjVoucher = custVendTrans.LastExchAdjVoucher;
            lastExchAdjDate = custVendTrans.LastExchAdj;
            lastExchAdjRate = custVendTrans.LastExchAdjRate;
            lastExchAdjRateReporting = custVendTrans.LastExchAdjRateReporting;

            _lastExchangeAdjustmentHistory.insert(
                CustVendTrans.RecId,
                [lastExchAdjVoucher, lastExchAdjDate, lastExchAdjRate, lastExchAdjRateReporting]);
        }

        // Only attempt to retrieve this information if a previous adjustment exists
        if (strLen(lastExchAdjVoucher) > 0)
        {
            // Get the previous created transaction id from the last adjustment transaction that was created
            previousCreatedTransactionId = CustVendExchAdjPostingEngine::getPrevCreatedTransactionId(this.getModule(), lastExchAdjVoucher, lastExchAdjDate);

            doesLedgerEntryIsExchangeAdjustmentExist = CustVendExchAdjPostingEngine::doesLedgerEntryIsExchangeAdjustmentExist(previousCreatedTransactionId);

            // Attempt to retrieve the previous exchange adjustment settings.
            CustVendExchRateAdjustment custVendExchRateAdjustment = CustVendExchRateAdjustment::getEmptyTableBuffer(this.getModule());

            select firstonly Dimensions, PostingProfile, UseProfile, CreatedTransactionId, ExchPrinciple from custVendExchRateAdjustment
                order by RecId desc
                where custVendExchRateAdjustment.CreatedTransactionId == previousCreatedTransactionId;

            // A currency revaluation can be done between an vendor invoice register and an invoice approval.  When the invoice approval is posted, it
            // will create a currency revaluation.  Now the last exchange information points to the invoice approval.  We need to use the invoice register to find the
            // the invoice register was revalued so we can correctly reverse off the approval journal currency revaulation.
            if (!custVendExchRateAdjustment && this.getModule() == ModuleCustVend::Vend)
            {
                LedgerJournalVoucherChanged ledgerJournalVoucherChanged;
                
                select ledgerJournalVoucherChanged
                    where ledgerJournalVoucherChanged.FromDate == custVendTrans.TransDate
                        && ledgerJournalVoucherChanged.FromVoucher == custVendTrans.Voucher;

                if (ledgerJournalVoucherChanged)
                {
                    VendTrans invoiceRegisterCurrencyRevaluation;

                    while select invoiceRegisterCurrencyRevaluation
                        order by invoiceRegisterCurrencyRevaluation.RecId desc
                        where invoiceRegisterCurrencyRevaluation.AccountNum == _custVendTrans.AccountNum
                            && invoiceRegisterCurrencyRevaluation.Invoice == _custVendTrans.Invoice
                            && invoiceRegisterCurrencyRevaluation.TransDate >= _custVendTrans.TransDate
                            && invoiceRegisterCurrencyRevaluation.Voucher != ledgerJournalVoucherChanged.FromVoucher
                            && invoiceRegisterCurrencyRevaluation.Voucher != ledgerJournalVoucherChanged.ToVoucher
                            && invoiceRegisterCurrencyRevaluation.TransType == LedgerTransType::ExchAdjustment

                    {
                        doesLedgerEntryIsExchangeAdjustmentExist = CustVendExchAdjPostingEngine::doesLedgerEntryIsExchangeAdjustmentExist(invoiceRegisterCurrencyRevaluation.CreatedTransactionId);
                  
                        select firstonly Dimensions, PostingProfile, UseProfile, CreatedTransactionId, ExchPrinciple from custVendExchRateAdjustment
                            order by RecId desc
                            where custVendExchRateAdjustment.CreatedTransactionId == invoiceRegisterCurrencyRevaluation.CreatedTransactionId;

                        if (custVendExchRateAdjustment)
                        {
                            break;
                        }
                    }

                }
            }

            if (custVendExchRateAdjustment != null)
            {
                if (custVendExchRateAdjustment.UseProfile == TransactionSelect::Transaction)
                {
                    previousPostingProfile = custVendTrans.PostingProfile;
                }
                else
                {
                    previousPostingProfile = custVendExchRateAdjustment.PostingProfile;
                }

                previousDimensionSpecification = custVendExchRateAdjustment.Dimensions;

                previousExchangePrinciple = custVendExchRateAdjustment.ExchPrinciple;
            }
            else
            {
                // Unable to find the settings from the previuos adjustment, so use the current settings.
                previousPostingProfile = postingProfile;
                previousDimensionSpecification = exchangeAdjustmentController.dimSpec();
            }

            // Due to dimension defaulting and the ability to change the account structure, gain/loss account, or other default
            // dimenaions on the customer/vendor and main account, it is necessary to retreive the actual dimensions used when
            // backing out previous adjustments. These can be different for the accounting and reporting currency gain/loss
            // accounts so they must be retrieved for each separately.

            // To do this, the CreatedTransactionId will be used to find all of the general journal account entry records
            // from the previous adjustment. From there, it is possible to determine if the last adjustment was a gain
            // or loss looking at the exchange rates invovled. With that information and an understanding about the sign
            // of the amounts, the proper account entry records can be retireved to get the ledger dimension.

            // Get the accounting gain/loss dimension from the last adjustment
            if (lastExchAdjRate)
            {
                // Re-calculate the last accounting currency exchange adjustment. It may not be exact due to
                // partial settlements, but it will provide enough information to determine if it was a gain
                // or a loss which is all that is required.

                // It is important to use the Currency APIs since it handles various to/from currency scenarios
                // appropriately factoring in the accounting currency changes as well. This also handles scenarios
                // where negative value documents are involved such as an AP invoice or AR payment.

                currencyExchangeHelper = CurrencyExchangeHelper::newLedger(Ledger::current());
                currencyExchangeHelper.parmExchangeRate1(lastExchAdjRate);
                currencyExchangeHelper.parmExchangeRate2(0);
                lastAccountingCurrencyAmount = currencyExchangeHelper.calculateTransactionToAccounting(
                    custVendTrans.CurrencyCode,
                    custVendTrans.AmountCur,
                    true);

                lastAccountingCurrencyAdjustmentEstimation = lastAccountingCurrencyAmount - custVendTrans.AmountMST;

                if (lastAccountingCurrencyAdjustmentEstimation != 0)
                {
                    previousAccountingCurrencyAdjustmentLedgerPostingType = this.getLedgerPostingType(
                        lastAccountingCurrencyAdjustmentEstimation,
                        false);

                    if (previousAccountingCurrencyAdjustmentLedgerPostingType == LedgerPostingType::ExchRateGain)
                    {
                        // We don't include a GJAE.CreatedTransactionId range becase we want to force SQL to start with
                        // the GJE index which will normally get us to the record we want faster. More GJAE ranges may
                        // encourage SQL to start with a GJAE index which is rarely faster.
                        select firstOnly LedgerDimension from generalJournalAccountEntry
                            where generalJournalAccountEntry.PostingType == LedgerPostingType::ExchRateGain
                                && generalJournalAccountEntry.AccountingCurrencyAmount < 0
                            exists join generalJournalEntry
                                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                                    && generalJournalEntry.createdTransactionId == previousCreatedTransactionId
                                    && generalJournalEntry.Ledger == currentLedgerRecId
                                    && generalJournalEntry.AccountingDate == lastExchAdjDate
                                    && generalJournalEntry.SubledgerVoucher == lastExchAdjVoucher;
                    }
                    else
                    {
                        // We don't include a GJAE.CreatedTransactionId range becase we want to force SQL to start with
                        // the GJE index which will normally get us to the record we want faster. More GJAE ranges may
                        // encourage SQL to start with a GJAE index which is rarely faster.
                        select firstOnly LedgerDimension from generalJournalAccountEntry
                            where generalJournalAccountEntry.PostingType == LedgerPostingType::ExchRateLoss
                                && generalJournalAccountEntry.AccountingCurrencyAmount > 0
                            exists join generalJournalEntry
                                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                                    && generalJournalEntry.createdTransactionId == previousCreatedTransactionId
                                    && generalJournalEntry.Ledger == currentLedgerRecId
                                    && generalJournalEntry.AccountingDate == lastExchAdjDate
                                    && generalJournalEntry.SubledgerVoucher == lastExchAdjVoucher;
                   }

                   previousAccountingCurrencyAdjustmentLedgerDimension = generalJournalAccountEntry.LedgerDimension;
                }
            }

            // Get the reporting gain/loss dimension from the last adjustment
            if (lastExchAdjRateReporting)
            {
                // Re-calculate the last reporting currency exchange adjustment. It may not be exact due to
                // partial settlements, but it will provide enough information to determine if it was a gain
                // or a loss which is all that is required.

                // It is important to use the Currency APIs since it handles various to/from currency scenarios
                // appropriately factoring in the accounting currency changes as well. This also handles scenarios
                // where negative value documents are involved such as an AP invoice or AR payment.

                currencyExchangeHelper = CurrencyExchangeHelper::newLedger(Ledger::current());
                currencyExchangeHelper.parmReportingExchangeRate1(lastExchAdjRateReporting);

                lastReportingCurrencyAmount = currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(
                    custVendTrans.CurrencyCode,
                    custVendTrans.AmountCur);

                lastReportingCurrencyAdjustmentEstimation = lastReportingCurrencyAmount - custVendTrans.ReportingCurrencyAmount;

                if (lastReportingCurrencyAdjustmentEstimation != 0)
                {
                    previousReportingCurrencyAdjustmentLedgerPostingType = this.getLedgerPostingType(
                        lastReportingCurrencyAdjustmentEstimation,
                        false);

                    if (previousReportingCurrencyAdjustmentLedgerPostingType == LedgerPostingType::ExchRateGain)
                    {
                        // We don't include a GJAE.CreatedTransactionId range becase we want to force SQL to start with
                        // the GJE index which will normally get us to the record we want faster. More GJAE ranges may
                        // encourage SQL to start with a GJAE index which is rarely faster.
                        select firstOnly LedgerDimension from generalJournalAccountEntry
                            where generalJournalAccountEntry.PostingType == LedgerPostingType::ExchRateGain
                                && generalJournalAccountEntry.ReportingCurrencyAmount < 0
                            exists join generalJournalEntry
                                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                                    && generalJournalEntry.createdTransactionId == previousCreatedTransactionId
                                    && generalJournalEntry.Ledger == currentLedgerRecId
                                    && generalJournalEntry.AccountingDate == lastExchAdjDate
                                    && generalJournalEntry.SubledgerVoucher == lastExchAdjVoucher;
                    }
                    else
                    {
                        // We don't include a GJAE.CreatedTransactionId range becase we want to force SQL to start with
                        // the GJE index which will normally get us to the record we want faster. More GJAE ranges may
                        // encourage SQL to start with a GJAE index which is rarely faster.
                        select firstOnly LedgerDimension from generalJournalAccountEntry
                            where generalJournalAccountEntry.PostingType == LedgerPostingType::ExchRateLoss
                                && generalJournalAccountEntry.ReportingCurrencyAmount > 0
                            exists join generalJournalEntry
                                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                                    && generalJournalEntry.createdTransactionId == previousCreatedTransactionId
                                    && generalJournalEntry.Ledger == currentLedgerRecId
                                    && generalJournalEntry.AccountingDate == lastExchAdjDate
                                    && generalJournalEntry.SubledgerVoucher == lastExchAdjVoucher;
                    }

                    previousReportingCurrencyAdjustmentLedgerDimension = generalJournalAccountEntry.LedgerDimension;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reload</Name>
				<Source><![CDATA[
    internal void reload(
        CustVendExchAdj _exchangeAdjustmentController,
        TransDate _exchangeRateDate,
        CustVendTrans _custVendTrans,
        CustVendTransOpen _custVendTransOpen,
        CustVendSettlement _custVendSettlement,
        Map _lastExchangeAdjustmentHistory,
        LedgerVoucher _ledgerVoucher)
    {
        this.init(
            _exchangeAdjustmentController,
            _exchangeRateDate,
            _custVendTrans,
            _custVendTransOpen,
            _custVendSettlement,
            _lastExchangeAdjustmentHistory,
            _ledgerVoucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPreviousRevaluationReversal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the previous currency revaluation was a reversal (Invoice Date).
    /// </summary>
    /// <returns>
    /// true if the previous currency revaluation was a reversal; otherwise, false.
    /// </returns>
    public boolean isPreviousRevaluationReversal()
    {
        return previousExchangePrinciple == CustVendExchPrinciples::InvDatePrinciple;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeProfitLossLedgerDimension</Name>
				<Source><![CDATA[
    protected LedgerDimensionAccount mergeProfitLossLedgerDimension(
        boolean _useSettingsFromPreviousAdjustment,
        LedgerDimensionDefaultAccount _previousAdjustmentLedgerDimension,
        LedgerDimensionDefaultAccount _currentAdjustmentLedgerDimension,
        boolean _isReversing = false)
    {
        LedgerDimensionAccount ledgerDimensionMerged;
        DimensionDefault dimensionsToDefault;
        DimensionDefault localDefaultDimension;

        if (_useSettingsFromPreviousAdjustment)
        {
            // We are reversing a previous adjustment

            // Get the exact dimensions used when the last adjustment was posted so they can be reversed
            // correctly. No new defaulting should be done in this case. This covers cases where the gain/loss
            // accounts have changed, the account structure has changed, or dimension defaults have changed.
            if (countryRegion_RUCZ || (_isReversing && !doesLedgerEntryIsExchangeAdjustmentExist))
            {
                ledgerDimensionMerged = _previousAdjustmentLedgerDimension;

                if (!ledgerDimensionMerged)
                {
                    ledgerDimensionMerged = this.calculateFallBackLedgerDimension(_currentAdjustmentLedgerDimension);
                }
            }
            else
            {
                if (previousDimensionSpecification == NoneTableTrans::Table)
                {
                    if (exchangeAdjustmentController.dimSpec() == NoneTableTrans::Table)
                    {
                        localDefaultDimension = defaultDimension;
                    }
                    else
                    {
                        localDefaultDimension = CustVendTransData::construct(custVendTrans).custVendTable().DefaultDimension;
                    }

                    // When using the Table dimension default, also attempt to default the dimensions from the main account.
                    dimensionsToDefault = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(localDefaultDimension, MainAccountLegalEntity::findByMainAccountLegalEntity(MainAccount::findByLedgerDimension(_currentAdjustmentLedgerDimension).RecId, CompanyInfo::current()).DefaultDimension);
                }
                else
                {
                    dimensionsToDefault = 0;
                }

                ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(_currentAdjustmentLedgerDimension, dimensionsToDefault);
            }
        }
        else
        {
            // We are posting a new adjustment

            if (exchangeAdjustmentController.dimSpec() == NoneTableTrans::Table)
            {
                // When using the Table dimension default, also attempt to default the dimensions from the main account.
                dimensionsToDefault = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(defaultDimension, MainAccountLegalEntity::findByMainAccountLegalEntity(MainAccount::findByLedgerDimension(_currentAdjustmentLedgerDimension).RecId, CompanyInfo::current()).DefaultDimension);
            }
            else
            {
                if (countryRegion_RUCZ)
                {
                    dimensionsToDefault = defaultDimension;
                }
                else
                {
                    //Reset to zero because None is already 0 and Posting we will look up so this does not apply.
                    dimensionsToDefault = 0;
                }
            }

            ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(_currentAdjustmentLedgerDimension, dimensionsToDefault);
        }

        return ledgerDimensionMerged;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeSummaryLedgerDimension</Name>
				<Source><![CDATA[
    protected LedgerDimensionAccount mergeSummaryLedgerDimension(
        boolean _useSettingsFromPreviousAdjustment,
        boolean _voucherContainsMultipleSummaryEntries = false,
        boolean _isReversing = false)
    {
        DimensionDefault localDimensionDefault;

        if (_useSettingsFromPreviousAdjustment)
        {
            switch (previousDimensionSpecification)
            {
                case NoneTableTrans::Table:
                    localDimensionDefault = CustVendTransData::construct(custVendTrans).custVendTable().DefaultDimension;
                    break;

                case NoneTableTrans::Transaction:
                    if (_voucherContainsMultipleSummaryEntries)
                    {
                        localDimensionDefault = custVendTrans.DefaultDimension;
                    }
                    break;
            }
        }
        else
        {
            switch (exchangeAdjustmentController.dimSpec())
            {
                case NoneTableTrans::Table:
                    localDimensionDefault = defaultDimension;
                    break;

                case NoneTableTrans::Transaction:
                    if (_voucherContainsMultipleSummaryEntries)
                    {
                        localDimensionDefault = custVendTrans.DefaultDimension;
                    }
                    break;
            }
        }

        return LedgerDimensionFacade::serviceCreateLedgerDimension(this.getSummaryLedgerDimension(custVendTrans.AccountNum, this.getPostingProfile(_useSettingsFromPreviousAdjustment)), localDimensionDefault);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        countryRegion_RUCZ = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ]);

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ, #isoEE, #isoHU, #isoLT, #isoLV, #isoPL, #isoRU]))
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceEEU00046, funcName());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postGainLossDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Posts gain or loss distributions.
    /// </summary>
    /// <param name="_accountingCurrencyExchangeAdjustmentAmount">
    ///  The accounting currency exchange adjustment.
    /// </param>
    /// <param name="_reportingCurrencyExchangeAdjustmentAmount">
    ///  The reporting currency exchange adjustment.
    /// </param>
    /// <param name="_gainLossLedgerPostingType">
    ///  The ledger posting type to find the expense or summary accounting entries of the document that is being revalued.
    /// </param>
    /// <param name="_ledgerVoucherObject">
    ///  The ledger voucher object to post the new currency revaluation.
    /// </param>
    /// <param name="_ledgerPostingController">
    ///  The ledger posting control to post the new currency revaluation.
    /// </param>
    /// <param name="_defaultLedgerDimension">
    ///  The default ledger dimension to post the new currency revaluation.
    /// </param>
    /// <param name="_useSettingsFromPreviousAdjustment">
    ///  True if the exchange adjustment settings from the previous adjustment should be used.
    /// </param>
    /// <param name="_skipDimensionValidation">
    ///  True will turn off dimension validation; otherwise dimensions will be validated.
    /// </param>
    /// <param name="_isReversing">
    ///  Indicates if this is a reversing adjustment.
    /// </param>
    protected void postGainLossDistributions(
        AmountMST _accountingCurrencyExchangeAdjustmentAmount,
        AmountMST _reportingCurrencyExchangeAdjustmentAmount,
        LedgerPostingType _gainLossLedgerPostingType,
        LedgerVoucherObject _ledgerVoucherObject,
        LedgerPostingController _ledgerPostingController,
        LedgerDimensionAccount _defaultLedgerDimension,
        boolean _useSettingsFromPreviousAdjustment,
        boolean _skipDimensionValidation,
        boolean _isReversing)
    {
        if (_accountingCurrencyExchangeAdjustmentAmount || _reportingCurrencyExchangeAdjustmentAmount)
        {
            NoneTableTrans dimensionSpecification = this.getDimensionSpecification(_useSettingsFromPreviousAdjustment);
            boolean forceSingleDistribution = (dimensionSpecification != NoneTableTrans::Transaction);
            boolean applyDefaultDimensions = (dimensionSpecification == NoneTableTrans::Transaction);

            List ledgerPostingTypes = this.getOriginalGainLossPostingAccountTypes();

            this.generateDistributionsForPostingTypes(
                ledgerPostingTypes,
                _gainLossLedgerPostingType,
                -_accountingCurrencyExchangeAdjustmentAmount,
                -_reportingCurrencyExchangeAdjustmentAmount,
                _ledgerVoucherObject,
                _ledgerPostingController,
                _defaultLedgerDimension,
                forceSingleDistribution,
                true,
                _skipDimensionValidation,
                this.getCustVendExchAdjType(_useSettingsFromPreviousAdjustment, _isReversing),
                applyDefaultDimensions);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postGeneralJournalSummaryDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Posts the summary account distributions.
    /// </summary>
    /// <param name="_accountingCurrencyExchangeAdjustmentAmount">
    ///  The accounting currency exchange adjustment.
    /// </param>
    /// <param name="_reportingCurrencyExchangeAdjustmentAmount">
    ///  The reporting currency exchange adjustment.
    /// </param>
    /// <param name="_ledgerVoucherObject">
    ///  The ledger voucher object to post the new currency revaluation.
    /// </param>
    /// <param name="_ledgerPostingController">
    ///  The ledger posting control to post the new currency revaluation.
    /// </param>
    /// <param name="_useSettingsFromPreviousAdjustment">
    ///   True if the exchange adjustment settings from the previous adjustment should be used.
    /// </param>
    /// <param name="_isReversing">
    ///  Indicates if this is a reversing adjustment.
    /// </param>
    /// <param name="_skipDimensionValidation">
    ///  True will turn off dimension validation; otherwise dimensions will be validated.
    /// </param>
    protected void postGeneralJournalSummaryDistributions(
        AmountMST _accountingCurrencyExchangeAdjustmentAmount,
        AmountMST _reportingCurrencyExchangeAdjustmentAmount,
        LedgerVoucherObject _ledgerVoucherObject,
        LedgerPostingController _ledgerPostingController,
        boolean _useSettingsFromPreviousAdjustment,
        boolean _isReversing,
        boolean _skipDimensionValidation)
    {
        List summaryPostingTypes = new List(Types::Enum);
        boolean voucherContainsMultipleSummaryEntries;

        LedgerPostingType summaryPostingType = this.getSummaryPostingAccountType();
        summaryPostingTypes.addEnd(summaryPostingType);

        if (_accountingCurrencyExchangeAdjustmentAmount || _reportingCurrencyExchangeAdjustmentAmount)
        {
            voucherContainsMultipleSummaryEntries = CustVendSettleSummaryAccountRelief::voucherContainsMultipleSummaryEntries(
                custVendTrans,
                summaryPostingType);

            LedgerDimensionAccount defaultLedgerDimension = this.mergeSummaryLedgerDimension(
                _useSettingsFromPreviousAdjustment,
                voucherContainsMultipleSummaryEntries,
                _isReversing);

            boolean forceSingleDistribution = this.shouldForceSummarySingleDistribution(_useSettingsFromPreviousAdjustment, voucherContainsMultipleSummaryEntries);

            boolean mergeDefaultWithOriginalDimension = this.shouldMergeSummaryDefaultWithOriginalDimension(_isReversing);
            boolean applyDefaultDimensions = false;

            this.generateDistributionsForPostingTypes(
                summaryPostingTypes,
                summaryPostingType,
                _accountingCurrencyExchangeAdjustmentAmount,
                _reportingCurrencyExchangeAdjustmentAmount,
                _ledgerVoucherObject,
                _ledgerPostingController,
                defaultLedgerDimension,
                forceSingleDistribution,
                mergeDefaultWithOriginalDimension,
                _skipDimensionValidation,
                this.getCustVendExchAdjType(_useSettingsFromPreviousAdjustment, _isReversing),
                applyDefaultDimensions);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldMergeSummaryDefaultWithOriginalDimension</Name>
				<Source><![CDATA[
    private boolean shouldMergeSummaryDefaultWithOriginalDimension(boolean _isReversing)
    {
        boolean shouldMerge;

        if (exchangeAdjustmentController.postingSpec() == TransactionSelect::Selection
            && postingProfile != custVendTrans.PostingProfile)
        {
            shouldMerge = true;
        }
        else 
        {
            if (FCRReversalDimensionOverwrittenEnableFlight::instance().isEnabled())
            {
                if (_isReversing && this.parmfromSettle() && previousPostingProfile != custVendTrans.PostingProfile)
                {
                    shouldMerge = true;
                }
            }
        }

        return shouldMerge;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postGeneralJournalSummaryDistributions_W</Name>
				<Source><![CDATA[
    private void postGeneralJournalSummaryDistributions_W(
        AmountMST _accountingCurrencyExchangeAdjustmentAmount,
        AmountMST _reportingCurrencyExchangeAdjustmentAmount,
        LedgerVoucherObject _ledgerVoucherObject,
        LedgerPostingController _ledgerPostingController,
        boolean _useSettingsFromPreviousAdjustment,
        CustVendExchAdjType _custVendExchAdjType)
    {
        LedgerPostingType summaryPostingType = this.getSummaryPostingAccountType();

        if (_accountingCurrencyExchangeAdjustmentAmount || _reportingCurrencyExchangeAdjustmentAmount)
        {
            LedgerDimensionAccount defaultLedgerDimension;
            if (CustVendExchAdjPostingAdjustmentAccountCorrectionFlight::instance().isEnabled() && countryRegion_RUCZ)
            {
                defaultLedgerDimension = this.mergeSummaryLedgerDimension(
                    _useSettingsFromPreviousAdjustment,
                    CustVendSettleSummaryAccountRelief::voucherContainsMultipleSummaryEntries(custVendTrans, summaryPostingType));
            }
            else
            {
                defaultLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(this.getSummaryLedgerDimension(custVendTrans.AccountNum, this.getPostingProfile(_useSettingsFromPreviousAdjustment)), defaultDimension);
            }
            // if the user did not specify to get dimensions from the transaction, then force distribution process to generate a single distribution
            boolean forceSingleDistribution = (this.getDimensionSpecification(_useSettingsFromPreviousAdjustment) != NoneTableTrans::Transaction);

            // get the set of LedgerDimension/Amount values to be posted
            List distributions = distributionController.generateDistributions(
                custVendTrans,
                summaryPostingType,
                0,                                // currency adjustments do not affect transaction currency value
                _accountingCurrencyExchangeAdjustmentAmount,
                _reportingCurrencyExchangeAdjustmentAmount,
                defaultLedgerDimension,
                forceSingleDistribution);

            // Generate a trans for each of the distributions
            ListEnumerator distributionEnumerator = distributions.getEnumerator();
            while (distributionEnumerator.moveNext())
            {
                CustVendTransDistribution distribution = distributionEnumerator.current();

                LedgerVoucherTransObject ledgerVoucherTransObject;
                if (distribution.accountingAmount())
                {
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(
                        _ledgerVoucherObject,
                        summaryPostingType,
                        distribution.ledgerDimension(),
                        custVendTrans.CurrencyCode,
                        distribution.accountingAmount(),
                        0.0);

                    // It is possible that the account structure and/or allowable dimensions could have changed
                    // since the summary account was first posted. As a result it is necessary to disable dimension
                    // validation.
                    ledgerVoucherTransObject.parmSkipDimensionValidation(true);

                    if (CustVendExchAdjLedgerEntryIsExchangeAdjustmentRUCZFlight::instance().isEnabled()
                        && _custVendExchAdjType == CustVendExchAdjType::NewAdjustment)
                    {
                        ledgerVoucherTransObject.parmIsExchangeAdjustment(NoYes::Yes);
                    }

                    _ledgerPostingController.addTrans(ledgerVoucherTransObject);
                }

                if (distribution.reportingAmount())
                {
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(
                        _ledgerVoucherObject,
                        summaryPostingType,
                        distribution.ledgerDimension(),
                        custVendTrans.CurrencyCode,
                        0.0,
                        distribution.reportingAmount());

                    // It is possible that the account structure and/or allowable dimensions could have changed
                    // since the summary account was first posted. As a result it is necessary to disable dimension
                    // validation.
                    ledgerVoucherTransObject.parmSkipDimensionValidation(true);

                    if (CustVendExchAdjLedgerEntryIsExchangeAdjustmentRUCZFlight::instance().isEnabled()
                        && _custVendExchAdjType == CustVendExchAdjType::NewAdjustment)
                    {
                        ledgerVoucherTransObject.parmIsExchangeAdjustment(NoYes::Yes);
                    }

                    _ledgerPostingController.addTrans(ledgerVoucherTransObject);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postToGeneralJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Posts the summary and gain or loss account, dimensions and amounts.
    /// </summary>
    /// <param name="_ledgerVoucher">
    ///  The ledger voucher that will hold the accounts, dimensions and amounts.
    /// </param>
    /// <param name="_accountingCurrencyExchangeAdjustmentAmount">
    ///  The accounting currency revaluation adjustment amount.
    /// </param>
    /// <param name="_accountingCurrencyLedgerDimensionProfitLoss">
    ///  The default accounting currency ledger dimension for the gain or loss account and dimension.
    /// </param>
    /// <param name="_reportingCurrencyExchangeAdjustmentAmount">
    ///  The reporting currency revaluation adjustment amount.
    /// </param>
    /// <param name="_reportingCurrencyLedgerDimensionProfitLoss">
    ///  The default reporting currency ledger dimension for the gain or loss account and dimension.
    /// </param>
    /// <param name="_newCustVendTrans">
    ///  The new customer or vendor transaction currency revaluation information.
    /// </param>
    /// <param name="_isReversing">
    ///  True if this is a reversing adjustment; otherwise false.
    /// </param>
    /// <param name="_useSettingsFromPreviousAdjustment">
    ///  True if the exchange adjustment settings from the previous adjustment should be used; otherwise false.
    /// </param>
    /// <param name="_ledgerPostingControllerLedgerTransType">
    ///  The ledger transaction type that will be used to create the summary and gain or loss account, dimensions and amounts; optional.
    /// </param>
    /// <param name="_skipProfitLossLedgerDimensionValidation">
    ///  Specifies whether profit/loss dimensions validation should be skipped; optional.
    /// </param>
    protected void postToGeneralJournal(
        LedgerVoucher _ledgerVoucher,
        AmountMST _accountingCurrencyExchangeAdjustmentAmount,
        LedgerDimensionDefaultAccount _accountingCurrencyLedgerDimensionProfitLoss,
        AmountMST _reportingCurrencyExchangeAdjustmentAmount,
        LedgerDimensionDefaultAccount _reportingCurrencyLedgerDimensionProfitLoss,
        CustVendTrans _newCustVendTrans,
        boolean _isReversing,
        boolean _useSettingsFromPreviousAdjustment,
        LedgerTransType _ledgerPostingControllerLedgerTransType = LedgerTransType::ExchAdjustment,
        boolean _skipProfitLossLedgerDimensionValidation = true)
    {
        LedgerDimensionAccount ledgerDimensionMerged;
        // <GEE>
        boolean countryRegion_EE = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ, #isoEE, #isoHU, #isoLT, #isoLV, #isoPL, #isoRU]);
        // </GEE>

        LedgerPostingController ledgerPostingController = this.getLedgerPostingController(_ledgerVoucher, _newCustVendTrans.TransDate, _ledgerPostingControllerLedgerTransType);
        LedgerVoucherObject ledgerVoucherObject = ledgerPostingController.getReference();
        Voucher originalReferenceNumber = ledgerVoucherObject.parmReferenceNumber();
        TransDate originalAccountingDate = ledgerVoucherObject.parmAccountingDate();

        distributionController.parmSkipUseLedgerVoucherChanged(skipUseLedgerVoucherChanged);

        // <GEEEE>
        if (countryRegion_EE)
        {
            ledgerVoucherObject.parmIsCorrectionDefault(_isReversing);
        }
        // </GEEEE>

        if (countryRegion_RUCZ || (_isReversing && _useSettingsFromPreviousAdjustment && !doesLedgerEntryIsExchangeAdjustmentExist))
        {
            this.postToGeneralJournal_W(
                ledgerVoucherObject,
                ledgerPostingController,
                _ledgerVoucher,
                _accountingCurrencyExchangeAdjustmentAmount,
                _accountingCurrencyLedgerDimensionProfitLoss,
                _reportingCurrencyExchangeAdjustmentAmount,
                _reportingCurrencyLedgerDimensionProfitLoss,
                _newCustVendTrans,
                _isReversing,
                _useSettingsFromPreviousAdjustment);
        }
        else
        {
            if (_accountingCurrencyExchangeAdjustmentAmount)
            {
                // Accounting Currency Gain/Loss
                ledgerDimensionMerged = this.mergeProfitLossLedgerDimension(
                    _useSettingsFromPreviousAdjustment,
                    0,
                    _accountingCurrencyLedgerDimensionProfitLoss,
                    _isReversing);

                this.postGainLossDistributions(
                    _accountingCurrencyExchangeAdjustmentAmount,
                    0,
                    this.getLedgerPostingType(_accountingCurrencyExchangeAdjustmentAmount, _isReversing),
                    ledgerVoucherObject,
                    LedgerPostingController::newForLedgerPostingJournal(_ledgerVoucher),
                    ledgerDimensionMerged,
                    _useSettingsFromPreviousAdjustment,
                    _skipProfitLossLedgerDimensionValidation,
                    _isReversing);
            }

            if (_reportingCurrencyExchangeAdjustmentAmount)
            {
                // Reporting Currency Gain/Loss
                ledgerDimensionMerged = this.mergeProfitLossLedgerDimension(
                    _useSettingsFromPreviousAdjustment,
                    0,
                    _reportingCurrencyLedgerDimensionProfitLoss,
                    _isReversing);

                this.postGainLossDistributions(
                    0,
                    _reportingCurrencyExchangeAdjustmentAmount,
                    this.getLedgerPostingType(_reportingCurrencyExchangeAdjustmentAmount, _isReversing),
                    ledgerVoucherObject,
                    LedgerPostingController::newForLedgerPostingJournal(_ledgerVoucher),
                    ledgerDimensionMerged,
                    _useSettingsFromPreviousAdjustment,
                    _skipProfitLossLedgerDimensionValidation,
                    _isReversing);
            }

            if (_accountingCurrencyExchangeAdjustmentAmount || _reportingCurrencyExchangeAdjustmentAmount)
            {
                // Post to the the AR/AP LedgerDimension(s)
                this.postGeneralJournalSummaryDistributions(
                    _accountingCurrencyExchangeAdjustmentAmount,
                    _reportingCurrencyExchangeAdjustmentAmount,
                    ledgerVoucherObject,
                    ledgerPostingController,
                    _useSettingsFromPreviousAdjustment,
                    _isReversing,
                    true);
            }
        }

        ledgerPostingController.findReference(originalReferenceNumber, originalAccountingDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postToGeneralJournal_W</Name>
				<Source><![CDATA[
    private void postToGeneralJournal_W(
        LedgerVoucherObject _ledgerVoucherObject,
        LedgerPostingController _ledgerPostingController,
        LedgerVoucher _ledgerVoucher,
        AmountMST _accountingCurrencyExchangeAdjustmentAmount,
        LedgerDimensionDefaultAccount _accountingCurrencyLedgerDimensionProfitLoss,
        AmountMST _reportingCurrencyExchangeAdjustmentAmount,
        LedgerDimensionDefaultAccount _reportingCurrencyLedgerDimensionProfitLoss,
        CustVendTrans _newCustVendTrans,
        boolean _isReversing,
        boolean _useSettingsFromPreviousAdjustment)
    {
        LedgerDimensionAccount ledgerDimensionMerged;
        LedgerVoucherTransObject ledgerVoucherTransObject;
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        LedgerBondClient_RU ledgerBondClient;
        LedgerBondId_RU accountingCurVRefId, reportingCurVRefId;

        // <GEERU>
        if (countryRegion_RU)
        {
            ledgerBondClient = _ledgerVoucherObject.ledgerBondClient_RU();
            if (ledgerBondClient)
            {
                ledgerBondClient.addNewLogObject();
            }
        }
        // </GEERU>

        if (!countryRegion_RUCZ)
        {
            distributionController = CustVendTransDistributionController::construct();
        }

        CustVendExchAdjType custVendExchAdjType = this.getCustVendExchAdjType(_useSettingsFromPreviousAdjustment, _isReversing);

        // Post to the Gain/Loss ledger dimension (accounting currency)
        if (_accountingCurrencyExchangeAdjustmentAmount)
        {
            ledgerDimensionMerged = this.mergeProfitLossLedgerDimension(
                _useSettingsFromPreviousAdjustment,
                previousAccountingCurrencyAdjustmentLedgerDimension,
                _accountingCurrencyLedgerDimensionProfitLoss,
                _isReversing);

            ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(
                _ledgerVoucherObject,
                this.getLedgerPostingType(_accountingCurrencyExchangeAdjustmentAmount, _isReversing),
                ledgerDimensionMerged,
                _newCustVendTrans.CurrencyCode,
                -_accountingCurrencyExchangeAdjustmentAmount,
                0);

            // It is possible that the account structure and/or allowable dimensions could have changed
            // since the gain/loss first posted. As a result it is necessary to disable dimension
            // validation when reversing previous exchange adjustments.
            ledgerVoucherTransObject.parmSkipDimensionValidation(true);

            if (CustVendExchAdjLedgerEntryIsExchangeAdjustmentRUCZFlight::instance().isEnabled()
                && custVendExchAdjType == CustVendExchAdjType::NewAdjustment)
            {
                ledgerVoucherTransObject.parmIsExchangeAdjustment(NoYes::Yes);
            }

            _ledgerPostingController.addTrans(ledgerVoucherTransObject);

            if (ledgerBondClient)
            {
                accountingCurVRefId = ledgerBondClient.lastVrefId();
            }
        }

        if (_reportingCurrencyExchangeAdjustmentAmount)
        {
            ledgerDimensionMerged = this.mergeProfitLossLedgerDimension(
                _useSettingsFromPreviousAdjustment,
                previousReportingCurrencyAdjustmentLedgerDimension,
                _reportingCurrencyLedgerDimensionProfitLoss,
                _isReversing);

            // Post to the Gain/Loss ledger dimension (reporting currency)
            ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(
                _ledgerVoucherObject,
                this.getLedgerPostingType(_reportingCurrencyExchangeAdjustmentAmount, _isReversing),
                ledgerDimensionMerged,
                _newCustVendTrans.CurrencyCode,
                0,
                -_reportingCurrencyExchangeAdjustmentAmount);

            // It is possible that the account structure and/or allowable dimensions could have changed
            // since the gain/loss first posted. As a result it is necessary to disable dimension
            // validation when reversing previous exchange adjustments.
            ledgerVoucherTransObject.parmSkipDimensionValidation(true);

            if (CustVendExchAdjLedgerEntryIsExchangeAdjustmentRUCZFlight::instance().isEnabled()
                && custVendExchAdjType == CustVendExchAdjType::NewAdjustment)
            {
                ledgerVoucherTransObject.parmIsExchangeAdjustment(NoYes::Yes);
            }

            _ledgerPostingController.addTrans(ledgerVoucherTransObject);

            if (ledgerBondClient)
            {
                reportingCurVRefId = ledgerBondClient.lastVrefId();
            }
        }

        // Post to the the Summary LedgerDimension(s)
        this.postGeneralJournalSummaryDistributions_W(
            _accountingCurrencyExchangeAdjustmentAmount,
            _reportingCurrencyExchangeAdjustmentAmount,
            _ledgerVoucherObject,
            _ledgerPostingController,
            _useSettingsFromPreviousAdjustment,
            custVendExchAdjType);

        if (!countryRegion_RUCZ)
        {
            distributionController = CustVendTransExchAdjDistController::construct();
        }

        if (ledgerBondClient)
        {
            if (ledgerBondClient.currentLogLength() && reportingCurVRefId && accountingCurVRefId)
            {            
                ledgerBondClient.bondVRef2Log(reportingCurVRefId);
                ledgerBondClient.bondVRef2Log(accountingCurVRefId);
            }
            ledgerBondClient.bondLog2Log();
            ledgerBondClient.removeCurrentLogObject();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes an instance of the <c>CustVendExchAdjPostingEngine</c> class.
    /// </summary>
    /// <param name="_exchangeAdjustmentController">
    /// An instance of the <c>CustVendExchAdj</c> class that contains the parameters for the exchange
    /// adjustment.
    /// </param>
    /// <param name="_exchangeRateDate">
    /// The exchange rate date.
    /// </param>
    /// <param name="_custVendTrans">
    /// The transaction record being adjusted.
    /// </param>
    /// <param name="_custVendTransOpen">
    /// The open transaction record being adjusted.
    /// </param>
    /// <param name="_custVendSettlement">
    /// The settlement record being adjusted.
    /// </param>
    /// <param name="_lastExchangeAdjustmentHistory">
    /// An instantiated map with a key of type Int64 and a value of type Container. The same instance of the map should
    /// be passed each time the <c>CustVendExchAdjPostingEngine</c> class is constructed for a given set of transactions.
    /// The <c>CustVendExchAdjPostingEngine</c> class will add information to the map regarding the transactions that
    /// have been processed.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The <c>LedgerVoucher</c> object to use for posting.
    /// </param>
    /// <param name="_isSettleByLineEnabled">
    ///  A boolean value that identifies when line level settlement should be performed; optional.
    /// </param>
    /// <param name="_debitSpecTransRecId">
    ///  Identfies the invoice line that is being settled; optional.
    /// </param>
    /// <returns>
    /// An instance of the <c>CustVendExchAdjPostingEngine</c> class.
    /// </returns>
    public static CustVendExchAdjPostingEngine construct(
        CustVendExchAdj _exchangeAdjustmentController,
        TransDate _exchangeRateDate,
        CustVendTrans _custVendTrans,
        CustVendTransOpen _custVendTransOpen,
        CustVendSettlement _custVendSettlement,
        Map _lastExchangeAdjustmentHistory,
        LedgerVoucher _ledgerVoucher,
        boolean _isSettleByLineEnabled = false,
        RefRecId _debitSpecTransRecId = 0)
    {
        CustVendExchAdjPostingEngine custVendExchAdjPostingEngine = CustVendExchAdjPostingEngine::constructUninitializedImplementation(_exchangeAdjustmentController);

        custVendExchAdjPostingEngine.init(
            _exchangeAdjustmentController,
            _exchangeRateDate,
            _custVendTrans,
            _custVendTransOpen,
            _custVendSettlement,
            _lastExchangeAdjustmentHistory,
            _ledgerVoucher,
            _isSettleByLineEnabled,
            _debitSpecTransRecId);

        return custVendExchAdjPostingEngine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructUninitializedImplementation</Name>
				<Source><![CDATA[
    internal static CustVendExchAdjPostingEngine constructUninitializedImplementation(CustVendExchAdj _exchangeAdjustmentController)
    {
        CustVendExchAdjPostingEngine custVendExchAdjPostingEngine;

        if (_exchangeAdjustmentController.module() == SysModule::Cust)
        {
            custVendExchAdjPostingEngine = new CustExchAdjPostingEngine();
        }
        else
        {
            custVendExchAdjPostingEngine = new VendExchAdjPostingEngine();
        }

        return custVendExchAdjPostingEngine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructForSettlements</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Initializes an instance of the <c>CustVendExchAdjPostingEngine</c> class for the reversal of unrealized currency revaluation during settlements.
    /// </summary>
    /// <param name="_sysModule">
    ///  The module that specifies the class to initialize.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///  The ledger voucher to post the new currency revaluation.
    /// </param>
    /// <param name="_exchangeRateDate">
    ///  The exchange rate date.
    /// </param>
    /// <param name="_custVendTrans">
    ///  The transaction being settled.
    /// </param>
    /// <param name="_unrealized">
    /// true if an unrealized exchange adjustment; false if a realized exchange adjustment.
    /// </param>
    /// <param name="_isSettleByLineEnabled">
    ///  A boolean value that identifies when line level settlement should be performed; optional.
    /// </param>
    /// <param name="_debitSpecTransRecId">
    ///  Identfies the invoice line that is being settled; optional.
    /// </param>
    /// <returns>
    ///  An instance of the <c>CustVendExchAdjPostingEngine</c> class.
    /// </returns>
    public static CustVendExchAdjPostingEngine constructForSettlements(
        SysModule _sysModule,
        LedgerVoucher _ledgerVoucher,
        TransDate _exchangeRateDate,
        CustVendTrans _custVendTrans,
        boolean _unrealized = true,
        boolean _isSettleByLineEnabled = false,
        RefRecId _debitSpecTransRecId = 0)
    {
        CustVendTrans custVendTrans;
        CustTrans custTrans;
        VendTrans vendTrans;
        CustVendTransOpen custVendTransOpen;
        CustVendSettlement custVendSettlement;
        Map lastExchangeAdjustmentHistory = new Map(Types::Int64, Types::Container);
        ModuleCustVend moduleCustVend;

        CustVendExchAdj custVendExchAdj = custVendExchAdj::construct(_sysModule);

        if (_sysModule == SysModule::Cust)
        {
            moduleCustVend = ModuleCustVend::Cust;
            custTrans.data(_custVendTrans);
            custVendTrans = custTrans;
        }
        else
        {
            moduleCustVend = ModuleCustVend::Vend;
            vendTrans.data(_custVendTrans);
            custVendTrans = vendTrans;
            custVendTrans.AmountCur = custVendTrans.AmountCur *-1;
            custVendTrans.AmountMST = custVendTrans.AmountMST *-1;
            custVendTrans.ReportingCurrencyAmount = custVendTrans.ReportingCurrencyAmount *-1;
        }

        if (_unrealized)
        {
            CreatedTransactionId previousCreatedTransactionId = CustVendExchAdjPostingEngine::getPrevCreatedTransactionId(
                moduleCustVend,
                _custVendTrans.LastExchAdjVoucher,
                _custVendTrans.LastExchAdj);

            boolean doesLedgerEntryIsExchangeAdjustmentExist = CustVendExchAdjPostingEngine::doesLedgerEntryIsExchangeAdjustmentExist(previousCreatedTransactionId);

            if (!doesLedgerEntryIsExchangeAdjustmentExist)
            {
                CustVendExchRateAdjustment custVendExchRateAdjustment = CustVendExchRateAdjustment::getEmptyTableBuffer(moduleCustVend);

                select firstonly Dimensions from custVendExchRateAdjustment
                    where custVendExchRateAdjustment.CreatedTransactionId == previousCreatedTransactionId;

                if (custVendExchRateAdjustment)
                {
                    custVendExchAdj.dimSpec(custVendExchRateAdjustment.Dimensions);
                }
            }

            _isSettleByLineEnabled = false;
            _debitSpecTransRecId = 0;
        }
        else
        {
            custVendExchAdj.dimSpec(NoneTableTrans::Transaction);
        }

        CustVendExchAdjPostingEngine custVendExchAdjPostingEngine = CustVendExchAdjPostingEngine::construct(
            custVendExchAdj,
            _exchangeRateDate,
            custVendTrans,
            custVendTransOpen,
            custVendSettlement,
            lastExchangeAdjustmentHistory,
            _ledgerVoucher,
            _isSettleByLineEnabled,
            _debitSpecTransRecId);

        if (_unrealized)
        {
            custVendExchAdjPostingEngine.parmfromSettle(true);
        }

        return custVendExchAdjPostingEngine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesLedgerEntryIsExchangeAdjustmentExist</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Determines if the previous currency revaluation identifies the difference between reversal adjustments and new adjustments.
    /// </summary>
    /// <param name="_previousCreatedTransactionId">
    ///  The created transaction identification of the previous currency revaluation.
    /// </param>
    /// <returns>
    ///  true if the specified record exists; otherwise, false.
    /// </returns>
    /// <remarks>
    ///  A single voucher is used to identify the reversal of a previous currency revaluation and the new currency revaluation.  The
    ///  <c>LedgerEntry</c> table is used to track which entries are related to the reversal and the new adjustment.
    /// </remarks>
    protected static boolean doesLedgerEntryIsExchangeAdjustmentExist(CreatedTransactionId _previousCreatedTransactionId)
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        LedgerEntry ledgerEntry;
        boolean doesExist;

        if (_previousCreatedTransactionId)
        {
            generalJournalAccountEntry.allowIndexHint(true);
            select firstOnly RecId from generalJournalAccountEntry
                index hint CreatedTransactionIdx
                where generalJournalAccountEntry.createdTransactionId == _previousCreatedTransactionId
                    && (generalJournalAccountEntry.PostingType == LedgerPostingType::ExchRateLoss
                    ||  generalJournalAccountEntry.PostingType == LedgerPostingType::ExchRateGain)
                exists join ledgerEntry
                    where ledgerEntry.GeneralJournalAccountEntry == generalJournalAccountEntry.RecId
                        && ledgerEntry.IsExchangeAdjustment == NoYes::Yes;
        }

        if (generalJournalAccountEntry)
        {
            doesExist = true;
        }

        return doesExist;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPrevCreatedTransactionId</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Gets the created transaction identification for the last currency revaluation.
    /// </summary>
    /// <param name="_moduleCustVend">
    ///  The module that specifies the table to query.
    /// </param>
    /// <param name="_lastExchAdjVoucher">
    ///  The last currency exchange adjustment ledger voucher.
    /// </param>
    /// <param name="_lastExchAdjDate">
    ///  The last currency exchange adjustment date.
    /// </param>
    /// <returns>
    ///  The created transaction identification.
    /// </returns>
    protected static CreatedTransactionId getPrevCreatedTransactionId(ModuleCustVend _moduleCustVend, Voucher _lastExchAdjVoucher, TransDate _lastExchAdjDate)
    {
        CustVendTrans custVendTrans = CustVendTrans::getEmptyTableBuffer(_moduleCustVend);

        select firstOnly CreatedTransactionId from custVendTrans
            where custVendTrans.Voucher == _lastExchAdjVoucher
                && custVendTrans.TransDate == _lastExchAdjDate
                && custVendTrans.TransType == LedgerTransType::ExchAdjustment;

        return custVendTrans.createdTransactionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRealizedExchangeAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a realized exchange adjustment.
    /// </summary>
    /// <param name="_accountingCurrencyExchangeAdjustmentAmount">
    /// The accounting currency exchange adjustment.
    /// </param>
    /// <param name="_accountingCurrencyLedgerDimensionProfitLoss">
    /// The accounting currency gain loss ledger dimension default account.
    /// </param>
    /// <param name="_reportingCurrencyExchangeAdjustmentAmount">
    /// The reporting currency exchange adjustment.
    /// </param>
    /// <param name="_reportingCurrencyLedgerDimensionProfitLoss">
    /// The reporting currency gain loss ledger dimension default account.
    /// </param>
    /// <param name="_forceSingleDistribution">
    ///  True if the exchange adjustment should be posted to the _accountingCurrencyLedgerDimensionProfitLoss and _reportingCurrencyLedgerDimensionProfitLoss;
    ///  otherwise the accounting entries of the document that is being revalued will be used.
    /// </param>
    public void addRealizedExchangeAdjustment(
        AmountMST _accountingCurrencyExchangeAdjustmentAmount = 0,
        LedgerDimensionDefaultAccount _accountingCurrencyLedgerDimensionProfitLoss = 0,
        AmountMST _reportingCurrencyExchangeAdjustmentAmount = 0,
        LedgerDimensionDefaultAccount _reportingCurrencyLedgerDimensionProfitLoss = 0,
        boolean _forceSingleDistribution = false)
    {
        LedgerTransType ledgerTransType;
        CustVendTrans localCustVendTrans;
        CustTrans custTrans;
        VendTrans vendTrans;

        if (exchangeAdjustmentController.module() == SysModule::Cust)
        {
            ledgerTransType = LedgerTransType::Cust;
            localCustVendTrans = custTrans;
        }
        else
        {
            ledgerTransType = LedgerTransType::Vend;
            localCustVendTrans = vendTrans;
        }

        localCustVendTrans.TransDate = exchangeRateDate;
        localCustVendTrans.CurrencyCode = custVendTrans.CurrencyCode;

        if (_forceSingleDistribution)
        {
            exchangeAdjustmentController.dimSpec(NoneTableTrans::None);
        }

        this.postToGeneralJournal(
            ledgerVoucher,
            _accountingCurrencyExchangeAdjustmentAmount,
            _accountingCurrencyLedgerDimensionProfitLoss,
            _reportingCurrencyExchangeAdjustmentAmount,
            _reportingCurrencyLedgerDimensionProfitLoss,
            localCustVendTrans,
            false,
            false,
            ledgerTransType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPreviousRevaluationInvDatePrinciple</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the previous currency revaluation was a reversal (Invoice Date).
    /// </summary>
    /// <param name = "_custVendTrans">The transaction that was revalued.</param>
    /// <returns>
    /// true if the previous currency revaluation was a reversal; otherwise, false.
    /// </returns>
    public static boolean isPreviousRevaluationInvDatePrinciple(
        CustVendTrans _custVendTrans)
    {
        NumberSequenceReference numberSequenceReference;
        SysModule sysModule;

        if ( _custVendTrans.TableId == tableNum(CustTrans))
        {
            numberSequenceReference = CustParameters::numRefCustExchAdjVoucher();
            sysModule = SysModule::Cust;
        }
        else
        {
            numberSequenceReference = VendParameters::numRefVendExchAdjVoucher();
            sysModule = SysModule::Vend;
        }
        NumberSeq numberSequence = NumberSeq::newGetVoucher(numberSequenceReference);

        LedgerVoucher ledgerVoucher = LedgerVoucher::newLedgerPost(
            DetailSummary::Detail,
            sysModule,
            numberSequence.parmVoucherSequenceCode());

        CustVendExchAdjPostingEngine custVendExchAdjPostingEngine = CustVendExchAdjPostingEngine::constructForSettlements(sysModule, ledgerVoucher, _custVendTrans.LastExchAdj, _custVendTrans);

        return custVendExchAdjPostingEngine.isPreviousRevaluationReversal();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimensionDefaultAccount</Name>
				<Source><![CDATA[
    private LedgerDimensionDefaultAccount getDimensionDefaultAccount(LedgerDimensionAccount _ledgerDimensionAccount)
    {
        MainAccount mainAccount = MainAccount::getMainAccountFromLedgerDimension(_ledgerDimensionAccount);
        DimensionAttributeValueCombination dimensionAttributeValueCombinationAccounting;

        select firstonly RecId from dimensionAttributeValueCombinationAccounting
            where dimensionAttributeValueCombinationAccounting.MainAccount == mainAccount.RecId
                && dimensionAttributeValueCombinationAccounting.LedgerDimensionType == LedgerDimensionType::DefaultAccount;

        return dimensionAttributeValueCombinationAccounting.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProfitLossAccount</Name>
				<Source><![CDATA[
    private LedgerDimensionDefaultAccount getProfitLossAccount(
        boolean _isReversing,
        AmountMST _exchAdjAmount,
        CustVendTrans _custVendTrans,
        LedgerDimensionAccount _previousLedgerDimension)
    {
        LedgerDimensionDefaultAccount profitLossAccount;
        if (_isReversing && _previousLedgerDimension && isCustVendExchAdjLedgerDimensionFlightEnabled)
        {
            profitLossAccount = this.getDimensionDefaultAccount(_previousLedgerDimension);
        }
        else
        {
            profitLossAccount = this.getDefaultLedgerDimensionUnrealizedProfitLossFromPostingProfile(
                _custVendTrans.TableId == tableNum(CustTrans),
                _exchAdjAmount,
                _isReversing,
                _custVendTrans.CurrencyCode,
                _custVendTrans.AccountNum);

            if (profitLossAccount == 0)
            {
                profitLossAccount = this.getLedgerDimensionUnrealizedProfitLoss(
                    _exchAdjAmount,
                    _custVendTrans.CurrencyCode,
                    _isReversing);
            }
        }

        return profitLossAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasPreviousAccountingExchAdjLedgerDimension</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean hasPreviousAccountingExchAdjLedgerDimension()
    {
        return this.previousAccountingCurrencyAdjustmentLedgerDimension != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasPreviousReportingExchAdjLedgerDimension</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean hasPreviousReportingExchAdjLedgerDimension()
    {
        return this.previousReportingCurrencyAdjustmentLedgerDimension != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastAccountingExchAdjDimensionDefaultAccount</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public LedgerDimensionDefaultAccount getLastAccountingExchAdjDimensionDefaultAccount()
    {
        return this.getDimensionDefaultAccount(this.previousAccountingCurrencyAdjustmentLedgerDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastReportingExchAdjDimensionDefaultAccount</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public LedgerDimensionDefaultAccount getLastReportingExchAdjDimensionDefaultAccount()
    {
        return this.getDimensionDefaultAccount(this.previousReportingCurrencyAdjustmentLedgerDimension);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>