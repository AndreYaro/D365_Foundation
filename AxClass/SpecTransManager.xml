<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SpecTransManager</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>SpecTransManager</c> class is used to interact with records in the <c>SpecTrans</c> table.
/// </summary>
/// <remarks>
/// All records that are associated with an instance of the class share common values for the
/// <c>SpecCompany</c>, <c>SpecTableId</c>, and <c>SpecRecId</c> fields. Records that are associated
/// with an instance of the class optionally share the value of the <c>RefTableId</c> field.This class
/// replaces the <c>Specification</c> and <c>Specification_OffsetVoucher</c> classes and replaces
/// several methods from the <c>SpecTrans</c> table.
/// </remarks>
class SpecTransManager implements SysPackable
{
    CompanyId specCompany;
    tableId specTableId;
    RefRecId specRecId;

    // refTableId is needed if the specCompany, specTableId, and specRecId could overlap and
    // capture records with different RefTableIds.
    tableId refTableId;

    SpecTransCache specTransCache;
    boolean cacheEnabled;
    boolean cacheInitialized;

    #LOCALMACRO.CurrentList
        specCompany,
        specTableId,
        specRecId,
        refTableId,
        cacheEnabled,
        cacheInitialized
    ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>delete</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the <c>SpecTrans</c> record from the database.
    /// </summary>
    /// <param name="_refCompany">
    ///    The reference company of the <c>SpecTrans</c> record to be deleted.
    /// </param>
    /// <param name="_refTableId">
    ///    The reference table ID of the <c>SpecTrans</c> record to be deleted.
    /// </param>
    /// <param name="_refRecId">
    ///    The reference record ID of the <c>SpecTrans</c> record to be deleted.
    /// </param>
    /// <remarks>
    ///    This method replaces the <c>deleteRef</c> method on the <c>Specification</c> class.
    /// </remarks>
    public void delete(CompanyId _refCompany, tableId _refTableId, RefRecId _refRecId)
    {
        SpecTrans specTrans;

        // Delete corresponding SpecTrans record from database
        changecompany(_refCompany)
        {
            ttsbegin;

            delete_from specTrans where
                specTrans.SpecCompany == specCompany &&
                specTrans.SpecTableId == specTableId &&
                specTrans.SpecRecId == specRecId &&
                specTrans.RefCompany == _refCompany &&
                specTrans.RefTableId == _refTableId &&
                specTrans.RefRecId == _refRecId;

            ttscommit;
        }

        if (cacheEnabled)
        {
            // If cache is not initialized, initialize with all records here.
            if (cacheInitialized == false)
            {
                this.initCacheWithMarkedTransactions();
            }
            else
            {
                // Remove corresponding SpecTrans record from cache
                specTransCache.remove(_refCompany, _refTableId, _refRecId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes a specific marked line.
    /// </summary>
    /// <param name="_specTrans">
    ///    The buffer of the <c>SpecTrans</c> table that is used to change the company and to find marked line
    ///    records.
    /// </param>
    /// <param name="_refCustTransOpenLineRecId">
    ///    A record ID of the <c>CustTransMarkedOpenLine</c> table.
    /// </param>

    public void deleteLine(SpecTrans _specTrans, RefRecId _refCustTransOpenLineRecId)
    {
        CustTransMarkedOpenLine deleteSpecTransLine;

        changecompany(_specTrans.RefCompany)
        {
            ttsbegin;

            delete_from deleteSpecTransLine
                where deleteSpecTransLine.SpecTrans == _specTrans.RecId
                    && deleteSpecTransLine.CustTransOpenLine == _refCustTransOpenLineRecId;

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>exist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified record in the <c>SpecTrans</c> table exists.
    /// </summary>
    /// <param name="_refCompany">
    /// The reference company of the <c>SpecTrans</c> record to find.
    /// </param>
    /// <param name="_refTableId">
    /// The reference table ID of the <c>SpecTrans</c> record to find.
    /// </param>
    /// <param name="_refRecId">
    /// The reference record ID of the <c>SpecTrans</c> record to find.
    /// </param>
    /// <returns>
    /// true if the specified record exists; otherwise false.
    /// </returns>
    /// <remarks>
    /// Replaces the <c>checkExist</c>, <c>existSpecTrans</c>, and <c>isMarked</c> methods on the <c>Specification</c> class.
    /// </remarks>
    public boolean exist(
        CompanyId _refCompany,
        TableId _refTableId,
        RefRecId _refRecId)
    {
        boolean found = false;
        SpecTrans specTrans;
        boolean inMissingCache = false;

        if (cacheEnabled)
        {
            // If cache is not initialized, initialize with all records here.
            if (cacheInitialized == false)
            {
                this.initCacheWithMarkedTransactions();
            }

            specTrans = specTransCache.get(_refCompany, _refTableId, _refRecId);

            found = specTrans.RecId != 0;

            if (found == false)
            {
                // Check if it is in the missing cache
                inMissingCache = specTransCache.inMissingCache(_refCompany, _refTableId, _refRecId);
            }
        }

        if (cacheEnabled == false || (found == false && inMissingCache == false))
        {
            // Caching was not enabled or it was not found in either cache, find in database
            specTrans = SpecTrans::find(specCompany, specTableId, specRecId, _refCompany, _refTableId, _refRecId);

            found = specTrans.RecId != 0;

            if (cacheEnabled == true)
            {
                if (found == true)
                {
                    // Add record to cache
                    specTransCache.add(specTrans);
                }
                else
                {
                    // Add reference to missing cache
                    specTransCache.addAsMissing(_refCompany, _refTableId, _refRecId);
                }
            }
        }

        return found;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existForOtherSpec</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the specified record in the <c>SpecTrans</c> table exists with a
    ///    <c>SpecCompany</c>, <c>SpecTableId</c>, and <c>SpecRecId</c> that do not correspond to this class
    ///    instance.
    /// </summary>
    /// <param name="_refCompany">
    ///    The reference company of the <c>SpecTrans</c> record to find.
    /// </param>
    /// <param name="_refTableId">
    ///    The reference table ID of the <c>SpecTrans</c> record to find.
    /// </param>
    /// <param name="_refRecId">
    ///    The reference record ID of the <c>SpecTrans</c> record to find.
    /// </param>
    /// <returns>
    ///    true if the specified record exists; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Replaces the <c>isMarkedElsewhere</c> method on the <c>Specification</c> class.
    /// </remarks>
    public boolean existForOtherSpec(CompanyId _refCompany, tableId _refTableId, RefRecId _refRecId)
    {
        boolean found = false;
        SpecTrans specTrans;
        int markedByOtherResult;
        #define.MarkedByOther(1)
        #define.NotInCache(2)

        if (cacheEnabled)
        {
            markedByOtherResult = specTransCache.getMarkedByOtherSpec(_refCompany, _refRecId);

            if (markedByOtherResult != #NotInCache)
            {
                found = (markedByOtherResult == #MarkedByOther);
            }
        }

        if (!cacheEnabled || markedByOtherResult == #NotInCache)
        {
            // Find corresponding SpecTrans in other spec set
            if (_refCompany != '' && _refTableId != 0 && _refRecId != 0)
            {
                select firstonly crossCompany RecId from specTrans where
                    (specTrans.SpecCompany != specCompany ||
                    specTrans.SpecTableId != specTableId ||
                    specTrans.SpecRecId != specRecId) &&
                    specTrans.RefCompany == _refCompany &&
                    specTrans.RefTableId == _refTableId &&
                    specTrans.RefRecId == _refRecId;

                if (cacheEnabled)
                {
                    specTransCache.addMarkedByOtherSpecInfo(_refCompany, _refRecId, (specTrans.RecId != 0));
                }

                found = (specTrans.RecId != 0);
            }
        }

        return found;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearMarkedByOtherSpec</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears the cache for whether a <c>SpecTrans</c> record is already marked by another <c>SpecTrans</c> record.
    /// </summary>
    /// <param name="_refCompany">
    ///    The reference company of the <c>SpecTrans</c> record to find.
    /// </param>
    /// <param name="_refRecId">
    ///    The reference record ID of the <c>SpecTrans</c> record to find.
    /// </param>
    internal void clearMarkedByOtherSpec(CompanyId _refCompany, RefRecId _refRecId)
    {
        if (cacheEnabled)
        {
            specTransCache.clearMarkedByOtherSpec(_refCompany, _refRecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByFullSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>SpecTrans</c> record that corresponds to the current instance with the <c>FullSettlement</c>
    /// field set to 'Yes'.
    /// </summary>
    /// <returns>
    /// A record in the <c>SpecTrans</c> table; otherwise, an empty record.
    /// </returns>
    /// <remarks>
    /// Replaces the <c>findFullSettlement</c> method on the <c>Specification</c> class.
    /// </remarks>
    public SpecTrans findByFullSettlement()
    {
        SpecTrans foundSpecTrans;

        if (cacheEnabled)
        {
            // If cache is not initialized, initialize with all records here.
            if (cacheInitialized == false)
            {
                this.initCacheWithMarkedTransactions();
            }

            foundSpecTrans = specTransCache.getFullSettlementSpecTrans();
        }

        if (cacheEnabled == false || foundSpecTrans.RecId == 0)
        {
            // Find SpecTrans with FullSettlement field set to Yes in current spec set
            if (refTableId == 0)
            {
                select firstonly crossCompany foundSpecTrans where
                    foundSpecTrans.SpecCompany == specCompany &&
                    foundSpecTrans.SpecTableId == specTableId &&
                    foundSpecTrans.SpecRecId == specRecId &&
                    foundSpecTrans.FullSettlement == NoYes::Yes;
            }
            else
            {
                select firstonly crossCompany foundSpecTrans where
                    foundSpecTrans.SpecCompany == specCompany &&
                    foundSpecTrans.SpecTableId == specTableId &&
                    foundSpecTrans.SpecRecId == specRecId &&
                    foundSpecTrans.RefTableId == refTableId &&
                    foundSpecTrans.FullSettlement == NoYes::Yes;
            }

            if (cacheEnabled == true && foundSpecTrans.RecId != 0)
            {
                // Add to cache if found
                specTransCache.add(foundSpecTrans);
            }
        }

        return foundSpecTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByMarkedPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>SpecTrans</c> record that corresponds to this class instance with the <c>Payment</c> field set to 'Yes'.
    /// </summary>
    /// <returns>
    /// A record in the <c>SpecTrans</c> table; otherwise, an empty record.
    /// </returns>
    public SpecTrans findByMarkedPayment()
    {
        SpecTrans foundSpecTrans;

        if (cacheEnabled)
        {
            // If cache is not initialized, initialize with all records here.
            if (cacheInitialized == false)
            {
                this.initCacheWithMarkedTransactions();
            }

            foundSpecTrans = specTransCache.getMarkedPaymentSpecTrans();
        }

        if (cacheEnabled == false || foundSpecTrans.RecId == 0)
        {
            // Find SpecTrans with Payment field set to Yes in current spec set
            if (refTableId == 0)
            {
                select firstonly crossCompany foundSpecTrans where
                    foundSpecTrans.SpecCompany == specCompany &&
                    foundSpecTrans.SpecTableId == specTableId &&
                    foundSpecTrans.SpecRecId == specRecId &&
                    foundSpecTrans.Payment == NoYes::Yes;
            }
            else
            {
                select firstonly crossCompany foundSpecTrans where
                    foundSpecTrans.SpecCompany == specCompany &&
                    foundSpecTrans.SpecTableId == specTableId &&
                    foundSpecTrans.SpecRecId == specRecId &&
                    foundSpecTrans.RefTableId == refTableId &&
                    foundSpecTrans.Payment == NoYes::Yes;
            }

            if (cacheEnabled == true && foundSpecTrans.RecId != 0)
            {
                // Add to cache if found
                specTransCache.add(foundSpecTrans);
            }
        }

        return foundSpecTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByRef</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the specified record in the <c>SpecTrans</c> table.
    /// </summary>
    /// <param name="_refCompany">
    /// The reference company of the <c>SpecTrans</c> record to find.
    /// </param>
    /// <param name="_refTableId">
    /// The reference table ID of the <c>SpecTrans</c> record to find.
    /// </param>
    /// <param name="_refRecId">
    /// The reference record ID of the <c>SpecTrans</c> record to find.
    /// </param>
    /// <returns>
    /// A record in the <c>SpecTrans</c> table; otherwise, an empty record.
    /// </returns>
    /// <remarks>
    /// Replaces the <c>findRefId</c> method on the <c>Specification</c> class.
    /// </remarks>
    public SpecTrans findByRef(CompanyId _refCompany, tableId _refTableId, RefRecId _refRecId)
    {
        SpecTrans foundSpecTrans;
        boolean inMissingCache = false;

        if (cacheEnabled)
        {
            // If cache is not initialized, initialize with all records here.
            if (cacheInitialized == false)
            {
                this.initCacheWithMarkedTransactions();
            }

            foundSpecTrans = specTransCache.get(_refCompany, _refTableId, _refRecId);

            if (foundSpecTrans.RecId == 0)
            {
                // Check if it is in the missing cache
                inMissingCache = specTransCache.inMissingCache(_refCompany, _refTableId, _refRecId);
            }
        }

        if (cacheEnabled == false || (foundSpecTrans.RecId == 0 && inMissingCache == false))
        {
            // Caching was not enabled or it was not found in either cache, find in database
            foundSpecTrans = SpecTrans::find(specCompany, specTableId, specRecId, _refCompany, _refTableId, _refRecId);

            if (cacheEnabled == true)
            {
                if (foundSpecTrans.RecId != 0)
                {
                    // Add record to cache
                    specTransCache.add(foundSpecTrans);
                }
                else
                {
                    // Add reference to missing cache
                    specTransCache.addAsMissing(_refCompany, _refTableId, _refRecId);
                }
            }
        }

        return foundSpecTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAllSpecTransMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets a map that contains all the <c>SpecTrans</c> records that correspond to this class instance.
    /// </summary>
    /// <returns>
    ///    The map that contains the <c>SpecTrans</c>.
    /// </returns>
    /// <remarks>
    ///    The key of the map contains the <c>RecId</c> and the value contains the <c>SpecTrans</c>
    ///    record.Retrieves the records from the cache, if it is enabled.
    /// </remarks>
    public Map getAllSpecTransMap()
    {
        Map allSpecTrans;
        SpecTrans specTrans;

        if (cacheEnabled == true)
        {
            // If cache is not initialized, initialize with all records here.
            if (cacheInitialized == false)
            {
                this.initCacheWithMarkedTransactions();
            }

            allSpecTrans = specTransCache.getAllSpecTransMap();
        }

        if (cacheEnabled == false || (allSpecTrans != null && allSpecTrans.elements() == 0))
        {
            allSpecTrans = new Map(Types::Int64, Types::Record);

            if (refTableId == 0)
            {
                while select crossCompany specTrans
                    where specTrans.SpecCompany == specCompany &&
                        specTrans.SpecTableId == specTableId &&
                        specTrans.SpecRecId == specRecId
                {
                    allSpecTrans.insert(specTrans.RecId, specTrans);
                }
            }
            else
            {
                while select crossCompany specTrans
                    where specTrans.SpecCompany == specCompany &&
                        specTrans.SpecTableId == specTableId &&
                        specTrans.SpecRecId == specRecId &&
                        specTrans.RefTableId == refTableId
                {
                    allSpecTrans.insert(specTrans.RecId, specTrans);
                }
            }
        }

        return allSpecTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSpecRecId_RU</Name>
				<Source><![CDATA[
    public recId getSpecRecId_RU()
    {
        return specRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSpecTransCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a count of the <c>SpecTrans</c> records that correspond to this class instance.
    /// </summary>
    /// <returns>
    /// The count of <c>SpecTrans</c> records.
    /// </returns>
    public int getSpecTransCount()
    {
        int specTransCount;
        SpecTrans specTrans;

        if (cacheEnabled)
        {
            // If cache is not initialized, initialize with all records here.
            if (cacheInitialized == false)
            {
                this.initCacheWithMarkedTransactions();
            }

            specTransCount = specTransCache.getSpecTransCount();
        }
        else
        {
            if (refTableId == 0)
            {
                specTransCount = SpecTrans::getSpecTransCount(specCompany, specTableId, specRecId);
            }
            else
            {
                select crossCompany count(RecId) from specTrans
                    where specTrans.SpecCompany == specCompany &&
                        specTrans.SpecTableId == specTableId &&
                        specTrans.SpecRecId == specRecId &&
                        specTrans.RefTableId == refTableId;

                specTransCount = any2int(specTrans.RecId);
            }
        }

        return specTransCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCacheWithMarkedTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a cache by using existing <c>SpecTrans</c> records with a <c>SpecCompany</c>,
    ///    <c>SpecTableId</c>, and <c>SpecRecId</c> that correspond to this class instance.
    /// </summary>
    protected void initCacheWithMarkedTransactions()
    {
        SpecTrans specTrans;
        container markedTransactions;
        int i;

        markedTransactions = SpecTransManager::getMarkedTransactions(specCompany, specTableId, specRecId, refTableId);
        for (i = 1; i <= conLen(markedTransactions); i++)
        {
            specTrans = conPeek(markedTransactions, i);
            specTransCache.add(specTrans);
        }

        cacheInitialized = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertSpec</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the <c>SpecTrans</c> record with the <c>SpecCompany</c>, <c>SpecTableId</c>, and <c>SpecRecId</c> fields shared
    /// by this instance of the <c>SpecTransManager</c> class.
    /// </summary>
    /// <param name="_insertSpecTrans">
    /// The reference table ID of the <c>SpecTrans</c> record to be inserted.
    /// </param>
    /// <param name="_refCompany">
    /// The reference company of the <c>SpecTrans</c> record to be inserted.
    /// </param>
    /// <param name="_refTableId">
    /// The reference table ID of the <c>SpecTrans</c> record to be inserted.
    /// </param>
    /// <param name="_refRecId">
    /// The reference record ID of the <c>SpecTrans</c> record to be inserted.
    /// </param>
    /// <param name="_balance">
    /// The amount that have been paid for the transaction.
    /// </param>
    /// <param name="_currency">
    /// The currency of the marked transaction.
    /// </param>
    /// <param name="_markedPayment">
    /// The indicator that the marked transaction is the primary payment; Optional.
    /// </param>
    /// <param name="_discAmountToTake">
    /// The cash discount amount of the marked transaction to be settled; Optional.
    /// </param>
    /// <param name="_selectedDateUsedToCalcCashDisc">
    /// The payment date for the calculation of cash discount to be settled.
    /// </param>
    /// <returns>
    /// A record of the <c>SpecTrans</c> table.
    /// </returns>
    public SpecTrans insertSpec(
        SpecTrans _insertSpecTrans,
        CompanyId _refCompany,
        tableId _refTableId,
        RefRecId _refRecId,
        Amount _balance,
        CurrencyCode _currency,
        NoYes _markedPayment = NoYes::No,
        CashDiscAmount _discAmountToTake = 0,
        TransDate _selectedDateUsedToCalcCashDisc = dateNull())
    {
        _insertSpecTrans.SpecCompany                    = specCompany;
        _insertSpecTrans.SpecTableId                    = specTableId;
        _insertSpecTrans.SpecRecId                      = specRecId;
        _insertSpecTrans.RefCompany                     = _refCompany;
        _insertSpecTrans.RefTableId                     = _refTableId;
        _insertSpecTrans.RefRecId                       = _refRecId;
        _insertSpecTrans.Balance01                      = _balance;
        _insertSpecTrans.Code                           = _currency;
        _insertSpecTrans.Payment                        = _markedPayment;
        _insertSpecTrans.CashDiscToTake                 = _discAmountToTake;
        _insertSpecTrans.SelectedDateUsedToCalcCashDisc = _selectedDateUsedToCalcCashDisc;
        _insertSpecTrans.insert();

        if (cacheEnabled)
        {
            // If cache is not initialized, initialize with all records here.
            if (!cacheInitialized)
            {
                this.initCacheWithMarkedTransactions();
            }

            // Add SpecTrans to cache
            specTransCache.add(_insertSpecTrans);
        }

        return _insertSpecTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isMarkedPayment</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the specified record in the <c>SpecTrans</c> table with the <c>Payment</c> field
    ///    set to <c>NoYes::Yes</c> exists.
    /// </summary>
    /// <param name="_refCompany">
    ///    The reference company of the <c>SpecTrans</c> record to find.
    /// </param>
    /// <param name="_refTableId">
    ///    The reference table ID of the <c>SpecTrans</c> record to find.
    /// </param>
    /// <param name="_refRecId">
    ///    The reference record ID of the <c>SpecTrans</c> record to find.
    /// </param>
    /// <returns>
    ///    true if the specified record is marked as payment; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Replaces the <c>existPaymentRefSpecTrans</c> method on the <c>SpecTrans</c> table.
    /// </remarks>
    public boolean isMarkedPayment(CompanyId _refCompany, tableId _refTableId, RefRecId _refRecId)
    {
        boolean isMarkedPayment = false;
        SpecTrans specTrans;
        boolean inMissingCache = false;

        if (cacheEnabled)
        {
            // If cache is not initialized, initialize with all records here.
            if (cacheInitialized == false)
            {
                this.initCacheWithMarkedTransactions();
            }

            specTrans = specTransCache.getMarkedPaymentSpecTrans();

            if (specTrans.RefCompany == _refCompany && specTrans.RefTableId == _refTableId && specTrans.RefRecId == _refRecId)
            {
                isMarkedPayment = true;
            }
            else
            {
                isMarkedPayment = false;
            }

            if (specTrans.RecId == 0)
            {
                // Check if it is in the missing cache
                inMissingCache = specTransCache.inMissingCache(_refCompany, _refTableId, _refRecId);
            }
        }

        if (cacheEnabled == false || (specTrans.RecId == 0 && inMissingCache == false))
        {
            // Find corresponding SpecTrans in current spec set
            select firstonly crossCompany RecId from specTrans where
                specTrans.SpecCompany == specCompany &&
                specTrans.SpecTableId == specTableId &&
                specTrans.SpecRecId == specRecId &&
                specTrans.RefCompany == _refCompany &&
                specTrans.RefTableId == _refTableId &&
                specTrans.RefRecId == _refRecId &&
                specTrans.Payment == NoYes::Yes;

            isMarkedPayment = specTrans.RecId != 0;

            if (cacheEnabled == true)
            {
                if (specTrans.RecId != 0)
                {
                    // Add record to cache
                    specTransCache.add(specTrans);
                }
                else
                {
                    // Add reference to missing cache
                    specTransCache.addAsMissing(_refCompany, _refTableId, _refRecId);
                }
            }
        }

        return isMarkedPayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs initialization for the <c>SpecTransManager</c> class.
    /// </summary>
    /// <param name="_specReference">
    ///    The table buffer used to initialize the class with the <c>Specification</c> fields.
    /// </param>
    /// <param name="_refTableId">
    ///    The table ID that is used to define the set of <c>SpecTrans</c> records. Zero should be used if the
    ///    table ID is not needed to define the set of <c>SpecTrans</c> records.
    /// </param>
    /// <param name="_enableCache">
    ///    A Boolean value that indicates whether a cache of the <c>SpecTrans</c> records will be maintained.
    /// </param>
    protected void new(Common _specReference, tableId _refTableId, boolean _enableCache)
    {
        if (_specReference)
        {
            // Initialize class variables for spec reference
            specCompany = _specReference.company();
            specTableId = _specReference.TableId;
            specRecId = _specReference.RecId;
        }

        refTableId = _refTableId;

        if (_enableCache)
        {
            cacheEnabled = true;
            specTransCache = new SpecTransCache(_specReference);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container specTransCachePack = conNull();
        if (specTransCache)
        {
            specTransCachePack = specTransCache.pack();
        }

        return [#CurrentList, specTransCachePack];
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _pack)
    {
        container specTransCachePack;

        [#CurrentList, specTransCachePack] = _pack;

        if (specTransCachePack != conNull())
        {
            specTransCache = SpecTransCache::create(specTransCachePack);
        }
        else
        {
            cacheEnabled = false;
            cacheInitialized = false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCrossRate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the referenced <c>SpecTrans</c> record with the specified exchange rate.
    /// </summary>
    /// <param name="_refCompany">
    ///    The reference company of the <c>SpecTrans</c> record to be updated.
    /// </param>
    /// <param name="_refTableId">
    ///    The reference table ID of the <c>SpecTrans</c> record to be updated.
    /// </param>
    /// <param name="_refRecId">
    ///    The reference record ID of the <c>SpecTrans</c> record to be updated.
    /// </param>
    /// <param name="_updateCrossRate">
    ///    The exchange rate that is used to translate from the currency of the marked transaction to the
    ///    payment currency.
    /// </param>
    public void updateCrossRate(CompanyId _refCompany, tableId _refTableId, RefRecId _refRecId, CrossExchRate _updateCrossRate)
    {
        SpecTrans specTrans;
        boolean validationPassed = true;

        // Validate to set the CrossRate field
        if (specTableId != tableNum(LedgerJournalTrans))
        {
            specTrans = this.findByMarkedPayment();

            if (specTrans.RecId == 0)
            {
                error("@SYS67735");
                validationPassed = false;
            }
        }

        if (validationPassed == true)
        {
            // Update the CrossRate field of the corresponding SpecTrans record in the database
            changecompany(_refCompany)
            {
                ttsbegin;

                specTrans = SpecTrans::find(specCompany, specTableId, specRecId, _refCompany, _refTableId, _refRecId, true);
                specTrans.CrossRate = _updateCrossRate;
                specTrans.update();

                ttscommit;
            }

            if (cacheEnabled)
            {
                // If cache is not initialized, initialize with all records here.
                if (cacheInitialized == false)
                {
                    this.initCacheWithMarkedTransactions();
                }

                // Update the corresponding SpecTrans record in cache
                specTransCache.update(specTrans);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFullSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the referenced <c>SpecTrans</c> record to mark for full settlement.
    /// </summary>
    /// <param name="_refCompany">
    ///    The reference company of the <c>SpecTrans</c> record to be updated.
    /// </param>
    /// <param name="_refTableId">
    ///    The reference table ID of the <c>SpecTrans</c> record to be updated.
    /// </param>
    /// <param name="_refRecId">
    ///    The reference record ID of the <c>SpecTrans</c> record to be updated.
    /// </param>
    /// <param name="_fullSettlement">
    ///    A Boolean value that indicates whether full settlement is marked.
    /// </param>
    /// <remarks>
    ///    This method replaces the <c>updateFullSettlement</c> method on the <c>Specification</c> class.
    /// </remarks>
    public void updateFullSettlement(
        CompanyId _refCompany,
        tableId _refTableId,
        RefRecId _refRecId,
        boolean _fullSettlement)
    {
        SpecTrans specTrans;
        boolean validationPassed = true;

        // Validate to set the FullSettlement field
        if (_fullSettlement == true)
        {
            if (this.exist(_refCompany, _refTableId, _refRecId) == false)
            {
                // If the transaction is not marked for settlement, throw an error
                error("@SYS77950");
                validationPassed = false;
            }
            else
            {
                // If another transaction is marked as FullSettlement, throw an error
                specTrans = this.findByFullSettlement();

                if (this.isTransactionAlreadyMarkedForFullSettlement(specTrans, _refCompany, _refTableId, _refRecId, _fullSettlement))
                {
                    error("@SYS77951");
                    validationPassed = false;
                }
            }
        }

        if (validationPassed == true)
        {
            // Update the FullSettlement field of the corresponding SpecTrans record in the database
            changecompany(_refCompany)
            {
                ttsbegin;

                specTrans = SpecTrans::find(specCompany, specTableId, specRecId, _refCompany, _refTableId, _refRecId, true);
                specTrans.FullSettlement = _fullSettlement;
                specTrans.update();

                ttscommit;
            }

            if (cacheEnabled)
            {
                // If cache is not initialized, initialize with all records here.
                if (cacheInitialized == false)
                {
                    this.initCacheWithMarkedTransactions();
                }

                // Update the corresponding SpecTrans record in cache
                specTransCache.update(specTrans);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransactionAlreadyMarkedForFullSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Is the transaction already marked for full settlement.
    /// </summary>
    /// <param name="_specTrans">
    ///  The full settlement <c>SpecTrans</c>
    /// </param>
    /// <param name="_refCompany">
    ///    The reference company of the <c>SpecTrans</c> record to be updated.
    /// </param>
    /// <param name="_refTableId">
    ///    The reference table ID of the <c>SpecTrans</c> record to be updated.
    /// </param>
    /// <param name="_refRecId">
    ///    The reference record ID of the <c>SpecTrans</c> record to be updated.
    /// </param>
    /// <param name="_fullSettlement">
    ///    A Boolean value that indicates whether full settlement is marked.
    /// </param>
    /// <returns>True when the transaction is already marked for full settlement; otherwise false.</returns>
    protected boolean isTransactionAlreadyMarkedForFullSettlement(
        SpecTrans _specTrans,
        CompanyId _refCompany,
        tableId _refTableId,
        RefRecId _refRecId,
        boolean _fullSettlement)
    {
        boolean ret;

        if (_specTrans.RecId != 0 &&
            (_specTrans.RefCompany != _refCompany ||
            _specTrans.RefTableId != _refTableId ||
            _specTrans.RefRecId != _refRecId))
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMarkedPayment</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the referenced <c>SpecTrans</c> record to mark as primary payment.
    /// </summary>
    /// <param name="_refCompany">
    ///    The reference company of the <c>SpecTrans</c> record to be updated.
    /// </param>
    /// <param name="_refTableId">
    ///    The reference table ID of the <c>SpecTrans</c> record to be updated.
    /// </param>
    /// <param name="_refRecId">
    ///    The reference record ID of the <c>SpecTrans</c> record to be updated.
    /// </param>
    /// <param name="_isMarked">
    ///    A Boolean value that indicates that a primary payment is marked.
    /// </param>
    /// <remarks>
    ///    Replaces the <c>setPaymentSpecTrans</c> method on the <c>SpecTrans</c> table.
    /// </remarks>
    public void updateMarkedPayment(CompanyId _refCompany, tableId _refTableId, RefRecId _refRecId, boolean _isMarked)
    {
        SpecTrans specTrans;
        boolean validationPassed = true;

        // Validate to set the Payment field
        if (_isMarked == true)
        {
            // If another transaction is marked as Payment, throw an error
            specTrans = this.findByMarkedPayment();

            if (specTrans.RecId != 0 &&
                (specTrans.RefCompany != _refCompany ||
                specTrans.RefTableId != _refTableId ||
                specTrans.RefRecId != _refRecId))
            {
                error("@SYS67734");
                validationPassed = false;
            }
        }

        if (validationPassed == true)
        {
            // Update the Payment field of the corresponding SpecTrans record in the database
            changecompany(_refCompany)
            {
                ttsbegin;

                specTrans = SpecTrans::find(specCompany, specTableId, specRecId, _refCompany, _refTableId, _refRecId, true);
                specTrans.Payment = _isMarked;
                specTrans.update();

                ttscommit;
            }

            if (cacheEnabled)
            {
                // If cache is not initialized, initialize with all records here.
                if (cacheInitialized == false)
                {
                    this.initCacheWithMarkedTransactions();
                }

                // Update the buffer and corresponding SpecTrans record in cache
                specTransCache.update(specTrans);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSettleAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the referenced <c>SpecTrans</c> record with the specified amount.
    /// </summary>
    /// <param name="_refCompany">
    ///    The reference company of the <c>SpecTrans</c> record to be updated.
    /// </param>
    /// <param name="_refTableId">
    ///    The reference table ID of the <c>SpecTrans</c> record to be updated.
    /// </param>
    /// <param name="_refRecId">
    ///    The reference record ID of the <c>SpecTrans</c> record to be updated.
    /// </param>
    /// <param name="_updateAmount">
    ///    The amount of the marked transaction to be settled.
    /// </param>
    /// <remarks>
    ///    This method replaces the <c>updateRefAmount</c> method on the <c>Specification</c> class.
    /// </remarks>
    public void updateSettleAmount(CompanyId _refCompany, tableId _refTableId, RefRecId _refRecId, Amount _updateAmount)
    {
        SpecTrans               specTrans;
        CustTransMarkedOpenLine custTransMarkedOpenLine;

        // Update the Balance01 field of the corresponding SpecTrans record in the database
        changecompany(_refCompany)
        {
            ttsbegin;

            specTrans = SpecTrans::find(specCompany, specTableId, specRecId, _refCompany, _refTableId, _refRecId, true);
            specTrans.Balance01 = _updateAmount;
            specTrans.update();

            // Mark Transaction line creates when customer parameter MarkOpenInvoiceLine is checked.
            select sum(AmountToSettle) from custTransMarkedOpenLine
            where custTransMarkedOpenLine.SpecTrans == specTrans.RecId;

            if (custTransMarkedOpenLine.AmountToSettle != _updateAmount)
            {
                //deleting all marked lines of current specTrans
                this.deleteAllLine(_refCompany, _refTableId, _refRecId);

                //marking SpecTrans line with updated amount
                this.insertAllLines(_refCompany, _refTableId, _refRecId, specTrans.RecId, _updateAmount, specTrans.CashDiscToTake);
            }

            ttscommit;
        }

        if (cacheEnabled)
        {
            // If cache is not initialized, initialize with all records here.
            if (cacheInitialized == false)
            {
                this.initCacheWithMarkedTransactions();
            }

            // Update the corresponding SpecTrans record in cache
            specTransCache.update(specTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the <c>SpecTrans</c> cache.
    /// </summary>
    /// <param name="_specTrans">
    /// The buffer of the <c>SpecTrans</c> table.
    /// </param>
    public void updateTransCache(SpecTrans _specTrans)
    {
        if (specTransCache != null)
        {
            specTransCache.update(_specTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Constructs an instance of the <c>SpecTransManager</c> class.
    /// </summary>
    /// <param name="_specReference">
    ///    The table buffer that is used for initializing the class.
    /// </param>
    /// <param name="_enableCache">
    ///    A Boolean value that indicates whether a cache of the <c>SpecTrans</c> records will be maintained;
    ///    optional.
    /// </param>
    /// <returns>
    ///    An instance of the <c>SpecTransManager</c> class.
    /// </returns>
    /// <remarks>
    ///    The table buffer should be either a <c>CustTable</c>, <c>VendTable</c>, <c>CustInvoiceTable</c>,
    ///    <c>SalesTable</c>, <c>PurchTable</c>, or <c>LedgerJournalTrans</c> table with an account type of
    ///    customer or vendor.This method replaces the <c>construct</c> method on the <c>Specification</c>
    ///    class and the <c>newCommon</c> method on the <c>Specification_OffsetVoucher</c> class.
    /// </remarks>
    [SysObsolete('This method has been deprecated. Please use the newFromSpec method instead.', false, 22\09\2020)]
    public static SpecTransManager construct(Common _specReference, boolean _enableCache = true)
    {
        return new SpecTransManager(_specReference, 0, _enableCache);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromSpec</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Constructs a V2, newFromSpec instance of the <c>SpecTransManager</c> class to fix memory issue with caching in batch.
    /// </summary>
    /// <param name="_specReference">
    ///    The table buffer that is used for initializing the class.
    /// </param>
    /// <param name="_enableCache">
    ///    A Boolean value that indicates whether a cache of the <c>SpecTrans</c> records will be maintained
    ///    changing default value to False;optional.
    /// </param>
    /// <returns>
    ///    An instance of the <c>SpecTransManager</c> class.
    /// </returns>
    /// <remarks>
    ///    The table buffer should be either a <c>CustTable</c>, <c>VendTable</c>, <c>CustInvoiceTable</c>,
    ///    <c>SalesTable</c>, <c>PurchTable</c>, or <c>LedgerJournalTrans</c> table with an account type of
    ///    customer or vendor.This method replaces the <c>construct</c> method on the <c>Specification</c>
    ///    class and the <c>newCommon</c> method on the <c>Specification_OffsetVoucher</c> class.
    /// </remarks>
    [Hookable(false)]
    public static SpecTransManager newFromSpec(Common _specReference, boolean _enableCache = false)
    {
        boolean enableCache = _enableCache;

        if (isFlightEnabled(CashManagementFlights::SpecTransAllowCacheInBatchProcessingFlight))
        {
            if (prmIsDefault(_enableCache))
            {
                // The previous method, SpecTransManager::construct, defaulted to enabling the cache
                // The new constructor, SpecTransManager::newFromSpec, defaults to disabling the cache
                // If the flight is enabled, we respect the old constructor and treat default as true
                enableCache = true;
            }
        }
        else
        {
            if (_enableCache && !SpecTransManager::isUIProcess())
            {
                // Otherwise, the cache is disabled for non-UI processes.
                SysInstrumentationLogger logger = SysInstrumentationLoggerFactory::CreateLogger(classStr(SpecTransManager));

                using (SysInstrumentationActivityContext context = logger.activityContext(CustVendInstrumentationConstants::ActivityNameSpecTransManagerCreation, CustVendInstrumentationConstants::InstrumentationNamespace))
                {
                    enableCache = false;

                    context.addCustomProperty(CustVendInstrumentationConstants::CustomPropertyDisableSpecTransManagerCache, any2Str(enableCache));
                }
            }
        }

        return SpecTransManager::construct(_specReference, enableCache);
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructServer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Constructs an instance of the <c>SpecTransManager</c> class located on the server tier.
    /// </summary>
    /// <param name="_specReference">
    ///    The table buffer used for initializing the class.
    /// </param>
    /// <param name="_enableCache">
    ///    A Boolean value that determines whether a cache of the <c>SpecTrans</c> records will be maintained;
    ///    optional.
    /// </param>
    /// <returns>
    ///    An instance of the <c>SpecTransManager</c> class.
    /// </returns>
    /// <remarks>
    ///    The table buffer should be from the <c>CustTable</c>, <c>VendTable</c>, <c>CustInvoiceTable</c>,
    ///    <c>SalesTable</c>, <c>PurchTable</c>, or <c>LedgerJournalTrans</c> table with an account type of
    ///    customer or vendor.
    ///    This method replaces the <c>constructServer</c> method on the
    ///    <c>Specification</c> class.
    /// </remarks>
    [SysObsolete('This method has been deprecated. Please use the newFromSpec method instead.', false, 22\09\2020)]
    public static SpecTransManager constructServer(Common _specReference, boolean _enableCache = true)
    {
        return SpecTransManager::construct(_specReference, _enableCache);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteAll</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes all <c>SpecTrans</c> records that have the same <c>SpecCompany</c>, <c>SpecTableId</c>, and
    ///    <c>SpecRecId</c> values as this class instance.
    /// </summary>
    /// <remarks>
    ///    Replaces the <c>deleteSpecifications</c> method on the <c>Specification</c> class.
    /// </remarks>
    public void deleteAll()
    {
        SpecTrans specTrans;
        SpecTrans specTransByCompany;

        // Delete all SpecTrans records in the current Spec set from database
        ttsbegin;

        if (BrazilParameters::isEnabled() && specTableId == tablenum(LedgerJournalTrans))
        {
            // Clear Interest/Fine information
            CustVendOpenTransManager::clearInterestAndFineAmounts_BR(specCompany, specTableId, specRecId);
        }

        // Because there is a cascading delete from SpecTrans to TaxWithholdTrans,
        // SpecTrans records must be deleted one RefCompany at a time.
        if (refTableId == 0)
        {
            SpecTrans::deleteSetForSingleOriginator(specCompany, specTableId, specRecId);
        }
        else
        {
            while select crossCompany RefCompany from specTransByCompany
                group by RefCompany
                where specTransByCompany.SpecCompany == specCompany
                    && specTransByCompany.SpecTableId == specTableId
                    && specTransByCompany.SpecRecId == specRecId
                    && specTransByCompany.RefTableId == refTableId
            {
                changecompany(specTransByCompany.RefCompany)
                {
                    delete_from specTrans
                        where specTrans.SpecCompany == specCompany
                            && specTrans.SpecTableId == specTableId
                            && specTrans.SpecRecId == specRecId
                            && specTrans.RefCompany == specTransByCompany.RefCompany
                            && specTrans.RefTableId == refTableId;
                }
            }
        }

        ttscommit;

        if (cacheEnabled)
        {
            // Remove all SpecTrans records in the current Spec set from cache
            specTransCache.removeAll();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteAllLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete all marked lines.
    /// </summary>
    /// <param name="_refCompany">
    /// The reference company of the <c>CustTransOpen</c> record.
    /// </param>
    /// <param name="_refTableId">
    /// The reference table ID of the <c>CustTransOpen</c> record.
    /// </param>
    /// <param name="_refCustTransOpenRecId">
    /// The reference record ID of the <c>CustTransOpen</c> record.
    /// </param>
    public void deleteAllLine(CompanyId _refCompany, tableId _refTableId, recId _refCustTransOpenRecId)
    {
        SpecTrans specTrans;
        CustTransMarkedOpenLine deleteSpecTransLine;

        changecompany(_refCompany)
        {
            delete_from deleteSpecTransLine
                exists join specTrans
                    where deleteSpecTransLine.SpecTrans == specTrans.RecId
                        && specTrans.SpecCompany == specCompany
                        && specTrans.SpecTableId == specTableId
                        && specTrans.SpecRecId == specRecId
                        && specTrans.RefCompany == _refCompany
                        && specTrans.RefTableId == _refTableId
                        && specTrans.RefRecId == _refCustTransOpenRecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>equalProration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts all invoice lines on the basis of amount to settle.
    /// </summary>
    /// <param name="_refCustTransOpenRecId">
    /// The reference record ID of the <c>CustTransOpen</c> record to be inserted.
    /// </param>
    /// <param name="_settleAmount">
    /// The amount to be distributed among the lines.
    /// </param>
    /// <param name="_refSpecTransRecId">
    /// The reference record ID of the <c>SpecTrans</c> record to be inserted.
    /// </param>
    /// <param name="_discAmountToTake">
    /// The cash discount amount to be distributed among the lines.
    /// </param>
    /// <param name="_totalMarkedTransaction">
    /// The number of transaction lines which have been fully marked.
    /// </param>
    /// <param name="_invoiceAmount">
    /// The total invoice amount.
    /// </param>
    /// <param name="_amountAvailableForSettlement">
    /// The total amount available for settlement.
    /// </param>
    /// <returns>
    /// Returns the available amount to settle.
    /// </returns>
    public AmountCur equalProration(
        RefRecId _refCustTransOpenRecId,
        AmountCur _settleAmount,
        RefRecId _refSpecTransRecId,
        CashDiscAmount _discAmountToTake,
        int _totalMarkedTransaction = 0,
        AmountCur _invoiceAmount = 0,
        AmountCur _amountAvailableForSettlement = 0)
    {
        CustTransMarkedOpenLine insertSpecTransLine;
        CustTransOpenLine       custTransOpenLine;
        CustTransOpen           custTransOpen;
        AmountCur               totalSettlementAmount;
        AmountCur               totalProportionalAmount;
        AmountCur               perTransSettlementAmount;
        AmountCur               lineAmountSettle;
        AmountCur               prorationLineAmountSettle;
        CurrencyCode            localCurrencyCode;
        CustTrans               custTrans;
        CashDiscAmount          totalLineDiscAmount;
        CustTransMarkedOpenLine custTransMarkedOpenLine;
        CashDiscAmount          lineDiscount;
        int countPartiallyPaidLines = 0;

        custTransOpen            = CustTransOpen::find(_refCustTransOpenRecId);
        custTrans                = custTransOpen.custTrans();
        localCurrencyCode        = custTrans.CurrencyCode;
        totalSettlementAmount    = _settleAmount;
        perTransSettlementAmount = _settleAmount;

        SpecTrans specTrans = this.findByRef(custTransOpen.company(), tableNum(CustTransOpen), custTransOpen.RecId);

        do
        {
            if (countPartiallyPaidLines > 0)
            {
                _totalMarkedTransaction = countPartiallyPaidLines;
            }

            prorationLineAmountSettle = CurrencyExchange::round(_settleAmount / _totalMarkedTransaction, localCurrencyCode);
            countPartiallyPaidLines = 0;

            while select RecId, CustTransOpen, AmountCur from custTransOpenLine
                order by RecId asc
                where custTransOpenLine.CustTransOpen == _refCustTransOpenRecId
                join CustTransOpenLine, AmountToSettle, CashDiscLineToTake from custTransMarkedOpenLine
                    where custTransMarkedOpenLine.SpecTrans == specTrans.RecId
                        && custTransMarkedOpenLine.CustTransOpenLine == custTransOpenLine.RecId
                        && custTransOpenLine.AmountCur > 0
                        && custTransOpenLine.AmountCur > custTransMarkedOpenLine.AmountToSettle + custTransMarkedOpenLine.CashDiscLineToTake
            {
                if (_settleAmount > 0)
                {
                    insertSpecTransLine = CustTransMarkedOpenLine::findByRefId(specTrans.RecId, custTransOpenLine.RecId, true);
                    insertSpecTransLine.SpecTrans = _refSpecTransRecId;
                    insertSpecTransLine.CustTransOpenLine = custTransOpenLine.RecId;
                    lineAmountSettle = CurrencyExchange::round( prorationLineAmountSettle + custTransMarkedOpenLine.AmountToSettle, localCurrencyCode);
                    lineDiscount = CurrencyExchange::round((custTransOpenLine.AmountCur / (_amountAvailableForSettlement + _discAmountToTake)) * _discAmountToTake, localCurrencyCode);

                    if (prorationLineAmountSettle + insertSpecTransLine.AmountToSettle >= custTransOpenLine.AmountCur - lineDiscount)
                    {
                        lineAmountSettle = custTransOpenLine.AmountCur - lineDiscount;
                        _settleAmount -= lineAmountSettle - insertSpecTransLine.AmountToSettle;
                        insertSpecTransLine.CashDiscLineToTake = lineDiscount;
                        totalProportionalAmount += lineAmountSettle - insertSpecTransLine.AmountToSettle;
                    }
                    else
                    {
                        lineAmountSettle = prorationLineAmountSettle + insertSpecTransLine.AmountToSettle;
                        _settleAmount -= prorationLineAmountSettle;
                        insertSpecTransLine.CashDiscLineToTake = CurrencyExchange::round((lineAmountSettle / _amountAvailableForSettlement) * _discAmountToTake, localCurrencyCode);
                        totalProportionalAmount += prorationLineAmountSettle;
                        countPartiallyPaidLines++;
                    }

                    if (totalProportionalAmount > perTransSettlementAmount)
                    {
                        lineAmountSettle -= totalProportionalAmount - perTransSettlementAmount;
                        _settleAmount += totalProportionalAmount - perTransSettlementAmount;
                    }
                        totalLineDiscAmount += insertSpecTransLine.CashDiscLineToTake;
                        insertSpecTransLine.AmountToSettle = lineAmountSettle;
                        totalLineDiscAmount -= insertSpecTransLine.CashDiscLineToTake;
                    insertSpecTransLine.CashDiscLineToTake = CurrencyExchange::round((insertSpecTransLine.AmountToSettle / _amountAvailableForSettlement) * _discAmountToTake, localCurrencyCode);
                        totalLineDiscAmount += insertSpecTransLine.CashDiscLineToTake;
                        totalSettlementAmount = totalSettlementAmount - prorationLineAmountSettle;
                }
                        insertSpecTransLine.update();
            }
        }
        while (_settleAmount > 0 && countPartiallyPaidLines > 0);

        return _settleAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMarkedTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets a container of <c>SpecTrans</c> records that correspond to specified parameters.
    /// </summary>
    /// <param name="_specCompany">
    ///    The spec company of the <c>SpecTrans</c> records to find.
    /// </param>
    /// <param name="_specTableId">
    ///    The spec table ID of the <c>SpecTrans</c> records to find.
    /// </param>
    /// <param name="_specRecId">
    ///    The spec record ID of the <c>SpecTrans</c> record to find.
    /// </param>
    /// <param name="_refTableId">
    ///    The ref table ID of the SpecTrans records to find.
    /// </param>
    /// <returns>
    ///    A container of <c>SpecTrans</c> records.
    /// </returns>
    /// <remarks>
    ///    This method adds <c>SpecTrans</c> records to container on the server tier to prevent unnecessary
    ///    RPC calls.
    /// </remarks>
    private static container getMarkedTransactions(CompanyId _specCompany, tableId _specTableId, RefRecId _specRecId, tableId _refTableId)
    {
        SpecTrans specTrans;
        container markedTransactions;

        if (_refTableId == 0)
        {
            while select crossCompany specTrans
                where specTrans.SpecCompany == _specCompany
                    && specTrans.SpecTableId == _specTableId
                    && specTrans.SpecRecId == _specRecId
            {
                markedTransactions += [specTrans];
            }
        }
        else
        {
            while select crossCompany specTrans
                where specTrans.SpecCompany == _specCompany
                    && specTrans.SpecTableId == _specTableId
                    && specTrans.SpecRecId == _specRecId
                    && specTrans.RefTableId == _refTableId
            {
                markedTransactions += [specTrans];
            }
        }

        return markedTransactions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalFineAmountForSpecRef_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the Fine total of the associated records in the <c>SpecTrans</c> table in the specified currency.
    /// </summary>
    /// <param name="_specCompany">
    /// The reference company of the group of <c>SpecTrans</c> records for which to calculate the total amount to settle.
    /// </param>
    /// <param name="_specTableId">
    /// The reference table ID of the group of <c>SpecTrans</c> records for which to calculate the total amount to settle.
    /// </param>
    /// <param name="_specRecId">
    /// The reference record ID of the group of <c>SpecTrans</c> records for which to calculate the total amount to settle.
    /// </param>
    /// <param name="_specCurrency">
    /// The currency of the referenced transaction that is used when converting the total.
    /// </param>
    /// <param name="_specCurrencyCompany">
    /// The company of the currency that is used when converting the total.
    /// </param>
    /// <param name="_exchRateDate">
    /// The date used to find exchange rates.
    /// </param>
    /// <param name="_exchRate">
    /// The exchange rate used to convert the total from the specified currency to the monetary standard (MST) currency; optional.
    /// </param>
    /// <returns>
    /// The total Fine amount of associated records in the <c>SpecTrans</c> table.
    /// </returns>
    public static AmountCur getTotalFineAmountForSpecRef_BR(
        CompanyId       _specCompany,
        tableId         _specTableId,
        RefRecId        _specRecId,
        CurrencyCode    _specCurrency,
        CompanyId       _specCurrencyCompany,
        TransDate       _exchRateDate,
        ExchRate        _exchRate = 0)
    {
        SpecTrans               specTrans;
        CustVendTransOpen       custVendTransOpen;
        CustVendTrans           custVendTrans;
        AmountCur               fineAmount;
        AmountCur               totalFineAmount;

        CompanyId specCompanyCurrency;
        CompanyId refCompanyCurrency;

        AmountMST               refAmountMst;
        CurrencyExchangeHelper  currencyHelper;

        currencyHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(_specCompany).RecId), _exchRateDate);

        while select crosscompany specTrans
              where specTrans.SpecCompany   == _specCompany &&
                    specTrans.SpecTableId   == _specTableId &&
                    specTrans.SpecRecId     == _specRecId
        {
            switch (specTrans.RefTableId)
            {
                case tablenum(CustTransOpen), tablenum(CustSettlement):
                    custVendTrans       = specTrans.custTrans();
                    custVendTransOpen   = specTrans.custTransOpen();
                    break;

                case tablenum(VendTransOpen), tablenum(VendSettlement):
                    custVendTrans       = specTrans.vendTrans();
                    custVendTransOpen   = specTrans.vendTransOpen();
                    break;

                default:
                    Debug::assert(false);
                    break;
            }

            fineAmount = custVendTransOpen.FineAmount_BR;

            if (custVendTrans.CurrencyCode == _specCurrency)
            {
                // Currencies are the same, no conversion needed, add to total
                totalFineAmount += fineAmount;
            }
            else if (specTrans.CrossRate != 0)
            {
                // CrossRate is specified, translate directly from Ref currency to Spec currency, round result
                totalFineAmount += CurrencyExchange::round(CurrencyExchange::calculateAmount(fineAmount, specTrans.CrossRate), _specCurrency);
            }
            else
            {
                // Set helper to convert to Ref company currency - use rate from RefCompany
                currencyHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(specTrans.RefCompany).RecId));
                refAmountMst = currencyHelper.calculateTransactionToAccounting(custVendTrans.CurrencyCode, fineAmount, false);

                if (specTrans.RefCompany != _specCurrencyCompany)
                {
                    // Get company currencies
                    changecompany(specTrans.RefCompany)
                    {
                        refCompanyCurrency = CompanyInfoHelper::standardCurrency();
                    }

                    changecompany(_specCurrencyCompany)
                    {
                        specCompanyCurrency = CompanyInfoHelper::standardCurrency();
                    }

                    if (refCompanyCurrency != specCompanyCurrency)
                    {
                        // Convert to spec ref company currency, interim result unrounded
                        refAmountMst = currencyHelper.calculateAccountingToTransaction(specCompanyCurrency, refAmountMst, false);
                    }
                }

                // Set helper to convert to Spec currency
                currencyHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(_specCurrencyCompany).RecId));

                if (_exchRate != 0)
                {
                    // Convert to spec currency - use exchange rate passed in, round result
                    // Note: we need to take the reciprocal of the exchange rate here because CurrencyExchHelper::calculateAmount
                    // method actually treats the exchange rate passed in as an 100 based ratio on the amount passed in.
                    refAmountMst = CurrencyExchange::calculateAmount(refAmountMst, (100 * 100 / _exchRate));
                    totalFineAmount += CurrencyExchange::round(refAmountMst, _specCurrency);
                }
                else
                {
                    // Convert to spec currency - lookup rate, round result
                    totalFineAmount += currencyHelper.calculateAccountingToTransaction(_specCurrency, refAmountMst, true);
                }
            }
        }

        return totalFineAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalInterestAmountForSpecRef_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the Interest total of the associated records in the <c>SpecTrans</c> table in the specified currency.
    /// </summary>
    /// <param name="_specCompany">
    /// The reference company of the group of <c>SpecTrans</c> records for which to calculate the total amount to settle.
    /// </param>
    /// <param name="_specTableId">
    /// The reference table ID of the group of <c>SpecTrans</c> records for which to calculate the total amount to settle.
    /// </param>
    /// <param name="_specRecId">
    /// The reference record ID of the group of <c>SpecTrans</c> records for which to calculate the total amount to settle.
    /// </param>
    /// <param name="_specCurrency">
    /// The currency of the referenced transaction that is used when converting the total.
    /// </param>
    /// <param name="_specCurrencyCompany">
    /// The company of the currency that is used when converting the total.
    /// </param>
    /// <param name="_exchRateDate">
    /// The date used to find exchange rates.
    /// </param>
    /// <param name="_exchRate">
    /// The exchange rate used to convert the total from the specified currency to the monetary standard (MST) currency; optional.
    /// </param>
    /// <returns>
    /// The total Interest amount of associated records in the <c>SpecTrans</c> table.
    /// </returns>
    public static AmountCur getTotalInterestAmountForSpecRef_BR(
        CompanyId       _specCompany,
        tableId         _specTableId,
        RefRecId        _specRecId,
        CurrencyCode    _specCurrency,
        CompanyId       _specCurrencyCompany,
        TransDate       _exchRateDate,
        ExchRate        _exchRate = 0)
    {
        SpecTrans               specTrans;
        CustVendTransOpen       custVendTransOpen;
        CustVendTrans           custVendTrans;
        AmountCur               finInterestAmount;
        AmountCur               totalFinInterestAmount;

        CompanyId specCompanyCurrency;
        CompanyId refCompanyCurrency;

        AmountMST               refAmountMst;
        CurrencyExchangeHelper  currencyHelper;

        currencyHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(_specCompany).RecId), _exchRateDate);

        while select crosscompany specTrans
              where specTrans.SpecCompany   == _specCompany &&
                    specTrans.SpecTableId   == _specTableId &&
                    specTrans.SpecRecId     == _specRecId
        {
            switch (specTrans.RefTableId)
            {
                case tablenum(CustTransOpen), tablenum(CustSettlement):
                    custVendTrans       = specTrans.custTrans();
                    custVendTransOpen   = specTrans.custTransOpen();
                    break;

                case tablenum(VendTransOpen), tablenum(VendSettlement):
                    custVendTrans = specTrans.vendTrans();
                    custVendTransOpen   = specTrans.vendTransOpen();
                    break;

                default:
                    Debug::assert(false);
                    break;
            }

            finInterestAmount = custVendTransOpen.InterestAmount_BR;

            if (custVendTrans.CurrencyCode == _specCurrency)
            {
                // Currencies are the same, no conversion needed, add to total
                totalFinInterestAmount += finInterestAmount;
            }
            else if (specTrans.CrossRate != 0)
            {
                // CrossRate is specified, translate directly from Ref currency to Spec currency, round result
                totalFinInterestAmount += CurrencyExchange::round(CurrencyExchange::calculateAmount(finInterestAmount, specTrans.CrossRate), _specCurrency);
            }
            else
            {
                // Set helper to convert to Ref company currency - use rate from RefCompany
                currencyHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(specTrans.RefCompany).RecId));
                refAmountMst = currencyHelper.calculateTransactionToAccounting(custVendTrans.CurrencyCode, finInterestAmount, false);

                if (specTrans.RefCompany != _specCurrencyCompany)
                {
                    // Get company currencies
                    changecompany(specTrans.RefCompany)
                    {
                        refCompanyCurrency = CompanyInfoHelper::standardCurrency();
                    }

                    changecompany(_specCurrencyCompany)
                    {
                        specCompanyCurrency = CompanyInfoHelper::standardCurrency();
                    }

                    if (refCompanyCurrency != specCompanyCurrency)
                    {
                        // Convert to spec ref company currency, interim result unrounded
                        refAmountMst = currencyHelper.calculateAccountingToTransaction(specCompanyCurrency, refAmountMst, false);
                    }
                }

                // Set helper to convert to Spec currency
                currencyHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(_specCurrencyCompany).RecId));

                if (_exchRate != 0)
                {
                    // Convert to spec currency - use exchange rate passed in, round result
                    // Note: we need to take the reciprocal of the exchange rate here because CurrencyExchHelper::calculateAmount
                    // method actually treats the exchange rate passed in as an 100 based ratio on the amount passed in.
                    refAmountMst = CurrencyExchange::calculateAmount(refAmountMst, (100 * 100 / _exchRate));
                    totalFinInterestAmount += CurrencyExchange::round(refAmountMst, _specCurrency);
                }
                else
                {
                    // Convert to spec currency - lookup rate, round result
                    totalFinInterestAmount += currencyHelper.calculateAccountingToTransaction(_specCurrency, refAmountMst, true);
                }
            }
        }

        return totalFinInterestAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalSettleAmountForSpecReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total of the associated records in the <c>SpecTrans</c> table in the specified
    /// currency.
    /// </summary>
    /// <param name="_specCompany">
    /// The reference company of the group of <c>SpecTrans</c> records for which to calculate the total
    /// amount to settle.
    /// </param>
    /// <param name="_specTableId">
    /// The reference table ID of the group of <c>SpecTrans</c> records for which to calculate the total
    /// amount to settle.
    /// </param>
    /// <param name="_specRecId">
    /// The reference record ID of the group of <c>SpecTrans</c> records for which to calculate the total
    /// amount to settle.
    /// </param>
    /// <param name="_specCurrency">
    /// The currency of the referenced transaction that is used when it converts the total.
    /// </param>
    /// <param name="_specCurrencyCompany">
    /// The company of the currency that is used when converting the total.
    /// </param>
    /// <param name="_exchRateDate">
    /// The date used to find exchange rates.
    /// </param>
    /// <param name="_exchRate">
    /// The exchange rate used to convert the total from the specified currency to the monetary standard
    /// (MST) currency; optional.
    /// </param>
    /// <returns>
    /// The total amount of associated records in the <c>SpecTrans</c> table.
    /// </returns>
    /// <remarks>
    /// This method replaces the <c>specAmount</c> method on the <c>Specification_OffsetVoucher</c> class.
    /// </remarks>
    public static AmountCur getTotalSettleAmountForSpecReference(
        CompanyId _specCompany,
        tableId _specTableId,
        RefRecId _specRecId,
        CurrencyCode _specCurrency,
        CompanyId _specCurrencyCompany,
        TransDate _exchRateDate,
        ExchRate _exchRate = 0)
    {
        #ISOCountryRegionCodes
        SpecTrans specTrans;
        TaxWithholdTrans taxWithholdTrans;
        AmountCur specTransBalance;
        AmountCur totalSettleAmount;
        CompanyId specCompanyCurrency;
        CompanyId refCompanyCurrency;
        AmountMST refAmountMst;
        CurrencyExchangeHelper currencyHelper;
        CustVendTrans custVendTrans;

        TaxWithholdTransExtensionTH taxWithholdTransExtensionTH;
        CFMPaymentRequestTable  paymentRequestTable;

        currencyHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(_specCurrencyCompany).RecId), _exchRateDate);

        // Loop through all SpecTrans in the current spec set, convert amount to given currency & add to total
        while select crossCompany specTrans
            where specTrans.SpecCompany == _specCompany
                && specTrans.SpecTableId == _specTableId
                && specTrans.SpecRecId == _specRecId
        {
            // Get the currency for the marked transaction
            switch (specTrans.RefTableId)
            {
                case tableNum(CustTransOpen), tableNum(CustSettlement):
                    custVendTrans = specTrans.custTrans();
                    break;

                case tableNum(VendTransOpen), tableNum(VendSettlement):
                    custVendTrans = specTrans.vendTrans();
                    break;

                case tableNum(CFMPaymentRequestTable): //for manual payment requests
                    paymentRequestTable = specTrans.paymentRequestTable();
                    custVendTrans = null;
                    if (paymentRequestTable.RecId)
                    {
                        totalSettleAmount += specTrans.Balance01;
                    }
                    break;

                default:
                    Debug::assert(false);
                    break;
            }

            if (!custVendTrans)
            {
                continue;
            }

            specTransBalance = SpecTransManager::getSpecTransBalanceForTaxWithholding(specTrans);

            if (custVendTrans.CurrencyCode == _specCurrency)
            {
                // Currencies are the same, no conversion needed, add to total
                totalSettleAmount += specTransBalance;
            }
            else if (specTrans.CrossRate != 0)
            {
                // CrossRate is specified, translate directly from Ref currency to Spec currency, round result
                totalSettleAmount += CurrencyExchange::round(CurrencyExchange::calculateAmount(specTransBalance, specTrans.CrossRate), _specCurrency);
            }
            else
            {
                // Set helper to convert to Ref company currency - use rate from RefCompany
                currencyHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(specTrans.RefCompany).RecId));
                refAmountMst = currencyHelper.calculateTransactionToAccounting(custVendTrans.CurrencyCode, specTransBalance, false);

                if (specTrans.RefCompany != _specCurrencyCompany)
                {
                    changecompany(specTrans.RefCompany)
                    {
                        refCompanyCurrency = CompanyInfoHelper::standardCurrency();
                        currencyHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(specTrans.RefCompany).RecId));
                    }

                    changecompany(_specCurrencyCompany)
                    {
                        specCompanyCurrency = CompanyInfoHelper::standardCurrency();
                    }

                    if (refCompanyCurrency != specCompanyCurrency)
                    {
                        // Convert to spec ref company currency, interim result unrounded
                        refAmountMst = currencyHelper.calculateAccountingToTransaction(specCompanyCurrency, refAmountMst, false);
                    }
                }

                // Set helper to convert to Spec currency
                currencyHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(_specCurrencyCompany).RecId));

                if (_exchRate != 0)
                {
                    // Convert to spec currency - use exchange rate passed in, round result
                    // Note: we need to take the reciprocal of the exchange rate here because CurrencyExchHelper::calculateAmount
                    // method actually treats the exchange rate passed in as an 100 based ratio on the amount passed in.
                    refAmountMst = CurrencyExchange::calculateAmount(refAmountMst, (100 * 100 / _exchRate));
                    totalSettleAmount += CurrencyExchange::round(refAmountMst, _specCurrency);
                }
                else
                {
                    // Convert to spec currency - lookup rate, round result
                    totalSettleAmount += currencyHelper.calculateAccountingToTransaction(_specCurrency, refAmountMst, true);
                }
            }

        }

        return totalSettleAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSpecTransBalanceForTaxWithholding</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the settlement balance adjusted for tax withholding.
    /// </summary>
    /// <param name = "_specTrans">
    /// The marked settlement.
    /// </param>
    /// <returns>
    /// The settlement amount that has been adjusted for tax withholding.
    /// </returns>
    public static AmountCur getSpecTransBalanceForTaxWithholding(SpecTrans _specTrans)
    {
        #ISOCountryRegionCodes
        TaxWithholdTrans taxWithholdTrans;
        AmountCur specTransBalance;
        TaxWithholdTransExtensionTH taxWithholdTransExtensionTH;

        if (_specTrans.RefTableId == tableNum(VendTransOpen)
            || (_specTrans.RefTableId == tableNum(CustTransOpen)
                && (TaxWithholdingGlobalFeature::isExtendedWHTSupportedInCountryRegionOrParamEnabled()
                || BrazilParameters::isEnabled())))
        {
            taxWithholdTrans = null;

            if (TaxThaiGovCertificationFeatureChecker::isTaxWithholdEnabled())
            {
                changecompany(_specTrans.RefCompany)
                {
                    // Include withholding tax amount in Ref currency before translating to Spec currency
                    select sum(InvoiceTaxWithholdAmount)from taxWithholdTrans
                        where taxWithholdTrans.SpecTransId == _specTrans.RecId
                        join sum(InvoiceCurExpenseAmount) from taxWithholdTransExtensionTH
                            where taxWithholdTransExtensionTH.TaxWithholdTrans == taxWithholdTrans.RecId;
                }

                specTransBalance = _specTrans.Balance01 + taxWithholdTrans.InvoiceTaxWithholdAmount - taxWithholdTransExtensionTH.InvoiceCurExpenseAmount;
            }
            else
            {
                changecompany(_specTrans.RefCompany)
                {
                    // Include withholding tax amount in Ref currency before translating to Spec currency
                    select sum(InvoiceTaxWithholdAmount) from taxWithholdTrans
                        where taxWithholdTrans.SpecTransId == _specTrans.RecId;
                }

                if (!BrazilParameters::isEnabled() || _specTrans.RefTableId == tableNum(VendTransOpen))
                {
                    specTransBalance = _specTrans.Balance01 + taxWithholdTrans.InvoiceTaxWithholdAmount;
                }
                else
                {
                    specTransBalance = _specTrans.Balance01 - taxWithholdTrans.InvoiceTaxWithholdAmount;
                }
            }
        }
        else
        {
            specTransBalance = _specTrans.Balance01;
        }


        return specTransBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertAllLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts all invoice lines based on amount to settle.
    /// </summary>
    /// <param name="_refCompany">
    ///    The reference company of the <c>SpecTrans</c> record to insert.
    /// </param>
    /// <param name="_refTableId">
    ///    The reference table ID of the <c>SpecTrans</c> record to insert.
    /// </param>
    /// <param name="_refCustTransOpenRecId">
    ///    The reference record ID of the <c>CustTransOpen</c> record to insert.
    /// </param>
    /// <param name="_refSpecTransRecId">
    ///    The reference record ID of the <c>SpecTrans</c> record to insert.
    /// </param>
    /// <param name="_settleAmount">
    ///    The amount to be distributed among the lines.
    /// </param>
    /// <param name="_discAmountToTake">
    ///    The cash discount amount to be distributed among the lines.
    /// </param>
    public void insertAllLines(
        CompanyId _refCompany,
        tableId _refTableId,
        RefRecId _refCustTransOpenRecId,
        RefRecId _refSpecTransRecId,
        AmountCur _settleAmount,
        CashDiscAmount _discAmountToTake = 0)
    {
        CustTransMarkedOpenLine insertSpecTransLine;
        CustTransOpenLine custTransOpenLine;
        CustTransOpen custTransOpen;
        CustTrans custTrans;
        AmountCur totalAmountCur;
        AmountCur remainingTotalAmount;
        AmountCur remainingSettlementAmount;
        AmountCur remainingLineAmount;
        CashDiscAmount remainingDiscToTake;
        boolean isAnyLines;
        RecordInsertList recordInsertListMarkedLines;
        AmountCur lineAmountSettle;
        AmountCur negativeInvoiceAmount;
        AmountCur positiveInvoiceAmount;
        AmountCur prorationLastLineAmountSettle;
        AmountCur prorationLineAmountSettle;
        AmountCur totalAmount;
        AmountCur totalProportionalAmount;
        boolean pennyDifference = false;
        CashDiscAmount lineDiscount;
        CustBillingClassificationCode custBillingClassificationCode;
        CustInvoiceLine custInvoiceLine;
        CustInvoiceLinePriority custInvoiceLinePriority;
        CustInvoiceTrans custInvoiceTrans;
        CustParameters custParameters;
        CustSettlementPriority custSettlementPriority;
        CustSettlementProrationType custSettlementProrationType;
        Enumerator openLinesEnumerator;
        int countPartiallyPaidLines = 0;
        int lineCounter = 0;
        int totalNegativeLines = 0;
        int totalPositiveLines = 0;
        List openLinesToMark;

        changecompany(_refCompany)
        {
            if ((tableNum(CustTransOpen) == _refTableId) && (CustTransOpen::exist(_refCustTransOpenRecId)))
            {
                custTransOpen = CustTransOpen::find(_refCustTransOpenRecId);
                custTrans = custTransOpen.custTrans();

                totalAmountCur = _settleAmount + _discAmountToTake;
                remainingTotalAmount = totalAmountCur;
                remainingDiscToTake = _discAmountToTake;
                remainingSettlementAmount = _settleAmount;

                recordInsertListMarkedLines = new RecordInsertList(tableNum(CustTransMarkedOpenLine));

                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                {
                    totalAmount = _settleAmount;
                    custInvoiceLinePriority = CustParameters::find().InvoiceLinePriority;
                    custSettlementProrationType = CustParameters::find().ProrationType;
                    custSettlementPriority = CustSettlementPriority::findByAttribute(CustSettlementPriorityAttribute::Billing);
                    openLinesToMark = new List(Types::Record);
                    custParameters = CustParameters::findByCompany(_refCompany);
                }

                ttsbegin;

                //marking negative lines
                while select custTransOpenLine
                    order by RecId asc
                    where custTransOpenLine.CustTransOpen == _refCustTransOpenRecId
                        && custTransOpenLine.AmountCur < 0
                {
                    remainingLineAmount = custTransOpenLine.findRemainingAmountCur();

                    if (remainingTotalAmount > 0 && remainingLineAmount != 0.0)
                    {
                        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                        {
                            totalNegativeLines++;
                            negativeInvoiceAmount += custTransOpenLine.AmountCur;
                        }

                        [remainingTotalAmount, insertSpecTransLine, remainingSettlementAmount, remainingDiscToTake] = this.markedSpecTransLine(
                            custTransOpenLine,
                            _refSpecTransRecId,
                            _discAmountToTake,
                            remainingTotalAmount,
                            totalAmountCur,
                            remainingDiscToTake,
                            remainingSettlementAmount,
                            custTrans.CurrencyCode);

                        recordInsertListMarkedLines.add(insertSpecTransLine);

                        Debug::assert(remainingTotalAmount == (remainingSettlementAmount + remainingDiscToTake));

                        isAnyLines = true;
                    }
                }

                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                {
                    if (custSettlementPriority.Enabled == NoYes::Yes
                        && custInvoiceLinePriority == CustInvoiceLinePriority::BillingCode)
                    {
                        while select RecId, CustTransOpen, AmountCur, CustInvoiceLineIdRef from custTransOpenLine
                            where custTransOpenLine.CustTransOpen == _refCustTransOpenRecId
                                && custTransOpenLine.AmountCur > 0
                            outer join SourceDocumentLine, CustBillingCode from custInvoiceLine
                            join SourceDocumentLine, CustInvoiceLineIdRef from custInvoiceTrans
                                where custInvoiceTrans.CustInvoiceLineIdRef == custTransOpenLine.CustInvoiceLineIdRef
                                    && custInvoiceLine.SourceDocumentLine == custInvoiceTrans.SourceDocumentLine
                            outer join SettlementPriority, CustBillingCode from custBillingClassificationCode
                                order by custBillingClassificationCode.SettlementPriority asc, custTransOpenLine.RecId asc
                                where custInvoiceLine.CustBillingCode == custBillingClassificationCode.CustBillingCode
                        {
                            remainingLineAmount = custTransOpenLine.findRemainingAmountCur();

                            if (remainingTotalAmount > 0.0 && remainingLineAmount != 0.0)
                            {
                                if (custBillingClassificationCode.SettlementPriority > 0)
                                {
                                    [remainingTotalAmount, insertSpecTransLine, remainingSettlementAmount, remainingDiscToTake] = this.markedSpecTransLine(
                                        custTransOpenLine,
                                        _refSpecTransRecId,
                                        _discAmountToTake,
                                        remainingTotalAmount,
                                        totalAmountCur,
                                        remainingDiscToTake,
                                        remainingSettlementAmount,
                                        custTrans.CurrencyCode);

                                    recordInsertListMarkedLines.add(insertSpecTransLine);

                                    Debug::assert(remainingTotalAmount == (remainingSettlementAmount + remainingDiscToTake));
                                    isAnyLines = true;
                                }
                                else
                                {
                                    //Initialize a set object to store open transaction lines which do not contain billing code.
                                    openLinesToMark.addEnd(custTransOpenLine);
                                }
                            }
                        }

                        openLinesEnumerator = openLinesToMark.getEnumerator();

                        while (openLinesEnumerator.moveNext())
                        {
                            custTransOpenLine = openLinesEnumerator.current();

                            if (remainingTotalAmount > 0)
                            {
                                [remainingTotalAmount, insertSpecTransLine, remainingSettlementAmount, remainingDiscToTake] = this.markedSpecTransLine(
                                    custTransOpenLine,
                                    _refSpecTransRecId,
                                    _discAmountToTake,
                                    remainingTotalAmount,
                                    totalAmountCur,
                                    remainingDiscToTake,
                                    remainingSettlementAmount,
                                    custTrans.CurrencyCode);

                                recordInsertListMarkedLines.add(insertSpecTransLine);
                                Debug::assert(remainingTotalAmount == (remainingSettlementAmount + remainingDiscToTake));
                                isAnyLines = true;
                            }
                        }
                    }
                    //Performing Equal Proration
                    else if (custSettlementPriority.Enabled == NoYes::Yes
                        && custInvoiceLinePriority == CustInvoiceLinePriority::Proration
                        && custSettlementProrationType == CustSettlementProrationType::Equal)
                    {
                        totalAmount = remainingSettlementAmount;
                        totalPositiveLines = CustTransOpenLine::numOfLines(_refCustTransOpenRecId) - totalNegativeLines;
                        lineCounter = totalPositiveLines;

                        if (totalNegativeLines > 0)
                        {
                            _settleAmount = totalAmount;
                        }

                        if (totalPositiveLines != 0)
                        {
                            prorationLineAmountSettle = CurrencyExchange::round((remainingSettlementAmount) / totalPositiveLines, custTrans.CurrencyCode);

                            if (prorationLineAmountSettle * totalPositiveLines < remainingSettlementAmount)
                            {
                                prorationLastLineAmountSettle = prorationLineAmountSettle + (remainingSettlementAmount - (prorationLineAmountSettle * totalPositiveLines));
                                pennyDifference = true;
                            }
                        }

                        while select RecId, AmountCur, CustTransOpen from custTransOpenLine
                            order by RecId asc
                            where custTransOpenLine.CustTransOpen == _refCustTransOpenRecId
                                && custTransOpenLine.AmountCur > 0.0
                        {
                            remainingLineAmount = custTransOpenLine.findRemainingAmountCur();

                            if (remainingTotalAmount > 0.0 && remainingLineAmount != 0.0)
                            {
                                lineCounter--;
                                lineDiscount = CurrencyExchange::round((custTransOpenLine.AmountCur/(totalAmount)) * _discAmountToTake, custTrans.CurrencyCode);

                                if (lineCounter == 0 && pennyDifference)
                                {
                                    prorationLineAmountSettle = prorationLastLineAmountSettle;
                                }

                                if (prorationLineAmountSettle >= custTransOpenLine.AmountCur - lineDiscount)
                                {
                                    lineAmountSettle = custTransOpenLine.AmountCur - lineDiscount;
                                }
                                else
                                {
                                    lineAmountSettle = prorationLineAmountSettle;
                                    lineDiscount = CurrencyExchange::round((prorationLineAmountSettle / totalAmount) * _discAmountToTake, custTrans.CurrencyCode);
                                    countPartiallyPaidLines++;
                                }

                                _settleAmount -= lineAmountSettle;
                                totalProportionalAmount += lineAmountSettle;
                                remainingTotalAmount -= lineAmountSettle;
                                remainingSettlementAmount -= lineAmountSettle;
                                remainingDiscToTake -= lineDiscount;

                                if (totalProportionalAmount > totalAmount)
                                {
                                    lineAmountSettle -= totalProportionalAmount - totalAmount;
                                }

                                this.insertLine(
                                    _refCompany,
                                    _refTableId,
                                    _refCustTransOpenRecId,
                                    _refSpecTransRecId,
                                    custTransOpenLine.RecId,
                                    lineAmountSettle,
                                    lineDiscount);
                            }
                        }
                        if (countPartiallyPaidLines > 0 && _settleAmount > 0 && totalPositiveLines != countPartiallyPaidLines)
                        {
                            //To distribute the remaining amount among the lines which have been paid partially
                            remainingTotalAmount = this.equalProration(
                                _refCustTransOpenRecId,
                                _settleAmount,
                                _refSpecTransRecId,
                                _discAmountToTake,
                                countPartiallyPaidLines,
                                custTransOpen.AmountCur,
                                totalAmount);

                            remainingSettlementAmount = remainingTotalAmount;
                            remainingDiscToTake = 0;
                        }
                    }
                    //Performing Proportional Proration
                    else if (custSettlementPriority.Enabled == NoYes::Yes
                        && custInvoiceLinePriority == CustInvoiceLinePriority::Proration
                        && custSettlementProrationType == CustSettlementProrationType::Proportional)
                    {
                        totalAmount = remainingSettlementAmount;
                        positiveInvoiceAmount = custTransOpen.AmountCur - negativeInvoiceAmount;

                        while select RecId, AmountCur from custTransOpenLine
                            order by RecId asc
                            where custTransOpenLine.CustTransOpen == _refCustTransOpenRecId
                                && custTransOpenLine.AmountCur > 0
                        {
                            remainingLineAmount = custTransOpenLine.findRemainingAmountCur();

                            if (remainingLineAmount != 0.0)
                            {
                                lineAmountSettle = CurrencyExchange::round((totalAmount / positiveInvoiceAmount) * custTransOpenLine.AmountCur, custTrans.CurrencyCode);
                                lineDiscount = CurrencyExchange::round((lineAmountSettle / (totalAmount)) * _discAmountToTake, custTrans.CurrencyCode);
                                totalProportionalAmount += lineAmountSettle;

                                if (totalProportionalAmount > totalAmount)
                                {
                                    lineAmountSettle -= totalProportionalAmount - totalAmount;
                                }

                                this.insertLine(
                                    _refCompany,
                                    _refTableId,
                                    _refCustTransOpenRecId,
                                    _refSpecTransRecId,
                                    custTransOpenLine.RecId,
                                    lineAmountSettle,
                                    lineDiscount);

                                remainingSettlementAmount -= lineAmountSettle;
                                remainingTotalAmount -= lineAmountSettle;
                                remainingDiscToTake -= lineDiscount;
                            }
                        }
                    }
                    else
                    {
                        while select custTransOpenLine
                            order by RecId asc
                            where custTransOpenLine.CustTransOpen == _refCustTransOpenRecId
                                && custTransOpenLine.AmountCur > 0
                        {
                            remainingLineAmount = custTransOpenLine.findRemainingAmountCur();

                            if (remainingTotalAmount > 0 && remainingLineAmount != 0.0)
                            {
                                [remainingTotalAmount, insertSpecTransLine, remainingSettlementAmount, remainingDiscToTake] = this.markedSpecTransLine(
                                    custTransOpenLine,
                                    _refSpecTransRecId,
                                    _discAmountToTake,
                                    remainingTotalAmount,
                                    totalAmountCur,
                                    remainingDiscToTake,
                                    remainingSettlementAmount,
                                    custTrans.CurrencyCode);

                                recordInsertListMarkedLines.add(insertSpecTransLine);
                                Debug::assert(remainingTotalAmount == (remainingSettlementAmount + remainingDiscToTake));
                                isAnyLines = true;
                            }
                        }
                    }
                }
                else
                {
                    //marking positive lines
                    while select custTransOpenLine
                        order by RecId asc
                        where custTransOpenLine.CustTransOpen  == _refCustTransOpenRecId
                            && custTransOpenLine.AmountCur > 0
                    {
                        remainingLineAmount = custTransOpenLine.findRemainingAmountCur();

                        if (remainingTotalAmount > 0 && remainingLineAmount != 0.0)
                        {
                            [remainingTotalAmount, insertSpecTransLine, remainingSettlementAmount, remainingDiscToTake] = this.markedSpecTransLine(
                                custTransOpenLine,
                                _refSpecTransRecId,
                                _discAmountToTake,
                                remainingTotalAmount,
                                totalAmountCur,
                                remainingDiscToTake,
                                remainingSettlementAmount,
                                custTrans.CurrencyCode);

                            recordInsertListMarkedLines.add(insertSpecTransLine);

                            Debug::assert(remainingTotalAmount == (remainingSettlementAmount + remainingDiscToTake));

                            isAnyLines = true;
                        }
                    }
                }

                recordInsertListMarkedLines.insertDatabase();

                ttscommit;

                if (isAnyLines)
                {
                    Debug::assert(remainingTotalAmount == 0);
                    Debug::assert(remainingDiscToTake == 0);
                    Debug::assert(remainingSettlementAmount == 0);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts a specific invoice lines.
    /// </summary>
    /// <param name="_refCompany">
    ///    The reference company of the <c>SpecTrans</c> record to insert.
    /// </param>
    /// <param name="_refTableId">
    ///    The reference table ID of the <c>SpecTrans</c> record to insert.
    /// </param>
    /// <param name="_refCustTransOpenRecId">
    ///    The reference record ID of the <c>CustTransOpen</c> record to insert.
    /// </param>
    /// <param name="_refSpecTransRecId">
    ///    The reference record ID of the <c>SpecTrans</c> record to insert.
    /// </param>
    /// <param name="_refCustTransOpenLineRecId">
    ///    The reference record ID of the <c>CustTransOpenLine</c> record to insert.
    /// </param>
    /// <param name="_settleAmount">
    ///    The amount to decide on the line.
    /// </param>
    /// <param name="_discAmountToTake">
    ///    The cash discount amount to settle for lines; optional.
    /// </param>
    public void insertLine(
        CompanyId _refCompany,
        tableId _refTableId,
        RefRecId _refCustTransOpenRecId,
        RefRecId _refSpecTransRecId,
        RefRecId _refCustTransOpenLineRecId,
        AmountCur _settleAmount,
        CashDiscAmount _discAmountToTake = 0)
    {
        CustTransMarkedOpenLine insertSpecTransLine;

        changecompany(_refCompany)
        {
            if (tableNum(CustTransOpen) == _refTableId)
            {
                insertSpecTransLine.SpecTrans          = _refSpecTransRecId;
                insertSpecTransLine.CustTransOpenLine  = _refCustTransOpenLineRecId;
                insertSpecTransLine.AmountToSettle     = _settleAmount;
                insertSpecTransLine.CashDiscLineToTake =  _discAmountToTake;
                insertSpecTransLine.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the <c>SpecTrans</c> record with the <c>SpecCompany</c>, <c>SpecTableId</c>, and
    ///    <c>SpecRecId</c> fields shared by this instance of the <c>SpecTransManager</c> class.
    /// </summary>
    /// <param name="_refCompany">
    ///    The reference company of the <c>SpecTrans</c> record to be inserted.
    /// </param>
    /// <param name="_refTableId">
    ///    The reference table ID of the <c>SpecTrans</c> record to be inserted.
    /// </param>
    /// <param name="_refRecId">
    ///    The reference record ID of the <c>SpecTrans</c> record to be inserted.
    /// </param>
    /// <param name="_settleAmount">
    ///    The settlement amount of the marked transaction to be settled.
    /// </param>
    /// <param name="_currency">
    ///    The currency of the marked transaction.
    /// </param>
    /// <param name="_markedPayment">
    ///    The indicator that the marked transaction is the primary payment; optional.
    /// </param>
    /// <param name="_discAmountToTake">
    ///    The cash discount amount of the marked transaction to be settled; optional.
    /// </param>
    /// <param name="_selectedDateUsedToCalcCashDisc">
    ///    The payment date for the calculation of cash discount to be settled.
    /// </param>
    /// <remarks>
    ///    Replaces the <c>create</c> method on the <c>Specification</c> class.
    /// </remarks>
    public void insert(
        CompanyId _refCompany,
        tableId _refTableId,
        RefRecId _refRecId,
        Amount _settleAmount,
        CurrencyCode _currency,
        NoYes _markedPayment = NoYes::No,
        AmountCur _discAmountToTake = 0,
        TransDate _selectedDateUsedToCalcCashDisc = dateNull())
    {
        if (_refRecId == 0 || specRecId == 0)
        {
            return;
        }

        SpecTrans insertSpecTrans;

        changecompany(_refCompany)
        {
            ttsbegin;

            // Set SpecTrans fields & insert
            insertSpecTrans.SpecCompany = specCompany;
            insertSpecTrans.SpecTableId = specTableId;
            insertSpecTrans.SpecRecId = specRecId;
            insertSpecTrans.RefCompany = _refCompany;
            insertSpecTrans.RefTableId = _refTableId;
            insertSpecTrans.RefRecId = _refRecId;
            insertSpecTrans.Balance01 = _settleAmount;
            insertSpecTrans.Code = _currency;
            insertSpecTrans.Payment = _markedPayment;
            insertSpecTrans.CashDiscToTake = _discAmountToTake;
            insertSpecTrans.SelectedDateUsedToCalcCashDisc = _selectedDateUsedToCalcCashDisc;
            insertSpecTrans.insert();

            // Mark Transaction line creates when customer parameter MarkOpenInvoiceLine is checked.
            this.insertAllLines(_refCompany, _refTableId, _refRecId, insertSpecTrans.RecId, _settleAmount, _discAmountToTake);

            ttscommit;
        }

        if (cacheEnabled)
        {
            // If cache is not initialized, initialize with all records here.
            if (cacheInitialized == false)
            {
                this.initCacheWithMarkedTransactions();
            }

            // Add SpecTrans to cache
            specTransCache.add(insertSpecTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>markedSpecTransLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks the invoice line.
    /// </summary>
    /// <param name="_custTransOpenLine">
    /// The <c>CustTransOpenLine</c> record.
    /// </param>
    /// <param name="_specTransRecId">
    /// The unique record ID of <c>SpecTrans</c> table.
    /// </param>
    /// <param name="_discAmountToTake">
    /// The total discount amount to take on the invoice.
    /// </param>
    /// <param name="_remainingTotalAmount">
    /// The total remaining amount on the invoice.
    /// </param>
    /// <param name="_totalAmountCur">
    /// The total amount on the invoice.
    /// </param>
    /// <param name="_remainingDiscToTake">
    /// The total remaining discount on the invoice.
    /// </param>
    /// <param name="_remainingSettlementAmount">
    /// The total remaining amount to settle on the invoice.
    /// </param>
    /// <param name="_currencyCode">
    /// The <c>CurrencyCode</c> to use in exchange rate calculations.
    /// </param>
    /// <returns>
    /// The remaining amount, discount and amount to settle on the invoice and marked line.
    /// </returns>
    public container markedSpecTransLine(
        CustTransOpenLine _custTransOpenLine,
        RefRecId _specTransRecId,
        CashDiscAmount _discAmountToTake,
        AmountCur _remainingTotalAmount,
        AmountCur _totalAmountCur,
        CashDiscAmount _remainingDiscToTake,
        AmountCur _remainingSettlementAmount,
        CurrencyCode _currencyCode)
    {
        CustTransMarkedOpenLine specTransLine;
        AmountCur lineAmount;
        AmountCur lineAmountToSettle;
        AmountCur lineDiscAmount;

        AmountCur remainingLineAmount = _custTransOpenLine.findRemainingAmountCur();

        if (_remainingTotalAmount >= remainingLineAmount)
        {
            lineAmount = remainingLineAmount;
        }
        else
        {
            lineAmount = _remainingTotalAmount;
        }

        _remainingTotalAmount -= lineAmount;

        if (_remainingTotalAmount > 0)
        {
            lineDiscAmount =  CurrencyExchange::round(((lineAmount / _totalAmountCur) * _discAmountToTake), _currencyCode);
            lineAmountToSettle = lineAmount - lineDiscAmount;
        }
        else
        {
            lineDiscAmount =  _remainingDiscToTake;
            lineAmountToSettle = _remainingSettlementAmount;
        }

        specTransLine.SpecTrans = _specTransRecId;
        specTransLine.CustTransOpenLine = _custTransOpenLine.RecId;
        specTransLine.CashDiscLineToTake = lineDiscAmount;
        specTransLine.AmountToSettle = lineAmountToSettle;

        _remainingSettlementAmount -= lineAmountToSettle;
        _remainingDiscToTake -= lineDiscAmount;

        return [_remainingTotalAmount, specTransLine, _remainingSettlementAmount, _remainingDiscToTake];
    }

]]></Source>
			</Method>
			<Method>
				<Name>newRefTableId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs an instance of the <c>SpecTransManager</c> class.
    /// </summary>
    /// <param name="_specReference">
    /// The table buffer used for initializing the class.
    /// </param>
    /// <param name="_refTableId">
    /// The table id used for defining the set of <c>SpecTrans</c> records.
    /// </param>
    /// <param name="_enableCache">
    /// The flag indicating whether a cache of the <c>SpecTrans</c> records will be maintained.
    /// </param>
    /// <returns>
    /// An instance of the <c>SpecTransManager</c> class.
    /// </returns>
    /// <remarks>
    /// The <paramref name="_refTableId"/> should be specified if the <paramref name="_specReference"/> could
    /// reference <c>SpecTrans</c> records with multiple <c>RefTableId</c> values.
    /// </remarks>
    public static SpecTransManager newRefTableId(
        Common _specReference,
        tableId _refTableId,
        boolean _enableCache)
    {
        boolean enableCache = _enableCache;

        if (!isFlightEnabled(CashManagementFlights::SpecTransAllowCacheInBatchProcessingFlight))
        {
            if (enableCache && !SpecTransManager::isUIProcess())
            {
                SysInstrumentationLogger logger = SysInstrumentationLoggerFactory::CreateLogger(classStr(SpecTransManager));

                using (SysInstrumentationActivityContext context = logger.activityContext(CustVendInstrumentationConstants::ActivityNameSpecTransManagerCreation, CustVendInstrumentationConstants::InstrumentationNamespace))
                {
                    enableCache = false;

                    context.addCustomProperty(CustVendInstrumentationConstants::CustomPropertyDisableSpecTransManagerCache, any2Str(enableCache));
                }
            }
        }

        return new SpecTransManager(_specReference, _refTableId, enableCache);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUIProcess</Name>
				<Source><![CDATA[
    private static boolean isUIProcess()
    {
        return !BatchHeader::isExecutingInBatch() && hasGUI();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSettleBalanceAndDisc</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the referenced <c>SpecTrans</c> record with the specified balance and discount amount.
    /// </summary>
    /// <param name="_refCompany">
    ///    The reference company of the <c>SpecTrans</c> record to update.
    /// </param>
    /// <param name="_refTableId">
    ///    The reference table ID of the <c>SpecTrans</c> record to update.
    /// </param>
    /// <param name="_refRecId">
    ///    The reference record ID of the <c>SpecTrans</c> record to update.
    /// </param>
    /// <param name="_updateBalanceAmount">
    ///    The settlement amount of the marked transaction to settle.
    /// </param>
    /// <param name="_updateDiscAmount">
    ///    The cash discount amount of the marked transaction to settle.
    /// </param>
    /// <param name="_selectedDateUsedToCalcCashDisc">
    ///    The payment date for the calculation of cash discount to settle.
    /// </param>
    /// <remarks>
    ///    Replaces the <c>updateRefAmount</c> method on the <c>Specification</c> class.
    /// </remarks>
    public void updateSettleBalanceAndDisc(
        CompanyId _refCompany,
        tableId _refTableId,
        RefRecId _refRecId,
        Amount _updateBalanceAmount,
        Amount _updateDiscAmount,
        TransDate _selectedDateUsedToCalcCashDisc = dateNull())
    {
        SpecTrans specTrans;
        CustTransMarkedOpenLine custTransMarkedOpenLine;

        changecompany(_refCompany)
        {
            ttsbegin;

            specTrans = SpecTrans::find(specCompany, specTableId, specRecId, _refCompany, _refTableId, _refRecId, true);
            specTrans.Balance01 = _updateBalanceAmount;
            specTrans.CashDiscToTake = _updateDiscAmount;
            specTrans.SelectedDateUsedToCalcCashDisc = _selectedDateUsedToCalcCashDisc;
            specTrans.update();

            // Mark Transaction line creates when customer parameter MarkOpenInvoiceLine is checked.
            select sum(AmountToSettle), sum(CashDiscLineToTake) from custTransMarkedOpenLine
            where custTransMarkedOpenLine.SpecTrans == specTrans.RecId;

            if ((custTransMarkedOpenLine.AmountToSettle != _updateBalanceAmount) || (custTransMarkedOpenLine.CashDiscLineToTake != _updateDiscAmount))
            {
                //deleting all marked lines of current specTrans
                this.deleteAllLine(_refCompany, _refTableId, _refRecId);

                //marking SpecTrans line with updated amount
                this.insertAllLines(_refCompany, _refTableId, _refRecId, specTrans.RecId, _updateBalanceAmount, _updateDiscAmount);
            }

            ttscommit;
        }

        if (cacheEnabled)
        {
            // If cache is not initialized, initialize with all records here.
            if (cacheInitialized == false)
            {
                this.initCacheWithMarkedTransactions();
            }

            // Update the corresponding SpecTrans record in cache
            specTransCache.update(specTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findUnmarkedAmountForRef</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the remaining unmarked amount for an open transaction.
    /// </summary>
    /// <param name = "_totalAmountCur">The total open balance on the open transaction.</param>
    /// <param name="_refCompany">The reference company of the open transaction.</param>
    /// <param name="_refTableId">The reference table ID of the open transaction.</param>
    /// <param name="_refRecId">The reference record ID of the open transaction.</param>
    /// <returns>The remaining unmarked amount for the open transaction.</returns>
    public AmountCur findUnmarkedAmountForRef(
        AmountCur _totalAmountCur,
        DataAreaId _refCompany,
        TableId _refTableId,
        RefRecId _refRecId)
    {
        SpecTrans specTrans;
        CustVendPaymProposalLine custVendPaymProposalLine;

        select sum(Balance01), sum(CashDiscToTake) from specTrans
            where specTrans.RefCompany == _refCompany
                && specTrans.RefTableId == _refTableId
                && specTrans.RefRecId == _refRecId
                && !(specTrans.SpecCompany == specCompany
                    && specTrans.SpecTableId == specTableId
                    && specTrans.SpecRecId == specRecId)
            notexists join custVendPaymProposalLine
                    where specTrans.SpecTableId == tableNum(LedgerJournalTrans)
                        && custVendPaymProposalLine.LedgerJournalTransRecId == specTrans.SpecRecId;

        return _totalAmountCur - specTrans.Balance01 - specTrans.CashDiscToTake;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCashDiscountMarkedToBeTaken</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the cash discount amount marked to be taken for an open transaction.
    /// </summary>
    /// <param name="_refCompany">The reference company of the open transaction.</param>
    /// <param name="_refTableId">The reference table ID of the open transaction.</param>
    /// <param name="_refRecId">The reference record ID of the open transaction.</param>
    /// <returns>The cash discount amount marked to be taken for the open transaction.</returns>
    public DiscAmount findCashDiscountMarkedToBeTaken(
        DataAreaId _refCompany,
        TableId _refTableId,
        RefRecId _refRecId)
    {
        SpecTrans specTrans;
        CustVendPaymProposalLine custVendPaymProposalLine;

        select sum(CashDiscToTake) from specTrans
            where specTrans.RefCompany == _refCompany
                && specTrans.RefTableId == _refTableId
                && specTrans.RefRecId == _refRecId
                && !(specTrans.SpecCompany == specCompany
                    && specTrans.SpecTableId == specTableId
                    && specTrans.SpecRecId == specRecId)
            notexists join custVendPaymProposalLine
                where specTrans.SpecTableId == tableNum(LedgerJournalTrans)
                    && custVendPaymProposalLine.LedgerJournalTransRecId == specTrans.SpecRecId;

        return specTrans.CashDiscToTake;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTransFullyMarkedByOtherSpec</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if an open transaction is fully marked for settlement by other transactions.
    /// </summary>
    /// <param name="_custVendTransOpen">The open transaction for which to retrieve the marked status.</param>
    /// <returns>true if the open transaction is fully marked for settlement by other transactions; otherwise, false.</returns>
    public boolean checkTransFullyMarkedByOtherSpec(CustVendTransOpen _custVendTransOpen)
    {
        AmountCur unmarkedAmount = this.findUnmarkedAmountForRef(
            _custVendTransOpen.AmountCur,
            _custVendTransOpen.company(),
            _custVendTransOpen.TableId,
            _custVendTransOpen.RecId);

        return unmarkedAmount == 0.0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionMarkedMessageByRef</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a marked transaction error message with details on the marking process for a given transaction.
    /// </summary>
    /// <param name = "_refCompany">The transaction company.</param>
    /// <param name = "_refTableId">The transaction table.</param>
    /// <param name = "_refRecId">The transaction record.</param>
    /// <returns>The marked transaction error message.</returns>
    internal static str getTransactionMarkedMessageByRef(
        DataAreaId _refCompany,
        TableId _refTableId,
        RefRecId _refRecId)
    {
        SpecTrans specTrans = SpecTrans::findByRef(
            _refCompany,
            _refTableId,
            _refRecId);

        return SpecTransFindMarkedMessageFactory::newFromSpecRecord(
            specTrans.SpecCompany,
            specTrans.SpecTableId,
            specTrans.SpecRecId).getTransactionMarkedErrorMessage();
    }

]]></Source>
			</Method>
			<Method>
				<Name>filterDataSourceBySpecTransMarked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Filters a form datasource by the existence of matching <c>SpecTrans</c> records which match the given spec filter.
    /// </summary>
    /// <param name = "_specTransDataSource">The form datasource for the <c>SpecTrans</c> table.</param>
    /// <param name = "_joinMode">The join mode for the associated datasource.</param>
    /// <param name = "_specFilter">The filter for the spec side of a <c>SpecTrans</c> record.</param>
    public static void filterDataSourceBySpecTransMarked(QueryBuildDataSource _specTransDataSource, JoinMode _joinMode, Common _specFilter)
    {
        if (_specTransDataSource && _specTransDataSource.joinMode() != _joinMode)
        {
            _specTransDataSource.joinMode(_joinMode);

            if (_specFilter)
            {
                SysQuery::findOrCreateRange(_specTransDataSource, fieldNum(SpecTrans, SpecRecId)).value(int642Str(_specFilter.RecId));
                SysQuery::findOrCreateRange(_specTransDataSource, fieldNum(SpecTrans, SpecTableId)).value(int2Str(_specFilter.TableId));
            }
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>