<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ReqCalc</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class ReqCalc extends RunBaseBatch
{
    #OCCRetryCount
    #macrolib.Req
    #TimeConstants

    ReqTransNeutralTracker_Insert reqTransNeutralTracker;

    // Cancel check interval
    const int cancellationCheckIntervalInSeconds = 60;
    private int resourceSchedulingMaxRetryCount;

    // Orphan Task Bundles check interval
    private const int OrphanTasksBundlesCheckIntervalInSeconds = 5 * 60; // 5 minutes
    private utcdatetime lastOrphanTasksBundlesCheckDateTime;    

    // Parameters
    ReqPlanId               reqPlanId;
    ReqPlanVersion          sourcePlanVersion;
    ReqPlanVersion          targetPlanVersion;
    ReqPlanVersion          activePlanVersionOfDynamicPlan;
    ReqCalcUpdate           reqCalcUpdate;
    NoYes                   autoReserveCoverage;
    boolean                 thisIsChildThread;

    // Resource scheduler
    WrkCtrScheduler_Req             wrkCtrScheduler;
    ReqOrderPartitioner             reqOrderPartitioner;
    WrkCtrSchedulerRuntimes         wrkCtrSchedulerRuntimes;
    ReqCalcCapacityConflictHandler  capacityConflictsHandler;

    SysInstrumentationActivityContext instrumentationActivityContext;
    
    // Task controller
    ReqCalcTaskController   reqCalcTaskController;

    // Delayed orders
    ReqCalcMarkDelayed      reqCalcMarkDelayed;

    // Intercompany
    boolean                             interCompanyCalc;
    ReqIntercompanyDemandPlanFilter     intercompanyDemandPlanFilter;
    ReqIntercompanyPlanningGroupRecId   intercompanyGroup;

    // Dialog
    Dialog                  dialog;
    DialogField             dflReqPlanId;
    DialogField             dflReqCalcUpdate;
    DialogField             dflmaxChildThreads;
    DialogField             dflIsTaskTraceEnabled;
    DialogField             dflComment;
      
    // Global object
    // All queries to ReqParameters table should be performed against this buffer.
    // It will ensure that master scheduling uses the same parameters during the whole run.
    ReqParameters                       reqParameters;
    ReqPlanData                         reqPlanData;
    ReqMemoryCacheCurrentSessionScope   memoryCacheCurrentSessionScope;
    private ReqCalcProcessController    processController;

    ReqTransCache           reqTransCache;
    Connection              connectionLock;
    ReqPlan                 reqPlanLock;

    // All advanced operations on plans should be performed using this class instance only.
    ReqPlanManager          reqPlanManager;
    boolean                 doNotDisposeReqPlanManager;
    InventTable             inventTableLock;
    ReqTrans                previousReceipt;
    ReqTrans                firstIssueCoveredByPreviousReceipt;

    Set                     setErrorItemId;
    Set                     setReqTransUpdated;
    Set                     setApprovedPlannedOrder;

    //
    // Defines if a default dynamic master plan has been locked by the current scheduling run.
    // This variable is set at the moment when the plan is locked and keeps its value until the moment
    // when the plan is unlocked.
    //

    boolean                 isDynamicReqPlanLocked;
    ReqForecastReduce       reqForecastReduce;

    // Global variables
    ReqRetryCount           retryCountUpdConflict;
    ReqRetryCount           retryCountDeadlock;
    ReqProcessNumThreads    maxChildThreads;
    ReqProcessId            processId;
    ReqProcessThreadId      threadId;
    ReqProcessThreadId      externThreadId;
    boolean                 thisIsPeriodicProcess;
    Integer                 numOfThreadProcesses;
    ReqProcessStatus        currentStatus;
    boolean                 isTaskTraceEnabled;
    TodaysDate              todaysDate;
    boolean                 updateAllItems;
    Integer                 numOfLevels;
    Integer                 totalNumOfItems;
    boolean                 hasErrors;
    boolean                 canceled;
    boolean                 infrastructureFailure;
    ReqUseCache             reqUseCache;
    //
    // ID of a default dynamic master plan. This variable has not to be queried directly.
    // Instead, use ReqCalc.dynamicReqPlanId method.
    //
    ReqPlanId               dynamicReqPlanId;
    ReqPlanId               staticReqPlanId;
    ReqNumOfChanges         numOfChanges;
    boolean                 isReqLogMerged;
    ReqComment              comment;

    ReqNumOfTrans           logNumOfAutoFirm;
    ReqNumOfTrans           logNumOfAutoFirmRetry;

    boolean                 clearLog;
    boolean                 cleanupPerformed = false;
    boolean                 throwCovItemValidationErrors;

    boolean                 enableTableTraceLog;
    boolean                 recalculateBomLevels;
    boolean                 recalculateSameItemAgain;

    ReqTraceLogger          reqTraceLogger;
    boolean                 traceLoggingEnabled;
    boolean                 applyFuturesEventKanban;

    // Temp global objects, used when updating data
    Map                     mapQueryInventSum;

    ReqDate                 covPeriodReceiptFromDate;
    ReqDate                 covPeriodReceiptToDate;

    List                    scheduleOrdersList;
    int                     del_ProcessListSize;

    Map                     mapPlanGroupIssues;
    ReqDate                 pmfCurrentCoByReqDate;

    Map                     sortedIssueMap;
    Map                     sortedPrioritizedIssueMap;
    Map                     shelfLifeSafetyStockIssues;
    boolean                 safetyStockIssuesAdded;
    boolean                 isFirstFuturesScheduling;
    boolean                 disableAutoFirm;

    boolean                 multiUserConcurrencyAllowed;

    // cache
    ReqCalcRecordCacheInventDim     reqCalcRecordCacheInventDim;
    ReqCalcRecordCacheUnitOfMeasure reqCalcRecordCacheUnitOfMeasure;
    LeanLocationCache               leanLocationCache;
    ReqCalcCoverageEngine           coverageEngine;

    ReqBOMLevelCalc                 bomLevelCalc;
    BOMDependencyManager            bomDependencyManager;
    boolean                         isPreviousReceiptOnHand;
    InventQty                       safetyStockLevel;

    Map                             safetyStockExpirationDates;
    date                            nextSafetyStockExpiration;
    utcdatetime                     helperThreadsCheckLastTime;    
    
    ReqFuturesActiveSafetyStockRequirementsTracker activeSafetyStockRequirementsTracker;
    internal ReqFirmingRunId        firmingRunId;
    private  ReqInstrumentationLogger reqInstrumentationLogger;

    private ReqProcessId            resumeProcessId;
    private boolean                 includeBatchInventSumIsEnabled;
    private boolean                 fixedTodaysDateForExpiryCheckIsEnabled;
    internal boolean                reqBatchTasksSchedulingFixToggleEnabled;
    private boolean                 reqCoverageCalcForPriorityReqTransToggleEnabled;
    private boolean                 isReqCalcResourceSchedulingRetryEnabled;
    private boolean                 isReqCalcInconsistentDataSchedulingErrorFlightEnabled;

    private readonly boolean        reqCalcRetryExceptionErrorWhenCausedBySQLErrorEnabled;
    private readonly boolean        reqCalcBatchJobCancellingToggleEnabled;
    internal readonly boolean       automaticallyReacquireLocks;
    private Set setOrdersWithSchedulingErrors;
    private boolean schedulingSingleOrderFinishedSuccessfully;
    private readonly boolean isReqCalcResourceSchedulingRetryBundleEnabled;
    internal boolean isNativelyResumed;
    internal boolean nativeRestartResumeIsEnabled;
    internal boolean resumeHelperThreadsIsEnabled;
    private readonly boolean reqCalcConvertSqlStatementsToSysDaFlightEnabled;
    private readonly boolean reqInclShelfLifeIssuesInPeriodQtyCalculationFlightEnabled;
    private readonly boolean isReqCalcFinalizeLevelRerunBundlesSameTransFlightEnabled;
    protected readonly boolean reqCalcEndHelperThreadsWhenMainNotProcessingFlightEnabled;

    #DEFINE.CurrentVersion(15)
    #LOCALMACRO.CurrentList
        reqPlanId,
        reqCalcUpdate,
        autoReserveCoverage,
        maxChildThreads,
        isTaskTraceEnabled,
        recalculateBomLevels,
        comment,
        enableTableTraceLog
    #ENDMACRO

    #DEFINE.Version12(12)
    #LOCALMACRO.Version12List
        reqPlanId,
        reqCalcUpdate,
        autoReserveCoverage,
        maxChildThreads,
        del_ProcessListSize,
        isTaskTraceEnabled,
        comment
    #ENDMACRO

    #DEFINE.CurrentThreadVersion(6)
    #LOCALMACRO.CurrentThreadList
        reqPlanId,
        processId,
        todaysDate,
        reqUseCache,
        dynamicReqPlanId,
        reqCalcUpdate,
        maxChildThreads,
        sourcePlanVersion,
        targetPlanVersion,
        recalculateBomLevels,
        applyFuturesEventKanban,
        isTaskTraceEnabled
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>actionCalcDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Processes action messages for one item dimension.
    /// </summary>
    /// <param name="_setupDim">
    ///    A <c>ReqSetupDim</c> object that specified the item and dimension for which the action messages are
    ///    processed.
    /// </param>
    protected void actionCalcDim(ReqSetupDim _setupDim)
    {
        MapIterator     mi_reqTrans;

        Map             mapReqTransSum;

        ReqTrans        reqTrans;

        ItemId          itemId = _setupDim.setup().itemId();
        InventDimId     covInventDimId = _setupDim.parmCovInventDimId();
        QueryRun        queryRun;

        queryRun = new QueryRun(reqTransCache.receiptsQuery(itemId, covInventDimId));
        if (!queryRun.next())
        {
            return;
        }

        mapReqTransSum  = new Map(typeName2Type(extendedTypeStr(RecId)), Types::Record);

        this.actionCalcDimTrans(_setupDim, mapReqTransSum, this.reqPlanVersionRefRecId(), itemId, covInventDimId, true);
        this.actionCalcDimTrans(_setupDim, mapReqTransSum, this.reqPlanVersionRefRecId(), itemId, covInventDimId, false);

        do
        {
            reqTrans = queryRun.get(tableNum(ReqTrans));
            if (reqPlanData.mustTransBeActionSet(_setupDim, reqTrans))
            {
                mapReqTransSum.insert(reqTrans.RecId, reqTrans);
            }
        }
        while (queryRun.next());

        mi_reqTrans = new MapIterator(mapReqTransSum);
        mi_reqTrans.begin();
        while (mi_reqTrans.more())
        {
            reqTrans = mapReqTransSum.lookup(mi_reqTrans.key());

            this.actionCalcDimTransSum(_setupDim, reqTrans, mapReqTransSum);

            mi_reqTrans.next();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>actionCalcDimDerived</Name>
				<Source><![CDATA[
    protected void actionCalcDimDerived(
        ReqSetupDim   _setupDim,
        ReqTrans      _reqTrans
        )
    {
        ReqTrans        reqTransLine;
        InventQty       qtyFactor;

        if (reqPlanData.mustTransBeActionDerived(_setupDim,_reqTrans))
        {
            qtyFactor = _reqTrans.Qty  ? _reqTrans.actionSum() / _reqTrans.Qty  : 0;

            reqTransLine = _reqTrans.selectDerived(true);

            while (reqTransLine.RecId)
            {
                this.actionCalcDimDerivedTrans(_reqTrans,reqTransLine,qtyFactor);
                next reqTransLine;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>actionCalcDimDerivedDelete</Name>
				<Source><![CDATA[
    protected void actionCalcDimDerivedDelete(
        ReqTrans      _reqTrans
        )
    {
        ReqTrans reqTransLine;

        reqTransLine = _reqTrans.selectDerived(true);

        while (reqTransLine.RecId)
        {
            this.actionCalcDimDerivedTransDelete(reqTransLine);
            next reqTransLine;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>actionCalcDimDerivedTrans</Name>
				<Source><![CDATA[
    protected void actionCalcDimDerivedTrans(
        ReqTrans    _reqTransParent,
        ReqTrans    _reqTransDerived,
        InventQty   _qtyFactor
        )
    {
        ReqTransCov     reqTransCov;

        ReqSetup        setup      = reqPlanData.newReqSetup(_reqTransDerived.ItemId);
        ReqSetupDim     setupDim   = reqPlanData.newReqSetupDim(setup,_reqTransDerived.CovInventDimId);

        if (setupDim.mustItemBeActionMarked() && _reqTransDerived.Qty < 0)
        {
            _reqTransDerived.ActionQtyAdd   = decRound(_reqTransDerived.Qty * _qtyFactor - _reqTransDerived.Qty,setup.inventDecimals());
            _reqTransDerived.ActionDays     = _reqTransParent.ActionDays;

            _reqTransDerived.setAction();
            _reqTransDerived.update(reqPlanData);

            while select forupdate reqTransCov
               where reqTransCov.IssueRecId == _reqTransDerived.RecId
            {
                reqTransCov.ActionQtyAdd = decRound(reqTransCov.Qty * _qtyFactor - reqTransCov.Qty, setup.inventDecimals());
                reqTransCov.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>actionCalcDimDerivedTransDelete</Name>
				<Source><![CDATA[
    protected void actionCalcDimDerivedTransDelete(
        ReqTrans    _reqTransDerived
        )
    {
        ReqTransCov     reqTransCov;

        _reqTransDerived.ActionQtyAdd   = 0;
        _reqTransDerived.ActionDays     = 0;

        _reqTransDerived.setAction();
        _reqTransDerived.update(reqPlanData);

        if (_reqTransDerived.Qty < 0)
        {
            update_recordset reqTransCov
                setting ActionQtyAdd = 0
                where reqTransCov.IssueRecId    == _reqTransDerived.RecId &&
                      reqTransCov.ActionQtyAdd  != 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>actionCalcDimTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Processes action messages for one requirement transaction.
    /// </summary>
    /// <param name="_setupDim">
    ///    A <c>ReqSetupDim</c> object that identifies the item and dimension coverage settings.
    /// </param>
    /// <param name="_mapReqTransSum">
    ///    A map where all the <c>ReqTrans</c> receipts that have actions are registered.
    /// </param>
    /// <param name="_reqPlanVersionRefRecId">
    ///    The current plan version.
    /// </param>
    /// <param name="_itemId">
    ///    The ID of the item to process.
    /// </param>
    /// <param name="_covInventDimId">
    ///    The coverage dimension to process.
    /// </param>
    /// <param name="_processStaticReceipts">
    ///    A <c>Boolean</c> value that indicates whether to process static receipts.
    /// </param>
    protected void actionCalcDimTrans(
        ReqSetupDim          _setupDim,
        Map                  _mapReqTransSum,
        RefRecId             _reqPlanVersionRefRecId,
        ItemId               _itemId,
        InventDimId          _covInventDimId,
        boolean              _processStaticReceipts
        )
    {
        ReqTrans        receipt;
        ReqTrans        issue;

        ReqTransCov     receiptCov;

        TransDate       searchFrom;
        TransDate       searchTo;

        // qty that should moved to another receipt
        InventQty       qtyNow;

        Array       receiptsArray = new Array(Types::Record);
        int         countReceipts = 0;

        Array       covArray = new Array(Types::Record);
        Array       covReceiptsArray = new Array(Types::Record);
        Array       covIssuesArray = new Array(Types::Record);
        int         countCov = 0;

        int         currentCovIndex;
        int         searchIndex;
        ReqTrans    searchReceipt;

        Map         accumulatedActionQtyMap            = new Map(typeName2Type(extendedTypeStr(RecId)), Types::Real);
        int         indexFirstSearchReceipt = 1;
        QtyHighest  highestQty = _setupDim.highestQty(false) ;

        WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::ActionMessage,'-------------------------------------------------------------------------');
        WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::ActionMessage, strFmt('Matching for item %1. Process static receipts only= %2', _itemId, _processStaticReceipts));

        // Performance optimization, first load data with highest probability of not returning any records. This may make the subsequent load superfluous.
        if (_processStaticReceipts)
        {
            countCov = this.actionLoadCoverageIssuesAndReceipts(covArray, covReceiptsArray, covIssuesArray, _itemId, _reqPlanVersionRefRecId, _covInventDimId, _processStaticReceipts);

            if (countCov > 0)
            {
                countReceipts = this.actionLoadReceipts(receiptsArray, accumulatedActionQtyMap, _itemId, _reqPlanVersionRefRecId, _covInventDimId, _processStaticReceipts);
            }
        }
        else
        {
            countReceipts = this.actionLoadReceipts(receiptsArray, accumulatedActionQtyMap, _itemId, _reqPlanVersionRefRecId, _covInventDimId, _processStaticReceipts);

            if (countReceipts > 0)
            {
                countCov = this.actionLoadCoverageIssuesAndReceipts(covArray, covReceiptsArray, covIssuesArray, _itemId, _reqPlanVersionRefRecId, _covInventDimId, _processStaticReceipts);
            }
        }

        if ((countCov == 0) || (countReceipts == 0))
        {
            return;
        }

        // For each coverage record, look for actions for the corresponding receipt
        WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::ActionMessage, strFmt('Number of Coverage records: %1, Number of receipts; %2', countCov, countReceipts));
        for (currentCovIndex=1; currentCovIndex<=countCov; ++currentCovIndex)
        {
            receiptCov = covArray.value(currentCovIndex);
            receipt = covReceiptsArray.value(currentCovIndex);
            issue = covIssuesArray.value(currentCovIndex);

            if (reqPlanData.mayTransBeActionCovFrom(_setupDim, receipt))
            {
                if (receipt.isStaticReceipt())
                {
                    qtyNow = receiptCov.ActionQtyAdd;
                }
                else
                {
                    qtyNow = receiptCov.actionSum();
                }

                if (qtyNow < 0)
                {
                    searchFrom  = _setupDim.searchReceiptFromDate(issue, issue.ActionDate ,reqPlanData.todaysdate());
                    searchTo    = _setupDim.searchReceiptToDate(issue, issue.ActionDate, reqPlanData.todaysdate(), reqPlanData);

                    if (traceLoggingEnabled)
                    {
                        reqTraceLogger.writeLog(ReqTraceLogMessageEntry::newFromReqTrans(ReqTraceMessageType::ActionFindIssuesForReceipt, [issue.RefId, ReqTraceLogMessage::packInventDim(_setupDim.inventDim()), searchFrom, searchTo], issue));
                    }

                    indexFirstSearchReceipt = this.actionFindFirstReceiptForCoverage(indexFirstSearchReceipt, countReceipts, receiptsArray, searchFrom, highestQty, accumulatedActionQtyMap, _setupDim, _processStaticReceipts);
                    if (indexFirstSearchReceipt > countReceipts)
                    {
                        WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::ActionMessage, 'No more receipts to search');
                        break;
                    }

                    for (searchIndex=indexFirstSearchReceipt; searchIndex<= countReceipts; ++searchIndex)
                    {
                        searchReceipt = receiptsArray.value(searchIndex);
                        if (searchReceipt.ReqDate > searchTo)
                        {
                            break;
                        }

                        if (  searchReceipt.ReqDate                   >= searchFrom                    &&
                              searchReceipt.ReqDate                   <= searchTo                      &&
                              searchReceipt.RecId                     != receipt.RecId)
                        {
                            if (reqPlanData.mayTransBeActionCovTo(_setupDim, searchReceipt, receipt.isStaticReceipt()))
                            {
                                qtyNow = this.actionCoverReceipt(highestQty, searchReceipt, _mapReqTransSum, accumulatedActionQtyMap, qtyNow, receiptCov, issue);
                            }

                            if (qtyNow >= 0)
                            {
                                break;
                            }
                        }
                    }
                }
            }
        }

        WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::ActionMessage,'-------------------------------------------------------------------------');
    }

]]></Source>
			</Method>
			<Method>
				<Name>actionCalcDimTransDelete</Name>
				<Source><![CDATA[
    protected void actionCalcDimTransDelete(
        ReqTrans             _receipt
        )
    {
        ReqTransCov reqTransCov;

        if (_receipt.ActionMarked)
        {
            _receipt.ActionDays      = 0;
            _receipt.ActionQtyAdd    = 0;
            _receipt.setAction();
            _receipt.update(reqPlanData);

            delete_from reqTransCov
                index hint ReceiptIdx
                where reqTransCov.ReceiptRecId == _receipt.RecId && reqTransCov.Qty == 0;

            update_recordset reqTransCov
                setting ActionQtyAdd = 0
                where reqTransCov.ReceiptRecId == _receipt.RecId && reqTransCov.ActionQtyAdd != 0;

            this.actionCalcDimDerivedDelete(_receipt);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>actionCalcDimTransSum</Name>
				<Source><![CDATA[
    protected void actionCalcDimTransSum(
        ReqSetupDim   setupDim,
        ReqTrans      receipt,
        Map           _mapReqTransSum
        )
    {
        boolean         issueFound;
        ReqTransCov     reqTransCov;

        InventQty       qtyOrigDiff;
        InventQty       qtyTmp;
        Days            days;
        Days            daysTmp;

        ReqLog          reqLog;

        ReqPO           plannedOrder;

        ReqDate         minReqDate;
        ReqTime         minReqTime;

        if (traceLoggingEnabled)
        {
            reqTraceLogger.writeLog(ReqTraceLogMessageEntry::newFromReqTrans(ReqTraceMessageType::ActionCalcTransSum, [receipt.RefId, [enumNum(ReqRefType), enum2int(receipt.RefType)], ReqTraceLogMessage::packInventDim(setupDim.inventDim())], receipt));
        }

        if (#PmfEnabled
            && !receipt.CovQty //direct demand for one of it's co-product
            &&  (receipt.RefType == ReqRefType::PmfPlannedProdBatch
            || (receipt.RefType == ReqRefType::Production && InventTable::find(receipt.ItemId).isFormulaAllowed())))
        {
            if (this.pmfCoActionCalcDimTransSum(receipt, _mapReqTransSum))
            {
                return;
            }
        }

        InventQty qty;
        ReqDate reqDate = receipt.ReqDate ? receipt.ReqDate : reqPlanData.todaysdate();

        [issueFound, days, minReqDate, minReqTime, qty] = this.deriveActionDataFromEarliestIssue(reqPlanData, setupDim, receipt);

        if (setupDim.actionBasicDateType() == ActionBasicDateType::FuturesDate)
        {
            if (receipt.FuturesMarked && (reqDate + days < receipt.FuturesDate))
            {
                days = receipt.FuturesDate - reqDate;

                this.traceDetail(ReqTraceMessageDetailType::ActionDaysFromReceiptFuturesDate, [receipt.FuturesDate, days]);
            }
        }

        if (issueFound && receipt.ReqTime > minReqTime)
        {
            days--;

            this.traceDetail(ReqTraceMessageDetailType::ActionReceiptTimeGreaterThanIssueTime, [receipt.ReqTime, minReqTime]);
        }

        if (days > 0
            && receipt.ReqTime > reqParameters.ReqTimePoDefault
            && receipt.isPlannedOrder()
            && receipt.getReqPo(reqPlanData).supplyPrinciple(reqPlanData) == ReqSupplyPrinciple::Conversion)
        {
            days--;

            this.traceDetail(ReqTraceMessageDetailType::ActionReceiptTimeGreaterDefaultTime, [receipt.ReqTime, reqParameters.ReqTimePoDefault]);
        }

        if (receipt.RefType == ReqRefType::ItemPlannedOrder && days > 0 && minReqTime < reqParameters.ReqTimePoDefault)
        {
            days--;

            this.traceDetail(ReqTraceMessageDetailType::ActionReceiptTimeGreaterDefaultTime, [minReqTime, reqParameters.ReqTimePoDefault]);
        }

        days = this.adjustActionDaysFromScheduledDate(reqPlanData, setupDim, receipt, reqDate, days);

        if (qty != 0 && ! this.actionQtyUpdate(receipt))
        {
            this.traceDetail(ReqTraceMessageDetailType::ActionTypeCannotHaveQuantity, [[enumNum(ReqRefType), enum2int(receipt.RefType)]]);

            qty = 0;
        }

        if ((qty   < 0 && reqPlanData.mayTransBeActionDecreased(setupDim,receipt))   ||
            (qty   > 0 && reqPlanData.mayTransBeActionIncreased(setupDim,receipt)))
        {
            qtyOrigDiff = qty;

            if (receipt.Qty + qty > 0)
            {
                if (receipt.Qty + qty < setupDim.lowestQty())
                {
                    qty = setupDim.lowestQty() - receipt.Qty;
                }
            }

            if (receipt.Qty + qty > setupDim.highestQty() && setupDim.highestQty() > 0)
            {
                qty = setupDim.highestQty() - receipt.Qty;
            }

            if (setupDim.quantity() && receipt.Qty + qty > 0)
            {
                qtyTmp = round(receipt.Qty + qty,decRound(setupDim.quantity(),setupDim.setup().inventDecimals()));

                if (qtyTmp < receipt.Qty + qty)
                {
                    qtyTmp = qtyTmp  + setupDim.quantity();
                }

                qty = qtyTmp - receipt.Qty;
            }

            if (qty != qtyOrigDiff)
            {
                this.traceDetail(ReqTraceMessageDetailType::ActionQtyChanged, [qty]);
            }

            if (sign(qtyOrigDiff) != sign(qty))
            {
                //Do not change qty from - to +
                //Can happen in case of a partial receipt where the remainder is lower than minimum quantity
                //or because of rounding up
                qty = 0;
            }

            if (receipt.RefType == ReqRefType::ItemPlannedOrder && qty)
            {
                plannedOrder = receipt.getReqPo(reqPlanData);
                if (plannedOrder.PurchQty != plannedOrder.Qty)
                {
                    plannedOrder.Qty += qty;
                    plannedOrder.initPurchQty(setupDim.setup());

                    qty = plannedOrder.Qty  - receipt.Qty;
                }
            }
        }
        else
        {
            if (qty != 0)
            {
                this.traceDetail(ReqTraceMessageDetailType::ActionQtyNotAllowed, [qty]);
            }

            qty = 0;
        }

        if (qty != receipt.ActionQtyAdd || days != receipt.ActionDays || receipt.ActionMarked)
        {
            receipt.ActionDays      = days;
            receipt.ActionQtyAdd    = qty;
            receipt.setAction();

            receipt.update(reqPlanData);

            this.traceDetail(ReqTraceMessageDetailType::ActionUpdate, [days, qty, [enumNum(ActionType), enum2int(receipt.ActionType)]]);

            this.updatePostponedDateAsRequirementDate(reqPlanData, setupDim, receipt, minReqDate);

            this.actionLogDecrease(receipt, reqLog);

            this.actionCalcDimDerived(setupDim,receipt);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deriveActionDataFromEarliestIssue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the initial action data from the earliest issue found for the receipt.
    /// </summary>
    /// <param name = "_reqPlanData">The master planning settings.</param>
    /// <param name = "_setupDim">The parameters for the receipt item dimensions combination.</param>
    /// <param name = "_receipt">The receipt to search for issues.</param>
    /// <returns>A container with the action data calculated based on the found issue, such as: issue itself,
    /// action days count, min requirement date and time, issue quantity the receipt is covering.</returns>
    protected container deriveActionDataFromEarliestIssue(ReqPlanData _reqPlanData, ReqSetupDim _setupDim, ReqTrans _receipt)
    {
        ReqTrans issue;
        ReqTransCov reqTransCov;
        Days daysTmp;
        ActionDate actionDate;
        Days days;
        ReqDate minReqDate;
        ReqTime minReqTime;
        boolean issueFound;

        InventQty qty = _receipt.CovQty - _receipt.Qty;

        // Receipt from the same source line with safety stock coverage shouldn't have postpone message when it has been firmed
        if (!_receipt.isPlannedOrder()
            && _receipt.InventTransOrigin
            && _receipt.isSafetyStockCoveredByReceiptLot())
        {
            days = 0;
        }
        else
        {
            days = maxInt();
        }

        ReqDate reqDate = _receipt.ReqDate ? _receipt.ReqDate : _reqPlanData.todaysdate();

        this.traceDetail(ReqTraceMessageDetailType::ActionInitialQuantity, [qty, 0]);

        while select forceplaceholders forceselectorder forupdate RecId, ActionQtyAdd from reqTransCov
            where reqTransCov.ReceiptRecId == _receipt.RecId
        join ReqDate, ReqTime, ActionDate, RefId, RefType
            from issue
            where issue.RecId == reqTransCov.IssueRecId
            &&    issue.ReqDate <= this.getMaxIssueActionDate(_setupDim)
        {
            issueFound = true;
            actionDate = issue.ActionDate ? issue.ActionDate : _reqPlanData.todaysdate();

            daysTmp = actionDate - reqDate;

            if (daysTmp < days
                && !(issue.RefType == ReqRefType::SafetyInvent && daysTmp > 0))
            {
                days = daysTmp;
            }

            qty -= reqTransCov.ActionQtyAdd;

            this.traceDetail(ReqTraceMessageDetailType::ActionSumChange, [reqTransCov.ActionQtyAdd, actionDate, issue.RefId, days, qty]);

            if (!minReqDate)
            {
                minReqDate = issue.ReqDate;
                minReqTime = issue.ReqTime;
            }
            else
            {
                if (minReqDate > issue.ReqDate)
                {
                    minReqDate = issue.ReqDate;
                    minReqTime = issue.ReqTime;
                }
                else if (minReqDate == issue.ReqDate && minReqTime > issue.ReqTime)
                {
                    minReqTime = issue.ReqTime;
                }
            }

        }

        if (days == maxInt())
        {
            days = 0;
        }

        return [issueFound, days, minReqDate, minReqTime, qty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustActionDaysFromScheduledDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates action days based on the original receipt date and newly rescheduled date.
    /// </summary>
    /// <param name = "_reqPlanData">The master planning settings.</param>
    /// <param name = "_setupDim">The parameters for the receipt item dimensions combination.</param>
    /// <param name = "_receipt">The receipt to calculate action days for.</param>
    /// <param name = "_receiptReqDate">The receipt requirement date.</param>
    /// <param name = "_days">The action days count calculated so far.</param>
    /// <param name = "_postponeSchedulingDirection">The direction to reschedule the receipt in case days count means the order needs to be postponed.</param>
    /// <param name = "_advanceSchedulingDirection">The direction to reschedule the receipt in case days count means the order needs to be advanced.</param>
    /// <returns>The new action days count.</returns>
    protected Days adjustActionDaysFromScheduledDate(
        ReqPlanData _reqPlanData,
        ReqSetupDim _setupDim,
        ReqTrans _receipt,
        ReqDate _receiptReqDate,
        Days _days,
        SchedDirection _postponeSchedulingDirection = SchedDirection::Backward,
        SchedDirection _advanceSchedulingDirection = SchedDirection::Forward)
    {
        if ((_days >=  _setupDim.postponeMargin() && reqPlanData.mayTransBeActionPostponed(_setupDim,_receipt))
            || (_days <= -_setupDim.advanceMargin()  && reqPlanData.mayTransBeActionAdvanced(_setupDim,_receipt)))
        {
            CalendarId purchCalendarId = this.findPurchCalendarId(reqPlanData, _setupDim, _receipt);

            ActionDate actionDateCheck = _receiptReqDate + _days;

            if (_days > 0)
            {
                actionDateCheck = reqPlanData.workCalendarSched().schedDate(
                    _postponeSchedulingDirection,
                    actionDateCheck,
                    0,
                    false,
                    _setupDim.reqCalendarId(),
                    purchCalendarId);
                _days = actionDateCheck - _receiptReqDate;
                if (_days < 0)
                {
                    _days = 0;
                }
            }
            else
            {
                actionDateCheck = reqPlanData.workCalendarSched().schedDate(
                    _advanceSchedulingDirection,
                    actionDateCheck,
                    0,
                    false,
                    _setupDim.reqCalendarId(),
                    purchCalendarId);

                _days = actionDateCheck - _receiptReqDate;
                if (_days > 0)
                {
                    _days = 0;
                }
            }
        }
        else
        {
            if (_days != 0)
            {
                this.traceDetail(ReqTraceMessageDetailType::ActionDaysNotWithinMargins, [_days, _setupDim.postponeMargin(), _setupDim.advanceMargin()]);
            }

            _days = 0;
        }

        return _days;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePostponedDateAsRequirementDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets postponed issue date as the receipt requirement date if master planning settings allow to do so.
    /// </summary>
    /// <param name = "_reqPlanData">The master planning settings.</param>
    /// <param name = "_setupDim">The parameters for the receipt item dimensions combination.</param>
    /// <param name = "_receipt">The receipt to update postponed date for.</param>
    /// <param name = "_minReqDate">The requirement date of the earliest issue.</param>
    protected void updatePostponedDateAsRequirementDate(ReqPlanData _reqPlanData, ReqSetupDim _setupDim, ReqTrans _receipt, ReqDate _minReqDate)
    {
        if (_receipt.ActionType == ActionType::Postpone              ||
            _receipt.ActionType == ActionType::PostponeAppreciate    ||
            _receipt.ActionType == ActionType::PostponeDepreciate)
        {
            ReqPO plannedOrder = _receipt.getReqPo(_reqPlanData, true);

            if (_receipt.RefType == ReqRefType::ItemPlannedOrder && _reqPlanData.actionUpdReqDatePurch() &&
                plannedOrder.ReqPOStatus != ReqPOStatus::Approved)
            {
                if (plannedOrder.RecId && plannedOrder.ReqDate)
                {
                    if (_minReqDate > plannedOrder.ReqDate)
                    {
                        plannedOrder.ReqDate = min(_receipt.ActionDate, _minReqDate);
                        plannedOrder.initFromReqDate(_setupDim,_reqPlanData);
                        plannedOrder.doUpdate();

                        _receipt.ReqDate         = plannedOrder.ReqDate;
                        _receipt.ReqDateDlvOrig  = plannedOrder.ReqDateDlv;
                        _receipt.ReqTime         = plannedOrder.ReqTime;

                        _receipt.ActionDays      = 0;
                        _receipt.setAction();

                        _receipt.update(_reqPlanData);

                        this.traceDetail(ReqTraceMessageDetailType::ActionUpdatePostponedDateAsReqDate, [plannedOrder.ReqDate]);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPurchCalendarId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a purchase calendar for the receipt.
    /// </summary>
    /// <param name = "_reqPlanData">The master planning settings.</param>
    /// <param name = "_setupDim">The parameters for the receipt item dimensions combination.</param>
    /// <param name = "_receipt">The receipt to find a purchase calendar for.</param>
    /// <returns>The found calendar Id.</returns>
    private CalendarId findPurchCalendarId(ReqPlanData _reqPlanData, ReqSetupDim _setupDim, ReqTrans _receipt)
    {
        CalendarId purchCalendarId;

        if (_receipt.RefType == ReqRefType::Purch)
        {
            purchCalendarId = _setupDim.purchCalendarId(PurchTable::find(_receipt.RefId).OrderAccount);
        }
        else
            if (_receipt.RefType == ReqRefType::ItemPlannedOrder)
        {
            purchCalendarId = _setupDim.purchCalendarId(_receipt.getReqPo(_reqPlanData).VendId);
        }
        else
        {
            purchCalendarId = '';
        }

        return purchCalendarId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>traceDetail</Name>
				<Source><![CDATA[
    private void traceDetail(ReqTraceMessageDetailType _messageType, ReqTraceMessageCon _messageCon)
    {
        if (traceLoggingEnabled)
        {
            reqTraceLogger.writeLog(ReqTraceLogMessageDetail::newDetail(_messageType, _messageCon));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>actionLogDecrease</Name>
				<Source><![CDATA[
    private void actionLogDecrease(ReqTrans _receipt, ReqLog _reqLog)
    {
        if (_receipt.RefType == ReqRefType::Purch && _receipt.ActionQtyAdd < 0 && _receipt.Qty > 0)
        {
            _reqLog = reqPlanData.reqLog();
            if (_reqLog.ReqLogId)
            {
                _reqLog.NumOfPurchLineDecrease++;
            }
        }

        if (_receipt.RefType == ReqRefType::Production && _receipt.ActionQtyAdd < 0 && _receipt.Qty > 0)
        {
            _reqLog = reqPlanData.reqLog();
            if (_reqLog.ReqLogId)
            {
                _reqLog.NumOfProductionDecrease++;
            }
        }

        if (   _receipt.RefType == ReqRefType::Kanban
                && _receipt.ActionQtyAdd < 0
                && _receipt.Qty > 0)
        {
            _reqLog = reqPlanData.reqLog();
            if (_reqLog.ReqLogId)
            {
                _reqLog.NumOfKanbanDecrease++;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMaxIssueActionDate</Name>
				<Source><![CDATA[
    private Date getMaxIssueActionDate(ReqSetupDim  _setupDim)
    {
        return reqPlanData.todaysdate() + _setupDim.timeFenceAction();
    }

]]></Source>
			</Method>
			<Method>
				<Name>processActionCalcItemTask</Name>
				<Source><![CDATA[
    private void processActionCalcItemTask(BOMLevel _level, ItemId _itemId)
    {
        int infologLineTry = infologLine();
        try
        {
            this.actionCalcItem(_level, _itemId);
        }
        catch (Exception::Error)
        {
            if (this.retryExceptionError(infologLineTry))
            {
                retry;
            }

            this.handleItemError(_itemId, "@SYS117410");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processInsertDataItemTask</Name>
				<Source><![CDATA[
    private void processInsertDataItemTask(BOMLevel _level, ItemId _itemId)
    {
        int infologLineTry = infologLine();
        try
        {
            this.insertDataItem(_level, _itemId);
        }
        catch (Exception::Error)
        {
            if (this.retryExceptionError(infologLineTry))
            {
                retry;
            }

            this.handleItemError(_itemId, "@SCMPlanning:ReqCalcUpdateCancelled");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processFuturesCalcItemTask</Name>
				<Source><![CDATA[
    private void processFuturesCalcItemTask(BOMLevel _level, ReqLevelState _reqLevelState, ItemId _itemId)
    {
        int infologLineTry = infologLine();
        try
        {
            this.futuresCalcItem(_level, _reqLevelState, _itemId);
        }
        catch (Exception::Error)
        {
            if (this.retryExceptionError(infologLineTry))
            {
                retry;
            }

            this.handleItemError(_itemId, "@SYS117409");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processCovCalcItemTask</Name>
				<Source><![CDATA[
    private void processCovCalcItemTask(BOMLevel _level, ItemId _itemId)
    {
        int infologLineTry = infologLine();
        try
        {
            this.covCalcItem(_level, _itemId);
        }
        catch (Exception::Error)
        {
            if (this.retryExceptionError(infologLineTry))
            {
                retry;
            }

            this.handleItemError(_itemId, "@SYS26323");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>actionCalcItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Processes action messages for the items in a given list on a given level.
    /// </summary>
    /// <param name="_level">
    ///    The level on which to process the list.
    /// </param>
    /// <param name="_itemId">
    ///    The item ID to process.
    /// </param>
    [SuppressBpWarning("BPParameterNotUsed", "Parameter _level is used by deriving classes that overrides this method.")]
    protected void actionCalcItem(BOMLevel      _level,
                                  ItemId        _itemId)
    {
        List            listCovDimSorted;
        ListEnumerator  leCovDimSorted;
        InventDimId     covInventDimId;
        ReqSetupDim     setupDim;

        void handleError()
        {
            this.handleItemError(_itemId, "@SYS117410");
        }

        reqTransCache.setCurrentItem(_itemId);
        reqTransCache.setCurrentLevel(_level);

        if (setErrorItemId.in(_itemId))
        {
            return;
        }

        /*
            Loop sorted by inventlocation level
        */

        int infologLineTry = infologLine();
        try
        {
            // make sorted list of covDimId
            listCovDimSorted = reqTransCache.listCovDimSorted(_itemId, reqPlanData);
        }
        catch (Exception::Error)
        {
            if (this.retryExceptionError(infologLineTry))
            {
                retry;
            }

            handleError();
            return;
        }

        leCovDimSorted = listCovDimSorted.getEnumerator();
        while (leCovDimSorted.moveNext())
        {
            covInventDimId = leCovDimSorted.current();

            setupDim = reqPlanData.newReqSetupDim(reqPlanData.newReqSetup(_itemId),covInventDimId);
            if (setupDim.mustItemBeActionMarked() && reqPlanData.timeFenceAction(setupDim) > 0)
            {
                setPrefix(fieldLabelValue(tableNum(InventTable), fieldNum(InventTable,ItemId), _itemId));
                setPrefix(fieldLabelValue(tableNum(InventDim), fieldNum(InventDim,InventDimId), covInventDimId));

                try
                {
                    reqPlanData.createReqLogRestorePoint();

                    ttsbegin;
                    this.actionCalcDim(setupDim);
                    ttscommit;
                }
                catch (Exception::Deadlock)
                {
                    retry;
                }
                catch (Exception::TransientSqlConnectionError)
                {
                    if (this.retryTransientSqlConnectionErrorRestoreReqCalc())
                    {
                        retry;
                    }
                    else
                    {
                        throw;
                    }
                }
                catch (Exception::UpdateConflict)
                {
                    if (this.manageExceptionUpdateConflictRestoreReqCalc())
                    {
                        retry;
                    }
                }
                catch (Exception::Error)
                {
                    if (this.retryExceptionErrorRestoreReqCalc(infologLineTry))
                    {
                        retry;
                    }

                    handleError();
                }
                catch (Exception::CLRError)
                {
                    ApplicationUnhandledExceptionLogger::processUnhandledCLRException();
                    handleError();
                }
                catch (Exception::Info)
                {
                    handleError();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>actionCovCreate</Name>
				<Source><![CDATA[
    protected void actionCovCreate(
        InventQty       _actionQtyAdd,
        ReqTrans        _receipt,
        ReqTrans        _issue
        )
    {
        ReqTransCov reqTransCov;
        reqTransCov.PlanVersion            = _receipt.PlanVersion;

        reqTransCov.ItemId              = _receipt.ItemId;
        reqTransCov.IsDerivedDirectly   = _receipt.IsDerivedDirectly;
        reqTransCov.ActionQtyAdd        = _actionQtyAdd;
        reqTransCov.ReceiptRecId        = _receipt.RecId;
        reqTransCov.IssueRecId          = _issue.RecId;
        reqTransCov.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>actionCoverReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an action to cover an issue.
    /// </summary>
    /// <param name="_highestQty">
    ///    The maximum amount a receipt may be loaded.
    /// </param>
    /// <param name="_receipt">
    ///    The receipt to use for coverage.
    /// </param>
    /// <param name="_mapReqTransSum">
    ///    A map that has receipts used for coverage.
    /// </param>
    /// <param name="_accumulatedActionQtyMap">
    ///    A map that has the amounts used for action coverage.
    /// </param>
    /// <param name="_qtyNow">
    ///    The quantity to cover.
    /// </param>
    /// <param name="_receiptCov">
    ///    The original receipt.
    /// </param>
    /// <param name="_issue">
    ///    The issue to cover.
    /// </param>
    /// <returns>
    ///    The remaining quantity to cover.
    /// </returns>
    private InventQty actionCoverReceipt(QtyHighest  _highestQty,
                                         ReqTrans    _receipt,
                                         Map         _mapReqTransSum,
                                         Map         _accumulatedActionQtyMap,
                                         InventQty   _qtyNow,
                                         ReqTransCov _receiptCov,
                                         ReqTrans    _issue )
    {
        InventQty       remainAddQtyOnReceipt;
        InventQty       qtyNowForParticularReceipt;

        remainAddQtyOnReceipt = this.remainAddQtyOnReceipt(_highestQty, _receipt, _accumulatedActionQtyMap);

        qtyNowForParticularReceipt = max(-remainAddQtyOnReceipt, _qtyNow);

        if (qtyNowForParticularReceipt < 0)
        {
            if (traceLoggingEnabled)
            {
                reqTraceLogger.writeLog(ReqTraceLogMessageEntry::newFromReqTrans(ReqTraceMessageType::ActionShiftQuantity, [qtyNowForParticularReceipt, _issue.RefId, ReqTrans::findRecId(_receiptCov.ReceiptRecId).RefId, _receipt.RefId], _issue));
            }

            _receiptCov.ActionQtyAdd -= qtyNowForParticularReceipt;
            _receiptCov.update();

            this.actionCovCreate(qtyNowForParticularReceipt,_receipt,_issue);
            _qtyNow -= qtyNowForParticularReceipt;

            _mapReqTransSum.insert(_receipt.RecId,_receipt);
            _accumulatedActionQtyMap.insert(_receipt.RecId, _accumulatedActionQtyMap.lookup(_receipt.RecId) - qtyNowForParticularReceipt);
        }

        return _qtyNow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>actionFindFirstReceiptForCoverage</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the first receipt that may be used for coverage.
    /// </summary>
    /// <param name="_indexFirstSearchReceipt">
    ///    The index of the first candidate to investigate.
    /// </param>
    /// <param name="_countReceipts">
    ///    The index of the last candidate to investigate.
    /// </param>
    /// <param name="_receiptsArray">
    ///    An array of the <c>ReqTrans</c> table candidate receipts.
    /// </param>
    /// <param name="_searchFrom">
    ///    The earliest date of a valid receipt.
    /// </param>
    /// <param name="_highestQty">
    ///    The maximum amount a receipt may be loaded.
    /// </param>
    /// <param name="_accumulatedActionQtyMap">
    ///    A map that contains the action quantities that are already allocated.
    /// </param>
    /// <param name="_setupDim">
    ///    A <c>ReqSetupDim</c> object that specified the item and dimension for which the action messages are
    ///    processed.
    /// </param>
    /// <param name="_includePlannedOrders">
    ///    A <c>Boolean</c> value that indicates whether to include planned orders.
    /// </param>
    /// <returns>
    ///    The index of the first receipt that may be used for coverage.
    /// </returns>
    private int actionFindFirstReceiptForCoverage(int           _indexFirstSearchReceipt,
                                                  int           _countReceipts,
                                                  Array         _receiptsArray,
                                                  date          _searchFrom,
                                                  InventQty     _highestQty,
                                                  Map           _accumulatedActionQtyMap,
                                                  ReqSetupDim   _setupDim,
                                                  boolean       _includePlannedOrders)
    {
        int         searchIndex;
        ReqTrans    searchReceipt;

        for (searchIndex= _indexFirstSearchReceipt; searchIndex<= _countReceipts; ++searchIndex)
        {
            searchReceipt = _receiptsArray.value(searchIndex);
            if ((searchReceipt.ReqDate >= _searchFrom) &&
                (this.remainAddQtyOnReceipt(_highestQty, searchReceipt, _accumulatedActionQtyMap)>0) &&
                reqPlanData.mayTransBeActionCovTo(_setupDim, searchReceipt, _includePlannedOrders)
               )
            {
                break;
            }
        }

        if (_indexFirstSearchReceipt < searchIndex)
        {
            WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::ActionMessage, strFmt('Moving search start index to %1', _indexFirstSearchReceipt));
        }

        return searchIndex;
    }

]]></Source>
			</Method>
			<Method>
				<Name>actionLoadCoverageIssuesAndReceipts</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads issues and receipts into arrays.
    /// </summary>
    /// <param name="_covArray">
    ///    The array to load the <c>ReqTransCov</c> records into.
    /// </param>
    /// <param name="_covReceiptsArray">
    ///    Array to load the <c>ReqTrans</c> records into.
    /// </param>
    /// <param name="_covIssuesArray">
    ///    Array to load the <c>ReqTrans</c> records into.
    /// </param>
    /// <param name="_itemId">
    ///    The ID of the item for which to load issues and receipts.
    /// </param>
    /// <param name="_reqPlanVersionRefRecId">
    ///    The record ID of the current plan version.
    /// </param>
    /// <param name="_covInventDimId">
    ///    The ID of the coverage dimension.
    /// </param>
    /// <param name="_staticReceiptsWithNegativeActionQty">
    ///    A <c>Boolean</c> value that indicates whether to load static receipts with negative action
    ///    quantities.
    /// </param>
    /// <returns>
    ///    The number of matching issues and receipts loaded.
    /// </returns>
    private int actionLoadCoverageIssuesAndReceipts(Array       _covArray,
                                                    Array       _covReceiptsArray,
                                                    Array       _covIssuesArray,
                                                    ItemId      _itemId,
                                                    RefRecId    _reqPlanVersionRefRecId,
                                                    InventDimId _covInventDimId,
                                                    boolean     _staticReceiptsWithNegativeActionQty = false)
    {
        ReqTransCov     receiptCov;
        ReqTrans        receipt;
        ReqTrans        issue;
        int             countCov = 0;

        // Load coverage records and the corresponding receipts and issues
        while select forupdate receiptCov
            where receiptCov.ItemId      == _itemId
            &&    receiptCov.Qty         != 0
            &&    ( !_staticReceiptsWithNegativeActionQty || (receiptCov.ActionQtyAdd < 0))
            join forupdate receipt
                where receiptCov.ReceiptRecId == receipt.RecId
                &&    receipt.ItemId == _itemId
                &&    receipt.PlanVersion == _reqPlanVersionRefRecId
                &&    receipt.CovInventDimId == _covInventDimId
                &&    (!_staticReceiptsWithNegativeActionQty ||
                       (_staticReceiptsWithNegativeActionQty
                        && (   (receipt.RefType == ReqRefType::InventOnHand)
                            || (receipt.RefType == ReqRefType::SafetyInvent))))
            join issue
                order by issue.ActionDate
                where issue.RecId == receiptCov.IssueRecId
        {
            countCov++;
            _covArray.value(countCov, receiptCov);
            _covReceiptsArray.value(countCov, receipt);
            _covIssuesArray.value(countCov, issue);
        }

        return countCov;
    }

]]></Source>
			</Method>
			<Method>
				<Name>actionLoadReceipts</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads receipts that may be used for action coverage into an array.
    /// </summary>
    /// <param name="_receiptsArray">
    ///    The array to load the receipts into.
    /// </param>
    /// <param name="_accumulatedActionQtyMap">
    ///    A map that is created that has entries of value 0.0 for each loaded receipt.
    /// </param>
    /// <param name="_itemId">
    ///    The ID of the item for which to load receipts.
    /// </param>
    /// <param name="_reqPlanVersionRefRecId">
    ///    The record ID of the active master plan version.
    /// </param>
    /// <param name="_covInventDimId">
    ///    The ID of the coverage dimension.
    /// </param>
    /// <param name="_includePlannedOrders">
    ///    A <c>Boolean</c> value that indicates whether to include planned orders.
    /// </param>
    /// <returns>
    ///    The number of receipts loaded.
    /// </returns>
    private int actionLoadReceipts(Array       _receiptsArray,
                                   Map         _accumulatedActionQtyMap,
                                   ItemId      _itemId,
                                   RefRecId    _reqPlanVersionRefRecId,
                                   InventDimId _covInventDimId,
                                   boolean     _includePlannedOrders = true)
    {
        ReqTrans    receipt;
        int         countReceipts = 0;

        while select forupdate receipt
           order by receipt.ReqDate, receipt.Qty, RecId
            where receipt.PlanVersion              == _reqPlanVersionRefRecId
            &&    receipt.ItemId                   == _itemId
            &&    receipt.CovInventDimId           == _covInventDimId
            &&    receipt.Direction                == InventDirection::Receipt
            &&    ( (      receipt.RefType != ReqRefType::BOMPlannedOrder
                      &&   receipt.RefType != ReqRefType::ItemPlannedOrder
                      &&   receipt.RefType != ReqRefType::TransferPlannedOrder
                      &&   receipt.RefType != ReqRefType::PlannedKanban )
                    || _includePlannedOrders )

        {
            countReceipts++;
            _receiptsArray.value(countReceipts, receipt);
            _accumulatedActionQtyMap.insert(receipt.RecId, 0.0);
        }

        return countReceipts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>actionQtyUpdate</Name>
				<Source><![CDATA[
    [SuppressBpWarning("BPParameterNotUsed", "Parameter _reqTrans is used by deriving classes that overrides this method.")]
    protected boolean actionQtyUpdate(ReqTrans _reqTrans)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>activeSafetyStockRequirementsTracker</Name>
				<Source><![CDATA[
    protected ReqFuturesActiveSafetyStockRequirementsTracker activeSafetyStockRequirementsTracker(ReqSetupDim _setupDim)
    {
        if (!activeSafetyStockRequirementsTracker || activeSafetyStockRequirementsTracker.setupDim() != _setupDim)
        {
            activeSafetyStockRequirementsTracker = ReqFuturesActiveSafetyStockRequirementsTracker::construct(
                _setupDim,
                this.reqPlanVersionRefRecId(),
                !this.coverageEngine(_setupDim).mustConsiderShelfLife());
        }

        return activeSafetyStockRequirementsTracker;
    }

]]></Source>
			</Method>
			<Method>
				<Name>add2ReqTransCache</Name>
				<Source><![CDATA[
    protected void add2ReqTransCache(
        boolean _onlyOpen,
        boolean deleteAction = false
        )
    {
        ReqTrans                reqTrans;

        if (! _onlyOpen)
        {
            while select forupdate reqTrans
                // unique
                where reqTrans.PlanVersion            == this.reqPlanVersionRefRecId()
            {
                if (reqTrans.Qty > 0 && deleteAction)
                {
                    this.actionCalcDimTransDelete(reqTrans);
                }

                reqTransCache.add(reqTrans);
            }
        }
        else
        {
            while select forupdate reqTrans
                where reqTrans.PlanVersion            == this.reqPlanVersionRefRecId()    &&
                      reqTrans.OpenStatus             == ReqOpenStatus::Neg
            {
                if (reqTrans.Qty > 0 && deleteAction)
                {
                    this.actionCalcDimTransDelete(reqTrans);
                }

                reqTransCache.add(reqTrans);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDerived2ReqTransCacheForNetChange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add derived transactions of given <c>ReqTrans</c> record to <c>ReqTransCache</c> object.
    /// </summary>
    /// <param name="_reqTrans">
    /// The <c>ReqTrans</c> whose derived transactions should be added to the cache.
    /// </param>
    private void addDerived2ReqTransCacheForNetChange(ReqTrans _reqTrans)
    {
        if (!updateAllItems && reqCalcUpdate == ReqCalcUpdate::NetChange)
        {
            var setup      = reqPlanData.newReqSetup(_reqTrans.ItemId);
            var setupDim   = reqPlanData.newReqSetupDim(setup, _reqTrans.CovInventDimId);

            if (reqPlanData.mustTransBeExploded(setupDim, _reqTrans.getReqPo(reqPlanData)))
            {
                ReqTrans reqTransDerived = _reqTrans.selectDerived(false);

                while (reqTransDerived)
                {
                    reqPlanData.addReqTransCache(reqTransDerived);
                    next reqTransDerived;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addItem2ReqTransCache</Name>
				<Source><![CDATA[
    protected void addItem2ReqTransCache(
        ItemId      _itemId,
        boolean     _onlyOpen,
        boolean     deleteAction = false
        )
    {
        ReqTrans        reqTrans;

        if (! _onlyOpen)
        {
            while select forupdate reqTrans
                where reqTrans.PlanVersion            == this.reqPlanVersionRefRecId()  &&
                      reqTrans.ItemId                 == _itemId
            {
                if (reqTrans.Qty > 0 && deleteAction)
                {
                    this.actionCalcDimTransDelete(reqTrans);

                    // As deleting actions, that happens only for net change, adds derived transactions to the transaction cache,
                    // this transactions should always be added, even if there is no action set, to avoid confusion.
                    this.addDerived2ReqTransCacheForNetChange(reqTrans);
                }

                reqPlanData.addReqTransCache(reqTrans);
            }
        }
        else
        {
            while select forupdate reqTrans
                index hint ItemIdx
                where reqTrans.PlanVersion              == this.reqPlanVersionRefRecId()    &&
                      reqTrans.ItemId                   == _itemId                          &&
                      reqTrans.OpenStatus               == ReqOpenStatus::Neg
            {
                if (reqTrans.Qty > 0 && deleteAction)
                {
                    this.actionCalcDimTransDelete(reqTrans);
                }

                reqPlanData.addReqTransCache(reqTrans);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addPlanningItemSupplyFilters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds relevant filters to the query that finds planning item supply.
    /// </summary>
    /// <param name="_query">
    /// The query to add the filters to.
    /// </param>
    protected void addPlanningItemSupplyFilters(Query _query)
    {
        QueryBuildDataSource prodTableDs        = _query.dataSourceTable(tableNum(ProdTable));
        QueryBuildDataSource reqProcessItemDs;

        reqProcessItemDs = prodTableDs.addDataSource(tableNum(ReqProcessItem));

        reqProcessItemDs.addLink(fieldNum(ProdTable, ItemId), fieldNum(ReqProcessItem, ItemId));
        reqProcessItemDs.joinMode(JoinMode::ExistsJoin);

        reqProcessItemDs.addRange(fieldNum(ReqProcessItem, ProcessId)).value(queryValue(processId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRef2ReqTransCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a transaction by reference to the cache.
    /// </summary>
    /// <param name="_refType">
    /// The type of transaction.
    /// </param>
    /// <param name="_refId">
    /// The reference id of the transaction.
    /// </param>
    /// <param name="_inventTransOriginId">
    /// The inventory transaction id.
    /// </param>
    /// <param name="_onlyOpen">
    /// A <c>boolean</c> value that indicates if only open transactions should be added.
    /// </param>
    /// <param name="_minLevel">
    /// The level at which to minimum add the transaction.
    /// </param>
    /// <returns>
    /// true if at least one transaction was added to the cache; otherwise, false.
    /// </returns>
    protected boolean addRef2ReqTransCache(
        ReqRefType          _refType,
        InventTransRefId    _refId,
        InventTransOriginId _inventTransOriginId,
        boolean             _onlyOpen,
        BOMLevel            _minLevel
        )
    {
        ReqTrans        reqTrans;
        ReqTrans        reqTransDerived;
        boolean         addedToCache = false;

        while select forupdate reqTrans
            where reqTrans.PlanVersion            == this.reqPlanVersionRefRecId()  &&
                  reqTrans.RefType                == _refType                       &&
                  reqTrans.RefId                  == _refId                         &&
                  reqTrans.InventTransOrigin      == _inventTransOriginId           &&
                 (reqTrans.OpenStatus             == ReqOpenStatus::Neg || ! _onlyOpen)
        {
            if (reqTrans.Level < _minLevel)
            {
                reqTrans.Level = _minLevel;
            }

            reqPlanData.addReqTransCache(reqTrans);

            addedToCache = true;

            if (reqTrans.IsDerivedDirectly && reqTrans.isDerivedFromPlannedOrder())
            {
                reqTransDerived = reqTrans.reqTransDirectlyDerived(true);
                if (reqTransDerived.isPlannedOrder())
                {
                    reqPlanData.addReqTransCache(reqTransDerived);
                    this.addRef2ReqTransCache(ReqTrans::derivedRefType(reqTransDerived.RefType),
                                              reqTransDerived.RefId,
                                              0,
                                              _onlyOpen,
                                              InventDistinctProduct::find(reqTrans.ItemId, reqTrans.CovInventDimId).Level);
                }
            }
        }

        return addedToCache;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addReqTrans2ReqTransCache</Name>
				<Source><![CDATA[
    protected void addReqTrans2ReqTransCache(
        ReqTrans            _reqTrans,
        boolean             _onlyOpen
        )
    {
        ReqTrans        reqTransDerived;

        reqPlanData.addReqTransCache(_reqTrans);

        if (_reqTrans.IsDerivedDirectly && _reqTrans.isDerivedFromPlannedOrder())
        {
            reqTransDerived = _reqTrans.reqTransDirectlyDerived(true);
            if (reqTransDerived.isPlannedOrder())
            {
                reqPlanData.addReqTransCache(reqTransDerived);

                this.addRef2ReqTransCache(ReqTrans::derivedRefType(reqTransDerived.RefType),
                                          reqTransDerived.RefId,
                                          0,
                                          _onlyOpen,
                                          InventDistinctProduct::find(reqTransDerived.ItemId, reqTransDerived.CovInventDimId).Level);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRequisitionLineDemandFilters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds relevant filters to the query that finds requisition lines demand.
    /// </summary>
    /// <param name="_query">
    /// The query to add the filters to.
    /// </param>
    protected void addRequisitionLineDemandFilters(Query _query)
    {
        QueryBuildDataSource requisitionLine = _query.dataSourceTable(tableNum(PurchReqLine));
        QueryBuildDataSource reqProcessItem = _query.dataSourceNo(_query.dataSourceCount()).addDataSource(tableNum(ReqProcessItem));

        reqProcessItem.addLink(fieldNum(PurchReqLine, ItemId), fieldNum(ReqProcessItem, ItemId), requisitionLine.name());
        reqProcessItem.joinMode(JoinMode::ExistsJoin);

        reqProcessItem.addRange(fieldNum(ReqProcessItem, ProcessId)).value(queryValue(processId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>bulkClearReqTransScrap</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears all of the <c>ReqTrans</c> records that originate from the <c>InventTrans</c> table.
    /// </summary>
    public void bulkClearReqTransScrap()
    {
        ReqTrans        reqTrans;

        SalesLine       salesLine;
        PurchLine       purchLine;

        InventTransOriginSalesLine  inventTransOriginSalesLine;
        InventTransOriginPurchLine  inventTransOriginPurchLine;
        ReqProcessItem              reqProcessItem;

        reqTrans.skipDataMethods(true);

        update_recordset reqTrans
            setting Qty         = 0,
                    Direction   = InventDirection::None
            where  reqTrans.PlanVersion     == reqPlanData.parmReqPlanVersionRefRecId()
                && reqTrans.RefType         == ReqRefType::Sales
                && reqTrans.Qty             >  0
                && reqTrans.CovQty          == 0
            exists join reqProcessItem
                where   reqProcessItem.ItemId       == reqTrans.ItemId
                &&      reqProcessItem.ProcessId    == processId
            exists join inventTransOriginSalesLine
                where inventTransOriginSalesLine.InventTransOrigin == reqTrans.InventTransOrigin
            exists join salesLine
                where salesLine.InventTransId   == inventTransOriginSalesLine.SalesLineInventTransId
                   && salesLine.DataAreaId      == inventTransOriginSalesLine.SalesLineDataAreaId
                   && salesLine.Scrap;

        update_recordset reqTrans
            setting Qty         = 0,
                    Direction   = InventDirection::None
            where  reqTrans.PlanVersion     == reqPlanData.parmReqPlanVersionRefRecId()
                && reqTrans.RefType         == ReqRefType::Purch
                && reqTrans.Qty             >  0
                && reqTrans.CovQty          == 0
            exists join reqProcessItem
                where   reqProcessItem.ItemId == reqTrans.ItemId
                &&      reqProcessItem.ProcessId    == processId
            exists join inventTransOriginPurchLine
                where inventTransOriginPurchLine.InventTransOrigin == reqTrans.InventTransOrigin
            exists join purchLine
                where purchLine.InventTransId   == inventTransOriginPurchLine.PurchLineInventTransId
                   && purchLine.DataAreaId      == inventTransOriginPurchLine.PurchLineDataAreaId
                   && purchLine.Scrap
                   && purchLine.ProjId          == '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>caption</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the description from the current class by calling the static description method on the class
    ///    if there is one.
    /// </summary>
    /// <returns>
    ///    The description from the current class.
    /// </returns>
    /// <remarks>
    ///    This method can be overridden to give a more precise description, for example, when you need some
    ///    internal variables to build the description text.The static <c>RunBase::description </c> method is
    ///    generally used to obtain the description of a class because you do not have to instantiate the
    ///    class to call it. The method speeds up displaying the description in a grid, for example.
    /// </remarks>
    public ClassDescription caption()
    {
        return ReqCalc::description();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProbability</Name>
				<Source><![CDATA[
    boolean checkProbability(InventTransOrigin _inventTransOrigin, smmQuotationProbabilityId _probabilityId)
    {
        boolean                     ret = true;
        SalesQuotationTable         salesQuotationTable;
        smmOpportunityTable         smmOpportunityTable;
        smmQuotationProbabilityId   quotationProbabilityId;

        if (_inventTransOrigin.ReferenceCategory == InventTransType::SalesQuotation)
        {
            salesQuotationTable = InventTransOriginSalesQuotationLine::salesQuotationTable(_inventTransOrigin.RecId);
            if (salesQuotationTable && salesQuotationTable.OpportunityId)
            {
                smmOpportunityTable = salesQuotationTable.smmOpportunityTable();
                if (smmOpportunityTable)
                {
                    quotationProbabilityId = smmOpportunityTable.ProbabilityId;
                }
            }
            if (quotationProbabilityId < _probabilityId)
            {
                ret = false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanUp</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Disposes the used resources of the scheduler engine.
    /// </summary>
    protected void cleanUp()
    {
        if (cleanupPerformed)
        {
            return;
        }

        if (reqCalcTaskController)
        {
            try
            {
                reqCalcTaskController.endAllTransactions();
            }
            catch
            {
                // nothing to do
            }

            if (thisIsChildThread)
            {
                reqCalcTaskController.resetAssignedNotCompletedBundles();
            }
            else
            {
                reqCalcTaskController.deleteAllBundlesAndTasks();
            }

            reqCalcTaskController.flushTaskTrace();

            this.releaseResources();
        }

        if (wrkCtrScheduler)
        {
            wrkCtrScheduler.dispose();
        }

        cleanupPerformed = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupInvalidRequisitionLineReferences</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes invalid references from the RequisitionLineFirmedOrderLine table.
    /// </summary>
    /// <param name="_requisitionsHelper">
    /// An instance of the requisition helper class.
    /// </param>
    /// <param name="_purchReqLineRecId">
    /// The RecId of the requisition line to delete invalid references for.
    /// </param>
    public void cleanupInvalidRequisitionLineReferences(
        ReqRequisitionsHelper   _requisitionsHelper,
        RecId                   _purchReqLineRecId)
    {
        try
        {
            ttsbegin;
            _requisitionsHelper.cleanupInvalidRequisitionLineReferences(_purchReqLineRecId);
            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            if (this.manageExceptionDeadLock())
            {
                retry;
            }
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (this.retryTransientSqlConnectionError())
            {
                retry;
            }
            else
            {
                throw;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if ( this.manageExceptionUpdateConflict() )
            {
                retry;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupPlanningItemTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cleans up the transactions for planning items.
    /// </summary>
    /// <param name="_planningItemHelper">
    /// The planning item helper instance.
    /// </param>
    public void cleanupPlanningItemTransactions(ReqPlanningItemHelper _planningItemHelper)
    {
        if (!updateAllItems)
        {
            _planningItemHelper.cleanupUsingReqProcessItem(reqPlanData.parmReqPlanVersionRefRecId(), processId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeSafetyStockExpirationDate</Name>
				<Source><![CDATA[
    private void removeSafetyStockExpirationDate(date _date)
    {
        safetyStockExpirationDates.remove(_date);
 
        MapEnumerator me = safetyStockExpirationDates.getEnumerator();

        nextSafetyStockExpiration = me.moveNext() ? me.currentKey() : dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSafetyStockExpirationQtyForDate</Name>
				<Source><![CDATA[
    private void setSafetyStockExpirationQtyForDate(date _expirationDate, ReqQty _expirationQty)
    {
        if (_expirationQty == 0)
        {
            this.removeSafetyStockExpirationDate(_expirationDate);
        }
        else
        {
            safetyStockExpirationDates.insert(_expirationDate, _expirationQty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCoverageEngineValidForItemIdCovDimId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified instance of the coverage engine can be used for the specified combination of item and coverage dimension values.
    /// </summary>
    /// <param name = "_coverageEngine">The coverage engine.</param>
    /// <param name = "_itemId">The item number.</param>
    /// <param name = "_inventDimId">The ID of the coverage dimension value combination.</param>
    /// <returns>true, if the coverage engine can be used for the specified combination of item and coverage dimension values; otherwise, false.</returns>
    protected boolean isCoverageEngineValidForItemIdCovDimId(ReqCalcCoverageEngine _coverageEngine, ItemId _itemId, InventDimId _inventDimId)
    {
        if (_coverageEngine)
        {
            ReqSetupDim reqSetupDim = _coverageEngine.parmSetupDim();
            return reqSetupDim.itemId() == _itemId && reqSetupDim.parmCovInventDimId() == _inventDimId;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>coverageEngine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the coverage engine corresponding to the specified <c>ReqSetupDim</c> object.
    /// </summary>
    /// <param name = "_reqSetupDim">An object containing planning parameters for a specific combination of item and coverage dimension values.</param>
    /// <returns>A coverage engine.</returns>
    protected ReqCalcCoverageEngine coverageEngine(ReqSetupDim _reqSetupDim)
    {
        if (!this.isCoverageEngineValidForItemIdCovDimId(coverageEngine, _reqSetupDim.itemId(), _reqSetupDim.parmCovInventDimId()))
        {
            coverageEngine = ReqCalcCoverageEngine::newFromReqCalcSetupDim(this, _reqSetupDim);
        }

        return coverageEngine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>coverageEngineForReqTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the coverage engine that can be used for the specified <c>ReqTrans</c> record.
    /// </summary>
    /// <param name = "_reqTrans">A <c>ReqTrans</c> record.</param>
    /// <returns>A coverage engine.</returns>
    private ReqCalcCoverageEngine coverageEngineForReqTrans(ReqTrans _reqTrans)
    {
        if (!this.isCoverageEngineValidForItemIdCovDimId(coverageEngine, _reqTrans.itemId, _reqTrans.CovInventDimId))
        {
            ReqSetupDim setupDim = reqPlanData.newReqSetupDim(reqPlanData.newReqSetup(_reqTrans.ItemId), _reqTrans.CovInventDimId);
            coverageEngine = ReqCalcCoverageEngine::newFromReqCalcSetupDim(this, setupDim);
        }

        return coverageEngine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>covCalcDimSafetyInvent</Name>
				<Source><![CDATA[
    private boolean covCalcDimSafetyInvent(ReqTrans _issue, ReqSetupDim _setupDim)
    {
        if (this.coverageEngine(_setupDim).mustConsiderShelfLife() && _issue.RefType == ReqRefType::SafetyInvent)
        {
            if (_issue.RecId == 0)
            {
                // Potential refill of expired safety stock.
                if (safetyStockExpirationDates.exists(_issue.ReqDate - 1) && _issue.ReqDate < reqPlanData.todaysdate() + reqPlanData.timeFenceCoverage(_setupDim))
                {
                    ReqTrans safetyStockReceipt;
                    safetyStockReceipt.data(_issue);

                    _issue.Qty = -safetyStockExpirationDates.lookup(_issue.ReqDate - 1);
                    _issue.OriginalQuantity = _issue.Qty;
                    _issue.insert(reqPlanData);

                    if (reqInclShelfLifeIssuesInPeriodQtyCalculationFlightEnabled)
                    {
                        this.unregisterSafetyStockQty(_issue.ReqDate, _issue.openQty());
                    }

                    safetyStockReceipt.Qty = -_issue.Qty;
                    safetyStockReceipt.OriginalQuantity = safetyStockReceipt.Qty;
                    safetyStockReceipt.CovQty = safetyStockReceipt.Qty;
                    safetyStockReceipt.ReqDate = _issue.ReqDate - 1;
                    safetyStockReceipt.insert(reqPlanData);

                    this.removeSafetyStockExpirationDate(_issue.ReqDate - 1);
                }
                else
                {
                    return false;
                }
            }
            else
            {
                // expired safety stock refill should not update available levels.
                safetyStockLevel -= _issue.openQty();
            }

            if (_issue.Direction == InventDirection::Receipt)
            {
                // Stamp the expiration dates on safety stock releases.
                InventQty remainingQty = _issue.Qty;
                if(safetyStockExpirationDates.exists(nextSafetyStockExpiration))
                {
                    while (remainingQty)
                    {
                        InventQty availableQty = safetyStockExpirationDates.lookup(nextSafetyStockExpiration);

                        if (availableQty < remainingQty)
                        {
                            ReqTrans splitReceipt;

                            splitReceipt.data(_issue);
                            splitReceipt.PdsExpiryDate = nextSafetyStockExpiration;
                            splitReceipt.Qty = availableQty;
                            splitReceipt.OriginalQuantity = availableQty;
                            splitReceipt.CovQty = 0;
                            splitReceipt.insert(reqPlanData);

                            this.removeSafetyStockExpirationDate(nextSafetyStockExpiration);

                            if (_issue.CovQty > 0)
                            {
                                ReqTransCov reqTransCov = _issue.selectCov(true);
                                InventQty remainingCovQty = splitReceipt.Qty;

                                while (reqTransCov.RecId)
                                {
                                    if (remainingCovQty >= abs(reqTransCov.Qty))
                                    {
                                        reqTransCov.ReceiptRecId = splitReceipt.RecId;
                                        reqTransCov.update();

                                        _issue.CovQty -= abs(reqTransCov.Qty);
                                        remainingCovQty -= abs(reqTransCov.Qty);
                                        splitReceipt.CovQty += abs(reqTransCov.Qty);
                                    }
                                    else
                                    {
                                        ReqTransCov splitReqTransCov;

                                        splitReqTransCov.data(reqTransCov);
                                        splitReqTransCov.Qty = sign(reqTransCov.Qty) * remainingCovQty;
                                        splitReqTransCov.ReceiptRecId = splitReceipt.RecId;
                                        splitReqTransCov.insert();

                                        reqTransCov.Qty -= sign(reqTransCov.Qty) * remainingCovQty;
                                        reqTransCov.update();

                                        _issue.CovQty -= remainingCovQty;
                                        remainingCovQty = 0;
                                        splitReceipt.CovQty += remainingCovQty;
                                    }

                                    splitReceipt.update(reqPlanData);

                                    if (!remainingCovQty)
                                    {
                                        break;
                                    }
                                    next reqTransCov;
                                }
                            }
                        }
                        else
                        {
                            _issue.PdsExpiryDate = nextSafetyStockExpiration;
                            _issue.Qty = remainingQty;
                            _issue.OriginalQuantity = remainingQty;
                            _issue.update(reqPlanData);
                            if (previousReceipt.RecId == _issue.RecId)
                            {
                                previousReceipt = null;
                            }

                            this.setSafetyStockExpirationQtyForDate(nextSafetyStockExpiration, availableQty - remainingQty);
                        }

                        remainingQty -= min(remainingQty, availableQty);
                    }
                }
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>covCalcDimBuildIssuesQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the query object for issues.
    /// </summary>
    /// <param name="_setupDim">
    /// A <c>ReqSetupDim</c> object that specified the item and dimension for which to perform the coverage calculation.
    /// </param>
    /// <returns>An initialized <c>QueryRun</c> instance for issues.</returns>
    protected QueryRun covCalcDimBuildIssuesQuery(ReqSetupDim _setupDim)
    {
        QueryRun queryRun;
        if (this.coverageEngine(_setupDim).mustConsiderShelfLife())
        {
            queryRun = new QueryRun(reqTransCache.issuesAndSafetyStockQuery(_setupDim.setup().itemId(), _setupDim.parmCovInventDimId()));
        }
        else
        {
            queryRun = new QueryRun(reqTransCache.issuesQuery(_setupDim.setup().itemId(), _setupDim.parmCovInventDimId()));
        }
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustIncludeIssueInCoverage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if an issue must be included in the coverage.
    /// </summary>
    /// <param name = "_issue">The issue.</param>
    /// <param name = "_reqPlanData">The planning data.</param>
    /// <param name="_setupDim">A <c>ReqSetupDim</c> object that specified the item and dimension for which to perform the coverage calculation.</param>
    /// <returns>true if the issue must be include in the coverage; otherwise, false.</returns>
    protected boolean mustIncludeIssueInCoverage(ReqTrans _issue, ReqPlanData _reqPlanData, ReqSetupDim _setupDim)
    {
        if (_issue.openQty() &&
            _issue.ReqDate < reqPlanData.todaysdate() + _reqPlanData.timeFenceCoverage(_setupDim) &&
            (_issue.IsDerivedDirectly || ! _setupDim.setup().mustItemOnlyBeDirectlyCov()))
        {
            return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>covCalcDimTransMarked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs coverage calculations for marked transactions.
    /// </summary>
    /// <param name = "_issue">The issue.</param>
    /// <param name="_setupDim">A <c>ReqSetupDim</c> object that specified the item and dimension for which to perform the coverage calculation.</param>
    /// <param name="_reqTransCovInsertList">A <c>recordInsertList</c> in which <c>ReqTransCov</c> records are added.</param>
    /// <param name="_level">The BOM level to which the item belongs.</param>
    protected void covCalcDimTransMarked(
        ReqTrans            _issue,
        ReqSetupDim         _setupDim,
        RecordInsertList    _reqTransCovInsertList,
        BOMLevel            _level)
    {
        if (_issue.MarkingRefInventTransOrigin)
        {
            _issue.Level = _level;
            this.covCalcDimTransRefTransId(_setupDim, _issue, _reqTransCovInsertList);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>includeIssueInCoverage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Includes an issue in the coverage.
    /// </summary>
    /// <param name = "_issue">The issue to include.</param>
    protected void includeIssueInCoverage(ReqTrans _issue)
    {
        if (_issue.openQty())
        {
            if (reqCoverageCalcForPriorityReqTransToggleEnabled && _issue.isPrioritized())
            {
                sortedPrioritizedIssueMap.insert(this.covReqTransOrderKey(_issue), _issue);
            }
            else
            {
                this.insertIntoSortedIssueMap(_issue, /*considerPriority:*/ true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>covCalcDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs coverage calculations (matching issues with receipts) for one item and one dimension.
    /// </summary>
    /// <param name="_setupDim">
    /// A <c>ReqSetupDim</c> object that specified the item and dimension for which to perform the coverage calculation.
    /// </param>
    /// <param name="_level">
    /// The BOM level to which the item belongs.
    /// </param>
    /// <param name="_isRecalculating">
    /// Boolean value specifying whether coverage is being performed for the same item again; optional.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Thrown in case an error occurred during the coverage calculation for one requirement transaction.
    /// </exception>
    protected void covCalcDim(
        ReqSetupDim         _setupDim,
        BOMLevel            _level,
        boolean             _isRecalculating = false)
    {
        RecordInsertList    reqTransCovInsertList = reqPlanData.useInsertList() ? new RecordInsertList(tableNum(ReqTransCov), true) : null;

        sortedIssueMap = new Map(Types::String, Types::Record);
        sortedPrioritizedIssueMap = new Map(Types::String, Types::Record);
        shelfLifeSafetyStockIssues = new Map(Types::Date, Types::Real);

        if (!_isRecalculating)
        {
            this.covForecastValidateAggregation(_setupDim);
            this.covForecastReduce(_setupDim);
            this.covForecastAggregate(_setupDim);
            this.covCreateSafetyInvent(_setupDim);
        }

        safetyStockLevel = 0;
        nextSafetyStockExpiration = dateNull();
        safetyStockExpirationDates = new Map(Types::Date, Types::Real);
        
        QueryRun queryRun = this.covCalcDimBuildIssuesQuery(_setupDim);

        while (queryRun.next())
        {
            ReqTrans issue = queryRun.get(tableNum(ReqTrans));
            
            if (this.mustIncludeIssueInCoverage(issue, reqPlanData, _setupDim))
            {
                //do coverage for marked transactions first -> unused marked receipts will then be used in loop below
                this.covCalcDimTransMarked(issue, _setupDim, reqTransCovInsertList, _level);

                this.includeIssueInCoverage(issue);
            }
        }

        // Firstly go through sorted prioritized issues
        MapEnumerator me_sortedPrioritizedIssueMap = sortedPrioritizedIssueMap.getEnumerator();

        while (me_sortedPrioritizedIssueMap.moveNext())
        {
            ReqTrans issue = me_sortedPrioritizedIssueMap.currentValue();

            // Try to cover prioritized issue with existing receipts
            this.covCalcDimTransPrioritized(issue, _setupDim, reqTransCovInsertList);

            // Insert issue into sorted list without considering prioritization
            this.insertIntoSortedIssueMap(issue, /*considerPriority:*/ false);
        }

        // Go through sorted all issues
        MapEnumerator me_sortedIssueMap = sortedIssueMap.getEnumerator();

        while (me_sortedIssueMap.moveNext())
        {
            ReqTrans issue = me_sortedIssueMap.currentValue();

            boolean needsCoverage = this.covCalcDimSafetyInvent(issue, _setupDim);

            if (!needsCoverage)
            {
                continue;
            }

            while (issue.openQty() < 0)
            {
                issue.Level = _level;

                if (!this.covCalcDimTrans(_setupDim, issue, reqTransCovInsertList))
                {
                    throw error(strFmt("@SYS18704",_setupDim.setup().itemId()));
                }
            }

            if (issue.openQty() > 0)
            {
                throw error(strFmt("@SCM:MasterPlanningDataCorruptionError", _setupDim.setup().itemId()));
            }

            // If new safety stock issues were added due to expiry during the processing then the map enumerator must be
            // reset (otherwise an error will be thrown when running under IL) and positioned at the original position
            if (safetyStockIssuesAdded)
            {
                str enumeratorPosition = me_sortedIssueMap.currentKey();

                me_sortedIssueMap = sortedIssueMap.getEnumerator();
                while (me_sortedIssueMap.moveNext())
                {
                    if (me_sortedIssueMap.currentKey() == enumeratorPosition)
                    {
                        break;
                    }
                }

                safetyStockIssuesAdded = false;
            }
        }

        if (reqTransCovInsertList)
        {
            reqTransCovInsertList.insertDatabase();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertIntoSortedIssueMap</Name>
				<Source><![CDATA[
    private void insertIntoSortedIssueMap(ReqTrans _issue, boolean _considerPriorityForSortKey)
    {
        if (_considerPriorityForSortKey)
        {
            sortedIssueMap.insert(this.covReqTransOrderKey(_issue), _issue);
        }
        else
        {
            var sortKeyWithoutPriority = ReqCalc::getReqTransCoverage2SortKey(_issue,
                                                                              _issue.ReqDate,
                                                                              this.coverageEngineForReqTrans(_issue).mustConsiderShelfLife(),
                                                                              /*considerPriority:*/ false);

            sortedIssueMap.insert(sortKeyWithoutPriority, _issue);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>covCalcDimTransPrioritized</Name>
				<Source><![CDATA[
    private void covCalcDimTransPrioritized(ReqTrans _issue, ReqSetupDim _setupDim, RecordInsertList _reqTransCovInsertList)
    {
        Debug::assert(_issue.isPrioritized());

        while (_issue.openQty() < 0)
        {
            var receipt = this.covFindExistingReceipt(_issue, _setupDim);

            if (receipt)
            {
                this.covCreateCoverage(_setupDim, receipt, _issue, _reqTransCovInsertList);
            }
            else
            {
                break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>covCalcDimTransSafetyInvent</Name>
				<Source><![CDATA[
    private ReqTrans covCalcDimTransSafetyInvent(ReqTrans _issue, ReqSetupDim _setupDim, ReqTrans _alternativeReceipt)
    {
        ReqTrans receipt = _alternativeReceipt;

        if (safetyStockLevel > 0
            && _issue.RefType != ReqRefType::SafetyInvent
            && this.coverageEngine(_setupDim).mustConsiderShelfLife())
        {
            ReqDate safetyStockExpirationDate;
            InventQty safetyStockQty = 0;

            var expirationDatesEnumerator = safetyStockExpirationDates.getEnumerator();
            while (expirationDatesEnumerator.moveNext() && safetyStockQty == 0)
            {
                safetyStockExpirationDate = expirationDatesEnumerator.currentKey();
                if (!safetyStockExpirationDate || safetyStockExpirationDate >= _issue.pdsNeedByDate())
                {
                    safetyStockQty = expirationDatesEnumerator.currentValue();
                }
            }

            if (safetyStockQty > 0
                && (_alternativeReceipt.openQty() == 0 || (safetyStockExpirationDate && _alternativeReceipt.PdsExpiryDate > safetyStockExpirationDate)))
            {
                ReqTrans safetyStockIssueReqTrans;

                safetyStockIssueReqTrans.PlanVersion =  this.reqPlanVersionRefRecId();
                safetyStockIssueReqTrans.ReqProcessId = reqPlanData.parmProcessId();

                safetyStockIssueReqTrans.ItemId = _setupDim.setup().itemId();
                safetyStockIssueReqTrans.CovInventDimId = _setupDim.parmCovInventDimId();

                safetyStockIssueReqTrans.RefType =  ReqRefType::SafetyInvent;
                safetyStockIssueReqTrans.OpenStatus = ReqOpenStatus::Neg;
                safetyStockIssueReqTrans.Direction = InventDirection::Issue;

                safetyStockIssueReqTrans.Level = _setupDim.itemLevel();

                safetyStockIssueReqTrans.Qty = -min(safetyStockQty, abs(_issue.openQty()));

                safetyStockIssueReqTrans.ReqDate = _issue.ReqDate;
                safetyStockIssueReqTrans.ReqTime = _issue.ReqTime;
                safetyStockIssueReqTrans.ReqDateDlvOrig = _issue.ReqDate;
                safetyStockIssueReqTrans.PdsSellableDays = _issue.PdsSellableDays;

                ReqTrans safetyStockReceiptTrans = safetyStockIssueReqTrans.data();
                safetyStockReceiptTrans.PdsExpiryDate = safetyStockExpirationDate;
                safetyStockReceiptTrans.Qty = -safetyStockIssueReqTrans.Qty;
                safetyStockReceiptTrans.OpenStatus = ReqOpenStatus::Pos;
                safetyStockReceiptTrans.Direction = InventDirection::Receipt;
                safetyStockReceiptTrans.PdsSellableDays = 0;

                if (this.coverageEngine(_setupDim).isReceiptValidForIssue(safetyStockReceiptTrans, _issue))
                {
                    safetyStockIssueReqTrans.insert();
                    sortedIssueMap.insert(this.covReqTransOrderKey(safetyStockIssueReqTrans), safetyStockIssueReqTrans);
                    safetyStockIssuesAdded = true;

                    this.setSafetyStockExpirationQtyForDate(safetyStockExpirationDate, safetyStockQty - safetyStockReceiptTrans.Qty);

                    safetyStockReceiptTrans.insert();

                    safetyStockLevel -= safetyStockReceiptTrans.Qty;

                    receipt = safetyStockReceiptTrans;
                }
            }
        }

        return receipt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>covCalcDimTrans</Name>
				<Source><![CDATA[
    protected boolean covCalcDimTrans(
        ReqSetupDim         _setupDim,
        ReqTrans            _issue,
        RecordInsertList    _reqTransCovInsertList)
    {
        ReqTrans receipt;

        setPrefix(#PrefixFieldValue(ReqTrans, RefId,_issue.RefId));

        if (traceLoggingEnabled)
        {
            reqTraceLogger.writeLog(ReqTraceLogMessageEntry::newFromReqTrans(ReqTraceMessageType::IssueMustBeCovered, [[enumNum(ReqRefType), enum2int(_issue.RefType)], ReqTraceLogMessage::packInventDim(_setupDim.inventDim()), _issue.ReqDate, _issue.openQty()], _issue));
        }

        receipt = this.covFindExistingReceipt(_issue, _setupDim);

        if (receipt && traceLoggingEnabled)
        {
            reqTraceLogger.writeLog(ReqTraceLogMessageEntry::newFromReqTrans(ReqTraceMessageType::ReceiptFound, [[enumNum(ReqRefType), enum2int(receipt.RefType)], ReqTraceLogMessage::packInventDim(receipt.inventDim()), receipt.ReqDate, receipt.Qty, receipt.openQty()], _issue));
        }

        // Ensure that we follow the FEFO principle by using safety stock prior to using receipts with later expiry dates or creating new planned orders
        receipt = this.covCalcDimTransSafetyInvent(_issue, _setupDim, receipt);

        if (!receipt)
        {
            if (_issue.PmfPlanGroupId)
            {
                if (this.pmfPlanGroupSubstituteIssue(_issue))
                {
                    return true;
                }
            }
            if (traceLoggingEnabled)
            {
                reqTraceLogger.writeLog(ReqTraceLogMessageEntry::newFromReqTrans(ReqTraceMessageType::NoReceiptFound, conNull(), _issue));
            }

            if (!receipt)
            {
                receipt = this.covCreatePlannedOrder(_setupDim, _issue);
            }
        }

        if (receipt)
        {
            this.covCreateCoverage(_setupDim, receipt, _issue, _reqTransCovInsertList);
            this.pmfClearPlannGroupIssuesAbovePriority(_issue);
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>covFindExistingReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the existing receipt record.
    /// </summary>
    /// <param name = "_issue">
    ///     A <c>ReqTrans</c> table record.
    /// </param>
    /// <param name = "_setupDim">
    ///     An instance of <c>ReqSetupDim</c> class.
    /// </param>
    /// <returns>
    ///    The retrieved receipt record.
    /// </returns>
    protected ReqTrans covFindExistingReceipt(ReqTrans _issue, ReqSetupDim _setupDim)
    {
        ReqTrans receipt;

        if (!_issue.IsDerivedDirectly)
        {
            if (_issue.Priority == #priorityReservPhysical)
            {
                receipt = this.covFindOnhand(_setupDim, _issue);
                if (receipt.RecId)
                {
                    isPreviousReceiptOnHand = true;
                }
            }

            if (!receipt)
            {
                receipt = this.covFindReceipt(_setupDim, _issue, false);
                isPreviousReceiptOnHand = false;
            }
        }

        return receipt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>covCalcDimTransRefTransId</Name>
				<Source><![CDATA[
    protected void covCalcDimTransRefTransId(
        ReqSetupDim         _setupDim,
        ReqTrans            _issue,
        RecordInsertList    _reqTransCovInsertList)
    {
        if (!_issue.MarkingRefInventTransOrigin
            || _issue.IsDerivedDirectly
            || _issue.Priority == #priorityReservPhysical) // marked, physically reserved demand should not bypass onhand => find supply according to sorted priority
        {
            return;
        }

        var receipt = this.covFindReceipt(_setupDim, _issue, true);

        if (receipt)
        {
            this.covCreateCoverage(_setupDim, receipt, _issue, _reqTransCovInsertList);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>covCalcItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs coverage calculation for one item list.
    /// </summary>
    /// <param name="_level">
    /// Level to process the list on.
    /// </param>
    /// <param name="_itemId">
    /// The item ID to process.
    /// </param>
    protected void covCalcItem(BOMLevel _level, ItemId _itemId)
    {
        #TimeConstants

        ReqSetupDim         setupDim;

        List                listCovDimSorted;
        ListEnumerator      leCovDimSorted;

        InventDimId         covInventDimId;
        Integer             dimElements;
        boolean             isRecalculating;

        void handleError()
        {
            this.handleItemError(_itemId, "@SYS26323");
            listCovDimSorted  = new List(Types::String);
            recalculateSameItemAgain = false;
        }

        if (_level > 0 && !this.isCompleteUpdate())
        {
            this.updateReqTransUpdate(_itemId);
        }

        do
        {
            isRecalculating = recalculateSameItemAgain;
            recalculateSameItemAgain = false;

            reqTransCache.setCurrentItem(_itemId);
            reqTransCache.setCurrentLevel(_level);

            scheduleOrdersList = new List(Types::String);

            WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::Item, fieldLabelValue(tableNum(InventTable), fieldNum(InventTable,ItemId), _itemId));
            setPrefix(fieldLabelValue(tableNum(InventTable), fieldNum(InventTable,ItemId), _itemId));

            int infologLineTry = infologLine();
            try
            {
                // make sorted list of covDimId
                listCovDimSorted = reqTransCache.listCovDimSorted(_itemId, reqPlanData);
            }
            catch (Exception::Error)
            {
                if (this.retryExceptionError(infologLineTry))
                {
                    retry;
                }

                handleError();
            }

            pmfCurrentCoByReqDate = dateNull();

            // remember number of covDimId
            dimElements  = listCovDimSorted.elements();

            leCovDimSorted = listCovDimSorted.getEnumerator();
            while (leCovDimSorted.moveNext())
            {
                if (! setErrorItemId.in(_itemId))
                {
                    covInventDimId = leCovDimSorted.current();

                    infologLineTry = infologLine();
                    try
                    {
                        reqPlanData.createReqLogRestorePoint();

                        ttsbegin;

                        scheduleOrdersList = new List(Types::String);

                        setupDim = reqPlanData.newReqSetupDim(reqPlanData.newReqSetup(_itemId), covInventDimId);

                        if (setupDim.validate(throwCovItemValidationErrors))
                        {
                            if (setupDim.mustBeCovPlanned())
                            {
                                setPrefix(fieldLabelValue(tableNum(InventDim), fieldNum(InventDim,InventDimId), covInventDimId));

                                previousReceipt             = null;

                                this.covCalcDim(setupDim, _level, isRecalculating);
                            }

                            reqPlanData.reqLogCoverage().add(setupDim.setup().itemId(), setupDim.parmCovInventDimId(), setupDim.covRule(), setupDim.minSatisfy(), setupDim.covPeriod(), setupDim.minInventOnHand(), setupDim.maxInventOnHand());

                            this.insertUnscheduledOrders(scheduleOrdersList);

                            setupDim.showInfolog();
                        }

                        ttscommit;
                    }
                    catch (Exception::Deadlock)
                    {
                        if ( this.manageExceptionDeadLockRestoreReqCalc() )
                        {
                            retry;
                        }
                    }
                    catch (Exception::TransientSqlConnectionError)
                    {
                        if (this.retryTransientSqlConnectionErrorRestoreReqCalc())
                        {
                            retry;
                        }
                        else
                        {
                            throw;
                        }
                    }
                    catch (Exception::UpdateConflict)
                    {
                        if (this.manageExceptionUpdateConflictRestoreReqCalc())
                        {
                            retry;
                        }
                    }
                    catch (Exception::Error)
                    {
                        if (this.retryExceptionErrorRestoreReqCalc(infologLineTry))
                        {
                            retry;
                        }

                        handleError();
                    }
                    catch (Exception::CLRError)
                    {
                        ApplicationUnhandledExceptionLogger::processUnhandledCLRException();
                        handleError();
                    }
                    catch (Exception::Info)
                    {
                        handleError();
                    }
                }
            }
        }
        while (recalculateSameItemAgain);
    }

]]></Source>
			</Method>
			<Method>
				<Name>covMinSafetyStockDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the minimum date of safety stock requirement during the coverage phase.
    /// </summary>
    /// <param name = "_setupDim">Master planning parameters for a specific combination of item and coverage dimension values.</param>
    /// <returns>The minimum date of safety stock requirement.</returns>
    protected ReqDate covMinSafetyStockDate(ReqSetupDim _setupDim)
    {
        ReqDate safetyStockDate;

        if (!this.isCompleteUpdate() ||
            (!_setupDim.minSafetyPeriod() && _setupDim.minSafetyKeyId()) ||
            (_setupDim.minSatisfy() != ReqMinSatisfy::TodaysDate &&
                _setupDim.minSatisfy() != ReqMinSatisfy::TimeFenceDate))
        {
            ReqTrans reqTransSafety;

            select firstonly ReqDate from reqTransSafety
                order by ReqDate
                where reqTransSafety.PlanVersion == this.reqPlanVersionRefRecId()
                    && reqTransSafety.RefType == ReqRefType::SafetyInvent
                    && reqTransSafety.RefId == ''
                    && reqTransSafety.InventTransOrigin == 0
                    && reqTransSafety.ItemId == _setupDim.itemId()
                    && reqTransSafety.CovInventDimId == _setupDim.parmCovInventDimId();

            safetyStockDate = reqTransSafety.ReqDate ? reqTransSafety.ReqDate : reqPlanData.todaysdate();
        }
        else
        {
            safetyStockDate = this.safetyStockDate(_setupDim);
        }

        return safetyStockDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>covCodeQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates quantity that must be ordered if the specified issue could not be covered with existing receipts.
    /// </summary>
    /// <param name = "_setupDim">Master planning parameters for a specific combination of item and coverage dimension values.</param>
    /// <param name = "_issue">The issue transaction that will be pegged with the new planned order.</param>
    /// <returns>The planned order quantity.</returns>
    protected InventQty covCodeQty(ReqSetupDim _setupDim, ReqTrans _issue)
    {
        ReqTraceMessageCon reqTraceMessageCon;
        ReqTraceMessageDetailType reqTraceMessageDetailType;
        ReqCalcCovCodeQty reqCalcCovCodeQty = ReqCalcCovCodeQty::construct();

        switch (_setupDim.covRule())
        {
            case ReqCovType::Req:
                this.covCodeQtyReq(_issue, reqCalcCovCodeQty);
                reqTraceMessageDetailType = ReqTraceMessageDetailType::OrderQuantityRequirement;
                reqTraceMessageCon = reqCalcCovCodeQty.pack();
                break;
            case ReqCovType::Period:
                this.covCodeQtyPeriod(_setupDim, _issue, reqCalcCovCodeQty);
                reqTraceMessageDetailType = ReqTraceMessageDetailType::OrderQuantityPeriodCoverage;

                reqTraceMessageCon = reqCalcCovCodeQty.pack();
                reqTraceMessageCon += covPeriodReceiptFromDate;
                reqTraceMessageCon += covPeriodReceiptToDate;
                break;
            case ReqCovType::MinMax:
                this.covCodeQtyMinMax(_setupDim, _issue, reqCalcCovCodeQty);
                reqTraceMessageDetailType = ReqTraceMessageDetailType::OrderQuantityMinMax;
                reqTraceMessageCon = reqCalcCovCodeQty.pack();
                break;
            case ReqCovType::Manual:
                this.covCodeQtyManual(reqCalcCovCodeQty);
                reqTraceMessageDetailType = ReqTraceMessageDetailType::OrderQuantityManual;
                reqTraceMessageCon = reqCalcCovCodeQty.pack();
                break;
        }

        this.writeToTraceLog(reqTraceMessageCon, reqTraceMessageDetailType);

        return reqCalcCovCodeQty.qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>covCodeQtyReq</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates quantity that must be ordered for <c>ReqCovType</c> Req.
    /// </summary>
    /// <param name = "_issue">The issue transaction that will be pegged with the new planned order.</param>
    /// <param name = "_reqCalcCovCodeQty">The <c>ReqCalcCovCodeQty</c> instance to store the relevant calculated values.</param>
    protected void covCodeQtyReq(ReqTrans _issue, ReqCalcCovCodeQty _reqCalcCovCodeQty)
    {
        _reqCalcCovCodeQty.qty = -_issue.openQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>covCodeQtyManual</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates quantity that must be ordered for <c>ReqCovType</c> Manual.
    /// </summary>
    /// <param name = "_reqCalcCovCodeQty">The <c>ReqCalcCovCodeQty</c> instance to store the relevant calculated values.</param>
    protected void covCodeQtyManual(ReqCalcCovCodeQty _reqCalcCovCodeQty)
    {
        _reqCalcCovCodeQty.qty = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>covCodeQtyPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates quantity that must be ordered for <c>ReqCovType</c> Period.
    /// </summary>
    /// <param name = "_setupDim">Master planning parameters for a specific combination of item and coverage dimension values.</param>
    /// <param name = "_issue">The issue transaction that will be pegged with the new planned order.</param>
    /// <param name = "_reqCalcCovCodeQty">The <c>ReqCalcCovCodeQty</c> instance to store the relevant calculated values.</param>
    protected void covCodeQtyPeriod(ReqSetupDim _setupDim, ReqTrans _issue, ReqCalcCovCodeQty _reqCalcCovCodeQty)
    {
        covPeriodReceiptFromDate = _issue.ReqDate <= reqPlanData.todaysdate() ? dateNull()                  : _issue.ReqDate;
        covPeriodReceiptToDate   = _issue.ReqDate <= reqPlanData.todaysdate() ? reqPlanData.todaysdate()    : _issue.ReqDate;
        covPeriodReceiptToDate   = covPeriodReceiptToDate + min(_setupDim.covPeriod(),_setupDim.maxPositiveDays()) - 1;

        _reqCalcCovCodeQty.qty = this.calculatePeriodQty(_setupDim, _issue);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSkipCalculateSafetyStock</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to perform the safety stock calculations.
    /// </summary>
    /// <param name = "_setupDim">
    /// Master planning parameters for a specific combination of item and coverage dimension values.
    /// </param>
    /// <param name = "_issue">
    /// The issue transaction that will be pegged with the new planned order.
    /// </param>
    /// <param name = "_reqCalcCovCodeQty">
    /// The <c>ReqCalcCovCodeQty</c> instance to store the relevant calculated values.
    /// </param>
    /// <returns>
    /// true if needs to be perform the safety stock calculations; otherwise, false.
    /// </returns>
    protected boolean mustSkipCalculateSafetyStock(ReqSetupDim _setupDim, ReqTrans _issue, ReqCalcCovCodeQty _reqCalcCovCodeQty)
    {
        // Route/BOM requirements are expected to only be used in special cases and we must not maintain safety stock for each possible route/bom
        // Skip calculating safety stock for Purchase Requisitions because they can't consume on-hand and can't affect the safety stock
        if ((_issue.ItemBomId && _setupDim.bomVersionReq()) || (_issue.ItemRouteId && _setupDim.routeVersionReq()) || _issue.RefType == ReqRefType::RequisitionLine)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>covCodeQtyMinMax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates quantity that must be ordered for <c>ReqCovType</c> MinMax.
    /// </summary>
    /// <param name = "_setupDim">Master planning parameters for a specific combination of item and coverage dimension values.</param>
    /// <param name = "_issue">The issue transaction that will be pegged with the new planned order.</param>
    /// <param name = "_reqCalcCovCodeQty">The <c>ReqCalcCovCodeQty</c> instance to store the relevant calculated values.</param>
    protected void covCodeQtyMinMax(ReqSetupDim _setupDim, ReqTrans _issue, ReqCalcCovCodeQty _reqCalcCovCodeQty)
    {
        if (this.mustSkipCalculateSafetyStock(_setupDim, _issue, _reqCalcCovCodeQty))
        {
            _reqCalcCovCodeQty.qty = -_issue.openQty();

            return;
        }
 
        InventQty totalOpenIssueQtyForDate = abs(_issue.openQty()) + abs(this.covFindIssueQtyDate(_setupDim, _issue));

        InventQty qtyMin, qtyMax;
        [qtyMin, qtyMax] = this.covMinMaxQtyOnDate(_setupDim, _issue.ReqDate);

        InventQty minSafetyStockQty = this.calculateMinSafetyStockQty(_setupDim, _issue, qtyMin);
        InventQty qty = this.calculateMinMaxQty(totalOpenIssueQtyForDate, qtyMax, minSafetyStockQty);

        _reqCalcCovCodeQty.qty = qty;
        _reqCalcCovCodeQty.reqDate = _issue.ReqDate;
        _reqCalcCovCodeQty.qtyMin = qtyMin;
        _reqCalcCovCodeQty.qtyMax = qtyMax;
        _reqCalcCovCodeQty.minSafetyStockQty = minSafetyStockQty;
        _reqCalcCovCodeQty.totalOpenIssueQtyForDate = totalOpenIssueQtyForDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculatePeriodQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the planned order quantity for <c>ReqCovType</c> Period.
    /// </summary>
    /// <param name = "_setupDim">Master planning parameters for a specific combination of item and coverage dimension values.</param>
    /// <param name = "_issue">The issue transaction that will be pegged with the new planned order.</param>
    /// <returns>The planned order quantity.</returns>
    private InventQty calculatePeriodQty(ReqSetupDim _setupDim, ReqTrans _issue)
    {
        InventQty qty = 0;

        if (_issue.MarkingRefInventTransOrigin)
        {
            qty = _issue.openQty();
        }

        qty += this.covFindIssueQtyPeriod(_setupDim, _issue, covPeriodReceiptFromDate, covPeriodReceiptToDate);

        if (reqInclShelfLifeIssuesInPeriodQtyCalculationFlightEnabled)
        {
            qty += this.findShelfLifeSafetyStockIssueQtyPeriod(_setupDim);
        }
        
        qty = (qty < 0) ? -qty : -_issue.openQty();

        return qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findShelfLifeSafetyStockIssueQtyPeriod</Name>
				<Source><![CDATA[
    private ReqQty findShelfLifeSafetyStockIssueQtyPeriod(ReqSetupDim _setupDim)
    {
        ReqQty sumQty;

        if (!shelfLifeSafetyStockIssues.empty())
        {
            MapEnumerator me_shelfLifeSafetyStockIssueMap = shelfLifeSafetyStockIssues.getEnumerator();
            
            while (me_shelfLifeSafetyStockIssueMap.moveNext())
            {
                ReqDate issueReqDate = me_shelfLifeSafetyStockIssueMap.currentKey();

                if (issueReqDate >= covPeriodReceiptFromDate
                    && issueReqDate <= covPeriodReceiptToDate)
                {
                    ReqQty issueQty = me_shelfLifeSafetyStockIssueMap.currentValue();
                    sumQty += issueQty;
                }
            }
        }

        return sumQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerSafetyStockQty</Name>
				<Source><![CDATA[
    private void registerSafetyStockQty(ReqDate _requirementDate, ReqQty _qty)
    {
        if (_qty == 0)
        {
            return;
        }

        if (shelfLifeSafetyStockIssues.exists(_requirementDate))
        {
            shelfLifeSafetyStockIssues.insert(_requirementDate, shelfLifeSafetyStockIssues.lookup(_requirementDate) + _qty);
        }
        else
        {
            shelfLifeSafetyStockIssues.insert(_requirementDate, _qty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unregisterSafetyStockQty</Name>
				<Source><![CDATA[
    private void unregisterSafetyStockQty(ReqDate _requirementDate, InventQtyOpen _qty)
    {
        if (_qty != 0 && shelfLifeSafetyStockIssues.exists(_requirementDate))
        {
            shelfLifeSafetyStockIssues.insert(_requirementDate, max(0, shelfLifeSafetyStockIssues.lookup(_requirementDate) - _qty));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateMinMaxQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the planned order quantity for <c>ReqCovType</c> MinMax.
    /// </summary>
    /// <param name = "_totalOpenIssueQtyForDate">An <c>InventQty</c> specifying the total open issue quantity.</param>
    /// <param name = "_qtyMax">An <c>InventQty</c> specifying the planned maximum order quantity.</param>
    /// <param name = "_minSafetyStockQty">An <c>InventQty</c> specifying the minimum safety stock quantity</param>
    /// <returns>The planned order quantity.</returns>
    protected InventQty calculateMinMaxQty(InventQty _totalOpenIssueQtyForDate, InventQty _qtyMax, InventQty _minSafetyStockQty)
    {
        return _totalOpenIssueQtyForDate + max(_qtyMax - _minSafetyStockQty, 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateMinSafetyStockQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the minimum safety stock quantity.
    /// </summary>
    /// <param name = "_setupDim">Master planning parameters for a specific combination of item and coverage dimension values.</param>
    /// <param name = "_issue">The issue transaction that will be pegged with the new planned order.</param>
    /// <param name = "_qtyMin">An <c>InventQty</c> specifying the planned minimum order quantity.</param>
    /// <returns>Minimum planned safety stock quantity.</returns>
    protected InventQty calculateMinSafetyStockQty(ReqSetupDim _setupDim, ReqTrans _issue, InventQty _qtyMin)
    {
        InventQty minSafetyStockQty = _qtyMin;

        // When an issue has sellable days then we cannot assume that on hand is at the minimum level when replenishment is triggered
        // We could still have on hand some batches that are just not fresh enough for the issue
        if (this.coverageEngine(_setupDim).mustConsiderShelfLife() && _issue.PdsSellableDays)
        {
            minSafetyStockQty += this.covFindOpenReceiptQtyForMinMax(_setupDim, _issue);
        }

        return minSafetyStockQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeToTraceLog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Writes to the log if trace logging is enabled.
    /// </summary>
    /// <param name = "_reqTraceMessageCon">A <c>ReqTraceMessageCon</c> holding values that are to be replaced in the message text.</param>
    /// <param name = "_reqTraceMessageDetailType">The message detail type.</param>
    protected void writeToTraceLog(ReqTraceMessageCon _reqTraceMessageCon, ReqTraceMessageDetailType _reqTraceMessageDetailType)
    {
        if (traceLoggingEnabled)
        {
            reqTraceLogger.writeLog(ReqTraceLogMessageDetail::newDetail(_reqTraceMessageDetailType, _reqTraceMessageCon));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>covMinMaxQtyOnDate</Name>
				<Source><![CDATA[
    private container covMinMaxQtyOnDate(ReqSetupDim _setupDim, ReqDate _reqDate)
    {
        ReqDate minSafetyStockDate = this.covMinSafetyStockDate(_setupDim);
        ReqDate minMaxDate;

        if (_setupDim.minSafetyKeyId() && !_setupDim.minSafetyPeriod())
        {
            minMaxDate = minSafetyStockDate;
        }
        else
        {
            minMaxDate = max(_reqDate, reqPlanData.todaysDate());
        }

        InventQty qtyMin = _setupDim.minInventOnhandDate(minMaxDate, reqPlanData.todaysdate());
        InventQty qtyMax = max(_setupDim.maxInventOnhandDate(minMaxDate, reqPlanData.todaysdate()), qtyMin);

        if (minSafetyStockDate > _reqDate && minSafetyStockDate > reqPlanData.todaysdate())
        {
            qtyMin = 0;
        }

        return [qtyMin, qtyMax];
    }

]]></Source>
			</Method>
			<Method>
				<Name>covCreateCoverage</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the <c>ReqTransCov</c> record to settle the receipt and the issue <c>reqTrans</c> records.
    /// </summary>
    /// <param name="_setupDim">
    ///    A <c>reqSetupDim</c> object that holds master planning data for a specific item and coverage
    ///    dimension.
    /// </param>
    /// <param name="_receipt">
    ///    A <c>reqTrans</c> record with positive quantity (receipt).
    /// </param>
    /// <param name="_issue">
    ///    A <c>reqTrans</c> record with a negative quantity (issue).
    /// </param>
    /// <param name="_reqTransCovInsertList">
    ///    A <c>recordInsertList</c> in which <c>ReqTransCov</c> records are added.
    /// </param>
    /// <param name="_receiptConstraints">
    ///    Constraints that were imposed by the issue on the receipt.
    /// </param>
    /// <remarks>
    ///    This method should be called when a receipt <c>reqTrans</c> record is found and should be used to
    ///    settle an issue <c>reqTrans</c> record.
    ///    Notice the <c>previousReceipt</c> and
    ///    <c>delayedOrderSet</c> variables are set.
    /// </remarks>
    protected void covCreateCoverage(
        ReqSetupDim                         _setupDim,
        ReqTrans                            _receipt,
        ReqTrans                            _issue,
        RecordInsertList                    _reqTransCovInsertList,
        ReqCalcCoverageReceiptConstraints   _receiptConstraints = null)
    {
        this.pdsMaintainSafetyStock(_receipt, _issue, _setupDim);

        ReqTransCov::insertFromReceiptIssue(_receipt,_issue,reqPlanData,_reqTransCovInsertList, reqPlanData.reqTraceLogger());

        if (_receipt.RecId != previousReceipt.RecId)
        {
            firstIssueCoveredByPreviousReceipt = _issue.data();
        }
        
        previousReceipt = _receipt.data();

        // Insert children if the receipt is a non-planned order
        this.explodeReceipt(_receipt);

        if (reqPlanData.doFuturesCalc() && reqPlanData.futuresSched())
        {
            reqCalcMarkDelayed.findAndMarkDelayedOrders(reqPlanData, _receipt,_issue,_setupDim);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustInitializeVendor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the vendor account needs to be initialized on the planned order record.
    /// </summary>
    /// <param name = "_plannedOrder">
    /// A planned order record buffer.
    /// </param>
    /// <returns>
    /// true if vendor account needs to be initialized on the planned order record; otherwise false;
    /// </returns>
    protected boolean mustInitializeVendor(ReqPO _plannedOrder)
    {
        return !(_plannedOrder.VendId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePlannedOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the planned order record.
    /// </summary>
    /// <param name = "_plannedOrder">
    /// A <c>ReqPO</c> record buffer.
    /// </param>
    /// <param name = "_setupDim">
    /// A <c>ReqSetupDim</c> object.
    /// </param>
    /// <returns>
    /// true if the planned order is valid; otherwise, false.
    /// </returns>
    protected boolean initializePlannedOrder(ReqPO _plannedOrder, ReqSetupDim _setupDim)
    {
        if (_plannedOrder.Qty <= 0)
        {
            return false;
        }

        if (this.mustInitDefaultLeadTime())
        {
            // Default lead time
            _plannedOrder.initLeadTime(_setupDim);
        }

        // Choose vendor
        if (this.mustInitializeVendor(_plannedOrder))
        {
            _plannedOrder.initVendId(_setupDim,reqPlanData);
        }

        // Find correct BOM and route version

        _plannedOrder.initFromSetup(_setupDim.setup(), reqPlanData.reqTraceLogger(), reqPlanData);

        _plannedOrder.initPurchQty();

        // Calculate SchedFromDate & reqDateOrder
        _plannedOrder.setSchedFromDate(_setupDim, reqPlanData);

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustInitDefaultLeadTime</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether to initialize the default lead time to the planned order.
    /// </summary>
    /// <returns>
    ///     true if the default lead time must be initialized to the planned order; otherwise, false.
    /// </returns>
    protected boolean mustInitDefaultLeadTime()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>covCreatePlannedOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates one or more planned orders, where each planned order is a combination of a <c>ReqPO</c> and
    ///    a <c>ReqTrans</c> record.
    /// </summary>
    /// <param name="_setupDim">
    ///    A <c>reqSetupDim</c> object which holds master planning setting for a specific item and coverage
    ///    dimensions.
    /// </param>
    /// <param name="_issue">
    ///    A <c>reqTrans</c> record with a negative unsettled quantity.
    /// </param>
    /// <returns>
    ///    A <c>ReqTrans</c> record with a positive quantity that can fulfill the issue record.
    /// </returns>
    /// <remarks>
    ///    The issue <c>reqTrans</c> record cannot be settled against any existing receipts or on-hand. A
    ///    planned order must be created.
    /// </remarks>
    protected ReqTrans covCreatePlannedOrder(
        ReqSetupDim     _setupDim,
        ReqTrans        _issue)
    {
        ReqSetup                setup = _setupDim.setup();
        ReqTransPOCreate        reqTransPOCreate;

        ReqPO                   plannedOrder;
        ReqTrans                reqTransPo;
        ReqPO                   reqPoParent;

        InventQty               qtyMinMaxRemain;
        ReqTrans                receipt;

        ReqRouteSchedulingView  reqRouteSchedulingView;
        WrkCtrTable             wrkCtrTableVend;
        ReqDateDlvOrig          reqDateDlvOrig;

        ReqItemTable            reqItemTable;

        BOM                     issueBom = BOM::findRecId(_issue.BOMRefRecId);

        reqTransPOCreate = ReqTransPOCreate::construct();
        reqTransPOCreate.parmBOMDependencyManager(this.parmBOMDependencyManager());

        if (this.validateCoverageForPlanningAndCoProduct(setup, _issue))
        {
            if (_setupDim.covRule() != ReqCovType::Req)
            {
                receipt = this.pmfCoCovIncreaseExistingOrder(_setupDim, _issue);
                if (receipt)
                {
                    // BP violation necessary to reduce changes to large block of code below
                    return receipt;
                }
            }

            if (this.mustCreateCoCovPlannedOrder(_setupDim, _issue))
            {
                // BP violation necessary; the PMF method replaces this method in this case
                return this.pmfCoCovCreatePlannedOrder(_issue);
            }
        }

        do
        {
            plannedOrder.clear();

            plannedOrder.RefId = NumberSeq::newGetNumFromId(reqPlanData.sequencePlannedOrder()).num();

            plannedOrder.initFromIssue(_issue,_setupDim);

            if (#PmfEnabled)
            {
                reqItemTable = ReqItemTable::find(plannedOrder.ItemId, plannedOrder.CovInventDimId);

                if (reqItemTable)
                {
                    plannedOrder.PmfPlanningItemId = reqItemTable.PmfPlanningItemId;
                }

                reqPoParent = ReqPO::find(_issue.PlanVersion,_issue.RefId);

                if (_issue.IsDerivedDirectly && _issue.RefType == ReqRefType::PmfFormulaLine && issueBom.BOMType != BOMType::Phantom)
                {
                    plannedOrder.PmfYieldPct = reqPoParent.PmfYieldPct;
                }
            }
            if (traceLoggingEnabled)
            {
                reqTraceLogger.writeLog(ReqTraceLogMessageEntry::newFromReqTrans(ReqTraceMessageType::CreatingNewPlannedOrder, [[enumNum(ReqRefType), enum2int(plannedOrder.RefType)], ReqTraceLogMessage::packInventDim(_setupDim.inventDim())], _issue));
                reqTraceLogger.writeLog(ReqTraceLogMessageDetail::newDetail(ReqTraceMessageDetailType::InitialRequirementDate, [plannedOrder.ReqDate, _issue.openQty()]));
            }

            // Calculate reqDates & SchedToDate
            plannedOrder.setReqDateFields(_setupDim,reqPlanData);

            plannedOrder.initFromSetupDim(_setupDim);

            plannedOrder.setIsDerivedDirectly(_setupDim,_issue);

            //    Special coverage
            if (_issue.IsDerivedDirectly)
            {
                if (plannedOrder.RefType == ReqRefType::ItemPlannedOrder)
                {
                    if ((_issue.RefType == ReqRefType::BOMLine ||  _issue.RefType == ReqRefType::PmfFormulaLine)
                        && _issue.bomType().isPeggedSupply())
                    {
                        plannedOrder.VendId = issueBom.VendId;

                        if (!plannedOrder.VendId)
                        {
                            reqPoParent = _issue.getReqPo(reqPlanData);
                            if (reqPoParent.ItemRouteId && _issue.OprNum)
                            {
                                // Get the vendor from the scheduled resource of the parent operation
                                select firstonly VendId from wrkCtrTableVend
                                    exists join reqRouteSchedulingView
                                    where wrkCtrTableVend.WrkCtrId              == reqRouteSchedulingView.WrkCtrId
                                       && reqRouteSchedulingView.PlanVersion    == this.reqPlanVersionRefRecId()
                                       && reqRouteSchedulingView.RefId          == reqPoParent.RefId
                                       && reqRouteSchedulingView.OprNum         == _issue.OprNum
                                       && reqRouteSchedulingView.OprPriority    == RouteOprPriority::Primary;

                                plannedOrder.VendId = wrkCtrTableVend.VendId;
                            }
                        }

                        if (plannedOrder.VendId)
                        {
                            plannedOrder.VendGroupId = setup.vendGroupId(plannedOrder.VendId);
                        }
                    }
                }

                plannedOrder.initFromSetup(setup, reqPlanData.reqTraceLogger(), reqPlanData); // we need the vendorId
            }
            else
            {
                /*
                    Coverage code
                    */

                    if (qtyMinMaxRemain)
                {
                    plannedOrder.Qty = qtyMinMaxRemain;
                }
                else
                {
                    if (! plannedOrder.Qty)
                    {
                        plannedOrder.Qty = this.covCodeQty(_setupDim,_issue);
                    }

                    if (_setupDim.covRule() == ReqCovType::MinMax)
                    {
                        qtyMinMaxRemain = plannedOrder.Qty;
                    }
                }

                if (plannedOrder.Qty <= 0)
                {
                    return null;
                }

                plannedOrder.adjustOrderQuantityPerCoverageSettings(_setupDim, reqTraceLogger);

                if (_setupDim.covRule() == ReqCovType::MinMax)
                {
                    qtyMinMaxRemain -= plannedOrder.Qty;
                }
            }

            // save the original delivery date to use for reqTRansPo
            reqDateDlvOrig = plannedOrder.ReqDateDlv;

            if (!this.initializePlannedOrder(plannedOrder, _setupDim))
            {
                return null;
            }

            // Create planned order
            plannedOrder.insert(reqPlanData);

            // Add to cache
            reqPlanData.reqTransCache().reqPoCacheInsert(plannedOrder);

            reqTransPo.clear();
            this.initializeReqTransPoFromIssue(reqTransPo, _issue);
            reqTransPo.ReqDateDlvOrig     = reqDateDlvOrig;
            reqTransPo.ReqProcessId       = processId;

            reqTransPOCreate.insertFromReqPo(reqTransPo,
                                             plannedOrder,
                                             maxChildThreads > 0,
                                             reqPlanData,_setupDim,
                                             scheduleOrdersList,
                                             reqCalcRecordCacheInventDim,
                                             reqCalcRecordCacheUnitOfMeasure,
                                             _issue);

            if (reqTransPo.RefType == ReqRefType::BOMPlannedOrder
                || plannedOrder.RefType == ReqRefType::PmfPlannedProdBatch)
            {
                reqTransCache.noteDownPlannedProdOrderId(reqTransPo.RefId);
            }

            if (!receipt)
            {
                receipt.data(reqTransPo);
            }
        }
        while (qtyMinMaxRemain > 0 && (receipt.Qty >= -_issue.openQty())); // create only planned orders that are not covering issues

        return receipt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreateCoCovPlannedOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether to create a planned order for co-product issue.
    /// </summary>
    /// <param name = "_setupDim">
    ///     An instance of <c>ReqSetupDim</c> class.
    /// </param>
    /// <param name = "_issue">
    ///     A <c>ReqTrans</c> table record for issue.
    /// </param>
    /// <returns>
    ///     true if a planned order must be created; otherwise, false.
    /// </returns>
    protected boolean mustCreateCoCovPlannedOrder(ReqSetupDim _setupDim, ReqTrans _issue)
    {
        return (_setupDim.plannedOrderTypeReq(_issue.IsDerivedDirectly) == ReqRefType::PmfPlannedProdBatch);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeReqTransPoFromIssue</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the current <c>ReqTrans</c> record from an issue <c>ReqTrans</c> record.
    /// </summary>
    /// <param name = "_reqTransPo">
    ///     A <c>ReqTrans</c> current record.
    /// </param>
    /// <param name = "_issue">
    ///      A <c>ReqTrans</c> issue record.
    /// </param>
    protected void initializeReqTransPoFromIssue(ReqTrans _reqTransPo, ReqTrans _issue)
    {
        _reqTransPo.OriginalQuantity    = -_issue.openQty();
        _reqTransPo.Level               = _issue.Level;
        _reqTransPo.IsForcedItemBomId   = _issue.ItemBomId   != '';
        _reqTransPo.IsForcedItemRouteId = _issue.ItemRouteId != '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCoverageForPlanningAndCoProduct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates coverage for planning and co-product.
    /// </summary>
    /// <param name = "_setup"> A <c>ReqSetup</c> object which holds master planning setting for a specific item.</param>
    /// <param name = "_issue">The net requirements table record with a negative unsettled quantity.</param>
    /// <returns>true if coverage is valid for planning and co-product; otherwise, false.</returns>
    protected boolean validateCoverageForPlanningAndCoProduct(ReqSetup _setup, ReqTrans _issue)
    {
        return #PmfEnabled
            && _setup.inventTable().PmfProductType == PmfProductType::Co_Product
            && _setup.inventTable().PmfPlanningItemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isMinInventOnHandSet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the minimum onhand is other than zero
    /// </summary>
    /// <param name = "_setupDim">
    /// A <c>ReqSetupDim</c> record buffer.
    /// </param>
    /// <returns>
    /// true if the minimum onhand is other than zero; otherwise, false.
    /// </returns>
    protected boolean isMinInventOnHandSet(ReqSetupDim _setupDim)
    {
        return _setupDim.isMinInventOnHandSet();
    }

]]></Source>
			</Method>
			<Method>
				<Name>covCreateSafetyInvent</Name>
				<Source><![CDATA[
    protected void covCreateSafetyInvent(ReqSetupDim _setupDim)
    {
        if (!this.isMinInventOnHandSet(_setupDim))
        {
            return;
        }

        boolean doCreate = this.mustCreateSafetyStockDuringCoverage(_setupDim);

        using (ReqPoPreventDeletionContext context = this.createReqPoPreventDeletionContext())
        {
            switch (true)
            {
                case reqCalcUpdate != ReqCalcUpdate::Regeneration:

                    ttsbegin;

                    // Processing issue and receipt safety stock separately in order to avoid updating conflict error on receipt
                    // updating, because receipt safety stock may be updated when deleting explosion coverage from issue safety stock
                    List listReqTransSafety = this.deleteSafetyStockNotRegeneration(InventDirection::Issue, doCreate, _setupDim);
                    listReqTransSafety.appendList(this.deleteSafetyStockNotRegeneration(InventDirection::Receipt, doCreate, _setupDim));

                    ListEnumerator leReqTransSafety = listReqTransSafety.getEnumerator();

                    while (leReqTransSafety.moveNext())
                    {
                        ReqTrans reqTransCopy = leReqTransSafety.current();
                        reqTransCopy.insert(reqPlanData);
                    }

                    ttscommit;

                    break;

                case reqCalcUpdate == ReqCalcUpdate::Regeneration && doCreate:
                    ReqTrans reqTransSafety;
                    while select forupdate reqTransSafety
                        where reqTransSafety.PlanVersion             == this.reqPlanVersionRefRecId()    &&
                              reqTransSafety.RefType                 == ReqRefType::SafetyInvent         &&
                              reqTransSafety.RefId                   == ''                               &&
                              reqTransSafety.InventTransOrigin       == 0                                &&
                              reqTransSafety.ItemId                  == _setupDim.setup().itemId()       &&
                              reqTransSafety.CovInventDimId          == _setupDim.parmCovInventDimId()
                    {
                        reqTransSafety.delete(reqPlanData);
                    }

                    break;
            }
        }

        if (doCreate)
        {
            this.createSafetyInvent(_setupDim, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteSafetyStockNotRegeneration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deleting safety stock and using a list to store the records which will be used to create again.
    /// </summary>
    /// <param name="_inventDirection">
    /// An <c>InventDirection</c> type represents quantity direction, receipt or issue.
    /// </param>
    /// <param name="_doCreateSafetyStock">
    /// A boolean value represents whether to create safety stock or not during coverage.
    /// </param>
    /// <param name="_setupDim">
    /// The dimension-based planned order requirement setup.
    /// </param>
    /// <returns>
    /// A list contains safety stock which needs to be regenerated.
    /// </returns>
    private List deleteSafetyStockNotRegeneration(
                InventDirection _inventDirection,
                boolean         _doCreateSafetyStock,
                ReqSetupDim     _setupDim)
    {
        List listReqTransSafety = new List(Types::Record);
        ReqTrans reqTransSafety;

        while select forupdate reqTransSafety
                    index hint RefIdx
                    where reqTransSafety.PlanVersion            == this.reqPlanVersionRefRecId()    &&
                          reqTransSafety.RefType                == ReqRefType::SafetyInvent         &&
                          reqTransSafety.RefId                  == ''                               &&
                          reqTransSafety.InventTransOrigin      == 0                                &&
                          reqTransSafety.ItemId                 == _setupDim.setup().itemId()       &&
                          reqTransSafety.CovInventDimId         == _setupDim.parmCovInventDimId()	&&
                          reqTransSafety.Direction              == _inventDirection
        {
            if (!_doCreateSafetyStock)
            {
                ReqTrans reqTransCopy;
                reqTransCopy.data(reqTransSafety);  // Coverage to safety stock is removed by deleting the record and create it again (necessary because the coverage is done in recId order)
                reqTransCopy.CovQty = 0;
                listReqTransSafety.addEnd(reqTransCopy);
            }

            reqTransSafety.deleteExplosionCoverage(reqPlanData);
            reqTransSafety.delete(reqPlanData);
        }

        return listReqTransSafety;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReqPoPreventDeletionContext</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a context in order to prevent deletion for given planned order.
    /// </summary>
    /// <returns>An instance of context.</returns>
    internal ReqPoPreventDeletionContext createReqPoPreventDeletionContext()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>covFinalizeLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finalizes the coverage phase for one level.
    /// </summary>
    /// <param name="_level">
    /// The BOM level.
    /// </param>
    protected void covFinalizeLevel(BOMLevel _level)
    {
        BOMLevel rerunFromLevel;

        try
        {
            ttsbegin;

            reqTransCache.createReqProcessTransFilterRecords();

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            if (this.manageExceptionDeadLock())
            {
                retry;
            }
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (this.retryTransientSqlConnectionError())
            {
                retry;
            }
            else
            {
                throw;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if ( this.manageExceptionUpdateConflict() )
            {
                retry;
            }
        }

        rerunFromLevel = (#PmfEnabled ? reqTransCache.getRerunFromLevel() : -1);
        if (rerunFromLevel != -1)
        {
            if (isReqCalcFinalizeLevelRerunBundlesSameTransFlightEnabled)
            {
                try
                {
                    reqCalcTaskController.initTaskAndBundle(ReqProcessStatus::Coverage, rerunFromLevel, ReqLevelState::InitLevel);
                    reqCalcTaskController.initTaskAndBundle(ReqProcessStatus::Coverage, rerunFromLevel, ReqLevelState::FinalizeLevel);

                    reqCalcTaskController.saveTaskAndBundleList();
                }
                catch (Exception::TransientSqlConnectionError)
                {
                    if (this.retryTransientSqlConnectionError())
                    {
                        reqCalcTaskController.clearTaskAndBundleList();
                        retry;
                    }
                    else
                    {
                        throw;
                    }
                }
            }
            else
            {
                reqCalcTaskController.insertTaskAndBundle(ReqProcessStatus::Coverage, rerunFromLevel, ReqLevelState::InitLevel);
                reqCalcTaskController.insertTaskAndBundle(ReqProcessStatus::Coverage, rerunFromLevel, ReqLevelState::FinalizeLevel);
            }

            reqTransCache.setRerunFromLevel(-1);
        }
        else
        {
            reqTransCache.setCurrentLevel(_level);
            if (reqTransCache.moveNextLevel())
            {
                reqCalcTaskController.insertTaskAndBundle(ReqProcessStatus::Coverage, reqTransCache.getCurrentLevel(), ReqLevelState::InitLevel);
                reqCalcTaskController.insertTaskAndBundle(ReqProcessStatus::Coverage, reqTransCache.getCurrentLevel(), ReqLevelState::FinalizeLevel);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>covFindIssueQtyDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total quantity of other open issues on the same date.
    /// </summary>
    /// <param name = "_setupDim">Master planning parameters for a specific combination of item and coverage dimension values.</param>
    /// <param name = "_issue">The issue that is being covered with a new planned order.</param>
    /// <returns>Total quantity of other open issues on the same date.</returns>
    /// <remarks>The quantity returned from this method can be added to the new planned order quantity to avoid creation of multiple orders.</remarks>
    protected InventQty covFindIssueQtyDate(ReqSetupDim _setupDim, ReqTrans _issue)
    {
        boolean bomReq = _setupDim.bomVersionReq();
        boolean routeReq = _setupDim.routeVersionReq();

        ReqTrans reqTrans;
        select sum(Qty), sum(CovQty) from reqTrans
            where reqTrans.PlanVersion == _issue.PlanVersion
                && reqTrans.ItemId == _setupDim.itemId()
                && reqTrans.CovInventDimId == _setupDim.parmCovInventDimId()
                && reqTrans.Direction == InventDirection::Issue
                && reqTrans.OpenStatus == ReqOpenStatus::Neg
                && ((reqTrans.ReqDate == _issue.ReqDate && _issue.ReqDate > reqPlanData.todaysdate())
                    || (reqTrans.ReqDate <= reqPlanData.todaysdate() && _issue.ReqDate <= reqPlanData.todaysdate()))
                && (!bomReq || reqTrans.ItemBomId == _issue.ItemBomId)
                && (!routeReq || reqTrans.ItemRouteId == _issue.ItemRouteId)
                && reqTrans.MarkingRefInventTransOrigin == 0
                && !reqTrans.IsDerivedDirectly
                && reqTrans.RecId != _issue.RecId;

        return reqTrans.openQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>covFindOpenReceiptQtyForMinMax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total quantity of open receipts that must be taken into account when calculating min/max replenishment quantity.
    /// </summary>
    /// <param name = "_setupDim">Master planning parameters for a specific combination of item and coverage dimension values.</param>
    /// <param name = "_issue">The issue that triggered min/max replenishment.</param>
    /// <returns>Total quantity of other open issues on the same date.</returns>
    protected InventQty covFindOpenReceiptQtyForMinMax(ReqSetupDim _setupDim, ReqTrans _issue)
    {
        ReqTrans reqTrans;

        select sum(Qty), sum(CovQty) from reqTrans
            where reqTrans.PlanVersion == this.reqPlanVersionRefRecId()
                && reqTrans.ItemId == _setupDim.itemId()
                && reqTrans.CovInventDimId == _setupDim.parmCovInventDimId()
                && reqTrans.Direction == InventDirection::Receipt
                && reqTrans.OpenStatus == ReqOpenStatus::Pos
                && reqTrans.ReqDate <= _issue.ReqDate
                && (!reqTrans.PdsExpiryDate || reqTrans.PdsExpiryDate >= _issue.ReqDate);

        return reqTrans.openQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>covFindIssueQtyPeriod</Name>
				<Source><![CDATA[
    protected InventQty covFindIssueQtyPeriod(
        ReqSetupDim _setupDim,
        ReqTrans    _issue,
        ReqDate     _fromDate,
        ReqDate     _toDate
        )
    {
        ReqTrans        reqTrans;

        InventQty       qty;

        boolean         bomReq;
        boolean         routeReq;

        bomReq   = _setupDim.bomVersionReq();
        routeReq = _setupDim.routeVersionReq();

        SysDaQueryObject qeReqTrans = new SysDaQueryObject(reqTrans);

        qeReqTrans.projection()
            .addSum(fieldStr(ReqTrans, Qty))
            .addSum(fieldStr(ReqTrans, CovQty));

        qeReqTrans.whereClause(this.buildCovFindIssueQtyPeriodWhereClause(reqTrans, _issue, bomReq, routeReq, _fromDate, _toDate));

        SysDaFindObject findObject = new SysDaFindObject(qeReqTrans);
        new SysDaFindStatement().execute(findObject);

        qty = reqTrans.openQty();

        return qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCovFindIssueQtyPeriodWhereClause</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Builds the where clause to sum up the quantity of issue records.
    /// </summary>
    /// <param name = "_reqTrans">
    ///      A <c>ReqTrans</c> record.
    /// </param>
    /// <param name = "_issue">
    ///     A <c>ReqTrans</c> record.
    /// </param>
    /// <param name = "_bomReq">
    ///     A boolean value which indicates bom requirements.
    /// </param>
    /// <param name = "_routeReq">
    ///     A boolean value which indicates route requirements.
    /// </param>
    /// <param name = "_fromDate">
    ///     From requirement date.
    /// </param>
    /// <param name = "_toDate">
    ///     To requirement date.
    /// </param>
    /// <returns>
    ///     An instance of <c>SysDaQueryExpression</c>.
    /// </returns>
    protected SysDaQueryExpression buildCovFindIssueQtyPeriodWhereClause(
        ReqTrans    _reqTrans,
        ReqTrans    _issue,
        boolean     _bomReq,
        boolean     _routeReq,
        ReqDate     _fromDate,
        ReqDate     _toDate)
    {
        SysDaQueryExpression whereClause;
        
        whereClause = new SysDaEqualsExpression(new SysDaFieldExpression(_reqTrans, fieldStr(ReqTrans, PlanVersion)), new SysDaFieldExpression(_issue, fieldStr(ReqTrans, PlanVersion)))
                        .and(new SysDaEqualsExpression(
                            new SysDaFieldExpression(_reqTrans, fieldStr(ReqTrans, ItemId)),
                            new SysDaFieldExpression(_issue, fieldStr(ReqTrans, ItemId))))
                        .and(new SysDaEqualsExpression(
                            new SysDaFieldExpression(_reqTrans, fieldStr(ReqTrans, CovInventDimId)),
                            new SysDaFieldExpression(_issue, fieldStr(ReqTrans, CovInventDimId)))
                        .and(new SysDaEqualsExpression(
                            new SysDaFieldExpression(_reqTrans, fieldStr(ReqTrans, Direction)),
                            new SysDaValueExpression(InventDirection::Issue))))
                        .and(new SysDaEqualsExpression(
                            new SysDaFieldExpression(_reqTrans, fieldStr(ReqTrans, OpenStatus)),
                            new SysDaValueExpression(ReqOpenStatus::Neg)))
                        .and(new SysDaEqualsExpression(
                            new SysDaFieldExpression(_reqTrans, fieldStr(ReqTrans, IsDerivedDirectly)),
                            new SysDaValueExpression(NoYes::No)))
                        .and(new SysDaGreaterThanOrEqualsExpression(
                            new SysDaFieldExpression(_reqTrans, fieldStr(ReqTrans, ReqDate)),
                            new SysDaValueExpression(_fromDate)))
                        .and(new SysDaLessThanOrEqualsExpression(
                            new SysDaFieldExpression(_reqTrans, fieldStr(ReqTrans, ReqDate)),
                            new SysDaValueExpression(_toDate)))
                        .and(new SysDaEqualsExpression(
                            new SysDaFieldExpression(_reqTrans, fieldStr(ReqTrans, ItemBomId)),
                            new SysDaFieldExpression(_issue, fieldStr(ReqTrans, ItemBomId)))
                            .or(new SysDaValueExpression(!_bomReq)))
                        .and(new SysDaEqualsExpression(
                            new SysDaFieldExpression(_reqTrans, fieldStr(ReqTrans, ItemRouteId)),
                            new SysDaFieldExpression(_issue, fieldStr(ReqTrans, ItemRouteId)))
                            .or(new SysDaValueExpression(!_routeReq)))
                        .and(new SysDaEqualsExpression(
                            new SysDaFieldExpression(_reqTrans, fieldStr(ReqTrans, MarkingRefInventTransOrigin)),
                            new SysDaValueExpression(0)));

        return whereClause;
    }

]]></Source>
			</Method>
			<Method>
				<Name>covFindOnhand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find on hand available for covering a specified requirement transaction.
    /// </summary>
    /// <param name="_setupDim">
    /// A <c>ReqSetupDim</c> object that defines the item and coverage dimension.
    /// </param>
    /// <param name="_reqTrans">
    /// The requirement transaction to cover with on hand.
    /// </param>
    /// <returns>
    /// A requirement transaction with on hand supply that covers the demand passed as parameter.
    /// </returns>
    protected ReqTrans covFindOnhand(
        ReqSetupDim     _setupDim,
        ReqTrans        _reqTrans
        )
    {
        ReqTrans        inventOnHand;

        if (_reqTrans.ItemBomId         &&
            _setupDim.bomVersionReq()   &&
            !BOMVersion::selectBomVersion(_reqTrans.ItemId,
                                          _reqTrans.ReqDate,
                                          abs(_reqTrans.Qty),
                                          _setupDim.inventDim(),
                                          true,
                                          true,
                                          true,
                                          false,
                                          true,
                                          _reqTrans.ItemBomId))
        {
            return null;
        }

        if (_reqTrans.ItemRouteId       &&
            _setupDim.routeVersionReq() &&
            !RouteVersion::selectRouteVersion(_reqTrans.ItemId,
                                              _reqTrans.ReqDate,
                                              abs(_reqTrans.Qty),
                                              _setupDim.inventDim(),
                                              true,
                                              true,
                                              true,
                                              false,
                                              true,
                                              _reqTrans.ItemRouteId))
        {
            return null;
        }
        
        if(reqCalcConvertSqlStatementsToSysDaFlightEnabled)
        {
            SysDaQueryObject inventOnHandQueryObject = ReqCalcSysDaSqlStatementGenerator::inventOnHandQueryObject(
                inventOnHand,
                _reqTrans, 
                _setupDim, 
                reqPlanData, 
                this.isExpiryDateIgnored(_setupDim, _reqTrans));

            SysDaFindStatement findStatement = new SysDaFindStatement();
            findStatement.find(new SysDaFindObject(inventOnHandQueryObject));

            return inventOnHand;
        }

        boolean ignoreExpiryDate;
        if (this.isExpiryDateIgnored(_setupDim , _reqTrans))
        {
            ignoreExpiryDate =true;
        }

        select firstonly forupdate inventOnHand
            order by
                PdsExpiryDate,
                ReqDate
            where inventOnHand.PlanVersion                  == _reqTrans.PlanVersion            &&
                  inventOnHand.RefType                      == ReqRefType::InventOnHand         &&
                  inventOnHand.RefId                        == ''                               &&
                  inventOnHand.InventTransOrigin            == 0                                &&
                  inventOnHand.ItemId                       == _reqTrans.ItemId                 &&
                  inventOnHand.CovInventDimId               == _reqTrans.CovInventDimId         &&
                  inventOnHand.OpenStatus                   == ReqOpenStatus::Pos               &&
                  inventOnHand.Direction                    == InventDirection::Receipt         &&
                  (ignoreExpiryDate ||
                    !inventOnHand.PdsExpiryDate || inventOnHand.PdsExpiryDate >= max(_reqTrans.pdsNeedByDate(), reqPlanData.todaysdate()));

        return inventOnHand;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isExpiryDateIgnored</Name>
				<Source><![CDATA[
    ///<summary>
    /// Checks if expiry date should be ignored.
    ///</summary>
    /// <param name="_setupDim">
    /// A <c>ReqSetupDim</c> object that defines the item and coverage dimension.
    /// </param>
    /// <param name="_reqTrans">
    /// The requirement transaction for which to check the expiry date.
    /// </param>
    /// <returns>
    /// true if expiry date should be ignored; otherwise, false.
    /// </returns>
    protected boolean isExpiryDateIgnored(ReqSetupDim _setupDim, ReqTrans _reqTrans)
    {
        return this.coverageEngine(_setupDim).mustConsiderShelfLife() && _reqTrans.InventTransOrigin && _reqTrans.RefType == ReqRefType::InventJournal
               &&  _reqTrans.inventTable().isShelfLifeItem() && InventTransOrigin::find(_reqTrans.InventTransOrigin).ReferenceCategory == InventTransType::Blocking;
    }

]]></Source>
			</Method>
			<Method>
				<Name>covCanReusePreviousReceiptBreakFEFO</Name>
				<Source><![CDATA[
    private boolean covCanReusePreviousReceiptBreakFEFO(
        ReqSetupDim _setupDim,
        ReqTrans    _issue)
    {
        return this.coverageEngine(_setupDim).mustConsiderShelfLife()
            && firstIssueCoveredByPreviousReceipt.pdsNeedByDate() > _issue.pdsNeedByDate(); // otherwise, if the current receipt has shorter sellable days then we may be able to supply it with a batch that expires earlier (FEFO principle)
    }

]]></Source>
			</Method>
			<Method>
				<Name>covFindReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds a record in the <c>ReqTrans</c> table with a positive free quantity in order to fulfill the
    ///    issue that is meant for it.
    /// </summary>
    /// <param name="_setupDim">
    ///    A <c>reqSetupDim</c> object that holds the master planning settings for a specific item and
    ///    coverage dimensions.
    /// </param>
    /// <param name="_issue">
    ///    An unsettled issue record in the <c>ReqTrans</c> table.
    /// </param>
    /// <param name="_searchMarkingInventTransOrigin">
    ///    A Boolean value that indicates whether marking should be respected.
    /// </param>
    /// <returns>
    ///    A record in the <c>ReqTrans</c> table which can be used to fulfill the issue record from the
    ///    <c>ReqTrans</c> table.
    /// </returns>
    /// <remarks>
    ///    If the <paramref name="_searchMarkingInventTransOrigin" /> is true than if the issue record in the
    ///    <c>ReqTrans</c> table is marked then only the corresponding marked receipt can qualify.
    /// </remarks>
    protected ReqTrans covFindReceipt(
        ReqSetupDim _setupDim,
        ReqTrans    _issue,
        boolean     _searchMarkingInventTransOrigin)
    {
        coverageEngine = this.coverageEngine(_setupDim);

        ReqCalcCoverageReceiptConstraints receiptConstraints = coverageEngine.defineReceiptConstraintsForIssue(_issue, _searchMarkingInventTransOrigin);
        receiptConstraints.CanUseOnHand = reqPlanData.onHandConsumption(_setupDim) == ReqOnHandConsumptionStrategy::BeforeAllOtherSupply;
        receiptConstraints.MustUseLatestPossibleSupplyFirst = reqPlanData.mustUseLatestPossibleSupplyFirst(_setupDim);

        this.covFindReceiptStartedWriteTraceLog(_setupDim, _issue, receiptConstraints);

        ReqTrans receiptPeriod = this.findReceiptPeriod(_setupDim, _issue, receiptConstraints.MustUseReceiptsWithCalculatedDelays);

        // The following two conditions are added for the case where a bom id/route id is specified on an issue being covered by the receipt at hand, it should not
        // try to also cover an issue with no bom id/route id specified on it.
        if (receiptPeriod && _setupDim.bomVersionReq() && !_issue.ItemBomId && receiptPeriod.IsForcedItemBomId)
        {
            return null;
        }

        if (receiptPeriod && _setupDim.routeVersionReq() && !_issue.ItemRouteId && receiptPeriod.IsForcedItemRouteId)
        {
            return null;
        }

        if (!isPreviousReceiptOnHand || receiptConstraints.CanUseOnHand)
        {
            if (receiptPeriod.RecId
                && (_issue.RefType != ReqRefType::RequisitionLine || receiptPeriod.RefType != ReqRefType::InventOnHand))
            {
                return receiptPeriod;
            }

            if (this.canPreviousReceiptBeReused(_setupDim, _issue, receiptConstraints))
            {
                return previousReceipt;
            }
        }

        ReqTrans receipt = coverageEngine.findFirstValidReceiptForIssue(_issue, receiptConstraints);

        if (receipt.RefType == ReqRefType::PmfCoProduct)
        {
            if (receipt.PmfCoByRefRecId)
            {
                PmfFormulaCoBy formulaCoBy = PmfFormulaCoBy::findRecId(receipt.PmfCoByRefRecId);
                if (formulaCoBy && formulaCoBy.ProductType == PmfProductType::By_Product)
                {
                    return null;
                }
            }
            else if (receipt.InventTransOrigin)
            {
                PmfProdCoBy prodCoBy = InventTransOriginPmfProdCoBy::prodCoBy(receipt.InventTransOrigin);
                if (prodCoBy && prodCoBy.ProductType == PmfProductType::By_Product)
                {
                    return null;
                }
            }
        }

        // On hand receipt should be searched in low priority
        if (this.covShouldSearchOnHandAfterOtherSupply(_setupDim, receipt))
        {
            receiptConstraints.CanUseOnHand = true;
            receipt = coverageEngine.findFirstValidOnHandForIssue(_issue, receiptConstraints);
        }

        return receipt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPreviousReceiptBeReused</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether previous receipt record can be reused.
    /// </summary>
    /// <param name = "_setupDim">
    ///     An instance of <c>ReqSetupDim</c> class.
    /// </param>
    /// <param name = "_issue">
    ///     A <c>ReqTrans</c> table record.
    /// </param>
    /// <param name = "_receiptConstraints">
    ///     An instance of <c>ReqCalcCoverageReceiptConstraints</c> class.
    /// </param>
    /// <returns>
    ///     true if previous receipt record can be reused; otherwise, false.
    /// </returns>
    protected boolean canPreviousReceiptBeReused(
        ReqSetupDim                       _setupDim,
        ReqTrans                          _issue,
        ReqCalcCoverageReceiptConstraints _receiptConstraints)
    {
        return (previousReceipt.openQty()
                && !this.covCanReusePreviousReceiptBreakFEFO(_setupDim, _issue)
                && coverageEngine.isReceiptValidForIssue(previousReceipt, _issue, _receiptConstraints));
    }

]]></Source>
			</Method>
			<Method>
				<Name>covShouldSearchOnHandAfterOtherSupply</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether to find the first valid on-hand receipt record for issue after other supply.
    /// </summary>
    /// <param name = "_setupDim">
    ///     An instance of <c>ReqSetupDim</c> class.
    /// </param>
    /// <param name = "_receipt">
    ///     A <c>ReqTrans</c> table record.
    /// </param>
    /// <returns>
    ///     true if the first valid on-hand receipt record for issue can be found; otherwise, false.
    /// </returns>
    protected boolean covShouldSearchOnHandAfterOtherSupply(
        ReqSetupDim _setupDim,
        ReqTrans    _receipt)
    {
        return (!_receipt.RecId
                && reqPlanData.onHandConsumption(_setupDim) == ReqOnHandConsumptionStrategy::AfterAllOtherSupply);
    }

]]></Source>
			</Method>
			<Method>
				<Name>covFindReceiptStartedWriteTraceLog</Name>
				<Source><![CDATA[
    private void covFindReceiptStartedWriteTraceLog(
        ReqSetupDim                         _setupDim,
        ReqTrans                            _issue,
        ReqCalcCoverageReceiptConstraints   _receiptConstraints)
    {
        if (traceLoggingEnabled)
        {
            reqTraceLogger.writeLog(ReqTraceLogMessageEntry::newFromReqTrans(ReqTraceMessageType::FindOpenReceipt,
                [ReqTraceLogMessage::packInventDim(_setupDim.inventDim()), _receiptConstraints.MinReqDate, _receiptConstraints.MaxReqDate, _issue.ReqTime], _issue));

            if (_receiptConstraints.MustUseReceiptsWithIssueBOM)
            {
                reqTraceLogger.writeLog(ReqTraceLogMessageDetail::newDetail(ReqTraceMessageDetailType::CriteriaBOM, [_issue.ItemBomId]));
            }

            if (_receiptConstraints.MustUseReceiptsWithIssueRoute)
            {
                reqTraceLogger.writeLog(ReqTraceLogMessageDetail::newDetail(ReqTraceMessageDetailType::CriteriaRoute, [_issue.ItemRouteId]));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>covForecastAggregate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Aggregates forecast.
    /// </summary>
    /// <param name="_setupDim">
    /// A <c>ReqSetupDim</c> object that contains coverage settings for a specific item ID and inventory dimensions.
    /// </param>
    protected void covForecastAggregate(ReqSetupDim  _setupDim)
    {
        ReqForecastAggregate reqForecastAggregate;

        if (reqPlanData.useForecastDemand())
        {
            reqForecastAggregate = ReqForecastAggregate::construct();
            reqForecastAggregate.aggregateDemandForecast(reqPlanData, _setupDim);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>covForecastReduce</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calls forecast reduction logic if supply or demand forecast should be reduced.
    /// </summary>
    /// <param name="_setupDim">
    ///    A <c>ReqSetupDim</c> object that holds master planning settings for a specific item and coverage
    ///    dimension.
    /// </param>
    /// <remarks>
    ///    The reduction of sales forecast applies only in the dynamic plan and if the master scheduling
    ///    principle are net change or net change minimized.
    /// </remarks>
    protected void covForecastReduce(ReqSetupDim  _setupDim)
    {
        if (!this.shouldReduceForecast(_setupDim))
        {
            return;
        }

        if (! reqForecastReduce)
        {
            // create global object for caching reduction data
            reqForecastReduce = ReqForecastReduce::newStandard(reqPlanData.reqReduceType(),reqPlanData.todaysdate());
        }

        this.covForecastReduceDemand(_setupDim);
        this.covForecastReduceSupply(_setupDim);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldReduceForecast</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if forecast reduction logic should be ran.
    /// </summary>
    /// <param name="_setupDim">
    /// A <c>ReqSetupDim</c> object that holds master planning settings for a specific item and coverage
    /// dimension.
    /// </param>
    /// <returns>True if the forecast should be reduced; otherwise, false.</returns>
    protected boolean shouldReduceForecast(ReqSetupDim _setupDim)
    {
        if (reqPlanData.timeFenceForecast(_setupDim) <= 0
            || reqPlanData.reqReduceType() == ReqReduceType::None)
        {
            return false;
        }

        if (!_setupDim.reqReduceKeyId()
            && (reqPlanData.reqReduceType() == ReqReduceType::OpenOrdersReductionKey || reqPlanData.reqReduceType() == ReqReduceType::Percent))
        {
            return false;
        }

        if (reqPlanData.reqReduceType() == ReqReduceType::Percent
            && reqCalcUpdate != ReqCalcUpdate::Regeneration)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>covForecastReduceDemand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reduces demand forecast.
    /// </summary>
    /// <param name="_setupDim">
    /// A <c>ReqSetupDim</c> object that contains coverage settings for a specific item ID and inventory dimensions.
    /// </param>
    [SuppressBpWarning("BPErrorMethodDeleteFromNotUsed", "The fix will require costly update operation on each forecast record, before its deletion.")]
    protected void covForecastReduceDemand(ReqSetupDim  _setupDim)
    {
        ReqTrans forecast;
        ItemId itemId = _setupDim.setup().itemId();
        InventDimId inventDimId = _setupDim.inventDim().InventDimId;
        boolean isAddItem2CacheInitialized = false;

        void addItemToCache()
        {
            // Adding all item transactions to cache would increase the risk of update conflicts in multi-user scenarios.
            if (!isAddItem2CacheInitialized && !multiUserConcurrencyAllowed)
            {
                isAddItem2CacheInitialized = true;
                this.addItem2ReqTransCache(itemId,false);
            }
        }

        reqForecastReduce.reset(_setupDim.reqReduceKeyId());

        // reduce forecast
        var searchObject = new SysDaSearchObject(this.demandForecastToReduceQueryObject(forecast, itemId, inventDimId));
        var searchStatement = new SysDaSearchStatement();

        while (searchStatement.findNext(searchObject))
        {
            addItemToCache();
            this.reduceForecastDemand(forecast, _setupDim);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>demandForecastToReduceQueryObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a query on <c>ReqTrans</c> in order to retrieve demand forecast requirements to reduce.
    /// </summary>
    /// <param name = "_forecast">A demand forecast requirement record.</param>
    /// <param name = "_itemId">An item Id.</param>
    /// <param name = "_inventDimId">An inventory dimension Id.</param>
    /// <returns>The created SysDA query object.</returns>
    protected SysDaQueryObject demandForecastToReduceQueryObject(ReqTrans _forecast, ItemId _itemId, InventDimId _inventDimId)
    {
        return ReqCalcSysDaSqlStatementGenerator::demandForecastToReduceQueryObject(_forecast, _itemId, _inventDimId, this.reqPlanVersionRefRecId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>reduceForecastDemand</Name>
				<Source><![CDATA[
    private void reduceForecastDemand(ReqTrans _forecast, ReqSetupDim  _setupDim)
    {
        _forecast.Qty = reqForecastReduce.calcForecastQty(ForecastTableType::Demand, reqPlanData.reqTransCache(), _forecast, _setupDim);

        if (_forecast.Qty)
        {
            _forecast.updateReduceCovQty(reqPlanData);
            _forecast.update(reqPlanData);
        }
        else
        {
            // delete the planned order if the qty is zero
            _forecast.delete();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>covForecastReduceSupply</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reduces supply forecast.
    /// </summary>
    /// <param name="_setupDim">
    /// A <c>ReqSetupDim</c> object that contains coverage settings for a specific item ID and inventory dimensions.
    /// </param>
    [SuppressBpWarning("BPErrorMethodDeleteFromNotUsed", "The fix will require costly update operation on each forecast record, before its deletion.")]
    protected void covForecastReduceSupply(ReqSetupDim  _setupDim)
    {
        ReqPO forecast;
        ReqTrans reqTrans;

        reqForecastReduce.reset(_setupDim.reqReduceKeyId());

        if(reqCalcConvertSqlStatementsToSysDaFlightEnabled)
        {
            SysDaQueryObject forecastQueryObject = ReqCalcSysDaSqlStatementGenerator::forecastReduceSupplyQuery(
                forecast,
                reqTrans,
                _setupDim, 
                reqPlanData,
                this.reqPlanVersionRefRecId());
            
            var searchObject  = new SysDaSearchObject(forecastQueryObject);
            var searchStatement = new SysDaSearchStatement();

            while (searchStatement.findNext(searchObject))
            {
                this.covForecastReduceSupply_updateForecast(forecast, reqTrans, _setupDim.itemId(), _setupDim);
            }

            return;
        }

        ItemId  itemId = _setupDim.itemId();
        InventdimId covInventDimId = _setupDim.inventDim().InventDimId;

        while select forupdate forceselectorder forcenestedloop forecast
            order by ReqDate // forecast must be reduced in ascending order
        where forecast.PlanVersion == this.reqPlanVersionRefRecId()
               && forecast.ItemId == itemId
               && forecast.CovInventDimId == covInventDimId
               && forecast.IsForecastPurch
            join reqTrans
                where reqTrans.PlanVersion == forecast.PlanVersion
                   && reqTrans.RefType == forecast.RefType
                   && reqTrans.RefId == forecast.RefId
                   && reqTrans.ItemId == itemId
                   && reqTrans.CovInventDimId == covInventDimId
                   && reqTrans.IsForecastPurch
        {
            this.covForecastReduceSupply_updateForecast(forecast, reqTrans, itemId, _setupDim);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>covForecastReduceSupply_updateForecast</Name>
				<Source><![CDATA[
    private void covForecastReduceSupply_updateForecast(ReqPO forecast, ReqTrans reqTrans, ItemId itemId, ReqSetupDim _setupDim)
    {
        boolean  isAddItem2CacheInitialized = false;
        if (!isAddItem2CacheInitialized && !multiUserConcurrencyAllowed)
        {
            isAddItem2CacheInitialized = true;
            this.addItem2ReqTransCache(itemId, false);
        }

        var forecastQtyChange = reqForecastReduce.calcForecastQty(ForecastTableType::Supply, reqPlanData.reqTransCache(), reqTrans, _setupDim);
           
        if (forecastQtyChange > forecast.orig().Qty)
        {
            // ensure the cursor has actual data if recursive explosion updated the same row => avoiding OCC update conflict
            forecast.reread();
            reqTrans.reread();
        }

        if (forecastQtyChange)
        {
            forecast.Qty = forecastQtyChange;
            forecast.update(reqPlanData, reqTrans);
        }
        else
        {
            // delete the planned order if the qty is zero
            forecast.delete();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>covForecastValidateAggregation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates aggregated forecasts' quantities and emits warnings when
    /// the sum of forecasts' quantities is bigger than the quantity of more general forecast.
    /// </summary>
    /// <param name="_setupDim">
    /// A <c>ReqSetupDim</c> object that contains coverage settings for a specific item ID and inventory dimensions.
    /// </param>
    protected void covForecastValidateAggregation(ReqSetupDim  _setupDim)
    {
        ReqForecastAggregate reqForecastAggregate;

        if (reqPlanData.useForecastDemand())
        {
            reqForecastAggregate = ReqForecastAggregate::construct();
            reqForecastAggregate.aggregateDemandForecast(reqPlanData, _setupDim, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>covInitLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts coverage computation tasks for one level.
    /// </summary>
    /// <param name="_level">
    /// The BOM level.
    /// </param>
    protected void covInitLevel(BOMLevel _level)
    {
        this.deleteUnscheduledOrders();

        if (wrkCtrScheduler)
        {
            wrkCtrScheduler.initCache();
        }

        int infologLineTry = infologLine();
        try
        {
            // make sure all items are in the database
            reqTransCache.updateReqProcessItems(_level);

            if (#PmfEnabled)
            {
                // There can be left-over task group information for the level in case the level is being re-calculated so clean it up
                PmfCoReqTransItem::cleanUp(processId, _level);
                reqCalcTaskController.resetTaskGroupIds();
            }
        }
        catch (Exception::Deadlock)
        {
            if ( this.manageExceptionDeadLockRestoreReqCalc() )
            {
                retry;
            }
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (this.retryTransientSqlConnectionErrorRestoreReqCalc())
            {
                retry;
            }
            else
            {
                throw;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if ( this.manageExceptionUpdateConflictRestoreReqCalc() )
            {
                retry;
            }
        }
        catch (Exception::Error)
        {
            if (this.retryExceptionErrorRestoreReqCalc(infologLineTry))
            {
                retry;
            }

            warning("@SYS322650");
        }

        Set items = reqTransCache.getItems(_level);

        if (#PmfEnabled)
        {
            SetEnumerator se = items.getEnumerator();

            Set pmfTaskGroupIds = new Set(Types::Int64);
            Set pmfItemIds = new Set(Types::String);

            while (se.moveNext())
            {
                InventTable inventTable = InventTable::find(se.current());

                if (inventTable.PmfProductType == PmfProductType::Co_Product || inventTable.pmfHasFormulaWithCoProdOutput())
                {
                    // The item should not be inserted as a normal coverage task but instead added to a special table and inserted as a CoProduct coverage task
                    PmfCoReqTransItem pmfCoReqTransItem = reqTransCache.pmfAddPmfCoReqTransItem(inventTable, _level);
                    if (!reqCalcTaskController.pmfExistTaskGroupId(_level, pmfCoReqTransItem.TaskGroupId))
                    {
                        pmfTaskGroupIds.add(pmfCoReqTransItem.TaskGroupId);
                        pmfItemIds.add(inventTable.ItemId);
                    }
                }
            }

            if (!pmfItemIds.empty())
            {
                items = Set::difference(items, pmfItemIds);
            }

            reqCalcTaskController.insertTaskBundlesTaskGroups(pmfTaskGroupIds, this.parmMaxChildThreads(), ReqProcessStatus::Coverage, _level, ReqLevelState::CoCoverage);
        }

        reqCalcTaskController.insertTaskBundlesForItems(items, this.parmMaxChildThreads(), ReqProcessStatus::Coverage, _level, ReqLevelState::Coverage);
        
        reqCalcTaskController.insertTaskAndBundle(ReqProcessStatus::Coverage, _level, ReqLevelState::PartitionOrders);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProcessTasks</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the tasks for the complete master planning process.
    /// </summary>
    /// <remarks>
    ///    The tasks are as follows:
    ///    <list type="bullet">
    ///       <item>
    ///          <description>Pre-Update</description>
    ///       </item>
    ///       <item>
    ///          <description>Update Item List- these tasks are created by the Pre-Update task</description>
    ///       </item>
    ///       <item>
    ///          <description>Post-Update</description>
    ///       </item>
    ///       <item>
    ///          <description>Pre-Coverage</description>
    ///       </item>
    ///       <item>
    ///          <description>Coverage, Init Level - one task for each level</description>
    ///       </item>
    ///       <item>
    ///          <description>Coverage, Item List - one task for each item list</description>
    ///       </item>
    ///       <item>
    ///          <description>Coverage, Partitioning resources - one task for each level</description>
    ///       </item>
    ///       <item>
    ///          <description>Coverage, Schedule resources - one task for each order bundle</description>
    ///       </item>
    ///       <item>
    ///          <description>Coverage, Finalize Level - one task for each level</description>
    ///       </item>
    ///       <item>
    ///          <description>Pre-Futures</description>
    ///       </item>
    ///       <item>
    ///          <description>Futures, Receipts - one task for each item list</description>
    ///       </item>
    ///       <item>
    ///          <description>Futures, Partitioning resources - one task for each level</description>
    ///       </item>
    ///       <item>
    ///          <description>Futures, Schedule resources - one task for each order bundle</description>
    ///       </item>
    ///       <item>
    ///          <description>Futures, Issues - one task for each item list</description>
    ///       </item>
    ///       <item>
    ///          <description>Pre-Actions</description>
    ///       </item>
    ///       <item>
    ///          <description>Actions - one task for each item list</description>
    ///       </item>
    ///       <item>
    ///          <description>Auto-Coverage</description>
    ///       </item>
    ///       <item>
    ///          <description>Plan finalization</description>
    ///       </item>
    ///       <item>
    ///          <description>Update item level</description>
    ///       </item>
    ///       <item>
    ///          <description>Update dynamic plan</description>
    ///       </item>
    ///    </list>
    /// </remarks>
    protected void createProcessTasks()
    {
        reqCalcTaskController.clearTaskAndBundleList();

        if (recalculateBomLevels)
        {
            reqCalcTaskController.initTaskAndBundle(ReqProcessStatus::RecalculateItemLevels);
        }

        reqCalcTaskController.initTaskAndBundle(ReqProcessStatus::PreUpdate);
        reqCalcTaskController.initTaskAndBundle(ReqProcessStatus::PostUpdate);

        if (reqPlanData.doCovCalc())
        {
            reqCalcTaskController.initTaskAndBundle(ReqProcessStatus::PreCoverage);
            reqCalcTaskController.initTaskAndBundle(ReqProcessStatus::PostCoverage);
        }

        if (reqPlanData.doFuturesCalc())
        {
            reqCalcTaskController.initTaskAndBundle(ReqProcessStatus::PreFutures);
        }

        if (reqPlanData.doActionCalc())
        {
            reqCalcTaskController.initTaskAndBundle(ReqProcessStatus::PreAction);
        }

        reqCalcTaskController.initTaskAndBundle(ReqProcessStatus::AutoCoverage);

        if (reqPlanData.mustCalculateBatchExpiry())
        {
            reqCalcTaskController.initTaskAndBundle(ReqProcessStatus::PlanFinalization, 0, ReqLevelState::BatchExpiryCalculation);
        }

        reqCalcTaskController.initTaskAndBundle(ReqProcessStatus::UpdatingDynamicPlan);

        if (!this.disableAutoFirm() && reqPlanData.doAutoFirmPo())
        {
            ReqProcessAutoFirmingRun::ensureExistsForProcessId(processId);

            reqCalcTaskController.initTaskAndBundle(ReqProcessStatus::AutoFirming, 0, ReqLevelState::PartitionOrders);
            ReqTransPoAutoFirmPartitioner::initPartitionOrdersForPostProcessingTaskAndBundle(reqCalcTaskController);
            reqCalcTaskController.initTaskAndBundle(ReqProcessStatus::AutoFirming, ReqTransPoAutoFirmPartitioner::MaxBundleLevel + 1, ReqLevelState::FinishedScheduling);
        }

        reqCalcTaskController.initTaskAndBundle(ReqProcessStatus::Statistics);

        if (this.includeIntercompanyDemand())
        {
            reqCalcTaskController.initTaskAndBundle(ReqProcessStatus::InsertInterCompanyDemand);
        }

        if (this.includeRequisitions())
        {
            reqCalcTaskController.initTaskAndBundle(ReqProcessStatus::InsertRequisitionsDemand);
        }

        reqCalcTaskController.initTaskAndBundle(ReqProcessStatus::InsertNonStockedData);

        // insert tasks and bundles to DataBase
        reqCalcTaskController.saveTaskAndBundleList();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReqIntercompanyConversionUtil</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new instance of the <c>ReqIntercompanyConversionUtil</c> class.
    /// </summary>
    /// <returns>
    ///    A new instance of the <c>ReqIntercompanyConversionUtil</c> class.
    /// </returns>
    protected ReqIntercompanyConversionUtil createReqIntercompanyConversionUtil()
    {
        return ReqIntercompanyConversionUtil::construct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReqIntercompanyQueryFactory</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new instance of the <c>ReqIntercompanyQueryFactory</c> class.
    /// </summary>
    /// <returns>
    ///    A new instance of the <c>ReqIntercompanyQueryFactory</c> class.
    /// </returns>
    protected ReqIntercompanyQueryFactory createReqIntercompanyQueryFactory()
    {
        return ReqIntercompanyQueryFactory::construct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReqPlanData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Factory method for the <c>ReqPlanData</c> instance used by the current master scheduling run.
    /// </summary>
    /// <returns>
    /// A new <c>ReqPlanData</c> instance.
    /// </returns>
    protected ReqPlanData createReqPlanData()
    {
        ReqPlanData newReqPlanData = ReqPlanData::newReqCalc(this, thisIsPeriodicProcess, processId);
        
        newReqPlanData.parmMemoryCacheCurrentSessionScope(memoryCacheCurrentSessionScope);
        newReqPlanData.parmLeanLocationCache(leanLocationCache);

        return newReqPlanData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReqTransCache</Name>
				<Source><![CDATA[
    protected ReqTransCache createReqTransCache()
    {
        return reqPlanData.reqTransCache();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReqTransNeutralDelete</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates the instance of the class responsible for deleting neutral transactions.
    /// </summary>
    /// <param name="_level">
    ///     The BOM level.
    /// </param>
    /// <param name="_processId">
    ///     The process ID.
    /// </param>
    /// <param name="_reqPlanData">
    ///     The planning data.
    /// </param>
    /// <returns>
    ///     The instance of the class responsible for deleting neutral transactions.
    /// </returns>
    [SysObsolete('The neutral transaction deletion workflow has changed, use the ReqTransNeutralTracker class for neutral transaction deletion.', false, 30\06\2018)]
    protected ReqTransNeutralDelete createReqTransNeutralDelete(BOMLevel _level, ReqProcessId _processId, ReqPlanData _reqPlanData)
    {
        return ReqTransNeutralDelete::newReqCalcBOMLevel(_level, _processId, _reqPlanData);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReqTransPoMarkFirm</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an instance of the <c>ReqTransPoMarkFirm</c> class that is used for firming planned orders.
    /// </summary>
    /// <param name="_mapReqTransMark">
    ///    The requirement transactions that indicate which planned orders to firm.
    /// </param>
    /// <returns>
    ///    A new instance of the <c>ReqTransPoMarkFirm</c> class.
    /// </returns>
    protected ReqTransPoMarkFirm createReqTransPoMarkFirm(Map _mapReqTransMark)
    {
        return ReqTransPoMarkFirm::newMap(_mapReqTransMark);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreateSafetyStockDuringCoverage</Name>
				<Source><![CDATA[
    private boolean mustCreateSafetyStockDuringCoverage(ReqSetupDim _setupDim)
    {
        return _setupDim.minSatisfy() == ReqMinSatisfy::FirstIssue || this.coverageEngine(_setupDim).mustConsiderShelfLife();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreateSafetyStockDuringInsert</Name>
				<Source><![CDATA[
    private boolean mustCreateSafetyStockDuringInsert(ReqSetupDim _setupDim)
    {
        return _setupDim.minSatisfy() != ReqMinSatisfy::FirstIssue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSafetyInventBeCreated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether needs to create issue record for safety stock.
    /// </summary>
    /// <param name = "_setupDim">
    /// A <c>ReqSetupDim</c> object.
    /// </param>
    /// <returns>
    /// true if needs to create issue record for safety stock; otherwise, false.
    /// </returns>
    protected boolean mustSafetyInventBeCreated(ReqSetupDim _setupDim)
    {
        return (_setupDim.mustReqBeCreated() && _setupDim.isMinInventOnHandSet());
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSafetyInvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>ReqTrans</c> issue record for safety stock.
    /// </summary>
    /// <param name = "_setupDim">The dimension setup to create for.</param>
    /// <param name = "_fromCoverage">Determines if the method is called from the coverage phase.</param>
    /// <remarks>
    /// The method can either insert data directly into <c>ReqTrans</c> table, or it is possible for the caller to use the
    /// <c>ReqCalcCreateSafetyInventContext</c> object to define a <c>RecordInsertList</c> that the record should be added to instead.
    /// </remarks>
    protected void createSafetyInvent(
        ReqSetupDim     _setupDim,
        boolean         _fromCoverage
        )
    {
        ReqTrans        reqTrans;
        ReqDate         reqDate;

        Days            days;

        if ((_fromCoverage && !this.mustCreateSafetyStockDuringCoverage(_setupDim))
            || (!_fromCoverage && !this.mustCreateSafetyStockDuringInsert(_setupDim)))
        {
            return;
        }

        if (this.mustSafetyInventBeCreated(_setupDim))
        {
            if (ReqCalcTradeAgreementLeadTimeDecoupledCalcFlight::instance().isEnabled())
            {
                _setupDim.searchMatchingTradeAgreement(reqPlanData);
            }
            reqDate = this.safetyStockDate(_setupDim);

            if (! reqDate && _setupDim.minSatisfy() == ReqMinSatisfy::FirstIssue)
            {
                return;
            }

            reqDate = reqPlanData.workCalendarSched().schedDate(SchedDirection::Forward,reqDate,0,false,_setupDim.reqCalendarId());

            days = reqDate - (reqPlanData.todaysdate() + reqPlanData.timeFenceCoverage(_setupDim)) + 1;

            if (days > 0)
            {
                reqDate = reqPlanData.workCalendarSched().schedDate(SchedDirection::Backward,reqDate,days,false,_setupDim.reqCalendarId());
            }

            reqTrans.PlanVersion            =  this.reqPlanVersionRefRecId();
            reqTrans.ReqProcessId           = reqPlanData.parmProcessId();

            reqTrans.ItemId                = _setupDim.setup().itemId();
            reqTrans.CovInventDimId        = _setupDim.parmCovInventDimId();

            reqTrans.RefType               =  ReqRefType::SafetyInvent;

            reqTrans.Level                 = _setupDim.itemLevel();

            if (_setupDim.minSafetyKeyId())
            {
                if (_setupDim.minSafetyPeriod())
                {
                    this.createSafetyInventKey(_setupDim,reqTrans,reqDate);
                }
                else
                {
                    reqTrans.ReqDate    =  reqDate;
                    reqTrans.Qty        = - _setupDim.minInventOnhandDate(reqDate, reqPlanData.todaysdate());
                    reqTrans.insertUsingInsertList(ReqCalcCreateSafetyInventContext::recordInsertListFromCurrentContext(), reqPlanData);
                }
            }
            else
            {
                reqTrans.ReqDate    =  reqDate;
                reqTrans.Qty        = - _setupDim.minInventOnHand();
                reqTrans.insertUsingInsertList(ReqCalcCreateSafetyInventContext::recordInsertListFromCurrentContext(), reqPlanData);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateMinInventOnhandQuantityBasedOnSafetyFactor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the quantity of the minimum inventory on hand value based on the safety key factor.
    /// </summary>
    /// <param name = "_setupDim">
    /// The <c>ReqSetupDim</c> instance of the class to be used for getting the quantity.
    /// </param>
    /// <param name = "_reqTrans"> must
    /// The <c>ReqSafetyLine</c> record buffer.
    /// </param>
    /// <param name = "_reqSafetyLine">
    /// The <c>ReqSafetyLine</c> instance used for calculation the quantity, associated to the safety stock key.
    /// </param>
    /// <param name = "_qtyLast">
    /// Quantity to subtract from the calculation, for instance if some part is covered at a previous date.
    /// </param>
    /// <returns>
    /// The quantity to be used as minimum on hand quantity.
    /// </returns>
    protected Qty calculateMinInventOnhandQuantityBasedOnSafetyFactor(ReqSetupDim _setupDim, ReqTrans _reqTrans, ReqSafetyLine _reqSafetyLine, InventQty _qtyLast)
    {
        return -1 * _setupDim.calculateMinInventOnhandQuantityBasedOnSafetyFactor(_reqSafetyLine, _qtyLast);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSafetyInventKey</Name>
				<Source><![CDATA[
    protected void createSafetyInventKey(
        ReqSetupDim     _setupDim,
        ReqTrans        _reqTrans,
        TransDate       _firstDate
        )
    {
        TransDate               fromDate;
        TransDate               toDate;
        TransDate               breakEvenDate = ReqSafetyKey::find(_setupDim.minSafetyKeyId()).breakEvenDate(reqPlanData.todaysdate());

        InventQty               qtyLast;

        ReqSafetyLine           reqSafetyLine;
        ReqSafetyLine           prvSafetyLine;

        while select reqSafetyLine
            order by Sort1980
            where reqSafetyLine.SafetyKeyId == _setupDim.minSafetyKeyId()
        {
            fromDate = reqSafetyLine.fromDate(breakEvenDate,prvSafetyLine);
            toDate   = reqSafetyLine.toDate(breakEvenDate);

            if (fromDate >= reqPlanData.todaysdate() + reqPlanData.timeFenceCoverage(_setupDim))
            {
                break;
            }

            if (toDate >= _firstDate)
            {
                _reqTrans.Qty            = this.calculateMinInventOnhandQuantityBasedOnSafetyFactor(_setupDim, _reqTrans, reqSafetyLine, qtyLast);
                _reqTrans.ReqDate        = fromDate < reqPlanData.todaysdate() ? reqPlanData.todaysdate() : fromDate;
                _reqTrans.ReqDateDlvOrig = _reqTrans.ReqDate;

                if (_reqTrans.Qty)
                {
                    _reqTrans.insert(reqPlanData);
                }

                qtyLast  -= _reqTrans.Qty;
            }

            prvSafetyLine = reqSafetyLine.data();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaskController</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new instance of the <c>ReqCalcTaskController</c> class.
    /// </summary>
    /// <returns>
    ///    A new <c>ReqCalcTaskController</c> class instance.
    /// </returns>
    protected ReqCalcTaskController createTaskController()
    {
        if (maxChildThreads == 0)
        {
            return ReqCalcTaskControllerSingleThread::newController(reqPlanId, processId);
        }
        else
        {
            return ReqCalcTaskController::newController(reqPlanId, processId, threadId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>currentDaySchedFrom</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines when scheduling on the current day should start from.
    /// </summary>
    /// <returns>
    /// The methodology to choose the start time.
    /// </returns>
    public ReqCurrentDaySchedFrom currentDaySchedFrom()
    {
        return ReqCurrentDaySchedFrom::BeginningOfDay;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteAllReqTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes all transactions of a given ReqRefType from the current plan version.
    /// </summary>
    /// <param name="_refType">
    /// The ReqRefType of transactions to delete
    /// </param>
    protected void deleteAllReqTrans(ReqRefType _refType)
    {
        ReqTrans        reqTrans;
        ReqProcessItem  reqProcessItem;
        ReqPO           reqPO;

        while select forupdate reqTrans
            where   reqTrans.RefType            == _refType
                &&  reqTrans.PlanVersion        == this.reqPlanVersionRefRecId()
        exists join reqProcessItem
            where   reqProcessItem.ItemId       == reqTrans.ItemId
            &&      reqProcessItem.ProcessId    == processId
        {
            if (_refType == ReqRefType::PlannedIntercompanyDemand)
            {
                reqPO = reqTrans.intercompanyParentReqPO();
                if (!reqPO)
                {
                    reqTrans.delete(reqPlanData);
                }
            }
            else
            {
                reqTrans.delete(reqPlanData);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteIntercompanyReqTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the intercompany demand for the current plan version.
    /// </summary>
    public void deleteIntercompanyReqTrans()
    {
        this.deleteAllReqTrans(ReqRefType::PlannedIntercompanyDemand);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteItemRequirement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the requirement profile for an item in order to do a new master scheduling.
    /// </summary>
    /// <param name="_setup">
    /// An object of type ReqSetup that holds requirement settings for an item.
    /// </param>
    /// <remarks>
    /// As the requirement profile is deleted for one item only the derived transactions and approved planned orders cannot be deleted.
    /// </remarks>
    protected void deleteItemRequirement(ReqSetup _setup)
    {
        ReqTrans            reqTrans;
        ReqTrans            reqTransDelete;

        ReqSetupDim         setupDim;
        ItemId              planningItemId;

        #LOCALMACRO.MatchStatement
            where  reqTransDelete.PlanVersion   == this.reqPlanVersionRefRecId()
               &&  reqTransDelete.ItemId        == _setup.itemId()
               &&  reqTransDelete.RefType       != ReqRefType::BOMLine
               &&  reqTransDelete.RefType       != ReqRefType::TransferDemand
               &&  reqTransDelete.RefType       != ReqRefType::ItemPlannedOrder
               &&  reqTransDelete.RefType       != ReqRefType::BOMPlannedOrder
               &&  reqTransDelete.RefType       != ReqRefType::TransferPlannedOrder
               &&  reqTransDelete.RefType       != ReqRefType::PlannedKanban
               &&  reqTransDelete.RefType       != ReqRefType::PlannedKanbanLine
               && reqTransDelete.RefType        != ReqRefType::PmfFormulaLine
               && reqTransDelete.RefType        != ReqRefType::PmfPlannedProdBatch
               && reqTransDelete.RefType        != ReqRefType::PmfCoProduct
        #ENDMACRO

        this.insertReqTransCovKeep(targetPlanVersion, targetPlanVersion, _setup.itemId());
        if (_setup.inventTable().PmfProductType == PmfProductType::Co_Product)
        {
            select firstonly reqTransDelete
                #MatchStatement
            &&  reqTransDelete.PmfPlanningItemId != '';
            planningItemId = reqTransDelete.PmfPlanningItemId;
        }

        reqTransDelete.skipDeleteActions(true);
        reqTransDelete.skipDataMethods(true);

        delete_from reqTransDelete
            #MatchStatement;

        SysDaQueryObject queryObject = new SysDaQueryObject(reqTrans);
        queryObject.forUpdateHint = true;
        queryObject.whereClause(this.buildDeleteItemRequirementWhereClause(reqTrans, _setup));
        
        SysDaSearchObject searchObject = new SysDaSearchObject(queryObject);
        SysDaSearchStatement searchStatement = new SysDaSearchStatement();

        // Handle issue
        while (searchStatement.nextRecord(searchObject))
        {
            this.tryToDeleteTransactionsAndCoverage(reqTrans, _setup);
        }
        // Handle non issue
        while select forupdate reqTrans
            where reqTrans.PlanVersion              == this.reqPlanVersionRefRecId() &&
                  reqTrans.ItemId                   == _setup.itemId()   &&
                  reqTrans.Direction                != InventDirection::Issue  &&
                ! reqTrans.IsDerivedDirectly
        {
            this.tryToDeleteTransactionsAndCoverage(reqTrans, _setup);
        }

        this.deleteInvalidCoverageByReceipt(_setup);

        this.itemRequirementDeleted(_setup);

        if (planningItemId)
        {
            this.deleteItemRequirement(ReqSetup::newItemId(planningItemId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildDeleteItemRequirementWhereClause</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Builds the where clause for deleting item requirements.
    /// </summary>
    /// <param name = "_reqTrans">
    ///     A <c>ReqTrans</c> table buffer.
    /// </param>
    /// <param name = "_setup">
    ///     An instance of <c>ReqSetup</c> class.
    /// </param>
    /// <returns>
    ///     An instance of <c>SysDaQueryExpression</c>.
    /// </returns>
    protected SysDaQueryExpression buildDeleteItemRequirementWhereClause(
        ReqTrans         _reqTrans,
        ReqSetup         _setup)
    {
        SysDaQueryExpression whereClause;

        whereClause = new SysDaEqualsExpression(
                            new SysDaFieldExpression(_reqTrans, fieldStr(ReqTrans, PlanVersion)),
                            new SysDaValueExpression(this.reqPlanVersionRefRecId()))
                        .and(new SysDaEqualsExpression(
                            new SysDaFieldExpression(_reqTrans, fieldStr(ReqTrans, ItemId)),
                            new SysDaValueExpression(_setup.itemId()))
                        .and(new SysDaEqualsExpression(
                            new SysDaFieldExpression(_reqTrans, fieldStr(ReqTrans, Direction)),
                            new SysDaValueExpression(InventDirection::Issue))
                        .and(new SysDaEqualsExpression(
                            new SysDaFieldExpression(_reqTrans, fieldStr(ReqTrans, IsDerivedDirectly)),
                            new SysDaValueExpression(NoYes::No)))));

        return whereClause;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deletedItemRequirement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for doing additional actions during deletion of item requirement.
    /// </summary>
    /// <param name = "_setup">A <c>ReqSetup</c> instance.</param>
    [SysObsolete('Use ReqCalc.itemRequirementDeleted instead.', true, 30\11\2017)]
    delegate void deletedItemRequirement(ReqSetup _setup)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemRequirementDeleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Extension point for doing additional actions during deletion of item requirement.
    /// </summary>
    /// <param name = "_setup">A <c>ReqSetup</c> instance.</param>
    protected void itemRequirementDeleted(ReqSetup _setup)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>tryToDeleteTransactionsAndCoverage</Name>
				<Source><![CDATA[
    protected void tryToDeleteTransactionsAndCoverage(ReqTrans _reqTrans, ReqSetup _setup)
    {
        try
        {
            this.deleteTransactionAndCoverage(_reqTrans, _setup);
        }
        catch (Exception::UpdateConflict)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::UpdateConflictNotRecovered;
            }
            else
            {
                reqPlanData.incrementRetryReqLog(Exception::UpdateConflict);
                _reqTrans.reread();
                retry;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDeleteTransactionAndCoverage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the <c>ReqTrans</c> should be deleted.
    /// </summary>
    /// <param name = "_reqTrans">
    /// A <c>ReqTrans</c> record buffer.
    /// </param>
    /// <param name = "_setup">
    /// A <c>ReqSetup</c> object.
    /// </param>
    /// <returns>
    /// The container with 3 boolean elements.
    /// </returns>
    protected container mustDeleteTransactionAndCoverage(ReqTrans _reqTrans, ReqSetup _setup)
    {
        boolean doDeleteCoverage, doDeleteTransaction, doDeleteExplosionCoverage;

        if (_reqTrans.isDerivedFromPlannedOrder())
        {
            // reqTrans has to be updated but it could be it has been derived deleted by the previous record in this select statement
            // we need to ensure the record still exists
            if (ReqTrans::findRecId(_reqTrans.RecId).RecId)
            {
                doDeleteCoverage = true;
            }
        }
        else if (_reqTrans.isPlannedOrder())
        {
            var setupDim = reqPlanData.newReqSetupDim(_setup, _reqTrans.CovInventDimId);

            if (reqPlanData.mustKeepPlannedOrder(setupDim, _reqTrans,setApprovedPlannedOrder))
            {
                doDeleteCoverage = true;
            }
            else
            {
                doDeleteExplosionCoverage = true;
                doDeleteTransaction = true;
            }
        }
        else
        {
            doDeleteTransaction = true;
        }

        return [doDeleteCoverage, doDeleteTransaction, doDeleteExplosionCoverage];
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTransactionAndCoverage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the item requirement transaction and its coverage from the requirement profile.
    /// </summary>
    /// <param name = "_reqTrans">The transaction to delete.</param>
    /// <param name = "_setup">The object instance with item settings.</param>
    protected void deleteTransactionAndCoverage(ReqTrans _reqTrans, ReqSetup _setup)
    {
        boolean doDeleteCoverage, doDeleteTransaction, doDeleteExplosionCoverage;

        [doDeleteCoverage, doDeleteTransaction, doDeleteExplosionCoverage] = this.mustDeleteTransactionAndCoverage(_reqTrans, _setup);

        if (doDeleteCoverage)
        {
            _reqTrans.CovQty = 0;
            _reqTrans.update(reqPlanData);
        }
        else
        if (doDeleteExplosionCoverage)
        {
            _reqTrans.deleteExplosionCoverage(reqPlanData);
        }

        if (doDeleteTransaction)
        {
            _reqTrans.reread();
            _reqTrans.CovQty = 0;
            _reqTrans.delete(reqPlanData, false, false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteRequisitionsReqTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes requisition lines demand from the current plan version.
    /// </summary>
    public void deleteRequisitionsReqTrans()
    {
        this.deleteAllReqTrans(ReqRefType::RequisitionLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteUnscheduledOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the unscheduled orders for the current process.
    /// </summary>
    protected void deleteUnscheduledOrders()
    {
        ReqUnscheduledOrders reqUnscheduledOrders;

        try
        {
            ttsbegin;

            delete_from reqUnscheduledOrders
                where   reqUnscheduledOrders.ProcessId == processId;

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            if (this.manageExceptionDeadLock())
            {
                retry;
            }
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (this.retryTransientSqlConnectionError())
            {
                retry;
            }
            else
            {
                throw;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if ( this.manageExceptionUpdateConflict() )
            {
                retry;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dynamicReqPlanId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines the ID of the default dynamic master plan.
    /// </summary>
    /// <returns>
    ///     The ID of the default dynamic master plan.
    /// </returns>
    public ReqPlanId dynamicReqPlanId()
    {
        if (!dynamicReqPlanId)
        {
            dynamicReqPlanId = ReqPlanSched::defaultDynamicId();
        }
        return dynamicReqPlanId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>explodeItemId</Name>
				<Source><![CDATA[
    protected ItemId explodeItemId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>explodeReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Explodes an non-planned receipt.
    /// </summary>
    /// <param name="_receipt">
    /// The receipt transaction to explode.
    /// </param>
    protected void explodeReceipt(ReqTrans _receipt)
    {
        KanbanJob   kanbanJob;

        if (this.mustExplodeNonPlannedReceipt())
        {
            switch (_receipt.RefType)
            {
                case ReqRefType::Production:
                    this.insertProdBOM(_receipt.RefId);
                    break;
                case ReqRefType::Kanban:
                    kanbanJob = _receipt.kanbanJob();
                    this.insertKanbanLines(kanbanJob.Kanban);
                    this.insertKanbanTransferIssue(kanbanJob.Kanban);
                    break;
                case ReqRefType::TransferOrderReceive:
                    this.insertTransferShip(_receipt.InventTransOrigin);
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findReceiptPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Searches for a <c>reqTrans</c> record with a positive free quantity in order to fulfill the issue
    ///    that is meant for it by a period quantity calculation.
    /// </summary>
    /// <param name="_setupDim">
    ///    A <c>ReqSetupDim</c> object that holds master planning settings for a specific item and coverage
    ///    dimension.
    /// </param>
    /// <param name="_issue">
    ///    An unsettled issue <c>ReqTrans</c> record.
    /// </param>
    /// <param name="_useReceiptsWithFuturesOnly">
    ///    A Boolean value specifying whether it is allowed to use receipts for which futures have not been calculated yet.
    /// </param>
    /// <returns>
    ///    A <c>ReqTrans</c> record which can be used to fulfill the issue <c>ReqTrans</c> record.
    /// </returns>
    protected ReqTrans findReceiptPeriod(ReqSetupDim    _setupDim,
                                         ReqTrans       _issue,
                                         boolean        _useReceiptsWithFuturesOnly)
    {
        if (_setupDim.covRule() != ReqCovType::Period   ||
            !previousReceipt                            ||
            _issue.ReqDate < covPeriodReceiptFromDate   ||
            _issue.ReqDate > covPeriodReceiptToDate)
        {
            return null;
        }

        if (   (_setupDim.bomVersionReq()   && _issue.ItemBomId   && _issue.ItemBomId != previousReceipt.ItemBomId)
            || (_setupDim.routeVersionReq() && _issue.ItemRouteId && _issue.ItemRouteId != previousReceipt.ItemRouteId))
        {
            ReqTrans receipt;

            if(reqCalcConvertSqlStatementsToSysDaFlightEnabled)
            {
                var receiptQueryObject = ReqCalcSysDaSqlStatementGenerator::runReceiptPeriodQuery(
                    receipt,
                    _issue, 
                    _setupDim,                    
                    reqPlanData,
                    _useReceiptsWithFuturesOnly, 
                    covPeriodReceiptFromDate,
                    covPeriodReceiptToDate);

                SysDaFindStatement findStatement = new SysDaFindStatement();
                findStatement.find(new SysDaFindObject(receiptQueryObject));

                return receipt;
            }

            select firstOnly receipt
                where receipt.PlanVersion               == _issue.PlanVersion
                   && receipt.ItemId                    == _issue.ItemId
                   && receipt.CovInventDimId            == _issue.CovInventDimId
                   && receipt.Direction                 == InventDirection::Receipt
                   && receipt.OpenStatus                == ReqOpenStatus::Pos
                   && receipt.IsDerivedDirectly         == NoYes::No
                   && receipt.ReqDate                   >= covPeriodReceiptFromDate
                   && receipt.ReqDate                   <= covPeriodReceiptToDate
                   && (!_setupDim.bomVersionReq()   || (_setupDim.bomVersionReq()   && receipt.ItemBomId   == _issue.ItemBomId))
                   && (!_setupDim.routeVersionReq() || (_setupDim.routeVersionReq() && receipt.ItemRouteId == _issue.ItemRouteId))
                   && receipt.MarkingRefInventTransOrigin == 0
                   && (receipt.FuturesCalculated || !_useReceiptsWithFuturesOnly);

            return receipt;
        }

        if (previousReceipt.openQty() == 0)
        {
            return null;
        }

        return previousReceipt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>futuresApplyKanban</Name>
				<Source><![CDATA[
    /// <summary>
    /// Applies the futures date to the (firmed) Event Kanban.
    /// </summary>
    /// <param name="_reqTrans">
    /// The transaction representing the kanban.
    /// </param>
    protected void futuresApplyKanban(ReqTrans _reqTrans)
    {
        Kanban                      kanban = Kanban::findKanbanId(_reqTrans.RefId, true);
        KanbanJobAutoPlanForward    autoPlan;
        utcdatetime                 planningResult;
        Timezone                    timezone;
        int                         failCount;
        ReqTrans                    reqTransDerived = _reqTrans.derivedTransWithMaxFuturesDateTime();

        if (kanban && reqTransDerived)
        {
            timezone = DateTimeUtil::getCompanyTimeZone();

            // Calculate due date of the kanban jobs and kanban forward from futures date
            KanbanDateCalculation::newStandard(kanban).setDueDateTimeForward(DateTimeUtil::newDateTime(reqTransDerived.FuturesDate, reqTransDerived.FuturesTime, timezone));

            if (LeanRuleKanban::newLeanRuleData(LeanRuleData::newKanbanRuleRecId(kanban.KanbanRule)).requiresAutoPlanning())
            {
                // Re-plan the kanban jobs forward based on the new due date, force shortage reaction to "Postpone"
                autoPlan = KanbanJobAutoPlanForward::newKanban(kanban, dateNull(), false, LeanCapacityShortageReactions::Slot, true);
                autoPlan.run();

                failCount = autoPlan.failCount();
                if (failCount == 0)
                {
                    // Use the expected date time as new dueDate for the kanban (and the jobs) to avoid having it looking delayed
                    kanban.reread();
                    kanban.DueDateTime = kanban.ExpectedDateTime;
                    kanban.update();

                    planningResult = DateTimeUtil::applyTimeZoneOffset(kanban.ExpectedDateTime, DateTimeUtil::getCompanyTimeZone());
                }
                else
                {
                    warning(strFmt("@SYS301793",failCount));
                }
            }

            if (!planningResult)
            {
                // Just fall back to use the kanban due date if auto planning is not enabled or if planning has failed
                kanban.reread();
                planningResult = DateTimeUtil::applyTimeZoneOffset(kanban.DueDateTime, timezone);
            }

            // Update the futures date on the _reqTrans record back from the kanban result
            _reqTrans.FuturesDate = DateTimeUtil::date(planningResult);
            _reqTrans.FuturesTime = DateTimeUtil::time(planningResult);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>futuresCalcDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the futures information on all transactions for a item/dimension pair.
    /// </summary>
    /// <param name="_setupDim">
    /// A <c>ReqSetupDim</c> object that contains the item coverage settings.
    /// </param>
    /// <param name="_reqTransQuery">
    /// A <c>Query</c> that can be used to get all the requirement transactions to be futures processed.
    /// </param>
    /// <param name="_listFuturesReschedule">
    /// A <c>List</c> object to which the orders to be scheduled should be added.
    /// </param>
    protected void futuresCalcDim(
        ReqSetupDim   _setupDim,
        Query         _reqTransQuery,
        List          _listFuturesReschedule = null)
    {
        if (!_reqTransQuery)
        {
            return;
        }

        using (var inMemoryCacheScope = reqPlanData.beginInMemoryCacheScope())
        {
            QueryRun queryRun = new QueryRun(_reqTransQuery);
            var futuresQueue = ReqTransInMemoryCachePriorityQueue::newStandard(reqPlanData.inMemoryCache(), this.futuresOrderStrategy());

            while (queryRun.next())
            {
                ReqTrans reqTrans = queryRun.get(tableNum(ReqTrans));

                if (reqPlanData.mustTransBeFuturesMarked(_setupDim, reqTrans))
                {
                    futuresQueue.enqueue(reqTrans);
                }
            }

            while (!futuresQueue.isEmpty())
            {
                this.futuresCalcDimTrans(_setupDim, futuresQueue.dequeue(), _listFuturesReschedule);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>futuresOrderStrategy</Name>
				<Source><![CDATA[
    private ReqIReqTransSortOrderStrategy futuresOrderStrategy()
    {
        return ReqTransSortOrderStrategy::newFromStaticMethod(classNum(ReqCalc), staticMethodStr(ReqCalc, reqTransFutures2sortKey));
    }

]]></Source>
			</Method>
			<Method>
				<Name>futuresCalcDimTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates a transaction that is futures marked. This includes rescheduling of planned orders if it is
    ///    required.
    /// </summary>
    /// <param name="_setupDim">
    ///    A <c>ReqSetupDim</c> object that contains the cached item coverage settings.
    /// </param>
    /// <param name="_reqTrans">
    ///    The <c>ReqTrans</c> record to be updated with the futures information.
    /// </param>
    /// <param name="_listFuturesReschedule">
    ///    A <c>List</c> that contains orders to be rescheduled.
    /// </param>
    /// <param name="_futuresQueue">
    ///    A queue of requirement transactions for which delays must be calculated. Pegging optimization will not happen if the futures queue is not specified.
    /// </param>
    /// <remarks>
    ///    If the <paramref name="_listFuturesReschedule" /> parameter is not null, the order to be
    ///    rescheduled is added to this list.Otherwise a new instance of a scheduling engine is created and
    ///    the order is rescheduled immediately.
    /// </remarks>
    protected void futuresCalcDimTrans(
        ReqSetupDim                         _setupDim,
        ReqTrans                            _reqTrans,
        List                                _listFuturesReschedule)
    {
        _reqTrans.initializeFutures(reqPlanData);

        if (_reqTrans.Direction == InventDirection::Issue)
        {
            ReqTrans    receipt;
            ReqTransCov reqTransCov;

            select firstonly forceplaceholders TableId from reqTransCov
                where reqTransCov.IssueRecId == _reqTrans.RecId
                    && reqTransCov.Qty != 0
            join reverse receipt
                order by FuturesDate, FuturesTime
                where receipt.RecId == reqTransCov.ReceiptRecId;

            _reqTrans.setFuturesDateTimeIssue(receipt, reqPlanData, _setupDim);

            // This code is needed to account for the following.
            // The previous query finds the latest pegged receipt ordered by FuturesDate - let's call it receipt1. 
            // Later in the setFuturesDateTimeIssues method the receipt margin is applied on the FuturesDate on receipt1.
            // The receipt margin is not applied on transaction of type InventOnHand and SafetyInvent.
            // So if receipt1 is of one of those types there is a chance that there is a receipt receipt2 such that
            // receipt2.FuturesDate < receipt1.FuturesDate but receipt2.FuturesDate + receiptMargin > receipt1.FuturesDate.
            // We need to find that receipt if it exists and update the delay for the issue accordingly.
            //
            // Note that we do not have to worry about InventOnHand since FuturesDate on on-hand records is always set to min date so 
            // the query will only pick on hand if only on-hand was pegged against the issue.
            if (reqPlanData.marginReceipt(_setupDim) != 0 // if there is receipt margin to apply
                && receipt.RefType == ReqRefType::SafetyInvent) // and the type of the receipt previously found is the type we do not apply margin on
            {
                // we need to find the latest receipt amongst the ones on which we do apply receipt margin
                select firstonly forceselectorder TableId from reqTransCov
                    where reqTransCov.IssueRecId == _reqTrans.RecId
                        && reqTransCov.Qty != 0
                    join reverse receipt
                        order by FuturesDate, FuturesTime
                        where receipt.RecId == reqTransCov.ReceiptRecId
                            && receipt.RefType != ReqRefType::SafetyInvent;

                _reqTrans.setFuturesDateTimeIssue(receipt, reqPlanData, _setupDim);
            }

            if (_reqTrans.isDelayed())
            {
                this.coverageEngine(_setupDim).optimizePeggingForDelayedIssue(_reqTrans);
            }
        }
        else
        {
            ReqPO reqPO;

            if (_reqTrans.isPlannedOrder())
            {
                reqPO = _reqTrans.getReqPo(reqPlanData, true);
                if (!reqPO.RecId)
                {
                    reqPO.insertFromReqTrans(_reqTrans,
                                             _reqTrans.reqSetup(reqPlanData),
                                             _reqTrans.reqSetupDim(reqPlanData),
                                             reqPlanData.reqTraceLogger());
                }
            }

            this.calculateFuturesDimTrans(_setupDim, _reqTrans, reqPO, _listFuturesReschedule);
        }

        // Update futures
        _reqTrans.FuturesCalculated = NoYes::Yes;
        _reqTrans.update(reqPlanData);

        if (_reqTrans.RefType == ReqRefType::Sales && _reqTrans.FuturesMarked)
        {
            ReqLog reqLog = reqPlanData.reqLog();
            if (reqLog.ReqLogId)
            {
                reqLog.NumOfSalesLineFuture++;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateBatchExpiryTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates and creates batch expiry requirement transactions for the plan.
    /// </summary>
    private void calculateBatchExpiryTransactions()
    {
        if (reqPlanData.mustCalculateBatchExpiry())
        {
            boolean mustDeleteStaleExpiryTrans = !this.isCompleteUpdate();
            reqTransCache.pdsCreateExpiryTrans(mustDeleteStaleExpiryTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateFuturesDimTrans</Name>
				<Source><![CDATA[
    [Hookable]
    private void calculateFuturesDimTrans(
        ReqSetupDim     _setupDim,
        ReqTrans        _reqTrans,
        ReqPO           _reqPO,
        List            _listFuturesReschedule)
    {
        switch (_reqTrans.RefType)
        {
            case ReqRefType::BOMPlannedOrder:
            case ReqRefType::PmfPlannedProdBatch:
                if (!_reqPO.postponeToFuturesDate(reqPlanData,_setupDim))
                {
                    _reqTrans.setFuturesDateTimeReceipt(reqPlanData,_setupDim,true);
                }
                else
                {
                    if (!_reqTrans.IsDelayed)
                    {
                        _reqTrans.FuturesDate = _reqPO.SchedToDate;
                        _reqTrans.FuturesDate = reqPlanData.schedMarginForward(_reqTrans.FuturesDate, 0, _setupDim);
                        _reqTrans.FuturesTime = _reqTrans.ReqTime;
                    }
                    else
                    {
                        if (traceLoggingEnabled)
                        {
                            reqTraceLogger.writeLog(ReqTraceLogMessageEntry::newFromReqTrans(ReqTraceMessageType::RescheduleOrderFuture, [_reqTrans.RefId], _reqTrans));
                        }

                        // trigger a production scheduling with limited materials.
                        if (!_listFuturesReschedule)
                        {
                            throw error(strFmt("@SYS118115", funcName()));
                        }

                        _listFuturesReschedule.addEnd(_reqTrans.RefId);
                        return;
                    }
                }
                break;

            case ReqRefType::TransferPlannedOrder:
                if (!_reqPO.postponeToFuturesDate(reqPlanData,_setupDim))
                {
                    _reqTrans.setFuturesDateTimeReceipt(reqPlanData,_setupDim,false);
                }
                else
                {
                    ReqTrans tmpReq = _reqTrans.selectDerived(true);
                    ReqDateOrder reqDateOrder  = tmpReq.FuturesDate ?
                                            reqPlanData.schedMarginBackward(tmpReq.FuturesDate,reqPlanData.marginOrder(_setupDim),_setupDim) :
                                            reqPlanData.todaysdate();

                    if (traceLoggingEnabled)
                    {
                        reqTraceLogger.writeLog(ReqTraceLogMessageEntry::newFromReqTrans(ReqTraceMessageType::FutureDateTransfer, [_reqTrans.RefId], _reqTrans));
                    }

                    if (reqDateOrder > _reqPO.ReqDateOrder)
                    {
                        SchedDate schedFromDate   = max(tmpReq.FuturesDate, reqPlanData.schedMarginForwardWithCalendar(reqDateOrder,reqPlanData.marginOrder(_setupDim),_setupDim, _setupDim.shippingCalendarId(), '', SalesCheckForPickup::PrimaryCalendar));
                        SchedDate schedToDate     = reqPlanData.schedReqPoForward(schedFromDate, _reqPO, _setupDim.transportCalendarId(), _setupDim.reqCalendarId());

                        _reqTrans.FuturesDate   = schedToDate;
                        _reqTrans.FuturesTime   = _reqTrans.ReqTime;

                        ReqDate reqDate = reqPlanData.schedMarginForward(schedToDate,reqPlanData.marginReceipt(_setupDim),_setupDim);

                        if (traceLoggingEnabled)
                        {
                            reqTraceLogger.writeLog(ReqTraceLogMessageDetail::newDetail(ReqTraceMessageDetailType::DerivedTransferDelayed, [reqDateOrder, reqPlanData.marginOrder(_setupDim)]));
                        }

                        LeadTime itemExpiryDateDelta = reqDate - _reqTrans.ReqDate;
                        LeadTime derivedItemExpiryDateDelta = reqDateOrder - tmpReq.ReqDate;

                        _reqPO.ReqDateOrder  = reqDateOrder;
                        _reqPO.SchedFromDate = schedFromDate;
                        _reqPO.SchedToDate   = schedToDate;
                        _reqPO.ReqDate       = reqDate;
                        _reqPO.ReqDateDlv    = schedToDate;
                        _reqPO.doUpdate();

                        if (tmpReq.RecId)
                        {
                            tmpReq.ReqDate      = _reqPO.ReqDateOrder;
                            if (tmpReq.PdsExpiryDate && tmpReq.RefType == ReqRefType::TransferDemand)
                            {
                                tmpReq.PdsExpiryDate += derivedItemExpiryDateDelta;
                            }
                            tmpReq.update(reqPlanData);
                        }

                        _reqTrans.ReqDate = _reqPO.ReqDate;
                        if (_reqTrans.PdsExpiryDate)
                        {
                            _reqTrans.PdsExpiryDate += itemExpiryDateDelta;
                        }
                        _reqTrans.ReqTime = _reqPO.ReqTime;
                    }
                    else if (_reqPO.ReqDateDlv > _reqTrans.ReqDateDlvOrig)
                    {
                        // Re-scheduling is not needed, but the order is still late.
                        _reqTrans.FuturesDate = _reqPO.ReqDateDlv;
                        _reqTrans.FuturesTime = _reqTrans.ReqTime;
                    }
                    else
                    {
                        if (traceLoggingEnabled)
                        {
                            reqTraceLogger.writeLog(ReqTraceLogMessageDetail::newDetail(ReqTraceMessageDetailType::DerivedTransferDelayed, conNull()));
                        }
                    }
                }
                break;

            case ReqRefType::ItemPlannedOrder:
                boolean isOrderDelayed = _reqTrans.setFuturesDateTimeReceipt(reqPlanData,_setupDim,true);
                if (_reqPO.ReqPOStatus == ReqPOStatus::Approved)
                {
                    // In case we have approved a planned purchase order then the earliest possible date (futures date)
                    // is the one that has been approved
                    if (_reqTrans.ReqDate > _reqTrans.FuturesDate)
                    {
                        _reqTrans.FuturesDate = _reqTrans.ReqDate;
                    }
                }
                else if (isOrderDelayed && _reqPO.postponeToFuturesDate(reqPlanData,_setupDim))
                {
                    _reqPO.ReqDateDlv  = _reqTrans.FuturesDate;

                    _reqPO.initFromReqDateDlv(_setupDim,reqPlanData);
                    _reqPO.doUpdate();

                    _reqTrans.ReqDate = _reqPO.ReqDate;
                    _reqTrans.ReqTime = _reqPO.ReqTime;
                }
                break;

            case ReqRefType::PlannedKanban:
                if ( _reqTrans.setFuturesDateTimeReceipt(reqPlanData,_setupDim,true)
                      && _reqPO.postponeToFuturesDate(reqPlanData,_setupDim))
                {
                    _reqPO.ReqDateDlv  = _reqTrans.FuturesDate;
                    _reqPO.initFromReqDateDlv(_setupDim,reqPlanData);
                    _reqPO.doUpdate();

                    _reqTrans.ReqDate = _reqPO.ReqDate;
                    _reqTrans.ReqTime = _reqPO.ReqTime;
                }
                break;

            case ReqRefType::Kanban:
                if (_reqTrans.setFuturesDateTimeReceipt(reqPlanData,_setupDim,true)
                        && this.parmApplyFuturesToEventKanban()
                        && _reqTrans.isEventKanban())
                {
                    this.futuresApplyKanban(_reqTrans);
                }
                break;

            case ReqRefType::SafetyInvent:
                this.activeSafetyStockRequirementsTracker(_setupDim).matchRecieptRequirements(_reqTrans);
                break;

            default :
                _reqTrans.setFuturesDateTimeReceipt(reqPlanData, _setupDim, true);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleItemError</Name>
				<Source><![CDATA[
    internal void handleItemError(ItemId _itemId, labelString _labelString)
    {
        warning(strFmt(_labelString, _itemId));
        setErrorItemId.add(_itemId);
        reqTransCache.manageItemError(_itemId, hasErrors);
        hasErrors = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>futuresCalcItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Processes futures messages for the items in a specified list on a specified level.
    /// </summary>
    /// <param name="_level">
    ///    The level on which to process the list.
    /// </param>
    /// <param name="_levelState">
    ///    A <c>ReqLevelState</c> that indicates the level sub-state.
    /// </param>
    /// <param name="_itemId">
    ///    The item ID to process.
    /// </param>
    [SuppressBpWarning("BPParameterNotUsed", "Parameter _level is used by deriving classes that overrides this method.")]
    protected void futuresCalcItem(BOMLevel         _level,
                                   ReqLevelState    _levelState,
                                   ItemId           _itemId)
    {
        List            listCovDimSorted;
        ListEnumerator  leCovDimSorted;
        InventDimId     covInventDimId;
        ReqSetupDim     setupDim;
        Query           reqTransQueryReceipt;
        Query           reqTransQueryIssue;

        void handleError()
        {
            this.handleItemError(_itemId, "@SYS117409");
        }

        reqTransCache.setCurrentItem(_itemId);
        reqTransCache.setCurrentLevel(_level);

        WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::Item, _itemId);

        if (setErrorItemId.in(_itemId))
        {
            return;
        }

        /*
            Loop used dimensions on item
            */

        int infologLineTry = infologLine();
        try
        {
            // make sorted list of covDimId sets
            listCovDimSorted = reqTransCache.listCovDimSorted(_itemId, reqPlanData, true);
        }
        catch (Exception::Error)
        {
            if (this.retryExceptionError(infologLineTry))
            {
                retry;
            }

            handleError();
            return;
        }

        /*
            Loop sorted by inventlocation level
            */

        leCovDimSorted = listCovDimSorted.getEnumerator();
        while (leCovDimSorted.moveNext())
        {
            covInventDimId = leCovDimSorted.current();
            coverageEngine = null;

            infologLineTry = infologLine();
            try
            {
                reqPlanData.createReqLogRestorePoint();

                ttsbegin;

                scheduleOrdersList = new List(Types::String);

                setupDim = reqPlanData.newReqSetupDim(reqPlanData.newReqSetup(_itemId),covInventDimId);
                if (setupDim.mustItemBeFuturesMarked() && reqPlanData.timeFenceFutures(setupDim) > 0)
                {
                    setPrefix(fieldLabelValue(tableNum(InventTable), fieldNum(InventTable,ItemId), _itemId));
                    setPrefix(fieldLabelValue(tableNum(InventDim), fieldNum(InventDim,InventDimId), covInventDimId));

                    reqTransQueryReceipt = reqTransCache.receiptsQuery(_itemId, covInventDimId);
                    reqTransQueryIssue = reqTransCache.issuesQuery(_itemId, covInventDimId);

                    switch (_levelState)
                    {
                        case ReqLevelState::FuturesReceipts:
                            // calculate the future date of the transfer and kanban demand for the planned transfer order in next dimension level.
                            reqTransQueryIssue.dataSourceTable(tableNum(ReqTrans)).addRange(fieldNum(ReqTrans, RefType)).value(queryValue(ReqRefType::TransferDemand));
                            reqTransQueryIssue.dataSourceTable(tableNum(ReqTrans)).addRange(fieldNum(ReqTrans, RefType)).value(queryValue(ReqRefType::PlannedKanbanLine));
                            reqTransQueryIssue.dataSourceTable(tableNum(ReqTrans)).addRange(fieldNum(ReqTrans, RefType)).value(queryValue(ReqRefType::KanbanLine));
                            reqTransQueryIssue.dataSourceTable(tableNum(ReqTrans)).addRange(fieldNum(ReqTrans, RefType)).value(queryValue(ReqRefType::TransferOrderShip));
                            reqTransQueryIssue.dataSourceTable(tableNum(ReqTrans)).addRange(fieldNum(ReqTrans, RefType)).value(queryValue(ReqRefType::SafetyInvent));
                            break;

                        case ReqLevelState::FuturesIssues:
                            // calculate the future date of the planned transfer and kanban order for the issue reqTrans in next level.
                            reqTransQueryReceipt.dataSourceTable(tableNum(ReqTrans)).addRange(fieldNum(ReqTrans, RefType)).value(queryValue(ReqRefType::TransferPlannedOrder));
                            reqTransQueryReceipt.dataSourceTable(tableNum(ReqTrans)).addRange(fieldNum(ReqTrans, RefType)).value(queryValue(ReqRefType::PlannedKanban));
                            reqTransQueryReceipt.dataSourceTable(tableNum(ReqTrans)).addRange(fieldNum(ReqTrans, RefType)).value(queryValue(ReqRefType::Kanban));
                            reqTransQueryReceipt.dataSourceTable(tableNum(ReqTrans)).addRange(fieldNum(ReqTrans, RefType)).value(queryValue(ReqRefType::SafetyInvent));
                            break;

                        default:
                            throw error("@SYS320448");
                    }

                    this.resetActiveSafetyStockRequirementsTracker();
                    this.futuresCalcDim(setupDim, reqTransQueryReceipt, scheduleOrdersList);
                    this.setTradableQuantities(setupDim);
                    this.futuresCalcDim(setupDim, reqTransQueryIssue);
                }

                if (_levelState == ReqLevelState::FuturesReceipts)
                {
                    this.insertUnscheduledOrders(scheduleOrdersList);
                }

                ttscommit;
            }
            catch (Exception::Deadlock)
            {
                if ( this.manageExceptionDeadLockRestoreReqCalc() )
                {
                    retry;
                }
            }
            catch (Exception::TransientSqlConnectionError)
            {
                if (this.retryTransientSqlConnectionErrorRestoreReqCalc())
                {
                    retry;
                }
                else
                {
                    throw;
                }
            }
            catch (Exception::UpdateConflict)
            {
                if (this.manageExceptionUpdateConflictRestoreReqCalc())
                {
                    retry;
                }
            }
            catch (Exception::Error)
            {
                if (this.retryExceptionErrorRestoreReqCalc(infologLineTry))
                {
                    retry;
                }

                handleError();
            }
            catch (Exception::CLRError)
            {
                ApplicationUnhandledExceptionLogger::processUnhandledCLRException();
                handleError();
            }
            catch (Exception::Info)
            {
                handleError();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTradableQuantities</Name>
				<Source><![CDATA[
    private void setTradableQuantities(ReqSetupDim _setupDim)
    {
        coverageEngine = this.coverageEngine(_setupDim);
        if (coverageEngine.isPeggingOptimizationEnabled())
        {
            var tradableQuantities = this.activeSafetyStockRequirementsTracker(_setupDim).getTradableQuantities();
            coverageEngine.setTradableSafetyStockIssueQuantities(tradableQuantities);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>futuresDeleteCapReserv</Name>
				<Source><![CDATA[
    protected void futuresDeleteCapReserv()
    {
        ReqTrans        reqTrans;
        WrkCtrCapRes    wrkCtrCapRes;
        ReqSetupDim     setupDim;
        Map             mapPlannedOrder;
        MapIterator     mi_PlannedOrder;

        if (!reqPlanData.futuresSched())
        {
            return;
        }

        mapPlannedOrder = reqTransCache.mapPlannedOrder();
        if (mapPlannedOrder)
        {
            mi_PlannedOrder = new MapIterator(mapPlannedOrder);
            mi_PlannedOrder.begin();
            while (mi_PlannedOrder.more())
            {
                reqTrans = mapPlannedOrder.lookup(mi_PlannedOrder.key());

                if (reqTrans.IsDelayed &&
                   (reqTrans.RefType == ReqRefType::BOMPlannedOrder ||
                    reqTrans.RefType == ReqRefType::PmfPlannedProdBatch))
                {
                    setupDim    = reqPlanData.newReqSetupDim(reqPlanData.newReqSetup(reqTrans.ItemId),reqTrans.CovInventDimId);
                    
                    if (reqPlanData.mustTransBeFuturesMarked(setupDim,reqTrans))
                    {
                        ReqPO delayedPlannedOrder = reqTrans.getReqPo(reqPlanData);
          
                        // delete capacity reservations only if delayed PPO will be rescheduled (not the case for approved/freeze planned orders)
                        if (delayedPlannedOrder.postponeToFuturesDate(reqPlanData, setupDim)  &&
                            reqPlanData.mustTransBeScheduled(setupDim, delayedPlannedOrder))
                        {
                            delete_from wrkCtrCapRes
                            where wrkCtrCapRes.PlanVersion == reqTrans.PlanVersion            &&
                                  wrkCtrCapRes.RefType     == WrkCtrCapRefType::PlannedOrder  &&
                                  wrkCtrCapRes.RefId       == reqTrans.RefId;
                        }
                    }
                }

                mi_PlannedOrder.next();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>futuresInitLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the resource scheduler cache for item BOM level processed during the futures loop.
    /// </summary>
    /// <param name="_level">
    /// The item BOM level being processed.
    /// </param>
    [SuppressBpWarning("BPParameterNotUsed", "Parameter _level is used by deriving classes that overrides this method.")]
    protected void futuresInitLevel(BOMLevel _level)
    {
        this.deleteUnscheduledOrders();

        if (wrkCtrScheduler)
        {
            wrkCtrScheduler.initCache();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBomLevelCalc</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates the instance of the <c>BOMLevelCalc</c> class if it has not been created yet.
    /// </summary>
    /// <returns>
    ///     The instance of the <c>BOMLevelCalc</c> class.
    /// </returns>
    private ReqBOMLevelCalc getBomLevelCalc()
    {
        if (!bomLevelCalc)
        {
            bomLevelCalc = ReqBOMLevelCalc::construct();
        }

        return bomLevelCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildBaseQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the base query used to find items to schedule.
    /// </summary>
    /// <returns>The base query used to find items to schedule</returns>
    protected QueryRun buildBaseQuery()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUpdateAllItems</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether a full or partial regeneration should be run.
    /// </summary>
    /// <param name="_query">The query that will be used for MRP</param>
    /// <returns>true, if a full regeneration should be run for the specified query; otherwise, false.</returns>
    protected boolean shouldUpdateAllItems(QueryRun _query)
    {
        QueryRun baseQuery = this.buildBaseQuery();
        if (baseQuery == null)
        {
            // Use only the method based on the query since we don't have a base query to compare to.
            return ReqCalc::updateAllItems(_query);
        }
        else
        {
            boolean queriesEqual = !strCmp(baseQuery.query().dataSourceNo(1).toString(), _query.query().dataSourceNo(1).toString());

            // UpdateAllItems, while deprecated and not necessary for the logic,
            // needs to be called for maintaining compatibility.
            return ReqCalc::updateAllItems(_query) && queriesEqual;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIntercompanyDemandQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Builds the query for finding the planned intercompany demand.
    /// </summary>
    /// <param name="_queryFactory">
    ///     The factory class for building the queries.
    /// </param>
    /// <param name="_lockedPlanVersions">
    ///     The set of plan versions being locked.
    /// </param>
    /// <param name="_processId">
    ///     The ID of the master scheduling process.
    /// </param>
    /// <returns>
    ///     The query used to find the planned intercompany demand.
    /// </returns>
    protected QueryRun getIntercompanyDemandQuery(ReqIntercompanyQueryFactory _queryFactory, Set _lockedPlanVersions, ReqProcessId _processId)
    {
        return _queryFactory.getIncomingDemandQuery(_lockedPlanVersions, false, _processId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProcessId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets a new master planning process from the number sequences.
    /// </summary>
    /// <returns>
    ///    A <c>ReqProcessId</c> value that represents the new master planning run ID
    /// </returns>
    protected ReqProcessId getProcessId()
    {
        return NumberSeq::newGetNum(CompanyInfo::numRefParmId()).num();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSetupDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>ReqSetupDim</c> class.
    /// </summary>
    /// <param name="_itemId">
    /// An <c>ItemId</c>.
    /// </param>
    /// <param name="_covInventDimId">
    /// An <c>InventDimId</c>
    /// </param>
    /// <returns>
    /// A new instance of the <c>ReqSetupDim</c> class.
    /// </returns>
    protected internal ReqSetupDim getSetupDim(ItemId _itemId, InventDimId _covInventDimId)
    {
        return reqPlanData.newReqSetupDim(reqPlanData.newReqSetup(_itemId), _covInventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStatusRuntime</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Computes the runtime for a range of phases of the master planning process.
    /// </summary>
    /// <param name="_fromStatus">
    ///    The lowest inclusive status to use for runtime computation.
    /// </param>
    /// <param name="_toStatus">
    ///    Highest inclusive status to use for runtime computation.
    /// </param>
    /// <returns>
    ///    The amount of seconds spent in the phases between the from and to statuses.
    /// </returns>
    protected Integer getStatusRuntime(ReqProcessStatus _fromStatus, ReqProcessStatus _toStatus)
    {
        return reqCalcTaskController.getStatusRuntime(_fromStatus, _toStatus);
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasErrors</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a boolean indicating whether the scheduling has errors.
    /// </summary>
    /// <returns>
    /// true if the scheduling has errors; otherwise, false.
    /// </returns>
    public boolean hasErrors()
    {
        return hasErrors;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasPreviousSchedulingError</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether an issue has a previous scheduling error.
    /// </summary>
    /// <param name="_issueInventTransOriginId">
    /// The <c>InventTransOriginId</c> of the issue.
    /// </param>
    /// <param name="_issueRefId">
    /// The <c>InventTransRefId</c> of the issue.
    /// </param>
    /// <param name="_issueRefType">
    /// The <c>ReqRefType</c> of the issue.
    /// </param>
    /// <returns>
    /// true if the issue has a previous scheduling error; otherwise, false.
    /// </returns>
    public boolean hasPreviousSchedulingError(InventTransOriginId _issueInventTransOriginId, InventTransRefId _issueRefId, ReqRefType _issueRefType)
    {
        RefRecId            reqPlanVersionRecId;
        ReqTrans            reqTransIssue;
        ReqTrans            reqTransReceipt;
        ReqTransCov         reqTransCov;

        reqPlanVersionRecId = ReqPlanVersion::findActiveReqPlanIdDynamic().RecId;

        if (reqPlanVersionRecId)
        {
            while select TableId from reqTransIssue
                        where  reqTransIssue.PlanVersion        == reqPlanVersionRecId
                            && reqTransIssue.InventTransOrigin  == _issueInventTransOriginId
                            && reqTransIssue.RefId              == _issueRefId
                            && reqTransIssue.RefType            == _issueRefType
            join TableId from reqTransCov
                where reqTransCov.IssueRecId == reqTransIssue.RecId
            join reqTransReceipt
                    where reqTransReceipt.RecId == reqTransCov.ReceiptRecId
                    && (reqTransReceipt.RefType == ReqRefType::BOMPlannedOrder
                        || reqTransReceipt.RefType == ReqRefType::TransferPlannedOrder
                        || reqTransReceipt.RefType == ReqRefType::PmfPlannedProdBatch
                        || reqTransReceipt.RefType == ReqRefType::PlannedKanban)
            {
                if (reqTransReceipt.fromDate() == dateNull())
                {
                    return true;
                }
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>includeIntercompanyDemand</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a value that indicates whether to include intercompany demand or not.
    /// </summary>
    /// <returns>
    ///    A Boolean that indicates whether to include intercompany demand or not.
    /// </returns>
    public boolean includeIntercompanyDemand()
    {
        return ReqPlanSched::find(reqPlanId).IncludePlannedIntercompanyDemand;
    }

]]></Source>
			</Method>
			<Method>
				<Name>includeRequisitions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to include requisitions.
    /// </summary>
    /// <returns>
    /// true if requisitions should be included; otherwise, false.
    /// </returns>
    public boolean includeRequisitions()
    {
        return ReqPlanSched::find(reqPlanId).IncludeRequisitions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePlanVersions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the source and target master plan versions that are used by the current scheduling run.
    /// </summary>
    public void initializePlanVersions()
    {
        ReqPlanVersion activePlanVersion = this.getPlanActiveVersion(reqPlanId);

        sourcePlanVersion = activePlanVersion;
        targetPlanVersion = activePlanVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOrderPartitioner</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the order partitioner.
    /// </summary>
    protected void initOrderPartitioner()
    {
        if (!reqOrderPartitioner)
        {
            reqOrderPartitioner = ReqOrderPartitioner::newProcessId(processId,
                                                                    reqPlanData.parmReqPlanVersionRefRecId());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initReqLog</Name>
				<Source><![CDATA[
    protected  void initReqLog()
    {
        reqPlanData.initReqLog(reqCalcUpdate, processId, clearLog);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTransFromInventSum</Name>
				<Source><![CDATA[
    protected ReqTrans initTransFromInventSum(
        ReqTrans            _reqTrans,
        ReqSetup            _setup,
        ReqSetupDim         _setupDim,
        InventSum           _inventSum
        )
    {
        _reqTrans.clear();
        _reqTrans.PlanVersion            = this.reqPlanVersionRefRecId();

        _reqTrans.ItemId              = _setup.itemId();
        _reqTrans.CovInventDimId      = _setupDim.parmCovInventDimId();

        _reqTrans.Qty                 = _inventSum.PhysicalInvent;

        _reqTrans.RefType             = ReqRefType::InventOnHand;
        _reqTrans.ReqDate             = dateNull();

        _reqTrans.Level               = _setupDim.itemLevel();

        return _reqTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTransFromInventTrans</Name>
				<Source><![CDATA[
    protected ReqTrans initTransFromInventTrans(
        ReqTrans            _reqTrans,
        ReqSetup            _setup,
        ReqSetupDim         _setupDim,
        InventTrans         _inventTrans,
        InventTransOrigin   _inventTransOrigin
        )
    {
        CustTable custTable;
        _reqTrans.clear();
        _reqTrans.PlanVersion            = this.reqPlanVersionRefRecId();

        _reqTrans.ItemId                 = _inventTransOrigin.ItemId;
        _reqTrans.CovInventDimId         = _setupDim.parmCovInventDimId();

        _reqTrans.Qty                    = _inventTrans.Qty;

        _reqTrans.RefType                = ReqTrans::transType2RefType(_inventTransOrigin.ReferenceCategory,_reqTrans.Qty);

        _reqTrans.setSupplyDemandSubClassification(_inventTransOrigin.ReferenceCategory);

        if (#PmfEnabled
            && _reqTrans.RefType == ReqRefType::BOMPlannedOrder
            && InventTable::find(_inventTrans.ItemId).isFormulaAllowed())
        {
            _reqTrans.RefType = ReqRefType::PmfPlannedProdBatch;
        }

        _reqTrans.InventTransOrigin      = _inventTransOrigin.RecId;
        _reqTrans.RefId                  = _inventTransOrigin.ReferenceId;

        _reqTrans.MarkingRefInventTransOrigin = _inventTrans.MarkingRefInventTransOrigin;

        _reqTrans.Priority               = ReqTrans::statusIssue2Priority(_inventTrans.StatusIssue);
        _reqTrans.OprNum                 = ReqTrans::findOprNum(_reqTrans.RefType,_inventTransOrigin.RecId,reqPlanData);

        _reqTrans.initDateTimeFromInvent(_inventTrans.DateStatus,_inventTrans.TimeExpected,reqPlanData,_setupDim);

        _reqTrans.Level                  = _setupDim.itemLevel();

        if (_reqTrans.RefType == ReqRefType::Sales)
        {
            custTable = CustTable::find(SalesLine::findInventTransId(_inventTransOrigin.InventTransId).CustAccount);

            if (custTable)
            {
                _reqTrans.CustAccountId = custTable.AccountNum;
                _reqTrans.CustGroupId = custTable.CustGroup;

            }
        }

        this.initializedTransFromInventTrans(this, _reqTrans, _setup, _setupDim, _inventTrans, _inventTransOrigin);

        return _reqTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializedTransFromInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for initializing any additional values the <c>ReqTrans</c> record.
    /// </summary>
    /// <param name = "_reqCalc">A <c>ReqCalc</c> instance.</param>
    /// <param name = "_reqTrans">A <c>ReqTrans</c> record.</param>
    /// <param name = "_setup">A <c>ReqSetup</c> instance.</param>
    /// <param name = "_setupDim">A <c>ReqSetupDim</c> instance.</param>
    /// <param name = "_inventTrans">A <c>InventTrans</c> record.</param>
    /// <param name = "_inventTransOrigin">A <c>InventTransOrigin</c> record.</param>
    delegate void initializedTransFromInventTrans(
        ReqCalc             _reqCalc,
        ReqTrans            _reqTrans,
        ReqSetup            _setup,
        ReqSetupDim         _setupDim,
        InventTrans         _inventTrans,
        InventTransOrigin   _inventTransOrigin)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initWrkCtrScheduler</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the instance of the resource scheduler engine.
    /// </summary>
    private void initWrkCtrScheduler()
    {
        if (!wrkCtrScheduler)
        {
            wrkCtrScheduler = WrkCtrScheduler_Req::newCheckLockingTTSLevel(false);
            if (!wrkCtrScheduler)
            {
                throw error("@SYS320449");
            }

            wrkCtrScheduler.setReqPlanData(reqPlanData);
            wrkCtrScheduler.setCapacityConflictHandler(capacityConflictsHandler);
            wrkCtrScheduler.parmResetWorkingTimesCacheForEachRun(maxChildThreads > 0);
            wrkCtrScheduler.parmIsRunningMultipleWrkCtrSchedulerInstances(maxChildThreads > 0);
        }

        wrkCtrScheduler.reset();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertApprovedPo</Name>
				<Source><![CDATA[
    protected void insertApprovedPo(ItemId _itemId = '')
    {
        ReqPO   reqPO;

        if (!setApprovedPlannedOrder)
        {
            setApprovedPlannedOrder = new Set(Types::String);
        }

        if ( _itemId)
        {
            while select RefId from reqPO
                // An active version of the plan has to be used in this case.
                where reqPO.PlanVersion == this.getPlanActiveVersion(ReqPlanId).RecId
                   && reqPO.ItemId      == _itemId
                   && reqPO.ReqPOStatus == ReqPOStatus::Approved
            {
                setApprovedPlannedOrder.add(reqPO.RefId);
            }
        }
        else
        {
            while select RefId from reqPO
                // An active version of the plan has to be used in this case.
                where reqPO.PlanVersion == this.getPlanActiveVersion(ReqPlanId).RecId
                   && reqPO.ReqPOStatus == ReqPOStatus::Approved
            {
                setApprovedPlannedOrder.add(reqPO.RefId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertData</Name>
				<Source><![CDATA[
    protected void insertData()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertDataItem</Name>
				<Source><![CDATA[
    [SuppressBpWarning("BPParameterNotUsed", "Parameter _level is used by deriving classes that overrides this method.")]
    protected void insertDataItem(BOMLevel _level, ItemId _itemId)
    {
        reqTransCache.setCurrentItem(_itemId);
        reqTransCache.setCurrentLevel(_level);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertIntercompanyDemand</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts the intercompany demand in the current plan version.
    /// </summary>
    protected void insertIntercompanyDemand()
    {
        QueryRun            queryRun;
        ReqTrans            reqTrans;
        ReqTrans            reqTransExisting;
        ReqPO               reqPO;
        RecordInsertList    reqTransInsertList;
        InventDim           custCovInventDim;
        ReqIntercompanyConversionUtil   conversionUtil;
        ReqIntercompanyDemand           intercompanyDemand;
        Set                lockedPlanVersions;
        ReqIntercompanyQueryFactory queryFactory;
        Set failedItems = new Set(Types::String);
        var deletePreviouslyInsertedIntercompanyReqTrans = ReqCalcDeleteInterCompanyReqTransBeforDemandInsertingToggle::instance().isEnabled();

        try
        {
            ttsbegin;

            if (reqCalcUpdate != ReqCalcUpdate::Regeneration || deletePreviouslyInsertedIntercompanyReqTrans)
            {
                this.deleteIntercompanyReqTrans();
            }

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            if (this.manageExceptionDeadLock())
            {
                retry;
            }
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (this.retryTransientSqlConnectionError())
            {
                retry;
            }
            else
            {
                throw;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if ( this.manageExceptionUpdateConflict() )
            {
                retry;
            }
        }

        queryFactory = this.createReqIntercompanyQueryFactory();

        lockedPlanVersions = this.parmIntercompanyDemandPlanFilter().getPlanVersions(reqPlanId, intercompanyGroup);
        this.lockIntercompanyPlanVersions(lockedPlanVersions);

        try
        {
            queryRun = this.getIntercompanyDemandQuery(queryFactory, lockedPlanVersions, processId);
            queryRun = this.modifyQueryForItemFilter(queryRun);

            conversionUtil = this.createReqIntercompanyConversionUtil();
            intercompanyDemand = ReqIntercompanyDemand::construct();

            reqTransInsertList = new RecordInsertList(tableNum(ReqTrans), true);

            while (queryRun.next())
            {
                reqPO = queryRun.get(tableNum(ReqPO));
                custCovInventDim = queryRun.get(tableNum(InventDim));

                reqTrans.clear();

                try
                {
                    if (intercompanyDemand.initReqTransFromIntercompanyReqPO(reqTrans, reqPO, custCovInventDim, conversionUtil, this.reqPlanVersionRefRecId()))
                    {
                        if (reqCalcUpdate != ReqCalcUpdate::Regeneration || deletePreviouslyInsertedIntercompanyReqTrans)
                        {
                            // Search for an existing record representing the same intercompany demand
                            reqTransExisting = reqTrans.findSimilarIntercompanyDemand();
                        }

                        if (!reqTransExisting)
                        {
                            reqTrans.insertUsingInsertList(reqTransInsertList, reqPlanData);
                        }
                        else if (!reqTrans.compareIntercompanyValues(reqTransExisting))
                        {
                            // The source has changed significantly, so it should be replaced with a new demand record
                            reqTransExisting.delete(reqPlanData);
                            reqTrans.insertUsingInsertList(reqTransInsertList, reqPlanData);
                        }
                        else
                        {
                            // The source may have changed, so the reference should be kept and the dates and quantities should be updated
                            intercompanyDemand.initReqTransFromIntercompanyReqPO(reqTransExisting, reqPO, custCovInventDim, conversionUtil, this.reqPlanVersionRefRecId());
                            reqTransExisting.doIntercompanyDemandUpdate(reqPlanData);
                        }
                    }
                }
                catch (Exception::Error)
                {
                    if (failedItems.add(reqPO.ItemId))
                    {
                        error(strFmt("@SCMPlanning:ReqIntercompanyDemandFailedForItem", reqPO.ItemId));
                    }
                }
            }

            reqTransInsertList.insertDatabase();
        }
        finally
        {
            this.unlockIntercompanyPlanVersions(lockedPlanVersions);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifyQueryForItemFilter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Modifies the queryRun object in order to remove the unneeded <c>ReqProcessItem</c> datasource when a full regeneration with demand filter is performed.
    /// </summary>
    /// <param name = "_queryRun">The object to be modified.</param>
    /// <returns>The modified object.</returns>
    public QueryRun modifyQueryForItemFilter(QueryRun _queryRun)
    {
        if (updateAllItems
            && reqCalcUpdate == ReqCalcUpdate::Regeneration
            && reqPlanData.useItemFilterPreUpdate())
        {
            _queryRun.query().dataSourceTable(tableNum(ReqProcessItem)).enabled(false);
        }

        return _queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertItemForecastDemand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds and inserts demand forecast in the requirement profile.
    /// </summary>
    /// <param name="_setup">
    /// A <c>ReqSetup</c> object that contains coverage settings for a specific item ID.
    /// </param>
    protected void insertItemForecastDemand(ReqSetup _setup)
    {
        RecordInsertList recordInsertList = reqPlanData.useInsertList() ? new RecordInsertList(tableNum(ReqTrans),true) : null;

        InventDimGroupSetup inventDimGroupSetup;
        ForecastModel       forecastModelTrans;
        ForecastInvent      forecastInvent;
        ForecastSales       forecastSales;
        InventDim           inventDim;

        void insertItemForecastDemandEntry()
        {
            ReqSetupDim setupDim = reqPlanData.newReqSetupDim(_setup,inventDim.reqCovDimId(inventDimGroupSetup));

            if (reqPlanData.mustForecastInventBeCreated(setupDim, forecastInvent))
            {
                ReqTrans reqTrans;
                reqTrans.clear();

                this.initItemForecastDemand(reqTrans, forecastSales, forecastInvent, setupDim);

                if (reqTrans.Qty)
                {
                    reqTrans.insertUsingInsertList(recordInsertList, reqPlanData);
                }
            }
        }

        if (reqPlanData.useForecastDemand())
        {
            inventDimGroupSetup = InventDimGroupSetup::newItemId(_setup.itemId());

            SysDaQueryObject itemForecastDemandQueryObject = this.itemForecastDemandQuery(_setup, forecastModelTrans, forecastInvent, forecastSales, inventDim);
            var searchObject  = new SysDaSearchObject(itemForecastDemandQueryObject);
            var searchStatement = new SysDaSearchStatement();

            while (searchStatement.findNext(searchObject))
            {
                insertItemForecastDemandEntry();
            }

            if (recordInsertList)
            {
                recordInsertList.insertDatabase();
                reqTransCache.createReqProcessTransFilterRecords();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemForecastDemandQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a SysDa query to retrieve item forecast demand entries.
    /// </summary>
    /// <param name = "_setup">A planning setup object.</param>
    /// <param name = "_forecastModelTrans">A forecasting model record.</param>
    /// <param name = "_forecastInvent">An item forecast demand record.</param>
    /// <param name = "_forecastSales">A demand forecast record.</param>
    /// <param name = "_inventDim">An inventory dimension record.</param>
    /// <returns>The <c>SysDaQueryObject</c> query object that can be used to retrieve item forecast demand.</returns>
    protected SysDaQueryObject itemForecastDemandQuery(
        ReqSetup _setup,
        ForecastModel _forecastModelTrans,
        ForecastInvent _forecastInvent,
        ForecastSales _forecastSales,
        InventDim _inventDim)
    {
        SysDaQueryObject forecastQueryObject = new SysDaQueryObject(_forecastInvent);
        forecastQueryObject.forceSelectOrderHint = true;

        forecastQueryObject.projection().addSum(fieldStr(ForecastInvent, QtyInvent));

        forecastQueryObject.groupByClause()
            .add(fieldStr(ForecastInvent, DateBudget))
            .add(fieldStr(ForecastInvent, ItemBOMId))
            .add(fieldStr(ForecastInvent, ItemRouteId));

        forecastQueryObject.whereClause(
            new SysDaEqualsExpression(
              new SysDaFieldExpression(_forecastInvent, fieldStr(ForecastInvent, ItemId)),
              new SysDaValueExpression(_setup.itemId()))
            .and(
            new SysDaEqualsExpression(
              new SysDaFieldExpression(_forecastInvent, fieldStr(ForecastInvent, TableType)),
              new SysDaValueExpression(enum2int(ForecastTableType::Demand)))
            )
            .and(
            new SysDaGreaterThanOrEqualsExpression(
              new SysDaFieldExpression(_forecastInvent, fieldStr(ForecastInvent, DateBudget)),
              new SysDaValueExpression(reqPlanData.todaysdate()))
            )
            .and(
            new SysDaLessThanExpression(
              new SysDaFieldExpression(_forecastInvent, fieldStr(ForecastInvent, QtyInvent)),
              new SysDaValueExpression(0))
            ));

        // Inner join InventDim
        SysDaQueryObject inventDimQueryObject = new SysDaQueryObject(_inventDim);

        inventDimQueryObject.whereClause(
            new SysDaEqualsExpression(
                new SysDaFieldExpression(_inventDim, fieldStr(InventDim, inventDimId)),
                new SysDaFieldExpression(_forecastInvent, fieldStr(ForecastInvent, InventDimId))));


        ListEnumerator dimFields = InventDim::dimEnabledFieldList().getEnumerator();
        SysDaGroupBys inventDimGroupBys = inventDimQueryObject.groupByClause();
        DictTable inventDimDictTable = new DictTable(tableNum(InventDim));

        while (dimFields.moveNext())
        {
            FieldId dimFieldId = dimFields.current();
            
            inventDimGroupBys.add(inventDimDictTable.fieldName(dimFieldId));
        }

        forecastQueryObject.joinClause(SysDaJoinKind::InnerJoin, inventDimQueryObject);

        // Inner join ForecastModel
        SysDaQueryObject forecastModelQueryObject = new SysDaQueryObject(_forecastModelTrans);
        forecastModelQueryObject.whereClause(
            new SysDaEqualsExpression(
              new SysDaFieldExpression(_forecastModelTrans, fieldStr(ForecastModel, ModelId)),
              new SysDaValueExpression(reqPlanData.forecastModelId()))
            .and(
            new SysDaEqualsExpression(
              new SysDaFieldExpression(_forecastModelTrans, fieldStr(ForecastModel, SubModelId)),
              new SysDaFieldExpression(_forecastInvent, fieldStr(ForecastInvent, ModelId)))));
        inventDimQueryObject.joinClause(SysDaJoinKind::InnerJoin, forecastModelQueryObject);

        // Outer join ForecastSales
        SysDaQueryObject forecastSalesQueryObject = new SysDaQueryObject(_forecastSales);
        forecastSalesQueryObject.whereClause(
            new SysDaEqualsExpression(
              new SysDaFieldExpression(_forecastSales, fieldStr(ForecastSales, RecId)),
              new SysDaFieldExpression(_forecastInvent, fieldStr(ForecastInvent, TransRecId))));

        forecastSalesQueryObject.groupByClause()
            .add(fieldStr(ForecastSales, CustGroupId))
            .add(fieldStr(ForecastSales, CustAccountId));

        forecastModelQueryObject.joinClause(SysDaJoinKind::OuterJoin, forecastSalesQueryObject);

        return forecastQueryObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initItemForecastDemand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes an item forecast requirement.
    /// </summary>
    /// <param name = "_reqTrans">A requirement record.</param>
    /// <param name = "_forecastSales">A demand forecast record.</param>
    /// <param name = "_forecastInvent">An inventory forecast record.</param>
    /// <param name = "_setupDim">A master planning setup for the item.</param>
    protected void initItemForecastDemand(ReqTrans _reqTrans, ForecastSales _forecastSales, ForecastInvent _forecastInvent, ReqSetupDim _setupDim)
    {
        _reqTrans.PlanVersion        = this.reqPlanVersionRefRecId();
        _reqTrans.RefId              = '';
        _reqTrans.RefType            = ReqRefType::SalesForecast;

        _reqTrans.ItemId             = _setupDim.itemId();
        _reqTrans.CovInventDimId     = _setupDim.parmCovInventDimId();

        _reqTrans.ItemBomId          = _forecastInvent.ItemBOMId;
        _reqTrans.ItemRouteId        = _forecastInvent.ItemRouteId;

        _reqTrans.CustGroupId        = _forecastSales.CustGroupId;
        _reqTrans.CustAccountId      = _forecastSales.CustAccountId;

        _reqTrans.Qty                = _forecastInvent.QtyInvent;
        _reqTrans.OriginalQuantity   = _reqTrans.Qty;
        _reqTrans.ReqDateDlvOrig     = _forecastInvent.DateBudget;

        if (_reqTrans.isReceipt())
        {
            _reqTrans.ReqDate        = reqPlanData.schedReqDateReceipt(_forecastInvent.DateBudget, _setupDim);
        }
        else
        {
            _reqTrans.ReqDate        = reqPlanData.schedReqDateIssue(_forecastInvent.DateBudget, _setupDim);
        }

        _reqTrans.initFromSetupDim(_setupDim);
        if (reqPlanData.pdsUseShelfLife())
        {
            _reqTrans.pdsSetShelfLifeFields();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertItemForecastInvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calls logic for inserting inventory forecast in the requirement profile.
    /// </summary>
    /// <param name="setup">
    /// A <c>ReqSetup</c> object that contains coverage settings for a specific item ID.
    /// </param>
    protected void insertItemForecastInvent(ReqSetup setup)
    {
        this.insertItemForecastDemand(setup);
        this.insertItemForecastSupply(setup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertItemForecastSupply</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds and inserts supply forecast in the requirement profile.
    /// </summary>
    /// <param name="_setup">
    /// A <c>ReqSetup</c> object that contains coverage settings for a specific item ID.
    /// </param>
    protected void insertItemForecastSupply(ReqSetup    _setup)
    {
        ForecastModel                   forecastModelTrans;
        ForecastInvent                  forecastInvent;

        ForecastPurch                   forecastPurch;

        ReqSetupDim                     setupDim;

        ReqTrans                        reqTrans;
        InventDim                       inventDim;

        ReqPO                           reqPO;
        ReqPO                           reqPOExisting;
        ReqDate                         forecastDate;
        ReqQty                          forecastQty;
        InventDimGroupSetup             inventDimGroupSetup;
        ReqTransPOCreate                reqTransPOCreate;

        if (reqPlanData.useForecastSupply())
        {
            inventDimGroupSetup = InventDimGroupSetup::newItemId(_setup.itemId());

            reqTransPOCreate = ReqTransPOCreate::construct();
            reqTransPOCreate.parmBOMDependencyManager(this.parmBOMDependencyManager());

            while select forceplaceholders sum(QtyInvent) from forecastInvent
                group by DateBudget,ItemBOMId,ItemRouteId
                where forecastInvent.ItemId         == _setup.itemId()
                   && forecastInvent.TableType      == ForecastTableType::Supply
                   && forecastInvent.DateBudget     >= reqPlanData.todaysdate()
                   && forecastInvent.QtyInvent      >  0
                join inventDim
                    group by #InventDimGroupAllFields
                    where inventDim.InventDimId     == forecastInvent.InventDimId
                join forecastPurch
                    group by VendGroupId, VendAccountId
                    where forecastPurch.RecId == forecastInvent.TransRecId
                join ModelId from forecastModelTrans
                    where forecastModelTrans.ModelId    == reqPlanData.forecastModelId()
                       && forecastModelTrans.SubModelId == forecastInvent.ModelId
            {
                setupDim = reqPlanData.newReqSetupDim(_setup,inventDim.reqCovDimId(inventDimGroupSetup));

                if (reqPlanData.mustForecastInventBeCreated(setupDim,forecastInvent))
                {
                    forecastDate = reqPlanData.schedMarginBackward(forecastInvent.DateBudget, 0, setupDim);

                    select firstonly Qty from reqPOExisting
                        where reqPOExisting.PlanVersion     == this.reqPlanVersionRefRecId()
                            && reqPOExisting.ItemId         == _setup.itemId()
                            && reqPOExisting.ReqDate        == forecastDate
                            && reqPOExisting.CovInventDimId == setupDim.parmCovInventDimId()
                            && (!forecastPurch.VendAccountId || reqPOExisting.VendId        == forecastPurch.VendAccountId)
                            && (!forecastPurch.VendGroupId   || reqPOExisting.VendGroupId   == forecastPurch.VendGroupId)
                            && reqPOExisting.IsForecastPurch;

                    forecastQty = roundUpDec(forecastInvent.QtyInvent - reqPOExisting.Qty, _setup.inventDecimals());

                    if (forecastQty > 0)
                    {
                        reqPO.clear();
                        reqPO.IsForecastPurch    = NoYes::Yes;
                        reqPO.PlanVersion        = this.reqPlanVersionRefRecId();

                        reqPO.ItemId             = _setup.itemId();
                        reqPO.CovInventDimId     = setupDim.parmCovInventDimId();

                        reqPO.RefId              = NumberSeq::newGetNumFromId(reqPlanData.sequencePlannedOrder()).num();
                        reqPO.RefType            = setupDim.plannedOrderTypeReq();

                        reqPO.ItemRouteId        = forecastInvent.ItemRouteId;
                        reqPO.ItemBomId          = forecastInvent.ItemBOMId;

                        reqPO.ReqDate            = forecastDate;
                        reqPO.ReqTime            = 0;

                        reqPO.initFromSetupDim(setupDim);

                        if (reqPO.RefType == ReqRefType::ItemPlannedOrder)
                        {
                            reqPO.VendId        = forecastPurch.VendAccountId;
                            reqPO.VendGroupId   = forecastPurch.VendGroupId;

                            if (! reqPO.VendGroupId && reqPO.VendId)
                            {
                                reqPO.VendGroupId  = _setup.vendGroupId(reqPO.VendId);
                            }
                        }

                        reqPO.Qty               = forecastQty;
                        reqPO.initPurchQty();

                        reqPO.initLeadTime(setupDim);

                        if (! reqPO.VendId)
                        {
                            reqPO.initVendId(setupDim,reqPlanData);
                        }

                        reqPO.initFromReqDate(setupDim,reqPlanData);
                        reqPO.initFromSetup(_setup
                                            , reqPlanData.reqTraceLogger()
                                            );

                        // Create planned order
                        reqPO.insert(reqPlanData);

                        reqTrans.clear();
                        reqTrans.ReqDateDlvOrig     = reqPO.ReqDateDlv;

                        reqTransPOCreate.insertFromReqPo(reqTrans, reqPO, maxChildThreads > 0, reqPlanData, setupDim);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertItemInventSum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts <c>InventSum</c> items as <c>ReqTrans</c> records.
    /// </summary>
    /// <param name = "_setup">The master planning <c>ReqSetup</c> instance for the item.</param>
    /// <param name = "_onlyPhysicalInvent">A <c>boolean</c> value indicating if only physical inventory is specified.</param>
    /// <returns>A container with [loopIssue, loopReceipt] boolean values.</returns>
    protected container insertItemInventSum(ReqSetup _setup, boolean _onlyPhysicalInvent)
    {
        if (!reqPlanData.useInventOnHands())
        {
            // Return true for loopIssue and loopReceipt
            return [true, true];
        }

        boolean batchSplitRun = false;
        boolean useShelfLife  = false;
        boolean batchCheck = #PdsEnabled && _setup.inventTable().isItemBatchActivated();

        PdsBatchDispNettableCheck nettableCheck;

        if (batchCheck)
        {
            nettableCheck = PdsBatchDispNettableCheck::construct();
            batchSplitRun = !_setup.inventDimParmCov().isFieldIdEnabled(fieldNum(InventDim,InventBatchId));
            useShelfLife  = this.isUseShelfLifeEnabled(_setup, batchSplitRun);
        }

        QueryRun queryRunInventSum = new QueryRun(this.buildInventSumQuery(_setup, _onlyPhysicalInvent));
        return this.executeInventSumQueryRun(queryRunInventSum, _setup, _onlyPhysicalInvent, batchCheck, batchSplitRun, useShelfLife, nettableCheck);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUseShelfLifeEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if shelf life functionality is enabled.
    /// </summary>
    /// <param name = "_setup">The master planning <c>ReqSetup</c> instance for the item.</param>
    /// <param name = "_batchSplitRun">A <c>boolean</c> value indicating if batch split run.</param>
    /// <returns>true if shelf life functionality is enabled; otherwise, false.</returns>
    protected boolean isUseShelfLifeEnabled(ReqSetup _setup, boolean _batchSplitRun)
    {
        return _batchSplitRun && reqPlanData.pdsUseShelfLife() && _setup.inventTable().PdsShelfLife;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeInventSumQueryRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs through the <c>InventSum</c> record's <c>Query</c> instance and inserts relevant records.
    /// </summary>
    /// <param name = "queryRunSum">The <c>InventSum</c> query.</param>
    /// <param name = "_setup">The master planning <c>ReqSetup</c> instance for the item.</param>
    /// <param name = "_onlyPhysicalInvent">A <c>boolean</c> value indicating if only physical inventory is specified.</param>
    /// <param name = "_batchCheck">A <c>boolean</c> value indicating if batch is specified.</param>
    /// <param name = "_batchSplitRun">A <c>boolean</c> value indicating if batch split run.</param>
    /// <param name = "_useShelfLife">A <c>boolean</c> value indicating if shelf life usage is specified.</param>
    /// <param name = "_nettableCheck">A <c>PdsBatchDispNettableCheck</c> instance.</param>
    /// <returns>A <c>container</c> with [loopIssue, loopReceipt] boolean values.</returns>
    protected container executeInventSumQueryRun(QueryRun queryRunSum,
                                                  ReqSetup _setup,
                                                  boolean _onlyPhysicalInvent,
                                                  boolean _batchCheck,
                                                  boolean _batchSplitRun,
                                                  boolean _useShelfLife,
                                                  PdsBatchDispNettableCheck _nettableCheck)
    {
        ReqTrans reqTrans;
        boolean loopReceipt, loopIssue;
        var reqTransBuffer = new ReqTransOnHandInsertBuffer(reqPlanData, reqTransCache);
        
        while (queryRunSum.next())
        {
            InventSum inventSum = queryRunSum.get(tableNum(InventSum));
            InventDim inventDim = queryRunSum.get(tableNum(InventDim));

            boolean writeSum = true;

            if (_batchCheck)
            {
                if (_batchSplitRun)
                {
                    // Avoid processing queryIntSum duplicated when inventDim field value isn't changed
                    if (!queryRunSum.changed(tableNum(InventDim)))
                    {
                        continue;
                    }

                    InventLocation inventLocation;

                    if (_setup.isInventLocationNotCovPlanned())
                    {
                        inventLocation = queryRunSum.get(tableNum(InventLocation));
                    }

                    if (this.isInventLocationManual(inventLocation, _setup))
                    {
                        continue;
                    }

                    writeSum = false;
                    
                    QueryRun queryIntSumRun = new QueryRun(this.buildInventIntSumQuery(_setup, _onlyPhysicalInvent, inventDim));

                    inventSum.pdsClearSum();

                    while (queryIntSumRun.next())
                    {
                        InventSum inventIntSum = queryIntSumRun.get(tableNum(InventSum));
                        InventDim inventIntDim = queryIntSumRun.get(tableNum(InventDim));

                        if (this.includeBatchInventSum(inventIntSum, inventIntDim, queryIntSumRun, _setup, _nettableCheck))
                        {
                            if (!_useShelfLife)
                            {
                                if (InventDim::isInventDimEqualCovDim(_setup.inventDimGroupSetup(), inventDim, inventIntDim))
                                {
                                    inventSum.pdsAddSum(inventIntSum);
                                }
                                writeSum = true;
                            }
                            else
                            {
                                // write the record immediately, to the buffer, to try to collapse 'similar' batches, into single ReqTrans.
                                // Note that the the InventDimId of the original InventSum will be used so the Batch will not be part of the dimension
                                [loopIssue, loopReceipt] = this.writeInventSum(inventIntSum, inventDim, inventIntDim, queryIntSumRun, _setup, reqTrans, reqTransBuffer, _onlyPhysicalInvent, loopIssue, loopReceipt);
                            }
                        }
                    }
                }
                else
                {
                    writeSum = this.includeBatchInventSum(inventSum, inventDim, queryRunSum, _setup, _nettableCheck);
                }
            }

            if (writeSum)
            {
                [loopIssue, loopReceipt] = this.writeInventSum(inventSum, inventDim, inventDim, queryRunSum, _setup, reqTrans, reqTransBuffer, _onlyPhysicalInvent, loopIssue, loopReceipt);
            }
        }

        reqTransBuffer.flush();

        return [loopIssue, loopReceipt];
    }

]]></Source>
			</Method>
			<Method>
				<Name>includeBatchInventSum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates based on the <c>InventDim</c> batch record if the <c>InventSum</c> record should be included.
    /// </summary>
    /// <param name = "_inventSum">The <c>InventSum</c> record to be included.</param>
    /// <param name = "_inventDimBatch">The batch <c>InventDim</c> to validate.</param>
    /// <param name = "_queryRunSum">The related <c>InventSum</c> query.</param>
    /// <param name = "_setup">The master planning <c>ReqSetup</c> instance for the item.</param>
    /// <param name = "_nettableCheck">A <c>PdsBatchDispNettableCheck</c> instance.</param>
    /// <returns>true if the <c>InventSum</c> record should be included; otherwise, false.</returns>
    protected boolean includeBatchInventSum(InventSum _inventSum,
                                          InventDim _inventDimBatch,
                                          QueryRun _queryRunSum,
                                          ReqSetup _setup,
                                          PdsBatchDispNettableCheck _nettableCheck)
    {
        InventLocation inventLocation;

        if (_setup.isInventLocationNotCovPlanned())
        {
            inventLocation = _queryRunSum.get(tableNum(InventLocation));
        }

        if (this.isInventLocationManual(inventLocation, _setup))
        {
            return false;
        }

        InventBatch inventBatch = InventBatch::find(_inventDimBatch.InventBatchId, _inventSum.ItemId);
        _nettableCheck.parmBatch(inventBatch);

        if (!_nettableCheck.checkInclude())
        {
            return false;
        }

        return this.includeBatchInventSumIsEnabled || this.allowBatch(_nettableCheck, inventBatch);
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if batch should be allowed.
    /// </summary>
    /// <param name = "_nettableCheck">A <c>PdsBatchDispNettableCheck</c> instance.</param>
    /// <param name = "_inventBatch">The <c>InventBatch</c> record to check.</param>
    /// <returns>true if batch is allowed; otherwise, false.</returns>
    protected boolean allowBatch(PdsBatchDispNettableCheck _nettableCheck, InventBatch _inventBatch)
    {
        date todaysdateValue = this.fixedTodaysDateForExpiryCheckIsEnabled ? ReqPlanData.todaysdate() : todaysDate;
        return !(reqPlanData.pdsUseShelfLife() && !InventBatch::pdsCheckExpiryDate(_inventBatch.InventBatchId, _inventBatch.ItemId, todaysdateValue, false));
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasPhysicalyInvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the <c>InventSum</c> has physical inventory.
    /// </summary>
    /// <param name = "_inventSum">
    /// An <c>InventSum</c> record buffer.
    /// </param>
    /// <returns>
    /// true if the <c>InventSum</c> has physical inventory; otherwise, false.
    /// </returns>
    protected boolean hasPhysicalyInvent(InventSum _inventSum)
    {
        return _inventSum.PhysicalInvent != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeInventSum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Writes the <c>InventSum</c> record as a <c>ReqTrans</c> record.
    /// </summary>
    /// <param name = "_inventSum">The <c>InventSum</c> record to be written.</param>
    /// <param name = "_inventDim">The related <c>InventDim</c> record.</param>
    /// <param name = "_inventDimBatch">The related <c>InventDim</c> batch record.</param>
    /// <param name = "_queryRunSum">The related <c>InventSum</c> query.</param>
    /// <param name = "_setup">The master planning <c>ReqSetup</c> instance for the item.</param>
    /// <param name = "_recordInsertList">A <c>RecordInsertList</c> instance.</param>
    /// <param name = "_onlyPhysicalInvent">A <c>boolean</c> value indicating if only physical inventory is specified.</param>
    /// <param name = "_loopIssue">A <c>boolean</c> value indicating if there is a loop issue.</param>
    /// <param name = "_loopReceipt">A <c>boolean</c> value indicating if there is a loop receipt.</param>
    /// <returns>A <c>container</c> with [loopIssue, loopReceipt] boolean values.</returns>
    private container writeInventSum(InventSum _inventSum,
                                    InventDim _inventDim,
                                    InventDim _inventDimBatch,
                                    QueryRun _queryRunSum,
                                    ReqSetup _setup,
                                    ReqTrans _reqTrans,
                                    ReqTransOnHandInsertBuffer _reqTransBuffer,
                                    boolean _onlyPhysicalInvent,
                                    boolean _loopIssue,
                                    boolean _loopReceipt)
    {
        InventLocation inventLocation;
        
        if (_setup.isInventLocationNotCovPlanned())
        {
            inventLocation = _queryRunSum.get(tableNum(InventLocation));
        }

        if (this.isInventLocationManual(inventLocation, _setup))
        {
            return [_loopIssue, _loopReceipt];
        }

        if (!_onlyPhysicalInvent)
        {
            _loopIssue = _loopIssue || _inventSum.OnOrder || _inventSum.QuotationIssue;

            if (!_loopIssue)
            {
                InventIAvailability inventAvailability = InventAvailabilityProvider::findByItemDim(_setup.inventTable(), _inventDimBatch).parmInventAvailability();
                _loopIssue = _loopIssue || inventAvailability.reservOrdered() || inventAvailability.reservPhysical();
            }

            _loopReceipt = _loopReceipt || _inventSum.Arrived || _inventSum.Ordered || _inventSum.QuotationReceipt;
        }

        if (this.hasPhysicalyInvent(_inventSum))
        {
            ReqSetupDim setupDim = reqPlanData.newReqSetupDim(_setup, InventDim::findOrCreate(_inventDim).InventDimId);
            
            if (setupDim.mustReqBeCreated())
            {
                this.initTransFromInventSum(_reqTrans, _setup, setupDim, _inventSum);
                this.pdsApplyExpiryDate(_reqTrans, _inventDimBatch);

                _reqTransBuffer.add(_reqTrans);
            }
        }

        return [_loopIssue, _loopReceipt];
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildInventSumQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>InventSum</c> query based on the <c>ReqSetup</c> instance's related <c>InventTable</c> table.
    /// </summary>
    /// <param name = "_setup">The master planning <c>ReqSetup</c> instance for the item.</param>
    /// <param name = "_onlyPhysicalInvent">A <c>boolean</c> value indicating if only physical inventory is specified.</param>
    /// <returns>A <c>Query</c> instance.</returns>
    protected Query buildInventSumQuery(ReqSetup _setup, boolean _onlyPhysicalInvent)
    {
        mapQueryInventSum = !mapQueryInventSum ? new Map(Types::String,Types::Class) : mapQueryInventSum;
        
        InventDimGroupSetup inventDimGroupSetup = InventDimGroupSetup::newInventTable(_setup.inventTable());

        Query querySum;

        if (!mapQueryInventSum.exists(inventDimGroupSetup.hashString()))
        {
            querySum = this.newQueryInventSum(_setup, _onlyPhysicalInvent);
            mapQueryInventSum.insert(inventDimGroupSetup.hashString(), querySum);
        }
        else
        {
            querySum = mapQueryInventSum.lookup(inventDimGroupSetup.hashString());
        }

        querySum.dataSourceTable(tableNum(InventSum)).findRange(fieldNum(InventSum, ItemId)).value(queryValue(_setup.itemId()));

        return querySum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildInventIntSumQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>InventSum</c> query using the found <c>InventDim</c> as filter, with batch enabled.
    /// </summary>
    /// <param name = "_setup">The master planning <c>ReqSetup</c> instance for the item.</param>
    /// <param name = "_onlyPhysicalInvent">A <c>boolean</c> value indicating if only physical inventory is specified.</param>
    /// <param name = "_inventDim">The related <c>InventDim</c> record.</param>
    /// <returns>A <c>Query</c> instance.</returns>
    protected Query buildInventIntSumQuery(ReqSetup _setup, boolean _onlyPhysicalInvent, InventDim _inventDim)
    {
        Query queryIntSum = this.newQueryInventSum(_setup, _onlyPhysicalInvent, true, _inventDim);
        queryIntSum.dataSourceTable(tableNum(InventSum)).findRange(fieldNum(InventSum, ItemId)).value(queryValue(_setup.itemId()));
        
        return queryIntSum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertItemInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts <c>InventTrans</c> items as <c>ReqTrans</c> records.
    /// </summary>
    /// <param name = "_setup">The master planning <c>ReqSetup</c> instance for the item.</param>
    /// <param name = "_inventTransId">The <c>InventTransId</c> value.</param>
    /// <param name = "_loopIssue">A <c>boolean</c> value indicating if there is a loop issue.</param>
    /// <param name = "_loopReceipt">A <c>boolean</c> value indicating if there is a loop receipt.</param>
    protected void insertItemInventTrans(ReqSetup        _setup,
                                         InventTransId   _inventTransId  = '',
                                         boolean         _loopIssue      = true,
                                         boolean         _loopReceipt    = true)
    {
        if (!_loopIssue && !_loopReceipt)
        {
            return;
        }

        if (reqPlanData.useMovements())
        {
            RecordInsertList recordInsertList = reqPlanData.useInsertList() ? new RecordInsertList(tableNum(ReqTrans), true) : null;
            try
            {
                if (_loopReceipt && _loopIssue)
                {
                    reqTransNeutralTracker = new ReqTransNeutralTracker_Insert();
                }

                if (_loopReceipt)
                {
                    Query    inventTransReceiptQuery = this.buildInventTransQuery(this.newQueryInventTransReceipt(_setup, _inventTransId), _setup);
                    QueryRun inventTransReceiptQueryRun = new QueryRun(inventTransReceiptQuery);
                    this.buildInventTransItemIntoRecordInsertList(inventTransReceiptQueryRun, _setup, recordInsertList);
                }
        
                if (_loopIssue)
                {
                    Query    inventTransIssueQuery = this.buildInventTransQuery(this.newQueryInventTransIssue(_setup, _inventTransId), _setup);
                    QueryRun inventTransIssueQueryRun = new QueryRun(inventTransIssueQuery);
                    this.buildInventTransItemIntoRecordInsertList(inventTransIssueQueryRun, _setup, recordInsertList);
                }

                if (reqTransNeutralTracker)
                {
                    reqTransNeutralTracker.insertNonNeutralTransactions(recordInsertList, reqPlanData);
                }
            }
            finally
            {
                reqTransNeutralTracker = null;
            }

            if (recordInsertList)
            {
                recordInsertList.insertDatabase();
            }
        }

        if (!reqPlanData.parmUseReqTransCache())
        {
            ReqTrans::bulkInitFromInventTransOrigin(reqPlanData, _setup);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventLocationManual</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the <c>InventLocation</c> record found in the related <c>QueryRun</c> instance is has the Manual field set.
    /// </summary>
    /// <param name = "_inventLocation">A <c>InventLocation</c> table record.</param>
    /// <param name = "_setup">The master planning <c>ReqSetup</c> instance for the item.</param>
    /// <returns>true if it is set to manual; otherwise, false.</returns>
    private boolean isInventLocationManual(InventLocation _inventLocation, ReqSetup _setup)
    {
        if (_inventLocation)
        {
            return _inventLocation.Manual;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildInventTransQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>Query</c> instance with the relevant ranges for the provided <c>InventTrans</c> query.
    /// </summary>
    /// <param name = "_query">An <c>InventTrans</c> query.</param>
    /// <param name = "_setup">The master planning <c>ReqSetup</c> instance for the item.</param>
    /// <returns>A new <c>Query</c> with the relevant <c>InventTrans</c> ranges.</returns>
    protected Query buildInventTransQuery(Query _query, ReqSetup _setup)
    {
        if (_query)
        {
            _query.dataSourceTable(tableNum(InventTransOrigin)).findRange(fieldNum(InventTransOrigin,ItemId)).value(queryValue(_setup.itemId()));
            SysQuery::findOrCreateRange(_query.dataSourceTable(tableNum(InventTrans)), fieldNum(InventTrans,ItemId)).value(queryValue(_setup.itemId()));
        }

        return _query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildInventTransItemIntoRecordInsertList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds <c>RecordInsertList</c> instance by inserting valid <c>InventTrans</c> item records.
    /// </summary>
    /// <param name = "_inventTransQueryRun">A <c>QueryRun</c> with the relevant <c>InventTrans</c> ranges.</param>
    /// <param name = "_setup">The master planning <c>ReqSetup</c> instance for the item.</param>
    /// <param name = "_recordInsertList">The <c>RecordInsertList</c> instance to have records inserted.</param>
    protected void buildInventTransItemIntoRecordInsertList(QueryRun _inventTransQueryRun, ReqSetup _setup, RecordInsertList _recordInsertList)
    {
        ReqSetupDim setupDim;
        InventDimId inventDimIdOrig;
        ReqTrans    reqTrans;

        while (_inventTransQueryRun.next())
        {
            InventTransOrigin inventTransOrigin = _inventTransQueryRun.get(tableNum(InventTransOrigin));
            InventLocation inventLocation;

            if (_setup.isInventLocationNotCovPlanned())
            {
                inventLocation = _inventTransQueryRun.get(tableNum(InventLocation));
            }

            if (this.mustSkipInventTrans(_setup, inventTransOrigin, inventLocation))
            {
                continue;
            }

            InventTrans inventTrans = _inventTransQueryRun.get(tableNum(InventTrans));
            InventDim fullInventDim = _inventTransQueryRun.get(tableNum(InventDim));
            InventDim inventDim;

            inventDim.data(fullInventDim);
            inventDim.checkInvalidFieldAccess(false);

            // Even if batch is not a coverage dimension, it could be included for shelf life calculation. We need to clear it out to make sure we don't stamp it on ReqTrans.
            if (inventDim.inventBatchId && !_setup.inventDimParmCov().InventBatchIdFlag)
            {
                inventDim.inventBatchId = '';
            }
            InventDimId inventDimId = InventDim::findOrCreate(inventDim).InventDimId;

            if (this.checkInventDimIdChanged(inventDimId, inventDimIdOrig))
            {
                setupDim = reqPlanData.newReqSetupDim(_setup, inventDimId);
                inventDimIdOrig = inventDimId;
            }

            if (this.checkInsert(inventTrans, inventTransOrigin, setupDim))
            {
                using (var context = ReqCalcCreateDerivedReqTransContext::construct(this.shouldSkipDefaultRequirementTransactionReqTime(inventTrans, inventTransOrigin)))
                {
                    this.initTransFromInventTrans(reqTrans, _setup, setupDim, inventTrans, inventTransOrigin);
                    this.pdsApplyExpiryDate(reqTrans, fullInventDim);

                    if (reqPlanData.parmUseReqTransCache())
                    {
                        reqTrans.initFromInventTransOrigin(inventTransOrigin, setupDim);
                    }

                    if (reqTransNeutralTracker && ReqTransNeutralTracker::canBeNeutralized(reqTrans, _setup))
                    {
                        reqTransNeutralTracker.trackReqTrans(reqTrans);
                    }
                    else if (this.mustInsertReqTransForInventTrans(reqTrans))
                    {
                        reqTrans.insertUsingInsertList(_recordInsertList, reqPlanData);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSkipInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if the inventory transaction must be included in the record sorted list.
    /// </summary>
    /// <param name = "_setup">
    ///     The master planning <c>ReqSetup</c> instance for the item.
    /// </param>
    /// <param name = "_inventTransOrigin">
    ///     A <c>InventTransOrigin</c> table record.
    /// </param>
    /// <param name = "_inventLocation">
    ///     A <c>InventLocation</c> table record.
    /// </param>
    /// <returns>
    ///     true if the inventory transaction must be included in the record sorted list; otherwise, false.
    /// </returns>
    protected boolean mustSkipInventTrans(ReqSetup _setup, InventTransOrigin _inventTransOrigin, InventLocation _inventLocation)
    {
        return (this.isInventLocationManual(_inventLocation, _setup)
                || !this.checkProbability(_inventTransOrigin, reqPlanData.quotationProbabilityId())
                || (_inventTransOrigin.ReferenceCategory == InventTransType::WHSWork && !_setup.inventDimParmCov().WMSLocationIdFlag)
                || (_inventTransOrigin.ReferenceCategory == InventTransType::WHSOrderCommittedReservation && !_setup.inventDimParmCov().WMSLocationIdFlag));
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustInsertReqTransForInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether the <c>ReqTrans</c> record must be inserted for inventory transactions.
    /// </summary>
    /// <param name = "_reqTrans">
    ///     A <c>ReqTrans</c> table record.
    /// </param>
    /// <returns>
    ///     true if the <c>ReqTrans</c> record must be inserted for inventory transactions; otherwise, false.
    /// </returns>
    protected boolean mustInsertReqTransForInventTrans(ReqTrans _reqTrans)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInsert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the <c>InventTrans</c> and <c>InventTransOrigin</c> records should be inserted into the <c>RecordInsertList</c>.
    /// </summary>
    /// <param name = "_inventTrans"> The <c>InventTrans</c> record to check.</param>
    /// <param name = "_inventTransOrigin"> The <c>InventTransOrigin</c> record to check. </param>
    /// <param name = "_setupDim"> The <c>ReqSetupDim</c> instance. </param>
    /// <returns> true if the records should be inserted in the <c>RecordInsertList</c>; otherwise false.</returns>
    protected boolean checkInsert(InventTrans _inventTrans, InventTransOrigin _inventTransOrigin, ReqSetupDim _setupDim)
    {
        return (this.checkInsertInventTransRecord(_inventTrans, _setupDim) && this.checkInsertInventTransOriginRecord(_inventTransOrigin));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInsertInventTransRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the <c>InventTrans</c> record should be inserted into the <c>RecordInsertList</c>.
    /// </summary>
    /// <param name = "_inventTrans">The <c>InventTrans</c> record to check.</param>
    /// <param name = "_setupDim">The <c>ReqSetupDim</c> instance.</param>
    /// <returns>true if the record should be inserted; otherwise, false.</returns>
    protected boolean checkInsertInventTransRecord(InventTrans _inventTrans, ReqSetupDim _setupDim)
    {
        return this.checkReqPlanCreationValid(_setupDim.mustReqBeCreated(), _inventTrans.DateStatus, _setupDim)
               && (this.isInventTransUpdatedEstimated(_inventTrans) || this.inventTransUseQuotationsOrRequestsForQuote(_inventTrans));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInsertInventTransOriginRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the inventory transactions should be inserted into the record list.
    /// </summary>
    /// <param name = "_inventTransOrigin">The inventory transactions originator table record to check.</param>
    /// <returns>true if the record should be inserted; otherwise, false.</returns>
    protected boolean checkInsertInventTransOriginRecord(InventTransOrigin _inventTransOrigin)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInventDimIdChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the <c>InventDimId</c> has changed.
    /// </summary>
    /// <param name = "_inventDimId">The <c>InventDimId</c> to check.</param>
    /// <param name = "_inventDimIdOrig">The original <c>InventDimId</c>.</param>
    /// <returns>true if changed; otherwise, false.</returns>
    protected boolean checkInventDimIdChanged(InventDimId _inventDimId, InventDimId _inventDimIdOrig)
    {
        return (_inventDimId != _inventDimIdOrig || !_inventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventTransUpdatedEstimated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the <c>InventTrans</c> updated record was estimated.
    /// </summary>
    /// <param name = "_inventTrans">The <c>InventTrans</c> record to check.</param>
    /// <returns>true if the record was estimated; otherwise, false.</returns>
    protected boolean isInventTransUpdatedEstimated(InventTrans _inventTrans)
    {
        return _inventTrans.isUpdatedEstimated();
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransUseQuotationsOrRequestsForQuote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the <c>InventTrans</c> record is set to include sales quotations or requests for quotation.
    /// </summary>
    /// <param name = "_inventTrans">The <c>InventTrans</c> record to check.</param>
    /// <returns>true if set to include sales quotations or requests for quotation; otherwise, false.</returns>
    protected boolean inventTransUseQuotationsOrRequestsForQuote(InventTrans _inventTrans)
    {
        return ((reqPlanData.useQuotations() && _inventTrans.StatusIssue == StatusIssue::QuotationIssue) // Include sales quotations
               || (reqPlanData.useRequestsForQuote() && _inventTrans.StatusReceipt == StatusReceipt::QuotationReceipt)); // Include request for quotation
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkReqPlanCreationValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the <c>ReqPlan</c> creation is valid.
    /// </summary>
    /// <param name = "_mustCreateReq">Boolean indicating if req must be created.</param>
    /// <param name = "_inventTransDateStatus"><c>DateStatus</c> for the <c>InventTrans</c> record.</param>
    /// <param name = "_setupDim">A <c>ReqSetupDim</c> instance.</param>
    /// <returns>true if the creation is valid; otherwise, false.</returns>
    protected boolean checkReqPlanCreationValid(boolean _mustCreateReq, DateStatus _inventTransDateStatus, ReqSetupDim _setupDim)
    {
        DateStatus maxDateStatus = reqPlanData.todaysdate() + reqPlanData.timeFenceCoverage(_setupDim);
        return _mustCreateReq && _inventTransDateStatus < maxDateStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreateSafetyInvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether safety stock transactions needs to be created.
    /// </summary>
    /// <param name = "_reqItemTable">
    /// An item coverage record buffer.
    /// </param>
    /// <param name = "_setup">
    /// A <c>ReqSetup</c> object.
    /// </param>
    /// <param name = "_inventDimGroupSetup">
    /// An <c>InventDimGroupSetup</c> object.
    /// </param>
    /// <returns>
    /// true if safety stock transactions needs to be created; otherwise, false.
    /// </returns>
    protected boolean mustCreateSafetyInvent(ReqItemTable _reqItemTable, ReqSetup _setup, InventDimGroupSetup _inventDimGroupSetup)
    {
        ReqSetupDim     setupDim;

        if (_reqItemTable.allCovDimSpecified(_inventDimGroupSetup))
        {
            setupDim = reqPlanData.newReqSetupDim(_setup, _reqItemTable.CovInventDimId);

            if (setupDim.mustReqBeCreated() &&
                setupDim.isMinInventOnHandSet())
            {
                return true;
            }
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInsertItemSafetyInventQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates query object for safety stock transactions.
    /// </summary>
    /// <param name = "_setup">
    /// A <c>ReqSetup</c> object.
    /// </param>
    /// <returns>
    /// The query object.
    /// </returns>
    protected Query createInsertItemSafetyInventQuery(ReqSetup _setup)
    {
        Query                   query = new Query();
        QueryBuildDataSource    qbdsReqItemTable;

        qbdsReqItemTable = query.addDataSource(tableNum(ReqItemTable));
        
        qbdsReqItemTable.addRange(fieldNum(ReqItemTable, ItemId)).value(queryValue(_setup.itemId()));
        
        qbdsReqItemTable.addRange(fieldNum(ReqItemTable, MinInventOnhand)).value(strFmt('(%1 > 0)', fieldStr(ReqItemTable, MinInventOnhand)));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertItemSafetyInvent</Name>
				<Source><![CDATA[
    protected void insertItemSafetyInvent(ReqSetup _setup)
    {
        ReqItemTable                reqItemTable;
        ItemId                      itemId = _setup.itemId();

        using (ReqCalcCreateSafetyInventContext rilContext = ReqCalcCreateSafetyInventContext::create())
        {
            InventDimGroupSetup inventDimGroupSetup = InventDimGroupSetup::newItemId(itemId);
            QueryRun queryRun = new QueryRun(this.createInsertItemSafetyInventQuery(_setup));
            while (queryRun.next())
            {
                reqItemTable = queryRun.get(tableNum(ReqItemTable));

                if (this.mustCreateSafetyInvent(reqItemTable, _setup, inventDimGroupSetup))
                {
                    ReqSetupDim setupDim = reqPlanData.newReqSetupDim(_setup, reqItemTable.CovInventDimId);
                    this.createSafetyInvent(setupDim,false);
                }
            }

            rilContext.insertDatabase();
        }  
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertKanbanLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the Kanban picking list lines for a Kanban to the cache for processing.
    /// </summary>
    /// <param name="_kanban">
    /// The record identifier of the Kanban
    /// </param>
    protected void insertKanbanLines(RefRecId _kanban)
    {
        KanbanJobPickingList                kanbanJobPickingList;
        InventTransOriginKanbanJobPickList  inventTransOriginKanbanJobPickList;
        InventTransOrigin                   inventTransOrigin;

        while select ItemId, InventDimId from kanbanJobPickingList
            where kanbanJobPickingList.Kanban == _kanban
            join InventTransOrigin from inventTransOriginKanbanJobPickList
                where inventTransOriginKanbanJobPickList.KanbanJobPickingList == kanbanJobPickingList.RecId
            join ReferenceId from inventTransOrigin
                where inventTransOrigin.RecId == inventTransOriginKanbanJobPickList.InventTransOrigin
        {
            this.updateReqTransUpdate(kanbanJobPickingList.ItemId);

            this.addRef2ReqTransCache(ReqRefType::KanbanLine,
                                      inventTransOrigin.ReferenceId,
                                      inventTransOriginKanbanJobPickList.InventTransOrigin,
                                      false,
                                      InventDistinctProduct::find(kanbanJobPickingList.ItemId, kanbanJobPickingList.InventDimId).Level);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertKanbanTransferIssue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the transfer issues for a withdrawal kanban to the cache for processing.
    /// </summary>
    /// <param name="_kanban">
    /// The record identifier of the Kanban.
    /// </param>
    protected void insertKanbanTransferIssue(RefRecId _kanban)
    {
        Kanban                              kanban;
        KanbanJob                           kanbanJob;
        InventTransOriginKanbanJobTrsIssue  inventTransOriginKanbanJobTrsIssue;
        InventTransOrigin                   inventTransOrigin;
        boolean                             addedToCache = false;

        while select ItemId, InventDimId from kanban
            where kanban.RecId == _kanban
            join RecId from kanbanJob
                where kanbanJob.Kanban == kanban.RecId
            join InventTransOrigin from inventTransOriginKanbanJobTrsIssue
                where inventTransOriginKanbanJobTrsIssue.KanbanJob == kanbanJob.RecId
            join ReferenceId from inventTransOrigin
                where inventTransOrigin.RecId == inventTransOriginKanbanJobTrsIssue.InventTransOrigin
        {
            this.updateReqTransUpdate(kanban.ItemId);

            addedToCache = this.addRef2ReqTransCache(ReqRefType::KanbanLine,
                                      inventTransOrigin.ReferenceId,
                                      inventTransOriginKanbanJobTrsIssue.InventTransOrigin,
                                      false,
                                      InventDistinctProduct::find(kanban.ItemId, kanban.InventDimId).Level);

            if (addedToCache)
            {
                // Need to rerun the level as the transaction might have a "warehouse level" that has already been processed
                recalculateSameItemAgain = true;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertPlanningItemSupply</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts planning item supply into the current requirement profile.
    /// </summary>
    public void insertPlanningItemSupply()
    {
        Query                   query;
        QueryRun                queryRun;
        ReqSetupDim             reqSetupDim;
        InventDimGroupSetup     inventDimGroupSetup;
        InventTable             inventTable;
        InventDim               inventDim;
        InventDimId             prevInventDimId;
        ReqTrans                reqTrans;
        RecordInsertList        reqTransInsertList;
        ProdTable               prodTable;
        ItemId                  prevItemId;
        ReqPlanningItemHelper   planningItemHelper;

        if (!this.mustInsertPlanningItemSupply())
        {
            return;
        }

        planningItemHelper = ReqPlanningItemHelper::construct();

        try
        {
            ttsbegin;

            this.cleanupPlanningItemTransactions(planningItemHelper);

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            if (this.manageExceptionDeadLock())
            {
                retry;
            }
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (this.retryTransientSqlConnectionError())
            {
                retry;
            }
            else
            {
                throw;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (this.manageExceptionUpdateConflict())
            {
                retry;
            }
        }

        reqTransInsertList = new RecordInsertList(tableNum(ReqTrans), true);

        query = planningItemHelper.createSupplyQuery();
        this.addPlanningItemSupplyFilters(query);

        queryRun = new QueryRun(query);
        queryRun = this.modifyQueryForItemFilter(queryRun);

        while (queryRun.next())
        {
            prodTable = queryRun.get(prodTable.TableId);
            inventTable = queryRun.get(inventTable.TableId);
            inventDim = queryRun.get(inventDim.TableId);

            if (prodTable.ItemId != prevItemId)
            {
                inventDimGroupSetup = InventDimGroupSetup::newInventTable(inventTable);
                prevInventDimId = '';
            }

            if (inventDim.InventDimId != prevInventDimId)
            {
                reqSetupDim = this.getSetupDim(prodTable.ItemId, inventDim.reqCovDimId(inventDimGroupSetup));
                prevInventDimId = inventDim.InventDimId;
            }

            reqTrans = planningItemHelper.initProductionReqTrans(prodTable, reqPlanData.parmReqPlanVersionRefRecId(),
                inventTable, reqSetupDim);

            reqTrans.insertUsingInsertList(reqTransInsertList, reqPlanData);

            prevItemId = prodTable.ItemId;
        }

        reqTransInsertList.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertProdBOM</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the BOM lines for a Production order to the cache for processing.
    /// </summary>
    /// <param name="_prodId">
    /// The Id of the production order.
    /// </param>
    /// <param name="_deleteMarking">
    /// A <c>boolean</c> value that indicates if marking should be deleted; optional.
    /// </param>
    protected void insertProdBOM(ProdId _prodId,
                                 boolean _deleteMarking = false)
    {
        ProdBOM                     prodBOM;
        InventTransOriginProdBOM    inventTransOriginProdBOM;
        InventMovement              movement;

        while select forupdate prodBOM
            where prodBOM.ProdId == _prodId
            join InventTransOrigin from inventTransOriginProdBOM
                where inventTransOriginProdBOM.ProdBOMDataAreaId    == prodBOM.DataAreaId
                    && inventTransOriginProdBOM.ProdBOMInventTransId == prodBOM.InventTransId
        {
            if (_deleteMarking && prodBOM.ProdLineType == BOMType::Item)
            {
                movement = InventMovement::construct(prodBOM);
                if (movement)
                {
                    InventUpd_Reservation::deleteReserveRefTransId(movement,true);
                }
            }

            this.updateReqTransUpdate(prodBOM.ItemId);

            this.addRef2ReqTransCache(ReqRefType::ProdLine,
                                        _prodId,
                                        inventTransOriginProdBOM.InventTransOrigin,
                                        false,
                                        InventDistinctProduct::find(prodBom.ItemId, prodBom.InventDimId).Level);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertProdCoBy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the co-product lines for a production order to the cache for processing.
    /// </summary>
    /// <param name="_prodId">
    /// The ID of the production order.
    /// </param>
    protected void insertProdCoBy(ProdId _prodId)
    {
        PmfProdCoBy                     prodCoBy;
        InventTransOriginPmfProdCoBy    inventTransOriginProdCoBy;

        while select forupdate prodCoBy
            where prodCoBy.ProdId == _prodId
            join InventTransOrigin from inventTransOriginProdCoBy
                where inventTransOriginProdCoBy.PmfProdCoByDataAreaId   == prodCoBy.DataAreaId
                    && inventTransOriginProdCoBy.PmfProdCoByRecId       == prodCoBy.RecId
        {
            this.updateReqTransUpdate(prodCoBy.ItemId);

            this.addRef2ReqTransCache(ReqRefType::PmfCoProduct,
                                        _prodId,
                                        inventTransOriginProdCoBy.InventTransOrigin,
                                        false,
                                        InventDistinctProduct::find(prodCoBy.ItemId, prodCoBy.InventDimId).Level);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertReqLog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts a record in the master planning log table.
    /// </summary>
    /// <param name="_canceled">
    ///    true if the master planning thread has been canceled; false if the master planning thread has not
    ///    been canceled.
    /// </param>
    protected void insertReqLog(boolean _canceled)
    {
        // we cannot log anything without a reqPlanData instance since we
        // don't know the ReqPlanId anyway
        if (!reqPlanData)
        {
            return;
        }

        isReqLogMerged = true;

        try
        {
            reqPlanData.insertReqLog(_canceled,
                                     hasErrors || resumeProcessId,
                                     this.isCompleteUpdate(),
                                     numOfChanges,
                                     processId,
                                     comment);
        }
        catch (Exception::Deadlock)
        {
            if (this.manageExceptionDeadLock())
            {
                retry;
            }
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (this.retryTransientSqlConnectionError())
            {
                retry;
            }
            else
            {
                throw;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if ( this.manageExceptionUpdateConflict() )
            {
                retry;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>invokeCompletedEvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Invokes MRP completed application event.
    /// </summary>
    protected void invokeCompletedEvent()
    {
        if (!this.parmThisIsChildThread())
        {
            ReqCalcTelemetry::invokeCompletedEvent(reqPlanId, processId, reqPlanData, this);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>invokeStartedEvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Invokes MRP started application event.
    /// </summary>
    protected void invokeStartedEvent()
    {
        if (!this.parmThisIsChildThread())
        {
            instrumentationActivityContext = this.initiateInstrumentationContext();

            ReqCalcTelemetry::invokeStartedEvent(this, reqPlanId, processId, reqPlanData, reqParameters, this.reqInstrumentationLogger());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initiateInstrumentationContext</Name>
				<Source><![CDATA[
    protected SysInstrumentationActivityContext initiateInstrumentationContext()
    {
        return this.reqInstrumentationLogger().calc().run();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqInstrumentationLoggerClassName</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected ClassName reqInstrumentationLoggerClassName()
    {
        return classStr(ReqCalc);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqInstrumentationLogger</Name>
				<Source><![CDATA[
    internal ReqInstrumentationLogger reqInstrumentationLogger()
    {
        if (!reqInstrumentationLogger)
        {
            reqInstrumentationLogger = ReqInstrumentationLogger::createLogger(this.reqInstrumentationLoggerClassName());
        }
        
        return reqInstrumentationLogger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertRequisitionsDemand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts requisition lines demand in the current requirement profile.
    /// Firstly, checking requisition lines that are already covered by firmed others,
    /// Secondly by checking approved requisition lines that do not have any firmed orders.
    /// </summary>
    public void insertRequisitionsDemand()
    {
        this.updateProcessItemsAndDeleteRequisitionReqTrans();
            
        var purchRequisitionsDemandGenerator = ReqPurchaseRequisitionsDemandGenerator::newStandard(this, reqPlanData);

        Query requisitionLinesCoveredByFirmedOrdersQuery = this.requisitionLinesDemandQuery(true);
        Query requisitionLinesNotCoveredByFirmedOrdersQuery = this.requisitionLinesDemandQuery(false);

        purchRequisitionsDemandGenerator.generatePurchaseRequisitionDemands(
            requisitionLinesCoveredByFirmedOrdersQuery,
            requisitionLinesNotCoveredByFirmedOrdersQuery);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProcessItemsAndDeleteRequisitionReqTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Before we insert demand lines for Requisition Lines, we update process items in reqTransCache
    /// and delete all requisition requirement transactions.
    /// </summary>
    private void updateProcessItemsAndDeleteRequisitionReqTrans()
    {
        if (reqCalcUpdate != ReqCalcUpdate::Regeneration)
        {
            try
            {
                ttsbegin;
                reqTransCache.updateReqProcessItemsAllLevels();
                this.deleteRequisitionsReqTrans();
                ttscommit;
            }
            catch (Exception::Deadlock)
            {
                if (this.manageExceptionDeadLock())
                {
                    retry;
                }
            }
            catch (Exception::TransientSqlConnectionError)
            {
                if (this.retryTransientSqlConnectionError())
                {
                    retry;
                }
                else
                {
                    throw;
                }
            }
            catch (Exception::UpdateConflict)
            {
                if (this.manageExceptionUpdateConflict())
                {
                    retry;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTasksForAllItems</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts tasks for all items to be processed for a given status and level state.
    /// </summary>
    /// <param name="_status">
    /// The status for which to insert the tasks.
    /// </param>
    /// <param name="_levelState">
    /// The level state for which to insert the tasks.
    /// </param>
    /// <param name="_uniquePerItem">
    /// A boolean indicating whether this task should be run for the item through all the levels or only a single time.
    /// </param>
    protected void insertTasksForAllItems(ReqProcessStatus  _status,
                                          ReqLevelState     _levelState     = ReqLevelState::NotApplicable,
                                          boolean           _uniquePerItem = false)
    {
        BOMLevel            level;
        Set                 items;

        if (_uniquePerItem)
        {
            level = 0;
            items = reqTransCache.getAllItems();
            reqCalcTaskController.insertTaskBundlesForItems(items, this.parmMaxChildThreads(), _status, level, _levelState);
        }
        else
        {
            reqTransCache.resetLevel();
            while (reqTransCache.moveNextLevel())
            {
                level = reqTransCache.getCurrentLevel();
                items = reqTransCache.getItems(level);

                reqCalcTaskController.insertTaskBundlesForItems(items, this.parmMaxChildThreads(), _status, level, _levelState);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTransferShip</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the issue for a transfer order line to the cache for processing.
    /// </summary>
    /// <param name="_inventTransOriginReceiveRecId">
    /// The record identifier of the <c>InventTransOrigin</c> record of the receipt inventory transaction.
    /// </param>
    protected void insertTransferShip(RefRecId _inventTransOriginReceiveRecId)
    {
        InventTransferLine              inventTransferLine;
        InventTransOrigin               inventTransOriginReceive;
        InventTransOriginTransferShip   inventTransOriginTransferShip;
        InventTransOrigin               inventTransOriginShip;
        boolean                         addedToCache;

        while select ItemId, InventDimId from inventTransferLine
            join TableId from inventTransOriginReceive
                where inventTransOriginReceive.RecId == _inventTransOriginReceiveRecId
                   && inventTransOriginReceive.InventTransId == inventTransferLine.InventTransIdReceive
            join TableId from inventTransOriginTransferShip
                where inventTransOriginTransferShip.TransferShipLineNum == inventTransferLine.LineNum
                   && inventTransOriginTransferShip.TransferShipDataAreaId == inventTransferLine.DataAreaId
                   && inventTransOriginTransferShip.TransferShipId == inventTransferLine.TransferId
            join ReferenceId, RecId from inventTransOriginShip
                where inventTransOriginShip.RecId == inventTransOriginTransferShip.InventTransOrigin
        {
            addedToCache = this.addRef2ReqTransCache(ReqRefType::TransferOrderShip,
                                      inventTransOriginShip.ReferenceId,
                                      inventTransOriginShip.RecId,
                                      false,
                                      InventDistinctProduct::find(inventTransferLine.ItemId, inventTransferLine.InventDimId).Level) || addedToCache;
        }

        if (addedToCache)
        {
            // Need to rerun the level as the transaction might have a "warehouse level" that has already been processed
            recalculateSameItemAgain = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertUnscheduledOrders</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts all orders that have not been scheduled into a table in the database for later scheduling.
    /// </summary>
    /// <param name="_orders">
    ///    A <c>List</c> that contains the orders to be inserted.
    /// </param>
    protected void insertUnscheduledOrders(List _orders)
    {
        ReqUnscheduledOrders    unscheduledOrder;
        ListEnumerator          le;
        RecordInsertList        unscheduledOrdersInsertList;

        // insert the orders on one connection
        if (_orders)
        {
            unscheduledOrdersInsertList = new RecordInsertList(tableNum(ReqUnscheduledOrders));

            le = _orders.getEnumerator();
            while (le.moveNext())
            {
                unscheduledOrder.RefId     = le.current();
                unscheduledOrder.ProcessId = processId;
                unscheduledOrdersInsertList.add(unscheduledOrder);
            }

            unscheduledOrdersInsertList.insertDatabase();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBOMLevelRecalculateAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the item BOM level recalculation can be performed.
    /// </summary>
    /// <returns>
    ///    true if the item BOM level recalculation can be performed; otherwise, false.
    /// </returns>
    protected boolean isBOMLevelRecalculateAllowed()
    {
        return this.getBomLevelCalc().isBOMLevelCalcNeeded();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCompleteUpdate</Name>
				<Source><![CDATA[
    protected boolean isCompleteUpdate()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPreviousReceiptValid</Name>
				<Source><![CDATA[
    [SysObsolete('Use ReqCalcCoverageEngine.isReceiptValidForIssue instead.', false, 30\11\2017)]
    protected boolean isPreviousReceiptValid(
        ReqTrans  _issue,
        TransDate _searchFrom,
        TransDate _searchTo,
        boolean   _bomReq,
        boolean   _routeReq,
        boolean   _searchMarkingInventTransOrigin,
        boolean   _bomVerReq,
        boolean   _routeVerReq)
    {
        ReqCalcCoverageReceiptConstraints constraints = new ReqCalcCoverageReceiptConstraints();
            
        constraints.MinReqDate = _searchFrom;
        constraints.MaxReqDate = _searchTo;
        constraints.MustUseReceiptsWithIssueBOM = _bomReq;
        constraints.MustUseReceiptsWithIssueRoute = _routeReq;
        constraints.MustUseReceiptMarkedWithIssue = _searchMarkingInventTransOrigin;
        constraints.CanUseReceiptsWithForcedBOM = !_bomVerReq || _issue.ItemBomId;
        constraints.CanUseReceiptsWithForcedRoute = !_routeVerReq || _issue.ItemRouteId;
        constraints.CanUseOnHand = true;

        return this.coverageEngineForReqTrans(_issue).isReceiptValidForIssue(previousReceipt, _issue, constraints);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isQtyChangedAndCoveredByOnHand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the quantity has been changed in a transaction covered by on-hand.
    /// </summary>
    /// <param name="_issueInventTransOriginId">
    /// The <c>InventTransOriginId</c> of the issue.
    /// </param>
    /// <param name="_issueRefId">
    /// The <c>InventTransRefId</c> of the issue.
    /// </param>
    /// <param name="_issueRefType">
    /// The <c>ReqRefType</c> of the issue.
    /// </param>
    /// <param name="_qtyChanged">
    /// The <c>Qty</c> of the issue.
    /// </param>
    /// <returns>
    /// true if the quantity is changed; otherwise, false.
    /// </returns>
    public boolean isQtyChangedAndCoveredByOnHand(InventTransOriginId _issueInventTransOriginId, InventTransRefId _issueRefId, ReqRefType _issueRefType, Qty _qtyChanged)
    {
        RefRecId            reqPlanVersionRecId;
        ReqTrans            reqTransIssue;
        ReqTrans            reqTransReceipt;
        ReqTransCov         reqTransCov;

        reqPlanVersionRecId = ReqPlanVersion::findActiveReqPlanIdDynamic().RecId;

        if (reqPlanVersionRecId)
        {
            select count(RecId), sum(CovQty) from reqTransIssue
                where  reqTransIssue.PlanVersion        == reqPlanVersionRecId
                    && reqTransIssue.InventTransOrigin  == _issueInventTransOriginId
                    && reqTransIssue.RefId              == _issueRefId
                    && reqTransIssue.RefType            == _issueRefType
                exists join reqTransCov
                    where reqTransCov.IssueRecId == reqTransIssue.RecId
                exists join reqTransReceipt
                    where reqTransReceipt.RecId == reqTransCov.ReceiptRecId
                    &&  reqTransReceipt.RefType == ReqRefType::InventOnHand;

            if (reqTransIssue.RecId != 0 && reqTransIssue.CovQty != _qtyChanged)
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReqCalcUpdateFixed</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the master scheduling principle is fixed.
    /// </summary>
    /// <returns>
    ///    true if the master scheduling principle is fixed; otherwise, false.
    /// </returns>
    protected boolean isReqCalcUpdateFixed()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReqTransUpdated</Name>
				<Source><![CDATA[
    protected boolean isReqTransUpdated(ItemId _itemId)
    {
        if (! setReqTransUpdated)
        {
            return false;
        }

        return setReqTransUpdated.in(_itemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTimeFenceBackRequisitionFixed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the requisitions time fence is fixed on the plan,
    /// i.e. not item or dimensions dependent.
    /// </summary>
    /// <returns>
    /// True if the requisitions time fence is fixed; otherwise, false.
    /// </returns>
    public boolean isTimeFenceBackRequisitionFixed()
    {
        return ReqPlanSched::find(reqPlanId).TimeFenceBackRequisitionFixed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTimeFenceCoverageFixed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the coverage time fence is fixed on the plan,
    /// i.e. not item or dimensions dependent.
    /// </summary>
    /// <returns>
    /// True if the coverage time fence is fixed; otherwise, false.
    /// </returns>
    public boolean isTimeFenceCoverageFixed()
    {
        return ReqPlanSched::find(reqPlanId).TimeFenceCovFixed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lockDynamicReqPlan</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Locks the default dynamic master plan.
    /// </summary>
    /// <remarks>
    ///     This method is empty.
    /// </remarks>
    protected void lockDynamicReqPlan()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>lockIntercompanyPlanVersions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Locks the plan versions in downstream customer companies, which serve as the source of the planned
    ///    intercompany demand.
    /// </summary>
    /// <param name="_planVersions">
    ///    The set of plan versions to lock.
    /// </param>
    protected void lockIntercompanyPlanVersions(Set _planVersions)
    {
        if (_planVersions)
        {
            SetEnumerator planVersionEnumerator = _planVersions.getEnumerator();
            Set acquiredPlanVersionLocks = new Set(Types::Int64);

            try
            {
                while (planVersionEnumerator.moveNext())
                {
                    RecId planVersionRecId = planVersionEnumerator.current();
                    this.parmReqPlanManager().acquireReaderLockOnPlanVersion(ReqPlanVersion::find(planVersionRecId));
                    acquiredPlanVersionLocks.add(planVersionRecId);
                }
            }
            catch (Exception::Error)
            {
                this.unlockIntercompanyPlanVersions(acquiredPlanVersionLocks);
                throw error(strFmt("@SCM:AppLockAcquireError", planVersionEnumerator.current()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapFindInventDimId</Name>
				<Source><![CDATA[
    protected InventDimId  mapFindInventDimId(
        Map         _mapInventDimId,
        InventDim   _inventDim
        )
    {
        str strDimId = _inventDim.mapKey(InventDim::dimProductDimFieldList()) +'#'+
                       _inventDim.InventLocationId +'#';

        if (_mapInventDimId.exists(strDimId))
        {
            _inventDim.InventDimId = _mapInventDimId.lookup(strDimId);
        }
        else
        {
            _inventDim.InventDimId = InventDim::findOrCreate(_inventDim).InventDimId;

            _mapInventDimId.insert(strDimId,_inventDim.InventDimId);
        }

        return _inventDim.InventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markDelayedScheduledOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks orders as delayed.
    /// </summary>
    /// <param name="_bundleId">
    /// A <c>ReqOrderBundle</c> value that identifies the orders to check and mark as delayed.
    /// </param>
    /// <remarks>
    /// The check for being delayed and delay marking is only done if either futures or actions messages should be processed in  the current run.
    /// </remarks>
    public void markDelayedScheduledOrders(ReqOrderBundle _bundleId)
    {
        ReqUnscheduledOrders    reqUnscheduledOrders;
        ReqTrans                reqTransReceipt;
        ReqTrans                reqTransIssue;
        ReqTransCov             reqTransCov;

        if (!reqPlanData.doFuturesCalc() || !reqPlanData.futuresSched())
        {
            return;
        }

        while select forceselectorder forcenestedloop RefId from reqUnscheduledOrders
            where   reqUnscheduledOrders.ProcessId      == processId
                &&  reqUnscheduledOrders.EngineBundle   == _bundleId
            join firstonly reqTransReceipt
                where   reqTransReceipt.PlanVersion == reqPlanData.parmReqPlanVersionRefRecId()
                    &&  reqTransReceipt.RefId     == reqUnscheduledOrders.RefId
                    &&
                        (
                        reqTransReceipt.RefType         == ReqRefType::BOMPlannedOrder
                            || reqTransReceipt.RefType  == ReqRefType::PmfPlannedProdBatch
                            || reqTransReceipt.RefType  == ReqRefType::PmfCoProduct )
            join firstonly IssueRecId from reqTransCov
                where   reqTransCov.PlanVersion     == reqTransReceipt.PlanVersion
                    &&  reqTransCov.ReceiptRecId  == reqTransReceipt.RecId
            join firstonly reqTransIssue
                where   reqTransIssue.RecId       == reqTransCov.IssueRecId
        {
            reqCalcMarkDelayed.findAndMarkDelayedOrders(reqPlanData, reqTransReceipt, reqTransIssue, reqPlanData.newReqSetupDimReqTrans(reqTransIssue));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrCovContinuityReduce</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates the coverage reduction for continuity forecasting.
    /// </summary>
    /// <param name="_setupDim">
    ///     The setup dimensions to use in the forecast reduction.
    /// </param>
    protected void mcrCovContinuityReduce(ReqSetupDim  _setupDim)
    {
        Map                 mapContinuity;
        MapIterator         mi_continuity;

        Map                 mapPeriods;
        MapIterator         mi_periods;

        ReqTrans            reqTrans;
        ReqTrans            continuity;

        ReqReduceLine       reqReduceLine;
        ReqReduceLine       prvReduceLine;

        TransDate           fromDate;
        TransDate           toDate;
        TransDate           breakEvenDate;

        InventQty           qty;
        QueryRun            queryRun;

        if (reqCalcUpdate == ReqCalcUpdate::Regeneration || reqPlanId != dynamicReqPlanId || ! _setupDim.reqReduceKeyId())
        {
            return;
        }

        if (reqPlanData.mcrUseContinuityPlan() &&
            (reqPlanData.reqReduceType() == ReqReduceType::OpenOrdersReductionKey
            ||  reqPlanData.reqReduceType() == ReqReduceType::OpenOrdersPeriod)
            && ReqTrans::mcrHasSalesContinuity(ReqPlanVersion::findActiveReqPlanId(reqPlanId, curext()).RecId, _setupDim.setup().itemId(), _setupDim.parmCovInventDimId()))
        {
            queryRun = new QueryRun(reqTransCache.issuesQuery(_setupDim.setup().itemId(), _setupDim.parmCovInventDimId()));
            queryRun.next();
            reqTrans = queryRun.get(tableNum(ReqTrans));

            if (reqTrans.RefType == ReqRefType::Sales && reqTrans.openQty() < 0 && reqTrans.ReqDate < reqPlanData.todaysdate() + reqPlanData.timeFenceCoverage(_setupDim))
            {
                if (!mapContinuity)
                {
                    while select forupdate continuity
                        index hint RefIdx
                        where continuity.PlanVersion           == reqTrans.PlanVersion              &&
                                continuity.RefType             == ReqRefType::MCRContinuity          &&
                                continuity.RefId               == ''                                &&
                                continuity.InventTransOrigin   == 0                                &&
                                continuity.ItemId              == reqTrans.ItemId                   &&
                                continuity.CovInventDimId      == reqTrans.CovInventDimId           &&
                                continuity.Direction           == InventDirection::Issue
                    {
                        if (!mapContinuity)
                        {
                            mapContinuity = new Map(typeName2Type(extendedTypeStr(RecId)), Types::Record);
                        }

                        mapContinuity.insert(continuity.RecId, continuity);
                    }
                }
                if (!mapContinuity)
                {
                    return;   // no Continuity exist
                }

                if (!mapPeriods)
                {
                    breakEvenDate = ReqReduceKey::find(_setupDim.reqReduceKeyId()).breakEvenDate(reqPlanData.todaysdate());

                    while select reqReduceLine
                        order by Sort1980
                        where reqReduceLine.ReduceKeyId == _setupDim.reqReduceKeyId()
                    {
                        fromDate = reqReduceLine.fromDate(breakEvenDate, prvReduceLine);
                        toDate   = reqReduceLine.toDate(breakEvenDate);

                        prvReduceLine = reqReduceLine.data();

                        if (toDate >= reqPlanData.todaysdate())
                        {
                            if (!mapPeriods)
                            {
                                mapPeriods = new Map(Types::Date, Types::Date);
                            }

                            mapPeriods.insert(fromDate, toDate);
                        }
                    }
                }

                if (!mapPeriods)
                {
                    return;
                }

                //   find period

                mi_periods = new MapIterator(mapPeriods);
                mi_periods.begin();
                while (mi_periods.more())
                {
                    fromDate = mi_periods.key();
                    toDate   = mapPeriods.lookup(mi_periods.key());

                    if (reqTrans.ReqDate >= fromDate && reqTrans.ReqDate <= toDate)
                    {
                        //    reduce Continuity in period
                        qty = reqTrans.openQty();

                        mi_continuity = new MapIterator(mapContinuity);
                        mi_continuity.begin();
                        while (mi_continuity.more())
                        {
                            continuity = mapContinuity.lookup(mi_continuity.key());

                            if (continuity.ReqDate >= fromDate && continuity.ReqDate <= toDate)
                            {
                                continuity.Qty -= qty;

                                qty = 0;
                                if (continuity.Qty > 0)
                                {
                                    qty = -continuity.Qty;
                                    continuity.delete(reqPlanData, false);
                                }
                                else
                                {
                                    continuity.updateReduceCovQty(reqPlanData);

                                    continuity.update(reqPlanData);
                                }

                                if (qty == 0)
                                {
                                    break;
                                }
                            }
                            mi_continuity.next();
                        }

                        break;
                    }
                    mi_periods.next();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrInsertItemContinuityInvent</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates the planned orders for the continuity forecasting plan.
    /// </summary>
    /// <param name="_setup">
    ///     The setup dimensions to use in the forecast reduction.
    /// </param>
    protected void mcrInsertItemContinuityInvent(ReqSetup _setup)
    {
        this.mcrInsertItemContinuitySales(_setup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrInsertItemContinuitySales</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates the planned orders for the continuity forecasting plan, based on sales order demand.
    /// </summary>
    /// <param name="_setup">
    ///     The setup dimensions to use in the forecast reduction.
    /// </param>
    protected void mcrInsertItemContinuitySales(ReqSetup _setup)
    {
        InventDim                       inventDim;
        ReqSetupDim                     setupDim;
        MCRContinuityCustLine           mcrContinuityCustLine;
        SalesLine                       salesLine;
        InventDimGroupSetup             inventDimGroupSetup;

        RecordInsertList                recordInsertList = reqPlanData.useInsertList()
                                                ? new RecordInsertList(tableNum(ReqTrans), true): null;

        if (reqPlanData.mcrUseContinuityPlan())
        {
            inventDimGroupSetup = InventDimGroupSetup::newItemId(_setup.itemId());

            while select sum(QuantityOrdered), InventDimId,  StartDate  from mcrContinuityCustLine
                group by InventDimId, StartDate
                exists join RecId from salesLine
                where   mcrContinuityCustLine.ItemId           == _setup.itemId()
                    &&  mcrContinuityCustLine.QuantityOrdered   >  0
                    &&  mcrContinuityCustLine.SalesId          == ''
                    &&  mcrContinuityCustLine.ActionCode       != MCRContinuityActionCode::Skip
                    &&  salesLine.InventTransId                == mcrContinuityCustLine.InventTransId
                    &&  salesLine.SalesStatus                  != SalesStatus::Canceled
            {
                inventDim = InventDim::find(mcrContinuityCustLine.InventDimId);

                setupDim = reqPlanData.newReqSetupDim(_setup, inventDim.reqCovDimId(inventDimGroupSetup));

                if (reqPlanData.mcrMustContinuityInventBeCreated(setupDim, mcrContinuityCustLine))
                {
                    ReqTrans reqTrans = this.initItemContinuitySalesReqTrans(_setup, inventDim, setupDim, mcrContinuityCustLine);
                    
                    if (reqTrans.Qty)
                    {
                        reqTrans.insertUsingInsertList(recordInsertList, reqPlanData);
                    }
                }
            }

            if (recordInsertList)
            {
                recordInsertList.insertDatabase();
                reqTransCache.createReqProcessTransFilterRecords();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initItemContinuitySalesReqTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes a <c>ReqTrans</c> record for the <c>mcrInsertItemContinuitySales</c> method.
    /// </summary>
    /// <param name = "_setup">
    ///     The setup dimensions to use in the forecast reduction.
    /// </param>
    /// <param name = "_inventDim">
    ///     The inventory dimensions linked to the <paramref name="_mcrContinuityCustLine" /> record.
    /// </param>
    /// <param name = "_setupDim">
    ///     The setup dimensions based on the <paramref name="_inventDim" /> settings.
    /// </param>
    /// <param name = "_mcrContinuityCustLine">
    ///     The <c>MCRContinuityCustLine</c> record being processed.
    /// </param>
    /// <returns>
    ///     A new <c>ReqTrans</c> record.
    /// </returns>
    protected ReqTrans initItemContinuitySalesReqTrans(
        ReqSetup _setup,
        InventDim _inventDim,
        ReqSetupDim _setupDim,
        MCRContinuityCustLine _mcrContinuityCustLine)
    {
        ReqTrans reqTrans;
        reqTrans.clear();
        reqTrans.PlanVersion        = this.reqPlanVersionRefRecId();
        reqTrans.RefId              = '';
        reqTrans.RefType            = ReqRefType::MCRContinuity;

        reqTrans.ItemId             = _setup.itemId();
        reqTrans.CovInventDimId     = _setupDim.parmCovInventDimId();

        InventTable inventTable     = InventTable::find(_setup.itemId());
        reqTrans.ItemBomId          = inventTable.bomId(reqPlanData.todaysdate(), _mcrContinuityCustLine.QuantityOrdered, _inventDim);
        reqTrans.ItemRouteId        = inventTable.routeId(reqPlanData.todaysdate(), _mcrContinuityCustLine.QuantityOrdered, _inventDim);

        reqTrans.Qty                = -1 * (_mcrContinuityCustLine.QuantityOrdered);
        reqTrans.OriginalQuantity   = reqTrans.Qty;
        reqTrans.ReqDateDlvOrig     = _mcrContinuityCustLine.StartDate;
        reqTrans.IsDerivedDirectly  = NoYes::Yes;

        if (reqTrans.isReceipt())
        {
            reqTrans.ReqDate        = reqPlanData.schedReqDateReceipt(_mcrContinuityCustLine.StartDate, _setupDim);
        }
        else
        {
            reqTrans.ReqDate        = reqPlanData.schedReqDateIssue(_mcrContinuityCustLine.StartDate, _setupDim);
        }

        reqTrans.initFromSetupDim(_setupDim);

        return reqTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrSkipInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns a <c>boolean</c> value indicating whether planning should be
    ///     skipped for the specified <paramref name="_inventTransOrigin" /> record.
    /// </summary>
    /// <param name="_inventTransOrigin">
    ///     The <c>InventTransOrigin</c> record that will be checked.
    /// </param>
    /// <returns>
    ///     true if planning should be skipped; otherwise, false.
    /// </returns>
    /// <remarks>
    ///     Records are skipped if they are drop ship or kit headers.  Kit headers
    ///     are skipped because planned orders should not be created for them and
    ///     so kit component lines will not be planned for twice the quantity.
    /// </remarks>
    private boolean mcrSkipInventTrans(InventTransOrigin _inventTransOrigin)
    {
        SalesLine                   salesLine;
        boolean                     skipInventTrans;
        MCRSalesLineDropShipment    mcrSalesLineDropShipment;
        MCRSalesLine                mcrSalesLine;

        skipInventTrans = false;

        if (_inventTransOrigin.ReferenceCategory == InventTransType::Sales)
        {
            salesLine = SalesLine::findInventTransId(_inventTransOrigin.InventTransId);
            mcrSalesLineDropShipment = salesLine.mcrSalesLineDropShipment();
            mcrSalesLine = salesLine.mcrSalesLine();
            if (mcrSalesLineDropShipment.DropShipment == NoYes::Yes
                || mcrSalesLine.ContinuityScheduleId != '')
            {
                skipInventTrans = true;
            }
        }
        else if (_inventTransOrigin.ReferenceCategory == InventTransType::Purch
                 && PurchLine::findInventTransId(_inventTransOrigin.InventTransId).mcrDropShipment)
        {
            skipInventTrans = true;
        }
        return skipInventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDeleteNeutralTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Defines whether neutral transactions must be deleted.
    /// </summary>
    /// <returns>
    ///     true if neutral transactions must be deleted; otherwise, false.
    /// </returns>
    [SysObsolete('The neutral transaction deletion workflow has changed, to always delete neutral transactions, omitting checking this method.', false, 30\06\2018)]
    public boolean mustDeleteNeutralTransactions()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUseCacheDuringUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the <c>ReqTransCache</c> must be used to track new requirements during the update phase.
    /// </summary>
    /// <returns>true if new requirements must be tracked in the cache; otherwise, false.</returns>
    [Hookable(false)]
    protected boolean mustUseCacheDuringUpdate()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustExplodeNonPlannedReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if non-planned receipts should also be exploded.
    /// </summary>
    /// <returns>
    /// true when non-planned receipts should be exploded; otherwise, false.
    /// </returns>
    protected boolean mustExplodeNonPlannedReceipt()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustInsertPlanningItemSupply</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defines if planning item supply must be inserted.
    /// </summary>
    /// <returns>
    /// true if planning item supply must be inserted; otherwise, false.
    /// </returns>
    public boolean mustInsertPlanningItemSupply()
    {
        //Net change and net change minimized and not updating transactions for planning items
        //because it is not possible to filter out production orders which have to be taken into consideration
        return reqCalcUpdate == ReqCalcUpdate::Regeneration;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();

        reqParameters                   = ReqParameters::find();
        wrkCtrSchedulerRuntimes         = WrkCtrSchedulerRuntimes::construct();
        reqPlanManager                  = ReqPlanManager::construct();

        intercompanyDemandPlanFilter    = ReqIntercompanyDemandPlanFilter::construct();
        reqCalcMarkDelayed              = ReqCalcMarkDelayed::construct();
        clearLog                        = true;
        throwCovItemValidationErrors    = true;
        isFirstFuturesScheduling        = true;
        disableAutoFirm                 = false;

        reqCalcRecordCacheInventDim     = ReqCalcRecordCacheInventDim::newStandard();
        reqCalcRecordCacheUnitOfMeasure = ReqCalcRecordCacheUnitOfMeasure::newStandard();
        leanLocationCache               = LeanLocationCache::construct();

        includeBatchInventSumIsEnabled                  = ReqIncludeBatchInventSumToggle::instance().isEnabled();
        fixedTodaysDateForExpiryCheckIsEnabled          = ReqFixTodaysDateWhenCheckingExpiryDateToggle::instance().isEnabled();
        reqBatchTasksSchedulingFixToggleEnabled         = ReqBatchTasksSchedulingFixToggle::instance().isEnabled();
        reqCoverageCalcForPriorityReqTransToggleEnabled = ReqCoverageCalcForPriorityReqTransToggle::instance().isEnabled();
        isReqCalcResourceSchedulingRetryEnabled         = ReqCalcResourceSchedulingRetryToggle::instance().isEnabled();
        isReqCalcResourceSchedulingRetryBundleEnabled   = ReqCalcResourceSchedulingRetryBundleToggle::instance().isEnabled();
        resourceSchedulingMaxRetryCount                 = ReqCalc::resolveResourceSchedulingMaxRetryCount();
        reqCalcRetryExceptionErrorWhenCausedBySQLErrorEnabled = ReqCalcRetryExceptionErrorWhenCausedBySQLErrorToggle::instance().isEnabled();
        reqCalcBatchJobCancellingToggleEnabled          = ReqCalcBatchJobCancellingToggle::instance().isEnabled();
        reqCalcConvertSqlStatementsToSysDaFlightEnabled = ReqCalcConvertSqlStatementsToSysDaFlight::instance().isEnabled();
        reqInclShelfLifeIssuesInPeriodQtyCalculationFlightEnabled = ReqInclShelfLifeIssuesInPeriodQtyCalcFlight::instance().isEnabled();        
        isReqCalcFinalizeLevelRerunBundlesSameTransFlightEnabled = ReqCalcFinalizeLevelRerunBundlesSameTransFlight::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>resolveResourceSchedulingMaxRetryCount</Name>
				<Source><![CDATA[
    private static int resolveResourceSchedulingMaxRetryCount()
    {
        int retryCount = #RetryNum;

        if (ReqCalcResourceSchedulingTwentyRetriesToggle::instance().isEnabled())
        {
            // setting maximum number of retries to 20 that allows to handle 17 minute of outage.
            retryCount = 20;
        }
        else if (ReqCalcResourceSchedulingFifteenRetriesToggle::instance().isEnabled())
        {
            // setting maximum number of retries to 15 that allows to handle 12 minute of outage.
            retryCount = 15;
        }
        else if (ReqCalcResourceSchedulingTenRetriesToggle::instance().isEnabled())
        {
            // setting maximum number of retries to 10 that allows to handle 7 minute of outage.
            retryCount = 10;
        }

        return retryCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resourceSchedulingMaxRetryCount</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected void resourceSchedulingMaxRetryCount(int _resourceSchedulingMaxRetryCount)
    {
        resourceSchedulingMaxRetryCount = _resourceSchedulingMaxRetryCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventMovement</Name>
				<Source><![CDATA[
    protected InventMovement newInventMovement(ReqTrans _issue)
    {
        return InventMovement::newReqTrans(_issue);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newQueryInventSum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a query for the <c>InventSum</c> table grouped based on the coverage dimension.
    /// </summary>
    /// <param name="_setup">
    /// The master planning setup for the item.
    /// </param>
    /// <param name="_onlyPhysicalInvent">
    /// A <c>boolean</c> that indicates if only the physical inventory quantity should be included.
    /// </param>
    /// <param name="_addBatchGrouping">
    /// A <c>boolean</c> that indicates if the query should be grouped also by the Batch dimension even though this might not be a coverage dimension; optional.
    /// </param>
    /// <param name="_inventDimFilter">
    /// An <c>InventDim</c> record that is used for filtering the query result; optional.
    /// </param>
    /// <returns>
    /// A query for the <c>InventSum</c> table.
    /// </returns>
    protected Query newQueryInventSum(
        ReqSetup        _setup,
        boolean         _onlyPhysicalInvent
        ,boolean         _addBatchGrouping = false
        ,InventDim       _inventDimFilter = null
        )
    {
        QueryBuildDataSource    qbsSum;
        QueryBuildDataSource    qbsDim;
        QueryBuildFieldList     fieldList;
        Query                   query;
        QueryBuildDataSource    qbsLocation;
        InventDimParm           inventDimParm;

        #query

        query = new Query();

        // InventSum

        qbsSum    = query.addDataSource(tableNum(InventSum));

        qbsSum.addRange(fieldNum(InventSum,ClosedQty)).value(queryValue(NoYes::No));
        qbsSum.addRange(fieldNum(InventSum,ItemId));

        qbsSum.addSortField(fieldNum(InventSum,ItemId));

        qbsSum.orderMode(OrderMode::GroupBy);

        fieldList = qbsSum.fields();
        fieldList.addField(fieldNum(InventSum,PhysicalInvent),SelectionField::Sum);

        if (! _onlyPhysicalInvent)
        {
            fieldList.addField(fieldNum(InventSum,ReservPhysical),SelectionField::Sum);
            fieldList.addField(fieldNum(InventSum,ReservOrdered),SelectionField::Sum);
            fieldList.addField(fieldNum(InventSum,OnOrder),SelectionField::Sum);
            fieldList.addField(fieldNum(InventSum,QuotationIssue),SelectionField::Sum);

            fieldList.addField(fieldNum(InventSum,Arrived),SelectionField::Sum);
            fieldList.addField(fieldNum(InventSum,Ordered),SelectionField::Sum);
            fieldList.addField(fieldNum(InventSum,QuotationReceipt),SelectionField::Sum);
        }

        qbsSum.addSortIndex(indexNum(InventSum,ClosedItemDimIdx));
        qbsSum.indexIsHint(true);

        // InventDim

        qbsDim      = qbsSum.addDataSource(tableNum(InventDim));
        qbsDim.joinMode(JoinMode::InnerJoin);
        qbsDim.relations(true);

        inventDimParm.data(_setup.inventDimParmCov());

        if (_addBatchGrouping)
        {
            inventDimParm.InventBatchIdFlag = NoYes::Yes;
        }

        inventDimParm.queryAddSortField(qbsDim);

        if (_inventDimFilter)
        {
            inventDimParm.queryAddRangeValue(qbsDim, _inventDimFilter);
            if (InventUseDimOfInventSumToggle::instance().isEnabled())
            {
                InventSum::queryAddRangeBasedOnInventDimCriteria(qbsSum, _inventDimFilter);
            }
        }

        // Hint

        qbsDim.addSortIndex(indexNum(InventDim,DimIdIdx));
        qbsDim.indexIsHint(true);

        if (_setup.isInventLocationNotCovPlanned())
        {
            //
            // if warehouse is an active dimension but not a coverage dimension then we must collect information about the manual property on the warehouse
            // inner join not possible as inventLocationId might be blank
            //

            qbsLocation = qbsDim.addDataSource(tableNum(InventLocation));
            qbsLocation.joinMode(JoinMode::OuterJoin);
            qbsLocation.relations(true);
            qbsLocation.addRange(fieldNum(InventLocation,Manual)).value(queryValue(NoYes::Yes));
            qbsLocation.addGroupByField(fieldNum(InventLocation,Manual));
        }

        query.literals(#queryForcePlaceholders);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newQueryInventTrans</Name>
				<Source><![CDATA[
    protected Query newQueryInventTrans(ReqSetup    _setup)
    {
        QueryBuildDataSource    qbsTransOrigin;
        QueryBuildDataSource    qbsTrans;
        QueryBuildDataSource    qbsDim;
        QueryBuildDataSource    qbsLocation;
        Query                   query;

        #query

        query = new Query();

        // InventTransOrigin

        qbsTransOrigin = query.addDataSource(tableNum(InventTransOrigin));
        qbsTransOrigin.addRange(fieldNum(InventTransOrigin,ItemId));
        qbsTransOrigin.addRange(fieldNum(InventTransOrigin,InventTransId));

        qbsTransOrigin.addGroupByField(fieldNum(InventTransOrigin,ItemId));
        qbsTransOrigin.addGroupByField(fieldNum(InventTransOrigin,ReferenceCategory));
        qbsTransOrigin.addGroupByField(fieldNum(InventTransOrigin,ReferenceId));
        qbsTransOrigin.addGroupByField(fieldNum(InventTransOrigin,InventTransId));
        qbsTransOrigin.addGroupByField(fieldNum(InventTransOrigin,RecId));

        // InventTrans

        qbsTrans = qbsTransOrigin.addDataSource(tableNum(InventTrans));
        qbsTrans.joinMode(JoinMode::InnerJoin);
        qbsTrans.addLink(fieldNum(InventTransOrigin, RecId), fieldNum(InventTrans, InventTransOrigin));

        qbsTrans.addRange(fieldNum(InventTrans,StatusReceipt));
        qbsTrans.addRange(fieldNum(InventTrans,StatusIssue));

        qbsTrans.addGroupByField(fieldNum(InventTrans,ItemId));
        qbsTrans.addGroupByField(fieldNum(InventTrans,MarkingRefInventTransOrigin));
        qbsTrans.addGroupByField(fieldNum(InventTrans,StatusIssue));
        qbsTrans.addGroupByField(fieldNum(InventTrans,StatusReceipt));
        qbsTrans.addGroupByField(fieldNum(InventTrans,DateStatus));
        qbsTrans.addGroupByField(fieldNum(InventTrans,TimeExpected));

        qbsTrans.fields().addField(fieldNum(InventTrans,Qty),SelectionField::Sum);

        // InventDim

        qbsDim      = qbsTrans.addDataSource(tableNum(InventDim));
        qbsDim.joinMode(JoinMode::InnerJoin);
        qbsDim.relations(true);

        InventDimParm inventDimParmCov = _setup.inventDimParmCov();

        if (isConfigurationkeyEnabled(configurationKeyNum(PdsShelf)) && _setup.inventDimParmActive().InventBatchIdFlag)
        {
            if (this.shouldAddGroupByBatchToInventTransQueryInventDimDataSource(_setup, reqPlanData, inventDimParmCov))
            {
                qbsDim.addGroupByField(fieldNum(InventDim, inventBatchId));
            }

            if (this.existsBatchWithNettableNo())
            {
                QueryBuildDataSource    qbsBatch       = qbsDim.addDataSource(tableNum(InventBatch));
                qbsBatch.addRange(fieldNum(InventBatch, itemId)).value(_setup.itemId());
                QueryBuildDataSource    qbsDisposition = qbsBatch.addDataSource(tableNum(PdsDispositionMaster));
            
                qbsDisposition.joinMode(JoinMode::InnerJoin);
                qbsDisposition.addLink(fieldNum(InventBatch, PdsDispositionCode), fieldNum(PdsDispositionMaster, DispositionCode));
                qbsDisposition.addRange(fieldNum(PdsDispositionMaster, PdsNettable)).value(queryValue(NoYes::No));
           
                qbsBatch.joinMode(JoinMode::NoExistsJoin);
                qbsBatch.addLink(fieldNum(InventDim, inventBatchId), fieldNum(InventBatch, inventBatchId));
            }
        }

        inventDimParmCov.queryAddGroupByField(qbsDim);

        query.literals(#queryForcePlaceholders);

        if (_setup.isInventLocationNotCovPlanned())
        {
            //
            // if warehouse is an active dimension but not a coverage dimension then we must collect information about the manual property on the warehouse
            // inner join not possible as inventLocationId might be blank
            //

            qbsLocation = qbsDim.addDataSource(tableNum(InventLocation));
            qbsLocation.relations(true);
            qbsLocation.addRange(fieldNum(InventLocation,Manual)).value(queryValue(NoYes::Yes));

            // In case there is an InventBatch that has desposition code with PdsNettable No, 
            // we first add the InventBatch as data source to the QueryBuildDataSource of the InventDim (qbsDim)
            // and since it is not supported to add two datasources to the same QueryBuildDataSource, the InventLocation datasource
            // will end up being ignored.
            // To circumvent this, we do an NoExistsJoin on the InventLocation to avoid planning for manual
            // warehouse in the case the product is part of a batch where one product in that batch
            // has disposition code with nettable No.
            if (InventTransQueryNotExistJoinOnManualInventLocationFlight::instance().isEnabled())
            {
                qbsLocation.joinMode(JoinMode::NoExistsJoin);
            }
            else
            {
                qbsLocation.joinMode(JoinMode::OuterJoin);
                qbsLocation.addGroupByField(fieldNum(InventLocation,Manual));
            }
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldAddGroupByBatchToInventTransQueryInventDimDataSource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether a group by clause should be added to the inventory dimension datasource when building the query on inventory transactions.
    /// </summary>
    /// <param name = "_setup">The setup object.</param>
    /// <param name = "_reqPlanData">The MRP run parameters.</param>
    /// <param name = "_inventDimParmCov">The coverage inventory dimensions</param>
    /// <returns>true if the group by should be added; otherwise, false.</returns>
    protected boolean shouldAddGroupByBatchToInventTransQueryInventDimDataSource(
        ReqSetup        _setup, 
        ReqPlanData     _reqPlanData, 
        InventDimParm   _inventDimParmCov)
    { 
        return _reqPlanData.pdsUseShelfLife() && !_inventDimParmCov.InventBatchIdFlag;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsBatchWithNettableNo</Name>
				<Source><![CDATA[
    private boolean existsBatchWithNettableNo()
    {
        PdsDispositionMaster pdsDispositionMaster;
        InventBatch inventBatch;

        select firstonly RecId from pdsDispositionMaster
            exists join inventBatch
                where pdsDispositionMaster.DispositionCode == inventBatch.PdsDispositionCode
                    && pdsDispositionMaster.PdsNettable == NoYes::No;
                        
        return pdsDispositionMaster.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newQueryInventTransIssue</Name>
				<Source><![CDATA[
    protected Query newQueryInventTransIssue(
        ReqSetup        _setup,
        InventTransId   _inventTransId = '')
    {
        Query                   query;
        QueryBuildDataSource    qbs_InventTrans;
        QueryBuildDataSource    qbs_InventTransOrigin;

        StatusIssue             fromStatusIssue     = StatusIssue::ReservPhysical;
        StatusIssue             toStatusIssue       = reqPlanData.useQuotations()? StatusIssue::QuotationIssue : StatusIssue::OnOrder;

        #query

        if (!reqPlanData.useInventOnHands())
        {
            fromStatusIssue = StatusIssue::ReservOrdered;
        }

        query = this.newQueryInventTrans(_setup);

        qbs_InventTrans = query.dataSourceTable(tableNum(InventTrans));
        qbs_InventTrans.findRange(fieldNum(InventTrans,StatusReceipt)).value(queryValue(StatusReceipt::None));
        qbs_InventTrans.findRange(fieldNum(InventTrans,StatusIssue)).value(queryValue(fromStatusIssue)+'..'+queryValue(toStatusIssue));

        if (_inventTransId)
        {
            qbs_InventTransOrigin = query.dataSourceTable(tableNum(InventTransOrigin));
            qbs_InventTransOrigin.findRange(fieldNum(InventTransOrigin,InventTransId)).value(queryValue(_inventTransId));
        }

        qbs_InventTrans.addSortIndex(indexNum(InventTrans,StatusItemIdx));

        query.literals(#queryForcePlaceholders);

        qbs_InventTrans.indexIsHint(true);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newQueryInventTransReceipt</Name>
				<Source><![CDATA[
    protected Query newQueryInventTransReceipt(
        ReqSetup        _setup,
        InventTransId   _inventTransId = '')
    {
        Query                   query;
        QueryBuildDataSource    qbs_InventTrans;
        QueryBuildDataSource    qbs_InventTransOrigin;

        StatusReceipt           fromStatusReceipt   = StatusReceipt::Arrived;
        StatusReceipt           toStatusReceipt     = reqPlanData.useRequestsForQuote() ? StatusReceipt::QuotationReceipt : StatusReceipt::Ordered;

        #query

        query = this.newQueryInventTrans(_setup);

        qbs_InventTrans = query.dataSourceTable(tableNum(InventTrans));
        qbs_InventTrans.findRange(fieldNum(InventTrans,StatusReceipt)).value(queryValue(fromStatusReceipt)+'..'+queryValue(toStatusReceipt));
        qbs_InventTrans.findRange(fieldNum(InventTrans,StatusIssue)).value(queryValue(StatusIssue::None));

        if (_inventTransId)
        {
            qbs_InventTransOrigin = query.dataSourceTable(tableNum(InventTransOrigin));
            qbs_InventTransOrigin.findRange(fieldNum(InventTransOrigin,InventTransId)).value(queryValue(_inventTransId));
        }

        qbs_InventTrans.addSortIndex(indexNum(InventTrans,StatusItemIdx));

        query.literals(#queryForcePlaceholders);

        qbs_InventTrans.indexIsHint(true);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container packed = [#CurrentVersion,#CurrentList];
        packed = this.appendVariableToPack(packed, varStr(resumeProcessId), resumeProcessId);
        return packed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>appendVariableToPack</Name>
				<Source><![CDATA[
    private container appendVariableToPack(container _pack, str _variableName, anytype _value)
    {
        XppPrePostArgs packArgs = this.createXppPrePostArgsWithPack(_pack);
        SysPackExtensions::pack(packArgs, this.getVariablePackKey(_variableName), [_value]);
        return packArgs.getReturnValue();
    }

]]></Source>
			</Method>
			<Method>
				<Name>extractPackedVariable</Name>
				<Source><![CDATA[
    private anytype extractPackedVariable(container _pack, str _variableName)
    {
        anytype value;
        [value] = SysPackExtensions::unpack(this.createXppPrePostArgsWithPack(_pack), this.getVariablePackKey(_variableName));
        return value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createXppPrePostArgsWithPack</Name>
				<Source><![CDATA[
    private XppPrePostArgs createXppPrePostArgsWithPack(container _pack)
    {
        // It has to be a XppEventHandlerCalledWhen::Post type, because otherwise the assignment to setReturnValue will do nothing
        XppPrePostArgs prePostArgs = new XppPrePostArgs(_pack, '',  XppEventHandlerCalledWhen::Post);
        
        // The SysPackExtensions::pack method uses the return value as the source of the container but the unpack uses the args, so need to set both
        prePostArgs.setReturnValue(_pack);

        return prePostArgs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVariablePackKey</Name>
				<Source><![CDATA[
    private ClassName getVariablePackKey(str _variableName)
    {
        return classStr(ReqCalc) + '.' + _variableName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>packThreadData</Name>
				<Source><![CDATA[
    public container packThreadData()
    {
        container packed = [#CurrentThreadVersion,#CurrentThreadList];
        packed = this.appendVariableToPack(packed, varStr(interCompanyCalc), interCompanyCalc);
        return packed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmApplyFuturesToEventKanban</Name>
				<Source><![CDATA[
    public boolean parmApplyFuturesToEventKanban(boolean _applyFuturesEventKanban = applyFuturesEventKanban)
    {
        applyFuturesEventKanban = _applyFuturesEventKanban;
        return applyFuturesEventKanban;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAutoReserveCoverage</Name>
				<Source><![CDATA[
    public NoYes parmAutoReserveCoverage(NoYes _autoReserveCoverage = autoReserveCoverage)
    {
        autoReserveCoverage = _autoReserveCoverage;
        return autoReserveCoverage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBOMDependencyManager</Name>
				<Source><![CDATA[
    public BOMDependencyManager parmBOMDependencyManager(BOMDependencyManager _bomDependencyManager = bomDependencyManager)
    {
        bomDependencyManager = _bomDependencyManager;

        if (bomDependencyManager == null)
        {
            bomDependencyManager = BOMDependencyManager::construct();
        }

        return bomDependencyManager;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBomLevelCalc</Name>
				<Source><![CDATA[
    public BOMLevelCalc parmBomLevelCalc(BOMLevelCalc _bomLevelCalc = bomLevelCalc)
    {
        bomLevelCalc = _bomLevelCalc;

        return bomLevelCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCapacityConflictsHandler</Name>
				<Source><![CDATA[
    public ReqCalcCapacityConflictHandler parmCapacityConflictsHandler(ReqCalcCapacityConflictHandler _capacityConflictsHandler = capacityConflictsHandler)
    {
        capacityConflictsHandler = _capacityConflictsHandler;
        return capacityConflictsHandler;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmClearLog</Name>
				<Source><![CDATA[
    public boolean parmClearLog(boolean _clearLog = clearLog)
    {
        clearLog = _clearLog;
        return clearLog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmComment</Name>
				<Source><![CDATA[
    public ReqComment parmComment(ReqComment _comment = comment)
    {
        comment = _comment;
        return comment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEnableTableTraceLog</Name>
				<Source><![CDATA[
    public boolean parmEnableTableTraceLog(boolean _enableTableTraceLog = enableTableTraceLog)
    {
        enableTableTraceLog = _enableTableTraceLog;
        return enableTableTraceLog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInterCompanyCalc</Name>
				<Source><![CDATA[
    public boolean parmInterCompanyCalc(boolean _interCompanyCalc = interCompanyCalc)
    {
        interCompanyCalc = _interCompanyCalc;
        return interCompanyCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIntercompanyDemandPlanFilter</Name>
				<Source><![CDATA[
    public ReqIntercompanyDemandPlanFilter parmIntercompanyDemandPlanFilter(ReqIntercompanyDemandPlanFilter _intercompanyDemandPlanFilter = intercompanyDemandPlanFilter)
    {
        intercompanyDemandPlanFilter = _intercompanyDemandPlanFilter;
        return intercompanyDemandPlanFilter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIntercompanyGroup</Name>
				<Source><![CDATA[
    public ReqIntercompanyPlanningGroupRecId parmIntercompanyGroup(ReqIntercompanyPlanningGroupRecId _intercompanyGroup = intercompanyGroup)
    {
        intercompanyGroup = _intercompanyGroup;
        return intercompanyGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsTaskTraceEnabled</Name>
				<Source><![CDATA[
    public boolean parmIsTaskTraceEnabled(boolean _isTaskTraceEnabled = isTaskTraceEnabled)
    {
        isTaskTraceEnabled = _isTaskTraceEnabled;
        return isTaskTraceEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMaxChildThreads</Name>
				<Source><![CDATA[
    public ReqProcessNumThreads parmMaxChildThreads(ReqProcessNumThreads _maxChildThreads = maxChildThreads)
    {
        maxChildThreads = _maxChildThreads;
        return maxChildThreads;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMultiUserConcurrencyAllowed</Name>
				<Source><![CDATA[
    public boolean parmMultiUserConcurrencyAllowed(boolean _multiUserConcurrencyAllowed = multiUserConcurrencyAllowed)
    {
        multiUserConcurrencyAllowed = _multiUserConcurrencyAllowed;
        return multiUserConcurrencyAllowed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRecalculateBomLevels</Name>
				<Source><![CDATA[
    public boolean parmRecalculateBomLevels(boolean _recalculateBomLevels = recalculateBomLevels)
    {
        recalculateBomLevels = _recalculateBomLevels;

        return recalculateBomLevels;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReqCalcMarkDelayed</Name>
				<Source><![CDATA[
    public ReqCalcMarkDelayed parmReqCalcMarkDelayed(ReqCalcMarkDelayed _reqCalcMarkDelayed = reqCalcMarkDelayed)
    {
        reqCalcMarkDelayed = _reqCalcMarkDelayed;
        return reqCalcMarkDelayed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReqCalcUpdate</Name>
				<Source><![CDATA[
    public ReqCalcUpdate parmReqCalcUpdate(ReqCalcUpdate _reqCalcUpdate = reqCalcUpdate)
    {
        reqCalcUpdate = _reqCalcUpdate;
        return reqCalcUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReqForecastReduce</Name>
				<Source><![CDATA[
    public ReqForecastReduce parmReqForecastReduce(ReqForecastReduce _reqForecastReduce = reqForecastReduce)
    {
        reqForecastReduce = _reqForecastReduce;
        return reqForecastReduce;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReqPlanData</Name>
				<Source><![CDATA[
    public ReqPlanData parmReqPlanData(ReqPlanData _reqPlanData = reqPlanData)
    {
        reqPlanData = _reqPlanData;
        return reqPlanData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReqPlanId</Name>
				<Source><![CDATA[
    public ReqPlanId parmReqPlanId(ReqPlanId _reqPlanId = reqPlanId)
    {
        reqPlanId = _reqPlanId;
        return reqPlanId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmResumeProcessId</Name>
				<Source><![CDATA[
    public ReqProcessId parmResumeProcessId(ReqProcessId _resumeProcessId = resumeProcessId)
    {
        resumeProcessId = _resumeProcessId;
        return resumeProcessId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReqPlanManager</Name>
				<Source><![CDATA[
    public ReqPlanManager parmReqPlanManager(ReqPlanManager _reqPlanManager = reqPlanManager)
    {
        reqPlanManager = _reqPlanManager;
        return reqPlanManager;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDoNotDisposeReqPlanManager</Name>
				<Source><![CDATA[
    public boolean parmDoNotDisposeReqPlanManager(boolean _doNotDispose = doNotDisposeReqPlanManager)
    {
        doNotDisposeReqPlanManager = _doNotDispose;
        return doNotDisposeReqPlanManager;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmThisIsChildThread</Name>
				<Source><![CDATA[
    public boolean parmThisIsChildThread(boolean _thisIsChildThread = thisIsChildThread)
    {
        thisIsChildThread = _thisIsChildThread;

        return thisIsChildThread;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmThrowCovItemValidationErrors</Name>
				<Source><![CDATA[
    public boolean parmThrowCovItemValidationErrors(boolean _throwCovItemValidationErrors = throwCovItemValidationErrors)
    {
        throwCovItemValidationErrors = _throwCovItemValidationErrors;
        return throwCovItemValidationErrors;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUpdatingAllItems</Name>
				<Source><![CDATA[
    public boolean isUpdatingAllItems()
    {
        return updateAllItems;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsApplyExpiryDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assign the appropriate expiration date to this requirements transaction line.
    /// </summary>
    /// <param name="_reqTrans"> Transaction line. </param>
    /// <param name="_inventDim">Optional. InventDim data for the originating transaction, if any. Some types of
    /// requirements transactions need this to properly determine the expiry date.</param>
    protected void pdsApplyExpiryDate(
        ReqTrans        _reqTrans,
        InventDim       _inventDim = null)
    {
        if (reqPlanData.pdsUseShelfLife())
        {
            _reqTrans.pdsSetShelfLifeFields(_inventDim);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsMaintainSafetyStock</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ensures that safety stock level is maintained for expiring receipts.
    /// </summary>
    /// <param name="_receipt">
    /// A <c>reqTrans</c> record with positive quantity (receipt).
    /// </param>
    /// <param name="_issue">
    /// A <c>reqTrans</c> record with a negative quantity (issue).
    /// </param>
    /// <param name="_setupDim">
    /// The dimension setup for the item.
    /// </param>
    protected void pdsMaintainSafetyStock(ReqTrans _receipt, ReqTrans _issue, ReqSetupDim _setupDim)
    {
        ReqTrans    reqTransSafetySplitReceipt, reqTransSafetyReceipt;
        InventQty   remainingQty;

        if (_receipt && _issue && _issue.RefType == ReqRefType::SafetyInvent && this.coverageEngine(_setupDim).mustConsiderShelfLife())
        {
            if (abs(_issue.openQty()) > abs(_receipt.openQty()))
            {
                remainingQty   = _receipt.openQty();
            }
            else
            {
                remainingQty   = -_issue.openQty();
            }

            if (nextSafetyStockExpiration == dateNull() || (_receipt.PdsExpiryDate < nextSafetyStockExpiration))
            {
                nextSafetyStockExpiration = _receipt.PdsExpiryDate;
            }

            if (safetyStockExpirationDates.exists(_receipt.PdsExpiryDate))
            {
                remainingQty += safetyStockExpirationDates.lookup(_receipt.PdsExpiryDate);
            }
            else if (_receipt.PdsExpiryDate)
            {
                ReqTrans reqTransSafetyIssue;

                reqTransSafetyIssue.data(_issue);
                reqTransSafetyIssue.RecId = 0;
                reqTransSafetyIssue.Qty = -remainingQty;
                reqTransSafetyIssue.CovQty = 0;
                reqTransSafetyIssue.OpenStatus = ReqOpenStatus::Neg;
                reqTransSafetyIssue.OriginalQuantity = reqTransSafetyReceipt.Qty;
                reqTransSafetyIssue.ReqDate = _receipt.PdsExpiryDate + 1;
                reqTransSafetyIssue.ReqDateDlvOrig = reqTransSafetyIssue.ReqDate;

                sortedIssueMap.insert(this.covReqTransOrderKey(reqTransSafetyIssue), reqTransSafetyIssue);

                if (reqInclShelfLifeIssuesInPeriodQtyCalculationFlightEnabled)
                {
                    this.registerSafetyStockQty(reqTransSafetyIssue.ReqDate, reqTransSafetyIssue.Qty);
                }

                // Do not insert into db yet. When we get to finding coverage for this transaction we will know whether this safety stock expires at all.
                safetyStockIssuesAdded = true;
            }

            safetyStockExpirationDates.insert(_receipt.PdsExpiryDate, remainingQty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsRunSequencing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs the sequencing process using the current <c>ReqPlanID</c> value.
    /// </summary>
    /// <remarks>
    /// All parameters are read from <c>ReqPlanSched</c> table.
    /// </remarks>
    public void pdsRunSequencing()
    {
        if (#PMFSequencingEnabled
            && !thisIsChildThread
            && ReqPlanSched::find(reqPlanId).pmfSeqCovSequencing
            && this.isCompleteUpdate())
        {
            PMFSequencingAnalysisEngine::runFromMRP(targetPlanVersion.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>planTimeFenceBackRequisition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the requisitions time fence value that is set on the plan.
    /// </summary>
    /// <returns>
    /// The requisitions time fence value that is set on the plan.
    /// </returns>
    public TimeFenceBackRequisition planTimeFenceBackRequisition()
    {
        return ReqPlanSched::find(reqPlanId).TimeFenceBackRequisition;
    }

]]></Source>
			</Method>
			<Method>
				<Name>planTimeFenceCoverage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the coverage time fence value that is set on the plan.
    /// </summary>
    /// <returns>
    /// The coverage time fence value that is set on the plan.
    /// </returns>
    public TimeFenceCoverage planTimeFenceCoverage()
    {
        return ReqPlanSched::find(reqPlanId).TimeFenceCov;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfClearPlannGroupIssuesAbovePriority</Name>
				<Source><![CDATA[
    /// <summary>
    /// clear the requirements on higher priorities in the same plan group.
    /// </summary>
    /// <param name="_issue">
    /// the <c>ReqTrans</c> record which has been fully covered.
    /// </param>
    private void pmfClearPlannGroupIssuesAbovePriority(ReqTrans _issue)
    {
        ReqTrans    localReqTransIssue;

        if (_issue.openQty() != 0 || !_issue.PmfPlanGroupId)
        {
            return;
        }

        while select forupdate localReqTransIssue
            where localReqTransIssue.PlanVersion              == _issue.PlanVersion
               && localReqTransIssue.RefType                  == _issue.RefType
               && localReqTransIssue.PmfPlanGroupId           == _issue.PmfPlanGroupId
               && localReqTransIssue.RefId                    == _issue.RefId
               && localReqTransIssue.PmfPlanGroupPrimaryIssue == NoYes::Yes
               && localReqTransIssue.PmfPlanGroupPriority     >  _issue.PmfPlanGroupPriority
        {
            localReqTransIssue.Qty = 0;
            localReqTransIssue.PmfPlanGroupPriority = -1;
            localReqTransIssue.update(reqPlanData);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfCoActionCalcDimTransSum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates action messages for planning item transactions.
    /// </summary>
    /// <param name="_receipt">Planning item transaction.</param>
    /// <returns>
    /// A boolean value determines if co-by requirement transaction exists.
    /// </returns>
    private boolean pmfCoActionCalcDimTransSum(
        ReqTrans      _receipt,
        Map           _mapReqTransSum
        )
    {
        ReqTrans    reqTrans, issue;
        ReqTransCov reqTransCov;
        boolean     isDirect = false, isDerived = false;
        boolean     hasCobyReqTrans = false;

        while select RecId
            from reqTrans
            where reqTrans.PlanVersion  == this.reqPlanVersionRefRecId()
                && reqTrans.RefId       == _receipt.RefId
                && reqTrans.Direction   == InventDirection::Receipt
                && reqTrans.CovQty
            join IssueRecId
                from reqTransCov
                where reqTransCov.ReceiptRecId == reqTrans.RecId
        {
            issue = ReqTrans::findRecId(reqTransCov.IssueRecId);

            if (issue.inventTable().PmfPlanningItemId == _receipt.ItemId)
            {
                hasCobyReqTrans = true;
                if (issue.RefType == ReqRefType::PmfFormulaLine)
                {
                    if (issue.ActionType == ActionType::Cancel)
                    {
                        isDerived = true;
                        break;
                    }
                }
                else
                {
                    isDirect = true;
                    break;
                }
            }
        }

        if (isDirect)
        {
            this.pmfCoActionCalcDimTransSumDirect(_receipt, _mapReqTransSum);
        }
        else if (isDerived)
        {
            this.pmfCoActionCalcDimTransSumDerived(_receipt);
        }

        return hasCobyReqTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfCoActionCalcDimTransSumDerived</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates action messages for derived planning item transactions.
    /// </summary>
    /// <param name="_receipt">Planning item transaction.</param>
    private void pmfCoActionCalcDimTransSumDerived(
        ReqTrans      _receipt)
    {
        ReqTrans::pmfSetActionCancel(reqPlanData, _receipt);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfCoActionCalcDimTransSumDirect</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates action messages for direct planning item transactions.
    /// </summary>
    /// <param name="_receipt">Planning item transaction.</param>
    /// <param name="_mapReqTransSum">A <c>Map</c> of requirement transactions.</param>
    protected void pmfCoActionCalcDimTransSumDirect(
        ReqTrans      _receipt,
        Map           _mapReqTransSum)
    {
        ReqTrans        coRelatedReqTrans,
                        coUnrelatedReqTrans,
                        unrelatedReqTrans;

        PmfFormulaCoBy  formulaCoBy;

        ItemId          lastItemId;
        int             coCount = 0, coCounter   = 0;

        select count (Level)
            from  coRelatedReqTrans
            where coRelatedReqTrans.PlanVersion == this.reqPlanVersionRefRecId()
                && coRelatedReqTrans.RefId == _receipt.RefId
                && coRelatedReqTrans.RefType == ReqRefType::PmfCoProduct
                && coRelatedReqTrans.Direction == InventDirection::Receipt
                && coRelatedReqTrans.CovQty
                && coRelatedReqTrans.ActionType != ActionType::Cancel;

        coCount = coRelatedReqTrans.Level;

        while select forupdate coUnrelatedReqTrans
            order by ReqDate
            where coUnrelatedReqTrans.PlanVersion == this.reqPlanVersionRefRecId()
                && coUnrelatedReqTrans.RefId != _receipt.RefId
                && coUnrelatedReqTrans.RefType == ReqRefType::PmfCoProduct
                && coUnrelatedReqTrans.Direction == InventDirection::Receipt
                && coUnrelatedReqTrans.Qty
                && !coUnrelatedReqTrans.CovQty
                && coUnrelatedReqTrans.ActionType != ActionType::Cancel
            join CovQty, ReqDate
            from  coRelatedReqTrans
            where coRelatedReqTrans.ItemId == coUnrelatedReqTrans.ItemId
               && coRelatedReqTrans.CovInventDimId == coUnrelatedReqTrans.CovInventDimId
               && coRelatedReqTrans.PlanVersion == this.reqPlanVersionRefRecId()
               && coRelatedReqTrans.RefId == _receipt.RefId
               && coRelatedReqTrans.RefType == ReqRefType::PmfCoProduct
               && coRelatedReqTrans.Direction == InventDirection::Receipt
               && coRelatedReqTrans.CovQty
               && coRelatedReqTrans.ReqDate >= coUnrelatedReqTrans.ReqDate
               && coRelatedReqTrans.ActionType != ActionType::Cancel
               && coRelatedReqTrans.RecId != coUnrelatedReqTrans.RecId
        {
            if (coUnrelatedReqTrans.RecId)
            {
                if (!lastItemId)
                {
                    lastItemId = coUnrelatedReqTrans.ItemId;
                }
                else if (lastItemId == coUnrelatedReqTrans.ItemId)
                {
                    continue;
                }

                coUnrelatedReqTrans.PmfActionQtyAdd += coRelatedReqTrans.CovQty;

                if (coUnrelatedReqTrans.PmfActionQtyAdd > abs(coUnrelatedReqTrans.openQty()))
                {
                    coUnrelatedReqTrans.ActionQtyAdd = coUnrelatedReqTrans.PmfActionQtyAdd
                                                       - abs(coUnrelatedReqTrans.openQty());

                    coUnrelatedReqTrans.ActionType = ActionType::Appreciate;
                }

                if (coUnrelatedReqTrans.ActionDate > coRelatedReqTrans.ReqDate
                    || !coUnrelatedReqTrans.ActionDate)
                {
                    coUnrelatedReqTrans.ActionDate = coRelatedReqTrans.ReqDate;
                }

                coUnrelatedReqTrans.update();

                if (coUnrelatedReqTrans.PmfActionQtyAdd > abs(coUnrelatedReqTrans.openQty()))
                {
                    select firstonly forupdate unrelatedReqTrans
                        where unrelatedReqTrans.PlanVersion == this.reqPlanVersionRefRecId()
                            && unrelatedReqTrans.RefId      == coUnrelatedReqTrans.RefId
                            && (unrelatedReqTrans.RefType    == ReqRefType::PmfPlannedProdBatch
                            ||  unrelatedReqTrans.RefType    == ReqRefType::Production);

                    formulaCoBy = PmfFormulaCoBy::findRecId(coUnrelatedReqTrans.PmfCoByRefRecId);

                    unrelatedReqTrans.PmfActionQtyAdd
                        += formulaCoBy.CoByQty
                            ? coRelatedReqTrans.CovQty
                                * formulaCoBy.CoByQtySerie
                                / formulaCoBy.CoByQty
                            : 0;

                    unrelatedReqTrans.ActionQtyAdd = unrelatedReqTrans.PmfActionQtyAdd
                                                    - abs(unrelatedReqTrans.openQty());

                    if (unrelatedReqTrans.ActionDate > unrelatedReqTrans.ReqDate
                        || !unrelatedReqTrans.ActionDate)
                    {
                        unrelatedReqTrans.ActionDate = unrelatedReqTrans.ReqDate;
                    }

                    unrelatedReqTrans.ActionType = ActionType::Appreciate;

                    unrelatedReqTrans.update();

                    if (_mapReqTransSum && _mapReqTransSum.exists(unrelatedReqTrans.RecId))
                    {
                        _mapReqTransSum.insert(unrelatedReqTrans.RecId, unrelatedReqTrans);
                    }
                }

                lastItemId = coUnrelatedReqTrans.ItemId;
                coCounter++;
            }
        }

        if (coCount <= coCounter)
        {
            ReqTrans::pmfSetActionCancel(reqPlanData, _receipt);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfCoBySetupQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines co-product reqTrans quantity based on inventory default settings.
    /// </summary>
    /// <param name="_qty">
    /// Planned quantity coming from formula version.
    /// </param>
    /// <param name="_setupDim">
    /// Item dimension setup.
    /// </param>
    /// <returns>
    /// Inventory quantity based on default item setup parameters.
    /// </returns>
    private InventQty pmfCoBySetupQty(InventQty _qty, ReqSetupDim _setupDim)
    {
        ReqSetup    setup   = _setupDim.setup();
        InventQty   qty     = _qty;
        InventQty   setupQty;

        if (qty < _setupDim.lowestQty())
        {
            qty = _setupDim.lowestQty();
        }

        if (qty > _setupDim.highestQty()
            && _setupDim.highestQty() >= _setupDim.lowestQty()
            && _setupDim.highestQty() > 0)
        {
            qty = _setupDim.highestQty();
        }

        qty = roundUpDec(qty, setup.inventDecimals());

        if (_setupDim.quantity()) // Rounding regarding to inventory quantity.
        {
            setupQty = round(qty,decRound(_setupDim.quantity(),setup.inventDecimals()));

            if (setupQty < qty)
            {
                qty = setupQty  + decRound(_setupDim.quantity(),setup.inventDecimals());
            }
            else
            {
                qty = setupQty;
            }
        }

        return qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveFormulaPlanningItemId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the formula planning itemId from the net requirements.
    /// </summary>
    /// <param name = "_issue">The net requirements.</param>
    /// <returns>A planning formula id.</returns>
    [Replaceable]
    protected PmfPlanningItemId retrieveFormulaPlanningItemId(ReqTrans _issue)
    {
        return _issue.inventTable().PmfPlanningItemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveRouteVersion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the route version.
    /// </summary>
    /// <param name = "_pmfCoByRelatedVersion">A BOM version record.</param>
    /// <param name = "_issue">A net requirements record.</param>
    /// <param name = "_qtyPerOrder">The quantity per order.</param>
    /// <param name = "_inventDimCriteria">The inventory dimension value.</param>
    /// <returns>A route version table record.</returns>
    [Replaceable]
    protected RouteVersion retrieveRouteVersion(BOMVersion _pmfCoByRelatedVersion, ReqTrans _issue, InventQty _qtyPerOrder, InventDim _inventDimCriteria)
    {
        return RouteVersion::findActive(_pmfCoByRelatedVersion.ItemId, _issue.ReqDate, _qtyPerOrder, _inventDimCriteria);
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveActiveFormulaSiteVersion</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Selects the active formula version based on the given parameters.
    /// </summary>
    /// <param name = "formulaPlanningItemId">A planning formula item id.</param>
    /// <param name = "_issue">A net requirements record.</param>
    /// <param name = "_inventDimCriteria">The inventory dimension.</param>
    /// <returns>An active formula version table record.</returns>
    [Replaceable]
    protected BOMVersion retrieveActiveFormulaSiteVersion(PmfPlanningItemId formulaPlanningItemId, ReqTrans _issue, InventDim _inventDimCriteria)
    {
        return BOMVersion::pmfSelectBOMSiteVersions(formulaPlanningItemId, _issue.ReqDate, _inventDimCriteria);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfCoCovCreatePlannedOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates one or more planned orders for a co-product issue, where each planned order is a combination of a
    /// <see cref="ReqPO Table"/> and a <see cref="ReqTrans Table"/> record.
    /// </summary>
    /// <param name="_issue">
    /// A <see cref="ReqTrans Table"/> record with a negative unsettled quantity.
    /// </param>
    /// <returns>
    /// A <see cref="ReqTrans Table"/> record with a positive quantity that can partially or completely fulfill the issue,
    /// or <c>null</c> if no receipt was created.
    /// </returns>
    /// <remarks>
    /// The issue <see cref="ReqTrans Table"/> record should not have been settled against any existing receipts or on-hand.
    /// A planned order must be created.
    /// </remarks>
    protected ReqTrans pmfCoCovCreatePlannedOrder(ReqTrans _issue)
    {
        ReqSetupDim         setupDim;

        ReqPO               plannedOrder;
        ReqTrans            reqTransPo;

        InventQty           coQtyRemain;
        ReqTrans            receipt;
        ReqTrans            pmfCoByReceipt;

        RouteVersion        routeVersion;
        InventDim           inventDim;
        InventTable         coInventTable = _issue.inventTable();
        PmfPlanningItemId   planningItem  = this.retrieveFormulaPlanningItemId(_issue);
        InventQty           plannedQty;
        InventQty           qtyPerOrder;

        PmfCoByQty          coByQty;
        BOMVersion          pmfCoByRelatedVersion;

        boolean             first = true;

        ReqSetupDim coSetupDim = ReqSetupDim::newInventTable(coInventTable, _issue.CovInventDimId);
        InventDim covDim = InventDim::find(_issue.CovInventDimId);

        InventTable planningInventTable = InventTable::find(planningItem);
        ReqSetup setup = ReqSetup::newItemId(planningItem);

        InventDim coInventDimCriteria = _issue.inventDim().data();
        coInventDimCriteria.clearNotActiveDim(InventDimGroupSetup::newInventTable(coInventTable));

        coQtyRemain = this.covCodeQty(coSetupDim, _issue);
        do
        {
            if (first || plannedQty < qtyPerOrder)
            {
                if (coQtyRemain > 0)
                {
                    pmfCoByRelatedVersion = this.retrieveActiveFormulaSiteVersion(planningItem, _issue, coInventDimCriteria);

                    while (pmfCoByRelatedVersion)
                    {
                        coByQty = pmfCoByRelatedVersion.pmfCoByQty(coInventTable.ItemId, coInventDimCriteria);
                        if (coByQty > 0)
                        {
                            inventDim = this.resolveCoverageDimensionForCoProductOrder(planningInventTable, pmfCoByRelatedVersion, covDim);
                            setupDim  = ReqSetupDim::newInventTable(planningInventTable, inventDim.InventDimId);

                            plannedQty  = coQtyRemain / coByQty;
                            qtyPerOrder = this.pmfCoBySetupQty(plannedQty, setupDim);

                            if (pmfCoByRelatedVersion.FromQty <= qtyPerOrder)
                            {
                                break;
                            }
                        }

                        next pmfCoByRelatedVersion;
                    }
                }
                else
                {
                    pmfCoByRelatedVersion = BOMVersion::findActive(planningItem, _issue.ReqDate, plannedQty, inventDim);
                    qtyPerOrder           = this.pmfCoBySetupQty(plannedQty, setupDim);
                }

                if (this.validatePmfCoByRelatedVersion(pmfCoByRelatedVersion, _issue))
                {
                    throw error(strFmt("@PRO:CoProductCovFailedNoFormulaVersionFoundError",_issue.ItemId, _issue.ReqDate, qtyPerOrder));
                }

                qtyPerOrder  = pmfCoByRelatedVersion.pmfSetMultipleQty(qtyPerOrder, false);
                routeVersion = this.retrieveRouteVersion(pmfCoByRelatedVersion, _issue, qtyPerOrder, inventDim);

                first = false;
            }

            if (setupDim.plannedOrderTypeReq() != ReqRefType::PmfPlannedProdBatch)
            {
                throw error(strFmt("@PDS2021", pmfCoByRelatedVersion.ItemId,_issue.ItemId));
            }

            plannedOrder.clear();

            this.initializePmfCoCovCreatePlannedOrderFromReqTrans(plannedOrder, _issue);

            plannedOrder.ItemId             = pmfCoByRelatedVersion.ItemId;
            plannedOrder.ItemBomId          = pmfCoByRelatedVersion.bomId;

            plannedOrder.CovInventDimId     = inventDim.InventDimId;

            plannedOrder.RefId = NumberSeq::newGetNumFromId(reqPlanData.sequencePlannedOrder()).num();

            plannedOrder.RefType            = ReqRefType::PmfPlannedProdBatch;

            plannedOrder.ItemRouteId        = routeVersion.RouteId;

            plannedOrder.setReqDateFields(setupDim,reqPlanData);
            plannedOrder.Qty = qtyPerOrder;

            if (plannedOrder.Qty <= 0)
            {
                return null;
            }

            // default lead time
            plannedOrder.initLeadTime(setupDim);

            //  choose vendor
            if (! plannedOrder.VendId)
            {
                plannedOrder.initVendId(setupDim,reqPlanData);
            }

            plannedOrder.initFromSetup(setup);

            plannedOrder.initPurchQty();

            plannedOrder.setSchedFromDate(setupDim,reqPlanData);

            if (reqPlanData.mustTransBeExploded(setupDim,plannedOrder))
            {
                plannedOrder.setBOMCreated();
            }

            if (reqPlanData.mustTransBeScheduled(setupDim,plannedOrder))
            {
                plannedOrder.setRouteCreated();
            }

            // Create planned order
            plannedOrder.insert(reqPlanData);

            reqTransPo.clear();
            reqTransPo.ReqDateDlvOrig     = plannedOrder.ReqDateDlv;
            reqTransPo.OriginalQuantity   = - qtyPerOrder;
            reqTransPo.Level              = _issue.Level;

            ReqTransPOCreate::construct().insertFromReqPo(reqTransPo,
                                                            plannedOrder,
                                                            maxChildThreads > 0,
                                                            reqPlanData,
                                                            setupDim,
                                                            scheduleOrdersList,
                                                            reqCalcRecordCacheInventDim,
                                                            reqCalcRecordCacheUnitOfMeasure,
                                                            _issue,
                                                            covDim,
                                                            _issue.ItemId);

            reqTransCache.noteDownPlannedProdOrderId(reqTransPo.RefId);

            if (coQtyRemain > 0)
            {
                // Locate the receipts created for the co-product from this end-item production
                while select pmfCoByReceipt
                    where pmfCoByReceipt.ItemId          == _issue.ItemId
                        && pmfCoByReceipt.PlanVersion    == _issue.PlanVersion
                        && pmfCoByReceipt.RefId          == reqTransPo.RefId
                        && pmfCoByReceipt.RefType        == ReqRefType::PmfCoProduct
                        && pmfCoByReceipt.CovInventDimId == _issue.CovInventDimId
                {
                    if (!receipt)
                    {
                        receipt.data(pmfCoByReceipt);
                    }

                    coQtyRemain -= pmfCoByReceipt.Qty;
                }

                if (!receipt)
                {
                    return null;
                }
            }

            plannedQty -= qtyPerOrder;
        }
        while (plannedQty > 0);

        return receipt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resolveCoverageDimensionForCoProductOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the coverage dimensions for the planned orders based on the given parameters.
    /// </summary>
    /// <param name = "_planningInventTable">InventTable for the planning item.</param>
    /// <param name = "_planningItemFormulaVersion">Active formula version for the planning item.</param>
    /// <param name = "_reqTransInventDim">InventDim of the ReqTrans corresponding to the planned order.</param>
    /// <returns>The InventDim Coverage dimentions of the planned order.</returns>
    protected InventDim resolveCoverageDimensionForCoProductOrder(InventTable _planningInventTable, BOMVersion _planningItemFormulaVersion, InventDim _reqTransInventDim)
    {
        InventDim reqPoCovInventDim;

        reqPoCovInventDim.InventSiteId = _planningItemFormulaVersion.inventSiteId();
        if (!reqPoCovInventDim.InventSiteId)
        {
            reqPoCovInventDim.InventSiteId = _reqTransInventDim.InventSiteId;
        }

        reqPoCovInventDim = InventDim::findOrCreate(reqPoCovInventDim);
        reqPoCovInventDim.InventLocationId = _planningInventTable
                                                .inventItemOrderSetupMap(InventItemOrderSetupType::Invent, reqPoCovInventDim.InventDimId)
                                                .inventLocationId('', _planningInventTable, reqPoCovInventDim.InventSiteId);
        if (!reqPoCovInventDim.InventLocationId)
        {
            reqPoCovInventDim.InventLocationId = _reqTransInventDim.InventLocationId;
        }

        return InventDim::findOrCreate(reqPoCovInventDim);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePmfCoCovCreatePlannedOrderFromReqTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the planned order from the <c>ReqTrans</c> record.
    /// </summary>
    /// <param name = "_reqPO">A planned order.</param>
    /// <param name = "_issue">A <c>ReqTrans</c> record.</param>
    protected void initializePmfCoCovCreatePlannedOrderFromReqTrans(ReqPO _reqPO, ReqTrans _issue)
    {
        _reqPO.PlanVersion        = _issue.PlanVersion;
        _reqPO.ReqDate            = _issue.ReqDate;
        _reqPO.ReqTime            = _issue.ReqTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePmfCoByRelatedVersion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the coverage for the co-product.
    /// </summary>
    /// <param name = "_pmfCoByRelatedVersion">A BOM version record.</param>
    /// <param name = "_issue">A <c>ReqTrans</c> record.</param>
    /// <returns>true if the validation succeeds; otherwise, false.</returns>
    protected boolean validatePmfCoByRelatedVersion(BOMVersion _pmfCoByRelatedVersion, ReqTrans _issue)
    {
        return !_pmfCoByRelatedVersion.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfCoCovIncreaseExistingOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Increase coverage for co-product demand adjustment.
    /// </summary>
    /// <param name="_setupDim">
    /// Item dimension setup.
    /// </param>
    /// <param name="_issue">
    /// Related issue transaction.
    /// </param>
    /// <returns>
    /// A matching existing receipt transaction.
    /// </returns>
    protected ReqTrans pmfCoCovIncreaseExistingOrder(ReqSetupDim _setupDim,
                                                     ReqTrans    _issue)
    {
        ReqTrans            existRec;
        ReqPO               planProdPO;
        BOMVersion          version;
        PmfFormulaCoBy      coProd;
        ReqQty              qty;

        existRec = this.pmfFindExistingCoProductReqTrans(_setupDim, _issue);
        if (!existRec)
        {
            return existRec;
        }

        select firstonly forupdate planProdPO
            where planProdPO.RefType        == ReqRefType::PmfPlannedProdBatch
                && planProdPO.RefId         == existRec.RefId
                && planProdPO.PlanVersion   == existRec.PlanVersion;

        if (!planProdPO.RecId)
        {
            if (!existRec.openQty())
            {
                return null;
            }
            else
            {
                return existRec;
            }
        }

        select firstonly coProd
            where  coProd.RecId == existRec.PmfCoByRefRecId
            join version
            where version.RecId == coProd.bomVersionRefRecId;

        if (!coProd)
        {
            throw error("@PRO2589");
        }

        qty = coProd.CoByQty
                ? -_issue.openQty()
                        * coProd.CoByQtySerie
                        / coProd.CoByQty
                : 0;

        qty = version.pmfSetMultipleQty(qty,false);

        planProdPO.Qty = this.pmfCoBySetupQty(planProdPO.Qty + qty, _setupDim);

        this.pmfCoCovUpdateProdPO(planProdPO);

        return this.covFindReceipt(_setupDim,_issue,false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfCoCovUpdateProdPO</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update coverage quantity for co-product related req trans.
    /// </summary>
    /// <param name="_reqPO">Related planned order.</param>
    protected void pmfCoCovUpdateProdPO(ReqPO _reqPO)
    {
        ReqTrans                reqTrans;
        ReqPO                   reqPo_orig;

        ttsbegin;

        reqPo_orig = _reqPO.orig();

        if (_reqPO.PurchQty == reqPo_orig.PurchQty)
        {
            _reqPO.initPurchQty();
        }

        if (PdsGlobal::pdsIsCWItem(_reqPO.ItemId))
        {
            _reqPO.Qty = PdsCatchWeight::cwRoundUpInventQty(_reqPO.ItemId, _reqPO.Qty);
            _reqPO.PdsCWReqQty = PdsCatchWeight::cwQty(_reqPO.ItemId, _reqPO.Qty);
        }

        reqTrans = _reqPO.reqTrans(true);

        reqTrans.initFromReqPo(_reqPO);
        reqTrans.update(reqPlanData);

        if (reqPo_orig.Qty != _reqPO.Qty)
        {
            switch (_reqPO.RefType)
            {
                case ReqRefType::PmfPlannedProdBatch    :
                case ReqRefType::BOMPlannedOrder        :
                    reqTrans.updateBOMQty(_reqPO, reqPlanData);
                    this.pmfUpdateCoByReqTrans(_reqPO);
                    break;

                case ReqRefType::TransferPlannedOrder   :
                    reqTrans.updateTransferDemandQty(reqPlanData);
                    break;
            }
        }

        _reqPO.doUpdate();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfCovCalcCoProdTaskGroup</Name>
				<Source><![CDATA[
    protected void pmfCovCalcCoProdTaskGroup(BOMLevel _level, PmfReqTaskGroupId _taskGroupId)
    {
        List                    itemList;
        ListEnumerator          listEnumerator;

        // Update the issue transaction dates to be used for sorting
        reqTransCache.pmfCoUpdateTransDateTime(_level, _taskGroupId);

        // Get all items for co-product processing in the right order
        itemList = reqTransCache.pmfCoCreateItemIdList(_level, _taskGroupId);

        listEnumerator = itemList.getEnumerator();
        while (listEnumerator.moveNext())
        {
            this.covCalcItem(_level, listEnumerator.current());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfFindExistingCoProductReqTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find existing receipt to fulfill planning demand for issue transaction.
    /// </summary>
    /// <param name="_setupDim">Item dimension setup.</param>
    /// <param name="_issue">Related issue transaction.</param>
    /// <returns>Matching existing receipt transaction.</returns>
    protected ReqTrans pmfFindExistingCoProductReqTrans(
        ReqSetupDim _setupDim,
        ReqTrans    _issue)
    {
        ReqTrans        receipt;
        TransDate       searchFrom;
        TransDate       searchTo;
        PmfFormulaCoBy  pmfFormulaCoBy;
        BOMVersion      bomVersion;

        if (pmfCurrentCoByReqDate == dateNull())
        {
            pmfCurrentCoByReqDate = _issue.ReqDate;
        }

        if (pmfCurrentCoByReqDate + _setupDim.covPeriod() - 1 < _issue.ReqDate)
        {
            searchFrom = pmfCurrentCoByReqDate
                            + (roundDown((_issue.ReqDate
                                            - pmfCurrentCoByReqDate
                                            + 1)
                                    / _setupDim.covPeriod(), 1)
                                * _setupDim.covPeriod());
        }
        else
        {
            searchFrom = pmfCurrentCoByReqDate;
        }

        searchTo = searchFrom + _setupDim.covPeriod() - 1;

        if (reqCalcConvertSqlStatementsToSysDaFlightEnabled)
        {
            var receiptQueryObject = ReqCalcSysDaSqlStatementGenerator::runPmfFindExistingCoProductQuery(
                receipt,
                _issue,
                _setupDim,
                reqPlanData,
                searchFrom, 
                searchTo);

            SysDaFindStatement findStatement = new SysDaFindStatement();
            findStatement.find(new SysDaFindObject(receiptQueryObject));

            return receipt;
        }

        // Find existing co-product receipts that originates from the planning item
        select firstonly forupdate receipt
            order by ReqDate
            where receipt.PlanVersion           == _issue.PlanVersion
                && receipt.OpenStatus           == ReqOpenStatus::Zero
                && receipt.ItemId               == _issue.ItemId
                && receipt.CovInventDimId       == _issue.CovInventDimId
                && receipt.Direction            == InventDirection::Receipt
                && receipt.ReqDate              >= searchFrom
                && (receipt.ReqDate             <  searchTo
                    || (receipt.ReqDate == searchTo && receipt.ReqTime <= _issue.ReqTime))
                && receipt.RefType             == ReqRefType::PmfCoProduct
                && (!receipt.PdsExpiryDate || receipt.PdsExpiryDate >= _issue.pdsNeedByDate())

            exists join pmfFormulaCoBy
                where  pmfFormulaCoBy.RecId == receipt.PmfCoByRefRecId
            exists join bomVersion
                where bomVersion.RecId == pmfFormulaCoBy.bomVersionRefRecId
                   && bomVersion.ItemId == _setupDim.setup().inventTable().PmfPlanningItemId;

        return receipt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfPlanGroupSubstituteIssue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs substitution between planning group items.
    /// </summary>
    /// <param name="_issue">
    /// An issue transaction which has the planning group set.
    /// </param>
    /// <returns>
    /// false if no planning group substitution could be made and a new planned order should be created; otherwise, true.
    /// </returns>
    public boolean pmfPlanGroupSubstituteIssue(ReqTrans _issue)
    {
        InventQty   qty;
        boolean     substitutionPerformed   = false;
        ReqTrans    substitutableIssue      = reqTransCache.findNextPlanGroupIssue(_issue);

        if (!substitutableIssue.RecId && !_issue.PmfPlanGroupPrimaryIssue)
        {
            // Find the primary issue when there are no more alternatives available
            substitutableIssue = reqTransCache.findPrimaryPlanGroupIssue(_issue);
        }
        
        if (substitutableIssue.RecId)
        {
            if (!InventTable::isItemActiveForPlanning(substitutableIssue.ItemId))
            {
                warning(strFmt("@SCM:InactiveProductLifecycleStateForSubstituteWarning", substitutableIssue.ItemId));
                substitutionPerformed = false;
            }
            else
            {
                qty = _issue.openQty();

                // Update quantity of the alternative issue
                substitutableIssue.Qty += qty;
                substitutableIssue.update(reqPlanData);

                // Mark the current issue as being processed by removing the open quantity placing it in the front of the queue
                _issue.PmfPlanGroupPriority = -1;
                _issue.Qty -= qty;
                _issue.update(reqPlanData);

                if (substitutableIssue.Level <= _issue.Level)
                {
                    // The issue could already have been processed so set a flag that the levels must be re-run
                    reqTransCache.setRerunFromLevel(substitutableIssue.Level);
                }

                substitutionPerformed = true;
            }
        }

        return substitutionPerformed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustResetDefaultPriorityOrderForItemCoverage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the default priority order for item coverage must be reset.
    /// </summary>
    protected boolean mustResetDefaultPriorityOrderForItemCoverage()
    {
        return #PmfEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfResetCovGroupsCurrent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets default priority order for item coverage.
    /// </summary>
    public void pmfResetCovGroupsCurrent()
    {
        this.pmfResetCovGroupsCurrentForProductType(PmfProductType::Co_Product);
        this.pmfResetCovGroupsCurrentForProductType(PmfProductType::By_Product);
        this.pmfResetCovGroupsCurrentForProductType(PmfProductType::Formula);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfResetCovGroupsCurrentForProductType</Name>
				<Source><![CDATA[
    private void pmfResetCovGroupsCurrentForProductType(PmfProductType _productType)
    {
        ReqItemTable        reqItemTable;
        InventTable         inventTable;

        ttsbegin;

        // The update method must be skipped since it would run a very costly circularity check for each record
        // which is not needed since only fields related to the plan priority are being changed
        reqItemTable.skipDataMethods(true);

        update_recordset reqItemTable
            setting PmfPlanPriorityCurrent      = reqItemTable.PmfPlanPriorityDefault,
                    PmfPlanPriorityDateChanged  = dateNull()
            exists join inventTable
            where inventTable.PmfProductType              == _productType
               && reqItemTable.ItemId                     == inventTable.ItemId
               && reqItemTable.PmfPlanPriorityDateChanged != DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())
               && reqItemTable.PmfPlanPriorityDateChanged != dateNull()
               && reqItemTable.PmfPlanPriorityCurrent     != reqItemTable.PmfPlanPriorityDefault;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfUpdateCoByReqTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates all planned order related co-product transaction quantities based on demand adjustment.
    /// </summary>
    /// <param name="_reqPO">Related planned order.</param>
    protected void pmfUpdateCoByReqTrans(ReqPO _reqPO)
    {
        PmfFormulaCoBy  coProd;
        ReqTrans        coByTrans;

        while select forupdate coByTrans
            where  coByTrans.PlanVersion == _reqPO.PlanVersion
                && coByTrans.RefId      == _reqPO.RefId
                && coByTrans.RefType    == ReqRefType::PmfCoProduct
            join CoByQty, CoByQtySerie
            from coProd
            where  coProd.RecId         == coByTrans.PmfCoByRefRecId
        {
            if (coProd.CoByQtySerie)
            {
                coByTrans.Qty = _reqPO.Qty * coProd.CoByQty / coProd.CoByQtySerie;
            }
            else
            {
                coByTrans.Qty = 0;
            }
            coByTrans.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCoverage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Task executed after the coverage phase
    /// </summary>
    protected void postCoverage()
    {
        this.updatePurchReqRefsCoveredByFirmedOrders();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postUpdate</Name>
				<Source><![CDATA[
    protected void postUpdate()
    {
        try
        {
            ttsbegin;

            if (!reqPlanData.parmUseReqTransCache())
            {
                this.bulkClearReqTransScrap();
            }

            // insert all filtering records
            reqTransCache.createReqProcessTransFilterRecords();

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            if (this.manageExceptionDeadLock())
            {
                retry;
            }
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (this.retryTransientSqlConnectionError())
            {
                retry;
            }
            else
            {
                throw;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if ( this.manageExceptionUpdateConflict() )
            {
                retry;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>preActions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts action messages computation tasks.
    /// </summary>
    protected void preActions()
    {
        this.insertTasksForAllItems(ReqProcessStatus::Actions, ReqLevelState::Actions);
    }

]]></Source>
			</Method>
			<Method>
				<Name>preCoverage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts coverage computation tasks for all levels.
    /// </summary>
    protected void preCoverage()
    {
        reqTransCache.resetLevel();
        if (reqTransCache.moveNextLevel())
        {
            reqCalcTaskController.insertTaskAndBundle(ReqProcessStatus::Coverage, reqTransCache.getCurrentLevel(), ReqLevelState::InitLevel);
            reqCalcTaskController.insertTaskAndBundle(ReqProcessStatus::Coverage, reqTransCache.getCurrentLevel(), ReqLevelState::FinalizeLevel);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>preFutures</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts future messages computation tasks.
    /// </summary>
    protected void preFutures()
    {
        Set                 items;
        BOMLevel            level;

        this.futuresDeleteCapReserv();

        reqTransCache.resetLevel();

        reqCalcTaskController.clearTaskAndBundleList();
        
        while (reqTransCache.moveNextLevel())
        {
            level = reqTransCache.getCurrentLevel();
            items = reqTransCache.getItems(level);

            reqCalcTaskController.initTaskAndBundle(ReqProcessStatus::Futures, -level, ReqLevelState::InitLevel);

            // the levels are negated for futures in order to easily handle the sorting of tasks
            reqCalcTaskController.insertTaskBundlesForItems(items, this.parmMaxChildThreads(), ReqProcessStatus::Futures, -level, ReqLevelState::FuturesReceipts);
            reqCalcTaskController.insertTaskBundlesForItems(items, this.parmMaxChildThreads(), ReqProcessStatus::Futures, -level, ReqLevelState::FuturesIssues);

            reqCalcTaskController.initTaskAndBundle(ReqProcessStatus::Futures, -level, ReqLevelState::PartitionOrders);
        }

        reqCalcTaskController.saveTaskAndBundleList();
    }

]]></Source>
			</Method>
			<Method>
				<Name>preUpdate</Name>
				<Source><![CDATA[
    protected void preUpdate()
    {
        this.updateData();
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleErrorProcessTask</Name>
				<Source><![CDATA[
    protected void handleErrorProcessTask()
    {
        this.resetCurrentBundle();
        throw error("@SYS320450");
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetCurrentBundle</Name>
				<Source><![CDATA[
    private void resetCurrentBundle()
    {
        reqCalcTaskController.resetAssignedNotCompletedBundles();
    }

]]></Source>
			</Method>
			<Method>
				<Name>throwInvalidTaskError</Name>
				<Source><![CDATA[
    private void throwInvalidTaskError(ReqCalcTask _reqCalcTask)
    {
        throw error(strfmt("@SYS322841",
                _reqCalcTask.Status,
                _reqCalcTask.Level,
                _reqCalcTask.LevelState,
                any2int(_reqCalcTask.LevelState),
                _reqCalcTask.ListNum));
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTask</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Processes one master planning task.
    /// </summary>
    /// <param name="_reqCalcTask">
    ///    A <c>ReqCalcTask</c> table buffer that contains the task to be processed.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    Exception thrown when an invalid task was passed to the method.
    /// </exception>
    public void processTask(ReqCalcTask _reqCalcTask)
    {
        WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::ReqTask, strFmt('[Status: %1, Level: %2, LevelState: %3(%4) ListNum(Bundle) %5]',
            _reqCalcTask.Status,
            _reqCalcTask.Level,
            _reqCalcTask.LevelState,
            any2int(_reqCalcTask.LevelState),
            _reqCalcTask.ListNum));

        // Set the state on the mrp trace logger
        reqPlanData.reqTraceLogger().parmContext().setContextFromCalcTask(_reqCalcTask);

        // The ListNum field contains an item list number or an order bundle number (depending on the task being executed

        try
        {
            reqTransCache.parmProcessStatus(_reqCalcTask.Status);

            switch (_reqCalcTask.Status)
            {
                case ReqProcessStatus::Initialising:
                    if (this.mustResetDefaultPriorityOrderForItemCoverage())
                    {
                        this.pmfResetCovGroupsCurrent();
                    }
                    this.createProcessTasks();
                    break;

                case ReqProcessStatus::RecalculateItemLevels:
                    this.recalculateBOMLevels();
                    break;

                case ReqProcessStatus::PreUpdate:
                    this.updateData();
                    break;

                case ReqProcessStatus::Update:
                    this.processInsertDataItemTask(_reqCalcTask.Level, _reqCalcTask.ItemId);
                    break;

                case ReqProcessStatus::InsertInterCompanyDemand:
                    this.insertIntercompanyDemand();
                    break;

                case ReqProcessStatus::InsertRequisitionsDemand:
                    this.insertRequisitionsDemand();
                    break;

                case ReqProcessStatus::InsertNonStockedData:
                    this.insertPlanningItemSupply();
                    break;

                case ReqProcessStatus::PostUpdate:
                    this.postUpdate();
                    break;

                case ReqProcessStatus::PreCoverage:
                    this.preCoverage();
                    break;

                case ReqProcessStatus::Coverage:
                    switch (_reqCalcTask.LevelState)
                    {
                        case ReqLevelState::InitLevel:
                            this.covInitLevel(_reqCalcTask.Level);
                            break;
                         
                        case ReqLevelState::Coverage:
                            this.processCovCalcItemTask(_reqCalcTask.Level, _reqCalcTask.ItemId);
                            break;

                        case ReqLevelState::CoCoverage:
                            this.pmfCovCalcCoProdTaskGroup(_reqCalcTask.Level, _reqCalcTask.TaskGroupId);
                            break;

                        case ReqLevelState::PartitionOrders:
                            this.resourceSchedulePartitionOrders(_reqCalcTask.Status, _reqCalcTask.Level);
                            break;

                        case ReqLevelState::ScheduleResources:
                            this.resourceScheduleOrderBundle(_reqCalcTask.Status, _reqCalcTask.ListNum);
                            break;

                        case ReqLevelState::FinalizeLevel:
                            this.covFinalizeLevel(_reqCalcTask.Level);
                            break;

                        default:
                            this.throwInvalidTaskError(_reqCalcTask);
                    }
                    break;

                case ReqProcessStatus::PostCoverage:
                    this.postCoverage();
                    break;

                case ReqProcessStatus::PreFutures:
                    this.preFutures();
                    break;

                case ReqProcessStatus::Futures:
					if (_reqCalcTask.Level > 0)
                    {
                        this.throwInvalidTaskError(_reqCalcTask);
                    }

                    switch (_reqCalcTask.LevelState)
                    {
                        case ReqLevelState::InitLevel:
                            this.futuresInitLevel(-_reqCalcTask.Level);
                            break;

                        case ReqLevelState::FuturesIssues:
                        case ReqLevelState::FuturesReceipts:
                            this.processFuturesCalcItemTask(-_reqCalcTask.Level, _reqCalcTask.LevelState, _reqCalcTask.ItemId);
                            break;

                        case ReqLevelState::PartitionOrders:
                            this.resourceSchedulePartitionOrders(_reqCalcTask.Status, _reqCalcTask.Level);
                            break;

                        case ReqLevelState::ScheduleResources:
                            this.resourceScheduleOrderBundle(_reqCalcTask.Status, _reqCalcTask.ListNum);
                            break;

                        default:
                            this.throwInvalidTaskError(_reqCalcTask);
                    }
                    break;

                case ReqProcessStatus::PreAction:
                    this.preActions();
                    break;

                case ReqProcessStatus::Actions:
                    this.processActionCalcItemTask(_reqCalcTask.Level, _reqCalcTask.ItemId);
                    break;

                case ReqProcessStatus::AutoCoverage:
                    this.updateAutoReserveCoverage();
                    break;

                case ReqProcessStatus::PlanFinalization:
                    switch (_reqCalcTask.LevelState)
                    {
                        case ReqLevelState::BatchExpiryCalculation:
                            this.calculateBatchExpiryTransactions();
                            break;

                        default:
                            this.throwInvalidTaskError(_reqCalcTask);
                    }
                    break;

                case ReqProcessStatus::UpdatingDynamicPlan:
                    this.updateReqPlans();
                    break;

                case ReqProcessStatus::AutoFirming:
                    switch (_reqCalcTask.LevelState)
                    {
                        case ReqLevelState::PartitionOrders:
                            this.partitionAutoFirmPO();
                            break;
                        case ReqLevelState::ScheduleResources:
                            this.updateAutoFirmPOBundle(_reqCalcTask.ListNum);
                            break;
                        case ReqLevelState::FinalizeLevel:
                            this.updateAutoFirmPOSingleThreadedRetry(_reqCalcTask.Level);
                            break;
                        case ReqLevelState::PartitionOrdersForPostProcessing:
                            this.createBundlesForOrdersPostProcessing();
                            break;
                        case ReqLevelState::OrdersPostProcessing:
                            this.postProcessAutoFirmingOrderBundle(_reqCalcTask.ListNum);
                            break;
                        case ReqLevelState::FinishedScheduling:
                            this.autoPlanKanbanRules();
                            break;
                        default:
                            this.throwInvalidTaskError(_reqCalcTask);
                    }
                    break;

                case ReqProcessStatus::Statistics:
                    this.statistics();
                    break;

                default:
                    this.throwInvalidTaskError(_reqCalcTask);
            }
        }
        catch (Exception::CLRError)
        {
            ApplicationUnhandledExceptionLogger::processUnhandledCLRException();
            this.handleErrorProcessTask();
        }
        catch (Exception::Deadlock)
        {
            this.resetCurrentBundle();
            throw Exception::Deadlock;
        }
        catch (Exception::TransientSqlConnectionError)
        {
            this.resetCurrentBundle();
            throw;
        }
        catch (Exception::UpdateConflict)
        {
            this.resetCurrentBundle();
            throw Exception::UpdateConflict;
        }
        catch
        {
            this.handleErrorProcessTask();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postProcessAutoFirmingOrderBundle</Name>
				<Source><![CDATA[
    private void postProcessAutoFirmingOrderBundle(ReqOrderBundle _bundleId)
    {
        var groupedOrders = new Set(Types::Record);

        this.setFirmingRunId();
        
        ReqPlannedOrderGroupFirmingParameters groupFirmingParameters;
        while select groupFirmingParameters
            where groupFirmingParameters.FirmingRunId  == firmingRunId
               && groupFirmingParameters.OrderBundle   == _bundleId
        {
            groupedOrders.add(groupFirmingParameters);
        }

        var reqTransPoMarkFirm = ReqTransPoMarkFirm::newMap(new Map(typeName2Type(extendedTypeStr(RecId)), Types::Record));

        reqTransPoMarkFirm.runPostProcessingOfOrders(groupedOrders, firmingRunId);

        hasErrors = reqTransPoMarkFirm.hasErrors() || hasErrors;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markFailedHelperThreadsAsNotRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the status of batch helper tasks from 'Error' to 'Didn't Run', modify the status field of each task accordingly.
    /// </summary>
    /// <remarks>
    /// If we do not change the status at the end of the MRP Batch, the Batch will retain the 'Error'
    /// status regardless of whether the resumed helper threads completed their tasks.
    /// </remarks>
    protected void markFailedHelperThreadsAsNotRun()
    {
        Batch helperThreads;
       
        ttsBegin;
       
        update_recordset helperThreads
            setting Status = BatchStatus::NotRun
            where helperThreads.BatchJobId == this.parmCurrentBatch().BatchJobId &&
                  helperThreads.Status == BatchStatus::Error &&
                  helperThreads.ClassNumber == classNum(ReqProcessExternThread) &&
                  helperThreads.RunTimeTask &&
                  helperThreads.Info == conNull();

        this.reqInstrumentationLogger().logInformation("Interrupted helper batches were detected. Their status was changed to 'Didn't run'.");
   
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustMarkFailedHelperThreadsAsNotRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if Batch job has at least one batch helper task which should be marked as 'Didn't Run'.
    /// </summary>
    /// <returns>
    /// true if batch has task with status 'Error'; otherwise, false.
    /// </returns>
    protected boolean mustMarkFailedHelperThreadsAsNotRun()
    {
        Batch helperThreads;

        select firstOnly RecId from helperThreads
            where helperThreads.BatchJobId == this.parmCurrentBatch().BatchJobId &&
                  helperThreads.Status == BatchStatus::Error &&
                  helperThreads.ClassNumber == classNum(ReqProcessExternThread) &&
                  helperThreads.RunTimeTask &&
                  helperThreads.Info == conNull();

        return helperThreads.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>activeHelperThreadsCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Count the number of active helper batches for currnt Batch Job.
    /// </summary>
    /// <returns>
    /// Number of active helper batches.
    /// </returns>
    private int activeHelperThreadsCount()
    {                
        Batch helperThreads;

        helperThreads.readCommittedLock(true);

        if (reqCalcEndHelperThreadsWhenMainNotProcessingFlightEnabled)
        {
            select count(RecId) from helperThreads
                where helperThreads.BatchJobId == this.parmCurrentBatch().BatchJobId &&
                      helperThreads.Status != BatchStatus::Error &&
                      helperThreads.Status != BatchStatus::NotRun &&                
                      helperThreads.Status != BatchStatus::Finished &&
                      helperThreads.ClassNumber == classNum(ReqProcessExternThread) &&
                      helperThreads.RunTimeTask;        
        }
        else
        {
            select count(RecId) from helperThreads
                where helperThreads.BatchJobId == this.parmCurrentBatch().BatchJobId &&
                      helperThreads.Status != BatchStatus::Error && 
                      helperThreads.Status != BatchStatus::NotRun &&                
                      helperThreads.ClassNumber == classNum(ReqProcessExternThread) &&
                      helperThreads.RunTimeTask;   
        }
            
        return int642int(helperThreads.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTimeToCheckAndResumeHelperThreads</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check the period between the last time helper threads were checked and now.
    /// </summary>
    /// <returns>
    /// true if it is time to check/resume helper thread batches; otherwise, false.
    /// </returns>
    private boolean isTimeToCheckAndResumeHelperThreads()
    {
        const int minutesToWait = 5;

        if (helperThreadsCheckLastTime)
        {
            if (DateTimeUtil::getDifference(DateTimeUtil::getSystemDateTime(), helperThreadsCheckLastTime) > minutesToWait * #secondsPerMinute)
            {
                return true;
            }
        }
        else
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustResumeMissingHelperThreads</Name>
				<Source><![CDATA[
    private boolean mustResumeMissingHelperThreads()
    {
        const ReqRetryCount maxNumberOfChildThreadResumeAttempts = 5;

        if (nativeRestartResumeIsEnabled &&
            resumeHelperThreadsIsEnabled &&
            maxChildThreads > 0 &&
            this.isOriginalMainThread() &&            
            this.isTimeToCheckAndResumeHelperThreads())
        {              
            helperThreadsCheckLastTime = DateTimeUtil::getSystemDateTime();

            ReqProcessList reqProcessList = reqTransCache.reqProcessList();

            if (reqProcessList.ResumedChildThreadsCount < maxNumberOfChildThreadResumeAttempts * maxChildThreads)
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tryResumeMissingHelperThreads</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create batches for the missing helper threads.
    /// </summary>
    private void tryResumeMissingHelperThreads()
    {        
        if (!this.mustResumeMissingHelperThreads())
        {
            return;
        }

        int numberOfThreadsToCreate = maxChildThreads - this.activeHelperThreadsCount();

        if (numberOfThreadsToCreate > 0)
        {
            using (var activity = this.reqInstrumentationLogger().calc().resumeHelperThreads(numberOfThreadsToCreate))
            {          
                reqTransCache.createExternThreads(this.parmCurrentBatch(), numberOfThreadsToCreate);
             
                processController.addResumedChildThreadsCount(numberOfThreadsToCreate);
            }                    
        }        
    }

]]></Source>
			</Method>
			<Method>
				<Name>tryRecoverMainThreadIfNotExecuting</Name>
				<Source><![CDATA[
    protected boolean tryRecoverMainThreadIfNotExecuting()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTasks</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Processes all the pending tasks for the current master planning process.
    /// </summary>
    public void processTasks()
    {
        ReqCalcTasksBundle reqCalcTasksBundle;
        ReqCalcTask reqCalcTask;
        boolean moreTasks;
        utcdatetime lastCancellationCheckDateTime = DateTimeUtil::getSystemDateTime();
        utcdatetime processTasksStartTime = DateTimeUtil::getSystemDateTime();        
        var reqLog = reqPlanData.reqLog();
        var watch = new System.Diagnostics.Stopwatch();

        do
        {
            if (this.hasProcessTimedOut(processTasksStartTime))
            {
                ReqCalcTelemetry::invokeTimeoutEvent(this, reqPlanId, this.reqInstrumentationLogger());
                this.cleanUp();
                throw error("@SCMPlanning:ReqCalcProcessTimeoutError");
            }

            this.tryResumeMissingHelperThreads();

            this.ensureStillHasPlanLocks();

            try
            {
                canceled = false;

                moreTasks = this.assignBundleAndCheckForMoreTasks(reqCalcTasksBundle);

                int taskCount = 0;

                if (reqCalcTasksBundle.RecId && moreTasks)
                {
                    using (var bundleSegment = ReqCalcTelemetry::createTasksBundleSegment(reqCalcTasksBundle))
                    {
                        while (reqCalcTaskController.readBundleTasks(reqCalcTasksBundle))
                        {
                            reqCalcTask = reqCalcTaskController.getCurrentBundleTask();
                            reqCalcTask.ThreadId = threadId;

                            reqCalcTaskController.startTask(reqCalcTask);
                        
                            watch.Restart();

                            using (var taskSegment = ReqCalcTelemetry::createTaskSegment(reqCalcTask))
                            {
                                this.processTask(reqCalcTask);
                            }

                            var reqLogFieldId = this.subStatusToReqLogFieldId(reqCalcTask.Status, reqCalcTask.LevelState);
                            if (reqLogFieldId != -1)
                            {
                                reqLog.(reqLogFieldId) += watch.ElapsedMilliseconds;
                            }

                            reqCalcTaskController.endTask(reqCalcTask, isTaskTraceEnabled);

                            if (this.mustCheckCancellation(lastCancellationCheckDateTime))
                            {
                                lastCancellationCheckDateTime = DateTimeUtil::getSystemDateTime();

                                this.retrieveAndSyncProcessStatus();

                                if (canceled)
                                {
                                    break;
                                }
                            }

                            if (taskCount == 0)
                            {
                                processController.updateProcessStatusAndLevel(reqCalcTasksBundle);
                            }

                            taskCount++;
                        }
                        
                        using (var transaction = reqCalcTaskController.createTransaction())
                        {
                            reqCalcTaskController.endTaskBundle(reqCalcTasksBundle);
                            transaction.markForCommit();
                        }
                    }
                }
                else
                {
                    this.retrieveAndSyncProcessStatus();

                    if (moreTasks)
                    {
                        this.detectAndResetOrphanTasksBundles();
                    }
             
                    if (this.tryRecoverMainThreadIfNotExecuting())
                    {
                        break;
                    }                   
                }
            }
            catch (Exception::UpdateConflict)
            {
                reqCalcTaskController.resetAssignedNotCompletedBundles();
                retry;
            }
            catch (Exception::Deadlock)
            {
                reqCalcTaskController.resetAssignedNotCompletedBundles();
                retry;
            }
            catch (Exception::TransientSqlConnectionError)
            {
                reqCalcTaskController.resetUserConnection();
                reqCalcTaskController.resetAssignedNotCompletedBundles();
                
                if (this.retryTransientSqlConnectionError())
                {
                    this.ensureStillHasPlanLocks();

                    retry;
                }
                else
                {
                    throw;
                }
            }
            catch
            {
                reqCalcTaskController.resetUserConnection();
                reqCalcTaskController.resetAssignedNotCompletedBundles();

                this.manageExceptionError();

                this.ensureStillHasPlanLocks();
                retry;
            }
        }
        while (moreTasks && !canceled);
    }

]]></Source>
			</Method>
			<Method>
				<Name>ensureStillHasPlanLocks</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Ensures that plan locks that were taken are still acquired.
    /// </summary>
    internal void ensureStillHasPlanLocks()
    {
        if (!automaticallyReacquireLocks)
        {
            return;
        }

        // Allow only the main thread to perform this operation as the main threads is managing the locks.
        if (thisIsChildThread)
        {
            return;
        }

        this.parmReqPlanManager().ensureStillHasUpdateLockOnPlanVersion(sourcePlanVersion);

        if (isDynamicReqPlanLocked)
        {
            this.parmReqPlanManager().ensureStillHasUpdateLockOnPlanVersion(activePlanVersionOfDynamicPlan);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignBundleAndCheckForMoreTasks</Name>
				<Source><![CDATA[
    private boolean assignBundleAndCheckForMoreTasks(ReqCalcTasksBundle _bundle)
    {
        boolean moreTasks;

        using (var transaction = reqCalcTaskController.createTransaction())
        {
            moreTasks = reqCalcTaskController.assignBundle(_bundle);

            if (_bundle.RecId && moreTasks)
            {
                reqCalcTaskController.setTaskBundleAsRunning(_bundle);
            }

            transaction.markForCommit();
        }

        return moreTasks;
    }

]]></Source>
			</Method>
			<Method>
				<Name>detectAndResetOrphanTasksBundles</Name>
				<Source><![CDATA[
    private void detectAndResetOrphanTasksBundles()
    {        
        if (!this.checkDetectAndResetOrphanTasksBundles())       
        {
            return;
        }

        if (DateTimeUtil::getDifference(DateTimeUtil::getSystemDateTime(), lastOrphanTasksBundlesCheckDateTime) < OrphanTasksBundlesCheckIntervalInSeconds)
        {
            return;
        }

        if (!canceled)
        {
            reqCalcTaskController.detectAndResetOrphanTasksBundles();
            lastOrphanTasksBundlesCheckDateTime = DateTimeUtil::getSystemDateTime();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDetectAndResetOrphanTasksBundles</Name>
				<Source><![CDATA[
    private boolean checkDetectAndResetOrphanTasksBundles()
    {
        return nativeRestartResumeIsEnabled && resumeHelperThreadsIsEnabled && !thisIsChildThread && maxChildThreads > 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isHeaderBatchJobCancelling</Name>
				<Source><![CDATA[
    private boolean isHeaderBatchJobCancelling()
    {
        BatchJob job;

        if (this.isInBatch())
        {
            select firstonly Status, RecId from job
                where job.RecId == this.parmCurrentBatch().BatchJobId;
        }

        return job.RecId ? job.Status == BatchStatus::Cancelling : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveAndSyncProcessStatus</Name>
				<Source><![CDATA[
    private void retrieveAndSyncProcessStatus()
    {
        boolean wasCancelled;
        boolean wasInfrastructureFailure;
        [wasCancelled, wasInfrastructureFailure] = processController.wasProcessCancelled();
        
        if (!wasCancelled && reqCalcBatchJobCancellingToggleEnabled && this.isHeaderBatchJobCancelling())
        {
            ReqTransCache::cancelProcess(processId);
            wasCancelled = true;
            this.reqInstrumentationLogger().logInformation(strFmt('Detected that batch job %1 has been cancelled. Marking MRP process as cancelled.', this.parmCurrentBatch().BatchJobId));
        }

        if (wasCancelled)
        {
            canceled = true;
        
            if (wasInfrastructureFailure)
            {
                infrastructureFailure = true;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>subStatusToReqLogFieldId</Name>
				<Source><![CDATA[
    // Note that not for all arguments there is a corresponding field in ReqLog table.
    // If corresponding field does not exist -1 is returned.
    private int subStatusToReqLogFieldId(ReqProcessStatus _status, ReqLevelState _level)
    {
        switch (_status)
        {
            case ReqProcessStatus::Coverage:
                switch (_level)
                {
                    case ReqLevelState::InitLevel:
                        return fieldNum(ReqLog, MillisecondsCoverageInitLevel);

                    case ReqLevelState::Coverage:
                        return fieldNum(ReqLog, MillisecondsCoverageCoverage);

                    case ReqLevelState::CoCoverage:
                        return fieldNum(ReqLog, MillisecondsCoverageCoCoverage);

                    case ReqLevelState::PartitionOrders:
                        return fieldNum(ReqLog, MillisecondsCoveragePartitionOrders);

                    case ReqLevelState::ScheduleResources:
                        return fieldNum(ReqLog, MillisecondsCoverageScheduleResources);
                }
                break;

            case ReqProcessStatus::Futures:
                switch (_level)
                {
                    case ReqLevelState::InitLevel:
                        return fieldNum(ReqLog, MillisecondsFuturesInitLevel);

                    case ReqLevelState::FuturesIssues:
                        return fieldNum(ReqLog, MillisecondsFuturesFuturesIssues);

                    case ReqLevelState::PartitionOrders:
                        return fieldNum(ReqLog, MillisecondsFuturesPartitionOrders);

                    case ReqLevelState::ScheduleResources:
                        return fieldNum(ReqLog, MillisecondsFuturesScheduleResources);
                }
                break;

            case ReqProcessStatus::AutoFirming:
                switch (_level)
                {
                    case ReqLevelState::PartitionOrders:
                        return fieldNum(ReqLog, MillisecondsAutoFirmingPartitionOrders);

                    case ReqLevelState::ScheduleResources:
                        return fieldNum(ReqLog, MillisecondsAutoFirmingScheduleResources);

                    case ReqLevelState::FinalizeLevel:
                        return fieldNum(ReqLog, MillisecondsAutoFirmingFinalizeLevel);

                    case ReqLevelState::FinishedScheduling:
                        return fieldNum(ReqLog, MillisecondsAutoFirmingFinishedScheduling);
                }
                break;

            case ReqProcessStatus::PlanFinalization:
                switch (_level)
                {
                    case ReqLevelState::BatchExpiryCalculation:
                        return fieldNum(ReqLog, MillisecondsPlanFinalizationBatchExpiryCalculation);
                }
                break;
        }
        
        return -1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasProcessTimedOut</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the master planning process exceeded the timeout.
    /// </summary>
    /// <param name = "_processTasksStartTime">The date when MRP tasks started processing.</param>
    /// <returns>True if the master planning process has timed out.</returns>
    internal boolean hasProcessTimedOut(utcdatetime _processTasksStartTime)
    {
        if (reqParameters.ReqCalcTimeoutInMinutes != 0)
        {
            return DateTimeUtil::getDifference(DateTimeUtil::getSystemDateTime(), _processTasksStartTime) > reqParameters.ReqCalcTimeoutInMinutes * #secondsPerMinute;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckCancellation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the master planning process was canceled by a user.
    /// </summary>
    /// <param name = "_lastCheckDateTime">The date when the last check was made.</param>
    /// <returns>true, if it's time to check whether the master planning process was canceled; otherwise, false.</returns>
    /// <remarks>The check should happen every 5 seconds. Doing this more frequently is unnecessary and will cause unnecessary database queries.</remarks>
    private boolean mustCheckCancellation(utcdatetime _lastCheckDateTime)
    {
        return DateTimeUtil::getDifference(DateTimeUtil::getSystemDateTime(), _lastCheckDateTime) > cancellationCheckIntervalInSeconds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>progressInitSeries</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the progress display.
    /// </summary>
    protected void progressInitSeries()
    {
        this.progressInit(this.caption(), 1, #AviUpdate, 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>recalculateBOMLevels</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Starts the item level recalculation, if it is required.
    /// </summary>
    [SuppressBPWarning('BPUpgradeCodeRunBaseRunCalled', 'The current stack frame is already inside the new session.')]
    protected void recalculateBOMLevels()
    {
        if (this.isBOMLevelRecalculateAllowed())
        {
            this.getBomLevelCalc().run();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainAddQtyOnReceipt</Name>
				<Source><![CDATA[
    private InventQty remainAddQtyOnReceipt(QtyHighest  _highestQty,
                                            ReqTrans    _receipt,
                                            Map         _accumulatedActionQtyMap)
    {
        InventQty       remainAddQtyOnReceipt;

        remainAddQtyOnReceipt = _highestQty - _receipt.Qty - _receipt.ActionQtyAdd;
        if (_accumulatedActionQtyMap.exists(_receipt.RecId))
        {
            remainAddQtyOnReceipt -= _accumulatedActionQtyMap.lookup(_receipt.RecId);
        }

        if (remainAddQtyOnReceipt < 0)
        {
            remainAddQtyOnReceipt = 0;
        }

        return remainAddQtyOnReceipt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqPlanVersionRefRecId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines the master plan version which must be used by the current scheduling process.
    /// </summary>
    /// <returns>
    ///     The record ID of the active master plan version.
    /// </returns>
    public RefRecId reqPlanVersionRefRecId()
    {
        return targetPlanVersion.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>requisitionLinesDemandQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a query that finds requisition lines that may have to be taken into account
    /// in the current master scheduling run.
    /// </summary>
    /// <param name="_linesCoveredByFirmedOrders">
    /// A boolean value indicating whether to query only for lines covered by firmed orders
    /// or only for lines not covered by firmed orders.
    /// </param>
    /// <returns>
    /// A query that finds requisition lines that may have to be taken into account
    /// in the current master scheduling run.
    /// </returns>
    protected Query requisitionLinesDemandQuery(boolean _linesCoveredByFirmedOrders = false)
    {
        Query                   query;
        QueryBuildDataSource    requisitionLine;
        QueryBuildDataSource    inventDim;
        QueryBuildDataSource    requisitionLineFirmedOrderLine;
        QueryBuildDataSource    inventTransOrigin;
        QueryBuildDataSource    reqTrans;

        RecId                   currentLegalEntityRecId = CompanyInfo::current();
        date                    requisitionsFromDate    = dateNull();
        date                    requisitionsToDate      = dateMax();

        query = new Query();

        query.setSqlRecompileHint();

        requisitionLine = query.addDataSource(tableNum(PurchReqLine));

        requisitionLine.addSelectionField(fieldNum(PurchReqLine, RecId));
        requisitionLine.addSelectionField(fieldNum(PurchReqLine, ItemId));
        requisitionLine.addSelectionField(fieldNum(PurchReqLine, PurchQty));
        requisitionLine.addSelectionField(fieldNum(PurchReqLine, RequiredDate));
        requisitionLine.addSelectionField(fieldNum(PurchReqLine, InventDimId));
        requisitionLine.addSelectionField(fieldNum(PurchReqLine, PurchUnitOfMeasure));

        requisitionLine.addSortField(fieldNum(PurchReqLine, ItemId));

        requisitionLine.addRange(fieldNum(PurchReqLine, BuyingLegalEntity)).value(queryValue(currentLegalEntityRecId));
        requisitionLine.addRange(fieldNum(PurchReqLine, RequisitionPurpose)).value(queryValue(enum2int(RequisitionPurpose::Replenishment)));

        if (this.isTimeFenceBackRequisitionFixed())
        {
            requisitionsFromDate = reqPlanData.todaysdate() - this.planTimeFenceBackRequisition();
        }

        if (this.isTimeFenceCoverageFixed())
        {
            requisitionsToDate = reqPlanData.todaysdate() + this.planTimeFenceCoverage();
        }

        requisitionLine.addRange(fieldNum(PurchReqLine, RequiredDate)).value(queryRange(requisitionsFromDate, requisitionsToDate));

        this.addRequisitionLineDemandLinks(query, _linesCoveredByFirmedOrders);

        // this can be overridden in child classes to change the way of filtering
        this.addRequisitionLineDemandFilters(query);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRequisitionLineDemandLinks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds relevant links and data sources to the query for requisition lines demand.
    /// </summary>
    /// <param name="_query">
    /// The query to add links and data sources.
    /// </param>
    /// <param name="_linesCoveredByFirmedOrders">
    /// A boolean value indicating whether to query only for lines covered by firmed orders
    /// or only for lines not covered by firmed orders.
    /// </param>
    private void addRequisitionLineDemandLinks(Query _query, boolean _linesCoveredByFirmedOrders)
    {
        QueryBuildDataSource requisitionLineFirmedOrderLine;

        QueryBuildDataSource requisitionLine = _query.dataSourceTable(tableNum(PurchReqLine));
        requisitionLine.addSortField(fieldNum(PurchReqLine, InventDimId));

        if (_linesCoveredByFirmedOrders)
        {
            requisitionLine.addRange(fieldNum(PurchReqLine, RequisitionStatus)).value(queryValue(enum2int(PurchReqRequisitionStatus::Closed)));

            requisitionLineFirmedOrderLine = requisitionLine.addDataSource(tableNum(RequisitionLineFirmedOrderLine));
            requisitionLineFirmedOrderLine.addLink(fieldNum(PurchReqLine, RecId), fieldNum(RequisitionLineFirmedOrderLine, RequisitionLine));
            requisitionLineFirmedOrderLine.joinMode(JoinMode::InnerJoin);
            requisitionLineFirmedOrderLine.fetchMode(QueryFetchMode::One2One);

            QueryBuildDataSource inventTransOrigin = requisitionLineFirmedOrderLine.addDataSource(tableNum(InventTransOrigin));
            inventTransOrigin.addLink(fieldNum(RequisitionLineFirmedOrderLine, FirmedOrderLineInventTransId), fieldNum(InventTransOrigin, InventTransId));
            inventTransOrigin.joinMode(JoinMode::InnerJoin);
            inventTransOrigin.fetchMode(QueryFetchMode::One2One);

            QueryBuildDataSource reqTrans = inventTransOrigin.addDataSource(tableNum(ReqTrans));
            reqTrans.addRange(fieldNum(ReqTrans, PlanVersion)).value(queryValue(this.reqPlanVersionRefRecId()));
            reqTrans.addLink(fieldNum(InventTransOrigin, RecId), fieldNum(ReqTrans, InventTransOrigin));
            reqTrans.joinMode(JoinMode::InnerJoin);
            reqTrans.fetchMode(QueryFetchMode::One2One);
        }
        else
        {
            requisitionLine.addRange(fieldNum(PurchReqLine, RequisitionStatus)).value(queryValue(enum2int(PurchReqRequisitionStatus::Approved)));
            requisitionLine.addRange(fieldNum(PurchReqLine, RequisitionStatus)).value(queryValue(enum2int(PurchReqRequisitionStatus::Closed)));

            requisitionLineFirmedOrderLine = requisitionLine.addDataSource(tableNum(RequisitionLineFirmedOrderLine));
            requisitionLineFirmedOrderLine.addLink(fieldNum(PurchReqLine, RecId), fieldNum(RequisitionLineFirmedOrderLine, RequisitionLine));
            requisitionLineFirmedOrderLine.joinMode(JoinMode::NoExistsJoin);
        }

        QueryBuildDataSource inventDim = requisitionLine.addDataSource(tableNum(InventDim));
        inventDim.addLink(fieldNum(PurchReqLine, InventDimId), fieldNum(InventDim, InventDimId));
        inventDim.joinMode(JoinMode::InnerJoin);
        inventDim.fetchMode(QueryFetchMode::One2One);
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetActiveSafetyStockRequirementsTracker</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets the active safety stock requirements.
    /// </summary>
    protected void resetActiveSafetyStockRequirementsTracker()
    {
        activeSafetyStockRequirementsTracker = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateScheduleDateTime</Name>
				<Source><![CDATA[
    private container calculateScheduleDateTime(ReqTrans _reqTrans, ReqPO _reqPO)
    {
        date minimumSchedDate;
        TimeOfDay minimumSchedTime;
        ReqSetupDim setupDim = _reqTrans.reqSetupDim(reqPlanData);

        if (reqPlanData)
        {
            boolean allowsSchedulingStartDateBeforeToday = _reqPO.allowsSchedulingStartDateBeforeToday(reqPlanData, setupDim);

            if (reqPlanData.covTimeFenceSchedBack() > 0)
            {
                minimumSchedDate = _reqTrans.ReqDate - reqPlanData.covTimeFenceSchedBack();

                if (minimumSchedDate < reqPlanData.todaysdate() && !allowsSchedulingStartDateBeforeToday)
                {
                    minimumSchedDate = reqPlanData.todaysdate();
                }
            }
            else if (!allowsSchedulingStartDateBeforeToday)
            {
                minimumSchedDate = reqPlanData.schedMarginForward(reqPlanData.todaysdate(), reqPlanData.marginOrder(setupDim), setupDim);
            }
            else
            {
                minimumSchedDate = dateNull();
            }

            if (this.currentDaySchedFrom() == ReqCurrentDaySchedFrom::CurrentTime)
            {
                utcdatetime now = ReqPlanData::currentDateTime();
                if (minimumSchedDate == DateTimeUtil::date(now))
                {
                    // Ensure that jobs scheduled today do not start before the current time
                    minimumSchedTime = DateTimeUtil::time(now);
                }
            }
        }

        return [minimumSchedDate, minimumSchedTime];
    }

]]></Source>
			</Method>
			<Method>
				<Name>resourceScheduleOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Schedules resources for an order.
    /// </summary>
    /// <param name="_status">
    ///    A <c>ReqProcessStatus</c> value that identifies the current process status.
    /// </param>
    /// <param name="_reqTrans">
    ///    A <c>ReqTrans</c> requirement transaction record.
    /// </param>
    /// <param name="_reqPO">
    ///    The <c>ReqPO</c> record that is related to the requirement transaction.
    /// </param>
    protected void resourceScheduleOrder(ReqProcessStatus _status, ReqTrans _reqTrans, ReqPO _reqPO = _reqTrans.getReqPo(reqPlanData))
    {
        date                    minimumSchedDate;
        TimeOfDay               minimumSchedTime;
        WrkCtrParmSchedule      wrkCtrParmSchedule;

        if (!_reqTrans || !_reqPO)
        {
            return;
        }

        if (reqPlanData)
        {
            [minimumSchedDate, minimumSchedTime] = this.calculateScheduleDateTime(_reqTrans, _reqPO);
        }

        //Add parameters for the order
        switch (_status)
        {
            case ReqProcessStatus::Coverage:
                wrkCtrParmSchedule = WrkCtrParmSchedule::newReqTransCoverage(_reqTrans, _reqPO, reqPlanData, false, false, minimumSchedDate, null, minimumSchedTime);

                if (wrkCtrScheduler && wrkCtrScheduler.parmHasOverlapJob() && _reqPO.SchedToDate && reqPlanData.covSchedMethod() == ProdSchedMethod::JobScheduling)
                {
                    wrkCtrScheduler = null;
                    wrkCtrParmSchedule = WrkCtrParmSchedule::newReqTransParameters(_reqTrans, _reqPO, reqPlanData, ReqSchedDirection::BackwardFromSchedDate, ProdSchedMethod::JobScheduling,
                                                                                       _reqPO.SchedToDate, _reqPO.ReqTime, false, wrkCtrParmSchedule.capacityLimited(), wrkCtrParmSchedule.propertyLimited(),
                                                                                       wrkCtrParmSchedule.materialLimited(), wrkCtrParmSchedule.parmKeepProductionUnit(), wrkCtrParmSchedule.parmKeepWarehouseFromResource(), wrkCtrParmSchedule.parmPrimaryResourceSelection());
                }

                break;

            case ReqProcessStatus::Futures:
                wrkCtrParmSchedule = WrkCtrParmSchedule::newReqTransFutures(_reqTrans, _reqPO, reqPlanData, null, minimumSchedTime);
                break;

            default:
                throw error(strFmt("@SYS320451", _status));
        }

        if (this.isReqCalcResourceSchedulingRetryBundleEnabled)
        {
            this.runSchedulingForSingleOrder(_status, wrkCtrParmSchedule);
        }
        else
        {
            this.runResourceScheduleOrder(_status, wrkCtrParmSchedule);
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>runResourceScheduleOrder</Name>
				<Source><![CDATA[
    private void runResourceScheduleOrder(ReqProcessStatus _status, WrkCtrParmSchedule _wrkCtrParmSchedule)
    {
        boolean firstFuturesScheduling = isFirstFuturesScheduling && _status == ReqProcessStatus::Futures;

        if (!isReqCalcResourceSchedulingRetryEnabled)
        {
            this.initWrkCtrScheduler();
            wrkCtrScheduler.addWrkCtrParmSchedule(_wrkCtrParmSchedule);

            if (firstFuturesScheduling)
            {
                wrkCtrScheduler.clearAllCachedData();
                isFirstFuturesScheduling = false;
            }
        }

        boolean schedulingErrorOccured;
        boolean logWarningOnSchedulingError;

        try
        {
            schedulingErrorOccured      = false;
            logWarningOnSchedulingError = false;

            if (isReqCalcResourceSchedulingRetryEnabled)
            {
                this.initWrkCtrScheduler();
                wrkCtrScheduler.addWrkCtrParmSchedule(_wrkCtrParmSchedule);

                if (firstFuturesScheduling)
                {
                    wrkCtrScheduler.clearAllCachedData();
                    isFirstFuturesScheduling = false;
                }
           }

            //Run the scheduling
            wrkCtrScheduler.run();

            schedulingErrorOccured = wrkCtrScheduler.schedulingErrorOccured();
        }
        catch (Exception::Deadlock)
        {
            schedulingErrorOccured      = true;
            logWarningOnSchedulingError = true;
            if (this.manageExceptionDeadLock())
            {
                retry;
            }
        }
        catch (Exception::UpdateConflict)
        {
            schedulingErrorOccured      = true;
            logWarningOnSchedulingError = true;
            if (this.manageExceptionUpdateConflict())
            {
                retry;
            }
        }
        catch (Exception::DuplicateKeyException)
        {
            schedulingErrorOccured      = true;
            logWarningOnSchedulingError = true;
            if (this.manageExceptionDuplicateKeyException())
            {
                retry;
            }
        }
        catch (Exception::Error)
        {
            schedulingErrorOccured      = true;
            logWarningOnSchedulingError = true;

            if (isReqCalcResourceSchedulingRetryEnabled && 
                (!wrkCtrScheduler.inconsistentDataSchedulingErrorOccured()) &&
                this.retryResourceSchedulingError())
            {
                retry;
            }
        }
        catch (Exception::TransientSqlConnectionError)
        {
            schedulingErrorOccured      = true;
            logWarningOnSchedulingError = true;

            if (isReqCalcResourceSchedulingRetryEnabled)
            {
                if (this.retryResourceSchedulingError())
                {
                    retry;
                }
            }
            else if (this.retryTransientSqlConnectionError())
            {
                retry;
            }
        }
        catch (Exception::CLRError)
        {
            schedulingErrorOccured = true;
            logWarningOnSchedulingError = true;

            if (isReqCalcResourceSchedulingRetryEnabled && this.retryResourceSchedulingError())
            {
                retry;
            }
            else
            {
                warning(WrkCtrSchedulerJobSchedulingEngine::getLastClrException());
            }
        }
        catch (Exception::Break)
        {
            throw;
        }
        catch
        {
            schedulingErrorOccured = true;
            logWarningOnSchedulingError = true;

            if (isReqCalcResourceSchedulingRetryEnabled && this.retryResourceSchedulingError())
            {
                retry;
            }
        }
        finally
        {
            // Take action if any errors happened during scheduling
            if (logWarningOnSchedulingError)
            {
                this.logWarningOnSchedulingError(_wrkCtrParmSchedule.schedNumId());
            }

            if (schedulingErrorOccured)
            {
                this.markSchedulingProcessWithError();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runSchedulingForSingleOrder</Name>
				<Source><![CDATA[
    private void runSchedulingForSingleOrder(ReqProcessStatus _status, WrkCtrParmSchedule _wrkCtrParmSchedule)
    {
        this.initWrkCtrScheduler();
        wrkCtrScheduler.addWrkCtrParmSchedule(_wrkCtrParmSchedule);

        if (isFirstFuturesScheduling && _status == ReqProcessStatus::Futures)
        {
            wrkCtrScheduler.clearAllCachedData();
            isFirstFuturesScheduling = false;
        }

        boolean logWarningOnSchedulingError = true;

        try
        {
            schedulingSingleOrderFinishedSuccessfully = false;

            //Run the scheduling
            wrkCtrScheduler.run();

            schedulingSingleOrderFinishedSuccessfully = !wrkCtrScheduler.schedulingErrorOccured();
            logWarningOnSchedulingError = false;
            setOrdersWithSchedulingErrors.remove(_wrkCtrParmSchedule.schedNumId());
        }
        finally
        {
            if (logWarningOnSchedulingError)
            {
                setOrdersWithSchedulingErrors.add(_wrkCtrParmSchedule.schedNumId());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>retryResourceSchedulingError</Name>
				<Source><![CDATA[
    private boolean retryResourceSchedulingError()
    {
        var currentRetryCount = xSession::currentRetryCount();
        const int baseRetryDelayInMilliseconds = 5000;

        if (currentRetryCount >= resourceSchedulingMaxRetryCount)
        {
            return false;
        }
        else
        {
            var delay = baseRetryDelayInMilliseconds * power(2, min(currentRetryCount, 5));
            sleep(min(60 * 1000, delay));
            return true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>logWarningOnSchedulingError</Name>
				<Source><![CDATA[
    private void logWarningOnSchedulingError(InventTransRefId _scheduleNumber)
    {
        warning(strFmt("@SYS322840", _scheduleNumber));
    }

]]></Source>
			</Method>
			<Method>
				<Name>markSchedulingProcessWithError</Name>
				<Source><![CDATA[
    private void markSchedulingProcessWithError()
    {
        reqTransCache.markProcessWithError();
        hasErrors = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resourceScheduleOrderBundle</Name>
				<Source><![CDATA[
    /// <summary>
    /// Schedules resources for a bundle of orders.
    /// </summary>
    /// <param name="_status">
    /// A <c>ReqProcessStatus</c> value that identifies the current process status.
    /// </param>
    /// <param name="_bundleId">
    /// A <c>ReqOrderBundle</c> value that identifies the order bundle to schedule.
    /// </param>
    public void resourceScheduleOrderBundle(ReqProcessStatus _status, ReqOrderBundle _bundleId)
    {
        if (!isReqCalcResourceSchedulingRetryBundleEnabled)
        {
            this.runResourceSchedulingForUnscheduledOrders(_status, _bundleId);
            this.postResourceScheduleOrderBundle(_status, _bundleId);
            return;
        }

        try
        {
            setOrdersWithSchedulingErrors = new Set(Types::String);
            wrkCtrScheduler = null;
            this.initWrkCtrScheduler();
            this.runResourceSchedulingForUnscheduledOrders(_status, _bundleId);
        }
        catch (Exception::Break)
        {
            throw;
        }
        catch (Exception::CLRError)
        {
            if (this.retryResourceSchedulingError())
            {
                retry;
            }
            else
            {
                warning(WrkCtrSchedulerJobSchedulingEngine::getLastClrException());
            }
        }
        catch
        {
            if (this.retryResourceSchedulingError())
            {
                retry;
            }
        }
        finally
        {
            if (setOrdersWithSchedulingErrors)
            {
                SetEnumerator enumerator = setOrdersWithSchedulingErrors.getEnumerator();

                while (enumerator.moveNext())
                {
                    var scheduleNumber = enumerator.current();
                    this.logWarningOnSchedulingError(scheduleNumber);
                }
            }

            if (!schedulingSingleOrderFinishedSuccessfully)
            {
                this.markSchedulingProcessWithError();
            }
        }

        this.postResourceScheduleOrderBundle(_status, _bundleId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>runResourceSchedulingForUnscheduledOrders</Name>
				<Source><![CDATA[
    private void runResourceSchedulingForUnscheduledOrders(ReqProcessStatus _status, ReqOrderBundle _bundleId)
    {
        ReqUnscheduledOrders    reqUnscheduledOrders;
        ReqTrans                reqTrans;
        ReqPO                   reqPO;

        //Select orders to schedule
        while select forceselectorder forcenestedloop RefId from reqUnscheduledOrders
            where   reqUnscheduledOrders.ProcessId      == processId
                &&  reqUnscheduledOrders.EngineBundle   == _bundleId
            join firstonly reqTrans
                order by ReqDate
                where   reqTrans.PlanVersion == reqPlanData.parmReqPlanVersionRefRecId()
                    &&  reqTrans.RefId     == reqUnscheduledOrders.RefId
                    &&
                        (
                        reqTrans.RefType   == ReqRefType::BOMPlannedOrder
                        || reqTrans.RefType == ReqRefType::PmfPlannedProdBatch)
            join firstonly reqPO
                where   reqPO.PlanVersion  == reqPlanData.parmReqPlanVersionRefRecId()
                    &&  reqPO.RefId        == reqUnscheduledOrders.RefId
        {
            SysInstrumentationActivityContext scheduleOrderActivityContext;

            try
            {
                scheduleOrderActivityContext = this.reqInstrumentationLogger().calc().scheduleOrder(reqPO.ItemRouteId);

                this.resourceScheduleOrder(_status, reqTrans, reqPO);

                // If overlap job is found, need to schedule backward from schedToDate again
                if (wrkCtrScheduler.parmHasOverlapJob()
                &&  reqPO.SchedToDate
                &&  reqPlanData.CovSchedMethod() == ProdSchedMethod::JobScheduling)
                {
                    this.resourceScheduleOrder(_status, reqTrans, reqPO);
                }

                // Reset the value to avoid affecting next scheduling
                wrkCtrScheduler.parmHasOverlapJob(false);
            }
            finally
            {
                if (scheduleOrderActivityContext)
                {
                    scheduleOrderActivityContext.dispose();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postResourceScheduleOrderBundle</Name>
				<Source><![CDATA[
    private void postResourceScheduleOrderBundle(ReqProcessStatus _status, ReqOrderBundle _bundleId)
    {
        try
        {
            ttsbegin;

            if (_status == ReqProcessStatus::Coverage)
            {
                if (this.updateParentPlannedOrdersNeeded())
                {
                    this.updateParentPlannedOrders(_bundleId);
                }
                // Mark delayed orders after scheduling
                this.markDelayedScheduledOrders(_bundleId);
            }

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            if (this.manageExceptionDeadLock())
            {
                retry;
            }
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (this.retryTransientSqlConnectionError())
            {
                retry;
            }
            else
            {
                throw;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if ( this.manageExceptionUpdateConflict())
            {
                retry;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateParentPlannedOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update order date and order time of planned orders that have derived requirements to the minimum date and time of its derived requirements.
    /// </summary>
    /// <param name="_bundleId">
    /// A <c>ReqOrderBundle</c> value that identifies the order bundle that was scheduled.
    /// </param>
    private void updateParentPlannedOrders(ReqOrderBundle _bundleId)
    {
        ReqUnscheduledOrders reqUnscheduledOrders;
        ReqPO                plannedOrder;
        ReqTrans             issue;
        ReqTrans             receipt;
        ReqTransCov          reqTransCov;
        Map                  issueToPlannedOrderMap = new Map(Types::Record, Types::Record);
        
        while select forceselectorder forcenestedloop TableId from reqUnscheduledOrders
            where reqUnscheduledOrders.ProcessId    == processId
               && reqUnscheduledOrders.EngineBundle == _bundleId
            join receipt
                where receipt.PlanVersion == reqPlanData.parmReqPlanVersionRefRecId()
                   && receipt.RefId        == reqUnscheduledOrders.RefId
                   && receipt.IsDerivedDirectly
            join IssueRecId from reqTransCov
                where reqTransCov.ReceiptRecId == receipt.RecId
            join issue
                where (issue.Direction == InventDirection::Issue || issue.Qty < 0 || issue.CovQty < 0)
                   && issue.RecId == reqTransCov.IssueRecId
                   && issue.IsDerivedDirectly
                   && (issue.RefType == ReqRefType::BOMLine || issue.RefType == ReqRefType::PmfFormulaLine)
                   && issue.PlanVersion == reqPlanData.parmReqPlanVersionRefRecId()
        {
            plannedOrder = receipt.getReqPo(reqPlanData);
            if (plannedOrder.RecId && plannedOrder.IsDerivedDirectly)
            {
                // Only store the planned order with minimum date and time
                if (issueToPlannedOrderMap.exists(issue))
                {
                    ReqPO localPlannedOrder = issueToPlannedOrderMap.lookup(issue);
                    if (localPlannedOrder.ReqDateOrder >  plannedOrder.ReqDateOrder ||
                           (localPlannedOrder.ReqDateOrder == plannedOrder.ReqDateOrder && localPlannedOrder.ReqTimeOrder > plannedOrder.ReqTimeOrder))
                    {
                        issueToPlannedOrderMap.insert(issue, plannedOrder);
                    }
                }
                else
                {
                    issueToPlannedOrderMap.insert(issue, plannedOrder);
                }
            }
        }
        
        ReqPO			reqPoParent;
        MapEnumerator	mapEnumerator = issueToPlannedOrderMap.getEnumerator();
        while (mapEnumerator.moveNext())
        {
            issue = mapEnumerator.currentKey();
            plannedOrder = mapEnumerator.currentValue();
        
            reqPoParent.skipDataMethods(true);
            reqPoParent.skipDatabaseLog(true);
            update_recordset reqPoParent
                    setting ReqDateOrder = plannedOrder.ReqDateOrder, ReqTimeOrder = plannedOrder.ReqTimeOrder
                    where reqPoParent.PlanVersion == issue.PlanVersion
                       && reqPoParent.RefId == issue.RefId
                       && (reqPoParent.ReqDateOrder > plannedOrder.ReqDateOrder ||
                          (reqPoParent.ReqDateOrder == plannedOrder.ReqDateOrder && reqPoParent.ReqTimeOrder > plannedOrder.ReqTimeOrder));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateParentPlannedOrdersNeeded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if parent planned orders should be adjusted.
    /// </summary>
    /// <returns>True if updating is needed; otherwise, false.</returns>
    protected boolean updateParentPlannedOrdersNeeded()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resourceSchedulePartitionOrders</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates order bundles according to the partitioning information and the associated master planning
    ///    task for each bundle.
    /// </summary>
    /// <param name="_processStatus">
    ///    The process status, coverage or futures, for which order partitioning is performed.
    /// </param>
    /// <param name="_level">
    ///    The BOM level for which order partitioning is performed.
    /// </param>
    protected void resourceSchedulePartitionOrders(ReqProcessStatus _processStatus, BOMLevel _level)
    {
        ReqUnscheduledOrders reqUnscheduledOrders;

        if (maxChildThreads > 0)
        {
            try
            {
                ttsbegin;

                WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::PartitionOrders, strFmt('Level %1', _level));

                // partition orders
                reqOrderPartitioner.partition();

                ttscommit;
            }
            catch (Exception::Deadlock)
            {
                if (this.manageExceptionDeadLock())
                {
                    retry;
                }
            }
            catch (Exception::TransientSqlConnectionError)
            {
                if (this.retryTransientSqlConnectionError())
                {
                    retry;
                }
                else
                {
                    throw;
                }
            }
            catch (Exception::UpdateConflict)
            {
                if ( this.manageExceptionUpdateConflict())
                {
                    retry;
                }
            }
        }

        reqCalcTaskController.clearTaskAndBundleList();

        while select EngineBundle from reqUnscheduledOrders
            group by EngineBundle
            where reqUnscheduledOrders.ProcessId == processId
        {
            reqCalcTaskController.initTaskAndBundle(_processStatus, _level, ReqLevelState::ScheduleResources, reqUnscheduledOrders.EngineBundle);
        }

        reqCalcTaskController.saveTaskAndBundleList();
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        using (var memoryCacheCurrentSessionScopeLocal = new ReqMemoryCacheCurrentSessionScope())
        {
            memoryCacheCurrentSessionScope = memoryCacheCurrentSessionScopeLocal;

            ReqParameters::checkPlanningProcessesAreEnabled();

            setPrefix(this.caption());

            this.setVariablesForResume();
            
            this.initializePlanVersions();

            this.ttsbegin();
            
            this.setParameters();
            
            this.invokeStartedEvent();

            try
            {
                this.lockDynamicReqPlan();
                
                this.processTasks();

                this.updateDocuRef();

                this.unlockDynamicReqPlan();

                this.insertReqLog(canceled);

                this.cleanUp();

                this.updateReqLog();

                this.ttscommit();

                this.runPostActions();

                reqTransCache.endProcess();

                this.pdsRunSequencing();

                this.invokeCompletedEvent();
            }
            finally
            {
                this.disposeContext();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>disposeContext</Name>
				<Source><![CDATA[
    internal void disposeContext()
    {
        if (!this.parmThisIsChildThread())
        {
            if (instrumentationActivityContext)
            {
                instrumentationActivityContext.dispose();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runPostActions</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Performs actions specified in master planning parameters after the
    ///     current scheduling process has completed.
    /// </summary>
    /// <remarks>
    ///     This method is empty.
    /// </remarks>
    protected void runPostActions()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>runReqTransUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Performs net requirements synchronization.
    /// </summary>
    /// <param name="_reqTransUpdate">
    ///     The instance of the <c>ReqTransUpdate</c> class to invoke.
    /// </param>
    protected void runReqTransUpdate(ReqTransUpdate _reqTransUpdate)
    {
        _reqTransUpdate.run();
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the batch task is run on the server or on a client.
    /// </summary>
    /// <returns>
    ///    true if the task is run on the server; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Your classes that extend <c>RunBaseBatch</c> must override the <c>runsImpersonated</c> method and
    ///    return false, if you want those tasks to run on a client.
    /// </remarks>
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcReqDateFromMarginDays</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates requirement date based on margin order and margin receipt days.
    /// </summary>
    /// <param name="_setupDim">
    /// A <c>ReqSetupDim</c> object that holds coverage settings for a specific item ID and inventory dimensions.
    /// </param>
    /// <param name="_reqDate">
    /// Requirement date.
    /// </param>
    /// <returns>
    /// Requirement date that is calculated based on margin days.
    /// </returns>
    public TransDate calcReqDateFromMarginDays(ReqSetupDim  _setupDim, ReqDate _reqDate)
    {
        if (_setupDim.marginOrder())
        {
            _reqDate = reqPlanData.schedMarginForward(_reqDate, _setupDim.marginOrder(), _setupDim, _setupDim.reqCalendarId());
        }
        if (_setupDim.minSatisfy() == ReqMinSatisfy::TodaysDateTime)
        {
            if (! _setupDim.leadTimeCalendarDays())
            {
                _reqDate += _setupDim.leadTime();
            }
            else
            {
                _reqDate = reqPlanData.workCalendarSched().schedDate(SchedDirection::Forward, _reqDate, _setupDim.leadTime(), true, _setupDim.reqCalendarId());
            }
        }
        if (_setupDim.marginReceipt())
        {
            _reqDate = reqPlanData.schedMarginForward(_reqDate, _setupDim.marginReceipt(), _setupDim, _setupDim.reqCalendarId());
        }
        return _reqDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>safetyStockDate</Name>
				<Source><![CDATA[
    protected TransDate safetyStockDate(ReqSetupDim  _setupDim)
    {
        ReqTrans        reqTrans;
        ReqDate         reqDate;

        switch (_setupDim.minSatisfy())
        {
            case ReqMinSatisfy::TodaysDate: // Fall through
            case ReqMinSatisfy::TodaysDateTime:
                return this.calcReqDateFromMarginDays(_setupDim, reqPlanData.todaysdate());

            case ReqMinSatisfy::FirstIssue:
                select firstonly ReqDate from reqTrans
                    order by ReqDate
                    where reqTrans.PlanVersion        == this.reqPlanVersionRefRecId()      &&
                    reqTrans.ItemId                   == _setupDim.setup().itemId()         &&
                    reqTrans.CovInventDimId           == _setupDim.parmCovInventDimId()     &&
                    reqTrans.Direction                == InventDirection::Issue             &&
                    reqTrans.ReqDate;

                if (reqTrans.RecId)
                {
                    reqDate = max(reqTrans.ReqDate, reqPlanData.todaysdate());
                    return this.calcReqDateFromMarginDays(_setupDim, reqDate);
                }
                return dateNull();

            case ReqMinSatisfy::TimeFenceDate:
                reqDate = reqPlanData.todaysdate() + reqPlanData.timeFenceCoverage(_setupDim) - 1;
                return this.calcReqDateFromMarginDays(_setupDim, reqDate);

            default:
                throw error("@SYS18709");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setVariablesForResume</Name>
				<Source><![CDATA[
    protected void setVariablesForResume()
    {
        if (resumeProcessId)
        {
            ReqProcessList reqProcessList = ReqProcessList::find(resumeProcessId, false);
            this.unpackThreadData(reqProcessList.Parameters);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqProcessListBeginProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Begins the scheduling process by inserting a new record into the <c>ReqProcessList</c> table.
    /// </summary>
    protected void reqProcessListBeginProcess()
    {
        if (thisIsPeriodicProcess)
        {
            todaysDate = reqPlanData.todaysdate();
            processController.beginProcess(this.packThreadData(), todaysDate);
        }

        //Ensure that product related support tables has been populated.
        InventParameters::find();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewThreadId</Name>
				<Source><![CDATA[
    private ReqProcessThreadId getNewThreadId()
    {
        return NumberSeq::newGetNum(CompanyInfo::numRefParmId()).num();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes all the parameters for the master planning run.
    /// </summary>
    /// <exception cref="Exception::Error">
    /// Thrown in case the validation of the current master plan run fails or the process ID
    /// or the thread ID could not be retrieved from the number sequence
    /// or the planned orders number sequence is not setup correctly.
    /// </exception>
    protected void setParameters()
    {
        currentStatus   = ReqProcessStatus::Initialising;

        reqUseCache     = reqParameters.UseCache;

        this.validateSourceAndTargetPlanVersions();

        if (this.isOriginalMainThread())
        {
            if (!this.validate())
            {
                throw error("@SYS18447");
            }

            this.initializePlanningMethod();

            // If the process is resumed then we already have the processId of the previous run.
            if (!isNativelyResumed)
            {
                processId = this.getProcessId();
            }
        }

        ClassId classId = classIdGet(this);
        processController = ReqCalcProcessController::construct(processId, classId, maxChildThreads, reqPlanId, reqCalcUpdate);

        reqPlanData = this.createReqPlanData();

        reqTraceLogger = reqPlanData.reqTraceLogger();
        traceLoggingEnabled = reqTraceLogger.loggingEnabled();

        this.initReqLog();
        reqPlanData.initReqLogCoverage(processId);

        setErrorItemId = new Set(Types::String);

        threadId = this.getNewThreadId();

        if (!processId || !threadId)
        {
            throw error("@SYS107508");
        }

        if (this.isOriginalMainThread() && !isNativelyResumed)
        {
            this.reqProcessListBeginProcess();
        }
        else
        {
            if (todaysDate == dateNull())
            {
                throw error("@SYS107505");
            }

            reqPlanData.parmTodaysDate(todaysDate);
        }

        if (!this.validateNumberSequences())
        {
            throw error("@SYS18447");
        }

        reqTransCache = this.createReqTransCache();
        reqTransCache.setThreadParameters(threadId, thisIsChildThread, maxChildThreads);

        reqTransCache.parmUseReqTransFilter(reqCalcUpdate != ReqCalcUpdate::Regeneration);

        // the initialization of the order partitioner must be done before
        // all helper threads start
        this.initOrderPartitioner();

        capacityConflictsHandler = ReqCalcCapacityConflictHandler::newProcessId(processId);

        reqCalcTaskController = this.createTaskController();
         
        if (this.isOriginalMainThread() && !isNativelyResumed)        
        {
            // insert the initialization task which will create all the other MRP tasks
            reqCalcTaskController.insertTaskAndBundle(ReqProcessStatus::Initialising);

            if (reqBatchTasksSchedulingFixToggleEnabled)
            {
                reqTransCache.startExternThreads(this.parmCurrentBatch());
            }
            else 
            {
                currentBatch = this.parmCurrentBatch();
                currentBatch.GroupId = this.batchInfo().parmGroupId();
                reqTransCache.startExternThreads(currentBatch);
            }
        
            processController.setProcessStatus(ReqProcessStatus::Initialising);
        }

        if (#PmfEnabled)
        {
            mapPlanGroupIssues = new Map(Types::Integer, Types::Record);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSourceAndTargetPlanVersions</Name>
				<Source><![CDATA[
    private void validateSourceAndTargetPlanVersions()
    {
        if (!sourcePlanVersion)
        {
            throw error("@SYS342113");
        }

        if (!targetPlanVersion)
        {
            throw error("@SYS342112");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePlanningMethod</Name>
				<Source><![CDATA[
    private void initializePlanningMethod()
    {
        if (   reqCalcUpdate != ReqCalcUpdate::Regeneration
            && reqPlanId != this.dynamicReqPlanId()
            && !this.isReqCalcUpdateFixed())
        {
            reqCalcUpdate = ReqCalcUpdate::Regeneration;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setReqTransUpdated</Name>
				<Source><![CDATA[
    protected void setReqTransUpdated(ItemId _itemId)
    {
        if (! setReqTransUpdated)
        {
            setReqTransUpdated = new Set(Types::String);
        }

        setReqTransUpdated.add(_itemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>staticReqPlanId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines the ID of the default static master plan.
    /// </summary>
    /// <returns>
    ///     The ID of the default static master plan.
    /// </returns>
    public ReqPlanId staticReqPlanId()
    {
        if (!staticReqPlanId)
        {
            staticReqPlanId = ReqPlanSched::defaultStaticId();
        }
        return staticReqPlanId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>statistics</Name>
				<Source><![CDATA[
    /// <summary>
    /// Computes time statistics for the update data, coverage, futures and actions phases.
    /// </summary>
    protected void statistics()
    {
        ReqLog reqLog = reqPlanData.reqLog();

        reqLog.TimeUpdate       = this.getStatusRuntime(ReqProcessStatus::PreUpdate, ReqProcessStatus::PostUpdate);
        reqLog.TimeCoverage     = this.getStatusRuntime(ReqProcessStatus::PreCoverage, ReqProcessStatus::PostCoverage);
        reqLog.TimeFutures      = this.getStatusRuntime(ReqProcessStatus::PreFutures, ReqProcessStatus::Futures);
        reqLog.TimeAction       = this.getStatusRuntime(ReqProcessStatus::PreAction, ReqProcessStatus::Actions);
        reqLog.TimeAutoFirm     = this.getStatusRuntime(ReqProcessStatus::AutoFirming, ReqProcessStatus::AutoFirming);
        reqLog.TimeCopy         = this.getStatusRuntime(ReqProcessStatus::UpdatingDynamicPlan, ReqProcessStatus::UpdatingDynamicPlan);
        reqLog.TimeFinalization = this.getStatusRuntime(ReqProcessStatus::PlanFinalization, ReqProcessStatus::PlanFinalization);

        if (ReqLogCapacityConflictsHandlerFlight::instance().isEnabled())
        {
            reqLog.CapacityConflictsCount = capacityConflictsHandler.getCapacityConflictsCount();
        }

        if (reqLog.ProcessId && reqLog.ReqPlanId)
        {
            // This will create the reqLog entry - that will be updated by other threads
            var blankReqLog = this.ensureBlankReqLogExists(reqLog.ProcessId, reqLog.ReqPlanId,  reqLog.ReqLogId);

            this.insertTaskStatistics(blankReqLog.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>threadId</Name>
				<Source><![CDATA[
    public ReqProcessThreadId threadId()
    {
        return threadId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ttsbegin</Name>
				<Source><![CDATA[
    protected void ttsbegin()
    {
        if (!thisIsChildThread)
        {
            sourcePlanVersion = this.parmReqPlanManager().acquireUpdateLockOnActivePlanVersion(reqPlanId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ttscommit</Name>
				<Source><![CDATA[
    protected void ttscommit()
    {
        if (!thisIsChildThread)
        {
            this.parmReqPlanManager().releaseLockOnPlanVersion(sourcePlanVersion);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unlockDynamicReqPlan</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Unlocks the default dynamic master plan.
    /// </summary>
    /// <remarks>
    ///     This method is empty.
    /// </remarks>
    protected void unlockDynamicReqPlan()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>unlockIntercompanyPlanVersions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Unlocks the plan versions in downstream customer companies, which serve as the source of the
    ///    planned intercompany demand.
    /// </summary>
    /// <param name="_lockedPlanVersions">
    ///    The set of plan versions, which have been locked.
    /// </param>
    protected void unlockIntercompanyPlanVersions(Set _lockedPlanVersions)
    {
        this.unlockingIntercompanyPlanVersions();

        SetEnumerator setEnumerator;

        if (_lockedPlanVersions)
        {
            setEnumerator = _lockedPlanVersions.getEnumerator();
            while (setEnumerator.moveNext())
            {
                this.parmReqPlanManager().releaseLockOnPlanVersion(ReqPlanVersion::find(setEnumerator.current()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Integer         version        = conPeek(packedClass, 1);

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList] = packedClass;
                resumeProcessId = this.extractPackedVariable(packedClass, varStr(resumeProcessId));
                break;

            case #Version12:
                [version, #Version12List] = packedClass;
                break;

            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpackThreadData</Name>
				<Source><![CDATA[
    public boolean unpackThreadData(container packedClass)
    {
        Integer version = conPeek(packedClass,1);

        switch (version)
        {
            case #CurrentThreadVersion:
                [version,#CurrentThreadList] = packedClass;
                interCompanyCalc = this.extractPackedVariable(packedClass, varStr(interCompanyCalc));
                break;
            default:
                return false;
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>partitionAutoFirmPO</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Partitions the planned orders in the firming time fence.
    /// </summary>
    protected void partitionAutoFirmPO()
    {
        ReqTrans            reqTrans;
        ReqTrans            reqTransCheck;

        Map                 mapPlannedOrder;
        MapEnumerator       mePlannedOrder;

        Map                 mapReqTransMark;

        ReqSetupDim         setupDim;

        // get map containing reqTrans records of type planned orders [reqTrans.recId, reqTrans]
        mapPlannedOrder = reqTransCache.mapPlannedOrder();

        mapReqTransMark = new Map(typeName2Type(extendedTypeStr(RecId)), Types::Record);

        if (mapPlannedOrder)
        {
            mePlannedOrder = mapPlannedOrder.getEnumerator();
            while (mePlannedOrder.moveNext())
            {
                reqTrans = mePlannedOrder.currentValue();

                if (thisIsPeriodicProcess)
                {
                    select firstonly RecId from reqTransCheck where reqTransCheck.RecId == reqTrans.RecId;

                    if (!reqTransCheck)
                    {
                        continue;
                    }
                }

                setupDim = reqPlanData.newReqSetupDim(reqPlanData.newReqSetup(reqTrans.ItemId), reqTrans.CovInventDimId);

                if (reqPlanData.mustTransBeAutoAuthorized(setupDim, reqTrans))
                {
                    mapReqTransMark.insert(reqTrans.RecId, reqTrans);
                }
            }

            this.createAutoFirmPoBundles(mapReqTransMark);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAutoFirmPoBundles</Name>
				<Source><![CDATA[
    private void createAutoFirmPoBundles(Map mapReqTransMark)
    {
        try
        {
            ttsbegin;
            ReqTransPoAutoFirmPartitioner::construct(reqPlanData).createBundles(mapReqTransMark, processId, reqCalcTaskController);
            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            if (this.manageExceptionDeadLock())
            {
                retry;
            }
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (this.retryTransientSqlConnectionError())
            {
                retry;
            }
            else
            {
                throw;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (this.manageExceptionUpdateConflict())
            {
                retry;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBundlesForOrdersPostProcessing</Name>
				<Source><![CDATA[
    private void createBundlesForOrdersPostProcessing()
    {
        this.setFirmingRunId();

        ReqTransPoAutoFirmPartitioner::createBundlesForOrdersPostProcessing(firmingRunId, reqCalcTaskController);
    }

]]></Source>
			</Method>
			<Method>
				<Name>autoPlanKanbanRules</Name>
				<Source><![CDATA[
    private void autoPlanKanbanRules()
    {
        KanbanRule kanbanRule;

        while select kanbanRule
        {
            LeanCommandAutoPlan leanCommandAutoPlan = LeanCommandAutoPlan::newStandard(kanbanRule, false);
            leanCommandAutoPlan.run();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFirmingRunId</Name>
				<Source><![CDATA[
    internal void setFirmingRunId()
    {
        if (!firmingRunId)
        {
            firmingRunId = ReqProcessAutoFirmingRun::findFirmingRunIdForProccessId(processId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAutoFirmPOBundle</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Firms the planned orders in the bundle.
    /// </summary>
    /// <param name="_bundleId">
    ///    The order bundle.
    /// </param>
    [SuppressBPWarning('BPUpgradeCodeRunBaseRunCalled', 'The current stack frame is already inside the new session.')]
    protected void updateAutoFirmPOBundle(ReqOrderBundle _bundleId)
    {
        this.setFirmingRunId();

        var mapReqTransMark = new Map(typeName2Type(extendedTypeStr(RecId)), Types::Record);

        ReqTrans            reqTrans;
        ReqUnfirmedOrders   reqUnfirmedOrders;
        while select reqTrans
            where reqTrans.PlanVersion == reqPlanData.parmReqPlanVersionRefRecId()
            exists join reqUnfirmedOrders
                where reqUnfirmedOrders.ProcessId   == processId
                  &&  reqUnfirmedOrders.OrderBundle == _bundleId
                  &&  reqUnfirmedOrders.RefId       == reqTrans.RecId
        {
            // If a the previous thread that was processing the bundle died before completing the bundle then some of the planned orders in the bundle can be firmed already and must not be picked up for processing again
            if (reqTrans.isPlannedOrder())
            {
                mapReqTransMark.insert(reqTrans.RecId, reqTrans);
            }
        }

        var reqTransPoMarkFirm = this.createReqTransPoMarkFirm(mapReqTransMark);
        reqTransPoMarkFirm.parmIsSortingByLevelNeeded(false);
        // We will retry firming the orders failed due to update conflicts in a single threaded retry task.
        reqTransPoMarkFirm.parmIgnoreUnhandledUpdateConflicts(true);
        // We have a separate step that plans all the firmed kanbans at once, after all of them were created. We can skip planning here.
        reqTransPoMarkFirm.parmIsKanbanRuleAutoPlanningDeferred(true);
        reqTransPoMarkFirm.created += eventhandler(this.deleteUnfirmedOrdersForFirmedReqTrans);
        
        const boolean IsMultiThreaded = true;
        reqTransPoMarkFirm.setAsPartOfBiggerRun(firmingRunId, IsMultiThreaded);

        if (mapReqTransMark.elements())
        {
            reqTransPoMarkFirm.run();
            hasErrors = reqTransPoMarkFirm.hasErrors() || hasErrors;

            logNumOfAutoFirm += reqTransPoMarkFirm.getFirmedOrderCount();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteUnfirmedOrdersForFirmedReqTrans</Name>
				<Source><![CDATA[
    private void deleteUnfirmedOrdersForFirmedReqTrans(ReqTrans _reqTransFirmedOriginal)
    {
        ReqUnfirmedOrders reqUnfirmedOrders;
        
        reqUnfirmedOrders.skipAosValidation(true);
        reqUnfirmedOrders.skipDataMethods(true);
        reqUnfirmedOrders.skipDeleteActions(true);
        
        delete_from reqUnfirmedOrders
            where reqUnfirmedOrders.ProcessId == processId
                && reqUnfirmedOrders.RefId == _reqTransFirmedOriginal.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAutoFirmPOSingleThreadedRetry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Firms all the planned orders that were not firmed while processing their bundles due to update conflicts.
    /// </summary>
    /// <param name="_level">
    /// The BOM level to analyze.
    /// </param>
    [SuppressBPWarning('BPUpgradeCodeRunBaseRunCalled', 'The current stack frame is already inside the new session.')]
    protected void updateAutoFirmPOSingleThreadedRetry(BOMLevel _level)
    {
        Map                 mapReqTransMark;
        ReqTransPoMarkFirm  reqTransPoMarkFirm;
        ReqTrans            reqTrans;
        ReqUnfirmedOrders   reqUnfirmedOrders;
        ReqCalcTasksBundle  reqCalcTasksBundle;

        mapReqTransMark = new Map(typeName2Type(extendedTypeStr(RecId)), Types::Record);

        while select reqTrans
            where reqTrans.PlanVersion == reqPlanData.parmReqPlanVersionRefRecId()
               && reqTrans.InventTransOrigin == 0
               && #ReqRefTypeIsPlannedOrder(reqTrans.RefType)
            exists join reqUnfirmedOrders
                where reqUnfirmedOrders.ProcessId == processId
                   && reqUnfirmedOrders.RefId == reqTrans.RecId
            exists join reqCalcTasksBundle
                where reqCalcTasksBundle.Level == _level
                   && reqCalcTasksBundle.Status == ReqProcessStatus::AutoFirming
                   && reqCalcTasksBundle.ListNum == reqUnfirmedOrders.OrderBundle
                   && reqCalcTasksBundle.ProcessId == processId
        {
            mapReqTransMark.insert(reqTrans.RecId, reqTrans);
        }

        this.setFirmingRunId();

        reqTransPoMarkFirm = this.createReqTransPoMarkFirm(mapReqTransMark);
        reqTransPoMarkFirm.parmIsSortingByLevelNeeded(false);
        reqTransPoMarkFirm.setAsPartOfBiggerRun(firmingRunId);

        if (mapReqTransMark.elements())
        {
            reqTransPoMarkFirm.run();
            hasErrors = reqTransPoMarkFirm.hasErrors() || hasErrors;

            logNumOfAutoFirm += reqTransPoMarkFirm.getFirmedOrderCount();
            logNumOfAutoFirmRetry += reqTransPoMarkFirm.getFirmedOrderCount();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAutoReserveCoverage</Name>
				<Source><![CDATA[
    protected boolean updateAutoReserveCoverage()
    {
        return autoReserveCoverage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the requirement profile for the current MRP run.
    /// </summary>
    protected void updateData()
    {
        this.insertData();

        mapQueryInventSum = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateItemLock</Name>
				<Source><![CDATA[
    protected void updateItemLock(ItemId _itemId)
    {
        select firstonly pessimisticlock inventTableLock
            where inventTableLock.ItemId == _itemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDocuRef</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Copies notes attached to approved planned orders during regeneration of the plan.
    /// </summary>
    protected void updateDocuRef()
    {
        if (this.isCompleteUpdate() && setApprovedPlannedOrder && !setApprovedPlannedOrder.empty())
        {
            try
            {
                ReqPO sourceReqPo, targetReqPo;
                DocuRef docuRef;

                ttsBegin;

                docuRef.skipDataMethods(true);

                update_recordSet docuRef
                        setting RefRecId = targetReqPo.RecId
                    join targetReqPo
                        where targetReqPo.PlanVersion == targetPlanVersion.RecId
                        exists join sourceReqPo
                            where sourceReqPo.RecId       == docuRef.RefRecId
                                && sourceReqPo.TableId     == docuRef.RefTableId
                                && sourceReqPo.dataAreaId  == docuRef.RefCompanyId
                                && sourceReqPo.ReqPOStatus == ReqPOStatus::Approved
                                && sourceReqPo.PlanVersion == sourcePlanVersion.RecId
                                && sourceReqPo.RefId       == targetReqPo.RefId;

                ttsCommit;
            }
            catch (Exception::TransientSqlConnectionError)
            {
                if (this.retryTransientSqlConnectionErrorRestoreReqCalc())
                {
                    retry;
                }
                else
                {
                    throw;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePurchReqRefsCoveredByFirmedOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new requisition line references for requisition lines that are being covered by planned orders.
    /// If those requisition lines are not in state Closed, they will be set to state Closed.
    /// </summary>
    public void updatePurchReqRefsCoveredByFirmedOrders()
    {
        ReqTrans                        reqTransIssue;
        ReqTrans                        reqTransReceipt;
        ReqTransCov                     reqTransCov;
        InventTransOrigin               inventTransOrigin;
        PurchReqLine                    requisitionLine;
        RequisitionLineFirmedOrderLine  reference;

        RecordInsertList    requisitionLineRefInsertList = new RecordInsertList(tableNum(RequisitionLineFirmedOrderLine));
        Set                 requisitionLinesToClose = new Set(Types::Int64);
        SetEnumerator       en;

        ttsbegin;

        while select RecId, RequisitionLine from reqTransIssue
            where   reqTransIssue.PlanVersion   == this.reqPlanVersionRefRecId()
                &&  reqTransIssue.RefType       == ReqRefType::RequisitionLine
            join RecId, RequisitionStatus from requisitionLine
                where   requisitionLine.RecId   == reqTransIssue.RequisitionLine
            join IssueRecId, ReceiptRecId from reqTransCov
                where   reqTransCov.IssueRecId  == reqTransIssue.RecId
            join RefType, InventTransOrigin from reqTransReceipt
                where   reqTransReceipt.RecId   == reqTransCov.ReceiptRecId
                    && (    reqTransReceipt.RefType == ReqRefType::Purch
                        ||  reqTransReceipt.RefType == ReqRefType::Production
                        ||  reqTransReceipt.RefType == ReqRefType::Kanban
                        ||  reqTransReceipt.RefType == ReqRefType::InventTransfer
                        ||  reqTransReceipt.RefType == ReqRefType::TransferOrderReceive)
            join InventTransId, DataAreaId from inventTransOrigin
                group by reqTransReceipt.RefType, inventTransOrigin.InventTransId, inventTransOrigin.DataAreaId, requisitionLine.RecId, requisitionLine.RequisitionStatus
                where   inventTransOrigin.RecId == reqTransReceipt.InventTransOrigin
            notexists join reference
                where   reference.RequisitionLine                       == reqTransIssue.RequisitionLine
                    &&  reference.FirmedReferenceType                   == reqTransReceipt.RefType
                    &&  reference.FirmedOrderLineInventTransId          == inventTransOrigin.InventTransId
                    &&  reference.FirmedOrderLineInventTransDataAreaId  == inventTransOrigin.DataAreaId
        {
            if (requisitionLine.RequisitionStatus != PurchReqRequisitionStatus::Closed)
            {
                requisitionLinesToClose.add(requisitionLine.RecId);
            }

            RequisitionLineFirmedOrderLine::insertReference(
                requisitionLineRefInsertList,
                requisitionLine,
                inventTransOrigin,
                reqTransReceipt.RefType);
        }

        requisitionLineRefInsertList.insertDatabase();

        en = requisitionLinesToClose.getEnumerator();
        while (en.moveNext())
        {
            PurchReqWFStatusTransitionHelper::setPurchReqLineStatus(en.current(), PurchReqRequisitionStatus::Closed);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReqLog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the <c>Reqlog</c> table with the number of auto-firmed orders.
    /// </summary>
    protected void updateReqLog()
    {
        ReqLog      reqLogUpdate;
        
        ttsbegin;

        reqLogUpdate.skipAosValidation(true);
        reqLogUpdate.skipDataMethods(true);

        update_recordset reqLogUpdate
            setting NumOfAutoFirm = reqLogUpdate.NumOfAutoFirm + logNumOfAutoFirm,
                    NumOfAutoFirmSingleThreadedRetry = reqLogUpdate.NumOfAutoFirmSingleThreadedRetry + logNumOfAutoFirmRetry
            where   reqLogUpdate.ProcessId == processId;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReqPlans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Copies the static master plan into the dynamic master plan if it is specified in
    ///     master planning parameters.
    /// </summary>
    protected void updateReqPlans()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReqTransUpdate</Name>
				<Source><![CDATA[
    protected void updateReqTransUpdate(ItemId _itemId)
    {
        ReqTransUpdate reqTransUpdate;

        if (! this.isReqTransUpdated(_itemId))
        {
            if (reqPlanData.parmReqPlanId() == this.dynamicReqPlanId())
            {
                reqTransUpdate = ReqTransUpdate::newReqCalcItemId(_itemId,reqPlanData);

                if (this.mustUseCacheDuringUpdate())
                {
                    reqTransUpdate.parmReqTransCache(reqTransCache);
                }
                
                this.runReqTransUpdate(reqTransUpdate);

                numOfChanges+= reqTransUpdate.numOfChanges();
            }

            this.setReqTransUpdated(_itemId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>useCache</Name>
				<Source><![CDATA[
    public ReqUseCache useCache()
    {
        return reqUseCache;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateNumberSequences</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the number sequences has been set up correctly.
    /// </summary>
    /// <returns>
    /// true if the number sequences are valid; otherwise, false.
    /// </returns>
    protected boolean validateNumberSequences()
    {
        boolean             ret                 = true;
        NumberSequenceTable numberSequenceTable = NumberSequenceTable::find(reqPlanData.sequencePlannedOrder());

        if (!numberSequenceTable.RecId)
        {
            ret = checkFailed(strFmt(NumberSequenceTable::txtNotExist(),reqPlanData.sequencePlannedOrder()));
        }
        else
        {
            if (numberSequenceTable.Continuous)
            {
                ret = checkFailed(strFmt("@SYS345433", numberSequenceTable.NumberSequence));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCovDimIdAsTask</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds the specified coverage dimension and dependent coverage dimensions to the <c>ReqDependency</c>
    ///    object.
    /// </summary>
    /// <param name="_reqLevelAnalyzer">
    ///    An object that holds all tasks and dependencies.
    /// </param>
    /// <param name="_itemId">
    ///    A string that holds the <c>itemID</c> value.
    /// </param>
    /// <param name="_covDimId">
    ///    A string that holds the inventory dimension ID.
    /// </param>
    /// <param name="_reqPlanData">
    ///    A <c>reqPlanData</c> object that holds cached data; optional.
    /// </param>
    /// <param name="_setCovDimIdCheck">
    ///    A set that holds coverage dimensions which are added; optional.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    The coverage dimensions have circular dependencies.
    /// </exception>
    public static void addCovDimIdAsTask(
        ReqDependencyAnalyzer   _reqLevelAnalyzer,
        ItemId                  _itemId,
        InventDimId             _covDimId,
        ReqPlanData             _reqPlanData        = null,
        Set                     _setCovDimIdCheck   = null)
    {
        ReqSetup                reqSetup    = _reqPlanData ? _reqPlanData.newReqSetup(_itemId) : ReqSetup::newItemId(_itemId);
        ReqSetupDim             reqSetupDim = _reqPlanData ? _reqPlanData.newReqSetupDim(reqSetup,_covDimId) : ReqSetupDim::newCovInventDimId(reqSetup,_covDimId);

        InventLocationId        locationIdFrom;
        InventLocation          inventLocationFrom;

        InventDim               inventDimTo;
        InventDim               inventDimFrom;

        InventDimParm           inventDimParm;

        inventDimTo = reqSetupDim.inventDim();

        setPrefix(strFmt("@WAX1112", inventDimTo.InventLocationId));

        // check for circularity
        if (   _setCovDimIdCheck
            && _setCovDimIdCheck.in(_covDimId))
        {
            throw error("@SYS105115");
        }

        _reqLevelAnalyzer.addTask(inventDimTo.InventDimId);

        // investigate if transfer exists - dependent covDimIds
        locationIdFrom = reqSetupDim.mainInventLocationId();

        if (locationIdFrom)
        {
            inventLocationFrom = InventLocation::find(locationIdFrom);

            if (! inventLocationFrom.Manual)
            {
                inventDimParm.initCovPrDimension(InventDimGroupSetup::newItemId(_itemId));

                // make an inventDim the same way as a transfer issue
                inventDimFrom = inventDimTo.data();
                inventDimFrom.initFromInventLocationAndDefault(inventLocationFrom,_itemId,InventDirection::Issue,inventDimParm);
                inventDimFrom = InventDim::findOrCreate(inventDimFrom);

                _reqLevelAnalyzer.addTask(inventDimFrom.InventDimId);
                _reqLevelAnalyzer.addDependency(inventDimTo.InventDimId,inventDimFrom.InventDimId);

                if (! _setCovDimIdCheck)
                {
                    _setCovDimIdCheck = new Set(Types::String);
                }

                _setCovDimIdCheck.add(inventDimTo.InventDimId);

                // make iterative call for the new covDimId
                ReqCalc::addCovDimIdAsTask(   _reqLevelAnalyzer,
                                                            _itemId,
                                                            inventDimFrom.InventDimId,
                                                            _reqPlanData,
                                                            _setCovDimIdCheck);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>argsItemId</Name>
				<Source><![CDATA[
    public static ItemId argsItemId(Args args)
    {
        FormRun                     callerForm;

        ItemId                      itemId;
        FieldId                     id;

        if (args.dataset())
        {
            id = fieldName2id(args.dataset(),fieldStr(InventTable,ItemId));

            if (id && args.record())
            {
                itemId = args.record().(id);
            }
            else if (id && args.lookupRecord())
            {
                itemId = args.lookupRecord().(id);
            }

            if (!itemId && args.caller())
            {
                callerForm = args.caller();

                if (callerForm && callerForm.args() && callerForm.args().record() && callerForm.args().record().TableId)
                {
                    id = fieldName2id(callerForm.args().record().TableId,fieldStr(InventTable,ItemId));

                    if (id)
                    {
                        itemId = callerForm.args().record().(id);
                    }
                }
            }
        }

        return itemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>argsReqPlanId</Name>
				<Source><![CDATA[
    public static ReqPlanId argsReqPlanId(Args args)
    {
        ReqTrans        reqTrans;
        Object          formRunObject;
        ReqTransForm    reqTransForm;
        FieldId         fieldId;
        ReqPlanId       reqPlanId;
        ReqPO           reqPO;

        if (args.dataset() == tableNum(ReqTrans))
        {
            reqTrans  = args.record();
            reqPlanId = ReqPlanVersion::find(reqTrans.PlanVersion).ReqPlanId;
        }
        if (! reqPlanId && args.dataset() == tableNum(ReqPO) && args.record())
        {
            reqPO  = args.record();
            reqPlanId = ReqPlanVersion::find(reqPO.PlanVersion).ReqPlanId;
        }
        if (! reqPlanId && args.caller() && formHasMethod(args.caller(),identifierStr(reqTransForm)))
        {
            formRunObject = args.caller();
            reqTransForm  = formRunObject.reqTransForm();

            reqPlanId = reqTransForm.parmReqPlanId();
        }
        if (! reqPlanId && args.caller() && args.dataset())
        {
            fieldId = fieldName2id(args.dataset(),fieldStr(ReqTrans,PlanVersion));

            if (fieldId && args.record().(fieldId))
            {
                reqPlanId = ReqPlanVersion::find(args.record().(fieldId)).ReqPlanId;
            }
        }
        if (!reqPlanId && ReqPlan::findReqPlanId(args.parm()))
        {
            reqPlanId = args.parm();
        }
        // we need this to support Drill Through links from SSRS reports
        if (! reqPlanId && args.lookupRecord() && args.lookupRecord() is ReqPO)
        {
            reqPO  = args.lookupRecord();
            reqPlanId = ReqPlanVersion::find(reqPO.PlanVersion).ReqPlanId;
        }
        if (!reqPlanId)
        {
            reqPlanId = ReqTransPlanIdFilter::getPlanIdFromArgsSysFilter(args);
        }

        return reqPlanId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>bulkInitFromInventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes many <c>ReqTrans</c> records for a specific item ID with settings from related
    ///    originator records.
    /// </summary>
    /// <param name="_reqPlanData">
    ///    A <c>ReqPlanData</c> object that holds master planning settings.
    /// </param>
    /// <param name="_setup">
    ///    A <c>ReqSetup</c> object that holds master planning settings for a specific item ID.
    /// </param>
    public static void bulkInitFromInventTransOrigin(
        ReqPlanData _reqPlanData,
        ReqSetup    _setup)
    {
        ItemId          itemId;
        InventDimId     covDimId;

        ReqTrans        reqTrans;

        SalesLine       salesLine;
        PurchLine       purchLine;
        ProdTable       prodTable;
        ProdBOM         prodBOM;

        InventTransOriginSalesLine  inventTransOriginSalesLine;
        InventTransOriginPurchLine  inventTransOriginPurchLine;
        InventTransOriginProdTable  inventTransOriginProdTable;
        InventTransOriginProdBOM    inventTransOriginProdBOM;

        Set             setCovDimId;
        SetEnumerator   se;

        ReqSetupDim     setupDim;

        #localmacro.updateBOMIdRouteId
            update_recordSet forceplaceholders reqTrans
                setting #ifnot.empty(%1) itemBOMId = salesLine.ItemBOMId #endif
                        #ifnot.empty(%2) #ifnot.empty(%1), #endif itemRouteId = salesLine.ItemRouteId #endif
                where  reqTrans.PlanVersion     == _reqPlanData.parmReqPlanVersionRefRecId()
                    && reqTrans.RefType         == ReqRefType::Sales
                    && reqTrans.ItemId          == itemId
                    && reqTrans.CovInventDimId  == covDimId
                join TableId from inventTransOriginSalesLine
                    where inventTransOriginSalesLine.InventTransOrigin == reqTrans.InventTransOrigin
                join ItemBOMId,ItemRouteId from salesLine
                    where salesLine.InventTransId   == inventTransOriginSalesLine.SalesLineInventTransId
                       && salesLine.DataAreaId      == inventTransOriginSalesLine.SalesLineDataAreaId;

            update_recordSet forceplaceholders reqTrans
                setting #ifnot.empty(%1) itemBOMId = purchLine.ItemBOMId #endif
                        #ifnot.empty(%2) #ifnot.empty(%1), #endif itemRouteId = purchLine.ItemRouteId #endif
                where  reqTrans.PlanVersion     == _reqPlanData.parmReqPlanVersionRefRecId()
                    && reqTrans.RefType         == ReqRefType::Purch
                    && reqTrans.ItemId          == itemId
                    && reqTrans.CovInventDimId  == covDimId
                join TableId from inventTransOriginPurchline
                    where inventTransOriginPurchline.InventTransOrigin == reqTrans.InventTransOrigin
                join ItemBOMId,ItemRouteId from Purchline
                    where Purchline.InventTransId   == inventTransOriginPurchline.PurchlineInventTransId
                       && Purchline.DataAreaId      == inventTransOriginPurchline.PurchlineDataAreaId;

            update_recordSet forceplaceholders reqTrans
                setting #ifnot.empty(%1) itemBOMId = prodTable.BOMId #endif
                        #ifnot.empty(%2) #ifnot.empty(%1), #endif itemRouteId = prodTable.RouteId #endif
                where  reqTrans.PlanVersion     == _reqPlanData.parmReqPlanVersionRefRecId()
                    && reqTrans.RefType         == ReqRefType::Production
                    && reqTrans.ItemId          == itemId
                    && reqTrans.CovInventDimId  == covDimId
                join TableId from inventTransOriginProdTable
                    where inventTransOriginProdTable.InventTransOrigin == reqTrans.InventTransOrigin
                join BOMId, RouteId from ProdTable
                    where ProdTable.ProdId          == inventTransOriginProdTable.ProdOrderId
                       && ProdTable.DataAreaId      == inventTransOriginProdTable.ProdOrderDataAreaId;

            update_recordSet forceplaceholders reqTrans
                setting #ifnot.empty(%1) itemBOMId = prodBOM.ItemBOMId #endif
                        #ifnot.empty(%2) #ifnot.empty(%1), #endif itemRouteId = prodBOM.ItemRouteId #endif
                where  reqTrans.PlanVersion     == _reqPlanData.parmReqPlanVersionRefRecId()
                    && reqTrans.RefType         == ReqRefType::ProdLine
                    && reqTrans.ItemId          == itemId
                    && reqTrans.CovInventDimId  == covDimId
                join TableId from inventTransOriginProdBOM
                    where inventTransOriginProdBOM.InventTransOrigin == reqTrans.InventTransOrigin
                join ItemBOMId,ItemRouteId from ProdBOM
                    where ProdBOM.InventTransId   == inventTransOriginProdBOM.ProdBOMInventTransId
                       && ProdBOM.DataAreaId      == inventTransOriginProdBOM.ProdBOMDataAreaId;

        #endmacro

        itemId = _setup.itemId();

        reqTrans.skipDataMethods(true);

        if (_reqPlanData.reqTransCache())
        {
            setCovDimId = _reqPlanData.reqTransCache().itemDimSet(itemId);
        }

        if (! setCovDimId)
        {
            setCovDimId = new Set(Types::String);

            while select CovInventDimId from reqTrans
                group by CovInventDimId
                where  reqTrans.PlanVersion == _reqPlanData.parmReqPlanVersionRefRecId()
                    && reqTrans.ItemId      == itemId
            {
                setCovDimId.add(reqTrans.CovInventDimId);
            }
        }

        se = setCovDimId.getEnumerator();

        // loop coverage dimensions
        while (se.moveNext())
        {
            setupDim = _reqPlanData.newReqSetupDim(_setup,se.current());

            if (setupDim.bomVersionReq() || setupDim.routeVersionReq())
            {
                covDimId = setupDim.inventDim().InventDimId;

                switch (true)
                {
                    case setupDim.bomVersionReq() && ! setupDim.routeVersionReq():
                        // update only bomId
                        #updateBOMIdRouteId(true)
                        break;

                    case ! setupDim.bomVersionReq() && setupDim.routeVersionReq():
                        // update only routeId
                        #updateBOMIdRouteId(,true)
                        break;

                    case setupDim.bomVersionReq() && setupDim.routeVersionReq():
                        // update bomId and routeId
                        #updateBOMIdRouteId(true,true)
                        break;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>disableAutoFirm</Name>
				<Source><![CDATA[
    public boolean disableAutoFirm(boolean _disableAutoFirm = disableAutoFirm)
    {
        disableAutoFirm = _disableAutoFirm;
        return disableAutoFirm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cacheReduceKey2Dates</Name>
				<Source><![CDATA[
    public static container cacheReduceKey2Dates(str _cachekey)
    {
        TransDate   fromDate;
        TransDate   toDate;

        Integer     p1;

        p1 = strFind(_cachekey,'#',1,strLen(_cachekey));

        fromDate     = num2date(str2int(subStr(_cachekey,1,p1-1)));
        toDate       = num2date(str2int(subStr(_cachekey,p1+1,strLen(_cachekey)-p1)));

        return [fromDate,toDate];
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static ReqCalc construct()
    {
        return new ReqCalc();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dates2cacheReduceKey</Name>
				<Source><![CDATA[
    private static str dates2cacheReduceKey(
        TransDate       _fromDate,
        TransDate       _toDate
        )
    {
        return int2str(date2num(_fromDate))+'#'+int2str(date2num(_toDate));
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS25606";
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqTransCoverage2SortKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a sort key used to sort requirement transactions during coverage calculation.
    /// </summary>
    /// <param name="_reqTrans">
    /// The <c>ReqTrans</c>
    /// </param>
    /// <param name="_reqDate">
    /// The <c>ReqDate</c>
    /// </param>
    /// <param name="_pdsConsiderShelfLife">
    /// A boolean value indicating whether shelf life must be considered.
    /// </param>
    /// <returns>
    /// The sort key.
    /// </returns>
    public static str reqTransCoverage2SortKey(
        ReqTrans    _reqTrans,
        ReqDate     _reqDate = _reqTrans.ReqDate,
        boolean     _pdsConsiderShelfLife = false)
    {
        return ReqCalc::getReqTransCoverage2SortKey(_reqTrans, _reqDate, _pdsConsiderShelfLife, /* considerPriority: */ true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReqTransCoverage2SortKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a sort key used to sort requirement transactions during coverage calculation.
    /// </summary>
    /// <param name="_reqTrans">
    /// The <c>ReqTrans</c>
    /// </param>
    /// <param name="_reqDate">
    /// The <c>ReqDate</c>
    /// </param>
    /// <param name="_pdsConsiderShelfLife">
    /// A boolean value indicating whether shelf life must be considered.
    /// </param>
    /// <param name="_considerPriority">
    /// A boolean value indicating whether priority of requirement transaction must be considered.
    /// </param>
    /// <returns>
    /// The sort key.
    /// </returns>
    private static str getReqTransCoverage2SortKey(
        ReqTrans    _reqTrans,
        ReqDate     _reqDate = _reqTrans.ReqDate,
        boolean     _pdsConsiderShelfLife = false,
        boolean     _considerPriority = true)
    {
        const int PriorityPosOffset = 50;
        const int NumLength = 3;
        const int TimeNumLength = 5;
        const int SellableDaysLength = 5;

        int sortRefType;

        //Order by: ReqTrans.Priority (must be converted to positive number since it is string ordering)
        //          ReqRefType::SafetyInvent last (if batch expiration date is not considered)
        //          ReqTrans.ReqDate
        //          ReqTrans.RecId
        //          SafetyInvent receipts first, then all other orders, then SafetyInventIssues

        switch (_reqTrans.RefType)
        {
            case ReqRefType::SafetyInvent:
                if (_reqTrans.Direction == InventDirection::Issue)
                {
                    sortRefType = 20;
                }
                else
                {
                    sortRefType = 0;
                }
                break;
            default:
                sortRefType = 10;
        }

        str dateSafetyInventOrdering = strFmt("%1#%2#%3#%4",
                int2str(date2num(_reqDate)),
                num2Str0(_reqTrans.ReqTime, TimeNumLength),
                _pdsConsiderShelfLife ? num2Str0(_reqTrans.PdsSellableDays, SellableDaysLength) : '',
                num2Str0(sortRefType, NumLength));

        str value = strFmt('%1#%2#%3#%4',
            #PmfEnabled ? num2Str0(_reqTrans.PmfPlanPriorityCurrent + PriorityPosOffset, NumLength) : '',
            _considerPriority ? num2Str0(_reqTrans.Priority + PriorityPosOffset, NumLength) : num2Str0(PriorityPosOffset, NumLength),
            dateSafetyInventOrdering,
            _reqTrans.RecId);

        return value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>covReqTransOrderKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the string key of the transaction which determines the coverage order.
    /// </summary>
    /// <param name = "_reqTrans">A <c>ReqTrans</c> record.</param>
    /// <returns>The string key which determines the coverage order.</returns>
    private str covReqTransOrderKey(ReqTrans _reqTrans)
    {
        return ReqCalc::reqTransCoverage2SortKey(_reqTrans, _reqTrans.ReqDate, this.coverageEngineForReqTrans(_reqTrans).mustConsiderShelfLife());
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqTransFutures2sortKey</Name>
				<Source><![CDATA[
    private static str reqTransFutures2sortKey(ReqTrans _reqTrans)
    {
        if (_reqTrans.isPlannedOrder())
        {
            ReqPO reqPO = _reqTrans.reqPo();

            return int2str(date2num(reqPO.ReqDateOrder))+'#'+int2str(reqPO.ReqTimeOrder)+ '#' + strFmt('%1', _reqTrans.RecId);
        }

        return int2str(date2num(_reqTrans.ReqDate))+'#'+int2str(_reqTrans.ReqTime)+ '#' + strFmt('%1', _reqTrans.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAllItems</Name>
				<Source><![CDATA[
    [SysObsolete("Use the shouldUpdateAllItems and override buildBaseQuery instead. This method does not consider joins properly.",false, 31\03\2019)]
    public static boolean updateAllItems(QueryRun _queryRun)
    {
        Integer i;
        Integer j;
        Query   query = _queryRun.query();

        for (i = 1; i <= query.dataSourceCount(); i++)
        {
            QueryBuildDataSource queryBuildDataSource = query.dataSourceNo(i);
            for (j = 1; j <= queryBuildDataSource.rangeCount(); j++)
            {
                if (queryBuildDataSource.range(j).value())
                {
                    return false;
                }
            }
        }

        for (j = 1; j <= query.queryFilterCount(); j++)
        {
            if (query.queryFilter(j).value())
            {
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>manageExceptionDeadLock</Name>
				<Source><![CDATA[
    protected boolean manageExceptionDeadLock()
    {
        WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::Error, 'Deadlock');

        if (xSession::currentRetryCount() >= #RetryNum)
        {
            throw Exception::Deadlock;
        }
        else
        {
            reqPlanData.incrementRetryReqLog(Exception::Deadlock);
            return true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>manageExceptionDeadLockRestoreReqCalc</Name>
				<Source><![CDATA[
    protected boolean manageExceptionDeadLockRestoreReqCalc()
    {
        WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::Error, 'Deadlock');

        if (xSession::currentRetryCount() >= #RetryNum)
        {
            throw Exception::Deadlock;
        }
        else
        {
            reqPlanData.restoreReqLog();
            reqPlanData.incrementRetryReqLog(Exception::Deadlock);
            return true;
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>retryTransientSqlConnectionError</Name>
				<Source><![CDATA[
    protected boolean retryTransientSqlConnectionError()
    {
        WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::Error, 'TransientSqlConnectionError');
        if (ReqTransientSqlConnectionErrorHandlingHelper::retryTransientSqlConnectionError())
        {
            reqPlanData.incrementRetryReqLog(Exception::TransientSqlConnectionError);
            return true;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>retryExceptionErrorRestoreReqCalc</Name>
				<Source><![CDATA[
    private boolean retryExceptionErrorRestoreReqCalc(int _infologLineTry)
    {
        if (this.retryExceptionError(_infologLineTry))
        {
            reqPlanData.restoreReqLog();
            return true;
        }
        
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retryExceptionError</Name>
				<Source><![CDATA[
    private boolean retryExceptionError(int _infologLineTry) 
    {
        if (!reqCalcRetryExceptionErrorWhenCausedBySQLErrorEnabled)
        {
            return false;
        }

        try
        {
            this.reqInstrumentationLogger().logInformation('Checking if Exception::Error was caused by a SQL issue.');
        }
        catch
        {
        }

        var shouldRetry = ReqTransientSqlConnectionErrorHandlingHelper::isExceptionErrorCausedBySQLError(_infologLineTry)
            && ReqTransientSqlConnectionErrorHandlingHelper::retryTransientSqlConnectionError();

        if (shouldRetry)
        {
            try
            {
                this.reqInstrumentationLogger().logInformation('Retrying Exception::Error that was caused by a SQL issue.');
            }
            catch
            {
            }
        }

        return shouldRetry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retryTransientSqlConnectionErrorRestoreReqCalc</Name>
				<Source><![CDATA[
    protected boolean retryTransientSqlConnectionErrorRestoreReqCalc()
    {
        WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::Error, 'TransientSqlConnectionError');
        if (ReqTransientSqlConnectionErrorHandlingHelper::retryTransientSqlConnectionError())
        {
            reqPlanData.restoreReqLog();
            reqPlanData.incrementRetryReqLog(Exception::TransientSqlConnectionError);
            return true;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>manageExceptionDuplicateKeyException</Name>
				<Source><![CDATA[
    protected boolean manageExceptionDuplicateKeyException()
    {
        WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::Error, 'DuplicateKey');
        if (appl.ttsLevel() == 0)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::DuplicateKeyExceptionNotRecovered;
            }
            else
            {
                reqPlanData.incrementRetryReqLog(Exception::DuplicateKeyException);
                return true;
            }
        }
        else
        {
            throw Exception::DuplicateKeyException;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>manageExceptionUpdateConflict</Name>
				<Source><![CDATA[
    protected boolean manageExceptionUpdateConflict()
    {
        WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::Error, 'UpdateConflict');
        if (appl.ttsLevel() == 0)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::UpdateConflictNotRecovered;
            }
            else
            {
                reqPlanData.incrementRetryReqLog(Exception::UpdateConflict);
                return true;
            }
        }
        else
        {
            throw Exception::UpdateConflict;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>manageExceptionUpdateConflictRestoreReqCalc</Name>
				<Source><![CDATA[
    protected boolean manageExceptionUpdateConflictRestoreReqCalc()
    {
        WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::Error, 'UpdateConflict');
        if (appl.ttsLevel() == 0)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::UpdateConflictNotRecovered;
            }
            else
            {
                reqPlanData.restoreReqLog();
                reqPlanData.incrementRetryReqLog(Exception::UpdateConflict);
                return true;
            }
        }
        else
        {
            throw Exception::UpdateConflict;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>manageExceptionError</Name>
				<Source><![CDATA[
    protected boolean manageExceptionError()
    {
        WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::Error, 'UnknownException');
        if (xSession::currentRetryCount() >= #RetryNum)
        {
            throw error("@SYS320450");
        }
        else
        {
            reqPlanData.incrementRetryReqLog(Exception::Error);
            return true;
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>dispose</Name>
				<Source><![CDATA[
    /// <summary>
    /// Disposes the current instance of an object.
    /// </summary>
    public void dispose()
    {
        if (reqPlanManager && !doNotDisposeReqPlanManager)
        {
            reqPlanManager.dispose();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyKeptCoverage</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Applies kept coverage to the actual plan version.
    /// </summary>
    /// <param name="_setup">
    ///     A <c>ReqSetup</c> object that contains item ID that will be used during the apply process.
    /// </param>
    protected void applyKeptCoverage(ReqSetup _setup)
    {
        ReqTransCov reqTransCovExists;

        if (_setup == null || _setup.itemId() == '')
        {
            return;
        }

        select firstOnly RecId
            from   reqTransCovExists
            where  reqTransCovExists.PlanVersion  == this.reqPlanVersionRefRecId()
                && reqTransCovExists.ItemId       == _setup.itemId();

        if (reqTransCovExists)
        {
            this.updateKeptCoverageIssueRecId(_setup);
            this.deleteInvalidCoverageByIssue(_setup);
            this.recalculateCoveredQty(_setup);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteInvalidCoverageByIssue</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Deletes ReqTransCov records for non existing issues.
    /// </summary>
    /// <param name="_setup">
    ///     A <c>ReqSetup</c> object that contains item ID that will be used during the deletion process.
    /// </param>
    protected void deleteInvalidCoverageByIssue(ReqSetup _setup)
    {
        ReqTrans            reqTransIssue;
        ReqTransCov         reqTransCov;

        new SkipAOSValidationPermission().assert();

        reqTransCov.skipAosValidation(true);
        reqTransCov.skipDataMethods(true);

        delete_from reqTransCov
            where  reqTransCov.PlanVersion      == this.reqPlanVersionRefRecId()
                && reqTransCov.ItemId           == _setup.itemId()
            notexists join reqTransIssue
            where  reqTransIssue.RecId          == reqTransCov.IssueRecId
                && reqTransIssue.PlanVersion    == reqTransCov.PlanVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteInvalidCoverageByReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Deletes ReqTransCov records for non existing receipts.
    /// </summary>
    /// <param name="_setup">
    ///     A <c>ReqSetup</c> object that contains item ID that will be used during the deletion process.
    /// </param>
    protected void deleteInvalidCoverageByReceipt(ReqSetup _setup)
    {
        ReqTrans            reqTransReceipt;
        ReqTransCov         reqTransCov;

        new SkipAOSValidationPermission().assert();

        reqTransCov.skipAosValidation(true);
        reqTransCov.skipDataMethods(true);

        delete_from reqTransCov
            where  reqTransCov.PlanVersion      == this.reqPlanVersionRefRecId()
                && reqTransCov.ItemId           == _setup.itemId()
                && !reqTransCov.IsDerivedDirectly
        notexists join reqTransReceipt
            where  reqTransReceipt.RecId        == reqTransCov.ReceiptRecId
                && reqTransReceipt.PlanVersion  == reqTransCov.PlanVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertReqTransCovKeep</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts coverage information to ReqTransCovKeep table based on approved planned orders coverage.
    /// </summary>
    /// <param name="_reqPlanVersionFrom">
    ///    The source plan version.
    /// </param>
    /// <param name="_reqPlanVersionTo">
    ///    The target plan version.
    /// </param>
    /// <param name="_itemId">
    ///    The ID of the item to process.
    /// </param>
    protected void insertReqTransCovKeep(ReqPlanVersion _reqPlanVersionFrom, ReqPlanVersion _reqPlanVersionTo, ItemId _itemId = '')
    {
        ReqTrans        reqTransIssue;
        ReqTrans        reqTransReceipt;
        ReqTransCov     reqTransCov;
        ReqPO           reqPo;
        ReqTransCovKeep reqTransCovKeep;
        RefRecId        reqPlanVersionToRecId   = _reqPlanVersionTo.RecId;

        if (!updateAllItems && _itemid != '')
        {
            delete_from reqTransCovKeep
                where  reqTransCovKeep.PlanVersion == reqPlanVersionToRecId
                    && reqTransCovKeep.itemid      == _itemid;
        }

        try
        {
            insert_recordset reqTransCovKeep (PlanVersion, ItemId, CovInventDimId, IssueInventTransOrigin, ReqDate, ReqTime, Priority, IssueLastRecId)
                select reqPlanVersionToRecId, ItemId, CovInventDimId, InventTransOrigin, ReqDate, ReqTime, Priority, RecId
                    from reqTransIssue
                    where  reqTransIssue.PlanVersion                    == _reqPlanVersionFrom.RecId
                        && (reqTransIssue.itemid                        == _itemid || _itemId == '')
                        && reqTransIssue.InventTransOrigin              != 0
                        && reqTransIssue.MarkingRefInventTransOrigin    == 0
                exists join reqTransCov
                    where  reqTransCov.IssueRecId                       == reqTransIssue.RecId
                        && reqTransCov.PlanVersion                      == _reqPlanVersionFrom.RecId
                join reqTransReceipt
                    where  reqTransReceipt.RecId                        == reqTransCov.ReceiptRecId
                        && reqTransReceipt.PlanVersion                  == _reqPlanVersionFrom.RecId
                join reqPo
                    where  reqPo.RefId                                  == reqTransReceipt.RefId
                        && reqPo.RefType                                == reqTransReceipt.RefType
                        && reqPo.PlanVersion                            == _reqPlanVersionFrom.RecId
                        && (reqPo.ReqPOStatus                           == ReqPOStatus::Approved
                            || (ReqCalcKanbanDerivedDirectlyPONotDuplicatedToggle::instance().isEnabled() && reqPo.IsDerivedDirectly));
        }
        catch (Exception::DuplicateKeyException)
        {
            error("@SCMPlanning:ReqPlanCopyDuplicateKeyException");
            throw;
        }
        catch (Exception::DuplicateKeyExceptionNotRecovered)
        {
            error("@SCMPlanning:ReqPlanCopyDuplicateKeyException");
            throw;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>recalculateCoveredQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates ReqTrans.CovQty based on actual coverage.
    /// </summary>
    /// <param name="_setup">
    ///     A <c>ReqSetup</c> object that contains item ID that will be used during the apply process.
    /// </param>
    protected void recalculateCoveredQty(ReqSetup _setup)
    {
        ReqTransCov     reqTransCov;
        ReqTrans        reqTransReceipt;
        ReqTrans        reqTransIssue;

        ReqQtyCoverage  availableCovQty;
        ReqQtyCoverage  reducedCovQty;

        Set updatedReqTransIssue    = new Set(Types::Int64);
        Set updatedReqTransReceipt  = new Set(Types::Int64);

        // For ReqTransCov records that has both issue and receipt in 'to' plan version update CovQty
        while select forupdate reqTransCov
                where  reqTransCov.PlanVersion      == this.reqPlanVersionRefRecId()
                    && reqTransCov.ItemId           == _setup.itemId()
                    && reqTransCov.Qty              <  0
                join   forupdate reqTransIssue
                where  reqTransIssue.RecId          == reqTransCov.IssueRecId
                    && reqTransIssue.PlanVersion    == reqTransCov.PlanVersion
                join   forupdate reqTransReceipt
                where  reqTransReceipt.RecId        == reqTransCov.ReceiptRecId
                    && reqTransReceipt.PlanVersion  == reqTransCov.PlanVersion
        {
            if (updatedReqTransIssue.in(reqTransIssue.RecId))
            {
                reqTransIssue.reread();
            }
            else
            {
                reqTransIssue.CovQty = 0;
            }

            if (updatedReqTransReceipt.in(reqTransReceipt.RecId))
            {
                reqTransReceipt.reread();
            }
            else
            {
                reqTransReceipt.CovQty = 0;
            }

            availableCovQty = min(abs(reqTransIssue.Qty - reqTransIssue.CovQty), reqTransReceipt.Qty - reqTransReceipt.CovQty);

            if (abs(reqTransCov.Qty) > availableCovQty)
            {
                reducedCovQty = availableCovQty;

                reqTransCov.Qty = -availableCovQty;
                reqTransCov.update();
            }
            else
            {
                reducedCovQty = -reqTransCov.Qty;
            }

            if (reducedCovQty != 0)
            {
                reqTransIssue.CovQty -= reducedCovQty;
                reqTransIssue.setOpenStatus();
                reqTransIssue.update();

                reqTransReceipt.CovQty += reducedCovQty;
                reqTransReceipt.setOpenStatus();
                reqTransReceipt.update();

                updatedReqTransIssue.add(reqTransIssue.RecId);
                updatedReqTransReceipt.add(reqTransReceipt.RecId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateKeptCoverageIssueRecId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates ReqTransCov.IssueRecId to match actual plan version's recIds.
    /// </summary>
    /// <param name="_setup">
    ///     A <c>ReqSetup</c> object that contains item ID that will be used during the apply process.
    /// </param>
    protected void updateKeptCoverageIssueRecId(ReqSetup _setup)
    {
        ReqTrans            reqTransIssue;
        ReqTransCov         reqTransCov;
        ReqTransCovKeep     reqTransCovKeep;

        new SkipAOSValidationPermission().assert();

        reqTransCov.skipAosValidation(true);
        reqTransCov.skipDataMethods(true);

        ReqCalcKeptCoverageIssueRecIdUpdateQueryBuilder::update(reqTransIssue, reqTransCov, reqTransCovKeep, this, _setup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReqProcessTransFilterForInventJournalReqTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creating missed requirement transactions process filter for <c>ReqTrans</c> with inventory journal type.
    /// </summary>
    /// <param name="_itemId">
    ///     An item ID that will be used to find reqTrans.
    /// </param>
    protected void createReqProcessTransFilterForInventJournalReqTrans(ItemId _itemId)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>releaseResources</Name>
				<Source><![CDATA[
    private void releaseResources()
    {
        if (reqCalcTaskController)
        {
            reqCalcTaskController.Dispose();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPlanActiveVersion</Name>
				<Source><![CDATA[
    private ReqPlanVersion getPlanActiveVersion(ReqPlanId _reqPlanId)
    {
        return ReqPlan::findReqPlanId(_reqPlanId).getActiveVersion();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOriginalMainThread</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current instance is the original ReqCalc main thread.
    /// </summary>
    /// <returns>true if the current instance is the original ReqCalc main thread; otherwise, false.</returns>
    protected boolean isOriginalMainThread()
    {
        return !thisIsChildThread && !resumeProcessId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    public void initParmDefault()
    {
        super();

        if (this.canRunMultiThreaded())
        {
            this.maxChildThreads = reqParameters.DefaultNumberOfThreads;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunMultiThreaded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns true if the class is designed to support running multi-threaded, false otherwise.
    /// </summary>
    /// <returns>True if the class supports running multi-threaded, false otherwise.</returns>
    [Hookable(false)]
    protected boolean canRunMultiThreaded()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateMaxChildThreads</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the planning is allowed to be scheduled with maximum number of children threads.
    /// </summary>
    /// <returns>True if planning is scheduled with number of children threads as a batch job; otherwise, false.</returns>
    internal static boolean validateMaxChildThreads(RunBaseBatch _runBaseBatch, ReqProcessNumThreads _maxChildThreads)
    {
        if (ReqCalcScheduleNotInBatchWithChildrenValidationToggle::instance().isEnabled())
        {
            if (_maxChildThreads > 0 && !ReqCalc::willBeExecutingInBatch(_runBaseBatch))
            {
                error("@SCMPlanning:ReqCalcScheduleNotBatchWithChildren");
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>willBeExecutingInBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the planning run will be executing as a batch job.
    /// ==> parmBatchExecute determines whether "Batch processing" parameter is enabled or disabled in "Run in background" section of dialog.
    /// ==> isExecutingInBatch determines whether the code is running in the batch server context.
    /// ==> parmInBatch determines whether the planning is scheduled from Batch jobs form.
    /// </summary>
    /// <returns>True if planning will be running in the batch job; otherwise, false.</returns>
    internal static boolean willBeExecutingInBatch(RunBaseBatch _runBaseBatch)
    {
        return _runBaseBatch.batchInfo().parmBatchExecute() || BatchHeader::isExecutingInBatch() || _runBaseBatch.parmInBatch();
    }

]]></Source>
			</Method>
			<Method>
				<Name>ensureBlankReqLogExists</Name>
				<Source><![CDATA[
    private ReqLog ensureBlankReqLogExists(ReqProcessId _processId, ReqPlanId _reqPlanId, ReqLogId _reqLogId)
    {
        if (ReqMRPStatisticsTaskRetriableToggle::instance().isEnabled())
        {
            ReqLog existingReqLog;

            select firstonly existingReqLog
                where existingReqLog.ProcessId == _processId
                   && existingReqLog.ReqPlanId == _reqPlanId
                   && existingReqLog.ReqLogId == _reqLogId;

            if (existingReqLog.RecId)
            {
                return existingReqLog;
            }
        }

        ReqProcessList reqProcessList = reqTransCache.reqProcessList();

        ReqLog blankReqLog;
        blankReqLog.ProcessId = _processId;
        blankReqLog.MaxChildThreads = reqProcessList.MaxChildThreads;
        blankReqLog.ReqPlanId = _reqPlanId;
        blankReqLog.ReqLogId = _reqLogId;
        blankReqLog.StartDateTime = DateTimeUtil::maxValue();
        blankReqLog.CapacityConflictsCount = capacityConflictsHandler.getCapacityConflictsCount();

        // get the count of used child threads
        blankReqLog.UsedChildThreads = max(reqCalcTaskController.getThreadCount() - 1, 0);

        ttsbegin;
        blankReqLog.insert();
        ttscommit;

        return blankReqLog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTaskStatistics</Name>
				<Source><![CDATA[
    private void insertTaskStatistics(RefRecId _reqLogRecId)
    {
        ReqCalcTasksBundle bundle;
        ReqLogTaskStatistics taskStatistics;
                
        insert_recordset taskStatistics (Status, Level, LevelState, StartTime, EndTime, Number, ReqLog)
            select Status, Level, LevelState, minof(StartTime), maxof(EndTime), count(RecId), _reqLogRecId from bundle
            group by Status, Level, LevelState
            where bundle.ProcessDataAreaId == curext() && bundle.ProcessId == processId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSkipDefaultRequirementTransactionReqTime</Name>
				<Source><![CDATA[
    private boolean shouldSkipDefaultRequirementTransactionReqTime(InventTrans _inventTrans, InventTransOrigin _inventTransOrigin)
    {
        boolean skipDefaulting = ReqCalcSkipRequirementTransactionReqTimeDefaultingToggle::instance().isEnabled()
                                 && _inventTrans.TimeExpected == 0
                                 && _inventTransOrigin.ReferenceCategory == InventTransType::ProdLine;

        if(skipDefaulting)
        {
            ProdTable prodTable = ProdTable::find(_inventTransOrigin.ReferenceId);
            skipDefaulting = prodTable.Recid != 0 &&  prodTable.ProdStatus == ProdStatus::Scheduled;
        }

        return skipDefaulting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unlockingIntercompanyPlanVersions</Name>
				<Source><![CDATA[
    /// <summary>
    // Added for testing purposes only.
    /// </summary>
    private void unlockingIntercompanyPlanVersions()
    {
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>