<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendSettle_Cust</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>CustVendSettle_Cust</c> class is used upon settling a customer transaction from Open
///    Transaction Editing.
/// </summary>
public class CustVendSettle_Cust extends CustVendSettle
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>createSettlementPair</Name>
				<Source><![CDATA[
    protected void createSettlementPair()
    {
        settlementPair = new SettlementPair_Cust();
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountLossProfit</Name>
				<Source><![CDATA[
    [SysObsolete('This method is obsoleted. Use accountRealizedGainLossFromPostingProfile() instead', false, 01\12\2022)]
    LedgerDimensionDefaultAccount accountLossProfit(Amount _exchRateDiff, CurrencyCode _currencyCode)
    {
        LedgerDimensionDefaultAccount defaultAccount;
        CurrencyGainLossAccountType   accountType;

        if (_exchRateDiff < 0)
        {
            accountType = CurrencyGainLossAccountType::RealizedGain;
        }
        else
        {
            accountType = CurrencyGainLossAccountType::RealizedLoss;
        }

        defaultAccount = CurrencyLedgerGainLossAccount::ledgerDimension(
            Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
            _currencyCode,
            accountType);

        return defaultAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountNonrealLossProfit</Name>
				<Source><![CDATA[
    [SysObsolete('This method is obsoleted. Use accountUnrealizedGainLossFromPostingProfile() instead', false, 01\12\2022)]
    LedgerDimensionDefaultAccount accountNonrealLossProfit(Amount _exchRateDiff, CurrencyCode _currencyCode)
    {
        LedgerDimensionDefaultAccount defaultAccount;
        CurrencyGainLossAccountType   accountType;

        if (_exchRateDiff > 0)
        {
            accountType = CurrencyGainLossAccountType::UnrealizedGain;
        }
        else
        {
            accountType = CurrencyGainLossAccountType::UnrealizedLoss;
        }

        defaultAccount = CurrencyLedgerGainLossAccount::ledgerDimension(
            Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
            _currencyCode,
            accountType);

        return defaultAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountRealizedGainLossFromPostingProfile</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountRealizedGainLossFromPostingProfile(Amount _exchRateDiff, CurrencyCode _currencyCode, AccountNum _accountNum)
    {
        CurrencyGainLossAccountType accountType = _exchRateDiff < 0 ? CurrencyGainLossAccountType::RealizedGain : CurrencyGainLossAccountType::RealizedLoss;

        return this.getDefaultLedgerDimensionFromPostingProfile(
            _accountNum,
            accountType,
            _currencyCode,
            LedgerExchAdjPostingModule::AccountsReceivable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountUnrealizedGainLossFromPostingProfile</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountUnrealizedGainLossFromPostingProfile(Amount _exchRateDiff, CurrencyCode _currencyCode, AccountNum _accountNum)
    {
        CurrencyGainLossAccountType accountType = _exchRateDiff > 0 ? CurrencyGainLossAccountType::UnrealizedGain : CurrencyGainLossAccountType::UnrealizedLoss;

        return this.getDefaultLedgerDimensionFromPostingProfile(
            _accountNum,
            accountType,
            _currencyCode,
            LedgerExchAdjPostingModule::AccountsReceivable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscMethod</Name>
				<Source><![CDATA[
    UnspecificSpecific cashDiscMethod()
    {
        return  CustParameters::find().CashDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscVat</Name>
				<Source><![CDATA[
    boolean cashDiscVat()
    {
        return TaxCashDiscountParametersHelper::cashDiscInclTax(ModuleCustVend::Cust);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIfCanBeSettled_RU</Name>
				<Source><![CDATA[
    protected boolean checkIfCanBeSettled_RU(TransDate _settlementDate)
    {
        boolean ret = super(_settlementDate);

        if (ret)
        {
            ret = CustTrans::checkIfCanBeSettled_RU(settlementPair.getCustVendTransDebit(),
                                                    settlementPair.getCustVendTransCredit(),
                                                    _settlementDate,
                                                    true,
                                                    offsetVoucher.parmDimSettlementType_RU());
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCreditNoteForCashDiscount_CZ</Name>
				<Source><![CDATA[
    /// <summary>
    ///     The method creates <c>CustInvoiceJour</c> and <c>CustInvoiceTrans</c>
    ///     for discount trans <c>CustTrans</c>.
    /// </summary>
    /// <param name="_custVendTrans">
    ///     Source  <c>CustTrans</c> record for discount trans.
    /// </param>
    /// <param name="_discTrans">
    ///     Discount trans <c>CustTrans</c> record.
    /// </param>
    /// <param name="_cashDiscAmountMst">
    ///     Discount amount value in MST.
    /// </param>
    /// <param name="_discLedgerDimension">
    ///     LedgerDimensionDefaultAccount value for <c>CustInvoiceTrans</c>.
    /// </param>
    /// <remarks>
    ///     Reverse document is used for Czech Republic.
    /// </remarks>
    /// <exception cref="Exception::Error">
    ///     If cust parameter CreditNoteReasonReq is ON and ReasonCodeCashDiscount_CZ is empty, the system terminates posting.
    /// </exception>
    protected void createCreditNoteForCashDiscount_CZ(
        CustVendTrans                   _custVendTrans,
        CustTrans                       _discTrans,
        AmountMST                       _cashDiscAmountMst,
        LedgerDimensionDefaultAccount   _discLedgerDimension)
    {
        CustTrans               discTransToAdjust;
        CustSettlement          dictSettlementToAdjust;
        CustInvoiceJour         custInvoiceJour;

        if (CustParameters::find().CreditNoteReasonReq
            && !CustParameters::find().ReasonCodeCashDiscount_CZ)
        {
            throw error("@SYS4002420");
        }

        // Create credit note for discount trans
        custInvoiceJour = this.createCustInvoiceJourDiscount_CZ(_custVendTrans, _discTrans, _cashDiscAmountMst, _discLedgerDimension);

        if (custInvoiceJour)
        {
            // The real discTrans will be posted from custVendTransSettlement. _discTrans is just a copy
            [discTransToAdjust, dictSettlementToAdjust] = custVendTransSettlement.findTransAndSettlement(_discTrans, settlementGroupPlaceHolder, _discTrans.OffsetRecid);
            if (discTransToAdjust.AccountNum)
            {
                discTransToAdjust.Invoice = custInvoiceJour.InvoiceId;
                custVendTransSettlement.modifyTransAndSettlement(discTransToAdjust, dictSettlementToAdjust, settlementGroupPlaceHolder, discTransToAdjust.OffsetRecid, true, false);
            }

            info(strFmt("@SYS4002421", custInvoiceJour.InvoiceId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustInvoiceJourDiscount_CZ</Name>
				<Source><![CDATA[
    private CustInvoiceJour createCustInvoiceJourDiscount_CZ(
        CustTrans                       _custTrans,
        CustTrans                       _discTrans,
        AmountMST                       _cashDiscAmountMst,
        LedgerDimensionDefaultAccount   _discLedgerDimension)
    {
        CustInvoiceJour             custInvoiceJour;
        CustInvoiceJour_W           custInvoiceJour_W;
        ReasonCodeCashDiscount_CZ   reasonCode;
        ReasonComment               reasonComment;

        CustInvoiceTrans            custInvoiceTransCashDisc;
        TaxTrans                    taxTrans;
        TaxTable                    taxTable;
        boolean                     transactionLinesCreated;

        AmountCur                   sumTax;
        AmountMST                   sumTaxMST;
        AmountCur                   salesBalance;
        AmountCur                   salesBalanceMST;

        boolean isCountrySupportingAdditionalCreditNoteCashDisc = SysCountryRegionCode::isLegalEntityInCountryRegion(CustParameters::listOfCountriesForCreditNoteCashDisc());

        if (isCountrySupportingAdditionalCreditNoteCashDisc)
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceGB00009, funcName());
        }

        custInvoiceJour.initValue();
        custInvoiceJour.initFromCustTable(CustTable::find(_discTrans.AccountNum));
        custInvoiceJour.initFromCustTrans(_discTrans);

        custInvoiceJour.DocumentDate    = custInvoiceJour.InvoiceDate;
        custInvoiceJour.FixedDueDate    = custInvoiceJour.InvoiceDate;
        custInvoiceJour.DueDate         = custInvoiceJour.InvoiceDate;
        custInvoiceJour.SalesBalance    = custInvoiceJour.InvoiceAmount;
        custInvoiceJour.InvoiceId       = CustVendSettle_Cust::getNewCreditNoteForCashDiscountId_CZ();
        custInvoiceJour.Updated         = NoYes::Yes;

        CustInvoiceJour sourceCustInvoiceJour = this.findInvoice(_custTrans.AccountNum, _custTrans.Invoice, _custTrans.Voucher, _custTrans.TransDate);
        custInvoiceJour.Listcode = sourceCustInvoiceJour ? sourceCustInvoiceJour.Listcode : custInvoiceJour.Listcode;

        custInvoiceJour.PostingProfile  = _discTrans.PostingProfile;
        custInvoiceJour.SalesType       = SalesType::Journal;

        reasonCode                      = CustParameters::find().ReasonCodeCashDiscount_CZ;
        reasonComment                   = ReasonTable::find(reasonCode).Description;
        custInvoiceJour.ReasonTableRef  = ReasonTableRef::createReasonTableRef(reasonCode, reasonComment);

        custInvoiceJour_W               = custInvoiceJour.custInvoiceJour_W();
        custInvoiceJour_W.CashDiscOrigInvoiceCustTrans_CZ   = _custTrans.RecId;
        custInvoiceJour.packCustInvoiceJour_W(custInvoiceJour_W);

        custInvoiceJour.insert();

        while select sum(TaxBaseAmount), sum(TaxAmount), sum(SourceBaseAmountCur), sum(SourceTaxAmountCur) from taxTrans
            group by TaxGroup, TaxItemGroup
                where   taxTrans.Voucher    == _discTrans.Voucher
                   &&   taxTrans.TransDate  == _discTrans.TransDate
            exists join taxTable
                where   taxTable.TaxCode        == taxTrans.TaxCode
                   &&   (taxTable.TaxType_W     == TaxType_W::VAT
                        || taxTable.TaxType_W   == TaxType_W::VATReduced
                        || taxTable.TaxType_W   == TaxType_W::VATZero
                        || isCountrySupportingAdditionalCreditNoteCashDisc)
        {
            custInvoiceTransCashDisc.clear();
            custInvoiceTransCashDisc.initValue();
            custInvoiceTransCashDisc.initFromCustInvoiceJour(custInvoiceJour);

            custInvoiceTransCashDisc.ReasonRefRecId = custInvoiceJour.ReasonTableRef;
            custInvoiceTransCashDisc.OrigSalesId    = custInvoiceJour.SalesId;
            custInvoiceTransCashDisc.SalesId        = custInvoiceJour.SalesId;
            custInvoiceTransCashDisc.InventDimId    = InventDim::inventDimIdBlank();
            custInvoiceTransCashDisc.Qty            = isCountrySupportingAdditionalCreditNoteCashDisc ? 0 : -1;
            custInvoiceTransCashDisc.PriceUnit      = 0;
            custInvoiceTransCashDisc.LedgerDimension    = _discLedgerDimension;
            custInvoiceTransCashDisc.Name           = isCountrySupportingAdditionalCreditNoteCashDisc ? _discTrans.Txt : _custTrans.Voucher;
            custInvoiceTransCashDisc.TaxGroup       = taxTrans.TaxGroup;
            custInvoiceTransCashDisc.TaxItemGroup   = taxTrans.TaxItemGroup;
            custInvoiceTransCashDisc.SalesPrice     = isCountrySupportingAdditionalCreditNoteCashDisc ? 0 : taxTrans.SourceBaseAmountCur;
            custInvoiceTransCashDisc.LineAmount     = -taxTrans.SourceBaseAmountCur;
            custInvoiceTransCashDisc.LineAmountMST  = -taxTrans.TaxBaseAmount;
            custInvoiceTransCashDisc.TaxAmount      = -taxTrans.SourceTaxAmountCur;
            custInvoiceTransCashDisc.TaxAmountMST   = -taxTrans.TaxAmount;

            custInvoiceTransCashDisc.insert();

            transactionLinesCreated                 = true;
            sumTax                                  += custInvoiceTransCashDisc.TaxAmount;
            sumTaxMST                               += custInvoiceTransCashDisc.TaxAmountMST;
            salesBalance                            += custInvoiceTransCashDisc.LineAmount;
            salesBalanceMST                         += custInvoiceTransCashDisc.LineAmountMST;
        }

        if  (!transactionLinesCreated)
        {
            custInvoiceJour.doDelete();
            custInvoiceJour.clear();
        }
        else
        {
            custInvoiceJour = custInvoiceJour::findRecId(custInvoiceJour.RecId, true);
            custInvoiceJour.SumTax          = sumTax;
            custInvoiceJour.SumTaxMST       = sumTaxMST;
            custInvoiceJour.SalesBalance    = salesBalance;
            custInvoiceJour.SalesBalanceMST = salesBalanceMST;
            custInvoiceJour.InvoiceAmount   = salesBalance + sumTax;
            custInvoiceJour.InvoiceAmountMST = salesBalanceMST + sumTaxMST;
            custInvoiceJour.doUpdate();
        }

        return custInvoiceJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>crossCompanyTxt</Name>
				<Source><![CDATA[
    protected LedgerTransTxt crossCompanyTxt()
    {
        return LedgerTransTxt::CustCrossCompanySettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>discTxtCustVend</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a <c>CustCashDiscCust</c> enumeration or a <c>VendCashDiscVend</c> enumeration
    ///    respectively.
    /// </summary>
    /// <returns>
    ///    An enumeration value from the <c>LedgerTransTxt</c> enumeration.
    /// </returns>
    /// <remarks>
    ///    The method is overridden in the derived methods. The parent method on the <c>CustVendSettle</c>
    ///    class is empty.
    /// </remarks>
    LedgerTransTxt discTxtCustVend()
    {
        return LedgerTransTxt::CustCashDiscCust;
    }

]]></Source>
			</Method>
			<Method>
				<Name>discTxtLedger</Name>
				<Source><![CDATA[
    LedgerTransTxt discTxtLedger()
    {
        return LedgerTransTxt::CustCashDiscLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchAdjTxt</Name>
				<Source><![CDATA[
    LedgerTransTxt exchAdjTxt(LedgerJournalACType _ledgerJournalACType = LedgerJournalACType::Cust)
    {
        LedgerTransTxt  ledgerTransTxt;

        switch (_ledgerJournalACType)
        {
            case LedgerJournalACType::Ledger :
                ledgerTransTxt = LedgerTransTxt::CustExchAdjLedger;
                break;

            default :
                ledgerTransTxt = LedgerTransTxt::CustExchAdjCust;
        }
        return ledgerTransTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findInvoice</Name>
				<Source><![CDATA[
    CustVendInvoiceJour findInvoice(
        CustVendAC  _custVendAC,
        InvoiceId   _invoiceId,
        Voucher     _voucher,
        TransDate   _transDate)
    {
        return CustInvoiceJour::findFromCustTransVoucher(_invoiceId, _voucher, _transDate, _custVendAC);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendName_BR</Name>
				<Source><![CDATA[
    public str getCustVendName_BR(CustVendAC vendAccountNum)
    {
        return CustTable::find(vendAccountNum).name();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerPostingType_Balance</Name>
				<Source><![CDATA[
    public LedgerPostingType getLedgerPostingType_Balance()
    {
        return LedgerPostingType::CustBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerPostingType_CashDisc</Name>
				<Source><![CDATA[
    public LedgerPostingType getLedgerPostingType_CashDisc()
    {
        return LedgerPostingType::CustCashDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerPostingType_ExchRate</Name>
				<Source><![CDATA[
    public LedgerPostingType getLedgerPostingType_ExchRate(Amount _exchRateDiff)
    {
        return (_exchRateDiff < 0 ? LedgerPostingType::ExchRateGain : LedgerPostingType::ExchRateLoss);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerPostingType_Settlement</Name>
				<Source><![CDATA[
    public LedgerPostingType getLedgerPostingType_Settlement()
    {
        return LedgerPostingType::CustSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendSettlementBuffer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates either a <c>CustSettlement</c> record or a <c>VendSettlement</c> record.
    /// </summary>
    /// <returns>
    ///    The new <c>CustSettlement</c> or <c>VendSettlement</c> instance.
    /// </returns>
    /// <remarks>
    ///    This method is overridden in the derived methods. The parent method on the <c>CustVendSettle</c>
    ///    class is empty.In the method <c>adjustCashDiscOnSettlement</c>, a <c>CustVendSettlement</c> map is
    ///    declared. In order to select on this, this method is called to create a <c>CustSettlement</c>
    ///    record or a <c>VendSettlement</c> record.
    /// </remarks>
    CustVendSettlement initCustVendSettlementBuffer()
    {
        CustSettlement  custSettlementBuffer;

        return custSettlementBuffer.data();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendSettlementOffsetVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Instantiates a <c>CustSettlementOffsetVoucher</c>.
    /// </summary>
    /// <returns>
    ///    The new <c>CustSettlementOffsetVoucher</c> instance.
    /// </returns>
    protected CustVendSettlementOffsetVoucher initCustVendSettlementOffsetVoucher()
    {
        CustSettlementOffsetVoucher custSettlementOffsetVoucher;

        return custSettlementOffsetVoucher.data();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendTransBuffer</Name>
				<Source><![CDATA[
    protected CustVendTrans initCustVendTransBuffer()
    {
        CustTrans  custTrans;

        return custTrans.data();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendTransOpenBuffer</Name>
				<Source><![CDATA[
    protected CustVendTransOpen initCustVendTransOpenBuffer()
    {
        CustTransOpen  custTransOpen;

        return custTransOpen.data();
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerJournalACType</Name>
				<Source><![CDATA[
    LedgerJournalACType ledgerJournalACType()
    {
        return LedgerJournalACType::Cust;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerPostingType_W</Name>
				<Source><![CDATA[
    public LedgerPostingType ledgerPostingType_W()
    {
        return LedgerPostingType::CustPayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>maxMSTDiff</Name>
				<Source><![CDATA[
    AmountCur maxMSTDiff()
    {
        return CustParameters::find().MaxMSTDiff;
    }

]]></Source>
			</Method>
			<Method>
				<Name>maxPennyDiff</Name>
				<Source><![CDATA[
    AmountMST maxPennyDiff()
    {
        CustParameters   custParameters;

        select firstonly MaxMSTDiff from custParameters;

        return custParameters.MaxMSTDiff;
    }

]]></Source>
			</Method>
			<Method>
				<Name>moduleCustVend</Name>
				<Source><![CDATA[
    protected ModuleCustVend moduleCustVend()
    {
        return ModuleCustVend::Cust;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mstDiffTxtLedger</Name>
				<Source><![CDATA[
    LedgerTransTxt mstDiffTxtLedger()
    {
        return LedgerTransTxt::CustMSTDiffLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pennyDiffTxt</Name>
				<Source><![CDATA[
    LedgerTransTxt pennyDiffTxt()
    {
        return LedgerTransTxt::CustMSTDiffCust;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postClosing</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates <c>GeneralJournalEntry</c> records when the posting profile has a close profile.
    /// </summary>
    /// <param name="_custTrans">
    ///    The <c>CustTrans</c> record that is used to create the records.
    /// </param>
    /// <param name="_postingDate">
    ///    The date the transaction was settled.
    /// </param>
    protected void postClosing(CustVendTrans _custTrans, TransDate _postingDate)
    {
        CustTrans           custTrans = _custTrans;
        LedgerVoucher       ledgerVoucher;
        CustPostingProfile  postingProfileClose;
        LedgerDimensionDefaultAccount   fromLedgerDimension;
        LedgerDimensionDefaultAccount   toLedgerDimension;
        LedgerVoucherObject             ledgerVoucherObject;
        LedgerVoucherTransObject ledgerVoucherTransObject;
        // <GEERU>
        boolean             countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        LedgerDimensionAccount          ledgerDimensionMerged;
        CurrencyExchangeHelper          exchangeRateHelper;

        Debug::assert(custTrans.DataAreaId == curext());

        postingProfileClose = CustLedger::find(custTrans.PostingProfile).PostingProfileClose;

        if (postingProfileClose != '' && postingProfileClose != custTrans.PostingProfile)
        {
            fromLedgerDimension     = CustLedgerAccounts::summaryLedgerDimension(custTrans.AccountNum, custTrans.PostingProfile);
            toLedgerDimension       = CustLedgerAccounts::summaryLedgerDimension(custTrans.AccountNum, postingProfileClose);

            custTrans.PostingProfileClose = postingProfileClose;

            if (fromLedgerDimension != toLedgerDimension)
            {
                ledgerVoucher = settlementPair.findOrCreateLedgerVoucherByCompany(custTrans.company());

                ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();
                exchangeRateHelper  = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());
                exchangeRateHelper.parmExchangeRate1(custTrans.ExchRate);

                ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(fromLedgerDimension, custTrans.DefaultDimension);

                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                            ledgerVoucherObject,
                        LedgerPostingType::CustBalance,
                                            ledgerDimensionMerged,
                        custTrans.CurrencyCode,
                       -custTrans.AmountCur,
                                            exchangeRateHelper);

                ledgerVoucherTransObject.parmSourceTableId(custTrans.TableId);
                ledgerVoucherTransObject.parmSourceRecId(custTrans.RecId);
                ledgerVoucherTransObject.parmTransTxt('');
                ledgerVoucherTransObject.parmDiscardLastTransTxt(true);
                ledgerVoucher.addTrans(ledgerVoucherTransObject);

                ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();
                exchangeRateHelper  = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());
                exchangeRateHelper.parmExchangeRate1(custTrans.ExchRate);

                ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(toLedgerDimension, custTrans.DefaultDimension);
                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                            ledgerVoucherObject,
                        LedgerPostingType::CustBalance,
                                            ledgerDimensionMerged,
                        custTrans.CurrencyCode,
                        custTrans.AmountCur,
                                            exchangeRateHelper);

                ledgerVoucherTransObject.parmSourceTableId(custTrans.TableId);
                ledgerVoucherTransObject.parmSourceRecId(custTrans.RecId);
                ledgerVoucherTransObject.parmTransTxt('');
                ledgerVoucherTransObject.parmDiscardLastTransTxt(true);
                ledgerVoucher.addTrans(ledgerVoucherTransObject);

                // <GEERU>
                if (countryRegion_RU && _custTrans.AmountCur)
                {
                    ledgerVoucher.bondLast2_RU();
                }
                // </GEERU>
                _custTrans.Closed = CustVendTransData::construct(_custTrans).maxSettlementDate(_postingDate);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postVATTransit_RU</Name>
				<Source><![CDATA[
    protected Voucher postVATTransit_RU(
        AmountMST           _settleAmountAccounting,
        AmountCur           _settleAmountTransaction,
        AmountMSTSecondary  _settleAmountReporting,
        CustVendTrans       _custVendTrans,
        NoYes               _correction = NoYes::No)
    {
        Voucher ret;

        if (CustParameters::taxation_RU(_custVendTrans.TransDate) == CustTaxation_RU::OnPayment ||
            CustVendTransData::construct(_custVendTrans).custVendInvoiceJour_RU().CustVendInvoiceJour::getVATOnPayment_RU())
        {
            ret = super(_settleAmountAccounting,
                        _settleAmountTransaction,
                        _settleAmountReporting,
                        _custVendTrans,
                        _correction);
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reversedAmount_RU</Name>
				<Source><![CDATA[
    protected AmountCur  reversedAmount_RU(Map       _map,
                                           TransDate _transDate)
    {
        return -super(_map,_transDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>settlementControl</Name>
				<Source><![CDATA[
    protected void settlementControl()
    {
        CustTrans custTrans;
        boolean overSettlementFound;
        Voucher overSettlementVoucher;

        while (custVendTransSettlementControl.next(custTrans))
        {
            if (custTrans.AmountCur > 0)
            {
                if ((custTrans.SettleAmountCur < 0) ||
                    (custTrans.SettleAmountCur > custTrans.AmountCur))
                {
                    overSettlementFound = true;
                    overSettlementVoucher = custTrans.Voucher;
                    break;
                }
            }

            if (custTrans.AmountCur < 0)
            {
                if ((custTrans.SettleAmountCur > 0) ||
                    (custTrans.SettleAmountCur < custTrans.AmountCur))
                {
                    overSettlementFound = true;
                    overSettlementVoucher = custTrans.Voucher;
                    break;
                }
            }
        }

        if (overSettlementFound)
        {
            throw error(strfmt("@SYS119352", overSettlementVoucher));
        }

        this.validateDiffCustAccount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDiffCustAccount</Name>
				<Source><![CDATA[
    private void validateDiffCustAccount()
    {
        CustTrans custTrans;
        AccountNum settleAccountNum;
        DataAreaId settleDataAreaId;
        Voucher settleVoucher;
        boolean diffAccountNumFound;

        boolean found = custVendTransSettlementControl.first(custTrans);
        while (found)
        {
            if (!settleAccountNum)
            {
                settleAccountNum = custTrans.AccountNum;
                settleDataAreaId = custTrans.DataAreaId;
                settleVoucher = custTrans.Voucher;
            }
            else if (settleAccountNum != custTrans.AccountNum && !CustTable::isSameCustomer(settleAccountNum, settleDataAreaId, custTrans.AccountNum, custTrans.dataAreaId))
            {
                diffAccountNumFound = true;
                break;
            }

            found = custVendTransSettlementControl.next(custTrans);
        }

        if (diffAccountNumFound)
        {
            throw error(strfmt("@CashManagement:DiffAccountNumSettleError", custTrans.AccountNum, custTrans.Voucher, settleAccountNum, settleVoucher));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldPostConditionalTaxForCreditCompany</Name>
				<Source><![CDATA[
    protected boolean shouldPostConditionalTaxForCreditCompany()
    {
        boolean shouldPost = super();

        if (shouldPost)
        {
            CustTrans custTransPaym = settlementPair.getCustVendTransCredit();

            shouldPost = custTransPaym.PaymMethod != NetCurrent::COD;
        }

        return shouldPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAdvanceDefinition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calls the <c>CustPrepaymentInvoiceTable</c> table to update advance application remaining.
    /// </summary>
    /// <param name="_custVendTrans">
    /// A <c>CustVendTrans</c> record.
    /// </param>
    /// <param name="settleAmountCur">
    /// An amount to update in prepayment application remaining amount.
    /// </param>
    protected void updateAdvanceDefinition(CustVendTrans _custVendTrans, AmountCur settleAmountCur)
    {
        if (CustPrepaymentInvoiceFeature::instance().isEnabled())
        {
            CustPrepaymentInvoiceTable custPrepaymentInvoiceTable = CustPrepaymentInvoiceTable::updatePrepaymentApplicationRemaining(_custVendTrans, settleAmountCur);
            try
            {
                if (CustParameters::find().PrepaymentApplicationPolicy == PrepaymentApplicationPolicy::Automatic && custPrepaymentInvoiceTable && custPrepaymentInvoiceTable.Status == CustPrepaymentInvoiceStatus::Received)
                {
                    CustPrepaymentCustInvoice::applyAutomaticPrepayment(custPrepaymentInvoiceTable);
                }
            }
            catch(Exception::Error)
            {
                warning("@AccountsReceivable:PrepaymentInvoiceAutoApplyError");
            }
        }
       
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCashDiscDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the <c>CashDiscDate</c> field on the <c>CustTransOpen</c> records that will be settled.
    /// </summary>
    /// <param name="_company">
    ///    The spec company of the <c>SpecTrans</c> records to find.
    /// </param>
    /// <param name="_tableId">
    ///    The spec table ID of the <c>SpecTrans</c> records to find.
    /// </param>
    /// <param name="_recId">
    ///    The spec record ID of the <c>SpecTrans</c> records to find.
    /// </param>
    /// <remarks>
    ///    This method sets the <c>CashDiscDate</c> field to the <c>DueDate</c> field when the
    ///    <c>PossibleCashDiscount</c> field is zero and <c>AmountCur</c> field is larger than zero.
    /// </remarks>
    protected void updateCashDiscDate(
        CompanyId _company,
        TableId _tableId,
        RecId _recId)
    {
        if (SettlementPostponeCashDiscountDateUpdateFlightHelper::canPostponeCashDiscountDateUpdateEnabled())
        {
            this.postponeUpdateCashDiscDate(_company, _tableId, _recId);
        }
        else
        {

            NoYes useUpdateCashDiscDateReduceDeadlock = CustParameters::find().SettlementUpdateCashDiscDateReduceDeadlock;

            SpecTrans specTrans;
            while select crossCompany RefCompany from specTrans group by RefCompany
                where specTrans.SpecCompany == _company
                    && specTrans.SpecTableId == _tableId
                    && specTrans.SpecRecId == _recId
            {
                changecompany(specTrans.RefCompany)
                {
                    // The data volume in CustTransOpen fluctuates.  It can be very low for specific DataAreaIds for extended periods of time and
                    // influence the set based query plan.  The set based query plan will try to start with CustTransOpen using the primary clustered index (AccountDateIdx).
                    // Under larger parallelization processes, that query plan can create deadlocks.  If a good query plan exists, it can be foreced.
                    // But, because the data volume can be so low it is very difficult to get/create a good plan guide.  Therefore, the row based queries
                    // start on SpecTrans and then updates specific CustTransOpen rows one by one.  This is slower, but it will reduce the deadlocks.

                    if (useUpdateCashDiscDateReduceDeadlock == NoYes::Yes)
                    {
                        this.updateCashDiscDateReduceDeadlock(_company, _tableId, _recId, specTrans.RefCompany);
                    }
                    else
                    {
                        this.updateCashDiscDateSetBased(_company, _tableId, _recId);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postponeUpdateCashDiscDate</Name>
				<Source><![CDATA[
    private void postponeUpdateCashDiscDate(
        CompanyId _company,
        TableId _tableId,
        RecId _recId)
    {
        SpecTrans refCompanySpecTrans;

        CustTransOpen custTransOpenLocal;

        while select custTransOpenLocal
            where custTransOpenLocal.AmountCur > 0
                && custTransOpenLocal.PossibleCashDisc == 0
                && custTransOpenLocal.CashDiscDate != custTransOpenLocal.DueDate
            exists join refCompanySpecTrans
                where  refCompanySpecTrans.SpecCompany == _company
                    && refCompanySpecTrans.SpecTableId == _tableId
                    && refCompanySpecTrans.SpecRecId == _recId
                    && custTransOpenLocal.TableId == refCompanySpecTrans.RefTableId
                    && custTransOpenLocal.RecId == refCompanySpecTrans.RefRecId
        {
            CashDiscDateSettlementCache::cacheCashDiscDate(custTransOpenLocal.RecId, custTransOpenLocal.DueDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCashDiscDateSetBased</Name>
				<Source><![CDATA[
    private void updateCashDiscDateSetBased(
        CompanyId _company,
        tableId _tableId,
        RecId _recId)
    {
        SpecTrans refCompanySpecTrans;

        CustTransOpen custTransOpenLocal;
        custTransOpenLocal.skipDatabaseLog(true);
        custTransOpenLocal.skipDataMethods(true);
        custTransOpenLocal.skipEvents(true);

        update_recordset custTransOpenLocal
            setting CashDiscDate = custTransOpenLocal.DueDate
                where custTransOpenLocal.AmountCur > 0
                    && custTransOpenLocal.PossibleCashDisc == 0
                    && custTransOpenLocal.CashDiscDate != custTransOpenLocal.DueDate
            exists join refCompanySpecTrans
                where  refCompanySpecTrans.SpecCompany == _company
                    && refCompanySpecTrans.SpecTableId == _tableId
                    && refCompanySpecTrans.SpecRecId == _recId
                    && custTransOpenLocal.TableId == refCompanySpecTrans.RefTableId
                    && custTransOpenLocal.RecId == refCompanySpecTrans.RefRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCashDiscDateReduceDeadlock</Name>
				<Source><![CDATA[
    private void updateCashDiscDateReduceDeadlock(
        CompanyId _company,
        tableId _tableId,
        RecId _recId,
        CompanyId _refCompany)
    {
        SpecTrans refCompanySpecTrans;

        CustTransOpen custTransOpenLocal;
        custTransOpenLocal.skipDatabaseLog(true);
        custTransOpenLocal.skipDataMethods(true);
        custTransOpenLocal.skipEvents(true);

        while select refCompanySpecTrans
            where refCompanySpecTrans.SpecCompany == _company
                && refCompanySpecTrans.SpecTableId == _tableId
                && refCompanySpecTrans.SpecRecId == _recId
                && refCompanySpecTrans.RefCompany == _refCompany
        {
            update_recordset custTransOpenLocal
                setting CashDiscDate = custTransOpenLocal.DueDate
                where custTransOpenLocal.TableId == refCompanySpecTrans.RefTableId
                    && custTransOpenLocal.RecId == refCompanySpecTrans.RefRecId
                    && custTransOpenLocal.AmountCur > 0
                    && custTransOpenLocal.PossibleCashDisc == 0
                    && custTransOpenLocal.CashDiscDate != custTransOpenLocal.DueDate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransaction_W</Name>
				<Source><![CDATA[
    public CustVendSettlement updateTransaction_W(
        CustVendTrans        _custTrans,
        CustVendTransOpen    _custTransOpen,
        DiscAmount           _utilizedCashDisc   = 0,
        PennyDiff            _pennyDiff          = 0,
        NoYes                _canBeReversed      = NoYes::No,
        boolean              _setOffsetRecId     = false,
        boolean              _update             = false,
        Voucher              _taxVoucher         = '',
        boolean              _isGroupSettlement  = true,
        RecId               _offsetRecId        = 0)
    {
        CustVendSettlement  custVendSettlement;
        CustTransData       custTransData;
        ;

        changecompany(_custTrans.company())
        {
            custTransData = _custTrans.transData();
            custTransData.parmIsGroupSettlement_W(_isGroupSettlement);

            custVendSettlement = custTransData.updateSettlement(_custTransOpen,
                                                                _utilizedCashDisc,
                                                                -_pennyDiff,
                                                                _canBeReversed,
                                                                _setOffsetRecId,
                                                                _update,
                                                                _custTrans.DefaultDimension,
                                                                max(_custTrans.TransDate, _custTrans.LastExchAdj),
                                                                _taxVoucher);

            this.updateTransOpen(_custTrans, _custTransOpen);
            _custTrans.update();
        }

        return custVendSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransactionProject</Name>
				<Source><![CDATA[
    [SysObsolete('This method is obsolete. Use updateTransactionProjectV2() instead.', false, 01\06\2022)]
    void updateTransactionProject(CustVendTrans _custTrans, AmountMST _remainDebitCur, AmountMST _settleAmountCur)
    {
        this.updateTransactionProjectV2(_custTrans, _remainDebitCur, _settleAmountCur);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransactionProjectV2</Name>
				<Source><![CDATA[
    public void updateTransactionProjectV2(CustVendTrans _custTrans, AmountCur _remainDebitCur, AmountCur _settleAmountCur)
    {
        // If invoice came from Project
        if (_custTrans.TransType == LedgerTransType::Project)
        {
            // Compare the invoice and payment amount
            if (_remainDebitCur != _settleAmountCur)
            {
                real percentagePayment;
                // In multiple settlement case, amount should be fetched from <c>ProjTransPosting</c> to get the correct remaining amount.
                ProjTransPosting projTransPosting;
                select firstonly RecId, AmountMST from projTransPosting
                    where projTransPosting.Voucher == _custTrans.Voucher
                        && projTransPosting.PaymentStatus == ProjPaymentStatus::ExpectedPayment;
                                           
                if (projTransPosting.RecId && projTransPosting.AmountMst != 0)
                {
                    Amount remainDebitAmount = projTransPosting.AmountMst * -1;

                    if (_custTrans.CurrencyCode != Ledger::accountingCurrency())
                    {
                        CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), systemDateGet());
                        remainDebitAmount = currencyExchangeHelper.calculateAccountingToTransaction(_custTrans.CurrencyCode, remainDebitAmount, true);
                    }

                    percentagePayment = _settleAmountCur/remainDebitAmount;
                }

                if (percentagePayment < 1)
                {
                    // partial payment
                    CustVoucher::updateProjTransPosting(_custTrans.LastSettleDate, _custTrans.Voucher,
                        ProjPaymentStatus::Paid, true, percentagePayment);
                }
                else
                {
                    // full payment. update the ProjTransposting payment date and payment status
                    CustVoucher::updateProjTransPosting(_custTrans.LastSettleDate, _custTrans.Voucher, ProjPaymentStatus::Paid);
                }
            }
            else
            {
                // full payment. update the ProjTransposting payment date and payment status
                CustVoucher::updateProjTransPosting(_custTrans.LastSettleDate, _custTrans.Voucher, ProjPaymentStatus::Paid);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransactionReverseExchAdj_W</Name>
				<Source><![CDATA[
    public CustVendSettlement updateTransactionReverseExchAdj_W(
        CustVendTrans      _custTrans,
        CustVendTransOpen  _custVendTransOpen,
        DiscAmount         _utilizedCashDisc  = 0,
        boolean            _isGroupSettlement = true)
    {
        CustVendSettlement  custVendSettlement;
        CustVendTrans       custTrans               = _custTrans;
        AmountMST           tmpSettleAmountMst      = custTrans.SettleAmountMST;
        AmountCur           tmpSettleAmountCur      = custTrans.SettleAmountCur;
        AmountMSTSecondary  tmpSettleAmountMSTSec   = custTrans.SettleAmountReporting;
        CustVendTrans       tmpCustVendTrans        = custTrans.orig().data();
        TransDate           tmpLastExchAdj          = custTrans.LastExchAdj;
        CustTransData       custTransData           = custTrans.transData();

        custTrans.SettleAmountMST       = tmpCustVendTrans.SettleAmountMST;
        custTrans.SettleAmountCur       = tmpCustVendTrans.SettleAmountCur;
        custTrans.SettleAmountReporting = tmpCustVendTrans.SettleAmountReporting;
        custTrans.LastExchAdj           = settlementPair.getTransactionDate();

        custTransData.parmIsGroupSettlement_W(_isGroupSettlement);
        custVendSettlement = custTransData.updateSettlement(_custVendTransOpen, _utilizedCashDisc);

        this.updateTransOpen(custTrans, _custVendTransOpen);

        custTrans.LastExchAdj = tmpLastExchAdj;
        custTrans.update();

        custTrans.SettleAmountMST       = tmpSettleAmountMst;
        custTrans.SettleAmountCur       = tmpSettleAmountCur;
        custTrans.SettleAmountReporting = tmpSettleAmountMSTSec;

        return custVendSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransOpen</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the <c>CustVendTransOpen</c> table in the database for the specified data.
    /// </summary>
    /// <param name="_custVendTrans">
    ///    The <c>CustVendTrans</c> record associated with the <c>CustVendTransOpen</c> record.
    /// </param>
    /// <param name="_custVendTransOpen">
    ///    The record to update.
    /// </param>
    public void updateTransOpen(CustVendTrans _custVendTrans, CustVendTransOpen _custVendTransOpen)
    {
        boolean recordDeleted;
        CustTransOpen custTransOpenToDelete;

        boolean countryRegion_RUCZ = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ]);

        if ((!countryRegion_RUCZ && _custVendTransOpen.RecId) ||
             (countryRegion_RUCZ && CustTransOpen::exist(_custVendTransOpen.RecId)))
        {
            _custVendTransOpen.update();

            if (_custVendTransOpen.AmountCur == 0 && _custVendTransOpen.AmountMST == 0)
            {
                // Balance is zero, the custVendTransSettlement manager will delete the transaction open record when
                // the post method is called.  Don't want to do the delete at this point because the CustVendTransCashDisc
                // records associated with the custTransOpen have to be moved to the settlement record and the settlement
                // record isn't created until the post method is called.
                recordDeleted = custVendTransSettlement.markCustVendTransOpenForDelete(_custVendTransOpen.RecId, _custVendTrans, settlementGroupPlaceHolder);

                if (!recordDeleted)
                {
                    // This will handle case where there isn't a settlement for record to be
                    // deleted, so just delete it here.
                    select firstonly RecId from custTransOpenToDelete
                        where custTransOpenToDelete.TableId == _custVendTransOpen.TableId
                           && custTransOpenToDelete.RecId == _custVendTransOpen.RecId;

                    if (custTransOpenToDelete.RecId)
                    {
                        if (!MCRPaymSchedLink::findCustTransOpen(custTransOpenToDelete.RecId))
                        {
                            _custVendTransOpen.delete();
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewCreditNoteForCashDiscountId_CZ</Name>
				<Source><![CDATA[
    /// <summary>
    ///     The method finds and returns a number sequence num for InvoiceId
    /// </summary>
    /// <returns>
    ///     Num of number sequence or empty string
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static Num getNewCreditNoteForCashDiscountId_CZ()
    {
        NumberSequenceReference numberSequenceReference;
        NumberSeq               numberSequence;

        numberSequenceReference = CustParameters::numRefCustCreditNoteId();
        if (!numberSequenceReference)
        {
            numberSequenceReference = CustParameters::numRefCustInvoiceId();
        }

        numberSequence = NumberSeq::newGetNum(numberSequenceReference);
        return numberSequence.num();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCollectionStatusForSettlement</Name>
				<Source><![CDATA[
    internal void updateCollectionStatusForSettlement()
    {
        CustTrans custTransDebit = settlementPair.getCustVendTransDebit() as CustTrans;

        if (custTransDebit.RecId && CustDisputeHistoryAutomation::doesDisputeExist(custTransDebit.RecId))
        {
            CustDisputeHistoryAutomationPayment::updateCollectionsStatus(custTransDebit.RecId, CustDisputeHistoryAutomationAction::Payment);
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>