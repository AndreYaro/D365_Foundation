<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CreditCardProcess</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;
using Retail = Microsoft.Dynamics.Retail;
using RetailConst = Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants;

abstract class CreditCardProcess
{
    SalesTable salesTable;
    SalesInvoiceId salesInvoiceId;
    CustInvoiceJour custInvoiceJour;
    CreditCardAuthTrans creditCardTrans;
    CreditCardOperation operation;
    AmountCur totalAmountCur;
    CurrencyCode currencyCode;
    boolean getCardVerificationValue;
    CreditCardCVV cardVerificationValue;
    MCRCustPaymTable mcrCustPaymTable;
    RecId mcrCustPaymRecId;
    CustInvoiceTable custInvoiceTable;
    LedgerJournalTrans ledgerJournalTrans;
    CustPaymSchedLine custPaymSchedLine;
    NoYes mcrEnableOrderCompletion;
    RetailExternalGiftCard retailExternalGiftCard;
    MCRPaymentTrackingId mcrPaymentTrackingId;
    AmountCur adjustAuthorizationAmount;
    PaymentIncrementalOffsetReference incrementalOffsetReference;
    int firstErrorCode;

    protected internal CreditCardRequestResult creditCardRequestResult;
    protected internal boolean isNetworkError;

    internal static CommerceHQEventSource eventSource = CommerceHQEventSource::Log;
    internal static CreditCardProcess_ExtendedParameters extendedParameters = CreditCardProcess_ExtendedParameters::construct();

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkForAddressVerification</Name>
				<Source><![CDATA[
    protected boolean checkForAddressVerification()
    {
        // Should be overriden in the derived class if AVS is performed.
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForCardVerificationValue</Name>
				<Source><![CDATA[
    protected boolean checkForCardVerificationValue()
    {
        // Should be overriden in the derived class if CVV is performed.
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymentSDKCommand</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected str getPaymentSDKCommand(CreditCardOperation _operation)
    {
        str commandString = '';

        switch(_operation)
        {
            case CreditCardOperation::Authorize:
                commandString = RetailConst.SupportedCorrelationCommands::get_Authorize();
                break;
            case CreditCardOperation::CaptureAfterAuthorize:
                commandString = RetailConst.SupportedCorrelationCommands::get_Capture();
                break;
            case CreditCardOperation::Refund:
                commandString = RetailConst.SupportedCorrelationCommands::get_Refund();
                break;
            case CreditCardOperation::Void:
                commandString = RetailConst.SupportedCorrelationCommands::get_Void();
                break;
        }

        return commandString;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForCommunicationError</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine if communication error has occured.
    /// </summary>
    /// <returns>
    /// true if communication has occured.
    /// </returns>
    internal boolean checkForCommunicationError()
    {
        return firstErrorCode == enum2int(Microsoft.Dynamics.Retail.PaymentSDK.Portable.ErrorCode::CommunicationError);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkFreight</Name>
				<Source><![CDATA[
    AmountCur checkFreight(AmountCur _amt = 0)
    {
        AmountCur freight = 0;

        if (mcrEnableOrderCompletion)
        {
            if (!mcrCustPaymTable)
            {
                throw error("@MCR40414");
            }
        }
        else if (!salesTable)
        {
            throw error("@SYS116917"); //"Sales Order not specified."
        }

        if (DlvTerm::find(salesTable.DlvTerm).ShipCarrierFreightApplied != ShipCarrierFreightApplied::None)
        {
            freight = salesTable.projectedFreightCharge(_amt);
        }

        return freight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProcessResponse</Name>
				<Source><![CDATA[
    abstract boolean createProcessResponse(str _successDescriptionOverride = '')
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>failedReason</Name>
				<Source><![CDATA[
    abstract str failedReason()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCardVerificationValue</Name>
				<Source><![CDATA[
    protected boolean getCardVerificationValue()
    {
        // Should be overriden in the derived class if CVV is performed.
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBase</Name>
				<Source><![CDATA[
    private void initBase(Common _record)
    {
        switch (_record.TableId)
        {
            case tableNum(SalesTable):
                salesTable = _record;
                creditCardTrans = CreditCardAuthTrans::findValidPreApproval(salesTable.SalesId);
                if (creditCardTrans.MCRPaymRecId)
                {
                    mcrCustPaymTable = mcrCustPaymTable::findByRecID(creditCardTrans.MCRPaymRecId);
                }
                break;

            case tableNum(CreditCardAuthTrans):
                creditCardTrans = _record;
                if (creditCardTrans.SalesId)
                {
                    salesTable = SalesTable::find(creditCardTrans.SalesId);
                }
                if (creditCardTrans.MCRPaymRecId)
                {
                    mcrCustPaymTable = mcrCustPaymTable::findByRecID(creditCardTrans.MCRPaymRecId);
                }
                break;
            case tableNum(MCRCustPaymTable):
                mcrCustPaymTable = _record;
                // Allow voiding of authorization even if its stale.
                if (RetailAllowVoidingofStaleAuthorizationsFeatureExposure::isEnabled() && this.parmOperation() == CreditCardOperation::Void)
                {
                    creditCardTrans = CreditcardAuthTrans::mcrFindAvailablePreApproval(mcrCustPaymTable.RecId);
                }
                else
                {
                    creditCardTrans = CreditCardAuthTrans::mcrfindValidPreApproval(mcrCustPaymTable.RecId);
                }
                // Sales table is required to submit the authorization so set the sales table.
                switch (mcrCustPaymTable.RefTableId)
                {
                    case tableNum(salesTable):
                        salesTable = salesTable::findRecId(mcrCustPaymTable.RefRecId);
                        break;
                    case tableNum(CustInvoiceTable):
                        custInvoiceTable = CustInvoiceTable::findRecId(mcrCustPaymTable.RefRecId);
                        break;
                    case tableNum(ledgerJournalTrans):
                        ledgerJournalTrans = ledgerJournalTrans::findRecId(mcrCustPaymTable.RefRecId, false);
                        break;
                    case tableNum(custPaymSchedLine):
                        CustPaymSchedLine = custPaymSchedLine::mcrFindByRecID(mcrCustPaymTable.RefRecId, false);
                        break;
                }
                break;
        }

        // If credit card is for an order determine if order completion is enabled for it's channel
        // otherwise use the channel for the current user.
        if (salesTable)
        {
            mcrEnableOrderCompletion = RetailMCRChannelTable::mcrEnableOrderCompletion(salesTable);
        }
        else
        {
            mcrEnableOrderCompletion = RetailMCRChannelTable::mcrEnableOrderCompletionFindByUser();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    protected void init(Common _record)
    {
        this.initBase(_record);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initActivation</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected void initActivation(SalesTable _salesTable, RetailExternalGiftCard _retailExternalGiftCard)
    {
        this.initBase(_salesTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isValidCurrencyCodeForCreditCard</Name>
				<Source><![CDATA[
    public boolean isValidCurrencyCodeForCreditCard()
    {
        CreditCardProcessors processors = CreditCardProcessors::find(this.parmCreditCardProcessor());
        CreditCardTypeSetup cardSetup;

        if (MCROrderParameters::isCallCenterEnabledAndInUse())
        {
            if (salesTable.CreditCardCustRefId)
            {
                cardSetup = CreditCardTypeSetup::find(processors, CreditCardCust::find(salesTable.CreditCardCustRefId).CreditCardTypeName);
                this.isValidCurrencyCodeForNonRecurringCreditCard(cardSetup);

            }
            else if (mcrCustPaymTable.isExternalGiftCardPayment())
            {
                cardSetup = CreditCardTypeSetup::find(processors, Microsoft.Dynamics.Retail.PaymentSDK.Portable.CardType::GiftCard.ToString());
                currencyCode = mcrCustPaymTable.CurrencyCode;
            }
            else if (mcrCustPaymTable)
            {
                CreditCardCust creditCardCust = CreditCardCust::find(mcrCustPaymTable.PaymInfoRecId);

                if (creditCardCust)
                {
                    cardSetup = CreditCardTypeSetup::find(processors, creditCardCust.CreditCardTypeName);
                    currencyCode = mcrCustPaymTable.CurrencyCode;
                }
                else
                {
                    // CreditCardCust record must of been delete try and recover by using lastest CreditCardAuthTran for mcrCustPaymTable
                    creditCardTrans = CreditCardAuthTrans::mcrFindLatest(mcrCustPaymTable.RecId);

                    if (creditCardTrans)
                    {
                        cardSetup = CreditCardTypeSetup::find(processors, creditCardTrans.CreditCardTypeName);
                        currencyCode = creditCardTrans.CurrencyCode;
                    }
                }

                if (!cardSetup && RetailNonRecurringTokenFeatureExposure::isEnabled())
                {
                    CreditCardAuthTrans creditCardAuthTrans = CreditCardAuthTrans::mcrFindLatest(mcrCustPaymTable.RecId);
                    if (creditCardCust && creditCardAuthTrans && creditCardCust.TokenScope == RetailTokenScope::NonRecurring)
                    {
                        cardSetup = CreditCardTypeSetup::find(processors, creditCardAuthTrans.CreditCardTypeName);
                        currencyCode = creditCardAuthTrans.CurrencyCode;
                    }
                    else if (RetailPaymentAccessTokenContext::instance().accessCodeExists(mcrCustPaymTable.RecId))
                    {
                        return true;
                    }
                    else
                    {
                        throw error("@Retail:RetailNonRecurringTokenAuthorizationCodeMissing");
                    }
                }
            }
            else if (creditCardTrans)
            {
                cardSetup = CreditCardTypeSetup::find(processors, creditCardTrans.CreditCardTypeName);
                currencyCode = creditCardTrans.CurrencyCode;
            }
            else if (salesTable && this.operation == CreditCardOperation::Activation)
            {
                // External gift card activation
                cardSetup = CreditCardTypeSetup::find(processors, Microsoft.Dynamics.Retail.PaymentSDK.Portable.CardType::GiftCard.ToString());
                currencyCode = salesTable.CurrencyCode;
            }
        }
        else
        {
            cardSetup = CreditCardTypeSetup::find(processors, CreditCardCust::find(salesTable.CreditCardCustRefId).CreditCardTypeName);
            this.isValidCurrencyCodeForNonRecurringCreditCard(cardSetup);
        }

        return CreditCardTypeCurrency::exist(cardSetup, currencyCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isValidCurrencyCodeForNonRecurringCreditCard</Name>
				<Source><![CDATA[
    private void isValidCurrencyCodeForNonRecurringCreditCard(CreditCardTypeSetup _cardSetup)
    {
        if (!_cardSetup && RetailNonRecurringTokenFeatureExposure::isEnabled())
        {
            CreditCardCust creditCardCust = CreditCardCust::find(mcrCustPaymTable.PaymInfoRecId);
            if (creditCardCust.TokenScope == RetailTokenScope::NonRecurring)
            {
                throw error("@Retail:RetailNonRecurringTokenOnlyRecurringTokenAllowed");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrSetRefundAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the amount to refund to the credit card.
    /// </summary>
    /// <param name="_amountToRefund">
    ///    The amount to refund to the credit card.
    /// </param>
    private void mcrSetRefundAmount(AmountCur _amountToRefund)
    {
        totalAmountCur = _amountToRefund;
        currencyCode = mcrCustPaymTable.CurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCardVerificationValue</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public CreditCardCVV parmCardVerificationValue(CreditCardCVV _cardVerificationValue = cardVerificationValue)
    {
        cardVerificationValue = _cardVerificationValue;
        return cardVerificationValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCreditCardAuthTrans</Name>
				<Source><![CDATA[
    CreditCardAuthTrans parmCreditCardAuthTrans(CreditCardAuthTrans _creditCardTrans = creditCardTrans)
    {
        creditCardTrans = _creditCardTrans;
        return creditCardTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRPaymentTrackingId</Name>
				<Source><![CDATA[
    protected MCRPaymentTrackingId parmMCRPaymentTrackingId(
        MCRPaymentTrackingId _mcrPaymentTrackingId = mcrPaymentTrackingId)
    {
        mcrPaymentTrackingId = _mcrPaymentTrackingId;
        return mcrPaymentTrackingId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAdjustAuthorizationAmount</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected AmountCur parmAdjustAuthorizationAmount(
        AmountCur _adjustAuthorizationAmount = adjustAuthorizationAmount)
    {
        adjustAuthorizationAmount = _adjustAuthorizationAmount;
        return adjustAuthorizationAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncrementalOffsetReference</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected PaymentIncrementalOffsetReference parmIncrementalOffsetReference(
            PaymentIncrementalOffsetReference _incrementalOffsetReference = incrementalOffsetReference)
    {
        incrementalOffsetReference = _incrementalOffsetReference;
        return incrementalOffsetReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>verifyCreditCardAuth</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verify if <c>CreditCardAuthTrans</c> record is valid.
    /// </summary>
    /// <param name = "_creditCardTrans">
    /// A <c>CreditCardAuthTrans</c> record.
    /// </param>
    /// <returns>
    /// A boolean value if <c>CreditCardAuthTrans</c> record is valid or not.
    /// </returns>
    /// <remarks>
    /// This method can be extended to include additional credit card auth checks.
    /// </remarks>
    public boolean verifyCreditCardAuth(CreditCardAuthTrans _creditCardTrans)
    {
        boolean result;

        if (_creditCardTrans != null)
        {
            result = _creditCardTrans.RecId != 0;
        }
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCreditCardProcessor</Name>
				<Source><![CDATA[
    public abstract CreditCardProcessorsId parmCreditCardProcessor()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustInvoiceJour</Name>
				<Source><![CDATA[
    public CustInvoiceJour parmCustInvoiceJour(CustInvoiceJour _custInvoiceJour = custInvoiceJour)
    {
        custInvoiceJour = _custInvoiceJour;
        return custInvoiceJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmGetCardVerificationValue</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean parmGetCardVerificationValue(boolean _getCardVerificationValue = getCardVerificationValue)
    {
        getCardVerificationValue = _getCardVerificationValue;
        return getCardVerificationValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRCustInvoiceTable</Name>
				<Source><![CDATA[
    public CustInvoiceTable parmMCRCustInvoiceTable(CustInvoiceTable _custInvoiceTable = custInvoiceTable)
    {
        custInvoiceTable = _custInvoiceTable;
        return custInvoiceTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRCustPaymRecId</Name>
				<Source><![CDATA[
    public RecId parmMCRCustPaymRecId(RecId _mcrCustPaymRecId = mcrCustPaymRecId)
    {
        mcrCustPaymRecId = _mcrCustPaymRecId;
        return mcrCustPaymRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRCustPaymSchedLine</Name>
				<Source><![CDATA[
    public CustPaymSchedLine parmMCRCustPaymSchedLine(CustPaymSchedLine _custPaymSchedLine = custPaymSchedLine)
    {
        custPaymSchedLine = _custPaymSchedLine;
        return custPaymSchedLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRCustPaymTable</Name>
				<Source><![CDATA[
    protected MCRCustPaymTable parmMCRCustPaymTable(MCRCustPaymTable _mcrCustPaymTable = mcrCustPaymTable)
    {
        mcrCustPaymTable = _mcrCustPaymTable;
        return mcrCustPaymTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRLedgerJournalTrans</Name>
				<Source><![CDATA[
    public ledgerJournalTrans parmMCRLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans = ledgerJournalTrans)
    {
        ledgerJournalTrans = _ledgerJournalTrans;
        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOperation</Name>
				<Source><![CDATA[
    CreditCardOperation parmOperation(CreditCardOperation _operation = operation)
    {
        operation = _operation;
        return operation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesInvoiceId</Name>
				<Source><![CDATA[
    public SalesInvoiceId parmSalesInvoiceId(SalesInvoiceId _salesInvoiceId = salesInvoiceId)
    {
        salesInvoiceId = _salesInvoiceId;
        return salesInvoiceId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesTable</Name>
				<Source><![CDATA[
    SalesTable parmSalesTable()
    {
        return salesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTotalAmountCur</Name>
				<Source><![CDATA[
    AmountCur parmTotalAmountCur(AmountCur _totalAmountCur = totalAmountCur)
    {
        totalAmountCur = _totalAmountCur;
        return totalAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramRetailExternalGiftCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets and returns the <c>RetailExternalGiftCard</c> class variable.
    /// </summary>
    /// <param name = "_retailExternalGiftCard">The <c>RetailExternalGiftCard</c> being set and returned; optional.</param>
    /// <returns>The <c>RetailExternalGiftCard</c> record.</returns>
    [Hookable(false)]
    RetailExternalGiftCard paramRetailExternalGiftCard(RetailExternalGiftCard _retailExternalGiftCard = retailExternalGiftCard)
    {
        retailExternalGiftCard = _retailExternalGiftCard;
        return retailExternalGiftCard;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareSubmission</Name>
				<Source><![CDATA[
    //must be overwrite in derived class
    abstract boolean prepareSubmission()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>presentResponse</Name>
				<Source><![CDATA[
    public void presentResponse(boolean _showSuccessMessage = true)
    {
        if (this.processSucceed())
        {
            if (_showSuccessMessage)
            {
                if (salesTable.CreditCardCustRefId)
                {
                    info(strFmt("@SYS327114", salesTable.SalesId));
                }
            }
        }
        else
        {
            error(strFmt("@SYS116935", this.failedReason()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>process</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Carries out all steps that are necessary to complete a credit card operation.
    /// </summary>
    /// <param name="_showSuccessMessage">
    ///    A Boolean value that specifies whether to display a message upon successful completion of the
    ///    operation.
    /// </param>
    /// <param name="_successDescriptionOverride">
    ///    A description that is logged for successful completion.
    /// </param>
    /// <returns>
    ///    true if the operation completed successfully; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The following methods are called, in order. If any of these methods return false, subsequent
    ///    methods are not called.
    ///    <list type="number">
    ///       <item>
    ///          <description>
    ///             <c>prepareSubmission</c>
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             <c>submit</c>
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             <c>createProcessResponse</c>
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             <c>doAddressVerification</c>
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             <c>updateSalesTable</c>
    ///          </description>
    ///       </item>
    ///    </list>
    /// </remarks>
    public boolean process(boolean _showSuccessMessage = true, str _successDescriptionOverride = '')
    {
        if (mcrEnableOrderCompletion)
        {
            _showSuccessMessage = false;
        }

        // For commerce enabled orders, CreditCardTypeSetup is not in context for commentPaymentsEnabledOrder, hence skipping validation..
        if (RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(salesTable, funcName()))
        {
            eventSource.EventWritePaymentsSkippingIsValidCurrencyCodeForCreditCardCheck(salesTable.RecId, creditCardTrans.RecId, mcrCustPaymTable.RecId);
        }
        else
        {
            if (!this.isValidCurrencyCodeForCreditCard())
            {
                // The credit card processor does not support the currency.
                throw error(strFmt("@SYS327527", CreditCardProcessors::find(this.parmCreditCardProcessor()).Name, currencyCode));
            }
        }

        if (!RetailPaymentsCvvPromptFlight::instance().isEnabled() && !this.getCardVerificationValue())
        {
            // The pre-auth is not obtained since the CVV entry was canceled.
            return false;
        }

        if (this.prepareSubmission())
        {
            this.submit();

            eventSource.EventWritePaymentsCreditCardProcessProcessComplete(this.parmCreditCardAuthTrans().RecId,
                    this.parmCreditCardProcessor(),
                    enum2Str(operation),
                    this.parmCreditCardAuthTrans().CreditCardTypeName,
                    mcrPaymentTrackingId != null,
                    this.checkForCommunicationError());
        }

        CreditCard_ExtendedParameters creditCard_ExtendedParameters = CreditCard::extendedParameters;
        creditCard_ExtendedParameters.parmInitCreditCardAuthTrans_MCRPaymentTrackingId(mcrPaymentTrackingId);
        this.createProcessResponse(_successDescriptionOverride);
        creditCard_ExtendedParameters.parmInitCreditCardAuthTrans_MCRPaymentTrackingId('');

        this.validateTransaction();
        this.updateSalesTable();
        
        // Call <c>presentResponse</c> method only when process succeeds. (OR)
        // When process fails and reason for process failure is not empty.
        if (this.processSucceed() || (!this.processSucceed() && this.failedReason() != ''))
        {
            this.presentResponse(_showSuccessMessage);
        }

        this.logTransaction();

        if (this.processSucceed())
        {
            this.updateRelatedCCAuthTrans();
        }

        return this.processSucceed();
    }

]]></Source>
			</Method>
			<Method>
				<Name>enforceCardTokenRestriction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Throw and exception if a scoped credit card token is used on more than one sales order.
    /// </summary>
    private void enforceCardTokenRestriction()
    {
        // we are suppressing the enforcement of the scope as part non-recurring token feature because of performance considerations and because non-recurring token is not stored in DB so it does not need to be enforced
        if (FeatureStateProvider::isFeatureEnabled(RetailRestrictCreditCardUsageFeature::instance()) && !RetailNonRecurringTokenFeatureExposure::isEnabled())
        {
            RecId creditCardCustRecId = 0;
            RecId salesTableRecId = 0;

            if (salesTable.CreditCardCustRefId)
            {
                creditCardCustRecId = salesTable.CreditCardCustRefId;
                salesTableRecId = salesTable.RecId;
            }
            else if (mcrCustPaymTable.PaymInfoTableId == tableNum(CreditCardCust))
            {
                creditCardCustRecId = mcrCustPaymTable.PaymInfoRecId;
                if (mcrCustPaymTable.RefTableId == tableNum(SalesTable))
                {
                    salesTableRecId = mcrCustPaymTable.RefRecId;
                }
                else if (mcrCustPaymTable.RefTableId == tableNum(CustPaymSchedLine))
                {
                    // Installment support
                    RecId custPaymSchedLineRecId = CustPaymSchedLine::mcrFindByRecID(mcrCustPaymTable.RefRecId).ParentRecID;
                    CustPaymSched custPaymShed = CustPaymSched::mcrFindRecID(custPaymSchedLineRecId);
                    if (custPaymShed.ExtTableId == tableNum(SalesTable))
                    {
                        salesTableRecId = custPaymShed.ExtRecId;
                    }
                }
            }

            if (creditCardCustRecId && salesTableRecId)
            {
                CreditCardCust creditCardCust = creditCardCust::find(creditCardCustRecId);

                if (creditCardCust.RecId && 
                        (creditCardCust.TokenScope == RetailTokenScope::SalesOrder || creditCardCust.TokenScope == RetailTokenScope::NonRecurring))
                {
                    SalesTable orderCount;
                    select firstonly RecId from orderCount
                        where orderCount.CreditCardCustRefId == creditCardCustRecId &&
                            orderCount.RecId != salesTableRecId;

                    SalesTable innerSalestable;
                    MCRContinuityCustLine mcrContinuityCustLine;
                    MCRContinuityCustHeader mcrContinuityCustHeader;

                    // Check for continuity order and get the header SalesId
                    select innerSalestable
                        where innerSalestable.RecId == salesTableRecId
                    join mcrContinuityCustLine
                        where mcrContinuityCustLine.SalesId == innerSalestable.SalesId
                    join mcrContinuityCustHeader
                        where mcrContinuityCustHeader.InventTransId == mcrContinuityCustLine.InventTransId;

                    MCRCustPaymTable mcrOrderCount;

                    if (mcrContinuityCustHeader.RecId)
                    {
                        // It is a continuity order
                        SalesTable childSalesTable;
                        MCRContinuityCustLine childMCRContinuityCustLine;
                        MCRContinuityCustHeader childMCRContinuityCustHeader;
                        select firstonly RefRecId from mcrOrderCount
                        where mcrOrderCount.PaymInfoTableId == tableNum(CreditCardCust) &&
                            mcrOrderCount.PaymInfoRecId == creditCardCustRecId &&
                            mcrOrderCount.RefTableId == tableNum(SalesTable) &&
                            mcrOrderCount.RefRecId != salesTableRecId
                        join childSalesTable
                            where childSalesTable.RecId == mcrOrderCount.RefRecId
                        join childMCRContinuityCustLine
                            where childMCRContinuityCustLine.SalesId == childSalesTable.SalesId
                        join childMCRContinuityCustHeader
                            where childMCRContinuityCustHeader.InventTransId == childMCRContinuityCustLine.InventTransId && childMCRContinuityCustHeader.SalesId != mcrContinuityCustHeader.SalesId;
                    }
                    else
                    {
                        // Not continuity order
                        select firstonly RefRecId from mcrOrderCount
                        where mcrOrderCount.PaymInfoTableId == tableNum(CreditCardCust) &&
                            mcrOrderCount.PaymInfoRecId == creditCardCustRecId &&
                            mcrOrderCount.RefTableId == tableNum(SalesTable) &&
                            mcrOrderCount.RefRecId != salesTableRecId;
                    }

                    if (orderCount.RecId || mcrOrderCount.RefRecId)
                    {
                        eventSource.EventWritePaymentsRetailErrorRestrictCreditCardTokenUsedOnMultipleSalesOrders();
                        throw error("@Retail:CreditCardProcessTokenRestrictionBroken"); //"Credit card token restricted but used on more than one sales order."
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSucceed</Name>
				<Source><![CDATA[
    //must be overwrite in derived class
    abstract public boolean processSucceed()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>logTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Log the credit card transaction success or failure to Kusto
    /// </summary>
    private void logTransaction()
    {
        str operationString = enum2Str(operation);
        eventSource.EventWritePaymentsCreditCardProcessComplete(this.parmCreditCardAuthTrans().RecId,
            this.parmCreditCardProcessor(),
            operationString,
            this.parmCreditCardAuthTrans().CreditCardTypeName,
            this.processSucceed());
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAmountFromAuthTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the amount to be processed on the credit card from a pre-authorization.
    /// </summary>
    /// <param name="_authTrans">
    /// A <c>CreditCardAuthTrans</c> record.
    /// </param>
    private void setAmountFromAuthTrans(CreditCardAuthTrans _authTrans)
    {
        totalAmountCur = _authTrans.ApprovalAmountCur;
        currencyCode = _authTrans.CurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAmountFromSales</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the amount to be charged to the credit card.
    /// </summary>
    /// <param name="_amountToPay">
    /// The amount to be charged to the credit card.
    /// </param>
    /// <param name="_currencyCode">
    /// The currency of amount to be charged to the credit card.
    /// </param>
    public void setAmountFromSales(AmountCur _amountToPay, CurrencyCode _currencyCode)
    {
        totalAmountCur = _amountToPay;
        currencyCode = _currencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setChargeAmount</Name>
				<Source><![CDATA[
    void setChargeAmount()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRefundAmountFromSales</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the amount to refund to the credit card.
    /// </summary>
    /// <param name="_salesTotals">
    ///    The amount to refund to the credit card.
    /// </param>
    private void setRefundAmountFromSales(SalesTotals_Sales _salesTotals)
    {
        totalAmountCur = -1 * _salesTotals.totalAmount();
        currencyCode = _salesTotals.currencyCode();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSalesTotals</Name>
				<Source><![CDATA[
    void setSalesTotals()
    {
        AmountCur freightEstimate;

        if (this.parmOperation() == CreditCardOperation::Authorize)
        {
            freightEstimate = this.checkFreight();
        }

        this.parmTotalAmountCur(this.parmTotalAmountCur() + freightEstimate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>submit</Name>
				<Source><![CDATA[
    //must be overwritten in derived class
    abstract boolean submit()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMCRPaymentTrackingId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the payment tracking id from the payment connector, This could be null if the connector does not support this functionality.
    /// </summary>
    /// <returns>The PaymentTrackingId.</returns>
    [Hookable(false)]
    protected MCRPaymentTrackingId getMCRPaymentTrackingId()
    {
        MCRPaymentTrackingId result = null;

        // we are setting the value indicating whether we want to use token stored in auth trans or only the auth token associated with stored credit card
        // this logic is not specific for non-recurring token feature but we are adding feature check for backward compatibility
        boolean shouldIgnoreAuthTransStoredCardToken = (!RetailNonRecurringTokenFeatureExposure::isEnabled() || this.operation == CreditCardOperation::Authorize || this.operation == CreditCardOperation::AuthorizeAndCapture);
        var properties = this.getCardToken(creditCardTrans, shouldIgnoreAuthTransStoredCardToken);

        // get processor and check if it implements the IPaymentReferenceProvider
        Retail.PaymentSDK.Portable.IPaymentProcessor processor = this.getProcessor(this.handleRequest(properties));

        Retail.PaymentSDK.Portable.IPaymentReferenceProvider iPaymentReferenceProvider = processor as Retail.PaymentSDK.Portable.IPaymentReferenceProvider;

        if (iPaymentReferenceProvider != null)
        {
            str commandString = this.getPaymentSDKCommand(this.parmOperation());

            Retail.PaymentSDK.Portable.PaymentTransactionReferenceData connectorResult = iPaymentReferenceProvider.GetPaymentReferenceData(commandString, totalAmountCur);
            if (connectorResult != null)
            {
                result = connectorResult.IdFromConnector;
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCardToken</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return the appropriate payment card properties.
    /// This should be an abstract method but will break backward compatibility. The implementation can be found is the inherited classes
    /// </summary>
    /// <param name="_creditCardAuthTrans">
    /// A <c>CreditCardAuthTrans</c> table record.
    /// </param>
    /// <param name="_useCard">
    /// Forces use of the card token from the <c>CreditCardCust</c> table.
    /// </param>
    /// <returns>
    /// The credit card properties.
    /// </returns>
    protected CreditCardPaymentProperties getCardToken(CreditCardAuthTrans _creditCardAuthTrans, boolean _useCard)
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProcessor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the payment connector by the passed connector name.
    /// The implementation can be found is the inherited classes
    /// </summary>
    /// <param name = "_connectorName">The connector name.</param>
    /// <returns>The payment connector, otherwise null.</returns>
    [Hookable(false)]
    protected Retail.PaymentSDK.Portable.IPaymentProcessor getProcessor(CreditCardConnectorName _connectorName)
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Setup the standard properties needed to request a credit card operation.
    /// The implementation can be found is the inherited classes
    /// </summary>
    /// <param name="_requestProperties">
    /// The request properties.
    /// </param>
    /// <returns>
    /// A connector name.
    /// </returns>
    [Hookable(false)]
    protected CreditCardConnectorName handleRequest(CreditCardPaymentProperties _requestProperties)
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRelatedCCAuthTrans</Name>
				<Source><![CDATA[
    public void updateRelatedCCAuthTrans()
    {
        switch (this.parmOperation())
        {
            case CreditCardOperation::Void:
                CreditCardAuthTrans::setVoidApproval(creditCardTrans.RecId);
                creditCardTrans.reread();
                break;

            case CreditCardOperation::CaptureAfterAuthorize:
                CreditCardAuthTrans::settlePreapprovalTransaction(creditCardTrans.RecId);
                creditCardTrans.reread();
                break;

            case CreditCardOperation::Refund:
                CreditCardAuthTrans::markRefundProcessed(creditCardTrans.RecId);
                creditCardTrans.reread();
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesTable</Name>
				<Source><![CDATA[
    // must overwrite in derived class
    abstract boolean updateSalesTable()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTransaction</Name>
				<Source><![CDATA[
    protected boolean validateTransaction()
    {
        // Should be overriden in the derived class to validate the result transaction
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static CreditCardProcess construct(CreditCardOperation _operation, Common _record)
    {
        CreditCardProcess creditCardProcess;

        if (RetailCreditCardProviderProcess::shouldConstructForRetail(_operation, _record))
        {
            if (CreditCardProcessHelper::lifeCycleManagementEnabled())
            {
                creditCardProcess = RetailManagedCreditCardProviderProcess::construct();
            }
            else
            {
                creditCardProcess = RetailCreditCardProviderProcess::construct();
            }
        }
        else
        {
            if (CreditCardProcessHelper::lifeCycleManagementEnabled())
            {
                creditCardProcess = ManagedCreditCardProviderProcess::construct();
            }
            else
            {
                creditCardProcess = CreditCardProviderProcess::construct();
            }
        }

        creditCardProcess.parmOperation(_operation);
        creditCardProcess.init(_record);

        return creditCardProcess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doActivation</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public static RetailActivationResult doActivation(SalesTable _salesTable, RetailExternalGiftCard _giftCardData, AmountCur _amount)
    {
        CreditCardProcess process = CreditCardProviderProcess::construct();
        process.parmOperation(CreditCardOperation::Activation);
        process.initActivation(_salesTable, _giftCardData);

        process.setAmountFromSales(_amount, _salesTable.CurrencyCode);
        process.paramRetailExternalGiftCard(_giftCardData);

        boolean success = process.process();
        RetailActivationResult retailActivationResult = RetailActivationResult::construct(success,
            process.paramRetailExternalGiftCard().CardNumber,
            process.paramRetailExternalGiftCard().Expiration,
            process.paramRetailExternalGiftCard().Pin);

        return retailActivationResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doCapture</Name>
				<Source><![CDATA[
    public static boolean doCapture(SalesTable _salesTable, SalesTotals_Sales _salesTotals, SalesInvoiceId _salesInvoiceId, CustInvoiceJour _custInvoiceJour)
    {
        // Compiler/Security problem, see bug AX6:232082
        CreditCardProcess process;
        CreditCardAuthTrans authTrans;

        process = CreditCardProcess::construct(CreditCardOperation::AuthorizeAndCapture, _salesTable);

        process.setAmountFromSales(_custInvoiceJour.remainAmountToBePaid(), _salesTable.CurrencyCode);
        process.parmSalesInvoiceId(_salesInvoiceId);
        process.parmCustInvoiceJour(_custInvoiceJour);

        authTrans = process.parmCreditCardAuthTrans();

        if (authTrans)
        {
            // if authorization is already done, chech if the amount is sufficient
            if (CreditCardProcess::isAuthTransApprovalAmountSufficient(process, authTrans))
            {
                // authorization is sufficient, just need to capture
                process.parmOperation(CreditCardOperation::CaptureAfterAuthorize);
            }
            else
            {
                // authorization is insufficient, void the authorization and then authorize and capture.
                info("@SYS116938");
                if (!CreditCardProcess::doVoidAuth(authTrans, false))
                {
                    return false;
                }
            }
        }
        return process.process();
    }

]]></Source>
			</Method>
			<Method>
				<Name>doPreAuth</Name>
				<Source><![CDATA[
    public static boolean doPreAuth(SalesTable _salesTable, boolean _presentExtraMsg = true)
    {
        CreditCardProcess process;
        CreditCardAuthTrans authTrans;
        SalesTotals salesTotals;

        // do nothing if no pre-authorize required
        if (!CustParameters::find().CreditCardPreAuthorization)
        {
            eventSource.EventWritePaymentsCreditCardPreAuthorizationSkipped(_salesTable.RecId);
            return true;
        }

        process = CreditCardProcess::construct(CreditCardOperation::Authorize, _salesTable);
        salesTotals = SalesTotals_Sales::construct(_salesTable, SalesUpdate::All);

        AmountCur salesTotalAmount = salesTotals.totalAmount();
        AmountCur prepaymentsTotalAmount = 0;
        AmountCur preAuthsTotalAmount = 0;

        // If sales total amount is negative it is a credit note and we don't authorize
        if (salesTotalAmount < 0)
        {
            return true;
        }

        // For Retail Orders, calculate the total of the deposits applied to the order before authorizing the remaining balance
        if ( _salesTable.isRetailSale())
        {
            RetailPrePaymentTrans retailPrePaymentTrans;
            CustTrans custTrans;

            // Calculate unsettled pre-payment amount (remaining deposits)
            select retailPrePaymentTrans
                where retailPrePaymentTrans.SalesId == _salesTable.SalesId
                    join sum(AmountCur),
                         sum(SettleAmountCur)
                    from custTrans
                    where custTrans.RecId == retailPrePaymentTrans.CustTransRecId;

            prepaymentsTotalAmount = abs(custTrans.AmountCur - custTrans.SettleAmountCur);

            // Duplication protection for remaining balance authorizations during invoicing process
            if (CreditcardAuthTrans::isPaymentDuplicationProtectionFeatureEnabled())
            {
                // Calculate total amount of available valid authorizations
                select sum(ApprovalAmountCur) from authTrans
                    where authTrans.SalesId == _salesTable.SalesId
                       && authTrans.ApprovalType == CreditCardOperation::Authorize
                       && authTrans.ProcessorStatus == CreditCardProcessorStatus::Approved
                       && authTrans.ApprovalExpired == NoYes::No
                       && authTrans.ApprovalVoid == NoYes::No;

                preAuthsTotalAmount = authTrans.ApprovalAmountCur;
            }
        }

        // Calculate amount to authorize:
        // - Non Retail Sales Order: No pre-payments are considered, authorize sales order remaining balance (Sold - Invoiced)
        // - Retail Sales Orders   : Authorize sales order remaining balance minus all remaining deposits (Sold - Invoices - Deposits)
        AmountCur amountToAuthorize;
        if (CreditcardAuthTrans::isPaymentDuplicationProtectionFeatureEnabled())
        {
            amountToAuthorize = (salesTotalAmount - prepaymentsTotalAmount) - preAuthsTotalAmount;
        }
        else
        {
            amountToAuthorize = salesTotalAmount - prepaymentsTotalAmount;
        }


        if (amountToAuthorize == 0.00)
        {
            return true;
        }

        process.setAmountFromSales(amountToAuthorize, salesTotals.currencyCode());

        process.parmGetCardVerificationValue(_presentExtraMsg);

        // do nothing if pre-authorization is already done, and amount is sufficient
        authTrans = process.parmCreditCardAuthTrans();
        if (authTrans)
        {
            if (CreditCardProcess::isAuthTransApprovalAmountSufficient(process, authTrans))
            {
                if (_presentExtraMsg)
                {
                    info("@SYS122586");
                }

                return true;
            }
            else
            {
                // Void the existing pre-authorization if amount has changed.
                if (!CreditCardProcess::doVoidAuth(authTrans, false))
                {
                    return false;
                }
            }
        }

        if (RetailIncrementalCaptureFeatureExposure::isEnabled())
        {
            if (CreditCardProcess::useExistingAuthorizationForIncrementalCapture(_salesTable.SalesId))
            {
                return true;
            }
        }

        // Enforce card token restrictions.
        process.enforceCardTokenRestriction();

        return process.process();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAuthTransApprovalAmountSufficient</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the credit card authorization approval amount is sufficient.
    /// </summary>
    /// <param name = "_process">A <c>CreditCardProcess</c> instance.</param>
    /// <param name = "_authTrans">A <c>CreditCardAuthTrans</c> buffer.</param>
    /// <returns>true if the pre-authorized credit card approval amount is sufficient; otherwise, false.</returns>
    [Replaceable(true)]
    public static boolean isAuthTransApprovalAmountSufficient(
        CreditCardProcess _process,
        CreditCardAuthTrans _authTrans)
    {
        if (!_process)
        {
            throw error(error::wrongUseOfFunction(funcName()));
        }

        if (RetailNonRecurringTokenFeatureExposure::isEnabled())
        {
            var _adjustmentAuth = CreditCardAuthTrans::findLatestReauthorization(_authTrans.MCRPaymRecId);
            eventSource.EventWriteRetailNonRecurringRetailSearchLatestReauthorizationResult(_adjustmentAuth.RecId);
            if (_adjustmentAuth.RecId)
            {
                return _adjustmentAuth.ApprovalAmountCur >= _process.parmTotalAmountCur();
            }
        }

        return _authTrans.ApprovalAmountCur >= _process.parmTotalAmountCur();
    }

]]></Source>
			</Method>
			<Method>
				<Name>useExistingAuthorizationForIncrementalCapture</Name>
				<Source><![CDATA[
    private static boolean useExistingAuthorizationForIncrementalCapture(SalesIdBase _salesId)
    {
        // Is latest transaction a capture?
        CreditCardAuthTrans latestTransaction = CreditCardAuthTrans::findLatest(_salesId);

        if (latestTransaction.hasPaymentOperationAndStatus(CreditCardOperation::CaptureAfterAuthorize, CreditCardProcessorStatus::Approved))
        {
            // Get associated credit card auth tran
            CreditCardAuthTrans associatedAuthTransaction = CreditCardAuthTrans::findReferencedSettledAuthorization(_salesId, latestTransaction.Authorization);

            if (CreditCardProcess::processPreAuthForIncrementalCapture(associatedAuthTransaction))
            {
                // Still funds outstanding on authorization, so use this instead of creating a new authorization.
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doRefund</Name>
				<Source><![CDATA[
    public static boolean doRefund(SalesTable _salesTable, SalesTotals_Sales _salesTotals, SalesInvoiceId _salesInvoiceId, CustInvoiceJour _custInvoiceJour)
    {
        // Compiler/Security problem, see bug AX6:232082
        CreditCardAuthTrans creditCardAuthTrans;
        CreditCardProcess process;

        creditCardAuthTrans = CreditCardAuthTrans::findRefundCharge(_salesTable.SalesId, true);
        if (!creditCardAuthTrans)
        {
            throw error("@SYS328891"); // Credit card refunds can be processed only when the credit note is created from an existing sales order.
        }

        // Must refund using the same processor as was used for authorization
        process = CreditCardProcess::construct(CreditCardOperation::Refund, creditCardAuthTrans);

        process.setRefundAmountFromSales(_salesTotals);
        process.parmSalesInvoiceId(_salesInvoiceId);
        process.parmCustInvoiceJour(_custInvoiceJour);

        return process.process();
    }

]]></Source>
			</Method>
			<Method>
				<Name>doRefundWithBreakDown</Name>
				<Source><![CDATA[
    public static boolean doRefundWithBreakDown(SalesTable _salesTable, SalesInvoiceId _salesInvoiceId, CustInvoiceJour _custInvoiceJour)
    {
        CreditCardAuthTrans creditCardAuthTrans = CreditCardAuthTrans::findRefundCharge(_salesTable.SalesId, true);
        if (!creditCardAuthTrans)
        {
            throw error("@SYS328891"); // Credit card refunds can be processed only when the credit note is created from an existing sales order.
        }

        // Must refund using the same processor as was used for authorization
        CreditCardProcess process = CreditCardProcess::construct(CreditCardOperation::Refund, creditCardAuthTrans);

        process.setAmountFromSales(-1 * _custInvoiceJour.remainAmountToBePaid(), _salesTable.CurrencyCode);
        process.parmSalesInvoiceId(_salesInvoiceId);
        process.parmCustInvoiceJour(_custInvoiceJour);

        return process.process();
    }

]]></Source>
			</Method>
			<Method>
				<Name>doReauthorize</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reauthorize the credit card authorization.
    /// </summary>
    /// <param name = "ccat">The credit card authorization record.</param>
    /// <param name = "amount">Amount for reauthorization.</param>
    /// <returns>True if the authorization is reauthorized; otherwise, false.</returns>
    public static boolean doReauthorize(CreditCardAuthTrans _ccat, AmountCur _amount)
    {
        CreditCardProcess process = CreditCardProcess::construct(CreditCardOperation::Reauthorize, _ccat);
        process.setAmountFromSales(_amount, _ccat.CurrencyCode);
        return process.process();
    }

]]></Source>
			</Method>
			<Method>
				<Name>doVoidAuth</Name>
				<Source><![CDATA[
    /// <summary>
    /// Voids the credit card authorization.
    /// </summary>
    /// <param name = "_creditCardAuthTrans2Void">The credit card authorization record.</param>
    /// <param name = "_showSuccessMessage">Whether to display the void successful message.</param>
    /// <param name = "_successDescriptionOverride">The message to display when voiding is successful.</param>
    /// <returns>True if the authorization is voided; otherwise, false.</returns>
    public static boolean doVoidAuth(CreditCardAuthTrans _creditCardAuthTrans2Void, boolean _showSuccessMessage = true, str _successDescriptionOverride = '')
    {
        CreditCardProcess process = CreditCardProcess::construct(CreditCardOperation::Void, _creditCardAuthTrans2Void);

        if (RetailIncrementalCaptureFeatureExposure::isEnabledAndSupported(_creditCardAuthTrans2Void))
        {
            process.parmMCRPaymentTrackingId(extendedParameters.parmDoVoidAuth_MCRPaymentTrackingId());
            process.parmAdjustAuthorizationAmount(extendedParameters.parmDoVoidAuth_AdjustAuthorizationAmount());
            process.parmIncrementalOffsetReference(extendedParameters.parmDoVoidAuth_IncrementalOffsetReference());
            AmountCur voidAmount = CreditCardProcess::processVoidForIncrementalCapture(_creditCardAuthTrans2Void);

            if (voidAmount == 0)
            {
                return true;
            }

            process.setAmountFromSales(voidAmount, _creditCardAuthTrans2Void.CurrencyCode);
        }
        else
        {
            process.setAmountFromAuthTrans(_creditCardAuthTrans2Void);
        }

        return process.process(_showSuccessMessage, _successDescriptionOverride);
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        SalesTable salesTable;
        MCRCustPaymTable mcrCustPaymTable;
        RetailSharedParameters retailSharedParameters;

        retailSharedParameters = RetailSharedParameters::find();
        if (retailSharedParameters && retailSharedParameters.EnableAdvancedExternalGiftCard)
        {
            CreditCardProcess::externalGiftCardSupportedMain(_args);
        }
        else
        {
            switch (_args.parmEnum())
            {
                case CreditCardOperation::Authorize:
                if (_args.record().TableId == tableNum(MCRCustPaymTable))
                    {
                        mcrCustPaymTable = _args.record();
                        CreditCardProcess::mcrDoPreAuth(mcrCustPaymTable, true, _args);
                    }
                    else
                    {
                        salesTable = _args.record();
                        CreditCardProcess::doPreAuth(salesTable);
                        salesTable.reread();
                    }
                    break;
                case CreditCardOperation::Void:
                if (_args.record().TableId == tableNum(MCRCustPaymTable))
                    {
                        mcrCustPaymTable = _args.record();
                        CreditCardProcess::mcrDoVoidPreAuth(mcrCustPaymTable, _args);
                        mcrCustPaymTable.reread();
                    }
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>externalGiftCardSupportedMain</Name>
				<Source><![CDATA[
    /// <summary>
    /// Alternate main, When retail external gift card payment switched on
    /// </summary>
    /// <param name = "_args">The passed arguments.</param>
    [Hookable(false)]
    public static void externalGiftCardSupportedMain(Args _args)
    {
        SalesTable salesTable;
        MCRCustPaymTable mcrCustPaymTable;

        switch (_args.parmEnum())
        {
            case CreditCardOperation::Authorize:
                if (_args.record().TableId == tableNum(MCRCustPaymTable))
                {
                    mcrCustPaymTable = _args.record();
                    CreditCardProcess process = null;
                    RetailExternalGiftCard retailExternalGiftCard = null;

                    process = CreditCardProcess::initProcessForExternalGiftCard(mcrCustPaymTable, CreditCardOperation::Authorize, _args);

                    CreditCardProcess::mcrDoPreAuthWithPassedProcess(mcrCustPaymTable, true, _args, process);
                    mcrCustPaymTable.reread();

                    if (mcrCustPaymTable.IsPrepay && mcrCustPaymTable.Status == MCRCustPaymStatus::Authorized)
                    {
                        CreditCardProcess::captureExternalGiftCardPayment(mcrCustPaymTable, process.paramRetailExternalGiftCard());
                    }
                }
                else
                {
                    salesTable = _args.record();
                    CreditCardProcess::doPreAuth(salesTable);
                    salesTable.reread();
                }
                break;
            case CreditCardOperation::Void:
                if (_args.record().TableId == tableNum(MCRCustPaymTable))
                {
                    mcrCustPaymTable = _args.record();
                    CreditCardProcess process = null;

                    process = CreditCardProcess::initProcessForExternalGiftCard(mcrCustPaymTable, CreditCardOperation::Void, _args);
                    CreditCardProcess::mcrDoVoidPreAuthWithPassedProcess(mcrCustPaymTable, _args, process);
                    mcrCustPaymTable.reread();
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrDoCapture</Name>
				<Source><![CDATA[
    /// <summary>
    /// Captures the amount of the passed in record.
    /// </summary>
    /// <param name="_record">
    /// <c>MCRCustPaymTable</c> or <c>CreditCardAuthTrans</c> record to be captured.
    /// </param>
    /// <param name="_salesInvoiceId">
    /// Invoice ID of the related <c>CustInvoiceJour</c> record; optional.
    /// </param>
    /// <param name="_custInvoiceJour">
    /// Invoice record generated during the invoicing process; optional.
    /// </param>
    /// <param name="_amount">
    /// The positive amount to post.
    /// </param>
    /// <returns>
    /// true if capture was successful; otherwise, false.
    /// </returns>
    /// <remarks>
    /// <c>SalesInvoiceId</c> and <c>CustInvoiceJour</c> are both passed in
    /// to improve usability of method.
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// Require record for processing; throw error if not provided.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Related table of payment must be <c>CustInvoiceTable</c>, <c>LedgerJournalTrans</c> or <c>SalesTable</c>;
    /// throw error if not the case.
    /// </exception>
    public static boolean mcrDoCapture(
        Common _record,
        SalesInvoiceId _salesInvoiceId = '',
        CustInvoiceJour _custInvoiceJour = null,
        Amount _amount = 0)
    {
        return CreditCardProcess::mcrDoCaptureWithPassedProcess(_record, _salesInvoiceId, _custInvoiceJour, _amount, null);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrDoCaptureWithPassedProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Captures the amount of the passed in record.
    /// </summary>
    /// <param name="_record">
    /// <c>MCRCustPaymTable</c> or <c>CreditCardAuthTrans</c> record to be captured.
    /// </param>
    /// <param name="_salesInvoiceId">
    /// Invoice ID of the related <c>CustInvoiceJour</c> record; optional.
    /// </param>
    /// <param name="_custInvoiceJour">
    /// Invoice record generated during the invoicing process; optional.
    /// </param>
    /// <param name="_amount">
    /// The positive amount to post.
    /// </param>
    /// <param name="_process">Optional passed credit card processor.</param>
    /// <returns>
    /// true if capture was successful; otherwise, false.
    /// </returns>
    /// <remarks>
    /// <c>SalesInvoiceId</c> and <c>CustInvoiceJour</c> are both passed in
    /// to improve usability of method.
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// Require record for processing; throw error if not provided.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Related table of payment must be <c>CustInvoiceTable</c>, <c>LedgerJournalTrans</c> or <c>SalesTable</c>;
    /// throw error if not the case.
    /// </exception>
    internal static boolean mcrDoCaptureWithPassedProcess(
        Common _record,
        SalesInvoiceId _salesInvoiceId = '',
        CustInvoiceJour _custInvoiceJour = null,
        Amount _amount = 0,
        CreditCardProcess _process = null)
    {
        CreditCardProcess process;
        CreditCardAuthTrans authTrans;
        MCRCustPaymTable mcrCustPaymTable;
        CreditCardAuthTrans latestTransaction;

        if (_record)
        {
            if (_process == null)
            {
                _process = CreditCardProcess::construct(CreditCardOperation::AuthorizeAndCapture, _record);
            }

            if (_record.TableId == tableNum(CreditCardAuthTrans))
            {
                authTrans = _record;
                mcrCustPaymTable = MCRCustPaymTable::findByRecID(authTrans.MCRPaymRecId);
                latestTransaction = CreditCardAuthTrans::mcrFindLatest(authTrans.MCRPaymRecId);
            }
            else if (_record.TableId == tableNum(MCRCustPaymTable))
            {
                mcrCustPaymTable = _record;
                latestTransaction = CreditCardAuthTrans::mcrFindLatest(mcrCustPaymTable.RecId);
            }

            if (mcrCustPaymTable)
            {
                _process.setAmountFromSales(_amount, mcrCustPaymTable.CurrencyCode);
                switch (mcrCustPaymTable.RefTableId)
                {
                    case tableNum(SalesTable):
                        _process.parmSalesInvoiceId(_salesInvoiceId);
                        _process.parmCustInvoiceJour(_custInvoiceJour);
                        break;
                    case tableNum(custInvoiceTable):
                        _process.parmMCRCustInvoiceTable(custInvoiceTable::findRecId(mcrCustPaymTable.RefRecId));
                        break;
                    case tableNum(ledgerJournalTrans):
                        _process.parmMCRLedgerJournalTrans(ledgerJournalTrans::findRecId(mcrCustPaymTable.RefRecId, false));
                        break;
                    case tableNum(custPaymSchedLine):
                        _process.parmMCRCustPaymSchedLine(custPaymSchedLine::mcrFindByRecID(mcrCustPaymTable.RefRecId, false));
                        break;
                    default:
                        throw error(strFmt("@MCR40412",int642str(mcrCustPaymTable.RefTableId)));
                }
                _process.parmMCRCustPaymRecId(mcrCustPaymTable.RecId);
            }
        }
        else
        {
            throw error("@MCR40413");
        }

        authTrans = _process.parmCreditCardAuthTrans();

        if (_process.verifyCreditCardAuth(authTrans))
        {
            // If authorization is already done, check if the amount is sufficient.
            if (CreditCardProcess::isAuthTransApprovalAmountSufficient(_process, authTrans))
            {
                // Authorization is sufficient, just need to capture
                _process.parmOperation(CreditCardOperation::CaptureAfterAuthorize);
            }
            else
            {
                // Authorization is insufficient, void the authorization and then authorize and capture.
                info("@SYS116938");
                if (!CreditCardProcess::doVoidAuth(authTrans, false, '' ))
                {
                    return false;
                }
            }
        }

        CreditCardProcess::setPaymentTrackingId(CreditCardOperation::CaptureAfterAuthorize, _process, latestTransaction);

        return _process.process();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrDoPreAuth</Name>
				<Source><![CDATA[
    /// <summary>
    /// Authorizes the amount on the passed in record.
    /// </summary>
    /// <param name="_record">
    /// <c>MCRCustPaymTable</c> or <c>CreditCardAuthTrans</c> record to be authorized.
    /// </param>
    /// <param name="_presentExtraMsg">
    /// Determines whether or not messages are displayed.
    /// </param>
    /// <returns>
    /// true if authorization was successful; otherwise, false.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Passed in common must be either a <c>MCRCustPaymTable</c> or <c>CreditCardAuthTrans</c>,
    /// throw error if not.
    /// </exception>
    public static boolean mcrDoPreAuth(Common _record,
                                    boolean _presentExtraMsg = true,
                                    Args _args = null)
    {
        return CreditCardProcess::mcrDoPreAuthWithPassedProcess(_record, _presentExtraMsg, _args, null);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrDoPreAuthWithPassedProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Authorizes the amount on the passed in record.
    /// </summary>
    /// <param name="_record">
    /// <c>MCRCustPaymTable</c> or <c>CreditCardAuthTrans</c> record to be authorized.
    /// </param>
    /// <param name="_presentExtraMsg">
    /// Determines whether or not messages are displayed.
    /// </param>
    /// <param name="_process">Optional passed credit card processor.</param>
    /// <returns>
    /// true if authorization was successful; otherwise, false.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Passed in common must be either a <c>MCRCustPaymTable</c> or <c>CreditCardAuthTrans</c>,
    /// throw error if not.
    /// </exception>

    internal static boolean mcrDoPreAuthWithPassedProcess(
        Common _record,
        boolean _presentExtraMsg = true,
        Args _args = null,
        CreditCardProcess _process = null)
    {
        MCRCustPaymTable mcrCustPaymTable;
        CreditCardAuthTrans latestTransaction;
        boolean success;
        boolean skipIncrementalCaptureCheck = false;

        // do nothing if no pre-authorize required
        if (!CustParameters::find().CreditCardPreAuthorization)
        {
            if (_record.TableId == tableNum(mcrCustPaymTable))
            {
                mcrCustPaymTable = _record;
                eventSource.EventWritePaymentsCreditCardPreAuthorizationSkipped(mcrCustPaymTable.RefRecId);
            }
            return true;
        }

        // for a non-repeating token we need to check if we have a capture request and no new authorization is required
        if (RetailNonRecurringTokenFeatureExposure::isEnabled()
            && _record.TableId == tableNum(mcrCustPaymTable)
            && !RetailPaymentAccessTokenContext::instance().accessCodeExists(_record.RecId))
        {
            mcrCustPaymTable = _record;
            if (mcrCustPaymTable.IsNonRecurring == NoYes::Yes)
            {
                latestTransaction = CreditCardAuthTrans::mcrFindLatest(_record.RecId);
                if (CreditCardProcess::processPreAuthForIncrementalCapture(latestTransaction))
                {
                    return true;
                }
                skipIncrementalCaptureCheck = true;
            }
        }

        if (_record)
        {
            if (_process == null)
            {
                _process = CreditCardProcess::construct(CreditCardOperation::Authorize, _record);
            }

            if (_record.TableId == tableNum(mcrCustPaymTable))
            {
                mcrCustPaymTable = _record;
                _process.setAmountFromSales(mcrCustPaymTable.getUnpostedAmount(),mcrCustPaymTable.CurrencyCode);
                latestTransaction = CreditCardAuthTrans::mcrFindLatest(mcrCustPaymTable.RecId);

            }
            else if (_record.TableId == tableNum(CreditCardAuthTrans))
            {
                CreditCardAuthTrans creditCardAuthTrans = _record;
                _process.setAmountFromSales(creditCardAuthTrans.ApprovalAmountCur,creditCardAuthTrans.CurrencyCode);
                latestTransaction = CreditCardAuthTrans::mcrFindLatest(creditCardAuthTrans.MCRPaymRecId);
            }
            else
            {
                throw error(error::wrongUseOfFunction(funcName()));
            }
        }
        else
        {
            throw error(error::wrongUseOfFunction(funcName()));
        }

        _process.parmGetCardVerificationValue(_presentExtraMsg);

        // Do nothing if pre-authorization is already done, and amount is sufficient
        CreditCardAuthTrans authTrans = _process.parmCreditCardAuthTrans();

        if (authTrans)
        {
            if (CreditCardProcess::isAuthTransApprovalAmountSufficient(_process, authTrans))
            {
                if (_presentExtraMsg)
                {
                    info("@SYS122586");
                }

                return true;
            }
            else
            {
                boolean doReauthorization = false;
                // do reauthorization only if there is no access code, so we dont try to create a new authorization
                if (RetailNonRecurringTokenFeatureExposure::isEnabled() && mcrCustPaymTable && !RetailPaymentAccessTokenContext::instance().accessCodeExists(mcrCustPaymTable.RecId))
                {
                    // Adjust the existing pre-authorization if amount has changed.
                    doReauthorization = true;
                    skipIncrementalCaptureCheck = true;
                    _process.parmOperation(CreditCardOperation::Reauthorize);
                }

                // Void the existing pre-authorization if amount has changed.
                // For backward compatibility, in the case where re-authorization is not available, we perform the previous logic.
                if (!doReauthorization && !CreditCardProcess::doVoidAuth(authTrans, false))
                {
                    return false;
                }
            }
        }
        // 
        else if (RetailNonRecurringTokenFeatureExposure::isEnabled()
            && mcrCustPaymTable
            && mcrCustPaymTable.IsNonRecurring == NoYes::Yes
            && !RetailPaymentAccessTokenContext::instance().accessCodeExists(mcrCustPaymTable.RecId))
        {
            error("@Retail:RetailNonRecurringTokenAuthorizationCodeMissing");
            return false;
        }

        if (!skipIncrementalCaptureCheck && CreditCardProcess::processPreAuthForIncrementalCapture(latestTransaction))
        {
            // Still funds outstanding on authorization, so use this instead of creating a new authorization.
            return true;
        }

        CreditCardProcess::setPaymentTrackingId(CreditCardOperation::Authorize, _process, latestTransaction);

        // Enforce card token restrictions.
        _process.enforceCardTokenRestriction();

        success = _process.process();
        if (success)
        {
            if (_record.TableId == tableNum(mcrCustPaymTable))
            {
                mcrCustPaymTable = mcrCustPaymTable::findByRecID(_record.RecId, true);

                // Only update Payment Status when caller authorizing payment via MCRCustPaymTable form
                // as in this case, the MCRCustPaymTable is not updated by default
                if (mcrCustPaymTable && _args)
                {
                    ttsbegin;
                    mcrCustPaymTable.Status= MCRCustPaymStatus::Authorized;
                    mcrCustPaymTable.update();
                    ttscommit;
                    // If there is a caller form, Refresh it
                    if (_args)
                    {
                        _args.callerDispatcher().refresh();
                    }
                }
            }
        }
        return success;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaymentTrackingId</Name>
				<Source><![CDATA[
    private static void setPaymentTrackingId(CreditCardOperation _operation, CreditCardProcess _process, CreditCardAuthTrans _latestTransaction)
    {
        if (RetailIncrementalCaptureFeatureExposure::isEnabled())
        {
            if (_latestTransaction.hasPaymentOperationAndStatus(_operation, CreditCardProcessorStatus::TimedOut))
            {
                // re-use tracking id as transaction might of been processed by gateway
                _process.parmMCRPaymentTrackingId(_latestTransaction.MCRTrackingId);
            }
            else
            {
                // Get a new tracking id as either an error was returned or this is a new payment transaction
                _process.parmMCRPaymentTrackingId(_process.getMCRPaymentTrackingId());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setVoidPaymentTrackingId</Name>
				<Source><![CDATA[
    private static void setVoidPaymentTrackingId(CreditCardOperation _operation, CreditCardProcess _process, CreditCardAuthTrans _latestTransaction)
    {
        if (RetailIncrementalCaptureFeatureExposure::isEnabled())
        {
            if (_latestTransaction.hasPaymentOperationAndStatus(_operation, CreditCardProcessorStatus::TimedOut))
            {
                // re-use tracking id as transaction might of been processed by gateway
                extendedParameters.parmDoVoidAuth_MCRPaymentTrackingId(_latestTransaction.MCRTrackingId);
            }
            else
            {
                // Get a new tracking id as either an error was returned or this is a new payment transaction
                extendedParameters.parmDoVoidAuth_MCRPaymentTrackingId(_process.getMCRPaymentTrackingId());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setIncrementalOffsetReference</Name>
				<Source><![CDATA[
    private static void setIncrementalOffsetReference(CreditCardAuthTrans _authorizationTransaction)
    {
        if (RetailIncrementalCaptureFeatureExposure::isEnabled() && _authorizationTransaction.RecId != 0)
        {
            CreditCardAuthTrans offsetTransaction = CreditCardAuthTrans::mcrFindLatestOffsetTransaction(_authorizationTransaction);

            if (offsetTransaction.RecId)
            {
                PaymentIncrementalOffsetReference offsetReference = CreditCardProcess::getIncrementalOffsetReference(offsetTransaction);

                if (offsetReference != '')
                {
                    extendedParameters.parmDoVoidAuth_IncrementalOffsetReference(offsetReference);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIncrementalOffsetReference</Name>
				<Source><![CDATA[
    private static PaymentIncrementalOffsetReference getIncrementalOffsetReference(CreditCardAuthTrans _offsetTransaction)
    {
        PaymentIncrementalOffsetReference offsetReference = '';
        CreditCardPaymentProperty property;

        var properties = CreditCardPaymentProperties::fromXmlString(_offsetTransaction.CardTokenResult);

        if (_offsetTransaction.ApprovalType == CreditCardOperation::Authorize)
        {
            property = properties.find(RetailConst.GenericNamespace::get_AuthorizationResponse(), RetailConst.AuthorizationResponseProperties::get_IncrementalOffsetReference());
        }
        else
        {
            property = properties.find(RetailConst.GenericNamespace::get_VoidResponse(), RetailConst.VoidResponseProperties::get_IncrementalOffsetReference());
        }

        if (property && property.parmStringValue())
        {
            offsetReference = property.parmStringValue();
        }

        return offsetReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrDoVoidPreAuth</Name>
				<Source><![CDATA[
    /// <summary>
    /// Voids the Authorization passed in record.
    /// </summary>
    /// <param name = "_record"><c>MCRCustPaymTable</c> or <c>CreditCardAuthTrans</c> record to be voided.</param>
    /// <param name = "_args">The args from the caller form.</param>
    /// <returns>true if void was successful; otherwise, false.</returns>
    public static boolean mcrDoVoidPreAuth(Common _record, Args _args = null)
    {
        return CreditCardProcess::mcrDoVoidPreAuthWithPassedProcess(_record, _args, null);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrDoVoidPreAuthWithPassedProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Voids the Authorization passed in record.
    /// </summary>
    /// <param name = "_record"><c>MCRCustPaymTable</c> or <c>CreditCardAuthTrans</c> record to be voided.</param>
    /// <param name = "_args">The args from the caller form.</param>
    /// <param name="_process">Optional passed credit card processor.</param>
    /// <returns>true if void was successful; otherwise, false.</returns>
    [Hookable(false)]
    public static boolean mcrDoVoidPreAuthWithPassedProcess(Common _record, Args _args = null, CreditCardProcess _process = null)
    {
        CreditCardAuthTrans authTrans;
        MCRCustPaymTable mcrCustPaymTable;
        CreditCardAuthTrans latestTransaction;
        CreditCardAuthTrans associatedAuthorization;
        boolean isPartialVoid = extendedParameters.parmDoVoidAuth_AdjustAuthorizationAmount() > 0;

        if (_record)
        {
            if (_process == null)
            {
                _process = CreditCardProcess::construct(CreditCardOperation::Void, _record);
            }

            if (_record.TableId == tableNum(mcrCustPaymTable))
            {
                mcrCustPaymTable = _record;
                latestTransaction = CreditCardAuthTrans::mcrFindLatest(mcrCustPaymTable.RecId);

            }
            else if (_record.TableId == tableNum(CreditCardAuthTrans))
            {
                authTrans = _record;
                latestTransaction = CreditCardAuthTrans::mcrFindLatest(authTrans.MCRPaymRecId);
            }

            associatedAuthorization =  latestTransaction.OrigAuthRecId == 0 ? latestTransaction : CreditCardAuthTrans::find(latestTransaction.OrigAuthRecId);

            CreditCardProcess::setVoidPaymentTrackingId(CreditCardOperation::Void, _process, latestTransaction);
            CreditCardProcess::setIncrementalOffsetReference(associatedAuthorization);

            authTrans = _process.parmCreditCardAuthTrans();
            boolean isVoided = CreditCardProcess::doVoidAuth(authTrans, false);
            extendedParameters.parmDoVoidAuth_MCRPaymentTrackingId(null);
            extendedParameters.parmDoVoidAuth_AdjustAuthorizationAmount(0);
            extendedParameters.parmDoVoidAuth_IncrementalOffsetReference(null);

            if (!isVoided)
            {
                return false;
            }
        }
        else
        {
            throw error(error::wrongUseOfFunction(funcName()));
        }

        // Update MCRCustPaymTable status and add new event for Reversing Authorization
        if (_record.TableId == tableNum(mcrCustPaymTable) || !RetailPaymentsVoidCreditCardAuthCorrectionFlight::instance().isEnabled())
        {
            mcrCustPaymTable = mcrCustPaymTable::findByRecID(_record.RecId, true);
        }
        else if (_record.TableId == tableNum(CreditCardAuthTrans))
        {
            mcrCustPaymTable = mcrCustPaymTable::findByRecID(authTrans.MCRPaymRecId, true);
        }

        if (mcrCustPaymTable)
        {
            ttsbegin;

            boolean isPostedOrPartiallyVoid = CreditCardProcess::isPostedOrPartialVoid(mcrCustPaymTable.PostedAmount, isPartialVoid);

            if (RetailIncrementalCaptureFeatureExposure::isEnabledAndSupported(mcrCustPaymTable) && isPostedOrPartiallyVoid)
            {
                // Unsubmit the payment and skip clearing void on credit card auth if the order is partially voided and payment is not posted.
                // Refer to <c>RetailPaymentsUnsubmitPaymentForPartiallyCanceledCallCenterOrderFlight</c> for more details.
                if ((RetailPaymentsUnsubmitPaymentForPartiallyCanceledCallCenterOrderFlight::instance().isEnabled() ||
                    RetailSkipDeletingVoidAuthorizationWhenPaymentAmountChangesToZeroFlight::instance().isEnabled()) &&
                    isPartialVoid &&
                    mcrCustPaymTable.PostedAmount == 0)
                {
                    mcrCustPaymTable.Status = MCRCustPaymStatus::NotSubmitted;
                }
                else 
                {
                    if (mcrCustPaymTable.Amount == mcrCustPaymTable.PostedAmount)
                    {
                        mcrCustPaymTable.Status = MCRCustPaymStatus::Paid;
                    }
                    else
                    {
                        mcrCustPaymTable.Status = MCRCustPaymStatus::Authorized;
                    }

                    CreditCardAuthTrans::clearVoidOnCreditCardAuthTrans(associatedAuthorization.RecId);
                }
            }
            else if(isPostedOrPartiallyVoid && (mcrCustPaymTable.Amount == mcrCustPaymTable.PostedAmount))
            {
                mcrCustPaymTable.Status = MCRCustPaymStatus::Paid;
                CreditCardAuthTrans::clearVoidOnCreditCardAuthTrans(associatedAuthorization.RecId);
            }
            else
            {
                mcrCustPaymTable.Status = MCRCustPaymStatus::NotSubmitted;
            }

            mcrCustPaymTable.update();

            ttscommit;

            // Change Sales Order Status back to Open
            if (_args)
            {
                _args.caller().mcrModify();
                _args.callerDispatcher().refresh();
            }

            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPostedOrPartialVoid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether posted amount or <c>AdjustAuthorizationAmount</c> exists for the payment.
    /// </summary>
    /// <param name="_postedAmount">
    /// Posted amount from <c>MCRCustPaymTable</c> record.
    /// </param>
    /// <param name="_isPartialVoid">
    /// boolean value which will be true if <c>AdjustAuthorizationAmount</c> is greater than zero else false.
    /// </param>
    /// <returns>
    /// true if either posted amount or <c>AdjustAuthorizationAmount</c> exists; otherwise, false.
    /// </returns>
    internal static boolean isPostedOrPartialVoid(AmountCur _postedAmount, boolean _isPartialVoid)
    {
        return _postedAmount != 0 || _isPartialVoid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrDoRefund</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refunds the amount on the passed in <c>MCRCustPaymTable</c> record.
    /// </summary>
    /// <param name="_mcrCustPaymTable">
    /// Payment record to be refunded.
    /// </param>
    /// <returns>
    /// true if refund was successful; otherwise, false.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// <c>MCRCustPaymTable</c> record required for processing, throw error if not provided.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// <c>CreditCardAuthTrans</c> record required for refund, throw error if not found.
    /// </exception>
    public static boolean mcrDoRefund(MCRCustPaymTable _mcrCustPaymTable)
    {
        CreditCardAuthTrans creditCardAuthTrans;
        CreditCardProcess process;
        McrCustPaymTable originalPayment;
        CreditCardAuthTrans latestTransaction;

        boolean isRefundsOverMultipleCaptureEnabled = RetailTransactionPaymentsHelper::isRefundsOverMultipleCapturesEnabled();
        SalesInvoiceId salesInvoiceId = extendedParameters.parmRecordRefund_SalesInvoiceId();

        if (!_mcrCustPaymTable)
        {
            throw error(error::wrongUseOfFunction(funcName()));
        }

        if (_mcrCustPaymTable.OrigRefundRecID)
        {
            creditCardAuthTrans = CreditCardAuthTrans::mcrFindRefundCharge(_mcrCustPaymTable.OrigRefundRecID, true);
            latestTransaction = CreditCardAuthTrans::mcrFindLatest(_mcrCustPaymTable.RecId);
        }
        else
        {
            // Find the original payment record using the same card
            select firstOnly RecId from originalPayment
            where originalPayment.RefTableId == _mcrCustPaymTable.RefTableId
               && originalPayment.RefRecId == _mcrCustPaymTable.RefRecId
               && originalPayment.PaymInfoTableId == _mcrCustPaymTable.PaymInfoTableId
               && originalPayment.PaymInfoRecId == _mcrCustPaymTable.PaymInfoRecId
               && originalPayment.Amount > 0
               && (originalPayment.Status == MCRCustPaymStatus::Paid ||
                   originalPayment.Status == MCRCustPaymStatus::Posted);

            // Find the capture trans of the original payment record
            creditCardAuthTrans = CreditCardAuthTrans::mcrFindRefundCharge(originalPayment.RecId, true);
            latestTransaction = CreditCardAuthTrans::mcrFindLatest(originalPayment.RecId);
        }

        // find authorization based on original sales order link if the link to the original payment is lost
        if (!creditCardAuthTrans && _mcrCustPaymTable.RefTableId == tableNum(salesTable) && RetailPaymentCardPaymentSearchLinkedRefundFlight::instance().isEnabled())
        {
            MCRReturnSalesTable returnSalesTable = _mcrCustPaymTable.salesTable(false).mcrReturnSalesTable();
            SalesTable origSalesOrder = SalesTable::find(returnSalesTable.OriginalSalesId);
            
            // Find the original payment record using the same card
            select firstonly RecId from originalPayment
                    where originalPayment.RefRecId == origSalesOrder.RecId
                        && originalPayment.RefTableId == _mcrCustPaymTable.RefTableId
                        && originalPayment.PaymInfoTableId == _mcrCustPaymTable.PaymInfoTableId
                        && originalPayment.PaymInfoRecId == _mcrCustPaymTable.PaymInfoRecId
                        && originalPayment.Amount > 0
                        && (originalPayment.Status == MCRCustPaymStatus::Paid
                        || originalPayment.Status == MCRCustPaymStatus::Posted);

            // Find the capture trans of the original payment record
            creditCardAuthTrans = CreditCardAuthTrans::mcrFindRefundCharge(originalPayment.RecId, true);
            latestTransaction = CreditCardAuthTrans::mcrFindLatest(originalPayment.RecId);
        }

        if (!creditCardAuthTrans && !_mcrCustPaymTable.allowAlternatePaymentMethod())
        {
            if (isRefundsOverMultipleCaptureEnabled)
            {
                throw error('@Retail:CreditCardRefundFailureError'); // The original card payment details cannot be retrieved.
            }
            else
            {
                throw error("@SYS328891");
            }
        }

        // Must refund using the same processor as was used for authorization
        if (creditCardAuthTrans)
        {
            process = CreditCardProcess::construct(CreditCardOperation::Refund,creditCardAuthTrans);
        }
        else if (_mcrCustPaymTable.allowAlternatePaymentMethod())
        {
            process = CreditCardProcess::construct(CreditCardOperation::Refund,_mcrCustPaymTable);
        }

        process.parmMCRCustPaymTable(_mcrCustPaymTable);

        CreditCard_ExtendedParameters creditCard_ExtendedParameters = CreditCard::extendedParameters;

        if (isRefundsOverMultipleCaptureEnabled)
        {
            creditCard_ExtendedParameters.parmRecordRefund_OrigAuthTransId(0);

            if (creditCardAuthTrans)
            {
                // Scenario of linked refund when the original capture has been found.
                // Get the capture refundable balance amount
                AmountCur refundAmount =
                min(CreditCardAuthTrans::getRefundableAmount(creditCardAuthTrans),
                    creditCard_ExtendedParameters.parmRecordRefund_RefundAmount());

                process.mcrSetRefundAmount(refundAmount);
                creditCard_ExtendedParameters.parmRecordRefund_RefundedAmount(-refundAmount);
                creditCard_ExtendedParameters.parmRecordRefund_OrigAuthTransId(creditCardAuthTrans.RecId);
            }
            else
            {
                // Scenario of blind return i.e. when return order is not associated to any previously invoiced sales order.
                AmountCur refundAmount =
                min(abs(_mcrCustPaymTable.getUnpostedAmount()),
                     creditCard_ExtendedParameters.parmRecordRefund_RefundAmount());

                process.mcrSetRefundAmount(refundAmount);
                creditCard_ExtendedParameters.parmRecordRefund_RefundedAmount(_mcrCustPaymTable.getUnpostedAmount());
            }
        }
        else
        {
            AmountCur refundAmount =
            min(abs(_mcrCustPaymTable.getUnpostedAmount()),
                creditCard_ExtendedParameters.parmRecordRefund_RefundAmount());

            process.mcrSetRefundAmount(refundAmount);
        }

        //Currently only return orders are supported for refunds.
        if (_mcrCustPaymTable.RefTableId == tableNum(salesTable))
        {
            process.parmSalesInvoiceId(salesInvoiceId);
        }

        CreditCardProcess::setPaymentTrackingId(CreditCardOperation::Refund, process, latestTransaction);

        return process.process();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrDoBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the balance on a card.
    /// </summary>
    /// <param name = "_mcrCustPaymTable"><c>MCRCustPaymTable</c> record required for processing, throw error if not provided.</param>
    /// <param name = "_process">Optional passed credit card processor.</param>
    /// <returns>True if the balance was retrieved; otherwise, false.</returns>
    [Hookable(false)]
    public static boolean mcrDoBalance(MCRCustPaymTable _mcrCustPaymTable, CreditCardProcess _process = null)
    {
        if (_process == null)
        {
            _process = CreditCardProcess::construct(CreditCardOperation::Balance,_mcrCustPaymTable);
        }

        _process.parmMCRCustPaymTable(_mcrCustPaymTable);

        return _process.process();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initProcessForExternalGiftCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Only Initialize the process for external gift card it the payment is external gift card.
    /// </summary>
    /// <param name = "_mcrCustPaymTable">The MCRCustPaymTable record for the payment.</param>
    /// <param name = "_operation">The credit card operation.</param>
    /// <param name = "_args">The main form arguments variable.</param>
    /// <returns>If external gift card return the process, otherwise null.</returns>
    private static CreditCardProcess initProcessForExternalGiftCard(MCRCustPaymTable _mcrCustPaymTable, CreditCardOperation _operation, Args _args)
    {
        CreditCardProcess process = null;

        if (_mcrCustPaymTable.isExternalGiftCardPayment())
        {
            Object callerForm = _args.caller();
            if (callerForm && formHasMethod(callerForm, identifierstr(mcrGetAllExternalGiftCard)))
            {
                Map externalGiftCardMap = callerForm.mcrGetAllExternalGiftCard();

                if (externalGiftCardMap.exists(_mcrCustPaymTable.PaymInfoRecId))
                {
                    RetailExternalGiftCard retailExternalGiftCard = externalGiftCardMap.lookup(_mcrCustPaymTable.PaymInfoRecId);

                    process = CreditCardProcess::construct(_operation, _mcrCustPaymTable);
                    process.paramRetailExternalGiftCard(retailExternalGiftCard);
                }
            }
        }

        return process;
    }

]]></Source>
			</Method>
			<Method>
				<Name>captureExternalGiftCardPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Capture the external gift card payment.
    /// </summary>
    /// <param name = "_mcrCustPaymTable">The MCRCustPaymTable record for the payment.</param>
    /// <param name = "_retailExternalGiftCard">The retail external gift card object for the capture..</param>
    private static void captureExternalGiftCardPayment(MCRCustPaymTable _mcrCustPaymTable, RetailExternalGiftCard _retailExternalGiftCard)
    {
        CreditCardAuthTrans creditCardAuthTrans = CreditCardAuthTrans::mcrfindValidPreApproval(_mcrCustPaymTable.RecId);

        if (creditCardAuthTrans)
        {
            CreditCardProcess process = CreditCardProcess::construct(CreditCardOperation::AuthorizeAndCapture, _mcrCustPaymTable);
            process.paramRetailExternalGiftCard(_retailExternalGiftCard);

            boolean success =  CreditCardProcess::mcrDoCaptureWithPassedProcess(creditCardAuthTrans, null, null, _mcrCustPaymTable.Amount, process);

            if (success)
            {
                ttsbegin;
                _mcrCustPaymTable.Status= MCRCustPaymStatus::Paid;
                _mcrCustPaymTable.update();
                ttscommit;
            }

            _mcrCustPaymTable.reread();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultExtendedParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets extendedParameters and returns a new object with default properties.
    /// This helps ensure that extendedParameters is not already dirty before using it.
    /// </summary>
    /// <returns>
    /// The newly instantiated extendedParameters with default properties.
    /// </returns>
    internal static CreditCardProcess_ExtendedParameters getDefaultExtendedParameters()
    {
        extendedParameters = CreditCardProcess_ExtendedParameters::construct();
        return extendedParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processPreAuthForIncrementalCapture</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allows incremental captures to be assigned to a single authorization up to the amount authorized.
    /// </summary>
    /// <param name = "_latestTransaction">The latest credit card authorization transaction.</param>
    /// <returns>true if multiple captures is used; otherwise, false.</returns>
    private static boolean processPreAuthForIncrementalCapture(CreditCardAuthTrans _latestTransaction)
    {
        CreditCardAuthTrans referencedCreditCardAuthTran = CreditCardAuthTrans::findReferencedSettledAuthorization(_latestTransaction.SalesId, _latestTransaction.Authorization);

        if (referencedCreditCardAuthTran && RetailIncrementalCaptureFeatureExposure::isEnabled() && referencedCreditCardAuthTran.supportsIncrementCapture())
        {
            return CreditCardProcess::executePreAuthForIncrementalCapture(referencedCreditCardAuthTran);
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>executePreAuthForIncrementalCapture</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allows incremental captures to be assigned to a single authorization up to the amount authorized.
    /// </summary>
    /// <param name = "_latestTransaction">The latest credit card authorization transaction.</param>
    /// <returns>true if multiple captures is used; otherwise, false.</returns>
    private static boolean executePreAuthForIncrementalCapture(CreditCardAuthTrans _latestTransaction)
    {
        // if capture check MCRPaymnRecid and sum up captures/voids and see if there is still authorized amount remaining
        if (_latestTransaction && (_latestTransaction.hasPaymentOperationAndStatus(CreditCardOperation::Authorize, CreditCardProcessorStatus::Approved)
            || _latestTransaction.hasPaymentOperationAndStatus(CreditCardOperation::Authorize, CreditCardProcessorStatus::Settled)))
        {
            AmountCur outstandingSettlement = CreditCardAuthTrans::totalReferencedAuthorizations(_latestTransaction.SalesId, _latestTransaction.Authorization);
            if (RetailPaymentsExcludeVoidedAmountForOutstandingFundsFlight::instance().isEnabled())
            {
                // The amount of original authorization is already adjusted when voiding payment, so there is no need to count voided payments again.
                outstandingSettlement -= CreditCardAuthTrans::totalReferencedCaptures(_latestTransaction.SalesId, _latestTransaction.Authorization);
            }
            else
            {
                // By default line below should not be executed since voided payment is counted twice here. This should be removed if no issues reported by customer.
                outstandingSettlement -= CreditCardAuthTrans::totalReferencedCaptureAndVoids(_latestTransaction.SalesId, _latestTransaction.RecId);
            }

            boolean fundOutstanding = CreditCardAuthTrans::activateAuthorizationForOutstandingFunds(_latestTransaction, outstandingSettlement);

            eventSource.EventWriteRetailFundsOutstandingResult(_latestTransaction.RecId, fundOutstanding);

            return fundOutstanding;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processVoidForIncrementalCapture</Name>
				<Source><![CDATA[
    /// <summary>
    /// When voiding an authorization that is in incremental capture mode just change the ProcessorStatus to Settled and reduce the approved amount to the total captured amount
    /// </summary>
    /// <param name = "_authTran">The credit card authorization transaction that needs to be voided.</param>
    /// <returns>The remaining amount that needs to be voided.</returns>
    internal static AmountCur processVoidForIncrementalCapture(CreditCardAuthTrans _authTran)
    {
        AmountCur settlementAmount = 0;
        // Default void amount to auth trans approval amount
        AmountCur voidAmount = _authTran.ApprovalAmountCur;

        if (_authTran.hasPaymentOperationAndStatus(CreditCardOperation::Authorize, CreditCardProcessorStatus::Approved))
        {
            MCRCustPaymTable mcrCustPaymTable = MCRCustPaymTable::findByRecID(_authTran.MCRPaymRecId);

            // Does this authorization have captures
            settlementAmount = CreditCardAuthTrans::totalReferencedCaptures(_authTran.SalesId, _authTran.Authorization);
            voidAmount = CreditCardProcess::closeAuthorizationAndReturnUnSettledFunds(_authTran, settlementAmount, _authTran.ApprovalAmountCur, mcrCustPaymTable.Amount);
        }

        return voidAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeAuthorizationAndReturnUnSettledFunds</Name>
				<Source><![CDATA[
    /// <summary>
    /// Close the authorization for the sum of the incremental captures and return the outstanding amount for the voiding.
    /// </summary>
    /// <param name = "_authTran">The authorization to be closed out.</param>
    /// <param name = "_settlementAmount">The sum of the incremental captures.</param>
    /// <param name = "_approvedAmount">The approved amount.</param>
    /// <param name = "_mcrAmount">The MCRCustPaymTable amount.</param>
    /// <returns>The amount to be voided.</returns>
    private static AmountCur closeAuthorizationAndReturnUnSettledFunds(CreditCardAuthTrans _authTran,
        AmountCur _settlementAmount,
        AmountCur _approvedAmount,
        AmountCur _mcrAmount)
    {
        AmountCur voidAmount;

        if (_approvedAmount > _mcrAmount)
        {
            // Void the difference
            CreditCardAuthTrans::updateCreditCardAuthTrans(_authTran.RecId, _mcrAmount, CreditCardProcessorStatus::Approved);

            voidAmount = _approvedAmount - _mcrAmount;
        }
        else
        {
            if (_settlementAmount > 0)
            {
                // Don't change approved amount on original authorization even if is expired.
                // When incremental capture feature and flight to re-authorize expired authorization are enabled.
                if (RetailIncrementalCaptureFeatureExposure::isEnabled() &&
                    RetailPaymentsReAuthorizeExpiredPreAuthorizationsFlight::instance().isEnabled())
                {
                    CreditCardAuthTrans::updateCreditCardAuthTrans(_authTran.RecId, _approvedAmount, CreditCardProcessorStatus::Settled);
                }
                else
                {
                    // Change auth approved amount to the total for linked captures and change status to settled
                    CreditCardAuthTrans::updateCreditCardAuthTrans(_authTran.RecId, _settlementAmount, CreditCardProcessorStatus::Settled);
                }

                voidAmount = _approvedAmount - _settlementAmount;
            }
            else
            {
                voidAmount = _approvedAmount;
            }
        }

        return voidAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canResendProceed</Name>
				<Source><![CDATA[
    internal static boolean canResendProceed(TableId _tableId, RecId _recId)
    {
        if (!CreditCardProcessHelper::lifeCycleManagementEnabled())
        {
            return false;
        }

        CreditCardRequestStatus creditCardRequestStatus = CreditCardRequest::getLastStatus(_tableId, _recId);
        return creditCardRequestStatus == CreditCardRequestStatus::NetworkError || creditCardRequestStatus == CreditCardRequestStatus::NoResponse;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resendLastRequest</Name>
				<Source><![CDATA[
    protected internal boolean resendLastRequest()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCreditCardRequestResult</Name>
				<Source><![CDATA[
    protected internal CreditCardRequestResult getCreditCardRequestResult()
    {
        return CreditCardRequestResult::RequestNone;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastCreditCardRequestResult</Name>
				<Source><![CDATA[
    internal static CreditCardRequestResult getLastCreditCardRequestResult(Common _record)
    {
        if (CreditCardProcessHelper::lifeCycleManagementEnabled())
        {
            return CreditCardResultCacheStore::getLastRequestStatus(new CreditCardResultCacheKey(_record));
        }
        else
        {
            return CreditCardRequestResult::RequestNone;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isConsistent</Name>
				<Source><![CDATA[
    internal static boolean isConsistent(Common _record, CreditCardOperation _ccOperation)
    {
        if (CreditCardProcessHelper::lifeCycleManagementEnabled())
        {
            boolean canProceed = conPeek(CreditCardRequestRecorder::preCheck(_record.TableId, _record.RecId, _ccOperation), 2);

            return canProceed;
        }
        else
        {
            return true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>doResend</Name>
				<Source><![CDATA[
    internal static boolean doResend(RefTableId _refTableId, RefRecId _refRecId)
    {
        Common sourceData;

        switch (_refTableId)
        {
            case tableNum(SalesTable):
                sourceData = SalesTable::findRecId(_refRecId);
                break;
            case tableNum(MCRCustPaymTable):
                sourceData = MCRCustPaymTable::findByRecID(_refRecId);
                break;
            default:
                throw error(error::wrongUseOfFunction(funcName()));
        }

        if (sourceData == null)
        {
            throw error(Error::missingRecord(funcName()));
        }

        CreditCardProcess processor = CreditCardProcess::construct(CreditCardOperation::Resend, sourceData);

        return processor.resendLastRequest();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>