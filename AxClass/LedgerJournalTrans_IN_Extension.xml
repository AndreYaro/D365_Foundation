<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerJournalTrans_IN_Extension</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Extension methods for the <c>LedgerJournalTrans</c> class.
/// </summary>
public static class LedgerJournalTrans_IN_Extension
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>canServiceTaxCalculate_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the service tax can be calculated.
    /// </summary>
    /// <param name="_voucher">
    /// The voucher information.
    /// </param>
    /// <param name="_journalNum">
    /// The ledger journal id.
    /// </param>
    /// <param name="_unsavedLedgerJournalTrans">
    /// The unsaved ledger journal transaction.
    /// </param>
    /// <returns>
    /// Returns true if the service tax can be calculated.
    /// </returns>
    public static boolean canServiceTaxCalculate_IN(
        Voucher            _voucher,
        LedgerJournalId    _journalNum,
        LedgerJournalTrans _unsavedLedgerJournalTrans = null)
    {
        boolean            ret;
        LedgerJournalTrans ledgerJournalTransCopy;

        if (_unsavedLedgerJournalTrans.RecId != 0)
        {
            ret = _unsavedLedgerJournalTrans.isTaxable();
        }
        else
        {
            while select * from ledgerJournalTransCopy
                where ledgerJournalTransCopy.JournalNum == _journalNum
                   && ledgerJournalTransCopy.Voucher    == _voucher
            {
                ret = ledgerJournalTransCopy.isTaxable();
                if (ret == true)
                {
                    break;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existLedgerJournalTrans_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the record exists in the table with specified value model.
    /// </summary>
    /// <param name="_assetBookIdPurchSalesInvent">
    /// The value model of the <c>LedgerJournalTrans</c> table record.
    /// </param>
    /// <param name="_accountNum">
    /// A enumration that indicates transaction whether have ledger dimension.
    /// </param>
    /// <returns>
    /// true if the record exits; otherwise, false.
    /// </returns>
    public static boolean existLedgerJournalTrans_IN(AssetBookIdPurchSalesInvent _assetBookIdPurchSalesInvent,
                                                     NoYesId                     _accountNum)
    {
        LedgerJournalTrans          ledgerJournalTransLoc;
        LedgerJournalTrans_Asset    ledgerJournalTransAssetLoc;

        if (_assetBookIdPurchSalesInvent)
        {
            if (_accountNum)
            {
                select firstonly RecId, LedgerDimension from ledgerJournalTransLoc
                    join BookId, TransType, RefRecId from ledgerJournalTransAssetLoc
                    where ledgerJournalTransLoc.LedgerDimension
                        && ledgerJournalTransAssetLoc.BookId     == _assetBookIdPurchSalesInvent
                        && ledgerJournalTransAssetLoc.TransType  == AssetTransTypeJournal::Depreciation
                        && ledgerJournalTransLoc.RecId           == ledgerJournalTransAssetLoc.RefRecId;
            }
            else
            {
                select firstonly RecId, LedgerDimension from ledgerJournalTransLoc
                    join BookId, TransType, RefRecId from ledgerJournalTransAssetLoc
                    where !ledgerJournalTransLoc.LedgerDimension
                        && ledgerJournalTransAssetLoc.BookId     == _assetBookIdPurchSalesInvent
                        && ledgerJournalTransAssetLoc.TransType  == AssetTransTypeJournal::Depreciation
                        && ledgerJournalTransLoc.RecId           == ledgerJournalTransAssetLoc.RefRecId;
            }
        }

        return ledgerJournalTransLoc.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsAdvancePaymentForServiceTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the advance payment for service tax exists.
    /// </summary>
    /// <param name="_ledgerJournalTrans">The journal line record.</param>
    /// <returns>
    /// Returns true if the advance payment for service tax exists.
    /// </returns>
    public static boolean existsAdvancePaymentForServiceTax_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean    ret;
        AmountCur  paymentAmount;
        AmountCur  invoiceAmount;

        if (_ledgerJournalTrans.TransactionType != LedgerTransType::Fee
            && _ledgerJournalTrans.isServiceTax_IN())
        {
            ret = true;
            paymentAmount   = abs(_ledgerJournalTrans.amount());
            invoiceAmount   = abs(SpecTransManager::getTotalSettleAmountForSpecReference(_ledgerJournalTrans.company(),
                                                                                            _ledgerJournalTrans.TableId,
                                                                                            _ledgerJournalTrans.RecId,
                                                                                            _ledgerJournalTrans.CurrencyCode,
                                                                                            _ledgerJournalTrans.Company,
                                                                                            _ledgerJournalTrans.TransDate,
                                                                                            _ledgerJournalTrans.crossrate()));
            // Case 1: Calculate service tax if payment is more than the Invoice amount to settle with.
            // Case 2: Do not calculate Tax if:
            //          a) Payment = Invoice amount  OR
            //          b) Payment < Invoice amount
            if (invoiceAmount != 0 && paymentAmount != 0)
            {
                if (paymentAmount > invoiceAmount)
                {
                    ret = true;
                }
                else if (paymentAmount == invoiceAmount)
                {
                    ret = false;
                }
                else
                {
                    ret = false;
                }
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsLedgerAccount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the ledger account exists.
    /// </summary>
    /// <param name="_accountType">
    /// The account type.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The ledger dimension.
    /// </param>
    /// <param name="_taxType">
    /// The tax type.
    /// </param>
    /// <returns>
    /// Returns true if the ledger account exist.
    /// </returns>
    public static boolean existsLedgerAccount_IN(LedgerJournalACType       _accountType,
                                          LedgerDimensionAccount    _ledgerDimension,
                                          TaxType_IN                _taxType)
    {
        if (_accountType != LedgerJournalACType::Ledger ||
            (_accountType == LedgerJournalACType::Ledger &&
            MainAccount_IN::existLedgerPostingType_IN(_ledgerDimension, _taxType)))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInterCompanyForCentralizedPay_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets te company id or the offset company id for a centralized payment line.
    /// </summary>
    /// <param name="_ledgerJournalTrans">The journal line record.</param>
    /// <param name="_company">
    /// The company id.
    /// </param>
    /// <returns>
    /// The company id information.
    /// </returns>
    public static CompanyId getInterCompanyForCentralizedPay_IN(
        LedgerJournalTrans _ledgerJournalTrans,
        CompanyId          _company)
    {
        CompanyId companyId =curext();

        if (LedgerJournalTrans_IN_Extension::isCentralizedAdvancePayment_IN(_ledgerJournalTrans) == true)
        {
            if (_ledgerJournalTrans.Company != ''
                && _ledgerJournalTrans.OffsetCompany != '')
            {
                if (_ledgerJournalTrans.Company == _company)
                {
                    companyId = _ledgerJournalTrans.OffsetCompany;
                }
                else if (_ledgerJournalTrans.OffsetCompany == _company)
                {
                    companyId = _ledgerJournalTrans.Company;
                }
            }
        }

        return companyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxWithholdInstance_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an instance of <c>TaxWithholdCalculation_IN</c> with the withhold tax lines loaded into <c>TmpTaxWithholdWorkTrans_IN</c>.
    /// </summary>
    /// <param name="_journalNum">
    /// The journal number of the journal.
    /// </param>
    /// <param name="_voucher">
    /// The voucher of the journal.
    /// </param>
    /// <param name="_invoiceId">
    /// The invoice ID of the journal.
    /// </param>
    /// <param name="_persistToTaxWithholdUncommitted">
    /// true if calculated withhold taxes should be persisted to the <c>TaxWithholdUncommitted_IN</c> table; otherwise, false.
    /// </param>
    /// <param name="_unsavedLedgerJournalTrans">
    ///    If a <c>LedgerJournalTrans</c> record is unsaved then it needs to be passed
    ///    into so that the new values may be considered for withhold tax calculations.
    /// </param>
    /// <returns>
    /// An instance of the <c>TaxWithholdCalculation_IN</c> class.
    /// </returns>
    public static TaxWithholdCalculation_IN getTaxWithholdInstance_IN(
        LedgerJournalId     _journalNum,
        Voucher             _voucher,
        InvoiceId           _invoiceId,
        boolean             _persistToTaxWithholdUncommitted,
        LedgerJournalTrans  _unsavedLedgerJournalTrans = null)

    {
        LedgerJournalTaxDocument    ledgerJournalTaxWithholdDocument;
        TaxWithholdCalculation_IN   taxWithholdJournal;
        TmpTaxWithholdWorkTrans_IN  tmpTaxWithholdWorkTransLoc;
        TaxWithhold_IN              taxwithhold;
        TaxWithholdGroup            taxWithholdGroup;
        DataAreaId                  dataAreaId;
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = _unsavedLedgerJournalTrans.ledgerJournalTransTaxExtensionIN();

        taxwithhold = new TaxWithhold_IN();
        taxWithholdGroup = ledgerJournalTransTaxExt.tdsGroup ?  ledgerJournalTransTaxExt.tdsGroup : ledgerJournalTransTaxExt.tcsGroup;

        ledgerJournalTaxWithholdDocument = LedgerJournalTaxWithholdDocument_IN::construct(_journalNum, _voucher, _invoiceId, _unsavedLedgerJournalTrans);

        dataAreaId = _unsavedLedgerJournalTrans.Company ? _unsavedLedgerJournalTrans.Company : _unsavedLedgerJournalTrans.company() ? _unsavedLedgerJournalTrans.company() : curext();
        changecompany(dataAreaId)
        {
            if (_persistToTaxWithholdUncommitted)
            {
                boolean loadTaxWithholdUncommitted = true;
                if (!TaxWithholdParameters_IN::find().DisableThresholdCumulativeTracking)
                {
                    loadTaxWithholdUncommitted = !TaxWHTThresholdCumulativeChangeTracking_IN::determineCumulativeChanged(
                        ledgerJournalTaxWithholdDocument.getSourceHeader().TableId,
                        ledgerJournalTaxWithholdDocument.getSourceHeader().RecId,
                        ledgerJournalTaxWithholdDocument.getReferenceNumber());
                }

                taxWithholdJournal = TaxWithholdCalculation_IN::newForSourceTypeWithTaxUncommitted(
                    TaxSourceType::Journals,
                    ledgerJournalTaxWithholdDocument,
                    loadTaxWithholdUncommitted,
                    false);

                if (!taxWithholdJournal.taxExists())
                {
                    taxWithholdJournal.calculateTax();
                }
            }
            else
            {
                taxWithholdJournal = TaxWithholdCalculation_IN::newForSourceType(TaxSourceType::Journals, ledgerJournalTaxWithholdDocument);
                taxWithholdJournal.calculateTax();
            }
            tmpTaxWithholdWorkTransLoc = taxWithholdJournal.tmpTaxWithholdWorkTrans();
            taxwithhold.tmpTaxWithholdWorkTrans(tmpTaxWithholdWorkTransLoc);
            taxwithhold.loadTaxWithholdRegulation(tmpTaxWithholdWorkTransLoc);
            taxwithhold.rateOfDeduction(taxWithholdJournal.parmRateOfDeduction());
            taxWithholdJournal.taxWithhold(taxwithhold);
        }

        return taxWithholdJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCentralizedAdvancePayment_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the journal line is linked to Servicetax centralized payment.
    /// </summary>
    /// <param name="_ledgerJournalTrans">The journal line record.</param>
    /// <returns>
    /// True if the journal line is linked to Centralized payment.
    /// </returns>
    public static boolean isCentralizedAdvancePayment_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean ret;
        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])
            && _ledgerJournalTrans.TaxItemGroup != ''
            && conLen(CustVendOpenTransManager::findSharedServiceCompanies(_ledgerJournalTrans.DataAreaId)) > 1
            && _ledgerJournalTrans.isPaymentJournal_IN()
            && _ledgerJournalTrans.Company != ''
            && _ledgerJournalTrans.OffsetCompany != ''
            && (_ledgerJournalTrans.Company != _ledgerJournalTrans.OffsetCompany)
           )
        {
            changecompany(_ledgerJournalTrans.Company)
            {
                if (
                    TaxParameters::isServiceTaxEnable_IN() // Centralized payment is only for cash basis.
                    && TaxItemGroupHeading::find(_ledgerJournalTrans.TaxItemGroup).ServiceTaxBasis_IN == ServiceTaxBasis_IN::CashBasis
                   )
                {
                    ret = true;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxWithholdGroupOnLJT_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified record have tax withhold group.
    /// </summary>
    /// <param name="_ledgerJournalId">
    /// The ledger journal number of the <c>LedgerJournalTrans</c> table record.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date of the <c>LedgerJournalTrans</c> table record.
    /// </param>
    /// <param name="_voucher">
    /// The voucher number of the <c>LedgerJournalTrans</c> table record.
    /// </param>
    /// <returns>
    /// true if the tax without group of transaction not exits; otherwise, false.
    /// </returns>
    public static boolean isTaxWithholdGroupOnLJT_IN(LedgerJournalId    _ledgerJournalId,
                                                     TransDate          _transDate,
                                                     Voucher            _voucher)
    {
        boolean ret ;
        LedgerJournalTrans ledgerJournalTrans;

        select firstonly ledgerJournalTrans
                where ledgerJournalTrans.JournalNum == _ledgerJournalId
                   && ledgerJournalTrans.TransDate == _transDate
                   && ledgerJournalTrans.Voucher == _voucher
                   && ledgerJournalTrans.TaxWithholdGroup;

        ret = ledgerJournalTrans ? false: true;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTaxWitholdUncommitted_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the <c>TaxWithholdUncommitted_IN</c> records if a field that affects tax has changed.
    /// </summary>
    /// <param name="_ledgerJournalTrans">The journal line record.</param>
    /// <param name="_ledgerJournalTable">
    /// The <c>LedgerJournalTable</c> record for the <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_recalculateTax">
    /// boolean value if withhold taxes needs to be recalculated.
    /// </param>
    /// <returns>
    /// true if the <c>TaxWithholdUncommitted_IN</c> records were deleted; otherwise, false.
    /// </returns>
    public static boolean deleteTaxWitholdUncommitted_IN(LedgerJournalTrans _ledgerJournalTrans, LedgerJournalTable _ledgerJournalTable, boolean _recalculateTax)
    {
        LedgerJournalTrans originalLedgerJournalTrans;
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt;
        LedgerJournalTransTaxExtensionIN originalLedgerJournalTransTaxExt;

        originalLedgerJournalTrans = _ledgerJournalTrans.orig();
        ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
        originalLedgerJournalTransTaxExt = originalLedgerJournalTrans.ledgerJournalTransTaxExtensionIN();

        if (_recalculateTax
            || ledgerJournalTransTaxExt.tdsGroup != originalLedgerJournalTransTaxExt.tdsGroup
            || ledgerJournalTransTaxExt.tcsGroup != originalLedgerJournalTransTaxExt.tcsGroup)

        {
            if (TaxWithholdUncommitted_IN::existByDocumentAndInvoice(_ledgerJournalTable.TableId, _ledgerJournalTable.RecId, originalLedgerJournalTrans.Voucher, originalLedgerJournalTrans.Invoice))
            {
                TaxWithholdUncommitted_IN::deleteForInvoice(_ledgerJournalTable.TableId, _ledgerJournalTable.RecId, originalLedgerJournalTrans.Voucher, originalLedgerJournalTrans.Invoice);
            }

            // if the invoice # changed then since taxes are calculated per voucher per invoice we need to also remove the
            // TaxUncommitted records from the new invoice so that taxes get recalculated on the new invoice.
            if (_ledgerJournalTrans.Invoice != originalLedgerJournalTrans.Invoice)
            {
                TaxWithholdUncommitted_IN::deleteForInvoice(_ledgerJournalTable.TableId, _ledgerJournalTable.RecId, originalLedgerJournalTrans.Voucher, _ledgerJournalTrans.Invoice);
            }

            // if the voucher changed then since taxes are calculated per voucher per invoice we need to also remove the
            // TaxUncommitted records from the new voucher so that taxes get recalculated on the new voucher.
            if (_ledgerJournalTrans.Voucher != originalLedgerJournalTrans.Voucher)
            {
                TaxWithholdUncommitted_IN::deleteForInvoice(_ledgerJournalTable.TableId, _ledgerJournalTable.RecId, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.Invoice);
            }

            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineVendBankDirection_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines vend bank direction.
    /// </summary>
    /// <param name="_ledgerJournalTrans">The journal line record.</param>
    /// <param name="_taxDirection">
    /// The tax direction.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxDirection</c> class.
    /// </returns>
    public static TaxDirection determineVendBankDirection_IN(LedgerJournalTrans _ledgerJournalTrans, TaxDirection _taxDirection)
    {
        TaxDirection taxDirection;
        TaxItemGroupHeading taxItemGroupHeadingRev = TaxItemGroupHeading::find(_ledgerJournalTrans.TaxItemGroup);

        taxDirection = _taxDirection;

        if ((_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank ||
            _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank) &&
            (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend ||
            _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend))
        {
            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
            {
                if (VendTable::find(_ledgerJournalTrans.parmAccount()).isGTA()
                    || taxItemGroupHeadingRev.ReverseChargePercentage_IN != 0)
                {
                    taxDirection = TaxDirection::OutgoingTax;
                }
            }
            else if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
            {
                if (VendTable::find(_ledgerJournalTrans.parmOffsetAccount()).isGTA()
                    || taxItemGroupHeadingRev.ReverseChargePercentage_IN != 0)
                {
                    taxDirection = TaxDirection::OutgoingTax;
                }
            }
        }

        return taxDirection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWithholdTaxTypeForJournalLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets India withholding tax type for current journal line.
    /// </summary>
    /// <param name="_ledgerJournalTrans">The journal line record.</param>
    /// <returns>
    /// returns India withholding tax type.
    /// </returns>
    public static TaxWithholdCodeType_IN getWithholdTaxTypeForJournalLine(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();

        if (ledgerJournalTransTaxExt.tdsGroup)
        {
            return TaxWithholdCodeType_IN::TDS;
        }
        else if (ledgerJournalTransTaxExt.tcsGroup)
        {
            return TaxWithholdCodeType_IN::TCS;
        }
        else
        {
            return TaxWithholdCodeType_IN::None;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateGTA_ForeignVendor_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates GTA and foreign vendors for reverse cahrge mechanism.
    /// </summary>
    /// <param name="_ledgerJournalTrans">The journal line record.</param>
    /// <returns>
    /// True if validation passes.
    /// </returns>
    public static boolean validateGTA_ForeignVendor_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean             ret;
        TaxItemGroupHeading taxItemGroupHeading;

        if (_ledgerJournalTrans.isGTAVendorAccount_IN() || _ledgerJournalTrans.isForeignVendorAccount_IN())
        {
            taxItemGroupHeading = TaxItemGroupHeading::find(_ledgerJournalTrans.orig().TaxItemGroup);
            if (taxItemGroupHeading)
            {
                ret = taxItemGroupHeading.isGTAVendorTaxItemGroup_IN();
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxSetOffVoucher_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the specified TaxSetoffVoucher record in the <c>LedgerJournalTrans</c> table.
    /// </summary>
    /// <param name="_ledgerJournalTrans">The journal line record.</param>
    /// <returns>
    /// Returns the specified TaxSetoffVoucher record.
    /// </returns>
    public static Voucher getTaxSetOffVoucher_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTrans  ledgerJournalTransloc;
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt;

        select firstonly ledgerJournalTransloc
                where ledgerJournalTransloc.Voucher   == _ledgerJournalTrans.Voucher
                   && ledgerJournalTransloc.TransDate == _ledgerJournalTrans.TransDate
                join TaxSetoffVoucher from ledgerJournalTransTaxExt
                    where ledgerJournalTransTaxExt.LedgerJournalTrans == ledgerJournalTransloc.RecId
                        && ledgerJournalTransTaxExt.TaxSetoffVoucher;

        return ledgerJournalTransTaxExt.TaxSetoffVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasIndirectTaxFieldChanged_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if India fields change affects tax changed.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <param name = "_originalLedgerJournalTrans">The original <c>LedgerJournalTrans</c> table record.</param>
    /// <returns>
    /// true if the <c>TaxUncommitted</c> records were deleted; otherwise, false.
    /// </returns>
    public static boolean hasIndirectTaxFieldChanged_IN(LedgerJournalTrans _ledgerJournalTrans, LedgerJournalTrans _originalLedgerJournalTrans = _ledgerJournalTrans.orig())
    {
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt;
        LedgerJournalTransTaxExtensionIN originalLedgerJournalTransTaxExt;
        boolean deleteTaxUncommitted = false;
        #ISOCountryRegionCodes

        ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
        originalLedgerJournalTransTaxExt = _originalLedgerJournalTrans.ledgerJournalTransTaxExtensionIN();

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            deleteTaxUncommitted =     ledgerJournalTransTaxExt.AssessableValueTransactionCurrency != originalLedgerJournalTransTaxExt.AssessableValueTransactionCurrency
                                    || ledgerJournalTransTaxExt.MaximumRetailPrice != originalLedgerJournalTransTaxExt.MaximumRetailPrice
                                    || _ledgerJournalTrans.SettleVoucher               != _originalLedgerJournalTrans.SettleVoucher;
        }
        return deleteTaxUncommitted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDirectSettleForCP_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether this <c>LedgerJournalTrans</c> is for centralized payment.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <returns>
    /// Returns true if this <c>LedgerJournalTrans</c> is for centralized payment; Otherwise, returns false.
    /// </returns>
    public static boolean isDirectSettleForCP_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
        SpecTrans specTrans;

        select firstonly RecId from specTrans
                where specTrans.SpecRecId    == _ledgerJournalTrans.RecId
                    && specTrans.SpecTableId == _ledgerJournalTrans.TableId
                    && specTrans.RefCompany  != _ledgerJournalTrans.Company;
        return specTrans.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isForeignVendorAccount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the transaction is foreign vendor account.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <returns>
    /// Returns true if the transaction is foreign vendor account.
    /// </returns>
    public static boolean isForeignVendorAccount_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
        VendTable  vendTable;
        boolean    ret;

        if (_ledgerJournalTrans.orig().AccountType == LedgerJournalACType::Vend)
        {
            vendTable = VendTable::find(_ledgerJournalTrans.orig().parmAccount());
        }
        else if (_ledgerJournalTrans.orig().OffsetAccountType == LedgerJournalACType::Vend)
        {
            vendTable = VendTable::find(_ledgerJournalTrans.orig().parmOffsetAccount());
        }

        if (vendTable && vendTable.isForeign())
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isGTAVendorAccount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the transaction is GTA vendor account.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <returns>
    /// Returns true if the transaction is GTA vendor account.
    /// </returns>
    public static boolean isGTAVendorAccount_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
        VendTable vendTable;

        if (_ledgerJournalTrans.orig().AccountType == LedgerJournalACType::Vend)
        {
            vendTable = VendTable::find(_ledgerJournalTrans.orig().parmAccount());
        }
        else if (_ledgerJournalTrans.orig().OffsetAccountType == LedgerJournalACType::Vend)
        {
            vendTable = VendTable::find(_ledgerJournalTrans.orig().parmOffsetAccount());
        }

        if (vendTable && vendTable.isGTA())
        {
            return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLedgerBankJournal_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// True if its a Ledger-Bank scenario.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <returns>
    /// True if its a Ledger-Bank scenario.
    /// </returns>
    public static boolean isLedgerBankJournal_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
        return ((_ledgerJournalTrans.AccountType ==  LedgerJournalACType::Bank
                    && (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger))
                ||
               (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank
                    && (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger)
               )
           );
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPaymentJournal_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// True if payment journal.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <returns>
    /// True if payment journal.
    /// </returns>
    public static boolean isPaymentJournal_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
        return (
                (_ledgerJournalTrans.AccountType ==  LedgerJournalACType::Bank
                    &&
                    (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
                )
                    ||
                (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank
                    &&
                    (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust || _ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
                )
                    ||
                // Vendor/Customer & Ledger A/C of marked PostingType = PurchaseCash, will also be considered as a Payment.
                _ledgerJournalTrans.isPurchaseCashAccount_IN()
            );
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPurchaseCashAccount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// True if the main AC or offset AC is a purchase cash one.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <returns>
    /// True if the main AC or offset AC is a purchase cash one.
    /// </returns>
    public static boolean isPurchaseCashAccount_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerDimensionAccount              ledgerDimensionAccount;
        DimensionAttributeValueCombination  dimensionAttributeValueCombination;
        boolean                             isPurchaseCash;

        if (
            _ledgerJournalTrans.AccountType ==  LedgerJournalACType::Ledger
                &&
                (_ledgerJournalTrans.OffsetAccountType ==  LedgerJournalACType::Vend
                 ||
                 _ledgerJournalTrans.OffsetAccountType ==  LedgerJournalACType::Cust)
           )
        {
            ledgerDimensionAccount = _ledgerJournalTrans.LedgerDimension;
        }
        else if (
                 _ledgerJournalTrans.OffsetAccountType ==  LedgerJournalACType::Ledger
                     &&
                     (_ledgerJournalTrans.AccountType ==  LedgerJournalACType::Vend
                      ||
                      _ledgerJournalTrans.AccountType ==  LedgerJournalACType::Cust)
                )
        {
            ledgerDimensionAccount = _ledgerJournalTrans.OffsetLedgerDimension;
        }

        MainAccount mainAccount;

        select firstonly PostingType from mainAccount
            join RecId from dimensionAttributeValueCombination
                where dimensionAttributeValueCombination.MainAccount == mainAccount.RecId
                    && dimensionAttributeValueCombination.RecId == ledgerDimensionAccount;

        if (mainAccount.PostingType == LedgerPostingType::PurchCash)
        {
            isPurchaseCash = true;
        }

        return isPurchaseCash;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isServiceApplicable_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the service is applicable.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <returns>
    /// Returns true if the service is applicable.
    /// </returns>
    public static boolean isServiceApplicable_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
        TaxGroupData    taxGroupData;
        TaxOnItem       taxOnItem;
        TaxTable        taxTable;

        changecompany(_ledgerJournalTrans.Company ? _ledgerJournalTrans.Company : curext())
        {
            select firstonly TaxCode from taxGroupData
                    where taxGroupData.TaxGroup == _ledgerJournalTrans.TaxGroup
                        join TaxCode from taxTable
                            where taxTable.TaxCode == taxGroupData.TaxCode
                                && taxTable.TaxType_IN == TaxType_IN::ServiceTax
                                    join RecId, TaxItemGroup, TaxCode from taxOnItem
                                        where taxOnItem.TaxItemGroup == _ledgerJournalTrans.TaxItemGroup
                                            && taxOnItem.TaxCode == taxTable.TaxCode;
        }

        return taxTable.TaxCode != '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>isServiceTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the service tax is available.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <returns>
    /// Returns true if the service tax is available.
    /// </returns>
    public static boolean isServiceTax_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean ret = false;

        boolean accountCombinationIsTaxable_IN()
        {
            return ((_ledgerJournalTrans.AccountType       ==  LedgerJournalACType::Bank       &&
                    (_ledgerJournalTrans.OffsetAccountType ==  LedgerJournalACType::Cust       ||
                     _ledgerJournalTrans.OffsetAccountType ==  LedgerJournalACType::Vend))     ||
                    (_ledgerJournalTrans.OffsetAccountType ==  LedgerJournalACType::Bank       &&
                    (_ledgerJournalTrans.AccountType       ==  LedgerJournalACType::Cust       ||
                     _ledgerJournalTrans.AccountType       ==  LedgerJournalACType::Vend)));
        }

        if (TaxParameters::isServiceTaxEnable_IN()
                && accountCombinationIsTaxable_IN()
                && _ledgerJournalTrans.isServiceApplicable_IN())
        {
            ret = true;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxTypeApplicable_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the tax type is applicable.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <returns>
    /// Returns true if the tax type is applicable.
    /// </returns>
    public static boolean isTaxTypeApplicable_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
        TaxGroupData    taxGroupData;
        TaxOnItem       taxOnItem;
        TaxTable        taxTable;

        if (TaxParameters::checkTaxParameters_IN())
        {
            select firstonly RecId, TaxGroup, TaxCode from taxGroupData
                where taxGroupData.TaxGroup == _ledgerJournalTrans.TaxGroup
                    join TaxItemGroup, TaxCode from taxOnItem
                        where taxOnItem.TaxItemGroup == _ledgerJournalTrans.TaxItemGroup &&
                            taxOnItem.TaxCode == taxGroupData.TaxCode
                                join TaxCode, TaxType_IN from taxTable
                                    where taxTable.TaxCode == taxOnItem.TaxCode
                                        && taxTable.TaxType_IN != TaxType_IN::None;
        }
        return taxGroupData.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransForGTAVendor_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether transaction is for GTA vendor.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <returns>
    /// Returns true if transaction is related with GTA vendor; Otherwise, returns false.
    /// </returns>
    public static boolean isTransForGTAVendor_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean ret;

        if ((_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend           ||
            _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
            && VendTable::find(_ledgerJournalTrans.parmAccount()).isGTA())
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerJournalTransTaxExtensionIN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the <c>LedgerJournalTransTaxExtensionIN</c> table.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <returns>
    /// The table <c>LedgerJournalTransTaxExtensionIN</c> associated with the current record.
    /// </returns>
    public static LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExtensionIN(LedgerJournalTrans _ledgerJournalTrans)
    {
        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            return _ledgerJournalTrans.SysExtensionSerializerMap::getExtensionTable(tableNum(LedgerJournalTransTaxExtensionIN));
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>notExistsPostedWHTForCP_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether current <c>LedgerJournalTrans</c> settles an invoice which has posted withholding tax.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <returns>
    /// Returns true if current <c>LedgerJournalTrans</c> does not settle an invoice which has posted withholding tax;
    /// Otherwise, returns false.
    /// </returns>
    public static boolean notExistsPostedWHTForCP_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
        SpecTrans           specTrans;
        TaxWithholdTrans_IN taxWithholdTrans;
        CustTrans           custTrans;
        VendTrans           vendTrans;
        CustVendTrans       custVendTrans;
        CustTransOpen       custTransOpen;
        VendTransOpen       vendTransOpen;
        CustVendTransOpen   custVendTransOpen;

        boolean             ret = true;

        while select RefCompany, RefTableId, RefRecId from specTrans
            where specTrans.SpecTableId == _ledgerJournalTrans.TableId
                && specTrans.SpecRecId  == _ledgerJournalTrans.RecId
        {
            changecompany(specTrans.RefCompany)
            {
                if (specTrans.RefTableId == tableNum(CustTransOpen))
                {
                    custVendTrans = custTrans;
                    custVendTransOpen = custTransOpen;
                }
                else
                {
                    custVendTrans = vendTrans;
                    custVendTransOpen = vendTransOpen;
                }

                taxWithholdTrans.clear();
                custVendTrans.clear();
                custVendTransOpen.clear();

                select firstonly RecId from taxWithholdTrans
                    exists join custVendTrans
                        where taxWithholdTrans.Voucher     == custVendTrans.Voucher
                            && taxWithholdTrans.TransDate  == custVendTrans.TransDate
                    exists join custVendTransOpen
                        where custVendTransOpen.AccountNum == custVendTrans.AccountNum
                            && custVendTransOpen.RefRecId  == custVendTrans.RecId
                            && custVendTransOpen.TableId   == specTrans.RefTableId
                            && custVendTransOpen.RecId     == specTrans.RefRecId;
                if (taxWithholdTrans.RecId)
                {
                    ret = false;
                    break;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>packledgerJournalTransTaxExtensionIN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Packs the <c>LedgerJournalTransTaxExtensionIN</c> table
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <param name="_ledgerJournalTransTaxExtensionIN">
    /// LedgerJournalTransTaxExtensionIN is packed.
    /// </param>
    public static void packledgerJournalTransTaxExtensionIN(LedgerJournalTrans _ledgerJournalTrans, LedgerJournalTransTaxExtensionIN _ledgerJournalTransTaxExtensionIN)
    {
        _ledgerJournalTransTaxExtensionIN.LedgerJournalTrans = _ledgerJournalTrans.RecId;

        _ledgerJournalTrans.SysExtensionSerializerMap::packExtensionTable(_ledgerJournalTransTaxExtensionIN);
    }

]]></Source>
			</Method>
			<Method>
				<Name>serviceTaxAmountForReverseCharge_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the service tax amount for reverse charge.
    /// </summary>
    /// <returns>
    /// Returns service tax amount for reverse charge, a instance of the <c>TaxAmountCur</c> class.
    /// </returns>
    public static TaxAmountCur serviceTaxAmountForReverseCharge_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
        TaxTrans        taxTrans;
        TaxAmountCur    totalReverseChargeTaxAmountCur;
        TaxTable        taxTableRev;

        // Get the service tax to be posted if reverse charge exist.
        // for reverse charge, 3 taxtrans would be postd:
        // Recoverable: Dr (serviceTaxAmount * (100 - reversePercentage)%)
        // Interim Recoverable: Dr (serviceTaxAmount - serviceTaxAmount * (100 - reversePercentage)%)
        // Interim Payable Cr: (serviceTaxAmount - serviceTaxAmount * (100 - reversePercentage)%)
        while select sum (SourceRegulateAmountCur), sum(SourceTaxAmountCur) from taxTrans
            group by taxTrans.TaxCode
            where taxTrans.Voucher      == _ledgerJournalTrans.orig().Voucher
                && taxTrans.TransDate   == _ledgerJournalTrans.orig().TransDate
                && taxTrans.TaxOrigin   == TaxOrigin::Tax
            exists join taxTableRev
                where taxTableRev.TaxCode == taxTrans.TaxCode
                    && taxTableRev.TaxType_IN == TaxType_IN::ServiceTax
        {
            totalReverseChargeTaxAmountCur += taxTrans.SourceRegulateAmountCur;
        }

        return totalReverseChargeTaxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>servicetaxBaseamountForAdvancePayment_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the service tax base amount for advance payment.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <returns>
    /// Returns service tax base amount for advance payment, a instance of the <c>AmountCur</c> class.
    /// </returns>
    public static AmountCur servicetaxBaseamountForAdvancePayment_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
        AmountCur baseAmountCur,specAmount;

        specAmount = SpecTransManager::getTotalSettleAmountForSpecReference(_ledgerJournalTrans.company(),
                                                                            _ledgerJournalTrans.TableId,
                                                                            _ledgerJournalTrans.RecId,
                                                                            _ledgerJournalTrans.CurrencyCode,
                                                                            _ledgerJournalTrans.Company,
                                                                            _ledgerJournalTrans.TransDate,
                                                                            _ledgerJournalTrans.crossrate());
        if (specAmount !=0)
        {
            if (abs(_ledgerJournalTrans.amount()) > abs(specAmount) && _ledgerJournalTrans.isServiceApplicable_IN())
            {
                baseAmountCur = abs(_ledgerJournalTrans.amount()) - abs(specAmount);

                if (_ledgerJournalTrans.amount() < 0)
                {
                    baseAmountCur = -baseAmountCur;
                }
            }
            else
            {
                baseAmountCur = _ledgerJournalTrans.amount();
            }
        }
        else
        {
            baseAmountCur = _ledgerJournalTrans.amount();
        }
        return baseAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAssessableValue_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets Assessable value of the table <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    public static void setAssessableValue_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExtensionIN = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
        ledgerJournalTransTaxExtensionIN.AssessableValueTransactionCurrency = _ledgerJournalTrans.AmountCurDebit ? _ledgerJournalTrans.AmountCurDebit : _ledgerJournalTrans.AmountCurCredit;
        LedgerJournalTrans_IN_Extension::packledgerJournalTransTaxExtensionIN(_ledgerJournalTrans, ledgerJournalTransTaxExtensionIN);
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitPaymentTAN_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Splits payment.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <param name = "_transDate">
    /// The transaction date.
    /// </param>
    public static void splitPaymentTAN_IN(LedgerJournalTrans _ledgerJournalTrans, TransDate _transDate = dateNull())
    {
        SpecTrans                       specTrans;
        VendTrans                       vendTrans;
        VendInvoiceJour                 vendInvoiceJour;
        VendInvoiceTrans                vendInvoiceTrans;
        VendInvoiceTransTaxExtensionIN  vendInvoiceTransTaxExtension;
        VendTransOpen                   vendTransOpen;
        LedgerJournalTrans              localLedgerJournalTrans = _ledgerJournalTrans;
        boolean                         first                   = true;
        AmountCur                       amountSum               = 0;
        TaxWithholdTAN_IN               tanNumber;
        container                       conRecid;
        LineNum                         lastLineNum             = 0;
        TaxWithholdSettleTrans_IN       taxWithholdSettleTrans;
        TransTaxInformation             transTaxInformation;

        TransTaxInformationHelper helper = TransTaxInformationHelper::newHelper();
        transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(localLedgerJournalTrans);

        ttsbegin;
        while select forupdate specTrans
            where specTrans.SpecTableId == _ledgerJournalTrans.TableId &&
                  specTrans.SpecRecId   == _ledgerJournalTrans.RecId   &&
                  specTrans.SpecCompany == _ledgerJournalTrans.company()
        {
            select firstonly DueDate, TransDate, AccountNum, RefRecId, TaxWithholdRegNumber_IN from vendTransOpen
                where vendTransOpen.TableId     == specTrans.RefTableId
                   && vendTransOpen.RecId       == specTrans.RefRecId
                   && vendTransOpen.DataAreaId  == specTrans.RefCompany
                   && vendTransOpen.TaxWithholdRegNumber_IN;

            tanNumber = TaxWithholdRegNumbers_IN::find(vendTransOpen.TaxWithholdRegNumber_IN).RegistrationNumber ?
            TaxWithholdRegNumbers_IN::find(vendTransOpen.TaxWithholdRegNumber_IN).RegistrationNumber : '';

            select firstonly CompanyLocation_IN from vendInvoiceTrans
                join RecId from vendInvoiceJour
                    where vendInvoiceTrans.PurchID             == vendInvoiceJour.PurchId
                       && vendInvoiceTrans.InvoiceId           == vendInvoiceJour.InvoiceId
                       && vendInvoiceTrans.InvoiceDate         == vendInvoiceJour.InvoiceDate
                       && vendInvoiceTrans.NumberSequenceGroup == vendInvoiceJour.NumberSequenceGroup
                       && vendInvoiceTrans.InternalInvoiceId   == vendInvoiceJour.InternalInvoiceId
                    join RecId from vendTrans
                        where vendTrans.AccountNum           == vendTransOpen.AccountNum
                           && vendTrans.RecId                == vendTransOpen.RefRecId
                           &&  vendInvoiceJour.LedgerVoucher == vendTrans.Voucher
                           && vendInvoiceJour.InvoiceAccount == vendTrans.AccountNum
                           && vendInvoiceJour.InvoiceDate    == vendTrans.TransDate
                    join TaxInformation_IN from vendInvoiceTransTaxExtension
                        where vendInvoiceTrans.RecId == vendInvoiceTransTaxExtension.VendInvoiceTrans;

            if (!first)
            {
                if (transTaxInformation && TaxWithholdRegNumbers_IN::find(transTaxInformation.TaxWithholdTAN).RegistrationNumber != tanNumber)
                {
                    lastLineNum++;

                    if (amountSum < 0)
                    {
                        localLedgerJournalTrans.AmountCurDebit  = -CurrencyExchangeHelper::amount(amountSum, localLedgerJournalTrans.CurrencyCode);
                        localLedgerJournalTrans.AmountCurCredit = 0;
                    }
                    else
                    {
                        localLedgerJournalTrans.AmountCurCredit = CurrencyExchangeHelper::amount(amountSum, localLedgerJournalTrans.CurrencyCode);
                        localLedgerJournalTrans.AmountCurDebit  = 0;
                    }
                    localLedgerJournalTrans.write();
                    localLedgerJournalTrans.calcPaymentFee();

                    localLedgerJournalTrans.TransDate           = _transDate;
                    if (vendInvoiceTrans)
                    {
                        helper.UpdateCompanyLocationFromTransTable(localLedgerJournalTrans, LogisticsPostalAddress::findByLocation(vendInvoiceTrans.CompanyLocation_IN).RecId);
                    }
                    else
                    {
                        helper.UpdateCompanyLocationFromTransTable(localLedgerJournalTrans, LogisticsPostalAddress::findByLocation(TransTaxInformationHelper::getDefaultCompanyLocation(localLedgerJournalTrans.Company ? localLedgerJournalTrans.Company : curext())).RecId);
                    }
                    localLedgerJournalTrans.Voucher             = LedgerJournalTrans::splitCreateNewVoucher(_ledgerJournalTrans.JournalNum);
                    localLedgerJournalTrans.LineNum             = LedgerJournalTrans::lastLineNum(_ledgerJournalTrans.JournalNum) + 1;
                    localLedgerJournalTrans.SettleVoucher       = SettlementType::SelectedTransact;
                    localLedgerJournalTrans.insert();
                    conRecid += localLedgerJournalTrans.RecId;
                    amountSum = 0;

                    vendTrans = VendTrans::find(vendTransOpen.RefRecId);
                    select sum(TaxAmount) from taxWithholdSettleTrans
                        where taxWithholdSettleTrans.Voucher == vendTrans.Voucher
                            && taxWithholdSettleTrans.Mark    == NoYes::Yes
                            && taxWithholdSettleTrans.Closed  == NoYes::No;
                    if (taxWithholdSettleTrans.TaxAmount)
                    {
                        taxWithholdSettleTrans.updateLedgerVoucher(localLedgerJournalTrans.Voucher, vendTrans.Voucher);
                    }
                }
                specTrans.SpecRecId = localLedgerJournalTrans.RecId;
                specTrans.update();
            }
            else
            {
                lastLineNum = LedgerJournalTrans::lastLineNum(_ledgerJournalTrans.JournalNum);
                first       = false;
                localLedgerJournalTrans.TransDate           = _transDate;
                conRecid += localLedgerJournalTrans.RecId;
            }
            amountSum += CurrencyExchangeHelper::curAmount2CurAmount(specTrans.Balance01, specTrans.Code, localLedgerJournalTrans.CurrencyCode, localLedgerJournalTrans.TransDate, false);
        }

        if (!first)
        {
            if (amountSum < 0)
            {
                localLedgerJournalTrans.AmountCurDebit  = -CurrencyExchangeHelper::amount(amountSum, localLedgerJournalTrans.CurrencyCode);
                localLedgerJournalTrans.AmountCurCredit = 0;
            }
            else
            {
                localLedgerJournalTrans.AmountCurCredit = CurrencyExchangeHelper::amount(amountSum, localLedgerJournalTrans.CurrencyCode);
                localLedgerJournalTrans.AmountCurDebit  = 0;
            }
            localLedgerJournalTrans.write();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTCSGroup_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update TCSGroup_IN.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    [SysObsolete('This methos is deprecated', false, 15\05\2023)]
    public static void updateTCSGroup_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTDSGroup_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update TDSGroup_IN.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    [SysObsolete('This methos is deprecated', false, 15\05\2023)]
    public static void updateTDSGroup_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIndirectExclusiveTaxAmountCur_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets Indirect exclusive tax amount
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <returns>
    /// Sales tax amount
    /// </returns>
    public static TaxAmountCur getIndirectExclusiveTaxAmountCur_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
        TaxUncommitted      taxUncommitted;
        FormulaDesigner_IN  formularDesign;

        select sum(SourceRegulateAmountCur) from taxUncommitted
                where taxUncommitted.SourceTableId == _ledgerJournalTrans.TableId
                    && taxUncommitted.SourceRecId   == _ledgerJournalTrans.RecId
                exists join RecId from formularDesign
                    where formularDesign.TaxItemGroup == _ledgerJournalTrans.TaxItemGroup
                        && formularDesign.TaxCode == taxUncommitted.TaxCode
                        && formularDesign.PriceInclTax == NoYes::No;

        return taxUncommitted.SourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSettledVendorAutority_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether settled vendor authority.
    /// </summary>
    /// <param name="_ledgerJournalTrans">The journal line record.</param>
    /// <param name="_checkStatus">
    /// A boolean that indicates whether to throw error message.
    /// </param>
    /// <returns>
    /// Returns true if transaction have been settled; otherwise false.
    /// </returns>
    public static boolean checkSettledVendorAutority_IN(LedgerJournalTrans _ledgerJournalTrans, boolean _checkStatus = false)
    {
        SpecTrans        specTrans;
        VendTransOpen    vendTransOpen;
        boolean          checkStatus;

        select firstonly RefRecId from specTrans
            where specTrans.SpecTableId == _ledgerJournalTrans.TableId
               && specTrans.SpecRecId   == _ledgerJournalTrans.RecId;
        select firstonly TaxWithholdStatus_IN from vendTransOpen
            where vendTransOpen.RecId   == specTrans.RefRecId;
        if (vendTransOpen.TaxWithholdStatus_IN)
        {
            checkStatus = true;
            if (_checkStatus)
            {
                throw error("@GLS223916");
            }
        }

        return checkStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxModelDocLine_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize tax model doc line by this ledger journal transaction record for Indian.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line record.</param>
    /// <returns>The <c>TaxModelDocLineJournalImpl_IN</c> object. </returns>
    public static TaxModelDocLineJournalImpl_IN initTaxModelDocLine_IN(LedgerJournalTrans _ledgerJournalTrans)
    {
        TaxModelDocLineJournalImpl_IN taxModelDocLine;

        taxModelDocLine = TaxModelDocLineFactory::newTaxModelDocLine(_ledgerJournalTrans) as TaxModelDocLineJournalImpl_IN;

        return taxModelDocLine;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>