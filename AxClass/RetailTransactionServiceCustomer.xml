<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailTransactionServiceCustomer</Name>
	<SourceCode>
		<Declaration><![CDATA[
using System.Collections;
using Microsoft.Dynamics.Application.Instrumentation;
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;
using Microsoft.Dynamics.Commerce.Runtime.TransactionService.Serialization;
using CrtDataModel = Microsoft.Dynamics.Commerce.Runtime.DataModel;

/// <summary>
/// The <c>RetailTransactionServiceCustomer</c> implements the customer related methods of the service interface exposed by the <c>RetailTransactionService</c> class to the retail channels.
/// </summary>
public class RetailTransactionServiceCustomer
{
    public static RetailTransactionServiceCustomer_ExtendedParameters extendedParameters = RetailTransactionServiceCustomer_ExtendedParameters::construct();

    private static CommerceHQEventSource eventSource = CommerceHQEventSource::Log;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>createAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create address for customer.
    /// </summary>
    /// <param name="custAccount">
    /// Customer account
    /// </param>
    /// <param name="custName">
    /// Customer name
    /// </param>
    /// <param name="street">
    /// Street
    /// </param>
    /// <param name="city">
    /// City
    /// </param>
    /// <param name="county">
    /// County
    /// </param>
    /// <param name="state">
    /// State
    /// </param>
    /// <param name="zip">
    /// Zip
    /// </param>
    /// <param name="country">
    /// Country
    /// </param>
    /// <param name="phone">
    /// Phone
    /// </param>
    /// <param name="email">
    /// Email
    /// </param>
    /// <param name="url">
    /// URL
    /// </param>
    /// <param name="taxGroup">
    /// Tax group
    /// </param>
    /// <param name="role">
    /// Role
    /// </param>
    /// <param name="streetNumber">
    /// Street number
    /// </param>
    /// <param name="districtName">
    /// District name
    /// </param>
    /// <param name="buildingCompliment">
    /// Building compliment
    /// </param>
    /// <param name="makePostalAddressPrimary">
    /// Optional. True if this should become the new primary address
    /// </param>
    /// <returns>
    /// A container with entity keys
    /// </returns>
    /// <remarks>
    /// Original parameter list consisted of a single _paramList parameter of type container.
    /// </remarks>
    public static container createAddress(  CustAccount                 custAccount,
                                            CustName                    custName,
                                            AddressStreet               street,
                                            AddressCity                 city,
                                            AddressCountyId             county,
                                            AddressStateId              state,
                                            AddressZipCodeId            zip,
                                            AddressCountryRegionId      country,
                                            Phone                       phone,
                                            LogisticsElectronicAddressLocator  email,
                                            URL                         url,
                                            TaxGroup                    taxGroup,
                                            LogisticsLocationRoleType   role,
                                            LogisticsAddressStreetNumber        streetNumber        = '',
                                            LogisticsAddressDistrictName        districtName        = '',
                                            LogisticsAddressBuildingCompliment  buildingCompliment  = '',
                                            // preserve default previous version behaviour
                                            boolean                     makePostalAddressPrimary = false)
    {
        return RetailTransactionServiceCustomer::createAddressExt(
            custAccount,
            custName,
            street,
            city,
            county,
            state,
            zip,
            country,
            phone,
            email,
            url,
            taxGroup,
            role,
            streetNumber,
            districtName,
            buildingCompliment,
            makePostalAddressPrimary);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAddressExt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create address for customer.
    /// </summary>
    /// <param name="custAccount">
    /// Customer account
    /// </param>
    /// <param name="custName">
    /// Customer name
    /// </param>
    /// <param name="street">
    /// Street
    /// </param>
    /// <param name="city">
    /// City
    /// </param>
    /// <param name="county">
    /// County
    /// </param>
    /// <param name="state">
    /// State
    /// </param>
    /// <param name="zip">
    /// Zip
    /// </param>
    /// <param name="country">
    /// Country
    /// </param>
    /// <param name="phone">
    /// Phone
    /// </param>
    /// <param name="email">
    /// Email
    /// </param>
    /// <param name="url">
    /// URL
    /// </param>
    /// <param name="taxGroup">
    /// Tax group
    /// </param>
    /// <param name="role">
    /// Role
    /// </param>
    /// <param name="streetNumber">
    /// Street number
    /// </param>
    /// <param name="districtName">
    /// District name
    /// </param>
    /// <param name="buildingCompliment">
    /// Building compliment
    /// </param>
    /// <param name="makePostalAddressPrimary">
    /// Optional. True if this should become the new primary address
    /// </param>
    /// <param name="extensionProperties">
    /// Optional. Extension properties XML.
    /// </param>
    /// <returns>
    /// A container with entity keys
    /// </returns>
    /// <remarks>
    /// Original parameter list consisted of a single _paramList parameter of type container.
    /// </remarks>
    public static container createAddressExt(CustAccount                        custAccount,
                                             CustName                           custName,
                                             AddressStreet                      street,
                                             AddressCity                        city,
                                             AddressCountyId                    county,
                                             AddressStateId                     state,
                                             AddressZipCodeId                   zip,
                                             AddressCountryRegionId             country,
                                             Phone                              phone,
                                             LogisticsElectronicAddressLocator  email,
                                             URL                                url,
                                             TaxGroup                           taxGroup,
                                             LogisticsLocationRoleType          role,
                                             LogisticsAddressStreetNumber       streetNumber = '',
                                             LogisticsAddressDistrictName       districtName = '',
                                             LogisticsAddressBuildingCompliment buildingCompliment = '',
                                             // preserve default previous version behaviour
                                             boolean                            makePostalAddressPrimary = false,
                                             str                                extensionProperties = '')
    {
        str                         error          = "@RET2445";
        boolean                     validInsert    = false;
        LogisticsPostalAddress      postalAddress;
        CustTable                   custTable;
        Counter                     infologline    = infolog.num();

        container                   roleContainer;
        CustomerEntity              customer;
        DirPartyPostalAddressView   addressView;
        LogisticsElectronicAddress  emailElectronicAddress, phoneElectronicAddress, urlElectronicAddress;
        LogisticsLocation           location,electronicsLocation;
        DirPartyLocation            partyLocation;
        DirPartyLocationRole        partyLocationRole;
        MCRAutoTaxSearch            autoTaxSearch;
        LogisticsLocationExt        taxLocationExt;
        int64                       phoneContactId,urlContactId,emailContactId,postalAddressId,postalPartyLocationId,postalPartyLocationRoleId;
        int64                       postalLocationId,postalLocationRoleId,taxLocationExtId;
        int                         fromLine;
        str                         postalLogisticsLocationId;
        RecId                       logisticsLocationRoleRecordId;

        // If there aren't any address fields, don't try to create the address.
        if (street == '' && city == '' && zip == '' && county == '' && country == '' && email == '' && phone == '' && url == ''
            && streetNumber == '' && districtName == '' && buildingCompliment == '')
        {
            return [false];
        }

        try
        {
            fromLine = Global::infologLine();

            custTable = CustTable::find(custAccount);
            customer  = new CustomerEntity(custTable, DateTimeUtil::utcNow());
            // If role's RecId is not given, fallback to previous logic of finding by role type only
            logisticsLocationRoleRecordId = extendedParameters.createAddress_logisticsLocationRoleRecordId;
            roleContainer = logisticsLocationRoleRecordId == 0 ? [LogisticsLocationRole::findBytype(role).RecId] : [logisticsLocationRoleRecordId];

            if (custTable)
            {
                ttsbegin;

                addressView.Street = street;
                addressView.City = city;
                addressView.ZipCode = zip;
                addressView.State = state;
                addressView.County = county;
                addressView.CountryRegionId = country;
                addressView.IsPrimary = makePostalAddressPrimary;
                addressView.StreetNumber = streetNumber;
                addressView.DistrictName = districtName;
                addressView.BuildingCompliment = buildingCompliment;

                // Set the ValidFrom date time, if required.
                if (extendedParameters.createUpdateAddress_ValidFrom != DateTimeUtil::minValue())
                {
                    addressView.ValidFrom = extendedParameters.createUpdateAddress_ValidFrom;
                }

                RetailTransactionServiceCustomerExtensions::beforeAddressCreate(addressView, extensionProperties);

                addressView = customer.createOrUpdatePostalAddress(addressView, roleContainer);

                select forupdate RecId from location where location.RecId == addressView.Location;

                location.Description = custName;
                location.update();

                select partyLocationRole where partyLocationRole.PartyLocation == addressView.RecId;
                select Location, RecId from postalAddress where postalAddress.Location == location.RecId;

                postalAddressId = postalAddress.RecId;
                postalPartyLocationId = addressView.RecId;
                postalLocationId = location.RecId;
                postalPartyLocationRoleId = partyLocationRole.RecId;
                postalLocationRoleId = partyLocationRole.LocationRole;
                postalLogisticsLocationId = location.LocationId;

                select forupdate partyLocation where partyLocation.Location == addressView.RecId;

                if (email != '' || phone != '' || url != '')
                {
                    electronicsLocation.initValue();
                    electronicsLocation.ParentLocation = postalLocationId;
                    electronicsLocation.IsPostalAddress = NoYes::No;
                    electronicsLocation.insert();
                }

                if (email != '')
                {
                    emailElectronicAddress.initValue();
                    emailElectronicAddress.Type = LogisticsElectronicAddressMethodType::Email;
                    emailElectronicAddress.Location = electronicsLocation.RecId;
                    emailElectronicAddress.Locator = email;
                    emailElectronicAddress.IsPrimary = NoYes::Yes;
                    emailElectronicAddress.IsPrivate = NoYes::No;

                    emailElectronicAddress.insert();

                    emailContactId = emailElectronicAddress.RecId;

                    RetailTransactionServiceCustomer::upsertElectronicAddressRole(roleContainer, emailContactId);
                }

                if (phone != '')
                {
                    phoneElectronicAddress.initValue();
                    phoneElectronicAddress.Type = LogisticsElectronicAddressMethodType::Phone;
                    phoneElectronicAddress.Location = electronicsLocation.RecId;
                    phoneElectronicAddress.Locator = phone;
                    phoneElectronicAddress.IsPrimary = NoYes::Yes;
                    phoneElectronicAddress.IsPrivate = NoYes::No;

                    phoneElectronicAddress.insert();

                    phoneContactId = phoneElectronicAddress.RecId;

                    RetailTransactionServiceCustomer::upsertElectronicAddressRole(roleContainer, phoneContactId);
                }

                if (url != '')
                {
                    urlElectronicAddress.initValue();
                    urlElectronicAddress.Type = LogisticsElectronicAddressMethodType::URL;
                    urlElectronicAddress.Location = electronicsLocation.RecId;
                    urlElectronicAddress.Locator = url;
                    urlElectronicAddress.IsPrimary = NoYes::Yes;
                    urlElectronicAddress.IsPrivate = NoYes::No;

                    urlElectronicAddress.insert();

                    urlContactId = urlElectronicAddress.RecId;

                    RetailTransactionServiceCustomer::upsertElectronicAddressRole(roleContainer, urlContactId);
                }

                if (!taxGroup)
                {
                    autoTaxSearch = new MCRAutoTaxSearch();
                    if (autoTaxSearch.autoSearchActive())
                    {
                        taxGroup = autoTaxSearch.setSalesTaxGroup(city,
                                                                  state,
                                                                  county,
                                                                  zip,
                                                                  country);
                    }

                    if (!taxGroup && AllowCustSalesTaxGroupPopulationInShippingAddressCreationFlight::instance().isEnabled())
                    {
                        taxGroup = custTable.TaxGroup;
                    }
                }

                select forupdate taxLocationExt where taxLocationExt.Location == postalLocationId;
                if (taxLocationExt)
                {
                    taxLocationExt.TaxGroup = taxGroup;
                    taxLocationExt.update();
                }
                else
                {
                    taxLocationExt.initValue();
                    taxLocationExt.Location = postalLocationId;
                    taxLocationExt.TaxGroup = taxGroup;
                    taxLocationExt.insert();
                }

                taxLocationExtId = taxLocationExt.RecId;

                ttscommit;

                validInsert = true;
                error = '';
            }
            else
            {
                error = strFmt("@SYS119849", custAccount);
                eventSource.EventWriteCustomerAccountNotFound(funcName());
            }
        }
        catch (Exception::Error)
        {
            ttsabort;
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            str axCallStack = con2Str(xSession::xppCallStack()); // Use AX call stack for Exception::Error
            eventSource.EventWriteCustomerCreateAddressException(funcName(), axCallStack);
        }

        // Returning the status as a container
        return [validInsert, error,
                custTable.Party, 0, 0, //0-2
                postalAddressId, postalLocationId, postalPartyLocationId, postalPartyLocationRoleId, postalLocationRoleId, //3-7
                taxLocationExtId, 0, 0, 0, 0,   //8-12
                emailContactId, electronicsLocation.RecId, electronicsLocation.LocationId, 0, 0, //13-17
                phoneContactId, electronicsLocation.RecId, electronicsLocation.LocationId, 0, 0, //18-22
                urlContactId, electronicsLocation.RecId, electronicsLocation.LocationId, 0, 0,   //23-27
                0, 0, 0, 0, 0, postalLogisticsLocationId, postalAddress.Address, taxGroup,      //28-35
                enum2int(addressView.IsPrimary), postalAddress.ValidFrom];                      //36-37
    }

]]></Source>
			</Method>
			<Method>
				<Name>deactivateAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for deactivating a record in <c>LogisticsPostalAddress</c> table.
    /// </summary>
    /// <param name="addressRecId">
    /// The LogisticsPostalAddress Record Id.
    /// </param>
    /// <param name="custTableRecId">
    /// The CUSTTABLE Record Id.
    /// </param>
    /// <returns>
    /// Success or failure result.
    /// </returns>
    /// <remarks>
    /// Updates the ValidTo date making the record no longer valid.
    /// </remarks>
    public static container deactivateAddress(RefRecId addressRecId, RefRecId custTableRecId)
    {
        str                         error           = "@RET2445"; // default - error message "Undefined error"
        boolean                     validDeactivate = false;      // default - failure
        LogisticsPostalAddress      address;
        CustTable                   custTable;
        Counter                     infologline     = infolog.num();

        try
        {
            eventSource.EventWriteStartedProcessingLogisticsPostalAddressDeactivation(addressRecId, custTableRecId);
            address = LogisticsPostalAddress::findRecId(addressRecId, true);

            custTable = CustTable::findRecId(custTableRecId, true);

            if (address && custTable)
            {
                ttsbegin;
                if (address.ValidTo > DateTimeUtil::utcNow())
                {
                    address.deactivate(custTable, true);
                }

                ttscommit;
                validDeactivate = true; // success
                error = ''; // success - No error message

                eventSource.EventWriteSuccessfullyCompletedProcessingLogisticsPostalAddressDeactivation(addressRecId, custTableRecId);
            }
            else
            {
                error = "@RET5166"; // The specified address does not exist
                eventSource.EventWriteFailedProcessingLogisticsPostalAddressDeactivation(addressRecId, custTableRecId, error);
            }
        }
        catch (Exception::Error)
        {
            ttsabort;

            error = conPeek(conPeek(infolog.copy(infologline + 1, infolog.num()), 2), 2);
            eventSource.EventWriteFailedProcessingLogisticsPostalAddressDeactivation(addressRecId, custTableRecId, error);
        }

        // Returning the status as a container
        return [validDeactivate, error];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCityRecId_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets primary key value for Cities table based on natural key fields.
    /// </summary>
    /// <param name="_countryRegionId">
    /// Country code.
    /// </param>
    /// <param name="_stateId">
    /// State code.
    /// </param>
    /// <param name="_countyId">
    /// County code.
    /// </param>
    /// <param name="_cityName">
    /// City name.
    /// </param>
    /// <returns>
    /// Record Id of city.
    /// </returns>
    /// <remarks>
    /// City table has no natural key [country/state/county/city].
    /// Assumption that there are no two cities with same name for given combination of country/state/county was made for Russia.
    /// </remarks>
    private static LogisticsAddressCityRecId getCityRecId_RU(LogisticsAddressCountryRegionId  _countryRegionId,
                                                             LogisticsAddressStateId          _stateId,
                                                             LogisticsAddressCountyId         _countyId,
                                                             LogisticsAddressCityName         _cityName)
    {
        LogisticsAddressCity city;

        if (!_cityName)
        {
            return 0;
        }

        select firstOnly RecId from city
            where city.CountryRegionId == _countryRegionId
               && city.StateId == _stateId
               && city.CountyId == _countyId
               && city.Name == _cityName;

        return city.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContactInfoData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves contact info data.
    /// </summary>
    /// <param name="_party">
    /// The party record identifier for which to retrieve the data.
    /// </param>
    /// <param name="_contactRecId">
    /// The electronic address record id to retrieve data from.
    /// </param>
    /// <returns>
    /// A container with contact location details.
    /// </returns>
    public static container getContactInfoData(DirPartyRecId _party, RecId _contactRecId)
    {
        DirPartyLocation            partyLocation;
        DirPartyLocationRole        partyLocationRole;
        LogisticsLocation           location;
        LogisticsElectronicAddress  electronicAddress;
        RecId                       contactPartyLocationRecId, contactPartyLocationRoleId, contactLocationRecId;
        LogisticsLocationRoleRecId  contactLocationRoleRecId;
        LogisticsLocationId         contactLocationId;

        select RecId, Party, Location from partyLocation
            where partyLocation.Party == _party &&
                    partyLocation.IsPostalAddress == NoYes::No
            join Type from electronicAddress
            where electronicAddress.RecId == _contactRecId
            && electronicAddress.Location == partyLocation.Location;

        contactPartyLocationRecId = partyLocation.RecId;

        select RecId, LocationId
        from location
        where location.RecId == partyLocation.Location;

        contactLocationId = location.LocationId;
        contactLocationRecId = location.RecId;

        select RecId, LocationRole from partyLocationRole
        where partyLocationRole.PartyLocation == partyLocation.RecId;

        contactPartyLocationRoleId = partyLocationRole.RecId;
        contactLocationRoleRecId = partyLocationRole.LocationRole;

        return [contactLocationRecId, contactLocationId, contactPartyLocationRecId, contactLocationRoleRecId, contactPartyLocationRoleId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchCustomers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs a keyword search of customers,
    /// and returns a list of customers matching the search terms provided.
    /// </summary>
    /// <param name="searchString">
    /// A string of keywods to be searched (space delimited). To use this string
    /// in a query, it is constrained to a max length of 255 characters.
    /// </param>
    /// <param name="recordsToSkip">
    /// The number of results to skip over before we start returning them.
    /// </param>
    /// <param name="recordsToGet">
    /// The number of results to return.
    /// </param>
    /// <returns>
    /// A container containing an array of global customers in XML.
    /// </returns>
    /// <remarks>
    /// Before adding/removing fields in response,
    /// please contact Merchandising team since it may affect azure search publishing pipeline.
    /// </remarks>
    public static container searchCustomers(str 255 searchString, int recordsToSkip = 0, int recordsToGet = 50)
    {
        #define.minCharsForWildcardSearch(4)

        const int maxCount = 500;
        int searchResultCount = 0;
        int                         recCount = 0;
        boolean                     success = true;
        str                         error = '';
        Counter                     infologline = infolog.num();
        int                         fromLine;

        RetailTmpCustomerSearchDirPartyData matchingPartyData;

        OMInternalOrganization      internalOrgs;
        CustTable                   custTableSearch;
        CustTable                   custTableExists;
        CustTable                   custTable;
        RetailCustTable             retailCustTable;
        DirAddressBookParty         dirAddressBookPartyExists;
        DirPartyTable               dirPartyTableSearch;
        DirPartyTable               dirPartyTable;
        DirPartyLocation            dirPartyLocation;
        DirPartyPostalAddressView   addressView;
        LogisticsElectronicAddress  logisticsElectronicAddressSearch;
        LogisticsElectronicAddress  logisticsElectronicAddressEmail;
        LogisticsElectronicAddress  logisticsElectronicAddressPhone;
        RetailLoyaltyCard           loyaltyCardSearch;

        XmlDocument                 doc = RetailTransactionServiceUtilities::getXmlDocumentForSerializedEntities();
        XmlElement                  rootNode;
        XmlElement                  recordNode;
        XmlElement                  fieldNode;

        rootNode = doc.createElement('ArrayOfGlobalCustomer');
        rootNode.setAttribute('xmlns', RetailTransactionServiceUtilities::getCrtDataModelXmlNamespace());
        doc.appendChild(rootNode);

        if (strLTrim(searchString) == '')
        {
            return [false, "@Retail:MustProvideKeywords", doc.xml()];
        }
        else if (recordsToSkip < 0)
        {
            return [false, "@Retail:PageNumberLessThanZero", doc.xml()];
        }
        else if (recordsToGet < 0)
        {
            return [false, "@Retail:PageSizeLessThanZero", doc.xml()];
        }

        try
        {
            fromLine = Global::infologLine();

            // Get the RecIds of DirPartyTable entries that match our search criteria.
            // Do an exists join with CustTable (where necessary) to ensure those parties are customers.

            // Search for a matching customer account number
            while select firstonly1000 Party from custTableSearch
                where custTableSearch.accountNum == searchString
            exists join dirAddressBookPartyExists
                where custTableSearch.Party == dirAddressBookPartyExists.Party
            exists join dirPartyTable
                where custTableSearch.Party == dirPartyTable.RecId
            notExists join internalOrgs
                where custTableSearch.Party == internalOrgs.RecId
            {
                if (searchResultCount >= maxCount)
                {
                    break;
                }
                matchingPartyData.addRecId(custTableSearch.Party);
                searchResultCount++;
            }

            // Search for a matching loyalty card number
            while select firstonly1000 crossCompany Party from loyaltyCardSearch
                where loyaltyCardSearch.CardNumber == searchString
            exists join dirAddressBookPartyExists
                where loyaltyCardSearch.Party == dirAddressBookPartyExists.Party
            exists join dirPartyTable
                where loyaltyCardSearch.Party == dirPartyTable.RecId
            notExists join internalOrgs
                where loyaltyCardSearch.Party == internalOrgs.RecId
            {
                if (searchResultCount >= maxCount)
                {
                    break;
                }
                matchingPartyData.addRecId(loyaltyCardSearch.Party);
                searchResultCount++;
            }

            // Search for a matching email, phone, url...
            while select firstonly1000 crossCompany Party from dirPartyLocation
                group by dirPartyLocation.Party
            exists join logisticsElectronicAddressSearch
                where dirPartyLocation.Location == logisticsElectronicAddressSearch.Location
                && dirPartyLocation.IsPostalAddress == NoYes::No
                && logisticsElectronicAddressSearch.locator == searchString
            exists join dirAddressBookPartyExists
                where dirPartyLocation.Party == dirAddressBookPartyExists.Party
            notExists join internalOrgs
                where dirPartyLocation.Party == internalOrgs.RecId
            {
                if (searchResultCount >= maxCount)
                {
                    break;
                }
                matchingPartyData.addRecId(dirPartyLocation.Party);
                searchResultCount++;
            }

            // Search by name
            // If 4 or more non-whitespace characters are provided, use a wildcard search
            if (strLen(strReplace(searchString, ' ', '')) >= #minCharsForWildcardSearch)
            {
                // Search by name with wildcards between each word
                while select firstonly1000 crossCompany RecId from dirPartyTableSearch
                    index NameIdx
                    where dirPartyTableSearch.name like '*' + strReplace(strRTrim(strLTrim(searchString)), ' ', '* ') + '*'
                exists join dirAddressBookPartyExists
                    where dirPartyTableSearch.RecId == dirAddressBookPartyExists.Party
                notExists join internalOrgs
                    where dirPartyTableSearch.RecId == internalOrgs.RecId
                {
                    if (searchResultCount >= maxCount)
                    {
                        break;
                    }
                    matchingPartyData.addRecId(dirPartyTableSearch.RecId);
                    searchResultCount++;
                }
            }
            else
            {
                // Search for an exact match of name
                while select firstonly1000 crossCompany RecId from dirPartyTableSearch
                    where dirPartyTableSearch.name == searchString
                exists join dirAddressBookPartyExists
                    where dirPartyTableSearch.RecId == dirAddressBookPartyExists.Party
                notExists join internalOrgs
                    where dirPartyTableSearch.RecId == internalOrgs.RecId
                {
                    if (searchResultCount >= maxCount)
                    {
                        break;
                    }
                    matchingPartyData.addRecId(dirPartyTableSearch.RecId);
                    searchResultCount++;
                }
            }

            RetailSearchCustomersParameters searchParameters = RetailSearchCustomersParameters::construct();
            searchParameters.matchingPartyData = matchingPartyData;
            searchParameters.searchKeyword = searchString;

            RetailSearchCustomersExtensions::searchCustomersPreIterateResults(searchParameters);

            // Join with the needed fields, sort, and iterate the search results
            while select * from matchingPartyData
            join Name, PartyNumber from dirPartyTable
                order by dirPartyTable.Name asc
                where matchingPartyData.Party == dirPartyTable.RecId
            outer join AccountNum from custTable
                where dirPartyTable.RecId == custTable.Party
                && custTable.dataAreaId == curext()
            outer join Address from addressView
                where dirPartyTable.RecId == addressView.Party
                && addressView.IsPrimary == NoYes::Yes
            outer join locator from logisticsElectronicAddressEmail
                where dirPartyTable.PrimaryContactEmail == logisticsElectronicAddressEmail.recid
            outer join locator from logisticsElectronicAddressPhone
                where dirPartyTable.PrimaryContactPhone == logisticsElectronicAddressPhone.RecId
            outer join B2BCustomerHierarchyNode from retailCustTable 
                where custTable.AccountNum == retailCustTable.accountNum
            {
                if (recCount >= recordsToSkip + recordsToGet)
                {
                    break;
                }
                if (recCount >= recordsToSkip)
                {
                    recordNode = doc.createElement('GlobalCustomer');

                    fieldNode = doc.createElement('AccountNumber');
                    fieldNode.text(custTable ? custTable.AccountNum : '');
                    recordNode.appendChild(fieldNode);

                    fieldNode = doc.createElement('CustomerTypeValue');
                    fieldNode.text(int2Str(enum2int(dirPartyTable.type())));
                    recordNode.appendChild(fieldNode);

                    if (logisticsElectronicAddressEmail)
                    {
                        fieldNode = doc.createElement('Email');
                        fieldNode.text(logisticsElectronicAddressEmail.Locator);
                        recordNode.appendChild(fieldNode);
                    }

                    if (addressView)
                    {
                        fieldNode = doc.createElement('FullAddress');
                        fieldNode.text(addressView.Address);
                        recordNode.appendChild(fieldNode);
                    }

                    fieldNode = doc.createElement('FullName');
                    fieldNode.text(dirPartyTable.Name);
                    recordNode.appendChild(fieldNode);

                    if (retailCustTable)
                    {
                        fieldNode = doc.createElement('IsB2b');
                        fieldNode.text(retailCustTable.B2BCustomerHierarchyNode == 0 ? 'false' : 'true');
                        recordNode.appendChild(fieldNode);
                    }

                    fieldNode = doc.createElement('PartyNumber');
                    fieldNode.text(dirPartyTable.PartyNumber);
                    recordNode.appendChild(fieldNode);

                    if (logisticsElectronicAddressPhone)
                    {
                        fieldNode = doc.createElement('Phone');
                        fieldNode.text(logisticsElectronicAddressPhone.Locator);
                        recordNode.appendChild(fieldNode);
                    }

                    if (custTable)
                    {
                        fieldNode = doc.createElement('RecordId');
                        fieldNode.text(int642Str(custTable.RecId));
                        recordNode.appendChild(fieldNode);
                    }

                    rootNode.appendChild(recordNode);
                }
                recCount++;
            }
        }
        catch
        {
            success = false;
            error = "@Retail:CustomerSearchFailed";
            error += RetailTransactionServiceUtilities::getInfologMessages(fromLine);
        }

        matchingPartyData.dispose();
        return [success, error, doc.xml()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerDataPackage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the specified customer (only one of the arguments needs to be populated).
    /// </summary>
    /// <param name="custRecId">
    /// The desired customer's recId.
    /// </param>
    /// <param name="accountNum">
    /// The desired customer's account number.
    /// </param>
    /// <param name="custPartyRecId">
    /// The desired customer's party recId.
    /// </param>
    /// <param name="channelId">
    /// The channel or store requesting the customer package (the customer will be added to their address book).
    /// </param>
    /// <param name="versionNumber">
    /// The version number to indicate which functionality is supported.
    /// Version number 1: Returns default data and data from tables <c>DirPersonName</c>, <c>RetailMediaAndMasterEntityRelation</c>, and <c>RetailMediaResource</c>.
    /// Version number 3: Returns additional data from <c>RetailCustTable</c>.
    /// Version number 4: Returns additional data from <c>CustomerInstanceValue</c>, <c>EcoResAttributeValue</c>, <c>EcoResAttribute</c>, <c>EcoResAttributeType</c>,
    /// <c>EcoResBooleanValue</c>, <c>EcoResDateTimeValue</c>, <c>EcoResFloatValue</c>, <c>EcoResIntValue</c>, <c>EcoResTextValue</c>, and <c>UnitOfMeasure</c>.
    /// </param>
    /// <returns>
    /// A serialized CDX package representing the customer.
    /// </returns>
    public static container getCustomerDataPackage(RecId custRecId, CustAccount accountNum, RecId custPartyRecId, RecId channelId, int versionNumber = 1)
    {
        RetailCdxDataPackageSerializationHelper serializer;
        RecId                       channelSchemaRecId;
        CustTable                   custTable;
        str                         serializedPackage;

        boolean                     success = true;
        str                         error   = '';

        Counter     infologline = infolog.num();
        int         fromLine = Global::infologLine();

        custTable = CustTable::findRecId(custRecId);

        // If customer is not found, find by account number.
        if (!custTable && accountNum != '')
        {
            custTable = CustTable::find(accountNum);
        }

        // If customer is not found, find by party record identifier.
        if (!custTable && custPartyRecId != 0)
        {
            custTable = custTable::findByPartyRecId(custPartyRecId);
        }

        try
        {
            channelSchemaRecId = RetailTransactionServiceUtilities::getChannelSchemaRecId(channelId);
            serializer = new RetailCdxDataPackageSerializationHelper(channelSchemaRecId);

            if (custTable)
            {
                RetailTransactionServiceCustomer::addPartyToLocalAddressBooks(custTable.Party, channelId);
                RetailTransactionServiceCustomer::addCustomerDataToPackage(serializer, custTable, versionNumber);
                RetailTransactionServiceCustomer::addPartyDataToPackage(serializer, custTable.Party);
                if (versionNumber >= 4)
                {
                    RetailTransactionServiceCustomer::addCustomerAttributesToPackage(serializer, custTable);
                }

                RetailTransactionServiceCustomerExtensions::addAdditionalCustomerDataToPackage(serializer, custTable);
            }

            serializedPackage = serializer.getBase64EncodedDataPackage();
        }
        catch (Exception::CLRError)
        {
            success = false;
            error = "@Retail:DataPackageGenerationError";

            System.Exception ex = CLRInterop::getLastException();
            error += ex.ToString();
        }
        catch
        {
            success = false;
            error = "@Retail:DataPackageGenerationError";
            error += RetailTransactionServiceUtilities::getInfologMessages(fromLine);
        }
        finally
        {
            if (serializer)
            {
                serializer.cleanUp();
                serializer = null;
            }
        }

        return [success, error, serializedPackage];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPartyDataPackage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the specified party.
    /// </summary>
    /// <param name="partyNum">
    /// The desired party's party number.
    /// </param>
    /// <param name="channelId">
    /// The channel or store requesting the data package.
    /// </param>
    /// <returns>
    /// A serialized CDX package representing it.
    /// </returns>
    public static container getPartyDataPackage(PartyNumber partyNum, RecId channelId)
    {
        RetailCdxDataPackageSerializationHelper  serializer;
        RecId                       channelSchemaRecId;
        DirPartyTable               dirPartyTable;
        str                         serializedPackage;

        boolean                     success = true;
        str                         error   = '';

        Counter     infologline = infolog.num();
        int         fromLine = Global::infologLine();

        dirPartyTable = DirPartyTable::findByNum(partyNum);

        try
        {
            channelSchemaRecId = RetailTransactionServiceUtilities::getChannelSchemaRecId(channelId);
            serializer = new RetailCdxDataPackageSerializationHelper(channelSchemaRecId);

            if (dirPartyTable)
            {
                RetailTransactionServiceCustomer::addPartyToLocalAddressBooks(dirPartyTable.RecId, channelId);
                RetailTransactionServiceCustomer::addPartyDataToPackage(serializer, dirPartyTable.RecId);
            }

            serializedPackage = serializer.getBase64EncodedDataPackage();
        }
        catch (Exception::CLRError)
        {
            success = false;
            error = "@Retail:DataPackageGenerationError";

            System.Exception ex = CLRInterop::getLastException();
            error += ex.ToString();
        }
        catch
        {
            success = false;
            error = "@Retail:DataPackageGenerationError";
            error += RetailTransactionServiceUtilities::getInfologMessages(fromLine);
        }
        finally
        {
            if (serializer)
            {
                serializer.cleanUp();
                serializer = null;
            }
        }

        return [success, error, serializedPackage];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the customer details for a given customer account.
    /// </summary>
    /// <param name="custAccount">
    /// The value of CustAccount for which customer details has to be fetched.
    /// </param>
    /// <returns>
    /// A container having the customer details in a XML string.
    /// </returns>
    public static container getCustomer(CustAccount custAccount)
    {
        str                 error = '';
        boolean             success = false;

        XmlDocument         xmlDoc;
        XmlElement          xmlRoot;

        XmlElement          xmlCustTable;
        XmlElement          xmlRetailCustTable;
        XmlElement          xmlRetailCustAffiliation;
        XmlElement          xmlRetailCustAffiliations;

        XmlElement          xmlDirParty;
        XmlElement          xmlDirPartyLocation;
        XmlElement          xmlDirPartyLocationRole;

        XmlElement          xmlLogisticsLocation;
        XmlElement          xmlLogisticsLocationRole;
        XmlElement          xmlLogisticsPostalAddress;
        XmlElement          xmlLogisticsElectronicAddress;

        XmlElement          xmlAddressSection;

        CustTable               custTable;
        RetailCustTable         retailCustTable;
        RetailCustAffiliation   retailCustAffiliation;

        DirPartyTable           dirParty;
        DirPartyLocation        partyLocation;
        DirPartyLocationRole    partyLocationRole;

        LogisticsLocation           logisticsLocation;
        LogisticsLocationRole       logisticsLocationRole;
        LogisticsPostalAddress      postalAddress;
        LogisticsElectronicAddress  electronicAddress;

        Counter     infologline = infolog.num();
        int         fromLine;
        utcdatetime validDateTime;

        try
        {
            fromLine = Global::infologLine();

            xmlDoc  = XmlDocument::newBlank();
            xmlRoot = xmlDoc.createElement('Customer');

            custTable = CustTable::find(custAccount);
            if (custTable)
            {
                // Gets the customer information from custtable
                xmlCustTable = RetailTransactionServiceCustomer::getCustTableXml(xmlDoc, custTable);
                xmlRoot.appendChild(xmlCustTable);

                retailCustTable = RetailCustTable::find(custAccount);

                xmlRetailCustTable = RetailTransactionServiceCustomer::getRetailCustTableXml(xmlDoc, retailCustTable);
                xmlRoot.appendChild(xmlRetailCustTable);

                select firstonly * from dirParty where (dirParty.RecId == custTable.Party);

                // gets the dir party row
                xmlDirParty = RetailTransactionServiceCustomer::getDirPartyXml(xmlDoc, dirParty);
                xmlRoot.appendChild(xmlDirParty);

                validDateTime = DateTimeUtil::utcNow();

                while select * from postalAddress
                join * from logisticsLocation
                    where (logisticsLocation.RecId == postalAddress.Location)
                outer join * from partyLocationRole
                    where (partyLocationRole.PartyLocation == postalAddress.Location)
                outer join * from logisticsLocationRole
                    where (logisticsLocationRole.RecId == partyLocationRole.LocationRole
                        && logisticsLocationRole.IsContactInfo == 1)
                join * from partyLocation
                    where (partyLocation.Location == postalAddress.Location
                        && partyLocation.IsPostalAddress == 1
                        && partyLocation.IsPrivate == 0
                        && postalAddress.ValidFrom <= validDateTime
                        && postalAddress.ValidTo >= validDateTime
                        && partyLocation.Party == custTable.Party)
                {
                    if (partyLocationRole != null && logisticsLocationRole == null)
                    {
                        continue;
                    }

                    xmlAddressSection = xmlDoc.createElement('PostalAddress');

                    // gets the dir party location row
                    xmlDirPartyLocation = RetailTransactionServiceCustomer::getDirPartyLocationXml(xmlDoc, partyLocation);
                    xmlAddressSection.appendChild(xmlDirPartyLocation);

                    // gets the dir party location role row
                    xmlDirPartyLocationRole = RetailTransactionServiceCustomer::getDirPartyLocationRoleXml(xmlDoc, partyLocationRole);
                    xmlAddressSection.appendChild(xmlDirPartyLocationRole);

                    // gets the logistics location row
                    xmlLogisticsLocation = RetailTransactionServiceCustomer::getLogisticsLocationXml(xmlDoc, logisticsLocation);
                    xmlAddressSection.appendChild(xmlLogisticsLocation);

                    // gets the logistics location role row
                    xmlLogisticsLocationRole = RetailTransactionServiceCustomer::getLogisticsLocationRoleXml(xmlDoc, logisticsLocationRole);
                    xmlAddressSection.appendChild(xmlLogisticsLocationRole);

                    // gets the logistics postal address row
                    xmlLogisticsPostalAddress = RetailTransactionServiceCustomer::getLogisticsPostalAddressXml(xmlDoc, postalAddress);
                    xmlAddressSection.appendChild(xmlLogisticsPostalAddress);

                    xmlRoot.appendChild(xmlAddressSection);
                }

                while select * from electronicAddress
                join * from logisticsLocation
                    where (logisticsLocation.RecId == electronicAddress.Location)
                join * from partyLocation
                    where (partyLocation.Location == electronicAddress.Location
                        && partyLocation.IsPostalAddress == 0
                        && partyLocation.IsPrimary == 1
                        && partyLocation.Party == custTable.Party)
                {
                    xmlAddressSection = xmlDoc.createElement('ElectronicAddress');

                    // gets the dir party location row
                    xmlDirPartyLocation = RetailTransactionServiceCustomer::getDirPartyLocationXml(xmlDoc, partyLocation);
                    xmlAddressSection.appendChild(xmlDirPartyLocation);

                    // gets the logistics location row
                    xmlLogisticsLocation = RetailTransactionServiceCustomer::getLogisticsLocationXml(xmlDoc, logisticsLocation);
                    xmlAddressSection.appendChild(xmlLogisticsLocation);

                    // gets the logistics electronic address row
                    xmlLogisticsElectronicAddress = RetailTransactionServiceCustomer::getLogisticsElectronicAddressXml(xmlDoc, electronicAddress);
                    xmlAddressSection.appendChild(xmlLogisticsElectronicAddress);

                    xmlRoot.appendChild(xmlAddressSection);
                }

                xmlRetailCustAffiliations = xmlDoc.createElement('RetailCustAffiliations');

                while select * from retailCustAffiliation
                    where retailCustAffiliation.CustAccountNum == custAccount
                {
                    xmlRetailCustAffiliation = RetailTransactionServiceCustomer::getRetailCustAffiliationXml(xmlDoc, retailCustAffiliation);
                    xmlRetailCustAffiliations.appendChild(xmlRetailCustAffiliation);
                }

                xmlRoot.appendChild(xmlRetailCustAffiliations);
            }

            xmlDoc.appendChild(xmlRoot);
            success = true;
        }
        catch(Exception::Error)
        {
            ttsabort;
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            success = false;
        }

        return [success, error, xmlDoc.toString()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustTableXml</Name>
				<Source><![CDATA[
    private static XmlElement getCustTableXml(XmlDocument xmlDoc, CustTable custTable)
    {
        XmlElement          xmlCustTable;

        xmlCustTable = xmlDoc.createElement('CustTable');
        if (custTable)
        {
            xmlCustTable.setAttribute('RecId', int642str(custTable.RecId));
            xmlCustTable.setAttribute('AccountNum', custTable.AccountNum);
            xmlCustTable.setAttribute('Party', int642str(custTable.Party));
            xmlCustTable.setAttribute('CustGroup', custTable.CustGroup);
            xmlCustTable.setAttribute('InvoiceAccount', custTable.InvoiceAccount);
            xmlCustTable.setAttribute('NameAlias', custTable.nameAlias());
            xmlCustTable.setAttribute('Currency', custTable.Currency);
            xmlCustTable.setAttribute('LanguageId', custTable.languageId());
            xmlCustTable.setAttribute('MultiLineDisc', custTable.MultiLineDisc);
            xmlCustTable.setAttribute('EndDisc', custTable.EndDisc);
            xmlCustTable.setAttribute('LineDisc', custTable.LineDisc);
            xmlCustTable.setAttribute('PriceGroup', custTable.PriceGroup);
            xmlCustTable.setAttribute('CreditMax', num2str(custTable.CreditMax, 5, 3, 1, 0));
            xmlCustTable.setAttribute('Blocked', int2str(enum2int(custTable.Blocked)));
            xmlCustTable.setAttribute('TaxGroup', custTable.TaxGroup);
            xmlCustTable.setAttribute('VATNum', custTable.getPrimaryRegistrationNumber(TaxRegistrationTypesList::TAXID));
            xmlCustTable.setAttribute('OrgId', custTable.OrgId);
            xmlCustTable.setAttribute('UsePurchRequest', int2str(enum2int(custTable.UsePurchRequest)));
            xmlCustTable.setAttribute('InclTax', int2str(enum2int(custTable.InclTax)));
            xmlCustTable.setAttribute('CNPJCPFNum', custTable.cnpjcpfNum_BR);

            unchecked (Uncheck::TableSecurityPermission)
            {
                xmlCustTable.setAttribute('IdentificationNumber', custTable.IdentificationNumber);
            }
        }

        return xmlCustTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDirPartyLocationRoleXml</Name>
				<Source><![CDATA[
    private static XmlElement getDirPartyLocationRoleXml(XmlDocument xmlDoc, DirPartyLocationRole dirPartyLocationRole)
    {
        XmlElement xmlDirPartyLocationRole;

        xmlDirPartyLocationRole = xmlDoc.createElement('DirPartyLocationRole');
        if (dirPartyLocationRole)
        {
            xmlDirPartyLocationRole.setAttribute('RecId', int642str(dirPartyLocationRole.RecId));
            xmlDirPartyLocationRole.setAttribute('LocationRole', int642str(dirPartyLocationRole.LocationRole));
            xmlDirPartyLocationRole.setAttribute('PartyLocation', int642str(dirPartyLocationRole.PartyLocation));
        }

        return xmlDirPartyLocationRole;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDirPartyLocationXml</Name>
				<Source><![CDATA[
    private static XmlElement getDirPartyLocationXml(XmlDocument xmlDoc, DirPartyLocation dirPartyLocation)
    {
        XmlElement xmlDirPartyLocation;

        xmlDirPartyLocation = xmlDoc.createElement('DirPartyLocation');
        if (dirPartyLocation)
        {
            xmlDirPartyLocation.setAttribute('RecId', int642str(dirPartyLocation.RecId));
            xmlDirPartyLocation.setAttribute('Location', int642str(dirPartyLocation.Location));
            xmlDirPartyLocation.setAttribute('Party', int642str(dirPartyLocation.Party));
            xmlDirPartyLocation.setAttribute('IsPostalAddress', int2str(dirPartyLocation.IsPostalAddress));
            xmlDirPartyLocation.setAttribute('IsPrimary', int2str(dirPartyLocation.IsPrimary));
            xmlDirPartyLocation.setAttribute('IsPrivate', int2str(dirPartyLocation.IsPrivate));
            xmlDirPartyLocation.setAttribute('IsLocationOwner', int2str(dirPartyLocation.IsLocationOwner));
            xmlDirPartyLocation.setAttribute('ValidFrom', DateTimeUtil::toStr(DateTimeUtil::minValue()));
            xmlDirPartyLocation.setAttribute('ValidTo', DateTimeUtil::toStr(DateTimeUtil::maxValue()));
        }

        return xmlDirPartyLocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDirPartyXml</Name>
				<Source><![CDATA[
    private static XmlElement getDirPartyXml(XmlDocument xmlDoc, DirPartyTable dirParty)
    {
        XmlElement xmlDirParty;

        xmlDirParty = xmlDoc.createElement('DirPartyTable');
        if (dirParty)
        {
            xmlDirParty.setAttribute('RecId', int642str(dirParty.RecId));
            xmlDirParty.setAttribute('Name', dirParty.Name);
            xmlDirParty.setAttribute('PartyNumber', dirParty.PartyNumber);
            xmlDirParty.setAttribute('RelationType', int642str(dirParty.RelationType));
        }

        return xmlDirParty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDistrictRecId_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets record id for districts based on natural key fields.
    /// </summary>
    /// <param name="_countryRegionId">
    /// Country code.
    /// </param>
    /// <param name="_stateId">
    /// State code.
    /// </param>
    /// <param name="_countyId">
    /// County code.
    /// </param>
    /// <param name="_cityRecId">
    /// Record id of city.
    /// </param>
    /// <param name="_districtName">
    /// District name.
    /// </param>
    /// <returns>
    /// Record id of district.
    /// </returns>
    private static LogisticsAddressDistrictRecId getDistrictRecId_RU(LogisticsAddressCountryRegionId  _countryRegionId,
                                                                     LogisticsAddressStateId          _stateId,
                                                                     LogisticsAddressCountyId         _countyId,
                                                                     LogisticsAddressCityRecId        _cityRecId,
                                                                     LogisticsAddressDistrictName     _districtName)
    {
        LogisticsAddressDistrict district;

        if (!_districtName)
        {
            return 0;
        }

        if (_cityRecId)
        {
            select RecId from district
                where district.City == _cityRecId
                   && district.Name == _districtName;
        }
        else
        {
            select RecId from district
                where district.CountryRegionId_RU == _countryRegionId
                   && district.StateId_RU == _stateId
                   && district.CountyId_RU == _countyId
                   && district.City == 0
                   && district.Name == _districtName;
        }

        return district.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLogisticsElectronicAddressXml</Name>
				<Source><![CDATA[
    private static XmlElement getLogisticsElectronicAddressXml(XmlDocument xmlDoc, LogisticsElectronicAddress electronicAddress)
    {
        XmlElement xmlLogisticsElectronicAddress;

        xmlLogisticsElectronicAddress = xmlDoc.createElement('LogisticsElectronicAddress');
        if (electronicAddress)
        {
            xmlLogisticsElectronicAddress.setAttribute('RecId', int642str(electronicAddress.RecId));
            xmlLogisticsElectronicAddress.setAttribute('Location', int642str(electronicAddress.Location));
            xmlLogisticsElectronicAddress.setAttribute('Locator', electronicAddress.Locator);
            xmlLogisticsElectronicAddress.setAttribute('Type', int2str(enum2int(electronicAddress.Type)));
            xmlLogisticsElectronicAddress.setAttribute('CountryRegionCode', electronicAddress.CountryRegionCode);
            xmlLogisticsElectronicAddress.setAttribute('ValidFrom', DateTimeUtil::toStr(DateTimeUtil::minValue()));
            xmlLogisticsElectronicAddress.setAttribute('ValidTo', DateTimeUtil::toStr(DateTimeUtil::maxValue()));
        }

        return xmlLogisticsElectronicAddress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLogisticsLocationRoleXml</Name>
				<Source><![CDATA[
    private static XmlElement getLogisticsLocationRoleXml(XmlDocument xmlDoc, LogisticsLocationRole logisticsLocationRole)
    {
        XmlElement xmlLogisticsLocationRole;

        xmlLogisticsLocationRole = xmlDoc.createElement('LogisticsLocationRole');
        if (logisticsLocationRole)
        {
            xmlLogisticsLocationRole.setAttribute('RecId', int642str(logisticsLocationRole.RecId));
            xmlLogisticsLocationRole.setAttribute('Name', logisticsLocationRole.Name);
            xmlLogisticsLocationRole.setAttribute('Type', int2str(enum2int(logisticsLocationRole.Type)));
            xmlLogisticsLocationRole.setAttribute('IsPostalAddress', int2str(logisticsLocationRole.IsPostalAddress));
            xmlLogisticsLocationRole.setAttribute('IsContactInfo', int2str(logisticsLocationRole.IsContactInfo));
        }

        return xmlLogisticsLocationRole;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLogisticsLocationXml</Name>
				<Source><![CDATA[
    private static XmlElement getLogisticsLocationXml(XmlDocument xmlDoc, LogisticsLocation logisticsLocation)
    {
        XmlElement xmlLogisticsLocation;

        xmlLogisticsLocation = xmlDoc.createElement('LogisticsLocation');
        if (logisticsLocation)
        {
            xmlLogisticsLocation.setAttribute('RecId', int642str(logisticsLocation.RecId));
            xmlLogisticsLocation.setAttribute('LocationId', logisticsLocation.LocationId);
            xmlLogisticsLocation.setAttribute('Description', logisticsLocation.Description);
            xmlLogisticsLocation.setAttribute('IsPostalAddress', int2str(logisticsLocation.IsPostalAddress));
            xmlLogisticsLocation.setAttribute('ParentLocation', int642str(logisticsLocation.ParentLocation));
        }

        return xmlLogisticsLocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLogisticsPostalAddressXml</Name>
				<Source><![CDATA[
    private static XmlElement getLogisticsPostalAddressXml(XmlDocument xmlDoc, LogisticsPostalAddress postalAddress)
    {
        XmlElement xmlLogisticsPostalAddress;

        xmlLogisticsPostalAddress = xmlDoc.createElement('LogisticsPostalAddress');
        if (postalAddress)
        {
            xmlLogisticsPostalAddress.setAttribute('RecId', int642str(postalAddress.RecId));
            xmlLogisticsPostalAddress.setAttribute('Location', int642str(postalAddress.Location));
            xmlLogisticsPostalAddress.setAttribute('Address', postalAddress.Address);
            xmlLogisticsPostalAddress.setAttribute('ZipCode', postalAddress.ZipCode);
            xmlLogisticsPostalAddress.setAttribute('State', postalAddress.State);
            xmlLogisticsPostalAddress.setAttribute('CountryRegionId', postalAddress.CountryRegionId);
            xmlLogisticsPostalAddress.setAttribute('County', postalAddress.County);
            xmlLogisticsPostalAddress.setAttribute('City', postalAddress.City);
            xmlLogisticsPostalAddress.setAttribute('Street', postalAddress.Street);
            xmlLogisticsPostalAddress.setAttribute('TimeZone', int2str(postalAddress.TimeZone));
            xmlLogisticsPostalAddress.setAttribute('StreetNumber', postalAddress.StreetNumber);
            xmlLogisticsPostalAddress.setAttribute('BuildingCompliment', postalAddress.BuildingCompliment);
            xmlLogisticsPostalAddress.setAttribute('DistrictName', postalAddress.DistrictName);
            xmlLogisticsPostalAddress.setAttribute('ValidFrom', DateTimeUtil::toStr(postalAddress.ValidFrom));
            xmlLogisticsPostalAddress.setAttribute('ValidTo', DateTimeUtil::toStr(postalAddress.ValidTo));
        }

        return xmlLogisticsPostalAddress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRetailCustAffiliationXml</Name>
				<Source><![CDATA[
    private  static XmlElement getRetailCustAffiliationXml(XmlDocument xmlDoc, RetailCustAffiliation retailCustAffiliation)
    {
        XmlElement xmlRetailCustAffiliation;

        xmlRetailCustAffiliation = xmlDoc.createElement('RetailCustAffiliation');
        if (xmlRetailCustAffiliation)
        {
            xmlRetailCustAffiliation.setAttribute('CustAccountNum', retailCustAffiliation.CustAccountNum);
            xmlRetailCustAffiliation.setAttribute('RetailAffiliationId', int642str(retailCustAffiliation.RetailAffiliationId));
            xmlRetailCustAffiliation.setAttribute('RecId', int642str(retailCustAffiliation.RecId));
        }

        return xmlRetailCustAffiliation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRetailCustTableXml</Name>
				<Source><![CDATA[
    private static XmlElement getRetailCustTableXml(XmlDocument xmlDoc, RetailCustTable retailCustTable)
    {
        XmlElement          xmlRetailCustTable;
        RetailSharedParameters  retailSharedParameters = RetailSharedParameters::find();

        xmlRetailCustTable = xmlDoc.createElement('RetailCustTable');
        if (retailCustTable)
        {
            xmlRetailCustTable.setAttribute('RecId', int642str(retailCustTable.RecId));
            xmlRetailCustTable.setAttribute('AccountNum', retailCustTable.AccountNum);
            xmlRetailCustTable.setAttribute('PostAsShipment', int2str(retailCustTable.PostAsShipment));
            xmlRetailCustTable.setAttribute('ReceiptEmail', retailCustTable.ReceiptEmail);
            xmlRetailCustTable.setAttribute('ReceiptOption', int2str(retailCustTable.ReceiptOption));
            xmlRetailCustTable.setAttribute('RequiresApproval', int2str(retailCustTable.RequiresApproval));
            xmlRetailCustTable.setAttribute('UseOrderNumberReference', int2str(retailCustTable.UseOrderNumberReference));
            xmlRetailCustTable.setAttribute('Image', retailCustTable.Image ? retailCustTable.Image : RetailAttributeHelper::getDefaultTextValue(retailSharedParameters.CustomerDefaultAttributeGroup, retailSharedParameters.ImagesAttributeType));
        }

        return xmlRetailCustTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustTableUsingChannelDefaultCustomer</Name>
				<Source><![CDATA[
    internal static CustTable initCustTableUsingChannelDefaultCustomer(CustTable custTable, CustTable channelDefaultCustomer)
    {
        if (channelDefaultCustomer)
        {
            // use the channel's default customer's payment method setting as the basis for the new customer
            custTable.PaymMode = channelDefaultCustomer.PaymMode;

            // If the following fields are not set, copy them from default channel customer
            if (custTable.CustGroup == '')
            {
                custTable.CustGroup = channelDefaultCustomer.CustGroup;
            }

            if (custTable.MultiLineDisc == '')
            {
                custTable.MultiLineDisc = channelDefaultCustomer.MultiLineDisc;
            }

            if (custTable.EndDisc == '')
            {
                custTable.EndDisc = channelDefaultCustomer.EndDisc;
            }

            if (custTable.LineDisc == '')
            {
                custTable.LineDisc = channelDefaultCustomer.LineDisc;
            }

            if (custTable.PriceGroup == '')
            {
                custTable.PriceGroup = channelDefaultCustomer.PriceGroup;
            }

            if (custTable.TaxGroup == '')
            {
                custTable.TaxGroup = channelDefaultCustomer.TaxGroup;
            }

            if (custTable.PaymTermId == '')
            {
                custTable.PaymTermId = channelDefaultCustomer.PaymTermId;
            }

            if (custTable.PaymSched == '')
            {
                custTable.PaymSched = channelDefaultCustomer.PaymSched;
            }

            if (!custTable.CreditMax)
            {
                custTable.CreditMax = channelDefaultCustomer.CreditMax;
            }

            if (!custTable.MandatoryCreditLimit)
            {
                custTable.MandatoryCreditLimit = channelDefaultCustomer.MandatoryCreditLimit;
            }

            // Copy the following fields from default channel customer
            custTable.AccountStatement = channelDefaultCustomer.AccountStatement;
            custTable.CashDisc = channelDefaultCustomer.CashDisc;
            custTable.CashDiscBaseDays = channelDefaultCustomer.CashDiscBaseDays;
            custTable.ClearingPeriod = channelDefaultCustomer.ClearingPeriod;
            custTable.CommissionGroup = channelDefaultCustomer.CommissionGroup;
            custTable.ConsDay_JP = channelDefaultCustomer.ConsDay_JP;
            custTable.CreditCardAddressVerification = channelDefaultCustomer.CreditCardAddressVerification;
            custTable.CreditCardAddressVerificationLevel = channelDefaultCustomer.CreditCardAddressVerificationLevel;
            custTable.CreditCardAddressVerificationVoid = channelDefaultCustomer.CreditCardAddressVerificationVoid;
            custTable.CreditCardCVC = channelDefaultCustomer.CreditCardCVC;
            custTable.CreditRating = channelDefaultCustomer.CreditRating;
            custTable.Currency  = channelDefaultCustomer.Currency;
            custTable.CustClassificationId = channelDefaultCustomer.CustClassificationId;
            custTable.CustExcludeCollectionFee = channelDefaultCustomer.CustExcludeCollectionFee;
            custTable.CustExcludeInterestCharges = channelDefaultCustomer.CustExcludeInterestCharges;
            custTable.CustItemGroupId = channelDefaultCustomer.CustItemGroupId;
            custTable.DlvMode = channelDefaultCustomer.DlvMode;
            custTable.DlvReason = channelDefaultCustomer.DlvReason;
            custTable.DlvTerm = channelDefaultCustomer.DlvTerm;
            custTable.EInvoice = channelDefaultCustomer.EInvoice;
            custTable.FineCode_BR = channelDefaultCustomer.FineCode_BR;
            custTable.FiscalDocType_PL = channelDefaultCustomer.FiscalDocType_PL;
            custTable.ForecastDMPInclude = channelDefaultCustomer.ForecastDMPInclude;
            custTable.GenerateIncomingFiscalDocument_BR = channelDefaultCustomer.GenerateIncomingFiscalDocument_BR;
            custTable.InterCompanyAllowIndirectCreation = channelDefaultCustomer.InterCompanyAllowIndirectCreation;
            custTable.InterCompanyAutoCreateOrders = channelDefaultCustomer.InterCompanyAutoCreateOrders;
            custTable.InterCompanyDirectDelivery = channelDefaultCustomer.InterCompanyDirectDelivery;
            custTable.InterestCode_BR = channelDefaultCustomer.InterestCode_BR;
            custTable.InventLocation = channelDefaultCustomer.InventLocation;
            custTable.InventProfileId_RU = channelDefaultCustomer.InventProfileId_RU;
            custTable.InventProfileType_RU = channelDefaultCustomer.InventProfileType_RU;
            custTable.InventSiteId = channelDefaultCustomer.InventSiteId;
            custTable.InvoicePostingType_RU = channelDefaultCustomer.InvoicePostingType_RU;
            custTable.LvPaymTransCodes = channelDefaultCustomer.LvPaymTransCodes;
            custTable.MandatoryVatDate_PL = channelDefaultCustomer.MandatoryVatDate_PL;
            custTable.MarkupGroup = channelDefaultCustomer.MarkupGroup;
            custTable.numberSequenceGroup = channelDefaultCustomer.numberSequenceGroup;
            custTable.OrderEntryDeadlineGroupId = channelDefaultCustomer.OrderEntryDeadlineGroupId;
            custTable.PackageDepositExcempt_PL = channelDefaultCustomer.PackageDepositExcempt_PL;
            custTable.PaymDayId = channelDefaultCustomer.PaymDayId;
            custTable.PaymSpec = channelDefaultCustomer.PaymSpec;
            custTable.PaymIdType = channelDefaultCustomer.PaymIdType;
            custTable.PdsCustRebateGroupId = channelDefaultCustomer.PdsCustRebateGroupId;
            custTable.PdsFreightAccrued = channelDefaultCustomer.PdsFreightAccrued;
            custTable.PdsRebateTMAGroup = channelDefaultCustomer.PdsRebateTMAGroup;
            custTable.RFIDCaseTagging = channelDefaultCustomer.RFIDCaseTagging;
            custTable.RFIDItemTagging = channelDefaultCustomer.RFIDItemTagging;
            custTable.RFIDPalletTagging = channelDefaultCustomer.RFIDPalletTagging;
            custTable.SalesCalendarId = channelDefaultCustomer.SalesCalendarId;
            custTable.SalesGroup = channelDefaultCustomer.SalesGroup;
            custTable.SalesPoolId = channelDefaultCustomer.SalesPoolId;
            custTable.StatisticsGroup = channelDefaultCustomer.StatisticsGroup;
            custTable.SuppItemGroupId = channelDefaultCustomer.SuppItemGroupId;
            custTable.TaxWithholdCalculate_IN = channelDefaultCustomer.TaxWithholdCalculate_IN;
            custTable.TaxWithholdCalculate_TH = channelDefaultCustomer.TaxWithholdCalculate_TH;
            custTable.TaxWithholdGroup_TH = channelDefaultCustomer.TaxWithholdGroup_TH;
            custTable.UnitedVATInvoice_LT = channelDefaultCustomer.UnitedVATInvoice_LT;
            custTable.UseCashDisc = channelDefaultCustomer.UseCashDisc;
            custTable.usePurchRequest = channelDefaultCustomer.usePurchRequest;
            custTable.WebSalesOrderDisplay = channelDefaultCustomer.WebSalesOrderDisplay;

            unchecked (Uncheck::TableSecurityPermission)
            {
                custTable.IRS1099CIndicator = channelDefaultCustomer.IRS1099CIndicator;
            }
        }

        return custTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating new customer.
    /// </summary>
    /// <param name="custName">
    /// Customer name.
    /// </param>
    /// <param name="custGroup">
    /// Customer group
    /// </param>
    /// <param name="currency">
    /// Currency
    /// </param>
    /// <param name="languageId">
    /// Language ID
    /// </param>
    /// <param name="street">
    /// Street
    /// </param>
    /// <param name="zipCode">
    /// Zip code
    /// </param>
    /// <param name="state">
    /// State
    /// </param>
    /// <param name="county">
    /// County
    /// </param>
    /// <param name="phone">
    /// Phone
    /// </param>
    /// <param name="cellularPhone">
    /// Cell phone
    /// </param>
    /// <param name="email">
    /// Email
    /// </param>
    /// <param name="url">
    /// URL
    /// </param>
    /// <param name="multiLineDisc">
    /// Multiline discount
    /// </param>
    /// <param name="endDisc">
    /// End discount
    /// </param>
    /// <param name="lineDisc">
    /// Line discount
    /// </param>
    /// <param name="priceGroup">
    /// Price Group
    /// </param>
    /// <param name="taxGroup">
    /// Tax Group
    /// </param>
    /// <param name="creditMax">
    /// Credit Max
    /// </param>
    /// <param name="blocked">
    /// Blocked
    /// </param>
    /// <param name="orgId">
    /// Org ID
    /// </param>
    /// <param name="usePurchRequest">
    /// Use purchase request
    /// </param>
    /// <param name="vatNum">
    /// Vat Number
    /// </param>
    /// <param name="invoiceAccount">
    /// Invoice account
    /// </param>
    /// <param name="mandatoryCreditLimit">
    /// Mandotory credit limit
    /// </param>
    /// <param name="contactPersonId">
    /// Contact person ID
    /// </param>
    /// <param name="useOrderNumberReference">
    /// Use order number reference
    /// </param>
    /// <param name="receiptOption">
    /// Receipt option
    /// </param>
    /// <param name="receiptEmail">
    /// Receipt Email
    /// </param>
    /// <param name="city">
    /// City
    /// </param>
    /// <param name="country">
    /// Country
    /// </param>
    /// <param name="identificationNumber">
    /// Identification Number
    /// </param>
    /// <param name="storeRecId">
    /// Store Rec ID
    /// </param>
    /// <param name="dirPartyRelationType">
    /// DirPartyType
    /// </param>
    /// <param name="streetNumber">
    /// Street Number
    /// </param>
    /// <param name="districtName">
    /// District Name
    /// </param>
    /// <param name="buildingCompliment">
    /// Building Complement
    /// </param>
    /// <param name="cnpjCpfNum_BR">
    /// CNPJ/CPF (Brazilian tax ID)
    /// </param>
    /// <param name="addressName">
    /// Address Name
    /// </param>
    /// <param name="addressType">
    /// Address Type
    /// </param>
    /// <param name="addressPhone">
    /// Address Phone
    /// </param>
    /// <param name="addressEmail">
    /// Address Email
    /// </param>
    /// <param name="addressUrl">
    /// Address URL
    /// </param>
    /// <param name="addressTaxGroup">
    /// Address Tax group
    /// </param>
    /// <param name="firstName">
    /// First name
    /// </param>
    /// <param name="middleName">
    /// Middle name
    /// </param>
    /// <param name="lastName">
    /// Last name
    /// </param>
    /// <param name="phoneExtension">
    /// Phone extension
    /// </param>
    /// <param name="retailCustAffiliations">
    /// A XML string having the details of customer affiliation list
    /// </param>
    /// <param name="externalIdentityId">
    /// The external identity identifier.
    /// </param>
    /// <param name="externalIdentityIssuer">
    /// The external identity issuer.
    /// </param>
    /// <param name="customerAttributes">
    /// Optional. An XML string having the details of customer attributes.
    /// </param>
    /// <param name="custAttributesDataPackageVersion">
    /// Optional. The customer attributes data package version.
    /// </param>
    /// <returns>
    /// Container with entity keys
    /// </returns>
    public static container newCustomer(    DirPartyName                custName,
                                            //NameAlias                   custTableAlias,
                                            CustGroupId                 custGroup,
                                            CustCurrencyCode            currency,
                                            CustLanguageId              languageId,
                                            AddressStreet               street,
                                            AddressZipCodeId            zipCode,
                                            AddressStateId              state,
                                            AddressCountyId             county,
                                            Phone                       phone,
                                            PhoneMobile                 cellularPhone,
                                            LogisticsElectronicAddressLocator email,
                                            URL                         url,
                                            CustMultiLineDiscCode       multiLineDisc,
                                            CustEndDiscCode             endDisc,
                                            CustLineDiscCode            lineDisc,
                                            CustPriceGroup              priceGroup,
                                            TaxGroup                    taxGroup,
                                            CustCreditMaxMST            creditMax,
                                            CustBlocked                 blocked,
                                            OrgId                       orgId,
                                            RetailUsePurchRequest       usePurchRequest,
                                            VATNum                      vatNum,
                                            CustInvoiceAccount          invoiceAccount,
                                            MandatoryCreditLimit        mandatoryCreditLimit,
                                            ContactPersonId             contactPersonId,
                                            RetailUseOrderNumberReference  useOrderNumberReference,
                                            RetailReceiptOption            receiptOption,
                                            RetailReceiptEmail             receiptEmail,
                                            AddressCity                 city,
                                            AddressCountryRegionId      country,
                                            CustIdentificationNumber    identificationNumber,
                                            int64                       storeRecId,
                                            DirPartyType                dirPartyRelationType,
                                            LogisticsAddressStreetNumber        streetNumber        = '',
                                            LogisticsAddressDistrictName        districtName        = '',
                                            LogisticsAddressBuildingCompliment  buildingCompliment  = '',
                                            CNPJCPFNum_BR                       cnpjCpfNum_BR       = '',
                                            CustName                    addressName = '',
                                            LogisticsLocationRoleType   addressType = LogisticsLocationRoleType::Other,
                                            Phone                       addressPhone = '',
                                            LogisticsElectronicAddressLocator addressEmail = '',
                                            URL                         addressUrl = '',
                                            TaxGroup                    addressTaxGroup = '',
                                            FirstName firstName = '',
                                            MiddleName middleName = '',
                                            LastName lastName = '',
                                            PhoneLocal phoneExtension = '',
                                            str retailCustAffiliations = '',
                                            str externalIdentityId = '',
                                            str externalIdentityIssuer = '',
                                            str customerAttributes = '',
                                            int custAttributesDataPackageVersion = 1)
    {
        // [FLIGHT-BUG]
        // Bug 879256: Customer related RTS didn't handle ttscommit exceptions correctly and returns succeed after ttscommit failure.
        // The flight below is responsible to revert the changes introduced by this Bug 879256 fix.
        if (!RetailCustomerNewCustomerRtsRevertFlight::instance().isEnabled())
        {
            str                         error          = "";
            boolean                     validInsert    = true;
            CustTable                   custTable;
            RetailCustTable             rboCustTable, defaultRboCustTable;
            Counter                     infologline    = infolog.num();
            CustAccount                 newCustAccount = '';
            CustTable                   channelDefaultCustomer;
            CustomerEntity              customer = new CustomerEntity(custTable, DateTimeUtil::utcNow());
            DirPartyPostalAddressView   addressView;
            LogisticsLocationExt        addressTaxLocationExt;
            DirPartyContactInfoView     contactInfoView, updatedContactInfoView;
            LogisticsPostalAddress      postalAddress;
            DirPartyLocation            partyLocation;
            DirPartyLocationRole        partyLocationRole;
            LogisticsLocation           location;
            DirPartyTable               partyRecord;
            DirAddressBookParty         dirAddressBookParty;
            DirPerson                   person;
            DirPersonName               personName;
            RetailStoreAddressBook      retailStoreAddressBook;
            container                   storeAddressBooks, storeAddressBooksForCustomer, storeAddressBooksForEmployee;
            int64                       custRecId, retailCustRecId;
            int64                       phoneContactId,cellularContactId,urlContactId,emailContactId,postalAddressId;
            int64                       emailPartyLocationRecId,phonePartyLocationRecId,cellularPartyLocationRecId,urlPartyLocationRecId,postalPartyLocationRecId;
            int64                       emailPartyLocationRoleId,phonePartyLocationRoleId,cellularPartyLocationRoleId,urlPartyLocationRoleId,postalPartyLocationRoleId;
            int64                       emailLocationRecId,emailLocationRoleId,phoneLocationRecId,phoneLocationRoleId,urlLocationRecId,urlLocationRoleId,cellularLocationRecId,cellularLocationRoleId,postalLocationRecId,postalLocationRoleId;
            int64                       addressPhoneLocationId,addressPhoneContactId;
            int64                       addressEmailLocationId,addressEmailContactId;
            int64                       addressUrlLocationId,addressUrlContactId;
            int64                       addressTaxLocationExtId, storeAddressBookId, dirAddressBookPartyId;
            str                         postalLogisticsLocationId, emailLogisticsLocationId, urlLogisticsLocationId, phoneLogisticsLocationId, cellularLogisticsLocationId;
            LogisticsLocationId         addressEmailLogisticsLocationId, addressUrlLogisticsLocationId, addressPhoneLogisticsLocationId;
            int                         fromLine;
            container                   roleContainer;
            str                         addressBookPartyData;
            XmlDocument                 addressBookPartiesXml;
            XmlNode                     addressBookPartiesRoot;
            XmlElement                  addressBookPartyXml;
            DirPartyType                partyType;
            int                         i;
            XmlElement                  xmlElementCustAffiliations;
            XmlDocument                 XmlrootCustAffiliations;
            XmlNodeList                 XmlListCustAffiliations;
            XmlElement                  xmlRecordCustAffiliation;
            RetailCustAffiliation       retailCustAffiliation;
            CustGroup                   theCustGroup;
            RetailExternalIdToCustomerMap externalIdToCustomerMap;
            str                         attributeChangesDataPackage;
            str                         receiptEmailResult;
            MCRCustTable                mcrCustTable, mcrDefaultCustTable;

            try
            {
                fromLine = Global::infologLine();

                if (CustParameters::numRefCustAccount() )
                {
                    ttsbegin;

                    // Get channel's default customer
                    channelDefaultCustomer = CustTable::find(RetailChannelTable::findByRecId(storeRecId).DefaultCustAccount);

                    if (!RetailGetNewCustAccountToggle::instance().isEnabled())
                    {
                        newCustAccount = RetailTransactionServiceCustomer::getNewCustAccount();
                    }
                    else
                    {
                        custGroup = custGroup != '' ? custGroup : channelDefaultCustomer.CustGroup;
                        newCustAccount = RetailTransactionServiceCustomer::getNewCustAccountV2(custGroup);
                    }

                    if (!newCustAccount)
                    {
                        validInsert = false;
                        error = strFmt("Customer creation failed. Captured infolog details: %1", RetailTransactionServiceUtilities::getInfologMessages(fromLine));
                        checkFailed("@Retail:RetailCustAccountNumberSequence");
                        throw Exception::Error;
                    }

                    custTable.clear();
                    custTable.initValue();

                    custTable.AccountNum            = newCustAccount;
                    custTable.CustGroup             = custGroup;
                    custTable.Currency              = currency;
                    custTable.MultiLineDisc         = multiLineDisc;
                    custTable.EndDisc               = endDisc;
                    custTable.LineDisc              = lineDisc;
                    custTable.PriceGroup            = priceGroup;
                    custTable.CreditMax             = creditMax;
                    custTable.Blocked               = blocked;
                    custTable.OrgId                 = orgId;
                    custTable.UsePurchRequest       = usePurchRequest;
                    custTable.vatNum                = vatNum;
                    custTable.InvoiceAccount        = invoiceAccount;
                    custTable.MandatoryCreditLimit  = mandatoryCreditLimit;
                    custTable.ContactPersonId       = contactPersonId;

                    unchecked (Uncheck::TableSecurityPermission)
                    {
                        custTable.IdentificationNumber  = identificationNumber;
                    }

                    // Initialize custTable fields using default channel customer record
                    RetailTransactionServiceCustomer::initCustTableUsingChannelDefaultCustomer(custTable, channelDefaultCustomer);

                    // Initialize few custTable fields, based on CustGroup. If newCustomer() has custGroup as empty, then we get CustGroup from default customer and initialize below properties.
                    // Note: This custGroup check is covered in initCustTableUsingChannelDefaultCustomer().
                    theCustGroup                    = CustGroup::find(custTable.CustGroup);
                    custTable.InclTax               = theCustGroup.PriceIncludeSalesTax; //Use the default PriceIncludeSalesTax from the given CustomerGroup
                    custTable.DefaultDimension      = theCustGroup.DefaultDimension; // Use the default DefaultDimension from the given CustomerGroup

                    // If the following fields are not set, copy them from CustGroup associated with customer.
                    custTable.TaxGroup   = custTable.TaxGroup != '' ? custTable.TaxGroup : theCustGroup.TaxGroupId; // If TaxGroup is not set from default customer, then use the default TaxGroup for the given CustomerGroup
                    custTable.PaymTermId = custTable.PaymTermId != '' ? custTable.PaymTermId : theCustGroup.PaymTermId; // If PaymTermId is not set from default customer, thenCreating the payment terms for the customer, not sent back to RetailEx3
                    custTable.PaymSched  = custTable.PaymSched != '' ?  custTable.PaymSched : PaymTerm::find(custTable.PaymTermId).PaymSched; // If PaymSched is not set from default customer, the payment schedule for the customer, not sent back to RetailEx3

                    // Retrieve the context which stores additional RTS parameters.
                    RetailTransactionServiceCustomerContext context = RetailTransactionServiceCustomerContext::current();

                    // RelationtType values match corresponding DirPartyType Enum values
                    partyType = dirPartyRelationType;

                    if (partyType == DirPartyType::Person)
                    {
                        // backwards compatibility: until the client send the proper values,
                        // use the old system.
                        if (lastName == '')
                        {
                            [firstName, middleName, lastName] = DirPerson::splitNameParts(custName);
                        }

                        person.initValue();
                        person.Name = custName;
                        if (context != null)
                        {
                            person.PersonalTitle = context.parmCustomerTitleRecId();
                        }
                        person.insert();

                        personName = DirPersonName::addNewNameToPerson(person.RecId, firstName, middleName, lastName);

                        //need to retrieve as the name was updated by the addNewName above.
                        partyRecord = DirPartyTable::findRec(person.RecId, true);
                    }
                    else
                    {
                        partyRecord = DirPartyTable::createNew(partyType, custName);
                    }

                    eventSource.EventWriteAddCustomerName(funcName(), partyRecord.RecId);

                    partyRecord.LanguageId = languageId;
                    partyRecord.update();

                    custTable.Party = partyRecord.RecId;

                    // <GBR>
                    #ISOCountryRegionCodes
                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoBR]))
                    {
                        custTable.CustFinalUser_BR      = NoYes::Yes;
                        custTable.ICMSContributor_BR    = NoYes::No;
                        custTable.CNPJCPFNum_BR         = cnpjCpfNum_BR;

                        // Requires custTable.Party already set
                        if (!custTable.validateField(fieldNum(custTable, CNPJCPFNum_BR)))
                        {
                            validInsert = false;
                            error = strFmt("Customer creation failed. Captured infolog details: %1", RetailTransactionServiceUtilities::getInfologMessages(fromLine));
                            // validateField already shows error message at the infolog
                            throw Exception::Error;
                        }
                    }
                    // </GBR>

                    custTable.insert();

                    custRecId = custTable.RecId;

                    eventSource.EventWriteCustomerAddNewRecord(funcName(), custRecId);

                    customer = new CustomerEntity(CustTable::find(newCustAccount), DateTimeUtil::utcNow());

                    if (externalIdentityId != '' && externalIdentityIssuer != '')
                    {
                        // Map the provided external identity information to the newly created customer account.
                        externalIdToCustomerMap = RetailTransactionServiceCustomer::createLinkExternalIdWithCustomer(externalIdentityId, externalIdentityIssuer, newCustAccount, NoYes::Yes);
                    }

                    // Only create a phone record if there is a phone specified
                    if (phone != '')
                    {
                        contactInfoView.clear();
                        contactInfoView.Party = custTable.Party;
                        contactInfoView.Type = LogisticsElectronicAddressMethodType::Phone;
                        contactInfoView.IsPrimary = NoYes::Yes;
                        contactInfoView.Locator   = phone;
                        contactInfoView.LocatorExtension = phoneExtension;

                        updatedContactInfoView = customer.createOrUpdateContactInfo(contactInfoView);

                        phoneContactId = updatedContactInfoView.ElectronicAddress;

                        [phoneLocationRecId, phoneLogisticsLocationId, phonePartyLocationRecId, phoneLocationRoleId, phonePartyLocationRoleId] =
                                RetailTransactionServiceCustomer::getContactInfoData(custTable.Party, phoneContactId);

                        eventSource.EventWriteCustomerAddPhoneRecord(funcName(), phoneContactId);
                    }

                    // Only create an email record if there is an email specified
                    if (email != '')
                    {
                        contactInfoView.clear();
                        contactInfoView.Party = custTable.Party;
                        contactInfoView.Type = LogisticsElectronicAddressMethodType::Email;
                        contactInfoView.IsPrimary = NoYes::Yes;
                        contactInfoView.Locator   = email;

                        updatedContactInfoView = customer.createOrUpdateContactInfo(contactInfoView);

                        emailContactId = updatedContactInfoView.ElectronicAddress;

                        [emailLocationRecId, emailLogisticsLocationId, emailPartyLocationRecId, emailLocationRoleId, emailPartyLocationRoleId] =
                                RetailTransactionServiceCustomer::getContactInfoData(custTable.Party, emailContactId);

                        eventSource.EventWriteCustomerAddEmailRecord(funcName(), emailContactId);
                    }

                    // Only create an url record if there is an url specified
                    if (url != '')
                    {
                        contactInfoView.clear();
                        contactInfoView.Party = custTable.Party;
                        contactInfoView.Type = LogisticsElectronicAddressMethodType::URL;
                        contactInfoView.IsPrimary = NoYes::Yes;
                        contactInfoView.Locator   = url;
                        updatedContactInfoView = customer.createOrUpdateContactInfo(contactInfoView);

                        urlContactId = updatedContactInfoView.ElectronicAddress;

                        [urlLocationRecId, urlLogisticsLocationId, urlPartyLocationRecId, urlLocationRoleId, urlPartyLocationRoleId] =
                                RetailTransactionServiceCustomer::getContactInfoData(custTable.Party, urlContactId);

                        eventSource.EventWriteCustomerAddURLContactRecord(funcName(), urlContactId);
                    }

                    // Only create a cellularPhone record if there is a cellularPhone specified
                    if (cellularPhone != '')
                    {
                        contactInfoView.clear();
                        contactInfoView.Party = custTable.Party;
                        contactInfoView.Type = LogisticsElectronicAddressMethodType::Phone;
                        contactInfoView.IsPrimary = NoYes::No;
                        contactInfoView.Locator   = cellularPhone;
                        contactInfoView.IsMobilePhone = NoYes::Yes;
                        updatedContactInfoView = customer.createOrUpdateContactInfo(contactInfoView);

                        cellularContactId = updatedContactInfoView.ElectronicAddress;

                        [cellularLocationRecId, cellularLogisticsLocationId, cellularPartyLocationRecId, cellularLocationRoleId, cellularPartyLocationRoleId] =
                                RetailTransactionServiceCustomer::getContactInfoData(custTable.Party, cellularContactId);

                        eventSource.EventWriteCustomerAddCellularPhoneRecord(funcName(), cellularContactId);
                    }

                    // Assign address books from the store to the customer.
                    while select AddressBook, AddressBookType from retailStoreAddressBook
                    where retailStoreAddressBook.StoreRecId == storeRecId
                    && retailStoreAddressBook.AddressBookType == RetailAddressBookType::Customer
                    {
                        storeAddressBooksForCustomer += retailStoreAddressBook.AddressBook;
                    }

                    // Validate customer address book value, If the store's customer address book list contains a single address book, use it.
                    // If there are two or more address books, remove those that are also part of the employee address book list.
                    if (AssignAddressBooksFromStoreToCustomerFlight::instance().isEnabled() && conLen(storeAddressBooksForCustomer) >= 2)
                    {
                        // Address books for the store associated with employee.
                        while select AddressBook, AddressBookType from retailStoreAddressBook
                            where retailStoreAddressBook.StoreRecId == storeRecId
                            && retailStoreAddressBook.AddressBookType == RetailAddressBookType::Employee
                        {
                            storeAddressBooksForEmployee += retailStoreAddressBook.AddressBook;
                        }

                        // Remove values from "Customer address book" for customer that are also part of the store's "employee address book" list.
                        for (int j = 1; j <= conLen(storeAddressBooksForCustomer); j++)
                        {
                            DirAddressBookRecId addressBookForCustomer  = conPeek(storeAddressBooksForCustomer, j);

                            if (!conFind(storeAddressBooksForEmployee, addressBookForCustomer ))
                            {
                                storeAddressBooks += addressBookForCustomer;
                            }
                        }

                        // When Store's "Customer address book" and "Employee address book" has identical values.
                        if (conLen(storeAddressBooks) == 0)
                        {
                            storeAddressBooks = storeAddressBooksForCustomer;
                        }
                    }
                    else
                    {
                        storeAddressBooks = storeAddressBooksForCustomer;
                    }

                    // newCustomer - so don't also need to assign address books from party.

                    addressBookPartiesXml = XmlDocument::newBlank('utf-16');
                    addressBookPartiesRoot = addressBookPartiesXml.createElement('ArrayOfAddressBookPartyData');

                    if (conLen(storeAddressBooks) > 0)
                    {
                        DirAddressBookParty::createPartyRelations(partyRecord.RecId, storeAddressBooks);

                        // iterate through al the store address books
                        for (i=1; i <= conLen(storeAddressBooks); i++)
                        {
                            storeAddressBookId = conPeek(storeAddressBooks, i);

                            while select firstOnly RecId, AddressBook from dirAddressBookParty
                            where dirAddressBookParty.Party == partyRecord.RecId
                            && dirAddressBookParty.AddressBook == storeAddressBookId
                            {
                                addressBookPartyXml = addressBookPartiesXml.CreateElement('AddressBookPartyData');
                                addressBookPartyXml.setAttribute('RecordId', int642str(dirAddressBookParty.RecId));
                                addressBookPartyXml.setAttribute('StoreAddressBook', int642str(storeAddressBookId));

                                addressBookPartiesRoot.AppendChild(addressBookPartyXml);
                            }
                        }
                    }

                    addressBookPartiesXml.AppendChild(addressBookPartiesRoot);

                    addressBookPartyData = addressBookPartiesXml.toString();

                    roleContainer = [LogisticsLocationRole::findBytype(addressType).RecId];

                    // Only create a postal address if there is any data for it
                    if (street != '' || city != '' || zipCode != '' || county != '' || country != ''
                    || streetNumber != '' || districtName != '' || buildingCompliment != '')
                    {
                        addressView.Party = custTable.Party;
                        addressView.Street = street;
                        addressView.City = city;
                        addressView.ZipCode = zipCode;
                        addressView.State = state;
                        addressView.County = county;
                        addressView.CountryRegionId = country;
                        addressView.IsPrimary = NoYes::Yes;
                        addressView.ValidFrom = DateTimeUtil::utcNow();
                        addressView.ValidTo = DateTimeUtil::maxValue();
                        addressView.StreetNumber = streetNumber;
                        addressView.DistrictName = districtName;
                        addressView.BuildingCompliment = buildingCompliment;
                        //<GEERU>
                        if (LogisticsPostalAddressUtility::isCountryRegionRU(country))
                        {
                            addressView.CityRecId = RetailTransactionServiceCustomer::getCityRecId_RU(country, state, county, city);
                            addressView.District = RetailTransactionServiceCustomer::getDistrictRecId_RU(country, state, county, addressView.CityRecId, districtName);
                        }
                        //</GEERU>
                        addressView.LocationName = addressName;

                        addressView = customer.createOrUpdatePostalAddress(addressView, roleContainer);
                        postalAddressId = addressView._RecId_LogisticsPostalAddress;

                        if (addressPhone != '')
                        {
                            [addressPhoneLocationId, addressPhoneContactId, addressPhoneLogisticsLocationId] =
                                RetailTransactionServiceCustomer::upsertLogisticsElectronicAddress(0, addressPhone, addressView.Location, LogisticsElectronicAddressMethodType::Phone);
                        }

                        if (addressEmail != '')
                        {
                            [addressEmailLocationId, addressEmailContactId, addressEmailLogisticsLocationId] =
                            RetailTransactionServiceCustomer::upsertLogisticsElectronicAddress(0, addressEmail, addressView.Location, LogisticsElectronicAddressMethodType::Email);
                        }

                        if (addressUrl != '')
                        {
                            [addressUrlLocationId, addressUrlContactId, addressUrlLogisticsLocationId] =
                            RetailTransactionServiceCustomer::upsertLogisticsElectronicAddress(0, addressUrl, addressView.Location, LogisticsElectronicAddressMethodType::URL);
                        }

                        if (addressTaxGroup != '')
                        {
                            select forupdate addressTaxLocationExt where addressTaxLocationExt.Location == addressView.Location;
                            if (addressTaxLocationExt)
                            {
                                addressTaxLocationExt.TaxGroup = addressTaxGroup;
                                addressTaxLocationExt.update();
                            }
                            else
                            {
                                addressTaxLocationExt.initValue();
                                addressTaxLocationExt.Location = addressView.Location;
                                addressTaxLocationExt.TaxGroup = addressTaxGroup;
                                addressTaxLocationExt.insert();
                            }

                            addressTaxLocationExtId = addressTaxLocationExt.RecId;
                        }

                        // For the party, there should be only one primary postal address
                        select Location, Address, RecId from postalAddress where postalAddress.RecId == postalAddressId;
                        postalLocationRecId = postalAddress.Location;

                        select RecId, Party, IsPostalAddress from partyLocation
                        where partyLocation.Party == custTable.Party &&
                              partyLocation.IsPrimary == NoYes::Yes &&
                              partyLocation.IsPostalAddress == NoYes::Yes &&
                              partyLocation.Location == postalAddress.Location;

                        postalPartyLocationRecId = partyLocation.RecId;

                        select RecId, LocationId from location where location.RecId == postalLocationRecId;
                        postalLogisticsLocationId = location.LocationId;

                        select partyLocationRole where partyLocationRole.PartyLocation == postalPartyLocationRecId;
                        postalPartyLocationRoleId = partyLocationRole.RecId;
                        postalLocationRoleId = partyLocationRole.LocationRole;
                    }

                    // Create the Retail Customer Affiliation
                    if (RetailCustAffiliations != '')
                    {
                        XmlrootCustAffiliations = new XmlDocument();
                        XmlrootCustAffiliations.loadXml(retailCustAffiliations);

                        xmlElementCustAffiliations = XmlrootCustAffiliations.getNamedElement('RetailCustAffiliations');

                        XmlListCustAffiliations = xmlElementCustAffiliations.childNodes();

                        if (XmlListCustAffiliations)
                        {
                            for (i=0; i < XmlListCustAffiliations.length(); i++)
                            {
                                xmlRecordCustAffiliation = XmlListCustAffiliations.item(i);

                                if (xmlRecordCustAffiliation)
                                {
                                    retailCustAffiliation.clear();
                                    retailCustAffiliation.CustAccountNum = newCustAccount;
                                    retailCustAffiliation.RetailAffiliationId = str2Int64(xmlRecordCustAffiliation.getAttribute('RetailAffiliationId'));

                                    retailCustAffiliation.insert();

                                    eventSource.EventWriteCreateRetailCustomerAffiliation(funcName(), retailCustAffiliation.RecId);

                                    //Fill the Retail CustAffiliation value to xml
                                    xmlRecordCustAffiliation.setAttribute('CustAccountNum', newCustAccount);
                                    xmlRecordCustAffiliation.setAttribute('RecId', int642str(retailCustAffiliation.RecId));
                                }
                            }
                        }

                        retailCustAffiliations = XmlrootCustAffiliations.toString();
                    }

                    // Get rboCustTable record for channel default customer
                    select receiptEmail, RequiresApproval from defaultRboCustTable
                        where defaultRboCustTable.accountNum == channelDefaultCustomer.AccountNum;

                    rboCustTable.clear();
                    rboCustTable.initValue();
                    rboCustTable.AccountNum              = newCustAccount;
                    rboCustTable.UseOrderNumberReference = useOrderNumberReference;
                    rboCustTable.ReceiptOption           = any2int(receiptOption);// == "" ? 0 : _RBOReceiptOption;

                    // Check feature is enable, so prevent copy receipt from default customer to new customer.
                    if (RetailPreventCopyingReceiptEmailValueFeature::isEnabled())
                    {
                        rboCustTable.ReceiptEmail = receiptEmail;
                    }
                    else
                    {
                        rboCustTable.ReceiptEmail = receiptEmail != '' ? receiptEmail : defaultRboCustTable.ReceiptEmail;
                    }

                    rboCustTable.RequiresApproval        = defaultRboCustTable.RequiresApproval;

                    if (context != null)
                    {
                        rboCustTable.OptOutPersonalization = context.parmOptOutPersonalization();
                        rboCustTable.OptOutWebActivityTracking = context.parmOptOutWebActivityTracking();
                    }

                    rboCustTable.insert();

                    retailCustRecId = rboCustTable.RecId;
                    receiptEmailResult = rboCustTable.receiptEmail;

                    // Create customer attributes
                    if (customerAttributes != '')
                    {
                        Map newAttributeValues = RetailCustomerAttributeHelper::deserializeCustomerAttributes(customerAttributes);
                        attributeChangesDataPackage = RetailCustomerAttributeHelper::createUpdateAttributeValuesOnCustomer(
                        custTable.AccountNum, custTable.DataAreaId, newAttributeValues, storeRecId, custAttributesDataPackageVersion);
                    }

                    // Initialize mcrCustTable fields using default channel customer record
                    mcrDefaultCustTable = MCRCustTable::findByCustAccount(channelDefaultCustomer.AccountNum);

                    mcrCustTable = MCRCustTable::findByCustAccount(newCustAccount);

                    if (!mcrCustTable.RecId)
                    {
                        mcrCustTable.initValue();
                        mcrCustTable.CustTable = custTable.RecId;
                        mcrCustTable.AllowOnAccount = context != null ? context.parmAllowOnAccountPayment() : mcrDefaultCustTable.AllowOnAccount;
                        mcrCustTable.insert();
                    }

                    ttscommit;

                    CustTable customerRecord = CustTable::find(newCustAccount, false);

                    // If dual-write is enabled and the data sync fails, the CustTable record created earlier will be auto-reverted.
                    // This can lead to scenarios where we replicate the "expected" customer record in the channel but the customer no longer exists in AX.
                    // To prevent this, we validate that the customer record still exists.
                    if (customerRecord.RecId == 0)
                    {
                        validInsert = false;
                        error = strFmt("Customer creation failed. Captured infolog details: %1", RetailTransactionServiceUtilities::getInfologMessages(fromLine));
                    }
                }
                else
                {
                    validInsert = false;
                    error = "@RET2446";
                    eventSource.EventWriteCustomerCouldNotGenerateNumberSequence(funcName());
                }
            }
            catch (Exception::DuplicateKeyException)
            {
                ttsabort;
                validInsert = false;
                error =  strFmt("@Retail:DuplicateKeyExceptionForValidateCustomer", custTable.AccountNum);
                str axCallStack = con2Str(xSession::xppCallStack()); // Use AX call stack for Exception::Error
                eventSource.EventWriteNewCustomerDuplicateKeyException(funcName(), axCallStack);
            }
            catch
            {
                ttsabort;
                validInsert = false;
                error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                str axCallStack = con2Str(xSession::xppCallStack()); // Use AX call stack for Exception::Error
                eventSource.EventWriteCustomerNewException(funcName(), axCallStack);
            }

            // IMPORTANT: The containers returned by newCustomer and newCustomerFromDirParty have to be aligned with the same fields.
            return [validInsert, error, newCustAccount, custTable.TaxGroup, custTable.Party, custRecId, retailCustRecId, //0-4
            postalAddressId, postalLocationRecId, postalPartyLocationRecId, postalPartyLocationRoleId, postalLocationRoleId, //5-9
            addressTaxLocationExtId, 0, 0, 0, 0, //10-14
            emailContactId, emailLocationRecId, emailPartyLocationRecId, emailPartyLocationRoleId, emailLocationRoleId, //15-19
            phoneContactId, phoneLocationRecId, phonePartyLocationRecId, phonePartyLocationRoleId, phoneLocationRoleId, //20-24
            urlContactId, urlLocationRecId, urlPartyLocationRecId, urlPartyLocationRoleId, urlLocationRoleId, //25-29
            cellularContactId, cellularLocationRecId, cellularPartyLocationRecId, cellularPartyLocationRoleId, cellularLocationRoleId, //30-34
            addressPhoneContactId, addressPhoneLocationId, addressPhoneLogisticsLocationId, 0, 0, //35-39
            addressEmailContactId, addressEmailLocationId, addressEmailLogisticsLocationId, 0, 0, //40-44
            addressUrlContactId, addressUrlLocationId, addressUrlLogisticsLocationId, 0, 0, //45-49
            partyRecord.PartyNumber, emailLogisticsLocationId, urlLogisticsLocationId, phoneLogisticsLocationId, cellularLogisticsLocationId, //50-54
            storeAddressBookId, dirAddressBookPartyId, postalLogisticsLocationId, personName.RecId, partyRecord.Name, //55-59
            retailCustAffiliations, postalAddress.Address, addressBookPartyData, (custTable.InclTax == NoYes::Yes), //60-63
            externalIdToCustomerMap.RecId, receiptEmailResult, attributeChangesDataPackage, (custTable.MandatoryCreditLimit == NoYes::Yes), // 64-67
            custTable.CreditMax, personName.ValidFrom, // 68-69
            mcrCustTable.RecId, (mcrCustTable.AllowOnAccount == NoYes::Yes), person.PersonalTitle]; // 70-72
        }
        else
        {
            str                         error          = "@RET2445";
            boolean                     validInsert    = false;
            CustTable                   custTable;
            RetailCustTable             rboCustTable, defaultRboCustTable;
            Counter                     infologline    = infolog.num();
            CustAccount                 newCustAccount = '';
            CustTable                   channelDefaultCustomer;
            CustomerEntity              customer = new CustomerEntity(custTable, DateTimeUtil::utcNow());
            DirPartyPostalAddressView   addressView;
            LogisticsLocationExt        addressTaxLocationExt;
            DirPartyContactInfoView     contactInfoView, updatedContactInfoView;
            LogisticsPostalAddress      postalAddress;
            DirPartyLocation            partyLocation;
            DirPartyLocationRole        partyLocationRole;
            LogisticsLocation           location;
            DirPartyTable               partyRecord;
            DirAddressBookParty         dirAddressBookParty;
            DirPerson                   person;
            DirPersonName               personName;
            RetailStoreAddressBook      retailStoreAddressBook;
            container                   storeAddressBooks, storeAddressBooksForCustomer, storeAddressBooksForEmployee;
            int64                       custRecId, retailCustRecId;
            int64                       phoneContactId,cellularContactId,urlContactId,emailContactId,postalAddressId;
            int64                       emailPartyLocationRecId,phonePartyLocationRecId,cellularPartyLocationRecId,urlPartyLocationRecId,postalPartyLocationRecId;
            int64                       emailPartyLocationRoleId,phonePartyLocationRoleId,cellularPartyLocationRoleId,urlPartyLocationRoleId,postalPartyLocationRoleId;
            int64                       emailLocationRecId,emailLocationRoleId,phoneLocationRecId,phoneLocationRoleId,urlLocationRecId,urlLocationRoleId,cellularLocationRecId,cellularLocationRoleId,postalLocationRecId,postalLocationRoleId;
            int64                       addressPhoneLocationId,addressPhoneContactId;
            int64                       addressEmailLocationId,addressEmailContactId;
            int64                       addressUrlLocationId,addressUrlContactId;
            int64                       addressTaxLocationExtId, storeAddressBookId, dirAddressBookPartyId;
            str                         postalLogisticsLocationId, emailLogisticsLocationId, urlLogisticsLocationId, phoneLogisticsLocationId, cellularLogisticsLocationId;
            LogisticsLocationId         addressEmailLogisticsLocationId, addressUrlLogisticsLocationId, addressPhoneLogisticsLocationId;
            int                         fromLine;
            container                   roleContainer;
            str                         addressBookPartyData;
            XmlDocument                 addressBookPartiesXml;
            XmlNode                     addressBookPartiesRoot;
            XmlElement                  addressBookPartyXml;
            DirPartyType                partyType;
            int                         i;
            XmlElement                  xmlElementCustAffiliations;
            XmlDocument                 XmlrootCustAffiliations;
            XmlNodeList                 XmlListCustAffiliations;
            XmlElement                  xmlRecordCustAffiliation;
            RetailCustAffiliation       retailCustAffiliation;
            CustGroup                   theCustGroup;
            RetailExternalIdToCustomerMap externalIdToCustomerMap;
            str                         attributeChangesDataPackage;
            str                         receiptEmailResult;
            MCRCustTable                mcrCustTable, mcrDefaultCustTable;

            try
            {
                fromLine = Global::infologLine();

                if (CustParameters::numRefCustAccount() )
                {
                    ttsbegin;

                    // Get channel's default customer
                    channelDefaultCustomer = CustTable::find(RetailChannelTable::findByRecId(storeRecId).DefaultCustAccount);

                    if (!RetailGetNewCustAccountToggle::instance().isEnabled())
                    {
                        newCustAccount = RetailTransactionServiceCustomer::getNewCustAccount();
                    }
                    else
                    {
                        custGroup = custGroup != '' ? custGroup : channelDefaultCustomer.CustGroup;
                        newCustAccount = RetailTransactionServiceCustomer::getNewCustAccountV2(custGroup);
                    }

                    if (!newCustAccount)
                    {
                        checkFailed("@Retail:RetailCustAccountNumberSequence");
                        throw Exception::Error;
                    }

                    custTable.clear();
                    custTable.initValue();

                    custTable.AccountNum            = newCustAccount;
                    custTable.CustGroup             = custGroup;
                    custTable.Currency              = currency;
                    custTable.MultiLineDisc         = multiLineDisc;
                    custTable.EndDisc               = endDisc;
                    custTable.LineDisc              = lineDisc;
                    custTable.PriceGroup            = priceGroup;
                    custTable.CreditMax             = creditMax;
                    custTable.Blocked               = blocked;
                    custTable.OrgId                 = orgId;
                    custTable.UsePurchRequest       = usePurchRequest;
                    custTable.vatNum                = vatNum;
                    custTable.InvoiceAccount        = invoiceAccount;
                    custTable.MandatoryCreditLimit  = mandatoryCreditLimit;
                    custTable.ContactPersonId       = contactPersonId;

                    unchecked (Uncheck::TableSecurityPermission)
                    {
                        custTable.IdentificationNumber  = identificationNumber;
                    }

                    // Initialize custTable fields using default channel customer record
                    RetailTransactionServiceCustomer::initCustTableUsingChannelDefaultCustomer(custTable, channelDefaultCustomer);

                    // Initialize few custTable fields, based on CustGroup. If newCustomer() has custGroup as empty, then we get CustGroup from default customer and initialize below properties.
                    // Note: This custGroup check is covered in initCustTableUsingChannelDefaultCustomer().
                    theCustGroup                    = CustGroup::find(custTable.CustGroup);
                    custTable.InclTax               = theCustGroup.PriceIncludeSalesTax; //Use the default PriceIncludeSalesTax from the given CustomerGroup
                    custTable.DefaultDimension      = theCustGroup.DefaultDimension; // Use the default DefaultDimension from the given CustomerGroup

                    // If the following fields are not set, copy them from CustGroup associated with customer.
                    custTable.TaxGroup   = custTable.TaxGroup != '' ? custTable.TaxGroup : theCustGroup.TaxGroupId; // If TaxGroup is not set from default customer, then use the default TaxGroup for the given CustomerGroup
                    custTable.PaymTermId = custTable.PaymTermId != '' ? custTable.PaymTermId : theCustGroup.PaymTermId; // If PaymTermId is not set from default customer, thenCreating the payment terms for the customer, not sent back to RetailEx3
                    custTable.PaymSched  = custTable.PaymSched != '' ?  custTable.PaymSched : PaymTerm::find(custTable.PaymTermId).PaymSched; // If PaymSched is not set from default customer, the payment schedule for the customer, not sent back to RetailEx3

                    // Retrieve the context which stores additional RTS parameters.
                    RetailTransactionServiceCustomerContext context = RetailTransactionServiceCustomerContext::current();

                    // RelationtType values match corresponding DirPartyType Enum values
                    partyType = dirPartyRelationType;

                    if (partyType == DirPartyType::Person)
                    {
                        // backwards compatibility: until the client send the proper values,
                        // use the old system.
                        if (lastName == '')
                        {
                            [firstName, middleName, lastName] = DirPerson::splitNameParts(custName);
                        }

                        person.initValue();
                        person.Name = custName;
                        if (context != null)
                        {
                            person.PersonalTitle = context.parmCustomerTitleRecId();
                        }
                        person.insert();

                        personName = DirPersonName::addNewNameToPerson(person.RecId, firstName, middleName, lastName);

                        //need to retrieve as the name was updated by the addNewName above.
                        partyRecord = DirPartyTable::findRec(person.RecId, true);
                    }
                    else
                    {
                        partyRecord = DirPartyTable::createNew(partyType, custName);
                    }

                    eventSource.EventWriteAddCustomerName(funcName(), partyRecord.RecId);

                    partyRecord.LanguageId = languageId;
                    partyRecord.update();

                    custTable.Party = partyRecord.RecId;

                    // <GBR>
                    #ISOCountryRegionCodes
                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoBR]))
                    {
                        custTable.CustFinalUser_BR      = NoYes::Yes;
                        custTable.ICMSContributor_BR    = NoYes::No;
                        custTable.CNPJCPFNum_BR         = cnpjCpfNum_BR;

                        // Requires custTable.Party already set
                        if (!custTable.validateField(fieldNum(custTable, CNPJCPFNum_BR)))
                        {
                            // validateField already shows error message at the infolog
                            throw Exception::Error;
                        }
                    }
                    // </GBR>

                    custTable.insert();

                    custRecId = custTable.RecId;

                    eventSource.EventWriteCustomerAddNewRecord(funcName(), custRecId);

                    customer = new CustomerEntity(CustTable::find(newCustAccount), DateTimeUtil::utcNow());

                    if (externalIdentityId != '' && externalIdentityIssuer != '')
                    {
                        // Map the provided external identity information to the newly created customer account.
                        externalIdToCustomerMap = RetailTransactionServiceCustomer::createLinkExternalIdWithCustomer(externalIdentityId, externalIdentityIssuer, newCustAccount, NoYes::Yes);
                    }

                    // Only create a phone record if there is a phone specified
                    if (phone != '')
                    {
                        contactInfoView.clear();
                        contactInfoView.Party = custTable.Party;
                        contactInfoView.Type = LogisticsElectronicAddressMethodType::Phone;
                        contactInfoView.IsPrimary = NoYes::Yes;
                        contactInfoView.Locator   = phone;
                        contactInfoView.LocatorExtension = phoneExtension;

                        updatedContactInfoView = customer.createOrUpdateContactInfo(contactInfoView);

                        phoneContactId = updatedContactInfoView.ElectronicAddress;

                        [phoneLocationRecId, phoneLogisticsLocationId, phonePartyLocationRecId, phoneLocationRoleId, phonePartyLocationRoleId] =
                                RetailTransactionServiceCustomer::getContactInfoData(custTable.Party, phoneContactId);

                        eventSource.EventWriteCustomerAddPhoneRecord(funcName(), phoneContactId);
                    }

                    // Only create an email record if there is an email specified
                    if (email != '')
                    {
                        contactInfoView.clear();
                        contactInfoView.Party = custTable.Party;
                        contactInfoView.Type = LogisticsElectronicAddressMethodType::Email;
                        contactInfoView.IsPrimary = NoYes::Yes;
                        contactInfoView.Locator   = email;

                        updatedContactInfoView = customer.createOrUpdateContactInfo(contactInfoView);

                        emailContactId = updatedContactInfoView.ElectronicAddress;

                        [emailLocationRecId, emailLogisticsLocationId, emailPartyLocationRecId, emailLocationRoleId, emailPartyLocationRoleId] =
                                RetailTransactionServiceCustomer::getContactInfoData(custTable.Party, emailContactId);

                        eventSource.EventWriteCustomerAddEmailRecord(funcName(), emailContactId);
                    }

                    // Only create an url record if there is an url specified
                    if (url != '')
                    {
                        contactInfoView.clear();
                        contactInfoView.Party = custTable.Party;
                        contactInfoView.Type = LogisticsElectronicAddressMethodType::URL;
                        contactInfoView.IsPrimary = NoYes::Yes;
                        contactInfoView.Locator   = url;
                        updatedContactInfoView = customer.createOrUpdateContactInfo(contactInfoView);

                        urlContactId = updatedContactInfoView.ElectronicAddress;

                        [urlLocationRecId, urlLogisticsLocationId, urlPartyLocationRecId, urlLocationRoleId, urlPartyLocationRoleId] =
                                RetailTransactionServiceCustomer::getContactInfoData(custTable.Party, urlContactId);

                        eventSource.EventWriteCustomerAddURLContactRecord(funcName(), urlContactId);
                    }

                    // Only create a cellularPhone record if there is a cellularPhone specified
                    if (cellularPhone != '')
                    {
                        contactInfoView.clear();
                        contactInfoView.Party = custTable.Party;
                        contactInfoView.Type = LogisticsElectronicAddressMethodType::Phone;
                        contactInfoView.IsPrimary = NoYes::No;
                        contactInfoView.Locator   = cellularPhone;
                        contactInfoView.IsMobilePhone = NoYes::Yes;
                        updatedContactInfoView = customer.createOrUpdateContactInfo(contactInfoView);

                        cellularContactId = updatedContactInfoView.ElectronicAddress;

                        [cellularLocationRecId, cellularLogisticsLocationId, cellularPartyLocationRecId, cellularLocationRoleId, cellularPartyLocationRoleId] =
                                RetailTransactionServiceCustomer::getContactInfoData(custTable.Party, cellularContactId);

                        eventSource.EventWriteCustomerAddCellularPhoneRecord(funcName(), cellularContactId);
                    }

                    // Assign address books from the store to the customer.
                    while select AddressBook, AddressBookType from retailStoreAddressBook
                    where retailStoreAddressBook.StoreRecId == storeRecId
                    && retailStoreAddressBook.AddressBookType == RetailAddressBookType::Customer
                    {
                        storeAddressBooksForCustomer += retailStoreAddressBook.AddressBook;
                    }

                    // Validate customer address book value, If the store's customer address book list contains a single address book, use it.
                    // If there are two or more address books, remove those that are also part of the employee address book list.
                    if (AssignAddressBooksFromStoreToCustomerFlight::instance().isEnabled() && conLen(storeAddressBooksForCustomer) >= 2)
                    {
                        // Address books for the store associated with employee.
                        while select AddressBook, AddressBookType from retailStoreAddressBook
                            where retailStoreAddressBook.StoreRecId == storeRecId
                            && retailStoreAddressBook.AddressBookType == RetailAddressBookType::Employee
                        {
                            storeAddressBooksForEmployee += retailStoreAddressBook.AddressBook;
                        }

                        // Remove values from "Customer address book" for customer that are also part of the store's "employee address book" list.
                        for (int j = 1; j <= conLen(storeAddressBooksForCustomer); j++)
                        {
                            DirAddressBookRecId addressBookForCustomer = conPeek(storeAddressBooksForCustomer, j);

                            if (!conFind(storeAddressBooksForEmployee, addressBookForCustomer))
                            {
                                storeAddressBooks += addressBookForCustomer;
                            }
                        }

                        // When Store's "Customer address book" and "Employee address book" has identical values.
                        if (conLen(storeAddressBooks) == 0)
                        {
                            storeAddressBooks = storeAddressBooksForCustomer;
                        }
                    }
                    else
                    {
                        storeAddressBooks = storeAddressBooksForCustomer;
                    }

                    // newCustomer - so don't also need to assign address books from party.

                    addressBookPartiesXml = XmlDocument::newBlank('utf-16');
                    addressBookPartiesRoot = addressBookPartiesXml.createElement('ArrayOfAddressBookPartyData');

                    if (conLen(storeAddressBooks) > 0)
                    {
                        DirAddressBookParty::createPartyRelations(partyRecord.RecId, storeAddressBooks);

                        // iterate through al the store address books
                        for (i=1; i <= conLen(storeAddressBooks); i++)
                        {
                            storeAddressBookId = conPeek(storeAddressBooks, i);

                            while select firstOnly RecId, AddressBook from dirAddressBookParty
                            where dirAddressBookParty.Party == partyRecord.RecId
                            && dirAddressBookParty.AddressBook == storeAddressBookId
                            {
                                addressBookPartyXml = addressBookPartiesXml.CreateElement('AddressBookPartyData');
                                addressBookPartyXml.setAttribute('RecordId', int642str(dirAddressBookParty.RecId));
                                addressBookPartyXml.setAttribute('StoreAddressBook', int642str(storeAddressBookId));

                                addressBookPartiesRoot.AppendChild(addressBookPartyXml);
                            }
                        }
                    }

                    addressBookPartiesXml.AppendChild(addressBookPartiesRoot);

                    addressBookPartyData = addressBookPartiesXml.toString();

                    roleContainer = [LogisticsLocationRole::findBytype(addressType).RecId];

                    // Only create a postal address if there is any data for it
                    if (street != '' || city != '' || zipCode != '' || county != '' || country != ''
                    || streetNumber != '' || districtName != '' || buildingCompliment != '')
                    {
                        addressView.Party = custTable.Party;
                        addressView.Street = street;
                        addressView.City = city;
                        addressView.ZipCode = zipCode;
                        addressView.State = state;
                        addressView.County = county;
                        addressView.CountryRegionId = country;
                        addressView.IsPrimary = NoYes::Yes;
                        addressView.ValidFrom = DateTimeUtil::utcNow();
                        addressView.ValidTo = DateTimeUtil::maxValue();
                        addressView.StreetNumber = streetNumber;
                        addressView.DistrictName = districtName;
                        addressView.BuildingCompliment = buildingCompliment;
                        //<GEERU>
                        if (LogisticsPostalAddressUtility::isCountryRegionRU(country))
                        {
                            addressView.CityRecId = RetailTransactionServiceCustomer::getCityRecId_RU(country, state, county, city);
                            addressView.District = RetailTransactionServiceCustomer::getDistrictRecId_RU(country, state, county, addressView.CityRecId, districtName);
                        }
                        //</GEERU>
                        addressView.LocationName = addressName;

                        addressView = customer.createOrUpdatePostalAddress(addressView, roleContainer);
                        postalAddressId = addressView._RecId_LogisticsPostalAddress;

                        if (addressPhone != '')
                        {
                            [addressPhoneLocationId, addressPhoneContactId, addressPhoneLogisticsLocationId] =
                                RetailTransactionServiceCustomer::upsertLogisticsElectronicAddress(0, addressPhone, addressView.Location, LogisticsElectronicAddressMethodType::Phone);
                        }

                        if (addressEmail != '')
                        {
                            [addressEmailLocationId, addressEmailContactId, addressEmailLogisticsLocationId] =
                            RetailTransactionServiceCustomer::upsertLogisticsElectronicAddress(0, addressEmail, addressView.Location, LogisticsElectronicAddressMethodType::Email);
                        }

                        if (addressUrl != '')
                        {
                            [addressUrlLocationId, addressUrlContactId, addressUrlLogisticsLocationId] =
                            RetailTransactionServiceCustomer::upsertLogisticsElectronicAddress(0, addressUrl, addressView.Location, LogisticsElectronicAddressMethodType::URL);
                        }

                        if (addressTaxGroup != '')
                        {
                            select forupdate addressTaxLocationExt where addressTaxLocationExt.Location == addressView.Location;
                            if (addressTaxLocationExt)
                            {
                                addressTaxLocationExt.TaxGroup = addressTaxGroup;
                                addressTaxLocationExt.update();
                            }
                            else
                            {
                                addressTaxLocationExt.initValue();
                                addressTaxLocationExt.Location = addressView.Location;
                                addressTaxLocationExt.TaxGroup = addressTaxGroup;
                                addressTaxLocationExt.insert();
                            }

                            addressTaxLocationExtId = addressTaxLocationExt.RecId;
                        }

                        // For the party, there should be only one primary postal address
                        select Location, Address, RecId from postalAddress where postalAddress.RecId == postalAddressId;
                        postalLocationRecId = postalAddress.Location;

                        select RecId, Party, IsPostalAddress from partyLocation
                        where partyLocation.Party == custTable.Party &&
                              partyLocation.IsPrimary == NoYes::Yes &&
                              partyLocation.IsPostalAddress == NoYes::Yes &&
                              partyLocation.Location == postalAddress.Location;

                        postalPartyLocationRecId = partyLocation.RecId;

                        select RecId, LocationId from location where location.RecId == postalLocationRecId;
                        postalLogisticsLocationId = location.LocationId;

                        select partyLocationRole where partyLocationRole.PartyLocation == postalPartyLocationRecId;
                        postalPartyLocationRoleId = partyLocationRole.RecId;
                        postalLocationRoleId = partyLocationRole.LocationRole;
                    }

                    // Create the Retail Customer Affiliation
                    if (RetailCustAffiliations != '')
                    {
                        XmlrootCustAffiliations = new XmlDocument();
                        XmlrootCustAffiliations.loadXml(retailCustAffiliations);

                        xmlElementCustAffiliations = XmlrootCustAffiliations.getNamedElement('RetailCustAffiliations');

                        XmlListCustAffiliations = xmlElementCustAffiliations.childNodes();

                        if (XmlListCustAffiliations)
                        {
                            for (i=0; i < XmlListCustAffiliations.length(); i++)
                            {
                                xmlRecordCustAffiliation = XmlListCustAffiliations.item(i);

                                if (xmlRecordCustAffiliation)
                                {
                                    retailCustAffiliation.clear();
                                    retailCustAffiliation.CustAccountNum = newCustAccount;
                                    retailCustAffiliation.RetailAffiliationId = str2Int64(xmlRecordCustAffiliation.getAttribute('RetailAffiliationId'));

                                    retailCustAffiliation.insert();

                                    eventSource.EventWriteCreateRetailCustomerAffiliation(funcName(), retailCustAffiliation.RecId);

                                    //Fill the Retail CustAffiliation value to xml
                                    xmlRecordCustAffiliation.setAttribute('CustAccountNum', newCustAccount);
                                    xmlRecordCustAffiliation.setAttribute('RecId', int642str(retailCustAffiliation.RecId));
                                }
                            }
                        }

                        retailCustAffiliations = XmlrootCustAffiliations.toString();
                    }

                    // Get rboCustTable record for channel default customer
                    select receiptEmail, RequiresApproval from defaultRboCustTable
                        where defaultRboCustTable.accountNum == channelDefaultCustomer.AccountNum;

                    rboCustTable.clear();
                    rboCustTable.initValue();
                    rboCustTable.AccountNum              = newCustAccount;
                    rboCustTable.UseOrderNumberReference = useOrderNumberReference;
                    rboCustTable.ReceiptOption           = any2int(receiptOption);// == "" ? 0 : _RBOReceiptOption;

                    // Check feature is enable, so prevent copy receipt from default customer to new customer.
                    if (RetailPreventCopyingReceiptEmailValueFeature::isEnabled())
                    {
                        rboCustTable.ReceiptEmail = receiptEmail;
                    }
                    else
                    {
                        rboCustTable.ReceiptEmail = receiptEmail != '' ? receiptEmail : defaultRboCustTable.ReceiptEmail;
                    }

                    rboCustTable.RequiresApproval        = defaultRboCustTable.RequiresApproval;

                    if (context != null)
                    {
                        rboCustTable.OptOutPersonalization = context.parmOptOutPersonalization();
                        rboCustTable.OptOutWebActivityTracking = context.parmOptOutWebActivityTracking();
                    }

                    rboCustTable.insert();

                    retailCustRecId = rboCustTable.RecId;
                    receiptEmailResult = rboCustTable.receiptEmail;

                    // Create customer attributes
                    if (customerAttributes != '')
                    {
                        Map newAttributeValues = RetailCustomerAttributeHelper::deserializeCustomerAttributes(customerAttributes);
                        attributeChangesDataPackage = RetailCustomerAttributeHelper::createUpdateAttributeValuesOnCustomer(
                        custTable.AccountNum, custTable.DataAreaId, newAttributeValues, storeRecId, custAttributesDataPackageVersion);
                    }

                    // Initialize mcrCustTable fields using default channel customer record
                    mcrDefaultCustTable = MCRCustTable::findByCustAccount(channelDefaultCustomer.AccountNum);

                    mcrCustTable = MCRCustTable::findByCustAccount(newCustAccount);

                    if (!mcrCustTable.RecId)
                    {
                        mcrCustTable.initValue();
                        mcrCustTable.CustTable = custTable.RecId;
                        mcrCustTable.AllowOnAccount = context != null ? context.parmAllowOnAccountPayment() : mcrDefaultCustTable.AllowOnAccount;
                        mcrCustTable.insert();
                    }

                    CustTable customerRecord = CustTable::find(newCustAccount, false);

                    // If dual-write is enabled and the data sync fails, the CustTable record created earlier will be auto-reverted.
                    // This can lead to scenarios where we replicate the "expected" customer record in the channel but the customer no longer exists in AX.
                    // To prevent this, we validate that the customer record still exists.
                    if (customerRecord.RecId == 0)
                    {
                        validInsert = false;
                        error = strFmt("Customer creation failed. Captured infolog details: %1", RetailTransactionServiceUtilities::getInfologMessages(fromLine));

                        ttsabort;
                    }
                    else
                    {
                        validInsert = true;
                        error = '';

                        ttscommit;
                    }
                }
                else
                {
                    error = "@RET2446";
                    eventSource.EventWriteCustomerCouldNotGenerateNumberSequence(funcName());
                }
            }
            catch (Exception::DuplicateKeyException)
            {
                ttsabort;
                error =  strFmt("@Retail:DuplicateKeyExceptionForValidateCustomer", custTable.AccountNum);
                str axCallStack = con2Str(xSession::xppCallStack()); // Use AX call stack for Exception::Error
                eventSource.EventWriteNewCustomerDuplicateKeyException(funcName(), axCallStack);
            }
            catch
            {
                ttsabort;
                error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                str axCallStack = con2Str(xSession::xppCallStack()); // Use AX call stack for Exception::Error
                eventSource.EventWriteCustomerNewException(funcName(), axCallStack);
            }

            // IMPORTANT: The containers returned by newCustomer and newCustomerFromDirParty have to be aligned with the same fields.
            return [validInsert, error, newCustAccount, custTable.TaxGroup, custTable.Party, custRecId, retailCustRecId, //0-4
            postalAddressId, postalLocationRecId, postalPartyLocationRecId, postalPartyLocationRoleId, postalLocationRoleId, //5-9
            addressTaxLocationExtId, 0, 0, 0, 0, //10-14
            emailContactId, emailLocationRecId, emailPartyLocationRecId, emailPartyLocationRoleId, emailLocationRoleId, //15-19
            phoneContactId, phoneLocationRecId, phonePartyLocationRecId, phonePartyLocationRoleId, phoneLocationRoleId, //20-24
            urlContactId, urlLocationRecId, urlPartyLocationRecId, urlPartyLocationRoleId, urlLocationRoleId, //25-29
            cellularContactId, cellularLocationRecId, cellularPartyLocationRecId, cellularPartyLocationRoleId, cellularLocationRoleId, //30-34
            addressPhoneContactId, addressPhoneLocationId, addressPhoneLogisticsLocationId, 0, 0, //35-39
            addressEmailContactId, addressEmailLocationId, addressEmailLogisticsLocationId, 0, 0, //40-44
            addressUrlContactId, addressUrlLocationId, addressUrlLogisticsLocationId, 0, 0, //45-49
            partyRecord.PartyNumber, emailLogisticsLocationId, urlLogisticsLocationId, phoneLogisticsLocationId, cellularLogisticsLocationId, //50-54
            storeAddressBookId, dirAddressBookPartyId, postalLogisticsLocationId, personName.RecId, partyRecord.Name, //55-59
            retailCustAffiliations, postalAddress.Address, addressBookPartyData, (custTable.InclTax == NoYes::Yes), //60-63
            externalIdToCustomerMap.RecId, receiptEmailResult, attributeChangesDataPackage, (custTable.MandatoryCreditLimit == NoYes::Yes), // 64-67
            custTable.CreditMax, personName.ValidFrom, // 68-69
            mcrCustTable.RecId, (mcrCustTable.AllowOnAccount == NoYes::Yes), person.PersonalTitle]; // 70-72
        }
        
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLinkExternalIdWithExistingCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for adding the link between an external identifier and a customer account.
    /// </summary>
    /// <param name="externalIdentityId">
    /// The external identity identifier.
    /// </param>
    /// <param name="externalIdentityProviderIssuer">
    /// The external identity provider issuer.
    /// </param>
    /// <param name="customerAccountNumber">
    /// The associated customer account.
    /// </param>
    /// <returns>
    /// Container with result of unlink request.
    /// </returns>
    internal static container createLinkExternalIdWithExistingCustomer(RetailExternalIdentityId externalIdentityId,
                                                                     str externalIdentityProviderIssuer,
                                                                     CustAccount customerAccountNumber)
    {
        str error = '';
        boolean validUpdate = true;
        int fromLine;
        int64 linkRecId;

        try
        {
            fromLine = Global::infologLine();
            RetailExternalIdToCustomerMap createExternalIdToCustomerMapResult = RetailTransactionServiceCustomer::createLinkExternalIdWithCustomer(externalIdentityId, externalIdentityProviderIssuer, customerAccountNumber, NoYes::Yes, NoYes::Yes);

            linkRecId = createExternalIdToCustomerMapResult.RecId;
            if (linkRecId == 0)
            {
                error = "@Retail:CreateExternalIdCustomerLinkCreationFailure";
                validUpdate = false;
            }

        }
        catch (Exception::Error)
        {
            error += RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            // [FLIGHT-BUG]
            // Bug 879256: Customer related RTS didn't handle ttscommit exceptions correctly and returns succeed after ttscommit failure.
            // The flight below is responsible to revert the changes introduced by this Bug 879256 fix.
            if (!RetailCustomerCreateLinkExternalIdWithExistingCustomerRtsRevertFlight::instance().isEnabled())
            {
                validUpdate = false;
            }
        }

        // Passing empty string in 4th item to match the date response with other linking APIs 
        return [validUpdate, error, customerAccountNumber, '', externalIdentityId, externalIdentityProviderIssuer, linkRecId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>initiateLinkExternalIdWithCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for initiating a link between an external identifier and an existing customer account.
    /// </summary>
    /// <param name="emailAddress">
    /// Email address used to look up customer account.
    /// </param>
    /// <param name="activationToken">
    /// The token for activating the link.
    /// </param>
    /// <param name="externalIdentityId">
    /// The external identifier.
    /// </param>
    /// <param name="identityProviderIssuer">
    /// The external identity issuer.
    /// </param>
    /// <param name="customerAccountNumber">
    /// Customer account number.
    /// </param>
    /// <returns>
    /// Container with result of link up request.
    /// </returns>
    public static container initiateLinkExternalIdWithCustomer(    Email    emailAddress,
                                                                   str    activationToken,
                                                                   RetailExternalIdentityId    externalIdentityId,
                                                                   str    identityProviderIssuer,
                                                                   CustAccount    customerAccountNumber)

    {
        str                         error          = "@Retail:UnexpectedError";
        boolean                     validUpdate    = false;
        RetailCustTable             retailCustTable;
        RetailIdentityProvider      retailIdentityProvider;
        RetailExternalIdToCustomerMap createExternalIdToCustomerMapResult;
        RetailExternalIdToCustomerLinkActivationTable linkActivationTable;
        Counter                     infologline    = infolog.num();
        int64                       linkRecId;
        int                         fromLine;
        utcdatetime                 cutOffDateTime;
        str                         errorCode = '';

        try
        {
            fromLine = Global::infologLine();

            ttsbegin;

            createExternalIdToCustomerMapResult = RetailTransactionServiceCustomer::createLinkExternalIdWithCustomer(externalIdentityId, identityProviderIssuer, customerAccountNumber, NoYes::No);

            if (createExternalIdToCustomerMapResult.RecId == 0)
            {
               error = "@Retail:InactiveExternalIdCustomerLinkCreationFailure";
               throw Exception::Error;
            }

            select  forupdate linkActivationTable
                where linkActivationTable.EmailAddress == emailAddress
                && linkActivationTable.ExternalIdentityId == createExternalIdToCustomerMapResult.ExternalIdentityId
                && linkActivationTable.IdentityProviderId == createExternalIdToCustomerMapResult.ProviderId
                && linkActivationTable.CustomerAccountNumber == createExternalIdToCustomerMapResult.CustomerAccountNumber;

            if (linkActivationTable)
            {
                linkActivationTable.LastModifiedDateTime = DateTimeUtil::utcNow();
                linkActivationTable.IsActivated = NoYes::No;
                linkActivationTable.ActivationToken = activationToken;
                linkActivationTable.update();
            }
            else
            {
                linkActivationTable.LastModifiedDateTime = DateTimeUtil::utcNow();
                linkActivationTable.IsActivated = NoYes::No;
                linkActivationTable.EmailAddress = emailAddress;
                linkActivationTable.ActivationToken = activationToken;
                linkActivationTable.ExternalIdentityId = createExternalIdToCustomerMapResult.ExternalIdentityId;
                linkActivationTable.IdentityProviderId = createExternalIdToCustomerMapResult.ProviderId;
                linkActivationTable.CustomerAccountNumber = createExternalIdToCustomerMapResult.CustomerAccountNumber;
                linkActivationTable.insert();
            }

            // Cleaup up all activation requests that have expired.
            // Consider any request that is older than a week as expired.
            cutOffDateTime = DateTimeUtil::addDays(DateTimeUtil::utcNow(), -7);
            delete_from linkActivationTable where linkActivationTable.LastModifiedDateTime < cutOffDateTime;

            ttscommit;

            validUpdate = true;
            error = '';
            errorCode = '';
        }
        catch (Exception::Error)
        {
            ttsabort;

            error += RetailTransactionServiceUtilities::getInfologMessages(fromLine);
        }

        // Returning the status as a container
        return [validUpdate, error, errorCode, emailAddress, externalIdentityId, identityProviderIssuer, createExternalIdToCustomerMapResult.RecId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>finalizeLinkExternalIdWithCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for finalize a link between an external identifier and an existing customer account.
    /// </summary>
    /// <param name="emailAddress">
    /// Email address used to look up customer account.
    /// </param>
    /// <param name="activationToken">
    /// The token for activating the link.
    /// </param>
    /// <returns>
    /// Container with result of link up request.
    /// </returns>
    public static container finalizeLinkExternalIdWithCustomer(    Email    emailAddress,
                                                                   str    activationToken)

    {
        // Constants
        #define.NoPendingExternalIdentityLinkActivationTokenFound('NoPendingExternalIdentityLinkActivationTokenFound');

        str                         error          = "@Retail:UnexpectedError";
        boolean                     validActivate    = false;
        CustAccount                 associatedCustomerAccountNumber;
        RetailIdentityProvider      retailIdentityProvider;
        RetailExternalIdToCustomerMap retailExternalIdToCustomerMap;
        RetailExternalIdToCustomerLinkActivationTable externalIdToCustomerLinkActivationTable;
        RetailExternalIdentityId    externalIdentityId;
        str                         externalIdentityProviderIssuer;
        Counter                     infologline    = infolog.num();
        int64                       linkRecId;
        int                         fromLine;
        str                         errorCode = '';

        try
        {
            fromLine = Global::infologLine();

            ttsbegin;

            select forupdate externalIdToCustomerLinkActivationTable
                where externalIdToCustomerLinkActivationTable.ActivationToken == activationToken
                && externalIdToCustomerLinkActivationTable.EmailAddress == emailAddress
                && externalIdToCustomerLinkActivationTable.IsActivated == NoYes::No;

            if (externalIdToCustomerLinkActivationTable)
            {
                select forupdate retailExternalIdToCustomerMap
                        where retailExternalIdToCustomerMap.ExternalIdentityId == externalIdToCustomerLinkActivationTable.ExternalIdentityId
                         && retailExternalIdToCustomerMap.ProviderId == externalIdToCustomerLinkActivationTable.IdentityProviderId
                        && retailExternalIdToCustomerMap.CustomerAccountNumber == externalIdToCustomerLinkActivationTable.CustomerAccountNumber;

                if (retailExternalIdToCustomerMap)
                {
                    retailExternalIdToCustomerMap.IsActivated = NoYes::Yes;
                    retailExternalIdToCustomerMap.update();
                }
                else
                {
                    error = "@Retail:NoInactiveExternalIdentityForActivationToken";
                    throw Exception::Error;
                }

                linkRecId = retailExternalIdToCustomerMap.RecId;

                select retailIdentityProvider where  retailIdentityProvider.RecId == externalIdToCustomerLinkActivationTable.IdentityProviderId;
                externalIdentityProviderIssuer = retailIdentityProvider.Issuer;

                externalIdentityId = externalIdToCustomerLinkActivationTable.ExternalIdentityId;

                externalIdToCustomerLinkActivationTable.IsActivated = NoYes::Yes;
                externalIdToCustomerLinkActivationTable.update();
            }
            else
            {
                error = "@Retail:NoPendingActivationToken";
                errorCode = #NoPendingExternalIdentityLinkActivationTokenFound;
                throw Exception::Error;
            }

            ttscommit;

            validActivate = true;
            error = '';
            errorCode = '';
        }
        catch (Exception::Error)
        {
            ttsabort;

            error += RetailTransactionServiceUtilities::getInfologMessages(fromLine);
        }

        // Returning the status as a container
        return [validActivate, error, errorCode, emailAddress, externalIdentityId, externalIdentityProviderIssuer, linkRecId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>unlinkExternalIdFromCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for deleting an existing link between an external identifier and a customer account.
    /// </summary>
    /// <param name="externalIdentityId">
    /// The external identifier.
    /// </param>
    /// <param name="externalIdentityProviderIssuer">
    /// The external identity provider issuer.
    /// </param>
    /// <param name="customerAccountNumber">
    /// The associated customer account.
    /// </param>
    /// <returns>
    /// Container with result of link up request.
    /// </returns>
    public static container unlinkExternalIdFromCustomer(    RetailExternalIdentityId    externalIdentityId,
                                                             str    externalIdentityProviderIssuer,
                                                             CustAccount customerAccountNumber)

    {
        str                         error          = "@Retail:UnexpectedError";
        boolean                     validDelete    = false;
        RetailIdentityProvider      retailIdentityProvider;
        RetailExternalIdToCustomerMap retailExternalIdToCustomerMap;
        Counter                     infologline    = infolog.num();
        int64                       linkRecId;
        int                         fromLine;

        try
        {
            fromLine = Global::infologLine();

            select retailIdentityProvider where retailIdentityProvider.Issuer == externalIdentityProviderIssuer;
            if (retailIdentityProvider)
            {
                ttsbegin;

                select forupdate retailExternalIdToCustomerMap
                        where retailExternalIdToCustomerMap.ExternalIdentityId == externalIdentityId
                         && retailExternalIdToCustomerMap.ProviderId == retailIdentityProvider.RecId
                        && retailExternalIdToCustomerMap.CustomerAccountNumber == customerAccountNumber;

                if (retailExternalIdToCustomerMap)
                {
                    linkRecId = retailExternalIdToCustomerMap.RecId;

                    // Set IsUnlinked to True and IsActivated to False.
                    retailExternalIdToCustomerMap.IsUnlinked = NoYes::Yes;
                    retailExternalIdToCustomerMap.IsActivated = NoYes::No;
                    retailExternalIdToCustomerMap.update();
                }
                else
                {
                    error = "@Retail:NoMappingForExternalIdentityCustomerAccountCombination";
                    throw Exception::Error;
                }

                ttscommit;
            }
            else
            {
                error = strFmt("@Retail:InvalidIdentityIdentityProvider", externalIdentityProviderIssuer);
                throw Exception::Error;
            }

            validDelete = true;
            error = '';
        }
        catch (Exception::Error)
        {
            ttsabort;

            error += RetailTransactionServiceUtilities::getInfologMessages(fromLine);
        }

        // Returning the status as a container
        return [validDelete, error, linkRecId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateClientBook</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update client book.
    /// 1. If fromStaffId is null and toStaffId has value, it means adding customer to toStaffId's client book.
    /// 2. If fromStaffId has value and toStaffId is null, it means removing customer from fromStaffId's client book.
    /// 3. If both fromStaffId and toStaffId have values, it means reassigning customer.
    /// </summary>
    /// <param name = "_channelId">
    /// The channel identifier.
    /// </param>
    /// <param name = "_serializedClientBookChanges">
    /// The collection of client book changes in JSON format.
    /// </param>
    /// <returns>
    /// A base 64 encoded CDX package representing the client book update.
    /// </returns>
    public static container updateClientBook(RetailChannelRecId _channelId,
                                             str _serializedClientBookChanges)
    {
        guid correlationId = newGuid();
        boolean isClientBookUpdated = false;
        str error;
        int fromLine;

        RetailCdxDataPackageSerializationHelper serializer;
        str serializedPackage;

        // The RTS is only available if clienteling feature is enabled.
        if (!RetailClientelingFeatureExposure::isEnabled())
        {
            eventSource.EventWriteClientelingFeatureNotEnabled();
            return [false, "@Retail:ClientelingFeatureNotEnabled", ''];
        }

        try
        {
            fromLine = Global::infologLine();

            eventSource.EventWriteClientelingUpdateClientBookStart(correlationId);

            // Initialize CDX package serializer.
            RecId channelSchemaRecId = RetailTransactionServiceUtilities::getChannelSchemaRecId(_channelId);
            serializer = new RetailCdxDataPackageSerializationHelper(channelSchemaRecId);

            // Deserialize client book changes.
            Microsoft.Dynamics.Commerce.Runtime.DataModel.ClientBookChanges clientBookChanges =
                RetailTransactionServiceJsonHelper::DeserializeClientBookChangesFromJSON(_serializedClientBookChanges);
            CLRObject clientBookChangesIterator = clientBookChanges.Changes.GetEnumerator();

            // Initialize temporary tables for adding/removing/reassigning client book customers.
            RetailTmpClientBookChange tmpClientBookChangeForAdding, tmpClientBookChangeForRemoving, tmpClientBookChangeForReassigning;
            RecordInsertList recordInsertListForAdding = new RecordInsertList(
                tableNum(RetailTmpClientBookChange),
                false /* skip insert */, false /* skip database log */, false /* skip events */, false /* skip aos validation */, false /* skip RLS validation */,
                tmpClientBookChangeForAdding);
            RecordInsertList recordInsertListForRemoving = new RecordInsertList(
                tableNum(RetailTmpClientBookChange),
                false /* skip insert */, false /* skip database log */, false /* skip events */, false /* skip aos validation */, false /* skip RLS validation */,
                tmpClientBookChangeForRemoving);
            RecordInsertList recordInsertListForReassigning = new RecordInsertList(
                tableNum(RetailTmpClientBookChange),
                false /* skip insert */, false /* skip database log */, false /* skip events */, false /* skip aos validation */, false /* skip RLS validation */,
                tmpClientBookChangeForReassigning);

            // Loop through client book changes to
            // 1. Add changes to corresponding temporary tables.
            // 2. Validate input changes, including
            //   2.1. the customer to be added does not exist in any client book;
            //   2.2. the customer to be removed exists in some staff's client book.
            // 3. If the destination staff does not have any client book, create one for the staff.
            while (clientBookChangesIterator.MoveNext())
            {
                RetailTmpClientBookChange tmpClientBookChange;
                Microsoft.Dynamics.Commerce.Runtime.DataModel.ClientBookChange clientBookChange = clientBookChangesIterator.get_Current();
                HcmPersonnelNumberId fromStaffId = clientBookChange.FromStaffId;
                HcmPersonnelNumberId toStaffId = clientBookChange.ToStaffId;
                CustAccount custAccountNum = clientBookChange.CustomerId;
                CustTable custTable = CustTable::find(custAccountNum);

                if (!custTable)
                {
                    continue;
                }

                if (fromStaffId != '')
                {
                    HcmWorker fromWorker = HcmWorker::findByPersonnelNumber(fromStaffId);
                    RetailWorkerClientBook fromWorkerClientBook = RetailWorkerClientBook::find(fromWorker.RecId);
                    RetailClientBookCustomer clientBookCustomer = RetailClientBookCustomer::find(custAccountNum, fromWorkerClientBook.ClientBookId);

                    if (!clientBookCustomer)
                    {
                        eventSource.EventWriteClientelingCustomerNotInWorkerClientBook(custTable.RecId, fromWorker.RecId);
                        error = strFmt("@Retail:CustomerNotInWorkerClientBookError", custAccountNum, fromStaffId);
                        throw Exception::Error;
                    }

                    tmpClientBookChange.FromClientBookId = clientBookCustomer.ClientBookId;
                }

                if (toStaffId != '')
                {
                    HcmWorker toWorker = HcmWorker::findByPersonnelNumber(toStaffId);
                    RetailWorkerClientBook toWorkerClientBook = RetailWorkerClientBook::find(toWorker.RecId);

                    // If the distination worker does not have any client book, create one for the worker.
                    if (!toWorkerClientBook)
                    {
                        RetailClientBook clientBook;
                        NumberSequenceTable numberSeqTable = NumberSequenceTable::find(RetailParameters::numRefClientBookId().NumberSequenceId);

                        if (!numberSeqTable.Manual)
                        {
                            clientBook.initValue();
                            clientBook.insert();
                            serializer.writeRecord(clientBook);

                            toWorkerClientBook = RetailWorkerClientBook::assignClientBookToWorker(clientBook.Id, toWorker.RecId);
                            serializer.writeRecord(toWorkerClientBook);
                        }
                        else
                        {
                            SysDictType edtType = new SysDictType(extendedtypenum(RetailClientBookId));
                            throw error(strFmt("@Retail:RetailNumSeqSetupIncorrect", edtType.label()));
                        }
                    }

                    RetailClientBookCustomer clientBookCustomer = RetailClientBookCustomer::find(custAccountNum);
                    if (fromStaffId == '' && clientBookCustomer)
                    {
                        eventSource.EventWriteClientelingCustomerAlreadyExistsInClientBook(custTable.RecId, toWorker.RecId);
                        error = strFmt("@Retail:CustomerAlreadyExistsInClientBookError", custAccountNum, toStaffId);
                        throw Exception::Error;
                    }

                    tmpClientBookChange.ToClientBookId = toWorkerClientBook.ClientBookId;
                }

                tmpClientBookChange.FromStaffId = fromStaffId;
                tmpClientBookChange.ToStaffId = toStaffId;
                tmpClientBookChange.CustAccountNum = custAccountNum;

                // If FromClientBookId is null and ToClientBookId has value, it means adding customer to the client book.
                // If FromClientBookId has value and ToClientBookId is null, it means removing customer from fromStaffId's client book.
                // If both FromClientBookId and ToClientBookId have values, it means reassigning customer.
                if (tmpClientBookChange.FromClientBookId == '' && tmpClientBookChange.ToClientBookId != '')
                {
                    recordInsertListForAdding.add(tmpClientBookChange);
                }
                else if (tmpClientBookChange.FromClientBookId != '' && tmpClientBookChange.ToClientBookId == '')
                {
                    recordInsertListForRemoving.add(tmpClientBookChange);
                }
                else if (tmpClientBookChange.FromClientBookId != '' && tmpClientBookChange.ToClientBookId != '')
                {
                    recordInsertListForReassigning.add(tmpClientBookChange);
                }

                // Add the worker's store to the customer's client book so that the customer will downloaded to the store by CDX.
                if (custTable && toStaffId != '')
                {
                    RetailTransactionServiceCustomer::addPartyToLocalAddressBooks(custTable.Party, _channelId);
                }
            }

            // Insert client book changes to corresponding temporary tables.
            recordInsertListForAdding.insertDatabase();
            recordInsertListForRemoving.insertDatabase();
            recordInsertListForReassigning.insertDatabase();

            // Update client book.
            ttsbegin;

            RetailTransactionServiceCustomer::addCustomersToClientBook(tmpClientBookChangeForAdding, serializer, correlationId);
            RetailTransactionServiceCustomer::removeCustomersFromClientBook(tmpClientBookChangeForRemoving, serializer, correlationId);
            RetailTransactionServiceCustomer::reassignClientBookCustomers(tmpClientBookChangeForReassigning, serializer, correlationId);

            ttscommit;

            serializedPackage = serializer.getBase64EncodedDataPackage();
            isClientBookUpdated = true;

            eventSource.EventWriteClientelingUpdateClientBookEnd(correlationId);
        }
        catch(Exception::Error)
        {
            error += RetailTransactionServiceUtilities::getInfologMessages(fromLine);
        }
        finally
        {
            if (serializer)
            {
                serializer.cleanUp();
                serializer = null;
            }
        }

        return [isClientBookUpdated, error, serializedPackage];
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCustomersToClientBook</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add customers to client book.
    /// </summary>
    /// <param name = "tmpClientBookChangeForAdding">Temporary table which contains the client book changes for adding customers.</param>
    /// <param name = "serializer">CDX package serializer.</param>
    /// <param name = "correlationId">Correlation ID.</param>
    private static void addCustomersToClientBook(
        RetailTmpClientBookChange tmpClientBookChangeForAdding,
        RetailCdxDataPackageSerializationHelper serializer,
        guid correlationId)
    {
        eventSource.EventWriteClientelingAddCustomersToClientBookStart(correlationId);

        RetailClientBookCustomer clientBookCustomer;
        insert_recordset clientBookCustomer(CustAccountNum, ClientBookId)
        select
            CustAccountNum, ToClientBookId
        from tmpClientBookChangeForAdding;

        while select *
            from clientBookCustomer
            join tmpClientBookChangeForAdding
                where tmpClientBookChangeForAdding.CustAccountNum == clientBookCustomer.CustAccountNum && tmpClientBookChangeForAdding.ToClientBookId == clientBookCustomer.ClientBookId
        {
            serializer.writeRecord(clientBookCustomer);
        }

        eventSource.EventWriteClientelingAddCustomersToClientBookEnd(correlationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeCustomersFromClientBook</Name>
				<Source><![CDATA[
    /// <summary>
    /// Remove customers from client book.
    /// </summary>
    /// <param name = "tmpClientBookChangeForRemoving">Temporary table which contains the client book changes for removing customers.</param>
    /// <param name = "serializer">CDX package serializer.</param>
    /// <param name = "correlationId">Correlation ID.</param>
    private static void removeCustomersFromClientBook(
        RetailTmpClientBookChange tmpClientBookChangeForRemoving,
        RetailCdxDataPackageSerializationHelper serializer,
        guid correlationId)
    {
        eventSource.EventWriteClientelingRemoveCustomersFromClientBookStart(correlationId);

        RetailClientBookCustomer clientBookCustomer;
        while select *
            from clientBookCustomer
            join tmpClientBookChangeForRemoving
                where tmpClientBookChangeForRemoving.CustAccountNum == clientBookCustomer.CustAccountNum && tmpClientBookChangeForRemoving.FromClientBookId == clientBookCustomer.ClientBookId
        {
            serializer.writeRemovalRecord(tableName2Id(tableStr(RetailClientBookCustomer)), clientBookCustomer.RecId);
        }

        delete_from clientBookCustomer
            exists join tmpClientBookChangeForRemoving
                where tmpClientBookChangeForRemoving.CustAccountNum == clientBookCustomer.CustAccountNum &&
                      tmpClientBookChangeForRemoving.FromClientBookId == clientBookCustomer.ClientBookId;

        eventSource.EventWriteClientelingRemoveCustomersFromClientBookEnd(correlationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reassignClientBookCustomers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reassign client book customers.
    /// </summary>
    /// <param name = "tmpClientBookChangeForReassigning">Temporary table which contains the client book changes for reassigning.</param>
    /// <param name = "serializer">CDX package serializer.</param>
    /// <param name = "correlationId">Correlation ID.</param>
    private static void reassignClientBookCustomers(
        RetailTmpClientBookChange tmpClientBookChangeForReassigning,
        RetailCdxDataPackageSerializationHelper serializer,
        guid correlationId)
    {
        eventSource.EventWriteClientelingReassignClientBookCustomersStart(correlationId);

        RetailClientBookCustomer clientBookCustomer;
        update_recordset clientBookCustomer
        setting
            ClientBookId = tmpClientBookChangeForReassigning.ToClientBookId
        join tmpClientBookChangeForReassigning
            where tmpClientBookChangeForReassigning.CustAccountNum == clientBookCustomer.CustAccountNum &&
                  tmpClientBookChangeForReassigning.FromClientBookId == clientBookCustomer.ClientBookId;

        while select *
            from clientBookCustomer
            join tmpClientBookChangeForReassigning
                where tmpClientBookChangeForReassigning.CustAccountNum == clientBookCustomer.CustAccountNum && tmpClientBookChangeForReassigning.ToClientBookId == clientBookCustomer.ClientBookId
        {
            serializer.writeRecord(clientBookCustomer);
        }

        eventSource.EventWriteClientelingReassignClientBookCustomersEnd(correlationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustomerFromDirParty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating new customer using existing dirParty record.
    /// </summary>
    /// <param name="dirPartyNumber">
    /// dirParty number.
    /// </param>
    /// <param name="storeRecId">
    /// Store Rec ID
    /// </param>
    /// <param name="cnpjCpfNum_BR">
    /// CNPJ/CPF (Brazilian tax ID).
    /// </param>
    /// <returns>
    /// Container with entity keys
    /// </returns>
    public static container newCustomerFromDirParty(
                DirPartyNumber      dirPartyNumber,
                int64               storeRecId,
                CNPJCPFNum_BR       cnpjCpfNum_BR = '')
    {
        str                         error          = "@RET2445";
        boolean                     validInsert    = false;
        CustTable                   custTable, latestCust;
        CustTable                   channelDefaultCustomer;
        RetailCustTable             rboCustTable, existingRboCustTable;
        Counter                     infologline    = infolog.num();
        CustAccount                 newCustAccount = '';
        DirPartyTable               partyRecord;
        int64                       custRecId, retailCustRecId;
        int64                       phoneContactId,cellularContactId,urlContactId,emailContactId,postalAddressId;
        int64                       emailPartyLocationId,phonePartyLocationId,cellularPartyLocationId,urlPartyLocationId;
        int64                       emailPartyLocationRoleId,phonePartyLocationRoleId,cellularPartyLocationRoleId,urlPartyLocationRoleId,postalPartyLocationRoleId, postalPartyLocationRecId;
        int64                       emailLocationId,emailLocationRoleId,phoneLocationId,phoneLocationRoleId,urlLocationId,urlLocationRoleId,cellularLocationId,cellularLocationRoleId, postalLocationRoleId,postalLocationRecId;
        int64                       addressPhoneLocationId,addressPhoneContactId;
        int64                       addressEmailLocationId,addressEmailContactId;
        int64                       addressUrlLocationId,addressUrlContactId,addressTaxLocationExtId;
        int64                       storeAddressBookId, dirAddressBookPartyId;
        str                         postalLogisticsLocationId, emailLogisticsLocationId, urlLogisticsLocationId, phoneLogisticsLocationId, cellularLogisticsLocationId;
        int                         fromLine;

        DirPerson                   dirPerson;
        DirPersonName               personName;
        CustGroup                   custGroup;
        CustPriceGroup              priceGroup;
        DirPartyLocation            partyLocation;
        DirPartyLocationRole        partyLocationRole;
        LogisticsLocation           location;
        LogisticsPostalAddress      postalAddress;
        LogisticsElectronicAddress  electronicAddress;
        LogisticsLocationExt        addressTaxLocationExt;
        DirPartyPostalAddressView   addressView;
        DirPartyContactInfoView     contactInfoView;

        str streetName, postalCode, state, county, telephone, mobilePhone;
        str email, wwwAddress, multiDiscGroup, totalDiscGroup, lineDiscGroup, salesTaxGroup, orgId, vatNum;
        str receiptEmailAddress, city, identificationNumber, addressNumber, districtName, addressComplement, country;
        str primaryAddressName, primaryAddressTelephone, primaryAddressEmail, primaryAddressURL, primaryAddressSalesTaxGroup;
        int receiptSettings, primaryAddressType = any2int(LogisticsLocationRoleType::None);
        boolean usePurchequest, mandatoryCreditLimit;
        RelationType                relationType;
        CustCreditMaxMST            creditLimit = 0;
        LogisticsLocationId         addressEmailLogisticsLocationId, addressUrlLogisticsLocationId, addressPhoneLogisticsLocationId;
        container                   customerDetails;
        RetailCustAffiliation       retailCustAffiliation;
        str                         retailCustAffiliations;
        XmlDocument                 xmlDocAffiliations;
        XmlElement                  xmlRootAffiliations;
        container                   storeAddressBooks;
        DirAddressBookParty         dirAddressBookParty;
        str                         addressBookPartyData;
        XmlDocument                 addressBookPartiesXml;
        XmlNode                     addressBookPartiesRoot;
        XmlElement                  addressBookPartyXml;
        int                         i;

        try
        {
            fromLine = Global::infologLine();

            partyRecord = DirPartyTable::findByNum(dirPartyNumber);

            // Select customer with the latest information
            select firstonly * from latestCust
                order by latestCust.modifiedDateTime desc
                where latestCust.Party == partyRecord.RecId;

            // If the latest customer record are in current company, we just return the existing
            // customer record rather than creating a new one.
            if (latestCust)
            {
                custTable = latestCust;
                custRecId = custTable.RecId;

                select RecId from existingRboCustTable
                    where existingRboCustTable.accountNum == custTable.AccountNum;

                // If it's not a retail customer, create a RetailCustTable record with default values
                if (!existingRboCustTable)
                {
                    ttsbegin;
                    rboCustTable.clear();
                    rboCustTable.initValue();
                    rboCustTable.AccountNum = custTable.AccountNum;
                    rboCustTable.insert();

                    retailCustRecId = rboCustTable.RecId;
                    ttscommit;
                }
                else
                {
                    retailCustRecId = existingRboCustTable.RecId;
                }

                validInsert = true;
                error = '';
            }
            else
            {
                // generate account number
                if (CustParameters::numRefCustAccount())
                {
                    ttsbegin;

                    // Get channel's default customer.
                    channelDefaultCustomer = CustTable::find(RetailChannelTable::findByRecId(storeRecId).DefaultCustAccount);

                    if (!RetailGetNewCustAccountToggle::instance().isEnabled())
                    {
                        newCustAccount = RetailTransactionServiceCustomer::getNewCustAccount();
                    }
                    else
                    {
                        newCustAccount = RetailTransactionServiceCustomer::getNewCustAccountV2(channelDefaultCustomer.CustGroup);
                    }

                    if (!newCustAccount)
                    {
                        checkFailed("@Retail:RetailCustAccountNumberSequence"); // Customer account number has to be filled in.
                        throw Exception::Error;
                    }

                    custTable.clear();
                    custTable.initValue();

                    custTable.AccountNum = newCustAccount;

                    // Initialize custTable fields using default channel customer record
                    RetailTransactionServiceCustomer::initCustTableUsingChannelDefaultCustomer(custTable, channelDefaultCustomer);

                    // Associate cust account with existing party
                    custTable.Party = partyRecord.RecId;

                    // <GBR>
                    #ISOCountryRegionCodes
                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoBR]))
                    {
                        custTable.CustFinalUser_BR      = NoYes::Yes;
                        custTable.ICMSContributor_BR    = NoYes::No;
                        custTable.CNPJCPFNum_BR         = cnpjCpfNum_BR;

                        // Requires custTable.Party already set
                        if (!custTable.validateField(fieldNum(custTable, CNPJCPFNum_BR)))
                        {
                            // validateField already shows error message at the infolog
                            throw Exception::Error;
                        }
                    }
                    // </GBR>

                    custTable.insert();

                    custRecId = custTable.RecId;

                    ttscommit;

                    storeAddressBooks = RetailTransactionServiceCustomer::addPartyToLocalAddressBooks(partyRecord.RecId, storeRecId);
                    select crosscompany AccountNum, DefaultDimension from latestCust order by latestCust.modifiedDateTime desc
                        where latestCust.Party == partyRecord.RecId && latestCust.RecId != custTable.RecId;

                    select crosscompany * from existingRboCustTable where existingRboCustTable.AccountNum == latestCust.AccountNum 
                        && existingRboCustTable.DataAreaId == latestCust.DataAreaId;

                    // [FLIGHT-BUG]
                    // Bug 725149: City and financial dimensions are not populating while copying customers 
                    //             from one Legal entity to another legal entity.
                    // The flight below is responsible to revert the changes introduced by this Bug 725149 fix.
                    if (latestCust.DefaultDimension && CustMergeDefaultDimensionOnCreationFlight::instance().isEnabled())
                    {
                        ttsbegin;

                        custTable.reread();
                        custTable.selectForUpdate(true);
                        custTable.DefaultDimension = DimensionDefaultFacade::serviceMergeDefaultDimensions(custTable.DefaultDimension, latestCust.DefaultDimension);
                        custTable.update();

                        ttscommit;
                    }

                    try
                    {
                        ttsbegin;
                        rboCustTable.clear();
                        rboCustTable.initValue();
                        rboCustTable.AccountNum              = newCustAccount;

                        if (existingRboCustTable)
                        {
                            rboCustTable.UseOrderNumberReference = existingRboCustTable.useOrderNumberReference;
                            rboCustTable.ReceiptOption           = existingRboCustTable.receiptOption;
                            rboCustTable.ReceiptEmail            = existingRboCustTable.receiptEmail;
                            rboCustTable.RequiresApproval        = existingRboCustTable.requiresApproval;
                            rboCustTable.OptOutPersonalization   = existingRboCustTable.OptOutPersonalization;
                            rboCustTable.OptOutWebActivityTracking = existingRboCustTable.OptOutWebActivityTracking;
                        }
                        else
                        {
                            rboCustTable.UseOrderNumberReference = NoYes::Yes;
                            rboCustTable.ReceiptOption           = 0;
                            rboCustTable.ReceiptEmail            = '';
                            rboCustTable.RequiresApproval        = NoYes::Yes;
                            rboCustTable.OptOutPersonalization   = NoYes::No;
                            rboCustTable.OptOutWebActivityTracking = NoYes::No;
                        }
                        rboCustTable.insert();

                        retailCustRecId = rboCustTable.RecId;
                        ttscommit;

                        validInsert = true;
                        error = '';
                    }
                    catch (Exception::Error)
                    {
                        ttsabort;
                        error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                        str axCallStack = con2Str(xSession::xppCallStack()); // Use AX call stack for Exception::Error
                        eventSource.EventWriteCustomerNewException(funcName(), axCallStack);
                    }
                }
                else
                {
                    error = "@RET2446";
                    eventSource.EventWriteCustomerCouldNotGenerateNumberSequence(funcName());
                }
            }

            addressBookPartiesXml = XmlDocument::newBlank('utf-16');
            addressBookPartiesRoot = addressBookPartiesXml.createElement('ArrayOfAddressBookPartyData');

            if (conLen(storeAddressBooks) > 0)
            {
                // iterate through all the store address books
                for (i=1; i <= conLen(storeAddressBooks); i++)
                {
                    storeAddressBookId = conPeek(storeAddressBooks, i);

                    while select firstOnly RecId, AddressBook from dirAddressBookParty
                                where dirAddressBookParty.Party == partyRecord.RecId
                                && dirAddressBookParty.AddressBook == storeAddressBookId
                    {
                        addressBookPartyXml = addressBookPartiesXml.CreateElement('AddressBookPartyData');
                        addressBookPartyXml.setAttribute('RecordId', int642str(dirAddressBookParty.RecId));
                        addressBookPartyXml.setAttribute('StoreAddressBook', int642str(storeAddressBookId));

                        addressBookPartiesRoot.AppendChild(addressBookPartyXml);
                    }
                }
            }

            addressBookPartiesXml.AppendChild(addressBookPartiesRoot);

            addressBookPartyData = addressBookPartiesXml.toString();

            // For the party, there should be only one primary postal address
            select RecId, Location, Party, IsPostalAddress from partyLocation
                where partyLocation.Party == partyRecord.RecId &&
                      partyLocation.IsPrimary == NoYes::Yes &&
                      partyLocation.IsPostalAddress == NoYes::Yes;

            // For the party, there should be only one primary postal address
            postalLocationRecId = partyLocation.Location;
            postalPartyLocationRecId = partyLocation.RecId;

            select RecId, LocationId from location where location.RecId == postalLocationRecId;
            postalLogisticsLocationId = location.LocationId;

            select RecId, Location from postalAddress where postalAddress.Location == location.RecId;
            postalAddressId = postalAddress.RecId;

            select addressView where addressView.Location == partyLocation.Location;

            select partyLocationRole where partyLocationRole.PartyLocation == postalPartyLocationRecId;
            postalPartyLocationRoleId = partyLocationRole.RecId;
            postalLocationRoleId = partyLocationRole.LocationRole;

            streetName                  = addressView.Street;
            postalCode                  = addressView.ZipCode;
            state                       = addressView.State;
            county                      = addressView.County;
            country                     = addressView.CountryRegionId;
            city                        = addressView.City;
            addressNumber               = addressView.StreetNumber;
            addressComplement           = addressView.BuildingCompliment;
            districtName                = addressView.DistrictName;
            primaryAddressName          = addressView.LocationName;

            select addressTaxLocationExt where addressTaxLocationExt.Location == addressView.Location;
            primaryAddressSalesTaxGroup = addressTaxLocationExt.TaxGroup;

            // Email
            select Party, location, RecId from partyLocation
                where partyLocation.Party == custTable.Party
                join contactInfoView where contactInfoView.Location == partyLocation.Location &&
                        contactInfoView.Type == LogisticsElectronicAddressMethodType::Email &&
                        contactInfoView.IsPrimary == NoYes::Yes;

            select location where location.RecId == partyLocation.Location;
            select partyLocationRole where partyLocationRole.PartyLocation == partyLocation.RecId;

            emailContactId              = contactInfoView.RecId;
            emailPartyLocationId        = partyLocation.RecId;
            emailLocationId             = location.RecId;
            emailPartyLocationRoleId    = partyLocationRole.RecId;
            emailLocationRoleId         = partyLocationRole.LocationRole;
            emailLogisticsLocationId    = location.LocationId;
            email                       = contactInfoView.Locator;

            select partyLocation
                where partyLocation.Party == custTable.Party
                join location where location.ParentLocation == partyLocation.Location &&
                        location.IsPostalAddress == NoYes::No
                join electronicAddress where electronicAddress.Location == location.RecId &&
                        electronicAddress.Type == LogisticsElectronicAddressMethodType::Email &&
                        electronicAddress.IsPrimary == NoYes::Yes;

            addressEmailContactId       = electronicAddress.RecId;
            addressEmailLocationId      = location.RecId;
            addressEmailLogisticsLocationId = location.LocationId;
            primaryAddressEmail         = electronicAddress.Locator;

            // Phone
            select Party, location, RecId from partyLocation
                where partyLocation.Party == custTable.Party
                join contactInfoView where contactInfoView.Location == partyLocation.Location &&
                        contactInfoView.Type == LogisticsElectronicAddressMethodType::Phone &&
                        contactInfoView.IsMobilePhone == NoYes::No &&
                        contactInfoView.IsPrimary == NoYes::Yes;

            select location where location.RecId == partyLocation.Location;
            select partyLocationRole where partyLocationRole.PartyLocation == partyLocation.RecId;

            phoneContactId              = contactInfoView.RecId;
            phonePartyLocationId        = partyLocation.RecId;
            phoneLocationId             = location.RecId;
            phonePartyLocationRoleId    = partyLocationRole.RecId;
            phoneLocationRoleId         = partyLocationRole.LocationRole;
            phoneLogisticsLocationId    = location.LocationId;
            telephone                   = contactInfoView.Locator;

            select partyLocation
                where partyLocation.Party == custTable.Party
                join location where location.ParentLocation == partyLocation.Location &&
                        location.IsPostalAddress == NoYes::No
                join electronicAddress where electronicAddress.Location == location.RecId &&
                        electronicAddress.Type == LogisticsElectronicAddressMethodType::Phone &&
                        electronicAddress.IsPrimary == NoYes::Yes;

            select partyLocationRole where partyLocationRole.PartyLocation == partyLocation.RecId;

            addressPhoneContactId       = electronicAddress.RecId;
            addressPhoneLocationId      = location.RecId;
            addressPhoneLogisticsLocationId = location.LocationId;
            primaryAddressTelephone     = electronicAddress.Locator;

            // URL
            select Party, location, RecId from partyLocation
                where partyLocation.Party == custTable.Party
                join contactInfoView where contactInfoView.Location == partyLocation.Location &&
                        contactInfoView.Type == LogisticsElectronicAddressMethodType::URL &&
                        contactInfoView.IsPrimary == NoYes::Yes;

            select location where location.RecId == partyLocation.Location;
            select partyLocationRole where partyLocationRole.PartyLocation == partyLocation.RecId;

            urlContactId                = contactInfoView.RecId;
            urlPartyLocationId          = partyLocation.RecId;
            urlLocationId               = location.RecId;
            urlPartyLocationRoleId      = partyLocationRole.RecId;
            urlLocationRoleId           = partyLocationRole.LocationRole;
            urlLogisticsLocationId      = location.LocationId;
            wwwAddress                  = contactInfoView.Locator;

            select partyLocation
                where partyLocation.Party == custTable.Party
                join location where location.ParentLocation == partyLocation.Location &&
                        location.IsPostalAddress == NoYes::No
                join electronicAddress where electronicAddress.Location == location.RecId &&
                        electronicAddress.Type == LogisticsElectronicAddressMethodType::URL &&
                        electronicAddress.IsPrimary == NoYes::Yes;

            select partyLocationRole where partyLocationRole.PartyLocation == partyLocation.RecId;

            addressUrlContactId         = electronicAddress.RecId;
            addressUrlLocationId        = location.RecId;
            addressUrlLogisticsLocationId        = location.LocationId;
            primaryAddressURL           = electronicAddress.Locator;

            // Mobile phone
            select Party, location, RecId from partyLocation
                where partyLocation.Party == custTable.Party
                join contactInfoView where contactInfoView.Location == partyLocation.Location &&
                        contactInfoView.Type == LogisticsElectronicAddressMethodType::Phone &&
                        contactInfoView.IsMobilePhone == NoYes::Yes &&
                        contactInfoView.IsPrimary == NoYes::Yes;

            select LocationId, RecId from location where location.RecId == partyLocation.Location;

            select partyLocationRole where partyLocationRole.PartyLocation == partyLocation.RecId;

            cellularContactId           = contactInfoView.RecId;
            cellularPartyLocationId     = partyLocation.RecId;
            cellularLocationId          = location.RecId;
            cellularPartyLocationRoleId = partyLocationRole.RecId;
            cellularLocationRoleId      = partyLocationRole.LocationRole;
            cellularLogisticsLocationId = location.LocationId;
            mobilePhone                 = contactInfoView.Locator;

            select firstOnly RecId from addressTaxLocationExt where addressTaxLocationExt.Location == addressView.Location;
            addressTaxLocationExtId     = addressTaxLocationExt.RecId;

            custGroup = custGroup::find(custTable.CustGroup);

            select rboCustTable
                where rboCustTable.accountNum == custTable.AccountNum;

            multiDiscGroup = custTable.MultiLineDisc;
            totalDiscGroup = custTable.EndDisc;
            lineDiscGroup = custTable.LineDisc;
            priceGroup = custTable.PriceGroup;
            salesTaxGroup = custTable.TaxGroup;
            receiptSettings = rboCustTable.receiptOption;
            if (rboCustTable.receiptEmail == '')
            {
                ttsBegin;
                rboCustTable = RetailCustTable::find(custTable.AccountNum, true);
                rboCustTable.receiptEmail = email;
                rboCustTable.update();
                ttsCommit;
            }

            receiptEmailAddress = rboCustTable.receiptEmail;
            creditLimit = custTable.CreditMax;
            orgId = custTable.OrgId;
            vatNum = custTable.getPrimaryRegistrationNumber(TaxRegistrationTypesList::TAXID);
            mandatoryCreditLimit = custTable.MandatoryCreditLimit;
            usePurchequest = custTable.usePurchRequest;
            relationType = partyRecord.InstanceRelationType;

            unchecked (Uncheck::TableSecurityPermission)
            {
                identificationNumber = custTable.IdentificationNumber;
            }

            // Customer Affiliations
            xmlDocAffiliations = XmlDocument::newBlank();
            xmlRootAffiliations = xmlDocAffiliations.createElement('RetailCustAffiliations');

            while select * from retailCustAffiliation
                where retailCustAffiliation.CustAccountNum == custTable.AccountNum
            {
                xmlRootAffiliations.appendChild(RetailTransactionServiceCustomer::getRetailCustAffiliationXml(xmlDocAffiliations, retailCustAffiliation));
            }
            xmlDocAffiliations.appendChild(xmlRootAffiliations);

            retailCustAffiliations = xmlDocAffiliations.toString();
        }
        catch (Exception::Error)
        {
            ttsabort;
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            str axCallStack = con2Str(xSession::xppCallStack()); // Use AX call stack for Exception::Error
            eventSource.EventWriteCustomerNewException(funcName(), axCallStack);
        }

        select personName where personName.Person == partyRecord.RecId;

        // we need this innner container to be able to return more than the container size limit of 100.
        customerDetails = [partyRecord.Name, partyRecord.NameAlias, personName.FirstName, personName.MiddleName, personName.LastName, custTable.CustGroup, // 0-5
                custTable.Currency, partyRecord.LanguageId, streetName, postalCode, state, county, // 6-11
                telephone, mobilePhone, email, wwwAddress, // 12-15
                multiDiscGroup, totalDiscGroup, lineDiscGroup, priceGroup, salesTaxGroup, orgId, vatNum, city, // 16-23
                identificationNumber, addressNumber, districtName, addressComplement, // 24-27
                primaryAddressName, primaryAddressTelephone, primaryAddressEmail, // 28-30
                primaryAddressURL, primaryAddressSalesTaxGroup, receiptSettings, relationType, primaryAddressType, // 31-35
                usePurchequest, mandatoryCreditLimit, creditLimit, country]; // 36-39

        dirPerson = DirPerson::find(partyRecord.RecId, true);

        // IMPORTANT: The containers returned by newCustomer and newCustomerFromDirParty have to be aligned with the same fields.
        return [validInsert, error, custTable.AccountNum, custTable.TaxGroup,
                // numbers from comments are relative to new customer indexes
                custTable.Party, custRecId, retailCustRecId, //2-4
                postalAddressId, postalLocationRecId, postalPartyLocationRecId, postalPartyLocationRoleId, postalLocationRoleId, //5-9
                addressTaxLocationExtId, 0, 0, 0, 0, //10-14
                emailContactId, emailLocationId, emailPartyLocationId, emailPartyLocationRoleId, emailLocationRoleId,   //15-19
                phoneContactId, phoneLocationId, phonePartyLocationId, phonePartyLocationRoleId, phoneLocationRoleId, //20-24
                urlContactId, urlLocationId, urlPartyLocationId, urlPartyLocationRoleId, urlLocationRoleId, //25-29
                cellularContactId, cellularLocationId, cellularPartyLocationId, cellularPartyLocationRoleId, cellularLocationRoleId, //30-34
                addressPhoneContactId, addressPhoneLocationId, addressPhoneLogisticsLocationId, 0, 0, //35-39
                addressEmailContactId, addressEmailLocationId, addressEmailLogisticsLocationId, 0, 0, //40-44
                addressUrlContactId, addressUrlLocationId, addressUrlLogisticsLocationId, postalLogisticsLocationId, 0, //45-49
                partyRecord.PartyNumber, emailLogisticsLocationId, urlLogisticsLocationId, phoneLogisticsLocationId, cellularLogisticsLocationId, //50-54
                storeAddressBookId, dirAddressBookPartyId, postalLogisticsLocationId, personName.RecId, partyRecord.Name, retailCustAffiliations, postalAddress.Address, //55-61
                addressBookPartyData, (custTable.InclTax == NoYes::Yes), customerDetails, receiptEmailAddress, 0, (custTable.MandatoryCreditLimit == NoYes::Yes), custTable.CreditMax, PersonName.ValidFrom, //62-69
                0, 0, dirPerson.PersonalTitle]; //70-72
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update address
    /// </summary>
    /// <param name="addressRecId">
    /// Address RecId
    /// </param>
    /// <param name="custName">
    /// Customer Name
    /// </param>
    /// <param name="street">
    /// Street
    /// </param>
    /// <param name="city">
    /// City
    /// </param>
    /// <param name="county">
    /// County
    /// </param>
    /// <param name="state">
    /// State
    /// </param>
    /// <param name="zip">
    /// Zip
    /// </param>
    /// <param name="country">
    /// Country
    /// </param>
    /// <param name="phone">
    /// Phone
    /// </param>
    /// <param name="email">
    /// Email
    /// </param>
    /// <param name="url">
    /// URL
    /// </param>
    /// <param name="taxGroup">
    /// Tax group
    /// </param>
    /// <param name="role">
    /// Role
    /// </param>
    /// <param name="phoneRecId">
    /// Phone RecId
    /// </param>
    /// <param name="emailRecId">
    /// Email RecId
    /// </param>
    /// <param name="urlRecId">
    /// URL RecId
    /// </param>
    /// <param name="streetNumber">
    /// Street Number
    /// </param>
    /// <param name="districtName">
    /// District Name
    /// </param>
    /// <param name="buildingCompliment">
    /// Building Complement
    /// </param>
    /// <param name="makePostalAddressPrimary">
    /// Optional. True if this should become the new primary address
    /// </param>
    /// <param name="custPartyNumber">
    /// The customer party number.
    /// </param>
    /// <returns>
    /// A container with entity keys
    /// </returns>
    /// <remarks>
    /// Original parameter list consisted of a single _paramList parameter of type container.
    /// </remarks>
    public static container updateAddress(  RefRecId                    addressRecId,
                                            CustName                    custName,
                                            AddressStreet               street,
                                            AddressCity                 city,
                                            AddressCountyId             county,
                                            AddressStateId              state,
                                            AddressZipCodeId            zip,
                                            AddressCountryRegionId      country,
                                            Phone                       phone,
                                            LogisticsElectronicAddressLocator  email,
                                            URL                         url,
                                            TaxGroup                    taxGroup,
                                            LogisticsLocationRoleType   role = LogisticsLocationRoleType::Other,
                                            int64                       phoneRecId = 0,
                                            int64                       emailRecId = 0,
                                            int64                       urlRecId = 0,
                                            LogisticsAddressStreetNumber        streetNumber        = '',
                                            LogisticsAddressDistrictName        districtName        = '',
                                            LogisticsAddressBuildingCompliment  buildingCompliment  = '',
                                            boolean                     makePostalAddressPrimary    = false,
                                            RecId                       custPartyNumber             = 0)
    {
        return RetailTransactionServiceCustomer::updateAddressExt(
            addressRecId,
            custName,
            street,
            city,
            county,
            state,
            zip,
            country,
            phone,
            email,
            url,
            taxGroup,
            role,
            phoneRecId,
            emailRecId,
            urlRecId,
            streetNumber,
            districtName,
            buildingCompliment,
            makePostalAddressPrimary,
            custPartyNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAddressExt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update address
    /// </summary>
    /// <param name="addressRecId">
    /// Address RecId
    /// </param>
    /// <param name="custName">
    /// Customer Name
    /// </param>
    /// <param name="street">
    /// Street
    /// </param>
    /// <param name="city">
    /// City
    /// </param>
    /// <param name="county">
    /// County
    /// </param>
    /// <param name="state">
    /// State
    /// </param>
    /// <param name="zip">
    /// Zip
    /// </param>
    /// <param name="country">
    /// Country
    /// </param>
    /// <param name="phone">
    /// Phone
    /// </param>
    /// <param name="email">
    /// Email
    /// </param>
    /// <param name="url">
    /// URL
    /// </param>
    /// <param name="taxGroup">
    /// Tax group
    /// </param>
    /// <param name="role">
    /// Role
    /// </param>
    /// <param name="phoneRecId">
    /// Phone RecId
    /// </param>
    /// <param name="emailRecId">
    /// Email RecId
    /// </param>
    /// <param name="urlRecId">
    /// URL RecId
    /// </param>
    /// <param name="streetNumber">
    /// Street Number
    /// </param>
    /// <param name="districtName">
    /// District Name
    /// </param>
    /// <param name="buildingCompliment">
    /// Building Complement
    /// </param>
    /// <param name="makePostalAddressPrimary">
    /// Optional. True if this should become the new primary address
    /// </param>
    /// <param name="custPartyNumber">
    /// The customer party number.
    /// </param>
    /// <param name="extensionProperties">
    /// Optional. Extension properties XML.
    /// </param>
    /// <returns>
    /// A container with entity keys
    /// </returns>
    /// <remarks>
    /// Original parameter list consisted of a single _paramList parameter of type container.
    /// </remarks>
    public static container updateAddressExt(  RefRecId                    addressRecId,
                                            CustName                    custName,
                                            AddressStreet               street,
                                            AddressCity                 city,
                                            AddressCountyId             county,
                                            AddressStateId              state,
                                            AddressZipCodeId            zip,
                                            AddressCountryRegionId      country,
                                            Phone                       phone,
                                            LogisticsElectronicAddressLocator  email,
                                            URL                         url,
                                            TaxGroup                    taxGroup,
                                            LogisticsLocationRoleType   role = LogisticsLocationRoleType::Other,
                                            int64                       phoneRecId = 0,
                                            int64                       emailRecId = 0,
                                            int64                       urlRecId = 0,
                                            LogisticsAddressStreetNumber        streetNumber        = '',
                                            LogisticsAddressDistrictName        districtName        = '',
                                            LogisticsAddressBuildingCompliment  buildingCompliment  = '',
                                            boolean                     makePostalAddressPrimary    = false,
                                            RecId                       custPartyNumber             = 0,
                                            str                         extensionProperties = '')
    {
        str                         error          = "@RET2445";
        boolean                     validUpdate    = false;
        LogisticsPostalAddress      address;
        Counter                     infologline    = infolog.num();
        boolean                     replaceRoles    = true;

        int64                       addressLocationRecId;
        LogisticsLocation           postalLocation;
        LogisticsLocationExt        taxLocationExt;
        DirPartyRecId               parentParty;
        DirPartyLocation            partyLocation;
        DirPartyLocationRole        partyLocationRole;
        int64                       phoneContactId,urlContactId,emailContactId, postalLocationRoleId;
        RecId                       emailLocationRecId,phoneLocationRecId,urlLocationRecId, taxLocationExtId, postalPartyLocationId, postalPartyLocationRoleId ;
        LogisticsLocationId         emailLocationId,phoneLocationId,urlLocationId;
        int                         fromLine;
        RecId                       locationRoleRecId;
        RecId                       logisticsLocationRoleRecordId;

        try
        {
            fromLine = Global::infologLine();

            address = LogisticsPostalAddress::findRecId(addressRecId, true);

            if (address)
            {
                ttsbegin;

                address.Street          = street;
                address.City            = city;
                address.County          = county;
                address.State           = state;
                address.ZipCode         = zip;
                address.CountryRegionId = country;
                address.StreetNumber        = streetNumber;
                address.DistrictName        = districtName;
                address.BuildingCompliment  = buildingCompliment;

                var addressStringBuilderParameters = LogisticsPostalAddressStringBuilderParameters::constructFromLogisticsPostalAddress(address);
                address.Address = LogisticsPostalAddressStringBuilder::buildAddressStringFromParameters(addressStringBuilderParameters);

                address.validTimeStateUpdateMode(ValidTimeStateUpdate::CreateNewTimePeriod);

                RetailTransactionServiceCustomerExtensions::beforeAddressUpdate(address, extensionProperties);

                // Because update mode is CreateNewTimePeriod, a new record will be created if address is modified. The ValidFrom of the new record will be the time when this line is executed.
                address.update();

                // If the validFrom period has been provided and new record is created then manually set the valid time of old and new address records to prevent a TimePeriodValidation error.
                if (extendedParameters.createUpdateAddress_ValidFrom != DateTimeUtil::minValue() && address.RecId != addressRecId)
                {
                    LogisticsPostalAddress oldAddress = LogisticsPostalAddress::findRecId(addressRecId, true);
                    oldAddress.ValidTo = DateTimeUtil::addSeconds(extendedParameters.createUpdateAddress_ValidFrom, -1);
                    oldAddress.validTimeStateUpdateMode(ValidTimeStateUpdate::Correction);
                    oldAddress.update();

                    address.ValidFrom = extendedParameters.createUpdateAddress_ValidFrom;
                    address.validTimeStateUpdateMode(ValidTimeStateUpdate::Correction);
                    address.update();
                }

                addressRecId = address.RecId;

                addressLocationRecId = address.Location;

                if (custPartyNumber == 0)
                {
                    select Location, RecId, Party from  partyLocation where partyLocation.Location == addressLocationRecId;
                }
                else
                {
                    select Location, RecId, Party from  partyLocation where partyLocation.Location == addressLocationRecId && partyLocation.Party == custPartyNumber;
                }

                parentParty = partyLocation.Party;
                // If role's RecId is not given, fallback to previous logic of finding by role type only
                logisticsLocationRoleRecordId = extendedParameters.updateAddress_logisticsLocationRoleRecordId;
                locationRoleRecId = logisticsLocationRoleRecordId == 0 ? LogisticsLocationRole::findBytype(role).RecId : logisticsLocationRoleRecordId;

                // Get partyLocationRole record for partylocation and locationrole.
                select firstonly partyLocationRole
                    where partyLocationRole.PartyLocation == partyLocation.RecId
                    && partyLocationRole.LocationRole == locationRoleRecId;

                // If partyLocationRole has record, then will set replaceRoles as "false" which control the delete record functionality for DirPartyLocationRole.
                if (partyLocationRole.RecId)
                {
                    replaceRoles = false;
                }

                if (locationRoleRecId)
                {
                    DirPartyLocationRole::createPartyLocationRoles(partyLocation.RecId, [locationRoleRecId], replaceRoles);
                }

                select firstonly partyLocationRole
                    where partyLocationRole.PartyLocation == partyLocation.RecId
                    && partyLocationRole.LocationRole == locationRoleRecId;

                postalPartyLocationId = partyLocation.RecId;
                postalPartyLocationRoleId = partyLocationRole.RecId;
                postalLocationRoleId = partyLocationRole.LocationRole;

                select forupdate postalLocation where postalLocation.RecId == address.Location;
                postalLocation.Description = custName;
                postalLocation.update();

                // set as new primary if needed
                if (partyLocation && makePostalAddressPrimary)
                {
                    // fetch full record, set as primary, and update, evicting previous primary
                    partyLocation = DirPartyLocation::findRec(partyLocation.RecId, true);
                    partyLocation.IsPrimary = NoYes::Yes;
                    partyLocation.updatePrimaryLocation();
                    partyLocation.update();
                }

                if (phone != '')
                {
                    [phoneLocationRecId, phoneContactId, phoneLocationId] = RetailTransactionServiceCustomer::upsertLogisticsElectronicAddress(
                                phoneRecId,
                                phone,
                                addressLocationRecId,
                                LogisticsElectronicAddressMethodType::Phone
                                );
                }

                if (email != '')
                {
                    [emailLocationRecId, emailContactId, emailLocationId] = RetailTransactionServiceCustomer::upsertLogisticsElectronicAddress(
                                emailRecId,
                                email,
                                addressLocationRecId,
                                LogisticsElectronicAddressMethodType::Email);
                }

                if (URL != '')
                {
                    [urlLocationRecId, urlContactId, urlLocationId] = RetailTransactionServiceCustomer::upsertLogisticsElectronicAddress(
                                urlRecId,
                                url,
                                addressLocationRecId,
                                LogisticsElectronicAddressMethodType::URL);
                }

                delete_from taxLocationExt where taxLocationExt.Location == addressLocationRecId;

                if (taxGroup != '')
                {
                    select forupdate taxLocationExt where taxLocationExt.Location == address.Location;
                    if (taxLocationExt)
                    {
                        taxLocationExt.TaxGroup = taxGroup;
                        taxLocationExt.update();
                    }
                    else
                    {
                        taxLocationExt.initValue();
                        taxLocationExt.Location = address.Location;
                        taxLocationExt.TaxGroup = taxGroup;
                        taxLocationExt.insert();
                    }

                    taxLocationExtId = taxLocationExt.RecId;
                }

                ttscommit;
                validUpdate = true;
                error = '';

                eventSource.EventWriteCustomerAddressRecordUpdated(funcName(), addressRecId);
            }

            else
            {
                eventSource.EventWriteCustomerAddressRecordNotExist(funcName(), addressRecId);
                error = "@RET5166";
            }
        }
        catch (Exception::Error)
        {
            ttsabort;
            error = conPeek(conPeek(infolog.copy(infologline +1,infolog.num()),2),2);
            str axCallStack = con2Str(xSession::xppCallStack()); // Use AX call stack for Exception::Error
            eventSource.EventWriteCustomerUpdateAddressException(funcName(), axCallStack);
        }

        // Returning the status as a container
        return [validUpdate, error,
                partyLocation.Party, 0, 0, //0-2
                addressRecId, addressLocationRecId, postalPartyLocationId, postalPartyLocationRoleId, postalLocationRoleId, //3-7
                taxLocationExtId, 0, 0, 0, 0, //8-12
                emailContactId, emailLocationRecId, emailLocationId, 0, 0,  //13-17
                phoneContactId, phoneLocationRecId, phoneLocationId, 0, 0,  //18-22
                urlContactId, urlLocationRecId, urlLocationId, 0, 0,      //23-27
                0, 0, 0, 0, 0, postalLocation.LocationId, address.Address, //28-34
                taxGroup, 0, address.ValidFrom]; // 35-37
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for updating an existing customer.
    /// </summary>
    /// <param name="custTableRecId">
    /// CustTable RecId.
    /// </param>
    /// <param name="custName">
    /// Customer Name.
    /// </param>
    /// <param name="custGroup">
    /// Customer group
    /// </param>
    /// <param name="currency">
    /// Currency
    /// </param>
    /// <param name="languageId">
    /// Language ID
    /// </param>
    /// <param name="phone">
    /// Phone
    /// </param>
    /// <param name="phoneRecId">
    /// Phone recid
    /// </param>
    /// <param name="cellularPhone">
    /// Cell phone
    /// </param>
    /// <param name="email">
    /// Email
    /// </param>
    /// <param name="emailRecId">
    /// Email recid
    /// </param>
    /// <param name="url">
    /// URL
    /// </param>
    /// <param name="urlRecId">
    /// Url recid
    /// </param>
    /// <param name="multiLineDisc">
    /// Multiline discount
    /// </param>
    /// <param name="endDisc">
    /// End discount
    /// </param>
    /// <param name="lineDisc">
    /// Line discount
    /// </param>
    /// <param name="priceGroup">
    /// Price Group
    /// </param>
    /// <param name="taxGroup">
    /// Tax Group
    /// </param>
    /// <param name="creditMax">
    /// Credit Max
    /// </param>
    /// <param name="blocked">
    /// Blocked
    /// </param>
    /// <param name="orgId">
    /// Org ID
    /// </param>
    /// <param name="usePurchRequest">
    /// Use purchase request
    /// </param>
    /// <param name="vatNum">
    /// Vat Number
    /// </param>
    /// <param name="invoiceAccount">
    /// Invoice account
    /// </param>
    /// <param name="mandatoryCreditLimit">
    /// Mandotory credit limit
    /// </param>
    /// <param name="contactPersonId">
    /// Contact person ID
    /// </param>
    /// <param name="useOrderNumberReference">
    /// Use order number reference
    /// </param>
    /// <param name="receiptOption">
    /// Receipt option
    /// </param>
    /// <param name="receiptEmail">
    /// Receipt Email
    /// </param>
    /// <param name="identificationNumber">
    /// Identification Number
    /// </param>
    /// <param name="firstName">
    /// First name
    /// </param>
    /// <param name="middleName">
    /// Middle name
    /// </param>
    /// <param name="lastName">
    /// Last name
    /// </param>
    /// <param name="phoneExtension">
    /// Phone extension
    /// </param>
    /// <param name="cellphoneRecId">
    /// Cell phone record id
    /// </param>
    /// <param name="retailCustAffiliations">
    /// A XML string having the details of customer affiliation list
    /// </param>
    /// <param name="customerAttributes">
    /// Optional. An XML string having the details of customer attributes.
    /// </param>
    /// <param name="storeRecId">
    /// Optional. A store record identifier.
    /// </param>
    /// <param name="custAttributesDataPackageVersion">
    /// Optional. The customer attributes data package version.
    /// </param>
    /// <returns>
    /// Results in container.
    /// </returns>
    public static container updateCustomer( int64                       custTableRecId,
                                            DirPartyName                custName,
                                            CustGroupId                 custGroup,
                                            CustCurrencyCode            currency,
                                            CustLanguageId              languageId,
                                            Phone                       phone,
                                            int64                       phoneRecId,
                                            PhoneMobile                 cellularPhone,
                                            LogisticsElectronicAddressLocator email,
                                            int64                       emailRecId,
                                            URL                         url,
                                            int64                       urlRecId,
                                            CustMultiLineDiscCode       multiLineDisc,
                                            CustEndDiscCode             endDisc,
                                            CustLineDiscCode            lineDisc,
                                            CustPriceGroup              priceGroup,
                                            TaxGroup                    taxGroup,
                                            CustCreditMaxMST            creditMax,
                                            CustBlocked                 blocked,
                                            OrgId                       orgId,
                                            RetailUsePurchRequest       usePurchRequest,
                                            VATNum                      vatNum,
                                            CustInvoiceAccount          invoiceAccount,
                                            MandatoryCreditLimit        mandatoryCreditLimit,
                                            ContactPersonId             contactPersonId,
                                            RetailUseOrderNumberReference  useOrderNumberReference,
                                            RetailReceiptOption            receiptOption,
                                            RetailReceiptEmail             receiptEmail,
                                            CustIdentificationNumber    identificationNumber,
                                            FirstName firstName = '',
                                            MiddleName middleName = '',
                                            LastName lastName = '',
                                            PhoneLocal phoneExtension = '',
                                            int64 cellphoneRecId = 0,
                                            str retailCustAffiliations = '',
                                            str customerAttributes = '',
                                            int64 storeRecId = 0,
                                            int custAttributesDataPackageVersion = 1)
    {
        #OccRetryCount

        // [FLIGHT-BUG]
        // Bug 879256: Customer related RTS didn't handle ttscommit exceptions correctly and returns succeed after ttscommit failure.
        // The flight below is responsible to revert the changes introduced by this Bug 879256 fix.
        if (!RetailCustomerUpdateCustomerRtsRevertFlight::instance().isEnabled())
        {
            str                         error          = "";
            boolean                     validUpdate    = true;
            int                         fromLine;
            CustTable                   custTable;
            RetailCustTable             retailCustTable;
            CustAccount                 newCustAccount = '';
            CustomerEntity              customer;
            DirPartyContactInfoView     contactInfoView, updatedContactInfoView;
            DirPersonName               dirPersonName;
            DirPartyTable               partyRecord;
            DirPerson                   dirPerson;
            int64                       emailPartyLocationRecId,phonePartyLocationRecId,cellularPartyLocationRecId,urlPartyLocationRecId;
            int64                       emailPartyLocationRoleId,phonePartyLocationRoleId,cellularPartyLocationRoleId,urlPartyLocationRoleId,postalPartyLocationRoleId;
            int64                       emailLocationRecId,emailLocationRoleId,phoneLocationRecId,phoneLocationRoleId,urlLocationRecId,urlLocationRoleId,cellularLocationRecId,cellularLocationRoleId,postalLocationRoleId;

            int64                       cellularContactId, postalAddressId;
            int64                       postalPartyLocationId;
            int64                       postalLocationId;
            int64                       retailCustTableRecId = 0;
            LogisticsLocationId         emailLogisticsLocationId, phoneLogisticsLocationId, urlLogisticsLocationId, cellularLogisticsLocationId;
            int                         i;
            XmlDocument                 xmlrootCustAffiliations;
            XmlElement                  xmlElementCustAffiliations;
            XmlElement                  xmlRecordCustAffiliation;
            XmlNodeList                 xmlListCustAffiliations;
            RetailCustAffiliation       retailCustAffiliation;
            int64                       retailCustAffiliationRecId;
            Set                         retailCustAffiliationRecIdSet;
            CustVendTaxGroup            defaultTaxGroup;
            str                         attributeChangesDataPackage;
            str                         receiptEmailResult;
            CustGroup                   custGroupTable;

            // Outer try-catch block to catch all exceptions.
            try
            {
                // The retryable try-catch block to handle deadlocks and update conflict retries.
                try
                {
                    fromLine = Global::infologLine();
                    custTable = CustTable::findRecId(custTableRecId, true);

                    if (!custTable)
                    {
                        validUpdate = false;
                        error = strFmt("@Retail:CustomerNotFoundForUpdate", custTableRecId);
                        eventSource.EventWriteCustomerRecordNotFoundForUpdateOperation(custTableRecId);
                    }
                    else
                    {
                        ttsbegin;

                        custGroupTable = CustGroup::find(custGroup);
                        defaultTaxGroup                 = CustGroup::find(custGroup).TaxGroupId;

                        custTable.Currency              = currency;
                        custTable.MultiLineDisc         = multiLineDisc;
                        custTable.EndDisc               = endDisc;
                        custTable.LineDisc              = lineDisc;
                        custTable.PriceGroup            = priceGroup;

                        if (!RetailDisableUsingCustTableTaxGroupWhenUpdateCustomerFlight::instance().isEnabled())
                        {
                            custTable.TaxGroup = taxGroup ? taxGroup : defaultTaxGroup;
                        }
                        else
                        {
                            custTable.TaxGroup = defaultTaxGroup ? defaultTaxGroup : taxGroup;
                        }

                        custTable.CreditMax             = creditMax;
                        custTable.Blocked               = blocked;
                        custTable.OrgId                 = orgId;
                        custTable.UsePurchRequest       = usePurchRequest;
                        custTable.vatNum                = vatNum;
                        custTable.InvoiceAccount        = invoiceAccount;
                        custTable.MandatoryCreditLimit  = mandatoryCreditLimit;
                        custTable.ContactPersonId       = contactPersonId;

                        if (custTable.CustGroup != custGroup)
                        {
                            custTable.CustGroup               = custGroup;
                            custTable.PaymTermId              = custGroupTable.PaymTermId;
                            custTable.DefaultDimension        = custGroupTable.DefaultDimension;
                            custTable.InclTax                 = custGroupTable.PriceIncludeSalesTax;
                            custTable.CustWriteOffRefRecId    = custGroupTable.CustWriteOffRefRecId;
                            custTable.BankCustPaymIdTable     = custGroupTable.BankCustPaymIdTable;
                            custTable.ClearingPeriod          = custGroupTable.ClearingPeriod;
                            custTable.TaxPeriodPaymentCode_PL = custGroupTable.TaxPeriodPaymentCode_PL;
                            custTable.CustWriteOffRefRecId    = custGroupTable.CustWriteOffRefRecId;
                        }

                        unchecked (Uncheck::TableSecurityPermission)
                        {
                            custTable.IdentificationNumber  = identificationNumber;
                        }

                        custTable.update();

                        eventSource.EventWriteUpdateCustomerRecord(funcName(), custTable.RecId);

                        partyRecord = DirPartyTable::findRec(custTable.Party, true);
                        customer = new CustomerEntity(custTable, DateTimeUtil::utcNow());

                        if (partyRecord)
                        {
                            partyRecord.Name = custName;
                            partyRecord.LanguageId = languageId;
                            partyRecord.update();

                            eventSource.EventWriteUpdatePartyRecord(funcName(), partyRecord.RecId);

                            container conLogisticsElectronicAddress;

                            if (email != '' || emailRecId > 0)
                            {
                                conLogisticsElectronicAddress = RetailTransactionServiceCustomer::GetLogisticsElectronicAddress(emailRecId);

                                contactInfoView.clear();
                                contactInfoView.Party = custTable.Party;
                                contactInfoView.Type = LogisticsElectronicAddressMethodType::Email;
                                contactInfoView.IsPrimary = NoYes::Yes;
                                contactInfoView.Locator   = email;
                                contactInfoView.ElectronicAddress = emailRecId;
                                contactInfoView.LocationName = conPeek(conLogisticsElectronicAddress, 1);
                                updatedContactInfoView = customer.createOrUpdateContactInfo(contactInfoView, conPeek(conLogisticsElectronicAddress, 2));

                                if (!emailRecId)
                                {
                                    emailRecId = updatedContactInfoView.ElectronicAddress;
                                }

                                [emailLocationRecId, emailLogisticsLocationId, emailPartyLocationRecId, emailLocationRoleId, emailPartyLocationRoleId] =
                                        RetailTransactionServiceCustomer::getContactInfoData(custTable.Party, emailRecId);

                                eventSource.EventWriteCustomerUpdateEmailRecord(funcName(), emailRecId);
                            }

                            if (phone != '' || phoneRecId > 0)
                            {
                                conLogisticsElectronicAddress = RetailTransactionServiceCustomer::GetLogisticsElectronicAddress(phoneRecId);

                                contactInfoView.clear();
                                contactInfoView.Party = custTable.Party;
                                contactInfoView.Type = LogisticsElectronicAddressMethodType::Phone;
                                contactInfoView.IsPrimary = NoYes::Yes;
                                contactInfoView.Locator   = phone;
                                contactInfoView.LocatorExtension = phoneExtension;
                                contactInfoView.ElectronicAddress = phoneRecId;
                                contactInfoView.LocationName = conPeek(conLogisticsElectronicAddress, 1);
                                updatedContactInfoView = customer.createOrUpdateContactInfo(contactInfoView, conPeek(conLogisticsElectronicAddress, 2));

                                if (!phoneRecId)
                                {
                                    phoneRecId = updatedContactInfoView.ElectronicAddress;
                                }

                                [phoneLocationRecId, phoneLogisticsLocationId, phonePartyLocationRecId, phoneLocationRoleId, phonePartyLocationRoleId] =
                                    RetailTransactionServiceCustomer::getContactInfoData(custTable.Party, phoneRecId);

                                eventSource.EventWriteCustomerUpdatePhoneRecord(funcName(), phoneRecId);
                            }

                            if (url != '' || urlRecId > 0)
                            {
                                conLogisticsElectronicAddress = RetailTransactionServiceCustomer::GetLogisticsElectronicAddress(urlRecId);

                                contactInfoView.clear();
                                contactInfoView.Party = custTable.Party;
                                contactInfoView.Type = LogisticsElectronicAddressMethodType::URL;
                                contactInfoView.IsPrimary = NoYes::Yes;
                                contactInfoView.Locator   = url;
                                contactInfoView.ElectronicAddress = urlRecId;
                                contactInfoView.LocationName = conPeek(conLogisticsElectronicAddress, 1);
                                updatedContactInfoView = customer.createOrUpdateContactInfo(contactInfoView, conPeek(conLogisticsElectronicAddress, 2));

                                if (!urlRecId)
                                {
                                    urlRecId = updatedContactInfoView.ElectronicAddress;
                                }

                                [urlLocationRecId, urlLogisticsLocationId, urlPartyLocationRecId, urlLocationRoleId, urlPartyLocationRoleId] =
                                        RetailTransactionServiceCustomer::getContactInfoData(custTable.Party, urlRecId);

                                eventSource.EventWriteCustomerUpdateURLContactRecord(funcName(), urlRecId);
                            }

                            // Only create a cellularPhone record if there is a cellularPhone specified
                            if (cellularPhone != '' || cellphoneRecId > 0)
                            {
                                conLogisticsElectronicAddress = RetailTransactionServiceCustomer::GetLogisticsElectronicAddress(cellphoneRecId);

                                contactInfoView.clear();
                                contactInfoView.Party = custTable.Party;
                                contactInfoView.Type = LogisticsElectronicAddressMethodType::Phone;
                                contactInfoView.IsPrimary = NoYes::No;
                                contactInfoView.Locator   = cellularPhone;
                                contactInfoView.IsMobilePhone = NoYes::Yes;
                                contactInfoView.ElectronicAddress = cellphoneRecId;
                                contactInfoView.LocationName = conPeek(conLogisticsElectronicAddress, 1);
                                updatedContactInfoView = customer.createOrUpdateContactInfo(contactInfoView, conPeek(conLogisticsElectronicAddress, 2));

                                cellularContactId = updatedContactInfoView.ElectronicAddress;
                                [cellularLocationRecId, cellularLogisticsLocationId, cellularPartyLocationRecId, cellularLocationRoleId, cellularPartyLocationRoleId] =
                                        RetailTransactionServiceCustomer::getContactInfoData(custTable.Party, cellularContactId);

                                eventSource.EventWriteCustomerUpdateCellularPhoneRecord(funcName(), cellularContactId);
                            }

                            if (partyRecord.type() == DirPartyType::Person)
                            {
                                // if this is a person, find/initialize the name record for the person
                                dirPersonName = DirPersonName::find(partyRecord.RecId, true);
                                // backwards compatibility until the client send the proper values,
                                // don't erase the names.
                                if (lastName == '')
                                {
                                    [firstName, middleName, lastName] = DirPerson::splitNameParts(custName);
                                }

                                dirPersonName.FirstName = firstName;
                                dirPersonName.MiddleName = middleName;
                                dirPersonName.LastName = lastName;

                                dirPersonName.validTimeStateUpdateMode(ValidTimeStateUpdate::Correction);

                                if (dirPersonName.RecId != 0)
                                {
                                    dirPersonName.update();
                                    eventSource.EventWriteUpdatePartyRecordForPerson(funcName(), dirPersonName.RecId);
                                }
                                else
                                {
                                    // if name didn't already exist, create it.
                                    dirPersonName.Person = partyRecord.RecId;
                                    dirPersonName.ValidFrom = DateTimeUtil::utcNow();
                                    dirPersonName.ValidTo = DateTimeUtil::maxValue();
                                    if (dirPersonName.validateWrite())
                                    {
                                        dirPersonName.insert();
                                        eventSource.EventWriteCreatePartyRecordForPerson(funcName(), dirPersonName.RecId);
                                    }
                                }

                                // update customer title.
                                dirPerson = DirPerson::find(partyRecord.RecId, true);
                                RetailTransactionServiceCustomerContext context = RetailTransactionServiceCustomerContext::current();
                                if (dirPerson && context != null)
                                {
                                    dirPerson.PersonalTitle = context.parmCustomerTitleRecId();
                                    dirPerson.update();
                                }

                                //refresh the party record
                                partyRecord = DirPartyTable::findRec(custTable.Party, false);
                            }
                        }

                        // Retail Customer Affiliation
                        if (RetailCustAffiliations != '')
                        {
                            xmlrootCustAffiliations = new XmlDocument();
                            xmlrootCustAffiliations.loadXml(retailCustAffiliations);

                            xmlElementCustAffiliations = xmlrootCustAffiliations.getNamedElement('RetailCustAffiliations');

                            xmlListCustAffiliations = xmlElementCustAffiliations.childNodes();

                            if (xmlListCustAffiliations)
                            {
                                retailCustAffiliationRecIdSet = new Set(Types::Int64);

                                for (i=0; i < xmlListCustAffiliations.length(); i++)
                                {
                                    xmlRecordCustAffiliation = xmlListCustAffiliations.item(i);

                                    if (xmlRecordCustAffiliation)
                                    {
                                        retailCustAffiliation.clear();
                                        retailCustAffiliationRecId = str2int64(xmlRecordCustAffiliation.getAttribute('RecId'));

                                        // Update the RetailCustAffiliation exists
                                        if (retailCustAffiliationRecId != 0)
                                        {
                                            retailCustAffiliation = RetailCustAffiliation::findRecId(retailCustAffiliationRecId, true);

                                            if (retailCustAffiliation)
                                            {
                                                retailCustAffiliation.RetailAffiliationId = str2Int64(xmlRecordCustAffiliation.getAttribute('RetailAffiliationId'));

                                                retailCustAffiliation.update();

                                                //Fill the RetailCustAffiliation value to xml
                                                xmlRecordCustAffiliation.setAttribute('RecId', int642str(retailCustAffiliation.RecId));
                                            }
                                        }
                                        else // Insert the RetailCustAffiliation if it does not exist
                                        {
                                            // forUpdate is set to TRUE because CacheLookup = Found on table RetailCustAffiliation.
                                            // If forupdate = False, a record will be selected from cache even it has been deleted.
                                            // A select forUpdate in a transaction forces reading from the database and replaces the record in the cache.
                                            retailCustAffiliation = RetailCustAffiliation::findByIdAndCustomer(str2Int64(xmlRecordCustAffiliation.getAttribute('RetailAffiliationId')), custTable.AccountNum, true);

                                            if (!retailCustAffiliation.RecId)
                                            {
                                                retailCustAffiliation.CustAccountNum = custTable.AccountNum;
                                                retailCustAffiliation.RetailAffiliationId = str2Int64(xmlRecordCustAffiliation.getAttribute('RetailAffiliationId'));
                                                retailCustAffiliation.insert();
                                            }

                                            //Fill the RetailCustAffiliation value back to xml
                                            xmlRecordCustAffiliation.setAttribute('RecId', int642str(retailCustAffiliation.RecId));
                                        }

                                        retailCustAffiliationRecIdSet.add(retailCustAffiliation.RecId);
                                        eventSource.EventWriteUpdateRetailCustomerAffiliation(funcName(), retailCustAffiliation.RecId);
                                    }
                                }

                                retailCustAffiliations = xmlrootCustAffiliations.toString();

                                // Remove unused RetailCustAffiliation
                                while select forUpdate RecId from retailCustAffiliation
                                where retailCustAffiliation.CustAccountNum == custTable.AccountNum
                                {
                                    if (!retailCustAffiliationRecIdSet.in(retailCustAffiliation.RecId))
                                    {
                                        int64 retailCustomerAffiliationRecId = retailCustAffiliation.RecId;

                                        retailCustAffiliation.delete();
                                        eventSource.EventWriteDeleteRetailCustomerAffiliation(funcName(), retailCustomerAffiliationRecId);
                                    }
                                }
                            }
                        }

                        // Upsert the RetailCustTable record.
                        retailCustTable = RetailCustTable::find(custTable.AccountNum, true);

                        if (!retailCustTable)
                        {
                            retailCustTable.initValue();
                        }

                        retailCustTable.AccountNum              = custTable.AccountNum;
                        retailCustTable.UseOrderNumberReference = useOrderNumberReference;
                        retailCustTable.ReceiptOption           = any2int(receiptOption);
                        retailCustTable.ReceiptEmail            = receiptEmail;

                        RetailTransactionServiceCustomerContext context = RetailTransactionServiceCustomerContext::current();
                        if (context != null)
                        {
                            retailCustTable.OptOutPersonalization = context.parmOptOutPersonalization();
                            retailCustTable.OptOutWebActivityTracking = context.parmOptOutWebActivityTracking();
                        }

                        // if retail cust table record found, update it, else insert it.
                        if (retailCustTable)
                        {
                            retailCustTable.update();
                            eventSource.EventWriteUpdateRecordInRetailCustTable(funcName(), retailCustTable.RecId);
                        }
                        else
                        {
                            retailCustTable.insert();
                            eventSource.EventWriteCreateRecordInRetailCustTable(funcName(), retailCustTable.RecId);
                        }

                        receiptEmailResult = retailCustTable.ReceiptEmail;
                        retailCustTableRecId = retailCustTable.RecId;

                        // update customer attributes
                        Map newAttributeValues = RetailCustomerAttributeHelper::deserializeCustomerAttributes(customerAttributes);
                        attributeChangesDataPackage = RetailCustomerAttributeHelper::createUpdateAttributeValuesOnCustomer(
                        custTable.AccountNum, custTable.DataAreaId, newAttributeValues, storeRecId, custAttributesDataPackageVersion);

                        ttscommit;
                    }
                }
                catch (Exception::Deadlock)
                {
                    if (xSession::currentRetryCount() < #RetryNum)
                    {
                        eventSource.EventWriteUpdateCustomerExceptionWithRetries(funcName(), 'Deadlock', xSession::currentRetryCount(), #RetryNum, true);
                        retry;
                    }
                    else
                    {
                        throw Exception::Deadlock;
                    }
                }
                catch (Exception::UpdateConflict)
                {
                    if (xSession::currentRetryCount() < #RetryNum)
                    {
                        eventSource.EventWriteUpdateCustomerExceptionWithRetries(funcName(), 'UpdateConflict', xSession::currentRetryCount(), #RetryNum, true);
                        retry;
                    }
                    else
                    {
                        throw Exception::UpdateConflictNotRecovered;
                    }
                }
            }
            catch
            {
                validUpdate = false;
                error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                str axCallStack = con2Str(xSession::xppCallStack()); // Use AX call stack for Exception::Error
                eventSource.EventWriteCustomerNewException(funcName(), axCallStack);
            }

            // Returning the status as a container
            return [validUpdate, error, custTable.AccountNum, custTable.TaxGroup, custTable.Party, custTable.RecId, retailCustTableRecId, //0-4
            // primary address is not updated here so these parameters should be 0
            postalAddressId, postalLocationId, postalPartyLocationId, postalPartyLocationRoleId, postalLocationRoleId,  //5-9
            0, 0, 0, 0, 0, //10-14
            emailRecId, emailLocationRecId, emailPartyLocationRecId, emailPartyLocationRoleId, emailLocationRoleId,  //15-19
            phoneRecId, phoneLocationRecId, phonePartyLocationRecId, phonePartyLocationRoleId, phoneLocationRoleId, //20-24
            urlRecId, urlLocationRecId, urlPartyLocationRecId, urlPartyLocationRoleId, urlLocationRoleId, //25-29
            cellularContactId, cellularLocationRecId, cellularPartyLocationRecId, cellularPartyLocationRoleId, cellularLocationRoleId, //30-34
            emailLogisticsLocationId, phoneLogisticsLocationId, urlLogisticsLocationId, cellularLogisticsLocationId, dirPersonName.RecId, //35-39
            partyRecord.Name, retailCustAffiliations, receiptEmailResult, attributeChangesDataPackage]; //40-43
        }
        else
        {
            str                         error          = "@RET2445";
            boolean                     validUpdate    = false;
            int                         fromLine;
            CustTable                   custTable;
            RetailCustTable             retailCustTable;
            CustAccount                 newCustAccount = '';
            CustomerEntity              customer;
            DirPartyContactInfoView     contactInfoView, updatedContactInfoView;
            DirPersonName               dirPersonName;
            DirPartyTable               partyRecord;
            DirPerson                   dirPerson;
            int64                       emailPartyLocationRecId,phonePartyLocationRecId,cellularPartyLocationRecId,urlPartyLocationRecId;
            int64                       emailPartyLocationRoleId,phonePartyLocationRoleId,cellularPartyLocationRoleId,urlPartyLocationRoleId,postalPartyLocationRoleId;
            int64                       emailLocationRecId,emailLocationRoleId,phoneLocationRecId,phoneLocationRoleId,urlLocationRecId,urlLocationRoleId,cellularLocationRecId,cellularLocationRoleId,postalLocationRoleId;

            int64                       cellularContactId, postalAddressId;
            int64                       postalPartyLocationId;
            int64                       postalLocationId;
            int64                       retailCustTableRecId = 0;
            LogisticsLocationId         emailLogisticsLocationId, phoneLogisticsLocationId, urlLogisticsLocationId, cellularLogisticsLocationId;
            int                         i;
            XmlDocument                 xmlrootCustAffiliations;
            XmlElement                  xmlElementCustAffiliations;
            XmlElement                  xmlRecordCustAffiliation;
            XmlNodeList                 xmlListCustAffiliations;
            RetailCustAffiliation       retailCustAffiliation;
            int64                       retailCustAffiliationRecId;
            Set                         retailCustAffiliationRecIdSet;
            CustVendTaxGroup            defaultTaxGroup;
            str                         attributeChangesDataPackage;
            str                         receiptEmailResult;
            CustGroup                   custGroupTable;

            // Outer try-catch block to catch all exceptions.
            try
            {
                // The retryable try-catch block to handle deadlocks and update conflict retries.
                try
                {
                    fromLine = Global::infologLine();
                    custTable = CustTable::findRecId(custTableRecId, true);

                    if (!custTable)
                    {
                        error = strFmt("@Retail:CustomerNotFoundForUpdate", custTableRecId);
                        eventSource.EventWriteCustomerRecordNotFoundForUpdateOperation(custTableRecId);
                    }
                    else
                    {
                        ttsbegin;

                        custGroupTable = CustGroup::find(custGroup);
                        defaultTaxGroup                 = CustGroup::find(custGroup).TaxGroupId;

                        custTable.Currency              = currency;
                        custTable.MultiLineDisc         = multiLineDisc;
                        custTable.EndDisc               = endDisc;
                        custTable.LineDisc              = lineDisc;
                        custTable.PriceGroup            = priceGroup;

                        if (!RetailDisableUsingCustTableTaxGroupWhenUpdateCustomerFlight::instance().isEnabled())
                        {
                            custTable.TaxGroup = taxGroup ? taxGroup : defaultTaxGroup;
                        }
                        else
                        {
                            custTable.TaxGroup = defaultTaxGroup ? defaultTaxGroup : taxGroup;
                        }

                        custTable.CreditMax             = creditMax;
                        custTable.Blocked               = blocked;
                        custTable.OrgId                 = orgId;
                        custTable.UsePurchRequest       = usePurchRequest;
                        custTable.vatNum                = vatNum;
                        custTable.InvoiceAccount        = invoiceAccount;
                        custTable.MandatoryCreditLimit  = mandatoryCreditLimit;
                        custTable.ContactPersonId       = contactPersonId;

                        if (custTable.CustGroup != custGroup)
                        {
                            custTable.CustGroup               = custGroup;
                            custTable.PaymTermId              = custGroupTable.PaymTermId;
                            custTable.DefaultDimension        = custGroupTable.DefaultDimension;
                            custTable.InclTax                 = custGroupTable.PriceIncludeSalesTax;
                            custTable.CustWriteOffRefRecId    = custGroupTable.CustWriteOffRefRecId;
                            custTable.BankCustPaymIdTable     = custGroupTable.BankCustPaymIdTable;
                            custTable.ClearingPeriod          = custGroupTable.ClearingPeriod;
                            custTable.TaxPeriodPaymentCode_PL = custGroupTable.TaxPeriodPaymentCode_PL;
                            custTable.CustWriteOffRefRecId    = custGroupTable.CustWriteOffRefRecId;
                        }

                        unchecked (Uncheck::TableSecurityPermission)
                        {
                            custTable.IdentificationNumber  = identificationNumber;
                        }

                        custTable.update();

                        eventSource.EventWriteUpdateCustomerRecord(funcName(), custTable.RecId);

                        partyRecord = DirPartyTable::findRec(custTable.Party, true);
                        customer = new CustomerEntity(custTable, DateTimeUtil::utcNow());

                        if (partyRecord)
                        {
                            partyRecord.Name = custName;
                            partyRecord.LanguageId = languageId;
                            partyRecord.update();

                            eventSource.EventWriteUpdatePartyRecord(funcName(), partyRecord.RecId);

                            container conLogisticsElectronicAddress;

                            if (email != '' || emailRecId > 0)
                            {
                                conLogisticsElectronicAddress = RetailTransactionServiceCustomer::GetLogisticsElectronicAddress(emailRecId);

                                contactInfoView.clear();
                                contactInfoView.Party = custTable.Party;
                                contactInfoView.Type = LogisticsElectronicAddressMethodType::Email;
                                contactInfoView.IsPrimary = NoYes::Yes;
                                contactInfoView.Locator   = email;
                                contactInfoView.ElectronicAddress = emailRecId;
                                contactInfoView.LocationName = conPeek(conLogisticsElectronicAddress, 1);
                                updatedContactInfoView = customer.createOrUpdateContactInfo(contactInfoView, conPeek(conLogisticsElectronicAddress, 2));

                                if (!emailRecId)
                                {
                                    emailRecId = updatedContactInfoView.ElectronicAddress;
                                }

                                [emailLocationRecId, emailLogisticsLocationId, emailPartyLocationRecId, emailLocationRoleId, emailPartyLocationRoleId] =
                                        RetailTransactionServiceCustomer::getContactInfoData(custTable.Party, emailRecId);

                                eventSource.EventWriteCustomerUpdateEmailRecord(funcName(), emailRecId);
                            }

                            if (phone != '' || phoneRecId > 0)
                            {
                                conLogisticsElectronicAddress = RetailTransactionServiceCustomer::GetLogisticsElectronicAddress(phoneRecId);

                                contactInfoView.clear();
                                contactInfoView.Party = custTable.Party;
                                contactInfoView.Type = LogisticsElectronicAddressMethodType::Phone;
                                contactInfoView.IsPrimary = NoYes::Yes;
                                contactInfoView.Locator   = phone;
                                contactInfoView.LocatorExtension = phoneExtension;
                                contactInfoView.ElectronicAddress = phoneRecId;
                                contactInfoView.LocationName = conPeek(conLogisticsElectronicAddress, 1);
                                updatedContactInfoView = customer.createOrUpdateContactInfo(contactInfoView, conPeek(conLogisticsElectronicAddress, 2));

                                if (!phoneRecId)
                                {
                                    phoneRecId = updatedContactInfoView.ElectronicAddress;
                                }

                                [phoneLocationRecId, phoneLogisticsLocationId, phonePartyLocationRecId, phoneLocationRoleId, phonePartyLocationRoleId] =
                                    RetailTransactionServiceCustomer::getContactInfoData(custTable.Party, phoneRecId);

                                eventSource.EventWriteCustomerUpdatePhoneRecord(funcName(), phoneRecId);
                            }

                            if (url != '' || urlRecId > 0)
                            {
                                conLogisticsElectronicAddress = RetailTransactionServiceCustomer::GetLogisticsElectronicAddress(urlRecId);

                                contactInfoView.clear();
                                contactInfoView.Party = custTable.Party;
                                contactInfoView.Type = LogisticsElectronicAddressMethodType::URL;
                                contactInfoView.IsPrimary = NoYes::Yes;
                                contactInfoView.Locator   = url;
                                contactInfoView.ElectronicAddress = urlRecId;
                                contactInfoView.LocationName = conPeek(conLogisticsElectronicAddress, 1);
                                updatedContactInfoView = customer.createOrUpdateContactInfo(contactInfoView, conPeek(conLogisticsElectronicAddress, 2));

                                if (!urlRecId)
                                {
                                    urlRecId = updatedContactInfoView.ElectronicAddress;
                                }

                                [urlLocationRecId, urlLogisticsLocationId, urlPartyLocationRecId, urlLocationRoleId, urlPartyLocationRoleId] =
                                        RetailTransactionServiceCustomer::getContactInfoData(custTable.Party, urlRecId);

                                eventSource.EventWriteCustomerUpdateURLContactRecord(funcName(), urlRecId);
                            }

                            // Only create a cellularPhone record if there is a cellularPhone specified
                            if (cellularPhone != '' || cellphoneRecId > 0)
                            {
                                conLogisticsElectronicAddress = RetailTransactionServiceCustomer::GetLogisticsElectronicAddress(cellphoneRecId);

                                contactInfoView.clear();
                                contactInfoView.Party = custTable.Party;
                                contactInfoView.Type = LogisticsElectronicAddressMethodType::Phone;
                                contactInfoView.IsPrimary = NoYes::No;
                                contactInfoView.Locator   = cellularPhone;
                                contactInfoView.IsMobilePhone = NoYes::Yes;
                                contactInfoView.ElectronicAddress = cellphoneRecId;
                                contactInfoView.LocationName = conPeek(conLogisticsElectronicAddress, 1);
                                updatedContactInfoView = customer.createOrUpdateContactInfo(contactInfoView, conPeek(conLogisticsElectronicAddress, 2));

                                cellularContactId = updatedContactInfoView.ElectronicAddress;
                                [cellularLocationRecId, cellularLogisticsLocationId, cellularPartyLocationRecId, cellularLocationRoleId, cellularPartyLocationRoleId] =
                                        RetailTransactionServiceCustomer::getContactInfoData(custTable.Party, cellularContactId);

                                eventSource.EventWriteCustomerUpdateCellularPhoneRecord(funcName(), cellularContactId);
                            }

                            if (partyRecord.type() == DirPartyType::Person)
                            {
                                // if this is a person, find/initialize the name record for the person
                                dirPersonName = DirPersonName::find(partyRecord.RecId, true);
                                // backwards compatibility until the client send the proper values,
                                // don't erase the names.
                                if (lastName == '')
                                {
                                    [firstName, middleName, lastName] = DirPerson::splitNameParts(custName);
                                }

                                dirPersonName.FirstName = firstName;
                                dirPersonName.MiddleName = middleName;
                                dirPersonName.LastName = lastName;

                                dirPersonName.validTimeStateUpdateMode(ValidTimeStateUpdate::Correction);

                                if (dirPersonName.RecId != 0)
                                {
                                    dirPersonName.update();
                                    eventSource.EventWriteUpdatePartyRecordForPerson(funcName(), dirPersonName.RecId);
                                }
                                else
                                {
                                    // if name didn't already exist, create it.
                                    dirPersonName.Person = partyRecord.RecId;
                                    dirPersonName.ValidFrom = DateTimeUtil::utcNow();
                                    dirPersonName.ValidTo = DateTimeUtil::maxValue();
                                    if (dirPersonName.validateWrite())
                                    {
                                        dirPersonName.insert();
                                        eventSource.EventWriteCreatePartyRecordForPerson(funcName(), dirPersonName.RecId);
                                    }
                                }

                                // update customer title.
                                dirPerson = DirPerson::find(partyRecord.RecId, true);
                                RetailTransactionServiceCustomerContext context = RetailTransactionServiceCustomerContext::current();
                                if (dirPerson && context != null)
                                {
                                    dirPerson.PersonalTitle = context.parmCustomerTitleRecId();
                                    dirPerson.update();
                                }

                                //refresh the party record
                                partyRecord = DirPartyTable::findRec(custTable.Party, false);
                            }
                        }

                        // Retail Customer Affiliation
                        if (RetailCustAffiliations != '')
                        {
                            xmlrootCustAffiliations = new XmlDocument();
                            xmlrootCustAffiliations.loadXml(retailCustAffiliations);

                            xmlElementCustAffiliations = xmlrootCustAffiliations.getNamedElement('RetailCustAffiliations');

                            xmlListCustAffiliations = xmlElementCustAffiliations.childNodes();

                            if (xmlListCustAffiliations)
                            {
                                retailCustAffiliationRecIdSet = new Set(Types::Int64);

                                for (i=0; i < xmlListCustAffiliations.length(); i++)
                                {
                                    xmlRecordCustAffiliation = xmlListCustAffiliations.item(i);

                                    if (xmlRecordCustAffiliation)
                                    {
                                        retailCustAffiliation.clear();
                                        retailCustAffiliationRecId = str2int64(xmlRecordCustAffiliation.getAttribute('RecId'));

                                        // Update the RetailCustAffiliation exists
                                        if (retailCustAffiliationRecId != 0)
                                        {
                                            retailCustAffiliation = RetailCustAffiliation::findRecId(retailCustAffiliationRecId, true);

                                            if (retailCustAffiliation)
                                            {
                                                retailCustAffiliation.RetailAffiliationId = str2Int64(xmlRecordCustAffiliation.getAttribute('RetailAffiliationId'));

                                                retailCustAffiliation.update();

                                                //Fill the RetailCustAffiliation value to xml
                                                xmlRecordCustAffiliation.setAttribute('RecId', int642str(retailCustAffiliation.RecId));
                                            }
                                        }
                                        else // Insert the RetailCustAffiliation if it does not exist
                                        {
                                            // forUpdate is set to TRUE because CacheLookup = Found on table RetailCustAffiliation.
                                            // If forupdate = False, a record will be selected from cache even it has been deleted.
                                            // A select forUpdate in a transaction forces reading from the database and replaces the record in the cache.
                                            retailCustAffiliation = RetailCustAffiliation::findByIdAndCustomer(str2Int64(xmlRecordCustAffiliation.getAttribute('RetailAffiliationId')), custTable.AccountNum, true);

                                            if (!retailCustAffiliation.RecId)
                                            {
                                                retailCustAffiliation.CustAccountNum = custTable.AccountNum;
                                                retailCustAffiliation.RetailAffiliationId = str2Int64(xmlRecordCustAffiliation.getAttribute('RetailAffiliationId'));
                                                retailCustAffiliation.insert();
                                            }

                                            //Fill the RetailCustAffiliation value back to xml
                                            xmlRecordCustAffiliation.setAttribute('RecId', int642str(retailCustAffiliation.RecId));
                                        }

                                        retailCustAffiliationRecIdSet.add(retailCustAffiliation.RecId);
                                        eventSource.EventWriteUpdateRetailCustomerAffiliation(funcName(), retailCustAffiliation.RecId);
                                    }
                                }

                                retailCustAffiliations = xmlrootCustAffiliations.toString();

                                // Remove unused RetailCustAffiliation
                                while select forUpdate RecId from retailCustAffiliation
                                where retailCustAffiliation.CustAccountNum == custTable.AccountNum
                                {
                                    if (!retailCustAffiliationRecIdSet.in(retailCustAffiliation.RecId))
                                    {
                                        int64 retailCustomerAffiliationRecId = retailCustAffiliation.RecId;

                                        retailCustAffiliation.delete();
                                        eventSource.EventWriteDeleteRetailCustomerAffiliation(funcName(), retailCustomerAffiliationRecId);
                                    }
                                }
                            }
                        }

                        // Upsert the RetailCustTable record.
                        retailCustTable = RetailCustTable::find(custTable.AccountNum, true);

                        if (!retailCustTable)
                        {
                            retailCustTable.initValue();
                        }

                        retailCustTable.AccountNum              = custTable.AccountNum;
                        retailCustTable.UseOrderNumberReference = useOrderNumberReference;
                        retailCustTable.ReceiptOption           = any2int(receiptOption);
                        retailCustTable.ReceiptEmail            = receiptEmail;

                        RetailTransactionServiceCustomerContext context = RetailTransactionServiceCustomerContext::current();
                        if (context != null)
                        {
                            retailCustTable.OptOutPersonalization = context.parmOptOutPersonalization();
                            retailCustTable.OptOutWebActivityTracking = context.parmOptOutWebActivityTracking();
                        }

                        // if retail cust table record found, update it, else insert it.
                        if (retailCustTable)
                        {
                            retailCustTable.update();
                            eventSource.EventWriteUpdateRecordInRetailCustTable(funcName(), retailCustTable.RecId);
                        }
                        else
                        {
                            retailCustTable.insert();
                            eventSource.EventWriteCreateRecordInRetailCustTable(funcName(), retailCustTable.RecId);
                        }

                        receiptEmailResult = retailCustTable.ReceiptEmail;
                        retailCustTableRecId = retailCustTable.RecId;

                        // update customer attributes
                        Map newAttributeValues = RetailCustomerAttributeHelper::deserializeCustomerAttributes(customerAttributes);
                        attributeChangesDataPackage = RetailCustomerAttributeHelper::createUpdateAttributeValuesOnCustomer(
                        custTable.AccountNum, custTable.DataAreaId, newAttributeValues, storeRecId, custAttributesDataPackageVersion);

                        validUpdate = true;
                        error = '';

                        ttscommit;
                    }
                }
                catch (Exception::Deadlock)
                {
                    if (xSession::currentRetryCount() < #RetryNum)
                    {
                        eventSource.EventWriteUpdateCustomerExceptionWithRetries(funcName(), 'Deadlock', xSession::currentRetryCount(), #RetryNum, true);
                        retry;
                    }
                    else
                    {
                        throw Exception::Deadlock;
                    }
                }
                catch (Exception::UpdateConflict)
                {
                    if (xSession::currentRetryCount() < #RetryNum)
                    {
                        eventSource.EventWriteUpdateCustomerExceptionWithRetries(funcName(), 'UpdateConflict', xSession::currentRetryCount(), #RetryNum, true);
                        retry;
                    }
                    else
                    {
                        throw Exception::UpdateConflictNotRecovered;
                    }
                }
            }
            catch
            {
                error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                str axCallStack = con2Str(xSession::xppCallStack()); // Use AX call stack for Exception::Error
                eventSource.EventWriteCustomerNewException(funcName(), axCallStack);
            }

            // Returning the status as a container
            return [validUpdate, error, custTable.AccountNum, custTable.TaxGroup, custTable.Party, custTable.RecId, retailCustTableRecId, //0-4
            // primary address is not updated here so these parameters should be 0
            postalAddressId, postalLocationId, postalPartyLocationId, postalPartyLocationRoleId, postalLocationRoleId,  //5-9
            0, 0, 0, 0, 0, //10-14
            emailRecId, emailLocationRecId, emailPartyLocationRecId, emailPartyLocationRoleId, emailLocationRoleId,  //15-19
            phoneRecId, phoneLocationRecId, phonePartyLocationRecId, phonePartyLocationRoleId, phoneLocationRoleId, //20-24
            urlRecId, urlLocationRecId, urlPartyLocationRecId, urlPartyLocationRoleId, urlLocationRoleId, //25-29
            cellularContactId, cellularLocationRecId, cellularPartyLocationRecId, cellularPartyLocationRoleId, cellularLocationRoleId, //30-34
            emailLogisticsLocationId, phoneLogisticsLocationId, urlLogisticsLocationId, cellularLogisticsLocationId, dirPersonName.RecId, //35-39
            partyRecord.Name, retailCustAffiliations, receiptEmailResult, attributeChangesDataPackage]; //40-43
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewCustAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a new <c>CustAccount</c>.
    /// </summary>
    /// <returns>
    /// A newly generated <c>CustAccount</c>.
    /// </returns>
    protected static CustAccount getNewCustAccount()
    {
        NumberSeq   numberSeq;
        CustAccount newCustAccount = '';

        numberSeq = NumberSeq::newGetNum(CustParameters::numRefCustAccount());
        newCustAccount = numberSeq.num();

        return newCustAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewCustAccountV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a new <c>CustAccount</c>.
    /// </summary>
    /// <param name="custGroupId">
    /// Customer group
    /// </param>
    /// <returns>
    /// A newly generated <c>CustAccount</c>.
    /// </returns>
    protected static CustAccount getNewCustAccountV2(CustGroupId custGroupId)
    {
        NumberSeq numberSeq;
        CustAccount newCustAccount = '';
        CustGroup custGroup;

        custGroup = CustGroup::find(custGroupId);

        // Check if number sequence for customer account number is configured at customer group level.
        if (custGroup.CustAccountNumSeq)
        {
            if (RetailGetCustGroupNumSeqByNumSeqReferenceIdFlight::instance().isEnabled())
            {
                NumberSequenceReference numberSequenceRef;
                select firstonly numberSequenceRef
                    where numberSequenceRef.NumberSequenceId == custGroup.CustAccountNumSeq;

                numberSeq = NumberSeq::newGetNum(numberSequenceRef);
            }
            else
            {
                // The code in another branch first finds NumberSequenceReference which references to NumberSequenceTable,
                // then uses it to generate a new number.
                //
                // However, not all the NumberSequenceTable has the corresponding NumberSequenceReference, especially for the
                // NumberSequenceTable record created using HQ UI. This leads to the failure of generating a new number.
                //
                // The solution is that, since CustGroup.CustAccountNumSeq directly references to NumberSequenceTable.RecId,
                // we can omit the step which uses the NumberSequenceTable.RecId to find NumberSequenceReference and to reference
                // back to NumberSequenceTable.RecId, and can directly use CustGroup.CustAccountNumSeq to generate a new number.
                numberSeq = NumberSeq::newGetNumFromId(custGroup.CustAccountNumSeq);
            }

            newCustAccount = numberSeq.num();
        }
        else
        {
            newCustAccount = RetailTransactionServiceCustomer::getNewCustAccount();
        }

        return newCustAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>upsertElectronicAddressRole</Name>
				<Source><![CDATA[
    private static void upsertElectronicAddressRole(container roleContainer, RecId electronicsAddressId)
    {
        LogisticsElectronicAddressRole electronicAddressRole;
        RecId     roleId;
        int       i;

        if (!electronicsAddressId)
        {
            return;
        }

        delete_from electronicAddressRole
            where electronicAddressRole.ElectronicAddress == electronicsAddressId;

        for (i = 1; i < conLen(roleContainer); ++i)
        {
            roleId = conPeek(roleContainer, i);
            electronicAddressRole.initValue();
            electronicAddressRole.ElectronicAddress = electronicsAddressId;
            electronicAddressRole.LocationRole = roleId;
            electronicAddressRole.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>upsertLogisticsElectronicAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts or updates the electronic address based on the locator.
    /// </summary>
    /// <param name="logisticsElectronicAddressRecId">
    /// RecId of LogisticsElectronic address.
    /// </param>
    /// <param name="value">
    /// Value of the loator.
    /// </param>/// <param name="parentLogisticsLocationId">
    /// Value of the Parent location Id.
    /// </param>
    /// <param name="type">
    /// Type of the electronic address.
    /// </param>
    /// <returns>
    /// A container object with Location Id and electronic address id.
    /// </returns>
    public static container upsertLogisticsElectronicAddress(
            RecId logisticsElectronicAddressRecId,
            LogisticsElectronicAddressLocator value,
            LogisticsLocationRecId parentLogisticsLocationId,
            LogisticsElectronicAddressMethodType type)
    {
        LogisticsElectronicAddress logisticsElectronicAddress, logisticsElectronicAddressSet;
        LogisticsLocation logisticsLocation;
        RecId returnLogisticLocationRecId, returnLogisticsElectronicAddressId;
        LogisticsLocationId returnLogisticsLocationId;

        if (parentLogisticsLocationId)
        {
            // insert LogisticsLocation
            select firstOnly logisticsLocation where logisticsLocation.ParentLocation == parentLogisticsLocationId;

            if (!logisticsLocation)
            {
                logisticsLocation.initValue();
                logisticsLocation.ParentLocation = parentLogisticsLocationId;
                logisticsLocation.IsPostalAddress = NoYes::No;
                logisticsLocation.insert();
            }
        }

        returnLogisticLocationRecId = logisticsLocation.RecId;
        returnLogisticsLocationId = logisticsLocation.LocationId;

        logisticsElectronicAddress = LogisticsElectronicAddress::findRecId(logisticsElectronicAddressRecId, true);

        update_recordSet logisticsElectronicAddressSet
                setting IsPrimary = NoYes::No
                where logisticsElectronicAddressSet.Location == returnLogisticLocationRecId
                    && logisticsElectronicAddressSet.Type == type
                    && logisticsElectronicAddressSet.RecId != logisticsElectronicAddressRecId;

        if (!logisticsElectronicAddress)
        {
            logisticsElectronicAddress.initValue();
            logisticsElectronicAddress.Type = type;
            logisticsElectronicAddress.Location = logisticsLocation.RecId;
        }

        logisticsElectronicAddress.Locator = value;
        logisticsElectronicAddress.IsPrimary = NoYes::Yes;
        logisticsElectronicAddress.IsPrivate = NoYes::No;

        logisticsElectronicAddress.write();

        returnLogisticsElectronicAddressId = logisticsElectronicAddress.RecId;

        return [returnLogisticLocationRecId, returnLogisticsElectronicAddressId, returnLogisticsLocationId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>upsertPartyLogisticsElectronicAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts or updates the electronic address based on the locator.
    /// </summary>
    /// <param name="party">
    /// Party of this customer
    /// </param>
    /// <param name="logisticsElectronicAddressRecId">
    /// RecId of LogisticsElectronic address.
    /// </param>
    /// <param name="value">
    /// Value of the loator.
    /// </param>
    /// <param name="logisticsLocationRecId">
    /// Value of the location record id.
    /// </param>
    /// <param name="type">
    /// Type of the electronic address.
    /// </param>
    /// <param name="parentLocationRecId">
    /// Value of the parent location record id.
    /// </param>
    /// <returns>
    /// A container object with Location Id and electronic address id.
    /// </returns>
    private static container upsertPartyLogisticsElectronicAddress(
            RecId party,
            RecId logisticsElectronicAddressRecId,
            LogisticsElectronicAddressLocator value,
            LogisticsLocationRecId logisticsLocationRecId,
            LogisticsElectronicAddressMethodType type,
            LogisticsLocationRecId parentLocationRecId)
    {
        LogisticsElectronicAddress logisticsElectronicAddress, logisticsElectronicAddressSet;
        LogisticsLocation logisticsLocation;
        DirPartyLocation partyLocation;
        RecId logisticsElectronicAddressId;
        LogisticsLocationRecId returnLocationRecId;
        LogisticsLocationId returnLogisticsLocationId;

        if (logisticsElectronicAddressRecId && logisticsLocationRecId)
        {
            // logisticsElectronicAddressRecId is provided
            // this must be update
            logisticsLocation = LogisticsLocation::find(logisticsLocationRecId);

            returnLocationRecId = logisticsLocation.RecId;
            returnLogisticsLocationId = logisticsLocation.LocationId;

            update_recordSet logisticsElectronicAddressSet
                setting IsPrimary = NoYes::No
                where logisticsElectronicAddressSet.Location == returnLocationRecId
                    && logisticsElectronicAddressSet.Type == type
                    && logisticsElectronicAddressSet.RecId != logisticsElectronicAddressRecId;

            logisticsElectronicAddress = LogisticsElectronicAddress::findRecId(logisticsElectronicAddressRecId, true);

            // Update
            logisticsElectronicAddress.Locator = value;
            logisticsElectronicAddress.Description = subStr(value, 0, 60);
            logisticsElectronicAddress.IsPrimary = NoYes::Yes;
            logisticsElectronicAddress.update();

            logisticsElectronicAddressId = logisticsElectronicAddress.RecId;
        }
        else
        {
            if (value)
            {
                // logisticsElectronicAddressRecId is not provided
                // this must be insert

                // first check if there is existing location
                if (logisticsLocationRecId)
                {
                    logisticsLocation = LogisticsLocation::find(logisticsLocationRecId);
                    returnLocationRecId = logisticsLocation.RecId;
                    returnLogisticsLocationId = logisticsLocation.LocationId;
                }
                else
                {
                    // otherwise create location first
                    logisticsLocation.initValue();
                    logisticsLocation.IsPostalAddress = NoYes::No;
                    logisticsLocation.ParentLocation = parentLocationRecId;
                    logisticsLocation.insert();

                    // create DirPartyLocation
                    partyLocation.initValue();
                    partyLocation.Party = party;
                    partyLocation.Location = logisticsLocation.RecId;
                    partyLocation.IsPostalAddress = NoYes::No;
                    partyLocation.insert();

                    returnLocationRecId = logisticsLocation.RecId;
                    returnLogisticsLocationId = logisticsLocation.LocationId;
                }

                update_recordSet logisticsElectronicAddressSet
                    setting IsPrimary = NoYes::No
                    where logisticsElectronicAddressSet.Location == returnLocationRecId
                       && logisticsElectronicAddressSet.Type == type
                       && logisticsElectronicAddressSet.RecId != logisticsElectronicAddressRecId;

                // create eletronic address
                logisticsElectronicAddress.initValue();
                logisticsElectronicAddress.Type = type;
                logisticsElectronicAddress.Location = returnLocationRecId;
                logisticsElectronicAddress.Locator = value;
                logisticsElectronicAddress.IsPrimary = NoYes::Yes;
                logisticsElectronicAddress.Description = subStr(value, 0, 60);
                logisticsElectronicAddress.insert();

                logisticsElectronicAddressId = logisticsElectronicAddress.RecId;
            }
            // if value is not provided, do nothing
        }

        return [returnLocationRecId, logisticsElectronicAddressId, returnLogisticsLocationId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCustomerStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for checking the status of the customer account i.e.,
    /// 1.Existence of the customer
    /// 2.Blocked/Unblocked
    /// 3.Credit limit
    /// </summary>
    /// <param name="_custAccount">
    /// ID of the CustTable.AccountNum field.
    /// </param>
    /// <param name="_salesAmount">
    /// <c>AmountMST</c>
    /// </param>
    /// <param name="_currencyCode">
    /// <c>CurrencyCode</c>
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fails to check the status of the customer account.
    /// </exception>
    public static container validateCustomerStatus(CustAccount _custAccount, AmountMST  _salesAmount, CurrencyCode _currencyCode)
    {
        container   custStatus = [false,0];
        AmountMST   creditMax = 0;

        TypeOfCreditmaxCheck creditMaxCheck = CustParameters::find().CreditMaxCheck;

        #Define.UserTab('\t')

        if (_currencyCode != CompanyInfoHelper::standardCurrency())
            _salesAmount = CurrencyExchangeHelper::amountCur2MST(_salesAmount, _currencyCode);

        try
        {
            if (!CustTable::checkExistAndOpen(_custAccount, _salesAmount))
            {
                custStatus = [false,strFmt("@RET4170018", _custAccount)];
            }
            else
            {
                CreditLineErrorType creditLineError = CustParameters::find().CreditLineError;
                boolean checkCreditLimitWarning;

                if (FeatureStateProvider::isFeatureEnabled(RetailSkipCreditLimitCheckInPOSWhenInReviewFeature::instance()))
                {
                    checkCreditLimitWarning = creditLineError == CreditLineErrorType::Warning || creditLineError == CreditLineErrorType::MCRReview;
                }
                else
                {
                    checkCreditLimitWarning = creditLineError == CreditLineErrorType::MCRReview;
                }

                if (CustTable::checkCreditLimit(_custAccount,
                                                creditMaxCheck,
                                                _salesAmount,
                                                checkCreditLimitWarning))
                {
                    custStatus = [true,''];
                }
                else
                {
                    if (RetailOrdersFeatureControl::allowThirdElementInReturnForValidateCustomerStatus())
                    {
                        custStatus = [false, strRem(infolog.text(), #UserTab), int2Str(Microsoft.Dynamics.Commerce.Runtime.DataModel.CreditLimitErrorType::CreditLimitExceeded)];
                    }
                    else
                    {
                        custStatus = [false, strRem(infolog.text(), #UserTab)];
                    }
                }
            }
        }
        catch
        {
            str axCallStack = con2Str(xSession::xppCallStack()); // Use AX call stack for Exception::Error
            eventSource.EventWriteCustomerValidateStatusException(funcName(), axCallStack);
            throw error("@RET2382");
        }

        infolog.clear(0);

        return custStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCustomerStatusV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for checking the status of the customer account i.e.,
    /// 1.Existence of the customer
    /// 2.Blocked/Unblocked
    /// 3.Credit limit
    /// </summary>
    /// <param name="_custAccount">
    /// ID of the CustTable.AccountNum field.
    /// </param>
    /// <param name="_salesAmount">
    /// <c>AmountMST</c>
    /// </param>
    /// <param name="_currencyCode">
    /// <c>CurrencyCode</c>
    /// </param>
    /// <param name="_skipCreditLimitCheckAmount">
    /// Amount that should not be considered during credit limit check.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fails to check the status of the customer account.
    /// </exception>
    public static container validateCustomerStatusV2(CustAccount _custAccount, AmountMST  _salesAmount, CurrencyCode _currencyCode, AmountMST _skipCreditLimitCheckAmount = 0)
    {
        container   custStatus = [false,0];
        AmountMST   creditMax = 0;

        TypeOfCreditmaxCheck creditMaxCheck = CustParameters::find().CreditMaxCheck;

        #Define.UserTab('\t')

        if (_currencyCode != CompanyInfoHelper::standardCurrency())
            _salesAmount = CurrencyExchangeHelper::amountCur2MST(_salesAmount, _currencyCode);

        try
        {
            if (!CustTable::checkExistAndOpen(_custAccount, _salesAmount))
            {
                custStatus = [false,strFmt("@RET4170018", _custAccount)];
            }
            else
            {
                CreditLineErrorType creditLineError = CustParameters::find().CreditLineError;
                boolean checkCreditLimitWarning;

                if (FeatureStateProvider::isFeatureEnabled(RetailSkipCreditLimitCheckInPOSWhenInReviewFeature::instance()))
                {
                    checkCreditLimitWarning = creditLineError == CreditLineErrorType::Warning || creditLineError == CreditLineErrorType::MCRReview;
                }
                else
                {
                    checkCreditLimitWarning = creditLineError == CreditLineErrorType::MCRReview;
                }

                if (CustTable::checkCreditLimit(_custAccount,
                                                creditMaxCheck,
                                                _salesAmount,
                                                checkCreditLimitWarning))
                {
                    custStatus = [true,''];
                }
                else
                {
                    if (_skipCreditLimitCheckAmount > 0 &&
                        RetailTransactionServiceCustomer::CheckCreditLimitForOpenCustomerOrders(_custAccount, creditMaxCheck, _salesAmount - _skipCreditLimitCheckAmount, _skipCreditLimitCheckAmount, checkCreditLimitWarning))
                    {
                        custStatus = [true,''];
                    }
                    else
                    {
                        if (RetailOrdersFeatureControl::allowThirdElementInReturnForValidateCustomerStatus())
                        {
                            custStatus = [false, strRem(infolog.text(), #UserTab), int2Str(Microsoft.Dynamics.Commerce.Runtime.DataModel.CreditLimitErrorType::CreditLimitExceeded)];
                        }
                        else
                        {
                            custStatus = [false, strRem(infolog.text(), #UserTab)];
                        }
                    }
                }
            }
        }
        catch
        {
            str axCallStack = con2Str(xSession::xppCallStack()); // Use AX call stack for Exception::Error
            eventSource.EventWriteCustomerValidateStatusException(funcName(), axCallStack);
            throw error("@RET2382");
        }

        infolog.clear(0);

        return custStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCustomerStatusV3</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for checking the status of the customer account i.e.,
    /// 1.Existence of the customer
    /// 2.Blocked/Unblocked
    /// 3.Credit limit
    /// </summary>
    /// <param name="_custAccount">
    /// ID of the CustTable.AccountNum field.
    /// </param>
    /// <param name="_salesAmount">
    /// <c>AmountMST</c>
    /// </param>
    /// <param name="_currencyCode">
    /// <c>CurrencyCode</c>
    /// </param>
    /// <param name="_skipCreditLimitCheckAmount">
    /// Amount that should not be considered during credit limit check.
    /// </param>
    /// </param>
    /// <param name="_skipCreditLimitCheckDeliveredAmount">
    /// Delivered amount that should not be considered during credit limit check.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fails to check the status of the customer account.
    /// </exception>
    public static container validateCustomerStatusV3(CustAccount _custAccount, AmountMST  _salesAmount, CurrencyCode _currencyCode, AmountMST _skipCreditLimitCheckAmount = 0, AmountMST _skipCreditLimitCheckDeliveredAmount = 0)
    {
        container   custStatus = [false, 0];
        AmountMST   creditMax = 0;

        TypeOfCreditmaxCheck creditMaxCheck = CustParameters::find().CreditMaxCheck;

        #Define.UserTab('\t')

        if (_currencyCode != CompanyInfoHelper::standardCurrency())
            _salesAmount = CurrencyExchangeHelper::amountCur2MST(_salesAmount, _currencyCode);

        try
        {
            if (!CustTable::checkExistAndOpen(_custAccount, _salesAmount))
            {
                custStatus = [false, strFmt("@RET4170018", _custAccount)];
            }
            else
            {
                CreditLineErrorType creditLineError = CustParameters::find().CreditLineError;
                boolean checkCreditLimitWarning;

                if (FeatureStateProvider::isFeatureEnabled(RetailSkipCreditLimitCheckInPOSWhenInReviewFeature::instance()))
                {
                    checkCreditLimitWarning = creditLineError == CreditLineErrorType::Warning || creditLineError == CreditLineErrorType::MCRReview;
                }
                else
                {
                    checkCreditLimitWarning = creditLineError == CreditLineErrorType::MCRReview;
                }

                if (CustTable::checkCreditLimit(_custAccount,
                                                creditMaxCheck,
                                                _salesAmount,
                                                checkCreditLimitWarning))
                {
                    custStatus = [true, ''];
                }
                else
                {
                    if (RetailOrdersCreditLimitCheckForPickupFlight::instance().isEnabled() &&
                        _skipCreditLimitCheckAmount > 0 &&
                        RetailTransactionServiceCustomer::CheckCreditLimitForOpenCustomerOrders(_custAccount, creditMaxCheck, _salesAmount - _skipCreditLimitCheckAmount, _skipCreditLimitCheckAmount, checkCreditLimitWarning))
                    {
                        custStatus = [true, ''];
                    }
                    else if (_skipCreditLimitCheckDeliveredAmount > 0 &&
                        RetailTransactionServiceCustomer::CheckCreditLimitForDeliveredCustomerOrders(_custAccount, creditMaxCheck, _salesAmount - _skipCreditLimitCheckDeliveredAmount, _skipCreditLimitCheckDeliveredAmount, checkCreditLimitWarning))
                    {
                        custStatus = [true, ''];
                    }
                    else
                    {
                        if (RetailOrdersFeatureControl::allowThirdElementInReturnForValidateCustomerStatus())
                        {
                            custStatus = [false, strRem(infolog.text(), #UserTab), int2Str(Microsoft.Dynamics.Commerce.Runtime.DataModel.CreditLimitErrorType::CreditLimitExceeded)];
                        }
                        else
                        {
                            custStatus = [false, strRem(infolog.text(), #UserTab)];
                        }
                    }
                }
            }
        }
        catch
        {
            str axCallStack = con2Str(xSession::xppCallStack()); // Use AX call stack for Exception::Error
            eventSource.EventWriteCustomerValidateStatusException(funcName(), axCallStack);
            throw error("@RET2382");
        }

        infolog.clear(0);

        return custStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>CheckCreditLimitForOpenCustomerOrders</Name>
				<Source><![CDATA[
    private static boolean CheckCreditLimitForOpenCustomerOrders(CustAccount          _custAccount,
                                                                 TypeOfCreditmaxCheck _creditMaxCheck            = CustParameters::find().CreditMaxCheck,
                                                                 AmountMST            _pendingAmountToVerify     = 0,
                                                                 AmountMST            _openOrderAmountToVerify   = 0,
                                                                 boolean              _warning                   = CustParameters::find().CreditLineError == CreditLineErrorType::Warning,
                                                                 boolean              _mcrReview                 = false)
    {
        AmountMST amountMST = _pendingAmountToVerify;

        // we already consider _openOrderAmountToVerify in balance when creditMaxCheck == TypeOfCreditmaxCheck::BalanceAll
        if (_creditMaxCheck != TypeOfCreditmaxCheck::BalanceAll)
        {
            amountMST = amountMST + _openOrderAmountToVerify;
        }

        return CustTable::checkCreditLimit(_custAccount, _creditMaxCheck, amountMST, _mcrReview);
    }

]]></Source>
			</Method>
			<Method>
				<Name>CheckCreditLimitForDeliveredCustomerOrders</Name>
				<Source><![CDATA[
    private static boolean CheckCreditLimitForDeliveredCustomerOrders(CustAccount          _custAccount,
                                                                      TypeOfCreditmaxCheck _creditMaxCheck            = CustParameters::find().CreditMaxCheck,
                                                                      AmountMST            _pendingAmountToVerify     = 0,
                                                                      AmountMST            _deliveredAmountToVerify   = 0,
                                                                      boolean              _warning                   = CustParameters::find().CreditLineError == CreditLineErrorType::Warning,
                                                                      boolean              _mcrReview                 = false)
    {
        AmountMST amountMST = _pendingAmountToVerify;

        // we already consider _deliveredAmountToVerify in balance when creditMaxCheck == TypeOfCreditmaxCheck::BalanceDelivered
        if (_creditMaxCheck != TypeOfCreditmaxCheck::BalanceDelivered)
        {
            amountMST = amountMST + _deliveredAmountToVerify;
        }

        return CustTable::checkCreditLimit(_custAccount, _creditMaxCheck, amountMST, _mcrReview);
    }

]]></Source>
			</Method>
			<Method>
				<Name>CreateAsyncCustomers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create the customers for entries in <c>RetailAsyncCustomer</c> and update <c>RetailTransactionTable</c> with the newly created customer account.
    /// </summary>
    public static void CreateAsyncCustomers()
    {
        RetailAsyncCustomer asyncCust;

        // Process the Async customers...
        while select forupdate asyncCust where
            asyncCust.OnlineCustCreated == NoYes::No
        {
            System.Exception ex;

            try
            {
                // For each async customer where we have not created the AX online version - do so (including any addresses)...
                RetailTransactionServiceCustomer::createAsyncCustomerWithAddresses(asyncCust);
            }
            catch (ex)
            {
                warning(ex.Message);
                warning("@Retail:AsyncCustomerCreateError");
                eventSource.EventWriteCreateAsyncCustomerWithAddressesFailed(strFmt('CustAccountAsync: %1, Exception: %2', asyncCust.CustAccountAsync, ex.ToString()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>CreateAsyncCustomerWithAddresses</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a customer account for the customer if it has not been created yet. Link the account to RetailCustTable.
    /// Creates any new addresses, attributes, affiliations, and contacts associated with the customer if it has been created.
    /// </summary>
    /// <remarks>Think of this method as 'create and/or update async customer'.</remarks>
    /// <param name = "asyncCust">The async customer for which we need a customer.</param>
    /// <returns>The <c>CustAccount</c> for the async customer.</returns>
    public static CustAccount CreateAsyncCustomerWithAddresses(RetailAsyncCustomer asyncCust)
    {
        CustAccount newCustAccount;
        System.Exception ex;

        try
        {
            newCustAccount = RetailTransactionServiceCustomer::createCustAccountForAsyncCustomer(asyncCust);

            // Handle addresses for the customer which exist in the RetailAsyncAddress table.
            RetailTransactionServiceCustomer::createAddressesForAsyncCustomer(asyncCust);

            // Handle addresses for the customer which exist in the RetailAsyncAddressV2 table.
            // Note: This table was introduced as part of the Async adress creation feature.
            // We want to ensure that all records here are processed regardless of the feature state.
            RetailTransactionServiceCustomer::processAsyncAddressOperationForAsyncCustomer(asyncCust);

            // Handle async customer attributes, affiliations and contacts.
            RetailTransactionServiceCustomer::processAsyncAttributesForAsyncCustomer(asyncCust);
            RetailTransactionServiceCustomer::processAsyncCustAttributeOperation(asyncCust.CustAccountAsync, true);

            RetailTransactionServiceCustomer::processAsyncAffiliationsForAsyncCustomer(asyncCust);
            RetailTransactionServiceCustomer::processAsyncContactsForAsyncCustomer(asyncCust);
            RetailTransactionServiceCustomer::processExternalIdentityLinkForAsyncCustomer(asyncCust);
        }
        catch (ex)
        {
            warning(ex.Message);
            warning("@Retail:AsyncCustomerCreateError");
            eventSource.EventWriteCreateAsyncCustomerWithAddressesFailed(strFmt('CustAccountAsync: %1, Exception: %2', asyncCust.CustAccountAsync, ex.ToString()));
        }

        return newCustAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processAsyncCustAffiliationOperation</Name>
				<Source><![CDATA[
    /// <summary>If the customer exists, create all new affiliations associated with the customer.</summary>
    /// <param name = "asyncCustAffiliation">The async customer affiliation(s) which should be created.</param>
    /// <param name = "custAccount">The customer whose async affiliation(s) should be created.</param>
    [Hookable(false)]
    internal static void processAsyncCustAffiliationOperation(RetailAsyncCustomerAffiliation asyncCustAffiliation, CustAccount custAccount)
    {
        if (!asyncCustAffiliation && !System.String::IsNullOrWhiteSpace(custAccount))
        {
            return;
        }

        CustTable custTable = CustTable::find(custAccount);
        // Ensure that the record is set to be updatable.
        asyncCustAffiliation.selectForupdate(true);

        // Save the line number in the InfoLog.
        int fromLine = Global::infologLine();

        switch (asyncCustAffiliation.Operation)
        {
            case RetailAsyncOperation::Create:
                // Check if affiliation already exists for the sync customer.
                if (!System.String::IsNullOrWhiteSpace(asyncCustAffiliation.CustAccount))
                {
                    RetailCustAffiliation custAffiliation = RetailCustAffiliation::findByIdAndCustomer(asyncCustAffiliation.RetailAffiliationId, custAccount, true);
                    if (custAffiliation)
                    {
                        eventSource.EventWriteCreateCustomerAsyncAffiliationAlreadyExists(custTable.RecId, asyncCustAffiliation.CustAccountAsync, asyncCustAffiliation.OperationId, custAffiliation.RecId);

                        // The affiliation already exists so mark the record on the 'RetailAsyncCustomerAffiliation' table as processed.
                        asyncCustAffiliation.OnlineOperationCompleted = NoYes::Yes;
                        asyncCustAffiliation.CustAccount = custAccount;
                        asyncCustAffiliation.RetailCustAffiliation = custAffiliation.RecId;
                        asyncCustAffiliation.LastKnownError = '';
                        asyncCustAffiliation.update();

                        break;
                    }
                }

                try
                {
                    // This is a new async customer so add their affiliations to the 'RetailCustAffiliation' table.
                    RetailCustAffiliation custAffiliation;
                    custAffiliation.initValue();
                    custAffiliation.CustAccountNum = custAccount;
                    custAffiliation.RetailAffiliationId = asyncCustAffiliation.RetailAffiliationId;
                    custAffiliation.ChannelReferenceId = asyncCustAffiliation.ChannelReferenceId;
                    custAffiliation.insert();

                    // Update the async customer affiliation record by marking it as processed.
                    if (custAffiliation.RecId)
                    {
                        asyncCustAffiliation.OnlineOperationCompleted = NoYes::Yes;
                        asyncCustAffiliation.CustAccount = custAccount;
                        asyncCustAffiliation.RetailCustAffiliation = custAffiliation.RecId;
                        asyncCustAffiliation.LastKnownError = '';
                        asyncCustAffiliation.update();

                        eventSource.EventWriteCreateCustomerAsyncAffiliationProcessingSuccessful(CustTable.RecId, asyncCustAffiliation.CustAccountAsync, asyncCustAffiliation.OperationId, custAffiliation.RecId, asyncCustAffiliation.Operation);
                    }
                    else
                    {
                        // Save the last known error.
                        asyncCustAffiliation.LastKnownError = strFmt("@Retail:AsyncCustomerAffilationCreationError", RetailTransactionServiceUtilities::getInfologMessages(fromLine));
                        asyncCustAffiliation.update();

                        // Log failure to create affiliation.
                        eventSource.EventWriteCreateCustomerAsyncAffiliationException(CustTable.RecId, asyncCustAffiliation.CustAccountAsync, asyncCustAffiliation.OperationId);
                    }
                }
                catch (Exception::Error)
                {
                    // Save the last known error.
                    asyncCustAffiliation.LastKnownError = strFmt("@Retail:AsyncCustomerAffilationCreationError", RetailTransactionServiceUtilities::getInfologMessages(fromLine));
                    asyncCustAffiliation.update();
                }

                break;
            case RetailAsyncOperation::Delete:
                try
                {
                    RetailCustAffiliation custAffiliationToRemove;
                    delete_from custAffiliationToRemove where custAffiliationToRemove.CustAccountNum == custAccount && custAffiliationToRemove.RetailAffiliationId == asyncCustAffiliation.RetailAffiliationId;

                    // Update the async customer affiliation record by marking it as processed.
                    asyncCustAffiliation.OnlineOperationCompleted = NoYes::Yes;
                    asyncCustAffiliation.CustAccount = custAccount;
                    asyncCustAffiliation.RetailCustAffiliation = 0;
                    asyncCustAffiliation.LastKnownError = '';
                    asyncCustAffiliation.update();

                    eventSource.EventWriteCreateCustomerAsyncAffiliationProcessingSuccessful(CustTable.RecId, asyncCustAffiliation.CustAccountAsync, asyncCustAffiliation.OperationId, 0, asyncCustAffiliation.Operation);
                }
                catch (Exception::Error)
                {
                    // Save the last known error.
                    asyncCustAffiliation.LastKnownError = strFmt("@Retail:AsyncCustomerAffilationDeletionError", RetailTransactionServiceUtilities::getInfologMessages(fromLine));
                    asyncCustAffiliation.update();
                }

                break;
            default:
                // Do nothing.
                eventSource.EventWriteCreateCustomerAsyncAffiliationUnhandledOperationType(CustTable.RecId, asyncCustAffiliation.CustAccountAsync, asyncCustAffiliation.OperationId, asyncCustAffiliation.Operation);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processAsyncCustContactOperation</Name>
				<Source><![CDATA[
    /// <summary>If the customer exists, create all new contacts associated with the customer.</summary>
    /// <param name = "asyncCustContact">The async customer contact(s) which should be created.</param>
    /// <param name = "custAccount">The customer whose async contact(s) should be created.</param>
    internal static void processAsyncCustContactOperation(RetailAsyncCustomerContact asyncCustContact, CustAccount custAccount)
    {
        if (!asyncCustContact && !System.String::IsNullOrWhiteSpace(custAccount))
        {
            return;
        }

        // Ensure that the record is set to be updatable.
        asyncCustContact.selectForupdate(true);
        CustTable custTable = CustTable::find(custAccount);

        // Save the current line number within InfoLog.
        int fromLine = Global::infologLine();

        switch(asyncCustContact.Operation)
        {
            case RetailAsyncOperation::Create:
                // Check if contacts already exist for this sync customer.
                if (!System.String::IsNullOrWhiteSpace(asyncCustContact.CustAccount))
                {
                    LogisticsElectronicAddress lea = LogisticsElectronicAddress::findAllByDirPartyRecId(custTable.Party);
                    if (lea)
                    {
                        while select lea
                        {
                            boolean areSame = strCmp(lea.Description, asyncCustContact.Description) == 0
                                && lea.IsPrimary == asyncCustContact.IsPrimary
                                && lea.IsPrivate == asyncCustContact.IsPrivate
                                && lea.IsMobilePhone == asyncCustContact.IsMobilePhone
                                && lea.Type == asyncCustContact.Type
                                && strCmp(lea.Locator, asyncCustContact.Locator) == 0
                                && strCmp(lea.LocatorExtension , asyncCustContact.LocatorExtension) == 0
                                && lea.RetailMarketingOptIn == asyncCustContact.RetailMarketingOptIn;

                            if (areSame)
                            {
                                // The contact already exists so mark the record on the 'RetailAsyncCustomerContact' table as processed.
                                eventSource.EventWriteCreateCustomerAsyncContactAlreadyExists(custTable.RecId, asyncCustContact.CustAccountAsync, asyncCustContact.OperationId, lea.RecId);

                                asyncCustContact.OnlineOperationCompleted = NoYes::Yes;
                                asyncCustContact.CustAccount = CustAccount;
                                asyncCustContact.LogisticsElectronicAddress = lea.RecId;
                                asyncCustContact.LastKnownError = '';
                                asyncCustContact.update();
                            }
                        }

                        break;
                    }
                }

                try
                {
                    CustomerEntity customer = new CustomerEntity(custTable, DateTimeUtil::utcNow());
                    DirPartyContactInfoView contactInfoView, updatedContactInfoView;

                    contactInfoView.LocationName = asyncCustContact.Description;
                    contactInfoView.Type = asyncCustContact.Type;
                    contactInfoView.Locator = asyncCustContact.Locator;
                    contactInfoView.LocatorExtension = asyncCustContact.LocatorExtension;
                    contactInfoView.IsPrimary = asyncCustContact.IsPrimary;
                    contactInfoView.IsPrivate = asyncCustContact.IsPrivate;
                    contactInfoView.Party = custTable.Party;
                    updatedContactInfoView = customer.createOrUpdateContactInfo(contactInfoView);

                    // If creation of contact was successful, update the RetailAsyncCustomerContact record to indicate that it's been processed.
                    if (updatedContactInfoView.ElectronicAddress)
                    {
                        // Set the 'ChannelReferenceId' and 'RetailMarketingOptIn' fields when required.
                        if (asyncCustContact.RetailMarketingOptIn || !System.String::IsNullOrWhiteSpace(asyncCustContact.ChannelReferenceId))
                        {
                            LogisticsElectronicAddress logisticsElectronicAddress = LogisticsElectronicAddress::findRecId(updatedContactInfoView.ElectronicAddress, true);
                            if (logisticsElectronicAddress)
                            {
                                logisticsElectronicAddress.RetailMarketingOptIn = asyncCustContact.RetailMarketingOptIn;

                                if (!System.String::IsNullOrWhiteSpace(asyncCustContact.ChannelReferenceId))
                                {
                                    logisticsElectronicAddress.ChannelReferenceId = asyncCustContact.ChannelReferenceId;
                                }

                                logisticsElectronicAddress.update();
                            }
                        }

                        asyncCustContact.OnlineOperationCompleted = NoYes::Yes;
                        asyncCustContact.CustAccount = custAccount;
                        asyncCustContact.LogisticsElectronicAddress = updatedContactInfoView.ElectronicAddress;
                        asyncCustContact.LastKnownError = '';
                        asyncCustContact.update();

                        eventSource.EventWriteCreateCustomerAsyncContactProcessingSuccessful(custTable.RecId, asyncCustContact.CustAccountAsync, asyncCustContact.OperationId, asyncCustContact.LogisticsElectronicAddress);
                    }
                    else
                    {
                        // Save the last known error.
                        asyncCustContact.LastKnownError = strFmt("@Retail:AsyncCustomerContactCreationError", RetailTransactionServiceUtilities::getInfologMessages(fromLine));
                        asyncCustContact.update();

                        // Insertion was not successful, add exception logging.
                        eventSource.EventWriteCreateCustomerAsyncContactException(custTable.RecId, asyncCustContact.CustAccountAsync, asyncCustContact.OperationId);
                    }
                }
                catch (Exception::Error)
                {
                    // Save the last known error.
                    asyncCustContact.LastKnownError = strFmt("@Retail:AsyncCustomerContactCreationError", RetailTransactionServiceUtilities::getInfologMessages(fromLine));
                    asyncCustContact.update();

                    eventSource.EventWriteCreateCustomerAsyncContactException(custTable.RecId, asyncCustContact.CustAccountAsync, asyncCustContact.OperationId);
                }

                break;
            case RetailAsyncOperation::Update:
                // Locate the electronic address record which needs to be updated.
                LogisticsElectronicAddress recordToUpdate = LogisticsElectronicAddress::findByChannelReferenceId(asyncCustContact.ChannelReferenceId, false);

                // The LogisticsElectronicAddress field will be populated for non-async contacts which are being updated.
                if (recordToUpdate.RecId == 0 && asyncCustContact.LogisticsElectronicAddress != 0)
                {
                    recordToUpdate = LogisticsElectronicAddress::findRecId(asyncCustContact.LogisticsElectronicAddress, false);
                }

                if (recordToUpdate.RecId == 0)
                {
                    // Save the last known error.
                    asyncCustContact.LastKnownError = "@Retail:AsyncContactUpdateFailedWhenUnableToLocateParent";
                    asyncCustContact.update();

                    eventSource.EventWriteCreateCustomerAsyncContactProcessingFailedDueToMissingParentRecord(custTable.RecId, asyncCustContact.ChannelReferenceId, asyncCustContact.OperationId);
                    break;
                }

                try
                {
                    // Update the electronic adddress record.
                    CustomerEntity targetCustomer = new CustomerEntity(custTable, asyncCustContact.OperationTimeStamp);
                    DirPartyContactInfoView contactView, updatedContactView;

                    contactView.LocationName = asyncCustContact.Description;
                    contactView.Type = asyncCustContact.Type;
                    contactView.Locator = asyncCustContact.Locator;
                    contactView.LocatorExtension = asyncCustContact.LocatorExtension;
                    contactView.IsPrimary = asyncCustContact.IsPrimary;
                    contactView.IsPrivate = asyncCustContact.IsPrivate;
                    contactView.Party = custTable.Party;
                    contactView.ElectronicAddress = recordToUpdate.RecId;
                    updatedContactView = targetCustomer.createOrUpdateContactInfo(contactView);

                    // If update of contact was successful, update the RetailAsyncCustomerContact record to indicate that it's been processed.
                    if (updatedContactView.ElectronicAddress)
                    {
                        // Update the ChannelReferenceId and RetailMarketingOptin fields.
                        recordToUpdate = LogisticsElectronicAddress::findRecId(updatedContactView.ElectronicAddress, true);
                        if (recordToUpdate)
                        {
                            recordToUpdate.RetailMarketingOptIn = asyncCustContact.RetailMarketingOptIn;
                            recordToUpdate.ChannelReferenceId = asyncCustContact.ChannelReferenceId;
                            recordToUpdate.update();
                        }

                        // Update the async contact record.
                        asyncCustContact.OnlineOperationCompleted = NoYes::Yes;
                        asyncCustContact.CustAccount = custAccount;
                        asyncCustContact.LogisticsElectronicAddress = updatedContactView.ElectronicAddress;
                        asyncCustContact.LastKnownError = '';
                        asyncCustContact.update();

                        eventSource.EventWriteUpdateCustomerAsyncContactProcessingSuccessful(custTable.RecId, asyncCustContact.CustAccountAsync, asyncCustContact.OperationId, asyncCustContact.LogisticsElectronicAddress);
                    }
                    else
                    {
                        // Save the last known error.
                        asyncCustContact.LastKnownError = strFmt("@Retail:AsyncCustomerContactUpdateError", RetailTransactionServiceUtilities::getInfologMessages(fromLine));
                        asyncCustContact.update();

                        // Log the update operation as having failed.
                        eventSource.EventWriteUpdateCustomerAsyncContactFailed(custTable.RecId, asyncCustContact.CustAccountAsync, asyncCustContact.OperationId);
                    }
                }
                catch (Exception::Error)
                {
                    str errorMessage = RetailTransactionServiceUtilities::getInfologMessages(fromLine);

                    // Save the last known error.
                    asyncCustContact.LastKnownError = strFmt("@Retail:AsyncCustomerContactUpdateError", errorMessage);
                    asyncCustContact.update();

                    eventSource.EventWriteUpdateCustomerAsyncContactException(custTable.RecId, asyncCustContact.CustAccountAsync, asyncCustContact.OperationId, errorMessage);
                }

                break;
            default:
                // Do nothing.
                eventSource.EventWriteCreateCustomerAsyncContactUnhandledOperationType(custTable.RecId, asyncCustContact.CustAccountAsync, asyncCustContact.OperationId, asyncCustContact.Operation);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processAsyncAddressOperation</Name>
				<Source><![CDATA[
    /// <summary>If the customer exists, allow creating, updating and/ or deactivating any new addresses associated with the customer.</summary>
    /// <param name = "asyncAddress">The async customer address which should be processed.</param>
    /// <param name = "custAccount">The customer whose async addresses should be processed.</param>
    [Hookable(false)]
    internal static void processAsyncAddressOperation(RetailAsyncAddressV2 asyncAddress, CustAccount custAccount)
    {
        if (!asyncAddress && !System.String::IsNullOrWhiteSpace(custAccount))
        {
            return;
        }

        // Ensure that the record is set to be updatable.
        asyncAddress.selectForUpdate(true);

        // Locate the cust table record.
        CustTable custTable = CustTable::find(custAccount);

        // If sync customer doesn’t not found in HQ, then async address operation for sync customer will non retriable.
        if (custTable.RecId == 0)
        {
            asyncAddress.OnlineOperationCompleted = NoYes::Yes;
            asyncAddress.LastKnownError = strFmt("@SYS119849", custAccount);;
            asyncAddress.update();

            eventSource.EventWriteSyncToAsyncAddressFailedWhenCustomerNotFound(asyncAddress.RecId, custAccount);
            return;
        }

        // Save the current line number within InfoLog.
        int fromLine = Global::infologLine();

        switch (asyncAddress.Operation)
        {
            case RetailAsyncOperation::Create:
                // Check if the address already exists for sync customers.
                if (!System.String::IsNullOrWhiteSpace(asyncAddress.CustAccount))
                {
                    LogisticsPostalAddress logisticsPostalAddress = RetailTransactionServiceCustomer::getExistingCustomerAddress(
                        asyncAddress.Street,
                        asyncAddress.City,
                        asyncAddress.State,
                        asyncAddress.Zip,
                        asyncAddress.Country,
                        asyncAddress.StreetNumber,
                        asyncAddress.County,
                        asyncAddress.CustAccount,
                        asyncAddress.CustName,
                        asyncAddress.BuildingCompliment,
                        asyncAddress.DistrictName);

                    if (logisticsPostalAddress)
                    {
                        // This address has already been created, we will mark the record as processed.
                        asyncAddress.OnlineOperationCompleted = NoYes::Yes;
                        asyncAddress.CustAccount = custAccount;
                        asyncAddress.LogisticsPostalAddress = logisticsPostalAddress.RecId;
                        asyncAddress.LastKnownError = '';
                        asyncAddress.update();

                        // Any duplicate address located was created during the customer order creation step. Correct the channel reference id.
                        LogisticsPostalAddress::updateCommerceChannelReferenceId(asyncAddress.LogisticsPostalAddress, asyncAddress.AddressId);

                        eventSource.EventWriteAsyncAddressProcessingSuccessfulDueToExistingAddress(custTable.RecId, asyncAddress.AddressId, asyncAddress.OperationId, asyncAddress.Operation);
                        break;
                    }
                }

                try
                {
                    RetailTransactionServiceCustomer_ExtendedParameters extendedParametersForCreate = RetailTransactionServiceCustomer::extendedParameters;
                    extendedParametersForCreate.createAddress_logisticsLocationRoleRecordId = asyncAddress.LogisticsLocationRoleRecordId;
                    extendedParametersForCreate.createUpdateAddress_ValidFrom = asyncAddress.OperationTimeStamp;

                    container result = RetailTransactionServiceCustomer::createAddress(
                        custAccount,
                        asyncAddress.custName,
                        asyncAddress.Street,
                        asyncAddress.City,
                        asyncAddress.County,
                        asyncAddress.State,
                        asyncAddress.Zip,
                        asyncAddress.Country,
                        asyncAddress.Phone,
                        asyncAddress.Email,
                        asyncAddress.Url,
                        asyncAddress.TaxGroup,
                        asyncAddress.Role,
                        asyncAddress.StreetNumber,
                        asyncAddress.DistrictName,
                        asyncAddress.BuildingCompliment,
                        asyncAddress.MakePostalAddressPrimary);

                    boolean addressCreationFailed = false;
                    str addressCreationError = '';

                    if (conLen(result) >= 1)
                    {
                        boolean addressCreated = conPeek(result, 1); // validInsert

                        if (addressCreated)
                        {
                            // Update the customer account value on the address record.
                            if (asyncAddress.CustAccount == '')
                            {
                                asyncAddress.CustAccount = custAccount;
                            }

                            // Update the link to logisticspostaladdress table.
                            asyncAddress.LogisticsPostalAddress = conPeek(result, 6);

                            // Mark the record as processed.
                            asyncAddress.OnlineOperationCompleted = NoYes::Yes;
                            asyncAddress.LastKnownError = '';
                            asyncAddress.update();

                            LogisticsPostalAddress::updateCommerceChannelReferenceId(asyncAddress.LogisticsPostalAddress, asyncAddress.AddressId);
                            eventSource.EventWriteAsyncAddressProcessingSuccessful(custTable.RecId, asyncAddress.AddressId, asyncAddress.OperationId, asyncAddress.Operation);
                        }
                        else
                        {
                            if (conLen(result) >= 2)
                            {
                                addressCreationError = System.String::IsNullOrWhiteSpace(conPeek(result, 2)) ? '' : conPeek(result, 2);
                            }

                            addressCreationFailed = true;
                            eventSource.EventWriteCreateCustomerAsyncAddressException(custTable.RecId, asyncAddress.AddressId, addressCreationError);
                        }
                    }
                    else
                    {
                        addressCreationFailed = true;
                        addressCreationError = strFmt("@Retail:AsyncCustomerAddressOperationFailedWithUnknownError", RetailTransactionServiceUtilities::getInfologMessages(fromLine));

                        eventSource.EventWriteAsyncAddressProcessingFailedDueToUnparsableResult(custTable.RecId, asyncAddress.AddressId, asyncAddress.OperationId, asyncAddress.Operation);
                    }

                    if (addressCreationFailed)
                    {
                        // Save the last known error.
                        asyncAddress.LastKnownError = addressCreationError;
                        asyncAddress.update();
                    }
                }
                catch (Exception::Error)
                {
                    str errorMessage = RetailTransactionServiceUtilities::getInfologMessages(fromLine);

                    // Save the last known error.
                    asyncAddress.LastKnownError = strFmt("@Retail:AsyncCustomerAddressOperationFailedWithUnknownError", errorMessage);
                    asyncAddress.update();
                }

                break;
            case RetailAsyncOperation::Update:
                try
                {
                // Check if the address already exists; Otherwise update can fail with a duplicate key exception.
                    LogisticsPostalAddress existingAddress = RetailTransactionServiceCustomer::getExistingCustomerAddress(
                            asyncAddress.Street,
                            asyncAddress.City,
                            asyncAddress.State,
                            asyncAddress.Zip,
                            asyncAddress.Country,
                            asyncAddress.StreetNumber,
                            asyncAddress.County,
                            custAccount,
                            asyncAddress.CustName,
                            asyncAddress.BuildingCompliment,
                            asyncAddress.DistrictName);

                    if (existingAddress)
                    {
                        // If an existing address is detected then we may be either attempting to update the role or the isPrimary property.
                        DirPartyLocation dirPartyLocation;
                        select firstonly1 dirPartyLocation where dirPartyLocation.Location == existingAddress.Location;

                        // Update the IsPrimary property for the address, if required.
                        // NOTE: AX MANDATES that a customer should always have a primary postal address.
                        // Hence, we cannot unset the isPrimary property of an address (attempting to do so will cause no failures but will not make the change).
                        // Instead, we can only attempt to set another address as primary.
                        if (dirPartyLocation && dirPartyLocation.IsPrimary != asyncAddress.MakePostalAddressPrimary)
                        {
                            dirPartyLocation.selectForUpdate(true);
                            dirPartyLocation.IsPrimary = asyncAddress.MakePostalAddressPrimary;
                            dirPartyLocation.update();
                        }

                        // Update the address role, if required.
                        if (dirPartyLocation && asyncAddress.LogisticsLocationRoleRecordId != 0)
                        {
                            // Please note that when the role for an address is changed, the LogisticsLocationRoleRecordId holds the new role value instead of the 'Role' field.
                            RecId locationRoleRecId = LogisticsLocationRole::findRec(asyncAddress.LogisticsLocationRoleRecordId, false).RecId;

                            // Get partyLocationRole record for partylocation and locationrole.
                            DirPartyLocationRole partyLocationRole;
                            select firstonly partyLocationRole
                                    where partyLocationRole.PartyLocation == dirPartyLocation.RecId && partyLocationRole.LocationRole == locationRoleRecId;

                            // If partyLocationRole has record, then will set replaceRoles as "false" which control the delete record functionality for DirPartyLocationRole.
                            boolean replaceRoles = true;
                            if (partyLocationRole.RecId)
                            {
                                replaceRoles = false;
                            }

                            if (locationRoleRecId)
                            {
                                DirPartyLocationRole::createPartyLocationRoles(dirPartyLocation.RecId, [locationRoleRecId], replaceRoles);
                            }
                        }

                        // This address has already been created, we will mark the record as processed.
                        asyncAddress.OnlineOperationCompleted = NoYes::Yes;
                        asyncAddress.CustAccount = custAccount;
                        asyncAddress.LogisticsPostalAddress = existingAddress.RecId;
                        asyncAddress.LastKnownError = '';
                        asyncAddress.update();

                        // Update the channel reference id.
                        LogisticsPostalAddress::updateCommerceChannelReferenceId(asyncAddress.LogisticsPostalAddress, asyncAddress.AddressId);

                        eventSource.EventWriteAsyncAddressProcessingSuccessfulDueToExistingAddress(custTable.RecId, asyncAddress.AddressId, asyncAddress.OperationId, asyncAddress.Operation);
                        break;
                    }

                    // Locate the address record which needs to be updated.
                    LogisticsPostalAddress addressRecordToUpdate = LogisticsPostalAddress::findByChannelReferenceId(asyncAddress.AddressId, false);

                    // The LogisticsPostalAddress field will be populated for non-async addresses which are being updated.
                    if (addressRecordToUpdate.RecId == 0 && asyncAddress.LogisticsPostalAddress != 0)
                    {
                        addressRecordToUpdate = LogisticsPostalAddress::findRecId(asyncAddress.LogisticsPostalAddress, false);
                    }

                    if (addressRecordToUpdate.RecId == 0)
                    {
                        asyncAddress.OnlineOperationCompleted = NoYes::Yes;
                        asyncAddress.LastKnownError = "@Retail:AsyncAddressUpdateFailedWhenUnableToLocateParent";
                        asyncAddress.update();

                        eventSource.EventWriteCreateCustomerAsynAddressProcessingFailedDueToMissingParentRecord(custTable.RecId, asyncAddress.AddressId, asyncAddress.OperationId);
                        break;
                    }

                    if (asyncAddress.OperationTimeStamp && (asyncAddress.OperationTimeStamp < addressRecordToUpdate.ValidFrom || asyncAddress.OperationTimeStamp > addressRecordToUpdate.ValidTo))
                    {
                        asyncAddress.LastKnownError = "@Retail:AsyncAddressUpdateFailedWhenOperationTimeOutOfValidTimeRange";
                        asyncAddress.update();

                        eventSource.EventWriteUpdateCustomerAsynAddressFailedDueToOperationTimeOutOfValidTimeRange(custTable.RecId, asyncAddress.AddressId, asyncAddress.OperationId);
                        break;
                    }

                    // Proceeed to update the address.
                    RetailTransactionServiceCustomer_ExtendedParameters extendedParametersForUpdate = RetailTransactionServiceCustomer::extendedParameters;
                    extendedParametersForUpdate.createAddress_logisticsLocationRoleRecordId = asyncAddress.LogisticsLocationRoleRecordId;
                    extendedParametersForUpdate.createUpdateAddress_ValidFrom = asyncAddress.OperationTimeStamp;

                    container updateResult = RetailTransactionServiceCustomer::updateAddress(
                        addressRecordToUpdate.RecId,
                        asyncAddress.CustName,
                        asyncAddress.Street,
                        asyncAddress.City,
                        asyncAddress.County,
                        asyncAddress.State,
                        asyncAddress.Zip,
                        asyncAddress.Country,
                        asyncAddress.Phone,
                        asyncAddress.Email,
                        asyncAddress.Url,
                        asyncAddress.TaxGroup,
                        asyncAddress.Role,
                        0,
                        0,
                        0,
                        asyncAddress.StreetNumber,
                        asyncAddress.DistrictName,
                        asyncAddress.BuildingCompliment,
                        asyncAddress.MakePostalAddressPrimary,
                        custTable.Party);

                    boolean addressUpdateFailed = false;
                    str addressUpdateError = '';

                    // Validate the result and update the async address record.
                    if (conLen(updateResult) >= 1)
                    {
                        boolean addressUpdated = conPeek(updateResult, 1); // validInsert

                        if (addressUpdated)
                        {
                            // Update the customer account value on the address record.
                            if (asyncAddress.CustAccount == '')
                            {
                                asyncAddress.CustAccount = custAccount;
                            }

                            // Update the link to logisticspostaladdress table.
                            asyncAddress.LogisticsPostalAddress = conPeek(updateResult, 6);

                            // Mark the record as processed.
                            asyncAddress.OnlineOperationCompleted = NoYes::Yes;
                            asyncAddress.LastKnownError = '';
                            asyncAddress.update();

                            LogisticsPostalAddress::updateCommerceChannelReferenceId(asyncAddress.LogisticsPostalAddress, asyncAddress.AddressId);
                            eventSource.EventWriteAsyncAddressProcessingSuccessful(custTable.RecId, asyncAddress.AddressId, asyncAddress.OperationId, asyncAddress.Operation);
                        }
                        else
                        {
                            if (conLen(updateResult) >= 2)
                            {
                                addressUpdateError = System.String::IsNullOrWhiteSpace(conPeek(updateResult, 2)) ? '' : conPeek(updateResult, 2);
                            }

                            addressUpdateFailed = true;
                            eventSource.EventWriteCreateCustomerAsyncAddressUpdateException(custTable.RecId, asyncAddress.AddressId, addressUpdateError);
                        }
                    }
                    else
                    {
                        addressUpdateFailed = true;
                        addressUpdateError = strFmt("@Retail:AsyncCustomerAddressOperationFailedWithUnknownError", RetailTransactionServiceUtilities::getInfologMessages(fromLine));
                        eventSource.EventWriteAsyncAddressProcessingFailedDueToUnparsableResult(custTable.RecId, asyncAddress.AddressId, asyncAddress.OperationId, asyncAddress.Operation);
                    }

                    if (addressUpdateFailed)
                    {
                        asyncAddress.LastKnownError = addressUpdateError;
                        asyncAddress.update();
                    }
                }
                catch (Exception::Error)
                {
                    str errorMessage = RetailTransactionServiceUtilities::getInfologMessages(fromLine);

                    // Save the last known error.
                    asyncAddress.LastKnownError = strFmt("@Retail:AsyncCustomerAddressOperationFailedWithUnknownError", errorMessage);
                    asyncAddress.update();
                }

                break;
            case RetailAsyncOperation::Delete:
                // Locate the address record which needs to be deactivated.
                LogisticsPostalAddress addressRecordToDeactivate = LogisticsPostalAddress::findByChannelReferenceId(asyncAddress.AddressId, false);

                // The LogisticsPostalAddress field will be populated for non-async addresses which are being deactivated.
                if (addressRecordToDeactivate.RecId == 0 && asyncAddress.LogisticsPostalAddress != 0)
                {
                    addressRecordToDeactivate = LogisticsPostalAddress::findRecId(asyncAddress.LogisticsPostalAddress, false);
                }

                if (addressRecordToDeactivate.RecId == 0)
                {
                    asyncAddress.OnlineOperationCompleted = NoYes::Yes;
                    asyncAddress.LastKnownError = "@Retail:AsyncAddressDeleteFailedWhenUnableToLocateParent";
                    asyncAddress.update();

                    eventSource.EventWriteCreateCustomerAsynAddressProcessingFailedDueToMissingParentRecord(custTable.RecId, asyncAddress.AddressId, asyncAddress.OperationId);
                    break;
                }

                try
                {
                    // Proceed to deactivate the address.
                    container deactivationResult = RetailTransactionServiceCustomer::deactivateAddress(addressRecordToDeactivate.RecId, custTable.RecId);

                    boolean addressDeleteFailed = false;
                    str addressDeleteError = '';

                    // Validate the result and update the async address record.
                    if (conLen(deactivationResult) >= 1)
                    {
                        boolean addressDeactivated = conPeek(deactivationResult, 1); // validInsert

                        if (addressDeactivated)
                        {
                            // Update the customer account value on the address record.
                            if (asyncAddress.CustAccount == '')
                            {
                                asyncAddress.CustAccount = custAccount;
                            }

                            // Update the link to logisticspostaladdress table.
                            asyncAddress.LogisticsPostalAddress = addressRecordToDeactivate.RecId;

                            // Mark the record as processed.
                            asyncAddress.OnlineOperationCompleted = NoYes::Yes;
                            asyncAddress.LastKnownError = '';
                            asyncAddress.update();

                            eventSource.EventWriteAsyncAddressProcessingSuccessful(custTable.RecId, asyncAddress.AddressId, asyncAddress.OperationId, asyncAddress.Operation);
                        }
                        else
                        {
                            if (conLen(deactivationResult) >= 2)
                            {
                                addressDeleteError = System.String::IsNullOrWhiteSpace(conPeek(deactivationResult, 2)) ? '' : conPeek(deactivationResult, 2);
                            }

                            addressDeleteFailed = true;
                            eventSource.EventWriteCreateCustomerAsyncAddressDeleteException(custTable.RecId, asyncAddress.AddressId, addressDeleteError);
                        }
                    }
                    else
                    {
                        addressDeleteFailed = true;
                        addressDeleteError = strFmt("@Retail:AsyncCustomerAddressOperationFailedWithUnknownError", RetailTransactionServiceUtilities::getInfologMessages(fromLine));
                        eventSource.EventWriteAsyncAddressProcessingFailedDueToUnparsableResult(custTable.RecId, asyncAddress.AddressId, asyncAddress.OperationId, asyncAddress.Operation);
                    }

                    if (addressDeleteFailed)
                    {
                        asyncAddress.LastKnownError = addressDeleteError;
                        asyncAddress.update();
                    }
                }
                catch (Exception::Error)
                {
                    str errorMessage = RetailTransactionServiceUtilities::getInfologMessages(fromLine);

                    // Save the last known error.
                    asyncAddress.LastKnownError = strFmt("@Retail:AsyncCustomerAddressOperationFailedWithUnknownError", errorMessage);
                    asyncAddress.update();
                }

                break;
            default:
                // nothing to do.
                eventSource.EventWriteAsyncAddressProcessingSkippedDueToUnhandledOperationType(custTable.RecId, asyncAddress.AddressId, asyncAddress.OperationId, asyncAddress.Operation);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustAccountForAsyncCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Create a customer account for the customer if it has not been created yet. Link the account to RetailCustTable.
    /// </summary>
    /// <param name = "asyncCust">
    ///     The async customer that should be created online
    /// </param>
    /// <returns>
    ///     The <c>CustAccount</c> of the existing/newly created online customer
    /// </returns>
    private static CustAccount createCustAccountForAsyncCustomer(RetailAsyncCustomer asyncCust)
    {
        CustAccount newCustAccount;
        System.Exception ex;

        // Use the existing customer if it was already created
        if (asyncCust.OnlineCustCreated)
        {
            newCustAccount = asyncCust.CustAccount;
            return newCustAccount;
        }

        try
        {
            ttsbegin;

            // Create the customer and link it to RetailCustTable
            container result;
            boolean customerCreated = false;
            DirPartyType dirPartyRelationType = any2Enum(asyncCust.RelationshipType);

            using (RetailTransactionServiceCustomerContext context = RetailTransactionServiceCustomerContext::construct())
            {
                context.parmCustomerTitleRecId(asyncCust.TitleRecordId);

                result = RetailTransactionServiceCustomer::newCustomer(
                asyncCust.CustName,
                asyncCust.CustGroup,
                asyncCust.currency,
                asyncCust.languageId,
                asyncCust.street,
                asyncCust.zipCode,
                asyncCust.state,
                asyncCust.county,
                asyncCust.phone,
                asyncCust.cellularPhone,
                asyncCust.email,
                asyncCust.url,
                asyncCust.multiLineDisc,
                asyncCust.endDisc,
                asyncCust.lineDisc,
                asyncCust.priceGroup,
                asyncCust.taxGroup,
                asyncCust.creditMax,
                asyncCust.blocked,
                asyncCust.OrganizationId,
                asyncCust.usePurchRequest,
                asyncCust.vatNum,
                asyncCust.invoiceAccount,
                asyncCust.mandatoryCreditLimit,
                asyncCust.contactPersonId,
                asyncCust.useOrderNumberReference,
                asyncCust.receiptOption,
                asyncCust.receiptEmail,
                asyncCust.city,
                asyncCust.country,
                asyncCust.identificationNumber,
                asyncCust.storeRecId,
                dirPartyRelationType,
                asyncCust.streetNumber,
                asyncCust.districtName,
                asyncCust.BuildingComplement,
                asyncCust.cnpjCpfNum_BR,
                asyncCust.addressName,
                asyncCust.addressType,
                asyncCust.addressPhone,
                asyncCust.addressEmail,
                asyncCust.addressUrl,
                asyncCust.addressTaxGroup,
                asyncCust.firstName,
                asyncCust.middleName,
                asyncCust.lastName,
                asyncCust.phoneExtension,
                asyncCust.retailCustAffiliations);
            }

            if (conLen(result) >= 1)
            {
                customerCreated = conPeek(result, 1); // validInsert
            }

            if (customerCreated)
            {
                newCustAccount = conPeek(result, 3); // newCustAccount
                asyncCust.OnlineCustCreated = NoYes::Yes;
                asyncCust.CustAccount = newCustAccount;
                asyncCust.update();

                // We would also like to associate the RetailCustTable entry for the customer to the async cust
                // so that the linkage becomes available on the channel side for the purpose of filtering them out in searches.
                RetailCustTable associatedRetailCust;
                RetailExternalIdToAsyncCustomerMap retailExternalIdToAsyncCustomerMap;
                RetailIdentityProvider retailIdentityProvider;

                select forupdate associatedRetailCust where associatedRetailCust.accountNum == newCustAccount;
                if (associatedRetailCust)
                {
                    associatedRetailCust.CustAccountAsync = asyncCust.CustAccountAsync;
                    associatedRetailCust.update();
                }

                // Update any external identity mappings for that customer.
                select forupdate retailExternalIdToAsyncCustomerMap where retailExternalIdToAsyncCustomerMap.AsyncCustomerAccountNumber == asyncCust.CustAccountAsync;
                if (retailExternalIdToAsyncCustomerMap)
                {
                    select retailIdentityProvider where  retailIdentityProvider.RecId == retailExternalIdToAsyncCustomerMap.ProviderId;
                    RetailTransactionServiceCustomer::createLinkExternalIdWithCustomer(retailExternalIdToAsyncCustomerMap.ExternalIdentityId, retailIdentityProvider.Issuer, newCustAccount, NoYes::Yes);
                    retailExternalIdToAsyncCustomerMap.delete();
                }
            }

            ttscommit;
        }
        catch (ex)
        {
            ttsabort;
            warning(ex.Message);
            warning("@Retail:AsyncCustomerCreateError");
            eventSource.EventWriteCreateCustAccountForRetailAsyncCustomerFailed(asyncCust.CustAccountAsync, ex.ToString());
        }

        return newCustAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountNumberAssociatedToAsyncCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the custAccount which was created for a given custAccountAsync value.
    /// </summary>
    /// <param name = "custAccountAsync">The account number for an async customer.</param>
    /// <returns>The sync account number registered against the provided async customer account.</returns>
    [Hookable(false)]
    internal static CustAccount getAccountNumberAssociatedToAsyncCustomer(RetailAsyncCustAccount custAccountAsync)
    {
        RetailCustTable retailCustTable;
        CustAccount result = '';

        if (!System.String::IsNullOrWhiteSpace(custAccountAsync))
        {
            select retailCustTable
                where retailCustTable.CustAccountAsync == custAccountAsync;

            if (retailCustTable)
            {
                result = retailCustTable.accountNum;
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAddressesForAsyncCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    ///     If the customer exists, create any new addresses associated with the customer
    /// </summary>
    /// <param name = "asyncCust">
    ///     The async customer whose addresses should be created online
    /// </param>
    private static void createAddressesForAsyncCustomer(RetailAsyncCustomer asyncCust)
    {
        // The customer must exist
        if (!asyncCust.OnlineCustCreated)
        {
            return;
        }

        RetailAsyncAddress asyncCustAddress;
        System.Exception ex;

        while select forupdate asyncCustAddress where
            asyncCustAddress.CustAccountAsync == asyncCust.CustAccountAsync &&
            asyncCustAddress.OnlineAddressCreated == NoYes::No
        {
            try
            {
                ttsbegin;
            
                container result;
                boolean addressCreated = false;

                RetailTransactionServiceCustomer_ExtendedParameters retailTransactionServiceCustomer_ExtendedParameters = RetailTransactionServiceCustomer::extendedParameters;
                retailTransactionServiceCustomer_ExtendedParameters.createAddress_logisticsLocationRoleRecordId = asyncCustAddress.LogisticsLocationRoleRecordId;

                result = RetailTransactionServiceCustomer::createAddress(
                        asyncCust.CustAccount,
                        asyncCustAddress.custName,
                        asyncCustAddress.Street,
                        asyncCustAddress.City,
                        asyncCustAddress.County,
                        asyncCustAddress.State,
                        asyncCustAddress.Zip,
                        asyncCustAddress.Country,
                        asyncCustAddress.Phone,
                        asyncCustAddress.Email,
                        asyncCustAddress.Url,
                        asyncCustAddress.TaxGroup,
                        asyncCustAddress.Role,
                        asyncCustAddress.StreetNumber,
                        asyncCustAddress.DistrictName,
                        asyncCustAddress.BuildingCompliment,
                        asyncCustAddress.MakePostalAddressPrimary);

                if (conLen(result) >= 1)
                {
                    addressCreated = conPeek(result, 1); // validInsert
                }

                if (addressCreated)
                {
                    asyncCustAddress.OnlineAddressCreated = NoYes::Yes;
                    asyncCustAddress.CustAccount = asyncCust.CustAccount;
                    asyncCustAddress.LogisticsPostalAddress = conPeek(result, 6);

                    asyncCustAddress.update();
                }

                ttscommit;
            }
            catch (ex)
            {
                ttsabort;

                warning(ex.Message);
                warning("@Retail:AsyncAddressOperationError");

                eventSource.EventWriteAsyncAddressProcessingFailed(strFmt('CustAccountAsync: %1, Exception: %2', asyncCustAddress.CustAccountAsync, ex.ToString()), asyncCustAddress.AddressId, "");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ProcessAsyncAddressOperationForSyncCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes async address operations for a sync customer.
    /// </summary>
    [Hookable(false)]
    public static void ProcessAsyncAddressOperationForSyncCustomer()
    {
        RetailAsyncAddressV2 asyncAddress;

        while select asyncAddress
                order by asyncAddress.OperationTimeStamp, asyncAddress.Operation asc
                where asyncAddress.OnlineOperationCompleted == NoYes::No
        {
            System.Exception ex;

            try
            {
                ttsbegin;

                // Handle the scenario where the address is for a sync customer.
                if (!System.String::IsNullOrWhiteSpace(asyncAddress.CustAccount))
                {
                    RetailTransactionServiceCustomer::processAsyncAddressOperation(asyncAddress, asyncAddress.CustAccount);
                }
                else
                {
                    // Locate the account number associated to the given async customer.
                    CustAccount custAccountNum = RetailTransactionServiceCustomer::getAccountNumberAssociatedToAsyncCustomer(asyncAddress.CustAccountAsync);

                    if (!System.String::IsNullOrWhiteSpace(custAccountNum))
                    {
                        RetailTransactionServiceCustomer::processAsyncAddressOperation(asyncAddress, custAccountNum);
                    }
                    else
                    {
                        eventSource.EventWriteAsyncAddressProcessingSkippedDueToMissingCustomerRecord(asyncAddress.AddressId, asyncAddress.OperationId, asyncAddress.Operation);
                    }
                }

                ttscommit;
            }
            catch (ex)
            {
                ttsabort;

                warning(ex.Message);
                warning("@Retail:AsyncAddressOperationError");

                eventSource.EventWriteAsyncAddressProcessingFailed(ex.ToString(), asyncAddress.AddressId, asyncAddress.OperationId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processAsyncAddressOperationForAsyncCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes async address operations for an async customer.
    /// </summary>
    /// <param name = "asyncCust">The async customer whose addresses is being processed.</param>
    private static void processAsyncAddressOperationForAsyncCustomer(RetailAsyncCustomer asyncCust)
    {
        // The customer must exist
        if (!asyncCust.OnlineCustCreated)
        {
            return;
        }

        RetailAsyncAddressV2 asyncAddress;
        System.Exception ex;

        while select forupdate asyncAddress
            order by asyncAddress.OperationTimeStamp, asyncAddress.Operation asc
            where asyncAddress.CustAccountAsync == asyncCust.CustAccountAsync &&
            asyncAddress.OnlineOperationCompleted == NoYes::No
        {
            try
            {
                ttsbegin;

                RetailTransactionServiceCustomer::processAsyncAddressOperation(asyncAddress, asyncCust.CustAccount);

                ttscommit;
            }
            catch (ex)
            {
                ttsabort;

                warning(ex.Message);
                warning("@Retail:AsyncAddressOperationError");

                eventSource.EventWriteAsyncAddressProcessingFailed(ex.ToString(), asyncAddress.AddressId, asyncAddress.OperationId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processExternalIdentityLinkForAsyncCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes and creates link for external identity for a single async customer.
    /// </summary>
    /// <param name="asyncCustomer">The async customer whose external id is being processed.</param>
    internal static void processExternalIdentityLinkForAsyncCustomer(RetailAsyncCustomer asyncCustomer)
    {
        // The customer must exist
        if (!asyncCustomer.OnlineCustCreated)
        {
            return;
        }

        RetailExternalIdToAsyncCustomerMapV2 retailExternalIdToAsyncCustomerMapV2;

        while select forupdate retailExternalIdToAsyncCustomerMapV2
            order by retailExternalIdToAsyncCustomerMapV2.OperationTimeStamp, retailExternalIdToAsyncCustomerMapV2.Operation asc
            where retailExternalIdToAsyncCustomerMapV2.CustAccountAsync == asyncCustomer.CustAccountAsync &&
            retailExternalIdToAsyncCustomerMapV2.OnlineOperationCompleted == NoYes::No
        {
            System.Exception ex;
            try
            {
                ttsbegin;

                RetailTransactionServiceCustomer::processAsyncLinkExternalIdentityOperation(retailExternalIdToAsyncCustomerMapV2, asyncCustomer.CustAccount);

                if (retailExternalIdToAsyncCustomerMapV2.OnlineOperationCompleted == NoYes::Yes)
                {
                    // Log Success
                    eventSource.EventWriteCustomerAsyncExternalIdentityOnlineOperationCompleted(CustTable::find(asyncCustomer.CustAccount).RecId, retailExternalIdToAsyncCustomerMapV2.CustAccountAsync, retailExternalIdToAsyncCustomerMapV2.OperationId);
                }
                else
                {
                    // Log Failure
                    eventSource.EventWriteCustomerAsyncExternalIdentityOnlineOperationNotCompleted(CustTable::find(asyncCustomer.CustAccount).RecId, retailExternalIdToAsyncCustomerMapV2.CustAccountAsync, retailExternalIdToAsyncCustomerMapV2.OperationId);
                }

                ttscommit;
            }
            catch (ex)
            {
                ttsabort;

                warning(ex.Message);
                warning("@Retail:@Retail:AsyncExternalIdentityLinkOperationError");
                eventSource.EventWriteProcessAsyncLinkExternalIdentityOperationFailed(retailExternalIdToAsyncCustomerMapV2.CustAccountAsync, retailExternalIdToAsyncCustomerMapV2.OperationId, ex.ToString());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ProcessAsyncExternalIdentityLink</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes and creates link for external identity for a sync or async customer.
    /// </summary>
    internal static void ProcessAsyncExternalIdentityLink()
    {
        RetailExternalIdToAsyncCustomerMapV2 retailExternalIdToAsyncCustomerMapV2;

        while select forupdate retailExternalIdToAsyncCustomerMapV2
            order by retailExternalIdToAsyncCustomerMapV2.OperationTimeStamp, retailExternalIdToAsyncCustomerMapV2.Operation asc
            where retailExternalIdToAsyncCustomerMapV2.OnlineOperationCompleted == NoYes::No
        {
            System.Exception ex;
            try
            {
                ttsbegin;

                // Handle the scenario where the external identity ID is for a sync customer.
                if (!System.String::IsNullOrWhiteSpace(retailExternalIdToAsyncCustomerMapV2.CustAccount))
                {
                    RetailTransactionServiceCustomer::processAsyncLinkExternalIdentityOperation(retailExternalIdToAsyncCustomerMapV2, retailExternalIdToAsyncCustomerMapV2.CustAccount);
                }
                else
                {
                    // Handle the scenario where the record is for an async customer which has been created but not yet synced down to the channel.
                    RetailAsyncCustomer asyncCustTable;
                    select asyncCustTable
                    where asyncCustTable.CustAccountAsync == retailExternalIdToAsyncCustomerMapV2.CustAccountAsync &&
                    asyncCustTable.OnlineCustCreated == NoYes::Yes;

                    // If the async customer record was found, then proceed.
                    if (asyncCustTable)
                    {
                        RetailTransactionServiceCustomer::processAsyncLinkExternalIdentityOperation(retailExternalIdToAsyncCustomerMapV2, asyncCustTable.CustAccount);
                    }
                }

                if (retailExternalIdToAsyncCustomerMapV2.OnlineOperationCompleted == NoYes::Yes)
                {
                    // Log Success
                    eventSource.EventWriteCustomerAsyncExternalIdentityOnlineOperationCompleted(CustTable::find(retailExternalIdToAsyncCustomerMapV2.CustAccount).RecId, retailExternalIdToAsyncCustomerMapV2.CustAccountAsync, retailExternalIdToAsyncCustomerMapV2.OperationId);
                }
                else
                {
                    // Log Failure
                    eventSource.EventWriteCustomerAsyncExternalIdentityOnlineOperationNotCompleted(CustTable::find(retailExternalIdToAsyncCustomerMapV2.CustAccount).RecId, retailExternalIdToAsyncCustomerMapV2.CustAccountAsync, retailExternalIdToAsyncCustomerMapV2.OperationId);
                }

                ttscommit;
            }
            catch (ex)
            {
                ttsabort;

                warning(ex.Message);
                warning("@Retail:@Retail:AsyncExternalIdentityLinkOperationError");
                eventSource.EventWriteProcessAsyncLinkExternalIdentityOperationFailed(retailExternalIdToAsyncCustomerMapV2.CustAccountAsync, retailExternalIdToAsyncCustomerMapV2.OperationId, ex.ToString());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processAsyncLinkExternalIdentityOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process async operations for initiating, finalizing, and unlinking a customer's external identity.
    /// </summary>
    /// <param name = "retailExternalIdToAsyncCustomerMapV2">The RetailExternalIdToAsyncCustomerMapV2 async record for the customer's external identity.</param>
    /// <param name = "custAccount">The customer account number for the customer being processed.</param>
    private static void processAsyncLinkExternalIdentityOperation(RetailExternalIdToAsyncCustomerMapV2 retailExternalIdToAsyncCustomerMapV2, CustAccount custAccount)
    {
        RetailExternalIdToCustomerMap retailExternalIdToCustomerMap;
        RetailIdentityProvider retailIdentityProvider;

        select retailIdentityProvider where retailIdentityProvider.RecId == retailExternalIdToAsyncCustomerMapV2.ProviderId;

        switch(retailExternalIdToAsyncCustomerMapV2.Operation)
        {
            case RetailAsyncOperation::Create:
            case RetailAsyncOperation::Update:
                // Initiate Or Finalize Link.
                retailExternalIdToCustomerMap = RetailTransactionServiceCustomer::createLinkExternalIdWithCustomer(retailExternalIdToAsyncCustomerMapV2.ExternalIdentityId, RetailIdentityProvider.Issuer, custAccount, RetailExternalIdToAsyncCustomerMapV2.IsActivated, retailExternalIdToAsyncCustomerMapV2.IsAutoLinked);

                if (retailExternalIdToCustomerMap.RecId)
                {
                    retailExternalIdToAsyncCustomerMapV2.OnlineOperationCompleted = NoYes::Yes;
                    retailExternalIdToAsyncCustomerMapV2.update();

                    eventSource.EventWriteCreateCustomerAsyncExternalIdentityProcessingSuccessful(CustTable::find(custAccount).RecId, retailExternalIdToAsyncCustomerMapV2.CustAccountAsync, retailExternalIdToAsyncCustomerMapV2.OperationId);
                }
                else
                {
                    eventSource.EventWriteCreateCustomerAsyncExternalIdentityProcessingUnsuccessful(CustTable::find(custAccount).RecId, retailExternalIdToAsyncCustomerMapV2.CustAccountAsync, retailExternalIdToAsyncCustomerMapV2.OperationId);
                }

                break;
            case RetailAsyncOperation::Delete:
                // Unlink.
                container unlinkResults = RetailTransactionServiceCustomer::unlinkExternalIdFromCustomer(retailExternalIdToAsyncCustomerMapV2.ExternalIdentityId, RetailIdentityProvider.Issuer, CustAccount);

                select retailExternalIdToCustomerMap
                    where retailExternalIdToCustomerMap.RecId == conPeek(unlinkResults, 3);

                if (retailExternalIdToCustomerMap)
                {
                    retailExternalIdToAsyncCustomerMapV2.OnlineOperationCompleted = NoYes::Yes;
                    retailExternalIdToAsyncCustomerMapV2.update();
                }
                else
                {
                    eventSource.EventWriteUnlinkCustomerAsyncExternalIdentityUnsuccessful(CustTable::find(custAccount).RecId, retailExternalIdToAsyncCustomerMapV2.CustAccountAsync, retailExternalIdToAsyncCustomerMapV2.OperationId);
                }
                break;
            default:
                eventSource.EventWriteCreateCustomerAsyncExternalIdentityUnhandledOperationType(CustTable::find(custAccount).RecId, retailExternalIdToAsyncCustomerMapV2.CustAccountAsync, retailExternalIdToAsyncCustomerMapV2.OperationId, retailExternalIdToAsyncCustomerMapV2.Operation);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processAsyncAffiliationsForAsyncCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes async affiliations for an async customer.
    /// </summary>
    /// <param name = "asyncCust">The async customer whose affiliations are being processed.</param>
    private static void processAsyncAffiliationsForAsyncCustomer(RetailAsyncCustomer asyncCust)
    {
        // The customer must exist
        if (!asyncCust.OnlineCustCreated)
        {
            eventSource.EventWriteCreateCustomerAsyncAffiliationsAsyncCustNotCreated(asyncCust.RecId);
            return;
        }

        // Find all eligible records in the 'RetailAsyncCustAffiliation' table that have not been processed.
        RetailAsyncCustomerAffiliation asyncCustAffiliationTable;

        while select forupdate asyncCustAffiliationTable
        order by asyncCustAffiliationTable.OperationTimeStamp, asyncCustAffiliationTable.Operation asc
        where asyncCustAffiliationTable.CustAccountAsync == asyncCust.CustAccountAsync
            && asyncCustAffiliationTable.OnlineOperationCompleted == NoYes::No
        {
            System.Exception ex;

            try
            {
                ttsbegin;

                RetailTransactionServiceCustomer::processAsyncCustAffiliationOperation(asyncCustAffiliationTable, asyncCust.CustAccount);

                ttscommit;
            }
            catch (ex)
            {
                ttsabort;

                warning(ex.Message);
                warning("@Retail:AsyncCustAffiliationOperationError");

                eventSource.EventWriteAsyncAffiliationProcessingFailed(strFmt('OperationId: %1, Exception: %2', asyncCustAffiliationTable.OperationId, ex.ToString()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ProcessAsyncAffiliationOperationForSyncCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes async affiliation operations for a sync customer.
    /// </summary>
    [Hookable(false)]
    internal static void ProcessAsyncAffiliationOperationForSyncCustomer()
    {
        RetailAsyncCustomerAffiliation asyncAffiliation;

        while select asyncAffiliation
            order by asyncAffiliation.OperationTimeStamp, asyncAffiliation.Operation asc
            where asyncAffiliation.OnlineOperationCompleted == NoYes::No
        {
            System.Exception ex;

            try
            {
                ttsbegin;

                // Handle the scenario where the affiliation is for a sync customer.
                if (!System.String::IsNullOrWhiteSpace(asyncAffiliation.CustAccount))
                {
                    RetailTransactionServiceCustomer::processAsyncCustAffiliationOperation(asyncAffiliation, asyncAffiliation.CustAccount);
                }
                else
                {
                    // Locate the account number associated to the given async customer.
                    CustAccount custAccountNum = RetailTransactionServiceCustomer::getAccountNumberAssociatedToAsyncCustomer(asyncAffiliation.CustAccountAsync);

                    if (!System.String::IsNullOrWhiteSpace(custAccountNum))
                    {
                        RetailTransactionServiceCustomer::processAsyncCustAffiliationOperation(asyncAffiliation, custAccountNum);
                    }
                    else
                    {
                        eventSource.EventWriteAsyncAffiliationProcessingSkippedDueToMissingCustomerRecord(asyncAffiliation.OperationId, asyncAffiliation.Operation);
                    }
                }
                
                ttscommit;
            }
            catch (ex)
            {
                ttsabort;

                warning(ex.Message);
                warning("@Retail:AsyncCustAffiliationOperationError");

                eventSource.EventWriteAsyncAffiliationProcessingFailed(strFmt('OperationId: %1, Exception: %2', asyncAffiliation.OperationId, ex.ToString()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processAsyncContactsForAsyncCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes async contact for an async customer.
    /// </summary>
    /// <param name = "asyncCust">The async customer whose contacts are being processed.</param>
    private static void processAsyncContactsForAsyncCustomer(RetailAsyncCustomer asyncCust)
    {
        // The customer must exist
        if (!asyncCust.OnlineCustCreated)
        {
            eventSource.EventWriteCreateCustomerAsyncContactsAsyncCustNotCreated(asyncCust.RecId);
            return;
        }

        // Find all eligible records in the 'RetailAsyncCustomerContact' table that have not been processed.
        RetailAsyncCustomerContact asyncCustContactTable;

        while select forupdate asyncCustContactTable
        order by asyncCustContactTable.OperationTimeStamp, asyncCustContactTable.Operation asc
        where asyncCustContactTable.CustAccountAsync == asyncCust.CustAccountAsync
            && asyncCustContactTable.OnlineOperationCompleted == NoYes::No
        {
            System.Exception ex;

            try
            {
                ttsbegin;

                RetailTransactionServiceCustomer::processAsyncCustContactOperation(asyncCustContactTable, asyncCust.CustAccount);

                ttscommit;
            }
            catch (ex)
            {
                ttsabort;

                warning(ex.Message);
                warning("@Retail:AsyncCustContactOperationError");

                eventSource.EventWriteAsyncContactProcessingFailed(strFmt('OperationId: %1, Exception: %2', asyncCustContactTable.OperationId, ex.ToString()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ProcessAsyncContactOperationForSyncCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes async contact operations for a sync customer.
    /// </summary>
    [Hookable(false)]
    internal static void ProcessAsyncContactOperationForSyncCustomer()
    {
        RetailAsyncCustomerContact asyncContact;

        while select asyncContact
            order by asyncContact.OperationTimeStamp, asyncContact.Operation asc
            where asyncContact.OnlineOperationCompleted == NoYes::No
        {
            System.Exception ex;

            try
            {
                ttsbegin;

                // Handle the scenario where the contact is for a sync customer.
                if (!System.String::IsNullOrWhiteSpace(asyncContact.CustAccount))
                {
                    RetailTransactionServiceCustomer::processAsyncCustContactOperation(asyncContact, asyncContact.CustAccount);
                }
                else
                {
                    // Locate the account number associated to the given async customer.
                    CustAccount custAccountNum = RetailTransactionServiceCustomer::getAccountNumberAssociatedToAsyncCustomer(asyncContact.CustAccountAsync);

                    if (!System.String::IsNullOrWhiteSpace(custAccountNum))
                    {
                        RetailTransactionServiceCustomer::processAsyncCustContactOperation(asyncContact, custAccountNum);
                    }
                    else
                    {
                        eventSource.EventWriteAsyncContactProcessingSkippedDueToMissingCustomerRecord(asyncContact.OperationId, asyncContact.Operation);
                    }
                }

                ttscommit;
            }
            catch (ex)
            {
                ttsabort;

                warning(ex.Message);
                warning("@Retail:AsyncCustContactOperationError");

                eventSource.EventWriteAsyncContactProcessingFailed(strFmt('OperationId: %1, Exception: %2', asyncContact.OperationId, ex.ToString()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ProcessAsyncAttributeOperationForSyncCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes async attribute operations for a sync customer.
    /// </summary>
    [Hookable(false)]
    public static void ProcessAsyncAttributeOperationForSyncCustomer()
    {
        RetailAsyncCustomerAttributeV2 asyncAttribute;

        while select asyncAttribute
            where asyncAttribute.OnlineOperationCompleted == NoYes::No
        {
            System.Exception ex;

            try
            {
                ttsbegin;

                // Since multiple attribute records are processsed together, re-validate that this record has not been processed.
                asyncAttribute.reread();
                if (asyncAttribute.OnlineOperationCompleted == NoYes::Yes)
                {
                    continue;
                }

                // Handle the scenario where the attribute is for a sync customer.
                if (!System.String::IsNullOrWhiteSpace(asyncAttribute.CustAccount))
                {
                    RetailTransactionServiceCustomer::processAsyncCustAttributeOperation(asyncAttribute.CustAccount, false);
                }
                else
                {
                    RetailTransactionServiceCustomer::processAsyncCustAttributeOperation(asyncAttribute.CustAccountAsync, true);
                }

                ttscommit;
            }
            catch (ex)
            {
                ttsabort;

                warning(ex.Message);
                warning("@Retail:AsyncAttributeOperationError");

                eventSource.EventWriteAsyncAttributeProcessingFailed(strFmt('OperationId: %1, Exception: %2', asyncAttribute.OperationId, ex.ToString()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processAsyncAttributesForAsyncCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    ///     If the customer exists, create new attributes associated with the customer
    /// </summary>
    /// <param name = "asyncCust">
    ///     The async customer whose attributes should be created online.
    /// </param>
    private static void processAsyncAttributesForAsyncCustomer(RetailAsyncCustomer asyncCust)
    {
        // The customer must exist
        if (!asyncCust.OnlineCustCreated)
        {
            return;
        }

        RetailAsyncCustomerAttribute asyncCustomerAttribute;
        EcoResAttribute ecoResAttribute;
        SysDictEnum sysDictEnum = new SysDictEnum(enumNum(AttributeDataType));
        Map customerAttributes = new Map(Types::Int64, Types::AnyType);
        System.Exception ex;

        try
        {
            ttsbegin;

            while select forupdate asyncCustomerAttribute where
                asyncCustomerAttribute.CustAccountAsync == asyncCust.CustAccountAsync &&
                asyncCustomerAttribute.OnlineAttributeCreated == NoYes::No
            {
                select RecId, Name from ecoResAttribute where ecoResAttribute.RecId == asyncCustomerAttribute.AttributeRecId;
                if (ecoResAttribute)
                {
                    Map attributeValueDetails;
                    Set attrValueSet;
                    anytype attrValue;

                    if (!customerAttributes.exists(asyncCustomerAttribute.AttributeRecId))
                    {
                        str attrValueString = asyncCustomerAttribute.AttributeValueString;
                        attrValue = RetailTransactionServiceCustomer::setAttributeValue(asyncCustomerAttribute, attrValueString);
                        if (attrValue == null)
                        {
                            str dataTypeText = sysDictEnum.value2Symbol(asyncCustomerAttribute.AttributeDataType);
                            throw error(strFmt('Data type conversion %1 is not supported', dataTypeText != '' ? dataTypeText : int2Str(asyncCustomerAttribute.AttributeDataType)));
                        }

                        // Instantiate a new dictionary attribute details.
                        attributeValueDetails = new Map(Types::String, Types::AnyType);
                        attributeValueDetails.insert(RetailAttributeHelper::AttributeDefinitionNameKey, ecoResAttribute.Name);
                        attributeValueDetails.insert(RetailAttributeHelper::AttributeDefinitionTypeKey, asyncCustomerAttribute.AttributeDataType);

                        // Instantiate a new Set object that holds attribute values.
                        attrValueSet = new Set(Types::AnyType);
                        attrValueSet.add(attrValue);

                        // Insert the Set object to attribute details dictionary.
                        attributeValueDetails.insert(RetailAttributeHelper::AttributeValuesKey, attrValueSet);

                        // Insert attribute details dictionary to customer attributes dictionary.
                        customerAttributes.insert(asyncCustomerAttribute.AttributeRecId, attributeValueDetails);
                    }
                    else
                    {
                        // Attribute details has been instantiated, get the instance of this dictionary.
                        attributeValueDetails = customerAttributes.lookup(asyncCustomerAttribute.AttributeRecId);

                        // Retrieve the Set instance that holds attribute values.
                        attrValueSet = attributeValueDetails.lookup(RetailAttributeHelper::AttributeValuesKey);
                        attrValueSet.add(attrValue);
                    }

                    asyncCustomerAttribute.OnlineAttributeCreated = NoYes::Yes;
                    asyncCustomerAttribute.update();
                }
            }

            RetailCustomerAttributeHelper::createUpdateAttributeValuesOnCustomer(asyncCust.CustAccount, asyncCust.DataAreaId, customerAttributes);

            ttscommit;
        }
        catch (ex)
        {
            ttsabort;

            warning("@Retail:AsyncCustAttributeForAsyncCustomerError");

            eventSource.EventWriteAsyncCustAttributeProcessingForAsyncCustomerFailed(asyncCust.RecId, asyncCust.CustAccountAsync, ex.ToString());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processAsyncCustAttributeOperation</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Creates or updates the attributes associated to the customer which maybe be either async or non-async.
    /// </summary>
    /// <param name = "custAccountOrCustAccountAsync">
    /// The account number for a sync customer, or the account number for an async customer which has been previously created.
    /// </param>
    /// <param name = "isAsyncCustAccount">
    /// Specifies if the account number specified is for an async customer or a non-async customer.
    /// </param>
    [Hookable(false)]
    internal static void processAsyncCustAttributeOperation(RetailAsyncCustAccount custAccountOrCustAccountAsync, boolean isAsyncCustAccount)
    {
        // Ensure that the associated sync customer exists.
        CustAccount custAccountNum = isAsyncCustAccount ? RetailTransactionServiceCustomer::getAccountNumberAssociatedToAsyncCustomer(custAccountOrCustAccountAsync) : custAccountOrCustAccountAsync;
        CustTable custTable = CustTable::find(custAccountNum, false);

        RetailAsyncCustomerAttributeV2 asyncCustAttribute;

        // If sync customer doesn’t not found in HQ, then async attribute operation for sync customer will non-retriable.
        if (custTable.RecId == 0)
        {
            while select forupdate asyncCustAttribute
                where asyncCustAttribute.CustAccount == custAccountNum && asyncCustAttribute.OnlineOperationCompleted == NoYes::No
            {
                asyncCustAttribute.OnlineOperationCompleted = NoYes::Yes;
                asyncCustAttribute.LastKnownError = strFmt("@SYS119849", custAccountNum);
                asyncCustAttribute.update();
            }

            eventSource.EventWriteSyncToAsyncAttributeFailedWhenCustomerNotFound(asyncCustAttribute.RecId, custAccountNum);
            return;
        }

        EcoResAttribute ecoResAttribute;
        SysDictEnum sysDictEnum = new SysDictEnum(enumNum(AttributeDataType));
        System.Exception ex;

        // Get the customer's current attributes, if any.
        Map customerAttributes = RetailCustomerAttributeHelper::getFormattedCustomerAttributeValues(custAccountNum, custTable.DataAreaId);

        try
        {
            ttsbegin;

            // NOTE: Processing of async attributes varies from that of contacts or addresses.
            // When processing an async contact we process one record at a time.
            // But for attributes, we group all the attributes and generate a map of all attributes to be updated and process these at one go.
            while select forupdate asyncCustAttribute
                order by asyncCustAttribute.OperationTimeStamp, asyncCustAttribute.Operation asc
                where (asyncCustAttribute.CustAccountAsync == custAccountNum || asyncCustAttribute.CustAccount == custAccountNum
                        || asyncCustAttribute.CustAccountAsync == custAccountOrCustAccountAsync || asyncCustAttribute.CustAccount == custAccountOrCustAccountAsync) &&
                       asyncCustAttribute.OnlineOperationCompleted == NoYes::No
            {
                eventSource.EventWriteCustomerAsyncAttributeProcessingStarted(custTable.RecId, asyncCustAttribute.OperationId, asyncCustAttribute.Operation);
                select RecId, Name from ecoResAttribute where ecoResAttribute.RecId == asyncCustAttribute.AttributeRecId;

                if (ecoResAttribute)
                {
                    Map attributeValueDetails;
                    Set attrValueSet;
                    anytype attrValue;

                    str attrValueString = asyncCustAttribute.AttributeValueString;
                    attrValue = RetailTransactionServiceCustomer::setAttributeValueV2(asyncCustAttribute, attrValueString);

                    if (attrValue == null)
                    {
                        str dataTypeText = sysDictEnum.value2Symbol(asyncCustAttribute.AttributeDataType);
                        str errorMessage = strFmt('Data type conversion %1 is not supported', dataTypeText != '' ? dataTypeText : int2Str(asyncCustAttribute.AttributeDataType));

                        // Save the last known error.
                        ttsbegin;
                        asyncCustAttribute.LastKnownError = errorMessage;
                        asyncCustAttribute.update();
                        ttscommit;

                        // Log an error and continue processing.
                        eventSource.EventWriteProcessingCustomerAsyncAttributeFailedDueToUnsupportedDataType(custTable.RecId, custAccountOrCustAccountAsync, asyncCustAttribute.OperationId, errorMessage);
                        continue;
                    }

                    // Multiple values are not supported for a single attribute. So clear the existing values and replace with the new one.
                    if (customerAttributes.exists(asyncCustAttribute.AttributeRecId))
                    {
                        customerAttributes.remove(asyncCustAttribute.AttributeRecId);
                    }

                    // Instantiate a new dictionary attribute details.
                    attributeValueDetails = new Map(Types::String, Types::AnyType);
                    attributeValueDetails.insert(RetailAttributeHelper::AttributeDefinitionNameKey, ecoResAttribute.Name);
                    attributeValueDetails.insert(RetailAttributeHelper::AttributeDefinitionTypeKey, asyncCustAttribute.AttributeDataType);

                    // Instantiate a new Set object that holds attribute values.
                    attrValueSet = new Set(Types::AnyType);
                    attrValueSet.add(attrValue);

                    // Insert the Set object to attribute details dictionary.
                    attributeValueDetails.insert(RetailAttributeHelper::AttributeValuesKey, attrValueSet);

                    // Insert attribute details dictionary to customer attributes dictionary.
                    customerAttributes.insert(asyncCustAttribute.AttributeRecId, attributeValueDetails);

                    // Mark the async attribute record as processed.
                    asyncCustAttribute.OnlineOperationCompleted = NoYes::Yes;
                    asyncCustAttribute.CustAccount = custTable.AccountNum;
                    asyncCustAttribute.LastKnownError = '';
                    asyncCustAttribute.update();

                    eventSource.EventWriteCustomerAsyncAttributeProcessingSuccessful(custTable.RecId, asyncCustAttribute.OperationId, asyncCustAttribute.Operation);
                }
            }

            // NOTE: When performing a create or an update attribute operation, make sure that the customer attributes map contains ever single attribute
            // Associated to the customer regardless of whether they are being operated on or not.
            // All attributes not in the map will no longer be associated to the customer.
            RetailCustomerAttributeHelper::createUpdateAttributeValuesOnCustomer(custTable.AccountNum, custTable.DataAreaId, customerAttributes);

            ttscommit;
        }
        catch (ex)
        {
            ttsabort;

            warning("@Retail:AsyncCustAttributeForCustomerError");

            eventSource.EventWriteAsyncCustAttributeProcessingForCustomerFailed(custTable.RecId, custTable.AccountNum, ex.ToString());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAttributeValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets attribute value based on <c>AttributeDataType</c>.
    /// </summary>
    /// <param name = "_asyncCustomerAttribute">
    ///     A table buffer.
    /// </param>
    /// <param name = "_attrValueString">
    ///     A <c>RetailAsyncCustomerAttribute</c> table field.
    /// </param>
    /// <returns>
    ///     Anytype value for known <c>AttributeDataType</c>.
    /// </returns>
    protected static anytype setAttributeValue(RetailAsyncCustomerAttribute _asyncCustomerAttribute, str _attrValueString)
    {
        anytype attrValue;

        switch (_asyncCustomerAttribute.AttributeDataType)
        {
            case AttributeDataType::Text:
                attrValue = _attrValueString;
                break;
            case AttributeDataType::TrueFalse:
                attrValue = strLwr(_attrValueString) == 'true';
                break;
            case AttributeDataType::DateTime:
                attrValue = str2Datetime(_attrValueString, RetailCustomerAttributeHelper::DateSequence);
                break;
            case AttributeDataType::Decimal:
                attrValue = str2Num(_attrValueString);
                break;
            case AttributeDataType::Integer:
                attrValue = str2Int(_attrValueString);
                break;
        }
        return attrValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAttributeValueV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets attribute value based on <c>AttributeDataType</c>.
    /// </summary>
    /// <param name = "_asyncCustomerAttribute">The table buffer.</param>
    /// <param name = "_attrValueString">The <c>RetailAsyncCustomerAttributeV2</c> table field.</param>
    /// <returns> Anytype value for known <c>AttributeDataType</c>.</returns>
    private static anytype setAttributeValueV2(RetailAsyncCustomerAttributeV2 _asyncCustomerAttribute, str _attrValueString)
    {
        anytype attrValue;

        switch (_asyncCustomerAttribute.AttributeDataType)
        {
            case AttributeDataType::Text:
                attrValue = _attrValueString;
                break;
            case AttributeDataType::TrueFalse:
                attrValue = strLwr(_attrValueString) == 'true';
                break;
            case AttributeDataType::DateTime:
                attrValue = str2Datetime(_attrValueString, RetailCustomerAttributeHelper::DateSequence);
                break;
            case AttributeDataType::Decimal:
                attrValue = str2Num(_attrValueString);
                break;
            case AttributeDataType::Integer:
                attrValue = str2Int(_attrValueString);
                break;
        }

        return attrValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addPartyToLocalAddressBooks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the specified party to the specified store's address books.
    /// </summary>
    /// <param name="dirPartyRecId">
    /// The RecId of the party to use.
    /// </param>
    /// <param name="storeRecId">
    /// The RecId of the store to assign the party to.
    /// </param>
    /// <returns>
    /// A container of RecIds corresponding to the address books the party was added to.
    /// </returns>
    private static container addPartyToLocalAddressBooks(DirPartyRecId dirPartyRecId, RecId storeRecId)
    {
        RetailStoreAddressBook      retailStoreAddressBook;
        DirAddressBookParty         dirAddressBookParty;
        container                   storeAddressBooks;

        ttsbegin;

        // Assign address books from the store to the customer.
        while select AddressBook, AddressBookType from retailStoreAddressBook
            where retailStoreAddressBook.StoreRecId == storeRecId
            && retailStoreAddressBook.AddressBookType == RetailAddressBookType::Customer
        {
            storeAddressBooks += retailStoreAddressBook.AddressBook;
        }

        // Also assign address books from Party.
        while select AddressBook, Party from dirAddressBookParty
            where dirAddressBookParty.Party == DirPartyRecId
        {
            if (conFind(storeAddressBooks, dirAddressBookParty.AddressBook) == 0)
            {
                storeAddressBooks += dirAddressBookParty.AddressBook;
            }
        }

        DirAddressBookParty::createPartyRelations(DirPartyRecId, storeAddressBooks);

        ttscommit;

        return storeAddressBooks;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCustomerDataToPackage</Name>
				<Source><![CDATA[
    private static void addCustomerDataToPackage(RetailCdxDataPackageSerializationHelper serializer, CustTable customerRecord, int versionNumber)
    {
        RetailCustTable                    retailCustTable;
        RetailMediaAndMasterEntityRelation retailMediaAndMasterEntityRelation;
        RetailMediaResource                retailMediaResource;

        serializer.writeRecord(customerRecord);

        /// Version number 1: Returns default data and data from tables <c>DirPersonName</c>, <c>RetailMediaAndMasterEntityRelation</c>, and <c>RetailMediaResource</c>.
        while select retailMediaAndMasterEntityRelation
            where retailMediaAndMasterEntityRelation.MasterEntityRecId == customerRecord.RecId
        {
            serializer.writeRecord(retailMediaAndMasterEntityRelation);
        }

        while select retailMediaResource
        join retailMediaAndMasterEntityRelation
            where retailMediaAndMasterEntityRelation.MasterEntityRecId == customerRecord.RecId &&
                retailMediaResource.ResourceId == retailMediaAndMasterEntityRelation.MediaResourceId
        {
             serializer.writeRecord(retailMediaAndMasterEntityRelation);
        }

        /// Version number 3: Returns additional data from <c>RetailCustTable</c>.
        if (versionNumber >= 3)
        {
            retailCustTable = RetailCustTable::find(customerRecord.AccountNum);
            serializer.writeRecord(retailCustTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCustomerAttributesToPackage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the customer attributes to the data package.
    /// </summary>
    /// <param name="serializer">
    /// The CDX data package serializer.
    /// </param>
    /// <param name="customerRecord">
    /// The customer record containing the account number and data area identifier used to uniquely identify a customer.
    /// </param>
    private static void addCustomerAttributesToPackage(RetailCdxDataPackageSerializationHelper serializer, CustTable customerRecord)
    {
        CustomerInstanceValue                customerInstanceValue;
        EcoResAttributeValue                 ecoResAttributeValue;
        EcoResFloatValue                     ecoResFloatValue;
        EcoResIntValue                       ecoResIntValue;

        select customerInstanceValue where customerInstanceValue.AccountNum == customerRecord.AccountNum && customerInstanceValue.CustomerDataAreaId == customerRecord.DataAreaId;
        if (customerInstanceValue)
        {
            serializer.writeRecord(customerInstanceValue);

            while select ecoResAttributeValue
                where ecoResAttributeValue.InstanceValue == customerInstanceValue.RecId
            {
                serializer.writeRecord(ecoResAttributeValue);

                EcoResAttribute ecoResAttribute = EcoResAttribute::find(ecoResAttributeValue.Attribute);

                serializer.writeRecord(ecoResAttribute);

                if (ecoResAttribute.RecId)
                {
                    EcoResAttributeType ecoResAttributeType = EcoResAttributeType::find(ecoResAttribute.AttributeType);
                    serializer.writeRecord(ecoResAttributeType);

                    switch (ecoResAttribute.getAttributeTypeDataType())
                    {
                        case AttributeDataType::TrueFalse:
                            serializer.writeRecord(EcoResBooleanValue::find(ecoResAttributeValue.Value));
                            break;

                        case AttributeDataType::DateTime:
                            serializer.writeRecord(EcoResDateTimeValue::find(ecoResAttributeValue.Value));
                            break;

                        case AttributeDataType::Decimal:
                            ecoResFloatValue = EcoResFloatValue::find(ecoResAttributeValue.Value);
                            serializer.writeRecord(ecoResFloatValue);
                            serializer.writeRecord(UnitOfMeasure::find(ecoResFloatValue.RecId));
                            break;

                        case AttributeDataType::Integer:
                            ecoResIntValue = EcoResIntValue::find(ecoResAttributeValue.Value);
                            serializer.writeRecord(ecoResIntValue);
                            serializer.writeRecord(UnitOfMeasure::find(ecoResIntValue.RecId));
                            break;

                        case AttributeDataType::Text:
                            serializer.writeRecord(EcoResTextValue::find(ecoResAttributeValue.Value));
                            break;
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addPartyDataToPackage</Name>
				<Source><![CDATA[
    private static void addPartyDataToPackage(RetailCdxDataPackageSerializationHelper serializer, DirPartyRecId partyRecId)
    {
        DirPartyTable               dirPartyTable;
        DirPersonName               dirPersonName;
        DirAddressBookParty         dirAddressBookParty;
        DirPartyLocation            dirPartyLocation;
        LogisticsLocation           logisticsLocation;
        LogisticsPostalAddress      logisticsPostalAddress;
        logisticsLocation           logisticsLocationNested;
        LogisticsElectronicAddress  logisticsElectronicAddress;
        LogisticsElectronicAddress  logisticsElectronicAddressNested;
        LogisticsLocationExt        logisticsLocationExt;
        DirPartyLocationRole        dirPartyLocationRole;
        LogisticsLocationRole       logisticsLocationRole;
        TransDate                   fromDate = dateNull(), toDate = dateMax(); // filter data for a customer from  DirPersonName.

        dirPartyTable = DirPartyTable::findRec(partyRecId);

        if (!dirPartyTable)
        {
            return;
        }

        serializer.writeRecord(dirPartyTable);

        while select validtimestate(fromDate, toDate) dirPersonName
            where dirPersonName.Person == dirPartyTable.RecId
        {
            serializer.writeRecord(dirPersonName);
        }

        while select dirAddressBookParty
            where dirAddressBookParty.Party == dirPartyTable.RecId
        {
            serializer.writeRecord(dirAddressBookParty);
        }

        while select dirPartyLocation
            where dirPartyLocation.Party == dirPartyTable.RecId
        {
            serializer.writeRecord(dirPartyLocation);
        }

        while select logisticsLocation
        exists join dirPartyLocation
            where logisticsLocation.RecId == dirPartyLocation.Location
            && dirPartyLocation.Party == dirPartyTable.RecId
        {
            serializer.writeRecord(logisticsLocation);
        }
        while select logisticsLocationNested
        exists join logisticsLocation
            where logisticsLocationNested.ParentLocation == logisticsLocation.RecId
        exists join dirPartyLocation
            where logisticsLocation.RecId == dirPartyLocation.Location
            && dirPartyLocation.Party == dirPartyTable.RecId
        {
            serializer.writeRecord(logisticsLocationNested);
        }

        while select logisticsPostalAddress
        exists join logisticsLocation
            where logisticsPostalAddress.Location == logisticsLocation.RecId
        exists join dirPartyLocation
            where logisticsLocation.RecId == dirPartyLocation.Location
            && dirPartyLocation.Party == dirPartyTable.RecId
        {
            serializer.writeRecord(logisticsPostalAddress);
        }

        while select logisticsElectronicAddress
        exists join logisticsLocation
            where logisticsElectronicAddress.Location == logisticsLocation.RecId
        exists join dirPartyLocation
            where logisticsLocation.RecId == dirPartyLocation.Location
            && dirPartyLocation.Party == dirPartyTable.RecId
        {
            serializer.writeRecord(logisticsElectronicAddress);
        }
        while select logisticsElectronicAddressNested
        exists join logisticsLocationNested
            where logisticsElectronicAddressNested.Location == logisticsLocationNested.RecId
        exists join logisticsLocation
            where logisticsLocationNested.ParentLocation == logisticsLocation.RecId
        exists join dirPartyLocation
            where logisticsLocation.RecId == dirPartyLocation.Location
            && dirPartyLocation.Party == dirPartyTable.RecId
        {
            serializer.writeRecord(logisticsElectronicAddressNested);
        }

        while select logisticsLocationExt
        exists join logisticsLocation
            where logisticsLocationExt.Location == logisticsLocation.RecId
        exists join dirPartyLocation
            where logisticsLocation.RecId == dirPartyLocation.Location
            && dirPartyLocation.Party == dirPartyTable.RecId
        {
            serializer.writeRecord(logisticsLocationExt);
        }
        while select logisticsLocationExt
        exists join logisticsLocationNested
            where logisticsLocationExt.Location == logisticsLocationNested.RecId
        exists join logisticsLocation
            where logisticsLocationNested.ParentLocation == logisticsLocation.RecId
        exists join dirPartyLocation
            where logisticsLocation.RecId == dirPartyLocation.Location
            && dirPartyLocation.Party == dirPartyTable.RecId
        {
            serializer.writeRecord(logisticsLocationExt);
        }

        while select dirPartyLocationRole
        exists join dirPartyLocation
            where dirPartyLocationRole.PartyLocation == dirPartyLocation.RecId
            && dirPartyLocation.Party == dirPartyTable.RecId
        {
            serializer.writeRecord(dirPartyLocationRole);
        }

        while select logisticsLocationRole
        exists join dirPartyLocationRole
            where logisticsLocationRole.recId == dirPartyLocationRole.LocationRole
        exists join dirPartyLocation
            where dirPartyLocationRole.PartyLocation == dirPartyLocation.RecId
            && dirPartyLocation.Party == dirPartyTable.RecId
        {
            serializer.writeRecord(logisticsLocationRole);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLinkExternalIdWithCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating a link between an external identifier and an existing customer account.
    /// </summary>
    /// <param name="externalIdentityId">
    /// The external identifier.
    /// </param>
    /// <param name="externalIdentityProviderIssuer">
    /// The external identity issuer.
    /// </param>
    /// <param name="customerAccountNumber">
    /// Customer account number.
    /// </param>
    /// <param name="isActiveLink">
    /// Indicate where an active or inactive link should be created.
    /// </param>
    /// <param name="isAutoLinked">
    /// Indicate where an link record created with auto link feature or not.
    /// </param>
    /// <returns>
    /// A row of RetailExternalIdToCustomerMap table.
    /// </returns>
    [Hookable(false)]
    internal static RetailExternalIdToCustomerMap createLinkExternalIdWithCustomer(RetailExternalIdentityId    externalIdentityId,
                                                                                  str    externalIdentityProviderIssuer,
                                                                                  CustAccount    customerAccountNumber,
                                                                                  NoYes isActiveLink,
                                                                                  NoYes isAutoLinked = NoYes::No)
    {
        CustTable                   custTable;
        RetailIdentityProvider      retailIdentityProvider;
        RetailExternalIdToCustomerMap retailExternalIdToCustomerMap;

            select custTable where custTable.AccountNum == customerAccountNumber;
            if (custTable)
            {
                select retailIdentityProvider where retailIdentityProvider.Issuer == externalIdentityProviderIssuer;
                if (retailIdentityProvider)
                {
                    ttsbegin;
                    select forupdate retailExternalIdToCustomerMap
                        where retailExternalIdToCustomerMap.ExternalIdentityId == externalIdentityId && retailExternalIdToCustomerMap.ProviderId == retailIdentityProvider.RecId;
                    if (retailExternalIdToCustomerMap)
                    {
                        retailExternalIdToCustomerMap.CustomerAccountNumber = customerAccountNumber;
                        retailExternalIdToCustomerMap.IsActivated = isActiveLink;
                        retailExternalIdToCustomerMap.IsAutoLinked = isAutoLinked;
                        retailExternalIdToCustomerMap.IsUnlinked = 0;
                        retailExternalIdToCustomerMap.update();
                    }
                    else
                    {
                        retailExternalIdToCustomerMap.ExternalIdentityId = externalIdentityId;
                        retailExternalIdToCustomerMap.ProviderId = retailIdentityProvider.RecId;
                        retailExternalIdToCustomerMap.CustomerAccountNumber = customerAccountNumber;
                        retailExternalIdToCustomerMap.IsActivated = isActiveLink;
                        retailExternalIdToCustomerMap.IsAutoLinked = isAutoLinked;
                        retailExternalIdToCustomerMap.insert();
                    }
                   ttscommit;
                }
                else
                {
                    throw error ("@Retail:InvalidExternalIdentityProvider");
                }
            }
            else
            {
                throw error ("@Retail:InvalidCustomerAccountNumber");
            }

        return retailExternalIdToCustomerMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxInformation_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new primary tax information record from XML.
    /// </summary>
    /// <param name = "taxInformationXml">The XML string containing a tax information entity with nested tax registration number entities.</param>
    /// <returns>The XML containing the collection of tax information entities.</returns>
    /// <remarks>
    /// The primary tax information entity contains nested tax registration numbers.
    /// </remarks>
    public static container createTaxInformation_IN(str taxInformationXml)
    {
        TaxInformation_IN taxInformation;
        TaxRegistrationNumbers_IN tin;
        TaxRegistrationNumbers_IN gstin;

        int fromLine;
        boolean success;
        str error = "@RET2445";

        str resultXmlStr;
        RecId registrationLocation;

        try
        {
            fromLine = Global::infologLine();

            [taxInformation, tin, gstin] = TaxInformationSerializationHelper_IN::deserializeTaxInformation(taxInformationXml);
            [success, error] = RetailTransactionServiceCustomer::addTaxInformation_IN(taxInformation, gstin, tin);

            if (success)
            {
                resultXmlStr = TaxInformationSerializationHelper_IN::getTaxInformationXml(taxInformation.RegistrationLocation).toString();
            }
        }
        catch (Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            str axCallStack = con2Str(xSession::xppCallStack()); // Use AX call stack for Exception::Error
            eventSource.EventWriteCustomerTaxCreateException(funcName(), axCallStack);
        }

        return [success, error, resultXmlStr];
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTaxInformation_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a new tax information record and makes it primary.
    /// </summary>
    /// <param name = "taxInformation">The tax information record.</param>
    /// <param name = "gstin">The GSTIN tax registration number.</param>
    /// <param name = "tin">The TIN (VAT) tax registration number.</param>
    /// <returns>The container with a tax information record.</returns>
    /// <remarks>
    /// The returned tax information record may be either the created record if it's changed,
    /// the current primary tax information record if not changed, or null if there are no
    /// primary tax information records at this location and no tax registration numbers provided.
    /// </remarks>
    private static container addTaxInformation_IN(
        TaxInformation_IN taxInformation,
        TaxRegistrationNumbers_IN gstin,
        TaxRegistrationNumbers_IN tin)
    {
        TaxInformation_IN result;
        TaxInformation_IN oldTaxInformation;
        TaxInformation_IN newTaxInformation;

        int fromLine;
        boolean success;
        str error = "@RET2445";

        try
        {
            fromLine = Global::infologLine();

            if (tin.RegistrationNumber)
            {
                tin = TaxRegistrationNumbers_IN::findOrCreate(tin);
            }

            if (gstin.RegistrationNumber)
            {
                gstin = TaxRegistrationNumbers_IN::findOrCreate(gstin);
            }

            // Get current primary tax information record.
            oldTaxInformation = TaxInformation_IN::findDefaultbyLocation(taxInformation.RegistrationLocation);

            // Create a new primary tax information record without inserting it.
            newTaxInformation.RegistrationLocation = taxInformation.RegistrationLocation;
            newTaxInformation.IsPrimary = NoYes::Yes;
            newTaxInformation.TIN = tin.RecId;
            newTaxInformation.GSTIN = gstin.RecId;

            if (TaxInformation_IN::taxRegistrationNumbersEqual(oldTaxInformation, newTaxInformation))
            {
                result = oldTaxInformation;
            }
            else
            {
                ttsbegin;
                if (oldTaxInformation)
                {
                    // Reset the IsPrimary flag for the current primary record.
                    oldTaxInformation.selectForUpdate(true);
                    oldTaxInformation.IsPrimary = NoYes::No;
                    oldTaxInformation.update();
                }

                // Insert the new primary TaxInformation_IN record.
                newTaxInformation.insert();
                result = newTaxInformation;
                ttscommit;
            }

            success = true;
            error = '';
        }
        catch (Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            str axCallStack = con2Str(xSession::xppCallStack()); // Use AX call stack for Exception::Error
            eventSource.EventWriteCustomerTaxAddException(funcName(), axCallStack);
        }

        return [success, error, result];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdatePANNumber_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates or updates a customer's PAN number.
    /// </summary>
    /// <param name = "accountNum">The customer account number.</param>
    /// <param name = "panNumber">The PAN number.</param>
    /// <returns>The container with the created or updated TaxInformationCustTable_IN record in XML.</returns>
    public static container createOrUpdatePANNumber_IN(str accountNum, str panNumber)
    {
        #define.RootNodeName('ArrayOfCustomerTaxInformation');
        #define.XmlNodeName('CustomerTaxInformation');
        int fromLine;
        boolean success;
        str error = "@RET2445";
        str result;

        try
        {
            fromLine = Global::infologLine();

            ttsbegin;
            TaxInformationCustTable_IN taxInformationCustTableIN = TaxInformationCustTable_IN::findByCustTable(accountNum, true);

            if (taxInformationCustTableIN)
            {
                taxInformationCustTableIN.PANNumber = panNumber;
                taxInformationCustTableIN.PanStatus = PANStatus_IN::Received;
                taxInformationCustTableIN.update();
            }
            else
            {
                taxInformationCustTableIN.CustTable = accountNum;
                taxInformationCustTableIN.PANNumber = panNumber;
                taxInformationCustTableIN.PanStatus = PANStatus_IN::Received;
                taxInformationCustTableIN.insert();
            }
            ttscommit;

            XmlDocument xmlDoc = XmlDocument::newBlank();
            XmlElement xmlRoot = xmlDoc.createElement(#RootNodeName);
            xmlDoc.appendChild(xmlRoot);

            XmlElement taxInformationCustTableXmlElement = TaxInformationSerializationHelper_IN::convertTaxInformationCustTableToXml(taxInformationCustTableIN, xmlDoc, #XmlNodeName);
            xmlRoot.appendChild(taxInformationCustTableXmlElement);
            result = xmlDoc.toString();
            success = true;
            error = '';
        }
        catch (Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            str axCallStack = con2Str(xSession::xppCallStack()); // Use AX call stack for Exception::Error
            eventSource.EventWriteCustomerPANException(funcName(), axCallStack);
        }

        return [success, error, result];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxIdentifiers_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates customer tax identifiers from XML.
    /// </summary>
    /// <param name = "taxIdentifiersDataXml">The XML string containing a tax identifiers data.</param>
    /// <returns>A <c>Container</c> containing result info.</returns>
    public static container updateTaxIdentifiers_BR(str taxIdentifiersDataXml)
    {
        boolean success;
        str errorMessage;
        int infologLine;

        try
        {
            infologLine = Global::infologLine();

            str cnpjCpfNumber;
            str ieNumber;
            str ccmNumber;
            str foreignerId;
            RecId recId;
            [cnpjCpfNumber, ieNumber, ccmNumber, recId, foreignerId] = RetailTaxInformationSerializationHelper_BR::deserializeTaxInformation(taxIdentifiersDataXml);

            CustTable custTable;
            custTable = CustTable::findRecId(recId, true);

            if (custTable)
            {
                ttsbegin;

                custTable.CNPJCPFNum_BR = cnpjCpfNumber;
                custTable.IENum_BR = ieNumber;
                custTable.CCMNum_BR = ccmNumber;
                custTable.ForeignerId_BR = foreignerId;
                custTable.update();

                ttscommit;

                success = true;
            }
            else
            {
                errorMessage = strfmt("@SYS76877", 'Customer');
            }
        }
        catch (Exception::Error)
        {
            errorMessage = RetailTransactionServiceUtilities::getInfologMessages(infologLine);
            str axCallStack = con2Str(xSession::xppCallStack()); // Use AX call stack for Exception::Error
            eventSource.EventWriteCustomerTaxUpdateException(funcName(), axCallStack);
        }

        return [success, errorMessage, ''];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerTimelineItemTypes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets customer time line item types.
    /// </summary>
    /// <returns>
    /// A container with entity keys.
    /// </returns>
    public static container getCustomerTimelineItemTypes()
    {
        smmActivityTypeGroup smmActivityType;
        int fromLine;

        // The RTS is only available if clienteling feature is enabled.
        if (!RetailClientelingFeatureExposure::isEnabled())
        {
            eventSource.EventWriteClientelingFeatureNotEnabled();
            return [false, "@Retail:ClientelingFeatureNotEnabled"];
        }

        try
        {
            fromLine = Global::infologLine();

            System.Collections.ArrayList resultList = new System.Collections.ArrayList();
            Microsoft.Dynamics.Commerce.Runtime.DataModel.CustomerTimelineItemType type;
            Microsoft.Dynamics.Commerce.Runtime.DataModel.CustomerTimelineItemTypeMap map;
            CLRObject types = new System.Collections.Generic.List<Microsoft.Dynamics.Commerce.Runtime.DataModel.CustomerTimelineItemType>();

            // Get customer activity entity type records and fill field values.
            while select TypeId, Description from smmActivityType
            {
                type = new Microsoft.Dynamics.Commerce.Runtime.DataModel.CustomerTimelineItemType();
                type.Description = smmActivityType.Description;
                type.TypeId = smmActivityType.TypeId;

                types.Add(type);
            }

            map = new Microsoft.Dynamics.Commerce.Runtime.DataModel.CustomerTimelineItemTypeMap();
            map.EntityType = RetailCustomerTimelineItemEntityType::Activity;
            map.Types = types;
            resultList.Add(map);

            // Get customer note entity type record and fill field values.
            DocuType docuType = DocuType::find(DocuType::typeNote());

            if (docuType)
            {
                map = new Microsoft.Dynamics.Commerce.Runtime.DataModel.CustomerTimelineItemTypeMap();
                map.EntityType = RetailCustomerTimelineItemEntityType::Note;
                types = new System.Collections.Generic.List<Microsoft.Dynamics.Commerce.Runtime.DataModel.CustomerTimelineItemType>();
                type = new Microsoft.Dynamics.Commerce.Runtime.DataModel.CustomerTimelineItemType();
                type.Description = docuType.Name;
                type.TypeId = docuType.TypeId;

                types.Add(type);
                map.Types = types;
                resultList.Add(map);
            }

            // Serialize the data-contract list using the specified type list.
            System.Type[] typeArray = new System.Type[1]();
            typeArray.SetValue(map.GetType(), 0);

            return [true, '', RetailTransactionServiceJsonHelper::SerializeToJson(resultList, typeArray)];
        }
        catch (Exception::Error)
        {
            eventSource.EventWriteClientelingReadCustomerActivityTypesFailed();
            return [false, RetailTransactionServiceUtilities::getInfologMessages(fromLine)];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerTimelineItems</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets customer time line items.
    /// </summary>
    /// <param name="criteriaJsonArgumentString">
    /// JSON string contains the criteria arguments for the method call.
    /// </param>
    /// <param name="querySettingsJsonArgumentString">
    /// JSON string contains the query settings arguments for the method call.
    /// </param>
    /// <returns>
    /// A container with entity keys.
    /// </returns>
    public static container getCustomerTimelineItems(str criteriaJsonArgumentString = '', str querySettingsJsonArgumentString = '')
    {
        int fromLine;
        int resultsCount = 0;
        int resultsMaxInsertCount = 100;
        int skip = 0;
        int top = 100;

        smmActivities smmActivities;
        smmActivityParentLinkTable smmActivityParentLinkTable;
        TmpCustomerTimelineItems tmpCustomerTimelineItems;
        HcmWorker hcmWorker;
        DocuRef docuRef;

        // The RTS is only available if clienteling feature is enabled.
        if (!RetailClientelingFeatureExposure::isEnabled())
        {
            eventSource.EventWriteClientelingFeatureNotEnabled();
            return [false, "@Retail:ClientelingFeatureNotEnabled"];
        }

        try
        {
            fromLine = Global::infologLine();

            if (criteriaJsonArgumentString == '')
            {
                return [false, "@Retail:RealTimeServiceInputRequestNullError"];
            }

            Microsoft.Dynamics.Commerce.Runtime.TransactionService.GetCustomerTimelineItemsCriteria criteria = RetailTransactionServiceJsonHelper::DeserializeGetCustomerTimelineItemsCriteriaFromJSON(criteriaJsonArgumentString);
            if (criteria.CustomerId == '')
            {
                return [false, "@Retail:RealTimeServiceInputRequestNullError"];
            }

            if (querySettingsJsonArgumentString != '')
            {
                Microsoft.Dynamics.Commerce.Runtime.DataModel.QueryResultSettings settings = RetailTransactionServiceJsonHelper::DeserializeQueryResultSettingsFromJSON(querySettingsJsonArgumentString, top);
                skip = settings.Paging.Skip;
                top = settings.Paging.Top;
                resultsMaxInsertCount = skip + top;
            }

            System.Collections.ArrayList resultList = new System.Collections.ArrayList();
            Microsoft.Dynamics.Commerce.Runtime.DataModel.CustomerTimelineItem item = new Microsoft.Dynamics.Commerce.Runtime.DataModel.CustomerTimelineItem();

            CustTable custTable = CustTable::find(criteria.CustomerId);
            DataAreaId dataAreaId = curext();

            if (custTable)
            {
                ttsbegin;

                tmpCustomerTimelineItems.clear();

                while   select RecId, Purpose, UserMemo, TypeId, StartDateTime
                        from smmActivities
                        order by smmActivities.startDateTime desc
                        where smmActivities.Category == smmActivityCategory::Action
                        join smmActivityParentLinkTable
                        where smmActivityParentLinkTable.ActivityNumber == smmActivities.ActivityNumber
                        && smmActivityParentLinkTable.RefTableId == custTable.TableId
                        && smmActivityParentLinkTable.RefRecId == custTable.RecId
                        && smmActivityParentLinkTable.ParentType == smmActivityParentType::Customer
                        join RecId, PersonnelNumber
                        from hcmWorker
                        where hcmWorker.RecId == smmActivities.ResponsibleWorker
                {
                    if (resultsCount < resultsMaxInsertCount)
                    {
                        tmpCustomerTimelineItems.initValue();
                        tmpCustomerTimelineItems.RefRecId = smmActivities.RecId;
                        tmpCustomerTimelineItems.Title = smmActivities.Purpose;
                        tmpCustomerTimelineItems.Description = smmActivities.UserMemo;
                        tmpCustomerTimelineItems.TypeId = smmActivities.TypeId;
                        tmpCustomerTimelineItems.StartDateTime = smmActivities.StartDateTime;
                        tmpCustomerTimelineItems.EntityType = RetailCustomerTimelineItemEntityType::Activity;
                        tmpCustomerTimelineItems.CustomerAccountNumber = custTable.AccountNum;
                        tmpCustomerTimelineItems.StaffId = hcmWorker.PersonnelNumber;

                        tmpCustomerTimelineItems.insert();
                        resultsCount++;
                    }
                    else
                    {
                        break;
                    }
                }

                resultsCount = 0;

                while select RecId, Name, Notes, TypeId, ModifiedDateTime
                        from docuRef
                        order by docuRef.CreatedDateTime desc
                        where docuRef.TypeId == DocuType::typeNote()
                        && docuRef.RefTableId == custTable.TableId
                        && docuRef.RefRecId == custTable.RecId
                        && docuRef.REFCOMPANYID == dataAreaId
                {
                    if (resultsCount < resultsMaxInsertCount)
                    {
                        tmpCustomerTimelineItems.initValue();
                        tmpCustomerTimelineItems.RefRecId = docuRef.RecId;
                        tmpCustomerTimelineItems.Title = docuRef.Name;
                        tmpCustomerTimelineItems.Description = docuRef.Notes;
                        tmpCustomerTimelineItems.TypeId = docuRef.TypeId;
                        tmpCustomerTimelineItems.StartDateTime = docuRef.ModifiedDateTime;
                        tmpCustomerTimelineItems.EntityType = RetailCustomerTimelineItemEntityType::Note;
                        tmpCustomerTimelineItems.CustomerAccountNumber = custTable.AccountNum;
                        tmpCustomerTimelineItems.StaffId = '';

                        tmpCustomerTimelineItems.insert();
                        resultsCount++;
                    }
                    else
                    {
                        break;
                    }
                }

                ttscommit;

                resultsCount = 0;

                while   select *
                        from tmpCustomerTimelineItems
                        order by StartDateTime desc
                {
                    if (resultsCount < skip)
                    {
                        resultsCount++;
                        continue;
                    }
                    else if (resultsCount < resultsMaxInsertCount)
                    {
                        item = new Microsoft.Dynamics.Commerce.Runtime.DataModel.CustomerTimelineItem();
                        item.CustomerId = tmpCustomerTimelineItems.CustomerAccountNumber;
                        item.Description = tmpCustomerTimelineItems.Description;
                        item.Id = int642Str(tmpCustomerTimelineItems.RefRecId);
                        item.EntityType = tmpCustomerTimelineItems.EntityType;
                        item.TypeId = tmpCustomerTimelineItems.TypeId;
                        System.DateTime startDateTime = System.DateTime::SpecifyKind(tmpCustomerTimelineItems.StartDateTime, System.DateTimeKind::Utc);
                        item.StartDateTime = new System.DateTimeOffset(startDateTime);
                        item.Title = tmpCustomerTimelineItems.Title;
                        item.StaffId = tmpCustomerTimelineItems.StaffId;

                        resultList.Add(item);
                        resultsCount++;
                    }
                    else
                    {
                        break;
                    }
                }

                tmpCustomerTimelineItems = null;

                // Serialize the data-contract list using the specified type list.
                System.Type[] typeArray = new System.Type[1]();
                typeArray.SetValue(item.GetType(), 0);

                return [true, '', RetailTransactionServiceJsonHelper::SerializeToJson(resultList, typeArray)];
            }
            else
            {
                eventSource.EventWriteClientelingCustomerAccountNotFoundForGetTimelineItems();
                return [false, strFmt("@SYS119849", criteria.CustomerId)];
            }
        }
        catch (Exception::Error)
        {
            ttsabort;
            eventSource.EventWriteClientelingReadCustomerTimelineItemsFailed();
            return [false, RetailTransactionServiceUtilities::getInfologMessages(fromLine)];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustomerActivity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates activity for the customer.
    /// </summary>
    /// <param name="jsonArgumentString">
    /// JSON string contains the arguments for the method call.
    /// </param>
    /// <returns>
    /// A container with entity keys.
    /// </returns>
    public static container createCustomerActivity(str jsonArgumentString = '')
    {
        // The RTS is only available if clienteling feature is enabled.
        if (!RetailClientelingFeatureExposure::isEnabled())
        {
            eventSource.EventWriteClientelingFeatureNotEnabled();
            return [false, "@Retail:ClientelingFeatureNotEnabled", 0];
        }

        // [FLIGHT-BUG]
        // Bug 879256: Customer related RTS didn't handle ttscommit exceptions correctly and returns succeed after ttscommit failure.
        // The flight below is responsible to revert the changes introduced by this Bug 879256 fix.
        if (!RetailCustomerCreateCustomerActivityRtsRevertFlight::instance().isEnabled())
        {
            str error;
            boolean validInsert = true;
            int fromLine;

            RecId recId = 0;
            CustTable custTable;
            HcmWorker hcmWorker;
            smmActivities smmActivities;
            smmActivityParentLinkTable smmActivityParentLinkTable;

            try
            {
                if (jsonArgumentString == '')
                {
                    return [false, "@Retail:RealTimeServiceInputRequestNullError"];
                }

                Microsoft.Dynamics.Commerce.Runtime.DataModel.CustomerTimelineItem item = RetailTransactionServiceJsonHelper::DeserializeCustomerTimelineItemFromJSON(jsonArgumentString);

                if (item.Title == '' || item.Description == '' || item.StaffId == '' || item.CustomerId == '')
                {
                    return [false, "@Retail:RealTimeServiceInputRequestNullError"];
                }

                fromLine = Global::infologLine();
                custTable = CustTable::find(item.CustomerId);
                hcmWorker = HcmWorker::findByPersonnelNumber(item.StaffId);

                System.DateTime startDateTime = item.StartDateTime.get_UtcDateTime();

                // Only insert the customer activity if find target customer and employed worker.
                if (custTable && hcmWorker && hcmWorker.workerStatus() == HcmWorkerStatus::Employed)
                {
                    eventSource.EventWriteClientelingCreateCustomerActivityStart(hcmWorker.RecId, custTable.RecId);
                    ttsbegin;

                    smmActivities.clear();
                    smmActivities.initValue();

                    // Get new activity number.
                    NumberSeq seq = NumberSeq::newGetNum(NumberSeqReference::findReference(extendedTypeNum(smmActivityNumber)), true, true);
                    smmActivities.ActivityNumber = seq.num();

                    smmActivities.Purpose = item.Title;
                    smmActivities.UserMemo = item.Description;
                    smmActivities.startDateTime = startDateTime;
                    smmActivities.ResponsibleWorker = hcmWorker.RecId;
                    smmActivities.Category = smmActivityCategory::Action;
                    smmActivities.TypeId = item.TypeId;

                    // Insert the activity record.
                    smmActivities.insert();

                    // Insert the parent mapping record between activity and customer table.
                    smmActivityParentLinkTable.clear();
                    smmActivityParentLinkTable.initValue();

                    smmActivityParentLinkTable.ActivityNumber = smmActivities.ActivityNumber;
                    smmActivityParentLinkTable.ParentType = smmActivityParentType::Customer;
                    smmActivityParentLinkTable.PrimaryLink = NoYes::Yes;
                    smmActivityParentLinkTable.RefTableId = CustTable.TableId;
                    smmActivityParentLinkTable.RefRecId = custTable.RecId;

                    smmActivityParentLinkTable.insert();

                    // Create organizer in the attendee table
                    smmAttendeeTable::createOrganizer(smmActivities);

                    ttscommit;
                
                    recId = smmActivities.RecId;

                    eventSource.EventWriteClientelingCreateCustomerActivityEnd(hcmWorker.RecId, custTable.RecId);
                }
                else
                {
                    validInsert = false;
                    if (!custTable)
                    {
                        error = strFmt("@SYS119849", item.CustomerId);
                        eventSource.EventWriteClientelingCustomerAccountNotFoundForCreateActivity();
                    }
                    else
                    {
                        error = strFmt("@Retail:InvalidStaffIdError", item.StaffId);
                        eventSource.EventWriteClientelingStaffNotFoundForCreateActivity();
                    }
                }
            }
            catch (Exception::Error)
            {
                ttsabort;
                validInsert = false;
                error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                eventSource.EventWriteClientelingCreateCustomerActivityFailed();
            }

            return [validInsert, error, recId];
        }
        else
        {
            str error;
            boolean validInsert = false;
            int fromLine;

            RecId recId = 0;
            CustTable custTable;
            HcmWorker hcmWorker;
            smmActivities smmActivities;
            smmActivityParentLinkTable smmActivityParentLinkTable;

            try
            {
                if (jsonArgumentString == '')
                {
                    return [false, "@Retail:RealTimeServiceInputRequestNullError"];
                }

                Microsoft.Dynamics.Commerce.Runtime.DataModel.CustomerTimelineItem item = RetailTransactionServiceJsonHelper::DeserializeCustomerTimelineItemFromJSON(jsonArgumentString);

                if (item.Title == '' || item.Description == '' || item.StaffId == '' || item.CustomerId == '')
                {
                    return [false, "@Retail:RealTimeServiceInputRequestNullError"];
                }

                fromLine = Global::infologLine();
                custTable = CustTable::find(item.CustomerId);
                hcmWorker = HcmWorker::findByPersonnelNumber(item.StaffId);

                System.DateTime startDateTime = item.StartDateTime.get_UtcDateTime();

                // Only insert the customer activity if find target customer and employed worker.
                if (custTable && hcmWorker && hcmWorker.workerStatus() == HcmWorkerStatus::Employed)
                {
                    eventSource.EventWriteClientelingCreateCustomerActivityStart(hcmWorker.RecId, custTable.RecId);
                    ttsbegin;

                    smmActivities.clear();
                    smmActivities.initValue();

                    // Get new activity number.
                    NumberSeq seq = NumberSeq::newGetNum(NumberSeqReference::findReference(extendedTypeNum(smmActivityNumber)), true, true);
                    smmActivities.ActivityNumber = seq.num();

                    smmActivities.Purpose = item.Title;
                    smmActivities.UserMemo = item.Description;
                    smmActivities.startDateTime = startDateTime;
                    smmActivities.ResponsibleWorker = hcmWorker.RecId;
                    smmActivities.Category = smmActivityCategory::Action;
                    smmActivities.TypeId = item.TypeId;

                    // Insert the activity record.
                    smmActivities.insert();

                    // Insert the parent mapping record between activity and customer table.
                    smmActivityParentLinkTable.clear();
                    smmActivityParentLinkTable.initValue();

                    smmActivityParentLinkTable.ActivityNumber = smmActivities.ActivityNumber;
                    smmActivityParentLinkTable.ParentType = smmActivityParentType::Customer;
                    smmActivityParentLinkTable.PrimaryLink = NoYes::Yes;
                    smmActivityParentLinkTable.RefTableId = CustTable.TableId;
                    smmActivityParentLinkTable.RefRecId = custTable.RecId;

                    smmActivityParentLinkTable.insert();

                    // Create organizer in the attendee table
                    smmAttendeeTable::createOrganizer(smmActivities);

                    validInsert = true;
                    error = '';
                    recId = smmActivities.RecId;

                    ttscommit;
                    eventSource.EventWriteClientelingCreateCustomerActivityEnd(hcmWorker.RecId, custTable.RecId);
                }
                else
                {
                    if (!custTable)
                    {
                        error = strFmt("@SYS119849", item.CustomerId);
                        eventSource.EventWriteClientelingCustomerAccountNotFoundForCreateActivity();
                    }
                    else
                    {
                        error = strFmt("@Retail:InvalidStaffIdError", item.StaffId);
                        eventSource.EventWriteClientelingStaffNotFoundForCreateActivity();
                    }
                }
            }
            catch (Exception::Error)
            {
                ttsabort;
                error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                eventSource.EventWriteClientelingCreateCustomerActivityFailed();
            }

            return [validInsert, error, recId];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustomerNote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates note for the customer.
    /// </summary>
    /// <param name="jsonArgumentString">
    /// JSON string contains the arguments for the method call.
    /// </param>
    /// <returns>
    /// A container with entity keys.
    /// </returns>
    public static container createCustomerNote(str jsonArgumentString = '')
    {
        // The RTS is only available if clienteling feature is enabled.
        if (!RetailClientelingFeatureExposure::isEnabled())
        {
            eventSource.EventWriteClientelingFeatureNotEnabled();
            return [false, "@Retail:ClientelingFeatureNotEnabled", 0];
        }

        // [FLIGHT-BUG]
        // Bug 879256: Customer related RTS didn't handle ttscommit exceptions correctly and returns succeed after ttscommit failure.
        // The flight below is responsible to revert the changes introduced by this Bug 879256 fix.
        if (!RetailCustomerCreateCustomerNoteRtsRevertFlight::instance().isEnabled())
        {
            str error;
            boolean validInsert = true;
            int fromLine;

            RecId recId = 0;
            CustTable custTable;
            DocuRef docuRef;

            try
            {
                if (jsonArgumentString == '')
                {
                    return [false, "@Retail:RealTimeServiceInputRequestNullError"];
                }

                Microsoft.Dynamics.Commerce.Runtime.DataModel.CustomerTimelineItem item = RetailTransactionServiceJsonHelper::DeserializeCustomerTimelineItemFromJSON(jsonArgumentString);
                DataAreaId dataAreaId = curext();

                if (item.Title == '' || item.Description == '' || item.CustomerId == '')
                {
                    return [false, "@Retail:RealTimeServiceInputRequestNullError"];
                }

                fromLine = Global::infologLine();
                custTable = CustTable::find(item.CustomerId);

                // Only insert customer note if find target customer.
                if (custTable)
                {
                    eventSource.EventWriteClientelingCreateCustomerNoteStart(custTable.RecId);
                    ttsbegin;

                    docuRef.clear();
                    docuRef.initValue();

                    docuRef.Name = item.Title;
                    docuRef.Notes = item.Description;
                    docuRef.RefCompanyId = dataAreaId;
                    docuRef.ActualCompanyId = dataAreaId;

                    docuRef.TypeId = DocuType::typeNote();
                    docuRef.RefTableId = custTable.TableId;
                    docuRef.RefRecId = custTable.RecId;

                    docuRef.insert();

                    ttscommit;

                    recId = docuRef.RecId;

                    eventSource.EventWriteClientelingCreateCustomerNoteEnd(custTable.RecId);
                }
                else
                {
                    validInsert = false;
                    error = strFmt("@SYS119849", item.CustomerId);
                    eventSource.EventWriteClientelingCustomerAccountNotFoundForCreateNote();
                }
            }
            catch (Exception::Error)
            {
                ttsabort;
                validInsert = false;
                error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                eventSource.EventWriteClientelingCreateCustomerNoteFailed();
            }

            return [validInsert, error, recId];
        }
        else
        {
            str error;
            boolean validInsert = false;
            int fromLine;

            RecId recId = 0;
            CustTable custTable;
            DocuRef docuRef;

            try
            {
                if (jsonArgumentString == '')
                {
                    return [false, "@Retail:RealTimeServiceInputRequestNullError"];
                }

                Microsoft.Dynamics.Commerce.Runtime.DataModel.CustomerTimelineItem item = RetailTransactionServiceJsonHelper::DeserializeCustomerTimelineItemFromJSON(jsonArgumentString);
                DataAreaId dataAreaId = curext();

                if (item.Title == '' || item.Description == '' || item.CustomerId == '')
                {
                    return [false, "@Retail:RealTimeServiceInputRequestNullError"];
                }

                fromLine = Global::infologLine();
                custTable = CustTable::find(item.CustomerId);

                // Only insert customer note if find target customer.
                if (custTable)
                {
                    eventSource.EventWriteClientelingCreateCustomerNoteStart(custTable.RecId);
                    ttsbegin;

                    docuRef.clear();
                    docuRef.initValue();

                    docuRef.Name = item.Title;
                    docuRef.Notes = item.Description;
                    docuRef.RefCompanyId = dataAreaId;
                    docuRef.ActualCompanyId = dataAreaId;

                    docuRef.TypeId = DocuType::typeNote();
                    docuRef.RefTableId = custTable.TableId;
                    docuRef.RefRecId = custTable.RecId;

                    docuRef.insert();

                    validInsert = true;
                    error = '';
                    recId = docuRef.RecId;

                    ttscommit;
                    eventSource.EventWriteClientelingCreateCustomerNoteEnd(custTable.RecId);
                }
                else
                {
                    error = strFmt("@SYS119849", item.CustomerId);
                    eventSource.EventWriteClientelingCustomerAccountNotFoundForCreateNote();
                }
            }
            catch (Exception::Error)
            {
                ttsabort;
                error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                eventSource.EventWriteClientelingCreateCustomerNoteFailed();
            }

            return [validInsert, error, recId];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomerActivity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates activity for the customer.
    /// </summary>
    /// <param name="jsonArgumentString">
    /// JSON string contains the arguments for the method call.
    /// </param>
    /// <returns>
    /// A container with entity keys.
    /// </returns>
    public static container updateCustomerActivity(str jsonArgumentString = '')
    {
        // The RTS is only available if clienteling feature is enabled.
        if (!RetailClientelingFeatureExposure::isEnabled())
        {
            eventSource.EventWriteClientelingFeatureNotEnabled();
            return [false, "@Retail:ClientelingFeatureNotEnabled", 0];
        }

        // [FLIGHT-BUG]
        // Bug 879256: Customer related RTS didn't handle ttscommit exceptions correctly and returns succeed after ttscommit failure.
        // The flight below is responsible to revert the changes introduced by this Bug 879256 fix.
        if (!RetailCustomerUpdateCustomerActivityRtsRevertFlight::instance().isEnabled())
        {
            str error;
            boolean validUpdate = true;
            int fromLine;

            smmActivities smmActivity;
            RecId recId = 0;

            try
            {
                if (jsonArgumentString == '')
                {
                    return [false, "@Retail:RealTimeServiceInputRequestNullError"];
                }

                Microsoft.Dynamics.Commerce.Runtime.DataModel.CustomerTimelineItem item = RetailTransactionServiceJsonHelper::DeserializeCustomerTimelineItemFromJSON(jsonArgumentString);
                recId = str2Int64(item.Id);
                System.DateTime startDateTime = item.StartDateTime.get_UtcDateTime();

                if (item.Id == '' || item.Title == '' || item.Description == '' || item.StaffId == '')
                {
                    return [false, "@Retail:RealTimeServiceInputRequestNullError"];
                }

                fromLine = Global::infologLine();
                smmActivity = smmActivities::findWithRecId(recId, true);
                HcmWorker hcmWorker = HcmWorker::findByPersonnelNumber(item.StaffId);

                // Find target activity with activity number then update the fields needed.
                if (smmActivity && hcmWorker && hcmWorker.workerStatus() == HcmWorkerStatus::Employed)
                {
                    eventSource.EventWriteClientelingUpdateCustomerActivityStart(smmActivity.RecId);
                    ttsbegin;

                    smmActivity.Purpose = item.Title;
                    smmActivity.UserMemo = item.Description;
                    smmActivity.TypeId = item.TypeId;
                    smmActivity.ResponsibleWorker = hcmWorker.RecId;
                    smmActivity.startDateTime = startDateTime;

                    smmActivity.update();

                    ttscommit;

                    eventSource.EventWriteClientelingUpdateCustomerActivityEnd(smmActivity.RecId);
                }
                else
                {
                    validUpdate = false;
                    if (!smmActivity)
                    {
                        error = strFmt("@Retail:InvalidActivityRecId", recId);
                        eventSource.EventWriteClientelingActivityNotFoundForUpdate();
                    }
                    else
                    {
                        error = strFmt("@Retail:InvalidStaffIdError", item.StaffId);
                        eventSource.EventWriteClientelingStaffNotFoundForUpdateActivity();
                    }
                }
            }
            catch (Exception::Error)
            {
                ttsabort;
                validUpdate = false;
                error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                eventSource.EventWriteClientelingUpdateCustomerActivityFailed(smmActivity.RecId);
            }

            return [validUpdate, error, recId];
        }
        else
        {
            str error;
            boolean validUpdate = false;
            int fromLine;

            smmActivities smmActivity;
            RecId recId = 0;

            try
            {
                if (jsonArgumentString == '')
                {
                    return [false, "@Retail:RealTimeServiceInputRequestNullError"];
                }

                Microsoft.Dynamics.Commerce.Runtime.DataModel.CustomerTimelineItem item = RetailTransactionServiceJsonHelper::DeserializeCustomerTimelineItemFromJSON(jsonArgumentString);
                recId = str2Int64(item.Id);
                System.DateTime startDateTime = item.StartDateTime.get_UtcDateTime();

                if (item.Id == '' || item.Title == '' || item.Description == '' || item.StaffId == '')
                {
                    return [false, "@Retail:RealTimeServiceInputRequestNullError"];
                }

                fromLine = Global::infologLine();
                smmActivity = smmActivities::findWithRecId(recId, true);
                HcmWorker hcmWorker = HcmWorker::findByPersonnelNumber(item.StaffId);

                // Find target activity with activity number then update the fields needed.
                if (smmActivity && hcmWorker && hcmWorker.workerStatus() == HcmWorkerStatus::Employed)
                {
                    eventSource.EventWriteClientelingUpdateCustomerActivityStart(smmActivity.RecId);
                    ttsbegin;

                    smmActivity.Purpose = item.Title;
                    smmActivity.UserMemo = item.Description;
                    smmActivity.TypeId = item.TypeId;
                    smmActivity.ResponsibleWorker = hcmWorker.RecId;
                    smmActivity.startDateTime = startDateTime;

                    smmActivity.update();
                    validUpdate = true;
                    error = '';

                    ttscommit;
                    eventSource.EventWriteClientelingUpdateCustomerActivityEnd(smmActivity.RecId);
                }
                else
                {
                    if (!smmActivity)
                    {
                        error = strFmt("@Retail:InvalidActivityRecId", recId);
                        eventSource.EventWriteClientelingActivityNotFoundForUpdate();
                    }
                    else
                    {
                        error = strFmt("@Retail:InvalidStaffIdError", item.StaffId);
                        eventSource.EventWriteClientelingStaffNotFoundForUpdateActivity();
                    }
                }
            }
            catch (Exception::Error)
            {
                ttsabort;
                error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                eventSource.EventWriteClientelingUpdateCustomerActivityFailed(smmActivity.RecId);
            }

            return [validUpdate, error, recId];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomerNote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates note for the customer.
    /// </summary>
    /// <param name="jsonArgumentString">
    /// JSON string contains the arguments for the method call.
    /// </param>
    /// <returns>
    /// A container with entity keys.
    /// </returns>
    public static container updateCustomerNote(str jsonArgumentString = '')
    {
        // The RTS is only available if clienteling feature is enabled.
        if (!RetailClientelingFeatureExposure::isEnabled())
        {
            eventSource.EventWriteClientelingFeatureNotEnabled();
            return [false, "@Retail:ClientelingFeatureNotEnabled", 0];
        }

        // [FLIGHT-BUG]
        // Bug 879256: Customer related RTS didn't handle ttscommit exceptions correctly and returns succeed after ttscommit failure.
        // The flight below is responsible to revert the changes introduced by this Bug 879256 fix.
        if (!RetailCustomerUpdateCustomerNoteRtsRevertFlight::instance().isEnabled())
        {
            str error;
            boolean validUpdate = true;
            int fromLine;

            DocuRef docuRef;
            RecId recId = 0;

            try
            {
                if (jsonArgumentString == '')
                {
                    return [false, "@Retail:RealTimeServiceInputRequestNullError"];
                }

                Microsoft.Dynamics.Commerce.Runtime.DataModel.CustomerTimelineItem item = RetailTransactionServiceJsonHelper::DeserializeCustomerTimelineItemFromJSON(jsonArgumentString);
                recId = str2Int64(item.Id);

                if (item.Title == '' || item.Description == '')
                {
                    return [false, "@Retail:RealTimeServiceInputRequestNullError"];
                }

                fromLine = Global::infologLine();
                docuRef = DocuRef::findRecId(recId, true);

                // Find target customer note with record Id and update fields needed.
                if (docuRef)
                {
                    eventSource.EventWriteClientelingUpdateCustomerNoteStart(docuRef.RecId);
                    ttsbegin;

                    docuRef.Name = item.Title;
                    docuRef.Notes = item.Description;
                    docuRef.update();

                    ttscommit;

                    eventSource.EventWriteClientelingUpdateCustomerNoteEnd(recId);
                }
                else
                {
                    validUpdate = false;
                    error = strFmt("@Retail:InvalidNoteRecId", recId);
                    eventSource.EventWriteClientelingNoteNotFoundForUpdate(recId);
                }
            }
            catch (Exception::Error)
            {
                ttsabort;
                validUpdate = false;
                error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                eventSource.EventWriteClientelingUpdateCustomerNoteFailed(recId);
            }

            return [validUpdate, error, recId];
        }
        else
        {
            str error;
            boolean validUpdate = false;
            int fromLine;

            DocuRef docuRef;
            RecId recId = 0;

            try
            {
                if (jsonArgumentString == '')
                {
                    return [false, "@Retail:RealTimeServiceInputRequestNullError"];
                }

                Microsoft.Dynamics.Commerce.Runtime.DataModel.CustomerTimelineItem item = RetailTransactionServiceJsonHelper::DeserializeCustomerTimelineItemFromJSON(jsonArgumentString);
                recId = str2Int64(item.Id);

                if (item.Title == '' || item.Description == '')
                {
                    return [false, "@Retail:RealTimeServiceInputRequestNullError"];
                }

                fromLine = Global::infologLine();
                docuRef = DocuRef::findRecId(recId, true);

                // Find target customer note with record Id and update fields needed.
                if (docuRef)
                {
                    eventSource.EventWriteClientelingUpdateCustomerNoteStart(docuRef.RecId);
                    ttsbegin;

                    docuRef.Name = item.Title;
                    docuRef.Notes = item.Description;
                    docuRef.update();

                    validUpdate = true;
                    error = '';

                    ttscommit;
                    eventSource.EventWriteClientelingUpdateCustomerNoteEnd(recId);
                }
                else
                {
                    error = strFmt("@Retail:InvalidNoteRecId", recId);
                    eventSource.EventWriteClientelingNoteNotFoundForUpdate(recId);
                }
            }
            catch (Exception::Error)
            {
                ttsabort;
                error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
                eventSource.EventWriteClientelingUpdateCustomerNoteFailed(recId);
            }

            return [validUpdate, error, recId];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomerFiscalCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates FiscalCode field for a specific customer.
    /// </summary>
    /// <param name = "accountNum">The customer account number.</param>
    /// <param name = "fiscalCode">The fiscal code.</param>
    /// <returns>A <c>Container</c> containing result info.</returns>
    public static container updateCustomerFiscalCode(str accountNum, str fiscalCode)
    {
        boolean success;
        str errorMessage;
        int infologLine;

        try
        {
            infologLine = Global::infologLine();

            if (CustTable::checkExist(accountNum))
            {
                ttsbegin;

                CustTable custTable;
                custTable = CustTable::find(accountNum, true);

                custTable.FiscalCode = fiscalCode;
                custTable.update();

                ttscommit;

                success = true;
            }
            else
            {
                errorMessage = strfmt("@SYS76877", 'Customer');
            }
        }
        catch (Exception::Error)
        {
            errorMessage = RetailTransactionServiceUtilities::getInfologMessages(infologLine);
            eventSource.EventWriteCustomerGenericMessage('RetailTransactionService', funcName(), errorMessage);
        }

        return [success, errorMessage, ''];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateCurrentTaxRegistration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new or updates the current <c>TaxRegistration</c> record at a given <c>DirPartyLocation</c> having the specified tax registration type and number.
    /// </summary>
    /// <param name = "dirPartyLocationRecId">The <c>DirPartyLocation</c> record id.</param>
    /// <param name = "taxRegistrationType">The tax registration type.</param>
    /// <param name = "registrationNumber">The registration number.</param>
    /// <param name = "effectiveDate">The date used to search or create the current record.</param>
    /// <param name = "dateSequence">The date format.</param>
    /// <returns>A <c>Container</c> containing an XML with <c>TaxRegistration</c> entities having the same directory party location and tax registration type.</returns>
    public static container createOrUpdateCurrentTaxRegistration(
        DirPartyLocationRecId dirPartyLocationRecId,
        TaxRegistrationTypesList taxRegistrationType,
        str registrationNumber,
        str effectiveDate,
        int dateSequence = 321)
    {
        boolean success;
        str errorMessage;
        int infologLine;
        str result;

        try
        {
            infologLine = Global::infologLine();
            TaxRegistration taxRegistration = TaxRegistration::createOrUpdateCurrentTaxRegistration(dirPartyLocationRecId, taxRegistrationType, registrationNumber, str2Date(effectiveDate, dateSequence));
            Query query = TaxRegistration::queryDirPartyLocationTaxRegistrationType(dirPartyLocationRecId, taxRegistrationType);
            result = RetailTaxRegistrationSerializationHelper::serializeTaxRegistrationQueryToXml(query).toString();
            success = true;
        }
        catch (Exception::Error)
        {
            success = false;
            errorMessage = RetailTransactionServiceUtilities::getInfologMessages(infologLine);
            eventSource.EventWriteCustomerGenericMessage('RetailTransactionService', funcName(), errorMessage);
        }

        return [success, errorMessage, result];
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTaxRegistration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes a tax registration record by identifier.
    /// </summary>
    /// <param name="taxRegistrationRecId">
    /// The TaxRegistration record identifier.
    /// </param>
    /// <returns>
    /// A container with the deletion status.
    /// </returns>
    public static container deleteTaxRegistration(RecId taxRegistrationRecId)
    {
        TaxRegistration taxRegistration;
        boolean         success = false;
        str             errorMessage;
        int             infologLine;

        try
        {
            infologLine = Global::infologLine();
            delete_from taxRegistration
                where taxRegistration.RecId == taxRegistrationRecId;
            success = true;
        }
        catch (Exception::Error)
        {
            errorMessage = RetailTransactionServiceUtilities::getInfologMessages(infologLine);
            eventSource.EventWriteCustomerGenericMessage('RetailTransactionService', funcName(), errorMessage);
        }

        return [success, errorMessage, ''];
    }

]]></Source>
			</Method>
			<Method>
				<Name>upsertCustomerContacts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Upsert customer contacts.
    /// </summary>
    /// <param name = "_custTableRecId">
    /// The RecId of CustTable.
    /// </param>
    /// <param name = "_serializedContacts">
    /// The serialized list of <c>ContactInfo</c> in JSON format.
    /// </param>
    /// <returns>
    /// The serialized list of updated <c>ContactInfo</c> in JSON format.
    /// </returns>
    public static container upsertCustomerContacts(RecId _custTableRecId, str _serializedContacts)
    {
        str                             error;
        str                             serializedUpdatedContacts;
        boolean                         validUpdate    = false;
        int                             fromLine;
        LogisticsLocationId             logisticsLocationId;
        LogisticsElectronicAddress      electronicAddress;
        DirPartyLocation                dirPartyLocation;
        CustTable                       custTable;
        LogisticsLocationRecId          logisticsLocationRecId;
        System.Collections.ArrayList    contacts;
        System.Collections.IEnumerator  contactEnumerator;
        guid                            correlationId = newGuid();

        eventSource.EventWriteCustomerUpsertContactsStart(correlationId, _custTableRecId);

        // Deserialize input contacts from JSON.
        try
        {
            contacts = RetailTransactionServiceJsonHelper::DeserializeContactsFromJSON(_serializedContacts);
        }
        catch (Exception::CLRError)
        {
            eventSource.EventWriteCustomerUpsertContactsDeserializeJsonFailed(correlationId);
            error = "@Retail:ContactInfoDeserializationError";
            return [false, error];
        }

        // Upsert customer contacts.
        try
        {
            ttsbegin;

            custTable = CustTable::findRecId(_custTableRecId);
            if (!custTable)
            {
                eventSource.EventWriteCustomerUpsertContactsCustomerNotFound(_custTableRecId, correlationId);
                error = "@Retail:InvalidCustomerRecId";
                throw Exception::Error;
            }

            dirPartyLocation = DirPartyLocation::findOrCreate(custTable.Party, 0, false);
            logisticsLocationRecId = dirPartyLocation.Location;
            logisticsLocationId = LogisticsLocation::find(logisticsLocationRecId).LocationId;

            // Iterate each contact in the JSON,
            // if RecordId is not present, a new contact will be created for the customer;
            // otherwise, the existing contact will be updated.
            contactEnumerator = contacts.GetEnumerator();
            while (contactEnumerator.MoveNext())
            {
                CrtDataModel.ContactInfo contactInfo = contactEnumerator.get_Current();
                electronicAddress.clear();

                // Update existing contact.
                if (contactInfo.RecordId != 0)
                {
                    eventSource.EventWriteCustomerUpsertContactsUpdateContactStart(correlationId);
                    electronicAddress = LogisticsElectronicAddress::findRecId(contactInfo.RecordId, true);

                    if (!electronicAddress)
                    {
                        eventSource.EventWriteCustomerUpsertContactsLogisticsElectronicAddressNotFound(contactInfo.RecordId, correlationId);
                        error = "@Retail:InvalidCustomerContactRecId";
                        throw Exception::Error;
                    }

                    electronicAddress.IsPrimary = contactInfo.IsPrimary;
                    electronicAddress.Locator = contactInfo.Value;
                    electronicAddress.LocatorExtension = contactInfo.ValueExtension;
                    electronicAddress.RetailMarketingOptIn = contactInfo.IsOptedInMarketing;
                    electronicAddress.IsPrivate = contactInfo.IsPrivate;
                    electronicAddress.IsMobilePhone = contactInfo.IsMobilePhone;
                    electronicAddress.update();
                }
                else // Insert the contact if it does not exist.
                {
                    eventSource.EventWriteCustomerUpsertContactsCreateContactStart(correlationId);

                    electronicAddress.initValue();
                    electronicAddress.IsPrimary = contactInfo.IsPrimary;
                    electronicAddress.Locator = contactInfo.Value;
                    electronicAddress.LocatorExtension = contactInfo.ValueExtension;
                    electronicAddress.RetailMarketingOptIn = contactInfo.IsOptedInMarketing;
                    electronicAddress.Type = contactInfo.AddressType;
                    electronicAddress.IsPrivate = contactInfo.IsPrivate;
                    electronicAddress.Location = logisticsLocationRecId;
                    electronicAddress.IsMobilePhone = contactInfo.IsMobilePhone;
                    electronicAddress.insert();
                }

                // Save the default role when there are no existing location roles.
                if (!electronicAddress.existLocationRoles())
                {
                    container defaultRole = map2Con(LogisticsLocationEntity::getDefaultLocationRoleFromEntity(tablenum(LogisticsElectronicAddress)));

                    eventSource.EventWriteLocationRoleIsNotSetForElectronicAddress(electronicAddress.RecId);

                    if (defaultRole != conNull())
                    {
                        LogisticsEntityLocationRoleMap::createEntityLocationRoles(tableNum(LogisticsElectronicAddressRole), electronicAddress.RecId, conPeek(defaultRole, 1), true);
                        unchecked(Uncheck::XDS)
                        {
                            electronicAddress.reread();
                        }

                        eventSource.EventWriteSetDefaultLocationRoleForCustomerElectronicsAddressIfNotSet(electronicAddress.RecId);
                    }
                    else
                    {
                        eventSource.EventWriteDefaultLocationRoleIsNull(electronicAddress.RecId);;
                    }
                }
                else
                {
                    eventSource.EventWriteLocationRoleHasAlreadySetForElectronicAddress(electronicAddress.RecId);
                }

                // Update contact entity, which will be sent back to RTS consumer.
                contactInfo.RecordId = electronicAddress.RecId;
                contactInfo.PartyLocationRecordId = dirPartyLocation.RecId;
                contactInfo.PartyRecordId = dirPartyLocation.Party;
                contactInfo.LogisticsLocationRecordId = logisticsLocationRecId;
                contactInfo.LogisticsLocationId = logisticsLocationId;
            }

            ttscommit;

            // Serialize updated contacts to JSON.
            System.Type[] typeArray = new System.Type[1]();
            System.Type contactInfoType = new CrtDataModel.ContactInfo().GetType();
            typeArray.SetValue(contactInfoType, 0);
            serializedUpdatedContacts = RetailTransactionServiceJsonHelper::SerializeToJson(contacts, typeArray);

            validUpdate = true;
        }
        catch (Exception::Error)
        {
            ttsabort;
            eventSource.EventWriteCustomerUpsertContactsFailed(correlationId);
            error += RetailTransactionServiceUtilities::getInfologMessages(fromLine);
        }

        eventSource.EventWriteCustomerUpsertContactsEnd(correlationId);

        return [validUpdate, error, serializedUpdatedContacts];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExistingCustomerAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the customer address based on the passed parameters.
    /// </summary>
    /// <param name="_street">The street address of the customer address.</param>
    /// <param name="_city">The city of the customer address</param>
    /// <param name="_state">The state of the customer address.</param>
    /// <param name="_zipcode">The zip code of the customer address.</param>
    /// <param name="_countryRegionId">The country or region of the customer address.</param>
    /// <param name="_streetNumber">The streetNumber of the customer address.</param>
    /// <param name="_county">County of the customer address.</param>
    /// <param name="_custAccount">The customer's account number for which this method finds the address.</param>
    /// <param name="_deliveryName">customer delivery name.</param>
    /// <param name="_buildingCompliment">Building compliment of the customer address.</param>
    /// <param name="_district">District of the customer address.</param>
    /// <param name="_isDefaultCustomer">Mark if customer is default customer of online channel.</param>
    /// <returns>The retrieved customer address.</returns>
    internal static LogisticsPostalAddress getExistingCustomerAddress(LogisticsAddressStreet _street,
                                                        LogisticsAddressCityName             _city,
                                                        LogisticsAddressStateId              _state,
                                                        LogisticsAddressZipCodeId            _zipcode,
                                                        LogisticsAddressCountryRegionId      _countryRegionId,
                                                        LogisticsAddressStreetNumber         _streetNumber,
                                                        AddressCountyId                      _county,
                                                        CustAccount                          _custAccount,
                                                        CustName                             _deliveryName,
                                                        LogisticsAddressBuildingCompliment   _buildingCompliment,
                                                        LogisticsAddressDistrictName         _district,
                                                        boolean                              _isDefaultCustomer = false)
    {
        LogisticsPostalAddress  logisticsPostalAddress;
        CustTable               custTable;
        LogisticsAddressing     logisticsAddressing;
        DirPartyLocation        dirPartyLocation;
        LogisticsLocation       logisticsLocation;

        custTable = CustTable::find(_custAccount);

        var addressStringBuilderParameters =
            new LogisticsPostalAddressStringBuilderParameters();

        addressStringBuilderParameters.parmStreet(_street);
        addressStringBuilderParameters.parmZipCodeId(_zipcode);
        addressStringBuilderParameters.parmCityName(_city);
        addressStringBuilderParameters.parmCountryRegionId(_countryRegionId);
        addressStringBuilderParameters.parmStateId(_state);
        addressStringBuilderParameters.parmCountyId(_county);
        addressStringBuilderParameters.parmStreetNumber(_streetNumber);
        addressStringBuilderParameters.parmBuildingCompliment(_buildingCompliment);
        addressStringBuilderParameters.parmDistrictName(_district);

        logisticsAddressing = LogisticsPostalAddressStringBuilder::buildAddressStringFromParameters(addressStringBuilderParameters);

        if (_isDefaultCustomer)
        {
            select firstOnly logisticsPostalAddress where logisticsPostalAddress.Address == logisticsAddressing
                exists join logisticsLocation where logisticsLocation.RecId == logisticsPostalAddress.Location && logisticsLocation.Description == _deliveryName;
        }
        else
        {
            select firstOnly logisticsPostalAddress where logisticsPostalAddress.Address == logisticsAddressing
                exists join dirPartyLocation where dirPartyLocation.Location == logisticsPostalAddress.Location
                exists join custTable where custTable.party == dirPartyLocation.Party && custTable.AccountNum == _custAccount
                exists join logisticsLocation where logisticsLocation.RecId == dirPartyLocation.Location && logisticsLocation.Description == _deliveryName;
        }

        return logisticsPostalAddress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendEmails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Send emails using the specified emailMessageCollectionXml.
    /// </summary>
    /// <param name="emailMessageCollectionXml">
    /// XML document containing the email messages contents, recipient email addresses, sender email addresses and
    /// the message properties, priority and batch group id.
    /// </param>
    /// <returns>A <c>Container</c> containing result info.</returns>
    public static container sendEmails(str emailMessageCollectionXml)
    {
        int fromLine;
        boolean success = true;
        str errorMsg = '';

        try
        {
            fromLine = Global::infologLine();

            SysEmailParameters emailParameters;
            select firstonly SMTPRelayServerName from emailParameters;

            // Do not send email if SMTP server is not configured.
            if (emailParameters.SMTPRelayServerName != '')
            {
                System.Collections.ArrayList  emailMessages = RetailTransactionServiceJsonHelper::DeserializeEmailMessagesFromJSON(emailMessageCollectionXml);
                SysEmailBatch batch = SysEmailBatch::construct();

                // Iterate over all email messages and send email message to each recipient address.
                int totalMessageCount =  emailMessages.Count;
                int messagesFailedToSend = 0;

                var emailEnumerator = emailMessages.GetEnumerator();
                while (emailEnumerator.MoveNext())
                {
                    CrtDataModel.EmailMessage emailMessage = emailEnumerator.get_Current();
                    if (RetailTransactionServiceCustomer::isValidEmailMessage(emailMessage))
                    {
                        // Prepare the batch object
                        batch.parmMessageBody(emailMessage.MessageBody);
                        batch.parmSenderAddr(emailMessage.SenderAddress);
                        batch.parmSendername(emailMessage.SenderName);
                        batch.parmSubject(emailMessage.Subject);
                        batch.parmPriority(emailMessage.PriorityTypeValue);

                        var recipientEnumerator = emailMessage.RecipientAddresses.GetEnumerator();
                        while (recipientEnumerator.MoveNext())
                        {
                            batch.parmEmailAddr(recipientEnumerator.Current);
                            if (emailMessage.BatchGroupId)
                            {
                                batch.sendToBatch(emailMessage.BatchGroupId);
                            }
                            else
                            {
                                batch.runOperation();
                            }
                        }
                    }
                    else
                    {
                        success = false;
                        messagesFailedToSend++;
                    }

                    if (messagesFailedToSend != 0)
                    {
                        errorMsg = strFmt("@Retail:FailedToSendEmailMessages", messagesFailedToSend, totalMessageCount);
                        eventSource.EventWriteCustomerSendEmailsEmailMessageIsNotValid(messagesFailedToSend, totalMessageCount);
                    }
                }
            }
            else
            {
                success = false;
                errorMsg = "@Retail:SMTPRelayServerNotConfigured";
                eventSource.EventWriteCustomerSendEmailsSMTPServerIsNotConfigured();
            }
        }
        catch (Exception::Error)
        {
            success = false;
            errorMsg = RetailUtilities::getInfologMessages(fromLine);
            str axCallStack = con2Str(xSession::xppCallStack()); // Use AX call stack for Exception::Error
            eventSource.EventWriteCustomerSendEmailsException(funcName(), axCallStack);
        }

        return [success, errorMsg];
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetLogisticsElectronicAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get Description and ElectronicAddressRoles properties for customer's logisticsElectronicAddress
    /// </summary>
    /// <param name ="logisticsElectronicAddressRecId">The LogisticsElectronicAdress record identifier.</param>
    /// <returns>A container with the contact description and roles.</returns>
    internal static container GetLogisticsElectronicAddress(int64 logisticsElectronicAddressRecId)
    {
        container roles = conNull();
        container paramAsCon;
        container returnValue;

        LogisticsElectronicAddress logisticsElectronicAddress = LogisticsElectronicAddress::findRecId(logisticsElectronicAddressRecId, false);

        paramAsCon = str2con(logisticsElectronicAddress.ElectronicAddressRoles, ";");

        LogisticsLocationRoleType logisticsLocationRoleType;

        for (int i=1; i<=conLen(paramAsCon); i++)
        {
            logisticsLocationRoleType = str2Enum(logisticsLocationRoleType, conPeek(paramAsCon, i));
            roles = conIns(roles , i , [LogisticsLocationRole::findBytype(logisticsLocationRoleType).RecId]);
        }

        returnValue = [logisticsElectronicAddress.Description, roles];

        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isValidEmailMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates 'EmailMessage'.
    /// </summary>
    /// <param name="emailMessage">
    /// The email message containing message body, sender address, sender name, subject and recipient email addresses.
    /// </param>
    /// <returns>A boolean value stating if the email message is valid.</returns>
    private static boolean isValidEmailMessage(CrtDataModel.EmailMessage emailMessage)
    {
        return emailMessage != null
            && (!System.String::isNullOrWhiteSpace(emailMessage.MessageBody)
            || !System.String::isNullOrWhiteSpace(emailMessage.SenderAddress))
            && !System.String::isNullOrWhiteSpace(emailMessage.SenderName)
            && !System.String::isNullOrWhiteSpace(emailMessage.Subject)
            && emailMessage.RecipientAddresses != null
            && emailMessage.RecipientAddresses.Count > 0;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>