<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustSettleJournalizingEntries</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>CustSettleJournalizingEntries</c> class manages the implementation of posting definitions on settlement process.
/// </summary>
class CustSettleJournalizingEntries
{
    Map                     settlementEntriesMap;
    Map                     custVendTransLedgerVoucher;
    Map                     custVendDiscTransMap;
    Map                     specTransMap;
    BankTransactionTypes    bankTransactionTypes;

    protected DataAreaId specCompany;
    protected TableId specTable;
    protected RecId specRecId;



}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addUnSpecifiedCashDiscEntries</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the unspecified cash discount transaction to the voucher.
    /// </summary>
    /// <param name="_ledgerVoucherObject">
    /// An instance of the <c>ledgerVoucherObject</c> class that will be used to add the entries to a
    /// voucher.
    /// </param>
    /// <param name="_custTransDebit">
    /// A <c>CustVendTrans</c> map of credit transactions to use.
    /// </param>
    /// <param name="_journalizingDefinitionEntriesList">
    /// A list on which voucher entries will be added.
    /// </param>
    protected void addUnSpecifiedCashDiscEntries(
        LedgerVoucherObject _ledgerVoucherObject,
        CustTrans           _custTransDebit,
        List                _journalizingDefinitionEntriesList)
    {
        LedgerVoucherTransList              ledgerVoucherTransList;
        LedgerVoucherTransObject            ledgerVoucherTransObject;
        Map                                 custBalanceMap;
        JournalizingDefinitionManagerBank   journalizingDefinitionManagerBank;
        JournalizingDefinitionEntry         journalizingDefinitionEntry;
        List                                systemGeneratedEntriesList;
        ListEnumerator                      systemGeneratedEntriesListEnumerator;
        Factor                              signFactor = 1;

        void addToList()
        {
            systemGeneratedEntriesListEnumerator = systemGeneratedEntriesList.getEnumerator();

            while (systemGeneratedEntriesListEnumerator.moveNext())
            {
                journalizingDefinitionEntry = systemGeneratedEntriesListEnumerator.current();
                signFactor = journalizingDefinitionEntry.parmJournalizingDefinitionDebitCredit() == DebitCredit::Debit ? 1: -1;
                journalizingDefinitionEntry.parmTransactionAmount(signFactor * ledgerVoucherTransObject.parmAmountCur());
                journalizingDefinitionEntry.parmAccountingAmount(signFactor * ledgerVoucherTransObject.parmAccountingCurrencyAmount());
                journalizingDefinitionEntry.parmReportingAmount(signFactor * ledgerVoucherTransObject.parmReportingCurrencyAmount());
                _journalizingDefinitionEntriesList.addEnd(journalizingDefinitionEntry);
            }
        }

        custBalanceMap = new Map(Types::Container, Types::Class);
        journalizingDefinitionManagerBank =  JournalizingDefinitionManager::newJournalizingDefinitionManagerBank(
                            _custTransDebit.CompanyBankAccountId,
                            _custTransDebit.PaymMode,
                            _custTransDebit.TransDate,
                            LedgerPostingType::Bank);

        journalizingDefinitionManagerBank.parmBankTransactionTypes(BankTransactionTypes::AccountsReceivableSettlement);
        journalizingDefinitionManagerBank.parmJournalizingDefinition(journalizingDefinitionManagerBank.getDefaultJournalizingDefinition());
        ledgerVoucherTransList = _ledgerVoucherObject.getInternalCollection();

        if (ledgerVoucherTransList.elements() > 0)
        {
            ledgerVoucherTransList.first();

            do
            {
                ledgerVoucherTransObject = ledgerVoucherTransList.item();
                if (ledgerVoucherTransObject.parmPostingType() == LedgerPostingType::CustCashDisc &&
                    this.isCredit(_custTransDebit, ledgerVoucherTransObject.parmAmountCur()))
                {
                    custBalanceMap.insert(ledgerVoucherTransObject.parmAmountCur(), ledgerVoucherTransObject);
                }
            }
            while (ledgerVoucherTransList.next());

            ledgerVoucherTransList.first();

            do
            {
                ledgerVoucherTransObject = ledgerVoucherTransList.item();

                if (ledgerVoucherTransObject.parmPostingType() == LedgerPostingType::CustBalance    &&
                    custBalanceMap.exists(-ledgerVoucherTransObject.parmAccountingCurrencyAmount()) &&
                    !this.isCredit(_custTransDebit, ledgerVoucherTransObject.parmAmountCur()))
                {
                    systemGeneratedEntriesList = journalizingDefinitionManagerBank.getSystemGeneratedEntries(DebitCredit::Debit, ledgerVoucherTransObject.parmLedgerDimensionId());
                    addToList();

                    ledgerVoucherTransObject = custBalanceMap.lookup(-ledgerVoucherTransObject.parmAccountingCurrencyAmount());
                    systemGeneratedEntriesList = journalizingDefinitionManagerBank.getSystemGeneratedEntries(DebitCredit::Debit, ledgerVoucherTransObject.parmLedgerDimensionId());
                    addToList();
                }
            }
            while (ledgerVoucherTransList.next());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createGeneratedEntries</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the generated entries by retrieving the accounts from the journalizing definition framework.
    /// </summary>
    /// <param name="_settleAmountCur">
    /// A settlement amount to use.
    /// </param>
    /// <param name="_custVendTransDebit">
    /// A <c>CustVendTrans</c> map of debit transactions to use.
    /// </param>
    /// <param name="_custVendTransCredit">
    /// A <c>CustVendTrans</c> map of credit transactions to use.
    /// </param>
    /// <param name="_custVendTransDebitOpenId">
    /// The record ID of a <c>CustTransOpen</c> table buffer to use.
    /// </param>
    /// <param name="_custSettlement">
    /// A <c>CustSettlement</c> table buffer to use.
    /// </param>
    /// <param name="_custVendTransCreditOpenId">
    /// The record ID of a <c>CustTransOpen</c> table buffer to use.
    /// </param>
    public void createGeneratedEntries(
        AmountCur           _settleAmountCur,
        CustVendTrans       _custVendTransDebit,
        CustVendTrans       _custVendTransCredit,
        RefRecId            _custVendTransDebitOpenId,
        CustSettlement      _custSettlement = null,
        RefRecId            _custVendTransCreditOpenId = 0)
    {
        JournalizingDefinitionManagerBank   journalizingDefinitionManagerBank;
        CustTrans                           custTransLocal, custTransPaym;
        ListEnumerator                      originatingEntriesListEnumerator;
        JournalizingDefinitionEntry         originatingJournalizingDefinitionEntry, generatedJournalizingDefinitionEntry;
        List                                systemGeneratedEntriesList;
        ListEnumerator                      systemGeneratedEntriesListEnumerator;
        List                                originatingEntriesList, settlementEntriesList;
        DimensionDefault                    originatingDefaultDimension;

        settlementEntriesList = new List(Types::Class);

        if (!_custVendTransDebitOpenId)
        {
            if (_custVendTransDebit.TableId == tableNum(CustTrans))
            {
                _custVendTransDebitOpenId = CustTransOpen::findRefId(_custVendTransDebit.RecId).RecId;
            }
            else
            {
                _custVendTransDebitOpenId = VendTransOpen::findRefId(_custVendTransDebit.RecId).RecId;
            }
        }

        if (!_custVendTransCreditOpenId)
        {
            if (_custVendTransCredit.TableId == tableNum(CustTrans))
            {
                _custVendTransCreditOpenId = CustTransOpen::findRefId(_custVendTransCredit.RecId).RecId;
            }
            else
            {
                _custVendTransCreditOpenId = VendTransOpen::findRefId(_custVendTransCredit.RecId).RecId;
            }
        }

        originatingEntriesList = this.getOriginatingEntries(
            _settleAmountCur,
            _custSettlement.SettleAmountMST,
            _custSettlement.SettleAmountReporting,
            _custVendTransDebit,
            _custVendTransCredit,
            _custVendTransDebitOpenId,
            _custVendTransCreditOpenId,
            _custSettlement);

        custTransPaym = _custVendTransDebit;

        if (_custVendTransDebit.TransType == LedgerTransType::Cust  &&
            _custVendTransDebit.TransType == LedgerTransType::Cust &&
            custTransPaym.PaymMethod == NetCurrent::COD)
        {
            journalizingDefinitionManagerBank =  JournalizingDefinitionManager::newJournalizingDefinitionManagerBank(
                                            _custVendTransDebit.CompanyBankAccountId,
                                            _custVendTransDebit.PaymMode,
                                            _custVendTransDebit.TransDate,
                                            LedgerPostingType::Bank);
        }
        else
        {
            journalizingDefinitionManagerBank =  JournalizingDefinitionManager::newJournalizingDefinitionManagerBank(
                                            _custVendTransCredit.CompanyBankAccountId,
                                            _custVendTransCredit.PaymMode,
                                            _custVendTransCredit.TransDate,
                                            LedgerPostingType::Bank);
        }

        journalizingDefinitionManagerBank.parmBankTransactionTypes(bankTransactionTypes);
        journalizingDefinitionManagerBank.parmJournalizingDefinition(journalizingDefinitionManagerBank.getDefaultJournalizingDefinition());

        originatingEntriesListEnumerator = originatingEntriesList.getEnumerator();

        while (originatingEntriesListEnumerator.moveNext())
        {
            originatingJournalizingDefinitionEntry = originatingEntriesListEnumerator.current();
            systemGeneratedEntriesList = journalizingDefinitionManagerBank.getSystemGeneratedEntries(DebitCredit::Debit, originatingJournalizingDefinitionEntry.parmLedgerDimension());
            systemGeneratedEntriesListEnumerator = systemGeneratedEntriesList.getEnumerator();

            while (systemGeneratedEntriesListEnumerator.moveNext())
            {
                generatedJournalizingDefinitionEntry = systemGeneratedEntriesListEnumerator.current();
                generatedJournalizingDefinitionEntry.parmTransactionAmount(generatedJournalizingDefinitionEntry.parmJournalizingDefinitionDebitCredit() == DebitCredit::Credit ? originatingJournalizingDefinitionEntry.parmTransactionAmount() : -1 * originatingJournalizingDefinitionEntry.parmTransactionAmount());
                generatedJournalizingDefinitionEntry.parmAccountingAmount(generatedJournalizingDefinitionEntry.parmJournalizingDefinitionDebitCredit() == DebitCredit::Credit ? originatingJournalizingDefinitionEntry.parmAccountingAmount() : -1 * originatingJournalizingDefinitionEntry.parmAccountingAmount());
                generatedJournalizingDefinitionEntry.parmReportingAmount(generatedJournalizingDefinitionEntry.parmJournalizingDefinitionDebitCredit() == DebitCredit::Credit ? originatingJournalizingDefinitionEntry.parmReportingAmount() : -1 * originatingJournalizingDefinitionEntry.parmReportingAmount());
                generatedJournalizingDefinitionEntry.parmLedgerPostingType(LedgerPostingType::CustSettlement);
                settlementEntriesList.addEnd(generatedJournalizingDefinitionEntry);
            }
            //Posting addtional interest originating entries
            if (this.validateForPostingAdditionalInterestOriginatingEntries(_custVendTransDebit, _custVendTransCredit))
            {
                originatingJournalizingDefinitionEntry.parmTransactionAmount(-1 * originatingJournalizingDefinitionEntry.parmTransactionAmount());
                originatingJournalizingDefinitionEntry.parmAccountingAmount(-1 * originatingJournalizingDefinitionEntry.parmAccountingAmount());
                originatingJournalizingDefinitionEntry.parmReportingAmount(-1 * originatingJournalizingDefinitionEntry.parmReportingAmount());
                settlementEntriesList.addEnd(originatingJournalizingDefinitionEntry);
            }
        }

        if ( _custVendTransCredit.TableId == tableNum(CustTrans)            &&
            (_custVendTransCredit.TransType == LedgerTransType::Cust        ||
             _custVendTransCredit.TransType == LedgerTransType::Payment     ||
             _custVendTransCredit.TransType == LedgerTransType::None)       &&
             custTransPaym.PaymMethod != NetCurrent::COD)
        {
            originatingEntriesList = this.getOriginatingEntries(-_settleAmountCur, -_custSettlement.SettleAmountMST, -_custSettlement.SettleAmountReporting, _custVendTransCredit, _custVendTransDebit, _custVendTransDebitOpenId, _custVendTransCreditOpenId);

            journalizingDefinitionManagerBank =
                JournalizingDefinitionManager::newJournalizingDefinitionManagerBank(
                    _custVendTransCredit.CompanyBankAccountId,
                    _custVendTransCredit.PaymMode,
                    _custVendTransCredit.TransDate,
                    LedgerPostingType::Bank);

            journalizingDefinitionManagerBank.parmBankTransactionTypes(BankTransactionTypes::AccountsReceivableSettlement);

            journalizingDefinitionManagerBank.parmJournalizingDefinition(journalizingDefinitionManagerBank.getDefaultJournalizingDefinition());

            originatingEntriesListEnumerator = originatingEntriesList.getEnumerator();

            while (originatingEntriesListEnumerator.moveNext())
            {
                originatingJournalizingDefinitionEntry = originatingEntriesListEnumerator.current();

                systemGeneratedEntriesList = journalizingDefinitionManagerBank.getSystemGeneratedEntries(DebitCredit::Credit, originatingJournalizingDefinitionEntry.parmLedgerDimension());

                systemGeneratedEntriesListEnumerator = systemGeneratedEntriesList.getEnumerator();

                while (systemGeneratedEntriesListEnumerator.moveNext())
                {
                    generatedJournalizingDefinitionEntry = systemGeneratedEntriesListEnumerator.current();
                    generatedJournalizingDefinitionEntry.parmTransactionAmount(generatedJournalizingDefinitionEntry.parmJournalizingDefinitionDebitCredit() == DebitCredit::Debit ? originatingJournalizingDefinitionEntry.parmTransactionAmount() : -1 * originatingJournalizingDefinitionEntry.parmTransactionAmount());
                    generatedJournalizingDefinitionEntry.parmAccountingAmount(generatedJournalizingDefinitionEntry.parmJournalizingDefinitionDebitCredit() == DebitCredit::Debit ? originatingJournalizingDefinitionEntry.parmAccountingAmount() : -1 * originatingJournalizingDefinitionEntry.parmAccountingAmount());
                    generatedJournalizingDefinitionEntry.parmReportingAmount(generatedJournalizingDefinitionEntry.parmJournalizingDefinitionDebitCredit() == DebitCredit::Debit ? originatingJournalizingDefinitionEntry.parmReportingAmount() : -1 * originatingJournalizingDefinitionEntry.parmReportingAmount());
                    generatedJournalizingDefinitionEntry.parmLedgerPostingType(LedgerPostingType::CustSettlement);
                    settlementEntriesList.addEnd(generatedJournalizingDefinitionEntry);
                }
            }
        }

        //Posting posting profile summary account additonal entries
        if (this.validateForPostingProfileSummaryAccountAdditionalEntries(_custVendTransDebit, _custVendTransCredit))
        {
            custTransLocal = this.creditOrDebitByCustVendTrans(_custVendTransDebit,_custVendTransCredit);

            originatingDefaultDimension = custTransLocal.DefaultDimension;
                        
            originatingEntriesListEnumerator = this.getProfileOriginatingEntriesList(custTransLocal, _settleAmountCur,_custSettlement.SettleAmountMST, _custSettlement.SettleAmountReporting, true, originatingDefaultDimension).getEnumerator();

            originatingEntriesListEnumerator.moveNext();
            settlementEntriesList.addEnd(originatingEntriesListEnumerator.current());
        }

        settlementEntriesMap.insert([_custVendTransDebit, _custVendTransDebitOpenId], settlementEntriesList.pack());
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditOrDebitByCustVendTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a <c>CustVendTrans</c> instance.
    /// </summary>
    /// <param name = "_custVendTransDebit">
    /// A <c>CustVendTrans</c> map of debit transactions to use.
    /// </param>
    /// <param name = "_custVendTransCredit">
    /// A <c>CustVendTrans</c> map of credit transactions to use.
    /// </param>
    /// <returns>
    /// A <c>CustVendTrans</c> instance selected from two different instances based on the transaction type.
    /// </returns>    
    protected CustVendTrans creditOrDebitByCustVendTrans(CustVendTrans _custVendTransDebit, CustVendTrans _custVendTransCredit)
    {
        if (_custVendTransDebit.TransType == LedgerTransType::Interest)
        {
            return _custVendTransDebit;
        }
        else
        {
            return _custVendTransCredit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>existGeneratedEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether generated entries exists by retrieving accounts from the journalizing definition framework.
    /// </summary>
    /// <param name="_settleAmountCur">
    /// The settlement amount to be used.
    /// </param>
    /// <param name="_settleAccountingAmount">
    /// An amount in accounting currency to be used.
    /// </param>
    /// <param name="_settleReportingAmount">
    /// An amount in reporting currency to be used.
    /// </param>
    /// <param name="_custVendTransDebit">
    /// The <c>CustVendTrans</c> map of debit transaction to be used.
    /// </param>
    /// <param name="_custVendTransCredit">
    /// The <c>CustVendTrans</c> map of credit transaction to be used.
    /// </param>
    /// <param name="_postEntries">
    /// A boolean that indicates whether to post the entries; optional.
    /// </param>
    /// <returns>
    /// true if exists otherwise, false.
    /// </returns>
    public boolean existGeneratedEntry(
        AmountCur       _settleAmountCur,
        AmountMST       _settleAccountingAmount,
        AmountMST       _settleReportingAmount,
        CustVendTrans   _custVendTransDebit,
        CustVendTrans   _custVendTransCredit,
        boolean         _postEntries = false)
    {
        JournalizingDefinitionManagerBank   journalizingDefinitionManagerBank;
        List                                originatingEntriesList, settlementEntriesList, systemGeneratedEntriesList;
        ListEnumerator                      originatingEntriesListEnumerator, systemGeneratedEntriesListEnumerator;
        JournalizingDefinitionEntry         originatingJournalizingDefinitionEntry, generatedJournalizingDefinitionEntry;
        boolean                             genereatedEntriesExists;
        CustVendTransOpen                   custVendTransOpenDebit;
        RefRecId                            custVendTransCreditOpenId;

        settlementEntriesList = new List(Types::Class);

        if (_custVendTransDebit.TableId == tableNum(CustTrans))
        {
            custVendTransOpenDebit = CustTransOpen::findRefId(_custVendTransDebit.RecId);
        }
        else
        {
            custVendTransOpenDebit = VendTransOpen::findRefId(_custVendTransDebit.RecId);
        }

        if (!custVendTransCreditOpenId)
        {
            if (_custVendTransCredit.TableId == tableNum(CustTrans))
            {
                custVendTransCreditOpenId = CustTransOpen::findRefId(_custVendTransCredit.RecId).RecId;
            }
            else
            {
                custVendTransCreditOpenId = VendTransOpen::findRefId(_custVendTransCredit.RecId).RecId;
            }
        }

        originatingEntriesList = this.getOriginatingEntries(_settleAmountCur, _settleAccountingAmount, _settleReportingAmount, _custVendTransDebit, _custVendTransCredit, custVendTransOpenDebit.RecId, custVendTransCreditOpenId);

        journalizingDefinitionManagerBank =  JournalizingDefinitionManager::newJournalizingDefinitionManagerBank(
                                        _custVendTransCredit.CompanyBankAccountId,
                                        _custVendTransCredit.PaymMode,
                                        _custVendTransCredit.TransDate,
                                        LedgerPostingType::Bank);

        if (_custVendTransDebit.TableId == tableNum(CustTrans))
        {
            bankTransactionTypes = BankTransactionTypes::AccountsReceivableSettlement;
        }
        else
        {
            bankTransactionTypes = !bankTransactionTypes ? BankTransactionTypes::Paymentjournal : bankTransactionTypes;
        }
        journalizingDefinitionManagerBank.parmBankTransactionTypes(bankTransactionTypes);

        journalizingDefinitionManagerBank.parmJournalizingDefinition(journalizingDefinitionManagerBank.getDefaultJournalizingDefinition());

        originatingEntriesListEnumerator = originatingEntriesList.getEnumerator();

        while (originatingEntriesListEnumerator.moveNext())
        {
            originatingJournalizingDefinitionEntry = originatingEntriesListEnumerator.current();

            systemGeneratedEntriesList = journalizingDefinitionManagerBank.getSystemGeneratedEntries(DebitCredit::Debit, originatingJournalizingDefinitionEntry.parmLedgerDimension());

            if (systemGeneratedEntriesList.elements() > 0 && !_postEntries)
            {
                genereatedEntriesExists = true;
                break;
            }

            systemGeneratedEntriesListEnumerator = systemGeneratedEntriesList.getEnumerator();

            while (systemGeneratedEntriesListEnumerator.moveNext())
            {
                generatedJournalizingDefinitionEntry = systemGeneratedEntriesListEnumerator.current();
                generatedJournalizingDefinitionEntry.parmTransactionAmount(generatedJournalizingDefinitionEntry.parmJournalizingDefinitionDebitCredit() == DebitCredit::Debit ? originatingJournalizingDefinitionEntry.parmTransactionAmount() : -1 * originatingJournalizingDefinitionEntry.parmTransactionAmount());
                generatedJournalizingDefinitionEntry.parmAccountingAmount(generatedJournalizingDefinitionEntry.parmJournalizingDefinitionDebitCredit() == DebitCredit::Debit ? originatingJournalizingDefinitionEntry.parmAccountingAmount() : -1 * originatingJournalizingDefinitionEntry.parmAccountingAmount());
                generatedJournalizingDefinitionEntry.parmReportingAmount(generatedJournalizingDefinitionEntry.parmJournalizingDefinitionDebitCredit() == DebitCredit::Debit ? originatingJournalizingDefinitionEntry.parmReportingAmount() : -1 * originatingJournalizingDefinitionEntry.parmReportingAmount());
                generatedJournalizingDefinitionEntry.parmLedgerPostingType(LedgerPostingType::CustSettlement);
                settlementEntriesList.addEnd(generatedJournalizingDefinitionEntry);
            }

            settlementEntriesMap.insert([_custVendTransDebit, custVendTransOpenDebit.RecId], settlementEntriesList.pack());
        }

        return genereatedEntriesExists;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDistributedAmountProrated</Name>
				<Source><![CDATA[
    private AmountMST getDistributedAmountProrated(AmountMST _settleAmount, AmountMST _distTransactionAmount, AmountMST _totalAmount)
    {
        if (_totalAmount == 0)
            return 0;

        return ( _distTransactionAmount/_totalAmount * _settleAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInterestLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the ledger dimension that is associated with a <c>CustInterestVersionDetail</c> record.
    /// </summary>
    /// <param name="_amount">
    /// An interest amount.
    /// </param>
    /// <param name="_custInterest">
    /// A <c>CustInterest</c> buffer that is used for interest calculation.
    /// </param>
    /// <param name="_calcInterestFrom">
    /// A date from which interest is calculated.
    /// </param>
    /// <param name="_transDate">
    /// A transaction date that forms the basis of an interest note.
    /// </param>
    /// <param name="_ledgerPostingType">
    /// A posting type to use; optional.
    /// </param>
    /// <param name="_custInterestJour">
    /// A <c>CustInterestJour</c> buffer that is used for interest calculation; optional.
    /// </param>
    /// <returns>
    /// The ledger dimension.
    /// </returns>
    protected LedgerDimensionDefaultAccount getInterestLedgerDimension(
        Amount              _amount,
        CustInterest        _custInterest,
        TransDate           _calcInterestFrom,
        TransDate           _transDate,
        LedgerPostingType   _ledgerPostingType = LedgerPostingType::CustInterest,
        CustInterestJour    _custInterestJour = null)
    {
        CustInterestVersion         custInterestVersion;
        CustInterestVersionDetail   custInterestVersionDetail;
        LedgerDimensionAccount      ledgerDimensionAccount;
        CustInterestFee             custInterestFee;

        if (_ledgerPostingType == LedgerPostingType::CustInterest)
        {
            if (_custInterest.CustInterestType == CustInterestType::MultipleRate)
            {
                custInterestVersion = CustInterestVersion::findByDate(_custInterest.RecId, _calcInterestFrom);
            }
            else
            {
                custInterestVersion = CustInterestVersion::findByDate(_custInterest.RecId, _transDate);
            }

            if (_amount > 0)
            {
                custInterestVersionDetail = CustInterestVersionDetail::findByFeeType(custInterestVersion.RecId,
                                                                                        CustInterestFeeType::Earning);
            }
            else
            {
                custInterestVersionDetail = CustInterestVersionDetail::findByFeeType(custInterestVersion.RecId,
                                                                                        CustInterestFeeType::Payment);
            }

            ledgerDimensionAccount = custInterestVersionDetail.LedgerDimension;
        }

        if (_ledgerPostingType == LedgerPostingType::CustInterestFee)
        {
            custInterestVersion = CustInterestVersion::findByDate(_custInterest.RecId,
                                                                    _custInterestJour.ToDate);

            custInterestVersionDetail = CustInterestVersionDetail::findByFeeType(custInterestVersion.RecId,
                                                                                    CustInterestFeeType::Earning);

            custInterestFee = CustInterestFee::findByCustInterestVersionDetail(custInterestVersionDetail.RecId,
                                                                                _custInterestJour.CurrencyCode);
            ledgerDimensionAccount = custInterestFee.FeeLedgerDimension;
        }

        return ledgerDimensionAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInterestOriginatingEntries</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the originating entries for the interest note.
    /// </summary>
    /// <param name="_custTrans">
    /// A <c>CustTrans</c> record to use.
    /// </param>
    /// <param name="_settleAmountCur">
    /// A settlement amount to use.
    /// </param>
    /// <param name="_custSettlement">
    /// A <c>CustSettlement</c> table buffer to use.
    /// </param>
    /// <returns>
    /// The list of originating entries.
    /// </returns>
    [Wrappable(true)]
    protected final List getInterestOriginatingEntries(
        CustTrans       _custTrans,
        AmountCur       _settleAmountCur,
        CustSettlement  _custSettlement = null)
    {
        boolean                                 recordFound;
        AccountingDistribution                  accountingDistribution;
        CustInterestTrans                       custInterestTrans;
        CustInterestTransLine                   custInterestTransLine;
        NumberOfRecords                         numOFdistributons;
        CustInvoiceLine                         custInvoiceLine;
        BillingClassificationRefRecId           billingClassificationRecId;
        LedgerDimensionAccount                  mergedLedgerDimension;
        SubledgerVoucherGeneralJournalEntry     subledgerVoucherGeneralJournalEntry;
        GeneralJournalEntry                     generalJournalEntry;
        GeneralJournalAccountEntry              generalJournalAccountEntry;
        CustInterestJour                        custInterestJour;
        AmountCur                               postedtransactionAmountSum;
        AmountCur                               postingAmount, transactionAmountToBePosted;
        List                                    originatingEntriesList, localOriginatingEntries;
        ListEnumerator                          localOriginatingEntriesEnumerator;
        JournalizingDefinitionEntry             journalizingDefinitionEntry, localJournalizingDefinitionEntry;
        DebitCredit                             accountType;
        CustTransOpen                           custTransOpen;
        CustTransOpenLine                       custTransOpenLine;
        CustSettlementLine                      custSettlementLine;
        RefRecId                                totalVoucherEntries;
        Counter                                 counter;
        Money                                   transactionAccountingAmount, reportingAmount;

        void addOriginatingAccount(LedgerDimensionAccount _ledgerDimension, AmountCur _postingAmount, Money _transactionAccountingAmount, Money _reportingAmount, LedgerPostingType _postingType = LedgerPostingType::CustInterest)
        {
            journalizingDefinitionEntry = new JournalizingDefinitionEntry();

            accountType = _postingAmount > 0 ? DebitCredit::Debit : DebitCredit::Credit;

            journalizingDefinitionEntry.parmJournalizingDefinitionDebitCredit(accountType);
            journalizingDefinitionEntry.parmLedgerDimension(_ledgerDimension);
            journalizingDefinitionEntry.parmLedgerPostingType(_postingType);
            journalizingDefinitionEntry.parmTransactionAmount(_postingAmount);
            journalizingDefinitionEntry.parmReportingAmount(_reportingAmount);
            journalizingDefinitionEntry.parmAccountingAmount(_transactionAccountingAmount);

            if (_postingType != LedgerPostingType::None)
            {
                originatingEntriesList.addEnd(journalizingDefinitionEntry);
            }
        }

        void getOriginatingAccounts()
        {
            custInvoiceLine = CustInvoiceLine::findByCustnterestTransLineIdRef(custInterestTransLine.CustInterestTransLineIdRef);
            numOFdistributons = AccountingDistribution::numOFDistrubitionsBySDL(custInvoiceLine.SourceDocumentLine);
            billingClassificationRecId = CustBillingClassification::findByCustInvoiceLine(custInvoiceLine.RecId).RecId;

            if (CustTrans::find(custInterestTrans.CustTransId).TransType == LedgerTransType::Cust)
            {
                while select AllocationFactor, TransactionCurrencyAmount, LedgerDimension from accountingDistribution
                    where accountingDistribution.SourceDocumentLine == custInvoiceLine.SourceDocumentLine
                {
                    //Merging interest code ledger dimension with the default dimension of the invoice line
                    mergedLedgerDimension = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(
                            this.getInterestLedgerDimension(custInterestTransLine.InterestAmount, CustInterest::find(custInterestTransLine.CustInterest), custInterestTransLine.CalcFrom,
                                                custInterestTrans.TransDate),
                            accountingDistribution.LedgerDimension);

                    postingAmount = CurrencyExchange::round(((custInterestTransLine.InterestAmount / custInterestTrans.InterestAmount) * custTransOpenLine.AmountCur) * accountingDistribution.AllocationFactor, _custTrans.CurrencyCode);
                    localOriginatingEntries = this.getIntOrigEntriesFromJournalizingDef(mergedLedgerDimension, postingAmount, custInterestTrans.TransDate, LedgerPostingType::CustInterest,
                                                            custInterestTransLine.CustBillingCode, billingClassificationRecId);

                    localOriginatingEntriesEnumerator = localOriginatingEntries.getEnumerator();

                    while (localOriginatingEntriesEnumerator.moveNext())
                    {
                        localJournalizingDefinitionEntry = localOriginatingEntriesEnumerator.current();
                        originatingEntriesList.addEnd(localJournalizingDefinitionEntry);
                    }
                }
            }
            else
            {
                custInterestJour = CustInterestJour::find(custInterestTrans.InterestNote);
                mergedLedgerDimension = CustLedgerAccounts::summaryLedgerDimension(custInterestJour.AccountNum,
                                                    CustParameters::find().PostingProfile);

                mergedLedgerDimension =  LedgerDimensionFacade::serviceCreateLedgerDimension(mergedLedgerDimension, custInterestJour.DefaultDimension);

                localOriginatingEntries = this.getIntOrigEntriesFromJournalizingDef(mergedLedgerDimension, _custSettlement.RecId ? custSettlementLine.SettledAmountCur: custTransOpenLine.AmountCur, custInterestTrans.TransDate, LedgerPostingType::CustInterest,
                                                            custInterestTransLine.CustBillingCode, billingClassificationRecId);

                localOriginatingEntriesEnumerator = localOriginatingEntries.getEnumerator();

                while (localOriginatingEntriesEnumerator.moveNext())
                {
                    localJournalizingDefinitionEntry = localOriginatingEntriesEnumerator.current();
                    originatingEntriesList.addEnd(localJournalizingDefinitionEntry);
                }
            }

            recordFound = true;
        }

        originatingEntriesList = new List(Types::Class);

        if (LedgerParameters::find().JournalizingDefinitionEnableValue == NoYes::Yes)
        {
            if (_custSettlement.RecId)
            {
                while select InterestAmount, CustBillingCode, CustInterestTransLineIdRef, CustInterest, CalcFrom  from custInterestTransLine
                    join CustTransId, TransDate, InterestAmount, InterestNote from custInterestTrans
                        where custInterestTrans.RecId == custInterestTransLine.CustInterestTrans
                        join SettledAmountCur from custSettlementLine
                            where custSettlementLine.CustInvoiceLineIdRef == custInterestTrans.CustInvoiceLineIdRef &&
                                    custSettlementLine.CustSettlement == _custSettlement.RecId
                {
                    getOriginatingAccounts();
                }
            }
            else
            {
                select firstonly RecId from custTransOpen
                    where custTransOpen.RefRecId == _custTrans.RecId;

                while select InterestAmount, CustBillingCode, CustInterestTransLineIdRef, CustInterest, CalcFrom  from custInterestTransLine
                    join CustTransId, TransDate, InterestAmount, InterestNote from custInterestTrans
                        where custInterestTrans.RecId == custInterestTransLine.CustInterestTrans
                    join AmountCur from custTransOpenLine
                        where custTransOpenLine.CustInvoiceLineIdRef == custInterestTrans.CustInvoiceLineIdRef &&
                                custTransOpenLine.CustTransOpen == custTransOpen.RecId
                {
                    getOriginatingAccounts();
                }
            }
            if (! recordFound)
            {
                while select generalJournalAccountEntry
                    where generalJournalAccountEntry.PostingType == LedgerPostingType::CustBalance
                    exists join generalJournalEntry
                        where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                    exists join subledgerVoucherGeneralJournalEntry
                        where
                            subledgerVoucherGeneralJournalEntry.Voucher == _custTrans.Voucher &&
                            subledgerVoucherGeneralJournalEntry.AccountingDate == _custTrans.TransDate &&
                            subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == _custTrans.DataAreaId &&
                            subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalAccountEntry.GeneralJournalEntry
                {
                    counter++;
                    [postedtransactionAmountSum, totalVoucherEntries] = GeneralJournalAccountEntry::sumOfPostedAmountByGJE(generalJournalAccountEntry.GeneralJournalEntry);

                    postingAmount = CurrencyExchange::round(((_settleAmountCur / postedtransactionAmountSum) * generalJournalAccountEntry.TransactionCurrencyAmount), _custTrans.CurrencyCode);
                    transactionAccountingAmount = CurrencyExchange::round(((_settleAmountCur / postedtransactionAmountSum) * generalJournalAccountEntry.AccountingCurrencyAmount), _custTrans.CurrencyCode);
                    reportingAmount = CurrencyExchange::round(((_settleAmountCur / postedtransactionAmountSum) * generalJournalAccountEntry.ReportingCurrencyAmount), _custTrans.CurrencyCode);

                    transactionAmountToBePosted += postingAmount;

                    if (counter == totalVoucherEntries && _settleAmountCur != transactionAmountToBePosted)
                    {
                        postingAmount += _settleAmountCur - transactionAmountToBePosted;
                        transactionAccountingAmount += _settleAmountCur - transactionAmountToBePosted;
                        reportingAmount += _settleAmountCur - transactionAmountToBePosted;
                    }

                    addOriginatingAccount(generalJournalAccountEntry.LedgerDimension, postingAmount,  transactionAccountingAmount, reportingAmount, generalJournalAccountEntry.PostingType);
                }
            }
        }

        return originatingEntriesList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIntOrigEntriesFromJournalizingDef</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the originating entries for the interest note from the posting definition.
    /// </summary>
    /// <param name="_ledgerDimension">
    /// The ledger dimension that is associated with the interest transaction.
    /// </param>
    /// <param name="_settlementAmount">
    /// The amount to settle.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date.
    /// </param>
    /// <param name="_postingType">
    /// The posting type of the transaction.
    /// </param>
    /// <param name="_billingCodeRecId">
    /// The record ID of the billing code that is associated with the interest line; optional.
    /// </param>
    /// <param name="_billingClassRefRecId">
    /// The record ID of the billing class that is associated with the interest note; optional.
    /// </param>
    /// <returns>
    /// The list of the originating entries that is associated with the interest transaction; otherwise, an
    /// empty list.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The journalizing definition record could not be found based on the specified value of the <paramref
    /// name="_ledgerDimension" /> parameter.
    /// </exception>
    protected List getIntOrigEntriesFromJournalizingDef(
        LedgerDimensionAccount          _ledgerDimension,
        AmountCur                       _settlementAmount,
        TransDate                       _transDate,
        LedgerPostingType               _postingType,
        BillingCodeRefRecId             _billingCodeRecId = 0,
        BillingClassificationRefRecId   _billingClassRefRecId = 0)
    {
        JournalizingDefinitionManager   journalizingDefinitionManager =  JournalizingDefinitionManager::newJournalizingDefinitionManagerCustomer(_billingCodeRecId, _billingClassRefRecId, _transDate, _postingType);
        List                            journalizingDefinitionLedgerDimensions, orioginatingEntriesList;
        ListEnumerator                  journalizingDefListEnumerator;
        LedgerDimensionAccount          ledgerDimensionAccount;
        JournalizingDefinitionEntry     generatedOutput;
        JournalizingDefinitionId        journalizingDefinitionId;
        InterestAmountCur               interestAmountCur;
        JournalizingDefinitionEntry     journalizingDefinitionEntry;

        orioginatingEntriesList = new List(Types::Class);

        journalizingDefinitionManager.parmTransactionType(enum2int(_postingType));

        journalizingDefinitionId = journalizingDefinitionManager.getDefaultJournalizingDefinition();

        if (!journalizingDefinitionId)
        {
            throw error(strFmt("@SPS1133",journalizingDefinitionManager.parmTransactionType()));
        }

        journalizingDefinitionManager.parmJournalizingDefinition(journalizingDefinitionId);

        journalizingDefinitionLedgerDimensions = journalizingDefinitionManager.getSystemGeneratedEntries(DebitCredit::Debit, _ledgerDimension);

        if (journalizingDefinitionLedgerDimensions.elements() == 0)
        {
            throw error(strFmt("@SPS668", JournalizingDefinition::findByRecId(journalizingDefinitionId).JournalizingDefinitionCode));
        }

        journalizingDefListEnumerator = journalizingDefinitionLedgerDimensions.getEnumerator();

        //Posting the generated entries that found with the help of posting definition
        while (journalizingDefListEnumerator.moveNext())
        {
            generatedOutput = journalizingDefListEnumerator.current();

            if (generatedOutput.parmJournalizingDefinitionDebitCredit() == DebitCredit::Debit)
            {
                interestAmountCur = _settlementAmount * -1;
            }
            else
            {
                interestAmountCur = _settlementAmount;
            }

            ledgerDimensionAccount = generatedOutput.parmLedgerDimension();

            journalizingDefinitionEntry = new JournalizingDefinitionEntry();

            journalizingDefinitionEntry.parmJournalizingDefinitionDebitCredit(DebitCredit::Debit);
            journalizingDefinitionEntry.parmLedgerDimension(ledgerDimensionAccount);
            journalizingDefinitionEntry.parmLedgerPostingType(LedgerPostingType::CustSettlement);
            journalizingDefinitionEntry.parmTransactionAmount(interestAmountCur);

            orioginatingEntriesList.addEnd(journalizingDefinitionEntry);
        }

        return orioginatingEntriesList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceOriginatingEntries</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the originating entries for free text invoice.
    /// </summary>
    /// <param name="_custVendTrans">
    /// A <c>CustTrans</c> record to use.
    /// </param>
    /// <param name="_settleAmountCur">
    /// The settlement amount to use.
    /// </param>
    /// <param name="_settleAccountingAmount">
    /// An amount in accounting currency to use.
    /// </param>
    /// <param name="_settleReportingAmount">
    /// An amount in reporting currency to use.
    /// </param>
    /// <param name="_custVendTransOpenId">
    /// A record ID of the <c>CustVendTransOpen</c> table.
    /// </param>
    /// <returns>
    /// The list of originating entries.
    /// </returns>
    protected List getInvoiceOriginatingEntries(
        CustVendTrans       _custVendTrans,
        AmountCur           _settleAmountCur,
        AmountMst           _settleAccountingAmount,
        AmountMst           _settleReportingAmount,
        RefRecId            _custVendTransOpenId)
    {
        List                                systemGeneratedList, distributions;
        JournalizingDefinitionEntry         journalizingDefinitionEntry;
        boolean                             isSettleByLineEnabled;
        ListEnumerator                      distributionEnumerator;
        CustVendTransDistribution           distribution;
        LedgerDimensionAccount              ledgerDimensionMerged;
        CustVendTransSettleDistController   debitSettleDistController;
        SpecTrans                           debitSpecTrans;
        LedgerPostingType                   ledgerPostingType;

        systemGeneratedList = new List(Types::Class);
        ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(_custVendTrans.summaryLedgerDimension(), _custVendTrans.DefaultDimension);

        isSettleByLineEnabled = CustParameters::find().MarkOpenInvoiceLine;

        debitSettleDistController = CustVendTransSettleDistController::construct(isSettleByLineEnabled);

        if (_custVendTrans.TableId == tableNum(CustTrans))
        {
            debitSpecTrans = SpecTrans::find(
                specCompany,
                specTable,
                specRecId,
                _custVendTrans.company(),
                tableNum(CustTransOpen),
                _custVendTransOpenId);

            ledgerPostingType = LedgerPostingType::CustBalance;
        }
        else
        {
            debitSpecTrans = SpecTrans::find(
                specCompany,
                specTable,
                specRecId,
                _custVendTrans.company(),
                tableNum(VendTransOpen),
                _custVendTransOpenId);

            ledgerPostingType = LedgerPostingType::VendBalance;
        }

        debitSettleDistController.parmSpecTransId(debitSpecTrans.RecId);

        distributions = debitSettleDistController.generateDistributions(
            _custVendTrans,
            ledgerPostingType,
            _settleAmountCur,
            _settleAccountingAmount,
            _settleReportingAmount,
            ledgerDimensionMerged,
            false);

        distributionEnumerator = distributions.getEnumerator();
        while (distributionEnumerator.moveNext())
        {
            distribution = distributionEnumerator.current();
            journalizingDefinitionEntry = JournalizingDefinitionEntry::create([distribution.ledgerDimension(), DebitCredit::Debit, LedgerPostingType::CustBalance, distribution.transactionAmount(), distribution.accountingAmount(), distribution.reportingAmount()]);
            systemGeneratedList.addEnd(journalizingDefinitionEntry);
        }

        return systemGeneratedList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOriginatingEntries</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the originating entries.
    /// </summary>
    /// <param name="_settleAmountCur">
    /// A settlement amount to use.
    /// </param>
    /// <param name="_settleAccountingAmount">
    /// An amount in accounting currency to use.
    /// </param>
    /// <param name="_settleReportingAmount">
    /// An amount in reporting currency to use.
    /// </param>
    /// <param name="_custVendTransDebit">
    /// The <c>CustTrans</c> table buffer of debit transaction to use.
    /// </param>
    /// <param name="_custVendTransCredit">
    /// The <c>CustTrans</c> table buffer of credit transaction to use.
    /// </param>
    /// <param name="_custTransDebitOpenId">
    /// The record ID of <c>CustTransOpen</c> table buffer to use.
    /// </param>
    /// <param name="_custTransCreditOpenId">
    /// The record ID of <c>CustTransOpen</c> table buffer to use.
    /// </param>
    /// <param name="_custSettlement">
    /// The <c>CustSettlement</c> table buffer to use.
    /// </param>
    /// <returns>
    /// The list of originating entries.
    /// </returns>
    protected List getOriginatingEntries(
        AmountCur           _settleAmountCur,
        AmountMST           _settleAccountingAmount,
        AmountMST           _settleReportingAmount,
        CustVendTrans       _custVendTransDebit,
        CustVendTrans       _custVendTransCredit,
        RefRecId            _custTransDebitOpenId,
        RefRecId            _custTransCreditOpenId,
        CustSettlement      _custSettlement = null)
    {
        List            originatingEntriesList;
        CustVendTrans   originatingCustTrans;
        AmountCur       cashDiscAmountCur;
        Money           cashDiscAccountingAmount;
        Money           cashDiscReportingAmount;

        originatingCustTrans = _custVendTransDebit;

        if (custVendDiscTransMap.exists(_custTransDebitOpenId))
        {
            [cashDiscAmountCur, cashDiscAccountingAmount, cashDiscReportingAmount] = custVendDiscTransMap.lookup(_custTransDebitOpenId);
        }
        else if (custVendDiscTransMap.exists(_custTransCreditOpenId))
        {
            [cashDiscAmountCur, cashDiscAccountingAmount, cashDiscReportingAmount] = custVendDiscTransMap.lookup(_custTransCreditOpenId);
        }

        cashDiscAmountCur = _settleAmountCur > 0 ? cashDiscAmountCur: -cashDiscAmountCur;
        cashDiscAccountingAmount = _settleAmountCur > 0 ? cashDiscAccountingAmount: -cashDiscAccountingAmount;
        cashDiscReportingAmount = _settleAmountCur > 0 ? cashDiscReportingAmount: -cashDiscReportingAmount;

        _settleAmountCur = _settleAmountCur - cashDiscAmountCur;
        _settleAccountingAmount = _settleAccountingAmount - cashDiscAccountingAmount;
        _settleReportingAmount = _settleReportingAmount - cashDiscReportingAmount;

        originatingEntriesList = this.initializeOriginatingEntriesList(originatingCustTrans,
                                                                       _settleAmountCur,
                                                                       _settleAccountingAmount,
                                                                       _settleReportingAmount,
                                                                       _custTransDebitOpenId,
                                                                       _custSettlement);

        return originatingEntriesList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOriginatingEntryFromVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retreives the entries from the voucher, filtered by posting type.
    /// </summary>
    /// <param name="_custVendTrans">
    /// The <c>CustVendTrans</c> map to be used.
    /// </param>
    /// <param name="_settleAmountCur">
    /// The settlement amount in currency to be used.
    /// </param>
    /// <param name="_settleAccountingAmount">
    /// The settlement amount in accounting currency to be used.
    /// </param>
    /// <param name="_settleReportingAmount">
    /// The settlement amount in reporting currency to be used.
    /// </param>
    /// <returns>
    /// The list of entries from the voucher.
    /// </returns>
    protected List getOriginatingEntryFromVoucher(
        CustVendTrans   _custVendTrans,
        AmountCur       _settleAmountCur,
        Money           _settleAccountingAmount,
        Money           _settleReportingAmount)
    {
        SubledgerVoucherGeneralJournalEntry localSubledgerVoucherGeneralJournalEntry;
        GeneralJournalAccountEntry          localGeneralJournalAccountEntry;
        List                                originatingEntriesList;
        JournalizingDefinitionEntry         journalizingDefinitionEntry;
        LedgerPostingType                   ledgerPostingType;
        AmountCur                           remainingSettleAmountCur;
        Money                               remainingSettleAccountingAmount, remainingSettleReportingAmount;
        int64                               distributionCount = 0;

        remainingSettleAmountCur = abs(_settleAmountCur);
        remainingSettleAccountingAmount = abs(_settleAccountingAmount);
        remainingSettleReportingAmount = abs(_settleReportingAmount);

        originatingEntriesList = new List(Types::Class);

        if (_custVendTrans.TableId == tableNum(CustTrans))
        {
            ledgerPostingType = LedgerPostingType::CustBalance;
        }
        else
        {
            ledgerPostingType = LedgerPostingType::VendBalance;
        }

        select crossCompany count(RecId) from  localGeneralJournalAccountEntry
            where localGeneralJournalAccountEntry.PostingType == ledgerPostingType
                exists join  localSubledgerVoucherGeneralJournalEntry
                where localSubledgerVoucherGeneralJournalEntry.GeneralJournalEntry  == localGeneralJournalAccountEntry.GeneralJournalEntry  &&
                      localSubledgerVoucherGeneralJournalEntry.Voucher              == _custVendTrans.Voucher                               &&
                      localSubledgerVoucherGeneralJournalEntry.VoucherDataAreaId    == _custVendTrans.DataAreaId                            &&
                      localSubledgerVoucherGeneralJournalEntry.AccountingDate       == _custVendTrans.TransDate;

        distributionCount = localGeneralJournalAccountEntry.RecId;

        while select crossCompany LedgerDimension, AccountingCurrencyAmount, TransactionCurrencyAmount, ReportingCurrencyAmount
            from  localGeneralJournalAccountEntry
            where localGeneralJournalAccountEntry.PostingType == ledgerPostingType
                exists join  localSubledgerVoucherGeneralJournalEntry
                where localSubledgerVoucherGeneralJournalEntry.GeneralJournalEntry  == localGeneralJournalAccountEntry.GeneralJournalEntry  &&
                      localSubledgerVoucherGeneralJournalEntry.Voucher              == _custVendTrans.Voucher                               &&
                      localSubledgerVoucherGeneralJournalEntry.VoucherDataAreaId    == _custVendTrans.DataAreaId                            &&
                      localSubledgerVoucherGeneralJournalEntry.AccountingDate       == _custVendTrans.TransDate
        {
            distributionCount--;
            journalizingDefinitionEntry = new JournalizingDefinitionEntry();
            journalizingDefinitionEntry.parmLedgerDimension(localGeneralJournalAccountEntry.LedgerDimension);

            journalizingDefinitionEntry.parmTransactionAmount(this.getDistributedAmountProrated(_settleAmountCur, localGeneralJournalAccountEntry.TransactionCurrencyAmount, _custVendTrans.AmountCur));
            journalizingDefinitionEntry.parmAccountingAmount(this.getDistributedAmountProrated(_settleAccountingAmount,  localGeneralJournalAccountEntry.AccountingCurrencyAmount, _custVendTrans.AmountCur));
            journalizingDefinitionEntry.parmReportingAmount(this.getDistributedAmountProrated(_settleReportingAmount,  localGeneralJournalAccountEntry.ReportingCurrencyAmount, _custVendTrans.AmountCur));

            remainingSettleAmountCur = localGeneralJournalAccountEntry.TransactionCurrencyAmount == 0 ? 0 : remainingSettleAmountCur - abs(journalizingDefinitionEntry.parmTransactionAmount());
            remainingSettleAccountingAmount = localGeneralJournalAccountEntry.AccountingCurrencyAmount == 0 ? 0 : remainingSettleAccountingAmount - abs(journalizingDefinitionEntry.parmAccountingAmount());
            remainingSettleReportingAmount = localGeneralJournalAccountEntry.ReportingCurrencyAmount == 0 ? 0 : remainingSettleReportingAmount - abs(journalizingDefinitionEntry.parmReportingAmount());

            if (distributionCount == 0 && (remainingSettleAmountCur != 0 || remainingSettleAccountingAmount != 0 || remainingSettleReportingAmount != 0))
            {
                journalizingDefinitionEntry.parmTransactionAmount(journalizingDefinitionEntry.parmTransactionAmount() + remainingSettleAmountCur);
                journalizingDefinitionEntry.parmAccountingAmount(journalizingDefinitionEntry.parmAccountingAmount() + remainingSettleAccountingAmount);
                journalizingDefinitionEntry.parmReportingAmount(journalizingDefinitionEntry.parmReportingAmount() + remainingSettleReportingAmount);
            }

            journalizingDefinitionEntry.parmLedgerPostingType(ledgerPostingType);
            journalizingDefinitionEntry.parmJournalizingDefinitionDebitCredit(DebitCredit::Debit);
            originatingEntriesList.addEnd(journalizingDefinitionEntry);
        }

        return originatingEntriesList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProfileOrigEntriesListForUseTaxPaym</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the originating entries for payment journal bank accounts for use tax payment with
    /// distributions and dimensions.
    /// </summary>
    /// <param name="_vendTrans">
    /// The <c>VendTrans</c> record that will be used.
    /// </param>
    /// <param name="_settleAmountCur">
    /// The settlement amount that will be used.
    /// </param>
    /// <param name="_settleAccountingAmountMst">
    /// The settlement accounting amount that will be used.
    /// </param>
    /// <param name="_settleReportingAmountMst">
    /// The settlement reporting amount that will be used.
    /// </param>
    /// <returns>
    /// The list of originating entries.
    /// </returns>
    protected List getProfileOrigEntriesListForUseTaxPaym(
        VendTrans           _vendTrans,
        AmountCur           _settleAmountCur,
        Money               _settleAccountingAmountMst,
        Money               _settleReportingAmountMst)
    {
        List originatingEntriesList;
        JournalizingDefinitionEntry journalizingDefinitionEntry;
        LedgerDimensionAccount      originatingLedgerDimension;
        DimensionDefault            originatingDimension;
        DebitCredit                 debitCredit;
        LedgerJournalTrans          ledgerJournalTrans;

        originatingEntriesList = new List(Types::Class);
        journalizingDefinitionEntry = new JournalizingDefinitionEntry();

        select firstonly RecId, OffsetLedgerDimension from ledgerJournalTrans
            where ledgerJournalTrans.Voucher == _vendTrans.Voucher &&
            ledgerJournalTrans.TransDate == _vendTrans.TransDate;

        originatingLedgerDimension = BankAccountTable::find(LedgerDimensionFacade::getDisplayValueForLedgerDimension(ledgerJournalTrans.OffsetLedgerDimension)).LedgerDimension;

        debitCredit = _settleAmountCur > 0 ? DebitCredit::Debit : DebitCredit::Credit;

        originatingDimension = _vendTrans.DefaultDimension;

        journalizingDefinitionEntry.parmJournalizingDefinitionDebitCredit(DebitCredit::Debit);
        journalizingDefinitionEntry.parmLedgerDimension(LedgerDimensionFacade::serviceCreateLedgerDimension(originatingLedgerDimension, originatingDimension));
        journalizingDefinitionEntry.parmLedgerPostingType(LedgerPostingType::CustSettlement);
        journalizingDefinitionEntry.parmTransactionAmount(_settleAmountCur);
        journalizingDefinitionEntry.parmAccountingAmount(_settleAccountingAmountMst);
        journalizingDefinitionEntry.parmReportingAmount(_settleReportingAmountMst);

        originatingEntriesList.addEnd(journalizingDefinitionEntry);

        return originatingEntriesList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProfileOriginatingEntriesList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the originating entries for posting profile.
    /// </summary>
    /// <param name="_custTrans">
    /// A <c>CustTrans</c> table buffer to use.
    /// </param>
    /// <param name="_settleAmountCur">
    /// A settlement amount to use.
    /// </param>
    /// <param name="_settleAccountingAmountMst">
    /// A settlement accounting amount to use.
    /// </param>
    /// <param name="_settleReportingAmountMst">
    /// A settlement reporting amount to use.
    /// </param>
    /// <param name="_useCustTransPostingProfile">
    /// A Boolean value that indicates whether to use the posting profile of the <c>custTrans</c> record.
    /// </param>
    /// <param name="_originatingDimensionDefault">
    /// The dimension record ID that is associated with the customer transaction; optional.
    /// </param>
    /// <returns>
    /// The list of originating entries.
    /// </returns>
    protected List getProfileOriginatingEntriesList(
        CustTrans           _custTrans,
        AmountCur           _settleAmountCur,
        Money               _settleAccountingAmountMst,
        Money               _settleReportingAmountMst,
        boolean             _useCustTransPostingProfile = false,
        DimensionDefault    _originatingDimensionDefault = 0)
    {
        List originatingEntriesList;
        JournalizingDefinitionEntry journalizingDefinitionEntry;
        LedgerDimensionAccount      originatingLedgerDimension;
        DimensionDefault            originatingDimension;
        DebitCredit                 debitCredit;

        originatingEntriesList = new List(Types::Class);
        journalizingDefinitionEntry = new JournalizingDefinitionEntry();

        if (!_useCustTransPostingProfile)
        {
            originatingLedgerDimension = CustLedgerAccounts::summaryLedgerDimension(_custTrans.AccountNum);
        }
        else
        {
            originatingLedgerDimension = CustLedgerAccounts::summaryLedgerDimension(_custTrans.AccountNum, _custTrans.PostingProfile);
        }

        debitCredit = _settleAmountCur > 0 ? DebitCredit::Debit : DebitCredit::Credit;

        originatingDimension = CustTable::find(_custTrans.AccountNum).DefaultDimension;

        journalizingDefinitionEntry.parmJournalizingDefinitionDebitCredit(DebitCredit::Debit);
        journalizingDefinitionEntry.parmLedgerDimension(LedgerDimensionFacade::serviceCreateLedgerDimension(originatingLedgerDimension, _originatingDimensionDefault));
        journalizingDefinitionEntry.parmLedgerPostingType(LedgerPostingType::CustSettlement);
        journalizingDefinitionEntry.parmTransactionAmount(_settleAmountCur);
        journalizingDefinitionEntry.parmAccountingAmount(_settleAccountingAmountMst);
        journalizingDefinitionEntry.parmReportingAmount(_settleReportingAmountMst);

        originatingEntriesList.addEnd(journalizingDefinitionEntry);

        return originatingEntriesList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCredit</Name>
				<Source><![CDATA[
    private boolean isCredit(CustVendTrans _custVendTrans, AmountCur transactionAmount)
    {
        return  (_custVendTrans.AmountCur > 0 && transactionAmount < 0) ||
                (_custVendTrans.AmountCur < 0 && transactionAmount > 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        custVendTransLedgerVoucher = new Map(Types::Int64, Types::Class);
        settlementEntriesMap = new Map(Types::Container, Types::Container);
        custVendDiscTransMap = new Map(Types::Int64, Types::Container);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankTransactionTypes</Name>
				<Source><![CDATA[
    public BankTransactionTypes parmBankTransactionTypes(BankTransactionTypes _bankTransactionTypes = bankTransactionTypes)
    {
        bankTransactionTypes = _bankTransactionTypes;

        return bankTransactionTypes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustVendDiscTransMap</Name>
				<Source><![CDATA[
    public Map parmCustVendDiscTransMap(Map _custVendDiscTransMap = custVendDiscTransMap)
    {
        custVendDiscTransMap = _custVendDiscTransMap;

        return custVendDiscTransMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustVendTransLedgerVoucherMap</Name>
				<Source><![CDATA[
    public Map parmCustVendTransLedgerVoucherMap(Map _custVendTransLedgerVoucher = custVendTransLedgerVoucher)
    {
        custVendTransLedgerVoucher = _custVendTransLedgerVoucher;

        return custVendTransLedgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSettlementEntriesMap</Name>
				<Source><![CDATA[
    public Map parmSettlementEntriesMap(Map _settlementEntriesMap = settlementEntriesMap)
    {
        settlementEntriesMap = _settlementEntriesMap;

        return settlementEntriesMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parseVoucherEntries</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the unspecified cash discount transaction to the voucher.
    /// </summary>
    /// <param name="_ledgerVoucherObject">
    /// The object <c>ledgerVoucherObject</c> class that will be used to adding the entries to voucher.
    /// </param>
    /// <param name="_custVendTransDebit">
    /// The <c>CustVendTrans</c> map of credit transaction to be used.
    /// </param>
    public void parseVoucherEntries(
        LedgerVoucherObject     _ledgerVoucherObject,
        CustVendTrans           _custVendTransDebit)
    {
        LedgerVoucherTransList              ledgerVoucherTransList;
        LedgerVoucherTransObject            ledgerVoucherTransObject;
        Map                                 custBalanceMap;
        JournalizingDefinitionManagerBank   journalizingDefinitionManagerBank;
        JournalizingDefinitionEntry         journalizingDefinitionEntry;
        List                                systemGeneratedEntriesList, generatedList;
        ListEnumerator                      systemGeneratedEntriesListEnumerator;
        Factor                              signFactor = 1;
        LedgerVoucherTransObject            ledgerVoucherTransObjectGenerated;
        LedgerPostingType                   settlementPostingType;
        BankTransactionTypes                localBankTransactionTypes;

        void addToList()
        {
            systemGeneratedEntriesListEnumerator = systemGeneratedEntriesList.getEnumerator();

            while (systemGeneratedEntriesListEnumerator.moveNext())
            {
                journalizingDefinitionEntry = systemGeneratedEntriesListEnumerator.current();
                signFactor = journalizingDefinitionEntry.parmJournalizingDefinitionDebitCredit() == DebitCredit::Debit ? 1: -1;
                journalizingDefinitionEntry.parmTransactionAmount(signFactor * ledgerVoucherTransObject.parmAmountCur());
                journalizingDefinitionEntry.parmAccountingAmount(signFactor * ledgerVoucherTransObject.parmAccountingCurrencyAmount());
                journalizingDefinitionEntry.parmReportingAmount(signFactor * ledgerVoucherTransObject.parmReportingCurrencyAmount());

                generatedList.addEnd(journalizingDefinitionEntry);
            }
        }

        if (_ledgerVoucherObject)
        {
            ledgerVoucherTransList = _ledgerVoucherObject.getInternalCollection();

            if (ledgerVoucherTransList.elements() > 0)
            {
                custBalanceMap = new Map(Types::Container, Types::Class);
                generatedList = new List(Types::Class);
                localBankTransactionTypes = CustSettleJournalizingEntries::getBankTransactionTypes(_custVendTransDebit);

                if (_custVendTransDebit.TableId == tableNum(CustTrans))
                {
                    settlementPostingType = LedgerPostingType::CustSettlement;
                }
                else
                {
                    settlementPostingType = LedgerPostingType::VendSettlement;
                }

                journalizingDefinitionManagerBank =  JournalizingDefinitionManager::newJournalizingDefinitionManagerBank(
                                    _custVendTransDebit.CompanyBankAccountId,
                                    _custVendTransDebit.PaymMode,
                                    _custVendTransDebit.TransDate,
                                    LedgerPostingType::Bank);

                journalizingDefinitionManagerBank.parmBankTransactionTypes(localBankTransactionTypes);
                journalizingDefinitionManagerBank.parmJournalizingDefinition(journalizingDefinitionManagerBank.getDefaultJournalizingDefinition());

                ledgerVoucherTransList.first();

                do
                {
                    ledgerVoucherTransObject = ledgerVoucherTransList.item();
                    systemGeneratedEntriesList = journalizingDefinitionManagerBank.getSystemGeneratedEntries(DebitCredit::Debit, ledgerVoucherTransObject.parmLedgerDimensionId());
                    addToList();
                }

                while (ledgerVoucherTransList.next());

                systemGeneratedEntriesListEnumerator = generatedList.getEnumerator();

                while (systemGeneratedEntriesListEnumerator.moveNext())
                {
                    journalizingDefinitionEntry = systemGeneratedEntriesListEnumerator.current();

                    ledgerVoucherTransObjectGenerated = LedgerVoucherTransObject::newBasicDefault(
                        _ledgerVoucherObject,
                        settlementPostingType,
                        journalizingDefinitionEntry.parmLedgerDimension(),
                        _custVendTransDebit.CurrencyCode,
                        journalizingDefinitionEntry.parmTransactionAmount(),
                        journalizingDefinitionEntry.parmAccountingAmount(),
                        journalizingDefinitionEntry.parmReportingAmount());

                    _ledgerVoucherObject.addTrans(ledgerVoucherTransObjectGenerated);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postJournalizingEntries</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the journalizing entries in the ledger voucher.
    /// </summary>
    public void postJournalizingEntries()
    {
        LedgerVoucherObject             ledgerVoucherObject;
        MapEnumerator                   settlementMapEnumerator;
        JournalizingDefinitionEntry     journalizingDefinitionEntry;
        CustVendTrans                   localCustVendTrans;
        RefRecId                        custTransOpenId;
        List                            journalizingDefinitionEntriesList;
        ListEnumerator                  journalizingDefinitionEntriesListEnumerator;
        container                       journalizingDefinitionlistContainer;
        LedgerPostingType               ledgerPostingType;
        LedgerVoucherTransObject        ledgerVoucherTransObject;

        if (settlementEntriesMap.elements() > 0)
        {
            settlementMapEnumerator = settlementEntriesMap.getEnumerator();

            while (settlementMapEnumerator.moveNext())
            {
                journalizingDefinitionlistContainer = settlementMapEnumerator.currentValue();
                [localCustVendTrans, custTransOpenId] = settlementMapEnumerator.currentKey();

                if (custVendTransLedgerVoucher.exists(custTransOpenId))
                {
                    ledgerVoucherObject = custVendTransLedgerVoucher.lookup(custTransOpenId);
                    ledgerVoucherObject.parmLedgerTransType(LedgerTransType::Settlement);

                    if (localCustVendTrans.TableId == tableNum(CustTrans))
                    {
                        ledgerPostingType = LedgerPostingType::CustSettlement;
                    }
                    else
                    {
                        ledgerPostingType = LedgerPostingType::VendSettlement;
                    }

                    journalizingDefinitionEntriesList = List::create(journalizingDefinitionlistContainer);

                    if (localCustVendTrans.TableId == tableNum(CustTrans))
                    {
                        this.addUnSpecifiedCashDiscEntries(ledgerVoucherObject, localCustVendTrans, journalizingDefinitionEntriesList);
                    }

                    journalizingDefinitionEntriesListEnumerator = journalizingDefinitionEntriesList.getEnumerator();

                    while (journalizingDefinitionEntriesListEnumerator.moveNext())
                    {
                        journalizingDefinitionEntry = journalizingDefinitionEntriesListEnumerator.current();

                        ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicDefault(
                                ledgerVoucherObject,
                                ledgerPostingType,
                                journalizingDefinitionEntry.parmLedgerDimension(),
                                localCustVendTrans.CurrencyCode,
                                journalizingDefinitionEntry.parmTransactionAmount(),
                                journalizingDefinitionEntry.parmAccountingAmount(),
                                journalizingDefinitionEntry.parmReportingAmount());

                        ledgerVoucherObject.addTrans(ledgerVoucherTransObject);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBankTransactionTypes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the transaction type for given transaction.
    /// </summary>
    /// <param name="_custVendTransCredit">
    /// The <c>CustVendTrans</c> map to be used.
    /// </param>
    /// <returns>
    /// The <c>BankTransactionTypes</c> base enum.
    /// </returns>
    private static BankTransactionTypes getBankTransactionTypes(CustVendTrans _custVendTransCredit)
    {
        BankTransactionTypes    bankTransactionTypes;
        LedgerJournalTrans      ledgerJournalTrans;

        if (_custVendTransCredit.TableId == tableNum(CustTrans))
        {
            bankTransactionTypes = BankTransactionTypes::AccountsReceivableSettlement;
        }
        else
        {
            while select ledgerJournalTrans
                where ledgerJournalTrans.Voucher == _custVendTransCredit.Voucher &&
                        ledgerJournalTrans.TransDate == _custVendTransCredit.TransDate
            {
                if (ledgerJournalTrans.parmAccount() == _custVendTransCredit.AccountNum)
                {
                    bankTransactionTypes = JournalizingDefinitionManagerBank::convertLedgerJourTypeToBankTransTypes(ledgerJournalTrans.ledgerJournalTable().JournalType);
                    break;
                }
            }
        }

        //If no bank transaction type found than it means the settlement process has been initiated without using any journal.
        //The code will use PaymentJournal type of bank transaction type in this case.
        if (!bankTransactionTypes)
        {
            bankTransactionTypes = BankTransactionTypes::Paymentjournal;
        }

        return bankTransactionTypes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>requiredAdditionalEntries</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether journalizing definition entries should be created.
    /// </summary>
    /// <param name="_debitTransType">
    /// The debit transaction type to use.
    /// </param>
    /// <param name="_creditTransType">
    /// The credit transaction type to use.
    /// </param>
    /// <returns>
    /// true if journalizing definition entries should be created; otherwise, false.
    /// </returns>
    public static boolean requiredAdditionalEntries(
        LedgerTransType _debitTransType,
        LedgerTransType _creditTransType)
    {
        return LedgerParameters::find().JournalizingDefinitionEnableValue == NoYes::Yes &&
            ( _creditTransType == LedgerTransType::Payment ||
              _creditTransType == LedgerTransType::Cust ||
              _creditTransType == LedgerTransType::Interest ||
              _creditTransType == 0 ) &&
            ( _debitTransType == LedgerTransType::Cust ||
              _debitTransType == LedgerTransType::Interest ||
              _debitTransType == LedgerTransType::Project ||
              _debitTransType == LedgerTransType::CollectionLetter ||
              (_debitTransType == LedgerTransType::Tax && PublicSectorUtils::isLegalEntityInSupportedCountryRegion()) ||
              _debitTransType == LedgerTransType::Purch ||
              _debitTransType == LedgerTransType::Vend ||
              _debitTransType == 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static CustSettleJournalizingEntries construct(DataAreaId _specCompany, TableId _specTable, RecId _specRecId)
    {
        CustSettleJournalizingEntries custSettleJournalizingEntries = new CustSettleJournalizingEntries();

        custSettleJournalizingEntries.specCompany = _specCompany;
        custSettleJournalizingEntries.specTable = _specTable;
        custSettleJournalizingEntries.specRecId = _specRecId;

        return custSettleJournalizingEntries;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeOriginatingEntriesList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes originating entries list.
    /// </summary>
    /// <param name = "_custVendTrans">
    /// A <c>CustVendTrans</c> record to use.
    /// </param>
    /// <param name = "_settleAmountCur">
    /// The settlement amount to use.
    /// </param>
    /// <param name = "_settleAccountingAmount">
    /// An amount in accounting currency to use.
    /// </param>
    /// <param name = "_settleReportingAmount">
    /// An amount in reporting currency to use.
    /// </param>
    /// <param name = "_custVendTransOpenId">
    /// A record ID of the <c>CustVendTransOpen</c> table.
    /// </param>
    /// <param name = "_custSettlement">
    /// The <c>CustSettlement</c> table buffer to use.
    /// </param>
    /// <returns>
    /// The list of originating entries.
    /// </returns>
    [Replaceable]
    protected List initializeOriginatingEntriesList(
        CustVendTrans  _custVendTrans,
        AmountCur      _settleAmountCur,
        AmountMst      _settleAccountingAmount,
        AmountMst      _settleReportingAmount,
        RefRecId       _custVendTransOpenId,
        CustSettlement _custSettlement)
    {
        List originatingEntriesList;

        switch (_custVendTrans.TransType)
        {
            case LedgerTransType::Cust, LedgerTransType::Purch, LedgerTransType::Payment, LedgerTransType::None:
                originatingEntriesList = this.getInvoiceOriginatingEntries(_custVendTrans, _settleAmountCur, _settleAccountingAmount, _settleReportingAmount, _custVendTransOpenId);
                break;

            case LedgerTransType::Interest:
                originatingEntriesList = this.getInterestOriginatingEntries(_custVendTrans, _settleAmountCur, _custSettlement);
                break;

            default:
                originatingEntriesList = this.getOriginatingEntryFromVoucher(_custVendTrans, _settleAmountCur, _settleAccountingAmount, _settleReportingAmount);
                break;
        }

        return originatingEntriesList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateForPostingAdditionalInterestOriginatingEntries</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if posting additional interest originating entries are needed.
    /// </summary>
    /// <param name = "_custVendTransDebit">
    /// A <c>CustVendTrans</c> record to use.
    /// </param>
    /// <param name = "_custVendTransCredit">
    /// A <c>CustVendTrans</c> record to use.
    /// </param>
    /// <returns>
    /// true if posting additional interest originating entries are needed; otherwise, false.
    /// </returns>
    protected boolean validateForPostingAdditionalInterestOriginatingEntries(CustVendTrans _custVendTransDebit, CustVendTrans _custVendTransCredit)
    {
        return (_custVendTransDebit.TransType == LedgerTransType::Interest || _custVendTransCredit.TransType == LedgerTransType::Interest);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateForPostingProfileSummaryAccountAdditionalEntries</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if Posting posting profile summary account additonal entries are needed.
    /// </summary>
    /// <param name = "_custVendTransDebit">
    /// A <c>CustVendTrans</c> record to use.
    /// </param>
    /// <param name = "_custVendTransCredit">
    /// A <c>CustVendTrans</c> record to use.
    /// </param>
    /// <returns>
    /// true if posting posting profile summary account additional entries are needed; otherwise, false.
    /// </returns>
    protected boolean validateForPostingProfileSummaryAccountAdditionalEntries(CustVendTrans _custVendTransDebit, CustVendTrans _custVendTransCredit)
    {
        return (_custVendTransDebit.TransType == LedgerTransType::Interest || _custVendTransCredit.TransType == LedgerTransType::Interest);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>