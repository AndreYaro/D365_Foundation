<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendSumForPaym</Name>
	<SourceCode>
		<Declaration><![CDATA[
public abstract class CustVendSumForPaym extends RunBase
{
    LedgerJournalId ledgerJournalId;
    PaymMode paymMode;
    CustVendPaymFormat paymFormat;
    CompanyBankAccountId bankAccountID;
    boolean selectOnPaymFormat;
    QueryRun queryRun;

    CustVendOutPaym custVendOutPaym;
    Args args;

    DialogRunbase dialog;
    DialogField dialogPaymMode;
    DialogField dialogPaymFormat;
    DialogField dialogBank;
    DialogGroup dialogGroupPaymMode;
    DialogGroup dialogGroupPaymFormat;
    boolean userCanceled;

    ERFileName erFileName;
    DialogField dialogErFileName;

    #DEFINE.dialogBankFieldNo(900)

    // <GEEU>
    boolean clientBank;
    // </GEEU>

    #define.CurrentVersion(7) // There is a HF occupying 5
    #define.CurrentVersion(9)
    //#localmacro.CurrentList
    #localMacro.list7
        ledgerJournalId,
        paymMode,
        paymFormat,
        selectOnPaymFormat,
        bankAccountID
    #endmacro

    #localMacro.currentList
        #list7, erFileName
    #endMacro
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>bank_lookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides a custom lookup for the <c>CompanyBankAccountId</c> field.
    /// </summary>
    /// <param name="_formControl">
    ///    The <c>FormControl</c> object that needs the lookup
    /// </param>
    private void bank_lookup(FormControl _formControl)
    {
        CustVendPaymDialogUtility::bank_lookup(dialog, _formControl);
    }

]]></Source>
			</Method>
			<Method>
				<Name>bank_modified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the bank account every time that it is modified.
    /// </summary>
    /// <param name="_formControl">
    ///    The <c>FormControl</c> object that is modified.
    /// </param>
    /// <returns>
    ///    true if the bank account in the <c>CompanyBankAccountId</c> field is active; otherwise, false.
    /// </returns>
    public boolean bank_modified(FormStringControl _formControl)
    {
        return CustVendPaymDialogUtility::bank_modified(dialogBank, _formControl);
    }

]]></Source>
			</Method>
			<Method>
				<Name>bank_jumpRef</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calls custom jumpRef() logic to handle viewing the details of the <c>CompanyBankAccountId</c> field.
    /// </summary>
    /// <param name = "_formControl">The <c>FormControl</c> object tied to the <c>CompanyBankAccountId</c> field.</param>
    public void bank_jumpRef(FormStringControl _formControl)
    {
        CustVendPaymDialogUtility::bank_jumpRef(dialogBank);
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymMode_jumpRef</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calls custom jumpRef() logic to handle viewing the details of the method of payment field.
    /// </summary>
    /// <param name = "_formControl">The <c>FormControl</c> object tied to the method of payment field.</param>
    public void paymMode_jumpRef(FormStringControl _formControl)
    {
        CustVendPaymDialogUtility::paymMode_jumpRef(dialogPaymMode, this.typePaymMode());
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogPaymMode_modified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enables or disables field 'File name' depending on export type.
    /// </summary>
    /// <param name = "_formControl">The <c>FormControl</c> object that is modified.</param>
    /// <returns>_formControl.modified() value.</returns>
    public boolean dialogPaymMode_modified(FormStringControl _formControl)
    {
        boolean ret;

        ret = _formControl.modified();
        if (ret)
        {
            paymMode = dialogPaymMode.value();
            dialogErFileName.visible(this.useGERConfiguration());
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>bankFormat</Name>
				<Source><![CDATA[
    public abstract BankFormat bankFormat()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQuery</Name>
				<Source><![CDATA[
    protected Query buildQuery()
    {
        Query                   query;
        QueryBuildDataSource    qbdsLedgerJournalTrans;
        QueryBuildDataSource    qbdsPaymModeTable;
        QueryBuildDataSource    qbdsPaymFormatTable;
        TableId                 paymModeTableId     = this.paymModeTable().TableId;
        TableId                 paymFormatTableId   = this.paymFormatTable().TableId;
        FieldId                 fieldIdPaymModeTablePaymMode;
        FieldId                 fieldIdPaymModeTableClassId;
        FieldId                 fieldIdPaymFormatTableClassId;
        DimensionAttributeSetItem dimAttrSetItem;

        fieldIdPaymModeTablePaymMode    = new DictField(paymModeTableId,    fieldName2id(paymModeTableId,   identifierStr(PaymMode))).id();
        fieldIdPaymModeTableClassId     = this.fieldIdPaymModeExportClassId();
        fieldIdPaymFormatTableClassId   = new DictField(paymFormatTableId,  fieldName2id(paymFormatTableId, identifierStr(ClassId))).id();

        query = new Query();
        query.recordLevelSecurity(true);

        // LedgerJournalTrans
        qbdsLedgerJournalTrans = query.addDataSource(tableNum(LedgerJournalTrans));
        qbdsLedgerJournalTrans.allowAdd(QueryAllowAdd::NoFields);
        qbdsLedgerJournalTrans.update(true);

        qbdsLedgerJournalTrans.addRange(fieldNum(LedgerJournalTrans, AccountType));
        SysQuery::addDimensionAttributeRange(query, qbdsLedgerJournalTrans.name(), fieldStr(LedgerJournalTrans, LedgerDimension), DimensionComponent::LedgerDimensionDisplayValue, '', '', true);
        qbdsLedgerJournalTrans.addRange(fieldNum(LedgerJournalTrans, OffsetAccountType));
        SysQuery::addDimensionAttributeRange(query, qbdsLedgerJournalTrans.name(), fieldStr(LedgerJournalTrans, OffsetLedgerDimension), DimensionComponent::LedgerDimensionDisplayValue, '', '', true);
        qbdsLedgerJournalTrans.addRange(fieldNum(LedgerJournalTrans, PaymMode));
        qbdsLedgerJournalTrans.addRange(fieldNum(LedgerJournalTrans, PaymSpec));
        qbdsLedgerJournalTrans.addRange(fieldNum(LedgerJournalTrans, PaymentStatus)).status(RangeStatus::Locked);
        qbdsLedgerJournalTrans.addRange(fieldNum(LedgerJournalTrans, BankTransType));
        qbdsLedgerJournalTrans.addRange(fieldNum(LedgerJournalTrans, BankAccountId));
        qbdsLedgerJournalTrans.addRange(fieldNum(LedgerJournalTrans, CurrencyCode));
        qbdsLedgerJournalTrans.addRange(fieldNum(LedgerJournalTrans, AmountCurDebit));
        qbdsLedgerJournalTrans.addRange(fieldNum(LedgerJournalTrans, AmountCurCredit));
        qbdsLedgerJournalTrans.addRange(fieldNum(LedgerJournalTrans, PaymId));
        qbdsLedgerJournalTrans.addRange(fieldNum(LedgerJournalTrans, DocumentNum));
        qbdsLedgerJournalTrans.addRange(fieldNum(LedgerJournalTrans, DocumentDate));
        qbdsLedgerJournalTrans.addRange(fieldNum(LedgerJournalTrans, BankCentralBankPurposeCode));
        qbdsLedgerJournalTrans.addRange(fieldNum(LedgerJournalTrans, BankRemittanceFileId));

        // Add all dimensions from the current ledger
        while select DimensionAttribute from dimAttrSetItem
            where dimAttrSetItem.DimensionAttributeSet == DimensionCache::getDimensionAttributeSetForLedger()
        {
            SysQuery::addDimensionAttributeRange(query, qbdsLedgerJournalTrans.name(), fieldStr(LedgerJournalTrans, DefaultDimension), DimensionComponent::DimensionAttribute, '', DimensionAttribute::find(dimAttrSetItem.DimensionAttribute).Name);
        }

        qbdsLedgerJournalTrans.rangeField(fieldNum(LedgerJournalTrans, AccountType)).value(queryValue(this.ledgerJournalACType()));
        qbdsLedgerJournalTrans.rangeField(fieldNum(LedgerJournalTrans, PaymentStatus)).value(strFmt('%1,%2', CustVendPaymStatus::None, CustVendPaymStatus::Rejected));

        // PaymModeTable
        qbdsPaymModeTable = qbdsLedgerJournalTrans.addDataSource(paymModeTableId);
        qbdsPaymModeTable.addLink(fieldNum(LedgerJournalTrans, PaymMode), fieldIdPaymModeTablePaymMode);
        qbdsPaymModeTable.joinMode(JoinMode::InnerJoin);
        qbdsPaymModeTable.fetchMode(QueryFetchMode::One2One);
        qbdsPaymModeTable.update(true);
        qbdsPaymModeTable.enabled(false);

        // PaymFormatTable
        qbdsPaymFormatTable = qbdsPaymModeTable.addDataSource(paymFormatTableId);
        qbdsPaymFormatTable.addLink(fieldIdPaymModeTableClassId, fieldIdPaymFormatTableClassId);
        qbdsPaymFormatTable.joinMode(JoinMode::InnerJoin);
        qbdsPaymModeTable.fetchMode(QueryFetchMode::One2One);
        qbdsPaymFormatTable.enabled(false);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanup</Name>
				<Source><![CDATA[
    void cleanup()
    {
        custVendOutPaym = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendOutPaym_W</Name>
				<Source><![CDATA[
    public CustVendOutPaym custVendOutPaym_W()
    {
        return custVendOutPaym;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Provides a dialog box for an instance of the <c>RunBase</c> class.
    /// </summary>
    /// <returns>
    ///    A dialog box for an instance of the <c>RunBase</c> class.
    /// </returns>
    public Object dialog()
    {
        dialog = super();

        dialogGroupPaymMode = dialog.addGroup("@SYS28161");
        dialogGroupPaymMode.frameOptionButton(FormFrameOptionButton::Radio);
        dialogGroupPaymMode.optionValue(!selectOnPaymFormat);

        dialogPaymMode = dialog.addFieldValue(this.typePaymMode(), paymMode);
        dialogErFileName = dialog.addFieldValue(extendedTypeStr(ERFileName), erFileName);
        dialogPaymMode.control().registerOverrideMethod(methodStr(FormStringControl, modified),
                                                             methodStr(CustVendSumForPaym, dialogPaymMode_modified),
                                                             this);

        dialogPaymMode.control().registerOverrideMethod(methodStr(FormStringControl, jumpRef),
                                                             methodStr(CustVendSumForPaym, paymMode_jumpRef),
                                                             this);

        dialogErFileName.visible(this.useGERConfiguration());

        dialogGroupPaymFormat = dialog.addGroup("@SYS66246");
        dialogGroupPaymFormat.frameOptionButton(FormFrameOptionButton::Radio);
        dialogGroupPaymFormat.optionValue(selectOnPaymFormat);

        dialogGroupPaymFormat.visible(args.dataset() == tableNum(LedgerJournalTrans));

        dialogPaymFormat = dialog.addFieldValue(this.typeFormat(), paymFormat);

        dialog.addGroup("@SYS59973");
        dialogBank = new DialogField(dialog, extendedTypeStr(CompanyBankAccountId), #dialogBankFieldNo);
        dialog.addCtrlDialogField(dialogBank.name());
        dialogBank.init(dialog);
        dialogBank.value(bankAccountID);

        dialogBank.control().registerOverrideMethod(methodStr(FormStringControl, lookup),
                                                             methodStr(CustVendSumForPaym, bank_lookup),
                                                             this);

        dialogBank.control().registerOverrideMethod(methodStr(FormStringControl, modified),
                                                             methodStr(CustVendSumForPaym, bank_modified),
                                                             this);

        dialogBank.control().registerOverrideMethod(methodStr(FormStringControl, jumpRef),
                                                             methodStr(CustVendSumForPaym, bank_jumpRef),
                                                             this);
        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogPostInit</Name>
				<Source><![CDATA[
    protected DialogRunbase dialogPostInit(DialogRunbase _dialog)
    {
        DialogRunbase ret;

        ret = super(_dialog);

        this.updateQuery();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogPostRun</Name>
				<Source><![CDATA[
    public void dialogPostRun(DialogRunbase _dialog)
    {
        super(_dialog);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fieldIdPaymModeExportClassId</Name>
				<Source><![CDATA[
    protected FieldId fieldIdPaymModeExportClassId()
    {
        TableId paymModeTableId = this.paymModeTable().TableId;

        return new DictField(paymModeTableId, fieldName2id(paymModeTableId, identifierStr(ClassId))).id();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
    {
        if (bankAccountID && bankAccountID != dialogBank.value() && this.paymModeTable().UseGERConfiguration == NoYes::No)
        {
            custVendOutPaym = CustVendOutPaym::newCustVendSumForPaym(this);
            if (xSysLastValue::existLast(custVendOutPaym))
            {
                xSysLastValue::deleteLast(custVendOutPaym);
            }
        }

        paymMode             = dialogPaymMode.value();
        erFileName           = dialogErFileName.value();
        bankAccountID        = dialogBank.value();
        paymFormat           = dialogPaymFormat.value();
        selectOnPaymFormat   = dialogGroupPaymFormat.optionValue() == 1;

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendOutPaym</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a <c>CustVendOutPaym</c> class variable if the <c>PaymMode</c> class variable is
    ///    initialized.
    /// </summary>
    void initCustVendOutPaym()
    {
        if (paymMode || paymFormat)
        {
            custVendOutPaym = CustVendOutPaym::newCustVendSumForPaym(this);
        }
        else
        {
            custVendOutPaym = null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the internal variables.
    /// </summary>
    /// <remarks>
    ///    This method is called when no <c>SysLastValue</c> record can be found when it calls the
    ///    <c>SysLastValue.GetLast</c> method. Remember to call the <c>super</c> method.
    /// </remarks>
    public void initParmDefault()
    {
        super();

        queryRun = new QueryRun(this.buildQuery());
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerJournalACType</Name>
				<Source><![CDATA[
    protected abstract LedgerJournalACType ledgerJournalACType()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerJournalTable</Name>
				<Source><![CDATA[
    public LedgerJournalTable ledgerJournalTable()
    {
        return LedgerJournalTable::find(ledgerJournalId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>MCRIncludeApproved</Name>
				<Source><![CDATA[
    /// <summary>
    /// Includes payments that are in an approved state.
    /// </summary>
    public void MCRIncludeApproved()
    {
        queryRun.query().dataSourceTable(tableNum(LedgerJournalTrans))
                .rangeField(fieldNum(LedgerJournalTrans, PaymentStatus))
                .value(strFmt('%1,%2',
                            CustVendPaymStatus::None,
                            CustVendPaymStatus::Confirmed));
    }

]]></Source>
			</Method>
			<Method>
				<Name>useGERConfiguration</Name>
				<Source><![CDATA[
    /// <summary>
    ///		Determines whether GER should be used for the payment generation.
    /// </summary>
    /// <returns>
    ///		true if GER is to be used for the format; otherwise false.
    /// </returns>
    protected boolean useGERConfiguration()
    {
        CustVendPaymModeTable custVendPaymModeTable = this.paymModeTable();
        LedgerJournalTable ledgerJournalTable = this.LedgerJournalTable();

        boolean useGER;

        if (ledgerJournalTable.JournalType == LedgerJournalType::CustBillOfExchangeDraw
            || ledgerJournalTable.JournalType == LedgerJournalType::VendPromissoryNoteDraw)
        {
            if (!custVendPaymModeTable.ClassId)
            {
                useGER = this.paymModeTable().UseGERConfiguration == NoYes::Yes;
            }
            else
            {
                useGER = false;
            }
        }
        else
        {
            useGER = this.paymModeTable().UseGERConfiguration == NoYes::Yes;
        }

        return useGER;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container packedQueryRun;

        if (queryRun != null)
        {
            packedQueryRun = queryRun.pack();
        }
        else
        {
            packedQueryRun = conNull();
        }

        return [#CurrentVersion, #CurrentList, packedQueryRun];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankAccountID</Name>
				<Source><![CDATA[
    BankAccountID parmBankAccountID(BankAccountID   _bankAccountID = bankAccountID)
    {
        bankAccountID = _bankAccountID;

        return bankAccountID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmClientBank_RU</Name>
				<Source><![CDATA[
    public boolean parmClientBank_RU(boolean _clientBank = clientBank)
    {
        clientBank = _clientBank;
        return clientBank;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalId</Name>
				<Source><![CDATA[
    public LedgerJournalId parmLedgerJournalId(LedgerJournalId _ledgerJournalId = ledgerJournalId)
    {
        ledgerJournalId = _ledgerJournalId;

        return ledgerJournalId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRUserCanceledPrint</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>userCanceled</c> paramter.
    /// </summary>
    /// <returns>
    /// true if the user canceled the check printing; otherwise, false.
    /// </returns>
    boolean parmMCRUserCanceledPrint()
    {
        return userCanceled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymFormat</Name>
				<Source><![CDATA[
    public CustVendPaymFormat parmPaymFormat(CustVendPaymFormat _paymFormat = paymFormat)
    {
        paymFormat = _paymFormat;

        return paymFormat;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymMode</Name>
				<Source><![CDATA[
    PaymMode parmPaymMode(PaymMode _paymMode = paymMode)
    {
        paymMode = _paymMode;

        if (!selectOnPaymFormat)
        {
            this.parmPaymFormat(this.paymModeTable().actionClassName(false, null));
        }

        return paymMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSelectOnPaymFormat</Name>
				<Source><![CDATA[
    public boolean parmSelectOnPaymFormat(boolean _selectOnPaymFormat = selectOnPaymFormat)
    {
        selectOnPaymFormat = _selectOnPaymFormat;

        return selectOnPaymFormat;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymFormatTable</Name>
				<Source><![CDATA[
    public abstract CustVendPaymFormatTable paymFormatTable()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymModeTable</Name>
				<Source><![CDATA[
    public abstract CustVendPaymModeTable paymModeTable()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmArgs</Name>
				<Source><![CDATA[
    public Args parmArgs(Args _args = args)
    {
        args = _args;
        return args;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareOutQuery</Name>
				<Source><![CDATA[
    protected void prepareOutQuery()
    {
        LedgerJournalTable      ledgerJournalTable;
        CustVendPaymFormatTable paymFormatTable = this.paymFormatTable();
        CustVendPaymModeTable   paymModeTable   = this.paymModeTable();
        FieldId                 fieldIdPaymModeTableClassId;
        FieldId                 fieldIdPaymFormatTableBankFormat;

        queryRun.query().dataSourceTable(paymModeTable.TableId).enabled(true);
        queryRun.query().dataSourceTable(paymFormatTable.TableId).enabled(true);

        if (BankParameters::find().AllowBankLedgerCheck &&
            queryRun.query().dataSourceTable(tableNum(LedgerJournalTrans)).findRange(fieldNum(LedgerJournalTrans, AccountType)))
        {
            queryRun.query().dataSourceTable(tableNum(LedgerJournalTrans)).findRange(fieldNum(LedgerJournalTrans, AccountType)).enabled(false);
        }

        if (bankAccountID)
        {
            ledgerJournalTable = this.ledgerJournalTable();

            switch (ledgerJournalTable.JournalType)
            {
                case LedgerJournalType::CustPaymRemittance,
                    LedgerJournalType::VendPaymRemittance :
                    queryRun.query().dataSourceTable(tableNum(LedgerJournalTrans)).findRange(fieldNum(LedgerJournalTrans, BankAccountId)).value(queryValue(bankAccountID));
                    break;

                case LedgerJournalType::CustBillOfExchangeDraw,
                    LedgerJournalType::VendPromissoryNoteDraw,
                    LedgerJournalType::CustBillOfExchangeRedraw,
                    LedgerJournalType::VendPromissoryNoteRedraw :
                    queryRun.query().dataSourceTable(tableNum(LedgerJournalTrans)).findRange(fieldNum(LedgerJournalTrans, BankAccountId)).value(queryValue(bankAccountID));
                    break;

                default :
            }
        }

        if (selectOnPaymFormat)
        {
            fieldIdPaymModeTableClassId = this.fieldIdPaymModeExportClassId();
            queryRun.query().dataSourceTable(paymModeTable.TableId).addRange(fieldIdPaymModeTableClassId).value(queryValue(paymFormatTable.ClassId));

            fieldIdPaymFormatTableBankFormat= new DictField(paymFormatTable.TableId,  fieldName2id(paymFormatTable.TableId, identifierStr(bankFormat))).id();
            queryRun.query().dataSourceTable(paymFormatTable.TableId).addRange(fieldIdPaymFormatTableBankFormat).value(queryValue(this.bankFormat()));
        }
        else
        {
            queryRun.query().dataSourceTable(tableNum(LedgerJournalTrans)).findRange(fieldNum(LedgerJournalTrans, PaymMode)).value(queryValue(paymMode));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </summary>
    /// <returns>
    ///    The instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </returns>
    /// <remarks>
    ///    This method is used if a query prompt is the dialog, and if a Select menu item is added to a
    ///    dialog. Do not create the instance of the <c>QueryRun</c> class when this method is called. Do it
    ///    in the <c>unpack</c> method and the <c>initParmDefault</c> method, or in the <c>init</c> method.
    /// </remarks>
    public QueryRun queryRun()
    {
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        boolean canPromptForPaymentFormat;

        // <GEERU>
        #ISOCountryRegionCodes
        //</GEERU>

        SysInstrumentationProgressLogger progressLogger = this.createProgressLogger();

        using (SysInstrumentationActivityContext activityContext = progressLogger.activityContextForStage(CustVendInstrumentationConstants::PaymentGenerationForJournal))
        {
            CustVendPaymModeTable custVendPaymModeTable;

            if (!selectOnPaymFormat && paymMode)
            {
                custVendPaymModeTable = this.paymModeTable();

                this.parmClientBank_RU(custVendPaymModeTable.UseCustomFormat_RU);

                if (this.useGERConfiguration() && !this.parmClientBank_RU())
                {
                    activityContext.addCustomProperty(CustVendInstrumentationConstants::Action, CustVendInstrumentationConstants::PaymentGenerationThroughERExport);

                    this.runERPaymentExport(custVendPaymModeTable.ERFormatMappingID);
                    return;
                }
            }

            this.prepareOutQuery();

            this.initCustVendOutPaym();

            if (!this.validate())
            {
                throw error('');
            }

            canPromptForPaymentFormat = custVendOutPaym.userInteraction().canPromptForPaymentFormat();

            if (canPromptForPaymentFormat
                && (!SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoCZ, #isoEE, #isoHU, #isoLT, #isoLV, #isoPL, #isoRU ]) || !this.parmClientBank_RU()))
            {
                if (!this.promptForPaymentFormat())
                {
                    return;
                }
            }
            else
            {
                if (this.shouldCancelPaymRun())
                {
                    throw error("@SYS18447");
                }
            }

            custVendOutPaym.prepareTransRecords();

            this.progressInit("@SYS13894", QueryRun::getQueryRowCount(custVendOutPaym.parmQueryRun().query(), intMax()), #AviFindFile);
            progress.setText("@SYS26577");

            this.generatePaymentLines();

            if (custVendPaymModeTable && this.parmClientBank_RU() && this.useGERConfiguration())
            {
                activityContext.addCustomProperty(CustVendInstrumentationConstants::Action, CustVendInstrumentationConstants::PaymentGenerationERExportIncludedInPaymentGeneration);

                this.runERPaymentExport(custVendPaymModeTable.ERFormatMappingID);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCancelPaymRun</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Verifies whether the payment should be cancelled.
    /// </summary>
    /// <returns>
    ///     true if the payment should be cancelled; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean shouldCancelPaymRun()
    {
        return (!custVendOutPaym || !custVendOutPaym.validate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>promptForPaymentFormat</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Prompts the user for a payment format.
    /// </summary>
    /// <returns>
    ///     true if the payment format is valid; otherwise, false.
    /// </returns>
    protected boolean promptForPaymentFormat()
    {
        if (!custVendOutPaym || !custVendOutPaym.prompt())
        {
            if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
            {
                userCanceled = true;
            }

            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generatePaymentLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Generates the payment lines.
    /// </summary>
    protected void generatePaymentLines()
    {
        #OCCRetryCount

        try
        {
            ttsbegin;
            custVendOutPaym.open();

            // <GBR>
            if (BrazilParameters::isEnabled()
                && this is VendSumForPaym
                && VendPaymModeTable::find(paymMode).Posting_BR != Posting_BR::None)
            {
                custVendOutPaym.generatePaymentLines_BR(VendPaymModeTable::find(paymMode).Posting_BR);
            }
            else if (custVendOutPaym.canGeneratePaymentLines())
            {
                // </GBR>
                custVendOutPaym.generatePaymentLines();
                // <GBR>
            }
            // </GBR>
            if (CFMParameters::isPaymentRequestsEnabled())
            {
                this.updatePaymentRequest(queryRun.query());
            }
            ttscommit;
            custVendOutPaym.close();
            custVendOutPaym.closeFile();
        }
        catch (Exception::Deadlock)
        {
            this.createProgressLogger().logRetryOnDeadlock();

            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    this.createProgressLogger().logRetryOnUpdateConflict();

                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch
        {
            //Delete the file.
            this.cleanup();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePaymentRequest</Name>
				<Source><![CDATA[
    private void updatePaymentRequest(Query _query)
    {
        Query query = new Query(_query);

        QueryBuildDataSource qbdsLedgerJournalTrans = query.dataSourceTable(tableNum(LedgerJournalTrans));
        SysQuery::findOrCreateRange(qbdsLedgerJournalTrans, fieldNum(LedgerJournalTrans, PaymentStatus)).value(SysQuery::valueUnlimited());

        QueryRun queryRunPR = new QueryRun(query);

        while  (queryRunPR.next())
        {
            LedgerJournalTrans ledgerJournalTrans = queryRunPR.get(tableNum(LedgerJournalTrans));
            CFMPaymentRequestPaymentLink::updatePaymReqJournalTransPaymentDocument(ledgerJournalTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQueryValues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether to add a Select button to the dialog.
    /// </summary>
    /// <returns>
    ///    Always returns true.
    /// </returns>
    /// <remarks>
    ///    If you click this button, it will show the query form. Therefore, the <c>queryRun</c> method has to
    ///    return a valid <c>queryRun</c> object.If you change the return value to false the button will no
    ///    longer be added.
    /// </remarks>
    public boolean showQueryValues()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>typeFormat</Name>
				<Source><![CDATA[
    protected abstract UtilElementName typeFormat()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>typePaymMode</Name>
				<Source><![CDATA[
    protected abstract UtilElementName typePaymMode()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        boolean     ret;
        Version     version = RunBase::getVersion(_packedClass);
        container   packedQueryRun;
        container   packedCustVendOutPaymInfo;

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList, packedQueryRun] = _packedClass;
                ret = true;
                break;

            case 5: // 5 is occupied by a Hot Fix which has same contents.
                [version, #CurrentList, packedQueryRun, packedCustVendOutPaymInfo] = _packedClass;
                break;

            case 4:
                [version, #CurrentList, packedQueryRun] = _packedClass;
                ret = true;
                break;

            default:
                ret = false;
                break;
        }

        this.unpackQueryRun(packedQueryRun);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpackQueryRun</Name>
				<Source><![CDATA[
    protected void unpackQueryRun(container packedQueryRun)
    {
        if (packedQueryRun)
        {
            queryRun = new QueryRun(packedQueryRun);
            this.updateQuery();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQuery</Name>
				<Source><![CDATA[
    protected void updateQuery()
    {
        QueryBuildRange queryBuildRange;

        queryBuildRange = SysQuery::findOrCreateRange(queryRun.query().dataSourceTable(tableNum(LedgerJournalTrans)), fieldNum(LedgerJournalTrans, JournalNum));

        if (queryBuildRange)
        {
            queryBuildRange.value(queryValue(ledgerJournalId));
            queryBuildRange.status(RangeStatus::Locked);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    public boolean validate(Object _calledFrom = null)
    {
        boolean ret = true;
        LedgerJournalTable ledgerJournalTable;

        ret = this.validateForPayment();

        boolean runErBinding = this.paymModeTable().UseGERConfiguration == NoYes::Yes;

        if (ret && !runErBinding)
        {
            if (!this.isPaymModeAndPaymFormatValid())
            {
                ret = checkFailed("@SYS79742");
            }

            if (ret)
            {
                if (!bankAccountID)
                {
                    this.initCustVendOutPaym();

                    if (!this.isBankAccountValid())
                    {
                        ret = checkFailed("@SYS24651");
                    }
                }
                else
                {
                    ret = BankAccountTable::checkIsActive(bankAccountID);
                }
            }
        }

        // <GBR>
        if (ret && BrazilParameters::isEnabled())
        {
            ret = this.validatePayment_BR();
        }
        // </GBR>

        if (ret && this.useGERConfiguration() && this.isSEPADirectDebit())
        {
            ledgerJournalTable = LedgerJournalTable::find(ledgerJournalId);
            ret = this.validateSEPATransaction(ledgerJournalTable) && this.validateSEPACreditorAccount(ledgerJournalTable);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBankAccountValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Is bank account valid for payment.
    /// </summary>
    /// <returns>
    /// true when the bank account is valid; otherwise false.
    /// </returns>
    protected boolean isBankAccountValid()
    {
        boolean ret = true;

        if (custVendOutPaym && !custVendOutPaym.multipleBankAccountsAllowed())
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPaymModeAndPaymFormatValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Is payment mode and payment format valid.
    /// </summary>
    /// <returns>
    /// true when valid; otherwise false.
    /// </returns>
    protected boolean isPaymModeAndPaymFormatValid()
    {
        boolean ret = true;

        if (!paymMode && !paymFormat)
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateForPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate for payment.
    /// </summary>
    /// <returns>
    /// true when we should validate for payment; otherwise false.
    /// </returns>
    /// <remarks>
    /// This method provides an extensibility point for extended validation logic to execute before core logic.
    /// </remarks>
    protected boolean validateForPayment()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSEPADirectDebit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the current method of payment is SEPA Direct Debit.
    /// </summary>
    /// <returns>
    /// True if the current method of payment is SEPA Direct Debit; otherwise, false.
    /// </returns>
    private boolean isSEPADirectDebit()
    {
        boolean ret = false;

        if (this.typePaymMode() == extendedTypeStr(CustPaymMode))
        {
            ret = CustPaymModeTable::find(this.paymMode).IsSEPA;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymentTypeElectronicPayment</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the electronic payment enum value of <c>PaymentType</c>.
    /// </summary>
    /// <returns>
    ///     Enum value of electronic payment of enum <c>PaymentType</c>.
    /// </returns>
    protected PaymentType getPaymentTypeElectronicPayment()
    {
        return PaymentType::ElectronicPayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePayment</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates transactions when the payment is generated for a particular vendor.
    /// </summary>
    /// <returns>
    ///    true if the payment can be generated; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    When the user clicks the OK button on the generate payments dialog box, this method validates the
    ///    journal for the payment generation. The method then checks the vendor bank account status. For an
    ///    active bank account it compares the bank account active date with the payment transaction date.
    /// </remarks>
    [SysObsolete('This method is obsolete, validation now occurs during generatePaymentLine()', false, 30\6\2020)]
    public boolean validatePayment()
    {
        LedgerJournalTable                  ledgerJournalTable;
        boolean                             ret;
        LedgerJournalTrans                  ledgerJournalTrans;
        VendBankAccount                     vendBankAccount;
        VendPaymModeTable                   vendPaymModeTable;
        QueryBuildRange                     qbr;
        str                                 paymentFilterQuery;
        DimensionAttributeValueCombination  dimAttrValueCombo;

        queryRun.query().dataSourceTable(tableNum(LedgerJournalTrans)).clearRange(fieldNum(LedgerJournalTrans, DataAreaId));
        ledgerJournalTable = LedgerJournalTable::find(ledgerJournalId);

        ret = true;

        while select CustVendBankAccountId, Company, TransDate, LineNum, Voucher from ledgerJournalTrans
        join PaymentType from vendPaymModeTable
            where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
                && ledgerJournalTrans.PaymMode == paymMode
                && vendPaymModeTable.PaymMode == paymMode
                && ledgerJournalTrans.AccountType == LedgerJournalACType::Vend
                && ledgerJournalTrans.CustVendBankAccountId != ''
        join DisplayValue from dimAttrValueCombo
            where dimAttrValueCombo.RecId == ledgerJournalTrans.LedgerDimension
        {
            select crosscompany vendBankAccount
                where vendBankAccount.AccountID == ledgerJournalTrans.CustVendBankAccountId
                    && vendBankAccount.DataAreaId == ledgerJournalTrans.Company
                    && vendBankAccount.VendAccount == dimAttrValueCombo.DisplayValue;

            if (vendBankAccount.bankAccountStatus(DateTimeUtil::newDateTime(ledgerJournalTrans.TransDate, 0)) == BankAccountStatus::Active)
            {
                if (DateTimeUtil::date(vendBankAccount.ActiveDate) > ledgerJournalTrans.TransDate
                    && vendPaymModeTable.PaymentType == this.getPaymentTypeElectronicPayment())
                {
                    if (!queryRun.query().dataSourceTable(tableNum(LedgerJournalTrans)).findRange(fieldNum(LedgerJournalTrans, DataAreaId)))
                    {
                        paymentFilterQuery = strFmt('(LineNum != %1)', queryValue(ledgerJournalTrans.LineNum));
                        qbr = queryRun.query().dataSourceTable(tableNum(LedgerJournalTrans)).addRange(fieldNum(LedgerJournalTrans, DataAreaId));
                        qbr.status(RangeStatus::Hidden);
                        qbr.value(paymentFilterQuery);
                    }
                    else
                    {
                        paymentFilterQuery = queryRun.query().dataSourceTable(tableNum(LedgerJournalTrans)).findRange(fieldNum(LedgerJournalTrans, DataAreaId)).value();
                        paymentFilterQuery = paymentFilterQuery + strFmt(' && (LineNum != %1)', queryValue(ledgerJournalTrans.LineNum));
                        qbr = queryRun.query().dataSourceTable(tableNum(LedgerJournalTrans)).findRange(fieldNum(LedgerJournalTrans, DataAreaId));
                        qbr.status(RangeStatus::Hidden);
                        qbr.value(paymentFilterQuery);
                    }

                    warning(strFmt("@SYS115093", ledgerJournalTrans.Voucher));
                }
            }
            else
            {
                if (!queryRun.query().dataSourceTable(tableNum(LedgerJournalTrans)).findRange(fieldNum(LedgerJournalTrans, DataAreaId)))
                {
                    paymentFilterQuery = strFmt('(LineNum != %1)', queryValue(ledgerJournalTrans.LineNum));
                    qbr = queryRun.query().dataSourceTable(tableNum(LedgerJournalTrans)).addRange(fieldNum(LedgerJournalTrans, DataAreaId));
                    qbr.status(RangeStatus::Hidden);
                    qbr.value(paymentFilterQuery);
                }
                else
                {
                    paymentFilterQuery = queryRun.query().dataSourceTable(tableNum(LedgerJournalTrans)).findRange(fieldNum(LedgerJournalTrans, DataAreaId)).value();
                    paymentFilterQuery = paymentFilterQuery + strFmt('&& (LineNum != %1)', queryValue(ledgerJournalTrans.LineNum));
                    qbr = queryRun.query().dataSourceTable(tableNum(LedgerJournalTrans)).findRange(fieldNum(LedgerJournalTrans, DataAreaId));
                    qbr.status(RangeStatus::Hidden);
                    qbr.value(paymentFilterQuery);
                }

                warning(strFmt("@SYS115093", ledgerJournalTrans.Voucher));
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePayment_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates number of settled invoices when the payment is generated for a particular customer or vendor.
    /// </summary>
    /// <returns>
    ///    true if the payment can be generated; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    When the user clicks the OK button on the generate payments dialog box, this method validates the
    ///    journal for the payment generation. The method then checks the if any payment line has more than
    ///    one invoice marked for settlement.
    /// </remarks>
    public boolean validatePayment_BR()
    {
        LedgerJournalTable  ledgerJournalTable;
        LedgerJournalTrans  ledgerJournalTrans;
        SpecTrans           specTrans;
        PaymSumBy           paymSumBy;
        boolean             ret = true;
        boolean				isElectronicPayment = false;

        ledgerJournalTable = LedgerJournalTable::find(ledgerJournalId);

        while select ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
               && ledgerJournalTrans.PaymMode == paymMode
               && ledgerJournalTrans.Company  == curext()
        {
            if (ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
            {
                CustPaymModeTable custPaymMode = CustPaymModeTable::find(paymMode);
                paymSumBy = custPaymMode.PaymSumBy;

                isElectronicPayment = custPaymMode.PaymentType == CustPaymentType::ElectronicPayment;

                if (isElectronicPayment)
                {
                    ret = CustVendElectronicPaymValidation_BR::checkCustomerPaymentFilledCorrectly(ledgerJournalTrans) && ret;
                }
            }
            else if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
            {
                VendPaymModeTable vendPaymMode = VendPaymModeTable::find(paymMode);
                paymSumBy = vendPaymMode.PaymSumBy;

                isElectronicPayment = vendPaymMode.PaymentType == this.getPaymentTypeElectronicPayment();

                if (isElectronicPayment)
                {
                    ret = CustVendElectronicPaymValidation_BR::checkVendorPaymentFilledCorrectly(ledgerJournalTrans, ledgerJournalTable) && ret;
                }
            }

            if (paymSumBy == PaymSumBy::Invoice)
            {
                select count(RecId) from specTrans
                    where specTrans.SpecCompany == curext()
                        && specTrans.SpecTableId == ledgerJournalTrans.TableId
                        && specTrans.SpecRecId   == ledgerJournalTrans.RecId;
                if (specTrans.RecId > 1)
                {
                    ret = checkFailed("@GLS223908");
                    break;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates transactions when the payment is generated for a particular vendor.
    /// </summary>
    /// <returns>
    ///    true if the payment generation can be proceeded; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    When the user clicks the generate payment menu item button, this method checks the validity of each
    ///    journal line. The validation is based on comparing bank account expiration date and active date
    ///    with the payment transaction date. The active date comparison occurs only if the payment type is
    ///    electronic.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    ///    This function is used incorrectly.
    /// </exception>
    public boolean validateTransactions()
    {
        boolean                 ret;
        LedgerJournalTable      ledgerJournalTable;
        LedgerJournalTrans      ledgerJournalTrans;
        VendBankAccount         vendBankAccount;
        VendPaymModeTable       vendPaymModeTable;
        int                     numberOfInvalidBankAccounts;
        DialogButton            dialogButton;
        DimensionAttributeValueCombination  dimAttrValueCombo;

        ledgerJournalTable = LedgerJournalTable::find(ledgerJournalId);

        while select CustVendBankAccountId, TransDate, Company, Voucher from ledgerJournalTrans
            where ledgerJournalTrans.AccountType == LedgerJournalACType::Vend
                && ledgerJournalTrans.JournalNum == ledgerJournalId
                && ledgerJournalTrans.CustVendBankAccountId != ''
            join DisplayValue from dimAttrValueCombo
                where dimAttrValueCombo.RecId == ledgerJournalTrans.LedgerDimension
        {
            select crosscompany ExpiryDate from vendBankAccount
                where vendBankAccount.AccountID == ledgerJournalTrans.CustVendBankAccountId
                    && vendBankAccount.DataAreaId == ledgerJournalTrans.Company
                    && vendBankAccount.VendAccount == dimAttrValueCombo.DisplayValue;

            if (vendBankAccount.ExpiryDate != Global::utcDateTimeNull()
                && ledgerJournalTrans.TransDate > DateTimeUtil::date(vendBankAccount.ExpiryDate))
            {
                numberOfInvalidBankAccounts = numberOfInvalidBankAccounts + 1;
                break;
            }
        }

        if (numberOfInvalidBankAccounts > 0)
        {
            switch (ledgerJournalTable.JournalType)
            {
                case LedgerJournalType::Payment:
                    if (ledgerJournalTable.numOfLines() > 1)
                    {
                        dialogButton = Box::okCancel("@SYS115094",DialogButton::Ok);
                        if (dialogButton == DialogButton::Ok)
                        {
                            ret = true;
                        }
                        else
                        {
                            ret = false;
                        }
                    }
                    else
                    {
                        select firstonly Voucher from ledgerJournalTrans
                            where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum;
                        ret = checkFailed(strFmt("@SYS115093", ledgerJournalTrans.Voucher));
                    }
                    break;

                case LedgerJournalType::VendPaymRemittance,
                    LedgerJournalType::VendPromissoryNoteDraw,
                    LedgerJournalType::VendPromissoryNoteRedraw :
                    if (ledgerJournalTable.numOfLines() > 1)
                    {
                        dialogButton = Box::okCancel("@SYS115096", DialogButton::Ok);
                        if (dialogButton == DialogButton::Ok)
                        {
                            ret = true;
                        }
                        else
                        {
                            ret = false;
                        }
                    }
                    else
                    {
                        select firstonly Voucher from ledgerJournalTrans
                            where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum;
                        ret = checkFailed(strFmt("@SYS115095", ledgerJournalTrans.Voucher));
                    }
                    break;

                default :
                    throw error(Error::wrongUseOfFunction(funcName()));
            }
        }
        else
        {
            ret = true;
        }

        numberOfInvalidBankAccounts = 0;

        if (ret)
        {
            while select JournalNum, Company, CustVendBankAccountId, TransDate, Voucher from ledgerJournalTrans
                where ledgerJournalTrans.JournalNum == ledgerJournalId
                    && ledgerJournalTrans.AccountType == LedgerJournalACType::Vend
                    && ledgerJournalTrans.CustVendBankAccountId != ''
                join vendPaymModeTable
                    where vendPaymModeTable.PaymMode == ledgerJournalTrans.PaymMode
                        && vendPaymModeTable.PaymentType == this.getPaymentTypeElectronicPayment()
                join DisplayValue from dimAttrValueCombo
                    where dimAttrValueCombo.RecId == ledgerJournalTrans.LedgerDimension
            {
                select crosscompany ActiveDate from vendBankAccount
                    where vendBankAccount.AccountID ==  ledgerJournalTrans.CustVendBankAccountId
                        && vendBankAccount.DataAreaId == ledgerJournalTrans.Company
                        && vendBankAccount.VendAccount == dimAttrValueCombo.DisplayValue;

                if (vendBankAccount.ActiveDate != Global::utcDateTimeNull()
                    && ledgerJournalTrans.TransDate <= DateTimeUtil::date(vendBankAccount.ActiveDate))
                {
                    numberOfInvalidBankAccounts = numberOfInvalidBankAccounts + 1;
                }
            }
            if (numberOfInvalidBankAccounts > 0)
            {
                if (ledgerJournalTable.numOfLines() == numberOfInvalidBankAccounts &&
                                                    ledgerJournalTable.numOfLines() != 1 )
                {
                    ret = checkFailed("@SYS116337");
                }
                else if (ledgerJournalTable.numOfLines() > 1)
                {
                    dialogButton = Box::okCancel("@SYS116336", DialogButton::Ok);
                    if (dialogButton == DialogButton::Ok)
                    {
                        ret = true;
                    }
                    else
                    {
                        ret = false;
                    }
                }
                else
                {
                    select firstonly Voucher from ledgerJournalTrans
                        where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum;

                    ret = checkFailed(strFmt("@SYS116362", ledgerJournalTrans.Voucher));
                }
            }
            else
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to create an instance of <c>CustVendSumForPaym</c>.
    /// </summary>
    /// <param name = "ledgerJournalTable">
    /// The payment journal.
    /// </param>
    /// <param name = "custVendSumForPaymResult">
    /// An <c>EventHandlerResult</c> where the <c>CustVendSumForPaym</c> instance result can be returned.
    /// </param>
    static delegate void constructDelegate(LedgerJournalTable _ledgerJournalTable, EventHandlerResult _custVendSumForPaymResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructDelegateHandler</Name>
				<Source><![CDATA[
    [SubscribesTo(classStr(CustVendSumForPaym), staticDelegateStr(CustVendSumForPaym, constructDelegate))]
    public static void constructDelegateHandler(LedgerJournalTable _ledgerJournalTable, EventHandlerResult _custVendSumForPaymResult)
    {
        CustVendSumForPaym custVendSumForPaym;

        if (_custVendSumForPaymResult.hasResult())
        {
            return;
        }

        switch (_ledgerJournalTable.JournalType)
        {
            case LedgerJournalType::CustPayment,
                 LedgerJournalType::CustBillOfExchangeDraw,
                 LedgerJournalType::CustBillOfExchangeRedraw :
                custVendSumForPaym = new CustSumForPaym();
                break;

            case LedgerJournalType::CustPaymRemittance:
                custVendSumForPaym = new CustSumForPaymRemittance();
                break;

            case LedgerJournalType::Payment,
                 LedgerJournalType::VendPromissoryNoteDraw,
                 LedgerJournalType::VendPromissoryNoteRedraw :
                custVendSumForPaym = new VendSumForPaym();
                break;

            case LedgerJournalType::VendPaymRemittance :
                custVendSumForPaym = new VendSumForPaymRemittance();
                break;

            case LedgerJournalType::PayrollDisbursement:
                custVendSumForPaym = new VendSumForPaymPayrollDisbursement();
                break;

            default :
                custVendSumForPaym = null;
        }

        if (custVendSumForPaym)
        {
            _custVendSumForPaymResult.result(custVendSumForPaym);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to allow additional <c>CustVendSumForPaym</c> initialization.
    /// </summary>
    /// <param name = "_custVendSumForPaym">
    /// The constucted <c>CustVendSumForPaym</c> instance.
    /// </param>
    /// <param name = "ledgerJournalTable">
    /// The payment journal.
    /// </param>
    static delegate void constructed(CustVendSumForPaym _custVendSumForPaym, LedgerJournalTable _ledgerJournalTable)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructedEventHandler</Name>
				<Source><![CDATA[
    [SubscribesTo(classStr(CustVendSumForPaym), staticDelegateStr(CustVendSumForPaym, constructed))]
    public static void constructedEventHandler(CustVendSumForPaym _custVendSumForPaym, LedgerJournalTable _ledgerJournalTable)
    {
        #ISOCountryRegionCodes

        if ( (_ledgerJournalTable.JournalType == LedgerJournalType::Payment || _ledgerJournalTable.JournalType == LedgerJournalType::PayrollDisbursement) &&
            _ledgerJournalTable.BankAccountId &&
            _custVendSumForPaym.parmBankAccountID() != _ledgerJournalTable.BankAccountId &&
            SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT]))
        {
            _custVendSumForPaym.parmBankAccountID(_ledgerJournalTable.BankAccountId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    static CustVendSumForPaym construct(LedgerJournalId  _ledgerJournalId)
    {
        LedgerJournalTable  ledgerJournalTable = LedgerJournalTable::find(_ledgerJournalId);
        CustVendSumForPaym  custVendSumForPaym;

        if (!ledgerJournalTable)
        {
            throw error("@SYS19282");
        }

        EventHandlerResult custVendSumForPaymResult = EventHandlerResult::newSingleResponse();
        CustVendSumForPaym::constructDelegate(ledgerJournalTable, custVendSumForPaymResult);
        if (custVendSumForPaymResult.hasResult())
        {
            custVendSumForPaym = custVendSumForPaymResult.result();
        }
        else
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        custVendSumForPaym.getLast();
        custVendSumForPaym.parmLedgerJournalId(_ledgerJournalId);

        custVendSumForPaym.updateQuery();

        CustVendSumForPaym::constructed(custVendSumForPaym, ledgerJournalTable);

        return custVendSumForPaym;
    }

]]></Source>
			</Method>
			<Method>
				<Name>countPaymFormats</Name>
				<Source><![CDATA[
    public static Counter countPaymFormats(container _packedQuery)
    {
        QueryRun                countQueryRun;
        Set                     setPaymFormats;
        CustVendPaymFormatTable custVendPaymFormatTable;
        TableId                 tableIdPaymFormatTable;
        Counter                 paymFormats;

        setPaymFormats  = new Set(typeName2Type(extendedTypeStr(CustVendPaymModeClassId)));
        countQueryRun   = new QueryRun(_packedQuery);

        if (countQueryRun.query().dataSourceTable(tableNum(CustPaymFormat)))
        {
            tableIdPaymFormatTable = tableNum(CustPaymFormat);
        }
        else
        {
            tableIdPaymFormatTable = tableNum(VendPaymFormat);
        }

        if (countQueryRun.query().dataSourceTable(tableIdPaymFormatTable).enabled())
        {
            while (countQueryRun.next())
            {
                custVendPaymFormatTable = countQueryRun.get(tableIdPaymFormatTable);

                setPaymFormats.add(custVendPaymFormatTable.ClassId);
            }

            paymFormats = setPaymFormats.elements();
        }

        return paymFormats;
    }

]]></Source>
			</Method>
			<Method>
				<Name>countPaymModes</Name>
				<Source><![CDATA[
    public static Counter countPaymModes(container _packedQuery)
    {
        QueryRun                countQueryRun;
        Set                     setPaymModes;
        CustVendPaymModeTable   custVendPaymModeTable;
        TableId                 tableIdPaymModeTable;
        Counter                 paymModes;

        setPaymModes    = new Set(Types::String);
        countQueryRun   = new QueryRun(_packedQuery);

        if (countQueryRun.query().dataSourceTable(tableNum(CustPaymModeTable)))
        {
            tableIdPaymModeTable = tableNum(CustPaymModeTable);
        }
        else
        {
            tableIdPaymModeTable = tableNum(VendPaymModeTable);
        }

        if (countQueryRun.query().dataSourceTable(tableIdPaymModeTable).enabled())
        {
            while (countQueryRun.next())
            {
                custVendPaymModeTable = countQueryRun.get(tableIdPaymModeTable);

                setPaymModes.add(custVendPaymModeTable.PaymMode);
            }

            paymModes = setPaymModes.elements();
        }

        return paymModes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS24287";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args args)
    {
        CustVendSumForPaym  custVendSumForPaym;

        switch (args.dataset())
        {
            case tableNum(LedgerJournalTrans) :
                custVendSumForPaym = CustVendSumForPaym::newLedgerJournalTrans(args.record());
                break;

            default :
                throw error(Error::wrongUseOfFunction("@SYS24287"));
        }

        custVendSumForPaym.parmArgs(args);

        if (custVendSumForPaym.prompt())
        {
            custVendSumForPaym.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newLedgerJournalTrans</Name>
				<Source><![CDATA[
    static CustVendSumForPaym newLedgerJournalTrans(LedgerJournalTrans  _ledgerJournalTrans)
    {
        CustVendSumForPaym  custVendSumForPaym;

        custVendSumForPaym = CustVendSumForPaym::construct(_ledgerJournalTrans.JournalNum);

        return custVendSumForPaym;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initERPaymentExport</Name>
				<Source><![CDATA[
    protected CustVendPaymERExport initERPaymentExport(ERFormatMappingID _eRFormatMappingID)
    {
        var custVendPaymERExport = new CustVendPaymERExport();
        custVendPaymERExport.parmERBinding(_eRFormatMappingID);
        custVendPaymERExport.parmLedgerJournalId(ledgerJournalId);
        custVendPaymERExport.parmBankAccountID(bankAccountID);
        custVendPaymERExport.parmERFileName(erFileName);
        custVendPaymERExport.parmQuery(this.queryRun().query());
        custVendPaymERExport.parmShowParamsDialog(true);
        custVendPaymERExport.parmCustVendPaymModeTable(this.paymModeTable());

        #ISOCountryRegionCodes
        if (LedgerJournalTable::find(ledgerJournalId).JournalType == LedgerJournalType::CustPaymRemittance
            && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoFR, #isoIT]))
        {
            custVendPaymERExport.addInputParameter(CustVendOutPaymConstants::GenerateRemittanceFileGERParameter, NoYes::Yes);
            custVendPaymERExport.parmPostERExportDataUpdateRequiredForCustomerRemittance(true);
        }

        return custVendPaymERExport;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runERPaymentExport</Name>
				<Source><![CDATA[
    private void runERPaymentExport(ERFormatMappingID _eRFormatMappingID)
    {
        this.initERPaymentExport(_eRFormatMappingID).run();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSEPATransaction</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the remaining balance is not debit balance if using SEPA
    /// </summary>
    /// <param name = "_ledgerJournalTable">
    ///     A <c>LedgerJournalTable</c> table buffer.
    /// </param>
    /// <returns>
    ///    true if the balance is not debit; false otherwise
    /// </returns>
    protected boolean validateSEPATransaction(LedgerJournalTable _ledgerJournalTable)
    {
        LedgerJournalTrans ledgerJournalTrans = this.JournalTransForSEPA(_ledgerJournalTable);
        return !ledgerJournalTrans ? true : checkFailed("@CashManagement:SEPADirectDebitValidation");
    }

]]></Source>
			</Method>
			<Method>
				<Name>JournalTransForSEPA</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the remaining balance is not debit balance if using SEPA
    /// </summary>
    /// <param name = "_ledgerJournalTable"><c>LedgerJournalTable</c> table buffer.</param>
    /// <returns><c>LedgerJournalTrans</c> buffer value.</returns>
    protected LedgerJournalTrans JournalTransForSEPA(LedgerJournalTable _ledgerJournalTable)
    {   
        LedgerJournalTrans ledgerJournalTrans;
        CustPaymModeTable custPaymModeTable;

        select firstonly RecId from ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum
            && ledgerJournalTrans.AmountCurDebit != 0
            && ledgerJournalTrans.AccountType == LedgerJournalACType::Cust
                exists join custPaymModeTable
                    where custPaymModeTable.PaymMode == ledgerJournalTrans.PaymMode
                    && custPaymModeTable.IsSEPA == NoYes::Yes;
        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDebitDirectIdByDebitMandate</Name>
				<Source><![CDATA[
    private BankDebitDirectId getDebitDirectIdByDebitMandate(
        Map _valueMap,
        SelectableDataArea _dataArea,
        RefRecId _directDebitMandate)
    {
        BankDebitDirectId ret;

        if (_valueMap.exists([_dataArea, _directDebitMandate]))
        {
            ret = _valueMap.lookup([_dataArea, _directDebitMandate]);
        }
        else
        {
            changecompany(_dataArea)
            {
                ret = BankAccountTable::find(
                    custDirectDebitMandate::find(_directDebitMandate).CreditorBankAccount).DebitDirectId;
            }

            _valueMap.insert(
                [_dataArea, _directDebitMandate],
                ret);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDebitDirectIdByOffsetAccount</Name>
				<Source><![CDATA[
    private BankDebitDirectId getDebitDirectIdByOffsetAccount(
        Map _valueMap,
        LedgerJournalType _journalType,
        LedgerJournalTrans _ledgerJournaltrans)
    {
        BankDebitDirectId ret;
        container selectData = [_ledgerJournalTrans.BankAccountId,
            _ledgerJournalTrans.OffsetLedgerDimension,
            _ledgerJournalTrans.PaymMode,
            _ledgerJournalTrans.OffsetAccountType];

        if (_valueMap.exists(selectData))
        {
            ret = _valueMap.lookup(selectData);
        }
        else
        {
            ret = this.getOffsetBankAccount(_ledgerJournalTrans, _journalType).DebitDirectId;

            _valueMap.insert(
                selectData,
                ret);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSEPACreditorAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates the Direct Debit ID from the CreditorBankAccount from the CustDirectDebitMandate
    ///     and the Direct Debit ID from the OffsetLedgerDimension are the same
    /// </summary>
    /// <param name="_ledgerJournalTable">
    ///     The LedgerJournalTable table associated with the payment.
    /// </param>
    /// <returns>
    ///     true if the Direct Debit IDs match; false otherwise
    /// </returns>
    protected boolean validateSEPACreditorAccount(LedgerJournalTable _ledgerJournalTable)
    {
        LedgerJournalTrans ledgerJournalTrans;
        CustTransOpen custTransOpen;
        SpecTrans specTrans;
        CustTrans custTrans;

        BankDebitDirectId debitMandateDirectId;
        BankDebitDirectId offsetBankAccDirectId;

        Map debitMandateDirectMap = new Map(Types::Container, Types::String);
        Map offsetBankAccDirectMap = new Map(Types::Container, Types::String);

        while select BankAccountId, OffsetLedgerDimension, DirectDebitMandate, Company, PaymMode, OffsetAccountType from ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum
                && ledgerJournalTrans.DirectDebitMandate != 0
        {
            debitMandateDirectId = this.getDebitDirectIdByDebitMandate(
                debitMandateDirectMap,
                ledgerJournalTrans.Company,
                ledgerJournalTrans.DirectDebitMandate);

            offsetBankAccDirectId = this.getDebitDirectIdByOffsetAccount(
                offsetBankAccDirectMap,
                _ledgerJournalTable.JournalType,
                ledgerJournalTrans);

            if (debitMandateDirectId != offsetBankAccDirectId)
            {
                return checkFailed("@CashManagement:SEPACreditorMandateValidation");
            }
        }

        while select crosscompany BankAccountId, OffsetLedgerDimension, PaymMode, OffsetAccountType from ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum
        join RefRecId from specTrans
            where specTrans.SpecCompany == curExt()
            && specTrans.SpecRecId == ledgerJournalTrans.RecId
            && specTrans.SpecTableId == ledgerJournalTrans.TableId
        join RefRecId from custTransOpen
            where custTransOpen.RecId == specTrans.RefRecId
        join DirectDebitMandate from custTrans
            where custTrans.RecId == custTransOpen.RefRecId
        {

            debitMandateDirectId = this.getDebitDirectIdByDebitMandate(
                debitMandateDirectMap,
                custTrans.Company(),
                custTrans.DirectDebitMandate);

            offsetBankAccDirectId = this.getDebitDirectIdByOffsetAccount(
                offsetBankAccDirectMap,
                _ledgerJournalTable.JournalType,
                ledgerJournalTrans);

            if (debitMandateDirectId != offsetBankAccDirectId)
            {
                return checkFailed("@CashManagement:SEPACreditorMandateValidation");
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOffsetBankAccount</Name>
				<Source><![CDATA[
    private BankAccountTable getOffsetBankAccount(LedgerJournalTrans _ledgerJournalTrans, LedgerJournalType _journalType)
    {
        BankAccountTable offsetBankAccount;

        if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank)
        {
            if (_journalType == LedgerJournalType::CustPayment)
            {
                offsetBankAccount = BankAccountTable::findByLedgerDimension(_ledgerJournalTrans.OffsetLedgerDimension);
            }
            else
            {
                offsetBankAccount = BankAccountTable::find(_ledgerJournalTrans.BankAccountId);
            }
        }
        else
        {
            CustPaymModeTable custPaymMode = CustPaymModeTable::find(_ledgerJournalTrans.PaymMode);

            if (custPaymMode.FurtherPosting)
            {
                DimensionAttributeValueCombination interCompanyDimAttribute = DimensionAttributeValueCombination::find(custPaymMode.InterCompanyLedgerDimension);
                DimensionAttributeValueCombination offsetDimAttribute = DimensionAttributeValueCombination::find(_ledgerJournalTrans.OffsetLedgerDimension);

                if (interCompanyDimAttribute.MainAccount == offsetDimAttribute.MainAccount
                    && custPaymMode.AccountType == LedgerJournalACType::Bank)
                {
                    offsetBankAccount = BankAccountTable::findByLedgerDimension(custPaymMode.PaymentLedgerDimension);
                }
            }
            else
            {
                offsetBankAccount = BankAccountTable::find(_ledgerJournalTrans.BankAccountId);
            }
        }

        return offsetBankAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProgressLogger</Name>
				<Source><![CDATA[
    private SysInstrumentationProgressLogger createProgressLogger()
    {
        ModuleCustVend moduleCustVend;

        switch (classIdGet(this))
        {
            case classNum(CustSumForPaym),
                classNum(CustSumForPaymPrenote),
                classNum(CustSumForPaymRemittance):
                moduleCustVend = ModuleCustVend::Cust;
                break;

            case classNum(VendSumForPaym),
                classNum(VendSumForPaymPrenote),
                classNum(VendSumForPaymRemittance),
                classNum(VendSumForPaymPayrollDisbursement):
                moduleCustVend = ModuleCustVend::Vend;
                break;
        }

        str sourceName = CustVendInstrumentationFormatter::sourceNameWithModule(CustVendInstrumentationConstants::SourceNamePaymentGeneration, moduleCustVend);

        return SysInstrumentationProgressLogger::createLogger(sourceName, CustVendInstrumentationConstants::InstrumentationNamespace);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>