<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventAdjustPost</Name>
	<SourceCode>
		<Declaration><![CDATA[
class InventAdjustPost
{
    // <GEERU>
    #isoCountryRegionCodes
    // </GEERU>

    Voucher                         voucher;
    TransDate                       transDate;
    InventAdjustmentSpec            specification;
    LedgerTransTxt                  transTxtType;
    NoYes                           correct;
    Voucher                         offsetVoucher;

    LedgerVoucher                   ledgerVoucher;
    TransactionTxt                  transactionTxt;

    CurrencyCode                    standardCurrency;
    CurrencyCode                    currencyCode;
    NumberSequenceCode              voucherSequence;

    boolean                         adjustPurch;
    Map                             mapCustomDetailLevelRecId;
    boolean                         checkItemPostedDate;
    Set                             setItemPostedDateValidated;

    boolean                         skipConversionCheck;
    // <GEEU>
    LedgerCorrection                previousAdjustmentCorrection;   // Used in case of cancellation, to indicate whether the recalculation/adjustment was using correction.
    // </GEEU>
    Map                     mapSettlement;
    RunbaseProgress         ledgerProgress;
    boolean                 correspondenceEnable;
    UnknownNoYes            storno_RU;
    boolean                 stornoAdj;
    boolean                 parmAdjust_RU;
    LedgerTransType         ledgerTransType;
    protected boolean isTelemetryForStornoSent;
    private InventAdjustmentType inventAdjustmentType;
    #AviFiles

    private boolean isInventTransRecIdFilterShouldBeApplied_RU;
    private TmpRecIdFilter inventTransRecIdFilter_RU;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addInventAdjustPostInventTransView</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the table <c>InventAdjustPostInventTransView</c> to the <c>QueryBuildDataSource</c> object for <c>InventSettlement</c>.
    /// </summary>
    /// <param name="_qbdsInventSettlement">
    /// The <c>QueryBuildDataSource</c> object for <c>InventSettlement</c>.
    /// </param>
    /// <returns>
    /// A <c>QueryBuildDataSource</c> object.
    /// </returns>
    protected QueryBuildDataSource addInventAdjustPostInventTransView(QueryBuildDataSource _qbdsInventSettlement)
    {
        QueryBuildDataSource qbds = _qbdsInventSettlement.addDataSource(tableNum(InventAdjustPostInventTransView));
        qbds.addLink(fieldNum(InventSettlement, TransRecId), fieldNum(InventAdjustPostInventTransView, RecId));
        qbds.orderMode(OrderMode::GroupBy);
        qbds.addGroupByField(fieldNum(InventAdjustPostInventTransView, ProjId));
        qbds.addGroupByField(fieldNum(InventAdjustPostInventTransView, ProjAdjustRefId));
        qbds.addGroupByField(fieldNum(InventAdjustPostInventTransView, ProjInventTransOrigin));

        if (LedgerParameters::isStornoEnabledEE())
        {
            qbds.addGroupByField(fieldNum(InventAdjustPostInventTransView, Voucher));
            qbds.addGroupByField(fieldNum(InventAdjustPostInventTransView, DateFinancial));
            qbds.addGroupByField(fieldNum(InventAdjustPostInventTransView, SignQty));
        }
        else if (correspondenceEnable)
        {
            qbds.addGroupByField(fieldNum(InventAdjustPostInventTransView, StatusIssue));
            qbds.addGroupByField(fieldNum(InventAdjustPostInventTransView, StatusReceipt));
            qbds.addGroupByField(fieldNum(InventAdjustPostInventTransView, SignQty));
            qbds.addGroupByField(fieldNum(InventAdjustPostInventTransView, Storno_RU));
            qbds.addGroupByField(fieldNum(InventAdjustPostInventTransView, StornoPhysical_RU));
        }

        qbds.addSortIndex(indexNum(InventTrans, RecId));
        qbds.indexIsHint(true);

        return qbds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addInventSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the table <c>InventSettlement</c> to the <c>Query</c>.
    /// </summary>
    /// <param name="_q">
    /// The <c>Query</c>.
    /// </param>
    /// <returns>
    /// A <c>QueryBuildDataSource</c> object.
    /// </returns>
    protected QueryBuildDataSource addInventSettlement(Query _q)
    {
        QueryBuildDataSource qbds = _q.addDataSource(tableNum(InventSettlement));
        qbds.orderMode(OrderMode::GroupBy);
        qbds.addSelectionField(fieldNum(InventSettlement, CostAmountAdjustment), SelectionField::Sum);
        qbds.addGroupByField(fieldNum(InventSettlement, BalanceSheetPosting));
        qbds.addGroupByField(fieldNum(InventSettlement, BalanceSheetLedgerDimension));
        qbds.addGroupByField(fieldNum(InventSettlement, OperationsPosting));
        qbds.addGroupByField(fieldNum(InventSettlement, OperationsLedgerDimension));
        qbds.addGroupByField(fieldNum(InventSettlement, DefaultDimension));
        qbds.addGroupByField(fieldNum(InventSettlement, Transdate));
        if (this.mustFetchItemId())
        {
            qbds.addGroupByField(fieldNum(InventSettlement, ItemId));
        }

        if (this.mustFetchItemGroupId())
        {
            qbds.addGroupByField(fieldNum(InventSettlement, ItemGroupId));
        }
        qbds.addSortIndex(indexNum(InventSettlement, DateVoucherIdx));
        qbds.indexIsHint(true);

        return qbds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLedger</Name>
				<Source><![CDATA[
    void addLedger(
        LedgerVoucher                   _ledgerVoucher,
        LedgerPostingType               _ledgerPostingType,
        LedgerDimensionAccount          _ledgerAccount,
        DimensionDefault                _dimension,
        CostAmount                      _costAmountAdjustmentCur,
        ProjLedger                      _projLedger = null,
        RecId                           _recId                      = 0,
        CostAmount                      _costAmountAdjustmentMST_RU = 0.0,
        NoYes                           _correct                    = false

        )
    {
        if (_projLedger
         && ProjItemTrans::findInvent(_projLedger.parmInventTransId(), _projLedger.parmProjAdjustRefId()))
        {
            // <GEERU>
            if (!prmisDefault(_correct))
            {
                this.addProjectLedger(
                        _ledgerVoucher,
                        _ledgerPostingType,
                        _ledgerAccount,
                        _dimension,
                        _costAmountAdjustmentCur,
                        _projLedger,
                        _recId,
                        _correct);
            }
            else
            {
            // </GEERU>
                this.addProjectLedger(
                        _ledgerVoucher,
                        _ledgerPostingType,
                        _ledgerAccount,
                        _dimension,
                        _costAmountAdjustmentCur,
                        _projLedger,
                        _recId);
            // <GEERU>
            }
            // </GEERU>
        }
        else
        {
            LedgerVoucherObject ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();
            CurrencyExchangeHelper currencyExchHelper = this.getCurrencyExchangeHelperForNonProjectLedger(ledgerVoucherObject.parmAccountingDate());
            
            LedgerDimensionAccount dimensionAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(_ledgerAccount, _dimension);

            if (!dimensionAccount)
            {
                this.checkMainAccountValid(_ledgerAccount);
            }

            LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                      ledgerVoucherObject,
                                                                      _ledgerPostingType,
                                                                      dimensionAccount,
                                                                      currencyCode,
                                                                      _costAmountAdjustmentCur,
                                                                      currencyExchHelper);

            ledgerVoucherTransObject.parmSkipDimensionValidation(true);

            ledgerVoucherTransObject.parmProjLedger(_projLedger);
            ledgerVoucherTransObject.parmCustomTransferLevel(_recId);

            // <GEEU>
            if (!prmisDefault(_correct))
            {
                ledgerVoucherTransObject.parmCorrect(_correct);
            }
            // </GEEU>
            if (!_ledgerVoucher.addTrans(ledgerVoucherTransObject))
            {
                throw error("@SYS21533");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkMainAccountValid</Name>
				<Source><![CDATA[
    private void checkMainAccountValid(LedgerDimensionAccount _ledgerAccount)
    {
        DimensionAttributeValueCombination dimensionAttributeValueCombination = DimensionAttributeValueCombination::find(_ledgerAccount);
        if (!DimensionHierarchy::getAccountStructure(dimensionAttributeValueCombination.MainAccount))
        {
            DimensionHierarchy dimensionHierarchy = DimensionHierarchy::find(dimensionAttributeValueCombination.AccountStructure);
            MainAccount mainAccount = MainAccount::find(dimensionAttributeValueCombination.MainAccount);
                
            warning(strFmt("@SCM:CheckMainAccountErrorMessage", dimensionHierarchy.Name, mainAccount.MainAccountId, inventAdjustmentType, transDate) + ' ' + "@SCM:HardeningPeriodEndProcessTempWarningMessage");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrencyExchangeHelperForNonProjectLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>CurrencyExchangeHelper</c> class for non project ledger.
    /// </summary>
    /// <param name="_accountingDate">
    /// The transaction date.
    /// </param>
    /// <returns>
    /// An instance of the <c>CurrencyExchangeHelper</c> class.
    /// </returns>
    protected CurrencyExchangeHelper getCurrencyExchangeHelperForNonProjectLedger(TransDate _accountingDate) 
    {
        CurrencyExchangeHelper currencyExchHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), _accountingDate); 
        return currencyExchHelper; 
    }

]]></Source>
			</Method>
			<Method>
				<Name>addProjectLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds project transactions to the voucher
    /// </summary>
    /// <param name="_ledgerVoucher">
    /// The voucher where the project transactions would be added to.
    /// </param>
    /// <param name="_ledgerPostingType">
    /// The posting type that will be used for the project transaction.
    /// </param>
    /// <param name="_ledgerAccount">
    /// The ledger account that will be used for the project transaction.
    /// </param>
    /// <param name="_dimension">
    /// The dimension that will be used for the project transaction.
    /// </param>
    /// <param name="_costAmountAdjustmentCur">
    /// The amount that will be used for the project transaction.
    /// </param>
    /// <param name="_projLedger">
    /// The <c>ProjLedger</c> object that will be used for the project transaction.
    /// </param>
    /// <param name="_recId">
    /// The custom transfer level that will be used for the project transaction.
    /// </param>
    /// <param name="_correct">
    /// The correction flag that will be used for the project transaction.
    /// </param>
    protected void addProjectLedger(
        LedgerVoucher                   _ledgerVoucher,
        LedgerPostingType               _ledgerPostingType,
        LedgerDimensionAccount          _ledgerAccount,
        DimensionDefault                _dimension,
        CostAmount                      _costAmountAdjustmentCur,
        ProjLedger                      _projLedger = null,
        RecId                           _recId = 0
        , NoYes                         _correct = false
        )
    {
        MapEnumerator                   fundingAllocationEnumerator;

        LedgerVoucherObject ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();
        CurrencyExchangeHelper currencyExchHelper = this.getCurrencyExchangeHelperForProjectLedger(ledgerVoucherObject.parmAccountingDate());

        ProjItemTrans projItemTrans = ProjItemTrans::findInvent(_projLedger.parmInventTransId(), _projLedger.parmProjAdjustRefId());
        ProjTrans projTrans = ProjTrans::newProjItemTrans(projItemTrans);

        if (!projItemTrans.fundingSourceList().empty())
        {
            fundingAllocationEnumerator = ProjFundingEngine::ledgerDistributions(projItemTrans.fundingSourceList(), _costAmountAdjustmentCur, currencyCode).getEnumerator();
        }
        else
        {
            ProjFundingEngine projFundingEngine = ProjFundingEngine::construct(projTrans, _costAmountAdjustmentCur, 0);
            if (projFundingEngine.allocate())
            {
                fundingAllocationEnumerator = projFundingEngine.parmCostDistributions().getEnumerator();
            }
            else
            {
                throw error("@SYS136009");
            }
        }
        while (fundingAllocationEnumerator.moveNext())
        {
            ProjLedger tmpProjLedger = _projLedger.clone();
            tmpProjLedger.parmfundingSourceID( fundingAllocationEnumerator.currentKey() );

            if (_ledgerPostingType == LedgerPostingType::ProjNeverLedger)
            {
                ProjLedgerUpdate::newNoneLedger(tmpProjLedger,
                                                LedgerPostingType::ProjNeverLedger,
                                                _dimension,
                                                _ledgerVoucher.lastVoucher(),
                                                transDate,
                                                fundingAllocationEnumerator.currentValue()).insert();
            }
            else
            {
                ProjFundingSource projFundingSourceLocal = ProjFundingSource::find(fundingAllocationEnumerator.currentKey());
                LedgerDimensionDefaultAccount defaultLedgerDimension = projTrans.costAccountLedgerDimension(fundingAllocationEnumerator.currentKey());
                LedgerDimensionAccount mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultLedgerDimension, projTrans.defaultDimension(), projFundingSourceLocal.DefaultDimension);

                LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                          ledgerVoucherObject,
                                                                          _ledgerPostingType,
                                                                          mergedLedgerDimension,
                                                                          currencyCode,
                                                                          fundingAllocationEnumerator.currentValue(),
                                                                          currencyExchHelper);

                ledgerVoucherTransObject.parmProjLedger(tmpProjLedger);
                ledgerVoucherTransObject.parmCustomTransferLevel(_recId);
                // <GEERU>
                if (!prmisDefault(_correct))
                {
                    ledgerVoucherTransObject.parmCorrect(_correct);
                }
                // </GEERU>

                if (!_ledgerVoucher.addTrans(ledgerVoucherTransObject))
                {
                    throw error("@SYS21533");
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrencyExchangeHelperForProjectLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>CurrencyExchangeHelper</c> class for project ledger.
    /// </summary>
    /// <param name="_accountingDate">
    /// The transaction date.
    /// </param>
    /// <returns>
    /// An instance of the <c>CurrencyExchangeHelper</c> class.
    /// </returns>
    protected CurrencyExchangeHelper getCurrencyExchangeHelperForProjectLedger(TransDate _accountingDate)
    {
        CurrencyExchangeHelper currencyExchHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), _accountingDate);
        return currencyExchHelper;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcLedgerCorrection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current adjustment should be posted with the correction flag set.
    /// </summary>
    /// <param name="_inventTrans">
    /// An <c>InventTrans</c> buffer holding summarized values for the transactions being updated.
    /// </param>
    /// <param name="_amountCur">
    /// The amount of the adjustment to be posted.
    /// </param>
    /// <returns>
    /// true if the transaction should be posted with the correction flag set; otherwise, false.
    /// </returns>
    protected Correct calcLedgerCorrection(InventTrans _inventTrans, AmountCur _amountCur)
    {
        LedgerCorrection    ledgerCorrection;

        if (!correct)
        {
            // Not running as correction, bail out.
            return false;
        }

        if (!LedgerParameters::isStornoEnabledEE())
        {
            // Special correction handling for Eastern Europe is not enabled. Use standard behavior.
            return correct;
        }

        boolean isCancellation               = this is InventAdjustPostClosingCancel;
        boolean wasPriorAdjustmentCorrection = this.parmPreviousAdjustmentCorrection();
        boolean sameSignAdjustment           = (_amountCur < 0 && _inventTrans.Qty < 0) || (_amountCur >= 0 && _inventTrans.Qty >= 0);
        boolean wasOriginalCorrection        = this.wasOriginalTransStorno(_inventTrans);

        switch (true)
        {
            case !isCancellation:
            case isCancellation && wasPriorAdjustmentCorrection:
                // This logic is similar to the non-cancellation scenario. This is because in this case we want "corretion" to be !previous correction.
                //  However in this scenario the sign will be opposite of the sign in the previous transaction, so that will already ensure we get the correct value.
                ledgerCorrection = (sameSignAdjustment && wasOriginalCorrection) || (!sameSignAdjustment && !wasOriginalCorrection);
                break;

            case isCancellation && !wasPriorAdjustmentCorrection:
                // If we are cancelling a transaction that was not posted as Storno, then we must apply storno principles now
                ledgerCorrection = true;
                break;
        }

        return ledgerCorrection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkItemPostedDate</Name>
				<Source><![CDATA[
    protected boolean checkItemPostedDate(ItemId _itemId, TransDate _transDate)
    {
        if (skipConversionCheck == true)
        {
            return true;
        }

        if (!setItemPostedDateValidated)
        {
            setItemPostedDateValidated = new Set(new DictType(extendedTypeNum(ItemId)).baseType());
        }

        if (!checkItemPostedDate)
        {
            return true;
        }

        if (setItemPostedDateValidated.in(_itemId))
        {
            return true;
        }

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) &&
            !InventStdCostConv::checkItemPostingDate(_itemId, _transDate, this.inventTransCurrency_RU()))
        {
            return false;
        }
        else
        // </GEERU>
        if (!InventStdCostConv::checkItemPostingDate(_itemId, _transDate))
        {
            return false;
        }

        setItemPostedDateValidated.add(_itemId);

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createUpdateItemQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prepares the query for the invent settlement fetching.
    /// </summary>
    /// <param name="_processPositiveAdjustment">
    /// The flag shows that query should process the settlements with positive amount adjustments; optional.
    /// </param>
    /// <returns>
    /// The query for the updateItme method.
    /// </returns>
    /// <remarks>
    /// The <paramref name="_processPositiveAdjustment" /> is only relevant if Russian Correspondence sets on.
    /// </remarks>
    protected Query createUpdateItemQuery(boolean _processPositiveAdjustment = true)
    {
        Query query = new Query();
        QueryBuildDataSource qbdsInventSettlement = this.addInventSettlement(query);
        this.addInventAdjustPostInventTransView(qbdsInventSettlement);

        QueryBuildRange costAmountAdjustmentRange = qbdsInventSettlement.addRange(fieldNum(InventSettlement, CostAmountAdjustment));
        str strValue = '!0';

        if (correspondenceEnable)
        {
            qbdsInventSettlement.addRange(fieldNum(InventSettlement, InventTransCurrency_RU)).value(queryValue(this.inventTransCurrency_RU()));

            strValue = _processPositiveAdjustment ? '>0' : '<0';
        }

        costAmountAdjustmentRange.value(queryValue(strValue));
        qbdsInventSettlement.addRange(fieldNum(InventSettlement, Posted)).value(queryValue(NoYes::No));
        this.setInventSettlementRanges(qbdsInventSettlement);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCheckItemPostedDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the variable <c>checkItemPostedDate</c>.
    /// </summary>
    /// <param name="_transDate">
    /// The transaction date.
    /// </param>
    protected void initCheckItemPostedDate(TransDate _transDate)
    {
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            checkItemPostedDate = InventStdCostConv::mustCheckItemPostingDate(_transDate, this.inventTransCurrency_RU());
        }
        else
        {
        // </GEERU>
            checkItemPostedDate = InventStdCostConv::mustCheckItemPostingDate(_transDate);
        // <GEERU>
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a <c>ledgervoucher</c> object.
    /// </summary>
    protected void initLedgerVoucher()
    {
        ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Summary,
                                                             SysModule::Invent,
                                                             voucherSequence);
        ledgerVoucher.parmCustomDetailLevel(true);  // records are summed according to ledgerVoucherTransObject.parmRecId
        LedgerVoucherObject ledgerVoucherObject = LedgerVoucherObject::newVoucher(voucher,
                                                                                  transDate,
                                                                                  SysModule::Invent,
                                                                                  LedgerTransType::Invent,
                                                                                  correct);
        ledgerVoucherObject.lastTransTxt(transactionTxt.txt());
        ledgerVoucher.addVoucher(ledgerVoucherObject);
        // <GEERU>
        if (! correspondenceEnable)
        {
            ledgerVoucher.parmCheckTransOnInsert(true);
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucherExt</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calls the protected methods to initialize a <c>LedgerVoucher</c> object.
    /// </summary>
    /// <returns>
    ///    The protected methods will be used to initialize the ledger voucher. The ledger voucher will then
    ///    be returned. Transactions can be added to this ledger voucher and will be posted during the
    ///    <c>updateNow</c> method.
    /// </returns>
    public LedgerVoucher initLedgerVoucherExt()
    {
        this.initTransactionTxt();

        this.initLedgerVoucher();

        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initProgress_RU</Name>
				<Source><![CDATA[
    void initProgress_RU()
    {
        ledgerProgress = new RunbaseProgress();

        ledgerProgress.setCaption("@SYS17508");
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTransactionTxt</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the transaction text.
    /// </summary>

    protected void initTransactionTxt()
    {
        transactionTxt  = TransactionTxt::construct();
        transactionTxt.setType(transTxtType);
        transactionTxt.setDate(transDate);
        transactionTxt.setVoucher(voucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransCurrency_RU</Name>
				<Source><![CDATA[
    protected InventTransCurrency_RU inventTransCurrency_RU()
    {
        return InventTransCurrency_RU::PrimaryCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerBondClient_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns current <c>LedgerBondClient_RU</c> for the <c>LedgerVoucherObject</c> in <c>OperationsTax::Current</c> or <c>OperationsTax::WarehouseCur_RU</c> posting layers.
    /// </summary>
    /// <returns>
    /// The <c>LedgerBondClient_RU</c> instance for the <c>LedgerVoucherObject</c>.
    /// </returns>
    protected LedgerBondClient_RU ledgerBondClient_RU()
    {
        LedgerBondClient_RU ledgerBondClient;

        if (this.inventTransCurrency_RU() == InventTransCurrency_RU::PrimaryCur)
        {
            ledgerBondClient = ledgerVoucher.findLedgerVoucherObject().ledgerBondClient_RU();
        }
        else
        {
            ledgerBondClient = ledgerVoucher.findOrCreateReferenceSecCur_RU().ledgerBondClient_RU();
            ledgerVoucher.restoreReferenceSecCur_RU();
        }

        return ledgerBondClient;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustFetchItemGroupId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if <c>InventSettlement.ItemGroupId</c> must be fetched.
    /// </summary>
    /// <returns>
    /// true if <c>InventSettlement.ItemGroupId</c> must be fetched; otherwise false.
    /// </returns>
    protected boolean mustFetchItemGroupId()
    {
        return specification == InventAdjustmentSpec::ItemNum || specification == InventAdjustmentSpec::ItemGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustFetchItemId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if <c> InventSettlement.ItemId </c> must be fetched.
    /// </summary>
    /// <returns>
    /// true if <c>InventSettlement.ItemId</c> must be fetched; otherwise false.
    /// </returns>
    protected boolean mustFetchItemId()
    {
        return adjustPurch ||
               specification == InventAdjustmentSpec::ItemNum ||
               correspondenceEnable ||
               checkItemPostedDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new(Voucher                _voucher,
             TransDate              _transDate,
             InventAdjustmentSpec   _specification,
             LedgerTransTxt         _transTxtType,
             NoYes                  _correct            = NoYes::No,
             Voucher                _offsetVoucher      = '',
             boolean                _onClosingDate      = false,
             boolean                _checkOpen          = true,
             NumberSequenceCode     _voucherSequence    = ''
            )
    {
        voucher            = _voucher;
        transDate          = _transDate;
        specification      = _specification;
        transTxtType       = _transTxtType;
        correct            = _correct;
        offsetVoucher      = _offsetVoucher;
        voucherSequence    = _voucherSequence;

        standardCurrency   = CompanyInfoHelper::standardCurrency();
        currencyCode       = standardCurrency;
        adjustPurch        = false;

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            if (_checkOpen && !InventClosing::checkOpen(transDate, _onClosingDate, this.inventTransCurrency_RU()))
            {
                throw error("@SYS18447");
            }
        }
        else
        {
        // </GEERU>
            if (_checkOpen && !InventClosing::checkOpen(transDate,_onClosingDate))
            {
                throw error("@SYS18447");
            }
        // <GEERU>
        }
        // </GEERU>

        // <GEERU>
        correspondenceEnable = LedgerParameters::find().Correspondence_RU == NoYes::Yes;
        if (correspondenceEnable)
        {
            InventTransDirection::initAllRecords();
            mapSettlement = new Map(Types::Container, Types::Container);
        }

        ledgerTransType = LedgerTransType::ExchAdjustment;
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjLedger_RU</Name>
				<Source><![CDATA[
    protected ProjLedger newProjLedger_RU(ProjId            _projId,
                                          InventTransId     _inventTransId,
                                          ProjAdjustRefId   _projAdjustRefId)
    {
        ProjLedger    projLedger;

        if (_projId)
        {
            ProjItemTrans projItemTrans = ProjItemTrans::findInvent(_inventTransId, _projAdjustRefId);

            projLedger = ProjLedger::newInventCost(_projId,
                                                   projItemTrans.ActivityNumber,
                                                   projItemTrans.CategoryId,
                                                   _inventTransId,
                                                   _projAdjustRefId,
                                                   projItemTrans.TransactionOrigin,
                                                   ProjOrigin::InventoryClosing,
                                                   projItemTrans.ItemId,
                                                   false,
                                                   projItemTrans.TransDate);
        }

        return projLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAdjust_RU</Name>
				<Source><![CDATA[
    public boolean parmAdjust_RU(boolean _parmAdjust_RU = parmAdjust_RU)
    {
        parmAdjust_RU = _parmAdjust_RU;
        return parmAdjust_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAdjustPurch</Name>
				<Source><![CDATA[
    public boolean parmAdjustPurch(boolean _adjustPurch  = adjustPurch)
    {
        adjustPurch = _adjustPurch;
        return adjustPurch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventAdjustType</Name>
				<Source><![CDATA[
    public boolean parmInventAdjustType(InventAdjustmentType _adjustType  = inventAdjustmentType)
    {
        inventAdjustmentType = _adjustType;
        return inventAdjustmentType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCurrencyCode</Name>
				<Source><![CDATA[
    public CurrencyCode parmCurrencyCode(CurrencyCode _currencyCode  = currencyCode)
    {
        currencyCode = _currencyCode;
        return currencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerTransType_RU</Name>
				<Source><![CDATA[
    public LedgerTransType parmLedgerTransType_RU(LedgerTransType _ledgerTransType = ledgerTransType)
    {
        ledgerTransType = _ledgerTransType;
        return ledgerTransType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPreviousAdjustmentCorrection</Name>
				<Source><![CDATA[
    public LedgerCorrection parmPreviousAdjustmentCorrection(LedgerCorrection _previousAdjustmentCorrection = previousAdjustmentCorrection)
    {
        previousAdjustmentCorrection = _previousAdjustmentCorrection;

        return previousAdjustmentCorrection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipConversionCheck</Name>
				<Source><![CDATA[
    public boolean parmSkipConversionCheck(boolean _skipConversionCheck = skipConversionCheck)
    {
        skipConversionCheck = _skipConversionCheck;

        return skipConversionCheck;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmStorno_RU</Name>
				<Source><![CDATA[
    public boolean parmStorno_RU(boolean _storno_RU = storno_RU == UnknownNoYes::Yes)
    {
        if (!prmisDefault(_storno_RU))
        {
            storno_RU = _storno_RU ? UnknownNoYes::Yes : UnknownNoYes::No;
        }

        return storno_RU == UnknownNoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucherSequence</Name>
				<Source><![CDATA[
    public NumberSequenceCode parmVoucherSequence(NumberSequenceCode _voucherSequence = voucherSequence)
    {
        voucherSequence = _voucherSequence;

        return voucherSequence;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processInventSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Process an <c>InventTrans</c> and <c>InventSettlement</c> record.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The <c>InventTrans</c> record that must be processed.
    /// </param>
    /// <param name="_inventSettlement">
    ///    The <c>InventSettlement</c> record that must be posted.
    /// </param>
    /// <remarks>
    ///    This method is used from the <c>updateItem</c> methods in the class hierarchy to post the
    ///    adjustments.
    /// </remarks>
    protected void processInventSettlement(InventTrans      _inventTrans,
                                           InventSettlement _inventSettlement)
    {
        ProjLedger              projLedger;

        if (!this.checkItemPostedDate(_inventSettlement.ItemId, _inventSettlement.TransDate))
        {
            throw error("@SYS18447");
        }

        // <GEERU>
        this.setTransactionText(_inventSettlement);

        if (correspondenceEnable)
        {
            this.updateMap_RU(_inventSettlement, _inventTrans);
            return;
        }
        // </GEERU>

        if (_inventTrans.ProjId)
        {
            projLedger = ProjLedger::newInventCostAdjust(_inventTrans.ProjId,
                                                         _inventTrans.inventTransOrigin().InventTransId,
                                                         _inventTrans.ProjAdjustRefId,
                                                         ProjOrigin::InventoryClosing);
        }
        else
        {
            projLedger = null;
        }

        // <GEEU>
        this.updateTrans(_inventSettlement, ledgerVoucher, projLedger, _inventTrans);
        // </GEEU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventSettlementRanges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets query ranges on the datasource of update item query.
    /// </summary>
    /// <param name="_qbdsInventSettlement">
    /// The datasource to be processed.
    /// </param>
    protected void setInventSettlementRanges(QueryBuildDataSource _qbdsInventSettlement)
    {
        _qbdsInventSettlement.addRange(fieldNum(InventSettlement, TransDate)).value(queryValue(transDate));
        _qbdsInventSettlement.addRange(fieldNum(InventSettlement, Voucher)).value(queryValue(voucher));
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransactionText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the transaction text.
    /// </summary>
    /// <param name="_inventSettlement">
    /// The <c>InventSettlement</c> record being processed.
    /// </param>
    protected void setTransactionText(InventSettlement _inventSettlement)
    {
        switch (specification)
        {
            case InventAdjustmentSpec::ItemNum:
                transactionTxt.setKey2(_inventSettlement.ItemId);
                //break continue
            case InventAdjustmentSpec::ItemGroup:
                transactionTxt.setKey1(_inventSettlement.ItemGroupId);
                ledgerVoucher.findLedgerVoucherObject().lastTransTxt(transactionTxt.txt());
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Selects inventory settlements to process.
    /// </summary>
    /// <remarks>
    ///    This method will select the <c>inventSettlements</c> group by accounts to add them to the ledger
    ///    postings.
    /// </remarks>
    protected void updateItem()
    {
        InventSettlement inventSettlement;
        InventTrans inventTrans;
        boolean processPositiveAdjustment = true;

        do
        {
            QueryRun qr = new QueryRun(this.createUpdateItemQuery(processPositiveAdjustment));

            this.applyInventTransRecIdFilter_RU(qr);

            while (qr.next())
            {
                if (qr.changed(tableNum(inventSettlement)))
                {
                    inventSettlement  = qr.get(tableNum(inventSettlement));
                }

                if (qr.changed(tableNum(InventAdjustPostInventTransView)))
                {
                    InventAdjustPostInventTransView inventAdjustPostInventTransView = qr.get(tableNum(InventAdjustPostInventTransView));
                    inventTrans = inventAdjustPostInventTransView.inventTrans();
                }

                this.processInventSettlement(inventTrans, inventSettlement);
            }

            processPositiveAdjustment = !processPositiveAdjustment;

        } while (correspondenceEnable && !processPositiveAdjustment);

        this.updateTrans_RU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMap_RU</Name>
				<Source><![CDATA[
    protected void updateMap_RU(InventSettlement        _inventSettlement,
                                InventTrans             _inventTrans)
    {
        AmountCur           costAmountAdjustmentCur;

        Amount              curAmount, mstAmount;

        if (! (_inventSettlement.OperationsPosting || _inventSettlement.BalanceSheetPosting))
        {
            return;
        }

        if (! mapSettlement)
        {
            mapSettlement = new Map(Types::Container, Types::Container);
        }

        _inventSettlement.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(_inventSettlement.DefaultDimension, InventTable::find(_inventSettlement.ItemId).DefaultDimension);

        if (currencyCode                  != standardCurrency &&
            this.inventTransCurrency_RU() == InventTransCurrency_RU::PrimaryCur)
        {
            costAmountAdjustmentCur = CurrencyExchangeHelper::curAmount(_inventSettlement.CostAmountAdjustment, currencyCode, transDate);
        }
        else
        {
            costAmountAdjustmentCur = _inventSettlement.CostAmountAdjustment;
        }

        InventModelGroup inventModelGroup = InventTable::find(_inventSettlement.ItemId).modelGroup();

        InventModelType inventModelType = this.inventTransCurrency_RU() == InventTransCurrency_RU::PrimaryCur ?
                                          inventModelGroup.inventModelType()                                  :
                                          inventModelGroup.inventModelTypeSecCur_RU();

        InventTransID inventTransId;

        if (_inventTrans.ProjId)
        {
            inventTransId = _inventTrans.inventTransOrigin().InventTransId;
        }

        // update map
        container cont = [ _inventSettlement.BalanceSheetPosting,
                 _inventSettlement.OperationsPosting,
                 _inventSettlement.BalanceSheetLedgerDimension,
                 _inventSettlement.OperationsLedgerDimension,
                 _inventSettlement.DefaultDimension,
                 currencyCode,
                 inventModelGroup.StandardCost || inventModelType.stdCostBased(),
                 _inventTrans.isUpdatedFinancial() ? _inventTrans.Storno_RU : _inventTrans.StornoPhysical_RU,
                 _inventTrans.Qty > 0,
                 _inventSettlement.CostAmountAdjustment > 0,
                 _inventTrans.ProjId,
                 inventTransId,
                 _inventTrans.ProjAdjustRefId];

        if (stornoAdj && storno_RU != UnknownNoYes::Unknown && _inventTrans.Storno_RU)
        {
            if (!isTelemetryForStornoSent)
            {
                isTelemetryForStornoSent = true;
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceRU00114, funcName());
            }
        }

        if (mapSettlement.exists(cont))
        {
            [mstAmount, curAmount] = mapSettlement.lookup(cont);
        }
        else
        {
            mstAmount = 0;
            curAmount = 0;
        }

        mapSettlement.insert(cont, [mstAmount + _inventSettlement.CostAmountAdjustment, curAmount + costAmountAdjustmentCur]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNow</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Handles the postings of inventory adjustments.
    /// </summary>
    /// <param name="_ledgerVoucher">
    ///    The ledger voucher to which the postings should be added; optional.
    /// </param>
    /// <param name="_initLedger">
    ///    A Boolean value that indicates whether the ledger voucher should be posted; optional.
    /// </param>
    /// <remarks>
    ///    When no ledger voucher is given, <paramref name="_initLedger" /> will be set to true and the
    ///    voucher will be posted.
    /// </remarks>
    public void updateNow(LedgerVoucher _ledgerVoucher = null,
                          boolean       _initLedger    = false)
    {
        boolean                 initLedger = _initLedger;
        TransactionTextLarge    transTxt;

        ledgerVoucher = _ledgerVoucher;

        this.initTransactionTxt();

        if (! ledgerVoucher)
        {
            this.initLedgerVoucher();
            initLedger = true;
        }
        else
        {
            transTxt = ledgerVoucher.findLedgerVoucherObject().lastTransTxt();
        }
        // <GEERU>
        if (! ledgerProgress)
        {
           this.initProgress_RU();
        }
        // </GEERU>

        if (ledgerVoucher.parmDetailSummary()   == DetailSummary::Summary           &&
            (specification                      == InventAdjustmentSpec::ItemGroup  ||
             specification                      == InventAdjustmentSpec::ItemNum))
        {
            ledgerVoucher.parmCustomDetailLevel(true);  // records are summed according to ledgerVoucherTransObject.parmRecId
            mapCustomDetailLevelRecId = new Map(Types::String,Types::Integer);
        }

        // <GEERU>
        stornoAdj = InventParameters::find().StornoAdjPosting;
        // </GEERU>

        this.initCheckItemPostedDate(transDate);

        this.updateItem();

        // Add the indirect costs of open production orders to the ledger voucher
        this.updateProduction();

        this.updatePosted();

        if (initLedger)
        {
            ledgerVoucher.end();
            ProjPost::inventAdjustPost(ledgerVoucher.findLedgerVoucherObject().parmAccountingDate(),
                ledgerVoucher.findLedgerVoucherObject().parmVoucher());
        }
        else
        {
            ledgerVoucher.findLedgerVoucherObject().lastTransTxt(transTxt);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePosted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the state of posted <c>InventSettlement</c> records.
    /// </summary>
    protected void updatePosted()
    {
        InventSettlement inventSettlement;

        inventSettlement.skipDataMethods(true);

        if (isInventTransRecIdFilterShouldBeApplied_RU)
        {
            update_recordset inventSettlement
                setting Posted = NoYes::Yes
                where inventSettlement.TransDate                    == transDate    &&
                      inventSettlement.Voucher                      == voucher      &&
                      // <GEERU>
                      inventSettlement.InventTransCurrency_RU       == this.inventTransCurrency_RU() &&
                      // </GEERU>
                      inventSettlement.CostAmountAdjustment         != 0            &&
                      inventSettlement.Posted                       == NoYes::No    &&
                      (inventSettlement.BalanceSheetLedgerDimension != 0
                      || inventSettlement.OperationsLedgerDimension    != 0)
            exists join inventTransRecIdFilter_RU
                where inventTransRecIdFilter_RU.RefRecId == inventSettlement.TransRecId;
        }
        else
        {
            update_recordset inventSettlement
                setting Posted = NoYes::Yes
                where inventSettlement.TransDate                    == transDate    &&
                      inventSettlement.Voucher                      == voucher      &&
                      // <GEERU>
                      inventSettlement.InventTransCurrency_RU       == this.inventTransCurrency_RU() &&
                      // </GEERU>
                      inventSettlement.CostAmountAdjustment         != 0            &&
                      inventSettlement.Posted                       == NoYes::No    &&
                      (inventSettlement.BalanceSheetLedgerDimension != 0
                      || inventSettlement.OperationsLedgerDimension    != 0);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProduction</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Handles the posting of production indirect costs.
    /// </summary>
    /// <remarks>
    ///    This method is overwritten in the child classes and will then handle the posting of the production
    ///    indirect costs.
    /// </remarks>
    protected void updateProduction()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProgress_RU</Name>
				<Source><![CDATA[
    void updateProgress_RU(ItemId _itemId)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates a ledger and project with the inventory settlement.
    /// </summary>
    /// <param name="_inventSettlement">
    ///    The inventory settlement.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The ledger voucher.
    /// </param>
    /// <param name="_projLedger">
    ///    A <c>ProjLedger</c> object.
    /// </param>
    /// <param name="_inventTrans">
    ///    An <c>InventTrans</c> buffer holding sumamrized values for the transactions being updated.
    /// </param>
    protected void updateTrans(
        InventSettlement        _inventSettlement,
        LedgerVoucher           _ledgerVoucher,
        ProjLedger              _projLedger,
        InventTrans             _inventTrans
        )
    {
        AmountCur               costAmountAdjustmentCur;
        // <GEERU>
        // </GEERU>
        // <GEERU>
        // </GEERU>

        setPrefix(#PreFixField(_InventSettlement,itemId));

        InventTable inventTable = InventTable::find(_inventSettlement.ItemId);
        ProjItemTrans projItemTrans = _projLedger ? ProjItemTrans::findInvent(_projLedger.parmInventTransId(), _projLedger.parmProjAdjustRefId()) : null;

        // <GEERU>
        if (currencyCode                  != standardCurrency &&
            this.inventTransCurrency_RU() == InventTransCurrency_RU::PrimaryCur)
        // </GEERU>
        {
            costAmountAdjustmentCur = CurrencyExchangeHelper::curAmount(_inventSettlement.CostAmountAdjustment, currencyCode, transDate);
        }
        else
        {
            costAmountAdjustmentCur = _inventSettlement.CostAmountAdjustment;
        }

        RecId customDetailLevelRecId = InventAdjustPost::inventAdjustmentSpecRecId(specification, inventTable, InventItemGroup::find(_inventSettlement.ItemGroupId));

        // <GEEU>
        LedgerCorrection ledgerCorrection = this.calcLedgerCorrection(_inventTrans, costAmountAdjustmentCur);
        // </GEEU>

        if (adjustPurch)
        {
            if (_inventSettlement.BalanceSheetPosting)
            {
                this.addLedger( ledgerVoucher,
                               _inventSettlement.BalanceSheetPosting,
                               _inventSettlement.BalanceSheetLedgerDimension,
                               _inventSettlement.DefaultDimension,
                               costAmountAdjustmentCur,
                               null,
                               // <GEEU>
                               customDetailLevelRecId,
                               0.0,
                               ledgerCorrection
                               // </GEEU>
                               );

                InventModelGroup inventModelGroup = inventTable.modelGroup();
                // <GEERU>
                InventModelType inventModelType = this.inventTransCurrency_RU() == InventTransCurrency_RU::PrimaryCur ?
                                                    inventModelGroup.inventModelType()                                  :
                                                    inventModelGroup.inventModelTypeSecCur_RU();
                // </GEERU>
                if (_inventSettlement.OperationsPosting &&
                    // <GEERU>
                    (inventModelGroup.StandardCost || !inventModelType.mustBeClosed()))
                    // </GEERU>
                {
                    this.addLedger( ledgerVoucher,
                                   _inventSettlement.OperationsPosting,
                                   _inventSettlement.OperationsLedgerDimension,
                                   _inventSettlement.DefaultDimension,
                                   -costAmountAdjustmentCur,
                                   null,
                                   // <GEEU>
                                   customDetailLevelRecId,
                                   0.0,
                                   ledgerCorrection
                                   // </GEEU>
                                   );
                }
            }
            else
            {
                if (_inventSettlement.OperationsPosting)
                {
                    this.addLedger( ledgerVoucher,
                                   _inventSettlement.OperationsPosting,
                                   _inventSettlement.OperationsLedgerDimension,
                                   _inventSettlement.DefaultDimension,
                                    costAmountAdjustmentCur,
                                   _projLedger,
                                   // <GEEU>
                                   customDetailLevelRecId,
                                   0.0,
                                   ledgerCorrection
                                   // </GEEU>
                                   );
                }
                else if (_projLedger && projItemTrans)
                {
                    this.addLedger( ledgerVoucher,
                                   LedgerPostingType::ProjNeverLedger,
                                   0,
                                   _inventSettlement.DefaultDimension,
                                    costAmountAdjustmentCur,
                                   _projLedger
                                   );
                }
            }
        }
        else
        {
            if (_inventSettlement.BalanceSheetPosting)
            {
                this.addLedger( ledgerVoucher,
                               _inventSettlement.BalanceSheetPosting,
                               _inventSettlement.BalanceSheetLedgerDimension,
                               _inventSettlement.DefaultDimension,
                                costAmountAdjustmentCur,
                               null,
                               // <GEEU>
                               customDetailLevelRecId,
                               0.0,
                               ledgerCorrection
                               // </GEEU>
                               );
            }

            if (_inventSettlement.OperationsPosting)
            {
                this.addLedger( ledgerVoucher,
                               _inventSettlement.OperationsPosting,
                               _inventSettlement.OperationsLedgerDimension,
                               _inventSettlement.DefaultDimension,
                             -  costAmountAdjustmentCur,
                               _projLedger,
                               // <GEEU>
                               customDetailLevelRecId,
                               0.0,
                               ledgerCorrection
                               // </GEEU>
                              );
            }
            else if (_projLedger && projItemTrans)
            {
                this.addLedger(ledgerVoucher,
                               LedgerPostingType::ProjNeverLedger,
                               0,
                               _inventSettlement.DefaultDimension,
                               -costAmountAdjustmentCur,
                               _projLedger
                               );
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTrans_RU</Name>
				<Source><![CDATA[
    protected void updateTrans_RU()
    {
        LedgerPostingType           postingTypeBalance, postingTypeOperation;
        CostAmount                  costAmountAdjustmentCur;
        CostAmount                  costAmountAdjustment;

        // Other container fields
        LedgerDimensionAccount      balanceSheetAccount;
        LedgerDimensionAccount      operationsAccount;
        DimensionDefault            dimension;
        CurrencyCode                conCurrencyCode;
        boolean                     standardCost;
        Storno_RU                   contStorno;
        boolean                     receipt;
        boolean                     isPosAdj;

        ProjId                      projId;
        InventTransId               inventTransId;
        ProjAdjustRefId             projAdjustRefId;
        ProjLedger                  projLedger;

        void insert(LedgerPostingType      _postingType,
                    LedgerDimensionAccount _ledgerAccount,
                    Sign                   _sign = 1)
        {
            boolean stornoCorrect;

            if (stornoAdj && (storno_RU == UnknownNoYes::Yes || (storno_RU == UnknownNoYes::Unknown && !parmAdjust_RU && !adjustPurch)))
            {
                if (storno_RU == UnknownNoYes::Yes)
                {
                    stornoCorrect = (costAmountAdjustmentCur < 0 && !contStorno) ||
                                    (costAmountAdjustmentCur > 0 &&  contStorno);
                }
                else
                {
                    stornoCorrect = (costAmountAdjustmentCur > 0 && !contStorno) ||
                                    (costAmountAdjustmentCur < 0 &&  contStorno);

                    if (receipt)
                    {
                        stornoCorrect = !stornoCorrect;
                    }
                }

                this.addLedger(ledgerVoucher,
                               _postingType,
                               _ledgerAccount,
                               dimension,
                               _sign * costAmountAdjustmentCur,
                               _ledgerAccount == operationsAccount ? projLedger : null,
                               0,
                               _sign * costAmountAdjustment,
                               stornoCorrect);
            }
            else
            {
                this.addLedger(ledgerVoucher,
                               _postingType,
                               _ledgerAccount,
                               dimension,
                               _sign * costAmountAdjustmentCur,
                               _ledgerAccount == operationsAccount ? projLedger : null,
                               0,
                               _sign * costAmountAdjustment);
            }
        }

        if (! correspondenceEnable)
        {
            return;
        }

        LedgerBondClient_RU ledgerBondClient = this.ledgerBondClient_RU();
        if (ledgerBondClient)
        {
            ledgerBondClient.addNewLogObject();
        }

        MapEnumerator me = mapSettlement.getEnumerator();
        while (me.moveNext())
        {
            [postingTypeBalance,
            postingTypeOperation,
            balanceSheetAccount,
            operationsAccount,
            dimension,
            conCurrencyCode,
            standardCost,
            contStorno,
            receipt,
            isPosAdj,
            projId,
            inventTransId,
            projAdjustRefId]      = me.currentKey();

            setPrefix(strFmt('%1: %2', "@SYS17629", postingTypeOperation));

            if (ledgerBondClient)
            {
                ledgerBondClient.addNewLogObject();
            }

            [costAmountAdjustment, costAmountAdjustmentCur] = me.currentValue();

            if (projId)
            {
                projLedger = this.newProjLedger_RU(projId,
                                                    inventTransId,
                                                    projAdjustRefId);
            }
            else
            {
                projLedger = null;
            }

            if (this.parmAdjustPurch())
            {
                if (postingTypeBalance)
                {
                    insert(postingTypeBalance, balanceSheetAccount);
                    if (postingTypeOperation && standardCost)
                    {
                        insert(postingTypeOperation, operationsAccount, -1);
                    }
                }
                else
                {
                    if (postingTypeOperation)
                    {
                        insert(postingTypeOperation, operationsAccount);
                    }
                    else if (projId)
                    {
                        ProjLedgerUpdate::newNoneLedger(this.newProjLedger_RU(projId,
                                                                              inventTransId,
                                                                              projAdjustRefId),
                                                        LedgerPostingType::ProjNeverLedger,
                                                        dimension,
                                                        ledgerVoucher.lastVoucher(),
                                                        transDate,
                                                        costAmountAdjustmentCur).insert();
                    }
                }
            }
            else
            {
                if (postingTypeBalance)
                {
                    insert(postingTypeBalance, balanceSheetAccount);
                }

                if (postingTypeOperation)
                {
                    insert(postingTypeOperation, operationsAccount, -1);
                }
                else if (projId)
                {
                    ProjLedgerUpdate::newNoneLedger(this.newProjLedger_RU(projId,
                                                                          inventTransId,
                                                                          projAdjustRefId),
                                                    LedgerPostingType::ProjNeverLedger,
                                                    dimension,
                                                    ledgerVoucher.lastVoucher(),
                                                    transDate,
                                                    -costAmountAdjustmentCur).insert();
                }
            }

            if (ledgerBondClient)
            {
                if (ledgerBondClient.currentLogLength() == 2)
                {
                    ledgerBondClient.bondLastVRef2CurrentLog();
                }
                ledgerBondClient.removeCurrentLogObject();
            }
        }

        ledgerProgress.setText("@SYS70093" + '. ' + "@GLS100945");

        if (ledgerBondClient)
        {
            if (ledgerBondClient.currentLogLength())
            {
                ledgerBondClient.bondLog2Log();
            }
            ledgerBondClient.removeCurrentLogObject();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>wasOriginalTransStorno</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the financial voucher for the transaction being corrected was originally posted as
    /// correction.
    /// </summary>
    /// <param name="_inventTrans">
    /// An <c>InventTrans</c> buffer holding summarized values for the transactions being updated.
    /// </param>
    /// <returns>
    /// true if the transaction was originally posted as correction; otherwise, false.
    /// </returns>
    protected boolean wasOriginalTransStorno(InventTrans _inventTrans)
    {
        SubledgerVoucherGeneralJournalEntry     subledgerVoucherGeneralJournalEntry;
        GeneralJournalAccountEntry              generalJournalAccountEntry;

        if (!_inventTrans.Voucher)
        {
            // Not posted financially
            return false;
        }

        select firstonly GeneralJournalEntry from generalJournalAccountEntry
            where generalJournalAccountEntry.IsCorrection
               && generalJournalAccountEntry.PostingType == _inventTrans.postingBalanceSheet()
            exists join subledgerVoucherGeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalAccountEntry.GeneralJournalEntry
                    && subledgerVoucherGeneralJournalEntry.Voucher == _inventTrans.Voucher
                    && subledgerVoucherGeneralJournalEntry.AccountingDate == _inventTrans.DateFinancial
                    && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == _inventTrans.DataAreaId;

        return generalJournalAccountEntry.GeneralJournalEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPostProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if transactions with project exists.
    /// </summary>
    /// <param name="voucher">
    /// Voucher to check for.
    /// </param>
    /// <param name="transDate">
    /// Transaction date to check.
    /// </param>
    /// <returns>
    /// Returns true if transactions with project exists; otherwise, false.
    /// </returns>
    static boolean checkPostProject(
        Voucher          voucher,
        TransDate        transDate
        )
    {
        InventSettlement        inventSettlement;
        InventTrans             inventTrans;

        select firstonly inventSettlement
            where inventSettlement.TransDate            == transDate    &&
                  inventSettlement.Voucher              == voucher      &&
                  inventSettlement.CostAmountAdjustment != 0            &&
                  inventSettlement.Posted               == NoYes::No
            exists join inventTrans
            where inventTrans.RecId == inventSettlement.TransRecId
               && inventTrans.ProjId;

        if (inventSettlement)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventAdjustmentSpecRecId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a record ID for the given specification.
    /// </summary>
    /// <param name="_inventAdjustmentSpec">
    ///    The specification.
    /// </param>
    /// <param name="_inventTable">
    ///    An <c>InventTable</c> buffer.
    /// </param>
    /// <param name="_inventItemGroup">
    ///    An <c>InventItemGroup</c> buffer; optional.
    /// </param>
    /// <returns>
    ///    The record ID for the specification.
    /// </returns>
    static public RecId inventAdjustmentSpecRecId(
        InventAdjustmentSpec    _inventAdjustmentSpec,
        InventTable             _inventTable,
        InventItemGroup         _inventItemGroup = null)
    {
        switch (_inventAdjustmentSpec)
        {
            case InventAdjustmentSpec::ItemNum:
                return _inventTable.RecId;

            case InventAdjustmentSpec::ItemGroup:
                if (_inventItemGroup.RecId)
                {
                    return _inventItemGroup.RecId;
                }
                else
                {
                    // When the settlement is initialized from InventTrans it takes the the ItemGroupId from InventTable.
                    return _inventTable.itemGroup().RecId;
                }
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromCurrency_RU</Name>
				<Source><![CDATA[
    static InventAdjustPost newFromCurrency_RU(
        Voucher                _voucher,
        TransDate              _transDate,
        InventAdjustmentSpec   _specification,
        LedgerTransTxt         _transTxtType,
        InventTransCurrency_RU _inventTransCurrency)
    {
        var factoryAttr = new InventTransCurrencyAdjPostFactoryAttribute(_inventTransCurrency);
        var instatiationStrategy = new InventAdjustPostInstantiation(_voucher, _transDate, _specification, _transTxtType);

        var instance = SysExtensionAppClassFactory::getClassFromSysAttributeWithInstantiationStrategy(classStr(InventAdjustPost),
            factoryAttr, instatiationStrategy);

        if (instance == null)
        {
            return new InventAdjustPost(_voucher, _transDate, _specification, _transTxtType);
        }

        return instance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjectNoLedger</Name>
				<Source><![CDATA[
    static void updateProjectNoLedger(
        Voucher     voucher,
        TransDate   transDate)
    {
        InventSettlement        inventSettlement;
        InventTrans             inventTrans;

        while select forceplaceholders sum(CostAmountAdjustment) from inventSettlement
            group by ItemId,ItemGroupId,
                BalanceSheetPosting,BalanceSheetLedgerDimension,
                OperationsPosting,OperationsLedgerDimension,
                DefaultDimension
            where inventSettlement.TransDate            == transDate    &&
                  inventSettlement.Voucher              == voucher      &&
                  inventSettlement.CostAmountAdjustment != 0            &&
                  inventSettlement.Posted               == NoYes::No
        join inventTrans
            group ProjId,ProjAdjustRefId,InventTransOrigin
            where inventTrans.RecId == inventSettlement.TransRecId
               && inventTrans.ProjId
        {
            if (ProjPost::checkCreateProjCost(inventSettlement.ItemId,inventTrans.ProjId))
            {
                ProjPost::newInventNeverLedger(inventTrans,transDate,voucher,inventSettlement.CostAmountAdjustment,true).postTrans();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventTransRecIdFilter_RU</Name>
				<Source><![CDATA[
    internal void setInventTransRecIdFilter_RU(TmpRecIdFilter _inventTransRecIdFilter)
    {
        if (_inventTransRecIdFilter)
        {
            inventTransRecIdFilter_RU = _inventTransRecIdFilter;
            isInventTransRecIdFilterShouldBeApplied_RU = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyInventTransRecIdFilter_RU</Name>
				<Source><![CDATA[
    private void applyInventTransRecIdFilter_RU(QueryRun _queryRun)
    {
        if (!isInventTransRecIdFilterShouldBeApplied_RU)
        {
            return;
        }

        QueryBuildDataSource qbdsRecIdFilter = _queryRun.query().dataSourceTable(tableNum(InventAdjustPostInventTransView)).addDataSource(tableNum(TmpRecIdFilter));
        qbdsRecIdFilter.addLink(fieldNum(InventAdjustPostInventTransView, RecId), fieldNum(TmpRecIdFilter, RefRecId));
        qbdsRecIdFilter.joinMode(JoinMode::ExistsJoin);

        _queryRun.setRecord(inventTransRecIdFilter_RU);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>