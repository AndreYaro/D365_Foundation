<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>rActAdjustEngineKernelCustVend</Name>
	<SourceCode>
		<Declaration><![CDATA[
abstract class rActAdjustEngineKernelCustVend
{
    RLedgerSheetEngine_ActAdjustCustVend    engine;
    RLedgerSheetServer_ActAdjustCustVend    rLedgerSheetServer;

    FormListControl         listControl;
    CustVendTable           custVendTable;          //Covenantee
    Set                     setShrinkKeys;          //Keep keys of nodes branches which were be shrink

    Map                     mapKeys;                //Keep hierarchy of keys for repor ordered by partitions of report
    // Key   -> Key for partitions totals.
    // Value -> MAP of keys for subsections totals.
    //          If node there are not subsections Value = Null.

    RHolderData_ActAdjustCustVend   holderData;     //Depot of report data

    boolean                 bShowCovenanteeName;    //Do covenantee name on form

    //Totals
    Amount                  turnoverDebit;          //Turnover of debit over period
    Amount                  turnoverCredit;         //Turnover of credit over period
    Amount                  amountDebitBalance;     //Balance of debit on end of period
    Amount                  amountCreditBalance;    //Balance of credit on end of period

    boolean                 calculatedTotals;       //Did totals calculate?

    //Positions into key for Depot of report data
    int                     posCustVendAC;
    int                     posAgreementHeaderExtRecId;
    int                     posActAdjustCVPartitionType;
    int                     posInvoiceId;
    int                     posINum;

    //Fields names in STRUCT with data
    TempStr                 transDateFieldName;         //Document's date
    TempStr                 documentFieldName;          //Document
    TempStr                 amountOfDocFieldName;       //Amount of document
    TempStr                 amountDebitFieldName;       //Debit amount
    TempStr                 amountCreditFieldName;      //Credit amount
    TempStr                 turnoverDebitFieldName;     //Amount of turnover by debit
    TempStr                 turnoverCreditFieldName;    //Amount of turnover by credit
    TempStr                 tableIdFieldName;           //Identifier of table for transition to original document
    TempStr                 recIdFieldName;             //Identifier of record for transition to original document
    TempStr                 currencyCodeFieldName;      //Currency of transaction (field can be absent)
    TempStr                 voucherFieldName;           //Voucher (field can be absent)

    int                     invoiceNumValue;            //Value of iNum field for invoice in key
    int                     paymentNumValue;            //Value of iNum field for payment in key

    TransDate               fromDate;                   //Beginning date of period
    TransDate               toDate;                     //Ending date of period

    CurrencyTypeBrief_RU    currencyTypeBrief;
    CurrencyCode            currencyCode;

    NoYes                   byAgreement;                //Group by agreements
    NoYes                   showDocument;               //Show documens in report
    NoYes                   deleteZeroInvoiceBalance;   //Does user want to delete line with zero balance and with balance equal amount of document ?
    NoYes                   showCovenanteePart;         //Fill covenantee's partitions

    #localmacro.conParameters
    fromDate,
    toDate,
    currencyTypeBrief,
    currencyCode,
    byAgreement,
    showDocument,
    deleteZeroInvoiceBalance,
    showCovenanteePart
#endmacro

    #localMacro.structFieldNames
    transDateFieldName,
    documentFieldName,
    amountOfDocFieldName,
    amountDebitFieldName,
    amountCreditFieldName,
    turnoverDebitFieldName,
    turnoverCreditFieldName,
    tableIdFieldName,
    recIdFieldName,
    currencyCodeFieldName,
    voucherFieldName
#endMacro

    #localmacro.posInKey
    posCustVendAC,
    posAgreementHeaderExtRecId,
    posActAdjustCVPartitionType,
    posInvoiceId,
    posINum
#endmacro

    #localmacro.numValue
    invoiceNumValue,
    paymentNumValue
#endmacro

    #define.sepKeyToStr('\n')                                   //Separator for item.Data()

    #define.firstColumnNum(0)                                   //First column number of FormListControl

    #define.numColumnTitleTxt(#firstColumnNum + 2)              //Column number for output text in patition title
    #define.numColumnCovenanteeTitleTxt(#numColumnTitleTxt)     //Column number for output covenantee name

    // line pictures
    #define.CovenanteePicture(4)
    #define.CovenanteeBegBalancePicture(4)
    #define.AgreementPicture(5)
    #define.AgreementBegBalancePicture(5)
    #define.PartitionPicture(6)
    #define.InvoicePicture(2)
    #define.PaymentPicture(0)
    #define.TotalSumPicture(1)

    #define.OverlayClear(0)
    #define.OverlayPictureSet(1)
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>agreementBegBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>Struct</c> class instance representing the balance on the beggining of period by agreement.
    /// </summary>
    /// <param name="_mapRoot">
    /// A <c>Map</c> with keys of derived data.
    /// </param>
    /// <param name="_conRootKey">
    /// A <c>container</c> key for the <c>Map</c> provided.
    /// </param>
    /// <returns>
    /// A <c>Struct</c> representing the balance.
    /// </returns>
    /// <remarks>
    /// Get balance on beginning of period by agreement
    /// _mapRoot     -> Node with keys of derived data.
    /// _conRootKey  -> Key of this node.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected Struct agreementBegBalance(Map _mapRoot, container _conRootKey)
    {
        container                               con;
        Struct                                  struct;

        //Create key
        con = rLedgerSheetServer.agreementTitleKeyToBegBalanceKey(_conRootKey);

        //Balance on beginning of period
        if (holderData.getMap().exists(con))
            struct = holderData.getMap().lookup(con);
        else
            struct = RHolderData_ActAdjustCustVend::emptyStruct();

        return struct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>agreementDocumentTitle</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a string representing agreement document title.
    /// </summary>
    /// <param name="_conKey">
    /// A container containing agreement identification info.
    /// </param>
    /// <returns>
    /// A string with agreement document title info.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected str agreementDocumentTitle(container _conKey)
    {
        AgreementHeaderExtRecId_RU agreementHeaderExtRecId;
        AgreementHeader            agreementHeader;
        str                        szRet = "";

        if (this.partitionType(_conKey) == RActAdjustCVPartitionType::Agreement)
        {
            agreementHeaderExtRecId = conpeek(_conKey, posAgreementHeaderExtRecId);
            if (agreementHeaderExtRecId)
            {
                agreementHeader = AgreementHeaderExt_RU::agreementHeader(agreementHeaderExtRecId);
                if (agreementHeader is SalesAgreementHeader)
                {
                    SalesAgreementHeader salesAgreementHeader = agreementHeader as SalesAgreementHeader;
                    szRet = strfmt("@GLS106745", (salesAgreementHeader.SalesNumberSequence) ? salesAgreementHeader.SalesNumberSequence : "@GLS110565");
                }
                else if (agreementHeader is PurchAgreementHeader)
                {
                    PurchAgreementHeader purchAgreementHeader = agreementHeader as PurchAgreementHeader;
                    szRet = strfmt("@GLS106745", (purchAgreementHeader.PurchNumberSequence) ? purchAgreementHeader.PurchNumberSequence : "@GLS110565");
                }
                else
                {
                    throw error(error::wrongUseOfFunction(funcName()));
                }
            }
            else
            {
                szRet = strfmt("@GLS106745", "@GLS110565");
            }
        }

        return szRet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allAgreementKeys</Name>
				<Source><![CDATA[
    //Use this.partitionKeys()
    private Set allAgreementKeys()
    {
        SetEnumerator   enSet;

        Map             map;
        container       conKey;

        Set             set = new Set(Types::Container);
        Set             setCovenantee;

        if (byAgreement)
        {
            setCovenantee = this.allCovenanteeKeys();
            enSet         = setCovenantee.getEnumerator();

            while (enSet.moveNext())
            {
                conKey = enSet.current();
                map    = this.findNodeInMapKeys(conKey);

                if (map)
                {
                    set = Set::union(set, map.keySet());
                }
            }
        }

        return set;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allCovenanteeKeys</Name>
				<Source><![CDATA[
    //Use this.partitionKeys()
    private Set allCovenanteeKeys()
    {
        Map           map;

        Set           set = new Set(Types::Container);
        MapEnumerator en  = mapKeys.getEnumerator();

        while (en.moveNext())
        {
            map = en.currentValue();

            if (map)
                set = Set::union(set, map.keySet());
        }

        return set;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allPartitionKeys</Name>
				<Source><![CDATA[
    //Use this.partitionKeys()
    private Set allPartitionKeys(RActAdjustCVPartitionType _actAdjustCVPartitionType)
    {
        SetEnumerator   enSet;
        Map             map;
        container       con, conKey;
        Set             setRoot;
        Set             set = new Set(Types::Container);

        if (byAgreement)
        {
            setRoot = this.allAgreementKeys();
        }
        else
        {
            setRoot = this.allCovenanteeKeys();
        }

        enSet = setRoot.getEnumerator();

        while (enSet.moveNext())
        {
            con = enSet.current();
            map = this.findNodeInMapKeys(con);

            if (map)
            {
                conKey = conPoke(con, posActAdjustCVPartitionType, int2str(_actAdjustCVPartitionType));

                if (map.exists(conKey))
                    set.add(conKey);
            }
        }

        return set;
    }

]]></Source>
			</Method>
			<Method>
				<Name>balance</Name>
				<Source><![CDATA[
    private container balance(container                 _conRootKey,
                              RActAdjustCVPartitionType _partitionType,
                              Amount                    _turnoverDeb  = 0,
                              Amount                    _turnoverCred = 0,
                              Amount                    _balanceDeb   = 0,
                              Amount                    _balanceCred  = 0)
    {
        container       con, conPartition;
        Amount          turnoverDeb  = _turnoverDeb,
                        turnoverCred = _turnoverCred,
                        balanceDeb   = _balanceDeb,
                        balanceCred  = _balanceCred;
        Amount          tmpTurnoverDeb, tmpTurnoverCred, tmpBalanceDeb, tmpBalanceCred;
        Struct          struct;

        Map             map;
        SetEnumerator   en;

        conPartition  = rLedgerSheetServer.agreementTitleKeyToPartitionKey(_conRootKey, _partitionType);
        map           = this.findNodeInMapKeys(conPartition);

        if (map)
        {
            en = map.keySet().getEnumerator();

            while (en.moveNext())
            {
                con    = en.current();

                struct = holderData.getMap().lookup(con);

                [tmpBalanceDeb, tmpBalanceCred] = this.calculateBalance(struct);

                tmpTurnoverDeb  = struct.value(turnoverDebitFieldName);
                tmpTurnoverCred = struct.value(turnoverCreditFieldName);

                balanceDeb   += tmpBalanceDeb;
                balanceCred  += tmpBalanceCred;
                turnoverDeb  += tmpTurnoverDeb;
                turnoverCred += tmpTurnoverCred;
            }
        }

        return [ turnoverDeb,
                 turnoverCred,
                 balanceDeb,
                 balanceCred ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>balanceAndTurnoverAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates balance and turnover by the agreement.
    /// </summary>
    /// <param name="_conRootKey">
    /// A container containing agreement identification info.
    /// </param>
    /// <returns>
    /// A container containing balance and turnover info.
    /// </returns>
    /// <remarks>
    /// Calculate balance and turnover by agreement
    /// _conRootKey -> Root node key of agreement.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected container balanceAndTurnoverAgreement(container _conRootKey)
    {
        #define.Balances(turnoverDeb, turnoverCred, balanceDeb, balanceCred)

        Amount turnoverDeb = 0, turnoverCred = 0, balanceDeb = 0, balanceCred = 0;

        if (holderData.getMap().exists(_conRootKey))
        {
            [ #Balances ] = this.balance(_conRootKey, RActAdjustCVPartitionType::InvoicePrevious);
            [ #Balances ] = this.balance(_conRootKey, RActAdjustCVPartitionType::InvoiceCurrent,  #Balances);
            [ #Balances ] = this.balance(_conRootKey, RActAdjustCVPartitionType::PaymentCurrent,  #Balances);
            [ #Balances ] = this.balance(_conRootKey, RActAdjustCVPartitionType::PaymentPrevious, #Balances);
        }

        return [ #Balances ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>balanceAndTurnoverCovenantee</Name>
				<Source><![CDATA[
    //Calculate balance and turnover for covenantee
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public container balanceAndTurnoverCovenantee()
    {
        container       con;
        Amount          tmpTurnoverDeb, tmpTurnoverCred, tmpBalanceDeb, tmpBalanceCred;
        Set             set;
        SetEnumerator   en;

        if (! calculatedTotals)
        {
            turnoverDebit       = 0;
            turnoverCredit      = 0;
            amountDebitBalance  = 0;
            amountCreditBalance = 0;

            if (byAgreement)
            {
                set = this.partitionKeys(RActAdjustCVPartitionType::Agreement);
            }
            else
            {
                set = this.partitionKeys(RActAdjustCVPartitionType::Covenantee);
            }

            en = set.getEnumerator();

            while (en.moveNext())
            {
                con = en.current();

                [tmpTurnoverDeb, tmpTurnoverCred, tmpBalanceDeb, tmpBalanceCred] = this.balanceAndTurnoverAgreement(con);

                turnoverDebit       += tmpTurnoverDeb;
                turnoverCredit      += tmpTurnoverCred;
                amountDebitBalance  += tmpBalanceDeb;
                amountCreditBalance += tmpBalanceCred;
            }

            calculatedTotals = true;
        }

        return [turnoverDebit, turnoverCredit, amountDebitBalance, amountCreditBalance];
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateBalance</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected container calculateBalance(Struct _struct)
    {
        Amount amountDebit  = _struct.value(amountDebitFieldName),
               amountCredit = _struct.value(amountCreditFieldName);

        if (abs(amountDebit) > abs(amountCredit))
        {
            amountDebit -= amountCredit;
            amountCredit = 0;
        }
        else
        {
            amountCredit -= amountDebit;
            amountDebit  = 0;
        }

        return [amountDebit, amountCredit];
    }

]]></Source>
			</Method>
			<Method>
				<Name>canExpand</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected boolean canExpand(container _conKey)
    {
        return setShrinkKeys.in(_conKey);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canExpandAllPartition</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected boolean canExpandAllPartition(container _conKey)
    {
        RActAdjustCVPartitionType partitionType = this.partitionType(_conKey);
        Set                       set;

        if (partitionType == RActAdjustCVPartitionType::Covenantee)
            return false;

        set = this.partitionKeys(partitionType);
        set = Set::intersection(set, setShrinkKeys);

        return (! set.empty());
    }

]]></Source>
			</Method>
			<Method>
				<Name>canShowOriginalDocuments</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected boolean canShowOriginalDocuments(container _conKey)
    {
        Struct  struct;
        int     cx;
        TempStr szSumKeyField = holderData.getSumKeyField();

        for (cx = conLen(_conKey); cx > 0; cx--)
        {
            if (conPeek(_conKey, cx) == szSumKeyField)
                return false;
        }

        struct = holderData.getMap().lookup(_conKey);

        return (struct.value(tableIdFieldName) && (struct.value(recIdFieldName) || struct.index(voucherFieldName)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>canShrink</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected boolean canShrink(container _conKey)
    {
        TempStr szSumKeyField;

        if (setShrinkKeys.in(_conKey))
            return false;

        szSumKeyField = holderData.getSumKeyField();
        return (conPeek(_conKey, posInvoiceId) == szSumKeyField &&
                conPeek(_conKey, posINum)      == szSumKeyField);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canShrinkAllPartition</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected boolean canShrinkAllPartition(container  _conKey)
    {
        RActAdjustCVPartitionType   partitionType;
        Set                         set;
        TempStr                     szSumKeyField = holderData.getSumKeyField();
        boolean                     bRet = false;

        if (conPeek(_conKey, posInvoiceId) == szSumKeyField &&
            conPeek(_conKey, posINum)      == szSumKeyField)
        {
            partitionType = this.partitionType(_conKey);

            if (partitionType != RActAdjustCVPartitionType::Covenantee)
            {
                set = this.partitionKeys(partitionType);
                set = Set::difference(set, setShrinkKeys);

                bRet = (!set.empty());
            }
        }

        return  bRet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>childNodeKeys</Name>
				<Source><![CDATA[
    //Get all keys of partition
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected Set childNodeKeys(Map _mapRoot)
    {
        Map           map;
        MapEnumerator en;
        container     con;
        Set           set = new Set(Types::Container);

        if (_mapRoot)
        {
            en = _mapRoot.getEnumerator();

            while (en.moveNext())
            {
                con = en.currentKey();
                map = en.currentValue();

                set.add(con);
                set = Set::union(set, this.childNodeKeys(map));
            }
        }

        return set;
    }

]]></Source>
			</Method>
			<Method>
				<Name>contragentForm</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    abstract protected FormName contragentForm()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLstIdx</Name>
				<Source><![CDATA[
    //Return list of indexes for items in accordance with keys
    // _setKeys -> There is keys of rows.
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected List createLstIdx(Set _setKeys)
    {
        container       con;
        TempStr         sz;
        List            lst;
        int             idx;

        ;

        lst  = new List(Types::Integer);

        if (!_setKeys.empty())
        {
            idx = listControl.getNextItem(FormListNext::All);

            while (idx > -1)
            {
                sz  = listControl.getItem(idx).data();
                con = this.itemDataToKey(sz);

                if (_setKeys.in(con))
                    lst.addStart(idx);

                idx = listControl.getNextItem(FormListNext::All, idx);
            }
        }

        return lst;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMapKeys</Name>
				<Source><![CDATA[
    //Create MAP of keys
    // _en          -> It is enumerator for traversal data from holder.
    // _stackKeys   -> It is selected from holder but not used keys.
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected Map createMapKeys(MapEnumerator _en, Stack  _stackKeys = null)
    {
        container con = conNull();
        int       cx, cntTmp;

        TempStr   sz, sumField = holderData.getSumKeyField();

        Map       map, mapRoot;

        boolean   loop;

        //-------------------------------------------------------

        //Calculate count of special field in container
        int cntSumFields()
        {
            int  i;

            for (cx = conLen(con); cx > 0; cx--)
            {
                sz = conPeek(con, cx);

                if (sz == sumField)
                    i++;
                else
                    break;
            }

            return i;
        }

        boolean  isSumKey()
        {
            for (cx = conLen(con); cx > 0; cx--)
            {
                sz = conPeek(con, cx);

                if (sz == sumField)
                    return true;
            }

            return false;
        }

        Map createMap()
        {
            return new Map(Types::Container, Types::Class);
        }

        //Get next key for processing
        //If OK -> loop = true
        void getNextKey()
        {
            if (_stackKeys.qty() > 0)
            {
                loop    = true;
                con     = _stackKeys.pop();
            }
            else
            {
                loop    = _en.moveNext();

                if (loop)
                    con = _en.currentKey();
                else
                    con = conNull();
            }
        }

        //-------------------------------------------------------

        if (! _stackKeys)
            _stackKeys = new Stack();

        mapRoot     = createMap();

        getNextKey();

        if (loop)
        {
            if (isSumKey())
            {
                //Special key

                do
                {
                    if (! isSumKey())
                        throw error(Error::wrongUseOfFunction(funcName()));

                    map = this.createMapKeys(_en, _stackKeys);
                    mapRoot.insert(con, map);

                    cntTmp = cntSumFields();

                    getNextKey();

                    if (cntTmp < cntSumFields())
                    {
                        //There is top level key
                        _stackKeys.push(con);
                        break;
                    }
                }
                while (loop);
            }
            else
            {
                //Insert ordinary keys only

                do
                {
                    if (isSumKey())
                    {
                        _stackKeys.push(con);    //Remember key
                        break;
                    }

                    mapRoot.insert(con, createMap());

                    getNextKey();
                }
                while (loop);
            }
        }

        return mapRoot;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteItems</Name>
				<Source><![CDATA[
    //Delete items from formList
    // _setKeys -> It keeps keys of row for removing.
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void deleteItems(Set _setKeys)
    {
        List            lstIdx;
        ListEnumerator  en;
        int             idx;

        ;

        if (!_setKeys.empty())
        {
            lstIdx  = this.createLstIdx(_setKeys);
            en      = lstIdx.getEnumerator();

            while (en.moveNext())
            {
                idx = en.current();
                listControl.delete(idx);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandAllPartitions</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void expandAllPartitions(RActAdjustCVPartitionType  _actAdjustCVPartitionType)
    {
        SetEnumerator   en;
        Set             set;
        container       conKey;

        ;

        listControl.lock();

        set = this.partitionKeys(_actAdjustCVPartitionType);
        en  = set.getEnumerator();

        while (en.moveNext())
        {
            conKey = en.current();
            this.expandNode(conKey, true, false);
        }

        listControl.unLock(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandNode</Name>
				<Source><![CDATA[
    //Expand node.
    // _conKey   -> It is key of node necessary expand.
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void expandNode(container     _conKey,
                              boolean       _bRemoveFromSetShrinkKeys = true,
                              boolean       _lockForm                 = true)
    {
        RActAdjustCVPartitionType   partitionType;
        Set                         setKeys;
        int                         idx, iTmp;
        ListEnumerator              en;
        Map                         map;

        ;

        if (!setShrinkKeys.in(_conKey))
            //Branch does not shrink
            return;

        if (_lockForm)
            listControl.lock();

        partitionType = this.partitionType(_conKey);

        setKeys       = new Set(Types::Container);
        setKeys.add(_conKey);

        en            = this.createLstIdx(setKeys).getEnumerator();

        if (en.moveNext())
        {
            idx = en.current();

            while (en.moveNext())
            {
                iTmp = en.current();
                idx  = (idx > iTmp) ? iTmp: idx;
            }

            idx--;
        }

        this.deleteItems(setKeys);

        if (_bRemoveFromSetShrinkKeys && setShrinkKeys.in(_conKey))
            setShrinkKeys.remove(_conKey);

        map = this.findNodeInMapKeys(_conKey);

        switch (partitionType)
        {
            case  RActAdjustCVPartitionType::Covenantee :
                this.insCovenanteeData(map, _conKey, idx);
                break;

            case  RActAdjustCVPartitionType::Agreement :
                this.insAgreementData(map, _conKey, idx, byAgreement);
                break;

            case  RActAdjustCVPartitionType::InvoicePrevious :
                this.insInvoicePreviousPartition(map, _conKey, idx);
                break;

            case  RActAdjustCVPartitionType::InvoiceCurrent :
                this.insInvoiceCurrentPartition(map, _conKey, idx);
                break;

            case  RActAdjustCVPartitionType::PaymentCurrent :
                this.insPaymentCurrentPartition(map, _conKey, idx);
                break;

            case  RActAdjustCVPartitionType::PaymentPrevious :
                this.insPaymentPreviousPartition(map, _conKey, idx);
                break;

            default :
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (_lockForm)
            listControl.unLock(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandTxt</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    abstract protected TempStr expandTxt()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>fetchNextRows</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public int fetchNextRows(int _idx)
    {
        container     conKey, conKeyCovenantee;
        MapEnumerator en, enCovenantee;
        Map           map, mapCovenantee;
        int           newIidx = _idx;
        ;

        setShrinkKeys = new Set(Types::Container);
        en            = mapKeys.getEnumerator();

        while (en.moveNext())
        {
            conKey  = en.currentKey();
            map     = en.currentValue();

            enCovenantee = map.getEnumerator();

            while (enCovenantee.moveNext())
            {
                conKeyCovenantee = enCovenantee.currentKey();
                mapCovenantee    = enCovenantee.currentValue();

                newIidx = this.insCovenanteeData(mapCovenantee, conKeyCovenantee, newIidx);
            }
        }

        return newIidx;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findNodeInMapKeys</Name>
				<Source><![CDATA[
    //Find node in MAP of key (mapKeys)
    // _conKey -> Key of node
    // Return found key or NULL.
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected Map findNodeInMapKeys(container _conKey)
    {
        container   con = conNull();
        Map         map;
        TempStr     sumKeyField = holderData.getSumKeyField(), sz;
        int         cx, len;
        boolean     bFound = false;

        ;

        len = conLen(_conKey);

        for (cx = 1; cx <= len; cx++)
            con += sumKeyField;

        map = mapKeys.lookup(con);

        for (cx = 1; cx <= len; cx++)
        {
            sz  = conPeek(_conKey, cx);
            con = conPoke(con, cx, sz);

            if (map.exists(con))
            {
                map = map.lookup(con);

                if (this.keyToStr(_conKey) == this.keyToStr(con))
                {
                    bFound = true;
                    break;
                }
            }
        }

        return (bFound) ? map : null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDataFromServer</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void getDataFromServer()
    {
        MapEnumerator en;
        container     conKey;
        Map           map;

        [#posInKey] = rLedgerSheetServer.getKeyMask();
        [#numValue] = rLedgerSheetServer.getDefaultNumValue();

        if (Global::isAOS())
        {
            holderData = RHolderData::unpackRHolderData(rLedgerSheetServer.getHolderDataContainer());
        }
        else
        {
            holderData = rLedgerSheetServer.getHolderData();
        }

        //Get names of fields in struct
        [#structFieldNames] = holderData.getFieldNames();

        //Create buffer of keys
        mapKeys = new Map(Types::Container, Types::Class);

        en      = holderData.getMap().getEnumerator();

        if (en.moveNext())
        {
            conKey = en.currentKey();
            map    = this.createMapKeys(en);   //Fill buffer of key

            mapKeys.insert(conKey, map);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getItemType</Name>
				<Source><![CDATA[
    //Get information about Item
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public container getItemType(int _idx)
    {
        RActAdjustCVPartitionType  partitionType;
        RActAdjustCVReportLineType reportLineType;

        container    conKey;
        FormListItem item;
        str          szKey = "", sz;
        int          tmpIdx, pos;

        //--------------------- functions -----------------------------
        int posInList()
        {
            pos    = 0;
            tmpIdx = listControl.getNextItem(FormListNext::All);

            while (tmpIdx > -1)
            {
                sz = listControl.getItem(tmpIdx).data();

                if (szKey == sz)
                {
                    pos++;

                    if (tmpIdx == _idx)
                        break;
                }

                tmpIdx = listControl.getNextItem(FormListNext::All, tmpIdx);
            }

            return pos;
        }
        //----------------------- start -------------------------
        ;

        item = listControl.getItem(_idx);

        if (!item)
            throw error(Error::wrongUseOfFunction(funcName()));

        szKey  = item.data();
        conKey = this.itemDataToKey(szKey);

        if (conKey == conNull())
            return conNull();

        partitionType = this.partitionType(conKey);

        switch (item.image())
        {
            case #PartitionPicture            :
                reportLineType = RActAdjustCVReportLineType::Caption;
                break;

            case #InvoicePicture              :
                reportLineType = RActAdjustCVReportLineType::Invoice;
                break;

            case #PaymentPicture              :
                reportLineType = RActAdjustCVReportLineType::Payment;
                break;

            case #TotalSumPicture             :
                reportLineType = RActAdjustCVReportLineType::Totals;
                break;

            case #CovenanteePicture           :
                // TODO(sevoroby, 11/7/2013): Code commented during fixing bug 858164.
                // The label case 4 already occurs in this switch statement.
                //case #CovenanteeBegBalancePicture :
                posInList();
                pos = bShowCovenanteeName ? pos : pos + 1;

                reportLineType = this.understandLineType(pos);
                break;

            case #AgreementPicture            :
                // TODO(sevoroby, 11/7/2013): Code commented during fixing bug 858164.
                // The label case 5 already occurs in this switch statement.
                //case #AgreementBegBalancePicture  :
                reportLineType = this.understandLineType(posInList());
                break;

            default :
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return [ partitionType, reportLineType ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRLedgerSheetType</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    abstract protected RLedgerSheetType getRLedgerSheetType()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParameters</Name>
				<Source><![CDATA[
    //Initialise object
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void initParameters(container _conParm)
    {
        ;

        [#conParameters] = _conParm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insAgreementData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts agreement data into internal structures.
    /// </summary>
    /// <param name="_mapRoot">
    /// A <c>Map</c> class instance containing the data mapped by keys.
    /// </param>
    /// <param name="_conRootKey">
    /// A container containing the key for the current node.
    /// </param>
    /// <param name="_idx">
    /// The starting index to insert data into.
    /// </param>
    /// <param name="_bShowAgreementInfo">
    /// A <c>Boolean</c> determining whether to show the information by the agreement.
    /// </param>
    /// <returns>
    /// An integer corresponding to the next index value.
    /// </returns>
    /// <remarks>
    /// Output data by agreement.
    /// _mapRoot          -> Node with keys of data.
    /// _conRootKey       -> Key of this node.
    /// _bShowConractInfo -> Show information by agreement (title, totals).
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected int insAgreementData(Map _mapRoot, container _conRootKey, int _idx, boolean _bShowAgreementInfo = true)
    {
        Map       map;
        container con = connull();
        TempStr   sz, szAgreementTitle;
        Struct    struct, structBalance;
        Amount    balanceDeb = 0, balanceCred = 0, turnoverDeb = 0, turnoverCred = 0;
        int       newIdx = _idx;
        anytype   anyNull = null;
        //Insert title of agreement and balance on beginnig of period
        if (_bShowAgreementInfo)
        {
            //Title
            szAgreementTitle = this.agreementDocumentTitle(_conRootKey);
            sz               = strfmt("@GLS110582", szAgreementTitle);
            newIdx           = this.insRowTitle(sz, _conRootKey, #numColumnTitleTxt, #AgreementPicture, newIdx);

            this.overlayPicture(newIdx, setShrinkKeys.in(_conRootKey) ? #OverlayPictureSet : #OverlayClear);

            //Create key
            con = rLedgerSheetServer.agreementTitleKeyToBegBalanceKey(_conRootKey);

            //Balance on beginning of period
            structBalance = this.agreementBegBalance(_mapRoot, _conRootKey);
            newIdx        = this.insRow(_conRootKey, structBalance, #AgreementBegBalancePicture, newIdx, "", true, false, false);
        }

        if (! setShrinkKeys.in(_conRootKey))
        {
            //Invoices of previous periods
            con    = rLedgerSheetServer.agreementTitleKeyToPartitionKey(_conRootKey, RActAdjustCVPartitionType::InvoicePrevious);
            map    = _mapRoot.exists(con) ? _mapRoot.lookup(con) : anyNull;
            newIdx = this.insInvoicePreviousPartition(map, con, newIdx);

            //Invoices of current period
            con    = rLedgerSheetServer.agreementTitleKeyToPartitionKey(_conRootKey, RActAdjustCVPartitionType::InvoiceCurrent);
            map    = _mapRoot.exists(con) ? _mapRoot.lookup(con) : anyNull;
            newIdx = this.insInvoiceCurrentPartition(map, con, newIdx);

            //Advances of current period
            con    = rLedgerSheetServer.agreementTitleKeyToPartitionKey(_conRootKey, RActAdjustCVPartitionType::PaymentCurrent);
            map    = _mapRoot.exists(con) ? _mapRoot.lookup(con) : anyNull;
            newIdx = this.insPaymentCurrentPartition(map, con, newIdx);

            //Advances of previous periods
            con    = rLedgerSheetServer.agreementTitleKeyToPartitionKey(_conRootKey, RActAdjustCVPartitionType::PaymentPrevious);
            map    = _mapRoot.exists(con) ? _mapRoot.lookup(con) : anyNull;
            newIdx = this.insPaymentPreviousPartition(map, con, newIdx);
        }

        if (_bShowAgreementInfo)
        {
            [turnoverDeb, turnoverCred, balanceDeb, balanceCred] = this.balanceAndTurnoverAgreement(_conRootKey);

            if ((fromDate != dateNull()) && (toDate != dateNull()))
            {
                sz = strfmt("@GLS110583", szAgreementTitle, fromDate, toDate);
            }
            else
            {
                sz = strfmt("@GLS110584", szAgreementTitle, toDate);
            }

            //Turnover over current period
            struct = RHolderData_ActAdjustCustVend::createStruct(dateNull(), sz, 0, turnoverDeb, turnoverCred, 0, 0);
            newIdx = this.insRow(_conRootKey, struct, #TotalSumPicture, newIdx, "", true, false, false);

            //Balance by agreement
            struct = RHolderData_ActAdjustCustVend::createStruct(dateNull(), strfmt("@GLS110585", szAgreementTitle, toDate), 0, balanceDeb, balanceCred, 0, 0);
            newIdx = this.insRow(_conRootKey, struct, #TotalSumPicture, newIdx, "", true, false, false);
        }

        return newIdx;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insCovenanteeData</Name>
				<Source><![CDATA[
    //Output information about covenantee
    // _mapCovenantee -> Node with key of covenantee.
    // _conRootKey    -> Key of this node.
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected int insCovenanteeData(Map _mapRoot, container _conRootKey, int _idx)
    {
        Struct        struct;
        container     con;
        MapEnumerator en;
        str           sz;
        Map           map;
        CustVendAC    localCustVendAC;
        int           newIdx = _idx;

        //-----------------------------------------------------------------
        void overlayPicture()
        {
            this.overlayPicture(newIdx, setShrinkKeys.in(_conRootKey) ? #OverlayPictureSet : #OverlayClear);
        }
        //-----------------------------------------------------------------
        ;

        if (_mapRoot)
        {
            //Insert title
            localCustVendAC = conPeek(_conRootKey, posCustVendAC);

            if (bShowCovenanteeName)
            {
                sz     = (custVendTable.name()) ? custVendTable.name() : custVendTable.AccountNum;
                newIdx = this.insRowTitle(this.txtCovenanteeName(), _conRootKey, #numColumnCovenanteeTitleTxt, #CovenanteePicture, newIdx);

                overlayPicture();
            }

            //Insert balance on beginning of period
            struct = this.structBalanceBegPeriod();
            newIdx = this.insRow(_conRootKey, struct, #CovenanteeBegBalancePicture, newIdx, "", true, false, false);

            if (!bShowCovenanteeName)
                overlayPicture();

            if (! setShrinkKeys.in(_conRootKey))
            {
                if (byAgreement)
                {
                    en = _mapRoot.getEnumerator();

                    while (en.moveNext())
                    {
                        map = en.currentValue();
                        con = en.currentKey();

                        newIdx = this.insAgreementData(map, con, newIdx, true);
                    }
                }
                else
                {
                    newIdx = this.insAgreementData(_mapRoot, _conRootKey, newIdx, false);
                }
            }

            //Output turnover over period and balance on ending of period
            struct = this.structTurnover(this.txtTurnoverCovenantee());
            newIdx = this.insRow(_conRootKey, struct, #TotalSumPicture, newIdx, "", true, false, false);

            struct = this.structBalanceEndPeriod(this.txtBalanceCovenantee());
            newIdx = this.insRow(_conRootKey, struct, #TotalSumPicture, newIdx, "", true, false, false);
        }

        return newIdx;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insDocuments</Name>
				<Source><![CDATA[
    //Output data of invoice
    // _mapRoot             -> Node with keys of data.
    // _conRootKey          -> Key of this node.
    // _idx                 -> Index of FormListItem.
    // _documentNumber      -> Number for combination with number from key.
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected int insDocuments(Map _mapRoot, container _conRootKey, int _idx1, int  _documentNumber)
    {
        #define.strZero('0')

        MapEnumerator enRoot;
        container     con;
        TempStr       sz = "", szDocNum = "";
        int           imageNum, iCntDigits, cx = -1;
        Struct        struct;
        boolean       bGenerateNum = false;
        int           newIdx = _idx1;
        ;

        if (_mapRoot)
        {
            if (_documentNumber > 0)
            {
                szDocNum     = int2str(_documentNumber);
                sz           = int2str(_mapRoot.elements());
                iCntDigits   = strLen(sz);
                bGenerateNum = true;
            }

            enRoot = _mapRoot.getEnumerator();

            while (enRoot.moveNext())
            {
                con = enRoot.currentKey();

                if (holderData.getMap().exists(con))
                {
                    struct = holderData.getMap().lookup(con);

                    imageNum = rLedgerSheetServer.isInvoiceKey(con) ? #InvoicePicture : #PaymentPicture;

                    if (bGenerateNum)
                    {
                        cx++;
                        sz = strFmt("@GLS110610", szDocNum, strRFix(int2str(cx), iCntDigits, #strZero));
                    }
                    else
                    {
                        sz = "";
                    }

                    newIdx = this.insRow(con, struct, imageNum, newIdx, sz);
                }
            }
        }

        return newIdx;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insInvoiceCurrentPartition</Name>
				<Source><![CDATA[
    //Output partition - invoices of current period
    // _mapRoot    -> Node with keys of data.
    // _conRootKey -> Key of this node.
    // Return: Index of last inserted Item
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected int insInvoiceCurrentPartition(Map _mapRoot, container _conRootKey, int _idx)
    {
        Struct  struct;
        TempStr sz;
        int     newIdx = _idx;

        if (_mapRoot)
        {
            if ((fromDate != dateNull()) && (toDate != dateNull()))
                sz = strFmt("@GLS110578", fromDate, toDate);
            else
                sz = strFmt("@GLS110579", toDate);

            newIdx = this.insPartition(sz, _mapRoot, _conRootKey, newIdx, true, true);

            if (setShrinkKeys.in(_conRootKey))
            {
                struct = this.invoicePartitionTurnover(_conRootKey, "@GLS110580");
                newIdx = this.insRow( _conRootKey, struct, #TotalSumPicture, newIdx, "", true, false, false);

                struct = this.partitionBalance(_conRootKey, "@GLS110581");
                newIdx = this.insRow( _conRootKey, struct, #TotalSumPicture, newIdx, "", true, false, false);
            }
        }

        return newIdx;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insInvoicePreviousPartition</Name>
				<Source><![CDATA[
    //Output partition - invoices of previous period
    // _mapRoot     -> Node with keys of data.
    // _conRootKey  -> Key of this node.
    // Return: Index of last inserted Item
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected int insInvoicePreviousPartition(Map _mapRoot, container _conRootKey, int _idx)
    {
        Struct  struct;
        TempStr sz;
        int     newIdx = _idx;

        if (_mapRoot)
        {
            sz = fromDate ? strFmt("@GLS110575", fromDate) : "@GLS110540";

            newIdx = this.insPartition(sz, _mapRoot, _conRootKey, newIdx, true, true);

            if (setShrinkKeys.in(_conRootKey))
            {
                struct = this.invoicePartitionTurnover(_conRootKey, "@GLS110576");
                newIdx = this.insRow( _conRootKey, struct, #TotalSumPicture, newIdx, "", true, false, false);

                struct = this.partitionBalance(_conRootKey, "@GLS110577");
                newIdx = this.insRow( _conRootKey, struct, #TotalSumPicture, newIdx, "", true, false, false);
            }
        }

        return newIdx;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insPartition</Name>
				<Source><![CDATA[
    //Output partition data
    // _titleTxt     -> Title of partition.
    // _mapRoot      -> Node with keys of data.
    // _conRootKey   -> Key of this node.
    // _showBalance  -> Show balance by documents.
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected int insPartition(TempStr   _txtPartitionTitle,
                               Map       _mapRoot,
                               container _conRootKey,
                               int       _idx1,
                               boolean   _showBalance,
                               boolean   _generateNumber)
    {
        RActAdjustCVPartitionType actAdjustCVPartitionType;
        TempStr                   sz;
        Struct                    struct;
        MapEnumerator             enRoot;
        Map                       map;
        container                 con = conNull(), conTmp;
        Amount                    amount, amountDebit, amountCredit;
        int                       cx = 0;
        int                       newIdx = _idx1;

        //--------------------------------------------------------------
        void getBalanceDescription()
        {
            actAdjustCVPartitionType = conPeek(con, posActAdjustCVPartitionType);

            switch (actAdjustCVPartitionType)
            {
                case RActAdjustCVPartitionType::InvoiceCurrent  :
                case RActAdjustCVPartitionType::InvoicePrevious :

                    conTmp = conPoke(con, posINum, int2str(invoiceNumValue));
                    break;

                case RActAdjustCVPartitionType::PaymentCurrent  :
                case RActAdjustCVPartitionType::PaymentPrevious :

                    conTmp = conPoke(con, posINum, int2str(paymentNumValue));
                    break;

                default :
                    sz = "";
                    return;
            }

            if (holderData.getMap().exists(conTmp))
            {
                struct = holderData.getMap().lookup(conTmp);
                sz     = strLwr(struct.value(documentFieldName));
            }
            else
            {
                sz = "@GLS110566";
            }

            sz = strFmt("@GLS110567", sz);
        }

        void balanceData()
        {
            getBalanceDescription();
            struct = this.partitionBalance(con, sz);

            amount       = struct.value(amountOfDocFieldName);
            amountDebit  = struct.value(amountDebitFieldName);
            amountCredit = struct.value(amountCreditFieldName);
        }

        void insBalance()
        {
            newIdx = this.insRow(con, struct, #TotalSumPicture, newIdx, "", true, false, false);
        }
        //--------------------------------------------------------------
        ;

        if (showDocument && _mapRoot)
        {
            //Output title
            newIdx = this.insRowTitle(_txtPartitionTitle, _conRootKey, #numColumnTitleTxt, #PartitionPicture, newIdx);

            if (setShrinkKeys.in(_conRootKey))
            {
                this.overlayPicture(newIdx, #OverlayPictureSet);
            }
            else
            {
                //Output data over period

                this.overlayPicture(newIdx, #OverlayClear);

                enRoot = _mapRoot.getEnumerator();

                while (enRoot.moveNext())
                {
                    cx++;
                    con = enRoot.currentKey();
                    map = enRoot.currentValue();

                    newIdx = this.insDocuments(map, con, newIdx, (_generateNumber) ? cx : 0);

                    //Balance on ending of period
                    if (_showBalance)
                    {
                        balanceData();

                        if (!deleteZeroInvoiceBalance                              ||
                          (((amountDebit    != 0) || (amountCredit != 0))         &&
                            (((amountDebit  == 0) && (amountCredit != amount))    ||
                             ((amountCredit == 0) && (amountDebit  != amount)))))
                        {
                            insBalance();
                        }
                    }
                    else
                    {
                        if (map.elements() > 1)
                        {
                            balanceData();
                            insBalance();
                        }
                    }
                }
            }
        }

        return newIdx;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insPaymentCurrentPartition</Name>
				<Source><![CDATA[
    //Output partition - payment of current period
    // _mapRoot    -> Node with keys of data.
    // _conRootKey -> Key of this node.
    // _szNumber   -> Document's number which will be output instead of number from key.
    // Return: Index of inserted Item.
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected int insPaymentCurrentPartition(Map _mapRoot, container _conRootKey, int _idx)
    {
        TempStr sz;
        Struct  struct;
        int     newIdx = _idx;

        if (_mapRoot)
        {
            if ((fromDate != dateNull()) && (toDate != dateNull()))
            {
                sz = strFmt("@GLS110568", fromDate, toDate);
            }
            else
            {
                sz = strFmt("@GLS110569", toDate);
            }

            newIdx = this.insPartition(sz, _mapRoot, _conRootKey, newIdx, false, true);

            struct = this.partitionBalance(_conRootKey, "@GLS110571");
            newIdx = this.insRow( _conRootKey, struct, #TotalSumPicture, newIdx, "", true, false, false);
        }

        return newIdx;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insPaymentPreviousPartition</Name>
				<Source><![CDATA[
    //Output partition - payments of previous period
    // _mapRoot      -> Node of data.
    // _conRootKey   -> Key of this node.
    // Return: Index of last inserted item
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected int insPaymentPreviousPartition(Map _mapRoot, container _conRootKey, int _idx)
    {
        TempStr sz;
        Struct  struct;
        int     newIdx = _idx;

        if (_mapRoot)
        {
            sz = fromDate ? strFmt("@GLS110573", fromDate) : "@GLS110572";

            newIdx = this.insPartition(sz, _mapRoot, _conRootKey, newIdx, false, true);

            struct = this.partitionBalance(_conRootKey, "@GLS110574");
            newIdx = this.insRow(_conRootKey, struct, #TotalSumPicture, newIdx, "", true, false, false);
        }

        return newIdx;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insRow</Name>
				<Source><![CDATA[
    //Insert row into formList
    // _conKey              -> Key.
    // _structVal           -> Data.
    // _imageNum            -> Number of icon.
    // _idx                 -> Index of FormListItem.
    // _szNumber            -> Document's number which will be show instead of number from key.
    // _showZero            -> Show zero value.
    // _showNum             -> Show number.
    // _showSumOfDocument   -> Show amount of document.
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected int insRow(container _conKey,
                         Struct    _structVal,
                         int       _imageNum,
                         int       _idx,
                         TempStr   _szNumber             = "",
                         boolean   _showZero             = false,
                         boolean   _showNum              = true,
                         boolean   _showAmountOfDocument = true)
    {
        int          cx = 0, colNum, iTmp, maxCx;
        int64        i64Tmp;
        FormListItem item;
        str          sz;
        date         dtTemp;
        Amount       amount;
        int          idxAmountOfDoc;
        int          idx = _idx + 1;

        //------------------------- functions ---------------------------------
        void amountToStr()
        {
            #define.Decimals(2)
            ;
            amount = decRound(amount, #Decimals);
            if ((amount == 0) && (! _showZero))
            {
                sz = "";
            }
            else
            {
                sz = strFmt("@GLS106745", amount);
            }
        }

        void valueToStr()
        {
            switch (_structVal.fieldType(cx))
            {
                case Types::Integer :
                    iTmp    = _structVal.valueIndex(cx);
                    sz      = int2str(iTmp);
                    break;
                case Types::Int64   :
                    i64Tmp    = _structVal.valueIndex(cx);
                    sz        = int642str(i64Tmp);
                    break;
                case Types::Date :
                    dtTemp  = _structVal.valueIndex(cx);
                    sz      = strFmt("@GLS106745", dtTemp);
                    break;

                case Types::String :
                    sz = _structVal.valueIndex(cx);
                    break;

                case Types::Real :
                    amount  = _structVal.valueIndex(cx);
                    amountToStr();
                    break;

                default :
                    sz = _structVal.valueImage(cx);
            }
        }

        void amountDocToStr()
        {
            if (_showAmountOfDocument)
            {
                if (_structVal.index(currencyCodeFieldName) != 0)
                    sz = _structVal.value(currencyCodeFieldName);
                else
                {
                    amount = _structVal.value(amountOfDocFieldName);
                    amount = abs(amount);
                    amountToStr();
                }
            }
            else
            {
                sz = "";
            }
        }

        //---------------------------- start -------------------------------

        ;

        sz = "";

        if (_showNum)
        {
            if (_szNumber)
                sz = _szNumber;
            else if (_conKey != conNull())
            {
                sz = conPeek(_conKey, posINum);
            }
        }

        item = new FormListItem(sz, _imageNum);

        if (_conKey != conNull())
            item.data(this.keyToItemData(_conKey));

        item.idx(idx);

        idx = listControl.addItem(item);

        colNum         = #firstColumnNum;
        maxCx          = _structVal.index(turnoverDebitFieldName);
        idxAmountOfDoc = _structVal.index(amountOfDocFieldName);

        //Output data from STRUCt
        for (cx = _structVal.index(transDateFieldName); cx < maxCx; cx++)
        {
            colNum++;

            if (idxAmountOfDoc == cx)
                amountDocToStr();
            else
                valueToStr();

            listControl.setText(idx, sz, colNum);
        }

        return idx;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insRowTitle</Name>
				<Source><![CDATA[
    //Insert caption into formList
    // _txt                 -> Text.
    // _conKey              -> Key of node.
    // _numColumnTitileTxt  -> Column's number.
    // _image               -> Icon of Item.
    // _idx                 -> Index of FormListItem.
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected int insRowTitle(str _txt, container _conKey, int _numColumnTitileTxt, int _image, int _idx)
    {
        FormListItem item;
        int          idx = _idx + 1;
        ;

        item = new FormListItem("", _image);

        if (_conKey != conNull())
            item.data(this.keyToItemData(_conKey));

        item.idx(idx);

        idx = listControl.addItem(item);

        listControl.setText(idx, _txt, _numColumnTitileTxt);

        return idx;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insRowTotalStruct</Name>
				<Source><![CDATA[
    //Insert row with totals amount in formList
    // _structVal -> Data.
    // _image     -> Icon of Item.
    // _idx       -> Index of FormListItem.
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public int insRowTotalStruct(Struct _structVal, int _image, int _idx)
    {
        return this.insRow(conNull(), _structVal, _image, _idx, "", true, false, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insRowTotalTxt</Name>
				<Source><![CDATA[
    //Insert text for totals partition in formList
    // _txt                 -> Text.
    // _image               -> Icon Item.
    // _idx                 -> Index of FormListItem.
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public int insRowTotalTxt(TempStr _txt, int _image, int _idx)
    {
        return this.insRowTitle(_txt, conNull(), #numColumnTitleTxt, _image, _idx);
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoicePartitionTurnover</Name>
				<Source><![CDATA[
    //Create STRUCT with balance by invoices.
    // _conRootKey      -> Key of partition
    // _txtDescription  -> Description.
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected Struct invoicePartitionTurnover(container _conRootKey, TempStr _txtDescription)
    {
        Struct struct;
        Amount amountDebit, amountCredit;

        if (holderData.getMap().exists(_conRootKey))
        {
            struct = holderData.getMap().lookup(_conRootKey);
        }
        else
        {
            struct = RHolderData_ActAdjustCustVend::emptyStruct();
        }

        amountDebit  = struct.value(amountDebitFieldName);
        amountCredit = struct.value(amountCreditFieldName);

        return RHolderData_ActAdjustCustVend::createStruct(dateNull(), _txtDescription, 0, amountDebit, amountCredit);
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemDataToKey</Name>
				<Source><![CDATA[
    //Transform value of "item.data()" to key.
    //Return: If OK -> key, else conNull().
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected container itemDataToKey(TempStr _itemData)
    {
        container      con            = this.strToKey(_itemData);
        ModuleCustVend moduleCustVend = conPeek(con, 1);

        if (moduleCustVend != this.moduleCustVend())
            return conNull();

        return conDel(con, 1, 1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>keyToItemData</Name>
				<Source><![CDATA[
    //Transform value of key to "item.data()".
    //It returns string for "item.data()".
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected TempStr keyToItemData(container _conKey)
    {
        return int2str(this.moduleCustVend()) + #sepKeyToStr + this.keyToStr(_conKey);
    }

]]></Source>
			</Method>
			<Method>
				<Name>keyToStr</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected str keyToStr(container _conKey)
    {
        return con2Str(_conKey, #sepKeyToStr);
    }

]]></Source>
			</Method>
			<Method>
				<Name>moduleCustVend</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    abstract protected ModuleCustVend moduleCustVend()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void new(RLedgerSheetEngine_ActAdjustCustVend _engine, CustVendTable _custVendTable)
    {
        if (!_engine || !_custVendTable)
            throw error(Error::wrongUseOfFunction(funcName()));

        engine              = _engine;
        custVendTable       = _custVendTable;

        listControl         = engine.parmFormListControl();
        bShowCovenanteeName = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>originalDocuments</Name>
				<Source><![CDATA[
    //Show original document
    //If original document shows on screen -> true
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public boolean originalDocuments(int _idx)
    {
        #define.fieldRecIdName("RecID")
        #define.fieldVoucherName("Voucher")
        #define.fieldTransDateName("TransDate")
        #define.fieldAccountNumName("AccountNum")

        Args                    args = new Args();
        FormRun                 formRun;
        FormDataSource          formDataSource;
        Query                   transQuery;
        QueryBuildDataSource    ds;

        Struct                  struct;
        container               conKey;
        str                     sz;
        TableId                 tableId;
        RecId                   recId;
        TransDate               transDate;
        Voucher                 voucher;

        ;
        if (listControl.getItem(_idx))
        {
            sz     = listControl.getItem(_idx).data();
            conKey = this.itemDataToKey(sz);
        }

        if ((conKey == conNull()) || (! this.canShowOriginalDocuments(conKey)))
            return false;

        struct  = holderData.getMap().lookup(conKey);

        tableId = struct.value(tableIdFieldName);

        args = new Args(this.contragentForm());
        args.caller(this);

        formRun = classfactory.formRunClass(args);

        formRun.init();

        formDataSource = formRun.dataSource();
        transQuery     = formDataSource.query();
        ds             = transQuery.dataSourceTable(tableId);

        if (!ds)
            throw error(Error::wrongUseOfFunction(funcName()));

        if (struct.value(recIdFieldName) != 0)
        {
            recId = struct.value(recIdFieldName);
            ds.addRange(fieldName2id(tableId, #fieldRecIdName)).value(queryValue(recId));
        }
        else
        {
            ds.addRange(fieldName2id(tableId, #fieldAccountNumName)).value(custVendTable.AccountNum);

            transDate = struct.value(transDateFieldName);
            ds.addRange(fieldName2id(tableId, #fieldTransDateName)).value(queryValue(transDate));

            voucher   = struct.value(voucherFieldName);
            ds.addRange(fieldName2id(tableId, #fieldVoucherName)).value(voucher);
        }

        formRun.run();
        formRun.detach();

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>overlayPicture</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void overlayPicture(int _itemIdx, int _img)
    {
        FormListItem item = listControl.getItem(_itemIdx);

        if (item.overlayImage() != _img)
        {
            item.overlayImage(_img);
            listControl.setItem(item);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>partitionBalance</Name>
				<Source><![CDATA[
    //Get balance of the partition
    // _conRootKey      -> Key of partitinon
    // _txtDescription  -> Description.
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected Struct partitionBalance(container _conRootKey, TempStr _txtDescription)
    {
        Struct      struct;
        Amount      amount, amountDebit, amountCredit;

        //Output balance
        if (holderData.getMap().exists(_conRootKey))
        {
            struct = holderData.getMap().lookup(_conRootKey);
        }
        else
        {
            struct = RHolderData_ActAdjustCustVend::emptyStruct();
        }

        amount = struct.value(amountOfDocFieldName);

        [ amountDebit, amountCredit ] = this.calculateBalance(struct);

        return  RHolderData_ActAdjustCustVend::createStruct(dateNull(), _txtDescription, amount, amountDebit, amountCredit, 0, 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>partitionKeys</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected Set partitionKeys(RActAdjustCVPartitionType _actAdjustCVPartitionType)
    {
        Set             set;

        switch (_actAdjustCVPartitionType)
        {
            case RActAdjustCVPartitionType::Covenantee :
                set = this.allCovenanteeKeys();
                break;

            case RActAdjustCVPartitionType::Agreement :
                set = this.allAgreementKeys();
                break;

            case RActAdjustCVPartitionType::InvoicePrevious :
            case RActAdjustCVPartitionType::InvoiceCurrent  :
            case RActAdjustCVPartitionType::PaymentCurrent  :
            case RActAdjustCVPartitionType::PaymentPrevious :

                set = this.allPartitionKeys(_actAdjustCVPartitionType);
                break;

            default :
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return set;
    }

]]></Source>
			</Method>
			<Method>
				<Name>partitionType</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected RActAdjustCVPartitionType partitionType(container _conKey)
    {
        RActAdjustCVPartitionType partitionType;
        TempStr                   sumKeyField = holderData.getSumKeyField();

        if (conPeek(_conKey, posActAdjustCVPartitionType) != sumKeyField)
        {
            partitionType = conPeek(_conKey, posActAdjustCVPartitionType);
        }
        else
        {
            if (byAgreement &&
               conpeek(_conKey, posAgreementHeaderExtRecId) != sumKeyField)
            {
                partitionType = RActAdjustCVPartitionType::Agreement;
            }
            else
            {
                partitionType = RActAdjustCVPartitionType::Covenantee;
            }
        }

        return partitionType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void run()
    {
        container  con;
        ;
        rLedgerSheetServer =  RLedgerSheetServer::construct(this.getRLedgerSheetType());

        con =  engine.getParmContainer();
        con =  conDel(con, conLen(con), 1);
        con += custVendTable.AccountNum;

        rLedgerSheetServer.initParameters(null, con);
        rLedgerSheetServer.run(null);
        this.getDataFromServer();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setShowCovenanteeName</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void setShowCovenanteeName(boolean _newShowCovenanteeName)
    {
        bShowCovenanteeName = _newShowCovenanteeName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shrinkAllAccounts</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void shrinkAllAccounts()
    {
        container       conKey, conKeyCovenantee;
        MapEnumerator   en, enCovenantee;
        Map             map;

        listControl.lock();

        en = mapKeys.getEnumerator();

        while (en.moveNext())
        {
            conKey       = en.currentKey();
            map          = en.currentValue();

            enCovenantee = map.getEnumerator();

            while (enCovenantee.moveNext())
            {
                conKeyCovenantee = enCovenantee.currentKey();
                this.shrinkNode(conKeyCovenantee, false);
            }
        }

        listControl.unLock(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shrinkAllPartitions</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void shrinkAllPartitions(RActAdjustCVPartitionType _actAdjustCVPartitionType)
    {
        SetEnumerator   en;
        Set             set;
        container       conKey;

        listControl.lock();

        set = this.partitionKeys(_actAdjustCVPartitionType);
        en  = set.getEnumerator();

        while (en.moveNext())
        {
            conKey = en.current();
            this.shrinkNode(conKey, false);
        }

        listControl.unLock(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shrinkNode</Name>
				<Source><![CDATA[
    //Shrink node
    // _conKey   -> Key of node which necessary shrink.
    // _lockForm -> Lock form.
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void shrinkNode(container _conKey, boolean _lockForm = true)
    {
        Map             map;
        Set             setKeys;

        ;

        if (_lockForm)
            listControl.lock();

        setShrinkKeys.add(_conKey);

        map = this.findNodeInMapKeys(_conKey);

        if (map)
        {
            setKeys = this.childNodeKeys(map);

            this.deleteItems(setKeys);

            this.expandNode(_conKey, false, false);
        }

        if (_lockForm)
            listControl.unLock(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shrinkTxt</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    abstract protected TempStr shrinkTxt()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>strToKey</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected container strToKey(str _sValue)
    {
        int         length     = strLen(_sValue);
        int         posCurrent = 1;
        int         posSep     = strScan(_sValue, #sepKeyToStr, 1, length);
        container   con        = conNull();
        str         sz;

        while (posSep)
        {
            sz = subStr(_sValue, posCurrent, posSep - posCurrent);
            con += sz;

            posCurrent = posSep + strLen(#sepKeyToStr);
            posSep = strScan(_sValue, #sepKeyToStr, posCurrent, length);
        }

        if (length > 0)
        {
            sz = subStr(_sValue, posCurrent, length);
            con += sz;
        }

        return con;
    }

]]></Source>
			</Method>
			<Method>
				<Name>structBalanceBegPeriod</Name>
				<Source><![CDATA[
    //Balance on beginning of period
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public Struct structBalanceBegPeriod()
    {
        return rLedgerSheetServer.getCovenanteeBegPeriodBalance();
    }

]]></Source>
			</Method>
			<Method>
				<Name>structBalanceEndPeriod</Name>
				<Source><![CDATA[
    //Return STRUCT with balance over period.
    // _txt -> Text of column "Origin".
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public Struct structBalanceEndPeriod(TempStr _txt)
    {
        this.balanceAndTurnoverCovenantee();  //Calculate totals

        return RHolderData_ActAdjustCustVend::createStruct(dateNull(), _txt, 0, amountDebitBalance, amountCreditBalance, 0, 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>structTurnover</Name>
				<Source><![CDATA[
    //Return STRUCT there is balance over a period
    // _txt -> Text of column "Origin".
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public Struct structTurnover(TempStr _txt)
    {
        this.balanceAndTurnoverCovenantee();  //Calculate totals

        return RHolderData_ActAdjustCustVend::createStruct(dateNull(), _txt, 0, turnoverDebit, turnoverCredit, 0, 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>txtBalanceCovenantee</Name>
				<Source><![CDATA[
    //Get text for string "Balance of covenantee"
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    abstract protected TempStr txtBalanceCovenantee()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>txtCovenanteeName</Name>
				<Source><![CDATA[
    //Get text for string "Covenantee"
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    abstract protected TempStr txtCovenanteeName()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>txtTurnoverCovenantee</Name>
				<Source><![CDATA[
    //Get text for string "Turnover of covenantee"
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    abstract protected TempStr txtTurnoverCovenantee()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>understandLineType</Name>
				<Source><![CDATA[
    #define.captionPos(1)
    #define.begBalancePos(2)
    private RActAdjustCVReportLineType understandLineType(int _pos)
    {
        RActAdjustCVReportLineType ret;

        switch (_pos)
        {
            case #captionPos    :
                ret = RActAdjustCVReportLineType::Caption;
                break;

            case #begBalancePos :
                ret = RActAdjustCVReportLineType::BalanceBegPeriod;
                break;

            default :
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    static public RActAdjustEngineKernelCustVend construct(ModuleCustVend     _moduleCustVend,
                                                           RLedgerSheetEngine _engine,
                                                           CustVendTable      _custVendTable)
    {
        RActAdjustEngineKernelCustVend ret;

        switch (_moduleCustVend)
        {
            case ModuleCustVend::Cust :
                ret = new RActAdjustEngineKernelCust(_engine, _custVendTable);
                break;

            case ModuleCustVend::Vend :
                ret = new RActAdjustEngineKernelVend(_engine, _custVendTable);
                break;

            default :
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return ret;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>