<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ReqTransUpdate</Name>
	<SourceCode>
		<Declaration><![CDATA[
class ReqTransUpdate
{
    #Req

    // Parameters

    ItemId              itemId;
    InventTransRefId    transRefIdFilter;
    InventTransType     excludeTransTypeFilter;
    boolean             filterTransactions;

    // Global objects

    ReqPlanData         reqPlanData;
    ReqTransCache       reqTransCache;

    // Tmp global objects

    ReqSetup            setup;
    ReqSetupDim         setupDim;

    ReqTransNeutralTracker_Update neutralTracker;

    // Tmp global variables

    InventDimId         lastInventDimId;
    ItemId              lastItemId;

    ReqRefType          refType;
    InventTransRefId    refId;

    InventTransOriginId refInventTransOriginId;

    Integer             refPriority;

    PdsExpiryDate       refExpiryDate;
    PdsSellableDays     refSellableDays;

    ReqNumOfChanges     numOfChanges;
    boolean             updateSoftDeletedOnly;
    boolean             isDefaultDynamicPlanLocked;
    boolean             hasSalesReturnScrap = false;
    
    private InventTable inventTable;
    private Set inventTransOriginsWithSafeDateStatusChange;

    ReqMemoryCacheCurrentSessionScope memoryCacheScope;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>deleteLog</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Deletes or marks for deletion the record in the <c>InventSumLogTTS</c> table.
    /// </summary>
    /// <param name="_inventSumLogTTS">
    ///     The record to be deleted or marked for deletion.
    /// </param>
    private void deleteLog(InventSumLogTTS _inventSumLogTTS)
    {
        ttsbegin;

        if (!isDefaultDynamicPlanLocked || this.parmUpdateSoftDeletedOnly())
        {
            _inventSumLogTTS.delete();
        }
        else
        {
            _inventSumLogTTS.SoftDeleted = NoYes::Yes;
            _inventSumLogTTS.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    public void init()
    {
        if (! reqPlanData)
        {
            reqPlanData = ReqPlanData::newReqPlanId(ReqPlanSched::defaultDynamicId());
        }

        isDefaultDynamicPlanLocked = ReqPlanManager::isDefaultDynamicReqPlanLocked();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRef</Name>
				<Source><![CDATA[
    protected void initRef(InventSumLogTTS _inventSumLogTTS)
    {
        if (_inventSumLogTTS.isStatusPhysical())
        {
            refType                 = ReqRefType::InventOnHand;
            refId                   = '';
            refInventTransOriginId  = 0;
            refPriority             = 0;
        }
        else
        {
            refType                 = ReqTrans::transType2RefType(_inventSumLogTTS.TransType,_inventSumLogTTS.Qty);
            refId                   = _inventSumLogTTS.TransRefId;
            refInventTransOriginId  = _inventSumLogTTS.InventTransOrigin;
            refPriority             = ReqTrans::statusIssue2Priority(_inventSumLogTTS.StatusIssue);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSetupDim</Name>
				<Source><![CDATA[
    protected void initSetupDim(
        InventSumLogTTS _inventSumLogTTS,
        InventDim       _inventDim
        )
    {
        if (! setup || setup.itemId() != _inventSumLogTTS.ItemId)
        {
            setup = reqPlanData.newReqSetup(_inventSumLogTTS.ItemId, this.findInventTable(_inventSumLogTTS.ItemId));

            lastInventDimId = '';
        }

        if (_inventSumLogTTS.InventDimId != lastInventDimId)
        {
            setupDim        = reqPlanData.newReqSetupDim(setup,_inventDim.reqCovDimId(InventDimGroupSetup::newItemId(_inventSumLogTTS.ItemId)));

            lastInventDimId = _inventSumLogTTS.InventDimId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initShelfLifeRef</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the shelf life related fields.
    /// </summary>
    /// <param name="_inventSumLogTTS">
    /// The <c>inventSum</c> record to initialize from.
    /// </param>
    /// <param name="_inventDim">
    /// The <c>inventDim</c> record to initialize from.
    /// </param>
    protected void initShelfLifeRef(InventSumLogTTS _inventSumLogTTS,
                                    InventDim       _inventDim)
    {
        SalesLine salesLine;

        refExpiryDate = dateNull();
        refSellableDays = 0;

        if (this.mustValidateShelfLife())
        {
            if (ReqTrans::refTypeIsReceipt(refType))
            {
                // Set the expiry date either from the batch or item
                if (_inventDim && _inventDim.InventBatchId)
                {
                    refExpiryDate = InventBatch::find(_inventDim.InventBatchId, setup.itemId()).pdsEffectiveExpiryDate();
                }

                if (!refExpiryDate)
                {
                    refExpiryDate = setup.inventTable().pdsEffectExpiryDate(_inventSumLogTTS.DateStatus);
                }
            }

            if (refType == ReqRefType::Sales)
            {
                // Sets the number of days from the sales line's shipping date that the product must be sellable.
                salesLine = InventTransOriginSalesLine::salesLine(_inventSumLogTTS.InventTransOrigin);
                if (salesLine)
                {
                    refSellableDays = salesLine.pdsSellableDays(_inventDim);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustValidateShelfLife</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine whether shelf life must be validated for master plan.
    /// </summary>
    /// <returns>true if shelf life must be validated for master plan; otherwise, false.</returns>
    protected boolean mustValidateShelfLife()
    {
        return reqPlanData.pdsUseShelfLife() && setup.inventTable().PdsShelfLife;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNotQuotation</Name>
				<Source><![CDATA[
    protected boolean isNotQuotation(InventSumLogTTS _addLog)
    {
        if (_addLog.StatusIssue     != StatusIssue::QuotationIssue      &&
            _addLog.StatusReceipt   != StatusReceipt::QuotationReceipt  )
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isQuotationIncluded</Name>
				<Source><![CDATA[
    protected boolean isQuotationIncluded(InventSumLogTTS _addLog)
    {
        if (_addLog.StatusIssue     == StatusIssue::QuotationIssue      && reqPlanData.useQuotations())
        {
            return true;
        }

        if (_addLog.StatusReceipt   == StatusReceipt::QuotationReceipt  && reqPlanData.useRequestsForQuote())
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateFields</Name>
				<Source><![CDATA[
    protected boolean mustUpdateFields(
        InventSumLogTTS _addLog,
        InventSumLogTTS _subLog
        )
    {
        if (! _addLog.RecId || ! _subLog.RecId)
        {
            return false;
        }

        if ((_addLog.StatusIssue   && _addLog.StatusIssue     <= StatusIssue::Picked         && _subLog.StatusIssue      <= StatusIssue::Picked) ||
            (_addLog.StatusReceipt && _addLog.StatusReceipt   <= StatusReceipt::Registered   && _subLog.StatusReceipt    <= StatusReceipt::Registered))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the requirement profile should be updated by subtract and add
    ///    <c>InventSumLogTTS</c> records.
    /// </summary>
    /// <param name="_addLog">
    ///    A <c>InventSumLogTTS</c> record that represent the from state of an inventory transaction change.
    /// </param>
    /// <param name="_subLog">
    ///    A <c>InventSumLogTTS</c> record that represents the to state of an inventory transaction change.
    /// </param>
    /// <returns>
    ///    true if the requirement profile should be updated; otherwise, false.
    /// </returns>
    protected boolean mustUpdateQty(
        InventSumLogTTS _addLog,
        InventSumLogTTS _subLog
        )
    {
        if (! _addLog.RecId || ! _subLog.RecId)
        {
            return true;
        }

        if (_addLog.ItemId              !=   _subLog.ItemId             ||
            _addLog.InventDimId         !=   _subLog.InventDimId        ||
            _addLog.Qty                 !=   _subLog.Qty)
        {
            return true;
        }

        // Update the requirement profile if the transaction has been marked or unmarked and the transaction was not already physically updated
        if (      _addLog.InventTransOriginRef  != _subLog.InventTransOriginRef
            && !( _addLog.isStatusPhysical()    && _subLog.isStatusPhysical())
           )
        {
            return true;
        }

        if ((_addLog.StatusIssue     <= StatusIssue::Picked         && _subLog.StatusIssue      > StatusIssue::Picked) ||
            (_addLog.StatusReceipt   <= StatusReceipt::Registered   && _subLog.StatusReceipt    > StatusReceipt::Registered))
        {
            return true;
        }

        //The below code is used for unregistered QTY for purchase line or unpick for sales line.
        if ((_addLog.StatusIssue   > StatusIssue::Picked       && _subLog.StatusIssue   <= StatusIssue::Picked) ||
            (_addLog.StatusReceipt > StatusReceipt::Registered && _subLog.StatusReceipt <= StatusReceipt::Registered))
        {
            return true;
        }

        if (ReqTrans::statusIssue2Priority(_addLog.StatusIssue) != ReqTrans::statusIssue2Priority(_subLog.StatusIssue))
        {
            return true;
        }

        if ((_addLog.StatusIssue     < StatusIssue::QuotationIssue && _subLog.StatusIssue      == StatusIssue::QuotationIssue) ||
            (_addLog.StatusReceipt   < StatusReceipt::QuotationReceipt && _subLog.StatusReceipt == StatusReceipt::QuotationReceipt))
        {
            return true;
        }

        if (this.mustValidateDateStatusForShelfLife(_addLog, _subLog))
        {
            if (inventTransOriginsWithSafeDateStatusChange
                && inventTransOriginsWithSafeDateStatusChange.in(_addLog.InventTransOrigin)
                && inventTransOriginsWithSafeDateStatusChange.in(_subLog.InventTransOrigin))
            {
                return false;
            }
            // On shelf life items the date will affect the search for existing ReqTrans so a full sub/add must be done
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustValidateDateStatusForShelfLife</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine whether date status must be validated for shelf life.
    /// </summary>
    /// <param name = "_addLog">Add state of inventory transaction record.</param>
    /// <param name = "_subLog">Subtract state of inventory transaction record.</param>
    /// <returns>true if date status must be validated for shelf life; otherwise, false.</returns>
    protected boolean mustValidateDateStatusForShelfLife(InventSumLogTTS _addLog, InventSumLogTTS _subLog)
    {
        return  _addLog.DateStatus != _subLog.DateStatus
           && reqPlanData.pdsUseShelfLife()
           && this.findInventTable(_addLog.ItemId).PdsShelfLife;
    }

]]></Source>
			</Method>
			<Method>
				<Name>filterByRefIdAndExcludeType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Filters the selected transaction log.
    /// </summary>
    /// <param name="_includeRefId">
    /// The reference ID to include into the selection.
    /// </param>
    /// <param name="_excludeType">
    /// The reference type to exclude from the selection.
    /// </param>
    public void filterByRefIdAndExcludeType(InventTransRefId _includeRefId, InventTransType _excludeType)
    {
        filterTransactions = true;
        transRefIdFilter = _includeRefId;
        excludeTransTypeFilter = _excludeType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numOfChanges</Name>
				<Source><![CDATA[
    ReqNumOfChanges numOfChanges()
    {
        return numOfChanges;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItemId</Name>
				<Source><![CDATA[
    public ItemId parmItemId(ItemId _itemId = itemId)
    {
        itemId = _itemId;
        return itemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReqPlanData</Name>
				<Source><![CDATA[
    public ReqPlanData parmReqPlanData(ReqPlanData _reqPlanData = reqPlanData)
    {
        reqPlanData = _reqPlanData;
        return reqPlanData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReqTransCache</Name>
				<Source><![CDATA[
    public ReqTransCache parmReqTransCache(ReqTransCache _reqTransCache = reqTransCache)
    {
        reqTransCache = _reqTransCache;
        return reqTransCache;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateSoftDeletedOnly</Name>
				<Source><![CDATA[
    public boolean parmUpdateSoftDeletedOnly(boolean _updateSoftDeletedOnly = updateSoftDeletedOnly)
    {
        updateSoftDeletedOnly = _updateSoftDeletedOnly;
        return updateSoftDeletedOnly;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventSumLogTTSEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the update from InventSumLogTTS is allowed.
    /// </summary>
    /// <returns>true if the update is allowed; otherwise, false.</returns>
    [Replaceable]
    public boolean isInventSumLogTTSEnabled()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        #OCCRetryCount

        if (!this.isInventSumLogTTSEnabled())
        {
            return;
        }

        try
        {
            if (reqPlanData)
            {
                reqPlanData.createReqLogRestorePoint();
            }

            if (!this.validate())
            {
                throw error("@SYS25904");
            }

            ttsbegin;

            this.update();

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            if (reqPlanData)
            {
                reqPlanData.restoreReqLog();
                reqPlanData.incrementRetryReqLog(Exception::Deadlock);
            }
            retry;
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (ReqTransientSqlConnectionErrorHandlingHelper::retryTransientSqlConnectionError())
            {
                if (reqPlanData)
                {
                    reqPlanData.restoreReqLog();
                    reqPlanData.incrementRetryReqLog(Exception::TransientSqlConnectionError);
                }
                retry;
            }
            else
            {
                throw;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    if (reqPlanData)
                    {
                        reqPlanData.restoreReqLog();
                        reqPlanData.incrementRetryReqLog(Exception::UpdateConflict);
                    }
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectLog</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Selects the records from the <c>InventSumLogTTS</c> table which must be processed in the requirements profile.
    /// </summary>
    /// <param name="_itemId">
    ///     The ID of the item to process.
    /// </param>
    /// <returns>
    ///     The collection of the <c>InventSumLogTTS</c> table records.
    /// </returns>
    [SuppressBPWarning('BPErrorSelectUsingFirstOnly', 'The buffer is used in next statement or in a datasource query loop.')]
    private InventSumLogTTS selectLog(ItemId _itemId)
    {
        InventSumLogTTS inventSumLogTTS;

        select forupdate inventSumLogTTS
        order by utcCreatedDateTime, ttsId, SequenceNumber desc, AddTrans
        where
            inventSumLogTTS.ItemId == _itemId
            && inventSumLogTTS.SoftDeleted == this.parmUpdateSoftDeletedOnly()
            && (
                (inventSumLogTTS.TransRefId == transRefIdFilter || inventSumLogTTS.TransType != excludeTransTypeFilter)
                || !filterTransactions
               );

        return inventSumLogTTS;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectReqTrans</Name>
				<Source><![CDATA[
    private ReqTrans selectReqTrans(InventSumLogTTS _log)
    {
        ReqTrans reqTrans;
        select firstonly forupdate reqTrans
            where reqTrans.PlanVersion          == reqPlanData.parmReqPlanVersionRefRecId() &&
                  reqTrans.RefType              == refType                               &&
                  reqTrans.RefId                == refId                                 &&
                  reqTrans.InventTransOrigin    == refInventTransOriginId                &&
                  reqTrans.ItemId               == _log.ItemId                           &&
                  reqTrans.CovInventDimId       == setupDim.parmCovInventDimId()         &&
                  reqTrans.Priority             == refPriority                           &&
                  reqTrans.PdsExpiryDate        == refExpiryDate                         &&
                 (refType == ReqRefType::InventOnHand || reqTrans.MarkingRefInventTransOrigin == _log.InventTransOriginRef);

        return reqTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    protected void update()
    {
        InventSumLogTTS         addLog;
        InventSumLogTTS         subLog;

        InventDim               addDim;
        InventDim               subDim;

        CreatedTransactionId lastTTSId = 0;
        Counter lastSequenceNumber = 0;

        InventSumLogTTS inventSumLogTTS = this.selectLog(itemId);

        neutralTracker = new ReqTransNeutralTracker_Update();

        using (var cacheScope = new ReqMemoryCacheCurrentSessionScope())
        {
            memoryCacheScope = cacheScope;
            while (inventSumLogTTS.RecId)
            {
                numOfChanges++;

                if (reqPlanData.newReqSetup(inventSumLogTTS.ItemId).mustItemReqBeCreated())
                {
                    InventDim inventDim = InventDim::find(inventSumLogTTS.InventDimId);

                    boolean includeInventSumLogTTS = true;
                    if (inventDim.InventBatchId)
                    {
                        InventBatch inventBatch = InventBatch::find(inventDim.InventBatchId, inventSumLogTTS.ItemId);
                        PdsBatchDispNettableCheck nettableCheck = PdsBatchDispNettableCheck::construct();
                        nettableCheck.parmBatch(inventBatch);
                        includeInventSumLogTTS = nettableCheck.checkInclude();
                    }
                    if (includeInventSumLogTTS)
                    {
                        if (lastSequenceNumber  &&
                           (lastSequenceNumber  != inventSumLogTTS.SequenceNumber ||
                            lastTTSId           != inventSumLogTTS.ttsId))
                        {
                            this.updateLog(addLog,addDim,subLog,subDim);

                            addLog.clear();
                            subLog.clear();
                        }

                        if (inventSumLogTTS.AddTrans)
                        {
                            addLog.data(inventSumLogTTS);
                            addDim.data(inventDim);
                        }
                        else
                        {
                            subLog.data(inventSumLogTTS);
                            subDim.data(inventDim);
                        }

                        lastTTSId           = inventSumLogTTS.ttsId;
                        lastSequenceNumber  = inventSumLogTTS.SequenceNumber;
                    }
                }

                this.deleteLog(inventSumLogTTS);

                next inventSumLogTTS;
            }

            if (lastSequenceNumber)
            {
                this.updateLog(addLog,addDim,subLog,subDim);
            }

            neutralTracker.deleteNeutralizableTransactions(setup);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLog</Name>
				<Source><![CDATA[
    protected void updateLog(
        InventSumLogTTS     _addLog,
        InventDim           _addDim,
        InventSumLogTTS     _subLog,
        InventDim           _subDim)
    {
        Map                     mapReqTransCov;
        boolean                 moveSettlement;

        if (this.mustUpdateQty(_addLog,_subLog))
        {
            moveSettlement = this.mustMoveSettlement(_addLog, _subLog);

            if (moveSettlement && _addLog.RecId && _subLog.RecId && _addDim.InventDimId != _subDim.InventDimId)
            {
                this.initSetupDim(_addLog,_addDim);

                if (! InventDim::isInventDimEqualCovDim(InventDimGroupSetup::newItemId(setup.itemId()), _subDim, _addDim))
                {
                    moveSettlement = false;
                }
            }

            if (moveSettlement && _addLog.RecId && _subLog.RecId && this.mustValidateDateStatusForShelfLife(_addLog, _subLog))
            {
                // When using sellable days and the date has changed, the coverage must be removed as it may not be valid any more
                moveSettlement = false;
            }

            if (_subLog.RecId)
            {
                mapReqTransCov = this.updateLogSubQty(_subLog,_subDim,moveSettlement);
            }

            if (_addLog.RecId)
            {
                mapReqTransCov = this.updateLogAddQty(_addLog,_addDim,mapReqTransCov);
            }

            this.removeTransactionCoverage(mapReqTransCov);
        }
        else if (this.mustUpdateFields(_addLog,_subLog))
        {
            this.updateLogfields(_addLog,_addDim);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustMoveSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the requirement profile should move settlement by subtract and add
    ///    <c>InventSumLogTTS</c> records.
    /// </summary>
    /// <param name="_addLog">
    ///    A <c>InventSumLogTTS</c> record that represent the from state of an inventory transaction change.
    /// </param>
    /// <param name="_subLog">
    ///    A <c>InventSumLogTTS</c> record that represents the to state of an inventory transaction change.
    /// </param>
    /// <returns>
    ///    true if settlement must be moved; otherwise, false.
    /// </returns>
    [Hookable(false)]
    protected boolean mustMoveSettlement(
        InventSumLogTTS _addLog,
        InventSumLogTTS _subLog)
    {
        if (_addLog.RecId && _subLog.RecId)
        {
            if (!InventTrans::isStatusIssueIncludedInPhysicalInventory(_addLog.StatusIssue)
                && !InventTrans::isStatusIssueIncludedInPhysicalInventory(_subLog.StatusIssue)
                && (_addLog.InventTransOriginRef == _subLog.InventTransOriginRef || !_subLog.InventTransOriginRef))
            {
                return true;
            }
        }
        else if (_addLog.RecId && !_subLog.RecId)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLogAddQty</Name>
				<Source><![CDATA[
    protected Map updateLogAddQty(
        InventSumLogTTS     _addLog,
        InventDim           _addDim,
        Map                 _mapReqTransCov)
    {
        ReqTrans        reqTrans;
        ReqTransCov     reqTransCov;

        MapIterator     mi_reqTransCov;
        boolean         deleted = false;

        if (_addLog.RecId)
        {
            this.initSetupDim(_addLog,_addDim);
        }

        if (_addLog.RecId && setupDim.mustReqBeCreated(_addDim))
        {
            this.initRef(_addLog);
            this.initShelfLifeRef(_addLog, _addDim);

            reqTrans = this.selectReqTrans(_addLog);

            // update existing record
            if (reqTrans.RecId)
            {
                reqTrans.Qty += this.returnOrderScrapInCache(reqTrans.RecId) ? 0 : _addLog.Qty;

                deleted = this.updateReqTransFields(reqTrans,_addLog,!_mapReqTransCov);

                if (!deleted && !_mapReqTransCov)
                {
                    this.updateAndTrackReqTrans(reqTrans, reqPlanData, false); // reqTrans, reqPlanData, _deleteCoverage = false
                }
            }
            else
            {
                // create new
                reqTrans.clear();

                if (this.mustInsertReqTrans(_addLog))
                {
                    if (   this.isNotQuotation(_addLog)
                        || this.isQuotationIncluded(_addLog))
                    {
                        this.initializeReqTrans(reqTrans, _addLog);
                        
                        reqTrans.insert();

                        if(memoryCacheScope && reqTrans.RefType == ReqRefType::Sales && reqTrans.Qty == 0 && reqTrans.CovQty == 0 && _addLog.Qty > 0)
                        {
                            ReqMemoryCache::addToCurrentSessionScope(this.getCacheKey(reqTrans.RecId), true, memoryCacheScope);
                            hasSalesReturnScrap = true;
                        }

                        if (neutralTracker && ReqTransNeutralTracker::canBeNeutralized(reqTrans, setup))
                        {
                            neutralTracker.trackReqTrans(reqTrans);
                        }

                        if (reqTransCache)
                        {
                            reqTransCache.add(reqTrans);
                        }
                    }
                }
            }

            // add settlements

            if (!deleted && reqTrans.RecId && _mapReqTransCov)
            {
                mi_reqTransCov = new MapIterator(_mapReqTransCov);
                mi_reqTransCov.begin();
                while (mi_reqTransCov.more())
                {
                    reqTransCov = mi_reqTransCov.value();

                    if (reqTransCov.ReceiptRecId == 0)
                    {
                        reqTransCov.ReceiptRecId    = reqTrans.RecId;
                        reqTrans.CovQty            -= reqTransCov.Qty;
                    }
                    else
                    {
                        reqTransCov.IssueRecId      = reqTrans.RecId;
                        reqTrans.CovQty            += reqTransCov.Qty;
                    }

                    if (reqTransCov.ReceiptRecId != reqTransCov.IssueRecId)
                    {
                        reqTransCov.update();
                    }
                    else
                    {
                        reqTransCov.delete();
                    }

                    mi_reqTransCov.next();
                }

                this.updateAndTrackReqTrans(reqTrans, reqPlanData);
                _mapReqTransCov = null;
            }
        }

        return _mapReqTransCov;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeReqTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the requirements profile.
    /// </summary>
    /// <param name = "_reqTrans">
    ///     A <c>ReqTrans</c> record to be initialized.
    /// </param>
    /// <param name = "_addLog">
    ///     A <c>InventSumLogTTS</c> record to initialize from.
    /// </param>
    protected void initializeReqTrans(
        ReqTrans        _reqTrans,
        InventSumLogTTS _addLog)
    {
        _reqTrans.PlanVersion                    = reqPlanData.parmReqPlanVersionRefRecId();
        _reqTrans.ItemId                         = setup.itemId();
        _reqTrans.CovInventDimId                 = setupDim.parmCovInventDimId();
        _reqTrans.MarkingRefInventTransOrigin    = _addLog.InventTransOriginRef;
        _reqTrans.Priority                       = refPriority;
        _reqTrans.Qty                            = _addLog.Qty;
        _reqTrans.RefType                        = refType;
        _reqTrans.PdsExpiryDate                  = refExpiryDate;
        _reqTrans.PdsSellableDays                = refSellableDays;

        _reqTrans.setSupplyDemandSubClassification(_addLog.TransType);

        if (refType != ReqRefType::InventOnHand)
        {
            _reqTrans.InventTransOrigin  = refInventTransOriginId;
            _reqTrans.RefId              = refId;

            _reqTrans.initFromInventSumLogTTS(_addLog);
            _reqTrans.initDateTimeFromInvent(_addLog.DateStatus,_addLog.TimeExpected,reqPlanData,setupDim);

            _reqTrans.OprNum         = ReqTrans::findOprNum(refType,_reqTrans.InventTransOrigin,reqPlanData);

            _reqTrans.initFromInventTransOrigin(null,setupDim);
        }

        _reqTrans.Level              = setupDim.itemLevel();
        _reqTrans.PlanVersion        = reqPlanData.parmReqPlanVersionRefRecId();
        _reqTrans.FuturesCalculated  = NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustInsertReqTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the requirement profile must be inserted.
    /// </summary>
    /// <param name="_addLog">
    ///    A <c>InventSumLogTTS</c> record that represent the from state of an inventory transaction change.
    /// </param>
    /// <returns>
    ///    true if requirement profile must be inserted; otherwise, false.
    /// </returns>
    protected boolean mustInsertReqTrans(InventSumLogTTS _addLog)
    {
        return (_addLog.DateStatus < reqPlanData.todaysdate() + reqPlanData.timeFenceCoverage(setupDim));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLogfields</Name>
				<Source><![CDATA[
    protected void updateLogfields(
        InventSumLogTTS     _addLog,
        InventDim           _addDim
        )
    {
        ReqTrans        reqTrans;

        if (_addLog.RecId)
        {
            this.initSetupDim(_addLog,_addDim);
            this.initRef(_addLog);
            this.initShelfLifeRef(_addLog, _addDim);

            select firstonly forupdate reqTrans
                where reqTrans.PlanVersion                  == reqPlanData.parmReqPlanVersionRefRecId()
                   && reqTrans.RefType                      == refType
                   && reqTrans.RefId                        == refId
                   && reqTrans.InventTransOrigin            == refInventTransOriginId
                   && reqTrans.ItemId                       == _addLog.ItemId
                   && reqTrans.CovInventDimId               == setupDim.parmCovInventDimId()
                   && reqTrans.MarkingRefInventTransOrigin  == _addLog.InventTransOriginRef
                   && reqTrans.Priority                     == refPriority
                   && reqTrans.PdsExpiryDate                == refExpiryDate
                   && reqTrans.PdsSellableDays              == refSellableDays;

            if (reqTrans.RecId) // update existing record
            {
                this.updateReqTransFields(reqTrans,_addLog);
            }
            else
            {
                this.updateLogAddQty(_addLog, _addDim, null);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLogSubQty</Name>
				<Source><![CDATA[
    protected Map updateLogSubQty(
        InventSumLogTTS _subLog,
        InventDim       _subDim,
        boolean         _moveSettlements
        )
    {
        ReqTrans            reqTrans;

        ReqTransCov         reqTransCov;
        ReqTransCov         reqTransCovSplit;

        Map                 mapReqTransCov;

        InventQty           covQtyChange;

        if (_subLog.RecId)
        {
            this.initSetupDim(_subLog,_subDim);
            this.initRef(_subLog);
            this.initShelfLifeRef(_subLog, _subDim);

            reqTrans = this.selectReqTrans(_subLog);

            if (!reqTrans.RecId && refType == ReqRefType::InventOnHand)
            {
                this.initializeReqTrans(reqTrans, _subLog);
                reqTrans.Qty = 0;
                reqTrans.insert();
            }

            if (reqTrans.RecId)
            {
                if (reqTrans.CovQty != 0)  // reduce settlements
                {
                    if (_moveSettlements)  // settlements should be handled before free qty
                    {
                        if (abs(reqTrans.CovQty) < abs(_subLog.Qty))
                        {
                            covQtyChange = -reqTrans.CovQty;
                        }
                        else
                        {
                            covQtyChange = -_subLog.Qty;
                        }
                    }
                    else
                    {
                        if (abs(reqTrans.CovQty) > abs(reqTrans.Qty - _subLog.Qty))
                        {
                            covQtyChange = reqTrans.Qty - reqTrans.CovQty - _subLog.Qty;
                        }
                        else
                        {
                            covQtyChange = 0;
                        }
                    }

                    if (covQtyChange != 0)
                    {
                        /*
                            Load existing settlements
                        */

                        reqTransCov = reqTrans.selectCov(true);
                        while (reqTransCov.RecId)
                        {
                            if (reqTransCov.Qty == 0 && reqTrans.Qty - _subLog.Qty == 0) // Delete action coverage
                            {
                                reqTransCov.delete();
                            }
                            else
                            {
                                if (! mapReqTransCov && _moveSettlements)
                                {
                                    mapReqTransCov = new Map(typeName2Type(extendedtypestr(recId)), Types::Record);
                                }

                                if (abs(reqTransCov.Qty) > abs(covQtyChange))   // split settlement
                                {
                                    if (_moveSettlements)
                                    {
                                        reqTransCovSplit.data(reqTransCov);
                                        reqTransCovSplit.Qty = -abs(covQtyChange);

                                        if (reqTrans.Qty >= 0)
                                        {
                                            reqTransCovSplit.ReceiptRecId = 0;
                                        }
                                        else
                                        {
                                            reqTransCovSplit.IssueRecId   = 0;
                                        }

                                        reqTransCovSplit.insert();

                                        mapReqTransCov.insert(reqTransCovSplit.RecId,reqTransCovSplit);
                                    }
                                    else
                                    {
                                        this.updateReqTransSettled(reqTrans,reqTransCov,covQtyChange);
                                    }

                                    reqTrans.CovQty += reqTrans.Qty > 0 ? -abs(covQtyChange) : abs(covQtyChange);

                                    reqTransCov.Qty += abs(covQtyChange);
                                    reqTransCov.update();

                                    covQtyChange = 0;
                                }
                                else
                                {
                                    if (_moveSettlements)
                                    {
                                        if (reqTrans.Qty >= 0)
                                        {
                                            reqTransCov.ReceiptRecId = 0;
                                        }
                                        else
                                        {
                                            reqTransCov.IssueRecId   = 0;
                                        }

                                        mapReqTransCov.insert(reqTransCov.RecId,reqTransCov);
                                    }
                                    else
                                    {
                                        //                                    this.updateReqTransSettled(reqTrans,reqTransCov,covQtyChange); BO 6/1-3
                                        this.updateReqTransSettled(reqTrans,reqTransCov,(reqTrans.Qty > 0 ? reqTransCov.Qty : -reqTransCov.Qty));

                                        reqTransCov.delete();
                                    }

                                    covQtyChange    += reqTrans.Qty > 0 ? -reqTransCov.Qty :  reqTransCov.Qty;
                                    reqTrans.CovQty += reqTrans.Qty > 0 ?  reqTransCov.Qty : -reqTransCov.Qty;
                                }

                                if (! covQtyChange)
                                {
                                    break;
                                }
                            }

                            next reqTransCov;
                        }
                    }
                }

                reqTrans.Qty -=  this.returnOrderScrapInCache(reqTrans.RecId) ? 0 : _subLog.Qty;

                this.updateAndTrackReqTrans(reqTrans, reqPlanData, false);
            }
        }

        return mapReqTransCov;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReqTransFields</Name>
				<Source><![CDATA[
    protected boolean updateReqTransFields(
        ReqTrans            _reqTrans,
        InventSumLogTTS     _inventSumLogTTS,
        boolean             _coverageDelete = true
        )
    {
        boolean deleted = false;

        if (_inventSumLogTTS.RecId && _reqTrans.RecId)
        {
            if (_reqTrans.RefType != ReqRefType::InventOnHand)
            {
                _reqTrans.IsDerivedDirectly = NoYes::No;
                _reqTrans.initFromInventSumLogTTS(_inventSumLogTTS);
                _reqTrans.initDateTimeFromInvent(_inventSumLogTTS.DateStatus,_inventSumLogTTS.TimeExpected,reqPlanData,setupDim);

                _reqTrans.initializeReceiptTime();

                // both ReqDate and ReqDateDlvOrig were just reset, so FuturesDate should also be reset
                _reqTrans.resetFutures();
            }

            _reqTrans.Level        = setupDim.itemLevel();

            deleted = this.updateAndTrackReqTrans(_reqTrans,null,_coverageDelete);
        }

        return deleted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAndTrackReqTrans</Name>
				<Source><![CDATA[
    private boolean updateAndTrackReqTrans(
        ReqTrans    _reqTrans,
        ReqPlanData _reqPlanData    = null,
        boolean     _coverageDelete = true,
        boolean     _updateSettledReqTransCovQty = true)
    {
        boolean deleted = ReqTransUpdate::updateReqTrans(_reqTrans, _reqPlanData, _coverageDelete, _updateSettledReqTransCovQty);

        if (!deleted && neutralTracker && ReqTransNeutralTracker::canBeNeutralized(_reqTrans, setup))
        {
            neutralTracker.trackReqTrans(_reqTrans);
        }
        else if (deleted && neutralTracker)
        {
            neutralTracker.trackDeletedRecord(_reqTrans);
        }

        return deleted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReqTransSettled</Name>
				<Source><![CDATA[
    protected void updateReqTransSettled(
        ReqTrans        _reqTrans,
        ReqTransCov     _reqTransCov,
        InventQty       _covQtyChange
        )
    {
        ReqTrans        reqTransSettled;

        if (_reqTrans.Qty >= 0)
        {
            reqTransSettled = ReqTrans::findRecId(_reqTransCov.IssueRecId,true);
        }
        else
        {
            reqTransSettled = ReqTrans::findRecId(_reqTransCov.ReceiptRecId,true);
        }

        if (reqTransSettled.RecId)
        {
            reqTransSettled.CovQty += reqTransSettled.Qty > 0 ? -abs(_covQtyChange) : abs(_covQtyChange);

            if (reqTransSettled.isPlannedOrder() && reqTransSettled.CovQty == 0 && ! reqPlanData.mustKeepPlannedOrder(setupDim,reqTransSettled,null))
            {
                reqTransSettled.deleteExplosionCoverage();
                reqTransSettled.delete(null, true, false); // _reqPlanData: null, _derivedDelete: true, _coverageDelete: false
                
                if (neutralTracker)
                {
                    neutralTracker.trackDeletedRecord(reqTransSettled);
                }
            }
            else
            {
                this.updateAndTrackReqTrans(reqTransSettled, null, false, false);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    public boolean validate()
    {
        if (reqPlanData.parmReqPlanId() != ReqPlanSched::defaultDynamicId())
        {
            return checkFailed("@SYS69802");
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeTransactionCoverage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes the coverage within the map, and updates the <c>ReqTrans</c> records that were covered by it.
    /// </summary>
    /// <param name = "_mapReqTransCov">A map of coverage records, that should be deleted.</param>
    protected void removeTransactionCoverage(Map _mapReqTransCov)
    {
        if (!_mapReqTransCov)
        {
            return;
        }

        MapIterator mi_reqTransCov = new MapIterator(_mapReqTransCov);
        mi_reqTransCov.begin();
        while (mi_reqTransCov.more())
        {
            ReqTransCov reqTransCov = _mapReqTransCov.lookup(mi_reqTransCov.key());
            ReqTrans reqTrans;

            if (reqTransCov.ReceiptRecId)
            {
                reqTrans = ReqTrans::findRecId(reqTransCov.ReceiptRecId,true);
                if (reqTrans.RecId)
                {
                    reqTrans.CovQty += reqTransCov.Qty;

                    if (reqTrans.isPlannedOrder() && reqTrans.CovQty == 0)
                    {
                        if (! reqPlanData)
                        {
                            reqPlanData = ReqPlanData::newReqPlanVersion(reqTrans.PlanVersion);
                        }

                        ReqSetupDim localSetupDim = reqPlanData.newReqSetupDim(reqPlanData.newReqSetup(reqTrans.ItemId),reqTrans.CovInventDimId);

                        if (! reqPlanData.mustKeepPlannedOrder(localSetupDim,reqTrans,null))
                        {
                            reqTrans.delete(null,true);

                            if (neutralTracker)
                            {
                                neutralTracker.trackDeletedRecord(reqTrans);
                            }
                        }
                        else
                        {
                            this.updateAndTrackReqTrans(reqTrans);
                        }
                    }
                    else
                    {
                        this.updateAndTrackReqTrans(reqTrans);
                    }
                }
            }

            if (reqTransCov.IssueRecId)
            {
                reqTrans = ReqTrans::findRecId(reqTransCov.IssueRecId,true);
                if (reqTrans.RecId)
                {
                    reqTrans.CovQty -= reqTransCov.Qty;

                    this.updateAndTrackReqTrans(reqTrans);
                }

                reqTransCov.delete();
            }

            mi_reqTransCov.next();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newItemId</Name>
				<Source><![CDATA[
    public static ReqTransUpdate newItemId(ItemId _itemId)
    {
        ReqTransUpdate reqTransUpdate = new ReqTransUpdate();
        reqTransUpdate.parmItemId(_itemId);

        reqTransUpdate.init();

        return reqTransUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newReqCalcItemId</Name>
				<Source><![CDATA[
    public static ReqTransUpdate newReqCalcItemId(
        ItemId          _itemId,
        ReqPlanData     _reqPlanData
        )
    {
        ReqTransUpdate reqTransUpdate = new ReqTransUpdate();
        reqTransUpdate.parmItemId(_itemId);
        reqTransUpdate.parmReqPlanData(_reqPlanData);

        reqTransUpdate.init();

        return reqTransUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runItemId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the requirement profile for the specified item ID.
    /// </summary>
    /// <param name="_itemId">
    /// A string value that contains an item ID.
    /// </param>
    public static void runItemId(ItemId _itemId)
    {
        ReqTransUpdate reqTransUpdate = ReqTransUpdate::newItemId(_itemId);
        reqTransUpdate.run();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReqTrans</Name>
				<Source><![CDATA[
    [SuppressBpWarning('BPParameterNotUsed', 'The parameter _reqPlanData is not used but it is preserved due to API compatibility.')]
    public static boolean updateReqTrans(
        ReqTrans    _reqTrans,
        ReqPlanData _reqPlanData    = null,
        boolean     _coverageDelete = true,
        boolean     _updateSettledReqTransCovQty = true)
    {
        boolean         deleted = false;

        if (_reqTrans.Qty || _reqTrans.CovQty)
        {
            _reqTrans.update(null, false);
            if (_coverageDelete)
            {
                _reqTrans.updateReduceCovQty(null, _updateSettledReqTransCovQty); // _reqPlanData: null, _updateSettledReqTransCovQty: true.
            }
        }
        else
        {
            _reqTrans.delete(null, true, false);
            deleted = true;

            if (_coverageDelete)
            {
                _reqTrans.deleteCov(null, _updateSettledReqTransCovQty); // _reqPlanData: null, _updateSettledReqTransCovQty: true.
            }
        }

        return deleted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCacheKey</Name>
				<Source><![CDATA[
    private str getCacheKey(RefRecId _reqTransRecId)
    {
        return strFmt('ck_%1', _reqTransRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>returnOrderScrapInCache</Name>
				<Source><![CDATA[
    private boolean returnOrderScrapInCache(RefRecId _reqTransRecId)
    {
        // Adding a check on a global flag on return orders as performance optimization, since there is no need to go to the cache if there are no return orders with scrap.
        return hasSalesReturnScrap && ReqMemoryCache::getFromCurrentSessionScope(this.getCacheKey(_reqTransRecId), memoryCacheScope, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findInventTable</Name>
				<Source><![CDATA[
    private InventTable findInventTable(ItemId _itemId)
    {
        if (inventTable.ItemId != _itemId)
        {
            inventTable = InventTable::find(_itemId);
        }
   
        return inventTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventTransOriginsWithSafeDateStatusChange</Name>
				<Source><![CDATA[
    public Set parmInventTransOriginsWithSafeDateStatusChange(Set _inventTransOriginsWithSafeDateStatusChange = inventTransOriginsWithSafeDateStatusChange)
    {
        inventTransOriginsWithSafeDateStatusChange = _inventTransOriginsWithSafeDateStatusChange;
        return _inventTransOriginsWithSafeDateStatusChange;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>