<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerEncumbranceReconciliationDP</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>LedgerEncumbranceReconciliationDP</c> class is used as a data provider for the <c>LedgerEncumbranceReconciliation</c> report.
/// </summary>
[SRSReportParameterAttribute(classStr(LedgerEncumbranceReconciliationContract))]
public class LedgerEncumbranceReconciliationDP extends SRSReportDataProviderPreProcessTempDB
{
    // Member variables used to filter the report data and control the report output.
    FromDate        fromDate;
    ToDate          toDate;
    recId           dimensionAttributeRecId;
    Name            parmDimensionAttributeName;
    boolean         parmIncludeEncumbranceBalance;
    boolean         parmIncludePreEncumbranceBalance;
    boolean         parmIncludeDetails;
    boolean         parmDifferencesOnly;

    // Member variables corresponding to the temporary table fields.
    TransDate       transDate;
    DocumentNum     documentNumber;
    TransTxt        documentType;
    AmountMST       encumbranceBalance;
    AmountMST       ledgerBalance;
    Name            dimensionAttributeName;
    DimensionValue  dimensionAttributeValue;
    Name            section;

    LedgerEncumbranceReconciliationTmp  ledgerEncumbranceReconciliationTmp;

    // Main account categories are created using MainAccountCategory::createDefaultAcctCategories method
    #define.MainAccountCategory_Encumbrance(54)
    #define.MainAccountCategory_PreEncumbrance(55)

    #define.Section_Encumbrance('Encumbrance')
    #define.Section_PreEncumbrance('PreEncumbrance')
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addReportRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds records to the temporary table, depending on the report parameters.
    /// </summary>
    /// <remarks>
    /// If the <c>Differences only</c> report parameter is set and if the encumbrance balance equals the
    /// ledger balance then it does not insert a record in the temporary table; otherwise, it inserts a
    /// record.
    /// </remarks>
    protected void addReportRecord()
    {
        if (parmDifferencesOnly)
        {
            // If user has opted to see the differences only, insert only if there is an imbalance.
            if (encumbranceBalance != ledgerBalance)
            {
                this.insertLedgerEncumbranceReconciliationTmp();
            }
        }
        else
        {
            this.insertLedgerEncumbranceReconciliationTmp();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fetchBudgetTransData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves reconciliation data for budget transactions.
    /// </summary>
    /// <param name="_budgetTransactionType">
    ///    A budget transaction type for restricting budget transactions to a single type.
    /// </param>
    /// <param name="_accountCategoryRef">
    ///    A main account category to use to identify main accounts that are used for storing ledger balances.
    /// </param>
    /// <param name="_section">
    ///    A section name with which to associate the resulting records.
    /// </param>
    /// <remarks>
    ///    For budget balances it looks for records in the budget source tracking tables.For ledger balances,
    ///    it looks for records in the general journal tables.
    /// </remarks>
    protected void fetchBudgetTransData(
        BudgetTransactionType   _budgetTransactionType,
        AccountCategoryRef      _accountCategoryRef,
        Name                    _section)
    {
        BudgetSource                        budgetSource;
        BudgetSourceTracking                budgetSourceTracking;
        BudgetSourceTrackingDetail          budgetSourceTrackingDetail;
        BudgetTransactionHeader             budgetTransactionHeader;
        BudgetTransactionLine               budgetTransactionLine;
        DimensionAttributeLevelValueAllView dimensionAttributeLevelValueView;
        DimensionAttributeValueCombination  dimensionAttributeValueCombination;
        DimensionAttributeValueGroup        dimensionAttributeValueGroup;
        GeneralJournalAccountEntry          generalJournalAccountEntry;
        Map                                 budgetEncumbrance;
        Map                                 ledgerEncumbrance;
        MainAccount                         mainAccount;

        // Enumerate completed budget transactions of the specified type
        while select RecId, @Date, TransactionNumber from budgetTransactionHeader
            where budgetTransactionHeader.BudgetTransactionType == _budgetTransactionType
               && budgetTransactionHeader.TransactionStatus == BudgetTransactionStatus::Completed
               && budgetTransactionHeader.Date >= fromDate
               && budgetTransactionHeader.Date <= toDate
        {
            budgetEncumbrance = new Map(Types::String, Types::Real);
            ledgerEncumbrance = new Map(Types::String, Types::Real);

            // For the current budget transaction header, retrieve budget reservation for the specified transaction type
            while select RecId from budgetTransactionLine
                where budgetTransactionLine.BudgetTransactionHeader == budgetTransactionHeader.RecId
                join RecId from budgetSource
                    where budgetSource.BudgetSourceType == BudgetSourceType::BudgetTransactionLine
                       && budgetSource.BudgetTransactionLine == budgetTransactionLine.RecId
                       && budgetSource.SourceDocumentLine == 0
                       && budgetSource.LedgerEntryGeneralJournalEntry == 0
                       && budgetSource.LedgerEntryJournalNumber == ''
                       && budgetSource.LedgerEntryJournalReferenceNumber == ''
                       && budgetSource.LedgerEntryJournalLegalEntity == 0
                join RecId from budgetSourceTracking
                    where budgetSourceTracking.BudgetSource == budgetSource.RecId
                       && budgetSourceTracking.Status == BudgetSourceTrackingStatus::Confirmed
                       && budgetSourceTracking.IsDeletePending == NoYes::No
                join sum(AccountingCurrencyAmount) from budgetSourceTrackingDetail
                    where budgetSourceTrackingDetail.BudgetSourceTracking == budgetSourceTracking.RecId
                       && budgetSourceTrackingDetail.IsDeletePending == NoYes::No
                       && budgetSourceTrackingDetail.IsSummarized == NoYes::Yes
                join DisplayValue from dimensionAttributeLevelValueView
                    group by dimensionAttributeLevelValueView.DisplayValue
                    where dimensionAttributeLevelValueView.ValueCombinationRecId == budgetSourceTrackingDetail.BudgetSourceLedgerDimension
                       && dimensionAttributeLevelValueView.DimensionAttribute == dimensionAttributeRecId
            {
                budgetEncumbrance.insert(dimensionAttributeLevelValueView.DisplayValue, budgetSourceTrackingDetail.AccountingCurrencyAmount);
            }

            // For the current budget transaction header, retrieve ledger balance against the specified main account category
            while select RecId from budgetTransactionLine
                where budgetTransactionLine.BudgetTransactionHeader == budgetTransactionHeader.RecId
                join sum(TransactionCurrencyAmount) from generalJournalAccountEntry
                    where generalJournalAccountEntry.GeneralJournalEntry == budgetTransactionLine.GeneralJournalEntry
                join RecId from dimensionAttributeValueCombination
                    where dimensionAttributeValueCombination.RecId == generalJournalAccountEntry.LedgerDimension
                join RecId from mainAccount
                    where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                       && mainAccount.AccountCategoryRef == _accountCategoryRef
                join DisplayValue from dimensionAttributeLevelValueView
                    group by dimensionAttributeLevelValueView.DisplayValue
                    where dimensionAttributeLevelValueView.ValueCombinationRecId == dimensionAttributeValueCombination.RecId
                       && dimensionAttributeLevelValueView.DimensionAttribute == dimensionAttributeRecId
                join RecId from dimensionAttributeValueGroup
                    where dimensionAttributeValueGroup.RecId == dimensionAttributeLevelValueView.DimensionAttributeValueGroup
                       && dimensionAttributeValueGroup.DimensionHierarchy == dimensionAttributeValueCombination.AccountStructure
            {
                ledgerEncumbrance.insert(dimensionAttributeLevelValueView.DisplayValue, generalJournalAccountEntry.TransactionCurrencyAmount);
            }

            transDate               = budgetTransactionHeader.Date;
            documentNumber          = budgetTransactionHeader.TransactionNumber;
            documentType            = "@SYS129613";
            dimensionAttributeName  = parmDimensionAttributeName;
            section                 = _section;

            this.reconcileAmountsByDimension(budgetEncumbrance, ledgerEncumbrance);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fetchEncumbranceBySourceDocument</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves encumbrance reconciliation data for source documents.
    /// </summary>
    /// <remarks>
    ///    For now, this method fetches the encumbrances that are generated by purchase orders and budget
    ///    transactions.In future versions, other source documents may also be included.
    /// </remarks>
    protected void fetchEncumbranceBySourceDocument()
    {
        if (parmIncludeDetails)
        {
            this.fetchBudgetTransData(
                BudgetTransactionType::Encumbrance,
                #MainAccountCategory_Encumbrance,
                #Section_Encumbrance);
        }

        this.fetchEncumbrancePurchOrderData();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fetchEncumbrancePurchOrderData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves encumbrance reconciliation data for purchase orders.
    /// </summary>
    /// <remarks>
    ///    For the encumbrance balance it looks for records in the budget source tracking tables.
    ///    For ledger balance, it looks for records in the general journal tables.
    /// </remarks>
    protected void fetchEncumbrancePurchOrderData()
    {
        AccountingEvent                     accountingEvent;
        BudgetSource                        budgetSource;
        BudgetSourceTracking                budgetSourceTracking;
        BudgetSourceTrackingDetail          budgetSourceTrackingDetail;
        DimensionAttributeLevelValueAllView dimensionAttributeLevelValueAllView;
        DimensionAttributeValueCombination  dimensionAttributeValueCombination;
        DimensionAttributeValueGroup        dimensionAttributeValueGroup;
        Map                                 budgetEncumbrance, currentBudgetEncumbrance;
        Map                                 ledgerEncumbrance, currentLedgerEncumbrance;
        Map                                 dimensionAttributeValueRecIdByDisplay;
        PurchTable                          purchTable;
        PurchTableVersion                   purchTableVersion;
        PurchTableVersion                   purchTableVersionNotArchived;
        SourceDocumentLine                  sourceDocumentLine;
        VendPurchOrderJour                  vendPurchOrderJour;
        AmountMST                           cachedAmount;

        budgetEncumbrance = new Map(Types::String, Types::Real);
        ledgerEncumbrance = new Map(Types::String, Types::Real);

        // Enumerate all the confirmed purchase orders
        while select PurchaseOrderVoucher, DataAreaId, SalesOrderbalance from vendPurchOrderJour
            join PurchId, SourceDocumentHeader from purchTable
                where vendPurchOrderJour.PurchId == purchTable.PurchId
            join RecId, IsArchived from purchTableVersion
                where purchTableVersion.RecId == vendPurchOrderJour.PurchTableVersion
                   && purchTableVersion.PurchIdDataAreaId == purchTable.dataAreaId
                   && purchTableVersion.PurchId == purchTable.PurchId
            join AccountingDate from accountingEvent
                where purchTable.SourceDocumentHeader == accountingEvent.SourceDocumentHeader
                   && accountingEvent.Type == AccountingEventType::Original
                   && accountingEvent.AccountingDate >= fromDate
                   && accountingEvent.AccountingDate <= toDate
        {
            if (purchTableVersion.IsArchived)
            {
                // This version of the PO has been archived - look for a non-archived version for the same PO
                select firstonly RecId from purchTableVersionNotArchived
                    where purchTableVersionNotArchived.PurchIdDataAreaId == purchTable.dataAreaId
                        && purchTableVersionNotArchived.PurchId == purchTable.PurchId
                        && purchTableVersionNotArchived.IsArchived == NoYes::No;

                if (purchTableVersionNotArchived)
                {
                    // An unarchived version was found - skip the archived version
                    continue;
                }

                // The archived version should only be processed if there is not an unarchived version
                // This happens when a PO has been changed, but the change is not yet confirmed
                // The archived version should be reported for this case
            }

            currentBudgetEncumbrance = new Map(Types::String, Types::Real);
            currentLedgerEncumbrance = new Map(Types::String, Types::Real);
            dimensionAttributeValueRecIdByDisplay = new Map(Types::String, Types::Int64);

            // For the current PO, retrieve the budget reservation for encumbrances
            while select RecId from sourceDocumentLine
                where sourceDocumentLine.SourceDocumentHeader == purchTable.SourceDocumentHeader
                   && sourceDocumentLine.ParentSourceDocumentLine == 0
                   && sourceDocumentLine.TypeEnumName == enumStr(SourceDocumentLine_ProductOrder)
                   && sourceDocumentLine.TypeEnumValue == SourceDocumentLine_ProductOrder::PurchaseOrderLine
                join RecId from budgetSource
                    where budgetSource.BudgetSourceType == BudgetSourceType::SourceDocumentLine
                       && budgetSource.SourceDocumentLine == sourceDocumentLine.RecId
                       && budgetSource.BudgetTransactionLine == 0
                       && budgetSource.LedgerEntryGeneralJournalEntry == 0
                       && budgetSource.LedgerEntryJournalNumber == ''
                       && budgetSource.LedgerEntryJournalReferenceNumber == ''
                       && budgetSource.LedgerEntryJournalLegalEntity == 0
                join RecId, Category from budgetSourceTracking
                    where budgetSourceTracking.BudgetSource == budgetSource.RecId
                       && budgetSourceTracking.Status == BudgetSourceTrackingStatus::Confirmed
                       && (budgetSourceTracking.Category == BudgetControlCategory::Encumbrance ||
                           budgetSourceTracking.Category == BudgetControlCategory::EncumbranceReduction)
                       && budgetSourceTracking.IsDeletePending == NoYes::No
                join sum(AccountingCurrencyAmount) from budgetSourceTrackingDetail
                    where budgetSourceTrackingDetail.BudgetSourceTracking == budgetSourceTracking.RecId
                       && budgetSourceTrackingDetail.IsDeletePending == NoYes::No
                       && budgetSourceTrackingDetail.IsSummarized == NoYes::Yes
                join RecId from dimensionAttributeValueCombination
                    where dimensionAttributeValueCombination.RecId == budgetSourceTrackingDetail.BudgetSourceLedgerDimension
                join AttributeValueRecId, DisplayValue from dimensionAttributeLevelValueAllView
                    group by dimensionAttributeLevelValueAllView.DisplayValue, dimensionAttributeLevelValueAllView.AttributeValueRecId, budgetSourceTracking.Category
                    where dimensionAttributeLevelValueAllView.ValueCombinationRecId == dimensionAttributeValueCombination.RecId
                       && dimensionAttributeLevelValueAllView.DimensionAttribute == dimensionAttributeRecId
                join RecId from dimensionAttributeValueGroup
                    where dimensionAttributeValueGroup.RecId == dimensionAttributeLevelValueAllView.DimensionAttributeValueGroup
                       && dimensionAttributeValueGroup.DimensionHierarchy == dimensionAttributeValueCombination.AccountStructure
            {
                cachedAmount = 0;

                if (currentBudgetEncumbrance.exists(dimensionAttributeLevelValueAllView.DisplayValue))
                {
                    cachedAmount = currentBudgetEncumbrance.lookup(dimensionAttributeLevelValueAllView.DisplayValue);
                }

                currentBudgetEncumbrance.insert(
                    dimensionAttributeLevelValueAllView.DisplayValue,
                    cachedAmount + budgetSourceTrackingDetail.AccountingCurrencyAmount +
                        this.getBudgetRelievingAmountForSourceDoc(purchTable.SourceDocumentHeader, budgetSourceTracking.Category, dimensionAttributeLevelValueAllView.AttributeValueRecId));
            }

            this.setPurchaseOrderLedgerBalance(purchTable.SourceDocumentHeader, currentLedgerEncumbrance);

            if (parmIncludeDetails)
            {
                transDate               = accountingEvent.AccountingDate;
                documentNumber          = purchTable.PurchId;
                documentType            = "@SYS25545";
                dimensionAttributeName  = parmDimensionAttributeName;
                section                 = #Section_Encumbrance;

                this.reconcileAmountsByDimension(currentBudgetEncumbrance, currentLedgerEncumbrance);
            }
            else
            {
                this.updateOrAppendMapEntries(currentBudgetEncumbrance, budgetEncumbrance);
                this.updateOrAppendMapEntries(currentLedgerEncumbrance, ledgerEncumbrance);
            }
        }

        if (!parmIncludeDetails)
        {
            transDate               = dateNull();
            documentNumber          = "";
            documentType            = "";
            dimensionAttributeName  = parmDimensionAttributeName;
            section                 = #Section_Encumbrance;

            this.reconcileAmountsByDimension(budgetEncumbrance, ledgerEncumbrance);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fetchPreEncumbranceBySourceDocument</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves pre-encumbrance reconciliation data for source documents.
    /// </summary>
    /// <remarks>
    ///    For now, this method fetches the pre-encumbrances that is generated by purchase requisitions and
    ///    budget transactions.In future versions, other source documents may also be included.
    /// </remarks>
    protected void fetchPreEncumbranceBySourceDocument()
    {
        if (parmIncludeDetails)
        {
            this.fetchBudgetTransData(
                BudgetTransactionType::PreEncumbrance,
                #MainAccountCategory_PreEncumbrance,
                #Section_PreEncumbrance);
        }

        this.fetchPreEncumbrancePurchReqData();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fetchPreEncumbrancePurchReqData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves pre-encumbrance reconciliation data for purchase orders.
    /// </summary>
    /// <remarks>
    ///    For the pre-encumbrance balance this method looks for records in the budget source tracking
    ///    tables.For ledger balance, it looks for records in the general journal tables.
    /// </remarks>
    protected void fetchPreEncumbrancePurchReqData()
    {
        BudgetSource                        budgetSource;
        BudgetSourceTracking                budgetSourceTracking;
        BudgetSourceTrackingDetail          budgetSourceTrackingDetail;
        DimensionAttributeLevelValueAllView dimensionAttributeLevelValueView;
        DimensionAttributeValueCombination  dimensionAttributeValueCombination;
        DimensionAttributeValueGroup        dimensionAttributeValueGroup;
        Map                                 budgetEncumbrance, currentBudgetEncumbrance;
        Map                                 ledgerEncumbrance, currentLedgerEncumbrance;
        PurchReqTable                       purchReqTable;
        SourceDocumentLine                  sourceDocumentLine;
        AmountMST                           cachedAmount;
        AccountingDistribution              accountingDistribution;
        CompanyInfo                         companyInfo;

        budgetEncumbrance = new Map(Types::String, Types::Real);
        ledgerEncumbrance = new Map(Types::String, Types::Real);

        // Enumerate all the approved purchase requisitions
        while select PurchReqId, RequisitionStatus, TransDate, SourceDocumentHeader, DataAreaId from purchReqTable
            where (purchReqTable.RequisitionStatus == PurchReqRequisitionStatus::Approved
                    || purchReqTable.RequisitionStatus == PurchReqRequisitionStatus::Closed )
                && purchReqTable.TransDate >= fromDate
                && purchReqTable.TransDate <= toDate
                exists join accountingDistribution
                    where accountingDistribution.SourceDocumentHeader == purchReqTable.SourceDocumentHeader
                        join companyInfo
                            where companyInfo.RecId == accountingDistribution.AccountingLegalEntity
                                && companyInfo.DataArea == curext()
        {
            currentBudgetEncumbrance = new Map(Types::String, Types::Real);
            currentLedgerEncumbrance = new Map(Types::String, Types::Real);

            // For the current PR, retrieve budget reservation for pre-encumbrances
            while select RecId from sourceDocumentLine
                where sourceDocumentLine.SourceDocumentHeader == purchReqTable.SourceDocumentHeader
                   && sourceDocumentLine.ParentSourceDocumentLine == 0
                join RecId from budgetSource
                    where budgetSource.BudgetSourceType == BudgetSourceType::SourceDocumentLine
                       && budgetSource.SourceDocumentLine == sourceDocumentLine.RecId
                       && budgetSource.BudgetTransactionLine == 0
                       && budgetSource.LedgerEntryGeneralJournalEntry == 0
                       && budgetSource.LedgerEntryJournalNumber == ''
                       && budgetSource.LedgerEntryJournalReferenceNumber == ''
                       && budgetSource.LedgerEntryJournalLegalEntity == 0
                join RecId,Category, Status from budgetSourceTracking
                    where budgetSourceTracking.BudgetSource == budgetSource.RecId
                       && budgetSourceTracking.Status == BudgetSourceTrackingStatus::Confirmed
                       && budgetSourceTracking.Category == BudgetControlCategory::PreEncumbrance
                join sum(AccountingCurrencyAmount) from budgetSourceTrackingDetail
                    where budgetSourceTrackingDetail.BudgetSourceTracking == budgetSourceTracking.RecId
                join RecId from dimensionAttributeValueCombination
                    where dimensionAttributeValueCombination.RecId == budgetSourceTrackingDetail.BudgetSourceLedgerDimension
                join AttributeValueRecId, DisplayValue from dimensionAttributeLevelValueView
                    group by dimensionAttributeLevelValueView.DisplayValue, dimensionAttributeLevelValueView.AttributeValueRecId, budgetSourceTracking.Category
                    where dimensionAttributeLevelValueView.ValueCombinationRecId == dimensionAttributeValueCombination.RecId
                       && dimensionAttributeLevelValueView.DimensionAttribute == dimensionAttributeRecId
                join RecId from dimensionAttributeValueGroup
                    where dimensionAttributeValueGroup.RecId == dimensionAttributeLevelValueView.DimensionAttributeValueGroup
                       && dimensionAttributeValueGroup.DimensionHierarchy == dimensionAttributeValueCombination.AccountStructure
            {
                cachedAmount = 0;

                if (currentBudgetEncumbrance.exists(dimensionAttributeLevelValueView.DisplayValue))
                {
                    cachedAmount = currentBudgetEncumbrance.lookup(dimensionAttributeLevelValueView.DisplayValue);
                }

                currentBudgetEncumbrance.insert(
                    dimensionAttributeLevelValueView.DisplayValue,
                    cachedAmount + budgetSourceTrackingDetail.AccountingCurrencyAmount +
                        this.getBudgetRelievingAmountForSourceDoc(purchReqTable.SourceDocumentHeader, budgetSourceTracking.Category, dimensionAttributeLevelValueView.AttributeValueRecId));
            }

            this.setPurchaseRequisitionLedgerBalance(purchReqTable.SourceDocumentHeader, currentLedgerEncumbrance);

            if (parmIncludeDetails)
            {
                transDate               = purchReqTable.TransDate;
                documentNumber          = purchReqTable.PurchReqId;
                documentType            = "@SYS318570";
                dimensionAttributeName  = parmDimensionAttributeName;
                section                 = #Section_PreEncumbrance;

                this.reconcileAmountsByDimension(currentBudgetEncumbrance, currentLedgerEncumbrance);
            }
            else
            {
                this.updateOrAppendMapEntries(currentBudgetEncumbrance, budgetEncumbrance);
                this.updateOrAppendMapEntries(currentLedgerEncumbrance, ledgerEncumbrance);
            }
        }

        if (!parmIncludeDetails)
        {
            transDate               = dateNull();
            documentNumber          = "";
            documentType            = "";
            dimensionAttributeName  = parmDimensionAttributeName;
            section                 = #Section_Encumbrance;

            this.reconcileAmountsByDimension(budgetEncumbrance, ledgerEncumbrance);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetRelievingAmountForSourceDoc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the relieving amounts for the purchase order or purchase requisition source document.
    /// </summary>
    /// <param name="_sourceDocumentHeaderRecID">
    /// The record ID of the source document.
    /// </param>
    /// <param name="_budgetControlCategory">
    /// The budget control category of the source document.
    /// </param>
    /// <param name="_attributeValueRecId">
    /// The dimension attribute value record.
    /// </param>
    /// <returns>
    /// The relieving amount for source document.
    /// </returns>
    protected AmountMST getBudgetRelievingAmountForSourceDoc(
        RefRecId                _sourceDocumentHeaderRecID,
        BudgetControlCategory   _budgetControlCategory,
        RecId                   _attributeValueRecId)
    {
        BudgetSource                        budgetSource;
        BudgetSourceTracking                budgetSourceTracking;
        BudgetSourceTracking                budgetSourceTrackingLocal;
        BudgetSourceTrackingDetail          budgetSourceTrackingDetail;
        BudgetSourceTrackingRelievingDetail budgetSourceTrackingRelievingDetail;
        DimensionAttributeLevelValueAllView dimensionAttributeLevelValueView;
        DimensionAttributeValueCombination  dimensionAttributeValueCombination;
        DimensionAttributeValueGroup        dimensionAttributeValueGroup;
        SourceDocumentLine                  sourceDocumentLine;

        select firstonly RecId from sourceDocumentLine
            where sourceDocumentLine.SourceDocumentHeader == _sourceDocumentHeaderRecID
               && sourceDocumentLine.ParentSourceDocumentLine == 0
            join RecId from budgetSource
                where budgetSource.BudgetSourceType == BudgetSourceType::SourceDocumentLine
                   && budgetSource.SourceDocumentLine == sourceDocumentLine.RecId
                   && budgetSource.BudgetTransactionLine == 0
                   && budgetSource.LedgerEntryGeneralJournalEntry == 0
                   && budgetSource.LedgerEntryJournalNumber == ''
                   && budgetSource.LedgerEntryJournalReferenceNumber == ''
                   && budgetSource.LedgerEntryJournalLegalEntity == 0
            join RecId, Status from budgetSourceTracking
                where budgetSourceTracking.BudgetSource == budgetSource.RecId
                   && budgetSourceTracking.Category == _budgetControlCategory
            join RecId from budgetSourceTrackingDetail
                where budgetSourceTrackingDetail.BudgetSourceTracking == budgetSourceTracking.RecId
            join RecId from dimensionAttributeValueCombination
                where dimensionAttributeValueCombination.RecId == budgetSourceTrackingDetail.BudgetSourceLedgerDimension
            join DisplayValue from dimensionAttributeLevelValueView
                group by dimensionAttributeLevelValueView.DisplayValue
                where dimensionAttributeLevelValueView.ValueCombinationRecId == dimensionAttributeValueCombination.RecId
                   && dimensionAttributeLevelValueView.DimensionAttribute == dimensionAttributeRecId
                   && dimensionAttributeLevelValueView.AttributeValueRecId == _attributeValueRecId
            join RecId from dimensionAttributeValueGroup
                where dimensionAttributeValueGroup.RecId == dimensionAttributeLevelValueView.DimensionAttributeValueGroup
                   && dimensionAttributeValueGroup.DimensionHierarchy == dimensionAttributeValueCombination.AccountStructure
            join sum(AccountingCurrencyAmount), RelievingBudgetSourceTracking from budgetSourceTrackingRelievingDetail
                where budgetSourceTrackingRelievingDetail.RelievedBudgetSourceTrackingDetail == budgetSourceTrackingDetail.RecId
            join RecId from budgetSourceTrackingLocal
                where budgetSourceTrackingLocal.RecId == budgetSourceTrackingRelievingDetail.RelievingBudgetSourceTracking
                   && budgetSourceTrackingLocal.Status == BudgetSourceTrackingStatus::Confirmed;

        return budgetSourceTrackingRelievingDetail.AccountingCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerEncumbranceReconciliationTmp</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves data from the <c>LedgerEncumbranceReconciliationTmp</c> temporary table.
    /// </summary>
    /// <returns>
    ///    The <c>LedgerEncumbranceReconciliationTmp</c> table buffer.
    /// </returns>
    [
        SRSReportDataSetAttribute('LedgerEncumbranceReconciliationTmp')
    ]
    public LedgerEncumbranceReconciliationTmp getLedgerEncumbranceReconciliationTmp()
    {
        select ledgerEncumbranceReconciliationTmp;
        return ledgerEncumbranceReconciliationTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReportParameters</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Copies the report parameters from a data contract to member variables.
    /// </summary>
    /// <returns>
    ///    true if the report parameters are successfully copied to the member variables; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method also queries the <c>FiscalCalendarYear</c> table to get the <c>StartDate</c> and
    ///    <c>EndDate</c> fields.
    /// </remarks>
    protected boolean getReportParameters()
    {
        boolean                                 paramsFetched = false;
        LegalEntity                             legalEntityRecId;
        ReconciliationPeriodType                parmReconciliationPeriodType;
        FiscalYearName                          parmFiscalYearName;
        FromDate                                parmFromDate;
        ToDate                                  parmToDate;
        FiscalCalendarYear                      fiscalCalendarYear;
        LedgerEncumbranceReconciliationContract contract = this.parmDataContract();

        if (contract)
        {
            parmReconciliationPeriodType        = contract.parmReconciliationPeriodType();
            parmFiscalYearName                  = contract.parmFiscalYearName();
            parmFromDate                        = contract.parmFromDate();
            parmToDate                          = contract.parmToDate();
            parmDimensionAttributeName          = contract.parmDimensionAttributeName();
            parmIncludeEncumbranceBalance       = contract.parmIncludeEncumbranceBalance();
            parmIncludePreEncumbranceBalance    = contract.parmIncludePreEncumbranceBalance();
            parmIncludeDetails                  = contract.parmIncludeDetails();
            parmDifferencesOnly                 = contract.parmDifferencesOnly();

            if (parmReconciliationPeriodType == ReconciliationPeriodType::FiscalYear)
            {
                legalEntityRecId    = CompanyInfo::findDataArea(curext()).RecId;
                fiscalCalendarYear  = FiscalCalendarYear::findByCalendarYearName(Ledger::fiscalCalendar(legalEntityRecId), parmFiscalYearName);

                if (fiscalCalendarYear)
                {
                    fromDate = fiscalCalendarYear.StartDate;
                    toDate   = fiscalCalendarYear.EndDate;
                }
            }
            else if (parmReconciliationPeriodType == ReconciliationPeriodType::DateRange)
            {
                fromDate = parmFromDate;
                toDate   = parmToDate;
            }

            dimensionAttributeRecId = DimensionAttribute::findByName(parmDimensionAttributeName).RecId;

            paramsFetched = true;
        }

        return paramsFetched;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertLedgerEncumbranceReconciliationTmp</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts a record into the <c>LedgerEncumbranceReconciliationTmp</c> table.
    /// </summary>
    protected void insertLedgerEncumbranceReconciliationTmp()
    {
        ledgerEncumbranceReconciliationTmp.TransDate                = transDate;
        ledgerEncumbranceReconciliationTmp.DocumentNumber           = documentNumber;
        ledgerEncumbranceReconciliationTmp.DocumentType             = documentType;
        ledgerEncumbranceReconciliationTmp.EncumbranceBalance       = encumbranceBalance;
        ledgerEncumbranceReconciliationTmp.LedgerBalance            = ledgerBalance;
        ledgerEncumbranceReconciliationTmp.DimensionAttribute       = dimensionAttributeName;
        ledgerEncumbranceReconciliationTmp.DimensionAttributeValue  = dimensionAttributeValue;
        ledgerEncumbranceReconciliationTmp.Section                  = section;
        ledgerEncumbranceReconciliationTmp.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>processReport</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the report data by using the parameter values.
    /// </summary>
    public void processReport()
    {
        this.setUserConnection(ledgerEncumbranceReconciliationTmp);

        if (this.getReportParameters())
        {
            if (parmIncludeEncumbranceBalance)
            {
                this.fetchEncumbranceBySourceDocument();
            }

            if (parmIncludePreEncumbranceBalance)
            {
                this.fetchPreEncumbranceBySourceDocument();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setUserConnection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the user connection on the table buffer.
    /// </summary>
    /// <param name="_common">
    /// The table buffer.
    /// </param>
    private void setUserConnection(Common _common)
    {
        UserConnection con = this.parmUserConnection();

        if (con)
        {
            _common.setConnection(con);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reconcileAmountsByDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reconciles the budget balances with the ledger balances by dimension.
    /// </summary>
    /// <param name="_budgetBalances">
    ///    A map that contains the budget balances by dimension.
    /// </param>
    /// <param name="_ledgerBalances">
    ///    A map that contains the ledger balances by dimension.
    /// </param>
    protected void reconcileAmountsByDimension(
        Map _budgetBalances,
        Map _ledgerBalances)
    {
        MapEnumerator mapEnumerator;

        // Enumerate all the budget balances
        mapEnumerator = _budgetBalances.getEnumerator();
        while (mapEnumerator.moveNext())
        {
            dimensionAttributeValue = mapEnumerator.currentKey();
            encumbranceBalance      = mapEnumerator.currentValue();

            if (_ledgerBalances.exists(mapEnumerator.currentKey()))
            {
                // If a corresponding ledger balance exists, report it and remove it from the map
                ledgerBalance = _ledgerBalances.lookup(mapEnumerator.currentKey());
                _ledgerBalances.remove(mapEnumerator.currentKey());
            }
            else
            {
                ledgerBalance = 0;
            }

            this.addReportRecord();
        }

        // If there are ledger balances left in the map, encumbrance balance should be zero for them
        encumbranceBalance = 0;

        // enumerate all the ledger balances
        mapEnumerator = _ledgerBalances.getEnumerator();
        while (mapEnumerator.moveNext())
        {
            dimensionAttributeValue = mapEnumerator.currentKey();
            ledgerBalance           = mapEnumerator.currentValue();

            this.addReportRecord();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPurchaseOrderLedgerBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the purchase order ledger balance in the given map.
    /// </summary>
    /// <param name="_purchOrderSourceDocumentHeaderId">
    /// The reocrd ID of <c>SourceDocumentHeader</c> table to be used.
    /// </param>
    /// <param name="_ledgerEncumbrance">
    /// The map to be used to set the value.
    /// </param>
    private void setPurchaseOrderLedgerBalance(
        SourceDocumentHeaderRecId _purchOrderSourceDocumentHeaderId,
        Map                       _ledgerEncumbrance)
    {
        DimensionAttributeLevelValueAllView dimensionAttributeLevelValueAllView, dimensionAttributeLevelValueAllViewRelieving;
        DimensionAttributeValueCombination  dimensionAttributeValueCombination, dimensionAttributeValueCombinationRelieving;
        MainAccount                         mainAccount, mainAccountRelieving;
        SubledgerJournalAccountEntry        subledgerJournalAccountEntry, subledgerJournalAccountEntryRelieving;
        SubledgerJournalEntry               subledgerJournalEntry, subledgerJournalEntryRelieving;
        AccountingEvent                     accountingEvent, accountingEventRelieving;
        PurchTable                          purchTableRelieving;
        VendInvoiceJour                     vendInvoiceJourRelieving;
        AmountMST                           currentPurchaseOrderAmount, RelievingAmount;

        // Retreive the subledger entries of current purchase order group by Financial Dimension value.
        while select sum(AccountingCurrencyAmount) from subledgerJournalAccountEntry
            join dimensionAttributeLevelValueAllView
            group by dimensionAttributeLevelValueAllView.AttributeValueRecId, dimensionAttributeLevelValueAllView.DisplayValue
            where dimensionAttributeLevelValueAllView.ValueCombinationRecId == subledgerJournalAccountEntry.LedgerDimension
                && dimensionAttributeLevelValueAllView.DimensionAttribute == dimensionAttributeRecId
            exists join subledgerJournalEntry
            where subledgerJournalEntry.RecId == subledgerJournalAccountEntry.SubledgerJournalEntry
                exists join accountingEvent
                where accountingEvent.RecId == subledgerJournalEntry.AccountingEvent
                   && accountingEvent.SourceDocumentHeader == _purchOrderSourceDocumentHeaderId
                exists join dimensionAttributeValueCombination
                where dimensionAttributeValueCombination.RecId == subledgerJournalAccountEntry.LedgerDimension
                   exists join mainAccount
                   where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                      && mainAccount.AccountCategoryRef == #MainAccountCategory_Encumbrance
        {
            currentPurchaseOrderAmount = subledgerJournalAccountEntry.AccountingCurrencyAmount;

            // Retreive the relieving subledger entries of current purchase order for given financial dimension.
            select sum(AccountingCurrencyAmount) from subledgerJournalAccountEntryRelieving
                exists join subledgerJournalEntryRelieving
                where subledgerJournalEntryRelieving.RecId == subledgerJournalAccountEntryRelieving.SubledgerJournalEntry
                    exists join accountingEventRelieving
                    where accountingEventRelieving.RecId == subledgerJournalEntryRelieving.AccountingEvent
                        exists join vendInvoiceJourRelieving
                        where vendInvoiceJourRelieving.SourceDocumentHeader == accountingEventRelieving.SourceDocumentHeader
                            exists join purchTableRelieving
                            where purchTableRelieving.PurchId == vendInvoiceJourRelieving.PurchId
                               && purchTableRelieving.SourceDocumentHeader == _purchOrderSourceDocumentHeaderId
                    exists join dimensionAttributeLevelValueAllViewRelieving
                    where dimensionAttributeLevelValueAllViewRelieving.ValueCombinationRecId == subledgerJournalAccountEntryRelieving.LedgerDimension
                       && dimensionAttributeLevelValueAllViewRelieving.DimensionAttribute == dimensionAttributeRecId
                       && dimensionAttributeLevelValueAllViewRelieving.AttributeValueRecId == dimensionAttributeLevelValueAllView.AttributeValueRecId
                    exists join dimensionAttributeValueCombinationRelieving
                    where dimensionAttributeValueCombinationRelieving.RecId == subledgerJournalAccountEntryRelieving.LedgerDimension
                       exists join mainAccountRelieving
                       where mainAccountRelieving.RecId == dimensionAttributeValueCombinationRelieving.MainAccount
                          && mainAccountRelieving.AccountCategoryRef == #MainAccountCategory_Encumbrance;

            RelievingAmount = subledgerJournalAccountEntryRelieving.AccountingCurrencyAmount;
            _ledgerEncumbrance.insert(dimensionAttributeLevelValueAllView.DisplayValue, currentPurchaseOrderAmount + RelievingAmount);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPurchaseRequisitionLedgerBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the purchase requisition ledger balance in the given map.
    /// </summary>
    /// <param name="_purchReqSourceDocumentHeaderId">
    /// The reocrd ID of <c>SourceDocumentHeader</c> table to be used.
    /// </param>
    /// <param name="_ledgerEncumbrance">
    /// The map to be used to set the value.
    /// </param>
    private void setPurchaseRequisitionLedgerBalance(
        SourceDocumentHeaderRecId _purchReqSourceDocumentHeaderId,
        Map                       _ledgerEncumbrance)
    {
        DimensionAttributeLevelValueAllView dimensionAttributeLevelValueAllView, dimensionAttributeLevelValueAllViewRelieving;
        DimensionAttributeValueCombination  dimensionAttributeValueCombination, dimensionAttributeValueCombinationRelieving;
        MainAccount                         mainAccount, mainAccountRelieving;
        AmountMST                           relievedAmount, currentRequisitionAmount;
        SubledgerJournalAccountEntry        subledgerJournalAccountEntry, subledgerJournalAccountEntryRelieving;
        SubledgerJournalEntry               subledgerJournalEntry, subledgerJournalEntryRelieving;
        AccountingEvent                     accountingEvent, accountingEventRelieving;
        PurchReqTable                       purchReqTableRelieving;
        PurchTable                          purchTableRelieving;
        PurchReqLine                        purchReqLineRelieving;

        // Retreive the subledger entries of current purchase requisition group by Financial Dimension value.
        while select sum(AccountingCurrencyAmount) from subledgerJournalAccountEntry
            join dimensionAttributeLevelValueAllView
            group by dimensionAttributeLevelValueAllView.AttributeValueRecId, dimensionAttributeLevelValueAllView.DisplayValue
            where dimensionAttributeLevelValueAllView.ValueCombinationRecId == subledgerJournalAccountEntry.LedgerDimension
                && dimensionAttributeLevelValueAllView.DimensionAttribute == dimensionAttributeRecId
            exists join subledgerJournalEntry
            where subledgerJournalEntry.RecId == subledgerJournalAccountEntry.SubledgerJournalEntry
                exists join accountingEvent
                where accountingEvent.RecId == subledgerJournalEntry.AccountingEvent
                   && accountingEvent.SourceDocumentHeader == _purchReqSourceDocumentHeaderId
            exists join dimensionAttributeValueCombination
            where dimensionAttributeValueCombination.RecId == subledgerJournalAccountEntry.LedgerDimension
                exists join mainAccount
                where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                    && mainAccount.AccountCategoryRef == #MainAccountCategory_PreEncumbrance
        {
            currentRequisitionAmount = subledgerJournalAccountEntry.AccountingCurrencyAmount;

            // Retreive the relieving subledger entries of current purchase requisition for given financial dimension.
            select sum(AccountingCurrencyAmount) from subledgerJournalAccountEntryRelieving
                exists join subledgerJournalEntryRelieving
                where subledgerJournalEntryRelieving.RecId == subledgerJournalAccountEntryRelieving.SubledgerJournalEntry
                    exists join accountingEventRelieving
                    where accountingEventRelieving.RecId == subledgerJournalEntryRelieving.AccountingEvent
                        exists join purchTableRelieving
                        where purchTableRelieving.SourceDocumentHeader == accountingEventRelieving.SourceDocumentHeader
                            exists join purchReqLineRelieving
                            where purchReqLineRelieving.PurchId == purchTableRelieving.PurchId
                                exists join purchReqTableRelieving
                                where purchReqTableRelieving.RecId == purchReqLineRelieving.PurchReqTable
                                   && purchReqTableRelieving.SourceDocumentHeader == _purchReqSourceDocumentHeaderId
                exists join dimensionAttributeLevelValueAllViewRelieving
                where dimensionAttributeLevelValueAllViewRelieving.ValueCombinationRecId == subledgerJournalAccountEntryRelieving.LedgerDimension
                    && dimensionAttributeLevelValueAllViewRelieving.DimensionAttribute == dimensionAttributeRecId
                    && dimensionAttributeLevelValueAllViewRelieving.AttributeValueRecId == dimensionAttributeLevelValueAllView.AttributeValueRecId
                exists join dimensionAttributeValueCombinationRelieving
                where dimensionAttributeValueCombinationRelieving.RecId == subledgerJournalAccountEntryRelieving.LedgerDimension
                    exists join mainAccountRelieving
                    where mainAccountRelieving.RecId == dimensionAttributeValueCombinationRelieving.MainAccount
                        && mainAccountRelieving.AccountCategoryRef == #MainAccountCategory_PreEncumbrance;

            relievedAmount = subledgerJournalAccountEntryRelieving.AccountingCurrencyAmount;
            _ledgerEncumbrance.insert(dimensionAttributeLevelValueAllView.DisplayValue, currentRequisitionAmount + relievedAmount);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOrAppendMapEntries</Name>
				<Source><![CDATA[
    private void updateOrAppendMapEntries(
        Map _fromMap,
        Map _toMap)
    {
        MapEnumerator fromMapEnumerator = _fromMap.getEnumerator();
        AmountMST     amountMST;

        while (fromMapEnumerator.moveNext())
        {
            if (_toMap.exists(fromMapEnumerator.currentKey()))
            {
                amountMST = _toMap.lookup(fromMapEnumerator.currentKey());
            }

            amountMST += fromMapEnumerator.currentValue();

            _toMap.insert(fromMapEnumerator.currentKey(), amountMST);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static LedgerEncumbranceReconciliationDP construct()
    {
        return new LedgerEncumbranceReconciliationDP();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>