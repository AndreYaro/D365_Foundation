<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ReqSupplyDemandScheduleModel</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class ReqSupplyDemandScheduleModel implements WorkPeriodTemplateCalculable
{
    #ReqSupplyDemandScheduleTypes

    container                   calculatedQuantities;
    container                   calculatedPeriods;

    int                         numberOfSupplyDemandTypes;
    int                         currentPeriod;

    TransDate                   todayDate;
    boolean                     queryData;
    boolean                     typeVisible [100];

    // Ranges and datasources used for filtering
    Query                       query;

    // Filters
    ItemId                      itemId;
    ForecastItemAllocationId    itemAllocationKey;
    ReqPlanId                   reqPlanId;
    RefRecId                    periodTemplate;
    InventDim                   inventDim;
    InventDimId                 inventDimId;

    boolean                     skipPeriodDescriptions;
    boolean                     forceDirectInventDimCoverageJoin;

    WMSReqTransMovementStatus   movementStatus;
    Set                         inboundTransTypes;
    Set                         outboundTransTypes;
    boolean                     skipBacklogPeriod;
    boolean                     skipOutlookPeriod;
    boolean                     processOnlyBacklogPeriod;
    boolean                     processOnlyOutlookPeriod;
    InventDimParm               inventDimParm;
    int                         currentSelectionRow;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addForecastItemAllocationRange</Name>
				<Source><![CDATA[
    private void addForecastItemAllocationRange(
        QueryBuildDataSource _queryBuildDataSource,
        FieldId              _fieldId)
    {
        QueryBuildRange         rangeAllocationKey;
        QueryBuildDataSource    dataSourceForecastItemAllocationLine;

        // Add forecast allocation as a filtering data source
        dataSourceForecastItemAllocationLine = _queryBuildDataSource.addDataSource(tableNum(ForecastItemAllocationLine));
        dataSourceForecastItemAllocationLine.addLink(_fieldId, fieldNum(ForecastItemAllocationLine, ItemId));
        dataSourceForecastItemAllocationLine.joinMode(JoinMode::ExistsJoin);

        // Set item allocation id range
        rangeAllocationKey = dataSourceForecastItemAllocationLine.addRange(fieldNum(ForecastItemAllocationLine, AllocationId));
        rangeAllocationKey.value(queryValue(this.parmForecastItemAllocationId()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addInventDimDatasource</Name>
				<Source><![CDATA[
    private void addInventDimDatasource(
        QueryBuildDataSource _masterTable,
        FieldId              _linkFieldId)
    {
        QueryBuildDataSource    datasourceInventDim;

        // Only add datasource if one or more invent dimensions are selected as filters
        if (!this.parmInventDimParm().isAllFlagNo())
        {
            datasourceInventDim = _masterTable.addDataSource(tableNum(InventDim));
            datasourceInventDim.joinMode(JoinMode::ExistsJoin);
            datasourceInventDim.addLink(_linkFieldId, fieldNum(InventDim, InventDimId));

            // Filter for inventory dimensions
            inventDimParm.queryAddRange(datasourceInventDim, inventDim);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addItemRange</Name>
				<Source><![CDATA[
    private void addItemRange(
        QueryBuildDataSource _queryBuildDataSource,
        FieldId              _fieldId)
    {
        QueryBuildRange rangeItemId;

        // Set item id range
        rangeItemId = _queryBuildDataSource.addRange(_fieldId);
        rangeItemId.value(queryValue(this.parmItemId()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addPeriod</Name>
				<Source><![CDATA[
    public void addPeriod(
        TransDate                 _fromDate,
        TransDate                 _toDate,
        PeriodTemplateDescription _periodDescription,
        PeriodTemplateOpenDays    _workDays)
    {
        if (this.parmProcessOnlyBacklogPeriod()
         && _periodDescription != "@SYS90879")
        {
            return; // do process only backlog period - skip all the others
        }

        if (this.parmProcessOnlyOutlookPeriod()
         && _periodDescription != "@SYS131154")
        {
            return; // do process only outlook period - skip all the others
        }

        if (this.parmSkipBacklogPeriod()
         && _periodDescription == "@SYS90879")
        {
            return; // do not process backlog period
        }

        if (this.parmSkipOutlookPeriod()
         && _periodDescription == "@SYS131154")
        {
            return; // do not process outlook period
        }

        currentPeriod++;

        // Only fetch data if requested, otherwise only period template periods are found and returned
        if (queryData)
        {
            this.executeQuery(_fromDate, _toDate);
        }

        // Add period to the result container
        calculatedPeriods = calculatedPeriods + [[_fromDate, _toDate, _periodDescription]];
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Builds the query that is used for retrieving the planning data that is based on the current filters.
    /// </summary>
    public void buildQuery()
    {
        QueryBuildDataSource        reqTransDatasource;
        QueryBuildRange             periodRange;
        QueryBuildRange             masterplanRange;
        QueryBuildRange             itemIdRange;

        query = new Query();

        reqTransDatasource = query.addDataSource(tableNum(ReqTrans));

        reqTransDatasource.addGroupByField(fieldNum(ReqTrans, RefType));
        reqTransDatasource.addGroupByField(fieldNum(ReqTrans, Direction));
        reqTransDatasource.addGroupByField(fieldNum(ReqTrans, IsForecastPurch));
        reqTransDatasource.addGroupByField(fieldNum(ReqTrans, SupplyDemandSubClassification));

        reqTransDatasource.addSelectionField(fieldNum(ReqTrans, Qty), SelectionField::Sum);
        reqTransDatasource.addSelectionField(fieldNum(ReqTrans, CovQty), SelectionField::Sum);

        periodRange = reqTransDatasource.addRange(fieldNum(ReqTrans, ReqDate));

        // Add filtering for master plan version
        if (reqPlanId)
        {
            masterplanRange = reqTransDatasource.addRange(fieldNum(ReqTrans, PlanVersion));
            masterplanRange.value(queryValue(ReqPlan::findReqPlanId(reqPlanId).findActiveVersion().RecId));
        }

        // Add filtering for item id
        if (itemId)
        {
            itemIdRange = reqTransDatasource.addRange(fieldNum(ReqTrans, ItemId));
            itemIdRange.value(queryValue(itemId));
        }
        else
        {
            // Add filtering for item allocation key
            if (itemAllocationKey)
            {
                this.addForecastItemAllocationRange(reqTransDatasource, fieldNum(ReqTrans, ItemId));
            }
        }

        if (this.parmMovementStatus() == WMSReqTransMovementStatus::Planned)
        {
            reqTransDatasource.addRange(fieldNum(ReqTrans, InventTransOrigin)).value(SysQuery::value(0));
        }
        else if (this.parmMovementStatus() == WMSReqTransMovementStatus::Confirmed)
        {
            reqTransDatasource.addRange(fieldNum(ReqTrans, InventTransOrigin)).value(SysQuery::valueNot(0));
        }

        // Add filtering for inventory dimensions
        this.addInventDimDatasource(reqTransDatasource, fieldNum(ReqTrans, CovInventDimId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSalesQuery</Name>
				<Source><![CDATA[
    private Query buildSalesQuery(
        TransDate _fromdate,
        TransDate _toDate,
        boolean   _setShippingDateRequestedRange,
        boolean   _setShippingDateConfirmedRange,
        boolean   _setLineAmountSum)
    {
        Query                   salesQuery;
        QueryBuildDataSource    dataSourceSalesLine;
        QueryBuildDataSource    dataSourceReqTrans;
        QueryBuildDataSource    dataSourceInventTransOriginSalesLine;
        QueryBuildRange         rangeReqDate;
        QueryBuildRange         rangeSalesStatus;
        int                     dayOffset;

        salesQuery = new Query();

        dataSourceSalesLine = salesQuery.addDataSource(tableNum(SalesLine));

        dataSourceReqTrans = dataSourceSalesLine.addDataSource(tableNum(ReqTrans));
        dataSourceReqTrans.fetchMode(QueryFetchMode::One2One);
        dataSourceReqTrans.addLink(fieldNum(SalesLine, SalesId), fieldNum(ReqTrans, RefId));
        dataSourceReqTrans.addRange(fieldNum(ReqTrans, RefType)).value(queryValue(ReqRefType::Sales));
        dataSourceReqTrans.addRange(fieldNum(ReqTrans, PlanVersion)).value(queryValue(ReqPlan::findReqPlanId(reqPlanId).findActiveVersion().RecId));
        dataSourceReqTrans.joinMode(JoinMode::ExistsJoin);
        rangeReqDate = dataSourceReqTrans.addRange(fieldNum(ReqTrans, ReqDate));

        dataSourceInventTransOriginSalesLine = dataSourceReqTrans.addDataSource(tableNum(InventTransOriginSalesLine));
        dataSourceInventTransOriginSalesLine.fetchMode(QueryFetchMode::One2One);
        dataSourceInventTransOriginSalesLine.addLink(fieldNum(ReqTrans, InventTransOrigin), fieldNum(InventTransOriginSalesLine, InventTransOrigin));
        dataSourceInventTransOriginSalesLine.joinMode(JoinMode::ExistsJoin);
        dataSourceInventTransOriginSalesLine.addLink(fieldNum(Salesline, InventTransId), fieldNum(InventTransOriginSalesLine, SalesLineInventTransId), dataSourceSalesLine.name());
        dataSourceInventTransOriginSalesLine.addLink(fieldNum(Salesline, DataAreaId), fieldNum(InventTransOriginSalesLine, SalesLineDataAreaId), dataSourceSalesLine.name());

        if (_fromdate == dateNull())
        {
            dayOffset = 1;
        }

        rangeReqDate.value(strFmt('( ((%1.%2 >= %3) && (%1.%2 <= %4)) )',
             rangeReqDate.dataSource().name(),
             fieldStr(ReqTrans, ReqDate),
             date2StrXpp(_fromdate + dayOffset),
             date2StrXpp(_toDate)
             ));

        rangeSalesStatus  = dataSourceSalesLine.addRange(fieldNum(SalesLine, SalesStatus));
        rangeSalesStatus.value(queryValue(SalesStatus::Backorder));

        if (!(_setShippingDateRequestedRange && _setShippingDateConfirmedRange))
        {
            if (_setLineAmountSum)
            {
                dataSourceSalesLine.addSelectionField(fieldNum(SalesLine, LineAmount), SelectionField::Sum);
            }
            else
            {
                dataSourceSalesLine.addSelectionField(fieldNum(SalesLine, RecId), SelectionField::Count);
                dataSourceSalesLine.addSelectionField(fieldNum(SalesLine, RemainSalesPhysical), SelectionField::Sum);
            }
        }

        if (this.parmItemId())
        {
            this.addItemRange(dataSourceSalesLine, fieldNum(SalesLine, ItemId));
        }
        else
        if (this.parmForecastItemAllocationId())
        {
            this.addForecastItemAllocationRange(dataSourceSalesLine, fieldNum(SalesLine, ItemId));
        }

        if (this.parmInventDim())
        {
            this.addInventDimDatasource(dataSourceSalesLine, fieldNum(SalesLine, InventDimId));
        }

        return salesQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcPeriods</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates all the periods that are defined by the period template.
    /// </summary>
    public void calcPeriods()
    {
        WorkPeriodTemplateCalculate     workPeriodTemplateCalculate;
        int                             i;

        currentPeriod = 0;

        // Clear results containers
        calculatedPeriods       = conNull();
        calculatedQuantities    = conNull();

        // Create an empty result container for each of the supply/demand types
        for (i = 1; i <= numberOfSupplyDemandTypes; i++)
        {
            calculatedQuantities = calculatedQuantities + [conNull()];

            // Set the type to the hidden by default. The type is shown if data are found
            typeVisible[i] = false;
        }

        this.setRowsAlwaysVisible();

        // Initialize and start period calculation
        workPeriodTemplateCalculate = WorkPeriodTemplateCalculate::newStandard(periodTemplate, todayDate, ForwardBackward::Forward);
        workPeriodTemplateCalculate.parmSkipPeriodDescriptions(skipPeriodDescriptions);
        workPeriodTemplateCalculate.calcPeriods(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateDemand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the demand quantity for one net requirement.
    /// </summary>
    /// <param name="_reqTrans">
    /// The net rerquirements to be used for calculation.
    /// </param>
    /// <returns>
    /// The demand quantity for the provided net requirement.
    /// </returns>
    protected ReqQty calculateDemand(ReqTrans    _reqTrans)
    {
        ReqQty      result = 0;

        switch (_reqTrans.RefType)
        {
            case ReqRefType::SalesForecast:
            case ReqRefType::SalesQuotation:
            case ReqRefType::PlannedIntercompanyDemand:
            case ReqRefType::TransferOrderShip:
            case ReqRefType::TransferDemand:
            case ReqRefType::RequisitionLine:
            case ReqRefType::PdsExpiredBatch:
                result = abs(_reqTrans.Qty);
                break;

            case ReqRefType::Sales:
            case ReqRefType::BOMLine:
            case ReqRefType::PmfFormulaLine:
            case ReqRefType::ProdLine:
            case ReqRefType::InventTransfer:
            case ReqRefType::InventJournal:
            case ReqRefType::ConsignmentReplenishmentOrder:
            case ReqRefType::Purch:
                result = (_reqTrans.Direction == InventDirection::Issue) ? abs(_reqTrans.Qty) : 0;
                break;

            case ReqRefType::PlannedKanbanLine:
            case ReqRefType::KanbanLine:
                if (_reqTrans.Direction == InventDirection::Issue)
                {
                    if (_reqTrans.SupplyDemandSubClassification == SupplyDemandSubClassification::WithdrawalKanban
                     || _reqTrans.SupplyDemandSubClassification == SupplyDemandSubClassification::ProductionKanban)
                    {
                        result = abs(_reqTrans.Qty);
                    }
                }
                break;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateDemandTransfers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the transfer demand quantity for one net requirement.
    /// </summary>
    /// <param name="_reqTrans">
    /// The net rerquirements to be used for calculation.
    /// </param>
    /// <returns>
    /// The transfer demand quantity for the provided net requirement.
    /// </returns>
    protected ReqQty calculateDemandTransfers(ReqTrans    _reqTrans)
    {
        ReqQty          result = 0;

        switch (_reqTrans.RefType)
        {
            case ReqRefType::TransferOrderShip:
            case ReqRefType::TransferDemand:
                result = abs(_reqTrans.Qty);
                break;

            case ReqRefType::InventTransfer:
                if (_reqTrans.Direction == InventDirection::Issue)
                {
                    result = abs(_reqTrans.Qty);
                }
                break;

            case ReqRefType::KanbanLine:
            case ReqRefType::PlannedKanbanLine:
                if (_reqTrans.Direction == InventDirection::Issue
                 && _reqTrans.SupplyDemandSubClassification == SupplyDemandSubClassification::WithdrawalKanban)
                {
                    result = abs(_reqTrans.Qty);
                }
                break;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculatedPeriods</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the container that has the calculated periods that are defined by the period template.
    /// </summary>
    /// <returns>
    ///    The container that has the calculated periods.
    /// </returns>
    public container calculatedPeriods()
    {
        return calculatedPeriods;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculatedQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the container that has the calculated quantities that are defined by the period template
    ///    and query.
    /// </summary>
    /// <returns>
    ///    The container that has the calculated quantities per period.
    /// </returns>
    public container calculatedQuantities()
    {
        return calculatedQuantities;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateInventoryStartPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the starting inventory onhand quantity for one net requirement.
    /// </summary>
    /// <param name="_reqTrans">
    /// The net rerquirements to be used for calculation.
    /// </param>
    /// <param name="_currentPeriod">
    /// The number of the current period.
    /// </param>
    /// <returns>
    /// The starting inventory onhand quantity for the provided net requirement.
    /// </returns>
    protected ReqQty calculateInventoryStartPeriod(
        ReqTrans    _reqTrans,
        int         _currentPeriod)
    {
        ReqQty          result = 0;

        if (_reqTrans.RefType == ReqRefType::InventOnHand
            && _currentPeriod == 1)
        {
            // onhand only appears in first period and must be the starting inventory quantity.
            result = _reqTrans.Qty;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateMinimumInventory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the minimum inventory quantity for one net requirement.
    /// </summary>
    /// <param name="_reqTrans">
    /// The net rerquirements to be used for calculation.
    /// </param>
    /// <returns>
    /// The minimum inventory quantity for the provided net requirement.
    /// </returns>
    protected ReqQty calculateMinimumInventory(ReqTrans    _reqTrans)
    {
        return (_reqTrans.RefType == ReqRefType::SafetyInvent && _reqTrans.Direction == InventDirection::Issue) ? abs(_reqTrans.Qty) : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculatePeggedInventoryPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the coverage planned inventory quantity for one net requirement.
    /// </summary>
    /// <param name="_reqTrans">
    /// The net rerquirements to be used for calculation.
    /// </param>
    /// <param name="_headerType">
    /// The type of header for the net requirement.
    /// </param>
    /// <returns>
    /// The coverage planned inventory quantity for the provided net requirement.
    /// </returns>
    protected ReqQty calculatePeggedInventoryPeriod(
        ReqTrans    _reqTrans,
        int         _headerType)
    {
        return (_headerType != 0) ? _reqTrans.CovQty : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSupply</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the supply quantity for one net requirement.
    /// </summary>
    /// <param name="_reqTrans">
    /// The net rerquirements to be used for calculation.
    /// </param>
    /// <returns>
    /// The supply quantity for the provided net requirement.
    /// </returns>
    protected ReqQty calculateSupply(ReqTrans    _reqTrans)
    {
        ReqQty          result = 0;

        switch (_reqTrans.RefType)
        {
            case ReqRefType::BOMPlannedOrder:
            case ReqRefType::PmfPlannedProdBatch:
            case ReqRefType::PmfCoProduct:
            case ReqRefType::Production:
            case ReqRefType::ItemPlannedOrder:
            case ReqRefType::TransferOrderReceive:
                result = _reqTrans.Qty;
                break;

            case ReqRefType::Purch:
                if (_reqTrans.Direction == InventDirection::Receipt)
                {
                    result = _reqTrans.Qty;
                }
            break;

            case ReqRefType::InventTransfer:
            case ReqRefType::KanbanLine:
            case ReqRefType::TransferPlannedOrder:
            case ReqRefType::ProdLine:
            case ReqRefType::BOMLine:
            case ReqRefType::PmfFormulaLine:
            case ReqRefType::InventJournal:
            case ReqRefType::ConsignmentReplenishmentOrder:
            case ReqRefType::Sales:
                if (_reqTrans.Direction == InventDirection::Receipt)
                {
                    result = _reqTrans.Qty;
                }
                break;

            case ReqRefType::Kanban:
            case ReqRefType::PlannedKanban:
                if (_reqTrans.Direction == InventDirection::Receipt)
                {
                    if (_reqTrans.SupplyDemandSubClassification == SupplyDemandSubClassification::ProductionKanban
                     || _reqTrans.SupplyDemandSubClassification == SupplyDemandSubClassification::WithdrawalKanban)
                    {
                        result = _reqTrans.Qty;
                    }
                }
                break;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSupplyPlannedKanban</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the planned kanban quantity for one net requirement.
    /// </summary>
    /// <param name="_reqTrans">
    /// The net rerquirements to be used for calculation.
    /// </param>
    /// <returns>
    /// The planned kanban quantity for the provided net requirement.
    /// </returns>
    protected ReqQty calculateSupplyPlannedKanban(ReqTrans    _reqTrans)
    {
        ReqQty          result = 0;

        if (_reqTrans.RefType == ReqRefType::PlannedKanban
         && _reqTrans.Direction == InventDirection::Receipt
         && _reqTrans.SupplyDemandSubClassification == SupplyDemandSubClassification::ProductionKanban)
        {
            result = _reqTrans.Qty;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSupplyPlannedKanbanLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the planned kanban line quantity for one net requirement.
    /// </summary>
    /// <param name="_reqTrans">
    /// The net rerquirements to be used for calculation.
    /// </param>
    /// <returns>
    /// The planned kanban line quantity for the provided net requirement.
    /// </returns>
    protected ReqQty calculateSupplyPlannedKanbanLines(ReqTrans    _reqTrans)
    {
        ReqQty          result = 0;

        if (_reqTrans.RefType == ReqRefType::KanbanLine
            && _reqTrans.Direction == InventDirection::Receipt
            && _reqTrans.SupplyDemandSubClassification == SupplyDemandSubClassification::ProductionKanban)
        {
            result = _reqTrans.Qty;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSupplyPlannedProductionOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the planned production order quantity for one net requirement.
    /// </summary>
    /// <param name="_reqTrans">
    /// The net rerquirements to be used for calculation.
    /// </param>
    /// <returns>
    /// The planned production order quantity for the provided net requirement.
    /// </returns>
    protected ReqQty calculateSupplyPlannedProductionOrders(ReqTrans    _reqTrans)
    {
        return (_reqTrans.RefType == ReqRefType::BOMPlannedOrder) ? _reqTrans.Qty : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSupplyPlannedPurchaseOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the planned purchase order quantity for one net requirement.
    /// </summary>
    /// <param name="_reqTrans">
    /// The net rerquirements to be used for calculation.
    /// </param>
    /// <returns>
    /// The planned purchase order quantity for the provided net requirement.
    /// </returns>
    protected ReqQty calculateSupplyPlannedPurchaseOrders(ReqTrans    _reqTrans)
    {
        return (_reqTrans.RefType == ReqRefType::ItemPlannedOrder) ? _reqTrans.Qty : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSupplyPmfPlannedBatchOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the planned batch order quantity for one net requirement.
    /// </summary>
    /// <param name="_reqTrans">
    /// The net rerquirements to be used for calculation.
    /// </param>
    /// <returns>
    /// The planned batch order quantity for the provided net requirement.
    /// </returns>
    protected ReqQty calculateSupplyPmfPlannedBatchOrders(ReqTrans    _reqTrans)
    {
        return (_reqTrans.RefType == ReqRefType::PmfPlannedProdBatch) ? _reqTrans.Qty : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSupplyProduction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the production supply quantity for one net requirement.
    /// </summary>
    /// <param name="_reqTrans">
    /// The net rerquirements to be used for calculation.
    /// </param>
    /// <returns>
    /// The prodcution supply quantity for the provided net requirement.
    /// </returns>
    protected ReqQty calculateSupplyProduction(ReqTrans    _reqTrans)
    {
        ReqQty          result = 0;

        switch (_reqTrans.RefType)
        {
            case ReqRefType::Production:
            case ReqRefType::BOMPlannedOrder:
            case ReqRefType::PmfPlannedProdBatch:
            case ReqRefType::PmfCoProduct:
                result = _reqTrans.Qty;
                break;

            case ReqRefType::ProdLine:
            case ReqRefType::BOMLine:
            case ReqRefType::PmfFormulaLine:
                if (_reqTrans.Direction == InventDirection::Receipt)
                {
                    result = _reqTrans.Qty;
                }
                break;

            case ReqRefType::KanbanLine:
                if (_reqTrans.Direction == InventDirection::Receipt
                 && _reqTrans.SupplyDemandSubClassification != SupplyDemandSubClassification::WithdrawalKanban)
                {
                    result = _reqTrans.Qty;
                }
                break;

            case ReqRefType::Kanban:
            case ReqRefType::PlannedKanban:
                if (_reqTrans.Direction == InventDirection::Receipt
                 && _reqTrans.SupplyDemandSubClassification == SupplyDemandSubClassification::ProductionKanban)
                {
                    result = _reqTrans.Qty;
                }
                break;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSupplyPurchase</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the purchase supply quantity for one net requirement.
    /// </summary>
    /// <param name="_reqTrans">
    /// The net rerquirements to be used for calculation.
    /// </param>
    /// <returns>
    /// The purchase supply quantity for the provided net requirement.
    /// </returns>
    protected ReqQty calculateSupplyPurchase(ReqTrans    _reqTrans)
    {
        ReqQty          result = 0;

        switch (_reqTrans.RefType)
        {
            case ReqRefType::Purch:
                if (_reqTrans.Direction == InventDirection::Receipt)
                {
                    result = _reqTrans.Qty;
                }
                break;

            case ReqRefType::ItemPlannedOrder:
                result = _reqTrans.Qty;
                break;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSupplyTransferPlannedKanbans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the planned kanban transfer quantity for one net requirement.
    /// </summary>
    /// <param name="_reqTrans">
    /// The net rerquirements to be used for calculation.
    /// </param>
    /// <returns>
    /// The planned kanban transfer quantity for the provided net requirement.
    /// </returns>
    protected ReqQty calculateSupplyTransferPlannedKanbans(ReqTrans    _reqTrans)
    {
        ReqQty          result = 0;

        if (_reqTrans.RefType == ReqRefType::PlannedKanban
            && _reqTrans.Direction == InventDirection::Receipt
            && _reqTrans.SupplyDemandSubClassification == SupplyDemandSubClassification::WithdrawalKanban)
        {
            result = _reqTrans.Qty;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSupplyTransferPlannedOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the planned transfer quantity for one net requirement.
    /// </summary>
    /// <param name="_reqTrans">
    /// The net rerquirements to be used for calculation.
    /// </param>
    /// <returns>
    /// The planned transfer quantity for the provided net requirement.
    /// </returns>
    protected ReqQty calculateSupplyTransferPlannedOrders(ReqTrans    _reqTrans)
    {
        ReqQty          result = 0;

        if (_reqTrans.RefType == ReqRefType::TransferPlannedOrder
         && _reqTrans.Direction == InventDirection::Receipt)
        {
            result = _reqTrans.Qty;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSupplyTransfers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the supply transfer quantity for one net requirement.
    /// </summary>
    /// <param name="_reqTrans">
    /// The net rerquirements to be used for calculation.
    /// </param>
    /// <returns>
    /// The supply transfer quantity for the provided net requirement.
    /// </returns>
    protected ReqQty calculateSupplyTransfers(ReqTrans    _reqTrans)
    {
        ReqQty          result = 0;

        switch (_reqTrans.RefType)
        {
            case ReqRefType::TransferOrderReceive:
                result = _reqTrans.Qty;
                break;

            case ReqRefType::InventTransfer:
            case ReqRefType::TransferPlannedOrder:
            case ReqRefType::InventJournal:
            case ReqRefType::ConsignmentReplenishmentOrder:
                if (_reqTrans.Direction == InventDirection::Receipt)
                {
                    result = _reqTrans.Qty;
                }
                break;

            case ReqRefType::KanbanLine:
            case ReqRefType::Kanban:
            case ReqRefType::PlannedKanban:
                if (_reqTrans.Direction == InventDirection::Receipt
                 && _reqTrans.SupplyDemandSubClassification == SupplyDemandSubClassification::WithdrawalKanban)
                {
                    result = _reqTrans.Qty;
                }
                break;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeQuery</Name>
				<Source><![CDATA[
    private void executeQuery(
        TransDate _fromDate,
        TransDate _toDate)
    {
        QueryRun    queryRun;
        ReqTrans    reqTrans;
        int         headerType;
        ReqQty      demandTotal;
        ReqQty      demandTransfersTotal;
        ReqQty      supplyTotal;
        ReqQty      supplyProductionTotal;
        ReqQty      supplyPlannedProductionOrdersTotal;
        ReqQty      supplyPmfPlannedBatchOrdersTotal;
        ReqQty      supplyPlannedKanbanTotal;
        ReqQty      supplyPlannedKanbanLinesTotal;
        ReqQty      supplyPurchaseTotal;
        ReqQty      supplyPlannedPurchaseOrdersTotal;
        ReqQty      supplyTransfersTotal;
        ReqQty      supplyTransferPlannedOrdersTotal;
        ReqQty      supplyTransferPlannedKanbansTotal;
        ReqQty      peggedInventoryPeriod;
        ReqQty      minimumInventoryChange;
        ReqQty      inventoryStartPeriod;
        QueryBuildRange     periodRange;
        Set                 inboundTypes = this.parmInboundTransTypes();
        Set                 outboundTypes = this.parmOutboundTransTypes();

        if (!
        this.parmQuery()
        )
        {
            this.buildQuery();
        }

        // Set from and to date based on the current period
        periodRange = this.parmQuery().dataSourceTable(tableNum(ReqTrans)).findRange(fieldNum(ReqTrans, ReqDate));
        periodRange.value(queryRange(_fromDate, _toDate));

        queryRun = new QueryRun(
        this.parmQuery()
        );

        ReqQty periodStartCumulativeInventoryQty;

        while (queryRun.next())
        {
            reqTrans = queryRun.get(tableNum(ReqTrans));
            headerType = 0;

            if ((!inboundTypes && !outboundTypes) // if no trans type filters are specified we need to process all
                || (inboundTypes && inboundTypes.in(reqTrans.RefType)) // if inbound types are specified then process if current trans type is in the set
                || (outboundTypes && outboundTypes.in(reqTrans.RefType))) // if outbound types are specified then process if current trans type is in the set
            {
                headerType = this.getHeaderType(reqTrans, currentPeriod);

                if (headerType)
                {
                    if (headerType == #PeriodStartInventory)                   
                    {
                        // Sum the start inventory quantities for all inventory directions
                        periodStartCumulativeInventoryQty += reqTrans.Qty;                   
                    }
                    // In case minimum onHand decreases we want to display the negative delta in Minimum Inventory
                    else if (headerType == #MinimumInventoryChange)
                    {
                        minimumInventoryChange -= reqTrans.Qty;
                    }
                    else
                    {
                        // Add result to the result set
                        this.insertPeriodValue(headerType, abs(reqTrans.Qty), true);
                    }
                }

                demandTotal                             += this.calculateDemand(reqTrans);
                demandTransfersTotal                    += this.calculateDemandTransfers(reqTrans);
                supplyTotal                             += this.calculateSupply(reqTrans);
                supplyProductionTotal                   += this.calculateSupplyProduction(reqTrans);
                supplyPlannedProductionOrdersTotal      += this.calculateSupplyPlannedProductionOrders(reqTrans);
                supplyPmfPlannedBatchOrdersTotal        += this.calculateSupplyPmfPlannedBatchOrders(reqTrans);
                supplyPlannedKanbanTotal                += this.calculateSupplyPlannedKanban(reqTrans);
                supplyPlannedKanbanLinesTotal           += this.calculateSupplyPlannedKanbanLines(reqTrans);
                supplyPurchaseTotal                     += this.calculateSupplyPurchase(reqTrans);
                supplyPlannedPurchaseOrdersTotal        += this.calculateSupplyPlannedPurchaseOrders(reqTrans);
                supplyTransfersTotal                    += this.calculateSupplyTransfers(reqTrans);
                supplyTransferPlannedOrdersTotal        += this.calculateSupplyTransferPlannedOrders(reqTrans);
                supplyTransferPlannedKanbansTotal       += this.calculateSupplyTransferPlannedKanbans(reqTrans);
                inventoryStartPeriod                    += this.calculateInventoryStartPeriod(reqTrans, currentPeriod);
                peggedInventoryPeriod                   += this.calculatePeggedInventoryPeriod(reqTrans, headerType);
            }
        }

        // Add result to the result set
        if (currentPeriod == 1)
        {
            this.insertPeriodValue(#PeriodStartInventory, periodStartCumulativeInventoryQty, true);
            this.insertPeriodValue(#MinimumInventory, minimumInventoryChange);
        }

        // Update totals
        if (currentPeriod > 1)
        {
            inventoryStartPeriod = this.previousPeriodValue(#PeriodEndInventory);
            this.insertPeriodValue(#PeriodStartInventory, inventoryStartPeriod, true);

            ReqQty previousMinimumInventory = this.previousPeriodValue(#MinimumInventory);
            this.insertPeriodValue(#MinimumInventory, previousMinimumInventory + minimumInventoryChange);
        }

        this.insertPeriodValue(#MinimumInventoryChange, minimumInventoryChange);
        this.insertPeriodValue(#DemandTotal, demandTotal);
        this.insertPeriodValue(#DemandTransfersTotal, demandTransfersTotal);
        this.insertPeriodValue(#SupplyTotal, supplyTotal);
        this.insertPeriodValue(#SupplyProductionTotal, supplyProductionTotal);
        this.insertPeriodValue(#SupplyPlannedProductionOrdersTotal, supplyPlannedProductionOrdersTotal);
        this.insertPeriodValue(#SupplyPmfPlannedBatchOrdersTotal, supplyPmfPlannedBatchOrdersTotal);
        this.insertPeriodValue(#SupplyPlannedKanbanTotal, supplyPlannedKanbanTotal);
        this.insertPeriodValue(#SupplyPlannedKanbanLinesTotal, supplyPlannedKanbanLinesTotal);
        this.insertPeriodValue(#SupplyPurchaseTotal, supplyPurchaseTotal);
        this.insertPeriodValue(#SupplyPlannedPurchaseOrdersTotal, supplyPlannedPurchaseOrdersTotal);
        this.insertPeriodValue(#SupplyTransfersTotal, supplyTransfersTotal);
        this.insertPeriodValue(#SupplyTransferPlannedOrdersTotal, supplyTransferPlannedOrdersTotal);
        this.insertPeriodValue(#SupplyTransferPlannedKanbansTotal, supplyTransferPlannedKanbansTotal);

        this.insertPeriodValue(#SupplyDemandDelta, supplyTotal - demandTotal);
        this.insertPeriodValue(#PeriodEndInventory, inventoryStartPeriod + supplyTotal - demandTotal);
        this.insertPeriodValue(#PeriodEndPeggedInventory, peggedInventoryPeriod+this.previousPeriodValue(#PeriodEndPeggedInventory));
    }

]]></Source>
			</Method>
			<Method>
				<Name>findDelays</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the delayed sales, purchase, and production orders of all the periods in the period template.
    /// </summary>
    /// <returns>
    ///    The container that has all the delayed sales, purchase, and production orders in the periods.
    /// </returns>
    public container findDelays()
    {
        #define.periodStartDate(1)
        #define.periodEndDate(2)
        QueryBuildDataSource    dataSourceSalesLine;
        QueryBuildDataSource    dataSourcePurchLine;
        QueryBuildDataSource    dataSourceProdTable;
        QueryBuildRange         rangeShippingDateRequested;
        QueryBuildRange         rangeShippingDateConfirmed;
        QueryBuildRange         rangeDlvDate;
        QueryBuildRange         rangeEndDate;
        Query                   totalsQuery;
        QueryRun                queryRun;
        SalesLine               salesLine;
        PurchLine               purchLine;
        ProdTable               prodTable;
        container               salesResult;
        container               purchResult;
        container               prodResult;
        Days                    highestDelay;
        int                     i;
        TransDate               fromDate;
        TransDate               toDate;

        // Traverse the periods in the period template
        for (i = 1; i <= conLen(calculatedPeriods); i++)
        {
            fromDate = conPeek(conPeek(calculatedPeriods, i), #periodStartDate);
            toDate = conPeek(conPeek(calculatedPeriods, i), #periodEndDate);

            totalsQuery = new Query();

            highestDelay = 0;

            // Find sales orders delays

            dataSourceSalesLine = totalsQuery.addDataSource(tableNum(SalesLine));
            rangeShippingDateConfirmed  = dataSourceSalesLine.addRange(fieldNum(SalesLine, ShippingDateConfirmed));
            rangeShippingDateRequested  = dataSourceSalesLine.addRange(fieldNum(SalesLine, ShippingDateRequested));

            rangeShippingDateRequested.value(queryRange(fromDate, toDate));
            rangeShippingDateConfirmed.value(SysQuery::valueNot(dateNull()));

            if (this.parmItemId())
            {
                this.addItemRange(dataSourceSalesLine, fieldNum(SalesLine, ItemId));
            }
            else
            if (this.parmForecastItemAllocationId())
            {
                this.addForecastItemAllocationRange(dataSourceSalesLine, fieldNum(SalesLine, ItemId));
            }

            if (this.parmInventDim())
            {
                this.addInventDimDatasource(dataSourceSalesLine, fieldNum(SalesLine, InventDimId));
            }

            queryRun = new QueryRun(totalsQuery);
            while (queryRun.next())
            {
                salesLine = queryRun.get(tableNum(SalesLine));

                if (salesLine.ShippingDateConfirmed > salesLine.ShippingDateRequested && (salesLine.ShippingDateConfirmed - salesLine.ShippingDateRequested) > highestDelay)
                {
                    highestDelay = salesLine.ShippingDateConfirmed - salesLine.ShippingDateRequested;
                }
            }

            salesResult += [highestDelay];

            // Find purchase orders delays

            totalsQuery = new Query();

            highestDelay = 0;

            dataSourcePurchLine = totalsQuery.addDataSource(tableNum(PurchLine));
            rangeShippingDateConfirmed  = dataSourcePurchLine.addRange(fieldNum(PurchLine, ShippingDateConfirmed));
            rangeShippingDateRequested  = dataSourcePurchLine.addRange(fieldNum(PurchLine, ShippingDateRequested));

            rangeShippingDateRequested.value(queryRange(fromDate, toDate));
            rangeShippingDateConfirmed.value(SysQuery::valueNot(dateNull()));

            if (this.parmItemId())
            {
                this.addItemRange(dataSourcePurchLine, fieldNum(PurchLine, ItemId));
            }
            else
            if (this.parmForecastItemAllocationId())
            {
                this.addForecastItemAllocationRange(dataSourcePurchLine, fieldNum(PurchLine, ItemId));
            }

            if (this.parmInventDim())
            {
                this.addInventDimDatasource(dataSourcePurchLine, fieldNum(PurchLine, InventDimId));
            }

            queryRun = new QueryRun(totalsQuery);
            while (queryRun.next())
            {
                purchLine = queryRun.get(tableNum(PurchLine));

                if (purchLine.ShippingDateConfirmed > purchLine.ShippingDateRequested && (purchLine.ShippingDateConfirmed - purchLine.ShippingDateRequested) > highestDelay)
                {
                    highestDelay = purchLine.ShippingDateConfirmed - purchLine.ShippingDateRequested;
                }
            }

            purchResult += [highestDelay];

            // Find production orders delays

            totalsQuery = new Query();

            highestDelay = 0;

            dataSourceProdTable = totalsQuery.addDataSource(tableNum(ProdTable));
            rangeEndDate = dataSourceProdTable.addRange(fieldNum(ProdTable, RealDate));
            rangeDlvDate = dataSourceProdTable.addRange(fieldNum(ProdTable, DlvDate));

            rangeDlvDate.value(queryRange(fromDate, toDate));
            rangeEndDate.value(SysQuery::valueNot(dateNull()));

            if (this.parmItemId())
            {
                this.addItemRange(dataSourceProdTable, fieldNum(ProdTable, ItemId));
            }
            else
            if (this.parmForecastItemAllocationId())
            {
                this.addForecastItemAllocationRange(dataSourceProdTable, fieldNum(ProdTable, ItemId));
            }

            if (this.parmInventDim())
            {
                this.addInventDimDatasource(dataSourceProdTable, fieldNum(ProdTable, InventDimId));
            }

            queryRun = new QueryRun(totalsQuery);
            while (queryRun.next())
            {
                prodTable = queryRun.get(tableNum(ProdTable));

                if (prodTable.RealDate > prodTable.DlvDate && (prodTable.RealDate - prodTable.DlvDate) > highestDelay)
                {
                    highestDelay = prodTable.RealDate - prodTable.DlvDate;
                }
            }

            prodResult += [highestDelay];
        }

        return [salesResult, purchResult, prodResult];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getHeaderType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrives the header type for one net requirement.
    /// </summary>
    /// <param name="_reqTrans">
    /// The net rerquirements to be used for calculation.
    /// </param>
    /// <param name="_currentPeriod">
    /// The number of the current period.
    /// </param>
    /// <returns>
    /// The header type for the provided net requirement.
    /// </returns>
    protected int getHeaderType(
        ReqTrans        _reqTrans,
        int             _currentPeriod)
    {
        int     headerType = 0;

        switch (_reqTrans.RefType)
        {
            case ReqRefType::InventOnHand:
                if (_currentPeriod == 1)
                {
                    // onhand only appears in first period and must be the starting inventory quantity.
                    headerType = #PeriodStartInventory;
                }
                break;

            case ReqRefType::SalesForecast:
                headerType = #DemandForecast;
                break;

            case ReqRefType::SalesQuotation:
                headerType = #DemandSalesQuotation;
                break;

            case ReqRefType::Sales:
                if (_reqTrans.Direction == InventDirection::Issue)
                {
                    headerType = #DemandSalesOrders;
                }
                else if (_reqTrans.Direction == InventDirection::Receipt)
                {
                    headerType = #SupplyReturnSalesOrders;
                }
                break;

            case ReqRefType::PlannedIntercompanyDemand:
                headerType = #DemandPlannedIntercompanyDemand;
                break;

            case ReqRefType::RequisitionLine:
                headerType = #DemandRequisitionLine;
                break;

            case ReqRefType::TransferOrderShip:
                headerType = #DemandTransferOrders;
                break;

            case ReqRefType::InventTransfer:
                if (_reqTrans.Direction == InventDirection::Issue)
                {
                    headerType = #DemandTransferJournal;
                }
                else
                if (_reqTrans.Direction == InventDirection::Receipt)
                {
                    headerType = #SupplyTransferJournal;
                }
                break;

            case ReqRefType::KanbanLine:
                if (_reqTrans.Direction == InventDirection::Issue)
                {
                    if (_reqTrans.SupplyDemandSubClassification == SupplyDemandSubClassification::WithdrawalKanban)
                    {
                        headerType = #DemandKanbanTransfer;
                    }
                    else
                    if (_reqTrans.SupplyDemandSubClassification == SupplyDemandSubClassification::ProductionKanban)
                    {
                        headerType = #DemandKanbanJobs;
                    }
                }
                else
                if (_reqTrans.Direction == InventDirection::Receipt)
                {
                    if (_reqTrans.SupplyDemandSubClassification == SupplyDemandSubClassification::ProductionKanban)
                    {
                        if (_reqTrans.IsForecastPurch)
                        {
                            headerType = #SupplyPlannedKanbanLinesForecast;
                        }
                        else
                        {
                            headerType = #SupplyPlannedKanbanLines;
                        }
                    }
                    else
                    if (_reqTrans.SupplyDemandSubClassification == SupplyDemandSubClassification::WithdrawalKanban)
                    {
                        headerType = #SupplyWithdrawalKanbanLine;
                    }
                    else
                    {
                        headerType = #SupplyKanbanLines;
                    }
                }
                break;

            case ReqRefType::PlannedKanbanLine:
                if (_reqTrans.Direction == InventDirection::Issue && _reqTrans.SupplyDemandSubClassification == SupplyDemandSubClassification::WithdrawalKanban)
                {
                    headerType = #DemandKanbanPlannedTransfer;
                }
                else
                if (_reqTrans.Direction == InventDirection::Issue && _reqTrans.SupplyDemandSubClassification == SupplyDemandSubClassification::ProductionKanban)
                {
                    headerType = #DemandPlannedKanbans;
                }
                break;

            case ReqRefType::TransferDemand:
                headerType = #DemandPlannedTransferOrders;
                break;

            case ReqRefType::TransferPlannedOrder:
                if (_reqTrans.Direction == InventDirection::Receipt)
                {
                    if (_reqTrans.IsForecastPurch)
                    {
                        headerType = #SupplyTransferPlannedOrdersForecast;
                    }
                    else
                    {
                        headerType = #SupplyTransferPlannedOrders;
                    }
                }
                break;

            case ReqRefType::ProdLine:
                if (_reqTrans.Direction == InventDirection::Issue)
                {
                    headerType = #DemandProductionOrders;
                }
                else
                if (_reqTrans.Direction == InventDirection::Receipt)
                {
                    headerType = #SupplyProductionOrderBOM;
                }
                break;

            case ReqRefType::BOMLine:
                if (_reqTrans.Direction == InventDirection::Issue)
                {
                    headerType = #DemandPlannedProductionOrders;
                }
                else
                if (_reqTrans.Direction == InventDirection::Receipt)
                {
                    headerType = #SupplyPlannedProductionOrderBOM;
                }
                break;

            case ReqRefType::PmfFormulaLine:
                if (_reqTrans.Direction == InventDirection::Issue)
                {
                    headerType = #DemandPmfPlannedBatchOrders;
                }
                else
                if (_reqTrans.Direction == InventDirection::Receipt)
                {
                    headerType = #SupplyPmfPlannedBatchOrderLine;
                }
                break;

            case ReqRefType::PmfCoProduct:
                headerType = #SupplyPmfCoProduct;
                break;

            case ReqRefType::SafetyInvent:
                headerType = #MinimumInventoryChange;
                break;

            case ReqRefType::PdsExpiredBatch:
                headerType = #DemandPdsExpiredBatch;
                break;

            case ReqRefType::Production:
                headerType = #SupplyProductionOrders;
                break;

            case ReqRefType::Kanban:
                if (_reqTrans.Direction == InventDirection::Receipt)
                {
                    if (_reqTrans.SupplyDemandSubClassification == SupplyDemandSubClassification::ProductionKanban)
                    {
                        headerType = #SupplyProductionKanban;
                    }
                    else
                    if (_reqTrans.SupplyDemandSubClassification == SupplyDemandSubClassification::WithdrawalKanban)
                    {
                        headerType = #SupplyWithdrawalKanbans;
                    }
                }
                break;

            case ReqRefType::BOMPlannedOrder:
                if (_reqTrans.IsForecastPurch)
                {
                    headerType = #SupplyPlannedProductionOrdersForecast;
                }
                else
                {
                    headerType = #SupplyPlannedProductionOrders;
                }
                break;

            case ReqRefType::PmfPlannedProdBatch:
                if (_reqTrans.IsForecastPurch)
                {
                    headerType = #SupplyPmfPlannedBatchOrdersForecast;
                }
                else
                {
                    headerType = #SupplyPmfPlannedBatchOrders;
                }
                break;

            case ReqRefType::Purch:
                if (_reqTrans.Direction == InventDirection::Issue)
                {
                    headerType = #DemandReturnPurchaseOrders;
                }
                else if (_reqTrans.Direction == InventDirection::Receipt)
                {
                    headerType = #SupplyPurchaseOrders;
                }
                break;

            case ReqRefType::ItemPlannedOrder:
                if (_reqTrans.IsForecastPurch)
                {
                    headerType = #SupplyPlannedPurchaseOrdersForecast;
                }
                else
                {
                    headerType = #SupplyPlannedPurchaseOrders;
                }
                break;

            case ReqRefType::TransferOrderReceive:
                headerType = #SupplyTransferOrders;
                break;

            case ReqRefType::PlannedKanban:
                if (_reqTrans.Direction == InventDirection::Receipt
                 && _reqTrans.SupplyDemandSubClassification == SupplyDemandSubClassification::WithdrawalKanban)
                {
                    if (_reqTrans.IsForecastPurch)
                    {
                        headerType = #SupplyTransferPlannedKanbansForecast;
                    }
                    else
                    {
                        headerType = #SupplyTransferPlannedKanbans;
                    }
                }
                else
                if (_reqTrans.Direction == InventDirection::Receipt
                 && _reqTrans.SupplyDemandSubClassification == SupplyDemandSubClassification::ProductionKanban)
                {
                    if (_reqTrans.IsForecastPurch)
                    {
                        headerType = #SupplyPlannedKanbanForecast;
                    }
                    else
                    {
                        headerType = #SupplyPlannedKanban;
                    }
                }
                break;

            case ReqRefType::InventJournal:
                if (_reqTrans.Direction == InventDirection::Receipt)
                {
                    headerType = #SupplyTransferInventoryJournals;
                }
                else
                if (_reqTrans.Direction == InventDirection::Issue)
                {
                    headerType = #DemandInventJournals;
                }
                break;

            case ReqRefType::ConsignmentReplenishmentOrder:
                if (_reqTrans.Direction == InventDirection::Receipt)
                {
                    headerType = #SupplyConsignmentReplenishmentOrder;
                }
                break;
        }

        return headerType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertPeriodValue</Name>
				<Source><![CDATA[
    private void insertPeriodValue(
        int     _rowHeaderType,
        Qty     _quantity,
        boolean _insertZeroes = false)
    {
        container periodResult = this.buildPeriodResult(_rowHeaderType, _quantity, _insertZeroes);

        if (this.shouldTypeBeVisible(_quantity))
        {
            typeVisible[_rowHeaderType] = true;
        }

        calculatedQuantities = conPoke(calculatedQuantities, _rowHeaderType,  periodResult);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPeriodResult</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the calculated quantities for the specified type.
    /// </summary>
    /// <param name = "_rowHeaderType">The header type.</param>
    /// <param name = "_quantity">The quantity of the specified type.</param>
    /// <param name = "_insertZeroes">Boolean value that determines whether to insert zeros to the result container.</param>
    /// <returns>The calculated quantities for the specified type.</returns>
    protected container buildPeriodResult(int _rowHeaderType, Qty _quantity, boolean _insertZeroes)
    {
        container   periodResult;
        int         periodResultCounter;

        // Get current results
        periodResult = conPeek(calculatedQuantities, _rowHeaderType);

        if (_insertZeroes)
        {
            for (periodResultCounter = conLen(periodResult) + 1; periodResultCounter < currentPeriod; periodResultCounter++)
            {
                periodResult = periodResult + [0];
            }
        }

        periodResult = periodResult + [_quantity];

        return periodResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldTypeBeVisible</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a type should be visible.
    /// </summary>
    /// <param name = "_quantity">The quantity of the type.</param>
    /// <returns>true if the type should be visible; otherwise, false.</returns>
    protected boolean shouldTypeBeVisible(Qty _quantity)
    {
        return _quantity != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>kanbansPreview</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the summarized information for the kanbans in a specified period.
    /// </summary>
    /// <param name="_fromdate">
    ///    The start date of the period that is calculated.
    /// </param>
    /// <param name="_toDate">
    ///    The start date of the period that is calculated.
    /// </param>
    /// <param name="_kanbanType">
    ///    The type of kanban that is calculated.
    /// </param>
    /// <returns>
    ///    A container that has the summarized information for the period.
    /// </returns>
    public container kanbansPreview(
        TransDate      _fromdate,
        TransDate      _toDate,
        LeanKanbanType _kanbanType)
    {
        QueryBuildDataSource    dataSourceKanban;
        QueryBuildDataSource    dataSourceKanbanJob;
        QueryBuildRange         rangeKanbanProductionDueDate;
        QueryBuildRange         rangeKanbanProductionExpectedDate;
        QueryBuildRange         rangeKanbanType;
        QueryBuildRange         rangeKanbanJobType;
        QueryBuildRange         rangeKanbanJobStatus;
        Query                   totalsQuery;
        QueryRun                queryRun;
        Kanban                  kanban;
        container               result;
        utcdatetime             fromDateTime    = DateTimeUtil::newDateTime(_fromdate, 0);
        utcdatetime             toDateTime      = DateTimeUtil::newDateTime(_toDate + 1, 0);

        totalsQuery = new Query();

        dataSourceKanban = totalsQuery.addDataSource(tableNum(Kanban));
        rangeKanbanProductionDueDate        = dataSourceKanban.addRange(fieldNum(Kanban, ExpectedDateTime));
        rangeKanbanProductionExpectedDate   = dataSourceKanban.addRange(fieldNum(Kanban, ExpectedDateTime));

        if (_kanbanType == LeanKanbanType::Manufacturing)
        {
            rangeKanbanProductionDueDate.value(strFmt('(((%1.%2 == %6) && (%1.%4 >= %3) && (%1.%4 < %5))))',
                dataSourceKanban.name(),                                                                                              // 1
                fieldStr(Kanban, ExpectedDateTime),                                                                                   // 2
                _fromdate != dateNull() ? DateTimeUtil::toStr(fromDateTime) : KanbanOverviewQueryBuilderCriteria::dateTimeNull2Str(), // 3
                fieldStr(Kanban, DueDateTime),                                                                                        // 4
                _toDate != dateNull() ? DateTimeUtil::toStr(toDateTime) : queryValue(DateTimeUtil::maxValue()),                       // 5
                KanbanOverviewQueryBuilderCriteria::dateTimeNull2Str()));                                                             // 6

            rangeKanbanProductionExpectedDate.value(strFmt('(((%1.%2 != %6) && (%1.%2 >= %3) && (%1.%2 < %5)))',
                dataSourceKanban.name(),                                                                                              // 1
                fieldStr(Kanban, ExpectedDateTime),                                                                                   // 2
                _fromdate != dateNull() ? DateTimeUtil::toStr(fromDateTime) : KanbanOverviewQueryBuilderCriteria::dateTimeNull2Str(), // 3
                fieldStr(Kanban, DueDateTime),                                                                                        // 4
                _toDate != dateNull() ? DateTimeUtil::toStr(toDateTime) : queryValue(DateTimeUtil::maxValue()),                       // 5
                KanbanOverviewQueryBuilderCriteria::dateTimeNull2Str()));                                                             // 6
        }
        else
        {
            rangeKanbanProductionExpectedDate.value(queryRange(_fromdate, _toDate));
        }

        rangeKanbanType = dataSourceKanban.addRange(fieldNum(Kanban, Type));
        rangeKanbanType.value(queryValue(_kanbanType));

        dataSourceKanban.addSelectionField(fieldNum(Kanban, RecId), SelectionField::Count);
        dataSourceKanban.addSelectionField(fieldNum(Kanban, QuantityOrdered), SelectionField::Sum);

        if (this.parmItemId())
        {
            this.addItemRange(dataSourceKanban, fieldNum(Kanban, ItemId));
        }
        else
        if (this.parmForecastItemAllocationId())
        {
            this.addForecastItemAllocationRange(dataSourceKanban, fieldNum(Kanban, ItemId));
        }

        if (this.parmInventDim())
        {
            this.addInventDimDatasource(dataSourceKanban, fieldNum(Kanban, InventDimId));
        }

        queryRun = new QueryRun(totalsQuery);
        queryRun.next();
        kanban = queryRun.get(tableNum(Kanban));

        result += [kanban.RecId];
        result += [kanban.QuantityOrdered];

        if (_kanbanType == LeanKanbanType::Manufacturing)
        {
            totalsQuery = new Query();

            dataSourceKanban = totalsQuery.addDataSource(tableNum(Kanban));

            dataSourceKanbanJob = dataSourceKanban.addDataSource(tableNum(KanbanJob));
            dataSourceKanbanJob.joinMode(JoinMode::InnerJoin);
            dataSourceKanbanJob.addLink(fieldNum(Kanban, RecId), fieldNum(KanbanJob, Kanban));

            rangeKanbanType = dataSourceKanban.addRange(fieldNum(Kanban, Type));
            rangeKanbanType.value(queryValue(_kanbanType));

            rangeKanbanProductionExpectedDate = dataSourceKanbanJob.addRange(fieldNum(KanbanJob, ExpectedDateTime));
            rangeKanbanProductionExpectedDate.value(queryRange(fromDateTime, toDateTime));

            rangeKanbanJobType = dataSourceKanbanJob.addRange(fieldNum(KanbanJob, Type));
            rangeKanbanJobType.value(queryValue(LeanKanbanJobType::Process));

            rangeKanbanJobStatus = dataSourceKanbanJob.addRange(fieldNum(KanbanJob, Status));
            rangeKanbanJobStatus.value(queryRange(LeanKanbanJobStatus::Planned, LeanKanbanJobStatus::InProgress));

            dataSourceKanban.addSelectionField(fieldNum(Kanban, QuantityOrdered), SelectionField::Sum);
            dataSourceKanban.addSelectionField(fieldNum(Kanban, RecId), SelectionField::Count);

            if (this.parmItemId())
            {
                this.addItemRange(dataSourceKanban, fieldNum(Kanban, ItemId));
            }
            else
            if (this.parmForecastItemAllocationId())
            {
                this.addForecastItemAllocationRange(dataSourceKanban, fieldNum(Kanban, ItemId));
            }

            if (this.parmInventDim())
            {
                this.addInventDimDatasource(dataSourceKanbanJob, fieldNum(KanbanJob, InventDimId));
            }

            queryRun = new QueryRun(totalsQuery);
            queryRun.next();

            kanban = queryRun.get(tableNum(Kanban));

            result += [kanban.RecId];
            result += [kanban.QuantityOrdered];
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmForecastItemAllocationId</Name>
				<Source><![CDATA[
    public ForecastItemAllocationId parmForecastItemAllocationId(ForecastItemAllocationId _itemAllocationKey = itemAllocationKey)
    {
        itemAllocationKey = _itemAllocationKey;

        return itemAllocationKey;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInboundTransTypes</Name>
				<Source><![CDATA[
    public Set parmInboundTransTypes(Set _inboundTransTypes = inboundTransTypes)
    {
        inboundTransTypes = _inboundTransTypes;

        return inboundTransTypes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDim</Name>
				<Source><![CDATA[
    public InventDim parmInventDim(InventDim _inventDim = inventDim)
    {
        inventDim = _inventDim;

        return inventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDimParm</Name>
				<Source><![CDATA[
    public InventDimParm parmInventDimParm(InventDimParm _inventDimParm = inventDimParm)
    {
        inventDimParm = _inventDimParm;

        return inventDimParm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItemId</Name>
				<Source><![CDATA[
    public ItemId parmItemId(ItemId _itemId = itemId)
    {
        itemId = _itemId;

        return itemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMovementStatus</Name>
				<Source><![CDATA[
    public WMSReqTransMovementStatus parmMovementStatus(WMSReqTransMovementStatus _movementStatus = movementStatus)
    {
        movementStatus = _movementStatus;

        return movementStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNumberOfSupplyDemandTypes</Name>
				<Source><![CDATA[
    public int parmNumberOfSupplyDemandTypes(int _numberOfsupplyDemandTypes = numberOfsupplyDemandTypes)
    {
        numberOfsupplyDemandTypes = _numberOfsupplyDemandTypes;

        return numberOfsupplyDemandTypes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOutboundTransTypes</Name>
				<Source><![CDATA[
    public Set parmOutboundTransTypes(Set _outboundTransTypes = outboundTransTypes)
    {
        outboundTransTypes = _outboundTransTypes;

        return outboundTransTypes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPeriodTemplate</Name>
				<Source><![CDATA[
    public RefRecId parmPeriodTemplate(RefRecId _periodTemplate = periodTemplate)
    {
        periodTemplate = _periodTemplate;

        return periodTemplate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProcessOnlyBacklogPeriod</Name>
				<Source><![CDATA[
    public boolean parmProcessOnlyBacklogPeriod(boolean _processOnlyBacklogPeriod = processOnlyBacklogPeriod)
    {
        processOnlyBacklogPeriod = _processOnlyBacklogPeriod;

        return processOnlyBacklogPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProcessOnlyOutlookPeriod</Name>
				<Source><![CDATA[
    public boolean parmProcessOnlyOutlookPeriod(boolean _processOnlyOutlookPeriod = processOnlyOutlookPeriod)
    {
        processOnlyOutlookPeriod = _processOnlyOutlookPeriod;

        return processOnlyOutlookPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQuery</Name>
				<Source><![CDATA[
    public Query parmQuery(Query _query = query)
    {
        query = _query;

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQueryData</Name>
				<Source><![CDATA[
    public boolean parmQueryData(boolean _queryData = queryData)
    {
        queryData = _queryData;

        return queryData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReqPlanId</Name>
				<Source><![CDATA[
    public ReqPlanId parmReqPlanId(ReqPlanId _reqPlanId = reqPlanId)
    {
        reqPlanId = _reqPlanId;

        return reqPlanId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipBacklogPeriod</Name>
				<Source><![CDATA[
    public boolean parmSkipBacklogPeriod(boolean _skipBacklogPeriod = skipBacklogPeriod)
    {
        skipBacklogPeriod = _skipBacklogPeriod;

        return skipBacklogPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipOutlookPeriod</Name>
				<Source><![CDATA[
    public boolean parmSkipOutlookPeriod(boolean _skipOutlookPeriod = skipOutlookPeriod)
    {
        skipOutlookPeriod = _skipOutlookPeriod;

        return skipOutlookPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipPeriodDescriptions</Name>
				<Source><![CDATA[
    public boolean parmSkipPeriodDescriptions(boolean _skipPeriodDescriptions = skipPeriodDescriptions)
    {
        skipPeriodDescriptions = _skipPeriodDescriptions;

        return skipPeriodDescriptions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTodayDate</Name>
				<Source><![CDATA[
    public TransDate parmTodayDate(TransDate _todayDate = todayDate)
    {
        todayDate = _todayDate;

        return todayDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCurrentSelectionRow</Name>
				<Source><![CDATA[
    internal int parmCurrentSelectionRow(int _currentSelectionRow = currentSelectionRow)
    {
        currentSelectionRow = _currentSelectionRow;

        return currentSelectionRow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSiteOrWarehouseFilterSet</Name>
				<Source><![CDATA[
    internal boolean isSiteOrWarehouseFilterSet()
    {
        return this.parmInventDim().InventSiteId || this.parmInventDim().InventLocationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>plannedOrdersPreview</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the summarized information for the planned orders in a specified period.
    /// </summary>
    /// <param name="_fromdate">
    ///    The start date of the period that is calculated.
    /// </param>
    /// <param name="_toDate">
    ///    The start date of the period that is calculated.
    /// </param>
    /// <param name="_reqRefType">
    ///    The type of planned orders that are calculated.
    /// </param>
    /// <param name="_subtype">
    ///    The subtype of planned orders that are calculated.
    /// </param>
    /// <returns>
    ///    A container that has the summarized information for the period.
    /// </returns>
    public container plannedOrdersPreview(
        TransDate                     _fromdate,
        TransDate                     _toDate,
        ReqRefType                    _reqRefType,
        SupplyDemandSubClassification _subtype)
    {
        #ReqSupplyDemandScheduleTypes
        
        boolean reqSupplyDemandScheduleDemandPlannedTransferOrdersToggle = ReqSupplyDemandScheduleDemandPlannedTransferOrdersToggle::instance().isEnabled();
        Query totalsQuery = new Query();
        QueryBuildDataSource dataSourceReqPO = totalsQuery.addDataSource(tableNum(ReqPO));

        RecId recIdActiveVersion = ReqPlanVersion::findActiveReqPlanId(reqPlanId, curExt()).RecId;

        QueryBuildDataSource dataSourceReqTrans = dataSourceReqPO.addDataSource(tableNum(ReqTrans));
        dataSourceReqTrans.joinMode(JoinMode::InnerJoin);
        dataSourceReqTrans.addLink(fieldNum(ReqPO, RefId), fieldNum(ReqTrans, RefId));
        dataSourceReqTrans.addLink(fieldNum(ReqPO, RefType), fieldNum(ReqTrans, RefType));
        dataSourceReqTrans.addLink(fieldNum(ReqPO, PlanVersion), fieldNum(ReqTrans, PlanVersion));

        if (_reqRefType == ReqRefType::TransferPlannedOrder && 
            (!reqSupplyDemandScheduleDemandPlannedTransferOrdersToggle || currentSelectionRow == #DemandPlannedTransferOrders))
        {
            dataSourceReqTrans.addRange(fieldNum(ReqTrans, Direction)).value(queryValue(InventDirection::Receipt));

            if (this.isSiteOrWarehouseFilterSet())
            {
                QueryBuildDataSource qbdsTransferDemand = ReqSupplyDemandScheduleModel::addTransferDemandReqTransDatasource(dataSourceReqTrans, dataSourceReqPO);
                qbdsTransferDemand.addRange(fieldNum(ReqTrans, PlanVersion)).value(queryValue(recIdActiveVersion));
                this.addInventDimDatasource(qbdsTransferDemand, fieldNum(ReqTrans, CovInventDimId));
            }
        }
        else
        {
            this.addInventDimDatasource(dataSourceReqTrans, fieldNum(ReqTrans, CovInventDimId));
        }

        QueryBuildRange rangeDate;
        
        if (currentSelectionRow == #DemandPlannedTransferOrders && reqSupplyDemandScheduleDemandPlannedTransferOrdersToggle)
        {
            rangeDate = dataSourceReqPO.addRange(fieldNum(ReqPO, ReqDateOrder));
        }
        else
        {
            rangeDate = dataSourceReqPO.addRange(fieldNum(ReqPO, ReqDate));
        }

        rangeDate.value(queryRange(_fromdate, _toDate));

        QueryBuildRange rangeReqPOPlanVersion = dataSourceReqPO.addRange(fieldNum(ReqPO, PlanVersion));
        rangeReqPOPlanVersion.value(queryValue(recIdActiveVersion));

        QueryBuildRange rangeReqPOType = dataSourceReqPO.addRange(fieldNum(ReqPO, RefType));
        rangeReqPOType.value(queryValue(_reqRefType));

        QueryBuildRange rangeReqTransSubClassification = dataSourceReqTrans.addRange(fieldNum(ReqTrans, SupplyDemandSubClassification));
        rangeReqTransSubClassification.value(queryValue(_subtype));

        dataSourceReqPO.addSelectionField(fieldNum(ReqPO, RecId), SelectionField::Count);
        dataSourceReqPO.addSelectionField(fieldNum(ReqPO, Qty), SelectionField::Sum);

        if (this.parmItemId())
        {
            this.addItemRange(dataSourceReqPO, fieldNum(ReqPO, ItemId));
        }
        else
        if (this.parmForecastItemAllocationId())
        {
            this.addForecastItemAllocationRange(dataSourceReqPO, fieldNum(ReqPO, ItemId));
        }

        QueryRun queryRun = new QueryRun(totalsQuery);
        queryRun.next();

        ReqPO reqPO = queryRun.get(tableNum(ReqPO));
        return [reqPO.RecId, reqPO.Qty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTransferDemandReqTransDatasource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create datasource for transfer demand requirement transaction.
    /// </summary>
    /// <param name="_dataSource">
    /// Query build datasource is used to create transfer demand reqTrans datasource.
    /// </param>
    /// <param name="_reqPODatasource">
    /// Parent reqPO datasource.
    /// </param>
    /// <returns>
    /// Generated datasource for transfer demand reqTrans.
    /// </returns>
    internal static QueryBuildDataSource addTransferDemandReqTransDatasource(QueryBuildDataSource _dataSource, QueryBuildDataSource _reqPODatasource)
    {
        QueryBuildDataSource qbdsTransferDemand = _dataSource.addDataSource(tableNum(ReqTrans));
        qbdsTransferDemand.joinMode(JoinMode::ExistsJoin);
        qbdsTransferDemand.addRange(fieldNum(ReqTrans, RefType)).value(queryValue(ReqRefType::TransferDemand));
        qbdsTransferDemand.addLink(fieldNum(ReqPO, RefId), fieldNum(ReqTrans, RefId), _reqPODatasource.name());
    
        return qbdsTransferDemand;
    }

]]></Source>
			</Method>
			<Method>
				<Name>previousPeriodValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the value of the previous period.
    /// </summary>
    /// <param name="_rowHeaderType">
    /// An integer value that represents the row type.
    /// </param>
    /// <returns>
    /// A real that represents the value of the previous period.
    /// </returns>
    protected ReqQty previousPeriodValue(int     _rowHeaderType)
    {
        anytype     value;
        container   rowResult;

        if (   currentPeriod > 1
            && conLen(calculatedQuantities) >= _rowHeaderType)
        {
            rowResult = conPeek(calculatedQuantities, _rowHeaderType);
            if (conLen(rowResult) >= currentPeriod-1)
            {
                value = conPeek(rowResult,currentPeriod-1);
            }
        }

        return any2real(value);
    }

]]></Source>
			</Method>
			<Method>
				<Name>productionOrdersPreview</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the summarized information for the production orders in a specified period.
    /// </summary>
    /// <param name="_fromdate">
    ///    The start date of the period that is calculated.
    /// </param>
    /// <param name="_toDate">
    ///    The start date of the period that is calculated.
    /// </param>
    /// <returns>
    ///    A container that has the summarized information for the period.
    /// </returns>
    public container productionOrdersPreview(
        TransDate _fromdate,
        TransDate _toDate)
    {
        QueryBuildDataSource    dataSourceProdTable;
        QueryBuildRange         rangeSchedEnd;
        QueryBuildRange         rangeDlvDate;
        QueryBuildRange         rangeProdStatus;

        Query                   totalsQuery;
        QueryRun                queryRun;
        ProdTable               prodTable;
        container               result;

        // **********************************
        // ***Production orders scheduled ***
        // **********************************

        totalsQuery = new Query();

        dataSourceProdTable = totalsQuery.addDataSource(tableNum(ProdTable));
        rangeSchedEnd  = dataSourceProdTable.addRange(fieldNum(ProdTable, SchedEnd));
        rangeProdStatus = dataSourceProdTable.addRange(fieldNum(ProdTable, ProdStatus));

        rangeSchedEnd.value(queryRange(_fromdate, _toDate));
        rangeProdStatus.value(queryRange(ProdStatus::Scheduled, ProdStatus::StartedUp));

        dataSourceProdTable.addSelectionField(fieldNum(ProdTable, RecId), SelectionField::Count);
        dataSourceProdTable.addSelectionField(fieldNum(ProdTable, QtySched), SelectionField::Sum);

        if (this.parmItemId())
        {
            this.addItemRange(dataSourceProdTable, fieldNum(ProdTable, ItemId));
        }
        else
        if (this.parmForecastItemAllocationId())
        {
            this.addForecastItemAllocationRange(dataSourceProdTable, fieldNum(ProdTable, ItemId));
        }

        if (this.parmInventDim())
        {
            this.addInventDimDatasource(dataSourceProdTable, fieldNum(ProdTable, InventDimId));
        }

        queryRun = new QueryRun(totalsQuery);
        queryRun.next();
        prodTable = queryRun.get(tableNum(ProdTable));

        result += [prodTable.RecId];
        result += [prodTable.QtySched];

        // **********************************
        // ***Production orders requested ***
        // **********************************

        totalsQuery = new Query();

        dataSourceProdTable = totalsQuery.addDataSource(tableNum(ProdTable));
        rangeDlvDate  = dataSourceProdTable.addRange(fieldNum(ProdTable, DlvDate));
        rangeProdStatus = dataSourceProdTable.addRange(fieldNum(ProdTable, ProdStatus));

        rangeDlvDate.value(queryRange(_fromdate, _toDate));
        rangeProdStatus.value(SysQuery::valueNot(ProdStatus::Completed));

        dataSourceProdTable.addSelectionField(fieldNum(ProdTable, RecId), SelectionField::Count);
        dataSourceProdTable.addSelectionField(fieldNum(ProdTable, QtySched), SelectionField::Sum);

        if (this.parmItemId())
        {
            this.addItemRange(dataSourceProdTable, fieldNum(ProdTable, ItemId));
        }
        else
        if (this.parmForecastItemAllocationId())
        {
            this.addForecastItemAllocationRange(dataSourceProdTable, fieldNum(ProdTable, ItemId));
        }

        if (this.parmInventDim())
        {
            this.addInventDimDatasource(dataSourceProdTable, fieldNum(ProdTable, InventDimId));
        }

        queryRun = new QueryRun(totalsQuery);
        queryRun.next();
        prodTable = queryRun.get(tableNum(ProdTable));

        result += [prodTable.RecId];
        result += [prodTable.QtySched];

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchaseOrdersPreview</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the summarized information for the purchase orders in a specified period.
    /// </summary>
    /// <param name="_fromdate">
    ///    The start date of the period that is calculated.
    /// </param>
    /// <param name="_toDate">
    ///    The start date of the period that is calculated.
    /// </param>
    /// <returns>
    ///    A container that has the summarized information for the period.
    /// </returns>
    public container purchaseOrdersPreview(
        TransDate _fromdate,
        TransDate _toDate)
    {
        QueryBuildDataSource    dataSourcePurchLine;
        QueryBuildRange         rangeShippingDeliveryDate;
        QueryBuildRange         rangeShippingDateConfirmed;
        Query                   totalsQuery;
        QueryRun                queryRun;
        PurchLine               purchLine;
        container               result;
        int                     dayOffset;

        totalsQuery = new Query();

        dataSourcePurchLine = totalsQuery.addDataSource(tableNum(PurchLine));
        rangeShippingDeliveryDate  = dataSourcePurchLine.addRange(fieldNum(PurchLine, DeliveryDate));

        dataSourcePurchLine.addRange(fieldNum(PurchLine, PurchStatus)).value(queryValue(PurchStatus::Backorder));

        if (_fromdate == dateNull())
        {
            dayOffset = 1;
        }
        rangeShippingDeliveryDate.value(strFmt('( ((%1.%2 >= %3) && (%1.%2 <= %4)) || ( ((%1.%6 >= %3) && (%1.%6 <= %4)) && (%1.%2 == %5)) )',
            rangeShippingDeliveryDate.dataSource().name(),
            fieldStr(PurchLine, ConfirmedDlv),
            date2StrXpp(_fromdate + dayOffset),
            date2StrXpp(_toDate),
            date2StrXpp(dateNull()),
            fieldStr(PurchLine, DeliveryDate)
            ));

        dataSourcePurchLine.addSelectionField(fieldNum(PurchLine, RecId), SelectionField::Count);
        dataSourcePurchLine.addSelectionField(fieldNum(PurchLine, RemainPurchPhysical), SelectionField::Sum);
        dataSourcePurchLine.addSelectionField(fieldNum(PurchLine, LineAmount), SelectionField::Sum);

        if (this.parmItemId())
        {
            this.addItemRange(dataSourcePurchLine, fieldNum(PurchLine, ItemId));
        }
        else
        if (this.parmForecastItemAllocationId())
        {
            this.addForecastItemAllocationRange(dataSourcePurchLine, fieldNum(PurchLine, ItemId));
        }

        if (this.parmInventDim())
        {
            this.addInventDimDatasource(dataSourcePurchLine, fieldNum(PurchLine, InventDimId));
        }

        queryRun = new QueryRun(totalsQuery);
        queryRun.next();

        purchLine = queryRun.get(tableNum(PurchLine));

        result += [purchLine.RecId];
        result += [purchLine.RemainPurchPhysical];
        result += [purchLine.LineAmount];

        totalsQuery = new Query();

        dataSourcePurchLine = totalsQuery.addDataSource(tableNum(PurchLine));
        rangeShippingDateConfirmed  = dataSourcePurchLine.addRange(fieldNum(PurchLine, ConfirmedDlv));

        rangeShippingDateConfirmed.value(queryRange(_fromdate, _toDate));

        dataSourcePurchLine.addRange(fieldNum(PurchLine, PurchStatus)).value(queryValue(PurchStatus::Backorder));

        dataSourcePurchLine.addSelectionField(fieldNum(PurchLine, RecId), SelectionField::Count);
        dataSourcePurchLine.addSelectionField(fieldNum(PurchLine, RemainPurchPhysical), SelectionField::Sum);

        if (this.parmItemId())
        {
            this.addItemRange(dataSourcePurchLine, fieldNum(PurchLine, ItemId));
        }
        else
        if (this.parmForecastItemAllocationId())
        {
            this.addForecastItemAllocationRange(dataSourcePurchLine, fieldNum(PurchLine, ItemId));
        }

        if (this.parmInventDim())
        {
            this.addInventDimDatasource(dataSourcePurchLine, fieldNum(PurchLine, InventDimId));
        }

        queryRun = new QueryRun(totalsQuery);
        queryRun.next();

        purchLine = queryRun.get(tableNum(PurchLine));

        result += [purchLine.RecId];
        result += [purchLine.RemainPurchPhysical];

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesOrdersPreview</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the summarized information for the sales orders in a specified period.
    /// </summary>
    /// <param name="_fromdate">
    ///    The start date of the period that is calculated.
    /// </param>
    /// <param name="_toDate">
    ///    The start date of the period that is calculated.
    /// </param>
    /// <returns>
    ///    A container the has the summarized information for the period.
    /// </returns>
    public container salesOrdersPreview(
        TransDate _fromdate,
        TransDate _toDate)
    {
        Query                   totalsQuery;
        QueryRun                queryRun;
        SalesLine               salesLine;
        container               result;
        Qty                     qtyNotOnTime;
        Qty                     totalRequestedQuantity;

        // Find total requested lines and quantity

        totalsQuery = this.buildSalesQuery(_fromdate, _toDate, true, false, false);

        queryRun = new QueryRun(totalsQuery);
        queryRun.next();
        salesLine = queryRun.get(tableNum(SalesLine));

        totalRequestedQuantity = salesLine.RemainSalesPhysical;

        result += [salesLine.RecId];
        result += [totalRequestedQuantity];

        // Find total confirmed lines and quantity

        totalsQuery = this.buildSalesQuery(_fromdate, _toDate, true, false, false);

        queryRun = new QueryRun(totalsQuery);
        queryRun.next();
        salesLine = queryRun.get(tableNum(SalesLine));

        result += [salesLine.RecId];
        result += [salesLine.RemainSalesPhysical];

        // Find percentage of order lines on time

        totalsQuery = this.buildSalesQuery(_fromdate, _toDate, true, true, false);

        queryRun = new QueryRun(totalsQuery);
        while (queryRun.next())
        {
            salesLine = queryRun.get(tableNum(SalesLine));

            if (salesLine.ShippingDateConfirmed > salesLine.ShippingDateRequested)
            {
                qtyNotOnTime += salesLine.RemainSalesPhysical;
            }
        }

        if (totalRequestedQuantity > 0)
        {
            result += [((totalRequestedQuantity - qtyNotOnTime) / totalRequestedQuantity) * 100];
        }
        else
        {
            result += [0];
        }

        // Find total line amount

        totalsQuery = this.buildSalesQuery(_fromdate, _toDate, true, false, true);

        queryRun = new QueryRun(totalsQuery);
        queryRun.next();

        salesLine = queryRun.get(tableNum(SalesLine));

        result += [salesLine.LineAmount];

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRowsAlwaysVisible</Name>
				<Source><![CDATA[
    private void setRowsAlwaysVisible()
    {
        typeVisible[#PeriodStartInventory] = true;
        typeVisible[#SupplyDemandDelta] = true;
        typeVisible[#PeriodEndInventory] = true;
        typeVisible[#PeriodEndPeggedInventory] = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferOrdersPreview</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calcuates summarized information for transfer orders within a specified period
    /// </summary>
    /// <param name="_fromdate">
    /// The start date of the period that should be calculated
    /// </param>
    /// <param name="_toDate">
    /// The start date of the period that should be calculated
    /// </param>
    /// <param name="_inventDirection">
    /// Invent direction (issue, receipt) of the transfer order line to be summarized
    /// </param>
    /// <returns>
    /// A container containing the summarized information for the period
    /// </returns>
    public container transferOrdersPreview(
        TransDate       _fromdate,
        TransDate       _toDate,
        InventDirection _inventDirection = InventDirection::Issue)
    {
        QueryBuildDataSource    dataSourceInventTransferTable;
        QueryBuildDataSource    dataSourceInventTransferLine;
        QueryBuildRange         rangeShipDate ;
        QueryBuildRange         rangeReceiveDate ;
        QueryBuildRange         rangeInventTransferLineStatus;
        Query                   totalsQuery;
        QueryRun                queryRun;
        InventTransferLine      inventTransferLine;
        container               result;

        totalsQuery = new Query();

        dataSourceInventTransferTable = totalsQuery.addDataSource(tableNum(InventTransferTable));

        dataSourceInventTransferLine = dataSourceInventTransferTable.addDataSource(tableNum(InventTransferLine));
        dataSourceInventTransferLine.joinMode(JoinMode::InnerJoin);
        dataSourceInventTransferLine.addLink(fieldNum(InventTransferTable, TransferId), fieldNum(InventTransferLine, TransferId));

        if (_inventDirection == InventDirection::Issue)
        {
            rangeShipDate = dataSourceInventTransferLine.addRange(fieldNum(InventTransferLine, ShipDate));
            rangeShipDate.value(queryRange(_fromdate, _toDate));
        }
        else
        if (_inventDirection == InventDirection::Receipt)
        {
            rangeReceiveDate = dataSourceInventTransferLine.addRange(fieldNum(InventTransferLine, ReceiveDate));
            rangeReceiveDate.value(queryRange(_fromdate, _toDate));
        }

        rangeInventTransferLineStatus = dataSourceInventTransferTable.addRange(fieldNum(InventTransferTable, TransferStatus));
        rangeInventTransferLineStatus.value(queryValue(InventTransferStatus::Created));

        dataSourceInventTransferLine.addSelectionField(fieldNum(InventTransferLine, RecId), SelectionField::Count);
        if (_inventDirection == InventDirection::Issue)
        {
            dataSourceInventTransferLine.addSelectionField(fieldNum(InventTransferLine, QtyRemainShip), SelectionField::Sum);
        }
        else
        if (_inventDirection == InventDirection::Receipt)
        {
            dataSourceInventTransferLine.addSelectionField(fieldNum(InventTransferLine, QtyRemainReceive), SelectionField::Sum);
        }

        if (this.parmItemId())
        {
            this.addItemRange(dataSourceInventTransferLine, fieldNum(InventTransferLine, ItemId));
        }
        else
        if (this.parmForecastItemAllocationId())
        {
            this.addForecastItemAllocationRange(dataSourceInventTransferLine, fieldNum(InventTransferLine, ItemId));
        }

        if (this.parmInventDim())
        {
            this.addInventDimDatasource(dataSourceInventTransferLine, fieldNum(InventTransferLine, InventDimId));
        }

        queryRun = new QueryRun(totalsQuery);
        queryRun.next();
        inventTransferLine = queryRun.get(tableNum(InventTransferLine));

        result += [inventTransferLine.RecId];
        if (_inventDirection == InventDirection::Issue)
        {
            result += [inventTransferLine.QtyRemainShip];
        }
        else
        if (_inventDirection == InventDirection::Receipt)
        {
            result += [inventTransferLine.QtyRemainReceive];
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>typeVisible</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the current shown or hidden states of the rows in the row structure.
    /// </summary>
    /// <returns>
    ///    A container that has the shown or hidden states of the rows.
    /// </returns>
    public container typeVisible()
    {
        int         typeCounter;
        container   typesVisible;

        for (typeCounter = 1; typeCounter <= numberOfSupplyDemandTypes; typeCounter++)
        {
            typesVisible = typesVisible + [typeVisible[typeCounter]];
        }

        return typesVisible;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static ReqSupplyDemandScheduleModel construct()
    {
        return new ReqSupplyDemandScheduleModel();
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPlannedOrderType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the planned order type that corresponds to a supply demand type.
    /// </summary>
    /// <param name="_type">
    ///    The supply demand overview type.
    /// </param>
    /// <returns>
    ///    A planned order type that corresponds to the supply demand type.
    /// </returns>
    public static ReqPOType findPlannedOrderType(int _type)
    {
        ReqPOType plannedOrderType;

        switch (_type)
        {
            case #SupplyPlannedProductionOrdersTotal:
            case #SupplyPlannedProductionOrdersForecast:
            case #SupplyPlannedProductionOrders:
            case #SupplyPlannedProductionOrderBOM:
            case #SupplyPmfPlannedBatchOrdersTotal:
            case #SupplyPmfPlannedBatchOrdersForecast:
            case #SupplyPmfPlannedBatchOrders:
            case #SupplyPmfPlannedBatchOrderLine:
                plannedOrderType = ReqPOType::Production;
                break;

            case #SupplyPlannedKanbanTotal:
            case #SupplyPlannedKanbanForecast:
            case #SupplyPlannedKanban:
            case #SupplyPlannedKanbanLinesTotal:
            case #SupplyPlannedKanbanLinesForecast:
            case #SupplyPlannedKanbanLines:
            case #SupplyTransferPlannedKanbansTotal:
            case #SupplyTransferPlannedKanbansForecast:
            case #SupplyTransferPlannedKanbans:
                plannedOrderType = ReqPOType::Kanban;
                break;

            case #SupplyPlannedPurchaseOrdersTotal:
            case #SupplyPlannedPurchaseOrders:
            case #SupplyPlannedPurchaseOrdersForecast:
                plannedOrderType = ReqPOType::Purch;
                break;

            case #SupplyTransferPlannedOrdersTotal:
            case #SupplyTransferPlannedOrdersForecast:
            case #SupplyTransferPlannedOrders:
                plannedOrderType = ReqPOType::Transfer;
                break;
        }

        return plannedOrderType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findReqRefType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Find the requirement reference type that corresponds to the supply demand type.
    /// </summary>
    /// <param name="_type">
    ///    The supply demand overview type.
    /// </param>
    /// <returns>
    ///    A requirement reference type that corresponds to the supply demand type.
    /// </returns>
    public static ReqRefType findReqRefType(int _type)
    {
        ReqRefType  reqRefType;

        switch (_type)
        {
            case #DemandRequisitionLine:
                reqRefType = ReqRefType::RequisitionLine;
                break;

            case #DemandSalesOrders:
                reqRefType = ReqRefType::Sales;
                break;

            case #DemandForecast:
                reqRefType = ReqRefType::SalesForecast;
                break;

            case #DemandSalesQuotation:
                reqRefType = ReqRefType::SalesQuotation;
                break;

            case #DemandTransferOrders:
                reqRefType = ReqRefType::TransferOrderShip;
                break;

            case #DemandTransferJournal:
            case #SupplyTransferJournal:
                reqRefType = ReqRefType::InventTransfer;
                break;

            case #DemandKanbanPlannedTransfer:
                reqRefType = ReqRefType::PlannedKanbanLine;
                break;

            case #DemandPlannedTransferOrders:
                reqRefType = ReqRefType::TransferPlannedOrder;
                break;

            case #DemandInventJournals:
                reqRefType = ReqRefType::InventJournal;
                break;

            case #DemandProductionOrders:
                reqRefType = ReqRefType::ProdLine;
                break;

            case #DemandPlannedKanbans:
                reqRefType = ReqRefType::PlannedKanbanLine;
                break;

            case #DemandPlannedProductionOrders:
                reqRefType = ReqRefType::BOMLine;
                break;

            case #DemandPmfPlannedBatchOrders:
                reqRefType = ReqRefType::PmfFormulaLine;
                break;

            case #MinimumInventory:
            case #MinimumInventoryChange:
                reqRefType = ReqRefType::SafetyInvent;
                break;

            case #DemandPdsExpiredBatch:
                reqRefType = ReqRefType::PdsExpiredBatch;
                break;

            case #SupplyProductionOrders:
                reqRefType = ReqRefType::Production;
                break;

            case #SupplyProductionKanban:
                reqRefType = ReqRefType::Kanban;
                break;

            case #SupplyPlannedProductionOrdersForecast:
            case #SupplyPlannedProductionOrders:
            case #SupplyPlannedProductionOrdersTotal:
                reqRefType = ReqRefType::BOMPlannedOrder;
                break;

            case #SupplyPmfPlannedBatchOrdersForecast:
            case #SupplyPmfPlannedBatchOrders:
            case #SupplyPmfPlannedBatchOrdersTotal:
                reqRefType = ReqRefType::PmfPlannedProdBatch;
                break;

            case #SupplyPmfCoProduct:
                reqRefType = ReqRefType::PmfCoProduct;
                break;

            case #SupplyProductionOrderBOM:
                reqRefType = ReqRefType::ProdLine;
                break;

            case #SupplyPlannedKanbanForecast:
            case #SupplyPlannedKanban:
                reqRefType = ReqRefType::PlannedKanban;
                break;

            case #SupplyPlannedProductionOrderBOM:
                reqRefType = ReqRefType::BOMLine;
                break;

            case #SupplyPmfPlannedBatchOrderLine:
                reqRefType = ReqRefType::PmfFormulaLine;
                break;

            case #SupplyPlannedKanbanLinesForecast:
            case #SupplyPlannedKanbanLines:
            case #SupplyKanbanLines:
            case #SupplyWithdrawalKanbanLine:
            case #DemandKanbanJobs:
            case #DemandKanbanTransfer:
                reqRefType = ReqRefType::KanbanLine;
                break;

            case #SupplyPurchaseOrders:
                reqRefType = ReqRefType::Purch;
                break;

            case #SupplyPlannedPurchaseOrdersTotal:
            case #SupplyPlannedPurchaseOrders:
            case #SupplyPlannedPurchaseOrdersForecast:
                reqRefType = ReqRefType::ItemPlannedOrder;
                break;

            case #SupplyTransferOrders:
                reqRefType = ReqRefType::TransferOrderReceive;
                break;

            case #SupplyWithdrawalKanbans:
                reqRefType = ReqRefType::Kanban;
                break;

            case #SupplyTransferPlannedOrdersForecast:
            case #SupplyTransferPlannedOrders:
                reqRefType = ReqRefType::TransferPlannedOrder;
                break;

            case #SupplyTransferPlannedKanbansForecast:
            case #SupplyTransferPlannedKanbans:
                reqRefType = ReqRefType::PlannedKanban;
                break;

            case #SupplyTransferInventoryJournals:
                reqRefType = ReqRefType::InventJournal;
                break;

            case #SupplyConsignmentReplenishmentOrder:
                reqRefType = ReqRefType::ConsignmentReplenishmentOrder;
                break;

            default:
                reqRefType = ReqRefType::None;
                break;
        }

        return reqRefType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newStandard</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an object of the <c>ReqSupplyDemandScheduleModel</c> class.
    /// </summary>
    /// <param name="_workPeriodTemplateRecId">
    ///    The record ID of a <c>WorkPeriodTemplate</c> record.
    /// </param>
    /// <param name="_todayDate">
    ///    A date that contains the current date.
    /// </param>
    /// <returns>
    ///    A <c>ReqSupplyDemandScheduleModel</c> object.
    /// </returns>
    public static ReqSupplyDemandScheduleModel newStandard(
        WorkPeriodTemplateRecId  _workPeriodTemplateRecId,
        TransDate                _todayDate)
    {
        ReqSupplyDemandScheduleModel      reqSupplyDemandScheduleModel;

        reqSupplyDemandScheduleModel = ReqSupplyDemandScheduleModel::construct();

        reqSupplyDemandScheduleModel.parmTodayDate(_todayDate);
        reqSupplyDemandScheduleModel.parmPeriodTemplate(_workPeriodTemplateRecId);

        return reqSupplyDemandScheduleModel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSupplyDemandRanges</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets query ranges for the planned order type, inventory direction, sub-classification, and the
    ///    forecast flag.
    /// </summary>
    /// <param name="_type">
    ///    The supply demand overview type.
    /// </param>
    /// <param name="_reqRefType">
    ///    The query range for the planned order type.
    /// </param>
    /// <param name="_inventDirection">
    ///    The query range for the invent direction.
    /// </param>
    /// <param name="_subClassification">
    ///    The query range for the subclassification.
    /// </param>
    /// <param name="_isForecast">
    ///    The query range for the forecast flag.
    /// </param>
    public static void setSupplyDemandRanges(
        int             _type,
        QueryBuildRange _reqRefType,
        QueryBuildRange _inventDirection,
        QueryBuildRange _subClassification,
        QueryBuildRange _isForecast)
    {
        switch (_type)
        {
            case #DemandSalesOrders:
                _reqRefType.value(queryValue(ReqRefType::Sales));
                _inventDirection.value(queryValue(InventDirection::Issue));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #DemandForecast:
                _reqRefType.value(queryValue(ReqRefType::SalesForecast));
                _inventDirection.value(queryValue(InventDirection::Issue));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #DemandSalesQuotation:
                _reqRefType.value(queryValue(ReqRefType::SalesQuotation));
                _inventDirection.value(queryValue(InventDirection::Issue));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #DemandTransferOrders:
                _reqRefType.value(queryValue(ReqRefType::TransferOrderShip));
                _inventDirection.value(queryValue(InventDirection::Issue));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #DemandTransferJournal:
                _reqRefType.value(queryValue(ReqRefType::InventTransfer));
                _inventDirection.value(queryValue(InventDirection::Issue));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #SupplyTransferJournal:
                _reqRefType.value(queryValue(ReqRefType::InventTransfer));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #DemandKanbanTransfer:
                _reqRefType.value(queryValue(ReqRefType::KanbanLine));
                _inventDirection.value(queryValue(InventDirection::Issue));
                _subClassification.value(queryValue(SupplyDemandSubClassification::WithdrawalKanban));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #DemandKanbanPlannedTransfer:
                _reqRefType.value(queryValue(ReqRefType::PlannedKanbanLine));
                _inventDirection.value(queryValue(InventDirection::Issue));
                _subClassification.value(queryValue(SupplyDemandSubClassification::WithdrawalKanban));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #DemandPlannedTransferOrders:
                _reqRefType.value(queryValue(ReqRefType::TransferPlannedOrder));
                _inventDirection.value(queryValue(InventDirection::Issue));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #DemandInventJournals:
                _reqRefType.value(queryValue(ReqRefType::InventJournal));
                _inventDirection.value(queryValue(InventDirection::Issue));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #DemandProductionOrders:
                _reqRefType.value(queryValue(ReqRefType::ProdLine));
                _inventDirection.value(queryValue(InventDirection::Issue));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #DemandKanbanJobs:
                _reqRefType.value(queryValue(ReqRefType::KanbanLine));
                _inventDirection.value(queryValue(InventDirection::Issue));
                _subClassification.value(queryValue(SupplyDemandSubClassification::ProductionKanban));
                break;

            case #DemandPlannedKanbans:
                _reqRefType.value(queryValue(ReqRefType::PlannedKanbanLine));
                _inventDirection.value(queryValue(InventDirection::Issue));
                _subClassification.value(queryValue(SupplyDemandSubClassification::ProductionKanban));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #DemandPlannedProductionOrders:
                _reqRefType.value(queryValue(ReqRefType::BOMLine));
                _inventDirection.value(queryValue(InventDirection::Issue));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                break;

            case #DemandPmfPlannedBatchOrders:
                _reqRefType.value(queryValue(ReqRefType::PmfFormulaLine));
                _inventDirection.value(queryValue(InventDirection::Issue));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                break;

            case #MinimumInventory:
                _reqRefType.value(queryValue(ReqRefType::SafetyInvent));
                _inventDirection.value(queryValue(InventDirection::None));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #DemandPdsExpiredBatch:
                _reqRefType.value(queryValue(ReqRefType::PdsExpiredBatch));
                _inventDirection.value(queryValue(InventDirection::None));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #SupplyProductionOrders:
                _reqRefType.value(queryValue(ReqRefType::Production));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #SupplyProductionKanban:
                _reqRefType.value(queryValue(ReqRefType::Kanban));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::ProductionKanban));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #SupplyPlannedProductionOrdersForecast:
                _reqRefType.value(queryValue(ReqRefType::BOMPlannedOrder));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::Yes));
                break;

            case #SupplyPmfPlannedBatchOrdersForecast:
                _reqRefType.value(queryValue(ReqRefType::PmfPlannedProdBatch));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::Yes));
                break;

            case #SupplyPlannedProductionOrders:
                _reqRefType.value(queryValue(ReqRefType::BOMPlannedOrder));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #SupplyPmfPlannedBatchOrders:
                _reqRefType.value(queryValue(ReqRefType::PmfPlannedProdBatch));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #SupplyPmfCoProduct:
                _reqRefType.value(queryValue(ReqRefType::PmfCoProduct));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #SupplyProductionOrderBOM:
                _reqRefType.value(queryValue(ReqRefType::ProdLine));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #SupplyKanbanLines:
                _reqRefType.value(queryValue(ReqRefType::KanbanLine));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #SupplyPlannedKanbanForecast:
                _reqRefType.value(queryValue(ReqRefType::PlannedKanban));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::ProductionKanban));
                _isForecast.value(queryValue(NoYes::Yes));
                break;

            case #SupplyPlannedKanban:
                _reqRefType.value(queryValue(ReqRefType::PlannedKanban));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::ProductionKanban));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #SupplyPlannedProductionOrderBOM:
                _reqRefType.value(queryValue(ReqRefType::BOMLine));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #SupplyPmfPlannedBatchOrderLine:
                _reqRefType.value(queryValue(ReqRefType::PmfFormulaLine));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #SupplyPlannedKanbanLinesForecast:
                _reqRefType.value(queryValue(ReqRefType::KanbanLine));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::ProductionKanban));
                _isForecast.value(queryValue(NoYes::Yes));
                break;

            case #SupplyPlannedKanbanLines:
                _reqRefType.value(queryValue(ReqRefType::KanbanLine));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::ProductionKanban));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #SupplyPurchaseOrders:
                _reqRefType.value(queryValue(ReqRefType::Purch));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #SupplyPlannedPurchaseOrdersTotal:
                _reqRefType.value(queryValue(ReqRefType::ItemPlannedOrder));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #SupplyPlannedPurchaseOrders:
                _reqRefType.value(queryValue(ReqRefType::ItemPlannedOrder));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #SupplyPlannedPurchaseOrdersForecast:
                _reqRefType.value(queryValue(ReqRefType::ItemPlannedOrder));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::Yes));
                break;

            case #SupplyTransferOrders:
                _reqRefType.value(queryValue(ReqRefType::TransferOrderReceive));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #SupplyWithdrawalKanbans:
                _reqRefType.value(queryValue(ReqRefType::Kanban));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::WithdrawalKanban));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #SupplyTransferPlannedOrdersForecast:
                _reqRefType.value(queryValue(ReqRefType::TransferPlannedOrder));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::Yes));
                break;

            case #SupplyTransferPlannedOrders:
                _reqRefType.value(queryValue(ReqRefType::TransferPlannedOrder));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #SupplyTransferPlannedKanbansForecast:
                _reqRefType.value(queryValue(ReqRefType::PlannedKanban));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::WithdrawalKanban));
                _isForecast.value(queryValue(NoYes::Yes));
                break;

            case #SupplyTransferPlannedKanbans:
                _reqRefType.value(queryValue(ReqRefType::PlannedKanban));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::WithdrawalKanban));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #SupplyTransferInventoryJournals:
                _reqRefType.value(queryValue(ReqRefType::InventJournal));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #SupplyWithdrawalKanbanLine:
                _reqRefType.value(queryValue(ReqRefType::KanbanLine));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::WithdrawalKanban));
                _isForecast.value(queryValue(NoYes::No));
                break;

            case #SupplyConsignmentReplenishmentOrder:
                _reqRefType.value(queryValue(ReqRefType::ConsignmentReplenishmentOrder));
                _inventDirection.value(queryValue(InventDirection::Receipt));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;

            default:
                _reqRefType.value(queryValue(0));
                _inventDirection.value(queryValue(0));
                _subClassification.value(queryValue(SupplyDemandSubClassification::None));
                _isForecast.value(queryValue(NoYes::No));
                break;
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>