<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProdRecBasketHandler</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///     The <c>ProdRecBasketHandler</c> class controls the operation that manipulate the basket.
/// </summary>
class ProdRecBasketHandler
{
    SysElementName          contextElementName;
    UserId                  contextUserId;
    SelectableDataArea      contextDataArea;
    RefTableId              contextTableId;
    boolean                 useCurrentUserIdAndDataareaId;

    boolean                 hasInitialized;
    private boolean         isProdBasketContextUsed, isProdBasketViewSelected;
    private Query           originalQuery, modifiedFormQuery;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addMultiSelectionToCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Adds the selected records of the datasource to the basket.
    /// </summary>
    /// <param name="_dataSource">
    ///     The datasource triggering the add event.
    /// </param>
    /// <param name="_multiSelectionContext">
    ///     The selection context.
    /// </param>
    /// <param name="_argRecord">
    ///     The selected if only one is provided.
    /// </param>
    /// <exception cref="Exception::Error">
    ///     An exception is thrown if the datasource specified is null.
    /// </exception>
    public void addMultiSelectionToCache(FormDataSource _dataSource, MultiSelectionContext _multiSelectionContext, Common _argRecord = null)
    {
        TmpProdRecBasketMultiOperations tmpProdRecBasketMultiOperations;
        boolean                         multiSelection;
        Common                          selectedRecord;
        container                       multiSelectionBucket = conNull();
        int64                           currentBasketRecords;
        int64                           currentNotInBasketRecords;

        if (!hasInitialized)
        {
            throw error(error::wrongUseOfFunction(funcName()));
        }

        if (_multiSelectionContext && _multiSelectionContext.getFirst())
        {
            //
            //multi selection is very painful and slow if we do exists check
            //need to use a set
            //
            multiSelection         = true;
            selectedRecord         = _multiSelectionContext.getFirst();

            while (selectedRecord)
            {
                tmpProdRecBasketMultiOperations.RefName  = selectedRecord.toolTipRecord();
                tmpProdRecBasketMultiOperations.RefRecId = selectedRecord.RecId;
                multiSelectionBucket+=[tmpProdRecBasketMultiOperations];
                selectedRecord = _multiSelectionContext.getNext();
            }

            [currentBasketRecords, currentNotInBasketRecords] = ProdRecBasketHandler::addMultiRecordsToCache(
                this.getCacheScope(),
                this.parmContextTableId(),
                this.parmContextDataArea(),
                this.parmContextUserId(),
                multiSelectionBucket);

            tmpProdRecBasketMultiOperations = null;
        }

        if (!multiSelection && _argRecord.RecId)
        {
            selectedRecord  = _argRecord;
            if (selectedRecord.RecId)
            {
                [currentBasketRecords, currentNotInBasketRecords] = this.addRecordToCache(selectedRecord);
            }
        }

        isProdBasketContextUsed = currentBasketRecords != 0;

        if (_dataSource)
        {
            if (this.getBasketJoinMode(_dataSource) == JoinMode::NoExistsJoin)
            {
                if (currentNotInBasketRecords == 0)
                {
                    this.clearDSFilterFromCache(_dataSource);
                }
                _dataSource.executeQuery();
            }
            _dataSource.refresh();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRecordToCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Adds a record to the basket.
    /// </summary>
    /// <param name="_record">
    ///     The specified record to add.
    /// </param>
    /// <returns>
    ///     A container with the count of the records in basket and the records not in basket.
    /// </returns>
    public container addRecordToCache(Common _record)
    {
        int64                           currentBasketRecords;
        int64                           currentNotInBasketRecords;
        TmpProdRecBasketMultiOperations tmpProdRecBasketMultiOperations;

        tmpProdRecBasketMultiOperations.initValue();

        tmpProdRecBasketMultiOperations.RefName  = _record.toolTipRecord();
        tmpProdRecBasketMultiOperations.RefRecId = _record.RecId;

        [currentBasketRecords, currentNotInBasketRecords] = ProdRecBasketHandler::addMultiRecordsToCache(
            this.getCacheScope(),
            this.parmContextTableId(),
            this.parmContextDataArea(),
            this.parmContextUserId(),
            [tmpProdRecBasketMultiOperations]);

        isProdBasketContextUsed = currentBasketRecords != 0;
        tmpProdRecBasketMultiOperations = null;

        return [currentBasketRecords, currentNotInBasketRecords];
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Clears the basket.
    /// </summary>
    public void clearCache()
    {
        ProdRecBasketRecords prodRecBasketRecords;

        ttsBegin;
        delete_from prodRecBasketRecords
            where   prodRecBasketRecords.CacheContextScope      == this.getCacheScope()
            &&      prodRecBasketRecords.RefTableId             == this.parmContextTableId()
            &&      prodRecBasketRecords.CacheContextDataArea   == this.parmContextDataArea()
            &&      prodRecBasketRecords.CacheContextUserId     == this.parmContextUserId();
        ttsCommit;

        isProdBasketContextUsed = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearDSFilterFromCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Clears the view filter of the form so it shows all the records.
    /// </summary>
    /// <param name="_formDataSource">
    ///     The main datasource of the form.
    /// </param>
    public void clearDSFilterFromCache(FormDataSource _formDataSource)
    {
        this.setDSFilterByCache(_formDataSource, JoinMode::OuterJoin);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteRecordFromCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Deletes a record from the basket.
    /// </summary>
    /// <param name="_record">
    ///     The specified record to delete.
    /// </param>
    /// <returns>
    ///     A container with the count of the records in basket and the records not in basket.
    /// </returns>
    public container deleteRecordFromCache(Common _record)
    {
        int64                           currentBasketRecords;
        int64                           currentNotInBasketRecords;
        TmpProdRecBasketMultiOperations tmpProdRecBasketMultiOperations;

        tmpProdRecBasketMultiOperations.initValue();
        tmpProdRecBasketMultiOperations.RefRecId = _record.RecId;

        [currentBasketRecords, currentNotInBasketRecords] = ProdRecBasketHandler::deleteMultiRecordFromCache(
            this.getCacheScope(),
            this.parmContextTableId(),
            this.parmContextDataArea(),
            this.parmContextUserId(),
            [tmpProdRecBasketMultiOperations]);

        isProdBasketContextUsed = currentBasketRecords != 0;
        tmpProdRecBasketMultiOperations = null;

        return [currentBasketRecords, currentNotInBasketRecords];
    }

]]></Source>
			</Method>
			<Method>
				<Name>delMultiSelectionFromCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Removes the selected records of the datasource from the basket.
    /// </summary>
    /// <param name="_dataSource">
    ///     The datasource triggering the add event.
    /// </param>
    /// <param name="_multiSelectionContext">
    ///     The selection context.
    /// </param>
    /// <param name="_argRecord">
    ///     The selected if only one is provided.
    /// </param>
    /// <exception cref="Exception::Error">
    ///     An exception is thrown if the datasource specified is null.
    /// </exception>
    public void delMultiSelectionFromCache(FormDataSource _dataSource, MultiSelectionContext _multiSelectionContext, Common _argRecord = null)
    {
        TmpProdRecBasketMultiOperations tmpProdRecBasketMultiOperations;
        boolean                         multiSelection;
        Common                          selectedRecord;
        container                       multiSelectionBucket = conNull();
        int64                           currentBasketRecords;
        int64                           currentNotInBasketRecords;

        if (!hasInitialized)
        {
            throw error(error::wrongUseOfFunction(funcName()));
        }

        if (_multiSelectionContext && _multiSelectionContext.getFirst())
        {
            //
            //multi selection is very painful and slow if we do exists check
            //need to use a set
            //
            multiSelection  = true;
            selectedRecord  = _multiSelectionContext.getFirst();

            while (selectedRecord)
            {
                tmpProdRecBasketMultiOperations.initValue();
                tmpProdRecBasketMultiOperations.RefRecId = selectedRecord.RecId;
                multiSelectionBucket+=[tmpProdRecBasketMultiOperations];
                selectedRecord = _multiSelectionContext.getNext();
            }

            [currentBasketRecords, currentNotInBasketRecords] = ProdRecBasketHandler::deleteMultiRecordFromCache(
                this.getCacheScope(),
                this.parmContextTableId(),
                this.parmContextDataArea(),
                this.parmContextUserId(),
                multiSelectionBucket);

            tmpProdRecBasketMultiOperations = null;
        }

        if (!multiSelection && _argRecord.RecId)
        {
            selectedRecord    = _argRecord;
            if (selectedRecord.RecId)
            {
                [currentBasketRecords, currentNotInBasketRecords] = this.deleteRecordFromCache(selectedRecord);
            }
        }

        isProdBasketContextUsed = currentBasketRecords != 0;

        if (_dataSource)
        {
            if (this.getBasketJoinMode(_dataSource) == JoinMode::ExistsJoin)
            {
                if (currentBasketRecords == 0)
                {
                    this.clearDSFilterFromCache(_dataSource);
                }
                _dataSource.executeQuery();
            }
            _dataSource.refresh();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsRecordOnCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if a record exists on the basket.
    /// </summary>
    /// <param name="_record">
    ///     The specified record to validate.
    /// </param>
    /// <returns>
    ///     True if the record exists on the basket; otherwise, false.
    /// </returns>
    public boolean existsRecordOnCache(Common _record)
    {
        return ProdRecBasketHandler::singleRecordExistsInCache(
            this.getCacheScope(),
            this.parmContextTableId(),
            this.parmContextDataArea(),
            this.parmContextUserId(),
            _record.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrAddBasketDataSource</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds or creates a datasource referencing the <c>ProdRecBasketRecords</c> table on the query of the specified form.
    /// </summary>
    /// <param name="_mainTableId">
    ///     The ID of the table of the main datasource on the form.
    /// </param>
    /// <param name="_query">
    ///     The current query of the form.
    /// </param>
    /// <returns>
    ///     An instance of a <c>QueryBuildDataSource</c> class.
    /// </returns>
    public QueryBuildDataSource findOrAddBasketDataSource(TableId _mainTableId, Query _query)
    {
        QueryBuildDataSource    qbdsBasket = _query.dataSourceTable(tableNum(ProdRecBasketRecords));

        if (!qbdsBasket)
        {
            SysDictTable dictTable      = SysDictTable::newTableId(_mainTableId);
            FieldId      fieldIdRecId   = dictTable.fieldName2Id(fieldStr(Common, RecId));
            FieldId      fieldIdTableId = dictTable.fieldName2Id(fieldStr(Common, TableId));

            qbdsBasket = _query.dataSourceNo(_query.dataSourceCount()).addDataSource(tableNum(ProdRecBasketRecords));
            qbdsBasket.addLink(fieldIdRecId,    fieldNum(ProdRecBasketRecords, RefRecId),    _query.dataSourceNo(1).name());
            qbdsBasket.addLink(fieldIdTableId,  fieldNum(ProdRecBasketRecords, RefTableId),  _query.dataSourceNo(1).name());
            qbdsBasket.addRange(fieldNum(ProdRecBasketRecords, CacheContextScope)).value(queryValue(this.getCacheScope()));

            if (this.parmUseCurrentUserIdAndDataareaId())
            {
                qbdsBasket.addRange(fieldNum(ProdRecBasketRecords, CacheContextDataArea)).value('(' + staticMethodStr(SysQueryRangeUtil, currentCompany) + '())');
                qbdsBasket.addRange(fieldNum(ProdRecBasketRecords, CacheContextUserId)).value('(' + staticMethodStr(SysQueryRangeUtil, currentUserId) + '())');
            }
            else
            {
                qbdsBasket.addRange(fieldNum(ProdRecBasketRecords, CacheContextDataArea)).value(queryValue(this.parmContextDataArea()));
                qbdsBasket.addRange(fieldNum(ProdRecBasketRecords, CacheContextUserId)).value(queryValue(this.parmContextUserId()));
            }

            qbdsBasket.joinMode(JoinMode::OuterJoin);
        }
        return qbdsBasket;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBasketJoinMode</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the current join mode that links the basket table to the main data source.
    /// </summary>
    /// <param name="_formDataSource">
    ///     The main data source linked to the basket table.
    /// </param>
    /// <returns>
    ///     A value of the <c>JoinMode</c> enumeration.
    /// </returns>
    public JoinMode getBasketJoinMode(FormDataSource _formDataSource)
    {
        QueryBuildDataSource qbds = this.findOrAddBasketDataSource(_formDataSource.table(), _formDataSource.query());
        return qbds.joinMode();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCacheScope</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the cache scope for the current basket.
    /// </summary>
    /// <returns>
    ///     The scope of the basket.
    /// </returns>
    public GlobalObjectCacheScope getCacheScope()
    {
        return strfmt('CacheBasket%1', this.parmContextElementName());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the records currently on and off the basket.
    /// </summary>
    /// <returns>
    ///     A container with the count of the records in basket and the records not in basket.
    /// </returns>
    public container getCount()
    {
        container resultCount = ProdRecBasketHandler::countBasketRecordsServer(
                this.getCacheScope(),
                this.parmContextTableId(),
                this.parmContextDataArea(),
                this.parmContextUserId());
        return resultCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSelectionBasketStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the selection status of the basket.
    /// </summary>
    /// <param name="_formDataSource">
    ///     The datasource being tracked.
    /// </param>
    /// <returns>
    ///     A value of the <c>NoneOneOfAllSelected</c> enumeration.
    /// </returns>
    /// <exception cref="Exception::Error">
    ///     An exception is thrown if the datasource specified is null.
    /// </exception>
    [SysObsolete('Method is deprecated and will be removed in the next major release', false, 30\06\2020)]
    public NoneOneOfAllSelected getSelectionBasketStatus(FormDataSource _formDataSource)
    {
        TmpProdRecBasketMultiOperations tmpProdRecBasketMultiOperations;

        boolean                 markedNotInBasket       = false;
        boolean                 markedInBasket          = false;
        NoneOneOfAllSelected    anyMarkedOnBasket       = NoneOneOfAllSelected::None;
        List                    multiSelectionBucket    = new List(Types::Record);

        if (_formDataSource == null)
        {
            throw error(error::wrongUseOfFunction(funcName()));
        }

        // marked records
        var markedCount = _formDataSource.recordsMarked().lastIndex();
        if (markedCount > 1)
        {
            Common recordsMarked = _formDataSource.getFirst(1);

            while (recordsMarked)
            {
                tmpProdRecBasketMultiOperations.initValue();
                tmpProdRecBasketMultiOperations.RefRecId = recordsMarked.RecId;
                multiSelectionBucket.addEnd(tmpProdRecBasketMultiOperations);

                recordsMarked = _formDataSource.getNext();
            }

            [markedInBasket, markedNotInBasket] = ProdRecBasketHandler::anyRecordInAnyOutOnCache(
                this.getCacheScope(),
                this.parmContextTableId(),
                this.parmContextDataArea(),
                this.parmContextUserId(),
                multiSelectionBucket);

            tmpProdRecBasketMultiOperations = null;
        }
        // unmarked records (standard single selection)
        else
        {
            Common recordNotMarked = _formDataSource.cursor();

            tmpProdRecBasketMultiOperations.initValue();
            tmpProdRecBasketMultiOperations.RefRecId = recordNotMarked.RecId;
            multiSelectionBucket.addEnd(tmpProdRecBasketMultiOperations);

            [markedInBasket, markedNotInBasket] = ProdRecBasketHandler::anyRecordInAnyOutOnCache(
                this.getCacheScope(),
                this.parmContextTableId(),
                this.parmContextDataArea(),
                this.parmContextUserId(),
                multiSelectionBucket);

            tmpProdRecBasketMultiOperations = null;
        }

        // all of them are in basket
        if (!markedNotInBasket && markedInBasket)
        {
            return NoneOneOfAllSelected::All;
        }
        // some of them are in basket
        else if (markedNotInBasket && markedInBasket)
        {
            return NoneOneOfAllSelected::OneOf;
        }
        // none of them are in basket
        else
        {
            return NoneOneOfAllSelected::None;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSelectionBasketStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the selection status of the basket.
    /// </summary>
    /// <param name="_formDataSource">
    ///     The datasource being tracked.
    /// </param>
    /// <returns>
    ///     A value of the <c>NoneOneOfAllSelected</c> enumeration.
    /// </returns>
    /// <exception cref="Exception::Error">
    ///     An exception is thrown if the datasource specified is null.
    /// </exception>
    public NoneOneOfAllSelected checkSelectionBasketStatus(FormDataSource _formDataSource)
    {
        TmpProdRecBasketMultiOperations tmpProdRecBasketMultiOperations;

        boolean                 markedNotInBasket       = false;
        boolean                 markedInBasket          = false;
        List                    multiSelectionBucket    = new List(Types::Record);

        if (_formDataSource == null)
        {
            throw error(error::wrongUseOfFunction(funcName()));
        }

        // marked single selection. Multi selection does not scale => deprecate
        if (_formDataSource.cursor())
        {
            Common recordMarked = _formDataSource.cursor();

            tmpProdRecBasketMultiOperations.initValue();
            tmpProdRecBasketMultiOperations.RefRecId = recordMarked.RecId;
            multiSelectionBucket.addEnd(tmpProdRecBasketMultiOperations);

            [markedInBasket, markedNotInBasket] = ProdRecBasketHandler::anyRecordInAnyOutOnCache(
                this.getCacheScope(),
                this.parmContextTableId(),
                this.parmContextDataArea(),
                this.parmContextUserId(),
                multiSelectionBucket);

            tmpProdRecBasketMultiOperations = null;
        }
        
        if (markedInBasket)
        {
            return NoneOneOfAllSelected::All;
        }
        else
        {
            return NoneOneOfAllSelected::None;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleClickedToggleComplView</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Handles the <c>click</c> event for the button that toggles the visibility of the basket complementary.
    /// </summary>
    /// <param name="_callingControl">
    ///     The control calling the method.
    /// </param>
    public void handleClickedToggleComplView(FormControl _callingControl)
    {
        FormDataSource  datasource = _callingControl.formRun().dataSource();
        JoinMode        joinMode    = this.getBasketJoinMode(datasource);

        isProdBasketViewSelected = false;

        if (joinMode == JoinMode::NoExistsJoin)
        {
            this.setDSFilterByCache(datasource, JoinMode::OuterJoin);
        }
        else
        {
            this.setDSFilterByCache(datasource, JoinMode::NoExistsJoin);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleClickedToggleView</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Handles the <c>click</c> event for the button that toggles the visibility of the basket.
    /// </summary>
    /// <param name="_callingControl">
    ///     The control calling the method.
    /// </param>
    public void handleClickedToggleView(FormControl _callingControl)
    {
        FormDataSource  datasource = _callingControl.formRun().dataSource();
        JoinMode        joinMode    = this.getBasketJoinMode(datasource);

        isProdBasketViewSelected = true;
        this.cacheFormQuery(datasource);

        if (joinMode == JoinMode::ExistsJoin)
        {
            this.setDSFilterByCache(datasource, JoinMode::OuterJoin);            
        }
        else
        {
            this.setDSFilterByCache(datasource, JoinMode::ExistsJoin);            
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasRecordOnCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if there are records on the basket for the current context.
    /// </summary>
    /// <returns>
    ///     true if there are records on the cache; otherwise, false.
    /// </returns>
    public boolean hasRecordOnCache()
    {
        ProdRecBasketRecords prodRecBasketRecords;

        select firstOnly RecId from prodRecBasketRecords
            where   prodRecBasketRecords.RefTableId             == this.parmContextTableId()
                &&  prodRecBasketRecords.CacheContextDataArea   == this.parmContextDataArea()
                &&  prodRecBasketRecords.CacheContextUserId     == this.parmContextUserId()
                &&  prodRecBasketRecords.CacheContextScope      == this.getCacheScope();

        return prodRecBasketRecords.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates the arguments for the handler and initializes the handler.
    /// </summary>
    /// <exception cref="Exception::Error">
    ///     Throws an error when the method is initialized incorrectly.
    /// </exception>
    public void init()
    {
        if (!contextDataArea || !contextElementName || !contextUserId || !contextTableId)
        {
            throw error(error::wrongUseOfFunction(funcName()));
        }
        hasInitialized = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        hasInitialized  = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmContextDataArea</Name>
				<Source><![CDATA[
    public SelectableDataArea parmContextDataArea(SelectableDataArea  _contextDataArea = contextDataArea)
    {
        contextDataArea = _contextDataArea;
        return contextDataArea;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmContextElementName</Name>
				<Source><![CDATA[
    public SysElementName parmContextElementName(SysElementName _contextElementName = contextElementName)
    {
        contextElementName = _contextElementName;
        return contextElementName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmContextTableId</Name>
				<Source><![CDATA[
    public tableId parmContextTableId(TableId _contextTableId = contextTableId)
    {
        contextTableId = _contextTableId;
        return contextTableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmContextUserId</Name>
				<Source><![CDATA[
    public UserId parmContextUserId(UserId  _contextUserId = contextUserId)
    {
        contextUserId = _contextUserId;
        return contextUserId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseCurrentUserIdAndDataareaId</Name>
				<Source><![CDATA[
    public boolean parmUseCurrentUserIdAndDataareaId(boolean _useCurrentUserIdAndDataareaId = useCurrentUserIdAndDataareaId)
    {
        useCurrentUserIdAndDataareaId = _useCurrentUserIdAndDataareaId;
        return useCurrentUserIdAndDataareaId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsProdBasketContextUsed</Name>
				<Source><![CDATA[
    public boolean parmIsProdBasketContextUsed(boolean _isProdBasketContextUsed = isProdBasketContextUsed)
    {
        isProdBasketContextUsed = _isProdBasketContextUsed;
        return isProdBasketContextUsed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDSFilterByCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets the join mode from the main form datasource to the basket datasource;
    /// </summary>
    /// <param name="_formDataSource">
    ///     The main datasource of the form.
    /// </param>
    /// <param name="_joinMode">
    ///     The join mode to apply.
    /// </param>
    /// <remarks>
    ///     Specify the value of <c>JoinMode::ExistsJoin</c> to only see the basket;
    ///     Specify the value of <c>JoinMode::NoExistsJoin</c> to only see the complementary of the basket;
    ///     Specify the value of <c>JoinMode::OuterJoin</c> to see all regular records;
    /// </remarks>
    public void setDSFilterByCache(FormDataSource _formDataSource, JoinMode _joinMode)
    {
        FormRun                 formRun = _formDataSource.formRun();

        this.findOrAddBasketDataSource(_formDataSource.table(), _formDataSource.query());

        Query query;
        
        if (isProdBasketViewSelected && originalQuery)
        {
            query = originalQuery;
        }
        else if (modifiedFormQuery)
        {
            query = modifiedFormQuery;
        }
        else
        {
            query = _formDataSource.query();
        }

        QueryBuildDataSource qbds = query.dataSourceTable(tableNum(ProdRecBasketRecords));
        qbds.joinMode(_joinMode);

        _formDataSource.query(query);
        _formDataSource.executeQuery();
        _formDataSource.refresh();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addMultiRecordsToCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Adds all the records from the current datasource that are linked to the specified temporary cursor.
    /// </summary>
    /// <param name="_cacheContextScope">
    ///     The scope of the cache to add the records to.
    /// </param>
    /// <param name="_refTableId">
    ///     The ID of the table to reference.
    /// </param>
    /// <param name="_cacheContextDataArea">
    ///     The ID of the company the user is running in.
    /// </param>
    /// <param name="_cacheContextUserId">
    ///     The ID of the active user.
    /// </param>
    /// <param name="_tmpProdRecBasketMultiOperationsPackedSet">
    ///     The container with the selection of records.
    /// </param>
    /// <returns>
    ///     A container with the count of the records in basket and the records not in basket.
    /// </returns>
    private static container addMultiRecordsToCache(
        GlobalObjectCacheScope  _cacheContextScope,
        RefTableId              _refTableId,
        SelectableDataArea      _cacheContextDataArea,
        UserId                  _cacheContextUserId,
        container               _tmpProdRecBasketMultiOperationsPackedSet)
    {
        ProdRecBasketRecords    prodRecBasketRecords;
        ProdRecBasketRecords    prodRecBasketRecordsExisting;
        TmpProdRecBasketMultiOperations tmpProdRecBasketMultiOperations;

        GlobalObjectCacheScope  cacheContextScope       = _cacheContextScope;
        RefTableId              refTableId              = _refTableId;
        SelectableDataArea      cacheContextDataArea    = _cacheContextDataArea;
        UserId                  cacheContextUserId      = _cacheContextUserId;

        int                     tmpRecBasketBucketCount = conLen(_tmpProdRecBasketMultiOperationsPackedSet);
        int                     basketIterator          = 1;
        int64                   currentBasketRecords;
        int64                   currentNotInBasketRecords;

        ttsBegin;

        while (basketIterator <= tmpRecBasketBucketCount)
        {
            tmpProdRecBasketMultiOperations.data(conPeek(_tmpProdRecBasketMultiOperationsPackedSet, basketIterator));
            tmpProdRecBasketMultiOperations.insert();
            basketIterator++;
        }

        insert_recordset prodRecBasketRecords
                (cacheContextScope, refTableId, cacheContextDataArea, cacheContextUserId, refRecId, refName)
        select   cacheContextScope, refTableId, cacheContextDataArea, cacheContextUserId, refRecId, refName
            from    tmpProdRecBasketMultiOperations
        notExists join prodRecBasketRecordsExisting
            where prodRecBasketRecordsExisting.cacheContextScope      == cacheContextScope
               && prodRecBasketRecordsExisting.refTableId             == refTableId
               && prodRecBasketRecordsExisting.refRecId               == tmpProdRecBasketMultiOperations.RefRecId
               && prodRecBasketRecordsExisting.cacheContextDataArea   == cacheContextDataArea
               && prodRecBasketRecordsExisting.cacheContextUserId     == cacheContextUserId;
        ttsCommit;

        tmpProdRecBasketMultiOperations = null;
        [currentBasketRecords, currentNotInBasketRecords] = ProdRecBasketHandler::countBasketRecordsServer(cacheContextScope, refTableId, cacheContextDataArea, cacheContextUserId);

        return [currentBasketRecords, currentNotInBasketRecords];
    }

]]></Source>
			</Method>
			<Method>
				<Name>anyRecordInAnyOutOnCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if any record of those selected is or is not in the basket.
    /// </summary>
    /// <param name="_cacheContextScope">
    ///     The scope of the cache to add the records to.
    /// </param>
    /// <param name="_refTableId">
    ///     The ID of the table to reference.
    /// </param>
    /// <param name="_cacheContextDataArea">
    ///     The ID of the company the user is running in.
    /// </param>
    /// <param name="_cacheContextUserId">
    ///     The ID of the active user.
    /// </param>
    /// <param name="_tmpProdRecBasketMultiOperationsList">
    ///     The List with the selection of records.
    /// </param>
    /// <returns>
    ///     A container with two values:
    ///         The boolean value of true if any selected record is in the basket; otherwise, false;
    ///         The boolean value of true if any selected record is not in the basket; otherwise, false;
    /// </returns>
    private static container anyRecordInAnyOutOnCache(
        GlobalObjectCacheScope  _cacheContextScope,
        RefTableId              _refTableId,
        SelectableDataArea      _cacheContextDataArea,
        UserId                  _cacheContextUserId,
        List                    _tmpProdRecBasketMultiOperationsList)
    {
        int                             selectedRecordsCount    = _tmpProdRecBasketMultiOperationsList.elements();
        container                       result                  = [false, false];

        if (selectedRecordsCount == 1)
        {
            var enumerator = _tmpProdRecBasketMultiOperationsList.getEnumerator();
            enumerator.moveNext();

            TmpProdRecBasketMultiOperations tmpProdRecBasketMultiOperations = enumerator.current() as TmpProdRecBasketMultiOperations;

            var existsOnBasket = ProdRecBasketHandler::singleRecordExistsInCache(_cacheContextScope,
                _refTableId,
                _cacheContextDataArea,
                _cacheContextUserId,
                tmpProdRecBasketMultiOperations.RefRecId);

            result = [existsOnBasket, !existsOnBasket];
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>singleRecordExistsInCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if single record is in the basket.
    /// </summary>
    /// <param name="_cacheContextScope">
    ///     The scope of the cache to add the records to.
    /// </param>
    /// <param name="_refTableId">
    ///     The ID of the table to reference.
    /// </param>
    /// <param name="_cacheContextDataArea">
    ///     The ID of the company the user is running in.
    /// </param>
    /// <param name="_cacheContextUserId">
    ///     The ID of the active user.
    /// </param>
    /// <param name="_selectedRecordRecId">
    ///     The RecId of record.
    /// </param>
    /// <returns>
    ///     True if record exists in the basket; otherwhise false.
    /// </returns>
    private static boolean singleRecordExistsInCache(
        GlobalObjectCacheScope  _cacheContextScope,
        RefTableId              _refTableId,
        SelectableDataArea      _cacheContextDataArea,
        UserId                  _cacheContextUserId,
        RecId                   _selectedRecordRecId)
    {
        ProdRecBasketRecords prodRecBasketRecords;

        select firstonly RefRecId from prodRecBasketRecords
            where   prodRecBasketRecords.RefRecId                == _selectedRecordRecId
            &&      prodRecBasketRecords.RefTableId              == _refTableId
            &&      prodRecBasketRecords.CacheContextDataArea    == _cacheContextDataArea
            &&      prodRecBasketRecords.CacheContextUserId      == _cacheContextUserId
            &&      prodRecBasketRecords.CacheContextScope       == _cacheContextScope;

        return prodRecBasketRecords.RefRecId > 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static ProdRecBasketHandler construct()
    {
        return new ProdRecBasketHandler();
    }

]]></Source>
			</Method>
			<Method>
				<Name>countBasketRecordsServer</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the records currently on and off the basket.
    /// </summary>
    /// <param name="_cacheContextScope">
    ///     The scope of the cache to add the records to.
    /// </param>
    /// <param name="_refTableId">
    ///     The ID of the table to reference.
    /// </param>
    /// <param name="_cacheContextDataArea">
    ///     The ID of the company the user is running in.
    /// </param>
    /// <param name="_cacheContextUserId">
    ///     The ID of the active user.
    /// </param>
    /// <returns>
    ///     A container with the count of the records in basket and the records not in basket.
    /// </returns>
    private static container countBasketRecordsServer(
        GlobalObjectCacheScope  _cacheContextScope,
        RefTableId              _refTableId,
        SelectableDataArea      _cacheContextDataArea,
        UserId                  _cacheContextUserId)
    {
        GlobalObjectCacheScope  cacheContextScope       = _cacheContextScope;
        RefTableId              refTableId              = _refTableId;
        SelectableDataArea      cacheContextDataArea    = _cacheContextDataArea;
        UserId                  cacheContextUserId      = _cacheContextUserId;

        Common                  common;

        int64                   recordsInBasket         = 0;
        int64                   recordsNotInBasket      = 0;

        Query                   query = new query();
        QueryBuildDataSource    qbds  = query.addDataSource(refTableId);

        SysDictTable dictTable      = SysDictTable::newTableId(refTableId);
        FieldId      fieldIdRecId   = dictTable.fieldName2Id(fieldStr(Common, RecId));
        FieldId      fieldIdTableId = dictTable.fieldName2Id(fieldStr(Common, TableId));

        qbds.addSelectionField(fieldIdRecId, SelectionField::Count);
        qbds = qbds.addDataSource(tableNum(ProdRecBasketRecords));
        qbds.joinMode(JoinMode::ExistsJoin);

        qbds.addLink(fieldIdRecId,   fieldNum(ProdRecBasketRecords, RefRecId));
        qbds.addLink(fieldIdTableId, fieldNum(ProdRecBasketRecords, RefTableId));

        qbds.addRange(fieldNum(ProdRecBasketRecords, CacheContextUserId)).value(cacheContextUserId);
        qbds.addRange(fieldNum(ProdRecBasketRecords, CacheContextDataArea)).value(cacheContextDataArea);
        qbds.addRange(fieldNum(ProdRecBasketRecords, CacheContextScope)).value(cacheContextScope);
        qbds.addRange(fieldNum(ProdRecBasketRecords, RefTableId)).value(queryValue(refTableId));

        QueryRun queryRun = new QueryRun(query);
        if (queryRun.next())
        {
            common = queryRun.get(refTableId);
            recordsInBasket = common.RecId;
        }

        return [recordsInBasket, recordsNotInBasket];
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteMultiRecordFromCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Removes all the records from the current datasource that are linked to the specified temporary cursor.
    /// </summary>
    /// <param name="_cacheContextScope">
    ///     The scope of the cache to add the records to.
    /// </param>
    /// <param name="_refTableId">
    ///     The ID of the table to reference.
    /// </param>
    /// <param name="_cacheContextDataArea">
    ///     The ID of the company the user is running in.
    /// </param>
    /// <param name="_cacheContextUserId">
    ///     The ID of the active user.
    /// </param>
    /// <param name="_tmpProdRecBasketMultiOperationsPackedSet">
    ///     The container with the selection of records.
    /// </param>
    /// <returns>
    ///     A container with the count of the records in basket and the records not in basket.
    /// </returns>
    private static container deleteMultiRecordFromCache(
        GlobalObjectCacheScope  _cacheContextScope,
        RefTableId              _refTableId,
        SelectableDataArea      _cacheContextDataArea,
        UserId                  _cacheContextUserId,
        container               _tmpProdRecBasketMultiOperationsPackedSet)
    {
        ProdRecBasketRecords    prodRecBasketRecords;
        TmpProdRecBasketMultiOperations tmpProdRecBasketMultiOperations;

        GlobalObjectCacheScope  cacheContextScope       = _cacheContextScope;
        RefTableId              refTableId              = _refTableId;
        SelectableDataArea      cacheContextDataArea    = _cacheContextDataArea;
        UserId                  cacheContextUserId      = _cacheContextUserId;

        int                     tmpRecBasketBucketCount = conLen(_tmpProdRecBasketMultiOperationsPackedSet);
        int                     basketIterator          = 1;
        int64                   currentBasketRecords;
        int64                   currentNotInBasketRecords;

        ttsBegin;
        while (basketIterator <= tmpRecBasketBucketCount)
        {
            tmpProdRecBasketMultiOperations.data(conPeek(_tmpProdRecBasketMultiOperationsPackedSet, basketIterator));
            tmpProdRecBasketMultiOperations.insert();
            basketIterator++;
        }

        delete_from prodRecBasketRecords
        exists join tmpProdRecBasketMultiOperations
            where   prodRecBasketRecords.RefRecId                == tmpProdRecBasketMultiOperations.refRecId
                &&  prodRecBasketRecords.RefTableId              == refTableId
                &&  prodRecBasketRecords.CacheContextDataArea    == cacheContextDataArea
                &&  prodRecBasketRecords.CacheContextUserId      == cacheContextUserId
                &&  prodRecBasketRecords.CacheContextScope       == cacheContextScope;
        ttsCommit;

        tmpProdRecBasketMultiOperations = null;

        [currentBasketRecords, currentNotInBasketRecords] = ProdRecBasketHandler::countBasketRecordsServer(cacheContextScope, refTableId, cacheContextDataArea, cacheContextUserId);
        return [currentBasketRecords, currentNotInBasketRecords];
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromFormName</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates an instance of the <c>ProdRecBasketHandler</c> class for the specified form and table.
    /// </summary>
    /// <param name="_formName">
    ///     The specified form.
    /// </param>
    /// <param name="_tableId">
    ///     The specified ID of the main table of the form.
    /// </param>
    /// <returns>
    ///     An instance of the <c>ProdRecBasketHandler</c> class.
    /// </returns>
    public static ProdRecBasketHandler newFromFormName(SysElementName _formName, tableId _tableId)
    {
        ProdRecBasketHandler basketHandler = ProdRecBasketHandler::construct();

        basketHandler.parmContextElementName(_formName);
        
        basketHandler.parmContextUserId(curUserId());
        basketHandler.parmContextDataArea(curext());
        basketHandler.parmUseCurrentUserIdAndDataareaId(true);
        
        basketHandler.parmContextTableId(_tableId);
        basketHandler.init();
        basketHandler.parmIsProdBasketContextUsed(basketHandler.hasRecordOnCache() != 0);

        return basketHandler;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cacheFormQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///     The method saves the query that was used for the datasource before the user clicked on the "view selection" button.
    ///     This allows the user to return to the previous state when they go back to the normal view.
    /// </summary>
    /// /// <param name="_formDataSource">
    ///     The main datasource of the form.
    /// </param>
    internal void cacheFormQuery(FormDataSource _formDataSource)
    {
        if (!originalQuery)
        {
            originalQuery = _formDataSource.query();
        }

        modifiedFormQuery = _formDataSource.queryRun().query();        
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProdBasketViewSelected</Name>
				<Source><![CDATA[
    /// <summary>
    ///     The method determines whether the basket is currently displayed or not.
    /// </summary>
    /// <returns>
    ///     true if the "view selection" button is active; otherwise false.
    /// </returns>
    internal boolean isProdBasketViewSelected()
    {
        return isProdBasketViewSelected;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>