<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailOrderCalculator</Name>
	<SourceCode>
		<Declaration><![CDATA[
using CommerceRunTimeDataModel = Microsoft.Dynamics.Commerce.Runtime.DataModel;
using CrtPriceAndDiscountCalculationParameters = Microsoft.Dynamics.Commerce.Runtime.Services.PricingEngine.PriceAndDiscountCalculationParameters;
using System.Collections.Generic;
using System.Reflection;

/// <summary>
/// Base class for <c>RetailSalesOrderCalculator</c> and <c>RetailSalesQuotationCalculator</c>.
/// </summary>
abstract class RetailOrderCalculator
{
    Microsoft.Dynamics.Commerce.Runtime.Services.PricingEngine.IPricingDataAccessorV2 pricingManager;

    RetailCurrencyOperations currencyAndRoundingHelper;
    RetailChannelTable currentChannel;
    CustTable customer;
    boolean priceIncludesTax;
    protected boolean exemptTaxesForPriceInclusive;
    CurrencyCode transactionCurrency;

    CustLineDiscCode lineDisc;
    CustMultiLineDiscCode multilineDisc;
    CustEndDiscCode endDisc;

    RetailTempOrderItem tempOrderItem;

    boolean priceCalculated;
    boolean discountCalculated;
    boolean tmpOrderItemInitialized;

    Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesTransaction crtSalesTransaction;

    // Pre calculation data.
    Map existingPricesExceptCurrentLine;
    Map existingDiscountsExceptCurrentLine;
    
    protected str currentInventTransId;
    protected str crtLineIdCurrentLine;
    int lineCount;

    // Maps CRT lineId to inventTransId, for new line InventTransId is blank
    protected Map lineIdToInventTransIdMap = new Map(Types::String, Types::String);
    
    System.DateTimeOffset activeDateTimeOffset;

    protected CustPriceGroup salesOrderPriceGroup;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>setCurrentLineId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets <c>currentLineId</c> based on current transaction line
    /// </summary>
    protected void setCurrentLineId()
    {
        // when inventTransId is blank, user lineId from CRT instead
        if (currentInventTransId == '')
        {
            MapEnumerator enumerator = lineIdToInventTransIdMap.getEnumerator();
            while (enumerator.moveNext())
            {
                str currentLineId = enumerator.currentValue();
                if (currentLineId == '')
                {
                    crtLineIdCurrentLine = enumerator.currentKey();
                    break;
                }
            }
        }
        else
        {
            crtLineIdCurrentLine = currentInventTransId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPrecalculationData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Build the pricing data for calculation.
    /// </summary>
    /// <param name="_crtSalesTransaction">
    /// Sales transaction containing sales lines.
    /// </param>
    protected void buildPrecalculationData(Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesTransaction _crtSalesTransaction)
    {
        this.setCurrentLineId();

        Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesLine crtSalesLine;
        CLRObject clrSalesLines, enumeratorSalesLine;
        str lineId;
        Price price;

        clrSalesLines = _crtSalesTransaction.get_SalesLines();
        enumeratorSalesLine = clrSalesLines.GetEnumerator();

        lineCount = clrSalesLines.get_Count();
        existingPricesExceptCurrentLine = new Map(Types::String, Types::Real);

        while (enumeratorSalesLine.MoveNext())
        {
            crtSalesLine = enumeratorSalesLine.get_Current();
            lineId = crtSalesLine.get_LineId();

            if (lineId != crtLineIdCurrentLine)
            {
                price = crtSalesLine.get_Price();
                existingPricesExceptCurrentLine.insert(lineId, price);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeExtensionContext</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes disposable <c>PricingEngineExtensionContext</c> instance. Register dependency
    /// into <c>PricingEngineExtensionRepository</c> to customize the pricing engine logic.
    /// </summary>
    /// <returns>The <c>PricingEngineExtensionContext</c> instance.</returns>
    protected Microsoft.Dynamics.Commerce.Runtime.Services.PricingEngine.PricingEngineExtensionContext initializeExtensionContext()
    {
        return new Microsoft.Dynamics.Commerce.Runtime.Services.PricingEngine.PricingEngineExtensionContext();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateDiscountsForOrderV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate discount for retail sales order and retail sales quote.
    /// </summary>
    /// <param name = "calculateSimpleDiscountsOnly">The value indicating whether to calculate simple discount only.</param>
    /// <remarks>
    /// Override this method if you want customize the call to the pricing engine.
    /// </remarks>
    protected void calculateDiscountsForOrderV2(boolean calculateSimpleDiscountsOnly)
    {
        if (!priceCalculated)
        {
            crtSalesTransaction = this.initializeCrtTransaction();
            this.buildPrecalculationData(crtSalesTransaction);
        }

        if (!tmpOrderItemInitialized)
        {
            this.initializeForDataManagerPerformance();
        }

        SalesTable salesTable = SalesTable::find(crtSalesTransaction.Id);

        RetailPricingTotalling totalling = this.initRetailPricingTotalling();

        using (var extensionContext = this.initializeExtensionContext())
        {
            CrtPriceAndDiscountCalculationParameters calculationParameters = new CrtPriceAndDiscountCalculationParameters();
            calculationParameters.TransactionTotaling = totalling;
            calculationParameters.ExcludeTradeAgreementDiscount = calculateSimpleDiscountsOnly;
            if (!RetailPricingImprovedAlgorithmForArrangeLineGroupsFlight::instance().isEnabled())
            {
                calculationParameters.MaxLoopCountForLegacyArrangeLineGroups = -1;
            }
            Microsoft.Dynamics.Commerce.Runtime.Services.PricingEngine.PricingEngine::CalculateDiscountsForLines(
                pricingManager,
                crtSalesTransaction,
                currencyAndRoundingHelper,
                transactionCurrency,
                lineDisc,
                multilineDisc,
                endDisc,
                calculateSimpleDiscountsOnly, // calculate simple discount only
                activeDateTimeOffset,
                calculationParameters); 
        }
        discountCalculated = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateDiscountsForOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate discount for retail sales order and retail sales quote.
    /// </summary>
    /// <remarks>
    /// Override this method if you want customize the call to the pricing engine.
    /// </remarks>
    protected void calculateDiscountsForOrder()
    {
        this.calculateDiscountsForOrderV2(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRetailPricingTotalling</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>RetailPricingTotalling</c> class.
    /// </summary>
    /// <returns>The <c>RetailPricingTotalling</c> instance.</returns>
    protected RetailPricingTotalling initRetailPricingTotalling()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculatePricesForOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate prices for retail sales order and retail sales quote.
    /// </summary>
    /// <remarks>
    /// Override this method if you want customize the call to the pricing engine.
    /// </remarks>
    protected void calculatePricesForOrder()
    {
        Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesTransaction crtSalesTransactionLocal;
        System.String customerPriceGroup;

        crtSalesTransactionLocal = this.initializeCrtTransaction();
        this.buildPrecalculationData(crtSalesTransactionLocal);

        customerPriceGroup = customer.PriceGroup;

        // by default SalesTable will be populated with price group from customer, but it can be overwritten in sales order header.
        if (customerPriceGroup != salesOrderPriceGroup && salesOrderPriceGroup != '')
        {
            customerPriceGroup = salesOrderPriceGroup;
        }

        using (var extensionContext = this.initializeExtensionContext())
        {
            Microsoft.Dynamics.Commerce.Runtime.Services.PricingEngine.PricingEngine::CalculatePricesForTransaction(
                crtSalesTransactionLocal,
                pricingManager,
                currencyAndRoundingHelper,
                customerPriceGroup,
                transactionCurrency,
                activeDateTimeOffset);
        }

        crtSalesTransaction = crtSalesTransactionLocal;

        priceCalculated = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculatePriceForCharge</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate prices for charges on retail sales order and retail sales quote.
    /// </summary>
    /// <param name = "markupTrans">Charge transaction.</param>
    /// <remarks>
    /// Override this method if you want customize the call to the pricing engine.
    /// </remarks>
    internal void calculatePriceForCharge(MarkupTrans markupTrans)
    {
        if (crtSalesTransaction == null)
        {
            return;
        }

        if (!tmpOrderItemInitialized)
        {
            this.initializeForDataManagerPerformance();
        }

        if (pricingManager is Microsoft.Dynamics.Commerce.Runtime.Services.PricingEngine.IPricingDataAccessorV3 && crtSalesTransaction.IsTaxExemptedForPriceInclusive)
        {
            Microsoft.Dynamics.Commerce.Runtime.Services.PricingEngine.IPricingDataAccessorV3 pricingManagerV3 = pricingManager as Microsoft.Dynamics.Commerce.Runtime.Services.PricingEngine.IPricingDataAccessorV3;

            real taxExemptPercentage = pricingManagerV3.GetTaxExemptPercentage(markupTrans.TaxGroup, markupTrans.TaxItemGroup, markupTrans.Value);
            real taxExemptPrice = currencyAndRoundingHelper.Round(markupTrans.Value / (1 + taxExemptPercentage));
            real taxExemptAmount = markupTrans.Value - taxExemptPrice;

            markupTrans.TaxExemptPriceInclusiveOriginalPrice = markupTrans.Value;
            markupTrans.TaxExemptPriceInclusiveReductionAmount = taxExemptAmount;
            markupTrans.Value = taxExemptPrice;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateShippingDiscountsForOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate shipping discount for retail sales order.
    /// </summary>
    /// <param name = "_applyOnHeadingLine">Indicates if discount should be applied to header or line.</param>
    /// <param name = "_moduleType">The module that generated the <c>MarkupTrans</c> record.</param>
    /// <remarks>
    /// Override this method if you want customize the call to the pricing engine.
    /// </remarks>
    internal void calculateShippingDiscountsForOrder(HeadingLine _applyOnHeadingLine, MarkupModule _moduleType)
    {
        if (!RetailPeriodicDiscount::existsShippingDiscounts())
        {
            return;
        }

        if (crtSalesTransaction == null)
        {
            return;
        }

        if (!tmpOrderItemInitialized)
        {
            this.initializeForDataManagerPerformance();
        }

        Map salesLineMap = RetailOrderCalculator::buildSalesLineByDlvMode(crtSalesTransaction);

        SetEnumerator enumerator = salesLineMap.keySet().getEnumerator();

        while (enumerator.moveNext())
        {
            DlvModeId dlvModeId = enumerator.current();
            DlvModeId transactionDlvModeId = crtSalesTransaction.get_DeliveryMode() == null ? '' : crtSalesTransaction.get_DeliveryMode();

            // only process if delivery is set on either header or lines
            if (dlvModeId == '' && transactionDlvModeId == '')
            {
                continue;
            }

            CLRObject clrSalesLines = salesLineMap.lookup(dlvModeId);

            this.prepareTransactionForShippingDiscCalcOnOrder(clrSalesLines);

            CrtPriceAndDiscountCalculationParameters calculationParameters = new CrtPriceAndDiscountCalculationParameters();
            if (!RetailPricingImprovedAlgorithmForArrangeLineGroupsFlight::instance().isEnabled())
            {
                calculationParameters.MaxLoopCountForLegacyArrangeLineGroups = -1;
            }
            Microsoft.Dynamics.Commerce.Runtime.Services.PricingEngine.PricingEngine::CalculateDiscountsForLines(
                new RetailShippingDiscountsDataServiceManager(currentChannel.RecId, this.getTransactionId(), tempOrderItem, true, dlvModeId),
                crtSalesTransaction,
                currencyAndRoundingHelper,
                transactionCurrency,
                lineDisc,
                multilineDisc,
                endDisc,
                false, // calculateSimpleDiscountOnly
                activeDateTimeOffset,
                calculationParameters);

            var discount = RetailOrderCalculator::getShipmentDiscountPct(crtSalesTransaction);

            if (discount != null)
            {
                this.applyShippingDiscountToOrder(dlvModeId, discount.get_Percentage(), discount.get_OfferId(), discount.get_OfferName(), _applyOnHeadingLine, _moduleType);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateShippingDiscountsBySalesLineDlvMode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate shipping discount for retail sales order by delivery modes on sales lines.
    /// </summary>
    /// <returns>A delivery mode to applied shipping discount mapping.</returns>
    internal Map calculateShippingDiscountsBySalesLineDlvMode()
    {
        Map dlvModeIdDiscountMap = new Map(Types::String, Types::Class);

        if (!RetailPeriodicDiscount::existsShippingDiscounts() || crtSalesTransaction == null)
        {
            return dlvModeIdDiscountMap;
        }

        if (!tmpOrderItemInitialized)
        {
            this.initializeForDataManagerPerformance();
        }
        
        Map salesLineMap = RetailOrderCalculator::buildSalesLineByDlvMode(crtSalesTransaction);
        SetEnumerator enumerator = salesLineMap.keySet().getEnumerator();

        while (enumerator.moveNext())
        {
            DlvModeId dlvModeId = enumerator.current();
            DlvModeId transactionDlvModeId = crtSalesTransaction.get_DeliveryMode() == null ? '' : crtSalesTransaction.get_DeliveryMode();

            // only process if delivery is set on either header or lines
            if (dlvModeId == '' && transactionDlvModeId == '')
            {
                continue;
            }

            CLRObject clrSalesLines = salesLineMap.lookup(dlvModeId);

            this.prepareTransactionForShippingDiscCalcOnOrder(clrSalesLines);

            Microsoft.Dynamics.Commerce.Runtime.Services.PricingEngine.PricingEngine::CalculateDiscountsForLines(
                new RetailShippingDiscountsDataServiceManager(currentChannel.RecId, this.getTransactionId(), tempOrderItem, true, dlvModeId),
                crtSalesTransaction,
                currencyAndRoundingHelper,
                transactionCurrency,
                lineDisc,
                multilineDisc,
                endDisc,
                true,
                false,
                activeDateTimeOffset);

            var discount = RetailOrderCalculator::getShipmentDiscountPct(crtSalesTransaction);

            if (discount != null)
            {
                dlvModeIdDiscountMap.insert(dlvModeId, discount);
            }
        }

        return dlvModeIdDiscountMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyShippingDiscountsByDlvModeToOrder</Name>
				<Source><![CDATA[
    internal void applyShippingDiscountsByDlvModeToOrder(Map _dlvModeIdDiscountMap, HeadingLine _applyOnHeadingLine, MarkupModule _moduleType)
    {
        SetEnumerator enumerator = _dlvModeIdDiscountMap.keySet().getEnumerator();

        while (enumerator.moveNext())
        {
            DlvModeId dlvModeId = enumerator.current();
            CommerceRunTimeDataModel.DiscountLine discount = _dlvModeIdDiscountMap.lookup(dlvModeId);
            this.applyShippingDiscountToOrder(dlvModeId, discount.get_Percentage(), discount.get_OfferId(), discount.get_OfferName(), _applyOnHeadingLine, _moduleType);
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareTransactionForShippingDiscCalcOnOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prepare transaction for shipping discount calculation on order.
    /// </summary>
    /// <param name = "_clrSalesLinesWithDlvMode">Collection of sales lines filtered by delivery mode.</param>
    [Wrappable(false), Replaceable(false)]
    protected void prepareTransactionForShippingDiscCalcOnOrder(CLRObject _clrSalesLinesWithDlvMode)
    {
        CLRObject transactionSalesLine = crtSalesTransaction.get_SalesLines();
        transactionSalesLine.clear();

        CLRObject enumeratorSalesLine = _clrSalesLinesWithDlvMode.GetEnumerator();
        while (enumeratorSalesLine.MoveNext())
        {
            Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesLine crtSalesLine = enumeratorSalesLine.get_Current();
            transactionSalesLine.add(crtSalesLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyShippingDiscountToOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Applies a discount pct to order misc. charges.
    /// </summary>
    /// <param name = "_dlvModeId">The delivery mode.</param>
    /// <param name = "_discPct">The discount percentage.</param>
    /// <param name = "_offerId">The shipping discount offer id.</param>
    /// <param name = "_offerName">The shipping discount offer name.</param>
    /// <param name = "_headingLine">Indicates if discount should be applied to header or line.</param>
    /// <param name = "_moduleType">The module that generated the <c>MarkupTrans</c> record.</param>
    [Hookable(false), Wrappable(false)] 
    protected internal void applyShippingDiscountToOrder(
        DlvModeId _dlvModeId,
        DiscPct _discPct,
        RetailOfferIdEx3 _offerId,
        Name _offerName,
        HeadingLine _headingLine,
        MarkupModule _moduleType)
    {
        // do nothing
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeCrtTransactionInstanceVariable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the channel retail table (CRT) instance variable.
    /// </summary>
    [Hookable(false), Wrappable(false)]
    protected internal void initializeCrtTransactionInstanceVariable()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getShipmentDiscountPct</Name>
				<Source><![CDATA[
    private static Microsoft.Dynamics.Commerce.Runtime.DataModel.DiscountLine getShipmentDiscountPct(Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesTransaction _crtSalesTransaction)
    {
        Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesLine crtSalesLine;
        CLRObject clrSalesLines, enumeratorSalesLine;
    
        clrSalesLines = _crtSalesTransaction.get_SalesLines();
        enumeratorSalesLine = clrSalesLines.GetEnumerator();

        while (enumeratorSalesLine.MoveNext())
        {
            crtSalesLine = enumeratorSalesLine.get_Current();

            CLRObject crtDiscountLines = crtSalesLine.get_DiscountLines();
            CLRObject enumeratorDiscountline = crtDiscountLines.GetEnumerator();

            while (enumeratorDiscountline.MoveNext())
            {
                Microsoft.Dynamics.Commerce.Runtime.DataModel.DiscountLine discountLine = enumeratorDiscountline.get_Current();

                // Only looks for shipping discount.
                if (discountLine.DiscountLineTypeValue == enum2int(RetailDiscountOriginType::Periodic)
                    && discountLine.PeriodicDiscountTypeValue == enum2int(RetailDiscountOfferTypeBase::Shipping))
                {
                    return discountLine;
                }
            }
        }
    
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeCrt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize CRT data.
    /// </summary>
    /// <param name="_channelId">
    /// Retail channel Id.
    /// </param>
    /// <param name="_custAccount">
    /// Customer account.
    /// </param>
    /// <param name="_currencyCode">
    /// Currency code.
    /// </param>
    /// <param name="_sessionDateTime">
    /// Session date time.
    /// </param>
    protected void initializeCrt(RetailChannelRecId _channelId, 
                                 CustAccount _custAccount, 
                                 CurrencyCode _currencyCode,
                                 utcDateTime _sessionDateTime = DateTimeUtil::getSystemDateTime())
    {
        currentChannel = RetailChannelTable::findByRecId(_channelId);
        customer = CustTable::find(_custAccount);

        priceIncludesTax = this.shouldPriceIncludeTax();
        exemptTaxesForPriceInclusive = priceIncludesTax && currentChannel.CalcExemptTaxesForPriceInclusive;

        transactionCurrency = _currencyCode;

        this.initializeDataAcessor();
        this.initializeCurrencyOperations(_currencyCode);
        this.initializeForDataManagerPerformance();
        
        activeDateTimeOffset = RetailPricingEngineHelper::getSessionDateTimeInChannelTimeZone(_channelId, _sessionDateTime);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeDataAcessor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the Pricing Data Accessor.
    /// </summary>
    /// <remarks>
    /// Override this method if you need to provide your own implementation of the pricing data accessor.
    /// </remarks>
    protected void initializeDataAcessor()
    {
        if (RetailPricingFeatureToggle::shouldUseRetailPricingDataManagerV3())
        {
            pricingManager = new RetailPricingDataManagerV3(currentChannel.RecId, this.getTransactionId(), tempOrderItem, true);
        }
        else
        {
            pricingManager = new RetailPricingDataManagerV2(currentChannel.RecId, this.getTransactionId(), tempOrderItem, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeCurrencyOperations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the Currency Operations.
    /// </summary>
    /// <param name = "_currencyCode">The currency that's being used in the transaction.</param>
    /// <remarks>
    /// Override this method if you need to provide your own implementation of the currency operations.
    /// </remarks>
    protected void initializeCurrencyOperations(CurrencyCode _currencyCode = CompanyInfoHelper::standardCurrency())
    {
        currencyAndRoundingHelper = new RetailCurrencyOperations(_currencyCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldPriceIncludeTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the price includes tax flag for the current channel.
    /// </summary>
    /// <returns>
    /// Returns a flag indicating whether the price should include the tax.
    /// </returns>
    protected boolean shouldPriceIncludeTax()
    {
        switch(currentChannel.ChannelType)
        {
            case RetailChannelType::MCRCallCenter:
                return customer.InclTax;

            case RetailChannelType::RetailStore:
                boolean useCustomerBasedTax = RetailStoreTable::findRecId(currentChannel.RecId).UseCustomerBasedTax;
                return  useCustomerBasedTax ? customer.InclTax : currentChannel.PriceIncludesSalesTax;

            case RetailChannelType::OnlineMarketplace:
            case RetailChannelType::OnlineStore:
            case RetailChannelType::SharePointOnlineStore:
                return currentChannel.PriceIncludesSalesTax;

            default:
                EventHandlerResult result = new EventHandlerResult();
                this.shouldPriceIncludeTaxDelegate(currentChannel, customer, result); // if a method has subscribed to this delegate invoke the method
                                                                                    // to get the priceIncludesTax flag value for the current channel
                if (result.hasResult()) // if the method is available and has a result return the result.
                {
                    return result.result();
                }
                else // if no result from the method subscribing to the delegate, return default result.
                {
                    return currentChannel.PriceIncludesSalesTax;
                }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldPriceIncludeTaxDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to determine the priceIncludesTax flag for the current channel, based on the channel type of the current channel.
    /// </summary>
    /// <param name="_channelTable">
    /// The channel specified by the current record.
    /// </param>
    /// <param name="_customer">
    /// The customer specified by the current record.
    /// </param>
    /// <param name="result">
    /// Subscribers should use this object to return true if priceIncludesTax flag should be set for the current channel; false otherwise.
    /// </param>
    delegate void shouldPriceIncludeTaxDelegate(RetailChannelTable _channelTable, CustTable _customer, EventHandlerResult result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeForDataManagerPerformance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a temporary table for data manager performance.
    /// </summary>
    protected abstract void initializeForDataManagerPerformance()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeCrtTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize Crt transaction
    /// </summary>
    /// <returns>
    /// Crt transaction.
    /// </returns>
    protected abstract Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesTransaction initializeCrtTransaction()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDiscountOnCurrentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set discount on current sales line.
    /// </summary>
    /// <remarks>
    /// The implementation is present in class <c>RetailSalesOrderCalculator</c> and <c>RetailSalesQuotationCalculator</c>.
    /// </remarks>
    abstract void setDiscountOnCurrentLine()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPriceOnCurrentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set price on current sales line.
    /// </summary>
    /// <remarks>
    /// The implementation is present in class <c>RetailSalesOrderCalculator</c> and <c>RetailSalesQuotationCalculator</c>.
    /// </remarks>
    abstract void setPriceOnCurrentLine()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPricesDiscountsOnOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set price and discount.
    /// </summary>
    /// <param name="_totalManualDiscountPercent">
    /// Total manual discount percent.
    /// </param>
    abstract void setPricesDiscountsOnOrder(DiscPct _totalManualDiscountPercent)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the transaction Id.
    /// </summary>
    /// <returns>Transaction Id.</returns>
    abstract TransactionID getTransactionId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDiscountOnCurrentLineV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get discount on current sales line.
    /// </summary>
    /// <param name = "calculateSimpleDiscountsOnly">The value indicating whether to calculate simple discount only.</param>
    /// <returns>Gets discount amount for current line.</returns>
    /// <remarks>
    /// The implementation is present in class <c>RetailSalesOrderCalculator</c> and <c>RetailSalesQuotationCalculator</c>.
    /// </remarks>
    public DiscAmount getDiscountOnCurrentLineV2(boolean calculateSimpleDiscountsOnly)
    {
        DiscAmount unitDiscount, totalDiscount = 0.0;
        Qty totalQuantity;
    
        Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesLine crtSalesLine;
        CLRObject clrSalesLines, enumeratorSalesLine;
        str lineId;

        this.calculateDiscountsForOrderV2(calculateSimpleDiscountsOnly);
    
        tmpOrderItemInitialized = false;
    
        clrSalesLines = crtSalesTransaction.get_SalesLines();
        enumeratorSalesLine = clrSalesLines.GetEnumerator();
        // Go through all sales lines until the current sales line is found
        while (enumeratorSalesLine.MoveNext())
        {
            crtSalesLine = enumeratorSalesLine.get_Current();
            lineId = crtSalesLine.get_LineId();
            if (lineId == crtLineIdCurrentLine)
            {
                totalDiscount = crtSalesLine.get_DiscountAmount();
                totalQuantity = crtSalesLine.get_Quantity();
    
                unitDiscount = (totalQuantity == 0.0) ? 0.0 : (totalDiscount / totalQuantity);
                return unitDiscount;
            }
        }
    
        return unitDiscount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDiscountOnCurrentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets discount amount on current sales line.
    /// </summary>
    /// <returns>Gets discount amount for current line.</returns>
    /// <remarks>
    /// The implementation is present in class <c>RetailSalesOrderCalculator</c> and <c>RetailSalesQuotationCalculator</c>.
    /// </remarks>
    public DiscAmount getDiscountOnCurrentLine()
    {
        return this.getDiscountOnCurrentLineV2(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new instance of <c>RetailOrderCalculator</c> using the plugin framework to decice which implementation will be instantiated.
    /// </summary>
    /// <param name="_tableId">
    /// The TableId of the target table.
    /// </param>
    /// <param name="_salesId">
    /// The primary key of the table.
    /// </param>
    /// <param name="_currentSalesPurchLine">
    /// The line of the transaction.
    /// </param>
    /// <returns>
    /// An instance of <c>RetailOrderCalculator</c>.
    /// </returns>
    public static RetailOrderCalculator construct(TableId _tableId, SalesIdBase _salesId, SalesPurchLine _currentSalesPurchLine = null)
    {
        if (prmIsDefault(_currentSalesPurchLine))
        {
            if (_tableId == tableNum(SalesTable))
            {
                SalesLine emptySalesLine; // "empty" buffer to satisfy the createOrderCalculator parameter.
                _currentSalesPurchLine = emptySalesLine;
            }
            else if (_tableId == tableNum(SalesQuotationTable))
            {
                SalesQuotationLine emptyQuotationLine; // "empty" buffer to satisfy the createOrderCalculator parameter.
                _currentSalesPurchLine = emptyQuotationLine;
            }
        }
        
        return RetailOrderCalculator::constructWithDateType(_tableId, _salesId, _currentSalesPurchLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructWithDateType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new instance of <c>RetailOrderCalculator</c> using the plugin framework to decice which implementation will be instantiated.
    /// </summary>
    /// <param name="_tableId">
    /// The TableId of the target table.
    /// </param>
    /// <param name="_salesId">
    /// The primary key of the table.
    /// </param>
    /// <param name="_currentSalesPurchLine">
    /// The line of the transaction.
    /// </param>
    /// <param name="_dateType">
    /// Date type.
    /// </param>
    /// <returns>
    /// An instance of <c>RetailOrderCalculator</c>.
    /// </returns>
    internal static RetailOrderCalculator constructWithDateType(
        TableId _tableId,
        SalesIdBase _salesId,
        SalesPurchLine _currentSalesPurchLine,
        SalesPriceDateType _dateType = SalesPriceDateType::Today)
    {
        if (prmIsDefault(_dateType))
        {
            return RetailPricingCalculatorCreator::getInstance().createOrderCalculator(_tableId, _salesId, _currentSalesPurchLine);
        }
        else
        {
            return RetailPricingCalculatorCreator::getInstance().createOrderCalculatorBasedOnDateType(_tableId, _salesId, _currentSalesPurchLine, _dateType);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSalesPrice</Name>
				<Source><![CDATA[
	/// <summary>
    /// Copies the sales price from the CRT SalesLine to the AX corresponding table.
    /// </summary>
    /// <param name = "_crtSalesLine">CRT sales line.</param>
    /// <param name = "_retailOrderLineMap">Retail order/quotation header information.</param>
    protected void setSalesPrice(Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesLine _crtSalesLine, RetailOrderLineMap _retailOrderLineMap)
    {
        Price price = _crtSalesLine.get_Price();
        _retailOrderLineMap.SalesPrice = price;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxExemptPriceInclusiveValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies the original price before exempted taxes and the exempted tax amount to the AX corresponding table.
    /// </summary>
    /// <param name = "_crtSalesLine">CRT sales line.</param>
    /// <param name = "_retailOrderLineExtensionMap">Retail order/quotation line information.</param>
    protected void setTaxExemptPriceInclusiveValues(
        Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesLine _crtSalesLine,
        RetailOrderLineExtensionMap _retailOrderLineExtensionMap)
    {
        RetailTaxExemptOriginalPrice taxExemptPriceInclusiveOriginalPrice = _crtSalesLine.get_TaxExemptPriceInclusiveOriginalPrice();
        RetailTaxExemptReductionAmount taxExemptPriceInclusiveReductionAmount = _crtSalesLine.get_TaxExemptPriceInclusiveReductionAmount();

        _retailOrderLineExtensionMap.TaxExemptPriceInclusiveOriginalPrice = taxExemptPriceInclusiveOriginalPrice;
        _retailOrderLineExtensionMap.TaxExemptPriceInclusiveReductionAmount = taxExemptPriceInclusiveReductionAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUnitDiscountAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get unit discount amount from CRT sales line.
    /// </summary>
    /// <param name = "_crtSalesLine">CRT sales line.</param>
    /// <returns>Unit discount amount.</returns>
    protected RetailDiscAmount getUnitDiscountAmount(Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesLine _crtSalesLine)
    {
        Qty qty = _crtSalesLine.get_Quantity();
        RetailDiscAmount discountAmount = _crtSalesLine.get_DiscountAmount();
        RetailDiscAmount unitDiscountAmount = qty != 0.0 ? discountAmount / qty : 0.0;
        return unitDiscountAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertCrtPriceLinePriceMethodToDiscountMethodEnum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Map price method from crtPriceLine to RetailDiscountOfferLineDiscMethodBase enum equivalent.
    /// </summary>
    /// <param name = "_priceMethod">Price method code from crtPriceLine.</param>
    /// <returns>Price method from <c>RetailDiscountOfferLineDiscMethodBase</c>.</returns>
    protected RetailDiscountOfferLineDiscMethodBase convertCrtPriceLinePriceMethodToDiscountMethodEnum(Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceMethod _priceMethod)
    {
        switch(_priceMethod)
        {
            case Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceMethod::Fixed:
                return RetailDiscountOfferLineDiscMethodBase::Price;
            case Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceMethod::AmountOff:
                return RetailDiscountOfferLineDiscMethodBase::AmountOff;
            default:
                return RetailDiscountOfferLineDiscMethodBase::PercentOff;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRetailSalesPurchLineMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize retail order/quotation lines.
    /// </summary>
    /// <param name = "_retailSalesPurchLineMap">Retail order/quotation line information.</param>
    /// <param name = "_retailOrderLineMap">Retail order/quotation header information.</param>
    /// <param name = "_crtSalesLine">CRT sales line</param>
    /// <returns>Retail order/quotation line information.</returns>
    protected RetailSalesPurchLineMap initRetailSalesPurchLineMap(RetailSalesPurchLineMap _retailSalesPurchLineMap, RetailOrderLineMap _retailOrderLineMap, Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesLine _crtSalesLine)
    {
        _retailSalesPurchLineMap.LineId = _retailOrderLineMap.RecId;
        _retailSalesPurchLineMap.Catalog = _crtSalesLine.get_CatalogId();
        _retailSalesPurchLineMap.LineManualDiscountAmount = _crtSalesLine.get_LineManualDiscountAmount();;
        _retailSalesPurchLineMap.PeriodicDiscount = _crtSalesLine.get_PeriodicDiscount();
        _retailSalesPurchLineMap.PeriodicPercentageDiscount = _crtSalesLine.get_PeriodicPercentageDiscount();
        _retailSalesPurchLineMap.LineDscAmount = _crtSalesLine.get_LineDiscount();
        _retailSalesPurchLineMap.LinePercentageDiscount = _crtSalesLine.get_LinePercentageDiscount();
        _retailSalesPurchLineMap.TotalDiscount = _crtSalesLine.get_TotalDiscount();
        _retailSalesPurchLineMap.TotalPctDiscount = _crtSalesLine.get_TotalPercentageDiscount();
        return _retailSalesPurchLineMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRetailSalesQuotesDiscountLineMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize Retail discount line.
    /// </summary>
    /// <param name = "_retailOrderLineMap">Retail order/quotation header information.</param>
    /// <param name = "_crtDiscountLine">CRT discount line.</param>
    /// <param name = "_discountLine">Retail sales/quotation discount line information.</param>
    /// <returns>Retail sales/quotation discount line information.</returns>
    protected RetailSalesQuotesDiscountLineMap initRetailSalesQuotesDiscountLineMap(RetailSalesQuotesDiscountLineMap _discountLine, RetailOrderLineMap _retailOrderLineMap, Microsoft.Dynamics.Commerce.Runtime.DataModel.DiscountLine _crtDiscountLine)
    {
        // We cannot declare a map object, so use clear() method instead.
        _discountLine.clear();
        _discountLine.InventTransId = _retailOrderLineMap.InventTransId;
        _discountLine.Amount = _crtDiscountLine.get_EffectiveAmount();
        _discountLine.DealPrice = _crtDiscountLine.get_DealPrice();
        _discountLine.DiscountAmount = _crtDiscountLine.get_Amount();
        _discountLine.Percentage = _crtDiscountLine.get_Percentage();
        if (_crtDiscountLine.get_DiscountCode() != null)
        {
            _discountLine.DiscountCode = _crtDiscountLine.get_DiscountCode();
        }
        _discountLine.DiscountOriginType = _crtDiscountLine.get_DiscountLineTypeValue();
        _discountLine.CustomerDiscountType = _crtDiscountLine.get_CustomerDiscountTypeValue();
        _discountLine.ManualDiscountType = _crtDiscountLine.get_ManualDiscountTypeValue();
        _discountLine.BundleId = _crtDiscountLine.BundleId;
        if (_crtDiscountLine.get_OfferId() != null)
        {
            _discountLine.PeriodicDiscountOfferId = _crtDiscountLine.get_OfferId();
        }

        return _discountLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRetailSalesPriceAdjustmentLineMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize Price Adjustment line.
    /// </summary>
    /// <param name = "_adjustmentLine">Retail price adjustment line information.</param>
    /// <param name = "_retailOrderLineMap">Retail order/quotation header information.</param>
    /// <param name = "_crtPriceLine">CRT price line.</param>
    /// <returns>Retail price adjustment line information.</returns>
    protected RetailSalesPriceAdjustmentLineMap initRetailSalesPriceAdjustmentLineMap(RetailSalesPriceAdjustmentLineMap                       _adjustmentLine, 
                                                                                      RetailOrderLineMap                                      _retailOrderLineMap, 
                                                                                      Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceLine _crtPriceLine)
    {
        _adjustmentLine.InventTransId                      = _retailOrderLineMap.InventTransId;
        _adjustmentLine.OfferId                            = _crtPriceLine.get_OriginId();
        _adjustmentLine.Amount                             = _crtPriceLine.get_Value();
        _adjustmentLine.DiscountMethod                     = this.convertCrtPriceLinePriceMethodToDiscountMethodEnum(_crtPriceLine.get_PriceMethod());
        _adjustmentLine.RetailPeriodicDiscountLineRefRecId = _crtPriceLine.get_RecordId();
        
        return _adjustmentLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRetailOrderLineMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize sales/quotation lines.
    /// </summary>
    /// <param name = "_retailOrderLineMap">Retail order/quotation header information.</param>
    /// <param name = "_crtSalesLine">CRT sales line.</param>
    /// <returns>Retail order/quotation header information</returns>
    /// <remarks>
    /// The implementation is present in class <c>RetailSalesOrderCalculator</c> and <c>RetailSalesQuotationCalculator</c>.
    /// </remarks>
    abstract RetailOrderLineMap initRetailOrderLineMap(RetailOrderLineMap _retailOrderLineMap, Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesLine _crtSalesLine)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructDefault</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new instance of <c>RetailOrderCalculator</c> using the default implementation.
    /// </summary>
    /// <param name="_tableId">
    /// The TableId of the target table.
    /// </param>
    /// <param name="_salesId">
    /// The primary key of the table.
    /// </param>
    /// <param name="_currentSalesPurchLine">
    /// The line of the transaction.
    /// </param>
    /// <returns>
    /// An instance of <c>RetailOrderCalculator</c> or null if no matching calculator is found.
    /// </returns>
    /// <remarks>
    /// Internal usage only.
    /// </remarks>
    internal static RetailOrderCalculator constructDefault(TableId _tableId, SalesIdBase _salesId, SalesPurchLine _currentSalesPurchLine)
    {
        if (tableNum(SalesTable) == _tableId || tableNum(SalesLine) == _tableId)
        {
            return RetailSalesOrderCalculator::constructDefault(_salesId, _currentSalesPurchLine);
        }
        else if (tableNum(SalesQuotationTable) == _tableId || tableNum(SalesQuotationLine) == _tableId)
        {
            return RetailSalesQuotationCalculator::constructDefault(_salesId, _currentSalesPurchLine);
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructDefaultWithDateType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new instance of <c>RetailOrderCalculator</c> using the default implementation.
    /// </summary>
    /// <param name="_tableId">
    /// The TableId of the target table.
    /// </param>
    /// <param name="_salesId">
    /// The primary key of the table.
    /// </param>
    /// <param name="_currentSalesPurchLine">
    /// The line of the transaction.
    /// </param>
    /// <param name="_dateType">
    /// Date type.
    /// </param>
    /// <returns>
    /// An instance of <c>RetailOrderCalculator</c> or null if no matching calculator is found.
    /// </returns>
    /// <remarks>
    /// Internal usage only.
    /// </remarks>
    internal static RetailOrderCalculator constructDefaultWithDateType(TableId _tableId, SalesIdBase _salesId, SalesPurchLine _currentSalesPurchLine, SalesPriceDateType _dateType)
    {
        if (tableNum(SalesTable) == _tableId || tableNum(SalesLine) == _tableId)
        {
            return RetailSalesOrderCalculator::constructDefaultWithDateType(_salesId, _currentSalesPurchLine, _dateType);
        }
        else if (tableNum(SalesQuotationTable) == _tableId || tableNum(SalesQuotationLine) == _tableId)
        {
            return RetailSalesQuotationCalculator::constructDefault(_salesId, _currentSalesPurchLine);
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSalesLineByDlvMode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a map of <c>SalesLine</c> grouped by delivery mode.
    /// </summary>
    /// <param name = "_crtSalesTransaction">The CRT transaction.</param>
    /// <returns>Map of <c>SalesLine</c> by delivery mode.</returns>
    private static Map buildSalesLineByDlvMode(Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesTransaction _crtSalesTransaction)
    {
        Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesLine crtSalesLine;
        CLRObject clrSalesLines, enumeratorSalesLine;

        clrSalesLines = _crtSalesTransaction.get_SalesLines();
        enumeratorSalesLine = clrSalesLines.GetEnumerator();

        Map salesLineMap = new Map(Types::String, Types::Class);

        while (enumeratorSalesLine.MoveNext())
        {
            crtSalesLine = enumeratorSalesLine.get_Current();

            if (!RetailPricingKillSwitch::disableRecalculateShippingDiscount())
            {
                // The charge should be calculated whenever this is called, and is not related to whether the sales line is locked.
                // The criteria in DiscountCalculableSalesLines will still apply.
                crtSalesLine.IsPriceLocked = false;
            }

            str dlvMode = crtSalesLine.get_DeliveryMode() == null ? '' : crtSalesLine.get_DeliveryMode();

            CLRObject salesLineList;

            if (salesLineMap.exists(dlvMode))
            {
                salesLineList = salesLineMap.lookup(dlvMode);
            }
            else
            {
                System.Object newCrtSalesLine = new Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesLine();
                salesLineList = Microsoft.Dynamics.Commerce.Runtime.Services.PricingEngine.TypeHelperForAx::CreateListOfType(newCrtSalesLine.GetType());
                salesLineList.Clear();
            }
            salesLineList.Add(crtSalesLine);
            salesLineMap.insert(dlvMode, salesLineList);
        }

        return salesLineMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setEngineAndDataAccessorInfoInTelemetry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set pricing engine and data accessor info into the telemetry.
    /// </summary>
    /// <param name = "_event">Map holding extended data to be logged in telemetry.</param>
    protected void setEngineAndDataAccessorInfoInTelemetry(Map _extendedDataMap)
    {
        _extendedDataMap.add(RetailPricingInstrumentationSegmentConstants::PricingEngineProviderName, 'Commerce');
        if (RetailPricingFeatureToggle::shouldUseRetailPricingDataManagerV3())
        {
            _extendedDataMap.add(RetailPricingInstrumentationSegmentConstants::PricingDataAccessorName, 'Flattened');
        }
        else if (FeatureStateProvider::isFeatureEnabled(RetailPricingPropertyFeature::instance()))
        {
            _extendedDataMap.add(RetailPricingInstrumentationSegmentConstants::PricingDataAccessorName, 'Property based');
        }
        else
        {
            _extendedDataMap.add(RetailPricingInstrumentationSegmentConstants::PricingDataAccessorName, 'Legacy');
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>