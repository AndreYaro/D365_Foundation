<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TradeTotals</Name>
	<SourceCode>
		<Declaration><![CDATA[
abstract class  TradeTotals
extends TradeTotalsBase
{
    #Retail
    Common              orderTable;
    Common              orderTableMarkup;
    Common              orderLine;

    RecordSortedList    recordSortedListLine;

    // Used by the costValue and updateQuantities methods and initialized in calc() for item based lines.
    InventTable         inventTable;

    UnitQty             qty;

    PdsCWInventQty      pdsCWQty;
    PdsCWInventQty      pdsCWQtyRemain;

    InventQty           qtyRemainInvent;
    Weight              weight;
    private GrossWeight grossWeight;

    Weight              grossWeightRemainInvent;
    Weight              weightRemainInvent;
    Volume              volume;
    Volume              volumeRemainInvent;

    CostAmount          costValue;
    AmountMST           freeValue;

    DiscAmount          lineDisc;
    DiscAmount          endDisc;
    DiscAmount          cashDisc;

    AmountCur           balance;
    Map                 orderBalances;
    Map                 endDiscBalances;
    Map                 lineRoundedOrderBalances;
    Map                 lineBalanceAdjustments;
    Map                 lineMarkupTotalAmounts;
    Map                 recIdLinesToAdjust;
    MarkupAmount        markupLineAmount;
    MarkupAmount        markupTableAmount;
    TaxAmountCur        taxTotal;
    RoundOff            roundOff;
    AmountCur           totalAmount;
    AmountCur           totalAmountUnRounded;
    AmountCur           totalAmountAddition;

    InventQty           remainInventPhysicalNow;

    Tax                 tax;

    boolean             calculateCostValue;
    boolean             calculateBalance;
    boolean             calculateMarkupLineAmount;
    boolean             calculateMarkupTableAmount;
    boolean             calculateQuantities;
    boolean             calculateRemainQuantities;
    boolean             calculateTaxAmount;

    boolean             costValueCalculated;
    boolean             balanceCalculated;
    boolean             markupLineAmountCalculated;
    boolean             markupTableAmountCalculated;
    boolean             markupTableAmountTaxCalculated;
    boolean             quantitiesCalculated;
    boolean             remainQuantitiesCalculated;
    boolean             taxAmountCalculated;

    boolean             freeValueCalculated;
    boolean             cashDiscCalculated;
    boolean             totalAmountUnRoundedCalculated;
    boolean             roundOffCalculated;
    boolean             endDiscCalculated;
    boolean             totalAmountCalculated;
    boolean             isCreditNoteCalculated;

    AmountCur           totalCashDisc;
    boolean             onlyOneCashDiscOnInvoice;
    boolean             isCreditNote;
    boolean             skipTaxCalculations;
    // Used to keep track of absolute value of order balances
    Map                 mcrOrderBalancesAbsoluteValue;
    AmountCur           mcrBalanceAbsoluteValue;

    boolean             endDiscCalculatedUnRounded;
    real                exdDiscountAmountUnRounded;

    Map                 lineEndDiscBalances;
    RecId               recIdRecordToAdjustTaxBase;
    boolean             endDiscLinesCalculated;

    AmountCur           lineAmountForRecordToAdjustTaxBase;
    AmountCur           endDiscLines;
    AmountCur           endDiscLinesDiff;

    // <GEERU>
    TaxAmount           totalTax_W;
    Map                 markupLineDetails;
    boolean             countryRegion_RU;
    // </GEERU>
    // <GIN>
    str                 formName;
    TaxWithholdCalculation_IN   taxWithholdCalculation;
    TaxWithhold_IN      taxWithholdIN;
    TaxAmountCur        taxWithholdTotal;
    // </GIN>
    // <GIN><GEERU>
    #ISOCountryRegionCodes
    // </GEERU></GIN>

    // Instrumentation
    protected int64   runTimeCalcTotals;
    protected int64   runTimeCalcTaxTotals;
    protected int64   runTimeCalcMarkupTotals;
    protected int64   runTimeCalcDiscountTotals;
    protected int     numberOfOrderLines;
    protected int     numberOfTaxLines;
    protected int     numberOfMarkupTrans;

    // <GEERU>
    SalesInvoicePostingType_RU          salesInvoicePostingType;
    GoodsInRouteId_RU                   goodsInRouteId;

    boolean                             calculateTotalsBySigns_RU;

    #define.totalSigns_RU(2)
    #define.positiveSignIndex_RU(1)
    #define.negativeSignIndex_RU(2)
    Map                                 endDiscBalancesBySign_RU; // [sign, percent] -> amount
    AmountCur                           totalAmountBySign_RU[#totalSigns_RU],
                                        totalAmountUnroundedBySign_RU[#totalSigns_RU],
                                        roundOffBySign_RU[#totalSigns_RU],
                                        balanceBySign_RU[#totalSigns_RU],
                                        endDiscBySign_RU[#totalSigns_RU],
                                        markupLineAmountBySign_RU[#totalSigns_RU],
                                        markupTableAmountBySign_RU[#totalSigns_RU],
                                        taxTotalBySign_RU[#totalSigns_RU],
                                        totalAmountAdditionBySign_RU[#totalSigns_RU];
    boolean                             totalAmountBySignCalculated_RU,
                                        totalAmountUnRoundedBySignCalculated_RU,
                                        roundOffBySignCalculated_RU,
                                        endDiscBySignCalculated_RU;
    // </GEERU>

    // <GBR>
    MarkupAmount                        markupFreightAmountCur_BR;
    MarkupAmount                        markupInsuranceAmountCur_BR;
    MarkupAmount                        markupOthersAmountCur_BR;
    MarkupAmount                        markupTotalAmountMST_BR;

    OrderBalanceMST                     productsTotalAmount_BR;
    OrderBalanceMST                     servicesTotalAmount_BR;

    CurrencyCode                        salesTaxCurrency_BR;
    // </GBR>

    boolean                             lineMarkupTransExist;
    boolean                             lineMarkupTransExistSet;
    boolean                             tableMarkupTransExist;
    boolean                             tableMarkupTransExistSet;
    Map                                 inventTableModuleCached;

    // Add fields that will be shown in totals form here and update lastPos appropriately.

    #define.posQty                      (1)
    #define.posWeight                   (2)
    #define.posVolume                   (3)
    #define.posCashDisc                 (4)
    #define.posCostValue                (5)
    #define.posContributionMargin       (6)
    #define.posContributionRatio        (7)
    #define.posCurrency                 (8)
    #define.posExchRate                 (9)
    #define.posCreditMax                (10)
    #define.posFreeValue                (11)
    #define.posLineDisc                 (12)
    #define.posEndDisc                  (13)
    #define.posBalance                  (14)
    #define.posMarkup                   (15)
    #define.posTaxTotal                 (16)
    #define.posRoundOff                 (17)
    #define.posTotalAmount              (18)
    #define.posPdsCWQty                 (19)
    // <GBR>
    #define.posICMSTotal_BR             (20)
    #define.posIPITotal_BR              (21)
    #define.posPISTotal_BR              (22)
    #define.posCOFINSTotal_BR           (23)
    #define.posImportTaxTotal_BR        (24)
    #define.posISSTotal_BR              (25)
    #define.posINSSTotal_BR             (26)
    #define.posIRRFTotal_BR             (27)
    #define.posRetainedINSSTotal_BR     (28)
    #define.posMarkupFreight_BR         (29)
    #define.posMarkupInsurance_BR       (30)
    #define.posMarkupOther_BR           (31)
    #define.posCSLLTotal_BR             (46)
    #define.posICMSSTTotal_BR           (47)
    #define.posICMSDiffTotal_BR         (48)
    #define.posSalesTaxCurrency_BR      (49)
    // </GBR>
    #define.posWithholdTCSTaxTotal_IN   (50)
    #define.mcrPosReturnBalanceAmount                (32)
    #define.mcrPosReturnDiscountTotal                (33)
    #define.mcrPosReturnDiscountTotal                (34)
    #define.mcrPosReturnMarkup                       (35)
    #define.mcrPosReturnTaxTotal                     (36)
    #define.mcrPosReturnTotalAmount                  (37)
    #define.mcrPostotalCoupon                        (38)
    #define.mcrPosReturnInstallmentTotal             (39)
    #define.mcrPosReturnInstallmentMarkUpLine        (40)
    #define.mcrPosReturnInstallmentTax               (41)
    #define.mcrPosReturnInstallmentMarkUpCoupon      (42)
    #define.mcrPosReturnInstallmentMarkUpTotal       (43)
    #define.mcrPosInstallmentLineDisc                (44)
    #define.mcrPosEndInstallmentDisc                 (45)
    #define.lastPos                     (#posWithholdTCSTaxTotal_IN)
    #define.numPos                      (#lastPos)
    // returnBalance holds the product total of the return side of the sales order
    AmountCur           returnBalance;
    MarkupAmount        markupReturnLineAmount;
    Map                 returnEndDiscBalances;
    DiscAmount          returnEndDisc;
    boolean             returnEndDiscCalculated;
    boolean             returnTotalAmountCalculated;
    boolean             returnTotalAmountUnRoundedCalculated;
    AmountCur           returnTotalAmount;
    AmountCur           returnTotalAmountUnRounded;
    RoundOff            returnRoundOff;
    boolean             returnRoundOffCalculated;
    TaxAmountCur        returnTaxTotal;
    MarkupAmount        markupCoupon;
    boolean             calcInstallEligibleHeaderAmts;
    boolean             endInstallmentDiscCalculated;
    AmountCur           returnInstallmentBalance;
    TaxAmountCur        returnInstallmentTax;
    TaxAmountCur        markupInstalTax;
    MarkUpAmount        markUpInstallmentCoupon;
    MarkUpAmount        markUpInstallmentLineAmount;
    MarkupAmount        markUpInstallEligTotalAmt;
    Map                 endDiscInstallmentBalances;
    Map                 returnEndDiscInstalBalances;
    DiscAmount          lineInstallmentDisc;
    DiscAmount          endInstallmentDisc;
    DiscAmount          cashInstallmentDisc;
    boolean             isTaxIncluded;
    boolean             trackUnroundedBalances;
    // Record lists to store sales lines that are install eligible and markups.
    RecordSortedList    recordSortedInstallmentListLine;
    RecordSortedList    recordSortedInstallEligMarkupLines;

    // <GTE>
    TaxAmountCur        taxTotalGTE;
    TaxAmountCur        taxTotalReverseCharge;
    // </GTE>

    private TradeInstrumentationLogger instrumentationLogger;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addMarkupLineDetails_RU</Name>
				<Source><![CDATA[
    protected void addMarkupLineDetails_RU(Common _record, MarkupAmount _markupAmount)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustEndDiscBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the total discount line amount.
    /// </summary>
    /// <remarks>
    /// If total discount per line summarized is not equal to the total discount for the order the total discount per line
    /// is adjusted for the nominally largest order line with the difference.
    /// </remarks>
    private void adjustEndDiscBalance()
    {
        AmountCur   lineEndDiscBalance;
        AmountCur   amountTotalDiscountLines, amountTotalDiscount;

        TradeInstrumentationStopwatch stopWatch = TradeInstrumentationStopwatch::newStopwatch();

        amountTotalDiscount = this.totalEndDisc();
        amountTotalDiscountLines = this.totalEndDiscLines();

        if (!isTaxIncluded && amountTotalDiscount != amountTotalDiscountLines)
        {
            endDiscLinesDiff = amountTotalDiscount - amountTotalDiscountLines;
            lineEndDiscBalance =  this.lineEndDiscBalance(recIdRecordToAdjustTaxBase);
            lineEndDiscBalance += endDiscLinesDiff;
            lineEndDiscBalances.insert(recIdRecordToAdjustTaxBase, lineEndDiscBalance);
        }

        runTimeCalcDiscountTotals += stopWatch.elapsedMilliseconds();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateLineBalanceAdjustmentsForPricesInclTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the lines to match the subtotal.
    /// </summary>
    /// <remarks>
    /// If the sum of the line subtotals doesn't match the order subtotal, we need to adjust the nominally largest order line with the difference.
    /// This difference can happen due to rounding when the subtotal is calculated back from the tax if it's included in the price.
    /// </remarks>
    private void calculateLineBalanceAdjustmentsForPricesInclTax()
    {
        if (!trackUnroundedBalances)
        {
            return;
        }

        var orderRecIdEnumerator = orderBalances.getEnumerator();

        while (orderRecIdEnumerator.moveNext())
        {
            AmountCur expectedBalance = orderBalances.lookup(orderRecIdEnumerator.currentKey());
            AmountCur lineRoundedOrderBalance = lineRoundedOrderBalances.lookup(orderRecIdEnumerator.currentKey());
            RecId     adjustedLineRecId;
            AmountCur adjustedLineBalance;

            if (lineRoundedOrderBalance != expectedBalance)
            {
                AmountCur difference = expectedBalance - lineRoundedOrderBalance;
                [adjustedLineRecId, adjustedLineBalance] = recIdLinesToAdjust.lookup(orderRecIdEnumerator.currentKey());
                lineBalanceAdjustments.insert(adjustedLineRecId, difference);
                recIdLinesToAdjust.insert(orderRecIdEnumerator.currentKey(), [adjustedLineRecId, adjustedLineBalance + difference]);
                lineRoundedOrderBalances.insert(orderRecIdEnumerator.currentKey(), expectedBalance);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundBalanceMap</Name>
				<Source><![CDATA[
    protected void roundBalanceMap(Map _map)
    {
        MapEnumerator enumerator = _map.getEnumerator();

        while (enumerator.moveNext())
        {
            AmountCur value = CurrencyExchangeHelper::amount(enumerator.currentValue(), this.currencyCode());

            _map.insert(enumerator.currentKey(), value);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundBalances</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rounds the totals according to the currency rules before they are used further.
    /// We can get unrounded numbers in there to avoid precision loss when the tax is included in sales price.
    /// </summary>
    protected void roundBalances()
    {
        if (!trackUnroundedBalances)
        {
            return;
        }
        balance = CurrencyExchangeHelper::amount(balance, this.currencyCode());

        this.roundBalanceMap(orderBalances);
        this.roundBalanceMap(endDiscBalances);
        this.roundBalanceMap(endDiscInstallmentBalances);
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineValuesToCalculate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the different values to be calculated.
    /// </summary>
    protected void determineValuesToCalculate()
    {
        if (!calculateBalance           && !balanceCalculated           &&
            !calculateCostValue         && !costValueCalculated         &&
            !calculateQuantities        && !quantitiesCalculated        &&
            !calculateRemainQuantities  && !remainQuantitiesCalculated  &&
            !calculateMarkupLineAmount  && !markupLineAmountCalculated  &&
            !calculateMarkupTableAmount && !markupTableAmountCalculated &&
            !calculateTaxAmount         && !taxAmountCalculated)
        {
            calculateBalance            = true;
            calculateCostValue          = true;
            calculateQuantities         = true;
            calculateRemainQuantities   = true;
            calculateMarkupLineAmount   = true;
            calculateMarkupTableAmount  = true;
            calculateTaxAmount          = true;
        }

        if (calculateTaxAmount          && !taxAmountCalculated)
            calculateBalance = true;

        if (calculateMarkupTableAmount  && !markupTableAmountCalculated)
            calculateBalance = true;

        if (calculateBalance)
            calculateBalance            = !balanceCalculated;

        if (calculateCostValue)
            calculateCostValue          = !costValueCalculated;

        if (calculateQuantities)
            calculateQuantities         = !quantitiesCalculated;

        if (calculateRemainQuantities)
            calculateRemainQuantities   = !remainQuantitiesCalculated;

        if (calculateMarkupTableAmount)
        {
            if (this.canCalculateMarkupTable())
            {
                calculateMarkupTableAmount  = !markupTableAmountCalculated;
            }
            else
            {
                calculateMarkupTableAmount  = false;
                markupTableAmountCalculated = true;
            }
        }

        if (calculateMarkupLineAmount)
        {
            if (this.lineMarkupTransExist())
            {
                calculateMarkupLineAmount   = !markupLineAmountCalculated;
            }
            else
            {
                calculateMarkupLineAmount   = false;
                markupLineAmountCalculated  = true;
            }
        }

        if (calculateTaxAmount)
        {
            calculateTaxAmount          = !taxAmountCalculated;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeTaxCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the tax calculation.
    /// </summary>
    /// <param name = "_tradeCalcTax">An instance of the <c>TradeCalcTax</c> class.</param>
    /// <param name = "_markup">An instance of the <c>Markup</c> class.</param>
    protected void executeTaxCalculation(TradeCalcTax _tradeCalcTax, Markup _markup)
    {
        if (calculateTaxAmount)
        {
            this.calcTaxInternal(_tradeCalcTax);

            taxAmountCalculated = true;

            this.setMarkupTax(_markup);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeTaxCalculationCountryRegion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the country region specific tax calculation.
    /// </summary>
    /// <param name = "_tradeCalcTax">An instance of the <c>TradeCalcTax</c> class.</param>
    /// <param name = "_markup">An instance of the <c>Markup</c> class.</param>
    protected void executeTaxCalculationCountryRegion(TradeCalcTax _tradeCalcTax, Markup _markup)
    {
        if (calculateTaxAmount && TaxWithholdParameters_IN::checkTaxParameters())
        {
            taxWithholdIN    = new TaxWithhold_IN();
            taxWithholdTotal = _tradeCalcTax.calcWithholdTax_IN(this);
            this.taxWithholdCalculation_IN(_tradeCalcTax.taxWithholdCalculation_IN());

            if (taxWithholdCalculation != null)
            {
                taxWithholdIN.tmpTaxWithholdWorkTrans(taxWithholdCalculation.tmpTaxWithholdWorkTrans());
                taxWithholdIN.loadTaxWithholdRegulation(taxWithholdIN.tmpTaxWithholdWorkTrans());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSkipCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the calculation must be skipped.
    /// </summary>
    /// <returns>true if the calculation must be skipped; otherwise, false.</returns>
    protected boolean mustSkipCalculation()
    {
        return (!(calculateBalance              ||
                calculateCostValue            ||
                calculateQuantities           ||
                calculateRemainQuantities     ||
                calculateMarkupLineAmount     ||
                calculateMarkupTableAmount    ||
                calculateTaxAmount));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTradeCalcTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>TradeCalcTax</c> instance.
    /// </summary>
    /// <param name = "_tradeCalcTax">An instance of the <c>TradeCalcTax</c> object.</param>
    protected void initTradeCalcTax(TradeCalcTax _tradeCalcTax)
    {
        _tradeCalcTax.transferEnumerableFactory(this.parmEnumerableFactory());
        _tradeCalcTax.parmGoodsInRouteId_RU(goodsInRouteId);

        _tradeCalcTax.parmSkipLineMarkup(!calculateMarkupLineAmount && !markupLineAmountCalculated);
        _tradeCalcTax.parmSkipTableMarkup(!calculateMarkupTableAmount && !MarkupTableAmountCalculated);

        isTaxIncluded = _tradeCalcTax.isTaxIncluded();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndInitMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and initializes an instance of the <c>Markup</c> class.
    /// </summary>
    /// <returns>A <c>Markup</c> object.</returns>
    protected Markup createAndInitMarkup()
    {
        Markup markup = new Markup(this.currencyCode());
        markup.parmExchRate(this.exchRate(), this.exchRateSecondary(), Currency::noYes2UnknownNoYes(this.triangulation()));
        markup.setReportingCurrencyExchangeRate(this.reportingCurrencyExchangeRate());
        markup.parmMarkupEnumerable(this.parmEnumerableFactory().createMarkupEnumerableProvider());
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoCZ, #isoEE, #isoHU, #isoLT, #isoLV, #isoPL, #isoRU ]))
        {
            markup.transDate(this.invoiceDate());
        }
        markup.parmGoodsInRouteId_RU(goodsInRouteId);
        // </GEERU>

        return markup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateLineAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the calculation of the line amounts.
    /// </summary>
    /// <param name = "_tradeCalcTax">An instance of the <c>TradeCalcTax</c> class.</param>
    /// <param name = "_markup">An instance of the <c>Markup</c> class.</param>
    /// <param name = "_isLineEligibleForInstallment">A <c>boolean</c> value.</param>
    protected void calculateLineAmounts(TradeCalcTax _tradeCalcTax, Markup _markup, boolean _isLineEligibleForInstallment)
    {
        UnitQty         unitQty = this.qtyUnit();
        PdsCWInventQty  pdsCWUnitQty = this.pdsCWQtyUnit();
        InventQty       inventQty;
        // Initialize InventTable for item based lines.
        if (this.isCategoryBased())
        {
            inventTable = null;
        }
        else
        {
            inventTable = InventTable::find(this.itemId());
        }

        if (calculateQuantities || calculateCostValue)
        {
            // calculate the quantity in inventory units (can use inventTable for conversion)
            inventQty   = this.qtyInventoryUnits(unitQty);
        }

        if (calculateQuantities || calculateRemainQuantities)
        {
            this.updateQuantities(unitQty, inventQty, pdsCWUnitQty);
        }

        if (calculateBalance || calculateMarkupLineAmount)
        {
            AmountCur lineAmount       = this.lineAmount(unitQty, _tradeCalcTax.invoiceDate());

            if (MCROrderParameters::isCallCenterEnabledAndInUse()
                        && _isLineEligibleForInstallment)
            {
                returnInstallmentBalance+=lineAmount;
            }

            this.executeCalculateBalance(_tradeCalcTax, lineAmount, _isLineEligibleForInstallment, unitQty);

            this.executeMarkupLineAmountCalculation(_tradeCalcTax, _markup, unitQty, lineAmount);
            this.executeMarkupLineAmountCalculationCountryRegion(_tradeCalcTax, _markup, unitQty, lineAmount);

        }

        if (calculateCostValue)
        {
            costValue += this.costValue(inventQty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the different totals values.
    /// </summary>
    public void calc()
    {
        using (var activityContext = instrumentationLogger.tradeTotalsActivities().calc())
        {
            this.determineValuesToCalculate();

            if (this.mustSkipCalculation())
            {
                return;
            }

            this.logCalcVariables('PreState');

            numberOfOrderLines = 0;
            TradeInstrumentationStopWatch stopWatch = TradeInstrumentationStopwatch::newStopwatch();

            if (BrazilParameters::isEnabled())
            {
                salesTaxCurrency_BR = Ledger::accountingCurrency(CompanyInfo::current());
            }

            Markup markup;
            if (calculateMarkupLineAmount || calculateMarkupTableAmount)
            {
                this.initMarkup();
                markup = this.createAndInitMarkup();
            }

            if (calculateBalance)
            {
                balanceCalculated = true;
            }
            TradeCalcTax tradeCalcTax         = this.constructCalcTax();
            this.initTradeCalcTax(tradeCalcTax);

            trackUnroundedBalances = isTaxIncluded && (this.itemModuleType() == ModuleInventPurchSales::Sales);

            this.executeTaxCalculation(tradeCalcTax, markup);
            this.executeTaxCalculationCountryRegion(tradeCalcTax, markup);

            boolean isCallCenterEnabledAndUsed = MCROrderParameters::isCallCenterEnabledAndInUse();

            if (this.mustCalculateLineValues())
            {
                TradeTotalsIQueryRun lineQueryRun = this.createLineQueryRun();

                while (this.lineQueryRunNext(lineQueryRun))
                {
                    boolean isLineEligibleForInstallment = false;
                    using (var activityContextCalcForLine = instrumentationLogger.tradeTotalsActivities().calcForLine())
                    {
                        orderLine = this.lineQueryRunGet(lineQueryRun);
                        numberOfOrderLines++;

                        if (isCallCenterEnabledAndUsed)
                        {
                            if (!recordSortedInstallmentListLine)
                            {
                                recordSortedInstallmentListLine=this.mcrInitRecordSortedListLine(orderLine.TableId);
                            }
                            if (!recordSortedInstallEligMarkupLines)
                            {
                                recordSortedInstallEligMarkupLines = this.mcrInitRecordSortedListLine(tableNum(MarkupTrans));
                            }

                            // If the line is eligible for installment, initialize the record list
                            //       and accumulate the totals based on the eligibility.

                            if (this.mcrIsLineInstallmentEligible())
                            {
                                recordSortedInstallmentListLine.ins(orderLine);
                                isLineEligibleForInstallment = true;
                            }
                            else
                            {
                                isLineEligibleForInstallment = false;
                            }
                        }

                        if (this.skipLine(orderLine))
                        {
                            continue;
                        }

                        if (this.mustInsertIntoSortedListLine())
                        {
                            recordSortedListLine.ins(orderLine);
                        }

                        this.calculateLineAmounts(TradeCalcTax, markup, isLineEligibleForInstallment);
                    }
                }

                this.roundBalances();
            }

            if (calculateBalance)
            {
                this.calculateLineBalanceAdjustmentsForPricesInclTax();
                this.adjustEndDiscBalance();
            }

            this.markLineValuesAsCalculated();

            this.executeMarkupTableAmountCalculation(tradeCalcTax, markup);

            this.markHeaderValuesAsCalculated();

            if (isCallCenterEnabledAndUsed)
            {
                if (!calcInstallEligibleHeaderAmts)
                {
                    if (!recordSortedInstallEligMarkupLines)
                    {
                        recordSortedInstallEligMarkupLines=this.mcrInitRecordSortedListLine(tableNum(MarkupTrans));
                    }
                    if (recordSortedInstallEligMarkupLines)
                    {
                        if (markup)
                        {
                            recordSortedInstallEligMarkupLines=markup.mcrMarkupInstallEligibleList();
                        }
                    }
                    this.mcrCalculateInstallEligibleHeaderAmts();
                    calcInstallEligibleHeaderAmts=true;
                }
            }
            // <GIN>
            if (TaxParameters::checkTaxParameters_IN()
                && calculateTaxAmount
                && this.tax())
            {
                //The condition is added to allow taxOnCharges to impact markupLineAmount only if the markup Tax is not instantiated,
                //as taxOnCharges had already been deducted earlier in Markup\calc if markup Tax instance has been created.
                if (markup && !markup.getTax_IN())
                {
                    TmpTaxCalc_IN tmpTaxCalc = tax.tmpTaxCalc_IN();

                    select sum(TaxOnCharges) from tmpTaxCalc
                        where tmpTaxCalc.OrigChargeAmt == 0
                            && tmpTaxCalc.ChargeCode == '';

                    AmountCur taxOnCharges = tmpTaxCalc.TaxOnCharges;

                    if (taxOnCharges)
                    {
                        if (markupLineAmount > 0)
                        {
                            markupLineAmount -= abs(taxOnCharges);
                        }
                        else
                        {
                            markupLineAmount += abs(taxOnCharges);
                        }
                        markupLineAmount = CurrencyExchangeHelper::amount(markupLineAmount);
                    }
                }
            }
            // </GIN>

            runTimeCalcTotals = stopWatch.elapsedMilliseconds();

            this.logInstrumentationMeasures();
            this.logCalcVariables('PostState');

            this.logTaxTelemetry(activityContext);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the tax values.
    /// </summary>
    internal void calcTax()
    {
        using (var activityContext = instrumentationLogger.tradeTotalsActivities().calc())
        {
            this.logCalcVariables('PreState');

            TradeCalcTax tradeCalcTax = this.constructCalcTax();
            this.initTradeCalcTax(tradeCalcTax);
            this.calcTaxInternal(tradeCalcTax);

            this.logInstrumentationMeasures();
            this.logCalcVariables('PostState');

            this.logTaxTelemetry(activityContext);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>logCalcVariables</Name>
				<Source><![CDATA[
    private void logCalcVariables(str _calcVariablesState)
    {
        SysInstrumentationEventDataJsonSerializer serializer = new SysInstrumentationEventDataJsonSerializer();

        serializer.setValue('CalcVariables', _calcVariablesState)
            .setValue('CalculateBalance', any2Str(calculateBalance))
            .setValue('CalculateCostValue', any2Str(calculateCostValue))
            .setValue('CalculateQuantities', any2Str(calculateQuantities))
            .setValue('CalculateRemainQuantities', any2Str(calculateRemainQuantities))
            .setValue('CalculateMarkupLineAmount', any2Str(calculateMarkupLineAmount))
            .setValue('CalculateMarkupTableAmount', any2Str(calculateMarkupTableAmount))
            .setValue('CalculateTaxAmount', any2Str(calculateTaxAmount))
            .setValue('CostValueCalculated', any2Str(costValueCalculated))
            .setValue('BalanceCalculated', any2Str(balanceCalculated))
            .setValue('MarkupLineAmountCalculated', any2Str(markupLineAmountCalculated))
            .setValue('MarkupTableAmountCalculated', any2Str(markupTableAmountCalculated))
            .setValue('MarkupTableAmountTaxCalculated', any2Str(markupTableAmountTaxCalculated))
            .setValue('QuantitiesCalculated', any2Str(quantitiesCalculated))
            .setValue('RemainQuantitiesCalculated', any2Str(remainQuantitiesCalculated))
            .setValue('TaxAmountCalculated', any2Str(taxAmountCalculated))
            .setValue('FreeValueCalculated', any2Str(freeValueCalculated))
            .setValue('CashDiscCalculated', any2Str(cashDiscCalculated))
            .setValue('TotalAmountUnRoundedCalculated', any2Str(totalAmountUnRoundedCalculated))
            .setValue('RoundOffCalculated', any2Str(roundOffCalculated))
            .setValue('EndDiscCalculated', any2Str(endDiscCalculated))
            .setValue('TotalAmountCalculated', any2Str(totalAmountCalculated))
            .setValue('IsCreditNoteCalculated', any2Str(isCreditNoteCalculated))
            .setValue('EndDiscCalculatedUnRounded', any2Str(endDiscCalculatedUnRounded))
            .setValue('EndDiscLinesCalculated', any2Str(endDiscLinesCalculated))
            .setValue('ReturnEndDiscCalculated', any2Str(returnEndDiscCalculated))
            .setValue('ReturnTotalAmountCalculated', any2Str(returnTotalAmountCalculated))
            .setValue('ReturnTotalAmountUnRoundedCalculated', any2Str(returnTotalAmountUnRoundedCalculated))
            .setValue('ReturnRoundOffCalculated', any2Str(returnRoundOffCalculated))
            .setValue('EndInstallmentDiscCalculated', any2Str(endInstallmentDiscCalculated));

        instrumentationLogger.logInformation(serializer.toString());
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustInsertIntoSortedListLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to insert the line into the sorted list.
    /// </summary>
    /// <returns>true if the line must be inserted into the sorted list; otherwise, false.</returns>
    protected boolean mustInsertIntoSortedListLine()
    {
        return calculateBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeMarkupTableAmountCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Do the markup table amount calculation.
    /// </summary>
    /// <param name = "_tradeCalcTax">An instance of the <c>TradeCalcTax</c> object.</param>
    /// <param name = "_markup">An instance of the <c>Markup</c> object.</param>
    protected void executeMarkupTableAmountCalculation(TradeCalcTax _tradeCalcTax, Markup _markup)
    {
        if (calculateMarkupTableAmount)
        {
            QueryRun queryOrderTableMarkup = this.queryBuildOrderTable();

            while (queryOrderTableMarkup.next())
            {
                orderTableMarkup = this.queryGetOrderTable(queryOrderTableMarkup);
                if (!orderTableMarkup)
                {
                    continue;
                }

                if (MCROrderParameters::isCallCenterEnabledAndInUse())
                {
                    this.markupCalc(_markup,
                                1,
                                this.getMarkupTableSourceValue(orderTableMarkup),
                                this.markupTable(),
                                this.documentStatus(),
                                this.interCompanyLineAmount(1, _tradeCalcTax.invoiceDate()),
                                '',
                                this.mcrTotalOrderBalanceAbsoluteValue(orderTableMarkup.RecId),
                                this.mcrGetParmId(),
                                this.mcrGetParmTableRefId());
                }
                else
                {
                    this.markupCalc(_markup, 1, this.getMarkupTableSourceValue(orderTableMarkup), this.markupTable(), this.documentStatus());
                }

                AmountCur currentMarkupTableAmount = this.markupCustVend(_markup);
                markupTableAmount += currentMarkupTableAmount;
                // <GEERU>
                if (calculateTotalsBySigns_RU)
                {
                    markupTableAmountBySign_RU[#positiveSignIndex_RU] += _markup.parmMarkupCustVendPositive_RU();
                    markupTableAmountBySign_RU[#negativeSignIndex_RU] += _markup.parmMarkupCustVendNegative_RU();
                }
                // </GEERU>
                if (MCROrderParameters::isCallCenterEnabledAndInUse())
                {
                    markupCoupon                    += _markup.mcrMarkupCoupon();
                    markUpInstallEligTotalAmt       += _markup.mcrMarkupInstallmentCustVend();
                    markUpInstallmentCoupon         += _markup.mcrMarkupInstallmentCoupon();
                    markupInstalTax                 += _markup.mcrMarkupInstallmentTax();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMarkupTableSourceValue</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal AmountCur getMarkupTableSourceValue(Common _orderTableMarkup)
    {
        return this.totalOrderBalance(_orderTableMarkup.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCalculateLineValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the calculation of totals for lines must be done.
    /// </summary>
    /// <returns>true if the calculation of totals for lines must be done; otherwise, false.</returns>
    protected boolean mustCalculateLineValues()
    {
        return (calculateBalance
            || calculateCostValue
            || calculateQuantities
            || calculateRemainQuantities
            || calculateMarkupLineAmount
            || calculateMarkupTableAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>markLineValuesAsCalculated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set the flags for line level calculations as calculated.
    /// </summary>
    protected void markLineValuesAsCalculated()
    {
        if (calculateBalance)
        {
            balanceCalculated           = true;
        }

        if (calculateCostValue)
        {
            costValueCalculated         = true;
        }

        if (calculateQuantities)
        {
            quantitiesCalculated        = true;
        }

        if (calculateRemainQuantities)
        {
            remainQuantitiesCalculated  = true;
        }

        if (calculateMarkupLineAmount)
        {
            markupLineAmountCalculated  = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>markHeaderValuesAsCalculated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set the flags for table calculations as calculated.
    /// </summary>
    protected void markHeaderValuesAsCalculated()
    {
        if (calculateMarkupTableAmount)
        {
            markupTableAmountCalculated = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeMarkupLineAmountCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the calculation of markup line amount.
    /// </summary>
    /// <param name = "_tradeCalcTax">An instance of the <c>TradeCalcTax</c> class.</param>
    /// <param name = "_markup">An instance of the <c>Markup</c> class.</param>
    /// <param name = "_unitQty">A <c>UnitQty</c> value.</param>
    /// <param name = "_lineAmount">A <c>LineAmount</c> value.</param>
    protected void executeMarkupLineAmountCalculation(TradeCalcTax _tradeCalcTax, Markup _markup, UnitQty _unitQty, LineAmount _lineAmount)
    {
        if (calculateMarkupLineAmount && !this.mustSkipMarkupLineAmountCalculation(this.markupLine()))
        {
            this.markupCalc(_markup, _unitQty, _lineAmount, this.markupLine(), this.documentStatus(), this.interCompanyLineAmount(_unitQty, _tradeCalcTax.invoiceDate()));
            AmountCur currentMarkupLineAmount = this.markupCustVend(_markup);
            markupLineAmount += currentMarkupLineAmount;
            lineMarkupTotalAmounts.insert(orderLine.RecId, currentMarkupLineAmount);
            if (MCROrderParameters::isCallCenterEnabledAndInUse())
            {
                // If the line amount is negative, the line is a return and the line
                // charges should be added to this class variable.
                if (_lineAmount < 0)
                {
                    markupReturnLineAmount += _markup.markupCustVend();
                }
                markUpInstallmentCoupon         += _markup.mcrMarkupInstallmentCoupon();
                markUpInstallmentLineAmount     += _markup.mcrMarkupInstallmentCustVend();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeMarkupLineAmountCalculationCountryRegion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the calculation of markup line amount specific to country/region.
    /// </summary>
    /// <param name = "_tradeCalcTax">An instance of the <c>TradeCalcTax</c> class.</param>
    /// <param name = "_markup">An instance of the <c>Markup</c> class.</param>
    /// <param name = "_unitQty">A <c>UnitQty</c> value.</param>
    /// <param name = "_lineAmount">A <c>LineAmount</c> value.</param>
    protected void executeMarkupLineAmountCalculationCountryRegion(TradeCalcTax _tradeCalcTax, Markup _markup, UnitQty _unitQty, LineAmount _lineAmount)
    {
        if (calculateMarkupLineAmount)
        {
            // <GEERU>
            if (countryRegion_RU)
            {
                if (calculateTotalsBySigns_RU)
                {
                    markupLineAmountBySign_RU[#positiveSignIndex_RU] += _markup.parmMarkupCustVendPositive_RU();
                    markupLineAmountBySign_RU[#negativeSignIndex_RU] += _markup.parmMarkupCustVendNegative_RU();
                }
                this.addMarkupLineDetails_RU(this.markupLine(), this.markupCustVend(_markup));
            }
            // </GEERU>

            // <GBR>
            if (BrazilParameters::isEnabled() && _markup)
            {
                markupFreightAmountCur_BR     = _markup.markupFreight_BR()     ;
                markupInsuranceAmountCur_BR   = _markup.markupInsurance_BR()   ;
                markupOthersAmountCur_BR      = _markup.markupOther_BR()       ;
            }
            // </GBR>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupCalc</Name>
				<Source><![CDATA[
    private void markupCalc(
        Markup            _markup,
        Qty               _qty,
        AmountCur         _value,
        Common            _source,
        DocumentStatus    _documentStatus = DocumentStatus::None,
        AmountCur         _interCompanyValue = 0,
        InvoiceId         _invoiceId         = '',
        AmountCur         _absoluteValue     = 0,
        ParmId            _parmId            = '',
        TradeLineRefId    _parmMCRTableRefId  = '')
    {
        using (var activityContext = instrumentationLogger.tradeTotalsActivities().markupCalc())
        {
            TradeInstrumentationStopwatch stopWatch = TradeInstrumentationStopwatch::newStopwatch();

            _markup.calc(
                _qty,
                _value,
                _source,
                _documentStatus,
                _interCompanyValue,
                _invoiceId,
                _absoluteValue,
                _parmId,
                _parmMCRTableRefId);

            numberOfMarkupTrans += _markup.getNumberOfMarkupTransactionsInCalculation();
            runTimeCalcMarkupTotals += stopWatch.elapsedMilliseconds();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTaxInternal</Name>
				<Source><![CDATA[
    private void calcTaxInternal(TradeCalcTax _tradeCalcTax)
    {
        using (var activityContext = instrumentationLogger.tradeTotalsActivities().calcTax())
        {
            TradeInstrumentationStopwatch stopWatch = TradeInstrumentationStopwatch::newStopwatch();

            // <GTE>
            if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
            {
                this.calcGTETax();
                _tradeCalcTax.tax(TaxCalculationEmpty::getInstance(this));
            }
            // </GTE>
            else
            {
                taxTotal = _tradeCalcTax.calcTax(this);
            }

            this.tax(_tradeCalcTax.tax());

            // <GEERU>
            if (calculateTotalsBySigns_RU)
            {
                [taxTotalBySign_RU[#positiveSignIndex_RU], taxTotalBySign_RU[#negativeSignIndex_RU]] = _tradeCalcTax.totalTaxAmountBySign_RU();
            }
            // </GEERU>

            this.updateNumberOfTaxLines(_tradeCalcTax);

            runTimeCalcTaxTotals += stopWatch.elapsedMilliseconds();

            this.logTaxTelemetry(activityContext);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcGTETax</Name>
				<Source><![CDATA[
     /// <summary>
    /// Calcluates GTE tax amount when GTE enabled.
    /// </summary>
    protected void calcGTETax()
    {
        // <GTE>
        ITaxableDocument taxableDocument = TaxableDocumentObject::construct(this.parmTaxableDocumentDescriptor());
        ITaxDocument taxDocumentObject = TaxBusinessService::calculateTax(taxableDocument);

        if (taxDocumentObject)
        {
            ITaxDocumentMeasureValue totalTaxMeasureValue = taxDocumentObject.getTotalTax();
            taxTotalGTE = taxTotal + totalTaxMeasureValue.amountTransactionCurrency();

            ITaxDocumentMeasureValue partyTaxMeasureValue = taxDocumentObject.sumByTaxAccountingProvider(TaxAccountingProvider::Party, TaxAccountingPostingProfileDistributionSide::Debit);
            taxTotal += partyTaxMeasureValue.amountTransactionCurrency();

            partyTaxMeasureValue = taxDocumentObject.sumByTaxAccountingProvider(TaxAccountingProvider::Party, TaxAccountingPostingProfileDistributionSide::Credit);
            taxTotal -= partyTaxMeasureValue.amountTransactionCurrency();

            taxTotalReverseCharge = TaxDocumentUtils::calculateTaxTotalReverseCharge(taxDocumentObject);
        }
        else
        {
            taxTotalGTE = taxTotal;
        }
        // </GTE>
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeCalculateBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the balance calculation.
    /// </summary>
    /// <param name = "_tradeCalcTax">An instance of the <c>TradeCalcTax</c> class.</param>
    /// <param name = "_lineAmount">The line amount value for the calculations.</param>
    /// <param name = "_isLineEligibleForInstallment">A boolean value</param>
    /// <param name = "_unitQty">The unit quantity.</param>
    protected void executeCalculateBalance(TradeCalcTax _tradeCalcTax, LineAmount _lineAmount, boolean _isLineEligibleForInstallment, UnitQty _unitQty)
    {
        if (calculateBalance)
        {
            this.updateOrderBalances(_lineAmount);

            TradeInstrumentationStopWatch stopWatchLineDiscount = TradeInstrumentationStopwatch::newStopwatch();
            if (this.mustUpdateEndDisc())
            {
                this.updateEndDiscBalances(_lineAmount);
                this.updateLineEndDiscBalances(_lineAmount);
            }
            if (MCROrderParameters::isCallCenterEnabledAndInUse()
                            && _isLineEligibleForInstallment)
            {
                this.mcrUpdateEndDiscInstallmentBalances(_lineAmount);
                lineInstallmentDisc += this.lineDiscAmount(_unitQty, _tradeCalcTax.invoiceDate());
            }

            if (this.lineHasDiscount())
            {
                lineDisc += this.lineDiscAmount(_unitQty, _tradeCalcTax.invoiceDate());
            }
            runTimeCalcDiscountTotals += stopWatchLineDiscount.elapsedMilliseconds();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNumberOfTaxLines</Name>
				<Source><![CDATA[
    private void updateNumberOfTaxLines(TradeCalcTax _tradeCalcTax)
    {
        if (_tradeCalcTax is SalesCalcTax_Sales)
        {
            SalesCalcTax_Sales salesCalcTaxSales = _tradeCalcTax as SalesCalcTax_Sales;
            numberOfTaxLines += salesCalcTaxSales.getNumberOfTaxLines();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>logInstrumentationMeasures</Name>
				<Source><![CDATA[
    /// <summary>
    /// Logs instrumentation measures.
    /// </summary>
    protected void logInstrumentationMeasures()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setMarkupTax</Name>
				<Source><![CDATA[
    public void setMarkupTax(Markup _markup)
    {
        if (calculateMarkupLineAmount || calculateMarkupTableAmount)
        {
            _markup.setTax(tax);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateBalance</Name>
				<Source><![CDATA[
    private void calculateBalance()
    {
        if (!balanceCalculated)
        {
            this.prepareBalanceCalculation();
            this.calc();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateCostValue</Name>
				<Source><![CDATA[
    private void calculateCostValue()
    {
        if (!costValueCalculated)
        {
            this.prepareCostValueCalculation();
            this.calc();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculatedEndDiscBalance</Name>
				<Source><![CDATA[
    public DiscAmount  calculatedEndDiscBalance()
    {
        MapEnumerator   endDiscBalancesEnumerator;
        AmountCur       calculatedEndDiscBalance;

        endDiscBalancesEnumerator = endDiscBalances.getEnumerator();

        while (endDiscBalancesEnumerator.moveNext())
        {
            calculatedEndDiscBalance += endDiscBalancesEnumerator.currentValue();
        }

        return CurrencyExchangeHelper::amount(calculatedEndDiscBalance, this.currencyCode());
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateFreeValue</Name>
				<Source><![CDATA[
    protected AmountCur calculateFreeValue()
    {
        freeValue = 0;

        return freeValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateIsCreditNote</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates whether the order is a credit note.
    /// </summary>
    /// <remarks>
    ///    The result is stored in the <c>isCreditNote</c> instance variable.
    /// </remarks>
    protected void calculateIsCreditNote()
    {
        TradeTotalsIQueryRun    lineQueryRun;
        AmountCur           total;
        UnitQty             unitQty;
        UnitQty             totalUnitQty;

        skipTaxCalculations = true;

        lineQueryRun = this.createLineQueryRun();

        while (this.lineQueryRunNext(lineQueryRun))
        {
            orderLine = this.lineQueryRunGet(lineQueryRun);

            if (this.skipLine(orderLine))
                continue;

            unitQty = this.qtyUnit();
            total += this.lineAmount(unitQty, DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
            totalUnitQty += unitQty;
        }

        isCreditNote = this.determineIsCreditNote(total, totalUnitQty);
        skipTaxCalculations = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateMarkupAmount</Name>
				<Source><![CDATA[
    private void calculateMarkupAmount()
    {
        if (!markupLineAmountCalculated || !markupTableAmountCalculated)
        {
            this.prepareMarkupLineAmountCalculation();
            this.prepareMarkupTableAmountCalculation();
            this.calc();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateMarkupLineAmount</Name>
				<Source><![CDATA[
    private void calculateMarkupLineAmount()
    {
        if (!markupLineAmountCalculated)
        {
            this.prepareMarkupLineAmountCalculation();
            this.calc();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateMarkupTableAmount</Name>
				<Source><![CDATA[
    private void calculateMarkupTableAmount()
    {
        if (!markupTableAmountCalculated)
        {
            this.prepareMarkupTableAmountCalculation();
            this.calc();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateQuantities</Name>
				<Source><![CDATA[
    private void calculateQuantities()
    {
        if (!quantitiesCalculated)
        {
            this.prepareQuantitiesCalculation();
            this.calc();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateRemainQuantities</Name>
				<Source><![CDATA[
    private void calculateRemainQuantities()
    {
        if (!remainQuantitiesCalculated)
        {
            this.prepareRemainQuantitiesCalculation();
            this.calc();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTaxAmount</Name>
				<Source><![CDATA[
    private void calculateTaxAmount()
    {
        if (!taxAmountCalculated)
        {
            this.prepareTaxAmountCalculation();
            this.calc();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTotalAmount</Name>
				<Source><![CDATA[
    private void calculateTotalAmount()
    {
        if (!taxAmountCalculated || !balanceCalculated || !markupLineAmountCalculated || !markupTableAmountCalculated)
        {
            this.prepareTotalAmountCalculation();
            this.calc();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscAmount</Name>
				<Source><![CDATA[
    protected DiscAmount cashDiscAmount()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscCode</Name>
				<Source><![CDATA[
    public CashDiscCode cashDiscCode()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscDate</Name>
				<Source><![CDATA[
    protected DiscDate  cashDiscDate()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscPercent</Name>
				<Source><![CDATA[
    public DiscPct cashDiscPercent()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>categoryEndDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a category based order line is eligible for total discount.
    /// </summary>
    /// <returns>
    /// Always returns true.
    /// </returns>
    protected boolean categoryEndDisc()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>categoryWeight</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the weight of a category based order line.
    /// </summary>
    /// <returns>
    ///    The weight of the category based order line.
    /// </returns>
    /// <remarks>
    ///    Derived classes that supports category based lines should override this method.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    ///    The method was not implemented in a derived class that supports category based lines.
    /// </exception>
    protected Weight categoryWeight()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>clear</Name>
				<Source><![CDATA[
    protected void clear()
    {
        pdsCWQty                = 0;
        pdsCWQtyRemain          = 0;
        qty                     = 0;
        weight                  = 0;
        grossWeight             = 0;
        volume                  = 0;
        qtyRemainInvent         = 0;
        weightRemainInvent      = 0;
        grossWeightRemainInvent = 0;
        volumeRemainInvent      = 0;

        costValue               = 0;
        freeValue               = 0;
        cashDisc                = 0;
        balance                 = 0;
        orderBalances           = new Map(typeName2Type(extendedtypestr(recId)), Types::Real);
        endDiscBalances         = new Map(Types::REAL, Types::REAL);
        lineRoundedOrderBalances= new Map(typeName2Type(extendedtypestr(recId)), Types::Real);
        lineBalanceAdjustments  = new Map(typeName2Type(extendedtypestr(recId)), Types::Real);
        lineMarkupTotalAmounts  = new Map(typeName2Type(extendedtypestr(recId)), Types::Real);
        recIdLinesToAdjust      = new Map(typeName2Type(extendedtypestr(recId)), Types::Container);
        costValue               = 0;
        lineDisc                = 0;
        markupLineAmount        = 0;
        markupTableAmount       = 0;
        roundOff                = 0;
        totalAmount             = 0;
        totalAmountUnRounded    = 0;
        totalAmountAddition     = 0;
        taxTotal                = 0;

        inventTable             = null;
        lineEndDiscBalances     = new Map(typeName2Type(extendedTypeStr(RecId)), Types::Real);

        returnEndDiscBalances           = new Map(Types::REAL, Types::REAL);
        mcrOrderBalancesAbsoluteValue   = new Map(typeName2Type(extendedtypestr(recId)), Types::Real);
        mcrBalanceAbsoluteValue         = 0;
        markupCoupon                    = 0;
        returnInstallmentBalance        = 0;
        markUpInstallmentCoupon         = 0;
        markUpInstallmentLineAmount     = 0;
        endDiscInstallmentBalances      = new Map(Types::Real,Types::Real);
        returnEndDiscInstalBalances     = new Map(Types::Real,Types::Real);

        // <GEERU>
        if (countryRegion_RU)
        {
            markupLineDetails       = new Map(Types::Container, Types::Real);
            balanceBySign_RU[0]             =0;
            totalAmountBySign_RU[0]         =0;
            totalAmountUnroundedBySign_RU[0]=0;
            roundOffBySign_RU[0]            =0;
            balanceBySign_RU[0]             =0;
            endDiscBySign_RU[0]             =0;
            markupLineAmountBySign_RU[0]    =0;
            markupTableAmountBySign_RU[0]   =0;
            taxTotalBySign_RU[0]            =0;
            totalAmountAdditionBySign_RU[0] =0;
        }
        // </GEERU>

        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            taxTotalGTE = 0;
        }
        // </GTE>
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructCalcTax</Name>
				<Source><![CDATA[
    protected TradeCalcTax constructCalcTax()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>costValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the cost value of the current order line.
    /// </summary>
    /// <param name="_inventQty">
    ///    The order line quantity in inventory units.
    /// </param>
    /// <returns>
    ///    The cost value of the current order line.
    /// </returns>
    protected CostAmount costValue(InventQty _inventQty)
    {
        CostPrice costPrice;

        InventQty  costInventQty;
        AmountCur  costInventValue;

        if (this.isCategoryBased())
        {
            return 0;
        }

        if (_inventQty > 0)
        {
            if (this.isStocked())
            {
                // For inventoried lines the cost is based on inventTrans.
                [costInventQty, costInventValue] = InventTrans::calcCostValue(InventTransOrigin::findByInventTransId(this.inventTransId()).RecId);
                if (costInventQty)
                {
                    costPrice = costInventValue/costInventQty;
                }
            }
            else
            {
                // For non-inventoried lines the cost is based on defined prices.
                costPrice = inventTable.costPcsPrice(this.inventDimId());
            }
        }
        else
        {
            costPrice = this.lineCostPrice();
        }

        return CurrencyExchangeHelper::amount(_inventQty * costPrice);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLineQueryRun</Name>
				<Source><![CDATA[
    abstract protected TradeTotalsIQueryRun createLineQueryRun()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditMax</Name>
				<Source><![CDATA[
    public AmountMST  creditMax()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the currency code of the record in the <c>Currency</c> table.
    /// </summary>
    /// <returns>
    ///    The currency code of the record in the <c>Currency</c> table.
    /// </returns>
    public CurrencyCode currencyCode()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>del_markupTotalAmountMST_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the total markup value in the accounting currency.
    /// </summary>
    /// <returns>
    ///    Total markup value.
    /// </returns>
    protected MarkupAmount del_markupTotalAmountMST_BR()
    {
        return markupTotalAmountMST_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineIsCreditNote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the order is a credit note by considering the total line amount and total unit quantity.
    /// </summary>
    /// <param name="_totalLineAmount">
    /// The total line amount of the order
    /// </param>
    /// <param name="_totalUnitQty">
    /// The total quantity in order units.
    /// </param>
    /// <returns>
    /// true if the order is a credit note; otherwise, false.
    /// </returns>
    protected boolean determineIsCreditNote(AmountCur _totalLineAmount, UnitQty _totalUnitQty)
    {
        return _totalLineAmount < 0 || (!_totalLineAmount && _totalUnitQty < 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>discPercent</Name>
				<Source><![CDATA[
    protected DiscPct discPercent()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayFields</Name>
				<Source><![CDATA[
    container  displayFields(container  _fields = connull())
    {
        #PdsNumbers

        int         maxPos          = #numPos;
        int         pos             = 1;
        container   displayFields;

        while (pos <= maxPos)
        {
            displayFields += [pos];
            pos++;
        }

        if (conlen(_fields) == 0)
        {
            _fields = displayFields;
        }

        pos = 1;

        while (pos <= conlen(_fields))
        {
            switch (any2int(conpeek(_fields, pos)))
            {
                case  TradeTotals::posQty()                : displayFields = conpoke(displayFields, TradeTotals::posQty()                   , this.totalQty());                 break;
                case  TradeTotals::pdsCWPosQty()           :
                    displayFields = conPoke(displayFields,
                                            TradeTotals::pdsCWPosQty(),
                                            this.pdsCWTotalQty());
                    break;
                case  TradeTotals::posWeight()             : displayFields = conpoke(displayFields, TradeTotals::posWeight()                , this.totalWeight());              break;
                case  TradeTotals::posVolume()             : displayFields = conpoke(displayFields, TradeTotals::posVolume()                , this.totalVolume());              break;
                case  TradeTotals::posCashDisc()           : displayFields = conpoke(displayFields, TradeTotals::posCashDisc()              , this.totalCashDisc());            break;
                case  TradeTotals::posCostValue()          : displayFields = conpoke(displayFields, TradeTotals::posCostValue()             , this.totalCostValue());           break;
                case  TradeTotals::posContributionMargin() : displayFields = conpoke(displayFields, TradeTotals::posContributionMargin()    , this.totalContributionMargin());  break;
                case  TradeTotals::posContributionRatio()  : displayFields = conpoke(displayFields, TradeTotals::posContributionRatio()     , this.totalContributionRatio());   break;
                case  TradeTotals::posCurrency()           : displayFields = conpoke(displayFields, TradeTotals::posCurrency()              , this.currencyCode());             break;
                case  TradeTotals::posExchRate()           : displayFields = conpoke(displayFields, TradeTotals::posExchRate()              , this.exchRate());                 break;
                case  TradeTotals::posCreditMax()          : displayFields = conpoke(displayFields, TradeTotals::posCreditMax()             , this.creditMax());                break;
                case  TradeTotals::posFreeValue()          : displayFields = conpoke(displayFields, TradeTotals::posFreeValue()             , this.totalFreeValue());           break;
                case  TradeTotals::posLineDisc()           : displayFields = conpoke(displayFields, TradeTotals::posLineDisc()              , this.totalLineDisc());            break;
                case  TradeTotals::posEndDisc()            : displayFields = conpoke(displayFields, TradeTotals::posEndDisc()               , this.totalEndDisc());             break;
                case  TradeTotals::posBalance()            : displayFields = conpoke(displayFields, TradeTotals::posBalance()               , this.totalBalance());             break;
                case  TradeTotals::posMarkup()             : displayFields = conpoke(displayFields, TradeTotals::posMarkup()                , this.totalMarkup());              break;
                case  TradeTotals::posTaxTotal()           :
                    // <GTE>
                    if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
                    {
                        displayFields = conPoke(displayFields, TradeTotals::posTaxTotal()              , this.taxTotalGTE());
                    }
                    // </GTE>
                    else
                    {
                        displayFields = conPoke(displayFields, TradeTotals::posTaxTotal()              , this.totalTaxAmount());
                    }
                    break;
                case  TradeTotals::posRoundOff()           : displayFields = conpoke(displayFields, TradeTotals::posRoundOff()              , this.totalRoundOff());            break;
                case  TradeTotals::posTotalAmount()        :
                    if (TaxParameters::canApplyCashDiscOnInvoice_ES())
                    {
                        displayFields = conPoke(displayFields, TradeTotals::posTotalAmount()           , this.totalAmountCashDiscOnInvoice(true));
                    }
                    // <GTE>
                    else if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
                    {
                        displayFields = conPoke(displayFields, TradeTotals::posTotalAmount()           , this.totalAmountGTE());
                    }
                    // </GTE>
                    else
                    {
                        displayFields = conPoke(displayFields, TradeTotals::posTotalAmount()           , this.totalAmount());
                    }

                    if (TaxWithholdEnableIncludeTCSInTotalFeatureToggle::includeTCSInInvoiceAmount(taxWithholdIN))
                    {
                        displayFields = conPoke(displayFields,
                            TradeTotals::posTotalAmount(),
                            conPeek(displayFields, TradeTotals::posTotalAmount()) + this.roundedOffTotalAmount(taxWithholdTotal));
                    }

                    break;
                // Return totals
                case  TradeTotals::mcrPosReturnTotalAmount()   : displayFields = conpoke(displayFields, TradeTotals::mcrPosReturnTotalAmount()      , this.mcrReturnTotalAmount());        break;
                case  TradeTotals::mcrPosReturnTaxTotal()      : displayFields = conpoke(displayFields, TradeTotals::mcrPosReturnTaxTotal()         , this.mcrReturnTotalTaxAmount());     break;
                case  TradeTotals::mcrPosReturnMarkup()        : displayFields = conpoke(displayFields, TradeTotals::mcrPosReturnMarkup()           , this.mcrTotalReturnMarkupLine());    break;
                case  TradeTotals::mcrPosReturnDiscountTotal() : displayFields = conpoke(displayFields, TradeTotals::mcrPosReturnDiscountTotal()    , this.mcrReturnTotalEndDisc());       break;
                case  TradeTotals::mcrPosReturnBalanceAmount() : displayFields = conpoke(displayFields, TradeTotals::mcrPosReturnBalanceAmount()    , this.mcrTotalReturnBalance());       break;
                case  TradeTotals::mcrPostotalCoupon()         : displayFields = conpoke(displayFields, TradeTotals::mcrPostotalCoupon()            , abs(this.mcrMarkupCoupon()));        break;
                // <GBR>
                case TradeTotals::posSalesTaxCurrency_BR()  : displayFields = conPoke(displayFields, TradeTotals::posSalesTaxCurrency_BR()  , this.salesTaxCurrency_BR());                          break;
                case TradeTotals::posICMSTotal_BR()         : displayFields = conPoke(displayFields, TradeTotals::posICMSTotal_BR()         , this.salesTaxTotals_BR(TaxType_BR::ICMS));            break;
                case TradeTotals::posIPITotal_BR()          : displayFields = conPoke(displayFields, TradeTotals::posIPITotal_BR()          , this.salesTaxTotals_BR(TaxType_BR::IPI));             break;
                case TradeTotals::posPISTotal_BR()          : displayFields = conPoke(displayFields, TradeTotals::posPISTotal_BR()          , this.salesTaxTotals_BR(TaxType_BR::PIS));             break;
                case TradeTotals::posCOFINSTotal_BR()       : displayFields = conPoke(displayFields, TradeTotals::posCOFINSTotal_BR()       , this.salesTaxTotals_BR(TaxType_BR::COFINS));          break;
                case TradeTotals::posImportTaxTotal_BR()    : displayFields = conPoke(displayFields, TradeTotals::posImportTaxTotal_BR()    , this.salesTaxTotals_BR(TaxType_BR::ImportTax));       break;
                case TradeTotals::posISSTotal_BR()          : displayFields = conPoke(displayFields, TradeTotals::posISSTotal_BR()          , this.salesTaxTotals_BR(TaxType_BR::ISS));             break;
                case TradeTotals::posINSSTotal_BR()         : displayFields = conPoke(displayFields, TradeTotals::posINSSTotal_BR()         , this.salesTaxTotals_BR(TaxType_BR::INSS));            break;
                case TradeTotals::posIRRFTotal_BR()         : displayFields = conPoke(displayFields, TradeTotals::posIRRFTotal_BR()         , this.salesTaxTotals_BR(TaxType_BR::IRRF));            break;
                case TradeTotals::posRetainedINSSTotal_BR() : displayFields = conPoke(displayFields, TradeTotals::posRetainedINSSTotal_BR() , this.salesTaxTotals_BR(TaxType_BR::INSSRetained));    break;
                case TradeTotals::posCSLLTotal_BR()         : displayFields = conPoke(displayFields, TradeTotals::posCSLLTotal_BR()         , this.salesTaxTotals_BR(TaxType_BR::CSLL));            break;
                case TradeTotals::posICMSSTTotal_BR()       : displayFields = conPoke(displayFields, TradeTotals::posICMSSTTotal_BR()       , this.salesTaxTotals_BR(TaxType_BR::ICMSST));          break;
                case TradeTotals::posICMSDiffTotal_BR()     : displayFields = conPoke(displayFields, TradeTotals::posICMSDiffTotal_BR()     , this.salesTaxTotals_BR(TaxType_BR::ICMSDiff));        break;

                // Totals for installments
                case  TradeTotals::mcrPosReturnInstallmentTotal() :
                        displayFields = conpoke(displayFields,TradeTotals::mcrPosReturnInstallmentTotal(),this.mcrReturnInstallmentEligibleAmount());
                break;
                case  TradeTotals::mcrPosReturnInstallmentMarkUpLine() :
                    displayFields = conpoke(displayFields,TradeTotals::mcrPosReturnInstallmentMarkUpLine(),this.mcrReturnInstallmentEligibleMarkUpLine());
                break;
                case TradeTotals::mcrPosReturnInstallmentTax():
                    displayFields = conpoke(displayFields,TradeTotals::mcrPosReturnInstallmentTax(),this.mcrReturnInstallmentEligibleTax());
                break;
                case TradeTotals::mcrPosReturnInstallmentMarkUpCoupon():
                    displayFields = conpoke(displayFields,TradeTotals::mcrPosReturnInstallmentMarkUpCoupon(),this.mcrReturnMarkupInstallEligibleCoupon());
                break;
                case TradeTotals::mcrPosReturnInstallmentMarkUpTotal():
                    displayFields = conpoke(displayFields,TradeTotals::mcrPosReturnInstallmentMarkUpTotal(),this.mcrReturnInstallmentEligibleMarkUpTotal());
                break;
                case TradeTotals::mcrPosInstallmentLineDisc():
                    displayFields = conpoke(displayFields,TradeTotals::mcrPosInstallmentLineDisc(),this.mcrTotalLineInstallmentDisc());
                break;
                case TradeTotals::mcrPosEndInstallmentDisc():
                    displayFields=conpoke(displayFields,TradeTotals::mcrPosEndInstallmentDisc(),this.mcrTotalEndInstallmentDisc());
                break;
                case TradeTotals::posMarkupFreight_BR()     : displayFields = conPoke(displayFields, TradeTotals::posMarkupFreight_BR()     , this.markupFreightAmountMST_BR());                    break;
                case TradeTotals::posMarkupInsurance_BR()   : displayFields = conPoke(displayFields, TradeTotals::posMarkupInsurance_BR()   , this.markupInsuranceAmountMST_BR());                  break;
                case TradeTotals::posMarkupOther_BR()       : displayFields = conPoke(displayFields, TradeTotals::posMarkupOther_BR()       , this.markupOthersAmountMST_BR());                     break;
                // </GBR>
                case  TradeTotals::posWithholdTCSTaxTotal_IN():
                    if (taxWithholdIN && taxWithholdIN.taxTCSType())
                    {
                        displayFields = conpoke(displayFields, TradeTotals::posWithholdTCSTaxTotal_IN(), taxWithholdTotal);
                    }
                    else
                    {
                        displayFields = conpoke(displayFields, TradeTotals::posWithholdTCSTaxTotal_IN(), 0);
                    }
                    break;
            }

            pos++;
        }

        return displayFields;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayFieldsCurrency</Name>
				<Source><![CDATA[
    container  displayFieldsCurrency(CurrencyCode _currencyCode = this.currencyCode(), container  _fields = connull())
    {
        int         maxPos          = #numPos;
        int         pos             = 1;
        container   displayFields   = this.displayFields(_fields);
        AmountCur   oldAmountCur, newAmountCur;
        AmountMST   amountMST;
        ExchRate    exchangeRate;

        if (_currencyCode != this.currencyCode()) // convert fields originally in Cur currency
        {
            // Set currency code and exchange rate
            displayFields = conpoke(displayFields, TradeTotals::posCurrency(), _currencyCode);
            displayFields = conpoke(displayFields, TradeTotals::posExchRate(), ExchangeRateHelper::exchRate(_currencyCode));

            for (pos = 1; pos <= conlen(displayFields); pos++)
            {
                switch (pos)
                {
                    case TradeTotals::posCostValue(),
                        TradeTotals::posCreditMax(),
                        TradeTotals::posFreeValue():
                        break;
                    case TradeTotals::posContributionMargin():
                        // keep contribution margin in MSt
                        amountMST = CurrencyExchangeHelper::amountCur2MST(this.totalBalance(), this.currencyCode(), this.exchRate()) -
                                    CurrencyExchangeHelper::amountCur2MST(this.totalEndDisc(), this.currencyCode(), this.exchRate()) -
                                    this.totalCostValue();
                                    // <GBR>
                                    if (BrazilParameters::isEnabled())
                                    {
                                        amountMST -= CurrencyExchangeHelper::amountCur2MST(this.tax().totalTaxIncludedInPrice_BR(), this.currencyCode(), this.exchRate());
                                    }
                                    // </GBR>
                        displayFields = conpoke(displayFields, pos, amountMST);
                        break;
                    case TradeTotals::posCashDisc(),
                        TradeTotals::posLineDisc(),
                        TradeTotals::posEndDisc(),
                        TradeTotals::posBalance(),
                        TradeTotals::posMarkup(),
                        TradeTotals::posTaxTotal(),
                        TradeTotals::posRoundOff(),
                        // <GBR>
                        TradeTotals::posICMSTotal_BR(),
                        TradeTotals::posIPITotal_BR(),
                        TradeTotals::posPISTotal_BR(),
                        TradeTotals::posCOFINSTotal_BR(),
                        TradeTotals::posISSTotal_BR(),
                        TradeTotals::posINSSTotal_BR(),
                        TradeTotals::posIRRFTotal_BR(),
                        TradeTotals::posRetainedINSSTotal_BR(),
                        TradeTotals::posMarkupFreight_BR(),
                        TradeTotals::posMarkupInsurance_BR(),
                        TradeTotals::posMarkupOther_BR(),
                        // </GBR>
                        TradeTotals::MCRPosReturnTotalAmount(),
                        TradeTotals::MCRPosReturnTaxTotal(),
                        TradeTotals::MCRPosReturnMarkup(),
                        TradeTotals::MCRPosReturnDiscountTotal(),
                        TradeTotals::MCRPosReturnBalanceAmount(),
                        TradeTotals::MCRPostotalCoupon(),
                        TradeTotals::posTotalAmount(),
                        TradeTotals::posWithholdTCSTaxTotal_IN():
                        // As the sales order can have a fixed exchange rate specified,
                        // the conversion must be managed.
                        oldAmountCur = conpeek(displayFields, pos);
                        amountMST    = CurrencyExchangeHelper::mstAmount(oldAmountCur, this.currencyCode(), DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), UnknownNoYes::Unknown, this.exchRate(), 0, false);
                        newAmountCur = CurrencyExchangeHelper::curAmount(amountMST, _currencyCode);
                        displayFields = conpoke(displayFields, pos, newAmountCur);
                        break;
                }
            }
        }

        if (_currencyCode != CompanyInfoHelper::standardCurrency()) // convert fields originally in MST currency
        {
            // Set currency code and exchange rate
            displayFields = conpoke(displayFields, TradeTotals::posCurrency(), _currencyCode);

            if (_currencyCode != this.currencyCode())
                displayFields = conpoke(displayFields, TradeTotals::posExchRate(), ExchangeRateHelper::exchRate(_currencyCode));

            exchangeRate = conpeek(displayFields, TradeTotals::posExchRate());

            for (pos = 1; pos <= conlen(displayFields); pos++)
            {
                switch (pos)
                {
                    case TradeTotals::posCreditMax(),
                        TradeTotals::posFreeValue():
                        amountMST     = conpeek(displayFields, pos);
                        newAmountCur  = CurrencyExchangeHelper::curAmount(amountMST, _currencyCode, DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), UnknownNoYes::Unknown, exchangeRate);
                        displayFields = conpoke(displayFields, pos, newAmountCur);
                        break;
                    case TradeTotals::posContributionMargin():
                        // keep contribution margin in MSt
                        amountMST = CurrencyExchangeHelper::amountCur2MST(this.totalBalance(), _currencyCode, this.exchRate()) -
                                    CurrencyExchangeHelper::amountCur2MST(this.totalEndDisc(), _currencyCode, this.exchRate()) -
                                    this.totalCostValue();
                        // <GBR>
                        if (BrazilParameters::isEnabled())
                        {
                            amountMST -= CurrencyExchangeHelper::amountCur2MST(this.tax().totalTaxIncludedInPrice_BR(), _currencyCode, this.exchRate());
                        }
                        // </GBR>

                        displayFields = conpoke(displayFields, pos, amountMST);
                        break;
                }
            }
        }

        return displayFields;
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentDate</Name>
				<Source><![CDATA[
    public DocumentDate documentDate()
    {
        return this.invoiceDate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentStatus</Name>
				<Source><![CDATA[
    protected DocumentStatus documentStatus()
    {
        return DocumentStatus::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>endDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether an order line is eligible for total discount.
    /// </summary>
    /// <returns>
    /// true if the order line is eligible for total discount; otherwise, false.
    /// </returns>
    private boolean endDisc()
    {
        return this.isCategoryBased() ? this.categoryEndDisc() : this.itemEndDisc();
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRate</Name>
				<Source><![CDATA[
    public ExchRate exchRate()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>reportingCurrencyExchangeRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the reporting currency exchange rate.
    /// </summary>
    /// <returns>The reporting currency exchange rate.</returns>
    internal ExchRate reportingCurrencyExchangeRate()
    {
        return 0.0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRateSecondary</Name>
				<Source><![CDATA[
    public ExchrateSecondary exchRateSecondary()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillRecordSortedListLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Fills the <c>RecordSortedList</c> list that holds lines.
    /// </summary>
    /// <remarks>
    ///    This method is used for performance reasons in scenarios where totals do not have to be calculated.
    /// </remarks>
    public void fillRecordSortedListLine()
    {
        TradeTotalsIQueryRun    lineQueryRun;

        lineQueryRun = this.createLineQueryRun();

        if (!recordSortedListLine)
        {
            this.initRecordSortedListLine();
        }

        while (this.lineQueryRunNext(lineQueryRun))
        {
            orderLine = this.lineQueryRunGet(lineQueryRun);

            if (this.skipLine(orderLine))
            {
                continue;
            }

            this.insertRecordSortedListLine(orderLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInclTaxAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets included tax amount.
    /// </summary>
    /// <param name="_buffer">
    /// The buffer.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxAmountCur</c> class.
    /// </returns>
    public TaxAmountCur getInclTaxAmount_IN(Common _buffer)
    {
        SalesLine               salesLine;
        SalesQuotationLine      salesQuotationLine;
        SalesTable              salesTable;
        SalesQuotationTable     salesQuotationTable;
        TableId                 tableId;
        TaxAmountCur            inclTaxAmount;
        TmpTaxWorkTrans         tmpTaxWorkTrans;
        FormulaDesigner_IN      formulaDesigner;
        TaxableBasis_IN         taxBasis;
        TmpTaxCalc_IN           tmpTaxCalc;
        SalesId                 salesId;
        QuotationId             salesQuotationId;
        Map                     mapRecId;
        MapEnumerator           mapEnumerator;
        SalesParmTable          salesParmTable;
        SalesParmLine           salesParmLine;
        SalesQuotationParmTable salesQuotationParmTable;
        SalesQuotationParmLine  salesQuotationParmLine;
        boolean                 checkCreditNote;
        boolean                 isInvoiced;

        mapRecId = new Map(Types::Int64,Types::String);

        if (_buffer.TableId == tableNum(SalesTable))
        {
            salesTable  = _buffer;
            salesId     = salesTable.SalesId;
            tableId     = tableNum(SalesLine);

            while select TaxItemGroup, RecId, SalesQty from salesLine
                join OrigSalesId from salesParmLine
                join ParmId from salesParmTable
                    where salesParmTable.SalesId == salesId
                       && salesParmLine.ParmId   == salesParmTable.ParmId
                       && salesLine.SalesId      == salesParmLine.OrigSalesId
                       && salesLine.TaxItemGroup != ""
            {
                isInvoiced = true;
                if (salesLine.SalesQty < 0)
                {
                    checkCreditNote = true;
                }
                mapRecId.insert(salesLine.RecId, salesLine.TaxItemGroup);
            }

            if (!isInvoiced)
            {
                while select TaxItemGroup, RecId, SalesQty from salesLine
                    where salesLine.SalesId == salesId
                        && salesLine.TaxItemGroup != ""
                {
                    if (salesLine.SalesQty < 0)
                    {
                        checkCreditNote = true;
                    }
                    mapRecId.insert(salesLine.RecId, salesLine.TaxItemGroup);
                }
            }
        }

        else if (_buffer.TableId == tableNum(SalesQuotationTable))
        {
            salesQuotationTable = _buffer;
            salesQuotationId    = salesQuotationTable.QuotationId;
            tableId             = tableNum(SalesQuotationLine);

            while select TaxItemGroup, RecId, SalesQty from salesQuotationLine
                join OrigQuotationId from salesQuotationParmLine
                join ParmId from salesQuotationParmTable
                    where salesQuotationParmTable.QuotationId == salesQuotationId
                       && salesQuotationParmLine.ParmId       == salesQuotationParmTable.ParmId
                       && salesQuotationLine.QuotationId      == salesQuotationParmLine.OrigQuotationId
            {
                isInvoiced = true;
                if (salesQuotationLine.SalesQty < 0)
                {
                    checkCreditNote = true;
                }
                mapRecId.insert(salesQuotationLine.RecId, salesQuotationLine.TaxItemGroup);
            }

            if (!isInvoiced)
            {
                while select TaxItemGroup, RecId, SalesQty from salesQuotationLine
                    where salesQuotationLine.QuotationId == salesQuotationId
                {
                    isInvoiced = true;
                    if (salesQuotationLine.SalesQty < 0)
                    {
                        checkCreditNote = true;
                    }
                    mapRecId.insert(salesQuotationLine.RecId, salesQuotationLine.TaxItemGroup);
                }
            }
        }

        mapEnumerator = mapRecId.getEnumerator();

        while (mapEnumerator.moveNext())
        {
            if (FormulaDesigner_IN::isPriceInclTaxOnLineAmount(mapEnumerator.currentValue()))
            {
                tmpTaxWorkTrans = this.tax().tmpTaxWorkTrans();
                tmpTaxCalc      = this.tax().tmpTaxCalc_IN();

                while select tmpTaxWorkTrans
                    where tmpTaxWorkTrans.SourceRecId      == mapEnumerator.currentKey()    &&
                          tmpTaxWorkTrans.SourceTableId    == tableId                       &&
                          tmpTaxWorkTrans.TaxDirection     != TaxDirection::UseTax          &&
                          tmpTaxWorkTrans.TaxOrigin        != TaxOrigin::TaxReversed
                {
                    formulaDesigner = FormulaDesigner_IN::findByTaxCode(tmpTaxWorkTrans.TaxItemGroup, tmpTaxWorkTrans.TaxCode);

                    if (formulaDesigner.PriceInclTax)
                    {
                        select tmpTaxCalc where
                            tmpTaxCalc.TaxCode         == tmpTaxWorkTrans.TaxCode        &&
                            tmpTaxCalc.SourceTableID   == tableId                        &&
                            tmpTaxCalc.SourceRecID     == mapEnumerator.currentKey();

                        taxBasis = formulaDesigner.TaxableBasis;

                        if (taxBasis == TaxableBasis_IN::ExclAmount)
                        {
                            taxBasis = Tax::getTaxableBasis_IN(formulaDesigner);
                        }

                        if (TaxTable::find(tmpTaxWorkTrans.TaxCode).TaxType_IN != TaxType_IN::None
                           && (taxBasis == TaxableBasis_IN::LineAmount
                               || taxBasis == TaxableBasis_IN::Assessable))
                        {
                            if (!tmpTaxWorkTrans.SourceRegulateAmountCur)
                            {
                                 inclTaxAmount += tmpTaxWorkTrans.SourceTaxAmountCur;
                            }
                            else
                            {
                                 inclTaxAmount += tmpTaxWorkTrans.SourceRegulateAmountCur;
                            }

                            if (inclTaxAmount < 0)
                            {
                                inclTaxAmount += tmpTaxCalc.TaxOnCharges;
                            }
                            else
                            {
                                inclTaxAmount -= tmpTaxCalc.TaxOnCharges;
                            }
                        }
                    }
                }
            }
        }
        if (_buffer.TableId == tableNum(SalesTable) && (salesTable.SalesType == SalesType::ReturnItem || checkCreditNote))
        {
            inclTaxAmount = CurrencyExchangeHelper::amount(inclTaxAmount) * -1;
        }
        else if (_buffer.TableId == tableNum(SalesTable) || _buffer.TableId == tableNum(SalesQuotationTable))
        {
            inclTaxAmount = CurrencyExchangeHelper::amount(abs(inclTaxAmount));
        }

        return inclTaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrderLineSign_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Returns an overall sign of the order line.
    /// </summary>
    /// <param name="_line">
    ///   Order line.
    /// </param>
    /// <returns>
    ///   Sign as index (see the <c>getSignIndexByAmount_RU</c> method).
    /// </returns>
    /// <exception cref="Exception::Error">
    ///   If is not overridden in particular descendant.
    /// </exception>
    protected int getOrderLineSign_RU(Common _line)
    {
        throw error(Error::missingOverride(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSignIndexByAmount_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets sign index by given amount.
    /// </summary>
    /// <param name="_amount">
    ///   Amount.
    /// </param>
    /// <returns>
    ///   Index of sign in arrays.
    /// </returns>
    public int getSignIndexByAmount_RU(Amount _amount)
    {
        return (_amount < 0) ? #negativeSignIndex_RU : #positiveSignIndex_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes charges transactions required for calculating the totals.
    /// </summary>
    protected void initMarkup()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRecordSortedListLine</Name>
				<Source><![CDATA[
    protected void initRecordSortedListLine()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertRecordSortedListLine</Name>
				<Source><![CDATA[
    protected void insertRecordSortedListLine(Common _orderLine)
    {
        recordSortedListLine.ins(orderLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyLineAmount</Name>
				<Source><![CDATA[
    public LineAmount interCompanyLineAmount(SalesQty _salesQty, InvoiceDate _invoiceDate)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the <c>InventDimId</c> field of the current order line.
    /// </summary>
    /// <returns>
    ///    The <c>InventDimId</c> field of the current order line.
    /// </returns>
    /// <remarks>
    ///    Derived classes that support non-inventoried item based lines should override this method.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    ///    The method was not implemented in a derived class that supports non-inventoried item based lines.
    /// </exception>
    protected InventDimId inventDimId()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTableModuleCached</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Selects and caches record buffers of the <c>InventTableModule</c> table.
    /// </summary>
    /// <param name="_itemId">
    ///     An <c>ItemId</c> type.
    /// </param>
    /// <param name="_type">
    ///     An <c>ModuleInventPurchSales</c> enumeration.
    /// </param>
    /// <returns>
    ///     A buffer of the <c>InventTableModule</c> table.
    /// </returns>
    protected InventTableModule inventTableModuleCached(ItemId _itemId, ModuleInventPurchSales _type)
    {
        InventTableModule inventTableModule;

        if (!inventTableModuleCached)
        {
            inventTableModuleCached = new Map(Types::String, Types::Record);
        }

        if (inventTableModuleCached.exists(_itemId))
        {
            inventTableModule = inventTableModuleCached.lookup(_itemId);
        }
        else
        {
            inventTableModule = InventTableModule::find(_itemId, _type);
            inventTableModuleCached.insert(_itemId, inventTableModule);
        }

        return inventTableModule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransId</Name>
				<Source><![CDATA[
    protected TradeInventTransId inventTransId()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceAccount</Name>
				<Source><![CDATA[
    protected CustAccount  invoiceAccount()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceDate</Name>
				<Source><![CDATA[
    protected TransDate invoiceDate()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCategoryBased</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether the order line is category based.
    /// </summary>
    /// <returns>
    ///    true if the order line is category based; otherwise, false.
    /// </returns>
    protected boolean isCategoryBased()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCreditNote</Name>
				<Source><![CDATA[
    public boolean isCreditNote()
    {
        if (!isCreditNoteCalculated)
        {
            this.calculateIsCreditNote();
            isCreditNoteCalculated = true;
        }

        return isCreditNote;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isStocked</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether the order line is tracked in the inventory.
    /// </summary>
    /// <returns>
    ///    true if the order line is tracked in the inventory; otherwise, false.
    /// </returns>
    protected boolean isStocked()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemEndDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether an item based order line is eligible for total discount.
    /// </summary>
    /// <returns>
    /// true if the order line is eligible for total discount; otherwise, false.
    /// </returns>
    protected boolean itemEndDisc()
    {
        return this.inventTableModuleCached(this.itemId(), this.itemModuleType()).EndDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemId</Name>
				<Source><![CDATA[
    protected ItemId itemId()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemModuleType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the item module type.
    /// </summary>
    /// <returns>
    ///    The item module type for the order.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The method was called from the base.
    /// </exception>
    protected ModuleInventPurchSales itemModuleType()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineAmount</Name>
				<Source><![CDATA[
    protected LineAmount  lineAmount(UnitQty _unitQty, TransDate _transDate)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineCostPrice</Name>
				<Source><![CDATA[
    protected CostPrice lineCostPrice()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineDiscAmount</Name>
				<Source><![CDATA[
    protected DiscAmount lineDiscAmount(UnitQty _unitQty, TransDate _transDate)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCalculateLineDiscountAmount</Name>
				<Source><![CDATA[
    protected boolean shouldCalculateLineDiscountAmount()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineEndDiscBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets line end discount balance.
    /// </summary>
    /// <param name="_recId">
    /// The record ID of the line for which end discount balance should be retrieved.
    /// </param>
    /// <returns>
    /// The end discount balance for line.
    /// </returns>
    public AmountCur lineEndDiscBalance(recId _recId)
    {
        AmountCur   lineEndDiscBalance;

        if (lineEndDiscBalances.exists(_recId))
        {
            lineEndDiscBalance = lineEndDiscBalances.lookup(_recId);
        }

        return lineEndDiscBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineHasDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether a discount is applied to the line.
    /// </summary>
    /// <returns>
    ///     Always true.
    /// </returns>
    protected boolean lineHasDiscount()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateEndDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the end discount must be updated for the order.
    /// </summary>
    /// <returns>
    /// true if end discount must be updated; otherwise, false.
    /// </returns>
    protected boolean mustUpdateEndDisc()
    {
        return (this.discPercent() && this.endDisc());
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineMarkupTransExist</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if any <c>MarkupTrans</c> table record is related to any line of the order.
    /// </summary>
    /// <returns>
    ///     Always true.
    /// </returns>
    public boolean lineMarkupTransExist()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineQueryRunGet</Name>
				<Source><![CDATA[
    abstract protected Common lineQueryRunGet(
        TradeTotalsIQueryRun    _lineQueryRun)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineQueryRunNext</Name>
				<Source><![CDATA[
    abstract protected boolean lineQueryRunNext(
        TradeTotalsIQueryRun    _lineQueryRun)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineRecordHasMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if any <c>MarkupTrans</c> table record is related to the specified line record in the specified table
    /// </summary>
    /// <param name="_tableId">
    ///     A <c>RefTableId</c> type.
    /// </param>
    /// <param name="_recId">
    ///     A <c>RefRecId</c> type.
    /// </param>
    /// <returns>
    ///     true if a <c>MarkupTrans</c> table record exist; otherwise, false.
    /// </returns>
    public boolean lineRecordHasMarkup(RefTableId _tableId, RefRecId _recId)
    {
        if (this.lineMarkupTransExist())
        {
            return this.recordHasMarkup(_tableId, _recId);
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupCustVend</Name>
				<Source><![CDATA[
    protected MarkupAmount markupCustVend(Markup _markup)
    {
        return _markup.markupCustVend();
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupFreightAmountCur_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the freight total amount in transaction currency.
    /// </summary>
    /// <returns>Returns the freight total amount.</returns>
    public MarkupAmount markupFreightAmountCur_BR()
    {
        return markupFreightAmountCur_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupFreightAmountMST_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the freight total amount in company currency.
    /// </summary>
    /// <returns>Returns the freight total amount.</returns>
    public MarkupAmount markupFreightAmountMST_BR()
    {
        return CurrencyExchangeHelper::amountCur2MST(markupFreightAmountCur_BR, this.currencyCode(), this.exchRate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupInsuranceAmountCur_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the insurance total amount in transaction currency.
    /// </summary>
    /// <returns>Returns the insurance total amount.</returns>
    public MarkupAmount markupInsuranceAmountCur_BR()
    {
        return markupInsuranceAmountCur_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupInsuranceAmountMST_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the insurance total amount in company currency.
    /// </summary>
    /// <returns>Returns the insurance total amount.</returns>
    public MarkupAmount markupInsuranceAmountMST_BR()
    {
        return CurrencyExchangeHelper::amountCur2MST(markupInsuranceAmountCur_BR, this.currencyCode(), this.exchRate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupLine</Name>
				<Source><![CDATA[
    protected Common markupLine()
    {
        return orderLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupOthersAmountCur_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the other charges total amount in transaction currency.
    /// </summary>
    /// <returns>Returns the other charges total amount.</returns>
    public MarkupAmount markupOthersAmountCur_BR()
    {
        return markupOthersAmountCur_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupOthersAmountMST_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the other charges total amount in company currency.
    /// </summary>
    /// <returns>Returns the other charges total amount.</returns>
    public MarkupAmount markupOthersAmountMST_BR()
    {
        return CurrencyExchangeHelper::amountCur2MST(markupOthersAmountCur_BR, this.currencyCode(), this.exchRate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupTable</Name>
				<Source><![CDATA[
    protected Common markupTable()
    {
        return orderTableMarkup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrCalculateInstallEligibleHeaderAmts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates installment eligible order amounts.
    /// </summary>
    public void mcrCalculateInstallEligibleHeaderAmts()
    {
        SalesLine           salesLine;
        SalesParmLine       salesParmLine;
        MarkUpTrans         markUpTrans;
        AmountCur           taxesPrLine;
        AmountCur           markuptaxes;

        switch (OrderLine.TableId)
        {
            case tablenum(SalesLine):
                if (recordSortedInstallmentListLine)
                {
                    if (recordSortedInstallmentListLine.first(salesLine))
                    {
                        if (tax)
                        {
                            do
                            {
                                taxesPrLine += tax.totalTaxAmountSingleLine(salesLine.TableId, salesLine.RecId);
                            }
                            while (recordSortedInstallmentListLine.next(salesLine));
                        }
                    }
                }

            break;
            case tablenum(SalesparmLine):
                if (recordSortedInstallmentListLine)
                {
                    if (recordSortedInstallmentListLine.first(salesParmLine))
                    {
                        if (tax)
                        {
                            do
                            {
                                salesLine = SalesLine::findRecId(salesParmLine.SalesLineRecId);
                                taxesPrLine += tax.totalTaxAmountSingleLine(salesLine.TableId, salesLine.RecId);
                            }
                            while (recordSortedInstallmentListLine.next(salesParmLine));
                        }
                    }
                }
            break;
        }

        if (recordSortedInstallEligMarkupLines)
        {
            if (recordSortedInstallEligMarkupLines.first(markUpTrans))
            {
                if (tax)
                {
                    do
                    {
                        markupTaxes += tax.totalTaxAmountSingleLine(markUpTrans.TableId, markUpTrans.RecId);
                    }
                    while (recordSortedInstallEligMarkupLines.next(markUpTrans));
                }
            }
        }

        returnInstallmentTax = taxesPrLine+markUpTaxes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrCalculateTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates tax for the specified <paramref name="_tradeCalcTax" />.
    /// </summary>
    /// <param name="_tradeCalcTax">
    ///     The <c>TradeCalcTax</c> to calculate totals on.
    /// </param>
    protected void mcrCalculateTax(TradeCalcTax _tradeCalcTax)
    {
        if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            taxTotal = _tradeCalcTax.calcTax(this);

            // Gets the class variable for the tax associated with the return part
            // of the order.
            returnTaxTotal = _tradeCalcTax.mcrGetReturnTaxTotal();

            this.tax(_tradeCalcTax.tax());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrGetCalcInvoicedDiscounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the amount of discount for the passed invoiced sales order.
    /// </summary>
    /// <param name="_salesTable">
    /// The <c>SalesTable</c> record for which this method finds the amount of discount.
    /// </param>
    /// <returns>
    /// The amount of discount given to the passed invoiced sales order.
    /// </returns>
    public AmountCur mcrGetCalcInvoicedDiscounts(SalesTable _salesTable)
    {
        CustInvoiceJour custInvoiceJour;

        select sum(EndDisc) from custInvoiceJour
            where custInvoiceJour.RefNum == RefNum::SalesOrder
            && custInvoiceJour.SalesId == _salesTable.SalesId;

        return custInvoiceJour.EndDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrGetEndInstallmentDiscBalance</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the end discount balance for the specified <paramref name="_discPct" />.
    /// </summary>
    /// <param name="_discPct">
    ///     The <c>DiscPct</c> record buffer.
    /// </param>
    /// <returns>
    ///     The end discount balance for the specified <paramref name="_discPct" />.
    /// </returns>
    /// <remarks>
    ///     Balance is amount that qualifies for the discount (updated in updateEndDiscBalances).
    /// </remarks>
    public AmountCur mcrGetEndInstallmentDiscBalance(DiscPct _discPct)
    {
        AmountCur endInstallmentDiscBalance;
        if (endDiscInstallmentBalances.exists(_discPct))
        {
            endInstallmentDiscBalance = endDiscInstallmentBalances.lookup(_discPct);
        }
        return endInstallmentDiscBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrGetParmId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the current <c>ParmId</c>.
    /// </summary>
    /// <returns>
    ///     The current <c>ParmId</c>.
    /// </returns>
    ParmId mcrGetParmId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrGetParmTableRefId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the <c>TableRefId</c> field from the <c>SalesParmTable</c>.
    /// </summary>
    /// <returns>
    ///     The <c>TableRefId</c> field from the <c>SalesParmTable</c>.
    /// </returns>
    TradeLineRefId mcrGetParmTableRefId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrGetTotalPostitiveLineAmountDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the line amount for a sales order line based on the passed parameters.
    /// </summary>
    /// <param name="priceDiscLine">
    /// The <c>PriceDiscLine</c> record used to find the appropriate sales order line.
    /// </param>
    /// <param name="_salesTable">
    /// The <c>SalesTable</c> record used to find the appropriate sales order line.
    /// </param>
    /// <returns>
    /// The line amount of the <c>SalesLine</c> record found based on the passed parameters.
    /// </returns>
    public AmountCur mcrGetTotalPostitiveLineAmountDisc(PriceDiscLine   priceDiscLine, SalesTable _salesTable)
    {
        InventTableModule  inventTableModule;
        SalesLine salesLine;

        select sum(LineAmount) from salesLine
            where salesLine.salesId == _salesTable.SalesId
                && salesLine.SalesQty > 0
            join priceDiscLine
                group by ItemId
                where priceDiscLine.SalesPurchId   == _salesTable.SalesId
                && priceDiscLine.ItemId == salesLine.ItemId
            join inventTableModule
                group by EndDisc
                where inventTableModule.ItemId     == priceDiscLine.ItemId  &&
                    inventTableModule.ModuleType == ModuleInventPurchSales::Sales &&
                    inventTableModule.EndDisc    == NoYes::Yes;

        return salesLine.LineAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrInitRecordSortedListLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates and returns a <c>RecordSortedList</c> for the specified <paramref name="_tableId" />.
    /// </summary>
    /// <param name="_tableId">
    ///     The <c>TableId</c> of the table used to create the <c>RecordSortedList</c>.
    /// </param>
    /// <returns>
    ///     A <c>RecordSortedList</c> for the specified <paramref name="_tableId" />.
    /// </returns>
    protected RecordSortedList mcrInitRecordSortedListLine(TableId _tableId)
    {
        RecordSortedList        recordSortedList;
        switch (_tableId)
        {
            case tablenum(SalesLine):

                recordSortedList = new RecordSortedList(tablenum(SalesLine));
                recordSortedList.sortOrder(fieldNum(SalesLine, RecId));

            break;
            case tablenum(MarkUpTrans):

                recordSortedList = new RecordSortedList(tablenum(MarkUpTrans));
                recordSortedList.sortOrder(fieldNum(MarkUpTrans, RecId));

            break;
            case tablenum(SalesParmLine):

                recordSortedList = new RecordSortedList(tablenum(SalesParmLine));
                recordSortedList.sortOrder(fieldNum(SalesParmLine, RecId));

            break;
            case tablenum(MarkUpTable):

                recordSortedList = new RecordSortedList(tablenum(MarkUpTable));
                recordSortedList.sortOrder(fieldNum(MarkUpTable, RecId));

            break;
        }
        return recordSortedList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrIsLineInstallmentEligible</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns a <c>Boolean</c> value indicating if the <c>SalesLine</c> is installment eligible.
    /// </summary>
    /// <returns>
    ///     true if the line is installment eligible; otherwise, false.
    /// </returns>
    protected boolean mcrIsLineInstallmentEligible()
    {
        SalesParmLine   salesParmLine;
        RecId           salesLineRecId;
        boolean         isInstallmentEligible = false;

        // The line may be related to the <c>SalesParmLine</c> table
        // or the <c>SalesLine</c> table - consider both cases.
        if (orderLine.TableId == tablenum(SalesParmLine))
        {
            salesParmLine = orderLine;
            salesLineRecId = salesParmLine.SalesLineRecId;
        }
        else if (orderLine.TableId == tablenum(SalesLine))
        {
            salesLineRecId = orderLine.RecId;
        }

        if (salesLineRecId
            && MCRSalesLine::findSalesLine(salesLineRecId).InstallmentEligible)
        {
            isInstallmentEligible = true;
        }

        return isInstallmentEligible;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrMarkupCoupon</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the miscellaneous charge subtotal by type.
    /// </summary>
    /// <returns>
    ///     The miscellaneous charge subtotal by type.
    /// </returns>
    public MarkupAmount mcrMarkupCoupon()
    {
        return markupCoupon;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrOrderBalanceAbsoluteValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the absolute value balance for the specified <paramref name="_recId" />.
    /// </summary>
    /// <param name="_recId">
    ///     The <c>RecId</c> to find the absolute value of.
    /// </param>
    /// <returns>
    ///     The absolute value for the specified <paramref name="_recId" />.
    /// </returns>
    protected AmountCur mcrOrderBalanceAbsoluteValue(RecId _recId)
    {
        AmountCur   orderBalance;

        if (MCROrderBalancesAbsoluteValue.exists(_recid))
        {
            orderBalance = MCROrderBalancesAbsoluteValue.lookup(_recId);
        }

        return orderBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrRecordSortedListLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns a <c>RecordSortedList</c> containing the order line record buffers.
    /// </summary>
    /// <returns>
    ///     A <c>RecordSortedList</c> containing the order line record buffers.
    /// </returns>
    /// <remarks>
    ///     This method duplicates some of the work done in calc to retrieve records.
    ///     Note that this resets the data for trade totals and should therefore not be called for normal
    ///     calculation scenarios.
    ///     The use of this method is to get the records that would normally be used in a calculation
    ///     without actually doing the calculation.  This is currently used to speed up performance of
    ///     picking and packing.  See <c>MCRInitFromSalesTotals</c> method in <c>SalesFormLetter_PickingList</c> and
    ///     SalesFormLetter_PackingSlip.
    /// </remarks>
    public RecordSortedList mcrRecordSortedListLine()
    {
        TradeTotalsIQueryRun    lineQueryRun;

        lineQueryRun = this.createLineQueryRun();

        if (!recordSortedListLine)
        {
            this.initRecordSortedListLine();
        }
        while (this.lineQueryRunNext(lineQueryRun))
        {
            orderLine = this.lineQueryRunGet(lineQueryRun);

            if (this.skipLine(orderLine))
            {
                continue;
            }

            recordSortedListLine.ins(orderLine);
        }
        return recordSortedListLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrRemainingMarkupCoupon</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the remaining markup coupon amount.
    /// </summary>
    /// <returns>
    ///     The remaining markup coupon amount.
    /// </returns>
    public MarkupAmount mcrRemainingMarkupCoupon()
    {
        return markupCoupon;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrReturnDiscPercent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the return order discount percent.
    /// </summary>
    /// <returns>
    /// The return order discount percent.
    /// </returns>
    protected DiscPct mcrReturnDiscPercent()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrReturnInstallmentEligibleAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the eligible amount for installment billing.
    /// </summary>
    /// <returns>
    /// The amount eligible for installment billing.
    /// </returns>
    public AmountCur mcrReturnInstallmentEligibleAmount()
    {
        return returnInstallmentBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrReturnInstallmentEligibleMarkUpLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the installment billing eligible amount for an order line.
    /// </summary>
    /// <returns>
    /// The amount eligible for installment billing on an order line.
    /// </returns>
    public AmountCur mcrReturnInstallmentEligibleMarkUpLine()
    {
        return markUpInstallmentLineAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrReturnInstallmentEligibleMarkUpTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the installment billing eligible amount for an order.
    /// </summary>
    /// <returns>
    /// The amount eligible for installment billing on an order.
    /// </returns>
    public AmountCur mcrReturnInstallmentEligibleMarkUpTotal()
    {
        return markUpInstallEligTotalAmt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrReturnInstallmentEligibleTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the taxes calculated on the sales order lines that were deemed to be installment eligible.
    /// </summary>
    /// <returns>
    ///     The calculated taxes for installment eligible <c>SalesLines</c>.
    /// </returns>
    TaxAmountCur mcrReturnInstallmentEligibleTax()
    {
        return returnInstallmentTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrReturnInstallmentEligibleTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total amount eligible for installment billing.
    /// </summary>
    /// <returns>
    /// The total amount eligible for installment billing.
    /// </returns>
    public Amountcur mcrReturnInstallmentEligibleTotal()
    {
        AmountCur   totalEligibleAmount = 0;

        totalEligibleAmount = this.mcrReturnInstallmentEligibleAmount()
                            + this.mcrReturnInstallmentEligibleMarkUpTotal()
                            + this.mcrReturnInstallmentEligibleTax()
                            - this.mcrTotalEndInstallmentDisc();

        return totalEligibleAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrReturnMarkupInstallEligibleCoupon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the eligible amount of the installment order with a coupon.
    /// </summary>
    /// <returns>
    /// The eligible amount of the installment order with a coupon.
    /// </returns>
    public MarkUpAmount mcrReturnMarkupInstallEligibleCoupon()
    {
        return markUpInstallmentCoupon;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrReturnTotalAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the total amount for the return portion of the order.
    /// </summary>
    /// <returns>
    ///     The total amount for the return portion of the order.
    /// </returns>
    public AmountCur mcrReturnTotalAmount()
    {
        if (!returnTotalAmountCalculated)
        {
            this.calculateTotalAmount();
            returnTotalAmount = this.mcrReturntotalAmountUnRounded() + this.mcrReturnTotalRoundOff();
            returnTotalAmountCalculated = true;
        }

        return returnTotalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrReturnTotalAmountUnRounded</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the unrounded total amount for the return portion of the order.
    /// </summary>
    /// <returns>
    ///     The unrounded total amount for the return portion of the order.
    /// </returns>
    public AmountCur mcrReturnTotalAmountUnRounded()
    {
        if (!returnTotalAmountUnRoundedCalculated)
        {
            this.calculateTotalAmount();

            returnBalance               = this.mcrTotalReturnBalance();
            markupReturnLineAmount      = this.mcrTotalReturnMarkupLine();

            returnEndDisc               = this.mcrReturnTotalEndDisc();

            returnTaxTotal              = this.mcrReturnTotalTaxAmount();

            returnTotalAmountUnRounded  = returnBalance - returnEndDisc +
                                            markupReturnLineAmount - (returnTaxTotal);

            returnTotalAmountUnRoundedCalculated  = true;
        }

        return returnTotalAmountUnRounded;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrReturnTotalEndDisc</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the dollar amount of the total order discounts for the return portion of the order.
    /// </summary>
    /// <returns>
    ///     The dollar amount of the total order discounts for the return portion of the order.
    /// </returns>
    public DiscAmount mcrReturnTotalEndDisc()
    {
        MapEnumerator   returnEndDiscBalancesEnumerator;

        if (!returnEndDiscCalculated)
        {
            this.calculateBalance();

            returnEndDiscBalancesEnumerator = returnEndDiscBalances.getEnumerator();

            while (returnEndDiscBalancesEnumerator.moveNext())
            {
                returnEndDisc += returnEndDiscBalancesEnumerator.current() * returnEndDiscBalancesEnumerator.currentValue() / 100;
            }

            returnEndDisc = CurrencyExchangeHelper::amount(returnEndDisc, this.currencyCode());

            returnEndDiscCalculated = true;
        }
        return returnEndDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrReturnTotalRoundOff</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the round off total of the return portion of the order.
    /// </summary>
    /// <returns>
    ///     The rounded off total of the return portion of the order.
    /// </returns>
    public RoundOff mcrReturnTotalRoundOff()
    {
        if (!returnRoundOffCalculated)
        {
            if (this.mcrReturnTotalAmountUnRounded())
            {
                returnRoundOff        = this.roundedOffTotalAmount(this.mcrReturnTotalAmountUnRounded()) - this.mcrReturnTotalAmountUnRounded();
            }

            returnRoundOffCalculated = true;
        }

        return returnRoundOff;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrReturnTotalTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates the tax amount for the return portion of the order.
    /// </summary>
    /// <returns>
    ///     The calculated tax amount for the return portion of the order.
    /// </returns>
    public TaxAmountCur mcrReturnTotalTaxAmount()
    {
        this.calculateTaxAmount();

        return returnTaxTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrSalesParmTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the <c>SalesParmTable</c> variable from the class.
    /// </summary>
    /// <returns>
    ///     The <c>SalesParmTable</c> record buffer.
    /// </returns>
    SalesParmTable mcrSalesParmTable()
    {
        SalesParmTable salesParmTable;

        return salesParmTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrTotalBalanceAbsoluteValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the absolute value of the total balance amount.
    /// </summary>
    /// <returns>
    ///     The absolute value of the total balance amount.
    /// </returns>
    public AmountCur mcrTotalBalanceAbsoluteValue()
    {
        this.calculateBalance();

        return MCRBalanceAbsoluteValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrTotalEndInstallmentDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves and returns the total discount of an installment order.
    /// </summary>
    /// <returns>
    /// The total discount of an installment order.
    /// </returns>
    public DiscAmount mcrTotalEndInstallmentDisc()
    {
        MapEnumerator   endInstalDiscBalancesEnumerator;

        if (!endInstallmentDiscCalculated)
        {
            this.calculateBalance();

            endInstalDiscBalancesEnumerator = endDiscInstallmentBalances.getEnumerator();

            while (endInstalDiscBalancesEnumerator.moveNext())
            {
                endInstallmentDisc += endInstalDiscBalancesEnumerator.current() * endInstalDiscBalancesEnumerator.currentValue() / 100;
            }

            endInstallmentDisc = CurrencyExchangeHelper::amount(endInstallmentDisc, this.currencyCode());

            endInstallmentDiscCalculated = true;
        }

        return endInstallmentDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrTotalLineInstallmentDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total discount of an installment order line.
    /// </summary>
    /// <returns>
    /// The total discount of an installment order line.
    /// </returns>
    public DiscAmount mcrTotalLineInstallmentDisc()
    {
        this.calculateBalance();

        return lineInstallmentDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrTotalOrderBalanceAbsoluteValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the absolute value balance for the specified <paramref name="_recId" />.
    /// </summary>
    /// <param name="_recId">
    ///     The <c>RecId</c> that specifies which buffer to return the balance for.
    /// </param>
    /// <returns>
    ///     The absolute value balance for the specified <paramref name="_recId" />.
    /// </returns>
    /// <remarks>
    ///     Same as totalOrderBalance() except returning the absolute value balance stored in
    ///     orderBalancesAbsoluteValue map.
    ///     See updateOrderBalances method for comments on why absolute value is being tracked.
    /// </remarks>
    public AmountCur mcrTotalOrderBalanceAbsoluteValue(RecId _recId)
    {
        this.calculateBalance();

        return this.mcrOrderBalanceAbsoluteValue(_recId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrTotalOrderDiscount_Invoice</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the discount total for returns and return/regular orders.
    /// </summary>
    /// <param name="_salesBalance">
    ///     The amount to use for the positive balance if the user has overridden the discount percentage.
    /// </param>
    /// <returns>
    ///     The amount of the discount total for the return or return/regular order.
    /// </returns>
    AmountCur mcrTotalOrderDiscount_Invoice(AmountCur _salesBalance)
    {
        InventTableModule   inventTableModule;
        InventTableModule   inventTableModuleParm;
        SalesLine           salesLine;
        AmountCur           totalPostiveAmtForDisc;
        AmountCur           positiveDiscAmt;
        PriceDisc           priceDisc;
        SalesParmTable      salesParmTable;
        SalesParmLine       salesParmLine;
        SalesTable          salesTable;
        AmountCur           returnDiscAmt;
        AmountCur           totalDiscAmt;
        SalesTable          originalSalesTable;
        SalesLine           originalSalesLine;
        AmountCur           salesBalance;
        salesLine           kitSalesLine;
        InventTableModule   kitInventTableModule;
        MCRSalesLine        mcrSalesLine;

        salesTable = orderTable;

        // Get the total positive sales balance
        select sum(LineAmount) from salesLine
            where salesLine.SalesId   == salesTable.SalesId
                && salesLine.SalesQty > 0
            exists join inventTableModule
            where inventTableModule.ItemId == salesLine.ItemId
                && inventTableModule.ModuleType == ModuleInventPurchSales::Sales
            exists join mcrSalesLine
            where mcrSalesLine.SalesLine == salesLine.RecId
            exists join kitSalesLine
            where kitSalesLine.InventTransId == mcrSalesLine.ParentLotId
            exists join kitInventTableModule
            where kitInventTableModule.ItemId == kitSalesLine.ItemId
                && kitInventTableModule.ModuleType == ModuleInventPurchSales::Sales
                && kitInventTableModule.EndDisc == NoYes::Yes;

        salesBalance = salesLine.LineAmount;

        salesParmTable = this.mcrSalesParmTable();
        if (salesParmTable)
        {
            while select salesParmLine
                where salesParmLine.ParmId  == salesParmTable.ParmId
                exists join inventTableModuleParm
                    where inventTableModuleParm.ItemId == salesParmLine.ItemId
                        && inventTableModuleParm.ModuleType == ModuleInventPurchSales::Sales
                        && inventTableModuleParm.EndDisc == NoYes::Yes
            {
                if (salesParmLine.salesQty()>0)
                {
                    totalPostiveAmtForDisc += salesParmLine.LineAmount;
                }
                // Returns
                else
                {
                    // get the original sales order's total
                    salesLine = SalesLine::findRecId(salesParmLine.SalesLineRecId);
                    originalSalesLine = SalesLine::findInventTransId(salesLine.InventTransIdReturn);
                    originalSalesTable = SalesTable::find(originalSalesLine.SalesId);

                    returnDiscAmt += originalSalesTable.DiscPercent * salesParmLine.LineAmount / 100;
                }
            }

            // If the user has overridden the discount percent
            // use the user's percent on the positive lines.
            // The return discount amount will remain the same because it is calculated
            // based on the original sales order.
            if (totalPostiveAmtForDisc)
            {
                if (#MCRPriceOverrideEnabled && salesTable.mcrSalesTable().PriceOverride == NoYes::Yes)
                {
                    positiveDiscAmt = _salesBalance * (salesTable.DiscPercent / 100);
                }
                else
                {
                    priceDisc = this.createPriceDiscInstance(this.createAndInitPriceDiscParametersForInvoice(salesParmLine, salesTable));

                    if (priceDisc.findEndDisc(salesTable.EndDisc, totalPostiveAmtForDisc, salesBalance))
                    {
                        if (priceDisc.getDiscAmount() * totalPostiveAmtForDisc != 0)
                        {
                            positiveDiscAmt =  priceDisc.getDiscAmount();
                        }
                    }
                    else
                    {
                        positiveDiscAmt = 0;
                    }
                }
                positiveDiscAmt = CurrencyExchangeHelper::amountCur2MST(positiveDiscAmt, this.currencyCode());
            }

            totalDiscAmt = abs(positiveDiscAmt) + returnDiscAmt;
        }

        return totalDiscAmt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPriceDiscParametersForInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>PriceDiscParameters</c> class.
    /// </summary>
    /// <returns>An instance of the <c>PriceDiscParameters</c> class.</returns>
    protected PriceDiscParameters createPriceDiscParametersForInvoice()
    {
        return PriceDiscParameters::construct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndInitPriceDiscParametersForInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and initializes an instance of the <c>PriceDiscParameters</c> class.
    /// </summary>
    /// <returns>An instance of the <c>PriceDiscParameters</c> class.</returns>
    protected PriceDiscParameters createAndInitPriceDiscParametersForInvoice(SalesParmLine _salesParmLine, SalesTable _salesTable)
    {
        PriceDiscParameters parameters = this.createPriceDiscParametersForInvoice();

        parameters.parmModuleType(ModuleInventPurchSales::Sales);
        parameters.parmItemId(_salesParmLine.ItemId);
        parameters.parmInventDim(_salesParmLine.inventDim());
        parameters.parmUnitID(_salesParmLine.salesUnit());
        parameters.parmPriceDiscDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
        parameters.parmQty(_salesParmLine.DeliverNow);
        parameters.parmAccountNum(_salesTable.CustAccount);
        parameters.parmCurrencyCode(_salesTable.CurrencyCode);

        return parameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrTotalOrderDiscount_Sales</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the discount total for the for the sales order.
    /// </summary>
    /// <param name="_salesBalance">
    ///     The amount to use for the positive balance if the user has overridden the discount percentage.
    /// </param>
    /// <returns>
    ///     The discount total for the sales order.
    /// </returns>
    AmountCur mcrTotalOrderDiscount_Sales(AmountCur _salesBalance)
    {
        InventTableModule  inventTableModule;
        SalesLine salesLine, salesLineMap;
        AmountCur totalPositiveAmtForDisc;
        AmountCur oldDiscTotal;
        AmountCur returnableDisc;
        AmountCur originalDiscAmt;
        AmountCur returnDiscAmt;
        AmountCur invoicedDiscs;

        SalesTable      originalSalesTable;
        SalesLine       originalSalesLine;
        SalesTable      salesTable;

        salesTable = orderTable;

        while select salesLine
            where salesLine.SalesId   == salesTable.SalesId
            exists join recId from inventTableModule
                where inventTableModule.ItemId     == salesLine.ItemId
                    && inventTableModule.ModuleType == ModuleInventPurchSales::Sales
                    && inventTableModule.EndDisc == NoYes::Yes
        {
            if (salesLine.SalesQty > 0)
            {
                totalPositiveAmtForDisc += salesLine.LineAmount;
            }
            else if ((salesLine.SalesQty < 0) && salesLine.InventTransIdReturn) // is return and is credit note
            {
                // get the original sales order's total
                originalSalesLine = SalesLine::findInventTransId(salesLine.InventTransIdReturn);
                originalSalesTable = SalesTable::find(originalSalesLine.SalesId);
                oldDiscTotal = this.mcrGetTotalPostitiveLineAmountDisc(salesLineMap, originalSalesTable);
                returnDiscAmt += -(originalSalesTable.DiscPercent * oldDiscTotal / 100)  * (salesLine.SalesQty / originalSalesLine.SalesQty);
            }
        }

        if (_salesBalance == 0)
        {
            _salesBalance = totalPositiveAmtForDisc;
        }

        // If the user has overridden the discount percent
        // use the user's percent on the positive lines.
        // The return discount amount will remain the same because it is calculated
        // based on the original sales order.
        if (#MCRPriceOverrideEnabled && salesTable.mcrSalesTable().PriceOverride == NoYes::Yes)
        {
            originalDiscAmt = _salesBalance * (salesTable.DiscPercent / 100);
        }
        else
        {
            PriceDisc priceDisc = this.createPriceDiscInstance(this.createAndInitPriceDiscParametersForTotalDiscount(salesTable, salesLine));

            if (priceDisc.findEndDisc(salesTable.EndDisc, _salesBalance, totalPositiveAmtForDisc))
            {
                if (priceDisc.getDiscAmount() * totalPositiveAmtForDisc != 0)
                {
                    // The discPercent was being rounded to 2 decimal places, remove the function call
                    // to round this value.
                    originalDiscAmt =  priceDisc.getDiscAmount();
                }
            }
            else
            {
                originalDiscAmt = 0;
            }
        }

        // originalDiscAmt should be positive, and returnDiscAmt should be negative.
        // This is because the work discount on the recap form implies that it is negative event though
        // it will not show as negative, and the opposite for returns.
        if (salesTable.SalesType == SalesType::ReturnItem
        || salesTable.mcrAnySalesLinesNegative())
        {
            if (abs(originalDiscAmt)==abs(returnDiscAmt))
            {
                returnableDisc = abs(originalDiscAmt);
            }
            else
            {
                if (originalDiscAmt != 0)
                {
                    returnableDisc = originalDiscAmt - returnDiscAmt;
                }
                else
                {
                    returnableDisc = returnDiscAmt;
                }
            }
        }
        else
        {
            // check if any part has been invoiced because if
            // it is it needs to be taken out of the original discount amount
            if (CustInvoiceJour::exist(salesTable.SalesId))
            {
                invoicedDiscs = this.mcrGetCalcInvoicedDiscounts(salesTable);
                if (originalDiscAmt > invoicedDiscs)
                {
                    returnableDisc = originalDiscAmt-invoicedDiscs + returnDiscAmt;
                }
                else
                {
                     returnableDisc = originalDiscAmt + returnDiscAmt;
                }
            }
            else
            {
                returnableDisc = originalDiscAmt + returnDiscAmt;
            }
        }

        returnableDisc = CurrencyExchangeHelper::amountCur2MST(returnableDisc, this.currencyCode());

        // if the line is negative , the discount needs to be
        // added else subtracted.
        if (_salesBalance <0)
        {
            returnableDisc = -returnableDisc;
        }
        return returnableDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPriceDiscInstance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>PriceDisc</c> class based on the parameters.
    /// </summary>
    /// <param name = "_parameters">An instance of the <c>PriceDiscParameters</c> class.</param>
    /// <returns>An instance of PriceDisc.</returns>
    protected PriceDisc createPriceDiscInstance(PriceDiscParameters _parameters)
    {
        return PriceDisc::newFromPriceDiscParameters(_parameters);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPriceDiscParametersForTotalDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>PriceDiscParameters</c> class.
    /// </summary>
    /// <returns>An instance of the <c>PriceDiscParameters</c> class.</returns>
    protected PriceDiscParameters createPriceDiscParametersForTotalDiscount()
    {
        return PriceDiscParameters::construct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndInitPriceDiscParametersForTotalDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>PriceDiscParameters</c> from the given parameters.
    /// </summary>
    /// <param name = "_salesTable">A <c>SalesTable</c> record.</param>
    /// <param name = "_salesLine">A <c>SalesLine</c> record.</param>
    /// <returns>An instance of PriceDiscParameters.</returns>
    protected PriceDiscParameters createAndInitPriceDiscParametersForTotalDiscount(SalesTable _salesTable, SalesLine _salesLine)
    {
        PriceDiscParameters parameters = this.createPriceDiscParametersForTotalDiscount();

        parameters.parmModuleType(ModuleInventPurchSales::Sales);
        parameters.parmItemId(_salesLine.ItemId);
        parameters.parmInventDim(_salesLine.inventDim());
        parameters.parmUnitID(_salesLine.SalesUnit);
        parameters.parmPriceDiscDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
        parameters.parmQty(_salesLine.SalesQty);
        parameters.parmAccountNum(_salesTable.CustAccount);
        parameters.parmCurrencyCode(_salesTable.CurrencyCode);

        return parameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrTotalReturnBalance</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the product total of the return half of the sales order, if any.
    /// </summary>
    /// <returns>
    ///     The product total of the return half of the sales order.
    /// </returns>
    public AmountCur mcrTotalReturnBalance()
    {
        this.calculateBalance();

        return returnbalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrTotalReturnMarkupLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the miscellaneous charges, that are return miscellaneous charges, on the sales line.
    /// </summary>
    /// <returns>
    ///     The total of the miscellaneous charges for returns.
    /// </returns>
    public MarkupAmount mcrTotalReturnMarkupLine()
    {
        this.calculateMarkupLineAmount();

        return markupReturnLineAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrTotalReturnOrderDiscount_Quotes</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the total discount for returns and return/regular order.
    /// </summary>
    /// <returns>
    ///     The total discount amount for the return order.
    /// </returns>
    real mcrTotalReturnOrderDiscount_Quotes()
    {
        Real returnableDisc;
        Real originalDiscAmt;

        originalDiscAmt = this.totalEndDisc();

        // originalDiscAmt should be positive, and returnDiscAmt should be negative.
        // This is because the work discount on the recap form implies that it is negative event though
        // it will not show as negative, and the opposite for returns.
        returnableDisc = originalDiscAmt;

        returnableDisc = CurrencyExchangeHelper::amount(returnableDisc, this.currencyCode());

        return returnableDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrUpdateEndDiscInstallmentBalances</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates the end discount installment balances using the specified <paramref name="_amountCur" />.
    /// </summary>
    /// <param name="_amountCur">
    ///     The amount to update the end discount installment balances.
    /// </param>
    private void mcrUpdateEndDiscInstallmentBalances(AmountCur _amountCur)
    {
        DiscPct     discPercent = this.discPercent();
        AmountCur   endDiscInstalBalance;
        DiscPct     returnDiscPercent;
        AmountCur   returnEndDiscInstalBalance;

        if (discPercent && _amountCur > 0)
        {
            if (endDiscInstallmentBalances.exists(discPercent))
            {
                endDiscInstalBalance = endDiscInstallmentBalances.lookup(discPercent);
            }

            endDiscInstalBalance += _amountCur;
            endDiscInstallmentBalances.insert(discPercent, endDiscInstalBalance);
        }

        if (_amountCur < 0) // indicates a return line
        {
            returnDiscPercent = this.mcrReturnDiscPercent();
            if (returnDiscPercent)
            {
                if (returnEndDiscInstalBalances.exists(returnDiscPercent))
                {
                    returnEndDiscInstalBalance = returnEndDiscInstalBalances.lookup(returnDiscPercent);
                }

                returnEndDiscInstalBalance += _amountCur;
                returnEndDiscInstalBalances.insert(returnDiscPercent, returnEndDiscInstalBalance);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new(Common         _orderTable)
    {
        this.init(_orderTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    protected void init(Common _orderTable)
    {
        orderTable          = _orderTable;

        calculateCostValue              = false;
        calculateBalance                = false;
        calculateMarkupLineAmount       = false;
        calculateMarkupTableAmount      = false;
        calculateQuantities             = false;
        calculateRemainQuantities       = false;
        calculateTaxAmount              = false;

        costValueCalculated             = false;
        balanceCalculated               = false;
        markupLineAmountCalculated      = false;
        markupTableAmountCalculated     = false;
        markupTableAmountTaxCalculated  = false;
        quantitiesCalculated            = false;
        remainQuantitiesCalculated      = false;
        taxAmountCalculated             = false;

        freeValueCalculated             = false;
        cashDiscCalculated              = false;
        totalAmountUnRoundedCalculated  = false;
        roundOffCalculated              = false;
        endDiscCalculated               = false;
        totalAmountCalculated           = false;
        onlyOneCashDiscOnInvoice        = true;

        // <GEERU>
        countryRegion_RU                = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        this.initRecordSortedListLine();

        instrumentationLogger = TradeInstrumentationLogger::createLogger(classId2Name(classIdGet(this)));

        this.clear();
    }

]]></Source>
			</Method>
			<Method>
				<Name>nextLine</Name>
				<Source><![CDATA[
    protected boolean nextLine(QueryRun _queryRun)
    {
        return _queryRun.next();
    }

]]></Source>
			</Method>
			<Method>
				<Name>orderBalance</Name>
				<Source><![CDATA[
    protected AmountCur orderBalance(RecId _recId)
    {
        AmountCur   orderBalance;

        if (orderBalances.exists(_recId))
        {
            orderBalance = orderBalances.lookup(_recId);
        }

        return orderBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineRoundedOrderBalance</Name>
				<Source><![CDATA[
    private AmountCur lineRoundedOrderBalance(RecId _recId)
    {
        AmountCur   lineRoundedOrderBalance;

        if (lineRoundedOrderBalances.exists(_recId))
        {
            lineRoundedOrderBalance = lineRoundedOrderBalances.lookup(_recId);
        }

        return lineRoundedOrderBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineAdjustment</Name>
				<Source><![CDATA[
    public AmountCur lineAdjustment(RecId _recId)
    {
        AmountCur   lineAdjustment;

        if (lineBalanceAdjustments.exists(_recId))
        {
            lineAdjustment = lineBalanceAdjustments.lookup(_recId);
        }

        return lineAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineMarkupTotalAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total line markup amount for a line.
    /// </summary>
    /// <param name = "_recId">The record ID that identifies the line.</param>
    /// <returns>The total line markup amount for a line.</returns>
    public AmountCur lineMarkupTotalAmount(RecId _recId)
    {
        AmountCur   lineMarkupTotalAmount;

        if (lineMarkupTotalAmounts.exists(_recId))
        {
            lineMarkupTotalAmount = lineMarkupTotalAmounts.lookup(_recId);
        }

        return lineMarkupTotalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>orderLine_orderTable</Name>
				<Source><![CDATA[
    protected Common orderLine_orderTable()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCalculateTotalsBySigns_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Property - calculate totals by their signs or not.
    /// </summary>
    /// <param name="_value">
    ///   A new value.
    /// </param>
    /// <returns>
    ///  A current value.
    /// </returns>
    public boolean parmCalculateTotalsBySigns_RU(boolean _value = calculateTotalsBySigns_RU)
    {
        calculateTotalsBySigns_RU = _value;
        return calculateTotalsBySigns_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmGoodsInRouteId_RU</Name>
				<Source><![CDATA[
    public GoodsInRouteId_RU parmGoodsInRouteId_RU(GoodsInRouteId_RU _goodsInRouteId = goodsInRouteId)
    {
        goodsInRouteId = _goodsInRouteId;
        return goodsInRouteId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesInvoicePostingType_RU</Name>
				<Source><![CDATA[
    public SalesInvoicePostingType_RU parmSalesInvoicePostingType_RU(SalesInvoicePostingType_RU _salesInvoicePostingType = salesInvoicePostingType)
    {
        salesInvoicePostingType = _salesInvoicePostingType;
        return salesInvoicePostingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymCode</Name>
				<Source><![CDATA[
    public PaymTermId paymCode()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymDayId</Name>
				<Source><![CDATA[
    public PaymDayId paymDayId()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWQtyRemain</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the quantity that remains in catch weight units.
    /// </summary>
    /// <returns>
    ///    The quantity that remains in catch weight units.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The method is not implemented in a derived class.
    /// </exception>
    protected PdsCWInventQty  pdsCWQtyRemain()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWQtyUnit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the order line quantity in catch weight units.
    /// </summary>
    /// <returns>
    ///    The order line quantity in catch weight units.
    /// </returns>
    protected PdsCWInventQty pdsCWQtyUnit()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWTotalQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the total order quantity in catch weight units.
    /// </summary>
    /// <returns>
    ///    The order quantity in catch weight units.
    /// </returns>
    public PdsCWInventQty pdsCWTotalQty()
    {
        this.calculateQuantities();
        return pdsCWQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWTotalRemainQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates and gets the remaining catch weight quantity.
    /// </summary>
    /// <returns>
    ///     The remaining catch weight quantity;
    /// </returns>
    public PdsCWInventQty  pdsCWTotalRemainQty()
    {
        this.calculateRemainQuantities();

        return pdsCWQtyRemain;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTotalContributionMargin_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the contribution margin subtracted of included taxes.
    /// </summary>
    /// <param name="_returnValue">
    ///     Contribution margin retuned by totalContributionMargin.
    /// </param>
    /// <returns>
    ///     Contribution margin.
    /// </returns>
    public SalesContributionMargin postTotalContributionMargin_BR(SalesContributionMargin _returnValue)
    {
        _returnValue -= this.tax().totalTaxIncludedInPrice_BR();

        return _returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postUpdateOrderBalances_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Update the products and services amount.
    /// </summary>
    /// <param name="_amountCur">
    ///     Amount of the current line.
    /// </param>
    private void postUpdateOrderBalances_BR(AmountCur _amountCur)
    {
        AmountMST amountMST = CurrencyExchangeHelper::amountCur2MST(_amountCur, this.currencyCode(), this.exchRate());

        if (inventTable)
        {
            switch (inventTable.ItemType)
            {
                case ItemType::Item :
                    productsTotalAmount_BR += amountMST;
                    break;

                case ItemType::Service :
                    servicesTotalAmount_BR += amountMST;
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareBalanceCalculation</Name>
				<Source><![CDATA[
    public void prepareBalanceCalculation()
    {
        calculateBalance  = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareCostValueCalculation</Name>
				<Source><![CDATA[
    public void prepareCostValueCalculation()
    {
        calculateCostValue  = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareMarkupAmountCalculation</Name>
				<Source><![CDATA[
    public void prepareMarkupAmountCalculation()
    {
        this.prepareMarkupLineAmountCalculation();
        this.prepareMarkupTableAmountCalculation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareMarkupLineAmountCalculation</Name>
				<Source><![CDATA[
    public void prepareMarkupLineAmountCalculation()
    {
        calculateMarkupLineAmount = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareMarkupTableAmountCalculation</Name>
				<Source><![CDATA[
    public void prepareMarkupTableAmountCalculation()
    {
        calculateMarkupTableAmount = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareQuantitiesCalculation</Name>
				<Source><![CDATA[
    public void prepareQuantitiesCalculation()
    {
        calculateQuantities = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareRemainQuantitiesCalculation</Name>
				<Source><![CDATA[
    public void prepareRemainQuantitiesCalculation()
    {
        calculateRemainQuantities = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareTaxAmountCalculation</Name>
				<Source><![CDATA[
    public void prepareTaxAmountCalculation()
    {
        calculateTaxAmount  = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareTotalAmountCalculation</Name>
				<Source><![CDATA[
    public void prepareTotalAmountCalculation()
    {
        this.prepareBalanceCalculation();
        this.prepareMarkupAmountCalculation();
        this.prepareTaxAmountCalculation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>productsTotalAmount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total products amount of the order.
    /// </summary>
    /// <returns>Returns the total products amount.</returns>
    public OrderBalanceMST productsTotalAmount_BR()
    {
        return productsTotalAmount_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyInvent</Name>
				<Source><![CDATA[
    protected InventQty  qtyInvent()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyInventoryUnits</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the order line quantity in inventory units.
    /// </summary>
    /// <param name="_unitQty">
    /// The order line quantity in order line units.
    /// </param>
    /// <returns>
    /// The order line quantity in inventory units.
    /// </returns>
    /// <remarks>
    /// For non-inventoried lines the <paramref name="_unitQty" /> parameter is converted to inventory
    /// units.
    /// </remarks>
    private InventQty qtyInventoryUnits(UnitQty _unitQty)
    {
        if (this.isStocked())
        {
            return this.qtyInvent();
        }
        else
        {
            if (this.isCategoryBased())
            {
                return _unitQty;
            }
            else
            {
                return this.unitQtyInInventoryUnits(_unitQty);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyInventRemain</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the quantity that remains in inventory units.
    /// </summary>
    /// <returns>
    ///    The quantity that remains in inventory units.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The method is not implemented in a derived class.
    /// </exception>
    protected InventQty  qtyInventRemain()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyRemainInventoryUnits</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the quantity that remains in inventory units.
    /// </summary>
    /// <returns>
    ///    The quantity that remains in inventory units.
    /// </returns>
    /// <remarks>
    ///    For non-inventoried lines the quantity is converted from the quantity in order line units.
    /// </remarks>
    private InventQty qtyRemainInventoryUnits()
    {
        if (this.isStocked())
        {
            return this.qtyInventRemain();
        }
        else
        {
            if (this.isCategoryBased())
            {
                return this.qtyUnitRemain();
            }
            else
            {
                return this.unitQtyInInventoryUnits(this.qtyUnitRemain());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyUnit</Name>
				<Source><![CDATA[
    protected UnitQty  qtyUnit()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyUnitRemain</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the quantity that remains in order line units.
    /// </summary>
    /// <returns>
    ///    The quantity that remains in order line units.
    /// </returns>
    /// <remarks>
    ///    Derived classes that supports non-inventoried lines should override this method.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    ///    The method was not implemented in a derived class that supports non-inventoried lines.
    /// </exception>
    protected InventQty  qtyUnitRemain()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryBuildOrderTable</Name>
				<Source><![CDATA[
    protected QueryRun  queryBuildOrderTable()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryGetOrderTable</Name>
				<Source><![CDATA[
    protected Common  queryGetOrderTable(QueryRun  _queryRun)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordHasMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if any <c>MarkupTrans</c> table record is related to the specified record in the specified table
    /// </summary>
    /// <param name="_tableId">
    ///     A <c>RefTableId</c> type.
    /// </param>
    /// <param name="_recId">
    ///     A <c>RefRecId</c> type.
    /// </param>
    /// <returns>
    ///     true if a <c>MarkupTrans</c> table record exist; otherwise, false.
    /// </returns>
    public boolean recordHasMarkup(RefTableId _tableId, RefRecId _recId)
    {
        return this.parmEnumerableFactory().createMarkupEnumerableProvider().markupEnumerable(_tableId, _recId).getEnumerator().moveNext();
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordSortedListLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a record sorted list of lines for which the totals object was created.
    /// </summary>
    /// <returns>
    /// The record sorted list of lines.
    /// </returns>
    public RecordSortedList recordSortedListLine()
    {
        return recordSortedListLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundedOffTotalAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Rounds off the total amount that is based on the currency setup.
    /// </summary>
    /// <param name="_totalAmount">
    ///    The total amount to round off.
    /// </param>
    /// <returns>
    ///    The total amount after rounding.
    /// </returns>
    protected AmountCur roundedOffTotalAmount(AmountCur _totalAmount)
    {
        return CurrencyExchange::roundWithRule(
            _totalAmount,
            this.roundOff(this.currencyCode()),
            this.roundOffType(this.currencyCode()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundOff</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the round-off amount for the order.
    /// </summary>
    /// <param name="_currencyCode">
    ///    The <c>CurrencyCode</c> field for the current order line.
    /// </param>
    /// <returns>
    ///    The <c>RoundOff</c> field defined for the order on the <c>Currency</c> table.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The method is not implemented in a derived class.
    /// </exception>
    protected RoundOff roundOff(CurrencyCode _currencyCode)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundOffType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the rounding form for the order.
    /// </summary>
    /// <param name="_currencyCode">
    ///    The <c>CurrencyCode</c> field for the current order line.
    /// </param>
    /// <returns>
    ///    The <c>RoundOffType</c> field defined for the order on the <c>Currency</c> table.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The method was not implemented in a derived class.
    /// </exception>
    protected RoundOffType roundOffType(CurrencyCode _currencyCode)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesTaxTotals_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Return the total tax amount by tax type.
    /// </summary>
    /// <param name="_taxType">Tax type to get total amount</param>
    /// <returns>
    ///     Return the total tax amount.
    /// </returns>
    protected TaxAmount salesTaxTotals_BR(TaxType_BR _taxType)
    {
        if (!BrazilParameters::isEnabled())
        {
            return 0;
        }

        return abs(CurrencyExchangeHelper::amountCur2MST(this.tax().totalTaxAmountByType_BR(_taxType), this.currencyCode(), this.exchRate(), this.invoiceDate()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>servicesTotalAmount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total services amount of the order.
    /// </summary>
    /// <returns>Returns the total services amount.</returns>
    public OrderBalanceMST servicesTotalAmount_BR()
    {
        return servicesTotalAmount_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesTaxCurrency_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return company currency.
    /// </summary>
    /// <returns>Company currency to be displayed with Brazilian taxes.</returns>
    public CurrencyCode salesTaxCurrency_BR()
    {
        return salesTaxCurrency_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Assigns a specific currency code.
    /// </summary>
    /// <param name="_targetCurrencyCode">
    ///     The currency code of a record in the <c>Currency</c> table.
    /// </param>
    public void setCurrencyCode(CurrencyCode _targetCurrencyCode)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the order line should be skipped during totals calculation.
    /// </summary>
    /// <param name="_orderLine">
    /// Order line record.
    /// </param>
    /// <returns>
    /// True if the order line should be skipped; otherwise, false.
    /// </returns>
    protected boolean skipLine(Common _orderLine)
    {
        return !_orderLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceLineRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the record ID for the source line for which is being used for total calculation.
    /// </summary>
    /// <returns>
    /// The record ID for the source line for which is being used for total calculation.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws an error since the <c>TradeTotals</c> class in not abstract.
    /// </exception>
    protected RecId sourceLineRecId()
    {
        throw error(Error::missingOverload(funcname()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>tax</Name>
				<Source><![CDATA[
    public Tax tax(Tax _tax = tax)
    {
        if (!tax && !_tax)
        {
            this.calculateTotalAmount();
            _tax = tax;
        }

        tax = _tax;
        return tax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxCashDiscPercent</Name>
				<Source><![CDATA[
    DiscPct taxCashDiscPercent()
    {
        if (TaxParameters::canApplyCashDiscOnInvoice_ES())
        {
            return this.cashDiscPercent();
        }
        else
        {
            return CashDisc::find(this.cashDiscCode()).Percent;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithhold_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax withhold.
    /// </summary>
    /// <param name="_taxWithhold">
    /// The tax withhold.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxWithhold_IN</c> class.
    /// </returns>
    public TaxWithhold_IN taxWithhold_IN(TaxWithhold_IN  _taxWithhold = taxWithholdIN)
    {
        taxWithholdIN = _taxWithhold;

        return taxWithholdIN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithholdCalculation_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax withhold calculation.
    /// </summary>
    /// <param name="_taxWithholdCalculation">
    /// The tax withhold calculation.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxWithholdCalculation_IN</c> class.
    /// </returns>
    public TaxWithholdCalculation_IN taxWithholdCalculation_IN(TaxWithholdCalculation_IN _taxWithholdCalculation = taxWithholdCalculation)
    {
        taxWithholdCalculation = _taxWithholdCalculation;
        return taxWithholdCalculation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalAmount</Name>
				<Source><![CDATA[
    public AmountCur  totalAmount()
    {
        if (!totalAmountCalculated)
        {
            this.calculateTotalAmount();
            totalAmount = this.roundedTotalAmount();
            totalAmountCalculated = true;
        }

        return totalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundedTotalAmount</Name>
				<Source><![CDATA[
    private AmountCur roundedTotalAmount()
    {
        if (TaxWithholdEnableIncludeTCSInTotalFeatureToggle::includeTCSInInvoiceAmount(taxWithholdIN))
        {
            return this.roundedOffTotalAmount(this.totalAmountUnRounded() + taxWithholdTotal)
                - this.roundedOffTotalAmount(taxWithholdTotal);
        }
        else
        {
            return this.totalAmountUnRounded() + this.totalRoundOff();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalAmountAddition</Name>
				<Source><![CDATA[
    public AmountCur totalAmountAddition()
    {
        return totalAmountAddition;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalAmountAdditionBySign_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Get total amount addition by given sign index.
    /// </summary>
    /// <param name="_sign">
    ///   Sign index (see the <c>getSignIndexByAmount</c> index)
    /// </param>
    /// <returns>
    ///   Amount for given index.
    /// </returns>
    public AmountCur totalAmountAdditionBySign_RU(int _sign)
    {
        return totalAmountAdditionBySign_RU[_sign];
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalAmountBySign_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Get total amount by given sign .
    /// </summary>
    /// <param name="_negative">
    ///   true - negative; false - positive.
    /// </param>
    /// <returns>
    ///   Amount for given index.
    /// </returns>
    public AmountCur  totalAmountBySign_RU(boolean _negative)
    {
        int i;
        if (!totalAmountBySignCalculated_RU)
        {
            this.calculateTotalAmount();
            for (i=1; i<=#totalSigns_RU; i++)
            {
                totalAmountBySign_RU[i] = this.totalAmountUnRoundedBySign_RU(i) + this.totalRoundOffBySign_RU(i);
            }
            totalAmountBySignCalculated_RU = true;
        }
        i = _negative ? #negativeSignIndex_RU : #positiveSignIndex_RU;
        return totalAmountBySign_RU[i];
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalAmountCashDiscOnInvoice</Name>
				<Source><![CDATA[
    public AmountCur totalAmountCashDiscOnInvoice(boolean _cashDiscApply = false)
    {
        if (!totalAmountCalculated)
        {
            this.calculateTotalAmount();
            totalAmount = this.roundedTotalAmount();
            totalAmountCalculated = true;
        }

        if (_cashDiscApply && onlyOneCashDiscOnInvoice && totalCashDisc && TaxParameters::canApplyCashDiscOnInvoice_ES())
        {
            totalAmount                 = totalAmount - totalCashDisc;
            _cashDiscApply               = false;
            onlyOneCashDiscOnInvoice    = false;
        }

        return totalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalAmountUnRounded</Name>
				<Source><![CDATA[
    public AmountCur  totalAmountUnRounded()
    {
        AmountCur totalOrderDiscount;
        AmountCur totalPosEndDisc;
        AmountCur returnTotalEndDisc;

        if (!totalAmountUnRoundedCalculated)
        {
            this.calculateTotalAmount();
            totalOrderDiscount = this.totalEndDisc();

            if (this.isCallCenterOrder())
            {
                 //changed to use updated total order discount method.
                totalPosEndDisc = abs(totalOrderDiscount);
                returnTotalEndDisc = this.mcrReturnTotalEndDisc();
                totalOrderDiscount = totalPosEndDisc + returnTotalEndDisc;
            }

            totalAmountUnRounded        = this.totalBalance() - totalOrderDiscount + this.totalMarkup() + this.totalTaxAmount() + this.totalAmountAddition();
            totalAmountUnRoundedCalculated  = true;
        }

        return totalAmountUnRounded;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalAmountUnRoundedBySign_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets total unrounded amount by the given sign index.
    /// </summary>
    /// <param name="_sign">
    ///   A sign index (see the <c>getSignIndexByAmount</c> index)
    /// </param>
    /// <returns>
    ///   Amount for the given index.
    /// </returns>
    public AmountCur totalAmountUnRoundedBySign_RU(int _sign)
    {
        int i;
        if (!totalAmountUnRoundedBySignCalculated_RU)
        {
            this.calculateTotalAmount();
            for (i=1; i<=#totalSigns_RU; i++)
            {
                totalAmountUnroundedBySign_RU[i] = this.totalBalanceBySign_RU(i) - this.totalEndDiscBySign_RU(i) + this.totalMarkupBySign_RU(i)
                                                 + this.totalTaxAmountBySign_RU(i) + this.totalAmountAdditionBySign_RU(i);
            }
            totalAmountUnRoundedBySignCalculated_RU  = true;
        }

        return totalAmountUnroundedBySign_RU[_sign];
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalBalance</Name>
				<Source><![CDATA[
    public AmountCur  totalBalance()
    {
        this.calculateBalance();

        return balance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalBalanceBySign_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Get total balance amount by given sign index.
    /// </summary>
    /// <param name="_sign">
    ///   Sign index (see the <c>getSignIndexByAmount</c> index)
    /// </param>
    /// <returns>
    ///   Amount for given index.
    /// </returns>
    public AmountCur totalBalanceBySign_RU(int _sign)
    {
        this.calculateBalance();

        return balanceBySign_RU[_sign];
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalCashDisc</Name>
				<Source><![CDATA[
    public DiscAmount  totalCashDisc()
    {
        if (!cashDiscCalculated)
        {
            cashDisc = this.cashDiscAmount();
            cashDiscCalculated = true;
        }

        return cashDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalContributionMargin</Name>
				<Source><![CDATA[
    public SalesContributionMargin  totalContributionMargin()
    {
        SalesContributionMargin salesContributionMargin;

        salesContributionMargin = this.totalBalance() -
                                  this.totalEndDisc() -
                                   CurrencyExchangeHelper::curAmount(this.totalCostValue(), this.currencyCode(), DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), Currency::noYes2UnknownNoYes(this.triangulation()), this.exchRate(), this.exchRateSecondary());

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            return this.postTotalContributionMargin_BR(salesContributionMargin);
        }
        // </GBR>

        return salesContributionMargin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalContributionRatio</Name>
				<Source><![CDATA[
    public SalesContributionRatio  totalContributionRatio()
    {
        return percent(this.totalContributionMargin(), (this.totalBalance() - this.totalEndDisc()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalCostValue</Name>
				<Source><![CDATA[
    public CostAmount  totalCostValue()
    {
        this.calculateCostValue();

        return costValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalEndDisc</Name>
				<Source><![CDATA[
    public DiscAmount  totalEndDisc()
    {
        MapEnumerator   endDiscBalancesEnumerator;

        if (!endDiscCalculated)
        {
            this.calculateBalance();

            endDiscBalancesEnumerator = endDiscBalances.getEnumerator();

            while (endDiscBalancesEnumerator.moveNext())
            {
                endDisc += endDiscBalancesEnumerator.current() * endDiscBalancesEnumerator.currentValue() / 100;
            }

            endDisc = CurrencyExchangeHelper::amount(endDisc, this.currencyCode());

            endDiscCalculated = true;
        }

        return endDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalEndDiscBySign_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Get total discount amount by given sign index.
    /// </summary>
    /// <param name="_sign">
    ///   Sign index (see the <c>getSignIndexByAmount</c> method)
    /// </param>
    /// <returns>
    ///   Amount for given index.
    /// </returns>
    public DiscAmount  totalEndDiscBySign_RU(int _sign)
    {
        MapEnumerator   endDiscBalancesEnumerator;
        int             sign;
        Percent         percent;
        int             i;

        if (!endDiscBySignCalculated_RU && endDiscBalancesBySign_RU)
        {
            this.calculateBalance();

            endDiscBalancesEnumerator = endDiscBalancesBySign_RU.getEnumerator();

            while (endDiscBalancesEnumerator.moveNext())
            {
                [sign, percent] = endDiscBalancesEnumerator.current();
                endDiscBySign_RU[sign] += percent * endDiscBalancesEnumerator.currentValue() / 100;
            }

            for (i=1; i<=#totalSigns_RU; i++)
            {
                endDiscBySign_RU[i]  = CurrencyExchangeHelper::amount(endDiscBySign_RU[i], this.currencyCode());
            }

            endDiscBySignCalculated_RU = true;
        }

        return endDiscBySign_RU[_sign];
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalEndDiscLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the sum of all total discount per line.
    /// </summary>
    /// <returns>
    /// The sum of all total discount per line.
    /// </returns>
    public DiscAmount  totalEndDiscLines()
    {
        MapEnumerator   lineEndDiscBalancesEnumerator;

        if (!endDiscLinesCalculated)
        {
            this.calculateBalance();

            lineEndDiscBalancesEnumerator = lineEndDiscBalances.getEnumerator();

            while (lineEndDiscBalancesEnumerator.moveNext())
            {
                endDiscLines += lineEndDiscBalancesEnumerator.currentValue();
            }

            endDiscLinesCalculated = true;
        }

        return endDiscLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalEndDiscUnRounded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total end discount for the order.
    /// </summary>
    /// <returns>
    /// The total end discount for the order, unrounded.
    /// </returns>
    public real  totalEndDiscUnRounded()
    {
        MapEnumerator       endDiscBalancesEnumerator;

        if (!endDiscCalculatedUnRounded)
        {
            this.calculateBalance();

            endDiscBalancesEnumerator = endDiscBalances.getEnumerator();

            while (endDiscBalancesEnumerator.moveNext())
            {
                exdDiscountAmountUnRounded += endDiscBalancesEnumerator.current() * endDiscBalancesEnumerator.currentValue() / 100;
            }

            endDiscCalculatedUnRounded = true;
        }

        return exdDiscountAmountUnRounded;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalFreeValue</Name>
				<Source><![CDATA[
    public AmountMST  totalFreeValue()
    {
        if (!freeValueCalculated)
        {
            this.calculateFreeValue();
            freeValueCalculated = true;
        }

        return freeValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalInventRemainQty</Name>
				<Source><![CDATA[
    public InventQty  totalInventRemainQty()
    {
        this.calculateRemainQuantities();

        return qtyRemainInvent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalLineDisc</Name>
				<Source><![CDATA[
    public DiscAmount  totalLineDisc()
    {
        this.calculateBalance();

        return lineDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalMarkup</Name>
				<Source><![CDATA[
    public MarkupAmount  totalMarkup()
    {
        this.calculateMarkupAmount();

        return this.totalMarkupLine() + this.totalMarkupTable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalMarkupBySign_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Markup amount by sign.
    /// </summary>
    /// <param name="_sign">
    ///   Sign index (see the <c>getSignIndexByAmount</c> method)
    /// </param>
    /// <returns>
    ///   Amount for a given index.
    /// </returns>
    public MarkupAmount  totalMarkupBySign_RU(int _sign)
    {
        this.calculateMarkupAmount();

        return this.totalMarkupLineBySign_RU(_sign) + this.totalMarkupTableBySign_RU(_sign);
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalMarkupLine</Name>
				<Source><![CDATA[
    public MarkupAmount  totalMarkupLine()
    {
        this.calculateMarkupLineAmount();

        return markupLineAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalMarkupLineBySign_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Get total line markup amount by given sign index.
    /// </summary>
    /// <param name="_sign">
    ///   Sign index (see the <c>getSignIndexByAmount</c> index)
    /// </param>
    /// <returns>
    ///   Amount for a given index.
    /// </returns>
    public MarkupAmount  totalMarkupLineBySign_RU(int _sign)
    {
        this.calculateMarkupLineAmount();

        return markupLineAmountBySign_RU[_sign];
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalMarkupLineDetails_RU</Name>
				<Source><![CDATA[
    public Map totalMarkupLineDetails_RU()
    {
        return markupLineDetails;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalMarkupTable</Name>
				<Source><![CDATA[
    public MarkupAmount  totalMarkupTable()
    {
        this.calculateMarkupTableAmount();

        return markupTableAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalMarkupTableBySign_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Get total table markup amount by given sign index.
    /// </summary>
    /// <param name="_sign">
    ///   Sign index (see the <c>getSignIndexByAmount</c> method)
    /// </param>
    /// <returns>
    ///   Amount for a given index.
    /// </returns>
    public MarkupAmount  totalMarkupTableBySign_RU(int _sign)
    {
        this.calculateMarkupTableAmount();

        return markupTableAmountBySign_RU[_sign];
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalOrderBalance</Name>
				<Source><![CDATA[
    public AmountCur totalOrderBalance(RecId _recId)
    {
        this.calculateBalance();

        return this.orderBalance(_recId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalQty</Name>
				<Source><![CDATA[
    public SalesQty  totalQty()
    {
        this.calculateQuantities();

        return qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalRemainInventGrossWeight</Name>
				<Source><![CDATA[
    public Weight  totalRemainInventGrossWeight()
    {
        this.calculateRemainQuantities();

        return grossWeightRemainInvent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalRemainInventVolume</Name>
				<Source><![CDATA[
    public Volume  totalRemainInventVolume()
    {
        this.calculateRemainQuantities();

        return volumeRemainInvent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalRemainInventWeight</Name>
				<Source><![CDATA[
    public Weight  totalRemainInventWeight()
    {
        this.calculateRemainQuantities();

        return weightRemainInvent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalRoundOff</Name>
				<Source><![CDATA[
    public RoundOff  totalRoundOff()
    {
        if (!roundOffCalculated)
        {
            if (this.totalAmountUnRounded())
            {
                if (TaxWithholdEnableIncludeTCSInTotalFeatureToggle::includeTCSInInvoiceAmount(taxWithholdIN))
                {
                    roundOff = this.roundedOffTotalAmount(this.totalAmountUnRounded() + taxWithholdTotal)
                        - this.totalAmountUnRounded() - taxWithholdTotal;
                }
                else
                {
                    roundOff = this.roundedOffTotalAmount(this.totalAmountUnRounded()) - this.totalAmountUnRounded();
                }
            }
            roundOffCalculated = true;
        }

        return roundOff;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalRoundOffBySign_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Get total amount round off by given sign index.
    /// </summary>
    /// <param name="_sign">
    ///   Sign index (see the <c>getSignIndexByAmount</c> method)
    /// </param>
    /// <returns>
    ///   An round off amount for the given index.
    /// </returns>
    public RoundOff totalRoundOffBySign_RU(int _sign)
    {
        int i;
        if (!roundOffBySignCalculated_RU)
        {
            if (this.totalAmountUnRounded())
            {
                for (i=1; i<=#totalSigns_RU; i++)
                {
                    roundOffBySign_RU[i] = this.roundedOffTotalAmount(this.totalAmountUnRoundedBySign_RU(i)) - this.totalAmountUnRoundedBySign_RU(i);
                }
            }
            roundOffBySignCalculated_RU = true;
        }

        return roundOffBySign_RU[_sign];
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxAmount</Name>
				<Source><![CDATA[
    public TaxAmountCur  totalTaxAmount()
    {
        this.calculateTaxAmount();

        return taxTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxReverseCharge</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total tax reverse charge amount.
    /// </summary>
    /// <returns>The total tax reverse charge amount.</returns>
    public TaxAmountCur totalTaxReverseCharge()
    {
        this.calculateTaxAmount();

        if (!TaxSolutionScopeIntegrationUtil::isCompanyEnabled() && this.tax())
        {
            taxTotalReverseCharge = this.tax().reverseChargeAmount_W();
        }
        return taxTotalReverseCharge;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxAmountBySign_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Get total tax amount by given sign index.
    /// </summary>
    /// <param name="_sign">
    ///   Sign index (see the <c>getSignIndexByAmount</c> index)
    /// </param>
    /// <returns>
    ///   Amount for given index.
    /// </returns>
    public TaxAmountCur  totalTaxAmountBySign_RU(int _sign)
    {
        this.calculateTaxAmount();

        return taxTotalBySign_RU[_sign];
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalVolume</Name>
				<Source><![CDATA[
    public Volume  totalVolume()
    {
        this.calculateQuantities();

        return volume;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalWeight</Name>
				<Source><![CDATA[
    public Weight  totalWeight()
    {
        this.calculateQuantities();

        return weight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>triangulation</Name>
				<Source><![CDATA[
    public EUROTriangulation  triangulation()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>unitQtyInInventoryUnits</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Converts a quantity from order line units to inventory units.
    /// </summary>
    /// <param name="_unitQty">
    ///    The order line quantity to convert.
    /// </param>
    /// <returns>
    ///    The order line quantity in inventory units.
    /// </returns>
    /// <remarks>
    ///    Derived classes that support non-inventoried item based lines should override this method.This
    ///    method should only be called after the <c>InventTable</c> instance variable has been initialized.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    ///    The method was called from the base.
    /// </exception>
    protected InventQty unitQtyInInventoryUnits(UnitQty _unitQty)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCallCenterOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns whether the order is call center enabled.
    /// </summary>
    /// <returns>
    /// true if the order is a call center order; otherwise, false.
    /// </returns>
	protected boolean isCallCenterOrder()
    {
        return MCROrderParameters::isCallCenterEnabledAndInUse();
	}

]]></Source>
			</Method>
			<Method>
				<Name>updateEndDiscBalances</Name>
				<Source><![CDATA[
    private void updateEndDiscBalances(AmountCur _amountCur)
    {
        DiscPct     discPercent = this.discPercent();
        AmountCur   endDiscBalance;
        DiscPct     returnDiscPercent;
        AmountCur   returnEndDiscBalance;
        boolean     isCallCenterReturn = _amountCur < 0 && this.isCallCenterOrder();

        if (discPercent
            && (_amountCur > 0 || !isCallCenterReturn))
        {
            if (endDiscBalances.exists(discPercent))
            {
                endDiscBalance = endDiscBalances.lookup(discPercent);
            }

            endDiscBalance += _amountCur;
            endDiscBalances.insert(discPercent, endDiscBalance);
        }

        if (isCallCenterReturn)
        {
            returnDiscPercent = this.mcrReturnDiscPercent();
            if (returnDiscPercent)
            {
                if (returnEndDiscBalances.exists(returnDiscPercent))
                {
                    returnEndDiscBalance = returnEndDiscBalances.lookup(returnDiscPercent);
                }

                returnEndDiscBalance += _amountCur;
                returnEndDiscBalances.insert(returnDiscPercent, returnEndDiscBalance);
            }
        }

        // <GEERU>
        if (discPercent && calculateTotalsBySigns_RU)
        {
            this.updateEndDiscBalancesBySign_RU(this.getOrderLineSign_RU(orderLine), discPercent, _amountCur);
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateEndDiscBalancesBySign_RU</Name>
				<Source><![CDATA[
    private void updateEndDiscBalancesBySign_RU(int _sign, Percent _percent, AmountCur _amountCur)
    {
        container key = [_sign, _percent];
        AmountCur value;

        if (!endDiscBalancesBySign_RU)
        {
            endDiscBalancesBySign_RU = new Map(Types::Container, extendedTypeId2Type(extendedTypeNum(AmountCur)));
        }
        if (endDiscBalancesBySign_RU.exists(key))
        {
            value = endDiscBalancesBySign_RU.lookup(key);
        }

        value += _amountCur;
        endDiscBalancesBySign_RU.insert(key, value);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLineEndDiscBalances</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the line total discount balances.
    /// </summary>
    /// <param name="_lineAmount">
    /// The line amount to calculate total discount from.
    /// </param>
    private void updateLineEndDiscBalances(AmountCur _lineAmount)
    {
        recId       recId = this.sourceLineRecId();
        AmountCur   lineEndDiscBalance;
        DiscAmount  lineEndDiscAmount;

        if (this.discPercent())
        {
            lineEndDiscBalance = this.lineEndDiscBalance(recId);

            lineEndDiscAmount = _lineAmount * this.discPercent()/100;
            lineEndDiscAmount = CurrencyExchangeHelper::amount(lineEndDiscAmount, this.currencyCode());

            lineEndDiscBalance += lineEndDiscAmount;

            lineEndDiscBalances.insert(recId, lineEndDiscBalance);

            if (abs(lineAmountForRecordToAdjustTaxBase) < abs(_lineAmount))
            {
                lineAmountForRecordToAdjustTaxBase = _lineAmount;
                recIdRecordToAdjustTaxBase         = recId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOrderBalances</Name>
				<Source><![CDATA[
    protected void updateOrderBalances(AmountCur _amountCur)
    {
        RecId       recId = this.orderLine_OrderTable().recId;
        recId       lineRecId = this.sourceLineRecId();
        AmountCur   orderBalance;
        AmountCur   lineRoundedOrderBalance;
        RecId       lineToAdjustRecId;
        AmountCur   lineToAdjustAmount;

        orderBalance             = this.orderBalance(recId);
        lineRoundedOrderBalance  = this.lineRoundedOrderBalance(recId);

        balance                     += _amountCur;
        orderBalance                += _amountCur;
        lineRoundedOrderBalance     += CurrencyExchangeHelper::amount(_amountCur, this.currencyCode());

        orderBalances.insert(recid, orderBalance);
        lineRoundedOrderBalances.insert(recId, lineRoundedOrderBalance);

        if (recIdLinesToAdjust.exists(recId))
        {
            [lineToAdjustRecId, lineToAdjustAmount] = recIdLinesToAdjust.lookup(recId);
        }

        if (abs(_amountCur) > abs(lineToAdjustAmount))
        {
            recIdLinesToAdjust.insert(recId, [lineRecId, _amountCur]);
        }

        if (MCROrderParameters::isCallCenterEnabledAndInUse())
        {
            orderBalance            =  this.mcrOrderBalanceAbsoluteValue(recId);
            MCRBalanceAbsoluteValue += abs(_amountCur);
            orderBalance            += abs(_amountCur);

            MCROrderBalancesAbsoluteValue.insert(recId, orderBalance);

            if (_amountCur < 0)
            {
                returnBalance += _amountCur;
            }
        }

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            this.postUpdateOrderBalances_BR(_amountCur);
        }
        // </GBR>
        // <GEERU>
        if (calculateTotalsBySigns_RU)
        {
            balanceBySign_RU[this.getOrderLineSign_RU(orderLine)] += _amountCur;
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the total order quantities, inventory quantities, and measurements.
    /// </summary>
    /// <param name="_unitQty">
    /// The order line quantity.
    /// </param>
    /// <param name="_inventQty">
    /// The order line quantity in inventory units.
    /// </param>
    /// <param name="_cwQty">
    /// The order line quantity in catch weight units.
    /// </param>
    /// <remarks>
    /// The <paramref name="_inventQty" /> parameter can be nonzero for non-inventoried lines.
    /// </remarks>
    protected void updateQuantities(UnitQty _unitQty, InventQty _inventQty, PdsCWInventQty _cwQty)
    {
        Weight      netWeight;
        Weight      taraWeight;
        Volume      unitVolume;
        InventQty   qtyRemainInventoryUnits;

        if (this.isCategoryBased())
        {
            netWeight   = this.categoryWeight();
            // The other measurements are 0 for category based lines.
        }
        else
        {
            netWeight   = inventTable.NetWeight;
            unitVolume  = inventTable.UnitVolume;
            taraWeight  = inventTable.TaraWeight;
        }

        if (calculateQuantities)
        {
            pdsCWQty += _cwQty;
            qty     += _unitQty;
            weight  += abs(_inventQty) * netWeight;
            volume  += abs(_inventQty) * unitVolume;
            grossWeight += abs(_inventQty) * (netWeight + taraWeight);
        }

        if (calculateRemainQuantities)
        {
            pdsCWQtyRemain          += this.pdsCWQtyRemain();
            qtyRemainInventoryUnits = this.qtyRemainInventoryUnits();

            qtyRemainInvent         += qtyRemainInventoryUnits;
            weightRemainInvent      += qtyRemainInventoryUnits * netWeight;
            grossWeightRemainInvent += qtyRemainInventoryUnits * (netWeight + taraWeight);
            volumeRemainInvent      += qtyRemainInventoryUnits * unitVolume;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrPosEndInstallmentDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the position of the value in the container.
    /// </summary>
    /// <returns>
    /// The position of the value in the container.
    /// </returns>
    public static Integer mcrPosEndInstallmentDisc()
    {
        return #mcrPosEndInstallmentDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrPosInstallmentLineDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the position of the value in the container.
    /// </summary>
    /// <returns>
    /// The position of the value in the container.
    /// </returns>
    public static Integer mcrPosInstallmentLineDisc()
    {
        return #mcrPosInstallmentLineDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrPosReturnBalanceAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the position of the value in the container.
    /// </summary>
    /// <returns>
    /// The position of the value in the container.
    /// </returns>
    public static Integer mcrPosReturnBalanceAmount()
    {
        return #mcrPosReturnBalanceAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrPosReturnDiscountTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the position of the value in the container.
    /// </summary>
    /// <returns>
    /// The position of the value in the container.
    /// </returns>
    public static Integer  mcrPosReturnDiscountTotal()
    {
        return #MCRPosReturnDiscountTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrPosReturnInstallmentMarkUpCoupon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the position of the value in the container.
    /// </summary>
    /// <returns>
    /// The position of the value in the container.
    /// </returns>
    public static Integer  mcrPosReturnInstallmentMarkUpCoupon()
    {
        return #mcrPosReturnInstallmentMarkUpCoupon;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrPosReturnInstallmentMarkUpLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the position of the value in the container.
    /// </summary>
    /// <returns>
    /// The position of the value in the container.
    /// </returns>
    public static Integer  mcrPosReturnInstallmentMarkUpLine()
    {
        return #mcrPosReturnInstallmentMarkUpLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrPosReturnInstallmentMarkUpTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the position of the value in the container.
    /// </summary>
    /// <returns>
    /// The position of the value in the container.
    /// </returns>
    public static Integer  mcrPosReturnInstallmentMarkUpTotal()
    {
        return #mcrPosReturnInstallmentMarkUpTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrPosReturnInstallmentTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the position of the value in the container.
    /// </summary>
    /// <returns>
    /// The position of the value in the container.
    /// </returns>
    public static Integer  mcrPosReturnInstallmentTax()
    {
        return #mcrPosReturnInstallmentTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrPosReturnInstallmentTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the position of the value in the container.
    /// </summary>
    /// <returns>
    /// The position of the value in the container.
    /// </returns>
    public static Integer  mcrPosReturnInstallmentTotal()
    {
        return #mcrPosReturnInstallmentTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrPosReturnMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the position of the value in the container.
    /// </summary>
    /// <returns>
    /// The position of the value in the container.
    /// </returns>
    public static Integer  mcrPosReturnMarkup()
    {
        return #mcrPosReturnMarkup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrPosReturnTaxTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the position of the value in the container.
    /// </summary>
    /// <returns>
    /// The position of the value in the container.
    /// </returns>
    public static Integer  mcrPosReturnTaxTotal()
    {
        return #mcrPosReturnTaxTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrPosReturnTotalAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the position of the value in the container.
    /// </summary>
    /// <returns>
    /// The position of the value in the container.
    /// </returns>
    public static Integer  mcrPosReturnTotalAmount()
    {
        return #mcrPosReturnTotalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrPostotalCoupon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the position of the value in the container.
    /// </summary>
    /// <returns>
    /// The position of the value in the container.
    /// </returns>
    public static Integer mcrPostotalCoupon()
    {
        return #mcrPostotalCoupon;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWPosQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the catch weight quantity index.
    /// </summary>
    /// <returns>
    /// A position index of the catch weight quantity.
    /// </returns>
    public static Integer pdsCWPosQty()
    {
        return #posPdsCWQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posBalance</Name>
				<Source><![CDATA[
    public static Integer  posBalance()
    {
        return #posBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posCashDisc</Name>
				<Source><![CDATA[
    public static Integer  posCashDisc()
    {
        return #posCashDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posCOFINSTotal_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>COFINS</c> tax type
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>COFINS</c> tax type.
    /// </returns>
    static Integer  posCOFINSTotal_BR()
    {
        return #posCOFINSTotal_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posContributionMargin</Name>
				<Source><![CDATA[
    public static Integer  posContributionMargin()
    {
        return #posContributionMargin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posContributionRatio</Name>
				<Source><![CDATA[
    public static Integer  posContributionRatio()
    {
        return #posContributionRatio;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posCostValue</Name>
				<Source><![CDATA[
    public static Integer  posCostValue()
    {
        return #posCostValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posCreditMax</Name>
				<Source><![CDATA[
    public static Integer  posCreditMax()
    {
        return #posCreditMax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posCurrency</Name>
				<Source><![CDATA[
    public static Integer  posCurrency()
    {
        return #posCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posEndDisc</Name>
				<Source><![CDATA[
    public static Integer  posEndDisc()
    {
        return #posEndDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posExchRate</Name>
				<Source><![CDATA[
    public static Integer  posExchRate()
    {
        return #posExchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posFreeValue</Name>
				<Source><![CDATA[
    public static Integer  posFreeValue()
    {
        return #posFreeValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posICMSTotal_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>ICMS</c> tax type
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>ICMS</c> tax type.
    /// </returns>
    static Integer  posICMSTotal_BR()
    {
        return #posICMSTotal_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posImportTaxTotal_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>ImportTax</c> tax type
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>ImportTax</c> tax type.
    /// </returns>
    static Integer  posImportTaxTotal_BR()
    {
        return #posImportTaxTotal_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posINSSTotal_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>INSS</c> tax type
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>INSS</c> tax type.
    /// </returns>
    static Integer  posINSSTotal_BR()
    {
        return #posINSSTotal_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posIPITotal_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>IPI</c> tax type
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>IPI</c> tax type.
    /// </returns>
    static Integer  posIPITotal_BR()
    {
        return #posIPITotal_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posIRRFTotal_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>IRRF</c> tax type
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>IRRF</c> tax type.
    /// </returns>
    static Integer  posIRRFTotal_BR()
    {
        return #posIRRFTotal_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posISSTotal_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>ISS</c> tax type
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>ISS</c> tax type.
    /// </returns>
    static Integer  posISSTotal_BR()
    {
        return #posISSTotal_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posLineDisc</Name>
				<Source><![CDATA[
    public static Integer  posLineDisc()
    {
        return #posLineDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posMarkup</Name>
				<Source><![CDATA[
    public static Integer  posMarkup()
    {
        return #posMarkup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posMarkupFreight_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>Freight</c> amount
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>Freight</c> amount.
    /// </returns>
    static Integer posMarkupFreight_BR()
    {
        return #posMarkupFreight_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posMarkupInsurance_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>Insurance</c> charges amount
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>Insurance</c> amount.
    /// </returns>
    static Integer posMarkupInsurance_BR()
    {
        return #posMarkupInsurance_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posMarkupOther_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>Other</c> charges amount
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>Other</c> amount.
    /// </returns>
    static Integer posMarkupOther_BR()
    {
        return #posMarkupOther_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posPISTotal_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>PIS</c> tax type
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>PIS</c> tax type.
    /// </returns>
    static Integer  posPISTotal_BR()
    {
        return #posPISTotal_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posQty</Name>
				<Source><![CDATA[
    public static Integer  posQty()
    {
        return #posQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posRetainedINSSTotal_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>RetainedINSS</c> tax type
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>RetainedINSS</c> tax type.
    /// </returns>
    static Integer posRetainedINSSTotal_BR()
    {
        return #posRetainedINSSTotal_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posRoundOff</Name>
				<Source><![CDATA[
    public static Integer  posRoundOff()
    {
        return #posRoundOff;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posTaxTotal</Name>
				<Source><![CDATA[
    public static Integer  posTaxTotal()
    {
        return #posTaxTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posWithholdTCSTaxTotal_IN</Name>
				<Source><![CDATA[
    public static Integer posWithholdTCSTaxTotal_IN()
    {
        return #posWithholdTCSTaxTotal_IN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posTotalAmount</Name>
				<Source><![CDATA[
    public static Integer  posTotalAmount()
    {
        return #posTotalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posVolume</Name>
				<Source><![CDATA[
    public static Integer  posVolume()
    {
        return #posVolume;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posWeight</Name>
				<Source><![CDATA[
    public static Integer  posWeight()
    {
        return #posWeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posCSLLTotal_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the position of the <c>CSLL</c> tax type in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>The position of the value of the <c>CSLL</c> tax type.</returns>
    public static Integer posCSLLTotal_BR()
    {
        return #posCSLLTotal_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posICMSSTTotal_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the position of the <c>ICMS-ST</c> tax type in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>The position of the value of the <c>ICMS-ST</c> tax type.</returns>
    public static Integer posICMSSTTotal_BR()
    {
        return #posICMSSTTotal_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posICMSDiffTotal_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the position of the <c>ICMSDiff</c> tax type in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>The position of the value of the <c>ICMSDiff</c> tax type.</returns>
    public static Integer posICMSDiffTotal_BR()
    {
        return #posICMSDiffTotal_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posSalesTaxCurrency_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the Brazilian taxes currency code.
    /// </summary>
    /// <returns>Currency code for Brazilian taxes.</returns>
    public static Integer posSalesTaxCurrency_BR()
    {
        return #posSalesTaxCurrency_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCalculateMarkupTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if any order table record is related to any header of the order.
    /// </summary>
    /// <returns>
    ///     Always true;
    /// </returns>
    public boolean canCalculateMarkupTable()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchangeRateForDisplay</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves an exchange rate that can be displayed to the user.
    /// </summary>
    /// <param name="_displayFields">
    /// To get the posCurrency.
    /// </param>
    /// <returns>
    /// An exchange rate that can be displayed to the user.
    /// </returns>
    static CurrencyExchangeRate exchangeRateForDisplay(container _displayFields)
    {
        ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newCurrency(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), conPeek(_displayFields, TradeTotals::posCurrency()) );
        Return exchangeRateHelper.displayStoredExchangeRate(conPeek(_displayFields, TradeTotals::posExchRate()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxableDocumentDescriptor</Name>
				<Source><![CDATA[
    // <GTE>
    public TaxableDocumentDescriptor parmTaxableDocumentDescriptor()
    {
        if (orderTable.TableId != tableNum(ProjProposalJour))
        {
            return TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(orderTable);
        }
        else
        {
            return TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(TaxEngineProjItemSOTransHeader::findOrCreateByProjProposalJour(orderTable));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxTotalGTE</Name>
				<Source><![CDATA[
    // </GTE>


    /// <summary>
    /// Get the amount of the total tax for the GTE.
    /// </summary>
    /// <returns>
    /// The total tax for the GTE
    /// </returns>
    public AmountCur taxTotalGTE()
    {
        return taxTotalGTE;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalAmountGTE</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the total amount for the GTE.
    /// </summary>
    /// <returns>
    /// The total amount for the GTE
    /// </returns>
    public AmountCur totalAmountGTE()
    {
        return this.totalAmount() - taxTotal + taxTotalGTE;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSkipMarkupLineAmountCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the calculation of charges in order lines can be skipped.
    /// </summary>
    /// <returns>
    /// True if the calculation of charges in order lines is skipped; otherwise, false.
    /// </returns>
    protected boolean mustSkipMarkupLineAmountCalculation(Common _orderLine)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalGrossWeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total gross weight.
    /// </summary>
    /// <returns>
    /// The total gross weight.
    /// </returns>
    public GrossWeight totalGrossWeight()
    {
        this.calculateQuantities();

        return grossWeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>logTaxTelemetry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Logs tax telemetry.
    /// </summary>
    /// <param name = "_activityContext">The activity context to log the telemetry.</param>
    [Hookable(false)]
    internal void logTaxTelemetry(SysInstrumentationActivityContext _activityContext)
    {
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>