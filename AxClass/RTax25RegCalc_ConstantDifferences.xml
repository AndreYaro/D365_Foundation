<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>rTax25RegCalc_ConstantDifferences</Name>
	<SourceCode>
		<Declaration><![CDATA[
final class rTax25RegCalc_ConstantDifferences extends RTax25RegCalc implements BatchRetryable
{
    Map            registerLineMap;
    AmountMST      totalBookkeepingAmount,totalTaxAmount,totalAmountReceipt,totalAmountIssue,totalCTLAmount,totalCTAAmount;
    AmountMST      profitBookkeepingAmount,profitTaxAmount,profitAmountReceipt,profitAmountIssue,profitCTLAmount,profitCTAAmount;
    AmountMST      taxCodeBookkeepingAmount,taxCodeTaxAmount,taxCodeAmountReceipt,taxCodeAmountIssue,taxCodeCTLAmount,taxCodeCTAAmount;
    TaxCode        lastTaxCode;
    RTax25Query    queryNotInfluenceIncome, queryStdCurrentExpense, queryAmountDifference,
                   queryExchAdj, queryTaxExchAdj, queryAssetDeprBonusRecovery;
    Counter        transCount;
    RefRecId       lastProfitTableRecId;
    TaxCode        debtReserveTaxCode;
    
    const str DebtReserveProfitID = 'DebtReserve';

    #define.FieldNum1(1)
    #define.FieldNum2(2)
    #define.FieldNum3(3)
    #define.FieldNum4(4)
    #define.FieldNum5(5)
    #define.FieldNum6(6)
    #define.FieldNum7(7)
    #define.FieldNum8(8)
    #define.FieldNum9(9)
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calc</Name>
				<Source><![CDATA[
    public void calc()
    {
        int64               totalStdCurrentExpense, totalNotInfluenceIncome, totalAmountDifference,
                            totalExchAdj, totalTaxExchAdj, totalAssetDeprBonusRecovery;
        RTax25RegisterTransMap  regTrans;
        ;
        try
        {
            ttsbegin;
            super();
            if (queryNotInfluenceIncome.first())
            {
                totalNotInfluenceIncome = queryNotInfluenceIncome.getTotalRecCount();
            }
            if (queryStdCurrentExpense.first())
            {
                totalStdCurrentExpense = queryStdCurrentExpense.getTotalRecCount();
            }
            if (queryAmountDifference.first())
            {
                totalAmountDifference = queryAmountDifference.getTotalRecCount();
            }
            if (queryExchAdj.first())
            {
                totalExchAdj = queryExchAdj.getTotalRecCount();
            }
            if (queryTaxExchAdj.first())
            {
                totalTaxExchAdj = queryTaxExchAdj.getTotalRecCount();
            }
            if (queryAssetDeprBonusRecovery.first())
            {
                totalAssetDeprBonusRecovery = queryAssetDeprBonusRecovery.getTotalRecCount();
            }

            this.progressInit("", totalNotInfluenceIncome + totalStdCurrentExpense + totalAmountDifference +
                                  totalExchAdj + totalTaxExchAdj + totalAssetDeprBonusRecovery + this.isDebtReserves());
            if (totalNotInfluenceIncome)
            {
                do
                {
                    regTrans = queryNotInfluenceIncome.getRecord();
                    progress.setText(strfmt("@GLS104191", RTax25ProfitTable::find(regTrans.rTax25ProfitTable).ProfitId));
                    progress.incCount();
                    this.createBodyNotInfluenceIncome(regTrans);
                }
                while (queryNotInfluenceIncome.next());
            }
            if (totalStdCurrentExpense)
            {
                do
                {
                    regTrans = queryStdCurrentExpense.getRecord();
                    progress.setText(strfmt("@GLS104191", RTax25ProfitTable::find(regTrans.rTax25ProfitTable).ProfitId));
                    progress.incCount();
                    this.createBodyStdCurrentExpense(regTrans);
                }
                while (queryStdCurrentExpense.next());
            }
            if (totalAmountDifference)
            {
                do
                {
                    regTrans = queryAmountDifference.getRecord();
                    progress.setText(strfmt("@GLS104191", RTax25ProfitTable::find(regTrans.rTax25ProfitTable).ProfitId));
                    progress.incCount();
                    this.createBodyAmountDifference(regTrans);
                }
                while (queryAmountDifference.next());
            }
            if (totalExchAdj)
            {
                do
                {
                    regTrans = queryExchAdj.getRecord();
                    progress.setText(strfmt("@GLS104191", RTax25ProfitTable::find(regTrans.rTax25ProfitTable).ProfitId));
                    progress.incCount();
                    this.createBodyExchAdj(regTrans);
                }
                while (queryExchAdj.next());
            }
            if (totalTaxExchAdj)
            {
                do
                {
                    regTrans = queryTaxExchAdj.getRecord();
                    progress.setText(strfmt("@GLS104191", RTax25ProfitTable::find(regTrans.rTax25ProfitTable).ProfitId));
                    progress.incCount();
                    this.createBodyTaxExchAdj(regTrans);
                }
                while (queryTaxExchAdj.next());
            }
            if (totalAssetDeprBonusRecovery)
            {
                do
                {
                    regTrans = queryAssetDeprBonusRecovery.getRecord();
                    progress.setText(strfmt("@GLS104191", RTax25ProfitTable::find(regTrans.rTax25ProfitTable).ProfitId));
                    progress.incCount();
                    this.createBodyAssetDeprBonusRecovery(regTrans);
                }
                while (queryAssetDeprBonusRecovery.next());
            }
            if (this.isDebtReserves())
            {
                progress.setText("@RTax25BadDebtReserve:ReserveBadDebts");
                progress.incCount();
                this.createBodyDebtReserve();
            }
 
            if (registerLineMap.elements())
            {
                this.sortRegisterTrans();
            }
            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            retry;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcDiffForReserve</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates tax differences for bad debt reserves.
    /// </summary>
    /// <param name="_profitTableRecId">
    /// A record ID of the profit table.
    /// </param>
    /// <param name="_key">
    /// A container holding accounting object ID information.
    /// </param>
    /// <param name="_valueRAP">
    /// A container holding amounts calculated for business accounting model.
    /// </param>
    /// <param name="_valueTAX">
    /// A container holding amounts calculated for tax accounting model.
    /// </param>

    private void calcDiffForReserve(
        RefRecId    _profitTableRecId,
        container   _key,
        container   _valueRAP,
        container   _valueTAX)
    {
        AmountMST           cTA, cTL;
        AmountMST           currentDifference;
        AmountMST           diffIncome, diffExpense;
        RecordSortedList    registerTransList;
        Tax                 tax = new Tax();
        RTax25RegisterTrans_ConstantDifferences regTrans;
        const int Coeff = 10000;

        currentDifference = conPeek(_valueRAP, 2) - conPeek(_valueTAX, 2);

        if (currentDifference)
        {
            if (currentDifference > 0)
            {
                diffExpense = currentDifference;
                diffIncome  = 0;

                cTL = tax.taxCalcWithoutSource_RU(debtReserveTaxCode,
                                              dateTo,
                                              Ledger::accountingCurrency(),
                                              diffExpense,
                                              TaxModuleType::Voucher);
                cTA = 0;
            }
            else
            {
                diffIncome  = -currentDifference;
                diffExpense = 0;

                cTA = tax.taxCalcWithoutSource_RU(debtReserveTaxCode,
                                              dateTo,
                                              Ledger::accountingCurrency(),
                                              diffIncome,
                                              TaxModuleType::Voucher);
                cTL = 0;
            }

            transCount++;
            regTrans = regQuery.addBodyRecord(_profitTableRecId,
                                          [conPeek(_key, 4),       //posting date
                                           "@RTax25BadDebtReserve:ReserveBadDebts",
                                           conPeek(_key, 3),       //invoice number
                                           conPeek(_valueRAP, 2),  //expense for the period for RAP
                                           conPeek(_valueTAX, 2),  //expense for the period for TAX
                                           diffIncome,
                                           cTA,
                                           diffExpense,
                                           cTL],
                                           conPeek(_key, 1),       //RefTableId
                                           conPeek(_key, 2),       //RefRecId
                                           strfmt("@RTax25BadDebtReserve:ConstDiffForInvoice", conPeek(_key, 3)),
                                           -(date2num(conPeek(_key, 4)) * Coeff + transCount),
                                           currentDifference);

            regTrans.LineNumber = -regTrans.LineNumber;

            if (registerLineMap.exists(debtReserveTaxCode))
            {
                registerTransList = registerLineMap.lookup(debtReserveTaxCode);
            }
            else
            {
                registerTransList = new RecordSortedList(tablenum(RTax25RegisterTrans_ConstantDifferences));
                registerTransList.sortOrder(fieldnum(RTax25RegisterTrans_ConstantDifferences, rTax25ProfitTable),
                                        fieldnum(RTax25RegisterTrans_ConstantDifferences, LineNumber));
            }

            registerTransList.ins(regTrans);
            registerLineMap.insert(debtReserveTaxCode, registerTransList);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>check</Name>
				<Source><![CDATA[
    public boolean check()
    {
        boolean ret;

        ret = super();

        if (ret)
        {
            if (! debtReserveTaxCode)
            {
                ret = checkFailed("@RTax25BadDebtReserve:BadDebtTaxCodeNotSet");
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBodyAmountDifference</Name>
				<Source><![CDATA[
    #define.Coeff(10000)
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void createBodyAmountDifference(RTax25RegisterTrans_AmountDifference _sourceRegisterTrans)
    {
        RTax25RegisterTrans_ConstantDifferences regTrans;
        TaxCode             taxCode = RTax25ProfitTable::find(_sourceRegisterTrans.rTax25ProfitTable).taxCode();
        RecordSortedList    registerTransList;

        if (! queryAmountDifference.getField(#FieldNum6) &&
            ! queryAmountDifference.getField(#FieldNum8))
            return;

        transCount++;
        regTrans = regQuery.addBodyRecord(_sourceRegisterTrans.rTax25ProfitTable,
                                                     [queryAmountDifference.getField(#FieldNum1),
                                                      queryAmountDifference.getField(#FieldNum2),
                                                      queryAmountDifference.getField(#FieldNum3) ? strfmt("@GLS111967", queryAmountDifference.getField(#FieldNum3)) : "@GLS101335",
                                                      0.0,
                                                      queryAmountDifference.getField(#FieldNum5) ? queryAmountDifference.getField(#FieldNum5) : queryAmountDifference.getField(#FieldNum7),
                                                      queryAmountDifference.getField(#FieldNum5),
                                                      queryAmountDifference.getField(#FieldNum6),
                                                      queryAmountDifference.getField(#FieldNum7),
                                                      queryAmountDifference.getField(#FieldNum8)],
                                                      _sourceRegisterTrans.TableId,
                                                      _sourceRegisterTrans.RecId,
                                                      _sourceRegisterTrans.LineDescription,
                                                      -(date2num(queryAmountDifference.getField(#FieldNum1))*#Coeff + transCount),
                                                      _sourceRegisterTrans.ProfitAmount);
        regTrans.LineNumber = -regTrans.LineNumber;

        if (registerLineMap.exists(taxCode))
        {
            registerTransList = registerLineMap.lookup(taxCode);
        }
        else
        {
            registerTransList = new RecordSortedList(tablenum(RTax25RegisterTrans_ConstantDifferences));
            registerTransList.sortOrder(fieldnum(RTax25RegisterTrans_ConstantDifferences, rTax25ProfitTable),
                                        fieldnum(RTax25RegisterTrans_ConstantDifferences, LineNumber));
        }
        registerTransList.ins(regTrans);
        registerLineMap.insert(taxCode,registerTransList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBodyAssetDeprBonusRecovery</Name>
				<Source><![CDATA[
    #define.Coeff(10000)
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void createBodyAssetDeprBonusRecovery(RTax25RegisterTrans_AssetDeprBonus _sourceRegisterTrans)
    {
        RTax25RegisterTrans_ConstantDifferences regTrans;
        TaxCode             taxCode = RTax25ProfitTable::find(_sourceRegisterTrans.rTax25ProfitTable).taxCode();
        RecordSortedList    registerTransList;

        transCount++;
        regTrans  = regQuery.addBodyRecord(_sourceRegisterTrans.rTax25ProfitTable,
                                                     [queryAssetDeprBonusRecovery.getField(#FieldNum1),
                                                      queryAssetDeprBonusRecovery.getField(#FieldNum2),
                                                      queryAssetDeprBonusRecovery.getField(#FieldNum3),
                                                      0.0,
                                                      queryAssetDeprBonusRecovery.getField(#FieldNum4),
                                                      0.0,
                                                      0.0,
                                                      0.0,
                                                      queryAssetDeprBonusRecovery.getField(#FieldNum5)],
                                                      _sourceRegisterTrans.TableId,
                                                      _sourceRegisterTrans.RecId,
                                                      _sourceRegisterTrans.LineDescription,
                                                      -(date2num(queryAssetDeprBonusRecovery.getField(#FieldNum1))*#Coeff + transCount),
                                                      _sourceRegisterTrans.ProfitAmount);

        regTrans.LineNumber = -regTrans.LineNumber;

        if (registerLineMap.exists(taxCode))
        {
            registerTransList = registerLineMap.lookup(taxCode);
        }
        else
        {
            registerTransList = new RecordSortedList(tablenum(RTax25RegisterTrans_ConstantDifferences));
            registerTransList.sortOrder(fieldnum(RTax25RegisterTrans_ConstantDifferences, rTax25ProfitTable),
                                        fieldnum(RTax25RegisterTrans_ConstantDifferences, LineNumber));
        }

        registerTransList.ins(regTrans);
        registerLineMap.insert(taxCode,registerTransList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBodyDebtReserve</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates tax difference register lines for doubtful debt reserves.
    /// </summary>

    protected void createBodyDebtReserve()
    {
        RTax25DebtModel rTax25DebtModel;
        Map             mapExpenseRAP;
        Map             mapExpenseTAX;
        MapEnumerator   enumerator;
        container       key, valueRAP, valueTAX;
        TransDate       modelStartDate, modelEndDate;
        Set             setProcessedKeys = new Set(Types::Container);
        RefRecId        profitTableRecId = RTax25ProfitTable::findByProfitId(DebtReserveProfitID).RecId;

        rTax25DebtModel = RTax25DebtModel::findRecId(CustParameters::rTax25DebtModelTax());

        [modelStartDate, modelEndDate] = RTax25DebtModel::periodDates(rTax25DebtModel.PeriodType, dateTo);

        if (modelEndDate != dateTo)
        {
            return;
        }

        mapExpenseRAP = RTax25DebtReserveTaxExpenseCalc::newParameters(modelStartDate, modelEndDate, RTax25DebtModelType::RAP).getExpenseMap();
        mapExpenseTAX = RTax25DebtReserveTaxExpenseCalc::newParameters(modelStartDate, modelEndDate, RTax25DebtModelType::TAX).getExpenseMap();

        enumerator = mapExpenseRAP.getEnumerator();
        while (enumerator.moveNext())
        {
            key         = enumerator.currentKey();
            valueRAP    = enumerator.currentValue();

            if (mapExpenseTAX.exists(key))
            {
                valueTAX = mapExpenseTAX.lookup(key);
                setProcessedKeys.add(key);
            }
            else
            {
                valueTAX = [0, 0];
            }

            this.calcDiffForReserve(profitTableRecId, key, valueRAP, valueTAX);
        }

        enumerator = mapExpenseTAX.getEnumerator();
        while (enumerator.moveNext())
        {
            key         = enumerator.currentKey();
            valueTAX    = enumerator.currentValue();

            if (setProcessedKeys.in(key))
            {
                continue;
            }

            this.calcDiffForReserve(profitTableRecId, key, [0, 0], valueTAX);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBodyExchAdj</Name>
				<Source><![CDATA[
    #define.Coeff(10000)
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void createBodyExchAdj(RTax25RegisterTrans_ExchangeAdj _sourceRegisterTrans)
    {
        RTax25RegisterTrans_ConstantDifferences regTrans;
        TaxCode             taxCode = RTax25ProfitTable::find(_sourceRegisterTrans.rTax25ProfitTable).taxCode();
        RecordSortedList    registerTransList;
        ;
        transCount++;
        regTrans = regQuery.addBodyRecord(_sourceRegisterTrans.rTax25ProfitTable,
                                                     [queryExchAdj.getField(#FieldNum1),
                                                      queryExchAdj.getField(#FieldNum2),
                                                      queryExchAdj.getField(#FieldNum3) ? strfmt("@GLS111971", queryExchAdj.getField(#FieldNum3)) : "@SYS24408",
                                                      queryExchAdj.getField(#FieldNum4) ? queryExchAdj.getField(#FieldNum4) : queryExchAdj.getField(#FieldNum6),
                                                      0.0,
                                                      queryExchAdj.getField(#FieldNum4) + queryExchAdj.getField(#FieldNum8),
                                                      queryExchAdj.getField(#FieldNum5),
                                                      queryExchAdj.getField(#FieldNum6) + queryExchAdj.getField(#FieldNum9),
                                                      queryExchAdj.getField(#FieldNum7)],
                                                      _sourceRegisterTrans.TableId,
                                                      _sourceRegisterTrans.RecId,
                                                      _sourceRegisterTrans.LineDescription,
                                                      -(date2num(queryExchAdj.getField(#FieldNum1))*#Coeff + transCount),
                                                      _sourceRegisterTrans.ProfitAmount);

        regTrans.LineNumber = -regTrans.LineNumber;

        if (registerLineMap.exists(taxCode))
        {
            registerTransList = registerLineMap.lookup(taxCode);
        }
        else
        {
            registerTransList = new RecordSortedList(tablenum(RTax25RegisterTrans_ConstantDifferences));
            registerTransList.sortOrder(fieldnum(RTax25RegisterTrans_ConstantDifferences, rTax25ProfitTable),
                                        fieldnum(RTax25RegisterTrans_ConstantDifferences, LineNumber));
        }
        registerTransList.ins(regTrans);
        registerLineMap.insert(taxCode,registerTransList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBodyNotInfluenceIncome</Name>
				<Source><![CDATA[
    #define.Coeff(10000)
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void createBodyNotInfluenceIncome(RTax25RegisterTrans_NotInfluenceIncome _sourceRegisterTrans)
    {
        RTax25RegisterTrans_ConstantDifferences regTrans;
        TaxCode             taxCode = RTax25ProfitTable::find(_sourceRegisterTrans.rTax25ProfitTable).taxCode();
        RecordSortedList    registerTransList;
        ;
        transCount++;
        regTrans = regQuery.addBodyRecord(_sourceRegisterTrans.rTax25ProfitTable,
                                                     [queryNotInfluenceIncome.getField(#FieldNum1),
                                                      queryNotInfluenceIncome.getField(#FieldNum2),
                                                      queryNotInfluenceIncome.getField(#FieldNum3),
                                                      queryNotInfluenceIncome.getField(#FieldNum4) ? queryNotInfluenceIncome.getField(#FieldNum4) : queryNotInfluenceIncome.getField(#FieldNum6),
                                                      0.0,
                                                      queryNotInfluenceIncome.getField(#FieldNum4),
                                                      queryNotInfluenceIncome.getField(#FieldNum5),
                                                      queryNotInfluenceIncome.getField(#FieldNum6),
                                                      queryNotInfluenceIncome.getField(#FieldNum7)],
                                                      _sourceRegisterTrans.TableId,
                                                      _sourceRegisterTrans.RecId,
                                                      _sourceRegisterTrans.LineDescription,
                                                      -(date2num(queryNotInfluenceIncome.getField(1))*#Coeff + transCount),
                                                      _sourceRegisterTrans.ProfitAmount);
        regTrans.LineNumber = -regTrans.LineNumber;

        if (registerLineMap.exists(taxCode))
        {
            registerTransList = registerLineMap.lookup(taxCode);
        }
        else
        {
            registerTransList = new RecordSortedList(tablenum(RTax25RegisterTrans_ConstantDifferences));
            registerTransList.sortOrder(fieldnum(RTax25RegisterTrans_ConstantDifferences, rTax25ProfitTable),
                                        fieldnum(RTax25RegisterTrans_ConstantDifferences, LineNumber));
        }
        registerTransList.ins(regTrans);
        registerLineMap.insert(taxCode,registerTransList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBodyStdCurrentExpense</Name>
				<Source><![CDATA[
    #define.FieldNum10(10)
    #define.Coeff(10000)
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void createBodyStdCurrentExpense(RTax25RegisterTrans_StdCurrentExpense _sourceRegisterTrans)
    {
        RTax25RegisterTrans_ConstantDifferences regTrans;
        TaxCode             taxCode = RTax25ProfitTable::find(_sourceRegisterTrans.rTax25ProfitTable).taxCode();
        RecordSortedList    registerTransList;
        AmountMST           bookkeepingAmount,differenceReceipt,differenceIssue,ctlAmount,ctaAmount;
        AmountMST           taxAmount;
        Tax                 tax = new Tax();
        ;
        bookkeepingAmount = queryStdCurrentExpense.getField(#FieldNum5);
        taxAmount         = queryStdCurrentExpense.getField(#FieldNum8) + queryStdCurrentExpense.getField(#FieldNum10);
        if (bookkeepingAmount == taxAmount)
        {
            return;
        }
        switch (RTax25ProfitTable::find(_sourceRegisterTrans.rTax25ProfitTable).ProfitType)
        {
            case RTax25ProfitType::Issue:
                if (bookkeepingAmount < taxAmount)
                {
                    differenceReceipt = taxAmount - bookkeepingAmount;
                }
                else
                {
                    differenceIssue = bookkeepingAmount - taxAmount;
                }
                break;
            case RTax25ProfitType::Receipt:
                if (bookkeepingAmount > taxAmount)
                {
                    differenceReceipt = bookkeepingAmount - taxAmount;
                }
                else
                {
                    differenceIssue = taxAmount - bookkeepingAmount;
                }
                break;
            default:
                return;
        }
        if (differenceReceipt)
        {
            ctaAmount = tax.taxCalcWithoutSource_RU(taxCode,dateTo,CompanyInfoHelper::standardCurrency(),differenceReceipt,TaxModuleType::Voucher);
        }
        else
        {
            ctlAmount = tax.taxCalcWithoutSource_RU(taxCode,dateTo,CompanyInfoHelper::standardCurrency(),differenceIssue,TaxModuleType::Voucher);
        }
        transCount++;
        regTrans = regQuery.addBodyRecord(_sourceRegisterTrans.rTax25ProfitTable,
                                                     [queryStdCurrentExpense.getField(#FieldNum4),
                                                      queryStdCurrentExpense.getField(#FieldNum2),
                                                      queryStdCurrentExpense.getField(#FieldNum3),
                                                      bookkeepingAmount,
                                                      taxAmount,
                                                      differenceReceipt,
                                                      ctaAmount,
                                                      differenceIssue,
                                                      ctlAmount],
                                                      _sourceRegisterTrans.TableId,
                                                      _sourceRegisterTrans.RecId,
                                                      _sourceRegisterTrans.LineDescription,
                                                      -(date2num(queryStdCurrentExpense.getField(#FieldNum4))*#Coeff + transCount),
                                                      differenceReceipt ? differenceReceipt : differenceIssue);
        regTrans.LineNumber = -regTrans.LineNumber;

        if (registerLineMap.exists(taxCode))
        {
            registerTransList = registerLineMap.lookup(taxCode);
        }
        else
        {
            registerTransList = new RecordSortedList(tablenum(RTax25RegisterTrans_ConstantDifferences));
            registerTransList.sortOrder(fieldnum(RTax25RegisterTrans_ConstantDifferences, rTax25ProfitTable),
                                        fieldnum(RTax25RegisterTrans_ConstantDifferences, LineNumber));
        }
        registerTransList.ins(regTrans);
        registerLineMap.insert(taxCode,registerTransList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBodyTaxExchAdj</Name>
				<Source><![CDATA[
    #define.Coeff(10000)
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void createBodyTaxExchAdj(RTax25RegisterTrans_TaxExchangeAdj _sourceRegisterTrans)
    {
        RTax25RegisterTrans_ConstantDifferences regTrans;
        TaxCode             taxCode = RTax25ProfitTable::find(_sourceRegisterTrans.rTax25ProfitTable).taxCode();
        RecordSortedList    registerTransList;
        ;
        transCount++;
        regTrans = regQuery.addBodyRecord(_sourceRegisterTrans.rTax25ProfitTable,
                                                     [queryTaxExchAdj.getField(#FieldNum1),
                                                      queryTaxExchAdj.getField(#FieldNum2),
                                                      queryTaxExchAdj.getField(#FieldNum3) ? strfmt("@GLS112750", queryTaxExchAdj.getField(#FieldNum3)) : "@SYS24408",
                                                      queryTaxExchAdj.getField(#FieldNum4) ? queryTaxExchAdj.getField(#FieldNum4) : queryTaxExchAdj.getField(#FieldNum6),
                                                      0.0,
                                                      queryTaxExchAdj.getField(#FieldNum4),
                                                      queryTaxExchAdj.getField(#FieldNum5),
                                                      queryTaxExchAdj.getField(#FieldNum6),
                                                      queryTaxExchAdj.getField(#FieldNum7)],
                                                      _sourceRegisterTrans.TableId,
                                                      _sourceRegisterTrans.RecId,
                                                      _sourceRegisterTrans.LineDescription,
                                                      -(date2num(queryTaxExchAdj.getField(#FieldNum1))*#Coeff + transCount),
                                                      _sourceRegisterTrans.ProfitAmount);
        regTrans.LineNumber = -regTrans.LineNumber;

        if (registerLineMap.exists(taxCode))
        {
            registerTransList = registerLineMap.lookup(taxCode);
        }
        else
        {
            registerTransList = new RecordSortedList(tablenum(RTax25RegisterTrans_ConstantDifferences));
            registerTransList.sortOrder(fieldnum(RTax25RegisterTrans_ConstantDifferences, rTax25ProfitTable),
                                        fieldnum(RTax25RegisterTrans_ConstantDifferences, LineNumber));
        }
        registerTransList.ins(regTrans);
        registerLineMap.insert(taxCode,registerTransList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFooter</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void createFooter(Counter       _i,
                                RTax25FieldId _blockFieldNum = 0)
    {
        TaxValue taxValue = TaxData::percent(lastTaxCode,dateTo,0);
        switch (_blockFieldNum)
        {
            case #FieldNum1:
                regQuery.addFooterRecord(0,
                                        [dateNull(),"","", taxCodeBookkeepingAmount,taxCodeTaxAmount,taxCodeAmountReceipt,taxCodeCTAAmount,taxCodeAmountIssue,taxCodeCTLAmount],
                                         0,
                                         strfmt("@GLS107102", lastTaxCode,taxValue),
                                         _i);
                taxCodeBookkeepingAmount = 0;
                taxCodeTaxAmount         = 0;
                taxCodeAmountReceipt     = 0;
                taxCodeAmountIssue       = 0;
                taxCodeCTAAmount         = 0;
                taxCodeCTLAmount         = 0;
                break;
            case #FieldNum2:
                regQuery.addFooterRecord(lastProfitTableRecId,
                                         [dateNull(),"","", profitBookkeepingAmount,profitTaxAmount,profitAmountReceipt,profitCTAAmount,profitAmountIssue,profitCTLAmount],
                                         0,
                                         strfmt("@GLS103999", RTax25ProfitTable::find(lastProfitTableRecId).ProfitId),
                                         _i);
                profitBookkeepingAmount = 0;
                profitTaxAmount         = 0;
                profitAmountReceipt     = 0;
                profitAmountIssue       = 0;
                profitCTAAmount         = 0;
                profitCTLAmount         = 0;
                break;
            default:
                regQuery.addFooterRecord(0,
                                         [dateNull(),"","",totalBookkeepingAmount,totalTaxAmount,totalAmountReceipt,totalCTAAmount,totalAmountIssue,totalCTLAmount],
                                         0,
                                         "@SYS37297",
                                         _i);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createHeader</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void createHeader(Counter       _i,
                                RTax25FieldId _blockFieldNum = 0)
    {
        switch (_blockFieldNum)
        {
            case #FieldNum1:
                regQuery.addHeaderRecord(0,
                                         conNull(),
                                         0,
                                         strfmt("@GLS107103",lastTaxCode, TaxData::percent(lastTaxCode,dateTo,0)),
                                         _i);
                break;
            case #FieldNum2:
                regQuery.addHeaderRecord(lastProfitTableRecId,
                                         conNull(),
                                         0,
                                         strfmt("@GLS104111", RTax25ProfitTable::find(lastProfitTableRecId).ProfitId),
                                         _i);
                break;
            default:
                 regQuery.addHeaderRecord(0,
                                          conNull(),
                                          0 ,
                                          "@SYS28004",
                                          _i);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    public boolean init(RTax25RegisterJournalTrans  _journalTrans = null,
                        Batch                       _batch        = null)
    {
        RTax25RegisterJournalTrans  childJournal;
        RTax25ProfitTable           registerTable;
        boolean                     ret = super(_journalTrans, _batch);

        childJournal = RTax25RegCalcController::findChildJournalTrans(RTax25RegisterType::NotInfluenceIncome, _journalTrans);
        queryNotInfluenceIncome     = RTax25Query::newParameters(RTax25RegisterType::NotInfluenceIncome, childJournal, true);

        childJournal = RTax25RegCalcController::findChildJournalTrans(RTax25RegisterType::StdCurrentExpense, _journalTrans);
        queryStdCurrentExpense      = RTax25Query::newParameters(RTax25RegisterType::StdCurrentExpense,childJournal, true);

        childJournal = RTax25RegCalcController::findChildJournalTrans(RTax25RegisterType::AmountDifference, _journalTrans);
        queryAmountDifference       = RTax25Query::newParameters(RTax25RegisterType::AmountDifference, childJournal, true);

        childJournal = RTax25RegCalcController::findChildJournalTrans(RTax25RegisterType::ExchangeAdj, _journalTrans);
        queryExchAdj                = RTax25Query::newParameters(RTax25RegisterType::ExchangeAdj, childJournal, true);

        childJournal = RTax25RegCalcController::findChildJournalTrans(RTax25RegisterType::TaxExchangeAdj, _journalTrans);
        queryTaxExchAdj             = RTax25Query::newParameters(RTax25RegisterType::TaxExchangeAdj, childJournal, true);

        childJournal = RTax25RegCalcController::findChildJournalTrans(RTax25RegisterType::AssetDeprBonusRecovery, _journalTrans);
        queryAssetDeprBonusRecovery = RTax25Query::newParameters(RTax25RegisterType::AssetDeprBonusRecovery, childJournal, true);

        registerLineMap = new Map (Types::String,Types::Class);

        debtReserveTaxCode  = strltrim(strrtrim(RTax25RegisterParameters::find(registerId, 1).Parameter));

        if (!RTax25ProfitTable::exist(DebtReserveProfitID))
        {
            registerTable.ProfitId = DebtReserveProfitID;
            registerTable.TaxCode  = debtReserveTaxCode;
            registerTable.doInsert();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDebtReserves</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if tax differences for doubtful debt reserves should be calculated.
    /// </summary>
    /// <returns>
    /// A boolean value indicating if tax differences for doubtful debt reserves should be calculated.
    /// </returns>

    private boolean isDebtReserves()
    {
        RTax25RegisterTable rTax25RegisterTable;

        select count(RecId) from rTax25RegisterTable
            where rTax25RegisterTable.RegisterType  == RTax25RegisterType::DebtDebitReservationDetail
               || rTax25RegisterTable.RegisterType  == RTax25RegisterType::DebtDebitReservationDetailRAP;

        return rTax25RegisterTable.RecId == 2;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sortRegisterTrans</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void sortRegisterTrans()
    {
        RTax25RegisterTrans_ConstantDifferences   regTrans;
        int                   i = 1;
        MapEnumerator         mapEnumerator = registerLineMap.getEnumerator();
        RecordSortedList      registerTransList;
        RefRecId              debtReserveProfitTableRecId = RTax25ProfitTable::findByProfitId(DebtReserveProfitID).RecId;

        progress.setText("@SYS4138");
        progress.setTotal(transCount);
        progress.setCount(0);

        while (mapEnumerator.moveNext())
        {
            registerTransList = mapEnumerator.currentValue();
            if (i == 1)
            {
                this.createHeader(i);
            }
            i++;
            lastTaxCode = mapEnumerator.currentKey();
            this.createHeader(i,#FieldNum1);
            lastProfitTableRecId = 0;
            while (registerTransList.next(regTrans))
            {
                if (regTrans.rTax25ProfitTable != lastProfitTableRecId)
                {
                    if (lastProfitTableRecId)
                    {
                        i++;
                        this.createFooter(i,#FieldNum2);
                    }
                    i++;
                    lastProfitTableRecId = regTrans.rTax25ProfitTable;
                    this.createHeader(i,#FieldNum2);
                }
                i++;
                this.totals(regTrans);

                regTrans.LineNumber = -regTrans.LineNumber;
                if (regQuery.getSortedList().find(regTrans))
                {
                    regQuery.getSortedList().del(regTrans);
                    regTrans.LineNumber = i;

                    if (regTrans.rTax25ProfitTable == debtReserveProfitTableRecId)
                    {
                        regTrans.rTax25ProfitTable = 0;
                    }

                    regQuery.getSortedList().ins(regTrans);
                }
                progress.incCount();
            }
            i++;
            this.createFooter(i,#FieldNum2);
            i++;
            this.createFooter(i,#FieldNum1);
        }
        if (i > 1 )
        {
            i++;
            this.createFooter(i);
        }
        progress.incCount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>totals</Name>
				<Source><![CDATA[
    #define.FieldNum9(9)
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void totals(RTax25RegisterTrans_ConstantDifferences _regTrans)
    {
        totalBookkeepingAmount   += _regTrans.BaseAmount;
        totalTaxAmount           += _regTrans.TaxAmount;
        totalAmountReceipt       += _regTrans.DifferencesIncome;
        totalCTAAmount           += _regTrans.CTAAmount;
        totalAmountIssue         += _regTrans.DifferencesExpense;
        totalCTLAmount           += _regTrans.CTLAmount;
        profitBookkeepingAmount  += _regTrans.BaseAmount;
        profitTaxAmount          += _regTrans.TaxAmount;
        profitAmountReceipt      += _regTrans.DifferencesIncome;
        profitCTAAmount          += _regTrans.CTAAmount;
        profitAmountIssue        += _regTrans.DifferencesExpense;
        profitCTLAmount          += _regTrans.CTLAmount;
        taxCodeBookkeepingAmount += _regTrans.BaseAmount;
        taxCodeTaxAmount         += _regTrans.TaxAmount;
        taxCodeAmountReceipt     += _regTrans.DifferencesIncome;
        taxCodeCTAAmount         += _regTrans.CTAAmount;
        taxCodeAmountIssue       += _regTrans.DifferencesExpense;
        taxCodeCTLAmount         += _regTrans.CTLAmount;
    }

]]></Source>
			</Method>
		<Method><Name>isRetryable</Name><Source><![CDATA[
    /// <summary>
    /// Controls whether the batch task should be retried in case of transient errors.
    /// </summary>
    /// <returns>
    /// Always returns true.
    /// </returns>
    [Hookable(false)]
    public final boolean isRetryable() 
    {
        return true;
    }
]]></Source></Method></Methods>
	</SourceCode>
</AxClass>