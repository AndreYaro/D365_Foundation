<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjMultipleContractLinesForProjectFeatureHelper</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Helper class for the 'Enable multiple contract lines for a project' feature.
/// </summary>
public final class ProjMultipleContractLinesForProjectFeatureHelper
{
    private static ProjOpsIntegrationLogger logger = ProjOpsIntegrationLogger::createLogger(classStr(ProjMultipleContractLinesForProjectFeatureHelper));
    private static ProjOpsIntegrationInstrumentationActivites activity = logger.projOpsIntegrationActivity();

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>isFeatureEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the feature is enabled for given company.
    /// </summary>
    /// <param name = "_dataAreaId">Company data area ID, optional, default to current company when not specified.</param>
    /// <returns>
    /// true if the feature is enabled for the company; otherwise, false.
    /// </returns>
    [Hookable(false)]
    public static boolean isFeatureEnabled(DataAreaId _dataAreaId = curExt())
    {
        boolean ret;
        ProjParameters projParameters;

        using (var activityContext = activity.featureStatusContext())
        {
            activityContext.addCustomProperty(ProjOpsInstrumentationBaseActitivies::Company, any2Str(_dataAreaId));

            if (ProjMultipleContractLinesFeatureStateCacheFlight::instance().isEnabled())
            {
                container cacheKey = [strUpr(_dataAreaId)];
                container cachedResult = ProjCache::getValue(ProjCacheScope::MultipleContractLinesFeatureStatus, cacheKey);

                if (cachedResult == conNull() || conLen(cachedResult) == 0)
                {
                    projParameters = ProjMultipleContractLinesForProjectFeatureHelper::getFeatureStateParameterForLE(_dataAreaId);
                    
                    if (projParameters)
                    {
                        // only update cache when ProjParameters is found.
                        ret = projParameters.MultipleContractLinesFeatureStatus == ProjMultipleContractLinesFeatureStatus::Enabled;
                        cachedResult = [ret];
                        ProjCache::insertValue(ProjCacheScope::MultipleContractLinesFeatureStatus, cacheKey, cachedResult);
                        logger.logInformation(strFmt("MultipleContractLinesFeatureStatus cachedResult is Null or Empty. Value inserted in cache for LE %1 = %2", _dataAreaId, any2Str(ret)));
                    }
                    else
                    {
                        ret = false;
                        logger.logInformation(strFmt("ProjParameters was not found or cannot be accessed for LE %1", _dataAreaId));
                    }
                }
                else
                {
                    ret = conpeek(cachedResult, 1);
                    logger.logInformation(strFmt("cachedResult for LE %1 = %2", _dataAreaId, any2Str(ret)));
                }
            }
            else
            {
                projParameters = ProjMultipleContractLinesForProjectFeatureHelper::getFeatureStateParameterForLE(_dataAreaId);
                ret = projParameters.MultipleContractLinesFeatureStatus == ProjMultipleContractLinesFeatureStatus::Enabled;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFeatureStateParameterForLE</Name>
				<Source><![CDATA[
    private static ProjParameters getFeatureStateParameterForLE(DataAreaId _dataAreaId = curExt())
    {
        ProjParameters projParameters;

        using (var activityContext = activity.featureStatusContext())
        {
            unchecked (Uncheck::TableSecurityPermission)
            {
                select firstonly crossCompany MultipleContractLinesFeatureStatus from projParameters
                    where projParameters.DataAreaId == _dataAreaId;
            }

            boolean multipleContractLinesFeatureStatus = projParameters.MultipleContractLinesFeatureStatus == ProjMultipleContractLinesFeatureStatus::Enabled;

            if (multipleContractLinesFeatureStatus && !ProjStatusTypeRule::exist(ProjStatus::Created, ProjType::None, ProjStatusRule::AllowUse))
            {
                ProjStatusTypeRule::enableRulesForNoneTypeProj();
            }

            logger.logInformation(strFmt("ProjParameters.MultipleContractLinesFeatureStatus for LE %1 = %2", _dataAreaId, any2Str(multipleContractLinesFeatureStatus)));
        }

        return projParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContractLineItems</Name>
				<Source><![CDATA[
    public static PSAContractLineItems getContractLineItems(ProjId _projId, PSAContractLineNum _contractLineId, ProjTransType _transType)
    {
        PSAContractLineItems contractLineItems;
        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            if (_contractLineId && ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled())
            {
                contractLineItems = PSAContractLineItems::find(_contractLineId);
            }
            else
            {
                contractLineItems = ProjMultipleContractLinesForProjectFeatureHelper::getProjContractLineByContractIdTransType(_projId, ProjTable::find(_projId).ProjInvoiceProjId, _transType);
            }
        }
        return contractLineItems;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCompanyParameterStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates feature status to expected status.
    /// </summary>
    /// <param name = "_featureStatus">Expected feature status</param>
    public static void setCompanyParameterStatus(ProjMultipleContractLinesFeatureStatus _featureStatus)
    {
        ttsbegin;
        ProjParameters projParameters = ProjParameters::find(true);
        projParameters.MultipleContractLinesFeatureStatus = _featureStatus;
        projParameters.update();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjContractLineByContractIdTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the contract line for given project ID, contract ID and transaction type.
    /// </summary>
    /// <param name = "_projId">Project ID.</param>
    /// <param name = "_contractId">Project contract ID.</param>
    /// <param name = "_projTransType">Project transaction type</param>
    /// <returns>
    /// Contract line which has the given transaction type included.
    /// </returns>
    public static PSAContractLineItems getProjContractLineByContractIdTransType(ProjId _projId, ProjInvoiceProjId _contractId, ProjTransType _projTransType)
    {
        PSAContractLineItems contractLine;
        
        if (_projId &&
            _contractId &&
            (_projTransType == ProjTransType::Hour || _projTransType == ProjTransType::Cost || _projTransType == ProjTransType::Revenue || _projTransType == ProjTransType::Item))
        {
            PSAContractLineItemsSetup contractLineProjSetup;

            // 1 - search contract line with line type: Progress, Time and material
            select firstonly contractLine
                where contractLine.ProjInvoiceProjId == _contractId
                    && contractLine.BillingMethod == ProjContractBillingMethod::TimeMaterial
                    && (contractLine.LineType == PSAContractLineType::TAndM || contractLine.LineType == PSAContractLineType::Progress)
                    && ((_projTransType == ProjTransType::Hour && contractLine.IncludeHourTrans == NoYes::Yes)
                        || (_projTransType == ProjTransType::Cost && contractLine.IncludeExpenseTrans == NoYes::Yes)
                        || (_projTransType == ProjTransType::Item && contractLine.IncludeItemTrans == NoYes::Yes)
                        || (_projTransType == ProjTransType::Revenue && contractLine.IncludeFeeTrans == NoYes::Yes))
                exists join contractLineProjSetup
                    where contractLineProjSetup.ContractLineNum == contractLine.ContractLineNum
                        && contractLineProjSetup.ProjId == _projId;
                        
            if (!contractLine)
            {
                // 2 - search contract line with line type: Milestone
                select firstonly contractLine
                    where contractLine.ProjInvoiceProjId == _contractId
                        && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice
                        && contractLine.LineType == PSAContractLineType::LumpSum
                        && ((_projTransType == ProjTransType::Hour && contractLine.IncludeHourTrans == NoYes::Yes)
                            || (_projTransType == ProjTransType::Cost && contractLine.IncludeExpenseTrans == NoYes::Yes)
                            || (_projTransType == ProjTransType::Item && contractLine.IncludeItemTrans == NoYes::Yes)
                            || (_projTransType == ProjTransType::Revenue && contractLine.IncludeFeeTrans == NoYes::Yes))
                    exists join contractLineProjSetup
                        where contractLineProjSetup.ContractLineNum == contractLine.ContractLineNum
                            && contractLineProjSetup.ProjId == _projId;
            }

            if (!contractLine && _projTransType == ProjTransType::Revenue)
            {
                // 3 - search contract line with line type: Unit of delivery
                select firstonly contractLine
                    where contractLine.ProjInvoiceProjId == _contractId
                        && contractLine.BillingMethod == ProjContractBillingMethod::TimeMaterial
                        && contractLine.LineType == PSAContractLineType::UOD
                        && contractLine.FeeProjId == _projId
                        && contractLine.IncludeFeeTrans == NoYes::Yes;
            }
        }

        return contractLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existContractLineForBillingMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the project contract line for given project ID, contract ID and billing method exists.
    /// </summary>
    /// <param name = "_projId">Project ID.</param>
    /// <param name = "_contractId">The project contract ID.</param>
    /// <param name = "_billingMethod">The billing method: FixedPrice or TimeMaterial.</param>
    /// <returns>
    /// true if the contract line exists; otherwise, false.
    /// </returns>
    public static boolean existContractLineForBillingMethod(ProjId _projId, ProjInvoiceProjId _contractId, ProjContractBillingMethod _billingMethod)
    {
        PSAContractLineItems contractLine;

        if (_projId && _contractId)
        {
            PSAContractLineItemsSetup contractLineProjSetup;

            if (_billingMethod == ProjContractBillingMethod::TimeMaterial)
            {
                // 1 - search contract line with line type: Progress, Time and material
                select firstonly contractLine
                    where contractLine.ProjInvoiceProjId == _contractId
                        && contractLine.BillingMethod == ProjContractBillingMethod::TimeMaterial
                        && (contractLine.LineType == PSAContractLineType::TAndM || contractLine.LineType == PSAContractLineType::Progress)
                    exists join contractLineProjSetup
                        where contractLineProjSetup.ContractLineNum == contractLine.ContractLineNum
                            && contractLineProjSetup.ProjId == _projId;
            }
            
            if (!contractLine && _billingMethod == ProjContractBillingMethod::FixedPrice)
            {
                // 2 - search contract line with line type: Milestone
                select firstonly contractLine
                    where contractLine.ProjInvoiceProjId == _contractId
                        && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice
                        && contractLine.LineType == PSAContractLineType::LumpSum
                    exists join contractLineProjSetup
                        where contractLineProjSetup.ContractLineNum == contractLine.ContractLineNum
                            && contractLineProjSetup.ProjId == _projId;
            }

            if (!contractLine && _billingMethod == ProjContractBillingMethod::TimeMaterial)
            {
                // 3 - search contract line with line type: Unit of delivery
                select firstonly contractLine
                    where contractLine.ProjInvoiceProjId == _contractId
                        && contractLine.BillingMethod == ProjContractBillingMethod::TimeMaterial
                        && contractLine.LineType == PSAContractLineType::UOD
                        && contractLine.FeeProjId == _projId
                        && contractLine.IncludeFeeTrans == NoYes::Yes;
            }
        }

        return contractLine.RecId ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBillingMethodForProjContractLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the billing method given project contract line number.
    /// </summary>
    /// <param name = "_contractLineNum">Project contract line number.</param>
    /// <returns>
    /// The <c>ProjContractBillingMethod</c>, FixedPrice or TimeMaterial.
    /// </returns>
    public static ProjContractBillingMethod getBillingMethodForProjContractLine(PSAContractLineNum _contractLineNum)
    {
        PSAContractLineItems contractLine;

        if (_contractLineNum)
        {
            select firstonly contractLine
                where contractLine.ContractLineNum == _contractLineNum;
        }

        return contractLine.BillingMethod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjContractLineNumForTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets project contract line number for given project transaction type.
    /// </summary>
    /// <param name = "_projId">Project ID.</param>
    /// <param name = "_contractId">Project contract ID.</param>
    /// <param name = "_projTransType">Project transaction type.</param>
    /// <param name = "_failWhenNoBillingMethodFound">Whether to fail the process when no contract line is configured for the item transaction type.</param>
    /// <returns>
    /// Contract line number for the given project transaction type.
    /// </returns>
    public static PSAContractLineNum getProjContractLineNumForTransType(ProjId _projId, ProjInvoiceProjId _contractId, ProjTransType _projTransType, boolean _failWhenNoBillingMethodFound = true)
    {
        PSAContractLineItems contractLine = ProjMultipleContractLinesForProjectFeatureHelper::getProjContractLineByContractIdTransType(_projId, _contractId, _projTransType);

        if (_failWhenNoBillingMethodFound && !contractLine.ContractLineNum)
        {
            throw Error(strFmt("@Proj:ProjNoContractLineForTransType", enum2Str(_projTransType), _contractId, _projId));
        }

        return contractLine.ContractLineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existContractLineForHourExpenseItemTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a contract line from the given contract exists which includes billing method for transaction type Hour or Expense or Item.
    /// </summary>
    /// <param name = "_contractNum">Contract number.</param>
    /// <returns>
    /// True if the contract line exists; otherwise, false.
    /// </returns>
    public static boolean existContractLineForHourExpenseItemTransType(ProjInvoiceProjId _contractNum)
    {
        PSAContractLineItems contractLine;

        if (_contractNum)
        {
            select firstonly contractLine
                where contractLine.ProjInvoiceProjId == _contractNum
                    && (contractLine.IncludeHourTrans == NoYes::Yes
                        || contractLine.IncludeExpenseTrans == NoYes::Yes
                        || contractLine.IncludeItemTrans == NoYes::Yes);
        }

        return contractLine.RecId ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existContractLineForRevenueTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a contract line from the given contract exists which includes billing method for Revenue transaction type.
    /// </summary>
    /// <param name = "_contractNum">Contract number.</param>
    /// <returns>
    /// True if the contract line exists; otherwise, false.
    /// </returns>
    public static boolean existContractLineForRevenueTransType(ProjInvoiceProjId _contractNum)
    {
        PSAContractLineItems contractLine;

        if (_contractNum)
        {
            select firstonly contractLine
                where contractLine.ProjInvoiceProjId == _contractNum && contractLine.IncludeFeeTrans;
        }

        return contractLine.RecId ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existContractLineForTransTypeBillingMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a contract line from the given contract exists which includes given transaction type and billing method.
    /// </summary>
    /// <param name = "_contractNum">Contract number.</param>
    /// <param name = "_projTransType">Project transaction type.</param>
    /// <param name = "_billingMethod">The billing method: FixedPrice or TimeMaterial.</param>
    /// <returns>
    /// True if the contract line exists; otherwise, false.
    /// </returns>
    public static boolean existContractLineForTransTypeBillingMethod(ProjInvoiceProjId _contractNum, ProjTransType _projTransType, ProjContractBillingMethod _billingMethod)
    {
        PSAContractLineItems contractLine;

        if (_contractNum)
        {
            switch (_projTransType)
            {
                case ProjTransType::Hour:
                    select firstonly contractLine
                        where contractLine.IncludeHourTrans == NoYes::Yes
                            && contractLine.ProjInvoiceProjId == _contractNum
                            && contractLine.BillingMethod == _billingMethod;
                    break;

                case ProjTransType::Cost:
                    select firstonly contractLine
                        where contractLine.IncludeExpenseTrans == NoYes::Yes
                            && contractLine.ProjInvoiceProjId == _contractNum
                            && contractLine.BillingMethod == _billingMethod;
                    break;

                case ProjTransType::Revenue:
                    select firstonly contractLine
                        where contractLine.IncludeFeeTrans == NoYes::Yes
                            && contractLine.ProjInvoiceProjId == _contractNum
                            && contractLine.BillingMethod == _billingMethod;
                    break;

                case ProjTransType::Item:
                    select firstonly contractLine
                        where contractLine.IncludeItemTrans == NoYes::Yes
                            && contractLine.ProjInvoiceProjId == _contractNum
                            && contractLine.BillingMethod == _billingMethod;
                    break;
            }
        }

        return contractLine.RecId ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existOverlappingContractLineForTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Given a contract line number, contract ID, and project transaction type, checks if there is another contract line
    /// from the same contract which includes the given transaction type and shares the same project ID
    /// </summary>
    /// <param name = "_contractLineNum">Contract line number.</param>
    /// <param name = "_contractId">Contract ID.</param>
    /// <param name = "_projTransType">Project transaction type.</param>
    /// <returns>
    /// True if another contract line exists; otherwise, false.
    /// </returns>
    public static boolean existOverlappingContractLineForTransType(PSAContractLineNum _contractLineNum, ProjInvoiceProjId _contractId, ProjTransType _projTransType)
    {
        PSAContractLineItems contractLine;
        PSAContractLineItemsSetup contractLineSetup, contractLineSetup2;

        if (_contractLineNum &&
            (_projTransType == ProjTransType::Hour || _projTransType == ProjTransType::Cost ||
             _projTransType == ProjTransType::Revenue || _projTransType == ProjTransType::Item))
        {
            select firstonly RecId from contractLine
                where (contractLine.ProjInvoiceProjId == _contractId
                    && (_projTransType == ProjTransType::Hour && contractLine.IncludeHourTrans == NoYes::Yes)
                        || (_projTransType == ProjTransType::Cost && contractLine.IncludeExpenseTrans == NoYes::Yes)
                        || (_projTransType == ProjTransType::Item && contractLine.IncludeItemTrans == NoYes::Yes)
                        || (_projTransType == ProjTransType::Revenue && contractLine.IncludeFeeTrans == NoYes::Yes))
                exists join contractLineSetup
                    where contractLineSetup.ContractLineNum == contractLine.ContractLineNum
                    exists join contractLineSetup2
                        where contractLineSetup2.ContractLineNum == _contractLineNum
                            && contractLineSetup2.ProjId == contractLineSetup.ProjId
                            && contractLineSetup2.ContractLineNum != contractLineSetup.ContractLineNum;
        }
        return contractLine.RecId ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existOverlappingContractLineAssociationForProj</Name>
				<Source><![CDATA[
    /// <summary>
    /// Given a contract line number, contract ID, project ID, and flags indicating which type of transactions are included, 
    /// checks to see if there exists a different contract line from the same contract with the same project ID
    /// which includes one of the given transaction types 
    /// </summary>
    /// <param name = "_contractLineNum">Contract line number.</param>
    /// <param name = "_contractId">Contract ID.</param>
    /// <param name = "_projId">Project ID.</param>
    /// <param name = "_hourTrans">Are hour transactions included.</param>
    /// <param name = "_expenseTrans">Are expense transactions included.</param>
    /// <param name = "_itemTrans">Are item transactions included.</param>
    /// <param name = "_feeTrans">Are fee transactions included.</param>
    /// <returns>
    /// True if another contract line exists; otherwise, false.
    /// </returns>
    public static boolean existOverlappingContractLineAssociationForProj(PSAContractLineNum _contractLineNum, ProjInvoiceProjId _contractId, ProjId _projId, NoYes _hourTrans, NoYes _expenseTrans, NoYes _itemTrans, NoYes _feeTrans)
    {
        PSAContractLineItems contractLine;
        PSAContractLineItemsSetup contractLineSetup;

        // If none of the transactions types are set then there is no chance for a conflict so bail out
        if (_hourTrans == NoYes::No && _expenseTrans == NoYes::No && _itemTrans == NoYes::No && _feeTrans == NoYes::No)
        {
            return false; 
        }

        if (_contractLineNum && _projId)
        {
            select firstonly RecId from contractLine
                where (contractLine.ProjInvoiceProjId == _contractId && (_hourTrans == NoYes::Yes && contractLine.IncludeHourTrans == NoYes::Yes)
                    || (_expenseTrans == NoYes::Yes && contractLine.IncludeExpenseTrans == NoYes::Yes)
                    || (_itemTrans == NoYes::Yes && contractLine.IncludeItemTrans == NoYes::Yes)
                    || (_feeTrans == NoYes::Yes && contractLine.IncludeFeeTrans == NoYes::Yes))
                exists join contractLineSetup
                    where contractLineSetup.ContractLineNum == contractLine.ContractLineNum
                        && contractLineSetup.ContractLineNum != _contractLineNum
                        && contractLineSetup.ProjId == _projId;
        }

        return contractLine.RecId ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existOverlappingContractLineAssociation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Given a contract line number, contract ID,  and flags indicating which type of transactions are included,
    /// checks to see if there exists a different contract line from the same contract with the same project ID
    /// which includes one of the given transaction types
    /// </summary>
    /// <param name = "_contractLineNum">Contract line number.</param>
    /// <param name = "_contractId">Contract ID.</param>
    /// <param name = "_hourTrans">Are hour transactions included.</param>
    /// <param name = "_expenseTrans">Are expense transactions included.</param>
    /// <param name = "_itemTrans">Are item transactions included.</param>
    /// <param name = "_feeTrans">Are fee transactions included.</param>
    /// <returns>
    /// True if another contract line exists; otherwise, false.
    /// </returns>
    public static boolean existOverlappingContractLineAssociation(PSAContractLineNum _contractLineNum, ProjInvoiceProjId _contractId, NoYes _hourTrans, NoYes _expenseTrans, NoYes _itemTrans, NoYes _feeTrans)
    {
        PSAContractLineItemsSetup contractLineSetup;

        // If none of the transactions types are set then there is no chance for a conflict so bail out
        if (_hourTrans == NoYes::No && _expenseTrans == NoYes::No && _itemTrans == NoYes::No && _feeTrans == NoYes::No)
        {
            return false;
        }

        if (_contractLineNum)
        {
            while select ProjId from contractLineSetup
                where contractLineSetup.ContractLineNum == _contractLineNum
            {
                if (ProjMultipleContractLinesForProjectFeatureHelper::existOverlappingContractLineAssociationForProj(_contractLineNum, _contractId, contractLineSetup.ProjId, _hourTrans, _expenseTrans, _itemTrans, _feeTrans))
                {
                    return true;
                }
            }
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAssociatedProjIdFromContractLineNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Given a contract line number returns the associated project
    /// </summary>
    /// <param name = "_contractLineNum">Contract line number.</param>
    /// <returns>Project ID associated with the given contract line</returns>
    public static ProjId getAssociatedProjIdFromContractLineNum(PSAContractLineNum _contractLineNum)
    {
        PSAContractLineItemsSetup contractLineSetup;

        select firstonly ProjId from contractLineSetup
            where contractLineSetup.contractLineNum == _contractLineNum;

        return contractLineSetup.ProjId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBillingMethodContractLineForHourExpenseItemTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a contract line from the given contract which includes the specified billing method for transaction type Hour or Expense or Item.
    /// </summary>
    /// <param name = "_projId">Project ID.</param>
    /// <param name = "_contractNum">Contract number.</param>
    /// <param name = "_billingMethod">The billing method.</param>
    /// <returns>
    /// The <c>PSAContractLineItems</c> record.
    /// </returns>
    public static PSAContractLineItems findBillingMethodContractLineForHourExpenseItemTransType(ProjId _projId, ProjInvoiceProjId _contractNum, ProjContractBillingMethod _billingMethod)
    {
        PSAContractLineItems contractLine;
        
        if (_projId && _contractNum)
        {
            PSAContractLineItemsSetup contractLineProjSetup;

            if (_billingMethod == ProjContractBillingMethod::TimeMaterial)
            {
                // 1 - search contract line with line type: Progress, Time and material
                select firstonly contractLine
                    where contractLine.ProjInvoiceProjId == _contractNum
                        && contractLine.BillingMethod == ProjContractBillingMethod::TimeMaterial
                        && (contractLine.LineType == PSAContractLineType::TAndM || contractLine.LineType == PSAContractLineType::Progress)
                        && (contractLine.IncludeHourTrans == NoYes::Yes
                            || contractLine.IncludeExpenseTrans == NoYes::Yes
                            || contractLine.IncludeItemTrans == NoYes::Yes)
                    exists join contractLineProjSetup
                        where contractLineProjSetup.ContractLineNum == contractLine.ContractLineNum
                            && contractLineProjSetup.ProjId == _projId;
            }

            if (!contractLine && _billingMethod == ProjContractBillingMethod::FixedPrice)
            {
                // 2 - search contract line with line type: Milestone
                select firstonly contractLine
                    where contractLine.ProjInvoiceProjId == _contractNum
                        && contractLine.BillingMethod == ProjContractBillingMethod::FixedPrice
                        && contractLine.LineType == PSAContractLineType::LumpSum
                        && (contractLine.IncludeHourTrans == NoYes::Yes
                            || contractLine.IncludeExpenseTrans == NoYes::Yes
                            || contractLine.IncludeItemTrans == NoYes::Yes)
                    exists join contractLineProjSetup
                        where contractLineProjSetup.ContractLineNum == contractLine.ContractLineNum
                            && contractLineProjSetup.ProjId == _projId;
            }
        }

        return contractLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransTypeIncludedByBillingMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the transaction type is included in a specific contract line billing method.
    /// </summary>
    /// <param name = "_projId">Project ID.</param>
    /// <param name = "_contractId">Project contract ID.</param>
    /// <param name = "_projTransType">Project transaction type.</param>
    /// <param name = "_billingMethod">The billing method: FixedPrice or TimeMaterial.</param>
    /// <returns>
    /// true if the transaction is included in the given contract line billing method; otherwise, false.
    /// </returns>
    public static boolean isTransTypeIncludedByBillingMethod(ProjId _projId, ProjInvoiceProjId _contractId, ProjTransType _projTransType, ProjContractBillingMethod _billingMethod)
    {
        boolean ret = false;

        if (_projId && _contractId)
        {
            PSAContractLineItems contractLine = ProjMultipleContractLinesForProjectFeatureHelper::getProjContractLineByContractIdTransType(_projId, _contractId, _projTransType);

            ret = contractLine && contractLine.BillingMethod == _billingMethod;
        }
        
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasFixedPriceBillingForItemTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the project item transactions should be billed using fixed price billing method.
    /// </summary>
    /// <param name = "_projId">Project ID.</param>
    /// <returns>
    /// true if project item transactions should be billed using fixed price billing method; otherwise, false.
    /// </returns>
    public static boolean hasFixedPriceBillingForItemTransactions(ProjId _projId)
    {
        boolean ret = false;

        ProjTable projTable = ProjTable::find(_projId);

        if (projTable.ProjInvoiceProjId)
        {
            ret = ProjMultipleContractLinesForProjectFeatureHelper::isTransTypeIncludedByBillingMethod(
                    _projId,
                    projTable.ProjInvoiceProjId,
                    ProjTransType::Item,
                    ProjContractBillingMethod::FixedPrice);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasMultiContractLineFixedPriceBillingForItemTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if Multiple Contract Lines feature is enabled and the project item transactions should be billed using fixed price billing method.
    /// </summary>
    /// <param name = "_projId">Project ID.</param>
    /// <returns>
    /// true if Multiple Contract Lines feature is enabled and project item transactions should be billed using fixed price billing method; otherwise, false.
    /// </returns>
    public static boolean hasMultiContractLineFixedPriceBillingForItemTrans(ProjId _projId)
    {
        boolean isFixedPriceProject = _projId != ''
                    && ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled()
                    && ProjMultipleContractLinesForProjectFeatureHelper::hasFixedPriceBillingForItemTransactions(_projId);

        return isFixedPriceProject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFixedPriceBillingMethodForContractLine</Name>
				<Source><![CDATA[
    public static boolean isFixedPriceBillingMethodForContractLine(ProjTable _projTable, PSAContractLineNum _contractLineId, ProjTransType _transType, boolean _projOpsEnabled = ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled())
    {
        boolean ret = false;
        if (_projTable)
        {
            if (_contractLineId && _projOpsEnabled)
            {
                ret = PSAContractLineItems::find(_contractLineId).BillingMethod == ProjContractBillingMethod::FixedPrice;
            }
            else
            {
                ret = ProjMultipleContractLinesForProjectFeatureHelper::isFixedPriceBillingMethod(_projTable, _transType);
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFixedPriceBillingMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the given transaction type should be using FixedPrice billing method when <c>ProjEnableMultipleContractLinesForProjectFeature</c> is turned on,
    ///   or whether the project type is FixedPrice when the feature is turned off.
    /// </summary>
    /// <param name = "_projTable"><c>ProjTable</c> record.</param>
    /// <param name = "_projTransType">Project transaction type.</param>
    /// <returns>
    /// tuen when the given transaction type should be using FixedPrice billing method or the project type is FixedPrice; otherwise, false.
    /// </returns>
    public static boolean isFixedPriceBillingMethod(ProjTable _projTable, ProjTransType _projTransType)
    {
        boolean ret = false;

        ret = _projTable
                && (_projTable.Type == ProjType::FixedPrice
                    || (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled()
                        && ProjMultipleContractLinesForProjectFeatureHelper::isTransTypeIncludedByBillingMethod(_projTable.ProjId, _projTable.ProjInvoiceProjId, _projTransType, ProjContractBillingMethod::FixedPrice)));

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTimeMaterialBillingMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the given transaction type should be using TimeMaterial billing method when <c>ProjEnableMultipleContractLinesForProjectFeature</c> is turned on,
    ///   or whether the project type is TimeMaterial when the feature is turned off.
    /// </summary>
    /// <param name = "_projTable"><c>ProjTable</c> record.</param>
    /// <param name = "_projTransType">Project transaction type.</param>    
    /// <returns>
    /// tuen when the given transaction type should be using TimeMaterial billing method or the project type is TimeMaterial; otherwise, false.
    /// </returns>
    public static boolean isTimeMaterialBillingMethod(ProjTable _projTable, ProjTransType _projTransType)
    {
        boolean ret = false;

        ret = _projTable
                && (_projTable.Type == ProjType::TimeMaterial
                    || (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled()
                        && ProjMultipleContractLinesForProjectFeatureHelper::isTransTypeIncludedByBillingMethod(_projTable.ProjId, _projTable.ProjInvoiceProjId, _projTransType, ProjContractBillingMethod::TimeMaterial)));

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTimeMaterialBillingMethodForContractLine</Name>
				<Source><![CDATA[
    public static boolean isTimeMaterialBillingMethodForContractLine(ProjTable _projTable, PSAContractLineNum _contractLineId, ProjTransType _transType, boolean _projOpsEnabled = ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled())
    {
        boolean ret = false;
        if (_projTable)
        {
            if (_contractLineId && _projOpsEnabled)
            {
                ret = PSAContractLineItems::find(_contractLineId).BillingMethod == ProjContractBillingMethod::TimeMaterial;
            }
            else
            {
                ret = ProjMultipleContractLinesForProjectFeatureHelper::isTimeMaterialBillingMethod(_projTable, _transType);
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInternalProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the given project is treated as internal project.
    /// </summary>
    /// <param name = "_projTable"><c>ProjTable</c> record.</param>
    /// <returns>
    /// tuen if the given project has no contract when <c>ProjEnableMultipleContractLinesForProjectFeature</c> is turned on, or the project tpe is Internal; otherwise, false.
    /// </returns>
    public static boolean isInternalProject(ProjTable _projTable)
    {
        boolean ret = false;

        ret = _projTable
                && (_projTable.Type == ProjType::Internal
                    || (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled() && _projTable.ProjInvoiceProjId == ''));

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>quotationTransType2ProjTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Maps <c>QuotationProjTransType</c> enum value to <c>ProjTransType</c>
    /// </summary>
    /// <param name = "_quotationProjTransType">The quotation transaction type.</param>
    /// <returns>
    /// The corresponding <c>ProjTransType</c> value.
    /// </returns>
    public static ProjTransType quotationTransType2ProjTransType(QuotationProjTransType _quotationProjTransType)
    {
        ProjTransType   projTransType;

        switch (_quotationProjTransType)
        {
            case QuotationProjTransType::None       :
                projTransType = ProjTransType::None;
                break;

            case QuotationProjTransType::Fee        :
                projTransType = ProjTransType::Revenue;
                break;

            case QuotationProjTransType::Hour       :
                projTransType = ProjTransType::Hour;
                break;

            case QuotationProjTransType::Expense    :
                projTransType = ProjTransType::Cost;
                break;

            case QuotationProjTransType::Item       :
                projTransType = ProjTransType::Item;
                break;
        }

        return projTransType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projectContainsFixedPriceComponent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the given project has an associated fixed price component by looking at the milestone transactions.
    /// </summary>
    /// <param name = "_projId">Project ID.</param>
    /// <returns>true if project is associated with any milestone transaction; otherwise, false.</returns>
	protected internal static boolean projectContainsFixedPriceComponent(ProjId _projId)
    {
        ProjOnAccTrans onAccTrans;

		select firstonly RecId from onAccTrans
            where onAccTrans.ProjId == _projId
				&& onAccTrans.TransactionOrigin == ProjOrigin::Milestone;

        return onAccTrans.RecId != 0;
	}

]]></Source>
			</Method>
			<Method>
				<Name>updateProjectPostedTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates project transactions posted with no contract associated.
    /// </summary>
    /// <param name = "_params">A container with the list of parameters used for updating project transactions.</param>
    public static void updateProjectPostedTrans(container _params)
    {
        if (_params == conNull() || conLen(_params) < 2)
        {
            return;
        }

        ProjId projId = conPeek(_params, 1);
        ProjInvoiceProjId projInvoiceProjId = conPeek(_params, 2);

        List projFundingSourceList = ProjFundingSource::getFundingSourcesByContract(projInvoiceProjId);
        ProjTable projTableLocal = ProjTable::find(projId);
        
        ttsbegin;

        ProjMultipleContractLinesForProjectFeatureHelper::updateProjectPostedEmplTrans(projTableLocal, projFundingSourceList);

        ProjMultipleContractLinesForProjectFeatureHelper::updateProjectPostedCostTrans(projTableLocal, projFundingSourceList);

        ProjMultipleContractLinesForProjectFeatureHelper::updateProjectPostedItemTrans(projTableLocal, projFundingSourceList);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjectPostedEmplTrans</Name>
				<Source><![CDATA[
    private static void updateProjectPostedEmplTrans(ProjTable _projTable, List _projFundingSourceList)
    {
        ListEnumerator listEnumerator = _projFundingSourceList.getEnumerator();
        ProjFundingSourceRefId fundingSourceRecId = listEnumerator.moveNext() ? listEnumerator.current() : 0;
        ProjFundingSource projFundingSource = ProjFundingSource::find(fundingSourceRecId);

        ProjEmplTrans projEmplTrans;
        while select forupdate projEmplTrans
            where projEmplTrans.ProjId == _projTable.ProjId && projEmplTrans.PSAContractLineNum == ''
        {
            projEmplTrans.PSAContractLineNum = ProjMultipleContractLinesForProjectFeatureHelper::getProjContractLineNumForTransType(_projTable.ProjId, _projTable.ProjInvoiceProjId, ProjTransType::Hour);

            DimensionDefault transDefaultDimension;

            if (ProjFeatureStateHelper::isProjDefaultDimensionRuleFeatureEnabled())
            {
                transDefaultDimension = ProjDefaultDimensionRule::getDefaultDimension(_projTable.ProjId, projEmplTrans.PSAContractLineNum);
            }
            else
            {
                transDefaultDimension = _projTable.DefaultDimension;
            }
            
            // update ProjJournalTrans
            ProjJournalTrans projJournalTrans;
            while select forupdate projJournalTrans
                where projJournalTrans.ProjId == _projTable.ProjId
                    && projJournalTrans.TransId == projEmplTrans.TransId
                    && projJournalTrans.Voucher == projEmplTrans.VoucherJournal
            {
                if (projJournalTrans.Resource)
                {
                    transDefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(ResourceFacade::getDefaultDimensionByDate(projJournalTrans.Resource, DateTimeUtil::newDateTime(projJournalTrans.ProjTransDate, 0)),
                        transDefaultDimension);
                }
                projJournalTrans.DefaultDimension = transDefaultDimension;
                projJournalTrans.update();
            }

            projEmplTrans.DefaultDimension = transDefaultDimension;
            projEmplTrans.update();

            DimensionDefault costSaleDefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(transDefaultDimension, projFundingSource.DefaultDimension);

            // update ProjEmplTransCost
            ProjEmplTransCost projEmplTransCost;
            while select forupdate projEmplTransCost
                where projEmplTransCost.TransId == projEmplTrans.TransId
                    && projEmplTransCost.TransStatus == ProjTransStatus::Posted
            {
                projEmplTransCost.FundingSource = fundingSourceRecId;
                projEmplTransCost.DefaultDimension = costSaleDefaultDimension;
                projEmplTransCost.update();
            }

            // update ProjEmplTransSale
            ProjEmplTransSale projEmplTransSale;
            while select forupdate projEmplTransSale
                where projEmplTransSale.TransId == projEmplTrans.TransId
                    && projEmplTransSale.TransStatus == ProjTransStatus::Posted
            {
                projEmplTransSale.FundingSource = fundingSourceRecId;
                projEmplTransSale.DefaultDimension = costSaleDefaultDimension;
                projEmplTransSale.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjectPostedCostTrans</Name>
				<Source><![CDATA[
    private static void updateProjectPostedCostTrans(ProjTable _projTable, List _projFundingSourceList)
    {
        ListEnumerator listEnumerator = _projFundingSourceList.getEnumerator();
        ProjFundingSourceRefId fundingSourceRecId = listEnumerator.moveNext() ? listEnumerator.current() : 0;
        ProjFundingSource projFundingSource = ProjFundingSource::find(fundingSourceRecId);

        ProjCostTrans projCostTrans;
        while select forupdate projCostTrans
            where projCostTrans.ProjId == _projTable.ProjId && projCostTrans.PSAContractLineNum == ''
        {
            projCostTrans.PSAContractLineNum = ProjMultipleContractLinesForProjectFeatureHelper::getProjContractLineNumForTransType(_projTable.ProjId, _projTable.ProjInvoiceProjId, ProjTransType::Cost);
      
            DimensionDefault transDefaultDimension;

            if (ProjFeatureStateHelper::isProjDefaultDimensionRuleFeatureEnabled())
            {
                transDefaultDimension = ProjDefaultDimensionRule::getDefaultDimension(_projTable.ProjId, projCostTrans.PSAContractLineNum);
            }
            else
            {
                transDefaultDimension = _projTable.DefaultDimension;
            }
           
            // update LedgerJournalTrans
            LedgerJournalTrans ledgerJournalTrans;
            LedgerJournalTrans_Project ledgerJournalTrans_proj;
            while select forupdate ledgerJournalTrans
                join Resource, ProjTransDate, RefRecId from ledgerJournalTrans_proj
                where ledgerJournalTrans.RecId == projCostTrans.LedgerJournalTrans
                    && ledgerJournalTrans.RecId == ledgerJournalTrans_proj.RefRecId
            {
                if (ledgerJournalTrans_proj.Resource)
                {
                    transDefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(
                        ResourceFacade::getDefaultDimensionByDate(ledgerJournalTrans_proj.Resource, DateTimeUtil::newDateTime(ledgerJournalTrans_proj.ProjTransDate, 0)),
                        transDefaultDimension);
                }
                ledgerJournalTrans.DefaultDimension = transDefaultDimension;
                ledgerJournalTrans.update();
            }

            projCostTrans.DefaultDimension = transDefaultDimension;
            projCostTrans.update();

            DimensionDefault costSaleDefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(transDefaultDimension, projFundingSource.DefaultDimension);
            // update ProjCostTransCost
            ProjCostTransCost projCostTransCost;
            while select forupdate projCostTransCost
                where projCostTransCost.TransId == projCostTrans.TransId
                    && projCostTransCost.TransStatus == ProjTransStatus::Posted
            {
                projCostTransCost.FundingSource = fundingSourceRecId;
                projCostTransCost.DefaultDimension = costSaleDefaultDimension;
                projCostTransCost.update();
            }

            // update ProjCostTransSale
            ProjCostTransSale projCostTransSale;
            while select forupdate projCostTransSale
                where projCostTransSale.TransId == projCostTrans.TransId
                    && projCostTransSale.TransStatus == ProjTransStatus::Posted
            {
                projCostTransSale.FundingSource = fundingSourceRecId;
                projCostTransSale.DefaultDimension = costSaleDefaultDimension;
                projCostTransSale.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjectPostedItemTrans</Name>
				<Source><![CDATA[
    private static void updateProjectPostedItemTrans(ProjTable _projTable, List _projFundingSourceList)
    {
        ListEnumerator listEnumerator = _projFundingSourceList.getEnumerator();
        ProjFundingSourceRefId fundingSourceRecId = listEnumerator.moveNext() ? listEnumerator.current() : 0;
        ProjFundingSource projFundingSource = ProjFundingSource::find(fundingSourceRecId);

        ProjItemTrans projItemTrans;

        while select forupdate projItemTrans
            where projItemTrans.ProjId == _projTable.ProjId && projItemTrans.PSAContractLineNum == ''
        {
            projItemTrans.PSAContractLineNum = ProjMultipleContractLinesForProjectFeatureHelper::getProjContractLineNumForTransType(_projTable.ProjId, _projTable.ProjInvoiceProjId, ProjTransType::Item);

            DimensionDefault transDefaultDimension;
            
            if (ProjFeatureStateHelper::isProjDefaultDimensionRuleFeatureEnabled())
            {
                transDefaultDimension = ProjDefaultDimensionRule::getDefaultDimension(_projTable.ProjId, projItemTrans.PSAContractLineNum);
            }
            else
            {
                transDefaultDimension = _projTable.DefaultDimension;
            }
            
            // update InventJournalTrans
            InventJournalTrans inventJournalTrans;

            while select forupdate inventJournalTrans
                where inventJournalTrans.ProjId == _projTable.ProjId
                    && inventJournalTrans.ProjTransId == projItemTrans.ProjTransId
            {
                inventJournalTrans.DefaultDimension = transDefaultDimension;
                inventJournalTrans.update();
            }

            projItemTrans.DefaultDimension = transDefaultDimension;
            projItemTrans.update();

            DimensionDefault costSaleDefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(transDefaultDimension, projFundingSource.DefaultDimension);
            
            // update ProjItemTransCost
            ProjItemTransCost projItemTransCost;

            while select forupdate projItemTransCost
                where projItemTransCost.ProjAdjustRefId == projItemTrans.ProjAdjustRefId
                    && projItemTransCost.InventTransId == projItemTrans.InventTransId
                    && projItemTransCost.TransStatus == ProjTransStatus::Posted
            {
                projItemTransCost.FundingSource = fundingSourceRecId;
                projItemTransCost.DefaultDimension = costSaleDefaultDimension;
                projItemTransCost.update();
            }

            // update ProjItemTransSale
            ProjItemTransSale projItemTransSale;

            while select forupdate projItemTransSale
                where projItemTransSale.ProjTransId == projItemTrans.ProjTransId
                    && projItemTransSale.TransStatus == ProjTransStatus::Posted
            {
                projItemTransSale.FundingSource = fundingSourceRecId;
                projItemTransSale.DefaultDimension = costSaleDefaultDimension;
                projItemTransSale.update();
            }
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>