<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjControlCalc</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>ProjControlCalc</c> class serves as the base class for various calculations.
/// </summary>
public abstract class ProjControlCalc
{
    ProjId                  projId;
    ProjControlId           controlId;
    ProjPeriodFrom          periodFrom;
    ProjPeriodTo            periodTo;
    ProjControlVersion      controlVersion;
    boolean                 parmEliminate;
    ProjCategoryId          categoryId;
    private ProjContractBillingMethod billingMethod;

    AmountMST               wipAccruedTurnoverAcc;
    AmountMST               wipAccruedTurnoverProfitAcc;
    AmountMST               wipAccruedTurnoverProdAcc;
    AmountMST               wipCostAcc;
    AmountMST               contractSum;
    AmountMST               wipValue;

    AmountMST               accGrossMarginTemp;

    Factor                  factor;
    ProjControlPeriodTableColumn
                            projControlColumnEstimatePrev,
                            projControlColumnAccEstimatePrev,
                            projControlColumnTotalEstimatePrev;

    boolean                 calledFromCode;
    boolean                 isContractLineUsed;
    AmountMST               projProfit;
    AmountMST               projSalesValue;
    AmountMST               projAccruedCost;
    AmountMST               maxCapital;

    ProjControlPeriodTableColumn
                            projControlPeriodTableColumnEstimate,
                            projControlPeriodTableColumnAccEstimate,
                            projControlPeriodTableColumnTotal;
    ProjRevRecContractLine projRevRecContractLine;

    ProjBeginningBalance    beginningBalance;

    [SysObsolete("This variable is obsolete. Use projContractCurrencyForRevRecParmEnabled instead.", false, 10\6\2024)]
    boolean contractCurrencyRevRecCalculationFeature = ProjContractCurrencyForRevRecCalculationFeature::isEnabled();

    private boolean projContractCurrencyForRevRecParmEnabled = ProjParameters::find().EnableContractCurrencyForRevRec;
    boolean contractLineBasedRevRecFeature = ProjContractLineBasedRevenueRecognitionFeatureHelper::isFeatureEnabled();
        
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>actualCostAmount</Name>
				<Source><![CDATA[
    protected AmountMST actualCostAmount(ProjControlPeriodTable  _projControlPeriod)
    {
        return (select sum(ActuelCostAmount) from projControlPeriodCostGroup
                    where projControlPeriodCostGroup.ProjId     == _projControlPeriod.ProjId         &&
                          projControlPeriodCostGroup.ControlId  == _projControlPeriod.ControlId      &&
                          projControlPeriodCostGroup.PeriodFrom == _projControlPeriod.PeriodFrom     &&
                          projControlPeriodCostGroup.Version    == _projControlPeriod.Version).ActuelCostAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcContract</Name>
				<Source><![CDATA[
    protected void calcContract(ProjControlPeriodTable _projControlPeriod)
    {
        ProjTable               projTable, projTableLoc;
        ProjOnAccTrans          projOnAccTrans;
        ProjOnAccTransSale      projOnAccTransSale;
        ProjOnAccTransSale      projOnAccTransSaleUpdate;
        ProjInvoiceOnAcc        projInvoiceOnAcc;
        ProjInvoiceOnAccDetail  projInvoiceOnAccDetail;
        ProjTrans               projTrans;
        ProjTrans               projTransInvoice;
        PSAContractLineItems contractLine;
        boolean                 invoiceFound;
        AmountMST               estTotal;
        LedgerRecId             ledger;
        Set recIdInvOnAccDetail = new Set (Types::Int64);

        _projControlPeriod.ActualContract           = 0;
        _projControlPeriod.ctcContract              = 0;
        _projControlPeriod.InternalContractTotal    = 0;
        estTotal = 0;
        boolean isFixedPriceBillingMethod = false;

        if(contractLineBasedRevRecFeature && ProjWIPTable::find(_projControlPeriod.ProjId).IsContractLineUsed)
        {
            while select projRevRecContractLine
        where projRevRecContractLine.RevenueRecognitionId == _projControlPeriod.ProjId
        join projOnAccTrans
        where projOnAccTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum
            join projOnAccTransSale
                where projOnAccTransSale.TransId == projOnAccTrans.TransId &&
                      ProjOnAccTransSale.TransStatus != ProjTransStatus::Adjusted
            join contractLine
                where contractLine.ContractLineNum == projOnAccTrans.PSAContractLineNum
                && contractLine.BillingMethod ==  ProjContractBillingMethod::FixedPrice
            {
                projTrans = ProjTrans::newProjOnAccTransSale(projOnAccTrans, projOnAccTransSale);
                invoiceFound = false;

                if (projContractCurrencyForRevRecParmEnabled)
                {
                  ledger = Ledger::primaryLedger(CompanyInfo::findDataArea(_projControlPeriod.company()).RecId);
                }

                ProjInvoiceJour projInvoiceJour;
                CurrencyCode currencyCode = ProjInvoiceTable::find(PSAContractLineItems::find(projOnAccTrans.PSAContractLineNum).ProjInvoiceProjId).CurrencyId;

                while select projInvoiceOnAccDetail
            where projInvoiceOnAccDetail.SaleRefRecId == projOnAccTransSale.RecId
                join projInvoiceOnAcc
                    where projInvoiceOnAcc.RecId == projInvoiceOnAccDetail.InvoiceRefRecId &&
                        projInvoiceOnAcc.InvoiceDate <= this.parmPeriodTo()
                join ExchRate, ExchrateSecondary, Triangulation from projInvoiceJour
                    where projInvoiceJour.ProjInvoiceId == projInvoiceOnAcc.ProjInvoiceId &&
                        projInvoiceJour.InvoiceDate == projInvoiceOnAcc.InvoiceDate
                {
                    projTransInvoice = ProjTrans::newProjInvoiceOnAccSale(projInvoiceOnAcc, projInvoiceOnAccDetail);
                    
                    if (projContractCurrencyForRevRecParmEnabled)
                    {
                        AmountMST turnoverAmount = CurrencyExchangeHelper::curAmount(projTransInvoice.transTurnoverMST(),
                                                                                 currencyCode,
                                                                                 projInvoiceOnAcc.InvoiceDate,
                                                                                 Currency::noYes2UnknownNoYes(projInvoiceJour.Triangulation),
                                                                                 projInvoiceJour.ExchRate,
                                                                                 projInvoiceJour.ExchrateSecondary);
                        _projControlPeriod.ActualContract += turnoverAmount;
                        estTotal += turnoverAmount;
                    }
                    else
                    {
                        _projControlPeriod.ActualContract += projTransInvoice.transTurnoverMST();
                        estTotal += projTransInvoice.transTurnoverMST();
                    }

                    invoiceFound = true;
                    if (!projInvoiceOnAccDetail.wipPeriod)
                    {
                        recIdInvOnAccDetail.add(projInvoiceOnAccDetail.RecId);
                    }
                }

                while select projInvoiceOnAccDetail
            where projInvoiceOnAccDetail.SaleRefRecId == projOnAccTransSale.RecId
                join projInvoiceOnAcc
                    where projInvoiceOnAcc.RecId == projInvoiceOnAccDetail.InvoiceRefRecId &&
                        projInvoiceOnAcc.InvoiceDate > this.parmPeriodTo()
                join ExchRate, ExchrateSecondary, Triangulation from projInvoiceJour
                    where projInvoiceJour.ProjInvoiceId == projInvoiceOnAcc.ProjInvoiceId &&
                        projInvoiceJour.InvoiceDate == projInvoiceOnAcc.InvoiceDate
                {
                    projTransInvoice = ProjTrans::newProjInvoiceOnAccSale(projInvoiceOnAcc, projInvoiceOnAccDetail);

                    if (projContractCurrencyForRevRecParmEnabled)
                    {
                        estTotal += CurrencyExchangeHelper::curAmount(projTransInvoice.transTurnoverMST(),
                                                                  currencyCode,
                                                                  projInvoiceOnAcc.InvoiceDate,
                                                                  Currency::noYes2UnknownNoYes(projInvoiceJour.Triangulation),
                                                                  projInvoiceJour.ExchRate,
                                                                  projInvoiceJour.ExchrateSecondary);
                    }
                    else
                    {
                        estTotal += projTransInvoice.transTurnoverMST();
                    }
                }
                PSAContractLineItemsSetup contractLineAssoc;
                select firstonly contractLineAssoc
                    where contractLineAssoc.ContractLineNum == contractLine.ContractLineNum;

                estTotal += this.populateContractValueContractLine(projOnAccTransSale, projTrans, _projControlPeriod, ProjTable::find(contractLineAssoc.ProjId), ledger);

                if (invoiceFound)
                {
                    projOnAccTransSaleUpdate = ProjOnAccTransSale::find(projOnAccTransSale.RecId,true);
                    if (projOnAccTransSaleUpdate.TransStatus == ProjTransStatus::Invoiced)
                    {
                        projOnAccTransSaleUpdate.TransStatus = ProjTransStatus::Estimated;
                    }
                    projOnAccTransSaleUpdate.update();
                }
            }
            _projControlPeriod.ContractValue = estTotal;
            _projControlPeriod.ctcContract = estTotal - _projControlPeriod.ActualContract - _projControlPeriod.InternalContractTotal;
        }
        else
        {
            while select projTable
        where projTable.wipProject == _projControlPeriod.ProjId
        join projOnAccTrans
        where projOnAccTrans.ProjID == projTable.ProjId
            join projOnAccTransSale
                where projOnAccTransSale.TransId == projOnAccTrans.TransId &&
                      ProjOnAccTransSale.TransStatus != ProjTransStatus::Adjusted
            {
                projTrans = ProjTrans::newProjOnAccTransSale(projOnAccTrans, projOnAccTransSale);
                invoiceFound = false;

                if (projContractCurrencyForRevRecParmEnabled)
                {
                    isFixedPriceBillingMethod = projTable.Type == ProjType::FixedPrice ||
                                            (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled() &&
                                            ProjMultipleContractLinesForProjectFeatureHelper::existContractLineForBillingMethod(projTable.ProjId, projTable.ProjInvoiceProjId, ProjContractBillingMethod::FixedPrice));
                    ledger = Ledger::primaryLedger(CompanyInfo::findDataArea(_projControlPeriod.company()).RecId);
                }

                ProjInvoiceJour projInvoiceJour;
                boolean shouldEnterContractCalculation = ProjCalcOnAccAmountInAccCurFlight::instance().isEnabled()
                    || !ProjControlDeductionCalculationFlight::instance().isEnabled() || ProjRevRecHelper::isNonDeductionOrNotAdjustedDeductionInvoicedWithMilestone(projOnAccTransSale);

                while select projInvoiceOnAccDetail
            where projInvoiceOnAccDetail.SaleRefRecId == projOnAccTransSale.RecId
                join projInvoiceOnAcc
                    where projInvoiceOnAcc.RecId == projInvoiceOnAccDetail.InvoiceRefRecId &&
                        projInvoiceOnAcc.InvoiceDate <= this.parmPeriodTo()
                join ExchRate, ExchrateSecondary, Triangulation, CurrencyId from projInvoiceJour
                    where projInvoiceJour.ProjInvoiceId == projInvoiceOnAcc.ProjInvoiceId &&
                        projInvoiceJour.InvoiceDate == projInvoiceOnAcc.InvoiceDate
                {
                    projTransInvoice = ProjTrans::newProjInvoiceOnAccSale(projInvoiceOnAcc, projInvoiceOnAccDetail);

                    if (shouldEnterContractCalculation)
                    {
                        if (ProjContractCurrencyConversionFlight::instance().isEnabled()
                            && projContractCurrencyForRevRecParmEnabled                         
                            && isFixedPriceBillingMethod
                            && projTable.contractCurrCode()
                            && projInvoiceJour.CurrencyId != projTable.contractCurrCode())
                        {
                            AmountMST turnoverAmount = CurrencyExchangeHelper::curAmount(projTransInvoice.transTurnoverMST(),
                                                                                    projTable.contractCurrCode(),
                                                                                    projInvoiceOnAcc.InvoiceDate,
                                                                                    Currency::noYes2UnknownNoYes(projInvoiceJour.Triangulation),
                                                                                    0,
                                                                                    projInvoiceJour.ExchrateSecondary);
                            _projControlPeriod.ActualContract += turnoverAmount;
                            estTotal += turnoverAmount;
                        }
                        else if (projContractCurrencyForRevRecParmEnabled && isFixedPriceBillingMethod)
                        {
                            AmountMST turnoverAmount = CurrencyExchangeHelper::curAmount(projTransInvoice.transTurnoverMST(),
                                                                                    projTable.contractCurrCode(),
                                                                                    projInvoiceOnAcc.InvoiceDate,
                                                                                    Currency::noYes2UnknownNoYes(projInvoiceJour.Triangulation),
                                                                                    projInvoiceJour.ExchRate,
                                                                                    projInvoiceJour.ExchrateSecondary);
                            _projControlPeriod.ActualContract += turnoverAmount;
                            estTotal += turnoverAmount;
                        }
                        else
                        {
                            _projControlPeriod.ActualContract += projTransInvoice.transTurnoverMST();
                            estTotal += projTransInvoice.transTurnoverMST();
                        }
                    }

                    invoiceFound = true;
                    if (!projInvoiceOnAccDetail.wipPeriod)
                    {
                        recIdInvOnAccDetail.add(projInvoiceOnAccDetail.RecId);
                    }
                }

                while select projInvoiceOnAccDetail
            where projInvoiceOnAccDetail.SaleRefRecId == projOnAccTransSale.RecId
                join projInvoiceOnAcc
                    where projInvoiceOnAcc.RecId == projInvoiceOnAccDetail.InvoiceRefRecId &&
                        projInvoiceOnAcc.InvoiceDate > this.parmPeriodTo()
                join ExchRate, ExchrateSecondary, Triangulation, CurrencyId from projInvoiceJour
                    where projInvoiceJour.ProjInvoiceId == projInvoiceOnAcc.ProjInvoiceId &&
                        projInvoiceJour.InvoiceDate == projInvoiceOnAcc.InvoiceDate
                {
                    projTransInvoice = ProjTrans::newProjInvoiceOnAccSale(projInvoiceOnAcc, projInvoiceOnAccDetail);

                    if (shouldEnterContractCalculation)
                    {
                        if (ProjContractCurrencyConversionFlight::instance().isEnabled()
                            && projContractCurrencyForRevRecParmEnabled                       
                            && isFixedPriceBillingMethod
                            && projTable.contractCurrCode()
                            && projInvoiceJour.CurrencyId != projTable.contractCurrCode())
                        {
                            estTotal += CurrencyExchangeHelper::curAmount(projTransInvoice.transTurnoverMST(),
                                                                        projTable.contractCurrCode(),
                                                                        projInvoiceOnAcc.InvoiceDate,
                                                                        Currency::noYes2UnknownNoYes(projInvoiceJour.Triangulation),
                                                                        0,
                                                                        projInvoiceJour.ExchrateSecondary);                      
                        }
                        else if (projContractCurrencyForRevRecParmEnabled && isFixedPriceBillingMethod)
                        {
                            estTotal += CurrencyExchangeHelper::curAmount(projTransInvoice.transTurnoverMST(),
                                                                        projTable.contractCurrCode(),
                                                                        projInvoiceOnAcc.InvoiceDate,
                                                                        Currency::noYes2UnknownNoYes(projInvoiceJour.Triangulation),
                                                                        projInvoiceJour.ExchRate,
                                                                        projInvoiceJour.ExchrateSecondary);
                        }
                        else
                        {
                            estTotal += projTransInvoice.transTurnoverMST();
                        }
                    }
                }

                estTotal += this.populateContractValueV2(projOnAccTransSale, projTrans, _projControlPeriod, projTable, isFixedPriceBillingMethod, ledger);

                if (invoiceFound)
                {
                    projOnAccTransSaleUpdate = ProjOnAccTransSale::find(projOnAccTransSale.RecId,true);
                    if (projOnAccTransSaleUpdate.TransStatus == ProjTransStatus::Invoiced)
                    {
                        projOnAccTransSaleUpdate.TransStatus = ProjTransStatus::Estimated;
                    }
                    projOnAccTransSaleUpdate.update();
                }
            }
            _projControlPeriod.ContractValue = estTotal;
            _projControlPeriod.ctcContract = estTotal - _projControlPeriod.ActualContract - _projControlPeriod.InternalContractTotal;
        }

        SetEnumerator iterator = recIdInvOnAccDetail.getEnumerator();
        RecId recId;
        while (iterator.moveNext())
        {
            recId = iterator.current();
            select forupdate  projInvoiceOnAccDetail where projInvoiceOnAccDetail.RecId == recId;
            ttsbegin;
            projInvoiceOnAccDetail.wipPeriod = this.parmPeriodTo();
            projInvoiceOnAccDetail.update();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateContractValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Populates the values to calculate the contract.
    /// </summary>
    /// <param name = "_projOnAccTransSale">
    ///     <c>ProjOnAccTransSale</c> buffer representing on account transaction.
    /// </param>
    /// <param name = "_projTrans">
    ///     An instance of <c>ProjTrans</c> class.
    /// </param>
    /// <param name = "_projControlPeriod">
    ///     <c>ProjControlPeriodTable</c> buffer to be updated.
    /// </param>
    /// <returns>
    ///     Total estimated contract value
    /// </returns>
    protected AmountMST populateContractValue(ProjOnAccTransSale _projOnAccTransSale,ProjTrans _projTrans, ProjControlPeriodTable _projControlPeriod)
    {
        return this.populateContractValueV2(_projOnAccTransSale, _projTrans, _projControlPeriod, null, false, 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateContractValueV2</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Populates the values to calculate the contract.
    /// </summary>
    /// <param name = "_projOnAccTransSale">
    ///     A <c>ProjOnAccTransSale</c> buffer representing on account transaction.
    /// </param>
    /// <param name = "_projTrans">
    ///     An instance of <c>ProjTrans</c> class.
    /// </param>
    /// <param name = "_projControlPeriod">
    ///     A <c>ProjControlPeriodTable</c> buffer to be updated.
    /// </param>
    /// <param name = "_projTable">
    ///     A <c>ProjTable</c> record.
    /// </param>
    /// <param name = "_isFixedPriceBillingMethod">
    ///     A boolean value.
    /// </param>
    /// <param name = "_ledger">
    ///    The record ID of a <c>Ledger</c> record.
    /// </param>
    /// <returns>
    ///     Total estimated contract value.
    /// </returns>
    protected AmountMST populateContractValueV2(ProjOnAccTransSale _projOnAccTransSale,ProjTrans _projTrans,
        ProjControlPeriodTable _projControlPeriod, ProjTable _projTable, boolean _isFixedPriceBillingMethod, LedgerRecId _ledger)
    {
        ProjOnAccTransSale projOnAccTransSaleUpdate;

        AmountMST total = 0;

        switch (_projOnAccTransSale.TransStatus)
        {
            case ProjTransStatus::Registered, ProjTransStatus::InvoiceProposal:

                if (projContractCurrencyForRevRecParmEnabled && _isFixedPriceBillingMethod)
                {
                    CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(_ledger, _projOnAccTransSale.LedgerTransdate);
                    total += currencyExchangeHelper.calculateAccountingToTransaction(_projTable.contractCurrCode(), _projTrans.transTurnoverMST(), true);;
                }
                else
                {
                    total += _projTrans.transTurnoverMST();
                }

                if (_projOnAccTransSale.LedgerTransdate <= this.parmPeriodTo())
                {
                    // Is this an internal funding source
                    if (!ProjFundingSource::isExternalFunding(_projTrans.fundingSource()))
                    {
                        if (projContractCurrencyForRevRecParmEnabled && _isFixedPriceBillingMethod)
                        {
                            CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(_ledger, _projOnAccTransSale.LedgerTransdate);
                            _projControlPeriod.InternalContractTotal += currencyExchangeHelper.calculateAccountingToTransaction(_projTable.contractCurrCode(), _projTrans.transTurnoverMST(), true);
                        }
                        else
                        {
                            _projControlPeriod.InternalContractTotal += _projTrans.transTurnoverMST();
                        }
                    }
                }
                break;

            case ProjTransStatus::Invoiced, ProjTransStatus::MarkedCreditNote, ProjTransStatus::CreditnoteProposal:

                ProjOnAccTrans projOnAccTransLocal = _projOnAccTransSale.projOnAccTrans();

                // No invoice exist for beginning balance so invoiceFound will be false
                if (projOnAccTransLocal.TransactionOrigin == ProjOrigin::BeginningBalance)
                {
                    if (projContractCurrencyForRevRecParmEnabled && _isFixedPriceBillingMethod)
                    {
                        CurrencyCode contractCurrency = _projTable.contractCurrCode();

                        if (projOnAccTransLocal.CurrencyId != contractCurrency)
                        {
                            AmountMST amountMST = CurrencyExchangeHelper::amountCur2MST(_projOnAccTransSale.Amount,
                                                                                        projOnAccTransLocal.CurrencyId,
                                                                                        _projTable.exchRateSales(_projOnAccTransSale.LedgerTransdate, projOnAccTransLocal.CurrencyId));

                            CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(_ledger, _projOnAccTransSale.LedgerTransdate);
                            currencyExchangeHelper.parmExchangeRate1(_projTable.exchRateSales());
                            total += currencyExchangeHelper.calculateAccountingToTransaction(contractCurrency, amountMST, true);
                        }
                        else
                        {
                            total += _projOnAccTransSale.Amount;
                        }
                    }
                    else
                    {
                        // The contract value is calculated correctly by fetching the sales amount in total.
                        if (projOnAccTransLocal.CurrencyId != Ledger::accountingCurrency())
                        {
                            total += CurrencyExchangeHelper::mstAmount(_projOnAccTransSale.Amount,
                                                                        projOnAccTransLocal.CurrencyId,
                                                                        _projOnAccTransSale.LedgerTransdate,
                                                                        UnknownNoYes::Unknown,
                                                                        _projTable.exchRateSales(_projOnAccTransSale.LedgerTransdate, projOnAccTransLocal.CurrencyId),
                                                                        0,
                                                                        true);
                        }
                        else
                        {
                            total += _projOnAccTransSale.Amount;
                        }
                    }

                    if (_projOnAccTransSale.LedgerTransdate <= this.parmPeriodTo())
                    {
                        if (this.parmBeginningBalance() == NoYes::Yes)
                        {
                            projOnAccTransSaleUpdate                = ProjOnAccTransSale::find(_projOnAccTransSale.RecId,true);
                            if (projOnAccTransSaleUpdate.TransStatus == ProjTransStatus::Invoiced)
                            {
                                projOnAccTransSaleUpdate.TransStatus = ProjTransStatus::Estimated;
                                projOnAccTransSaleUpdate.wipPeriod = this.parmPeriodTo();
                                projOnAccTransSaleUpdate.update();
                            }

                            if (projContractCurrencyForRevRecParmEnabled && _isFixedPriceBillingMethod)
                            {
                                CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(_ledger, _projOnAccTransSale.LedgerTransdate);
                                _projControlPeriod.ActualContract += currencyExchangeHelper.calculateAccountingToTransaction(_projTable.contractCurrCode(), _projTrans.ledgerSalesAmountMST(), true);
                            }
                            else
                            {
                                _projControlPeriod.ActualContract += _projTrans.ledgerSalesAmountMST();
                            }
                        }
                    }
                }

                break;

            case ProjTransStatus::Estimated, ProjTransStatus::Eliminated :

                if (_projOnAccTransSale.projOnAccTrans().TransactionOrigin == ProjOrigin::BeginningBalance)
                {
                    if (projContractCurrencyForRevRecParmEnabled && _isFixedPriceBillingMethod)
                    {
                        CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(_ledger, _projOnAccTransSale.LedgerTransdate);
                        total += currencyExchangeHelper.calculateAccountingToTransaction(_projTable.contractCurrCode(), _projTrans.ledgerSalesAmountMST(), true);
                        _projControlPeriod.ActualContract += currencyExchangeHelper.calculateAccountingToTransaction(_projTable.contractCurrCode(), _projTrans.ledgerSalesAmountMST(), true);
                    }
                    else
                    {
                        total += _projTrans.ledgerSalesAmountMST();
                        _projControlPeriod.ActualContract   += _projTrans.ledgerSalesAmountMST();
                    }
                }

                break;
        }

        return total;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateContractValueContractLine</Name>
				<Source><![CDATA[
    protected AmountMST populateContractValueContractLine(ProjOnAccTransSale _projOnAccTransSale, ProjTrans _projTrans,
        ProjControlPeriodTable _projControlPeriod, Projtable _projtable, LedgerRecId _ledger)
    {
        ProjOnAccTransSale projOnAccTransSaleUpdate;

        AmountMST total = 0;

        switch (_projOnAccTransSale.TransStatus)
        {
            case ProjTransStatus::Registered, ProjTransStatus::InvoiceProposal:

                if (projContractCurrencyForRevRecParmEnabled)
                {
                    CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(_ledger, _projOnAccTransSale.LedgerTransdate);
                    total += currencyExchangeHelper.calculateAccountingToTransaction(_projtable.contractCurrCode(), _projTrans.transTurnoverMST(), true);;
                }
                else
                {
                    total += _projTrans.transTurnoverMST();
                }

                if (_projOnAccTransSale.LedgerTransdate <= this.parmPeriodTo())
                {
                    // Is this an internal funding source
                    if (!ProjFundingSource::isExternalFunding(_projTrans.fundingSource()))
                    {
                        if (projContractCurrencyForRevRecParmEnabled)
                        {
                            CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(_ledger, _projOnAccTransSale.LedgerTransdate);
                            _projControlPeriod.InternalContractTotal += currencyExchangeHelper.calculateAccountingToTransaction(_projtable.contractCurrCode(), _projTrans.transTurnoverMST(), true);
                        }
                        else
                        {
                            _projControlPeriod.InternalContractTotal += _projTrans.transTurnoverMST();
                        }
                    }
                }
                break;

            case ProjTransStatus::Invoiced, ProjTransStatus::MarkedCreditNote, ProjTransStatus::CreditnoteProposal:

                ProjOnAccTrans projOnAccTransLocal = _projOnAccTransSale.projOnAccTrans();

                // No invoice exist for beginning balance so invoiceFound will be false
                if (projOnAccTransLocal.TransactionOrigin == ProjOrigin::BeginningBalance)
                {
                    if (projContractCurrencyForRevRecParmEnabled)
                    {
                        // The contract value is calculated correctly by fetching the sales amount in total.
                        if (projOnAccTransLocal.CurrencyId != _projtable.contractCurrCode())
                        {
                            AmountMST amountMST = CurrencyExchangeHelper::amountCur2MST(_projOnAccTransSale.Amount,
                                                                                        projOnAccTransLocal.CurrencyId,
                                                                                        _projTable.exchRateSales(_projOnAccTransSale.LedgerTransdate, projOnAccTransLocal.CurrencyId));

                            CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(_ledger, _projOnAccTransSale.LedgerTransdate);
                            currencyExchangeHelper.parmExchangeRate1(_projTable.exchRateSales());
                            total += currencyExchangeHelper.calculateAccountingToTransaction(_projtable.contractCurrCode(), amountMST, true);
                        }
                        else
                        {
                            total += _projOnAccTransSale.Amount;
                        }
                    }
                    else
                    {
                        // The contract value is calculated correctly by fetching the sales amount in total.
                        if (projOnAccTransLocal.CurrencyId != Ledger::accountingCurrency())
                        {
                            total += CurrencyExchangeHelper::mstAmount(_projOnAccTransSale.Amount,
                                                                        projOnAccTransLocal.CurrencyId,
                                                                        _projOnAccTransSale.LedgerTransdate,
                                                                        UnknownNoYes::Unknown,
                                                                        _projTable.exchRateSales(_projOnAccTransSale.LedgerTransdate, projOnAccTransLocal.CurrencyId),
                                                                        0,
                                                                        true);
                        }
                        else
                        {
                            total += _projOnAccTransSale.Amount;
                        }
                    }

                    if (_projOnAccTransSale.LedgerTransdate <= this.parmPeriodTo())
                    {
                        if (this.parmBeginningBalance() == NoYes::Yes)
                        {
                            projOnAccTransSaleUpdate                = ProjOnAccTransSale::find(_projOnAccTransSale.RecId,true);
                            if (projOnAccTransSaleUpdate.TransStatus == ProjTransStatus::Invoiced)
                            {
                                projOnAccTransSaleUpdate.TransStatus = ProjTransStatus::Estimated;
                                projOnAccTransSaleUpdate.wipPeriod = this.parmPeriodTo();
                                projOnAccTransSaleUpdate.update();
                            }

                            if (projContractCurrencyForRevRecParmEnabled)
                            {
                                CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(_ledger, _projOnAccTransSale.LedgerTransdate);
                                _projControlPeriod.ActualContract += currencyExchangeHelper.calculateAccountingToTransaction(_projTable.contractCurrCode(), _projTrans.ledgerSalesAmountMST(), true);
                            }
                            else
                            {
                                _projControlPeriod.ActualContract += _projTrans.ledgerSalesAmountMST();
                            }
                        }
                    }
                }

                break;

            case ProjTransStatus::Estimated, ProjTransStatus::Eliminated :

                if (_projOnAccTransSale.projOnAccTrans().TransactionOrigin == ProjOrigin::BeginningBalance)
                {
                    if (projContractCurrencyForRevRecParmEnabled)
                    {
                        CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(_ledger, _projOnAccTransSale.LedgerTransdate);
                        total += currencyExchangeHelper.calculateAccountingToTransaction(_projTable.contractCurrCode(), _projTrans.ledgerSalesAmountMST(), true);
                        _projControlPeriod.ActualContract += currencyExchangeHelper.calculateAccountingToTransaction(_projTable.contractCurrCode(), _projTrans.ledgerSalesAmountMST(), true);
                    }
                    else
                    {
                        total += _projTrans.ledgerSalesAmountMST();
                        _projControlPeriod.ActualContract   += _projTrans.ledgerSalesAmountMST();
                    }
                }

                break;
        }

        return total;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTotals</Name>
				<Source><![CDATA[
    protected void calcTotals(
        ProjControlPeriodTableColumn    _projControlPeriodTableColumn,
        ProjEstimateColumn              _estimateColumn)
    {
        _projControlPeriodTableColumn.plCostTotalCost             = this.plCostTotalCost(_projControlPeriodTableColumn);
        _projControlPeriodTableColumn.plAccRevTotalAccRev         = this.plAccRevTotalAccRev(_projControlPeriodTableColumn);
        _projControlPeriodTableColumn.wipSalespriceTotal          = this.wipSalespriceTotal(_projControlPeriodTableColumn,_estimateColumn);

        _projControlPeriodTableColumn.wipCostpriceTotal           = this.wipCostpriceTotal(_projControlPeriodTableColumn,_estimateColumn);
        _projControlPeriodTableColumn.wipTotalGrossWIP            = this.wipTotalGrossWIP(_projControlPeriodTableColumn,_estimateColumn);
        _projControlPeriodTableColumn.wipTotalNetWIP              = this.wipTotalNetWIP(_projControlPeriodTableColumn,_estimateColumn);

        _projControlPeriodTableColumn.plTotalRevenue              = this.plTotalRevenue(_projControlPeriodTableColumn);
        _projControlPeriodTableColumn.plTotalValueAddedAmount     = this.plTotalValueAddedAmount(_projControlPeriodTableColumn);
        _projControlPeriodTableColumn.plTotalGrossMargin          = this.plTotalGrossMargin(_projControlPeriodTableColumn);

        _projControlPeriodTableColumn.ConsumCostHourRate          = this.consumHourCostHourRate(_projControlPeriodTableColumn);

        _projControlPeriodTableColumn.GeneralHourRevenue          = this.generalHourRevenue(_projControlPeriodTableColumn);
        _projControlPeriodTableColumn.GeneralHourValuaddedHourRate
                                                                  = this.generalHourValuaddedHourRate(_projControlPeriodTableColumn);
        _projControlPeriodTableColumn.GeneralHourCostHourRate     = this.generalHourCostHourRate(_projControlPeriodTableColumn);
        _projControlPeriodTableColumn.GeneralHourGrossMarginHourRate
                                                                  = this.generalHourGrossMarginHourRate(_projControlPeriodTableColumn);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcWIPAcc</Name>
				<Source><![CDATA[
    protected void calcWIPAcc(ProjControlPeriodTable _projControlPeriod)
    {
        ProjControlPeriodTable   localProjControlPeriod;

        select sum(wipAccruedTurnover), sum(wipAccruedTurnoverProfit), sum(wipAccruedTurnoverProd), sum(wipCost)
            from  localProjControlPeriod
            where localProjControlPeriod.ProjId          == _projControlPeriod.ProjId        &&
                  localProjControlPeriod.PeriodStatus    == ProjControlPeriodStatus::Posted  &&
                  localProjControlPeriod.PeriodFrom      <= _projControlPeriod.PeriodFrom;

        wipAccruedTurnoverProfitAcc = localProjControlPeriod.wipAccruedTurnoverProfit;
        wipAccruedTurnoverProdAcc   = localProjControlPeriod.wipAccruedTurnoverProd;
        wipAccruedTurnoverAcc       = localProjControlPeriod.wipAccruedTurnover;
        wipCostAcc                  = localProjControlPeriod.wipCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>capital</Name>
				<Source><![CDATA[
    protected AmountMST capital(
        ProjCostType    _costType)
    {
        ProjControlPeriodCostGroup  projControlPeriodCostGroup;
        ProjControlCostGroup        projControlCostGroup;

        select sum(ActuelCostAmountCapitalized) from projControlPeriodCostGroup
            where projControlPeriodCostGroup.ProjId     == projId           &&
                  projControlPeriodCostGroup.ControlId  == controlId        &&
                  projControlPeriodCostGroup.PeriodFrom == periodFrom       &&
                  projControlPeriodCostGroup.Version    == controlVersion
                  exists join projControlCostGroup
                    where projControlCostGroup.CostGroupId  == projControlPeriodCostGroup.CostGroupId   &&
                          projControlCostGroup.CostType     == _costType;

        return projControlPeriodCostGroup.ActuelCostAmountCapitalized;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCalculateHoursQtyCapitalized</Name>
				<Source><![CDATA[
    protected boolean checkCalculateHoursQtyCapitalized()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>consum</Name>
				<Source><![CDATA[
    protected AmountMST consum(
        ProjCostType    _costType)
    {
        ProjControlPeriodCostGroup  projControlPeriodCostGroup;
        ProjControlCostGroup        projControlCostGroup;

        select sum(ActuelCostAmount) from projControlPeriodCostGroup
            where projControlPeriodCostGroup.ProjId     == projId           &&
                  projControlPeriodCostGroup.ControlId  == controlId        &&
                  projControlPeriodCostGroup.PeriodFrom == periodFrom       &&
                  projControlPeriodCostGroup.Version    == controlVersion
                  exists join projControlCostGroup
                    where projControlCostGroup.CostGroupId  == projControlPeriodCostGroup.CostGroupId   &&
                          projControlCostGroup.CostType     == _costType;

        return projControlPeriodCostGroup.ActuelCostAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>consumExpNotCapital</Name>
				<Source><![CDATA[
    protected ProjNotCapitalized consumExpNotCapital(
        ProjControlPeriodTableColumn  _projControlPeriodTableColumn)
    {
        return _projControlPeriodTableColumn.ConsumExpConsum-_projControlPeriodTableColumn.ConsumExpCapital;
    }

]]></Source>
			</Method>
			<Method>
				<Name>consumHourCostHourRate</Name>
				<Source><![CDATA[
    protected ProjCostHourRate consumHourCostHourRate(
        ProjControlPeriodTableColumn  _projControlPeriodTableColumn)
    {
        if (_projControlPeriodTableColumn.GeneralHoursQty)
        {
            return _projControlPeriodTableColumn.ConsumHourConsum/_projControlPeriodTableColumn.GeneralHoursQty;
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>consumHourNotCapital</Name>
				<Source><![CDATA[
    protected ProjNotCapitalized consumHourNotCapital(
        ProjControlPeriodTableColumn  _projControlPeriodTableColumn)
    {
        return _projControlPeriodTableColumn.ConsumHourConsum-_projControlPeriodTableColumn.ConsumHourCapital;
    }

]]></Source>
			</Method>
			<Method>
				<Name>consumItemNotCapital</Name>
				<Source><![CDATA[
    protected ProjNotCapitalized consumItemNotCapital(
        ProjControlPeriodTableColumn  _projControlPeriodTableColumn)
    {
        return _projControlPeriodTableColumn.ConsumItemConsum-
               _projControlPeriodTableColumn.ConsumItemCapital;
    }

]]></Source>
			</Method>
			<Method>
				<Name>consumTotalCapital</Name>
				<Source><![CDATA[
    ProjCapitalized consumTotalCapital(
        ProjControlPeriodTableColumn  _projControlPeriodTableColumn)
    {
        return _projControlPeriodTableColumn.ConsumHourCapital+
               _projControlPeriodTableColumn.ConsumExpCapital+
               _projControlPeriodTableColumn.ConsumItemCapital;
    }

]]></Source>
			</Method>
			<Method>
				<Name>consumTotalConsum</Name>
				<Source><![CDATA[
    protected ProjConsumption consumTotalConsum(
        ProjControlPeriodTableColumn  _projControlPeriodTableColumn)
    {
        return _projControlPeriodTableColumn.ConsumHourConsum+
               _projControlPeriodTableColumn.ConsumExpConsum+
               _projControlPeriodTableColumn.ConsumItemConsum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>consumTotalNotCapital</Name>
				<Source><![CDATA[
    protected ProjNotCapitalized consumTotalNotCapital(
        ProjControlPeriodTableColumn  _projControlPeriodTableColumn)
    {
        return _projControlPeriodTableColumn.ConsumTotalConsum-
               _projControlPeriodTableColumn.ConsumTotalCapital;
    }

]]></Source>
			</Method>
			<Method>
				<Name>contractSum</Name>
				<Source><![CDATA[
    protected AmountMST contractSum(ProjControlPeriodTable _projControlPeriod)
    {
        contractSum = (_projControlPeriod.ActualContract + _projControlPeriod.InternalContractTotal + _projControlPeriod.ctcContract);

        return contractSum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costItemCost</Name>
				<Source><![CDATA[
    protected AmountMST costItemCost(ProjControlPeriodTable _projControlPeriod)
    {
        ProjControlPeriodCostGroup  projControlPeriodCostGroup;
        ProjControlCostGroup        projControlCostGroup;

        select sum(ActuelCostAmount), sum(ctcCostAmount) from projControlPeriodCostGroup
            group by ProjId
            where projControlPeriodCostGroup.ProjId     == _projControlPeriod.ProjId         &&
                  projControlPeriodCostGroup.ControlId  == _projControlPeriod.ControlId      &&
                  projControlPeriodCostGroup.Version    == _projControlPeriod.Version        &&
                  projControlPeriodCostGroup.PeriodFrom == _projControlPeriod.PeriodFrom
            exists join projControlCostGroup
            where projControlCostGroup.ControlId        == projControlPeriodCostGroup.ControlId     &&
                  projControlCostGroup.CostGroupId      == projControlPeriodCostGroup.CostGroupId   &&
                 (projControlCostGroup.CostType         == ProjCostType::Cost                       ||
                  projControlCostGroup.CostType         == ProjCostType::Item);

        return (projControlPeriodCostGroup.ActuelCostAmount + projControlPeriodCostGroup.ctcCostAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>ctcCostAmount</Name>
				<Source><![CDATA[
    protected AmountMST ctcCostAmount(ProjControlPeriodTable _projControlPeriod)
    {
        return (select sum(ctcCostAmount) from projControlPeriodCostGroup
                    where projControlPeriodCostGroup.ProjId     == _projControlPeriod.ProjId      &&
                          projControlPeriodCostGroup.ControlId  == _projControlPeriod.ControlId   &&
                          projControlPeriodCostGroup.PeriodFrom == _projControlPeriod.PeriodFrom  &&
                          projControlPeriodCostGroup.Version    == _projControlPeriod.Version).ctcCostAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>eliminationAmountTurnover</Name>
				<Source><![CDATA[
    abstract protected AmountMST eliminationAmountTurnover(ProjControlPeriodTable _projControlPeriod)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>factor</Name>
				<Source><![CDATA[
    protected Factor factor(ProjControlPeriodTable _projControlPeriod)
    {
        Factor f = 0;

        if ((_projControlPeriod.ActualCostAmount  + _projControlPeriod.ctcCostAmount))
        {
            f = (_projControlPeriod.ActualContract    + _projControlPeriod.ctcContract) / (_projControlPeriod.ActualCostAmount  + _projControlPeriod.ctcCostAmount);
        }

        return f;
    }

]]></Source>
			</Method>
			<Method>
				<Name>forseeablesLossesAmount</Name>
				<Source><![CDATA[
    protected AmountMST forseeablesLossesAmount(
        ProjControlPeriodTable   _projControlPeriod)
    {
        return -projControlColumnAccEstimatePrev.plCostAccCost-_projControlPeriod.contributionMargen();
    }

]]></Source>
			</Method>
			<Method>
				<Name>generalHourCostHourRate</Name>
				<Source><![CDATA[
    protected ProjCostHourRate generalHourCostHourRate(
        ProjControlPeriodTableColumn  _projControlPeriodTableColumn)
    {
        if (_projControlPeriodTableColumn.plHourQty())
        {
            return _projControlPeriodTableColumn.plCostHour/_projControlPeriodTableColumn.plHourQty();
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generalHourGrossMarginHourRate</Name>
				<Source><![CDATA[
    ProjGrossMarginHourRate generalHourGrossMarginHourRate(
        ProjControlPeriodTableColumn  _projControlPeriodTableColumn)
    {
        if (_projControlPeriodTableColumn.plHourQty())
        {
            return _projControlPeriodTableColumn.plTotalGrossMargin/_projControlPeriodTableColumn.plHourQty();
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generalHourRevenue</Name>
				<Source><![CDATA[
    protected ProjRevenueHourRate generalHourRevenue(
        ProjControlPeriodTableColumn  _projControlPeriodTableColumn)
    {
        if (_projControlPeriodTableColumn.plHourQty())
        {
            return _projControlPeriodTableColumn.plTotalRevenue/_projControlPeriodTableColumn.plHourQty();
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generalHoursQty</Name>
				<Source><![CDATA[
    protected ProjQtyEmpl generalHoursQty(
        ProjControlPeriodTable  _controlPeriodTable,
        ProjEstimateColumn      _estimateColumn,
        ProjQty                 _qtyEstimate    = 0
        )
    {
        ProjControlPeriodCostGroup  projControlPeriodCostGroup;
        ProjControlCostGroup        projControlCostGroup;

        switch (_estimateColumn)
        {
            case ProjEstimateColumn::Estimate:
                return _qtyEstimate;

            case ProjEstimateColumn::Accumulated:
                select sum(ActuelCostUnit) from projControlPeriodCostGroup
                    where projControlPeriodCostGroup.ProjId     == projId           &&
                          projControlPeriodCostGroup.ControlId  == controlId        &&
                          projControlPeriodCostGroup.PeriodFrom == periodFrom       &&
                          projControlPeriodCostGroup.Version    == controlVersion
                    exists join projControlCostGroup
                      where projControlCostGroup.CostGroupId  == projControlPeriodCostGroup.CostGroupId   &&
                            projControlCostGroup.CostType     == ProjCostType::Hour;

                return projControlPeriodCostGroup.ActuelCostUnit;

            case ProjEstimateColumn::Total:
                return this.generalHoursQtyTotal();
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generalHoursQtyCapitalized</Name>
				<Source><![CDATA[
    protected ProjQtyEmpl generalHoursQtyCapitalized(
        ProjEstimateColumn              _estimateColumn
        )
    {
        ProjEmplTrans           projEmplTrans;
        ProjEmplTransCost       projEmplTransCost;
        ProjLineProperty        projLineProperty;
        ProjTable               projTable;

        switch (_estimateColumn)
        {
            case ProjEstimateColumn::Estimate:
                return projControlPeriodTableColumnAccEstimate.GeneralHourQtyCapitalized-
                       projControlColumnAccEstimatePrev.GeneralHourQtyCapitalized;

            case ProjEstimateColumn::Accumulated:
                if(contractLineBasedRevRecFeature && isContractLineUsed)
                {
                    select sum(Qty) from projEmplTrans
                    exists join projEmplTransCost
                    where projEmplTransCost.TransId == projEmplTrans.TransId &&
                          projEmplTransCost.wipPeriod &&
                          projEmplTransCost.wipPeriod <= periodTo &&
                          projEmplTransCost.TransStatus == ProjTransStatus::Estimated
                    exists join projRevRecContractLine
                    where projRevRecContractLine.ContractLineNum == projEmplTrans.PSAContractLineNum
                        &&  projRevRecContractLine.RevenueRecognitionId == projId
                    exists join projLineProperty
                    where projLineProperty.LinePropertyId == projEmplTrans.LinePropertyId &&
                          projLineProperty.ToBeCapitalize == NoYes::Yes;
                }
                else
                {
                select sum(Qty) from projEmplTrans
                    exists join projEmplTransCost
                    where projEmplTransCost.TransId == projEmplTrans.TransId &&
                          projEmplTransCost.wipPeriod &&
                          projEmplTransCost.wipPeriod <= periodTo &&
                          projEmplTransCost.TransStatus == ProjTransStatus::Estimated
                    exists join projTable
                    where projTable.ProjId == projEmplTrans.ProjId &&
                          projTable.wipProject == projId
                    exists join projLineProperty
                    where projLineProperty.LinePropertyId == projEmplTrans.LinePropertyId &&
                          projLineProperty.ToBeCapitalize == NoYes::Yes;
                }

                return projEmplTrans.Qty;

            case ProjEstimateColumn::Total:
                return 0;
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generalHoursQtyTotal</Name>
				<Source><![CDATA[
    protected ProjQtyEmpl generalHoursQtyTotal()
    {
        ProjControlPeriodCostGroup  projControlPeriodCostGroup;
        ProjControlCostGroup        projControlCostGroup;

        select sum(ActuelCostUnit), sum(ctcCostUnit) from projControlPeriodCostGroup
            where projControlPeriodCostGroup.ProjId     == projId           &&
                  projControlPeriodCostGroup.ControlId  == controlId        &&
                  projControlPeriodCostGroup.PeriodFrom == periodFrom       &&
                  projControlPeriodCostGroup.Version    == controlVersion
            exists join projControlCostGroup
            where projControlCostGroup.CostGroupId  == projControlPeriodCostGroup.CostGroupId   &&
                  projControlCostGroup.CostType     == ProjCostType::Hour;

        return projControlPeriodCostGroup.ActuelCostUnit + projControlPeriodCostGroup.ctcCostUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generalHourValuaddedHourRate</Name>
				<Source><![CDATA[
    protected ProjValueAddedHourRate generalHourValuaddedHourRate(
        ProjControlPeriodTableColumn  _projControlPeriodTableColumn)
    {
        if (_projControlPeriodTableColumn.plHourQty())
        {
            return _projControlPeriodTableColumn.plTotalValueAddedAmount/_projControlPeriodTableColumn.plHourQty();
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccruedCost</Name>
				<Source><![CDATA[
    public AmountMST parmAccruedCost(AmountMST _projAccruedCost = projAccruedCost)
    {
        projAccruedCost = _projAccruedCost;

        return projAccruedCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBeginningBalance</Name>
				<Source><![CDATA[
    public ProjBeginningBalance parmBeginningBalance(ProjBeginningBalance _beginningBalance = beginningBalance)
    {
        beginningBalance = _beginningBalance;

        return beginningBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCalledFromCode</Name>
				<Source><![CDATA[
    public boolean parmCalledFromCode(boolean _calledFromCode = calledFromCode)
    {
        calledFromCode = _calledFromCode;

        return calledFromCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmControlId</Name>
				<Source><![CDATA[
    public ProjControlId parmControlId(ProjControlId _controlId = controlId)
    {
        controlId  = _controlId;

        return  controlId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmControlVersion</Name>
				<Source><![CDATA[
    public ProjControlVersion parmControlVersion(ProjControlVersion _version = controlVersion)
    {
        controlVersion  = _version;

        return  controlVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEliminate</Name>
				<Source><![CDATA[
    public NoYes parmEliminate(NoYes _parmEliminate = parmEliminate)
    {
        parmEliminate   = _parmEliminate;

        return parmEliminate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMaxCapital</Name>
				<Source><![CDATA[
    public AmountMST parmMaxCapital(AmountMST _maxCapital = maxCapital)
    {
        maxCapital = _maxCapital;

        return maxCapital;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPeriodFrom</Name>
				<Source><![CDATA[
    public ProjPeriodFrom  parmPeriodFrom(ProjPeriodFrom _periodFrom = periodFrom)
    {
        periodFrom  = _periodFrom;

        return  periodFrom;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPeriodTo</Name>
				<Source><![CDATA[
    public ProjPeriodTo  parmPeriodTo(ProjPeriodTo _periodTo = periodTo)
    {
        periodTo  = _periodTo;

        return  periodTo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsContractLineUsed</Name>
				<Source><![CDATA[
    public boolean  parmIsContractLineUsed(boolean _isContractLineUsed = isContractLineUsed)
    {
        isContractLineUsed  = _isContractLineUsed;

        return  isContractLineUsed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProfit</Name>
				<Source><![CDATA[
    public ProjProfit parmProfit(ProjProfit _projProfit = projProfit)
    {
        projProfit = _projProfit;

        return projProfit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjId</Name>
				<Source><![CDATA[
    public ProjId parmProjId(ProjId _projId = projId)
    {
        projId  = _projId;

        return  projId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesValue</Name>
				<Source><![CDATA[
    public ProjSalesValue parmSalesValue(ProjSalesValue _projSalesValue = projSalesValue)
    {
        projSalesValue = _projSalesValue;

        return projSalesValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBillingMethod</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public ProjContractBillingMethod parmBillingMethod(ProjContractBillingMethod _billingMethod = billingMethod)
    {
        billingMethod = _billingMethod;

        return billingMethod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodInit</Name>
				<Source><![CDATA[
    protected void periodInit()
    {
        projControlPeriodTableColumnEstimate       =
            ProjControlPeriodTableColumn::find(projId,controlId,periodFrom,controlVersion,ProjEstimateColumn::Estimate,true);

        projControlPeriodTableColumnAccEstimate    =
            ProjControlPeriodTableColumn::find(projId,controlId,periodFrom,controlVersion,ProjEstimateColumn::Accumulated,true);

        projControlPeriodTableColumnTotal    =
            ProjControlPeriodTableColumn::find(projId,controlId,periodFrom,controlVersion,ProjEstimateColumn::Total,true);

        if (! projControlPeriodTableColumnEstimate)
        {
            projControlPeriodTableColumnEstimate.ProjId         = projId;
            projControlPeriodTableColumnEstimate.ControlId      = controlId;
            projControlPeriodTableColumnEstimate.PeriodFrom     = periodFrom;
            projControlPeriodTableColumnEstimate.Version        = controlVersion;
            projControlPeriodTableColumnEstimate.EstimateColumn = ProjEstimateColumn::Estimate;
            projControlPeriodTableColumnEstimate.insert();
        }
        else
        {
            this.setPeriodZero(projControlPeriodTableColumnEstimate);
        }

        if (! projControlPeriodTableColumnAccEstimate)
        {
            projControlPeriodTableColumnAccEstimate.ProjId              = projId;
            projControlPeriodTableColumnAccEstimate.ControlId           = controlId;
            projControlPeriodTableColumnAccEstimate.PeriodFrom          = periodFrom;
            projControlPeriodTableColumnAccEstimate.Version             = controlVersion;
            projControlPeriodTableColumnAccEstimate.EstimateColumn      = ProjEstimateColumn::Accumulated;
            projControlPeriodTableColumnAccEstimate.insert();
        }
        else
        {
            this.setPeriodZero(projControlPeriodTableColumnAccEstimate);
        }

        if (!projControlPeriodTableColumnTotal)
        {
            projControlPeriodTableColumnTotal.ProjId                = projId;
            projControlPeriodTableColumnTotal.ControlId             = controlId;
            projControlPeriodTableColumnTotal.PeriodFrom            = periodFrom;
            projControlPeriodTableColumnTotal.Version               = controlVersion;
            projControlPeriodTableColumnTotal.EstimateColumn        = ProjEstimateColumn::Total;
            projControlPeriodTableColumnTotal.insert();
        }
        else
        {
            this.setPeriodZero(projControlPeriodTableColumnTotal);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setProjControlPeriodTableFields</Name>
				<Source><![CDATA[
    protected void setProjControlPeriodTableFields(ProjControlPeriodTable _projControlPeriod)
    {
        _projControlPeriod.ActualCostAmount = this.actualCostAmount(_projControlPeriod);
        _projControlPeriod.ctcCostAmount = _projControlPeriod.displayCTCCostAmount();
        this.calcContract(_projControlPeriod);

        ProjRevRecInstrumentationLogger logger;
        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            logger = ProjRevRecInstrumentationLogger::createLogger(classStr(ProjControlCalc));
        }
        else
        {
            logger = ProjRevRecInstrumentationLogger::createLogger(classStr(ProjControlCalc));
        }
        

        using (var activityContext = logger.revRecActivity().calculatePercentageContext())
        {
            logger.logInformation(strFmt("Compute estimate percentage for ProjectId: %1", projId));
            _projControlPeriod.CompletePctCalculated = _projControlPeriod.completePct();
        }
      
        if (_projControlPeriod.AutoManualCalculation == ProjAutoManual::Auto)
        {
            _projControlPeriod.CompletePct = _projControlPeriod.CompletePctCalculated;
        }

        _projControlPeriod.Factor = this.factor(_projControlPeriod);
        _projControlPeriod.ValueAdded = this.valueAdded(_projControlPeriod);
        _projControlPeriod.Recalculated = NoYes::No;

        this.calcWIPAcc(_projControlPeriod);

        if (this.parmCalledFromCode())
        {
            _projControlPeriod.wipAccruedTurnover = this.parmSalesValue();
            _projControlPeriod.wipAccruedTurnoverProfit = this.parmProfit();
        }
        else
        {
            _projControlPeriod.wipAccruedTurnover = this.wipAccruedTurnover(_projControlPeriod);
            _projControlPeriod.wipAccruedTurnoverProfit = this.wipAccruedTurnoverProfit(_projControlPeriod);
        }

        _projControlPeriod.wipAccruedTurnoverProd = this.wipAccruedTurnoverProd(_projControlPeriod);
        _projControlPeriod.wipCost = this.wipCost(_projControlPeriod);

        if (this.parmCalledFromCode() && this.parmMaxCapital())
        {
            _projControlPeriod.TotalMaxCapital = this.parmMaxCapital();
        }

        this.periodUpdateColumn(_projControlPeriod);

        if (this.provisionForseeablesLosses(_projControlPeriod) && ! this.parmCalledFromCode())
        {
            _projControlPeriod.wipAccruedTurnover = projControlPeriodTableColumnEstimate.wipSalesPriceSalesValue;
            _projControlPeriod.wipAccruedTurnoverProd = projControlPeriodTableColumnEstimate.wipSalespriceProduction;
            _projControlPeriod.wipAccruedTurnoverProfit = projControlPeriodTableColumnEstimate.wipSalesPriceProfit;
        }

        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            using (var activityContext = logger.revRecActivity().postContractLineBasedRevRec())
            {
                logger.logInformation(strFmt(@"ProjControlCalc::%11 done for
                ProjectId: %1, ctcAmount: %2, contractValue: %3
                projContractCurrencyForRevRecParmEnabled: %4
                controlId : %5,
                wipAccruedTurnover: %6
                wipAccruedTurnoverProd: %7
                wipAccruedTurnoverProfit: %8
                wipCost: %9
                completepct: %10",
                projId,
                _projControlPeriod.CTCContract,
                _projControlPeriod.ContractValue,
                _projControlPeriod.ContractValue,
                _projControlPeriod.ControlId,
                _projControlPeriod.WIPAccruedTurnover,
                _projControlPeriod.WIPAccruedTurnoverProd,
                _projControlPeriod.WIPAccruedTurnoverProfit,
                _projControlPeriod.WIPCost,
                _projControlPeriod.CompletePct,
                ProjRevRecInstrumentationActivities::ContractLineBasedRevRec));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodUpdate</Name>
				<Source><![CDATA[
    protected void periodUpdate()
    {
        projControlColumnEstimatePrev = ProjControlPeriodTableColumn::findPrev(projId, controlId, periodFrom, ProjEstimateColumn::Estimate, this.parmEliminate());
        projControlColumnAccEstimatePrev = ProjControlPeriodTableColumn::findPrev(projId, controlId, periodFrom, ProjEstimateColumn::Accumulated, this.parmEliminate());
        projControlColumnTotalEstimatePrev = ProjControlPeriodTableColumn::findPrev(projId, controlId, periodFrom, ProjEstimateColumn::Total, this.parmEliminate());
        
        ProjControlPeriodTable projControlPeriod = ProjControlPeriodTable::find(projId, controlId, periodFrom, controlVersion, true);
        if (projControlPeriod && projControlPeriod.PeriodStatus == ProjControlPeriodStatus::Created)
        {
            this.setProjControlPeriodTableFields(projControlPeriod);
            projControlPeriod.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipPeriodUpdateColumnEstimate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the project control period estimate calculation must be skipped.
    /// </summary>
    /// <param name = "_projControlPeriod">
    /// A <c>ProjControlPeriodTable</c> record.
    /// </param>
    /// <returns>
    /// true if the calculation must be skipped; otherwise, false.
    /// </returns>
    protected boolean skipPeriodUpdateColumnEstimate(ProjControlPeriodTable _projControlPeriod)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipPeriodUpdateForseeablesLosses</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the project control period forseeable losses calculation must be skipped.
    /// </summary>
    /// <param name = "_projControlPeriod">
    /// A <c>ProjControlPeriodTable</c> record.
    /// </param>
    /// <returns>
    /// true if the calculation must be skipped; otherwise, false.
    /// </returns>
    protected boolean skipPeriodUpdateForseeablesLosses(ProjControlPeriodTable _projControlPeriod)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodUpdateColumn</Name>
				<Source><![CDATA[
    protected void periodUpdateColumn(
        ProjControlPeriodTable  _projControlPeriod)
    {
        this.periodInit();

        this.periodUpdateColumnAccEstimate(_projControlPeriod);

        if (!this.skipPeriodUpdateColumnEstimate(_projControlPeriod))
        {
            this.periodUpdateColumnEstimate(_projControlPeriod);
        }
        this.periodUpdateColumnTotal(_projControlPeriod);

        if (!this.skipPeriodUpdateForseeablesLosses(_projControlPeriod))
        {
            this.periodUpdateForseeablesLosses(_projControlPeriod);
        }

        projControlPeriodTableColumnEstimate.update();
        projControlPeriodTableColumnAccEstimate.update();
        projControlPeriodTableColumnTotal.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodUpdateColumnAccEstimate</Name>
				<Source><![CDATA[
    protected void periodUpdateColumnAccEstimate(
        ProjControlPeriodTable  _projControlPeriodTable)
    {
        projControlPeriodTableColumnAccEstimate.GeneralHoursQty             = this.generalHoursQty(_projControlPeriodTable,ProjEstimateColumn::Accumulated);

        if (this.checkCalculateHoursQtyCapitalized())
        {
            projControlPeriodTableColumnAccEstimate.GeneralHourQtyCapitalized  = this.generalHoursQtyCapitalized(ProjEstimateColumn::Accumulated);
        }

        projControlPeriodTableColumnAccEstimate.ConsumExpCapital        = this.capital(ProjCostType::Cost);
        projControlPeriodTableColumnAccEstimate.ConsumExpConsum         = this.consum(ProjCostType::Cost);
        projControlPeriodTableColumnAccEstimate.ConsumExpNotCapital     = this.consumExpNotCapital(projControlPeriodTableColumnAccEstimate);

        projControlPeriodTableColumnAccEstimate.ConsumHourCapital       = this.capital(ProjCostType::Hour);
        projControlPeriodTableColumnAccEstimate.ConsumHourConsum        = this.consum(ProjCostType::Hour);
        projControlPeriodTableColumnAccEstimate.ConsumHourNotCapital    = this.consumHourNotCapital(projControlPeriodTableColumnAccEstimate);

        projControlPeriodTableColumnAccEstimate.ConsumItemCapital       = this.capital(ProjCostType::Item);
        projControlPeriodTableColumnAccEstimate.ConsumItemConsum        = this.consum(ProjCostType::Item);
        projControlPeriodTableColumnAccEstimate.ConsumItemNotCapital    = this.consumItemNotCapital(projControlPeriodTableColumnAccEstimate);

        projControlPeriodTableColumnAccEstimate.ConsumTotalCapital     = this.consumTotalCapital(projControlPeriodTableColumnAccEstimate);
        projControlPeriodTableColumnAccEstimate.ConsumTotalConsum      = this.consumTotalConsum(projControlPeriodTableColumnAccEstimate);
        projControlPeriodTableColumnAccEstimate.ConsumTotalNotCapital  = this.consumTotalNotCapital(projControlPeriodTableColumnAccEstimate);

        projControlPeriodTableColumnAccEstimate.ConsumCostHourRate     = this.consumHourCostHourRate(projControlPeriodTableColumnAccEstimate);

        projControlPeriodTableColumnAccEstimate.wipInvoiceOnAcc         = this.wipInvoiceOnAcc(_projControlPeriodTable);

        projControlPeriodTableColumnAccEstimate.plInvRevInvoiceOnAcc    = this.plInvRevInvoiceOnAcc(_projControlPeriodTable,ProjEstimateColumn::Accumulated);

        projControlPeriodTableColumnAccEstimate.plAccRevAccOnAcc        = this.plAccRevAccOnAcc(_projControlPeriodTable,ProjEstimateColumn::Accumulated);
        projControlPeriodTableColumnAccEstimate.plCostAccCost           = this.plCostAccCost(_projControlPeriodTable,ProjEstimateColumn::Accumulated);
        projControlPeriodTableColumnAccEstimate.plCostHour              = this.plCostHour(projControlPeriodTableColumnAccEstimate,ProjEstimateColumn::Accumulated);

        ProjMatchingPrincip matchingPrinciple = ProjRevRecHelper::getMatchingPrincipleForProjControlPeriodTable(_projControlPeriodTable);

        if (matchingPrinciple == ProjMatchingPrincip::SalesValue)
        {
            projControlPeriodTableColumnAccEstimate.plAccRevSalesValue  = this.plAccRevSalesValue(_projControlPeriodTable,
                                                                                                  ProjEstimateColumn::Accumulated,
                                                                                                  projControlPeriodTableColumnAccEstimate);
        }
        else
        {
            projControlPeriodTableColumnAccEstimate.plAccRevProduction  = this.plAccRevProduction(_projControlPeriodTable,ProjEstimateColumn::Accumulated);
            projControlPeriodTableColumnAccEstimate.plAccRevProfit      = this.plAccRevProfit(_projControlPeriodTable,
                                                                                              ProjEstimateColumn::Accumulated,
                                                                                              projControlPeriodTableColumnAccEstimate);
        }

        if (matchingPrinciple == ProjMatchingPrincip::SalesValue)
        {
            projControlPeriodTableColumnAccEstimate.wipSalesPriceSalesValue =
                this.wipSalespriceSalesValue(projControlPeriodTableColumnAccEstimate,ProjEstimateColumn::Accumulated);
        }
        else
        {
            projControlPeriodTableColumnAccEstimate.wipSalespriceProduction =
                this.wipSalespriceProduction(projControlPeriodTableColumnAccEstimate,ProjEstimateColumn::Accumulated);

            projControlPeriodTableColumnAccEstimate.wipSalesPriceProfit     =
                this.wipSalespriceProfit(projControlPeriodTableColumnAccEstimate,ProjEstimateColumn::Accumulated);
        }

        projControlPeriodTableColumnAccEstimate.plAccRevTotalAccRev     = this.plAccRevTotalAccRev(projControlPeriodTableColumnAccEstimate);

        projControlPeriodTableColumnAccEstimate.wipSalespriceTotal      = this.wipSalespriceTotal(projControlPeriodTableColumnAccEstimate,ProjEstimateColumn::Accumulated);

        projControlPeriodTableColumnAccEstimate.wipCostpriceAccruedCost = this.wipCostpriceAccruedCost(projControlPeriodTableColumnAccEstimate,ProjEstimateColumn::Accumulated);
        projControlPeriodTableColumnAccEstimate.wipCostpriceHour        = this.wipCostpriceHour(projControlPeriodTableColumnAccEstimate,ProjEstimateColumn::Accumulated);
        projControlPeriodTableColumnAccEstimate.wipCostpriceExp         = this.wipCostpriceExp(projControlPeriodTableColumnAccEstimate,ProjEstimateColumn::Accumulated);
        projControlPeriodTableColumnAccEstimate.wipCostpriceItem        = this.wipCostpriceItem(projControlPeriodTableColumnAccEstimate,ProjEstimateColumn::Accumulated);
        projControlPeriodTableColumnAccEstimate.wipCostpriceTotal       = this.wipCostpriceTotal(projControlPeriodTableColumnAccEstimate,ProjEstimateColumn::Accumulated);
        projControlPeriodTableColumnAccEstimate.wipTotalGrossWIP        = this.wipTotalGrossWIP(projControlPeriodTableColumnAccEstimate,ProjEstimateColumn::Accumulated);
        projControlPeriodTableColumnAccEstimate.wipTotalNetWIP          = this.wipTotalNetWIP(projControlPeriodTableColumnAccEstimate,ProjEstimateColumn::Accumulated);

        projControlPeriodTableColumnAccEstimate.plCostHour             = this.plCostHour(projControlPeriodTableColumnAccEstimate,ProjEstimateColumn::Accumulated);
        projControlPeriodTableColumnAccEstimate.plCostExpenses         = this.plCostExpenses(projControlPeriodTableColumnAccEstimate,ProjEstimateColumn::Accumulated);
        projControlPeriodTableColumnAccEstimate.plCostItem             = this.plCostItem(projControlPeriodTableColumnAccEstimate,ProjEstimateColumn::Accumulated);
        projControlPeriodTableColumnAccEstimate.plCostTotalCost        = this.plCostTotalCost(projControlPeriodTableColumnAccEstimate);

        projControlPeriodTableColumnAccEstimate.plTotalRevenue         = this.plTotalRevenue(projControlPeriodTableColumnAccEstimate);
        projControlPeriodTableColumnAccEstimate.plTotalValueAddedAmount= this.plTotalValueAddedAmount(projControlPeriodTableColumnAccEstimate);
        projControlPeriodTableColumnAccEstimate.plTotalGrossMargin     = this.plTotalGrossMargin(projControlPeriodTableColumnAccEstimate);

        projControlPeriodTableColumnAccEstimate.GeneralHourRevenue     = this.generalHourRevenue(projControlPeriodTableColumnAccEstimate);
        projControlPeriodTableColumnAccEstimate.GeneralHourValuaddedHourRate
                                                                    = this.generalHourValuaddedHourRate(projControlPeriodTableColumnAccEstimate);
        projControlPeriodTableColumnAccEstimate.GeneralHourCostHourRate= this.generalHourCostHourRate(projControlPeriodTableColumnAccEstimate);
        projControlPeriodTableColumnAccEstimate.GeneralHourGrossMarginHourRate
                                                                    = this.generalHourGrossMarginHourRate(projControlPeriodTableColumnAccEstimate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodUpdateColumnAccEstimateSecond</Name>
				<Source><![CDATA[
    protected void periodUpdateColumnAccEstimateSecond(
        ProjControlPeriodTable  _projControlPeriodTable)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodUpdateColumnEstimate</Name>
				<Source><![CDATA[
    protected void periodUpdateColumnEstimate(
        ProjControlPeriodTable  _projControlPeriodTable)
    {
        ProjQty     generalHours;

        generalHours    = projControlPeriodTableColumnAccEstimate.GeneralHoursQty - projControlColumnAccEstimatePrev.GeneralHoursQty;

        projControlPeriodTableColumnEstimate.GeneralHoursQty            = this.generalHoursQty(_projControlPeriodTable,ProjEstimateColumn::Estimate,generalHours);
        if (this.checkCalculateHoursQtyCapitalized())
        {
            projControlPeriodTableColumnEstimate.GeneralHourQtyCapitalized  = this.generalHoursQtyCapitalized(ProjEstimateColumn::Estimate);
        }

        projControlPeriodTableColumnEstimate.ConsumExpCapital       = projControlPeriodTableColumnAccEstimate.ConsumExpCapital -
                                                                      projControlColumnAccEstimatePrev.ConsumExpCapital;
        projControlPeriodTableColumnEstimate.ConsumExpConsum        = projControlPeriodTableColumnAccEstimate.ConsumExpConsum -
                                                                      projControlColumnAccEstimatePrev.ConsumExpConsum;
        projControlPeriodTableColumnEstimate.ConsumExpNotCapital    = this.consumExpNotCapital(projControlPeriodTableColumnEstimate);

        projControlPeriodTableColumnEstimate.ConsumHourCapital      = projControlPeriodTableColumnAccEstimate.ConsumHourCapital -
                                                                      projControlColumnAccEstimatePrev.ConsumHourCapital;
        projControlPeriodTableColumnEstimate.ConsumHourConsum       = projControlPeriodTableColumnAccEstimate.ConsumHourConsum -
                                                                      projControlColumnAccEstimatePrev.ConsumHourConsum;
        projControlPeriodTableColumnEstimate.ConsumHourNotCapital   = this.consumHourNotCapital(projControlPeriodTableColumnEstimate);

        projControlPeriodTableColumnEstimate.ConsumItemCapital      = projControlPeriodTableColumnAccEstimate.ConsumItemCapital -
                                                                      projControlColumnAccEstimatePrev.ConsumItemCapital;
        projControlPeriodTableColumnEstimate.ConsumItemConsum       = projControlPeriodTableColumnAccEstimate.ConsumItemConsum -
                                                                      projControlColumnAccEstimatePrev.ConsumItemConsum;
        projControlPeriodTableColumnEstimate.ConsumItemNotCapital   = this.consumItemNotCapital(projControlPeriodTableColumnEstimate);

        projControlPeriodTableColumnEstimate.ConsumTotalCapital     = this.consumTotalCapital(projControlPeriodTableColumnEstimate);
        projControlPeriodTableColumnEstimate.ConsumTotalConsum      = this.consumTotalConsum(projControlPeriodTableColumnEstimate);
        projControlPeriodTableColumnEstimate.ConsumTotalNotCapital  = this.consumTotalNotCapital(projControlPeriodTableColumnEstimate);

        projControlPeriodTableColumnEstimate.ConsumCostHourRate     = this.consumHourCostHourRate(projControlPeriodTableColumnEstimate);

        projControlPeriodTableColumnEstimate.wipInvoiceOnAcc        = this.wipInvoiceOnAcc(_projControlPeriodTable) -
                                                                      projControlColumnAccEstimatePrev.wipInvoiceOnAcc;

        projControlPeriodTableColumnEstimate.plInvRevInvoiceOnAcc   = projControlPeriodTableColumnAccEstimate.plInvRevInvoiceOnAcc -
                                                                      projControlColumnAccEstimatePrev.plInvRevInvoiceOnAcc;

        projControlPeriodTableColumnEstimate.plAccRevAccOnAcc       = this.plAccRevAccOnAcc(_projControlPeriodTable,ProjEstimateColumn::Estimate) -
                                                                      projControlColumnAccEstimatePrev.plAccRevAccOnAcc;

        if (this.parmCalledFromCode())
        {
            if (ProjRevRecHelper::getMatchingPrincipleForProjControlPeriodTable(_projControlPeriodTable) == ProjMatchingPrincip::SalesValue)
            {
                projControlPeriodTableColumnEstimate.plAccRevSalesValue      = this.parmSalesValue();
                projControlPeriodTableColumnEstimate.wipSalesPriceSalesValue = this.parmSalesValue();
            }
            else
            {
                projControlPeriodTableColumnEstimate.plAccRevProfit         = this.parmProfit();
                projControlPeriodTableColumnEstimate.wipSalesPriceProfit    = this.parmProfit();
            }
        }
        else
        {
            if (ProjRevRecHelper::getMatchingPrincipleForProjControlPeriodTable(_projControlPeriodTable) == ProjMatchingPrincip::SalesValue)
            {
                projControlPeriodTableColumnEstimate.plAccRevSalesValue      = this.plAccRevSalesValue(_projControlPeriodTable,ProjEstimateColumn::Estimate);
                projControlPeriodTableColumnEstimate.wipSalesPriceSalesValue = this.wipSalespriceSalesValue(projControlPeriodTableColumnEstimate,ProjEstimateColumn::Estimate);
            }
            else
            {
                projControlPeriodTableColumnEstimate.plAccRevProfit         = this.plAccRevProfit(_projControlPeriodTable,ProjEstimateColumn::Estimate);
                projControlPeriodTableColumnEstimate.wipSalesPriceProfit    = this.wipSalespriceProfit(projControlPeriodTableColumnEstimate,ProjEstimateColumn::Estimate);
            }
        }

        if (this.parmCalledFromCode())
        {
            projControlPeriodTableColumnEstimate.plCostAccCost           = this.parmAccruedCost();
            projControlPeriodTableColumnEstimate.wipCostpriceAccruedCost = this.wipCostpriceAccruedCost(projControlPeriodTableColumnEstimate,ProjEstimateColumn::Estimate);
        }
        else if (this.provisionForseeablesLosses(_projControlPeriodTable))
        {
            projControlPeriodTableColumnEstimate.plCostAccCost           = this.plCostAccCost(_projControlPeriodTable,ProjEstimateColumn::Estimate);
            projControlPeriodTableColumnEstimate.wipCostpriceAccruedCost = this.wipCostpriceAccruedCost(projControlPeriodTableColumnEstimate,ProjEstimateColumn::Estimate);
        }

        projControlPeriodTableColumnEstimate.plAccRevProduction      = this.plAccRevProduction(_projControlPeriodTable,ProjEstimateColumn::Estimate);
        projControlPeriodTableColumnEstimate.wipSalespriceProduction = this.wipSalespriceProduction(projControlPeriodTableColumnEstimate,ProjEstimateColumn::Estimate);

        projControlPeriodTableColumnEstimate.plAccRevTotalAccRev     = this.plAccRevTotalAccRev(projControlPeriodTableColumnEstimate);

        projControlPeriodTableColumnEstimate.wipSalespriceTotal      = this.wipSalespriceTotal(projControlPeriodTableColumnEstimate,ProjEstimateColumn::Estimate);
        projControlPeriodTableColumnEstimate.wipCostpriceHour        = this.wipCostpriceHour(projControlPeriodTableColumnEstimate,ProjEstimateColumn::Estimate);
        projControlPeriodTableColumnEstimate.wipCostpriceExp         = this.wipCostpriceExp(projControlPeriodTableColumnEstimate,ProjEstimateColumn::Estimate);
        projControlPeriodTableColumnEstimate.wipCostpriceItem        = this.wipCostpriceItem(projControlPeriodTableColumnEstimate,ProjEstimateColumn::Estimate);

        projControlPeriodTableColumnEstimate.wipCostpriceTotal       = this.wipCostpriceTotal(projControlPeriodTableColumnEstimate,ProjEstimateColumn::Estimate);
        projControlPeriodTableColumnEstimate.wipTotalGrossWIP        = this.wipTotalGrossWIP(projControlPeriodTableColumnEstimate,ProjEstimateColumn::Estimate);
        projControlPeriodTableColumnEstimate.wipTotalNetWIP          = this.wipTotalNetWIP(projControlPeriodTableColumnEstimate,ProjEstimateColumn::Estimate);

        projControlPeriodTableColumnEstimate.plCostHour             = this.plCostHour(projControlPeriodTableColumnEstimate,ProjEstimateColumn::Estimate);
        projControlPeriodTableColumnEstimate.plCostExpenses         = this.plCostExpenses(projControlPeriodTableColumnEstimate,ProjEstimateColumn::Estimate);
        projControlPeriodTableColumnEstimate.plCostItem             = this.plCostItem(projControlPeriodTableColumnEstimate,ProjEstimateColumn::Estimate);
        projControlPeriodTableColumnEstimate.plCostTotalCost        = this.plCostTotalCost(projControlPeriodTableColumnEstimate);

        projControlPeriodTableColumnEstimate.plTotalRevenue         = this.plTotalRevenue(projControlPeriodTableColumnEstimate);
        projControlPeriodTableColumnEstimate.plTotalValueAddedAmount= this.plTotalValueAddedAmount(projControlPeriodTableColumnEstimate);
        projControlPeriodTableColumnEstimate.plTotalGrossMargin     = this.plTotalGrossMargin(projControlPeriodTableColumnEstimate);

        projControlPeriodTableColumnEstimate.GeneralHourRevenue     = this.generalHourRevenue(projControlPeriodTableColumnEstimate);
        projControlPeriodTableColumnEstimate.GeneralHourValuaddedHourRate
                                                                    = this.generalHourValuaddedHourRate(projControlPeriodTableColumnEstimate);
        projControlPeriodTableColumnEstimate.GeneralHourCostHourRate= this.generalHourCostHourRate(projControlPeriodTableColumnEstimate);
        projControlPeriodTableColumnEstimate.GeneralHourGrossMarginHourRate
                                                                    = this.generalHourGrossMarginHourRate(projControlPeriodTableColumnEstimate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodUpdateColumnEstimateSecond</Name>
				<Source><![CDATA[
    protected void periodUpdateColumnEstimateSecond(
        ProjControlPeriodTable  _projControlPeriodTable)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodUpdateColumnTotal</Name>
				<Source><![CDATA[
    protected void periodUpdateColumnTotal(
        ProjControlPeriodTable  _projControlPeriodTable)
    {
        projControlPeriodTableColumnTotal.GeneralHoursQty           = this.generalHoursQty(_projControlPeriodTable,ProjEstimateColumn::Total);

        projControlPeriodTableColumnTotal.GeneralHourQtyCapitalized = this.generalHoursQtyCapitalized(ProjEstimateColumn::Total);

        projControlPeriodTableColumnTotal.plInvRevInvoiceOnAcc      = this.plInvRevInvoiceOnAcc(_projControlPeriodTable,ProjEstimateColumn::Total);

        if (ProjRevRecHelper::getMatchingPrincipleForProjControlPeriodTable(_projControlPeriodTable) == ProjMatchingPrincip::SalesValue)
        {
            projControlPeriodTableColumnTotal.plAccRevSalesValue    = this.plAccRevSalesValue(_projControlPeriodTable,ProjEstimateColumn::Total);
        }
        else
        {
            projControlPeriodTableColumnTotal.plAccRevProduction    = this.plAccRevProduction(_projControlPeriodTable,ProjEstimateColumn::Total);
            projControlPeriodTableColumnTotal.plAccRevProfit        = this.plAccRevProfit(_projControlPeriodTable,ProjEstimateColumn::Total);
        }
        projControlPeriodTableColumnTotal.plAccRevAccOnAcc          = this.plAccRevAccOnAcc(_projControlPeriodTable,ProjEstimateColumn::Total);

        projControlPeriodTableColumnTotal.plCostAccCost             = this.plCostAccCost(_projControlPeriodTable,ProjEstimateColumn::Total);
        projControlPeriodTableColumnTotal.plCostHour                = this.plCostHour(projControlPeriodTableColumnTotal,ProjEstimateColumn::Total);

        projControlPeriodTableColumnTotal.wipInvoiceOnAcc           = this.wipInvoiceOnAcc(_projControlPeriodTable);

        projControlPeriodTableColumnTotal.plAccRevTotalAccRev       = this.plAccRevTotalAccRev(projControlPeriodTableColumnTotal);
        projControlPeriodTableColumnTotal.plCostAccCost             = this.plCostAccCost(_projControlPeriodTable,ProjEstimateColumn::Total);
        projControlPeriodTableColumnTotal.plCostHour                = this.plCostHour(projControlPeriodTableColumnTotal,ProjEstimateColumn::Total);
        projControlPeriodTableColumnTotal.plCostExpenses            = this.plCostExpenses(projControlPeriodTableColumnTotal,ProjEstimateColumn::Total);
        projControlPeriodTableColumnTotal.plCostItem                = this.plCostItem(projControlPeriodTableColumnTotal,ProjEstimateColumn::Total);
        projControlPeriodTableColumnTotal.plCostTotalCost           = this.plCostTotalCost(projControlPeriodTableColumnTotal);

        projControlPeriodTableColumnTotal.plTotalRevenue            = this.plTotalRevenue(projControlPeriodTableColumnTotal);
        projControlPeriodTableColumnTotal.plTotalValueAddedAmount   = this.plTotalValueAddedAmount(projControlPeriodTableColumnTotal);
        projControlPeriodTableColumnTotal.plTotalGrossMargin        = this.plTotalGrossMargin(projControlPeriodTableColumnTotal);

        projControlPeriodTableColumnTotal.GeneralHourRevenue        = this.generalHourRevenue(projControlPeriodTableColumnTotal);
        projControlPeriodTableColumnTotal.GeneralHourValuaddedHourRate
                                                                    = this.generalHourValuaddedHourRate(projControlPeriodTableColumnTotal);
        projControlPeriodTableColumnTotal.GeneralHourCostHourRate   = this.generalHourCostHourRate(projControlPeriodTableColumnTotal);
        projControlPeriodTableColumnTotal.GeneralHourGrossMarginHourRate
                                                                    = this.generalHourGrossMarginHourRate(projControlPeriodTableColumnTotal);

        projControlPeriodTableColumnTotal.ConsumExpCapital          = this.capital(ProjCostType::Cost);
        projControlPeriodTableColumnTotal.ConsumExpConsum           = this.consum(ProjCostType::Cost);
        projControlPeriodTableColumnTotal.ConsumExpNotCapital       = this.consumExpNotCapital(projControlPeriodTableColumnTotal);

        projControlPeriodTableColumnTotal.ConsumHourCapital         = this.capital(ProjCostType::Hour);
        projControlPeriodTableColumnTotal.ConsumHourConsum          = this.consum(ProjCostType::Hour);
        projControlPeriodTableColumnTotal.ConsumHourNotCapital      = this.consumHourNotCapital(projControlPeriodTableColumnTotal);

        projControlPeriodTableColumnTotal.ConsumItemCapital         = this.capital(ProjCostType::Item);
        projControlPeriodTableColumnTotal.ConsumItemConsum          = this.consum(ProjCostType::Item);
        projControlPeriodTableColumnTotal.ConsumTotalNotCapital     = this.consumTotalNotCapital(projControlPeriodTableColumnTotal);
        projControlPeriodTableColumnTotal.ConsumCostHourRate        = this.consumHourCostHourRate(projControlPeriodTableColumnTotal);
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodUpdateForseeablesLosses</Name>
				<Source><![CDATA[
    protected void periodUpdateForseeablesLosses(
        ProjControlPeriodTable   _projControlPeriod
        )
    {
        accGrossMarginTemp      = this.forseeablesLossesAmount(_projControlPeriod);

        this.periodUpdateColumnAccEstimateSecond(_projControlPeriod);
        this.periodUpdateColumnEstimateSecond(_projControlPeriod);
    }

]]></Source>
			</Method>
			<Method>
				<Name>plAccRevAccOnAcc</Name>
				<Source><![CDATA[
    protected AmountMST plAccRevAccOnAcc(
        ProjControlPeriodTable  _projControlPeriodTable,
        ProjEstimateColumn      _estimateColumn)
    {
        if (_estimateColumn == ProjEstimateColumn::Total)
        {
            return - this.plInvRevInvoiceOnAcc(_projControlPeriodTable,_estimateColumn);
        }

        return -_projControlPeriodTable.ActualContract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>plAccRevProduction</Name>
				<Source><![CDATA[
    protected AmountMST plAccRevProduction(
        ProjControlPeriodTable _projControlPeriodTable,
        ProjEstimateColumn     _estimateColumn)
    {
        switch (_estimateColumn)
        {
            case ProjEstimateColumn::Total:
                return _projControlPeriodTable.totalCost();

            case ProjEstimateColumn::Accumulated:
                return _projControlPeriodTable.wipAccruedTurnoverProd+projControlColumnAccEstimatePrev.plAccRevProduction;

            case ProjEstimateColumn::Estimate:
                return _projControlPeriodTable.wipAccruedTurnoverProd;
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>plAccRevProfit</Name>
				<Source><![CDATA[
    protected AmountMST plAccRevProfit(
        ProjControlPeriodTable          _projControlPeriodTable,
        ProjEstimateColumn              _estimateColumn,
        ProjControlPeriodTableColumn    _projControlPeriodTableColumnAccEstimate = _projControlPeriodTableColumnAccEstimate)
    {
        switch (_estimateColumn)
        {
            case ProjEstimateColumn::Estimate:
                return _projControlPeriodTable.wipAccruedTurnoverProfit;

            case ProjEstimateColumn::Accumulated:
                return _projControlPeriodTable.wipAccruedTurnoverProfit+projControlColumnAccEstimatePrev.plAccRevProfit;

            case ProjEstimateColumn::Total:
                return _projControlPeriodTable.contributionMargen();
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>plAccRevSalesValue</Name>
				<Source><![CDATA[
    protected AmountMST plAccRevSalesValue(
        ProjControlPeriodTable          _projControlPeriodTable,
        ProjEstimateColumn              _estimateColumn,
        ProjControlPeriodTableColumn    _projControlPeriodTableColumnAccEstimate = _projControlPeriodTableColumnAccEstimate)
    {
        switch (_estimateColumn)
        {
            case ProjEstimateColumn::Total:
                return _projControlPeriodTable.totalContract();

            case ProjEstimateColumn::Accumulated:
                return _projControlPeriodTable.wipAccruedTurnover+projControlColumnAccEstimatePrev.plAccRevSalesValue;

            case ProjEstimateColumn::Estimate:
                return _projControlPeriodTable.wipAccruedTurnover;
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>plAccRevTotalAccRev</Name>
				<Source><![CDATA[
    protected ProjAccruedRevenueTotal plAccRevTotalAccRev(
        ProjControlPeriodTableColumn  _projControlPeriodTableColumn)
    {
        return _projControlPeriodTableColumn.plAccRevAccOnAcc+
               _projControlPeriodTableColumn.plAccRevProduction+
               _projControlPeriodTableColumn.plAccRevProfit+
               _projControlPeriodTableColumn.plAccRevSalesValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>plCostAccCost</Name>
				<Source><![CDATA[
    protected AmountMST plCostAccCost(
        ProjControlPeriodTable          _projControlPeriodTable,
        ProjEstimateColumn              _estimateColumn,
        ProjControlPeriodTableColumn    _projControlPeriodTableColumnAccEstimate = _projControlPeriodTableColumnAccEstimate)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>plCostExpenses</Name>
				<Source><![CDATA[
    protected ProjExpenses plCostExpenses(
        ProjControlPeriodTableColumn  _projControlPeriodTableColumnEstimate,
        ProjEstimateColumn            _estimateColumn)
    {
        if (_estimateColumn == ProjEstimateColumn::Total)
        {
            return this.plCostExpTotal();
        }

        return _projControlPeriodTableColumnEstimate.ConsumExpNotCapital;
    }

]]></Source>
			</Method>
			<Method>
				<Name>plCostExpTotal</Name>
				<Source><![CDATA[
    protected AmountMST plCostExpTotal()
    {
        ProjControlPeriodCostGroup  projControlPeriodCostGroup;
        ProjControlCostGroup        projControlCostGroup;

        select sum(ActuelCostAmount), sum(ctcCostAmount) from projControlPeriodCostGroup
            where projControlPeriodCostGroup.ProjId     == projId           &&
                  projControlPeriodCostGroup.ControlId  == controlId        &&
                  projControlPeriodCostGroup.PeriodFrom == periodFrom       &&
                  projControlPeriodCostGroup.Version    == controlVersion
            exists join projControlCostGroup
            where projControlCostGroup.CostGroupId  == projControlPeriodCostGroup.CostGroupId   &&
                  projControlCostGroup.CostType     == ProjCostType::Cost;

        return projControlPeriodCostGroup.ActuelCostAmount + projControlPeriodCostGroup.ctcCostAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>plCostHour</Name>
				<Source><![CDATA[
    protected AmountMST plCostHour(
        ProjControlPeriodTableColumn  _projControlPeriodTableColumnEstimate,
        ProjEstimateColumn            _estimateColumn)
    {
        if (_estimateColumn == ProjEstimateColumn::Total)
        {
            return this.plCostHourTotal();
        }

        return _projControlPeriodTableColumnEstimate.ConsumHourNotCapital;
    }

]]></Source>
			</Method>
			<Method>
				<Name>plCostHourTotal</Name>
				<Source><![CDATA[
    protected AmountMST plCostHourTotal()
    {
        ProjControlPeriodCostGroup  projControlPeriodCostGroup;
        ProjControlCostGroup        projControlCostGroup;

        select sum(ActuelCostAmount), sum(ctcCostAmount) from projControlPeriodCostGroup
            where projControlPeriodCostGroup.ProjId     == projId           &&
                  projControlPeriodCostGroup.ControlId  == controlId        &&
                  projControlPeriodCostGroup.PeriodFrom == periodFrom       &&
                  projControlPeriodCostGroup.Version    == controlVersion
            exists join projControlCostGroup
            where projControlCostGroup.CostGroupId  == projControlPeriodCostGroup.CostGroupId   &&
                  projControlCostGroup.CostType     == ProjCostType::Hour;

        return projControlPeriodCostGroup.ActuelCostAmount + projControlPeriodCostGroup.ctcCostAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>plCostItem</Name>
				<Source><![CDATA[
    protected ProjItem plCostItem(
        ProjControlPeriodTableColumn  _projControlPeriodTableColumnEstimate,
        ProjEstimateColumn            _estimateColumn)
    {
        if (_estimateColumn == ProjEstimateColumn::Total)
        {
            return this.plCostItemTotal();
        }

        return _projControlPeriodTableColumnEstimate.ConsumItemNotCapital;
    }

]]></Source>
			</Method>
			<Method>
				<Name>plCostItemTotal</Name>
				<Source><![CDATA[
    protected AmountMST plCostItemTotal()
    {
        ProjControlPeriodCostGroup  projControlPeriodCostGroup;
        ProjControlCostGroup        projControlCostGroup;

        select sum(ActuelCostAmount), sum(ctcCostAmount) from projControlPeriodCostGroup
            where projControlPeriodCostGroup.ProjId     == projId           &&
                  projControlPeriodCostGroup.ControlId  == controlId        &&
                  projControlPeriodCostGroup.PeriodFrom == periodFrom       &&
                  projControlPeriodCostGroup.Version    == controlVersion
            exists join projControlCostGroup
            where projControlCostGroup.CostGroupId  == projControlPeriodCostGroup.CostGroupId   &&
                  projControlCostGroup.CostType     == ProjCostType::Item;

        return projControlPeriodCostGroup.ActuelCostAmount + projControlPeriodCostGroup.ctcCostAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>plCostTotalCost</Name>
				<Source><![CDATA[
    protected ProjTotalCost plCostTotalCost(
        ProjControlPeriodTableColumn  _projControlPeriodTableColumn)
    {
        return _projControlPeriodTableColumn.plCostAccCost+
               _projControlPeriodTableColumn.plCostHour+
               _projControlPeriodTableColumn.plCostExpenses+
               _projControlPeriodTableColumn.plCostItem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>plInvRevInvoiceOnAcc</Name>
				<Source><![CDATA[
    protected AmountMST plInvRevInvoiceOnAcc(
        ProjControlPeriodTable  _projControlPeriodTable,
        ProjEstimateColumn      _estimateColumn)
    {
        if (_estimateColumn == ProjEstimateColumn::Total)
        {
            return _projControlPeriodTable.totalContract();
        }

        return _projControlPeriodTable.ActualContract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>plTotalGrossMargin</Name>
				<Source><![CDATA[
    protected ProjGrossMargin plTotalGrossMargin(
        ProjControlPeriodTableColumn  _projControlPeriodTableColumn)
    {
        return _projControlPeriodTableColumn.plTotalRevenue-
               _projControlPeriodTableColumn.plCostTotalCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>plTotalRevenue</Name>
				<Source><![CDATA[
    protected ProjRevenue plTotalRevenue(
        ProjControlPeriodTableColumn  _projControlPeriodTableColumn)
    {
        return _projControlPeriodTableColumn.plInvRevInvoiceOnAcc+
               _projControlPeriodTableColumn.plAccRevTotalAccRev;
    }

]]></Source>
			</Method>
			<Method>
				<Name>plTotalValueAddedAmount</Name>
				<Source><![CDATA[
    protected ProjValueAddedAmount plTotalValueAddedAmount(
        ProjControlPeriodTableColumn  _projControlPeriodTableColumn)
    {
        return _projControlPeriodTableColumn.plTotalRevenue-
               _projControlPeriodTableColumn.plCostExpenses-
               _projControlPeriodTableColumn.plCostAccCost-
               _projControlPeriodTableColumn.plCostItem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeOffsetOnAcc</Name>
				<Source><![CDATA[
    public LedgerPostingType postingTypeOffsetOnAcc()
    {
        if (this.parmEliminate())
        {
            return LedgerPostingType::ProjAccruedRevenueOnAccount;
        }

        return LedgerPostingType::ProjWIPInvoicedOnAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeOnAcc</Name>
				<Source><![CDATA[
    public LedgerPostingType postingTypeOnAcc()
    {
        if (this.parmEliminate())
        {
            return LedgerPostingType::ProjWIPInvoicedOnAccount;
        }

        return LedgerPostingType::ProjAccruedRevenueOnAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeWIPCost</Name>
				<Source><![CDATA[
    public LedgerPostingType postingTypeWIPCost()
    {
        return LedgerPostingType::ProjCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeWIPOffsetCost</Name>
				<Source><![CDATA[
    public LedgerPostingType postingTypeWIPOffsetCost()
    {
        return LedgerPostingType::ProjWIPCostvalue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeWIPOffsetProd</Name>
				<Source><![CDATA[
    public LedgerPostingType postingTypeWIPOffsetProd()
    {
        return LedgerPostingType::ProjAccruedTurnoverProd;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeWIPOffsetProfit</Name>
				<Source><![CDATA[
    public LedgerPostingType postingTypeWIPOffsetProfit()
    {
        return LedgerPostingType::ProJAccruedTurnoverProfit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeWIPOffsetTurnover</Name>
				<Source><![CDATA[
    public LedgerPostingType postingTypeWIPOffsetTurnover()
    {
        return LedgerPostingType::ProjSalesvalue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeWIPProd</Name>
				<Source><![CDATA[
    public LedgerPostingType postingTypeWIPProd()
    {
        return LedgerPostingType::ProjWIPProduction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeWIPProfit</Name>
				<Source><![CDATA[
    public LedgerPostingType postingTypeWIPProfit()
    {
        return LedgerPostingType::ProjWIPProfit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeWIPTurnover</Name>
				<Source><![CDATA[
    public LedgerPostingType postingTypeWIPTurnover()
    {
        return LedgerPostingType::ProjSalesvalueOffset;
    }

]]></Source>
			</Method>
			<Method>
				<Name>provisionForseeablesLosses</Name>
				<Source><![CDATA[
    protected boolean provisionForseeablesLosses(ProjControlPeriodTable _projControlPeriodTable)
    {
        return (_projControlPeriodTable.contributionMargen() < 0 && ProjRevRecHelper::isForeseeableLossesActivatedForProjControlPeriodTable(_projControlPeriodTable));
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        #OCCRetryCount

        try
        {
            ttsbegin;
            
            ProjRevRecInstrumentationLogger logger;
            if(contractLineBasedRevRecFeature && isContractLineUsed)
            {
                logger = ProjRevRecInstrumentationLogger::createLogger(classStr(ProjControlCalc));
            }
            else
            {
                logger = ProjRevRecInstrumentationLogger::createLogger(classStr(ProjControlCalc));
            }
            using (var activityContext = logger.revRecActivity().updateProjControlPeriodContext())
            {
                this.periodUpdate();
            }

            ttscommit;
        }

        catch (Exception::Error)
        {
            throw error("@SYS21628");
        }

        catch (Exception::Deadlock)
        {
            retry;
        }

        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPeriodZero</Name>
				<Source><![CDATA[
    protected void setPeriodZero(
        ProjControlPeriodTableColumn    _projControlPeriodTableColumn)
    {
        _projControlPeriodTableColumn.plInvRevInvoiceOnAcc  =0;
        _projControlPeriodTableColumn.plAccRevSalesValue    = 0;
        _projControlPeriodTableColumn.plAccRevProduction    = 0;
        _projControlPeriodTableColumn.plAccRevProfit        = 0;
        _projControlPeriodTableColumn.plAccRevAccOnAcc      = 0;
        _projControlPeriodTableColumn.plCostHour            = 0;
        _projControlPeriodTableColumn.plCostAccCost         = 0;
        _projControlPeriodTableColumn.ConsumHourConsum      = 0;
        _projControlPeriodTableColumn.ConsumHourCapital     = 0;
        _projControlPeriodTableColumn.ConsumExpConsum       = 0;
        _projControlPeriodTableColumn.ConsumExpCapital      = 0;
        _projControlPeriodTableColumn.ConsumItemConsum      = 0;
        _projControlPeriodTableColumn.ConsumItemCapital     = 0;
        _projControlPeriodTableColumn.wipInvoiceOnAcc       = 0;
        _projControlPeriodTableColumn.wipSalesPriceProfit   = 0;
        _projControlPeriodTableColumn.wipSalesPriceSalesValue= 0;
        _projControlPeriodTableColumn.wipSalespriceProduction= 0;
        _projControlPeriodTableColumn.ConsumExpNotCapital= 0;
        _projControlPeriodTableColumn.ConsumHourNotCapital= 0;
        _projControlPeriodTableColumn.ConsumItemNotCapital= 0;
        _projControlPeriodTableColumn.ConsumTotalConsum= 0;
        _projControlPeriodTableColumn.ConsumTotalNotCapital= 0;
        _projControlPeriodTableColumn.wipSalespriceTotal= 0;
        _projControlPeriodTableColumn.wipCostpriceHour= 0;
        _projControlPeriodTableColumn.wipCostpriceExp= 0;
        _projControlPeriodTableColumn.wipCostpriceItem= 0;
        _projControlPeriodTableColumn.wipCostpriceAccruedCost= 0;
        _projControlPeriodTableColumn.wipCostpriceTotal= 0;
        _projControlPeriodTableColumn.wipTotalGrossWIP= 0;
        _projControlPeriodTableColumn.wipTotalNetWIP= 0;
        _projControlPeriodTableColumn.plAccRevTotalAccRev= 0;
        _projControlPeriodTableColumn.plCostExpenses= 0;
        _projControlPeriodTableColumn.plCostItem= 0;
        _projControlPeriodTableColumn.plCostTotalCost   = 0;
        _projControlPeriodTableColumn.plTotalRevenue= 0;
        _projControlPeriodTableColumn.plTotalValueAddedAmount= 0;
        _projControlPeriodTableColumn.plTotalGrossMargin= 0;
        _projControlPeriodTableColumn.GeneralHourRevenue= 0;
        _projControlPeriodTableColumn.GeneralHourValuaddedHourRate= 0;
        _projControlPeriodTableColumn.GeneralHourCostHourRate= 0;
        _projControlPeriodTableColumn.GeneralHourGrossMarginHourRate= 0;
        _projControlPeriodTableColumn.ConsumTotalCapital = 0;
        _projControlPeriodTableColumn.ConsumCostHourRate = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>valueAdded</Name>
				<Source><![CDATA[
    AmountMST valueAdded(ProjControlPeriodTable _projControlPeriod)
    {
        AmountMST   ret = 0;

        if (_projControlPeriod.ActualCostAmount + _projControlPeriod.ctcCostAmount - this.costItemCost(_projControlPeriod))
        {
            ret = CurrencyExchangeHelper::amount(_projControlPeriod.ActualContract + _projControlPeriod.ctcContract - this.costItemCost(_projControlPeriod))/
                                       (_projControlPeriod.ActualCostAmount + _projControlPeriod.ctcCostAmount - this.costItemCost(_projControlPeriod));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipAccrTurnoverProdCreditLedgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount wipAccrTurnoverProdCreditLedgerDimension(ProjFundingSourceRefId _fundingSourceID, TaxGroup _taxGroup = '')
    {
        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            return ProjPosting::getLedgerDimension(ProjAccountType::AccruedTurnoverProd, ProjWIPTable::getProjIdForRevenuePosting(projId), categoryId, _fundingSourceID, true, true, _taxGroup);
        }
        return ProjPosting::getLedgerDimension(ProjAccountType::AccruedTurnoverProd, projId, categoryId, _fundingSourceID, true, true, _taxGroup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipAccrTurnoverProdDebitLedgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount wipAccrTurnoverProdDebitLedgerDimension(ProjFundingSourceRefId _fundingSourceID, TaxGroup _taxGroup = '')
    {
        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            return ProjPosting::getLedgerDimension(ProjAccountType::WIPProduction, ProjWIPTable::getProjIdForRevenuePosting(projId), categoryId, _fundingSourceID, true, true, _taxGroup);
        
        }
        return ProjPosting::getLedgerDimension(ProjAccountType::WIPProduction, projId, categoryId, _fundingSourceID, true, true, _taxGroup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipAccrTurnovrProfitCredtLedgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount wipAccrTurnovrProfitCredtLedgerDimension(ProjFundingSourceRefId _fundingSourceID, TaxGroup _taxGroup = '')
    {
        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            return ProjPosting::getLedgerDimension(ProjAccountType::AccruedTurnoverProfit, ProjWIPTable::getProjIdForRevenuePosting(projId), categoryId, _fundingSourceID, true, true, _taxGroup);
        }
        return ProjPosting::getLedgerDimension(ProjAccountType::AccruedTurnoverProfit, projId, categoryId, _fundingSourceID, true, true, _taxGroup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipAccrTurnovrProfitDebitLedgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount wipAccrTurnovrProfitDebitLedgerDimension(ProjFundingSourceRefId _fundingSourceID, TaxGroup _taxGroup = '')
    {
        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            return ProjPosting::getLedgerDimension(ProjAccountType::WIPProfit, ProjWIPTable::getProjIdForRevenuePosting(projId), categoryId, _fundingSourceID, true, true, _taxGroup);
        }
        return ProjPosting::getLedgerDimension(ProjAccountType::WIPProfit, projId, categoryId, _fundingSourceID, true, true, _taxGroup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>WIPAccruedCostCredit</Name>
				<Source><![CDATA[
    public boolean WIPAccruedCostCredit()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>WIPAccruedCostCreditLedgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount WIPAccruedCostCreditLedgerDimension(ProjFundingSourceRefID _fundingSourceID)
    {
        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            return ProjPosting::getLedgerDimension(ProjAccountType::StatusAccount, ProjWIPTable::getProjIdForRevenuePosting(projId), '', _fundingSourceId,true);

        }
        return ProjPosting::getLedgerDimension(ProjAccountType::StatusAccount, projId, '', _fundingSourceId,true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>WIPAccruedCostDebit</Name>
				<Source><![CDATA[
    public boolean WIPAccruedCostDebit(ProjControlPeriodTable _projControlPeriod)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>WIPAccruedCostDebitLedgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount WIPAccruedCostDebitLedgerDimension(ProjFundingSourceRefID _fundingSourceID)
    {
        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            return ProjPosting::getLedgerDimension(ProjAccountType::CostAccount, ProjWIPTable::getProjIdForRevenuePosting(projId), '', _fundingSourceId, true);
        }
        return ProjPosting::getLedgerDimension(ProjAccountType::CostAccount, projId, '', _fundingSourceId, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipAccruedTurnover</Name>
				<Source><![CDATA[
    abstract protected AmountMST wipAccruedTurnover(ProjControlPeriodTable _projControlPeriod)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipAccruedTurnoverAcc</Name>
				<Source><![CDATA[
    protected AmountMST wipAccruedTurnoverAcc(ProjControlPeriodTable _projControlPeriod)
    {
        return wipAccruedTurnoverAcc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipAccruedTurnoverCredit</Name>
				<Source><![CDATA[
    abstract public boolean wipAccruedTurnoverCredit(ProjControlPeriodTable _projControlPeriod)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipAccruedTurnoverCreditLedgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount wipAccruedTurnoverCreditLedgerDimension(ProjFundingSourceRefId _fundingSourceID, TaxGroup _taxGroup = '')
    {
        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            return ProjPosting::getLedgerDimension(ProjAccountType::SalesValue, ProjWIPTable::getProjIdForRevenuePosting(projId), categoryId, _fundingSourceID, true, true, _taxGroup);
        
        }
        return ProjPosting::getLedgerDimension(ProjAccountType::SalesValue, projId, categoryId, _fundingSourceID, true, true, _taxGroup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipAccruedTurnoverDebit</Name>
				<Source><![CDATA[
    abstract public boolean wipAccruedTurnoverDebit(ProjControlPeriodTable _projControlPeriod)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipAccruedTurnoverDebitLedgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount wipAccruedTurnoverDebitLedgerDimension(ProjFundingSourceRefId _fundingSourceId, TaxGroup _taxGroup = '')
    {
        if(contractLineBasedRevRecFeature && isContractLineUsed)
        {
            return ProjPosting::getLedgerDimension(ProjAccountType::SalesOffsetAccount, ProjWIPTable::getProjIdForRevenuePosting(projId), categoryId, _fundingSourceId, true, true, _taxGroup);
        
        }
        return ProjPosting::getLedgerDimension(ProjAccountType::SalesOffsetAccount, projId, categoryId, _fundingSourceId, true, true, _taxGroup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipAccruedTurnoverProd</Name>
				<Source><![CDATA[
    abstract protected AmountMST wipAccruedTurnoverProd(ProjControlPeriodTable _projControlPeriod)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipAccruedTurnoverprodAcc</Name>
				<Source><![CDATA[
    protected AmountMST wipAccruedTurnoverprodAcc()
    {
        return wipAccruedTurnoverProdAcc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipAccruedTurnoverProdCredit</Name>
				<Source><![CDATA[
    public boolean wipAccruedTurnoverProdCredit()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipAccruedTurnoverProdDebit</Name>
				<Source><![CDATA[
    public boolean wipAccruedTurnoverProdDebit()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipAccruedTurnoverProfit</Name>
				<Source><![CDATA[
    abstract protected AmountMST wipAccruedTurnoverProfit(ProjControlPeriodTable  _projControlPeriod)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipAccruedTurnoverProfitAcc</Name>
				<Source><![CDATA[
    protected AmountMST wipAccruedTurnoverProfitAcc(ProjControlPeriodTable _projControlPeriod)
    {
        return wipAccruedTurnoverProfitAcc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipAccruedTurnoverProfitCredit</Name>
				<Source><![CDATA[
    public boolean wipAccruedTurnoverProfitCredit()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipAccruedTurnoverProfitDebit</Name>
				<Source><![CDATA[
    public boolean wipAccruedTurnoverProfitDebit()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipCost</Name>
				<Source><![CDATA[
    abstract protected AmountMST wipCost(ProjControlPeriodTable _projControlPeriod)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipCostAcc</Name>
				<Source><![CDATA[
    protected AmountMST wipCostAcc()
    {
        return wipCostAcc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipCostpriceAccruedCost</Name>
				<Source><![CDATA[
    protected ProjAccruedCost wipCostpriceAccruedCost(
        ProjControlPeriodTableColumn    _projControlPeriodTableColumn,
        ProjEstimateColumn              _estimateColumn)
    {
        return -_projControlPeriodTableColumn.plCostAccCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipCostpriceExp</Name>
				<Source><![CDATA[
    protected ProjExpenses wipCostpriceExp(
        ProjControlPeriodTableColumn    _projControlPeriodTableColumn,
        ProjEstimateColumn              _estimateColumn)
    {
        return _projControlPeriodTableColumn.ConsumExpCapital;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipCostpriceHour</Name>
				<Source><![CDATA[
    protected ProjHour wipCostpriceHour(
        ProjControlPeriodTableColumn    _projControlPeriodTableColumn,
        ProjEstimateColumn              _estimateColumn)
    {
        return _projControlPeriodTableColumn.ConsumHourCapital;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipCostpriceItem</Name>
				<Source><![CDATA[
    protected ProjItem wipCostpriceItem(
        ProjControlPeriodTableColumn    _projControlPeriodTableColumn,
        ProjEstimateColumn              _estimateColumn)
    {
        return _projControlPeriodTableColumn.ConsumItemCapital;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipCostpriceTotal</Name>
				<Source><![CDATA[
    protected ProjTotalWIPCostPrice wipCostpriceTotal(
        ProjControlPeriodTableColumn    _projControlPeriodTableColumn,
        ProjEstimateColumn              _estimateColumn)
    {
        return  _projControlPeriodTableColumn.wipCostpriceItem+
                _projControlPeriodTableColumn.wipCostpriceHour+
                _projControlPeriodTableColumn.wipCostpriceExp+
                _projControlPeriodTableColumn.wipCostpriceAccruedCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipInvoiceOnAcc</Name>
				<Source><![CDATA[
    protected AmountMST wipInvoiceOnAcc(
        ProjControlPeriodTable  _projControlPeriodTable)
    {
        return _projControlPeriodTable.ActualContract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipSalespriceProduction</Name>
				<Source><![CDATA[
    protected ProjProduction wipSalespriceProduction(
        ProjControlPeriodTableColumn    _projControlPeriodTableColumn,
        ProjEstimateColumn              _estimateColumn)
    {
        return _projControlPeriodTableColumn.plAccRevProduction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipSalespriceProfit</Name>
				<Source><![CDATA[
    protected ProjProfit wipSalespriceProfit(
        ProjControlPeriodTableColumn    _projControlPeriodTableColumn,
        ProjEstimateColumn              _estimateColumn)
    {
        return _projControlPeriodTableColumn.plAccRevProfit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipSalespriceSalesValue</Name>
				<Source><![CDATA[
    protected ProjSalesValue wipSalespriceSalesValue(
        ProjControlPeriodTableColumn    _projControlPeriodTableColumn,
        ProjEstimateColumn              _estimateColumn)
    {
        return _projControlPeriodTableColumn.plAccRevSalesValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipSalespriceTotal</Name>
				<Source><![CDATA[
    protected ProjTotalWIPSalesprice wipSalespriceTotal(
        ProjControlPeriodTableColumn    _projControlPeriodTableColumn,
        ProjEstimateColumn              _estimateColumn)
    {
        return _projControlPeriodTableColumn.wipSalesPriceSalesValue+
               _projControlPeriodTableColumn.wipSalesPriceProfit+
               _projControlPeriodTableColumn.wipSalespriceProduction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipTotalGrossWIP</Name>
				<Source><![CDATA[
    protected ProjGrossWIP wipTotalGrossWIP(
        ProjControlPeriodTableColumn    _projControlPeriodTableColumn,
        ProjEstimateColumn              _estimateColumn)
    {
        return  _projControlPeriodTableColumn.wipCostpriceTotal+
                _projControlPeriodTableColumn.wipSalespriceTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipTotalNetWIP</Name>
				<Source><![CDATA[
    protected projNetWIP wipTotalNetWIP(
        ProjControlPeriodTableColumn    _projControlPeriodTableColumn,
        ProjEstimateColumn              _estimateColumn)
    {
        return _projControlPeriodTableColumn.wipTotalGrossWIP-
               _projControlPeriodTableColumn.wipInvoiceOnAcc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipValue</Name>
				<Source><![CDATA[
    protected AmountMST wipValue(ProjControlPeriodTable _projControlPeriod)
    {
        wipValue = CurrencyExchangeHelper::amount(this.contractSum(_projControlPeriod) * _projControlPeriod.CompletePct / 100);

        return wipValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipValueCPSPlitByProjCompletePrincipExt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Implements logic for <c>ProjControlCalc::wipValueCPSplit</c> based on extensions to <c>ProjCompleteSplit</c>.
    /// </summary>
    /// <remarks>'next' should NOT be called here, as default impementation throws error.</remarks>
    /// <param name = "_completePrincip">Extended value of complete principle.</param>
    /// <param name = "_projControlPeriod"><c>ProjControlPeriod</c> record.</param>
    /// <param name = "_projGroup"><c>ProjGroup</c> object.</param>
    /// <param name = "_callerName">Name of calling function.</param>
    /// <returns><c>AmountMST</c> value.</returns>
    [Replaceable]
    protected AmountMST wipValueCPSPlitByProjCompletePrincipExt(ProjCompletePrincip _completePrincip, ProjControlPeriodTable _projControlPeriod, ProjGroup _projGroup, str _callerName)
    {
        throw error(strFmt("@SYS22828", _callerName));
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipValueCPSPlitByProjCompletePrincipleUsingRevenueProfileExt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Implements logic for <c>ProjControlCalc::wipValueCPSplit</c> based on extensions to <c>ProjCompleteSplit</c>.
    /// </summary>
    /// <remarks>'next' should NOT be called here, as default impementation throws error.</remarks>
    /// <param name = "_completePrincip">Extended value of complete principle.</param>
    /// <param name = "_projControlPeriod"><c>ProjControlPeriod</c> record.</param>
    /// <param name = "_revProfile"><c>ProjRevenueProfile</c> object.</param>
    /// <param name = "_callerName">Name of calling function.</param>
    /// <returns><c>AmountMST</c> value.</returns>
    [Replaceable]
    protected AmountMST wipValueCPSPlitByProjCompletePrincipleUsingRevenueProfileExt(ProjCompletePrincip _completePrinciple, ProjControlPeriodTable _projControlPeriod,
                                                                                    ProjRevenueProfile _revProfile, str _callerName)
    {
        throw error(strFmt("@SYS22828", _callerName));
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipValueCPSPlit</Name>
				<Source><![CDATA[
    protected AmountMST wipValueCPSPlit(ProjControlPeriodTable _projControlPeriod)
    {
        boolean multipleContractLinesFeatureEnabled = ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled();
        ProjCompletePrincip completePrinciple;
        ProjSalesPriceMatchingPrincip salesPriceMatching;
        ProjRevenueProfile revProfile;
        ProjGroup projGroup;
        ProjWIPTable wipProject = ProjWIPTable::find(_projControlPeriod.ProjId);
        if(ProjContractLineBasedRevenueRecognitionFeatureHelper::isFeatureEnabled() && wipProject.IsContractLineUsed)
        {
            revProfile = ProjRevRecHelper::getProfileForRevRecProjectContractLine(wipProject);
            completePrinciple = revProfile.CompletePrinciple;
            salesPriceMatching = revProfile.SalesPriceMatchingPrinciple;
        }
        else if (multipleContractLinesFeatureEnabled)
        {
            revProfile = ProjRevRecHelper::getRevProfile(ProjTable::find(_projControlPeriod.ProjId), ProjContractBillingMethod::FixedPrice);
            completePrinciple = revProfile.CompletePrinciple;
            salesPriceMatching = revProfile.SalesPriceMatchingPrinciple;
        }
        else
        {
            projGroup = _projControlPeriod.projGroup();
            completePrinciple = projGroup.CompletePrincip;
            salesPriceMatching = projGroup.SalesPriceMatchingPrincip;
        }

        AmountMST wipAccruedTurnover;
        ProjControlPeriodCostGroup projControlPeriodCostGroup;
        ProjControlCostGroup projControlCostGroup;
        AmountMST plCostHour;
        ProjQtyEmpl generalHoursQty;
        AmountMST consumHourConsum;

        switch (completePrinciple)
        {
            case ProjCompletePrincip::CompletedPercentage:
                switch (salesPriceMatching)
                {
                    case ProjSalesPriceMatchingPrincip::None:
                        wipAccruedTurnover = CurrencyExchangeHelper::amount(((this.contractSum(_projControlPeriod) -
                                                                        (this.actualCostAmount(_projControlPeriod) +
                                                                         this.ctcCostAmount(_projControlPeriod))) *
                                                                        _projControlPeriod.CompletePct / 100)
                                                                        - this.wipAccruedTurnoverProfitAcc(_projControlPeriod));
                        break;

                    case ProjSalesPriceMatchingPrincip::ValueAddedMarkupPercent:
                        plCostHour = this.plCostHourTotal();
                        if (plCostHour)
                        {
                            consumHourConsum = this.consum(ProjCostType::Hour);
                            wipAccruedTurnover = CurrencyExchangeHelper::amount(
                                ((consumHourConsum *
                                    (_projControlPeriod.contributionMargen() + plCostHour))
                                    / plCostHour)
                                - consumHourConsum
                                - this.wipAccruedTurnoverProfitAcc(_projControlPeriod));
                        }
                        break;

                    case ProjSalesPriceMatchingPrincip::ValueAddedHourRate:
                        generalHoursQty = this.generalHoursQtyTotal();
                        if (generalHoursQty)
                        {
                            plCostHour = this.plCostHourTotal();

                            select sum(ActuelCostUnit) from projControlPeriodCostGroup
                                where projControlPeriodCostGroup.ProjId == _projControlPeriod.ProjId &&
                                      projControlPeriodCostGroup.ControlId == _projControlPeriod.ControlId &&
                                      projControlPeriodCostGroup.PeriodFrom == _projControlPeriod.PeriodFrom &&
                                      projControlPeriodCostGroup.Version == _projControlPeriod.Version
                                exists join projControlCostGroup
                                where projControlCostGroup.CostGroupId == projControlPeriodCostGroup.CostGroupId &&
                                      projControlCostGroup.CostType == ProjCostType::Hour;

                            consumHourConsum = this.consum(ProjCostType::Hour);

                            wipAccruedTurnover = CurrencyExchangeHelper::amount(
                                ((projControlPeriodCostGroup.ActuelCostUnit *
                                    (_projControlPeriod.contributionMargen() + plCostHour))
                                    / generalHoursQty)
                                - consumHourConsum
                                - this.wipAccruedTurnoverProfitAcc(_projControlPeriod));
                        }
                        break;

                    default:
                        throw error(strFmt("@SYS22828",funcName()));
                }
                break;

            default:
                if (multipleContractLinesFeatureEnabled || (ProjContractLineBasedRevenueRecognitionFeatureHelper::isFeatureEnabled() && wipProject.IsContractLineUsed))
                {
                    wipAccruedTurnover = this.wipValueCPSPlitByProjCompletePrincipleUsingRevenueProfileExt(revProfile.CompletePrinciple, _projControlPeriod, revProfile, funcName());
                }
                else
                {
                    wipAccruedTurnover = this.wipValueCPSPlitByProjCompletePrincipExt(projGroup.CompletePrincip, _projControlPeriod, projGroup, funcName());
                }
                break;
        }

        return wipAccruedTurnover;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructByProjCompletePrincipExt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Implements logic for constructing a <c>ProjControlCalc</c> instance based on extensions to <c>ProjCompletePrincip</c>.
    /// </summary>
    /// <remarks>'next' should NOT be called, as default implementation throws error.</remarks>
    /// <param name = "_completePrincip">Extended value of complete principle.</param>
    /// <param name = "_projGroup"><c>ProjGroup</c> object.</param>
    /// <param name = "_eliminate">true if eliminate; otherwise, false.</param>
    /// <returns><c>ProjControlCalc</c> object.</returns>
    [Replaceable]
    public static ProjControlCalc constructByProjCompletePrincipExt(ProjCompletePrincip _completePrincip, ProjGroup _projGroup, boolean _eliminate)
    {
        throw error("@SYS99911");
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructByProjCompletePrincipUsingRevProfileExt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Implements logic for constructing a <c>ProjControlCalc</c> instance based on extensions to <c>ProjCompletePrincip</c>.
    /// </summary>
    /// <remarks>'next' should NOT be called, as default implementation throws error.</remarks>
    /// <param name = "_completePrincip">Extended value of complete principle.</param>
    /// <param name = "_revProfile"><c>ProjRevenueProfile</c> object.</param>
    /// <param name = "_eliminate">true if eliminate; otherwise, false.</param>
    /// <returns><c>ProjControlCalc</c> object.</returns>
    [Replaceable]
    public static ProjControlCalc constructByProjCompletePrincipUsingRevProfileExt(ProjCompletePrincip _completePrincip, ProjRevenueProfile _revProfile, boolean _eliminate)
    {
        throw error("@SYS99911");
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructByProjMatchingPrincipExt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Implements logic for constructing a <c>ProjControlCalc</c> instance based on extensions to <c>ProjMatchingPrincip</c>.
    /// </summary>
    /// <remarks>'next' should NOT be called, as default implementation throws error.</remarks>
    /// <param name = "_matchingPrincip">Extended value of matching principle enum.</param>
    /// <param name = "_projGroup"><c>ProjGroup</c> object.</param>
    /// <param name = "_eliminate">true if eliminate; otherwise, false.</param>
    /// <returns><c>ProjControlCalc</c> object.</returns>
    [Replaceable]
    public static ProjControlCalc constructByProjMatchingPrincipExt(ProjMatchingPrincip _matchingPrincip, ProjGroup _projGroup, boolean _eliminate)
    {
        throw error(strFmt("@SYS22828","@SYS7523"));
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructByProjMatchingPrincipUsingRevProfileExt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Implements logic for constructing a <c>ProjControlCalc</c> instance based on extensions to <c>ProjMatchingPrincip</c>.
    /// </summary>
    /// <remarks>'next' should NOT be called, as default implementation throws error.</remarks>
    /// <param name = "_matchingPrincip">Extended value of matching principle enum.</param>
    /// <param name = "_revProfile"><c>ProjRevenueProfile</c> object.</param>
    /// <param name = "_eliminate">true if eliminate; otherwise, false.</param>
    /// <returns><c>ProjControlCalc</c> object.</returns>
    [Replaceable]
    public static ProjControlCalc constructByProjMatchingPrincipUsingRevProfileExt(ProjMatchingPrincip _matchingPrincip, ProjRevenueProfile _revProfile, boolean _eliminate)
    {
        throw error(strFmt("@SYS22828","@SYS7523"));
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructByProjMatchingPrinciple</Name>
				<Source><![CDATA[
    private static ProjControlCalc constructByProjMatchingPrinciple(ProjMatchingPrincip _matchingPrincip, ProjGroup _projGroup, ProjRevenueProfile _revProfile, boolean _eliminate)
    {
        if (_revProfile)
        {
            return ProjControlCalc::constructByProjMatchingPrincipUsingRevProfileExt(_matchingPrincip, _revProfile, _eliminate);
        }
        else
        {
            return ProjControlCalc::constructByProjMatchingPrincipExt(_matchingPrincip, _projGroup, _eliminate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructByCompletePrinciple</Name>
				<Source><![CDATA[
    private static ProjControlCalc constructByCompletePrinciple(ProjCompletePrincip _completePrincip, ProjGroup _projGroup, ProjRevenueProfile _revProfile, boolean _eliminate)
    {
        if (_revProfile)
        {
            return ProjControlCalc::constructByProjCompletePrincipUsingRevProfileExt(_completePrincip, _revProfile, _eliminate);
        }
        else
        {
            return ProjControlCalc::constructByProjCompletePrincipExt(_completePrincip, _projGroup, _eliminate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static ProjControlCalc construct(
        ProjGroup _projGroup,
        boolean  _eliminate)
    {
        if (_projGroup.ProjType == ProjType::FixedPrice)
        {
            if (_eliminate)
            {
                switch (_projGroup.CompletePrincip)
                {
                    case ProjCompletePrincip::CompletedContract:
                        return ProjControlCalc::constructForCCEliminate(_projGroup, null, _projGroup.InvoicePosting, _projGroup.MatchingPrincip);
                    case ProjCompletePrincip::CompletedPercentage:
                        return ProjControlCalc::constructForCPEliminate(_projGroup, null, _projGroup.InvoicePosting, _projGroup.MatchingPrincip);
                    default:
                        return ProjControlCalc::constructByCompletePrinciple(_projGroup.CompletePrincip, _projGroup, null, _eliminate);
                }
            }
            else
            {
                switch (_projGroup.CompletePrincip)
                {
                    case ProjCompletePrincip::CompletedContract:
                        return ProjControlCalc::constructForCCEstimate(_projGroup, null, _projGroup.InvoicePosting, _projGroup.MatchingPrincip);
                    case ProjCompletePrincip::CompletedPercentage:
                        return ProjControlCalc::constructForCPEstimate(_projGroup, null, _projGroup.InvoicePosting, _projGroup.MatchingPrincip);
                    default:
                        return ProjControlCalc::constructByCompletePrinciple(_projGroup.CompletePrincip, _projGroup, null, _eliminate);
                }
            }
        }
        else
        {
            if (_eliminate)
            {
                return new ProjControlCalcInvestEliminate();
            }
            else
            {
                return new ProjControlCalcInvest();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructFromWIPProjectOrRevenueProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs the <c>ProjControlCalc</c> object using revenue profile or project group created by the user.
    /// </summary>
    /// <param name = "_projWIPTable"><c>ProjWIPTable</c> record for which <c>ProjControlCalc</c> record is being created.</param>
    /// <param name = "_eliminate">true if the object is for elimation; false for an estimate.</param>
    /// <param name = "_billingMethod"><c>ProjContractBillingMethod</c> value used to get revenue profile from profile rules.</param>
    /// <returns><c>ProjControlCalc</c> object.</returns>
    public static ProjControlCalc constructFromWIPProjectOrRevenueProfile(ProjWIPTable _projWIPTable, boolean _eliminate, ProjContractBillingMethod _billingMethod = ProjContractBillingMethod::FixedPrice)
    {
        ProjControlCalc controlCalcLoc;
        boolean isContractLineUsed = _projWIPTable.IsContractLineUsed;
        if (!ProjContractLineBasedRevenueRecognitionFeatureHelper::isFeatureEnabled() || !_projWIPTable.IsContractLineUsed)
        {
            throw error(strFmt("@SYS22828",funcName()));
        }

        ProjRevenueProfile revProfile;
        if(_projWIPTable.ProjRevenueProfileId)
        {
            revProfile = ProjRevenueProfile::findByRevenueProfileId(_projWIPTable.ProjRevenueProfileId);
            controlCalcLoc = ProjControlCalc::constructFromRevenueProfile(revProfile, _eliminate);
        }
        else
        {
            throw error(strFmt("@Proj:WIPNoProfileRule",_projWIPTable.ProjId));
        }
        return controlCalcLoc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructFromProjGroupOrRevenueProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs the <c>ProjControlCalc</c> object using revenue profile or project group created by the user.
    /// </summary>
    /// <param name = "_projTable"><c>Projtable</c> record for which <c>ProjControlCalc</c> record is being created.</param>
    /// <param name = "_eliminate">true if the object is for elimation; false for an estimate.</param>
    /// <param name = "_billingMethod"><c>ProjContractBillingMethod</c> value used to get revenue profile from profile rules.</param>
    /// <returns><c>ProjControlCalc</c> object.</returns>
    public static ProjControlCalc constructFromProjGroupOrRevenueProfile(ProjTable _projTable, boolean _eliminate, ProjContractBillingMethod _billingMethod)
    {
        ProjControlCalc controlCalcLoc;

        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            ProjRevenueProfile revProfile = ProjRevRecHelper::getRevProfile(_projTable, _billingMethod);
            controlCalcLoc = ProjControlCalc::constructFromRevenueProfile(revProfile, _eliminate);
        }
        else
        {
            controlCalcLoc = ProjControlCalc::construct(ProjGroup::find(_projTable.ProjGroupId), _eliminate);
        }        
        controlCalcLoc.billingMethod = _billingMethod;
        return controlCalcLoc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructFromRevenueProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs the <c>ProjControlCalc</c> object using revenue profile created by the user.
    /// </summary>
    /// <param name = "_revProfile"><c>ProjRevenueProfile</c> record.</param>
    /// <param name = "_eliminate">true if the object is for elimation; false for an estimate.</param>
    /// <returns><c>ProjControlCalc</c> object.</returns>
    public static ProjControlCalc constructFromRevenueProfile(ProjRevenueProfile _revProfile, boolean  _eliminate)
    {
        if (_revProfile.BillingMethod == ProjContractBillingMethod::FixedPrice)
        {
            if (_eliminate)
            {
                switch (_revProfile.CompletePrinciple)
                {
                    case ProjCompletePrincip::CompletedContract:
                        return ProjControlCalc::constructForCCEliminate(null, _revProfile, _revProfile.OnAccLedgerStatus, _revProfile.MatchingPrinciple);
                    case ProjCompletePrincip::CompletedPercentage:
                        return ProjControlCalc::constructForCPEliminate(null, _revProfile, _revProfile.OnAccLedgerStatus, _revProfile.MatchingPrinciple);
                    default:
                        return ProjControlCalc::constructByCompletePrinciple(_revProfile.CompletePrinciple, null, _revProfile, _eliminate);
                }
            }
            else
            {
                switch (_revProfile.CompletePrinciple)
                {
                    case ProjCompletePrincip::CompletedContract:
                        return ProjControlCalc::constructForCCEstimate(null, _revProfile, _revProfile.OnAccLedgerStatus, _revProfile.MatchingPrinciple);
                    case ProjCompletePrincip::CompletedPercentage:
                        return ProjControlCalc::constructForCPEstimate(null, _revProfile, _revProfile.OnAccLedgerStatus, _revProfile.MatchingPrinciple);
                    default:
                        return ProjControlCalc::constructByCompletePrinciple(_revProfile.CompletePrinciple, null, _revProfile, _eliminate);
                }
            }
        }
        else
        {
            if (_eliminate)
            {
                return new ProjControlCalcInvestEliminate();
            }
            else
            {
                return new ProjControlCalcInvest();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructForCCEliminate</Name>
				<Source><![CDATA[
    private static ProjControlCalc constructForCCEliminate(ProjGroup _projGroup, ProjRevenueProfile _revProfile, ProjLedgerStatusOnAcc _onAccLS, ProjMatchingPrincip _matchingPrinciple)
    {
        boolean eliminate = true;
        ProjControlCalc calcObj;

        switch (_onAccLS)
        {
            case ProjLedgerStatusOnAcc::BalanceSheet:
                switch (_matchingPrinciple)
                {
                    case ProjMatchingPrincip::ProductionProfit:
                        calcObj = new ProjControlCalcCCSplitBalanceEliminate();
                        break;
                    case ProjMatchingPrincip::SalesValue:
                        calcObj = new ProjControlCalcCCSalesBalanceEliminate();
                        break;
                    default:
                        calcObj = ProjControlCalc::constructByProjMatchingPrinciple(_matchingPrinciple, _projGroup, _revProfile, eliminate);
                        break;
                }
                break;
            case ProjLedgerStatusOnAcc::Operations:
                switch (_matchingPrinciple)
                {
                    case ProjMatchingPrincip::ProductionProfit:
                        calcObj = new ProjControlCalcCCSplitPLEliminate();
                        break;
                    case ProjMatchingPrincip::SalesValue:
                        calcObj = new ProjControlCalcCCSalesPLEliminate();
                        break;
                    default:
                        calcObj = ProjControlCalc::constructByProjMatchingPrinciple(_matchingPrinciple, _projGroup, _revProfile, eliminate);
                        break;
                }
                break;
        }

        return calcObj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructForCPEliminate</Name>
				<Source><![CDATA[
    private static ProjControlCalc constructForCPEliminate(ProjGroup _projGroup, ProjRevenueProfile _revProfile, ProjLedgerStatusOnAcc _onAccLS, ProjMatchingPrincip _matchingPrinciple)
    {
        boolean eliminate = true;
        ProjControlCalc calcObj;

        switch (_onAccLS)
        {
            case ProjLedgerStatusOnAcc::BalanceSheet:
                switch (_matchingPrinciple)
                {
                    case ProjMatchingPrincip::ProductionProfit:
                        calcObj = new ProjControlCalcCPSplitBalanceEliminate();
                        break;
                    case ProjMatchingPrincip::SalesValue:
                        calcObj = new ProjControlCalcCPSalesBalanceEliminate();
                        break;
                    default:
                        calcObj = ProjControlCalc::constructByProjMatchingPrinciple(_matchingPrinciple, _projGroup, _revProfile, eliminate);
                        break;
                }
                break;
            case ProjLedgerStatusOnAcc::Operations:
                switch (_matchingPrinciple)
                {
                    case ProjMatchingPrincip::ProductionProfit:
                        calcObj = new ProjControlCalcCPSplitPLEliminate();
                        break;
                    case ProjMatchingPrincip::SalesValue:
                        calcObj = new ProjControlCalcCPSalesPLEliminate();
                        break;
                    default:
                        calcObj = ProjControlCalc::constructByProjMatchingPrinciple(_matchingPrinciple, _projGroup, _revProfile, eliminate);
                        break;
                }
                break;
        }

        return calcObj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructForCPEstimate</Name>
				<Source><![CDATA[
    private static ProjControlCalc constructForCPEstimate(ProjGroup _projGroup, ProjRevenueProfile _revProfile, ProjLedgerStatusOnAcc _onAccLS, ProjMatchingPrincip _matchingPrinciple)
    {
        boolean eliminate = false;
        ProjControlCalc calcObj;

        switch (_onAccLS)
        {
            case ProjLedgerStatusOnAcc::BalanceSheet:
                switch (_matchingPrinciple)
                {
                    case ProjMatchingPrincip::ProductionProfit:
                        calcObj = new ProjControlCalcCPSplitBalance ();
                        break;
                    case ProjMatchingPrincip::SalesValue:
                        calcObj = new ProjControlCalcCPSalesBalance ();
                        break;
                    default:
                        calcObj = ProjControlCalc::constructByProjMatchingPrinciple(_matchingPrinciple, _projGroup, _revProfile, eliminate);
                        break;
                }
                break;
            case ProjLedgerStatusOnAcc::Operations:
                switch (_matchingPrinciple)
                {
                    case ProjMatchingPrincip::ProductionProfit:
                        calcObj = new ProjControlCalcCPSplitPL();
                        break;
                    case ProjMatchingPrincip::SalesValue:
                        calcObj = new ProjControlCalcCPSalesPL();
                        break;
                    default:
                        calcObj = ProjControlCalc::constructByProjMatchingPrinciple(_matchingPrinciple, _projGroup, _revProfile, eliminate);
                        break;
                }
                break;
        }

        return calcObj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructForCCEstimate</Name>
				<Source><![CDATA[
    private static ProjControlCalc constructForCCEstimate(ProjGroup _projGroup, ProjRevenueProfile _revProfile, ProjLedgerStatusOnAcc _onAccLS, ProjMatchingPrincip _matchingPrinciple)
    {
        boolean eliminate = false;
        ProjControlCalc calcObj;

        switch (_onAccLS)
        {
            case ProjLedgerStatusOnAcc::BalanceSheet:
                switch (_matchingPrinciple)
                {
                    case ProjMatchingPrincip::ProductionProfit:
                        calcObj = new ProjControlCalcCCSplitBalance();
                        break;
                    case ProjMatchingPrincip::SalesValue:
                        calcObj = new ProjControlCalcCCSalesBalance();
                        break;
                    default:
                        calcObj = ProjControlCalc::constructByProjMatchingPrinciple(_matchingPrinciple, _projGroup, _revProfile, eliminate);
                        break;
                }
                break;
            case ProjLedgerStatusOnAcc::Operations:
                switch (_matchingPrinciple)
                {
                    case ProjMatchingPrincip::ProductionProfit:
                        calcObj = new ProjControlCalcCCSplitPL();
                        break;
                    case ProjMatchingPrincip::SalesValue:
                        calcObj = new ProjControlCalcCCSalesPL();
                        break;
                    default:
                        calcObj = ProjControlCalc::constructByProjMatchingPrinciple(_matchingPrinciple, _projGroup, _revProfile, eliminate);
                        break;
                }
                break;
        }

        return calcObj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    private static ClassDescription description()
    {
        return "@SYS55655";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    private static void main(Args args)
    {
        ProjControlPeriodTable  localProjControlPeriod;
        Object                  callerForm;

        if (!args)
        {
            throw error("@SYS25407");
        }

        if (args.dataset() != tableNum(ProjControlPeriodTable))
        {
            throw error("@SYS25407");
        }

        callerForm              = args.caller();
        localProjControlPeriod  = args.record();

        ProjTable projTableLoc;
        ProjWIPTable projWIPTableLoc;
        ProjControlCalc projControlCalc;

        if(projWIPTableLoc.IsContractLineUsed && ProjContractLineBasedRevenueRecognitionFeatureHelper::isFeatureEnabled())
        {
            projWIPTableLoc = ProjWIPTable::find(localProjControlPeriod.ProjId);
            projControlCalc = ProjControlCalc::constructFromWIPProjectOrRevenueProfile(projWIPTableLoc, localProjControlPeriod.Elimination, ProjContractBillingMethod::FixedPrice);
        }
        else
        {
            projTableLoc = ProjTable::find(localProjControlPeriod.ProjId);
            projControlCalc = ProjControlCalc::constructFromProjGroupOrRevenueProfile(projTableLoc, localProjControlPeriod.Elimination, ProjContractBillingMethod::FixedPrice);
        }

        projControlCalc.parmProjId(localProjControlPeriod.ProjId);
        projControlCalc.parmControlId(localProjControlPeriod.ControlId);
        projControlCalc.parmPeriodFrom(localProjControlPeriod.PeriodFrom);
        projControlCalc.parmControlVersion(localProjControlPeriod.Version);
        projControlCalc.parmEliminate(localProjControlPeriod.Elimination);
        projControlCalc.parmBeginningBalance(localProjControlPeriod.BeginningBalance);

        projControlCalc.run();

        callerForm.bookRefresh();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCategoryId</Name>
				<Source><![CDATA[
    public ProjCategoryId parmCategoryId(ProjCategoryId _categoryId = categoryId)
    {
        categoryId  = _categoryId;

        return  categoryId;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>