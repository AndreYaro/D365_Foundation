<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PurchYearEndProcess</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>PurchYearEndProcess</c> class implements all the required processing of open purchase orders
/// for the purchase order year end process.
/// </summary>
class PurchYearEndProcess extends RunBaseBatch implements BatchRetryable
{
    JournalizingDefinitionEngine            jdEngine;
    FiscalCalendarYear                      prevFiscalYearRec;
    FiscalCalendar                          fiscalCalendarRec;
    LedgerParameters                        ledgerParams;
    BudgetTransactionCode                   budgetTransactionCode;
    BudgetTransactionManager                budgetTransactionManager;
    BudgetTransactionMultiPost              budgetTransactionMultiPost;
    SubledgerJournalAccountEntryTmpDetail   accountEntryTmpDetail;
    ListEnumerator                          poListEnumerator;
    List                                    budgetModels;
    int                                     numOfBudgetTransactionLines;
    Set                                     budgetTransactionLineRecIdsSet;
    Set                                     topSourceDocumentLineRecIds;
    SetEnumerator                           topSourceDocumentLineRecIdsEnumerator;

    //  Map used to cache ledger account budget reservations for encumbrances in the closing year.
    //  Key:    Top parent source document line (Int64)
    //  Value:  BudgetSourceInquiryDetails (Class)
    Map                                     budgetReservationEncumbranceDetails;
    Map                                     ledgerFundMapOnClient;

    //Current objects
    PurchTable                              currentPurchOrder;
    SourceDocumentLine                      currentSourceDocumentLine;
    BudgetSourceInquiryDetails              currentBudgetDetails;
    PurchaseLineAmountsCalculate_PSN        purchaseLineAmountsCalculate;

    // parm fields
    PurchYearEndOption                      yearEndOption;
    FiscalCalendarID                        fiscalCalendarID;
    FiscalYearName                          prevFiscalYearName;
    TransDate                               prevFiscalYearStartDate;
    TransDate                               prevFiscalYearEndDate;
    TransDate                               closingPostingDate;
    FiscalCalendarPeriodRecId               closingFiscalCalendarPeriod;
    TransDate                               openingPostingDate;
    FiscalCalendarPeriodRecId               openingFiscalCalendarPeriod;
    List                                    poList;
    container                               poListContainer;
    boolean                                 showProgress;
    boolean                                 isSubProcess;
    RefRecId                                batchJobId;
    RefRecId                                originalBudgetTransactionCode;
    RefRecId                                carryForwardBudgetTransactionCode;

    //Derived options
    boolean                                 optApplyUsTaxRules;
    boolean                                 optPreview;

    //Current processing flags
    boolean                                 optEncEnabled;  //true if encumbrance accounting
    boolean                                 optBudgetCarryForward;
    boolean                                 optBudgetPost;
    boolean                                 foundAccountWithDisabledBudgetControl;
    boolean                                 doRecordBudgetEncumbranceAsClosing;

    private const int parallelExecutionThreshold = 10;
    private const int parallelExecutionBatchSize = 1000;

    private const int currentVersion = 5;

    // If you change the list, also update the cloneForSubProcess and add/edit the list there too
    #localmacro.CurrentList
        yearEndOption,
        fiscalCalendarId,
        prevFiscalYearName,
        prevFiscalYearStartDate,
        prevFiscalYearEndDate,
        closingPostingDate,
        closingFiscalCalendarPeriod,
        openingPostingDate,
        openingFiscalCalendarPeriod,
        isSubProcess,
        batchJobId,
        originalBudgetTransactionCode,
        carryForwardBudgetTransactionCode,
        showProgress,
        poListContainer
    #endmacro
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>canGoBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the class can be executed in batch.
    /// </summary>
    /// <returns>
    /// Always returns false.
    /// </returns>
    /// <remarks>
    /// This is an overridden method of the <c>RunBaseBatch</c> class.
    /// </remarks>
    public boolean canGoBatch()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cloneForSubProcess</Name>
				<Source><![CDATA[
    protected PurchYearEndProcess cloneForSubProcess()
    {
        List emptyList = new List(Types::String);
        PurchYearEndProcess instance = PurchYearEndProcess::construct();

        instance.parmYearEndOption(yearEndOption);
        instance.parmFiscalCalendarID(fiscalCalendarID);
        instance.parmPrevFiscalYearName(prevFiscalYearName);
        instance.parmPrevFiscalYearStartDate(prevFiscalYearStartDate);
        instance.parmPrevFiscalYearEndDate(prevFiscalYearEndDate);
        instance.parmClosingPostingDate(closingPostingDate);
        instance.parmClosingFiscalCalendarPeriod(closingFiscalCalendarPeriod);
        instance.parmOpeningPostingDate(openingPostingDate);
        instance.parmOpeningFiscalCalendarPeriod(openingFiscalCalendarPeriod);
        instance.parmIsSubProcess(true);
        instance.parmBatchJobId(batchJobId);
        instance.parmOriginalBudgetTransactionCode(originalBudgetTransactionCode);
        instance.parmCarryForwardBudgetTransactionCode(carryForwardBudgetTransactionCode);
        instance.parmShowProgress(false);
        instance.parmPOList(emptyList);

        return instance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>commitmentDocumentExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if an associated <c>PurchCommitmentHeader_PSN</c> exists in the new year.
    /// </summary>
    /// <param name="_previousYearCommitmentHeaderRecId">
    /// The reference <c>PurchCommitmentHeader_PSN</c> record id.
    /// </param>
    /// <returns>
    /// The record buffer of the associated <c>PurchCommitmentHeader_PSN</c> in the new year.
    /// </returns>
    private PurchCommitmentHeader_PSN commitmentDocumentExists(RefRecId _previousYearCommitmentHeaderRecId)
    {
        PurchCommitmentHeader_PSN     purchCommitmentHeader;

        select firstonly RefPurchCommitmentHeader_PSN from purchCommitmentHeader
            where purchCommitmentHeader.RefPurchCommitmentHeader_PSN == _previousYearCommitmentHeaderRecId;

        return purchCommitmentHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBudgetEncumbrances</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates budget encumbrances for a source document line.
    /// </summary>
    /// <param name="_sourceLine">
    /// A parent source document line instance
    /// </param>
    private void createBudgetEncumbrances(SourceDocumentLine _sourceLine)
    {
        if (!optPreview)
        {
            if (PublicSectorUtils::isFrenchRegulatoryEnabled())
            {
                // Since we have relieving details, the CF flag has to be set to false
                BudgetControlSourceDocumentProcessor::submitSourceDocumentLineToCheckBudget(_sourceLine,
                    false, null, true, curUserId(), false);
            }
            else
            {
                BudgetControlSourceDocumentProcessor::submitSourceDocumentLineToCheckBudget(_sourceLine,
                    false, null, true, curUserId(), true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBudgetTransactionHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>BudgetTransactionHeader</c> table record for a specified budget model.
    /// </summary>
    /// <param name="_modelId">
    /// The budget model ID.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The ledger dimension.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date.
    /// </param>
    /// <param name="_budgetTransactionCode">
    /// The budget transaction code record ID.
    /// </param>
    /// <returns>
    /// A <c>BudgetTransactionHeader</c> record buffer.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The creation process encountered an error and was not completed.
    /// </exception>
    private RefRecId createBudgetTransactionHeader(BudgetModelId         _modelId,
                                                   LedgerDimensionBase   _ledgerDimension,
                                                   TransDate             _transDate,
                                                   RefRecId              _budgetTransactionCode)
    {
        BudgetTransactionHeader budgetTransactionHeader = null;
        NumberSeq numberSeq;
        BudgetModel budgetModel;

        budgetTransactionHeader.clear();
        budgetTransactionHeader.initValue();

        numberSeq = NumberSeq::newGetNum(BudgetParameters::numRefBudgetTransactionId());
        budgetTransactionHeader.TransactionNumber = numberSeq.num();

        budgetModel = this.findBudgetModelByLedgerDimensionAndDate(_ledgerDimension, _transDate);
        budgetTransactionHeader.editBudgetModel(true, budgetModel.ModelId);

        budgetTransactionHeader.setBudgetTransactionCode(_budgetTransactionCode);
        budgetTransactionHeader.Date = _transDate;
        budgetTransactionHeader.TransactionStatus = BudgetTransactionStatus::Draft;
        budgetTransactionHeader.TransferSourceNumber = currentPurchOrder.PurchId;

        if (budgetTransactionHeader.validateWrite() == true)
        {
            budgetTransactionHeader.write();
            budgetTransactionMultiPost.addBudgetTransactionHeaderToPost(budgetTransactionHeader.TransactionNumber);
        }
        else
        {
            // The budget transaction header must be created to complete the transfer.
            throw error("@SYS131643");
        }

        budgetModels.addEnd([_modelId, budgetTransactionHeader.RecId]);
        return budgetTransactionHeader.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBudgetTransactionLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the <c>BudgetTransactionLine</c> table records.
    /// </summary>
    /// <param name="_budgetDetails">
    /// The <c>BudgetDetails</c> object contains the information for the new <c>BudgetTransactionLine</c> table records.
    /// </param>
    /// <param name="_budgetTransactionCode">
    /// A budget transaction code rec ID.
    /// </param>
    /// <param name="_transactionType">
    /// A budget transaction type.
    /// </param>
    /// <param name="_transDate">
    /// A date to set on transaction lines.
    /// </param>
    private void createBudgetTransactionLines(BudgetSourceInquiryDetails _budgetDetails,
                                              RefRecId                   _budgetTransactionCode,
                                              BudgetTransactionType      _transactionType,
                                              TransDate                  _transDate)
    {
        BudgetTransactionLine           budgetTransactionLine;
        BudgetTransactionLineClosing    budgetTransactionLineClosing;
        CurrencyCode                    currency;
        LedgerDimensionBase             ledgerAccount;
        RecId                           headerId;
        BudgetModel                     model;

        boolean                         doCarryForwardBudgetLocal;
        LedgerDimensionBase             fundLedgerAccount;
        LedgerFundYearEndOption         ledgerFundYearEndOption;
        boolean                         isPublicSectorEnabled;

        isPublicSectorEnabled = PublicSectorUtils::isPurchYearEndEnabled();

        if (isPublicSectorEnabled)
        {
            if (yearEndOption == PurchYearEndOption::ProcessAndCarryForwardBudget)
            {
                ledgerFundYearEndOption = LedgerFundYearEndOption::ProcessAndCarryForwardBudget;
            }
            else
            {
                ledgerFundYearEndOption = LedgerFundYearEndOption::ProcessAndDoNotCarryForwardBudget;
            }
        }
        currency = Ledger::accountingCurrency(CompanyInfo::current());

        _budgetDetails.resetCurrent();

        while (_budgetDetails.next())
        {
            if (_budgetDetails.currentAmountAvailable() != 0)
            {
            //Verify budget control status of the accounts
            ledgerAccount = currentBudgetDetails.currentSourceLedgerDimension();

            if (isPublicSectorEnabled)
            {
                fundLedgerAccount = ledgerAccount;
                doCarryForwardBudgetLocal = this.doCarryForwardBudget(fundLedgerAccount, ledgerFundYearEndOption);
            }

            if (_budgetDetails.currentAmountAvailable() > 0
                && !BudgetControlLedgerDimensionHelper::isLedgerDimensionEnabledForBudgetControl(Ledger::current(), ledgerAccount))
            {
                foundAccountWithDisabledBudgetControl = true;
            }

            //find/create header
            model = this.findBudgetModelByLedgerDimensionAndDate(ledgerAccount, _transDate);
            headerId = this.findBudgetTransactionHeader(model.ModelId);

            if (!isPublicSectorEnabled || doCarryForwardBudgetLocal)
            {
            if (!headerId)
            {
                headerId = this.createBudgetTransactionHeader(model.ModelId, ledgerAccount, _transDate, _budgetTransactionCode);
                numofBudgetTransactionLines = 0;
            }

            //create transaction line
            numOfBudgetTransactionLines += 1;
            budgetTransactionLine.clear();
            budgetTransactionLine.LineNumber = numOfBudgetTransactionLines;
            budgetTransactionLine.BudgetTransactionHeader = headerId;
            budgetTransactionLine.Date = _transDate;
            budgetTransactionLine.LedgerDimension = BudgetTransactionManager::saveBudgetLedgerDimension(ledgerAccount);
            budgetTransactionLine.BudgetType = BudgetType::Expense;
            budgetTransactionLine.TransactionCurrency = currency;

            //Create a negative Budget Transaction during the Closing-process to offset the carry forward budget amount
            if (_transactionType == BudgetTransactionType::OriginalBudget)
            {
                budgetTransactionLine.AccountingCurrencyAmount = _budgetDetails.currentAmountAvailable() * -1;
            }
            else
            {
                budgetTransactionLine.AccountingCurrencyAmount = _budgetDetails.currentAmountAvailable();
            }
            budgetTransactionLine.TransactionCurrencyAmount = budgetTransactionLine.AccountingCurrencyAmount;

            if (budgetTransactionLine.validateWrite()
                && BudgetTransactionManager::validateLedgerDimension(budgetTransactionLine.LedgerDimension, budgetTransactionLine.Date))
            {
                // Insert the budget transaction line - this will by-pass the budget check at save, but
                // this is not necessary since this budget transaction will be checked at confirmation as part of this process.
                budgetTransactionLine.insert();

                // Track entries that are created for a closing period.
                if (isPublicSectorEnabled
                    && _transactionType == BudgetTransactionType::OriginalBudget
                    && doRecordBudgetEncumbranceAsClosing)
                {
                    budgetTransactionLineClosing.clear();
                    budgetTransactionLineClosing.BudgetTransactionLine = budgetTransactionLine.RecId;
                    budgetTransactionLineClosing.insert();
                }

                //Store RecId of each line for clean-up in case POYE process fails for the PO
                budgetTransactionLineRecIdsSet.add(budgetTransactionLine.RecId);
            }
            else
            {
                throw error("@SYS131643");
            }
            }
            }
        }//while
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeLineItemForYearEnd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates and then caches the <c>PurchOrderLineSourceDocumentLineItem</c> object into the transactional scope global cache to be consumed by the
    /// <c>ProjectCommitmentFacade</c> class when a call to SourceDocumentLineItem::newFromSourceDocumentLine() is made by the
    /// <c>ProjectCommitmentFacade</c> class. The newFromSourceDocumentLine method uses the transactional scope cache.
    /// </summary>
    /// <param name="_purchOrderLineSourceDocumentLineItem">
    /// If it is a <c>PurchOrderLineSourceDocumentLineItem</c> object, the object is updated with the _openingDate and _closingDate parameters.
    /// It is then stored in the cache.
    /// </param>
    /// <param name="_openingDate">
    /// The opening period date for the year-end process.
    /// </param>
    /// <param name="_closingDate">
    /// The closing period date for the year-end process.
    /// </param>
    private void initializeLineItemForYearEnd(
        SourceDocumentLineItem _purchOrderLineSourceDocumentLineItem,
        AccountingDate _openingDate = dateNull(),
        AccountingDate _closingDate = dateNull())
    {
        PurchOrderLineSourceDocumentLineItem purchOrderLineSourceDocumentLineItem;

        if (_purchOrderLineSourceDocumentLineItem
            && _purchOrderLineSourceDocumentLineItem is PurchOrderLineSourceDocumentLineItem)
        {
            purchOrderLineSourceDocumentLineItem = _purchOrderLineSourceDocumentLineItem;
            purchOrderLineSourceDocumentLineItem.parmClosingDate(_closingDate);
            purchOrderLineSourceDocumentLineItem.parmOpeningDate(_openingDate);

            SourceDocumentLineItem::addToCache(purchOrderLineSourceDocumentLineItem);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrAddCommitmentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>PurchCommitmentHeader_PSN</c> and <c>PurchCommitmentLine_PSN</c> or adds a new <c>PurchCommitmentLine_PSN</c> to
    /// an existing <c>PurchCommitmentHeader_PSN</c>.
    /// </summary>
    /// <param name="_topParentSourceDocumentLineRecId">
    /// The RecId of the current top parent source document line for which to process the budget functionality.
    /// </param>
    /// <remarks>
    /// This method creates a new <c>PurchCommitmentHeader_PSN</c> with a single line in the new year or adds a new line to an existing
    /// <c>PurchCommitmentHeader_PSN</c>. The newly created line is then associated with the <c>PurchLine</c> in the new year.
    /// </remarks>
    private void createOrAddCommitmentLine(RecId _topParentSourceDocumentLineRecId)
    {
        AccountingDistribution          comAccountingDistribution;
        AccountingDistribution          poAccountingDistribution;
        PurchCommitmentHeader_PSN       previousYearPurchCommitmentHeader;
        PurchCommitmentHeader_PSN       purchCommitmentHeader, purchCommitmentHeaderForUpdate;
        PurchCommitmentLine_PSN         previousYearPurchCommitmentLine;
        PurchCommitmentLine_PSN         purchCommitmentLine;
        PurchLine                       purchLine = PurchLine::findBySourceDocumentLine(_topParentSourceDocumentLineRecId, true);
        TradeLineTmpAmountSummary_PSN   tradeLineAmountSummary;

        if (!purchLine)
        {
            return;
        }

        previousYearPurchCommitmentLine     = PurchCommitmentLine_PSN::find(purchLine.PurchCommitmentLine_PSN);
        previousYearPurchCommitmentHeader   = PurchCommitmentHeader_PSN::find(previousYearPurchCommitmentLine.PurchCommitmentHeader_PSN);

        // Find the associated commitment header in the new year
        purchCommitmentHeader = this.commitmentDocumentExists(previousYearPurchCommitmentHeader.RecId);

        // Get the PO line amounts
        tradeLineAmountSummary.setTmpData(purchaseLineAmountsCalculate.parmTradeLineTmpAmountSummary());
        select firstonly InvoiceRemaining from tradeLineAmountSummary where tradeLineAmountSummary.SourceDocumentLine == purchLine.SourceDocumentLine;

        // If found, add a new line to the header. If not, create a new header and add a line.
        if (!purchCommitmentHeader)
        {
            purchCommitmentHeader.initValue();
            purchCommitmentHeader.RefPurchCommitmentHeader_PSN  = previousYearPurchCommitmentHeader.RecId;
            purchCommitmentHeader.DefaultAccountingDate         = openingPostingDate;
            purchCommitmentHeader.Name                          = previousYearPurchCommitmentHeader.Name;
            purchCommitmentHeader.VendorAccount                 = previousYearPurchCommitmentHeader.VendorAccount;
            purchCommitmentHeader.CurrencyCode                  = previousYearPurchCommitmentHeader.CurrencyCode;
            purchCommitmentHeader.FiscalCalendarYear            = FiscalCalendarYear::findYearByCalendarDate(Ledger::fiscalCalendar(CompanyInfo::current()), openingPostingDate).RecId;
            purchCommitmentHeader.HcmWorker                     = HcmWorker::userId2Worker(curUserId());
            purchCommitmentHeader.insert();
        }

        purchCommitmentLine.initValue();
        purchCommitmentLine.Comment                     = previousYearPurchCommitmentLine.Comment;
        purchCommitmentLine.PurchCommitmentHeader_PSN   = purchCommitmentHeader.RecId;
        purchCommitmentLine.LineDate                    = openingPostingDate;
        purchCommitmentLine.LedgerDimension             = previousYearPurchCommitmentLine.LedgerDimension;
        purchCommitmentLine.LineAmount                  = tradeLineAmountSummary.InvoiceRemaining;
        purchCommitmentLine.AgreementLine               = previousYearPurchCommitmentLine.AgreementLine;
        purchCommitmentLine.insert();

        purchLine.PurchCommitmentLine_PSN = purchCommitmentLine.RecId;
        purchLine.doUpdate();

        ttsbegin;
        select firstonly forupdate purchCommitmentHeaderForUpdate where purchCommitmentHeaderForUpdate.RecId == purchCommitmentHeader.RecId;
        purchCommitmentHeaderForUpdate.processSourceDocumentHeader();
        purchCommitmentHeaderForUpdate.DocumentStatus = PurchCommitmentDocumentStatus_PSN::Complete;
        purchCommitmentHeaderForUpdate.update();
        previousYearPurchCommitmentLine.finalizeSourceDocumentLine();
        ttscommit;

        // Get the Commitment line distribution that we created in the new year
        select firstonly RecId from comAccountingDistribution
            where comAccountingDistribution.SourceDocumentLine == purchCommitmentLine.SourceDocumentLine;

        // Get the distribution for the purchase order line with the opening date in the new year
        select firstonly forupdate poAccountingDistribution
            where poAccountingDistribution.AccountingDate     == openingPostingDate
               && poAccountingDistribution.SourceDocumentLine == purchLine.SourceDocumentLine;

        if (poAccountingDistribution)
        {
            // Update the distribution with the new Commitment line distribution recid and set the reference role to matching
            poAccountingDistribution.ReferenceDistribution = comAccountingDistribution.RecId;
            poAccountingDistribution.ReferenceRole = AccountingDistributionReferenceRole::Matching;
            poAccountingDistribution.AccountingEvent = 0;
            poAccountingDistribution.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves an instance of custom parameters form for the batch process.
    /// </summary>
    /// <returns>
    ///    An instance of the <c>PurchYearEndClose</c> form.
    /// </returns>
    public Object dialog()
    {
        Args    args;
        FormRun formRun;

        args = new Args();
        args.name(formStr(PurchYearEndClose));
        args.caller(this);
        args.menuItemName(menuitemActionStr(PurchOrderYearEndProcess));
        args.menuItemType(MenuItemType::Action);

        formRun = ClassFactory::formRunClassOnClient(args);
        formRun.init();

        return formRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doCarryForwardBudget</Name>
				<Source><![CDATA[
    /// <summary>
    /// Filters the <c>SourceDocumentDistribution</c> records by the passed-in <c>LedgerFundYearEndOption</c> value.
    /// </summary>
    /// <param name="_fundLedgerAccount">
    /// A <c>LedgerDimensionBase</c> value.
    /// </param>
    /// <param name="_yearEndOption">
    /// Represents the current <c>LedgerFundYearEndOption</c> carry forward option of the year end process.
    /// </param>
    /// <returns>
    /// true if <c>SourceDocumentDistribution</c> amount needs to be carried forward; otherwise false.
    /// </returns>
    private boolean doCarryForwardBudget(LedgerDimensionBase _fundLedgerAccount, LedgerFundYearEndOption _yearEndOption)
    {
        LedgerFund  ledgerFund;
        List        filteredDistList    = new List(Types::Record);

        if (!ledgerFundMapOnClient.exists(_fundLedgerAccount))
        {
            ledgerFundMapOnClient = PurchYearEndProcess::lookupLedgerFundForAccountDim(_fundLedgerAccount, ledgerFundMapOnClient);
        }

        ledgerFund = ledgerFundMapOnClient.lookup(_fundLedgerAccount);

        if (ledgerFund.OverrideYearEndOption == NoYes::No && _yearEndOption == LedgerFundYearEndOption::ProcessAndCarryForwardBudget)
        {
            return true;
        }

        if ((ledgerFund.OverrideYearEndOption == NoYes::Yes) && (ledgerFund.YearEndOption == LedgerFundYearEndOption::ProcessAndCarryForwardBudget))
        {
            return true;
        }

        if (!ledgerFund && _yearEndOption == LedgerFundYearEndOption::ProcessAndCarryForwardBudget)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBudgetModelByLedgerDimensionAndDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>BudgetModel</c> table record for a specified ledger dimension and transaction date.
    /// </summary>
    /// <param name="_ledgerDimension">
    /// The ledger dimension.
    /// </param>
    /// <param name="_date">
    /// The transaction date.
    /// </param>
    /// <returns>
    /// A <c>BudgetModel</c> record buffer.
    /// </returns>
    private BudgetModel findBudgetModelByLedgerDimensionAndDate(LedgerDimensionBase _ledgerDimension,
                                                                date _date)
    {
        return BudgetControlLedgerDimensionHelper::findBudgetModelByLedgerDimensionAndDate(Ledger::current(),
            _ledgerDimension, _date);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBudgetTransactionHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>BudgetTransactionHeader</c> table record for a specified budget model.
    /// </summary>
    /// <param name="_modelId">
    /// The budget model ID.
    /// </param>
    /// <returns>
    /// A <c>BudgetTransactionHeader</c> record ID.
    /// </returns>
    private RecId findBudgetTransactionHeader(BudgetModelId _modelId)
    {
        BudgetModelId   modelId;
        RecId           transId;
        ListEnumerator  modelsEnumerator = budgetModels.getEnumerator();

        while (modelsEnumerator.moveNext())
        {
            [modelId, transId] = modelsEnumerator.current();

            if (modelId == _modelId)
            {
                return transId;
            }
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generatePreviewJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Generates the list of temporary subledger journal entries to be displayed in preview mode in the
    ///    subledger journal form.
    /// </summary>
    /// <returns>
    ///    true if the journal is generated successfully; otherwise, false.
    /// </returns>
    public boolean generatePreviewJournal()
    {
        optPreview = true;
        showProgress = false;
        return this.processAll();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextPurchId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the ID of the next purchase order to process.
    /// </summary>
    /// <returns>
    /// The ID of the next purchase order to process.
    /// </returns>
    private PurchId getNextPurchId()
    {
        PurchId purchId = '';

        if (poListEnumerator.moveNext())
        {
            purchId = poListEnumerator.current();
        }

        return purchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the process.
    /// </summary>
    private void initProcess()
    {
        TaxParameters taxParams;

        fiscalCalendarRec = FiscalCalendar::findByCalendarId(fiscalCalendarID);
        prevFiscalYearRec = FiscalCalendarYear::findByCalendarYearName(fiscalCalendarRec.RecId, prevFiscalYearName);
        ledgerParams = LedgerParameters::find();
        optEncEnabled = ledgerParams.IsEncumbranceProcessEnabled;
        taxParams = TaxParameters::find();
        optApplyUsTaxRules =  taxParams.PurchTaxOnOperations == NoYes::Yes;
        jdEngine = JournalizingDefinitionEngine::construct();
        // Construct an instance of the budget transaction manager to track the dimension attributes
        // that are not in the active budget structure.
        budgetTransactionManager = BudgetTransactionManager::construct();
        if (poList)
        {
            poListEnumerator = poList.getEnumerator();
        }
        budgetReservationEncumbranceDetails = new Map(Types::Int64, Types::Class);
        topSourceDocumentLineRecIds = new Set(Types::Int64);
        budgetTransactionLineRecIdsSet = new Set(Types::Int64);
        ledgerFundMapOnClient = new Map(Types::Int64, Types::Record);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBudgetControlEnabledForCommitment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if Budget control has been enabled for commitment documents.
    /// </summary>
    /// <returns>
    /// true if Budget control has been enabled for commitment documents; otherwise, false.
    /// </returns>
    public boolean isBudgetControlEnabledForCommitment()
    {
        LedgerRecId ledgerRecId = Ledger::current();

        if (Ledger::isLedgerBudgetControlEnabled(LedgerRecId)
            && BudgetControlConfiguration::isSourceIntegratorEnabled(ledgerRecId, BudgetControlSourceIntegrator::PurchCommitment_PSN))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBudgetControlEnabledForPO</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the budget control has been enabled for purchase orders.
    /// </summary>
    /// <returns>
    /// true if Budget control has been enabled for purchase orders; otherwise, false.
    /// </returns>
    public boolean isBudgetControlEnabledForPO()
    {
        LedgerRecId ledgerRecId = Ledger::current();
        boolean     budgetControlEnabledForPO;

        budgetControlEnabledForPO = Ledger::isLedgerBudgetControlEnabled(ledgerRecId)
            && BudgetControlConfiguration::isSourceIntegratorEnabled(ledgerRecId, BudgetControlSourceIntegrator::PurchaseOrder);

        return budgetControlEnabledForPO;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPurchOrderSelected</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether a purchase order is selected for the purchase order year end process.
    /// </summary>
    /// <param name="_purchId">
    ///    The ID of the purchase order.
    /// </param>
    /// <returns>
    ///    true if the purchase order is selected; otherwise, false.
    /// </returns>
    private boolean isPurchOrderSelected(PurchId _purchId)
    {
        ListEnumerator  purchListEnum;
        PurchId         current;

        purchListEnum = poList.getEnumerator();
        while (purchListEnum.moveNext())
        {
            current = purchListEnum.current();

            if (current == _purchId)
            {
                return true;
            }
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new instance of the class.
    /// </summary>
    protected void new()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    /// <summary>
    /// Packs the fields of the instance into a container.
    /// </summary>
    /// <returns>
    /// A container with all private fields.
    /// </returns>
    public container pack()
    {
        container      packedContainer;
        ListEnumerator listEnum;

        poListContainer = conNull();

        if (poList != null)
        {
            listEnum = poList.getEnumerator();
            while (listEnum.moveNext())
            {
                poListContainer += listEnum.current();
            }
        }

        packedContainer = [currentVersion, #CurrentList];
        return packedContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBatchJobId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the ID of batch header record in parallel execution.
    /// </summary>
    /// <param name="_batchJobId">
    /// The ID of the parent batch job.
    /// </param>
    /// <returns>
    /// The current or new value of the field.
    /// </returns>
    public RefRecId parmBatchJobId(RefRecId _batchJobId = batchJobId)
    {
        batchJobId = _batchJobId;
        return batchJobId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCarryForwardBudgetTransactionCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the carry forward budget code value.
    /// </summary>
    /// <param name="_carryForwardBudgetTransactionCode">
    /// The carry forward budget transaction code; optional.
    /// </param>
    /// <returns>
    /// The current or new value of the field.
    /// </returns>
    public RefRecId parmCarryForwardBudgetTransactionCode(RefRecId _carryForwardBudgetTransactionCode = carryForwardBudgetTransactionCode)
    {
        carryForwardBudgetTransactionCode = _carryForwardBudgetTransactionCode;
        return carryForwardBudgetTransactionCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmClosingFiscalCalendarPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the closing fiscal calendar period value.
    /// </summary>
    /// <param name="_closingFiscalCalendarPeriod">
    /// The closing fiscal calendar period value; optional.
    /// </param>
    /// <returns>
    /// The closing fiscal calendar period value.
    /// </returns>
    public FiscalCalendarPeriodRecId parmClosingFiscalCalendarPeriod(
        FiscalCalendarPeriodRecId _closingFiscalCalendarPeriod = closingFiscalCalendarPeriod)
    {
        closingFiscalCalendarPeriod = _closingFiscalCalendarPeriod;
        return closingFiscalCalendarPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmClosingPostingDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the closing posting date value.
    /// </summary>
    /// <param name="_closingPostingDate">
    /// The closing posting date value; optional.
    /// </param>
    /// <returns>
    /// The closing posting date value.
    /// </returns>
    public TransDate parmClosingPostingDate(TransDate _closingPostingDate = closingPostingDate)
    {
        closingPostingDate = _closingPostingDate;
        return closingPostingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFiscalCalendarID</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the fiscal calendar Id value.
    /// </summary>
    /// <param name="_fiscalCalendarID">
    /// The fiscal calendar ID value; optional.
    /// </param>
    /// <returns>
    /// The fiscal calendar ID value.
    /// </returns>
    public FiscalCalendarID parmFiscalCalendarID(FiscalCalendarID _fiscalCalendarID = fiscalCalendarID)
    {
        fiscalCalendarID = _fiscalCalendarID;
        return fiscalCalendarID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsSubProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the boolean field indicating that the object is a sub-process.
    /// </summary>
    /// <param name="_isSubProcess">
    /// A new value for the field; optional.
    /// </param>
    /// <returns>
    /// The current or new value of the field.
    /// </returns>
    public boolean parmIsSubProcess(boolean _isSubProcess = isSubProcess)
    {
        isSubProcess = _isSubProcess;
        return isSubProcess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOpeningFiscalCalendarPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the opening fiscal calendar period value.
    /// </summary>
    /// <param name="_openingFiscalCalendarPeriod">
    /// The opening fiscal calendar period value; optional.
    /// </param>
    /// <returns>
    /// The opening fiscal calendar period value.
    /// </returns>
    public FiscalCalendarPeriodRecId parmOpeningFiscalCalendarPeriod(
        FiscalCalendarPeriodRecId _openingFiscalCalendarPeriod = openingFiscalCalendarPeriod)
    {
        openingFiscalCalendarPeriod = _openingFiscalCalendarPeriod;
        return openingFiscalCalendarPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOpeningPostingDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the opening posting date value.
    /// </summary>
    /// <param name="_openingPostingDate">
    /// The opening posting date value; optional.
    /// </param>
    /// <returns>
    /// The opening posting date value.
    /// </returns>
    public TransDate parmOpeningPostingDate(TransDate _openingPostingDate = openingPostingDate)
    {
        openingPostingDate = _openingPostingDate;
        return openingPostingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOriginalBudgetTransactionCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the original budget code.
    /// </summary>
    /// <param name="_originalBudgetTransactionCode">
    /// The original budget transaction code; optional.
    /// </param>
    /// <returns>
    /// The current or new value of the field.
    /// </returns>
    public RefRecId parmOriginalBudgetTransactionCode(RefRecId _originalBudgetTransactionCode = originalBudgetTransactionCode)
    {
        originalBudgetTransactionCode = _originalBudgetTransactionCode;
        return originalBudgetTransactionCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPOList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the list of Purchase Orders.
    /// </summary>
    /// <param name="_poList">
    /// The list of Purchase Orders; optional.
    /// </param>
    /// <returns>
    /// The list of Purchase Orders.
    /// </returns>
    public List parmPOList(List _poList = poList)
    {
        poList = _poList;
        return poList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrevFiscalYearEndDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the end date of the previous fiscal year.
    /// </summary>
    /// <param name="_fiscalYearEndDate">
    /// The Fiscal Year end date value; optional.
    /// </param>
    /// <returns>
    /// The Fiscal Year end date value.
    /// </returns>
    public TransDate parmPrevFiscalYearEndDate(TransDate _fiscalYearEndDate = prevFiscalYearEndDate)
    {
        prevFiscalYearEndDate = _fiscalYearEndDate;
        return prevFiscalYearEndDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrevFiscalYearName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the fiscal calendar year name.
    /// </summary>
    /// <param name="_fiscalYearName">
    /// The fiscal calendar year name; optional.
    /// </param>
    /// <returns>
    /// The fiscal calendar year name.
    /// </returns>
    public FiscalYearName parmPrevFiscalYearName(FiscalYearName _fiscalYearName = prevFiscalYearName)
    {
        prevFiscalYearName = _fiscalYearName;
        return prevFiscalYearName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrevFiscalYearStartDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the start date of the prevous fiscal year.
    /// </summary>
    /// <param name="_fiscalYearStartDate">
    /// The previous fiscal year start date value; optional.
    /// </param>
    /// <returns>
    /// The fiscal year start date value.
    /// </returns>
    public TransDate parmPrevFiscalYearStartDate(TransDate _fiscalYearStartDate = prevFiscalYearStartDate)
    {
        prevFiscalYearStartDate = _fiscalYearStartDate;
        return prevFiscalYearStartDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowProgress</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the Boolean field that controls the progress bar dialog box.
    /// </summary>
    /// <param name="_showProgress">
    ///    A new value for the field; optional.
    /// </param>
    /// <returns>
    ///    The current or new value of the field.
    /// </returns>
    public boolean parmShowProgress(boolean _showProgress = showProgress)
    {
        showProgress = _showProgress;
        return showProgress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmYearEndOption</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the year end option value.
    /// </summary>
    /// <param name="_yearEndOption">
    /// The year end option value; optional.
    /// </param>
    /// <returns>
    /// The year end option value.
    /// </returns>
    public PurchYearEndOption parmYearEndOption(PurchYearEndOption _yearEndOption = yearEndOption)
    {
        yearEndOption = _yearEndOption;
        return yearEndOption;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postBudgetTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts budget transactions for the carry-forward budget to the ledger.
    /// </summary>
    private void postBudgetTransactions()
    {
        if (optBudgetPost && !optPreview)
        {
            budgetTransactionMultiPost.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCarryForwardBudgetTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and posts budget transactions for a top parent source document line and related child
    /// source document lines when carrying the budget forward to the next year.
    /// </summary>
    /// <param name="_topParentSourceDocumentLineRecId">
    /// The <c>RecId</c> value of the current top parent source document line for which to post the carry
    /// forward budget transactions.
    /// </param>
    private void postCarryForwardBudgetTransactions(RecId _topParentSourceDocumentLineRecId)
    {
        //Retrieve the Budget Reservation details from cache
        if (optBudgetCarryForward && !optPreview
            && budgetReservationEncumbranceDetails.exists(_topParentSourceDocumentLineRecId))
        {
            currentBudgetDetails = budgetReservationEncumbranceDetails.lookup(_topParentSourceDocumentLineRecId);

            if (currentBudgetDetails)
            {
                budgetModels = new List(Types::Container);
                budgetTransactionMultiPost = BudgetTransactionMultiPost::construct();
                ttsbegin;
                this.createBudgetTransactionLines(currentBudgetDetails, this.parmCarryForwardBudgetTransactionCode(),
                    BudgetTransactionType::CarryForwardBudget, openingPostingDate);
                this.postBudgetTransactions();
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postClosingBudgetTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and posts negative budget transactions for a top parent source document line and related child source document lines to reduce the budget in the closing year.
    /// </summary>
    private void postClosingBudgetTransactions()
    {
        // check that the conditions for creating Budget Transaction Lines are met
        if (optBudgetCarryForward && !optPreview
            && currentBudgetDetails)
        {
            budgetModels = new List(Types::Container);
            budgetTransactionMultiPost = BudgetTransactionMultiPost::construct();
            ttsbegin;
            this.createBudgetTransactionLines(currentBudgetDetails, this.parmOriginalBudgetTransactionCode(),
                BudgetTransactionType::OriginalBudget, closingPostingDate);
            this.postBudgetTransactions();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processAll</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Processes all the purchase orders in the list.
    /// </summary>
    /// <returns>
    ///    true if the processing was successful for all purchase orders; otherwise, false.
    /// </returns>
    private boolean processAll()
    {
        #OCCRetryCount

        PurchId currPurchId;
        int     poCount = 0;
        boolean result = true;
        boolean success = true;

        if (this.validateProcessParameters())
        {
            doRecordBudgetEncumbranceAsClosing = PublicSectorUtils::isPurchYearEndEnabled()
                && FiscalCalendarPeriod::find(this.parmClosingFiscalCalendarPeriod()).Type == FiscalPeriodType::Closing;

            this.progressStart(poList.elements());

            currPurchId = this.getNextPurchId();

            while (currPurchId)
            {
                poCount++;
                this.progressUpdate(poCount);
                try
                {
                    success = this.processPurchOrder(currPurchId);

                    if (success && !optPreview)
                    {
                        info(strFmt("@SYS325163", currPurchId)); //Purchase order was processed successfully.
                    }
                    result = result & success;

                    //Capture any scenarios that don't throw an exception
                    if (!success)
                    {
                        error(strFmt("@SYS309608", currPurchId));
                    }
                }
                catch (Exception::Deadlock)
                {
                    if (xSession::currentRetryCount() >= #RetryNum)
                    {
                        throw Exception::Deadlock;
                    }
                    else
                    {
                        retry;
                    }
                }
                catch (Exception::UpdateConflict)
                {
                    if (appl.ttsLevel() == 0)
                    {
                        if (xSession::currentRetryCount() >= #RetryNum)
                        {
                            throw Exception::UpdateConflictNotRecovered;
                        }
                        else
                        {
                            retry;
                        }
                    }
                    else
                    {
                        throw Exception::UpdateConflict;
                    }
                }
                catch (Exception::Error)
                {
                    result = false;
                    error(strFmt("@SYS309608", currPurchId));
                    if (PurchLineManualCorrectionPurchTableUnblockYearEndFlight::instance().isEnabled())
                    {
                        warning("@SCM:YearEndProcessingPurchOrderWarning");
                    }
                }
                catch (Exception::Break)
                {
                    //error should be already reported; getJournalizingDefinition can throw this exception to break processing of PO
                    result = false;
                }

                //Clear the Sets below between POs so we only track the current
                topSourceDocumentLineRecIds = new Set(Types::Int64);
                budgetTransactionLineRecIdsSet = new Set(Types::Int64);

                currPurchId = this.getNextPurchId();
            } //while purchListEnum.moveNext

            this.progressEnd();
        }
        else
        {
            result = false;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processCurrentLineForBudget</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the budget functionality for the current top parent source document line for closing and
    /// opening accounting events.
    /// </summary>
    /// <param name="_closing">
    /// A Boolean value that indicates whether the event is closing or opening.
    /// </param>
    /// <param name="_topParentSourceDocumentLineRecId">
    /// The record ID of the current top parent source document line for which to process the budget
    /// functionality.
    /// </param>
    protected void processCurrentLineForBudget(boolean _closing,
                                               RecId _topParentSourceDocumentLineRecId)
    {
        SourceDocumentLine  topParentSourceDocumentLine = SourceDocumentLine::find(_topParentSourceDocumentLineRecId);
        SourceDocumentLineItem sourceDocumentLineItem;

        if (_closing)
        {
            //CLOSING

            currentBudgetDetails = BudgetSourceSourceDocumentLine::getBudgetSourceInquiryDetails(topParentSourceDocumentLine);

            //Cache the Budget Reservation details so they can be retrieved during the Opening process
            //The caching needs to be done before the relief of budget encumbrances
            if (optBudgetCarryForward && !optPreview)
            {
                budgetReservationEncumbranceDetails.insert(topParentSourceDocumentLine.RecId, currentBudgetDetails);
            }

            // relieve budget encumbrances
            this.relieveBudgetEncumbrances(topParentSourceDocumentLine);

            //create Budget transactions to offset the carry forward budget amount in the closing year
            this.postClosingBudgetTransactions();

            sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(topParentSourceDocumentLine);

            this.initializeLineItemForYearEnd(sourceDocumentLineItem,
                dateNull(),
                closingPostingDate);

            //Delete project commitments
            ProjectCommitmentFacade::deleteProjectCommitments(topParentSourceDocumentLine.RecId, true, openingPostingDate);
        }
        else
        {
            //OPENING

            //if budget carry-forward, create budget transactions
            this.postCarryForwardBudgetTransactions(_topParentSourceDocumentLineRecId);

            // Create or Edit an existing Commitment Document if France and budget control is enabled
            if (PublicSectorUtils::isFrenchRegulatoryEnabled() && this.isBudgetControlEnabledForCommitment())
            {
                this.createOrAddCommitmentLine(_topParentSourceDocumentLineRecId);
            }

            //encumber budget in new year
            this.createBudgetEncumbrances(topParentSourceDocumentLine);

            sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(topParentSourceDocumentLine);
            this.initializeLineItemForYearEnd(sourceDocumentLineItem,
                openingPostingDate);

            //Create project commitments
            ProjectCommitmentFacade::updateProjectCommitments(SourceDocumentLineItem::newFromSourceDocumentLine(topParentSourceDocumentLine));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processingPeriodEndEventHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process budget for the period end event.
    /// </summary>
    public void processingPeriodEndEventHandler()
    {
        PurchLine   purchLine;

        while select RecId from currentSourceDocumentLine
            where currentSourceDocumentLine.SourceDocumentHeader == currentPurchOrder.SourceDocumentHeader
               && currentSourceDocumentLine.ParentSourceDocumentLine == 0
            notExists join purchLine
                where purchLine.SourceDocumentLine == currentSourceDocumentLine.RecId
                   && purchLine.IsDeleted
        {
            topSourceDocumentLineRecIds.add(currentSourceDocumentLine.RecId);
            this.processCurrentLineForBudget(true, currentSourceDocumentLine.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processingPeriodOpenEventHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process budget for the period end event.
    /// </summary>
    public void processingPeriodOpenEventHandler()
    {
        topSourceDocumentLineRecIdsEnumerator = topSourceDocumentLineRecIds.getEnumerator();

        while (topSourceDocumentLineRecIdsEnumerator.moveNext())
        {
            this.processCurrentLineForBudget(false, topSourceDocumentLineRecIdsEnumerator.current());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processPurchOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Processes a purchase order, determined by ID.
    /// </summary>
    /// <param name="_purchId">
    ///    The ID of the purchase order to process.
    /// </param>
    /// <returns>
    ///    true if the process was successful; otherwise, false.
    /// </returns>
    [Hookable(false)]
    protected boolean processPurchOrder(PurchId _purchId)
    {
        boolean processPO = false;
        SourceDocumentProcessorFacade sourceDocumentProcessorFacade;

        // Set these values only when the region context is France
        if (PublicSectorUtils::isFrenchRegulatoryEnabled() && PublicSectorUtils::isPurchYearEndEnabled())
        {
            purchaseLineAmountsCalculate = new PurchaseLineAmountsCalculate_PSN();
            purchaseLineAmountsCalculate.populateAmounts(_purchId);
        }

        if (PurchYearEndProcess::isPurchOrderValidForProcess(_purchId, prevFiscalYearStartDate, prevFiscalYearEndDate, true))
        {
            foundAccountWithDisabledBudgetControl = false;
            this.setProcessingFlags(yearEndOption);

            ttsbegin;

            currentPurchOrder = PurchTable::find(_purchId, true);

            sourceDocumentProcessorFacade = SourceDocumentProcessorFacade::construct();

            if (this.isBudgetControlEnabledForPO())
            {
                sourceDocumentProcessorFacade.processingPeriodEndImplEventHandler += eventhandler(this.processingPeriodEndEventHandler);
                sourceDocumentProcessorFacade.processingPeriodOpenImplEventHandler += eventhandler(this.processingPeriodOpenEventHandler);
            }

            sourceDocumentProcessorFacade.submitYearEndSourceDocImplementation(currentPurchOrder, closingPostingDate, openingPostingDate, this.parmClosingFiscalCalendarPeriod(), optPreview);

            if (!optPreview)
            {
                currentPurchOrder.AccountingDate = openingPostingDate;
                currentPurchOrder.doUpdate();
            }

            BudgetControlProcessor::instance().parmIsPurchYearEndProcess(true);

            ttscommit;

            this.reportWarnings();

            processPO = true;
        }

        return processPO;
    }

]]></Source>
			</Method>
			<Method>
				<Name>progressEnd</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Hides the progress bar dialog box.
    /// </summary>
    protected void progressEnd()
    {
        if (showProgress)
        {
            this.progressKill();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>progressStart</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Shows the progress indicator.
    /// </summary>
    /// <param name="_total">
    ///    The total count of the purchase orders to process.
    /// </param>
    private void progressStart(int _total)
    {
        if (showProgress)
        {
            this.progressInit("@SYS306442", _total, '');
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>progressUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the progress indicator.
    /// </summary>
    /// <param name="_count">
    ///    A current purchase order count.
    /// </param>
    private void progressUpdate(int _count)
    {
        if (showProgress)
        {
            progress.setCount(_count);
            progress.setText(strFmt("@SYS306443", _count));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>relieveBudgetEncumbrances</Name>
				<Source><![CDATA[
    /// <summary>
    /// Relieves budget encumbrances for a source document line in the old year.
    /// </summary>
    /// <param name="_sourceLine">
    /// Parent source document line instance
    /// </param>
    private void relieveBudgetEncumbrances(SourceDocumentLine _sourceLine)
    {
        if (!optPreview)
        {
            BudgetControlSourceDocumentProcessor::submitSourceDocLineToReturnRemaining(
                _sourceLine,
                closingPostingDate,
                null,
                curuserid(),
                doRecordBudgetEncumbranceAsClosing);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reportWarnings</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts warning messages to the Infolog.
    /// </summary>
    protected void reportWarnings()
    {
        PurchId purchId = currentPurchOrder.PurchId;

        //Show warning about disabled budget control for an account with carry-forward budget
        if (foundAccountWithDisabledBudgetControl)
        {
            warning(strFmt("@SYS321703", purchId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs the process.
    /// </summary>
    public void run()
    {
        optPreview = false;

        if (isSubProcess || poList.elements() < parallelExecutionThreshold)
        {
            this.processAll();
        }
        else
        {
            this.scheduleParallelExecution();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>scheduleParallelExecution</Name>
				<Source><![CDATA[
    /// <summary>
    /// Schedules parallel execution of the process.
    /// </summary>
    private void scheduleParallelExecution()
    {
        BatchHeader header;
        ListEnumerator poListEnum = poList.getEnumerator();
        int i;
        List subList;
        PurchYearEndProcess subTask;

        header = BatchHeader::construct();
        batchJobId = header.parmBatchHeaderId();
        header.parmCaption(this.batchInfo().parmCaption());
        header.parmLogLevel(BatchLogLevel::Always);

        // Build sub-tasks for each chunk to process
        i = 0;
        subList = new List(Types::String);
        while (poListEnum.moveNext())
        {
            subList.addEnd(poListEnum.current());
            i++;

            if (i >= parallelExecutionBatchSize)
            {
                subTask = this.cloneForSubProcess();
                subTask.parmPOList(subList);
                header.addTask(subTask);

                // Reset the sublist and start counting for next chunk
                subList = new List(Types::String);
                i = 0;
            }
        }

        // Any added to the list after the last chunk need to be processed as well
        if (i > 0)
        {
            subTask = this.cloneForSubProcess();
            subTask.parmPOList(subList);
            header.addTask(subTask);
        }

        header.save();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setProcessingFlags</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the processing values for the specified processing option.
    /// </summary>
    /// <param name="_option">
    /// The processing option.
    /// </param>
    protected void setProcessingFlags(PurchYearEndOption _option)
    {
        if (PublicSectorUtils::isPurchYearEndEnabled())
        {
            optBudgetCarryForward = true;
            optBudgetPost = optBudgetCarryForward;
        }
        else
        {
            optBudgetCarryForward = false;
            optBudgetPost = false;

            if (_option == PurchYearEndOption::ProcessAndCarryForwardBudget)
            {
                optBudgetCarryForward = true;
            }

            optBudgetPost = optBudgetCarryForward;// && ledgerParams.IsBudgetAppropriationEnabled;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    /// <summary>
    /// Packs the fields of the instance into a container.
    /// </summary>
    /// <param name="_packedClass">
    /// Packed contents of the instance.
    /// </param>
    /// <returns>
    /// true if the process was successful; otherwise, false.
    /// </returns>
    public boolean unpack(container _packedClass)
    {
        Version version = RunBase::getVersion(_packedClass);

        switch (version)
        {
            case currentVersion:
                [version, #CurrentList] = _packedClass;
                poList = Global::con2List(poListContainer);
                break;

            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateExtendedProcessParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides a method that validates the extended process parameters in vendor-specific versions of the
    /// class.
    /// </summary>
    /// <returns>
    /// true if extended parameters are valid; otherwise, false.
    /// </returns>
    public boolean validateExtendedProcessParameters()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateProcessParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the process parameters from the form.
    /// </summary>
    /// <returns>
    /// true if parameters are valid; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method will be overridden in the public sector version.
    /// </remarks>
    public boolean validateProcessParameters()
    {
        FiscalCalendarPeriod                period;
        JournalizingDefinitionPurchTrans    jdPurchTrans;
        VendInvoiceInfoSubTable             invoiceSubInfo;
        VendInvoiceInfoTable                invoiceInfo;
        boolean                             mayNeedBudgetCarryForward;
        BudgetTransactionCode               originalBudgetCodeRec;
        BudgetTransactionCode               carryForwardBudgetCodeRec;
        boolean                             originalBudgetCodeError;
        boolean                             carryForwardBudgetCodeError;
        boolean                             originalBudgetCodeExist = false;
        boolean                             carryForwardBudgetCodeExist = false;
        boolean                             result = true;

        this.initProcess();

        //do not repeat validation for subprocess
        if (isSubProcess)
        {
            return true;
        }

        //check journalizing definitions
        if (optEncEnabled)
        {
            select firstonly jdPurchTrans
                where jdPurchTrans.PurchasingTransactionType == PurchasingTransactionType::PurchaseOrderYearEnd;

            if (!jdPurchTrans)
            {
                result = checkFailed("@SYS303883");
            }

            select firstonly jdPurchTrans
                where jdPurchTrans.PurchasingTransactionType == PurchasingTransactionType::PurchaseOrder;

            if (!jdPurchTrans)
            {
                result = checkFailed("@SYS303883");
            }
        }

        // Have the appropriate fields been supplied
        if (!prevFiscalYearRec)
        {
            result = checkFailed(strFmt("@SYS26332", "@SYS127885"));
        }

        //Closing fiscal period
        period = FiscalCalendarPeriod::find(closingFiscalCalendarPeriod);

        if (!period)
        {
            result = checkFailed("@SYS303879");
        }
        else
        {
            if (period.currentLedgerPeriodStatus() != FiscalPeriodStatus::Open)
            {
                result = checkFailed("@SYS303880");
            }

            if (!LedgerFiscalCalendar::checkModuleIsOpen(SysModule::Ledger, closingPostingDate, period))
            {
                result = checkFailed("@SYS303896");
            }
        }

        //opening fiscal period
        //note: for "Expense and accrue liability" option, we normally don't create and post any SubLedger lines
        // in opening fiscal year; therefore opening period does not seem to be needed. However, for Inventoried (stocked)
        // items option Expense is replaced with "Process with Budget Carry Forward", so opening period might be needed for this
        period = FiscalCalendarPeriod::find(openingFiscalCalendarPeriod);

        if (!period)
        {
            result = checkFailed(strFmt("@SYS26332", "@SYS303600"));
        }
        else
        {
            if (period.currentLedgerPeriodStatus() != FiscalPeriodStatus::Open)
            {
                result = checkFailed("@SYS303895");
            }

            if (!LedgerFiscalCalendar::checkModuleIsOpen(SysModule::Ledger, openingPostingDate, period))
            {
                result = checkFailed("@SYS303897");
            }
        }

        //check PO list is not empty
        if (poList == null || poList.elements() == 0)
        {
            result = checkFailed("@SYS308570");
        }
        else
        {
            //check unposted invoices
            while select OrigPurchId from invoiceSubInfo join invoiceInfo
                where  invoiceSubInfo.TableRefId == invoiceInfo.TableRefId
                    && invoiceSubInfo.ParmId     == invoiceInfo.ParmId
                    && invoiceInfo.ParmJobStatus != ParmJobStatus::Executed
            {
                if (this.isPurchOrderSelected(invoiceSubInfo.OrigPurchId))
                {
                    result = checkFailed(strFmt("@SCM:YearEndProcessingUnpostedInvoice", invoiceSubInfo.OrigPurchId));
                }
            }
        }

        //Check if we may need budget carry forward settings
        // Note: the ExpenseAndAccrueLiability option for inventoried items is automatically changed
        // to ProcessAndDoNotCarryForwardBudget; budget parameters not needed for Expense option.
        mayNeedBudgetCarryForward = yearEndOption == PurchYearEndOption::ProcessAndCarryForwardBudget;

        if (mayNeedBudgetCarryForward)
        {
            //validate number sequence
            result = result & BudgetTransactionManager::checkBudgetTransactionNumberSequence();

            originalBudgetCodeError = !originalBudgetTransactionCode;

            if (originalBudgetCodeError)
            {
                originalBudgetCodeRec = BudgetTransactionCode::findDefaultByTransactionType(BudgetTransactionType::OriginalBudget);
                originalBudgetCodeExist = originalBudgetCodeRec.RecId && !originalBudgetCodeRec.WorkflowTableSequenceNumber;
            }

            carryForwardBudgetCodeError = !carryForwardBudgetTransactionCode;

            if (carryForwardBudgetCodeError)
            {
                carryForwardBudgetCodeRec = BudgetTransactionCode::findDefaultByTransactionType(BudgetTransactionType::CarryForwardBudget);
                carryForwardBudgetCodeExist = carryForwardBudgetCodeRec.RecId && !carryForwardBudgetCodeRec.WorkflowTableSequenceNumber;
            }

            if (originalBudgetCodeError && carryForwardBudgetCodeError)
            {
                // both budget codes are empty
                if (originalBudgetCodeExist && carryForwardBudgetCodeExist)
                {
                    // both budget codes exist in table
                    result = checkFailed(strFmt("@SYS330738", "@SYS330733", "@SYS330744"));
                }
                else if (!originalBudgetCodeExist && !carryForwardBudgetCodeExist)
                {
                    // both budget codes do not exist
                    result = checkFailed(strFmt("@SYS330740", formStr(BudgetTransactionCode), "@SYS330733", "@SYS330744"));
                }
            }
            else if (originalBudgetCodeError)
            {
                // original budget code is empty

                if (originalBudgetCodeExist)
                {
                    // original budget code exist in table
                    result = checkFailed(strFmt("@SYS330737", "@SYS330733"));
                }
                else
                {
                    // no original budget codes exist in the budget transaction table
                    result = checkFailed(strFmt("@SYS330739", formStr(BudgetTransactionCode), "@SYS330733"));
                }
            }
            else if (carryForwardBudgetCodeError)
            {
                // carry forward budget code is empty
                if (carryForwardBudgetCodeExist)
                {
                    // carry forward budget code exist in table
                    result = checkFailed(strFmt("@SYS330737", "@SYS330744"));
                }
                else
                {
                    // no carry forward budget codes exist in the budget transaction table
                    result = checkFailed(strFmt("@SYS330739", formStr(BudgetTransactionCode), "@SYS330744"));
                }
            }

            // Verify budget transaction codes exist
            originalBudgetCodeRec = BudgetTransactionCode::find(originalBudgetTransactionCode);
            carryForwardBudgetCodeRec = BudgetTransactionCode::find(carryForwardBudgetTransactionCode);

            if (originalBudgetCodeRec.BudgetTransactionType != BudgetTransactionType::OriginalBudget
                && carryForwardBudgetCodeRec.BudgetTransactionType != BudgetTransactionType::CarryForwardBudget)
            {
                result = checkFailed(strFmt("@SYS330742", formStr(BudgetTransactionCode)));
            }
            else if (originalBudgetCodeRec.BudgetTransactionType != BudgetTransactionType::OriginalBudget)
            {
                result = checkFailed(strFmt("@SYS330741", "@SYS330749", formStr(BudgetTransactionCode)));
            }
            else if (carryForwardBudgetCodeRec.BudgetTransactionType != BudgetTransactionType::CarryForwardBudget)
            {
                result = checkFailed(strFmt("@SYS330741", "@SYS330750", formStr(BudgetTransactionCode)));
            }

            originalBudgetCodeError = originalBudgetTransactionCode && originalBudgetCodeRec.RecId == 0;
            carryForwardBudgetCodeError = carryForwardBudgetTransactionCode && carryForwardBudgetCodeRec.RecId == 0;

            if (originalBudgetCodeError && carryForwardBudgetCodeError)
            {
                result = checkFailed(strFmt("@SYS330736", formStr(BudgetTransactionCode)));
            }
            else if (originalBudgetCodeError)
            {
                result = checkFailed(strFmt("@SYS330735", originalBudgetCodeRec.Name, BudgetTransactionType::OriginalBudget,
                    formStr(BudgetTransactionCode)));
            }
            else if (carryForwardBudgetCodeError)
            {
                result = checkFailed(strFmt("@SYS330735", carryForwardBudgetCodeRec.Name, BudgetTransactionType::CarryForwardBudget,
                    formStr(BudgetTransactionCode)));
            }

            // Verify budget codes do not have workflow enabled
            originalBudgetCodeError = originalBudgetCodeRec.WorkflowTableSequenceNumber != "";
            carryForwardBudgetCodeError = carryForwardBudgetCodeRec.WorkflowTableSequenceNumber != "";

            if (originalBudgetCodeError && carryForwardBudgetCodeError)
            {
                result = checkFailed(strFmt("@SYS330734", formStr(BudgetTransactionCode)));
            }
            else if (originalBudgetCodeError)
            {
                result = checkFailed(strFmt("@SYS330748", "@SYS330749", formStr(BudgetTransactionCode)));
            }
            else if (carryForwardBudgetCodeError)
            {
                result = checkFailed(strFmt("@SYS330748", "@SYS330750", formStr(BudgetTransactionCode)));
            }
        }

        //validate extra parameters (in public sector this will be fund parameters validation)
        result = result & this.validateExtendedProcessParameters();

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>PurchYearEndProcess</c> class.
    /// </summary>
    /// <returns>
    ///    A new instance of the <c>PurchYearEndProcess</c> class.
    /// </returns>
    public static PurchYearEndProcess construct()
    {
        return new PurchYearEndProcess();
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    /// <summary>
    /// A standard method providing class description.
    /// </summary>
    /// <returns>
    /// Class description.
    /// </returns>
    public static ClassDescription description()
    {
        return "@SYS306442";
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPurchOrderValidForProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a purchase order is valid for the PO year end process.
    /// </summary>
    /// <param name="_purchId">
    /// An ID of the purchase order.
    /// </param>
    /// <param name="_startDate">
    /// The first day of the old fiscal year.
    /// </param>
    /// <param name="_endDate">
    /// The last day of the old fiscal year.
    /// </param>
    /// <param name="_validateQuantity">
    /// true if the quantity of goods received versus invoiced should be validated; optional.
    /// </param>
    /// <returns>
    /// true if the purchase order is valid for the process; otherwise, false.
    /// </returns>
    private static boolean isPurchOrderValidForProcess(PurchId _purchId,
                                                       TransDate _startDate,
                                                       TransDate _endDate,
                                                       boolean   _validateQuantity = false)
    {
        AccountingEvent events;
        SourceDocumentLine sourceDocumentLine;
        BudgetSourceInquiryDetails budgetDetails;
        boolean processPO = true;
        PurchTable purchTable = PurchTable::find(_purchId);

        PurchLine               purchLine;
        Qty                     receivedQty;
        Qty                     invoicedQty;
        VendPackingSlipTrans    vendPackingSlipTrans;
        VendInvoiceTrans        vendInvoiceTrans;

        if (!purchTable
            || (!purchTable.isBackOrder()
                && !purchTable.isReceived())
            || purchTable.DocumentState != VersioningDocumentState::Confirmed)
        {
            processPO = false;
        }

        if (processPO)
        {
            select firstonly RecId, AccountingDate, SourceDocumentHeader from events
                order by AccountingDate desc
                where events.SourceDocumentHeader == purchTable.SourceDocumentHeader;

            if (!events.RecId || events.AccountingDate < _startDate || events.AccountingDate > _endDate)
            {
                processPO = false;
            }
        }

        if  (processPO)
        {
            // This validation is done only for the PurchCommitments feature context
            if (_validateQuantity && PublicSectorUtils::isFrenchRegulatoryEnabled() && PublicSectorUtils::isPurchYearEndEnabled())
            {
                while select InventTransId from purchLine
                    where purchLine.PurchId == _purchId
                {
                    select sum(Qty) from vendPackingSlipTrans
                        where vendPackingSlipTrans.InventTransId == purchLine.InventTransId;
                    receivedQty = vendPackingSlipTrans.Qty;

                    if (receivedQty > 0)
                    {
                        select sum(Qty) from vendInvoiceTrans
                            where vendInvoiceTrans.InventTransId == purchLine.InventTransId;
                        invoicedQty = vendInvoiceTrans.Qty;

                        if (receivedQty > invoicedQty)
                        {
                            return checkFailed(strFmt("@SPS2329", _purchId));
                        }
                    }
                }
            }

            processPO = false;

            sourceDocumentLine = SourceDocumentLine::findBySourceDocumentHeader(purchTable.SourceDocumentHeader);
            while (!processPO && sourceDocumentLine)
            {
                // Is there a budget being tracked?
                budgetDetails = BudgetSourceSourceDocumentLine::getBudgetSourceInquiryDetails(sourceDocumentLine);

                if (budgetDetails)
                {
                    while (!processPO && budgetDetails.next())
                    {
                        processPO = budgetDetails.currentAmountTracked() != 0;
                    }
                }

                next sourceDocumentLine;
            }

            if (!processPO)
            {
                if (PurchYearEndProcess::existSubledgerJournalEntryForNotFinalized(PurchTable.SourceDocumentHeader))
                {
                    processPO = true;
                }
            }
        }

        return processPO;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existSubledgerJournalEntryForNotFinalized</Name>
				<Source><![CDATA[
    private static boolean existSubledgerJournalEntryForNotFinalized(SourceDocumentHeaderRecId _sourceDocumentHeader)
    {
        SubledgerJournalEntry subledgerJournalEntry;
        AccountingDistribution accountingDistribution;

        select firstonly RecId from subledgerJournalEntry
             exists join accountingDistribution
                where accountingDistribution.AccountingEvent == subledgerJournalEntry.AccountingEvent
                    && accountingDistribution.FinalizeAccountingEvent == 0
                    && accountingDistribution.SourceDocumentHeader == _sourceDocumentHeader;

        return subledgerJournalEntry.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupLedgerFundForAccountDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Looks up the <c>LedgerFund</c> record based on the passed-in <c>LedgerDimension</c>
    /// </summary>
    /// <param name="_ledgerDimension">
    /// A <c>LedgerDimension</c> value.
    /// </param>
    /// <param name="_ledgerFundMap">
    /// A <c>Map</c> containing the passed-in <c>LedgerDimension</c> and the related <c>LedgerFund</c> record.
    /// </param>
    /// <returns>
    /// A <c>Map</c> containing the passed-in <c>LedgerDimension</c> and the related <c>LedgerFund</c> record.
    /// </returns>
    /// <remarks>
    /// The method is used for caching and is marked static to ensure it is executed on the same tier it is called from.
    /// </remarks>
    private static Map lookupLedgerFundForAccountDim(
        RecId   _ledgerDimension,
        Map     _ledgerFundMap)
    {
        DimensionAttributeLevelValueView    dimensionAttributeLevelValueView;
        DimensionAttribute                  dimensionAttribute;
        LedgerFund                          ledgerFund;

        if (_ledgerFundMap.exists(_ledgerDimension))
        {
            return _ledgerFundMap;
        }

        select DisplayValue from dimensionAttributeLevelValueView
        join BackingEntityType from dimensionAttribute
            where dimensionAttributeLevelValueView.ValueCombinationRecId == _ledgerDimension
               && dimensionAttributeLevelValueView.DimensionAttribute == dimensionAttribute.RecId
               && dimensionAttribute.BackingEntityType == tableNum(DimAttributeLedgerFund_PSN)
        join ledgerFund
            where dimensionAttributeLevelValueView.DisplayValue == ledgerFund.FundNumber;

        _ledgerFundMap.insert(_ledgerDimension, ledgerFund);

        return _ledgerFundMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    /// <summary>
    /// A standard static method implementing the process functionality called by AX menu item.
    /// </summary>
    /// <param name="_args">
    /// Standard AX <c>Args</c> object providing system parameters for the process.
    /// </param>
    public static void main(Args _args)
    {
        PurchYearEndProcess purchYearEndProcessBatch = PurchYearEndProcess::construct();

        if (!purchYearEndProcessBatch.isBudgetControlEnabledForPO()
            && !LedgerParameters::find().IsEncumbranceProcessEnabled)
        {
            error("@SYS331107");
        }
        else if (purchYearEndProcessBatch.prompt())
        {
            purchYearEndProcessBatch.parmShowProgress(true);

            if (purchYearEndProcessBatch.parmPOList().elements() >= parallelExecutionThreshold)
            {
                info(strFmt("@SYS342696", parallelExecutionThreshold));
            }

            purchYearEndProcessBatch.runOperation();

            Box::info("@SYS303888");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePurchaseOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates a list of Purchase Orders.
    /// </summary>
    /// <param name="_poListPack">
    /// A list of Purchase Orders.
    /// </param>
    /// <param name="_yearEndOption">
    /// The year end process option.
    /// </param>
    /// <param name="_oldFiscalYearStartDate">
    /// The start date of the old fiscal year.
    /// </param>
    /// <param name="_oldFiscalYearEndDate">
    /// The end date of the old fiscal year.
    /// </param>
    /// <param name="_fiscalCalendarID">
    /// The id of the fiscalcalendar; deprecated.
    /// </param>
    /// <param name="_fiscalYearName">
    /// The name of the fiscal year; deprecated.
    /// </param>
    /// <returns>
    /// A container with the list of valid Purchase Orders.
    /// </returns>
    /// <remarks>
    /// This static methods ensures that processing happens on the server.
    /// </remarks>
    public static container validatePurchaseOrders(
        container           _poListPack,
        PurchYearEndOption  _yearEndOption,
        TransDate           _oldFiscalYearStartDate,
        TransDate           _oldFiscalYearEndDate,
        FiscalCalendarID    _fiscalCalendarID = "",
        FiscalYearName      _fiscalYearName = ""
        )
    {
        PurchId             purchId;
        boolean             ok;
        ListEnumerator      poListEnum;
        List                poList;

        poList = new List(Types::String);

        // Go through the list of purchase orders and validate they can be processed.
        poListEnum = List::create(_poListPack).getEnumerator();
        while (poListEnum.moveNext())
        {
            purchId = poListEnum.current();

            ok = PurchYearEndProcess::isPurchOrderValidForProcess(purchId,
                _oldFiscalYearStartDate, _oldFiscalYearEndDate);

            if (ok)
            {
                poList.addEnd(purchId);
            }
        }

        return poList.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    final boolean isRetryable() 
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>