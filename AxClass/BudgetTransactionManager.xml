<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BudgetTransactionManager</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>BudgetTransactionManager</c> class manages budget transactions with methods that support the
///    budget transactions continuous number sequence and custom lookups.
/// </summary>
class BudgetTransactionManager
{
    NumberSeqFormHandler numberSeqFormHandler;
    Set dimAttsNotEnabledForBudget;
    Set ledgerDimsCheckedForBudgetEnabled;
    Set defaultDimsCheckedForBudgetEnabled;

    // Key:   String that is the combination of the Main Account RecId and the default dimensions RecId.
    // Value: RecId of a DAVC for a LedgerDimensionBudget.
    Map     budgetLedgerDimensions;

    recId   mainAccountAttributeRecId;
    boolean isMainAccountInBudgetDimensions;

    #BudgetFaults
    #define.DefaultLedgerDimensionFieldName('LedgerDimension')

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>cacheDefaultDimAttribNotBudgetEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Caches the dimension attributes from the specified default dimensions that are not enabled for
    /// budget.
    /// </summary>
    /// <param name="_defaultDimensions">
    /// The default dimensions from which to retrieve the dimension attributes.
    /// </param>
    public void cacheDefaultDimAttribNotBudgetEnabled(DimensionDefault _defaultDimensions)
    {
        DimensionAttribute                    dimensionAttribute;
        DimensionAttributeValue               dimAttributeValue;
        DimensionAttributeValueSetItem        dimensionAttributeValueSetItem;
        BudgetPrimaryLedgerDimensionAttribute budgetPrimaryLedgerDimensionAttribute;
        recId primaryLedger = Ledger::current();

        if (!defaultDimsCheckedForBudgetEnabled.in(_defaultDimensions))
        {
            // Find all dimension attributes in the specified default dimension that are not enabled
            // for budget in the current ledger.
            while select Name from dimensionAttribute
                join DimensionAttribute from dimAttributeValue
                    where dimensionAttribute.RecId == dimAttributeValue.DimensionAttribute
                join DimensionAttributeValue from dimensionAttributeValueSetItem
                    where dimensionAttributeValueSetItem.DimensionAttributeValueSet == _defaultDimensions &&
                        dimAttributeValue.RecId == dimensionAttributeValueSetItem.DimensionAttributeValue
                notexists join budgetPrimaryLedgerDimensionAttribute
                    where budgetPrimaryLedgerDimensionAttribute.DimensionAttribute == dimAttributeValue.DimensionAttribute &&
                        budgetPrimaryLedgerDimensionAttribute.PrimaryLedger == primaryLedger
            {
                dimAttsNotEnabledForBudget.add(dimensionAttribute.Name);
            }

            defaultDimsCheckedForBudgetEnabled.add(_defaultDimensions);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cacheDimAttributesNotBudgetEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Caches the dimension attributes from the specified ledger dimension that are not enabled for the
    ///    budget.
    /// </summary>
    /// <param name="_ledgerDimension">
    ///    The ledger dimension from which to retrieve the dimension attributes.
    /// </param>
    public void cacheDimAttributesNotBudgetEnabled(LedgerDimensionBase _ledgerDimension)
    {
        DimensionAttribute                    dimensionAttribute;
        DimensionAttributeLevelValueView      valueView;
        BudgetPrimaryLedgerDimensionAttribute budgetPrimaryLedgerDimensionAttribute;
        recId primaryLedger = Ledger::current();

        if (!ledgerDimsCheckedForBudgetEnabled.in(_ledgerDimension))
        {
            // Find all dimension attributes in the specified ledger dimension that are not enabled
            // for budget in the current ledger.
            while select ValueCombinationRecId from valueView
                where valueView.ValueCombinationRecId == _ledgerDimension
                join Name, RecId from dimensionAttribute
                    where valueView.DimensionAttribute == dimensionAttribute.RecId
                notexists join budgetPrimaryLedgerDimensionAttribute where
                    budgetPrimaryLedgerDimensionAttribute.DimensionAttribute == dimensionAttribute.RecId &&
                    budgetPrimaryLedgerDimensionAttribute.PrimaryLedger == primaryLedger
            {
                dimAttsNotEnabledForBudget.add(dimensionAttribute.Name);
            }

            ledgerDimsCheckedForBudgetEnabled.add(_ledgerDimension);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceCreate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Manages the number sequence when a number is allocated when a budget transaction header is being
    ///    created.
    /// </summary>
    /// <param name="_element">
    ///    The form that uses the number sequence.
    /// </param>
    /// <param name="_budgetHeader_ds">
    ///    The data source of the form that uses the number sequence.
    /// </param>
    public void formMethodDataSourceCreate(FormRun _element, FormDataSource _budgetHeader_ds)
    {
        this.numberSeqFormHandlerBudgetTransactionId(_element, _budgetHeader_ds).formMethodDataSourceCreate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceCreatePre</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Manages the number sequence before a number is allocated when a budget transaction header is being
    ///    created.
    /// </summary>
    /// <param name="_element">
    ///    The form that uses the number sequence.
    /// </param>
    /// <param name="_budgetHeader_ds">
    ///    The data source of the form that uses the number sequence.
    /// </param>
    public void formMethodDataSourceCreatePre(FormRun _element, FormDataSource _budgetHeader_ds)
    {
        this.numberSeqFormHandlerBudgetTransactionId(_element, _budgetHeader_ds).formMethodDataSourceCreatePre();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceDelete</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Manages the number sequence during the deletion of a budget transaction header.
    /// </summary>
    /// <param name="_element">
    ///    The form where the number sequence is being used.
    /// </param>
    /// <param name="_budgetHeader_ds">
    ///    The data source of the form where the number sequence is being used.
    /// </param>
    public void formMethodDataSourceDelete(FormRun _element, FormDataSource _budgetHeader_ds)
    {
        this.numberSeqFormHandlerBudgetTransactionId(_element, _budgetHeader_ds).formMethodDataSourceDelete();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceLinkActive</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Manages the number sequence when a budget transaction header becomes active.
    /// </summary>
    /// <param name="_element">
    ///    The form where the number sequence is being used.
    /// </param>
    /// <param name="_budgetHeader_ds">
    ///    The data source of the form where the number sequence is being used.
    /// </param>
    public void formMethodDataSourceLinkActive(FormRun _element, FormDataSource _budgetHeader_ds)
    {
        this.numberSeqFormHandlerBudgetTransactionId(_element, _budgetHeader_ds).formMethodDataSourceLinkActive();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceValidateWrite</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Manages the number sequence during the validation of saving a budget transaction header.
    /// </summary>
    /// <param name="_element">
    ///    The form where the number sequence is being used.
    /// </param>
    /// <param name="_budgetHeader_ds">
    ///    The data source of the form where the number sequence is being used.
    /// </param>
    /// <returns>
    ///    true if the budget transaction number sequence passes validation; otherwise, false.
    /// </returns>
    public boolean formMethodDataSourceValidateWrite(FormRun _element, FormDataSource _budgetHeader_ds)
    {
        boolean ret = true;

        if (!this.numberSeqFormHandlerBudgetTransactionId(_element, _budgetHeader_ds).formMethodDataSourceValidateWrite())
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceWrite</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Manages the number sequence during the saving of a budget transaction header.
    /// </summary>
    /// <param name="_element">
    ///    The form where the number sequence is being used.
    /// </param>
    /// <param name="_budgetHeader_ds">
    ///    The data source of the form where the number sequence is being used.
    /// </param>
    public void formMethodDataSourceWrite(FormRun _element, FormDataSource _budgetHeader_ds)
    {
        this.numberSeqFormHandlerBudgetTransactionId(_element, _budgetHeader_ds).formMethodDataSourceWrite();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionBudget</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a budget ledger dimension reference based on the main account, default dimension, and the
    /// dimensions that are enabled for budget.
    /// </summary>
    /// <param name="_defaultAccount">
    /// The default account of the ledger dimension reference to be processed for inclusion in the budget
    /// ledger dimension.
    /// </param>
    /// <param name="_defaultDimensions">
    /// The default dimension reference to be processed for inclusion in the budget ledger dimension.
    /// </param>
    /// <param name="_errorMessage">
    /// The error message to throw if no dimensions are found for the budget ledger dimension.
    /// </param>
    /// <returns>
    /// A ledger dimension reference.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// No specified dimensions are enabled for budget.
    /// </exception>
    public LedgerDimensionBudget getLedgerDimensionBudget(
        LedgerDimensionDefaultAccount _defaultAccount,
        DimensionDefault _defaultDimensions,
        str _errorMessage)
    {
        LedgerDimensionBudget ledgerDimensionBudget =
            LedgerDimensionFacade::serviceCreateLedgerDimensionForType(
                LedgerDimensionType::Budget,
                _defaultAccount,
                _defaultDimensions);

        if (!ledgerDimensionBudget)
        {
            throw error(_errorMessage);
        }

        return ledgerDimensionBudget;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs initialization for the <c>BudgetTransactionManager</c> class.
    /// </summary>
    protected void new()
    {
        dimAttsNotEnabledForBudget = new Set(Types::String);
        ledgerDimsCheckedForBudgetEnabled = new Set(Types::Int64);
        defaultDimsCheckedForBudgetEnabled = new Set(Types::Int64);
        budgetLedgerDimensions = new Map(Types::String, Types::Int64);
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberSeqFormHandlerBudgetTransactionId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an instance of the <c>NumberSeqFormHandler</c> class for the budget transaction identifier
    ///    number sequence.
    /// </summary>
    /// <param name="_element">
    ///    The form where the number sequence is used.
    /// </param>
    /// <param name="_budgetHeader_ds">
    ///    The data source of the form where the number sequence is used.
    /// </param>
    /// <returns>
    ///    An instance of the <c>NumberSeqFormHandler</c> class for the budget transaction identifier number
    ///    sequence.
    /// </returns>
    public NumberSeqFormHandler numberSeqFormHandlerBudgetTransactionId(FormRun _element, FormDataSource _budgetHeader_ds)
    {
        NumberSequenceReference numberSequenceReference;

        if (!numberSeqFormHandler)
        {
            numberSequenceReference = BudgetParameters::numRefBudgetTransactionId();

            numberSeqFormHandler = NumberSeqFormHandler::newForm(numberSequenceReference.NumberSequenceId,
                                                                       _element,
                                                                       _budgetHeader_ds,
                                                                       fieldnum(BudgetTransactionHeader, TransactionNumber)
                                                                       );
        }

        return numberSeqFormHandler;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showWarningsDimAttsNotBudgetEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Shows warnings that dimension attributes are not enabled for the budget.
    /// </summary>
    /// <param name="_warningLabel">
    ///    The label of the warning message to provide.
    /// </param>
    /// <remarks>
    ///    The label is assumed to have a %1 replacement value that will be replaced by the dimension
    ///    attribute names from the cache.
    /// </remarks>
    public void showWarningsDimAttsNotBudgetEnabled(str _warningLabel)
    {
        SetEnumerator dimAttsEnumerator;

        if (dimAttsNotEnabledForBudget.elements() > 0)
        {
            dimAttsEnumerator = dimAttsNotEnabledForBudget.getEnumerator();

            while (dimAttsEnumerator.moveNext())
            {
                warning(strfmt(_warningLabel, dimAttsEnumerator.current()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDimensionCriteriaForAttributeValueSet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the appropriate joins and filters to the specified query to filter by the specified dimension
    /// attribute name and value pairs.
    /// </summary>
    /// <param name="_query">
    /// The query to add filters to.
    /// </param>
    /// <param name="_dimensionNameValuePairs">
    /// A map that contains the dimension attribute name and value pairs.
    /// </param>
    /// <param name="_dataSourceName">
    /// The name of the data source that contains the dimension information.
    /// </param>
    /// <param name="_dimensionFieldName">
    /// The name of the field on the data source that contains the dimension information; optional.
    /// </param>
    public static void addDimensionCriteriaForAttributeValueSet(
        Query _query,
        Map _dimensionNameValuePairs,
        str _dataSourceName,
        str _dimensionFieldName = #DefaultLedgerDimensionFieldName)
    {
        DimensionProvider   dimensionProvider;
        MapEnumerator       dimensionNameValuePairsEnumerator;

        if (_dimensionNameValuePairs &&
            _dimensionNameValuePairs.elements() > 0)
        {
            dimensionProvider = new DimensionProvider();
            dimensionNameValuePairsEnumerator = _dimensionNameValuePairs.getEnumerator();

            while (dimensionNameValuePairsEnumerator.moveNext())
            {
                //Dimension Attribute name can be translated or localized but while adding attribute filter we need to consider the non localized attribute.
                str dimensionAttributeName = DimensionAttribute::findByLocalizedName(dimensionNameValuePairsEnumerator.currentKey()).Name;
                if (!dimensionAttributeName)
                {
                    dimensionAttributeName = dimensionNameValuePairsEnumerator.currentKey();
                }

                dimensionProvider.addAttributeFilterToQuery(
                    _query,
                    _dataSourceName,
                    _dimensionFieldName,
                    DimensionComponent::DimensionAttribute,
                    dimensionNameValuePairsEnumerator.currentValue(),
                    dimensionAttributeName);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDimensionCriteriaForLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the appropriate joins and filters to the specified query to filter by the dimension attributes
    /// and values in the specified ledger dimension.
    /// </summary>
    /// <param name="_query">
    /// The query to add filters to.
    /// </param>
    /// <param name="_ledgerDimension">
    /// An identifier of a record in the <c>DimensionAttributeValueCombination</c> table.
    /// </param>
    /// <param name="_dataSourceName">
    /// The name of the data source that contains the dimension information.
    /// </param>
    /// <param name="_dimensionFieldName">
    /// The name of the field on the data source that contains the dimension information; optional.
    /// </param>
    public static void addDimensionCriteriaForLedgerDimension(
        Query _query,
        LedgerDimensionBase _ledgerDimension,
        str _dataSourceName,
        str _dimensionFieldName = #DefaultLedgerDimensionFieldName)
    {
        DimensionAttribute               dimensionAttribute;
        DimensionProvider                dimensionProvider = new DimensionProvider();
        DimensionAttributeLevelValueView valueView;

        while select AttributeValueRecId, DisplayValue, DimensionAttribute from valueView
            where valueView.ValueCombinationRecId == _ledgerDimension
            join RecId, Name from dimensionAttribute
                where dimensionAttribute.RecId == valueView.DimensionAttribute
        {
            dimensionProvider.addAttributeFilterToQuery(
                _query,
                _dataSourceName,
                _dimensionFieldName,
                DimensionComponent::DimensionAttribute,
                valueView.DisplayValue,
                dimensionAttribute.Name);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addPrimaryLedgerRangeToQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a range to the specified instance of the <c>Query</c> class for the <c>PrimaryLedger</c> field
    ///    of the <c>BudgetTransactionHeader</c> table.
    /// </summary>
    /// <param name="_query">
    ///    A instance of the <c>Query</c> class that contains a data source for the
    ///    <c>BudgetTransactionHeader</c> table.
    /// </param>
    /// <param name="_primaryLedgerId">
    ///    The record ID of the <c>Ledger</c> record; optional.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    The specified instance of the <c>Query</c> class does not contain a data source for the
    ///    <c>BudgetTransactionHeader</c> table.
    /// </exception>
    public static void addPrimaryLedgerRangeToQuery(Query _query, LedgerRecId _primaryLedgerId = Ledger::current())
    {
        QueryBuildDataSource qbs_BudgetTransactionHeader;
        QueryBuildRange qbr_PrimaryLedger;

        qbs_BudgetTransactionHeader = _query.dataSourceTable(tablenum(BudgetTransactionHeader));

        if (qbs_BudgetTransactionHeader == null || _primaryLedgerId == 0)
        {
            throw error(Error::wrongUseOfFunction(funcname()));
        }
        else
        {
            // Filter the budget transactions based on the specified primary ledger.
            qbr_PrimaryLedger = qbs_BudgetTransactionHeader.addRange(fieldnum(BudgetTransactionHeader, PrimaryLedger));
            qbr_PrimaryLedger.value(queryValue(_primaryLedgerId));
            qbr_PrimaryLedger.status(RangeStatus::Hidden);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBudgetTransactionTypeRangeToQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Adds a range to the specified instance of the <c>Query</c> class for the
    ///   <c>BudgetTransactionType</c> field of the <c>BudgetTransactionHeader</c> table.
    /// </summary>
    /// <param name = "_query">
    ///   An instance of the <c>Query</c> class that contains data source for the
    ///   <c>BudgetTransactionHeader</c> table.
    /// </param>
    /// <param name = "_budgetTransactionType">
    ///   A value of the <c>BudgetTransactionType</c> enum.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    The specified instance of the <c>Query</c> class does not contain a data source
    ///    for the <c>BudgetTransactionHeader</c> table.
    /// </exception>
    public static void addBudgetTransactionTypeRangeToQuery(Query _query, BudgetTransactionType _budgetTransactionType)
    {
        QueryBuildDataSource qbdsBudgetTransactionHeader = _query.dataSourceTable(tablenum(BudgetTransactionHeader));

        if (qbdsBudgetTransactionHeader == null)
        {
            throw error(Error::wrongUseOfFunction(funcname()));
        }

        QueryBuildRange qbrBudgetTransactionType = SysQuery::findOrCreateRange(qbdsBudgetTransactionHeader, fieldNum(BudgetTransactionHeader, BudgetTransactionType));

        qbrBudgetTransactionType.status(RangeStatus::Locked);
        qbrBudgetTransactionType.value(int2str(_budgetTransactionType));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTransactionStatusRangeToQuery</Name>
				<Source><![CDATA[
    public static void addTransactionStatusRangeToQuery(Query _query, BudgetTransactionStatus _budgetTransactionStatus)
    {
        QueryBuildDataSource qbdsBudgetTransactionHeader = _query.dataSourceTable(tablenum(BudgetTransactionHeader));

        if (qbdsBudgetTransactionHeader != null)
        {
            QueryBuildRange qbrBudgetTransactionType = SysQuery::findOrCreateRange(qbdsBudgetTransactionHeader, fieldNum(BudgetTransactionHeader, TransactionStatus));

            qbrBudgetTransactionType.status(RangeStatus::Locked);
            qbrBudgetTransactionType.value(int2str(_budgetTransactionStatus));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTransAmountToAccountingAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates an amount in the accounting currency of the company using budget exchange rates.
    /// </summary>
    /// <param name="_amountCur">
    /// The amount to convert to the accounting currency of the company.
    /// </param>
    /// <param name="_currency">
    /// The currency of the specified amount.
    /// </param>
    /// <param name="_exchangeDate">
    /// The date used to determine the exchange rate for the calculation.
    /// </param>
    /// <param name="_exchangeRateType">
    /// The exchange rate type to use; optional.
    /// </param>
    /// <param name="_suppressErrors">
    /// Determines whether messages should be logged for validation failures; optional.
    /// </param>
    /// <param name="_exchangeRate">
    /// The exchange rate to use; optional.
    /// </param>
    /// <returns>
    /// The amount in the accounting currency of the ledger.
    /// </returns>
    /// <remarks>
    /// This method should be used to set the amount in the accounting currency of the ledger when either
    /// the transaction amount or currency are set for budget transactions.If the exchange rate type is not
    /// specified, the budgeting exchange rate type will be used.
    /// </remarks>
    public static AmountMST calculateTransAmountToAccountingAmount(
        AmountCur _amountCur,
        CurrencyCode _currency,
        date _exchangeDate,
        ExchangeRateTypeRecId _exchangeRateType = 0,
        boolean _suppressErrors = false,
        ExchRate _exchangeRate = 0)
    {
        AmountMST amountMST = 0;
        CurrencyExchangeHelper currencyHelper;

        if (_amountCur != 0)
        {
            if (BudgetTransactionManager::validateCurrency(_currency, _suppressErrors))
            {
                currencyHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), _exchangeDate);
                if (_exchangeRate)
                {
                    currencyHelper.parmExchangeRate1(_exchangeRate);
                }
                if (_exchangeRateType)
                {
                    currencyHelper.parmExchangeRateTypeRecId(_exchangeRateType);
                }
                else
                {
                    currencyHelper.parmExchangeRateTypeRecId(Ledger::budgetExchangeRateType());
                }

                amountMST = currencyHelper.calculateTransactionToAccounting(_currency, _amountCur, true);
            }
        }

        return amountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBudgetTransactionNumberSequence</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the number sequence that is set up for the budget transaction identifier.
    /// </summary>
    /// <param name="_numberSequenceReference">
    ///    The number sequence reference to validate.
    /// </param>
    /// <returns>
    ///    true if the number sequence is valid for budget transactions; otherwise, false.
    /// </returns>
    public static boolean checkBudgetTransactionNumberSequence(NumberSequenceReference _numberSequenceReference = null)
    {
        boolean                 ret = true;
        NumberSequenceTable     numberSequenceTable;
        NumberSequenceReference numberSequenceReference = _numberSequenceReference;

        if (!numberSequenceReference)
        {
            // Number sequence reference to check was not passed; find the reference for the budget transaction number.
            numberSequenceReference = BudgetParameters::numRefBudgetTransactionId();
        }
        else if (NumberSequenceDatatype::find(numberSequenceReference.NumberSequenceDatatype).DatatypeId != extendedtypenum(BudgetTransactionId))
        {
            // Number sequence reference that was passed is not for budget transaction number.
            ret = AifFault::checkFailedLogFault("@SYS55194");
        }

        if (ret)
        {
            if (!numberSequenceReference)
            {
                ret = AifFault::checkFailedLogFault(strfmt("@SYS53911", "@SYS127773", enum2str(NumberSeqModule::Budget)));
            }
            else
            {
                numberSequenceTable = NumberSequenceTable::find(numberSequenceReference.NumberSequenceId);

                if (!numberSequenceTable)
                {
                    // The number sequence that was selected for the Budget Transaction Number does not exist.
                    ret = AifFault::checkFailedLogFault(strfmt("@SYS53911", numberSequenceReference.referenceLabel(), numberSequenceReference.referenceModuleLabel()));
                }
                else
                {
                    if (BudgetTransactionManager::isNumSequenceNotContinuous(numberSequenceTable))
                    {
                        // The number sequence set up for Budget Transaction Number is not continuous.
                        ret = AifFault::checkFailedLogFault(strfmt("@SYS26207", numberSequenceTable.NumberSequence));
                    }

                    if (numberSequenceTable.Blocked)
                    {
                        // The number sequence set up for Budget Transaction Number on hold.
                        ret = AifFault::checkFailedLogFault(strfmt("@SYS25068", numberSequenceTable.NumberSequence));
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNumSequenceNotContinuous</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the Number sequence is not continuous.
    /// </summary>
    /// <param name = "numberSequenceTable">
    /// The <c>NumberSequenceTable</c> record.
    /// </param>
    /// <returns>
    /// Returns true if number sequence is not continuous; otherwise false.
    /// </returns>
    protected static boolean isNumSequenceNotContinuous(NumberSequenceTable _numberSequenceTable)
    {
        return !_numberSequenceTable.Continuous;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTransactionStatusForDelete</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the current user is blocked from using the budget transaction.
    /// </summary>
    /// <param name="_budgetTransactionStatus">
    ///    The ID of a user.
    /// </param>
    /// <param name="_budgetTransactionId">
    ///    The ID of a budget transaction.
    /// </param>
    /// <returns>
    ///    true if the user is blocked from the use of the budget transaction; otherwise, false.
    /// </returns>
    public static boolean checkTransactionStatusForDelete(BudgetTransactionStatus _budgetTransactionStatus, BudgetTransactionId _budgetTransactionId)
    {
        boolean isValid = true;

        if (_budgetTransactionStatus == BudgetTransactionStatus::Completed)
        {
            // Do not allow the header to be deleted if it has been processed.
            isValid = AifFault::checkFailedLogFault(
                strfmt("@SYS127808", _budgetTransactionId),
                #UnableToDeleteCompletedBudgetTransaction);
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTransactionStatusForWrite</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether a budget transaction could be written to contain the specified
    ///    <c>BudgetTransactionStatus</c> enumeration value.
    /// </summary>
    /// <param name="_budgetTransactionStatus">
    ///    A <c>BudgetTransactionStatus</c> enumeration value.
    /// </param>
    /// <param name="_budgetTransactionId">
    ///    The ID of a budget transaction.
    /// </param>
    /// <returns>
    ///    true if a budget transaction could be written that had the specified <c>BudgetTransactionStatus</c>
    ///    enumeration value; otherwise, false.
    /// </returns>
    public static boolean checkTransactionStatusForWrite(BudgetTransactionStatus _budgetTransactionStatus, BudgetTransactionId _budgetTransactionId)
    {
        boolean isValid = true;

        if (_budgetTransactionStatus == BudgetTransactionStatus::Completed)
        {
            // Do not allow the transaction to be written if it has been processed.
            isValid = AifFault::checkFailedLogFault(
                strfmt("@SYS328424", _budgetTransactionId),
                #UnableToWriteCompletedBudgetTransaction);
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWorkflowStatusForDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a budget transaction can be deleted with the specified
    /// <c>BudgetTransactionWorkflowStatus</c> enumeration value.
    /// </summary>
    /// <param name="_workflowStatus">
    /// A <c>BudgetTransactionWorkflowStatus</c> enumeration value.
    /// </param>
    /// <param name="_budgetTransactionId">
    /// The ID of a budget transaction.
    /// </param>
    /// <param name="_isFormDataSource">
    /// A Boolean value that indicates whether the check is being made from a form.
    /// </param>
    /// <param name="_isHeader">
    /// A Boolean value that indicates whether the check is being made for a budget transaction header or
    /// line; optional.
    /// </param>
    /// <returns>
    /// true if a budget transaction could be deleted that had the specified
    /// <c>BudgetTransactionWorkflowStatus</c> enumeration value; otherwise, false.
    /// </returns>
    public static boolean checkWorkflowStatusForDelete(BudgetTransactionWorkflowStatus _workflowStatus, BudgetTransactionId _budgetTransactionId, boolean _isFormDataSource, boolean _isHeader = true)
    {
        boolean isValid = true;

        if (_workflowStatus == BudgetTransactionWorkflowStatus::Rejected ||
            _workflowStatus == BudgetTransactionWorkflowStatus::Submitted ||
            (!_isFormDataSource && (_workflowStatus == BudgetTransactionWorkflowStatus::Approved)))
        {
            if (_isHeader)
            {
                isValid = AifFault::checkFailedLogFault(strfmt("@SYS327588", _budgetTransactionId), #WorkflowStatusPreventsBudgetTransactionDelete);
            }
            else
            {
                isValid = AifFault::checkFailedLogFault("@SYS327587", #WorkflowStatusPreventsBudgetTransactionDelete);
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWorkflowStatusForUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Indicates whether a budget transaction can be updated with the specified
    /// <c>BudgetTransactionWorkflowStatus</c> enumeration value.
    /// </summary>
    /// <param name="_workflowStatus">
    /// A <c>BudgetTransactionWorkflowStatus</c> enumeration value.
    /// </param>
    /// <param name="_budgetTransactionId">
    /// The ID of a budget transaction.
    /// </param>
    /// <returns>
    /// true if a budget transaction can be updated by using the specified
    /// <c>BudgetTransactionWorkflowStatus</c> enumeration value; otherwise, false.
    /// </returns>
    public static boolean checkWorkflowStatusForUpdate(BudgetTransactionWorkflowStatus _workflowStatus, BudgetTransactionId _budgetTransactionId)
    {
        boolean isValid = true;

        if (_workflowStatus == BudgetTransactionWorkflowStatus::Rejected ||
            _workflowStatus == BudgetTransactionWorkflowStatus::Submitted ||
            _workflowStatus == BudgetTransactionWorkflowStatus::Approved)
        {
            isValid = AifFault::checkFailedLogFault(strfmt("@SYS327586", _budgetTransactionId), #WorkflowStatusPreventsBudgetTransactionUpdate);
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearInUse</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the <c>InUseBy</c> value of a budget transaction header.
    /// </summary>
    /// <param name="_budgetTransactionHeaderId">
    ///    The identifier of a budget transaction header.
    /// </param>
    /// <returns>
    ///    true if the <c>InUseBy</c> value was cleared on the budget transaction header; otherwise, false.
    /// </returns>
    public static boolean clearInUse(RefRecId _budgetTransactionHeaderId)
    {
        boolean                 ret = false;
        BudgetTransactionHeader budgetTransactionHeader;

        if (_budgetTransactionHeaderId != 0)
        {
            ttsbegin;

            budgetTransactionHeader = BudgetTransactionHeader::find(_budgetTransactionHeaderId, true);

            if (budgetTransactionHeader.RecId != 0)
            {
                budgetTransactionHeader.InUseBy = '';
                budgetTransactionHeader.doUpdate();
                ret = true;
            }

            ttscommit;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Constructs an instance of the <c>BudgetTransactionManager</c> class.
    /// </summary>
    /// <returns>
    ///    An instance of the <c>BudgetTransactionManager</c> class.
    /// </returns>
    public static BudgetTransactionManager construct()
    {
        // Create a new instance and return.
        return new BudgetTransactionManager();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceWriteLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Manages the save of a budget transaction line.
    /// </summary>
    /// <param name="_budgetTransactionLine_ds">
    ///    The data source of the form where the budget transaction line is saved.
    /// </param>
    public static void formMethodDataSourceWriteLine(FormDataSource _budgetTransactionLine_ds)
    {
        BudgetTransactionLine budgetTransactionLine;
        BudgetTransactionLine origBudgetTransactionLine;

        if (_budgetTransactionLine_ds.table() == tablenum(BudgetTransactionLine))
        {
            budgetTransactionLine = _budgetTransactionLine_ds.cursor();
            origBudgetTransactionLine = budgetTransactionLine.orig();

            if (origBudgetTransactionLine.Date != budgetTransactionLine.Date ||
                origBudgetTransactionLine.TransactionCurrencyAmount != budgetTransactionLine.TransactionCurrencyAmount ||
                origBudgetTransactionLine.TransactionCurrency != budgetTransactionLine.TransactionCurrency)
            {
                // Changes in the date, transaction amount and transaction currency
                // requires accounting currency amount to be recaclculated.

                budgetTransactionLine.AccountingCurrencyAmount = budgetTransactionLine.calculateTransAmountToAccountingAmount();
            }

            budgetTransactionLine.write();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountStructure</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the ID of an account structure if a valid account structure is found with the specified name
    ///    for the specified ledger.
    /// </summary>
    /// <param name="_primaryLedger">
    ///    The ID of a <c>Ledger</c> record.
    /// </param>
    /// <param name="_accountStructureName">
    ///    The name of an account structure.
    /// </param>
    /// <returns>
    ///    The ID of an account structure if a valid account structure is found; otherwise zero.
    /// </returns>
    public static recId getAccountStructure(recId _primaryLedger, Name _accountStructureName)
    {
        recId accountStructureId;

        if (_accountStructureName == '')
        {
            checkFailed("@SYS317163");
        }
        else
        {
            accountStructureId = DimensionHierarchy::findByTypeAndName(DimensionHierarchyType::AccountStructure, _accountStructureName).RecId;

            if (accountStructureId != 0)
            {
                if (!BudgetTransactionManager::isAccountStructureInLedger(accountStructureId, _primaryLedger))
                {
                    // The account structure is not in the ledger on this budget transaction.
                    checkFailed(strfmt("@SYS315941", _accountStructureName, Ledger::name(_primaryLedger)));
                    accountStructureId = 0;
                }
                else if (!BudgetPrimaryLedgerDimensionAttribute::existByAccountStructure(accountStructureId, _primaryLedger))
                {
                    // The account structure exists and is in the ledger but does not have at least one attribute enabled for budget.
                    checkFailed(strfmt("@SYS315221", _accountStructureName));
                    accountStructureId = 0;
                }
            }
            else
            {
                // Account structure with the specified name was not found.
                checkFailed(strfmt("@SYS315313", _accountStructureName));
            }
        }

        return accountStructureId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAllSubModelsForQueryRange</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Builds a string for a query range that contains the specified budget model and all its sub-models.
    /// </summary>
    /// <param name="_modelId">
    ///    The budget model for which to create the query string.
    /// </param>
    /// <returns>
    ///    A string that contains the specified budget model and all its sub-models.
    /// </returns>
    /// <remarks>
    ///    This method obtains a list of all of the budget sub-models for a budget model in a comma separated
    ///    string.
    /// </remarks>
    public static str getAllSubModelsForQueryRange(BudgetModelId _modelId)
    {
        BudgetModel budgetModel;
        str budgetModelQueryValue;

        while select ModelId, SubModelId from budgetModel
            where budgetModel.ModelId == _modelId
        {
            if (budgetModelQueryValue == '')
            {
                budgetModelQueryValue = SysQuery::value(budgetModel.SubModelId);
            }
            else
            {
                budgetModelQueryValue = strfmt(budgetModelQueryValue + ',' + '%1', SysQuery::value(budgetModel.SubModelId));
            }
        }

        if (budgetModelQueryValue == '')
        {
            budgetModelQueryValue = _modelId;
        }

        return budgetModelQueryValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetLedgerDimensionsKey</Name>
				<Source><![CDATA[
    private static str getBudgetLedgerDimensionsKey(RefRecId _mainAccount, RefRecId _defaultDimensions)
    {
        return (int642str(_mainAccount) + int642str(_defaultDimensions));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetTransactionCodeQuery</Name>
				<Source><![CDATA[
    [SysObsolete('This method has been deprecated. Use getBudgetTransactionCodeQueryForBudgetTranasactionTypes instead.', false, 15\07\2020)]
    public static Query getBudgetTransactionCodeQuery(boolean _restrictToType, BudgetTransactionType _budgetTransactionType)
    {
        if (_restrictToType)
        {
            return BudgetTransactionManager::getBudgetTransactionCodeQueryForBudgetTranasactionTypes(BudgetTransactionCodeQueryMode::RestrictToType, _budgetTransactionType);
        }
        else
        {
            return BudgetTransactionManager::getBudgetTransactionCodeQueryForBudgetTranasactionTypes();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetTransactionCodeQueryForBudgetTranasactionTypes</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets a query that can be used to retrieve the <c>BudgetTransactionCode</c> records.
    /// </summary>
    /// <param name="_queryMode">
    ///    An enum value that indicates whether only the <c>BudgetTransactionCode</c> records of the
    ///    specified type should be included.
    /// </param>
    /// <param name="_budgetTransactionType">
    ///    The <c>BudgetTransactionType</c> for which to restrict the <c>BudgetTransactionCode</c> records.
    /// </param>
    /// <returns>
    ///    A query to retrieve the <c>BudgetTransactionCode</c> records.
    /// </returns>
    [Hookable(false)]
    public static Query getBudgetTransactionCodeQueryForBudgetTranasactionTypes(
        BudgetTransactionCodeQueryMode _queryMode = BudgetTransactionCodeQueryMode::QueryAllTypes,
        BudgetTransactionType _budgetTransactionType = BudgetTransactionType::Blank)
    {
        // Create the query.
        Query query = new Query();
        QueryBuildDataSource queryBuildDataSource = query.addDataSource(tablenum(BudgetTransactionCode));

        // Restrict to transaction types that are allowed for use in the context of an AX client form.
        SysDictEnum budgetTransTypeEnum = new SysDictEnum(enumnum(BudgetTransactionType));
        int budgetTransTypeEnumValue = budgetTransTypeEnum.firstValue();
        int budgetTransTypeEnumEnumCounter = 0;
            
        // Check every transaction type to determine if it is allowed for use in the context of an AX client form.
        while (budgetTransTypeEnumEnumCounter < budgetTransTypeEnum.values())
        {
            BudgetTransactionHeader budgetTransactionHeader;
            budgetTransactionHeader.BudgetTransactionType = budgetTransTypeEnumValue;
            BudgetTransHeaderType budgetTransHeaderType = BudgetTransHeaderType::construct(budgetTransactionHeader);
            boolean includeInQuery = true;

            if (_queryMode == BudgetTransactionCodeQueryMode::ExcludeType)
            {
                includeInQuery = budgetTransTypeEnumValue == _budgetTransactionType ? false : includeInQuery;
            }
            else if (_queryMode == BudgetTransactionCodeQueryMode::RestrictToType)
            {
                includeInQuery = budgetTransTypeEnumValue != _budgetTransactionType ? false : includeInQuery;
            }

            if (includeInQuery && budgetTransHeaderType.isInteractiveContextAllowed())
            {
                // The transaction type is allowed for use in the context of an AX client form.
                // Add it to the query.
                QueryBuildRange queryBuildRangeBudgetTransType = queryBuildDataSource.addRange(fieldnum(BudgetTransactionCode, BudgetTransactionType));
                queryBuildRangeBudgetTransType.value(int2str(enum2int(budgetTransTypeEnumValue)));
            }

            budgetTransTypeEnumValue = budgetTransTypeEnum.nextValue(budgetTransTypeEnumValue);
            budgetTransTypeEnumEnumCounter++;
        }
        
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultAccountStructureId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the default account structure with budget dimension attributes for the current ledger.
    /// </summary>
    /// <param name="_primaryLedger">
    /// The ledger record ID for which the default account structure ID needs to be obtained.
    /// </param>
    /// <returns>
    /// The account structure record ID if only one account structure exists; otherwise zero.
    /// </returns>
    /// <remarks>
    /// If more than one account structure exists for the provided ledger with budget dimension attributes,
    /// then no account structure is provided as default.
    /// </remarks>
    public static DimensionHierarchyId getDefaultAccountStructureId(RecId _primaryLedger)
    {
        DimensionHierarchy                      dimensionHierarchy;
        LedgerStructure                         ledgerStructure;
        DimensionHierarchyLevel                 dimensionHierachyLevel;
        DimensionAttribute                      dimensionAttribute;
        BudgetPrimaryLedgerDimensionAttribute   budgetPrimaryLedgerDimensionAttribute;
        LedgerRecId                             currentLedger = Ledger::current();
        DimensionHierarchyId                    defaultAccountStructureId;

        // Get active account structures for the current ledger with budget dimension attributes
        while select RecId from dimensionHierarchy
            where dimensionHierarchy.IsDraft == NoYes::No
                && dimensionHierarchy.IsSystemGenerated == NoYes::No
                && dimensionHierarchy.StructureType == DimensionHierarchyType::AccountStructure
            exists join ledgerStructure
                where ledgerStructure.Ledger == currentLedger
                    && ledgerStructure.DimensionHierarchy == dimensionHierarchy.RecId
            exists join dimensionHierachyLevel
                where dimensionHierachyLevel.DimensionHierarchy == dimensionHierarchy.RecId
            exists join dimensionAttribute
                where dimensionAttribute.RecId == dimensionHierachyLevel.DimensionAttribute
            exists join budgetPrimaryLedgerDimensionAttribute
                where budgetPrimaryLedgerDimensionAttribute.DimensionAttribute == dimensionAttribute.RecId
                    && budgetPrimaryLedgerDimensionAttribute.PrimaryLedger == _primaryLedger
        {
            // If only 1 is found, set as default, otherwise do not provide default
            if (!defaultAccountStructureId)
            {
                defaultAccountStructureId = dimensionHierarchy.Recid;
            }
            else
            {
                defaultAccountStructureId = 0;
                break;
            }
        }

        return defaultAccountStructureId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimensionValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the display value of a dimension value from the parent table of the dimension value.
    /// </summary>
    /// <param name="_dimensionAttributeValueRecId">
    ///    The ID of a <c>DimensionAttributeValue</c> record for which to obtain the display value.
    /// </param>
    /// <returns>
    ///    The display value of the specified dimension value.
    /// </returns>
    public static DimensionValue getDimensionValue(RefRecId _dimensionAttributeValueRecId)
    {
        return DimensionAttributeValue::find(_dimensionAttributeValueRecId).getValue();
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasLinesForBudgetHeader</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether any budget transaction lines exist for a budget transaction header.
    /// </summary>
    /// <param name="_budgetTransactionHeader">
    ///    The budget transaction header to examine.
    /// </param>
    /// <returns>
    ///    true if at least one line exists for the specified budget transaction header; otherwise, false.
    /// </returns>
    public static boolean hasLinesForBudgetHeader(BudgetTransactionHeader _budgetTransactionHeader)
    {
        BudgetTransactionLine budgetTransactionLine;

        // Query for the first line for this header.
        select firstonly RecId from budgetTransactionLine
            where budgetTransactionLine.BudgetTransactionHeader == _budgetTransactionHeader.RecId;

        // If a record wasn't found, return false.
        return (budgetTransactionLine.RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAccountStructureInLedger</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the specified account structure is in the specified ledger.
    /// </summary>
    /// <param name="_accountStructure">
    ///    The ID of a <c>DimensionHierarchy</c> record.
    /// </param>
    /// <param name="_ledger">
    ///    The ID of a <c>Ledger</c> record; optional.
    /// </param>
    /// <returns>
    ///    true if the specified account structure is the in the specified ledger; otherwise, false.
    /// </returns>
    public static boolean isAccountStructureInLedger(DimensionHierarchyId _accountStructure, LedgerRecId _ledger = Ledger::current())
    {
        return (LedgerStructure::findByLedgerStructure(_ledger, _accountStructure).RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUserBlocked</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the current user is blocked from using the budget transaction.
    /// </summary>
    /// <param name="_userId">
    ///    The ID of a user.
    /// </param>
    /// <param name="_budgetTransactionId">
    ///    The ID of a budget transaction.
    /// </param>
    /// <param name="_logWarning">
    ///    A Boolean value indicating whether to log the fault as a warning or not.
    /// </param>
    /// <returns>
    ///    true if the user is blocked from the use of the budget transaction; otherwise, false.
    /// </returns>
    public static boolean isUserBlocked(userId _userId, BudgetTransactionId _budgetTransactionId, boolean _logWarning = true)
    {
        boolean isUserBlocked = false;

        if (_userId && (_userId != curuserid()))
        {
            isUserBlocked = true;

            if (_logWarning)
            {
                AifFault::checkFailedLogFault(
                    strfmt("@SYS128887", _budgetTransactionId, _userId),
                    #BudgetTransactionBlockedForUser);
            }
        }

        return isUserBlocked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupBudgetTransactionCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the lookup for the <c>BudgetTransactionCode</c> records.
    /// </summary>
    /// <param name="_ctrl">
    /// The form reference control to perform the lookup for.
    /// </param>
    /// <param name="_restrictToType">
    /// A Boolean value that determines if only the <c>BudgetTransactionCode</c> records of the specified type should be included; optional.
    /// </param>
    /// <param name="_budgetTransactionType">
    /// The <c>BudgetTransactionType</c> for which to restrict the <c>BudgetTransactionCode</c> records; optional.
    /// </param>
    /// <returns>
    /// The <c>BudgetTransactionCode</c> record selected by the lookup.
    /// </returns>
    public static BudgetTransactionCode lookupBudgetTransactionCode(
        FormReferenceControl _ctrl,
        boolean _restrictToType = false,
        BudgetTransactionType _budgetTransactionType = BudgetTransactionType::OriginalBudget)
    {
        SysReferenceTableLookup budgetTransactionCodeLookup;

        budgetTransactionCodeLookup = SysReferenceTableLookup::newParameters(tablenum(BudgetTransactionCode), _ctrl, true);

        // Add the fields to be shown in the lookup form.
        budgetTransactionCodeLookup.addLookupfield(fieldnum(BudgetTransactionCode, Name));
        budgetTransactionCodeLookup.addLookupfield(fieldnum(BudgetTransactionCode, Description));
        budgetTransactionCodeLookup.addLookupfield(fieldnum(BudgetTransactionCode, BudgetTransactionType));

        // Add the query to the lookup form.
        budgetTransactionCodeLookup.parmQuery(BudgetTransactionManager::getBudgetTransactionCodeQuery(_restrictToType, _budgetTransactionType));

        // Perform the lookup.
        return budgetTransactionCodeLookup.performFormLookup() as BudgetTransactionCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeDefaultDimWithLedgerDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Merges the dimension values in a default dimension and ledger dimension into a single ledger
    ///    dimension.
    /// </summary>
    /// <param name="_defaultDimensions">
    ///    An identifier of a record in the <c>DimensionAttributeValueSet</c> table.
    /// </param>
    /// <param name="_budgetLedgerDimension">
    ///    An identifier of a record in the <c>DimensionAttributeValueCombination</c> table.
    /// </param>
    /// <param name="_transactionDate">
    ///    The date that is used to validate the new dimension combination.
    /// </param>
    /// <param name="_validateLedgerDimension">
    ///    A <c>Boolean</c> value to determine whether the combination need to be validated before persisting; Optional.
    /// </param>
    /// <returns>
    ///    A ledger dimension that contains the values from the merge of the specified default dimension and
    ///    ledger dimension; otherwise, 0.
    /// </returns>
    public static LedgerDimensionBudget mergeDefaultDimWithLedgerDim(
        DimensionDefault _defaultDimensions,
        LedgerDimensionBudget _budgetLedgerDimension,
        TransDate _transactionDate,
        boolean _validateLedgerDimension = true)
    {
        LedgerDimensionBudget ledgerDimensionReturn;
        DimensionValidationStatus dimensionValidationStatus = DimensionValidationStatus::Valid;

        LedgerDimensionBase ledgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimForDefaultDim(_defaultDimensions, _budgetLedgerDimension);

        if (_validateLedgerDimension)
        {
            dimensionValidationStatus = LedgerDimensionValidationHelper::validateByTree(ledgerDimension, _transactionDate, true, true);
        }

        if (dimensionValidationStatus == DimensionValidationStatus::Valid)
        {
            ledgerDimensionReturn = ledgerDimension;
        }

        return ledgerDimensionReturn;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveBudgetLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Saves the budget ledger dimension that is specified by the dimension attribute values from a ledger
    ///    dimension.
    /// </summary>
    /// <param name="_ledgerDimension">
    ///    The ledger dimension from which to create the budget ledger dimension.
    /// </param>
    /// <returns>
    ///    A budget ledger dimension.
    /// </returns>
    /// <remarks>
    ///    No validation is performed on the budget ledger dimension that is returned.Only the dimension
    ///    attributes that are enabled for budget are used to create the budget ledger dimension.If no
    ///    segments are set in the budget ledger dimension, 0 is returned.
    /// </remarks>
    public static LedgerDimensionBudget saveBudgetLedgerDimension(LedgerDimensionBase _ledgerDimension)
    {
        if (_ledgerDimension == 0)
        {
            return 0;
        }

        // Sync the ledger dimension to the active structure.
        LedgerDimensionBase activeLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimFromLedgerDim(_ledgerDimension);

        LedgerDimensionBudget budgetDimension = LedgerDimensionFacade::serviceCreateLedgerDimensionForType(LedgerDimensionType::Budget, activeLedgerDimension);

        return budgetDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInUse</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the value of the <c>InUseBy</c> field of a budget transaction header to indicate it is being
    ///    used.
    /// </summary>
    /// <param name="_budgetTransactionHeader">
    ///    A budget transaction header data source.
    /// </param>
    public static void setInUse(FormDataSource _budgetTransactionHeader)
    {
        BudgetTransactionHeader budgetTransactionHeader = _budgetTransactionHeader.cursor() as BudgetTransactionHeader;

        ttsbegin;

        // Set the transaction to in use by the current user.
        budgetTransactionHeader.InUseBy = curuserid();
        budgetTransactionHeader.doUpdate();

        ttscommit;

        _budgetTransactionHeader.setCurrent();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAccountStructure</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the account structure associated with the <c>LedgerDimension</c> field is valid.
    /// </summary>
    /// <param name="_budgetTransactionLine">
    ///    The <c>BudgetTransactionLine</c> record that contains the account structure to validate.
    /// </param>
    /// <returns>
    ///    true if the account structure is valid; otherwise, false.
    /// </returns>
    public static boolean validateAccountStructure(BudgetTransactionLine _budgetTransactionLine)
    {
        boolean isValid = true;

        recId accountStructure;

        LedgerStructure ledgerStructure;

        DimensionHierarchy dimHierarchy;
        DimensionHierarchyLevel dimHierarchyLevel;
        DimensionAttribute dimAttribute;

        BudgetPrimaryLedgerDimensionAttribute budgetPrimaryLedgerDimensionAttribute;

        if (_budgetTransactionLine.LedgerDimension)
        {
            accountStructure = DimensionAttributeValueCombination::find(_budgetTransactionLine.LedgerDimension).AccountStructure;

            if (!BudgetTransactionManager::isAccountStructureInLedger(accountStructure, _budgetTransactionLine.getBudgetTransactionHeader().PrimaryLedger))
            {
                // Get the first dimension hierachy that contains budget enabled dimensions.
                select firstonly RecId from dimHierarchy
                    exists join ledgerStructure
                        where  ledgerStructure.DimensionHierarchy == dimHierarchy.RecId
                            && ledgerStructure.Ledger == _budgetTransactionLine.getBudgetTransactionHeader().PrimaryLedger
                    exists join dimHierarchyLevel
                        where dimHierarchyLevel.DimensionHierarchy == dimHierarchy.RecId
                    exists join dimAttribute
                        where dimAttribute.RecId == dimHierarchyLevel.DimensionAttribute
                    exists join budgetPrimaryLedgerDimensionAttribute
                        where budgetPrimaryLedgerDimensionAttribute.DimensionAttribute == dimAttribute.RecId;

                if (!dimHierarchy)
                {
                    // No account structure in the ledger has budget enabled dimensions.
                    isValid = AifFault::checkFailedLogFault(
                        "@SYS318927",
                        #NoDimensionsEnabledForBudget);
                }

                if (isValid)
                {
                    // The account structure is not in the ledger.
                    isValid = AifFault::checkFailedLogFault(
                        strfmt("@SYS318928", DimensionHierarchy::find(accountStructure).Name),
                        #AccountStructureNotInChartOfAccounts);
                }
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBudgetModel</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the budget model of the specified <c>BudgetTransactionHeader</c> record is valid.
    /// </summary>
    /// <param name="_budgetTransactionHeader">
    ///    A <c>BudgetTransactionHeader</c> record.
    /// </param>
    /// <returns>
    ///    true if the budget model of the specified <c>BudgetTransactionHeader</c> record is valid;
    ///    otherwise, false.
    /// </returns>
    public static boolean validateBudgetModel(BudgetTransactionHeader _budgetTransactionHeader)
    {
        boolean     isValid = true;
        BudgetModel budgetModel;

        if (_budgetTransactionHeader.BudgetModelDataAreaId)
        {
            changecompany(_budgetTransactionHeader.BudgetModelDataAreaId)
            {
                budgetModel = BudgetModel::find(_budgetTransactionHeader.BudgetModelType, _budgetTransactionHeader.BudgetModelId, _budgetTransactionHeader.BudgetSubModelId);
            }
        }

        if (!budgetModel)
        {
            // A budget model wasn't found. Fail validation if there is a budget model identifier specified.
            // If a budget model identifier isn't specified, only fail validation if the table buffer is coming from
            //  a source that is not a form. If the source is a form, rely on the kernel messages instead since budget model is a mandatory field.
            if (_budgetTransactionHeader.BudgetModelId || !FormDataUtil::isFormDataSource(_budgetTransactionHeader))
            {
                isValid = AifFault::checkFailedLogFault(
                    strFmt("@SYS9966", _budgetTransactionHeader.BudgetModelId),
                    #BudgetModelDoesNotExist);
            }
        }
        else
        {
            if (budgetModel.Type == HeadingSub::SubModel)
            {
                isValid = AifFault::checkFailedLogFault(
                    strfmt("@SYS23399", _budgetTransactionHeader.BudgetSubModelId, _budgetTransactionHeader.BudgetModelId),
                    #BudgetModelTypeIsSubModel);
            }

            if (budgetModel.Blocked == NoYes::Yes)
            {
                isValid = AifFault::checkFailedLogFault(
                    strfmt("@SYS4829", _budgetTransactionHeader.BudgetModelId),
                    #BudgetModelLocked);
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the current company settings.
    /// </summary>
    /// <returns>
    /// true if the current company settings are valid; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The setting that is validated on the company is the consolidation setting.
    /// </remarks>
    public static boolean validateCompany()
    {
        boolean isValid = true;

        if (CompanyInfo::isConsolidationCompany() == NoYes::Yes)
        {
            // Budget transactions cannot be posted to the consolidated company account.
            isValid = checkFailed(strfmt("@SYS135470", curext()));
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the currency that is involved in a budget transaction.
    /// </summary>
    /// <param name="_currencyCode">
    ///    The currency to validate.
    /// </param>
    /// <param name="_suppressErrors">
    ///    Determines if messages should be logged for validation failures; optional.
    /// </param>
    /// <returns>
    ///    true if the specified currency is valid; otherwise, false.
    /// </returns>
    public static boolean validateCurrency(CurrencyCode _currencyCode, boolean _suppressErrors = false)
    {
        boolean isValid = true;

        if (!_currencyCode)
        {
            // Currency code was not specified
            isValid = false;

            if (!_suppressErrors)
            {
                AifFault::checkFailedLogFault(strfmt("@SYS84753", "@SYS7572"), #BudgetTransactionCurrencyDoesNotExist);
            }
        }
        else if (Currency::exist(_currencyCode) == false)
        {
            // Currency code does not exist
            isValid = false;

            if (!_suppressErrors)
            {
                AifFault::checkFailedLogFault(strfmt("@SYS117888", _currencyCode, curext()), #BudgetTransactionCurrencyDoesNotExist);
            }
        }
        else
        {
            // Default budget rate type is not defined for the ledger
            if (Ledger::budgetExchangeRateType() == 0)
            {
                isValid = false;

                if (!_suppressErrors)
                {
                    AifFault::checkFailedLogFault("@SYS323933", #BudgetRateTypeNotDefinedForLedger);
                }
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDimensionFocus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the dimension focus value.
    /// </summary>
    /// <param name="_dimensionFocusValue">
    /// The dimension focus value that must be validated.
    /// </param>
    /// <returns>
    /// true when the dimension focus value is valid. Otherwise, false.
    /// </returns>
    public static boolean validateDimensionFocus(str _dimensionFocusValue)
    {
        boolean isValid = true;

        if ((_dimensionFocusValue != '') && DimensionHierarchy::findByTypeAndName(DimensionHierarchyType::Focus, _dimensionFocusValue).RecId == 0)
        {
            // Dimension focus with the name the user entered was not found.
            isValid = checkFailed(strfmt("@SYS304909", _dimensionFocusValue, fieldpname(DimensionHierarchy, Name), tablepname(DimensionHierarchy)));
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the specified ledger dimension.
    /// </summary>
    /// <param name="_ledgerDimensionBudget">
    ///    The ledger dimension to validate.
    /// </param>
    /// <param name="_date">
    ///    A date to use to validate the ledger dimension.
    /// </param>
    /// <returns>
    ///    true if the ledger dimension is valid; otherwise, false.
    /// </returns>
    public static boolean validateLedgerDimension(LedgerDimensionBudget _ledgerDimensionBudget, TransDate _date)
    {
        boolean isValid;
        DimensionValidationStatus dimensionValidationStatus;

        dimensionValidationStatus = LedgerDimensionValidationHelper::validateByTree(_ledgerDimensionBudget, _date, true, true);

        if (dimensionValidationStatus == DimensionValidationStatus::Valid)
        {
            isValid = true;
        }
        else
        {
            isValid = false;
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLedgerDimensionV2</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the specified ledger dimension.
    /// </summary>
    /// <param name="_ledgerDimensionBudget">
    ///    The ledger dimension to validate.
    /// </param>
    /// <param name="_date">
    ///    A date to use to validate the ledger dimension.
    /// </param>
    /// <returns>
    ///    A value of <c>DimensionValidationStatus</c>.
    /// </returns>
    public static DimensionValidationStatus validateLedgerDimensionV2(LedgerDimensionBudget _ledgerDimensionBudget, TransDate _date)
    {
       return LedgerDimensionValidationHelper::validateByTree(_ledgerDimensionBudget, _date, true, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTransactionCodeType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the transaction code and transaction type are valid.
    /// </summary>
    /// <returns>
    /// true if the transaction code and transaction type are valid; otherwise, false.
    /// </returns>
    public static boolean validateTransactionCodeType(BudgetTransactionHeader _header)
    {
        boolean ret = true;

        if ((_header.BudgetTransactionCode == 0) || (_header.BudgetTransactionType == 0))
        {
            checkFailed("@SYS318772");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTransactionDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified date is in an open period for the ledger module.
    /// </summary>
    /// <param name="_date">
    /// A date.
    /// </param>
    /// <returns>
    /// true if the date is in an open period for the ledger module; otherwise, false.
    /// </returns>
    public static boolean validateTransactionDate(TransDate _date)
    {
        boolean isValid;

        isValid = LedgerFiscalCalendar::checkLedgerPeriodDateModule(
                Ledger::fiscalCalendar(),
                _date,
                SysModule::Ledger,
                false);

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInUseBy</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the budget transaction is blocked from modifying the budget transaction due to the budget transaction being modified.
    /// </summary>
    /// <param name="_inUseByUserId">
    ///    The ID of a user.
    /// </param>
    /// <param name="_budgetTransactionId">
    ///    The ID of a budget transaction.
    /// </param>
    /// <returns>
    ///    true if the service is allowed to modify the budget transaction; otherwise, false.
    /// </returns>
    public static boolean validateInUseBy(userId _inUseByUserId, BudgetTransactionId _budgetTransactionId)
    {
        boolean isValid = true;

        if (_inUseByUserId)
        {
            isValid = false;

            checkFailed(strfmt("@SYS128887", _budgetTransactionId, _inUseByUserId));
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBudgetType</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Validates that all lines have matching <c>BudgetType</c> values when the transaction type is transfer.
    /// </summary>
    /// <param name = "_budgetTransactionHeader">
    ///   The <c>BudgetTransactionHeader</c> record.
    /// </param>
    /// <param name = "_type">
    ///   The <c>BudgetType</c> of the line being processed.
    /// </param>
    /// <returns>true if the budget types match.</returns>
    public static boolean validateBudgetType(BudgetTransactionHeader _budgetTransactionHeader, BudgetType _type)
    {
        BudgetTransactionLine line;

        if (_budgetTransactionHeader.BudgetTransactionType == BudgetTransactionType::Transfer)
        {
            select firstonly RecId from line
                where line.BudgetTransactionHeader == _budgetTransactionHeader.RecId
                    && line.BudgetType != _type;

            if (line.RecId != 0)
            {
                checkFailed("@SYS128885");
            }
        }

        return line.RecId == 0;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>