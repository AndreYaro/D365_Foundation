<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WhsSplitWork</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>WHSSplitWork</c> class is responsible for separating specified work from the work that was created initially
/// </summary>
public class WhsSplitWork
{
    WHSWorkId           origWorkId;
    WHSWorkId           newWorkId;
    LineNum             lineNum;
    Qty                 qtyToPick;
    Qty                 origQtyToPick;
    Qty                 origConvertedQtyToPick;
    UnitOfMeasureSymbol prevDoneUnitId;
    InventDimId         prevDoneInventDimId;
    ItemId              prevDoneItemId;
    ItemId              prevToDoItemId;
    ItemId              itemIdRemainLine;
    ItemId              prevItemIdOfNewWork;
    WHSWorkType         prevDoneWorkType;
    UnitOfMeasureSymbol prevToDoUnitId;
    InventDimId         prevToDoInventDimId;
    InventDimId         prevInventDimIdOfNewWork;
    Qty                 qtyDoneInvent;
    Qty                 qtyDone;
    Qty                 qtyToDoInvent;
    Qty                 qtyToDo;
    boolean             changedDoneUnitId;
    boolean             changedDoneItemId;
    boolean             changedDoneInventDimId;
    boolean             changedDoneProductVariants;
    boolean             changedToDoItemId;
    boolean             changedToDoUnitId;
    boolean             changedToDoInventDimId;
    boolean             changedToDoProductVariants;
    boolean             lockOrigWork;
    boolean             doneWithPicks;
    boolean             newWorkHasMultiItems;
    LineNum             origWorkLineNum;
    LineNum             newWorkLineNum;
    LineNum             currentLineNum;
    WHSUserId           userId;
    Map                 workLineWithQuantity;
    LineNum             groupPickLineNumber;
    private Map         workLineNumMap;
    private LineNum     workLineNumCounter;
    private boolean     isEnabledSplitWorkLineResolveDuplicateKeyFlight = WHSSplitWorkLineResolveDuplicateKeyV2Flight::instance().isEnabled();
    private boolean     isSplitOnClosingPackingWork;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>updateCancelledWorkLineNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update lineNum field of cancelled work lines to avoid duplicate lineNum and workId records in work split process.
    /// </summary>
    /// <remarks>
    /// All the lineNum of cancelled work lines will be updated to series from current maximum lineNum
    /// </remarks>
    [SysObsolete('Cancelled lines now keep their position. Use handleCancelledWorkLineStayingOnOriginalWorkHeader() for any extension related to handling of cancelled lines.', false, 30\06\2020)]
    protected final void updateCancelledWorkLineNumber()
    {
        LineNum             maxLineNum;
        WHSWorkLine         cancelledWorkLine;

        maxLineNum = WHSWorkLine::lastLineNum(origWorkId);

        cancelledWorkLine.skipDataMethods(true);
        update_recordSet cancelledWorkLine
        setting lineNum = cancelledWorkLine.lineNum + maxLineNum + 1
            where cancelledWorkLine.WorkId      == origWorkId
                && cancelledWorkLine.WorkStatus == WHSWorkStatus::Cancelled
                && cancelledWorkLine.LineNum    <= maxLineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetCancelledWorkLineNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reset lineNum field of cancelled work lines to make current WhsWorkLine lineNum records in a series.
    /// </summary>
    /// <remarks>
    /// All the lineNum of cancelled work lines will be updated to series from current maximum lineNum.
    /// </remarks>
    [SysObsolete('Cancelled lines now keep their position. Use handleCancelledWorkLineStayingOnOriginalWorkHeader() for any extension related to handling of cancelled lines.', false, 30\06\2020)]
    protected void resetCancelledWorkLineNum()
    {
        LineNum maxLineNum = WHSWorkLine::lastNotCancelledLineNum(origWorkId);
        LineNum firstCanceledLineNum = WHSWorkLine::firstLineNumWithWorkStatusAfterLine(origWorkId, WHSWorkStatus::Cancelled, maxLineNum);
        LineNum lastLineNum = WHSWorkLine::lastLineNum(origWorkId);

        ttsBegin;

        WHSWorkLine workline;
        while select forUpdate workline
            order by lineNum asc
            where workline.WorkId     == origWorkId
               && workline.WorkStatus == WHSWorkStatus::Cancelled
               && workline.LineNum    >= firstCanceledLineNum
               && workline.LineNum    <= lastLineNum
        {
            maxLineNum++;
            workline.LineNum = maxLineNum;
            workline.update();
        }

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateNewWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a new work line record.
    /// </summary>
    /// <param name="_workLine">
    /// The original <c>WHSWorkLine</c> record
    /// </param>
    protected final void generateNewWorkLine(WHSWorkLine _workLine)
    {
        WHSWorkLine newWorkLine;

        WhsSplitWork::initializeNewWorkLineFromOriginalWorkLine(_workLine, newWorkLine);

        newWorkLine.WorkId  = newWorkId;
        newWorkLine.LineNum = newWorkLineNum;

        if (changedDoneItemId)
        {
            newWorkLine.ItemId = prevDoneItemId;
        }

        newWorkLine.InventDimId = this.getInventDimIdForNonInitialPickWorkLines(changedDoneProductVariants, changedDoneInventDimId, prevDoneInventDimId, prevDoneItemId);

        newWorkLine.InventQtyWork   = qtyDoneInvent;
        newWorkLine.InventQtyRemain = qtyDoneInvent;

        this.updateWorkLineQuantities(newWorkLine, qtyDone);

        if (!newWorkLine.QtyWork)
        {
            newWorkLine.WorkStatus = WHSWorkStatus::Closed;
        }

        // If new work has multiple line items, then set item id to null for the work type put.
        if (newWorkHasMultiItems)
        {
            newWorkLine.ItemId = '';
        }

        newWorkLine.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventDimIdForNonInitialPickWorkLines</Name>
				<Source><![CDATA[
    private  InventDimId getInventDimIdForNonInitialPickWorkLines(
        boolean _areProductDimensionsTheSame,
        boolean _areInventDimTheSame,
        InventDimId _inventDimId,
        ItemId _itemId)
    {
        if (_areInventDimTheSame)
        {
            return _inventDimId;
        }

        if (_areProductDimensionsTheSame)
        {
            return InventDim::findOrCreateProductInventDimId(_itemId, InventDim::find(_inventDimId));
        }

        return InventDim::inventDimIdBlank();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWorkLineLineNum</Name>
				<Source><![CDATA[
    protected void setWorkLineLineNum(WHSWorkLine _workLineForUpdate, LineNum _lineNumProposed = origWorkLineNum)
    {
        _workLineForUpdate.LineNum = _lineNumProposed;

        if (workLineNumMap.exists(workLineNumCounter) && WHSWorkLine::exist(_workLineForUpdate.WorkId, _lineNumProposed))
        {
            _workLineForUpdate.LineNum = workLineNumMap.lookup(workLineNumCounter);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setNextWorkLineCounters</Name>
				<Source><![CDATA[
    private void setNextWorkLineCounters(WHSWorkLine _workLine)
    {
        workLineNumCounter++;
        if (_workLine.isSplitLine())
        {
            --origWorkLineNum;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleFullOriginalWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the full quantity on the original work line.
    /// </summary>
    /// <param name = "_workLine">The work line.</param>
    protected void handleFullOriginalWorkLine(WHSWorkLine _workLine)
    {
        // If splitting off full workLine
        if (isEnabledSplitWorkLineResolveDuplicateKeyFlight)
        {
            this.setWorkLineLineNum(_workLine);
        }
        else 
        {
            _workLine.LineNum                    = origWorkLineNum;
        }

        _workLine.WorkStatus                 = WHSWorkStatus::Open;
        _workLine.UserId                     = '';
        _workLine.WorkInProcessUTCDateTime   = utcDateTimeNull();
        _workLine.update();

        this.updateWorkInventoryTransactionReference(_workLine.WorkId, _workLine.LineNum);
        this.updateReplenishmentWorkLinks(_workLine.WorkId, _workLine.LineNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleCancelledWorkLineStayingOnOriginalWorkHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles a original cancelled work line.
    /// </summary>
    /// <param name = "_workLineRecId">The RecId of the workLine.</param>
    protected void handleCancelledWorkLineStayingOnOriginalWorkHeader(WHSWorkLineRecId _workLineRecId)
    {
        if (this.shouldRenumberWorkLineOriginalWork())
        {
            ttsbegin;

            WHSWorkLine workLine = WHSWorkLine::findByRecId(_workLineRecId, true);
            
            if (isEnabledSplitWorkLineResolveDuplicateKeyFlight)
            {
                this.setWorkLineLineNum(workLine);
            }
            else
            {
                workLine.LineNum = origWorkLineNum;
            }

            workLine.update();

            this.updateWorkInventoryTransactionReference(workLine.WorkId, workLine.LineNum);
            this.updateReplenishmentWorkLinks(workLine.WorkId, workLine.LineNum);

            ttscommit;

            origWorkLineNum++;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleOrignalWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the original <c>WHSWorkLine</c> record and all associated transactions
    /// </summary>
    /// <param name="_workLineRecId">
    /// The record identifier of the original <c>WHSWorkLine</c> record
    /// </param>
    /// <param name="_convertedQtyToPick">
    /// The quantity to pick converted into the unit specified on the work line
    /// </param>
    protected final void handleOrignalWorkLine(RefRecId _workLineRecId, Qty _convertedQtyToPick)
    {
        WHSWorkLine workLine = WHSWorkLine::findByRecId(_workLineRecId, true);

        if (!qtyToPick
            && workLine.InventQtyWork == workLine.InventQtyRemain)
        {
            this.handleFullOriginalWorkLine(workLine);
        }
        else
        {
            WHSWorkLine newWorkLine;
            WhsSplitWork::initializeNewWorkLineFromOriginalWorkLine(workLine, newWorkLine);
            this.setChangedDoneValues(newWorkLine);

            WHSInventQtyWork currentInventQtyWork = workLine.InventQtyWork;

            // Otherwise, Partial split
            this.setPrevDoneValuesFromWorkLine(workLine);

            if (currentInventQtyWork > qtyToPick)
            {
                workLine.LineNum                    = origWorkLineNum;
                workLine.UserId                     = '';
                workLine.WorkInProcessUTCDateTime   = utcDateTimeNull();

                workLine.InventQtyWork              -= qtyToPick;

                // For packing work split QtyRemain on the original work line should keep the value as QtyRemain being cut from it should be zero.
                if (!isSplitOnClosingPackingWork)
                {
                    workLine.InventQtyRemain             = workLine.InventQtyWork;
                }

                this.updateWorkLineQuantities(workLine, workLine.QtyWork - _convertedQtyToPick);
                workLine.WorkStatus                  = workLine.InventQtyRemain > 0 ? WHSWorkStatus::Open : WHSWorkStatus::Closed;
                workLine.AskForNewLicensePlate = NoYes::No;
           
                workLine.update();
            }    

            newWorkLine.WorkId          = newWorkId;
            newWorkLine.LineNum         = newWorkLineNum;
            newWorkLine.InventQtyWork   = qtyToPick;
            newWorkLine.InventQtyRemain = origQtyToPick;
            this.updateWorkLineQuantities(newWorkLine, _convertedQtyToPick);

            // If the new work line has nothing further to pick, we need to close it so we don't try to pick again.
            if (!newWorkLine.InventQtyRemain)
            {
                newWorkLine.WorkStatus  = WHSWorkStatus::Closed;
            }
            newWorkLine.insert();

            if (!doneWithPicks)
            {
                this.setItemIdRemainLineOfNewWork(newWorkLine);
            }

            this.updateWorkInventoryTransactionReference(newWorkId, newWorkLineNum);
            this.updateWorkTransactionReference(newWorkId, newWorkLineNum);
            this.updateDimensionTrackingReference(newWorkId, newWorkLineNum);
            this.updateWorkExceptionLog(newWorkId, newWorkLineNum);
            this.adjustReplenWorkLinks(newWorkLine);
            
            if (currentInventQtyWork > qtyToPick)
            {
                this.adjustWorkInventoryTransactions(workLine);
            }
            else
            {
                //Remove closed work line with zero work and remaining quantity. New work was created to process pick.
                workLine.delete();
                origWorkLineNum--;
            }
            ++newWorkLineNum;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustWorkInventoryTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// This function takes the split qty (<c>origQtyToPick</c>) and the existing transactions to split the <c>WHSWorkInventTrans</c> appropriately.
    /// It takes into account any transactions that have been partially or fully completed before splitting.
    /// </summary>
    /// <param name="_workLine">
    /// The original work line where the initial work was. In the end this work line should hold all transactions which have not been completed yet.
    /// </param>
    private void adjustWorkInventoryTransactions(WHSWorkLine _workLine)
    {
        // Keep a running quantity to ensure proper split of WHSWorkInventTrans record.
        InventQty runningQtyToKeepOnNewWorkLine = origQtyToPick;
        
        WHSWorkInventTrans workInventTrans;
        /// Move qty back to original work line
        /// Select work inventory transactions with a real parent first, as opposed to a dummy parent.
        while select forUpdate workInventTrans
            order by InventTransIdParent
            where workInventTrans.WorkId == newWorkId
                && workInventTrans.LineNum == newWorkLineNum
        {
            // If running quantity is greater than the WHSWorkInventTrans remaining quantity then we leave it associated to the new work line.
            if (runningQtyToKeepOnNewWorkLine >= workInventTrans.InventQtyRemain)
            {
                runningQtyToKeepOnNewWorkLine -= workInventTrans.InventQtyRemain;
            }
            else if (runningQtyToKeepOnNewWorkLine == 0 && workInventTrans.InventQtyRemain == workInventTrans.Qty)
            {
                this.moveWorkInventTransToOriginalWorkLineAndUpdateInventTransOrigin(workInventTrans, _workLine);
            }
            else
            {
                InventQty splitQtyForOrigWorkLine = workInventTrans.InventQtyRemain - runningQtyToKeepOnNewWorkLine;

                // The quantity for this work invent trans record remaining on the new work line should be equal
                // to the already picked quantity for this invent trans record plus any remaining quantity to be kept on the new work line.
                InventHandlingQty alreadyPickedInventQty = workInventTrans.Qty - workInventTrans.InventQtyRemain;
                workInventTrans.Qty = alreadyPickedInventQty + runningQtyToKeepOnNewWorkLine;

                this.updateWorkInventTransWeightIfCatchWeight(workInventTrans, runningQtyToKeepOnNewWorkLine);

                workInventTrans.update();

                runningQtyToKeepOnNewWorkLine = 0;

                if (_workLine.InventQtyRemain > 0)
                {
                    // Make a new transaction (split from previous), move it to the original work line and set the quantity
                    WHSWorkInventTrans splitWorkInventTrans = this.initializeWorkInventTransFromWorkLineAndQuantity(workInventTrans, _workLine, splitQtyForOrigWorkLine);

                    this.updateWorkInventTransWeightIfCatchWeight(splitWorkInventTrans, splitQtyForOrigWorkLine);

                    splitWorkInventTrans.insert();
                }

                // If a pick line was partially picked then executed as full with 0 qty, need to ensure the WHSWorkInventTrans's inventDimTo is correct.
                this.updateWorkInventTransInventDimToWithUserLocation(workInventTrans);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkInventTransWeightIfCatchWeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>WHSWorkInventTrans</c> transaction weight if it has a catch weight item.
    /// </summary>
    /// <param name = "_workInventTrans">
    /// The <c>WHSWorkInventTrans</c> to update.
    /// </param>
    /// <param name = "_remainingQty">
    /// The remaining quantity.
    /// </param>
    private void updateWorkInventTransWeightIfCatchWeight(WHSWorkInventTrans _workInventTrans, InventQty _remainingQty = 0)
    {
        if (PdsGlobal::pdsIsCWItem(_workInventTrans.ItemId))
        {
            _workInventTrans.TransactionWeight          = WhsInvent::defaultCatchWeightReserveQuantity(_workInventTrans.ItemId, _workInventTrans.Qty);
            _workInventTrans.RemainingTransactionWeight = WhsInvent::defaultCatchWeightReserveQuantity(_workInventTrans.ItemId, _remainingQty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkInventTransInventDimToWithUserLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>WHSWorkInventTrans</c> inventory dimension id to if necessary.
    /// </summary>
    /// <param name = "_workInventTrans">
    /// The <c>WHSWorkInventTrans</c> which to update.
    /// </param>
    private void updateWorkInventTransInventDimToWithUserLocation(WHSWorkInventTrans _workInventTrans)
    {
        if (userId
            && !_workInventTrans.InventQtyRemain
            && !InventDim::find(_workInventTrans.InventDimIdTo).wMSLocationId)
        {
            InventDim inventDimTo = InventDim::find(_workInventTrans.InventDimIdTo);
            inventDimTo.wMSLocationId = userId;

            _workInventTrans.InventDimIdTo = InventDim::findOrCreate(inventDimTo).InventDimId;
            _workInventTrans.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeWorkInventTransFromWorkLineAndQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new <c>WHSWorkInventTrans</c> from the other <c>WHSWorkInventTrans</c>.
    /// </summary>
    /// <param name = "_workInventTrans">
    /// The <c>WHSWorkInventTrans</c> to be copied from by the new <c>WHSWorkInventTrans</c>.
    /// </param>
    /// <param name = "_workLine">
    /// The <c>WHSWorkLine</c> to which the <c>WHSWorkInventTrans</c> will be moved to.
    /// </param>
    /// <param name = "_workQty">The quantity to set on the new <c>WHSWorkInventTrans</c>.
    /// </param>
    /// <returns>
    /// The newly initialized <c>WHSWorkInventTrans</c> buffer.
    /// </returns>
    private WHSWorkInventTrans initializeWorkInventTransFromWorkLineAndQuantity(WHSWorkInventTrans _workInventTrans, WHSWorkLine _workLine, ProductQuantity _workQty)
    {
        WHSWorkInventTrans splitWorkInventTrans;
        buf2Buf(_workInventTrans, splitWorkInventTrans);
        splitWorkInventTrans.WorkId             = _workLine.WorkId;
        splitWorkInventTrans.LineNum            = _workLine.LineNum;
        splitWorkInventTrans.Qty                = _workQty;
        splitWorkInventTrans.InventQtyRemain    = splitWorkInventTrans.Qty;

        splitWorkInventTrans.InventoryTransactionOriginId = emptyGuid();
        splitWorkInventTrans.ItemSetId = emptyGuid();

        return splitWorkInventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeNewWorkLineFromOriginalWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the new <c>WHSWorkLine</c> form the original <c>WHSWorkLine</c>.
    /// </summary>
    /// <param name = "_originalWorkLine">The <c>WHSWorkLine</c> to initialize from.</param>
    /// <param name = "_newWorkLine">The <c>WHSWorkLine</c> to initialize.</param>
    protected static void initializeNewWorkLineFromOriginalWorkLine(WHSWorkLine _originalWorkLine, WHSWorkLine _newWorkLine)
    {
        buf2Buf(_originalWorkLine, _newWorkLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustReplenWorkLinks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates existing or creates new replenishment link.
    /// </summary>
    /// <param name="_newWorkLine">
    /// The new work line
    /// </param>
    private void adjustReplenWorkLinks(WHSWorkLine _newWorkLine)
    {
        ttsbegin;

        Qty runningQtyToKeepOnNewWorkLine = _newWorkLine.InventQtyRemain;
        WHSReplenWorkLink replenWorkLink;

        // in order to satisfy more demand work lines, sort replenishment work links by inventQty in ascending order.
        while select forupdate replenWorkLink
            order by InventQty asc
            where replenWorkLink.ReplenWorkId   == origWorkId
               && replenWorkLink.ReplenLineNum  == currentLineNum
        {
            if (runningQtyToKeepOnNewWorkLine >= replenWorkLink.InventQty)
            {
                replenWorkLink.ReplenWorkId = _newWorkLine.WorkId;
                replenWorkLink.ReplenLineNum = _newWorkLine.LineNum;
                runningQtyToKeepOnNewWorkLine -= replenWorkLink.InventQty;
            }
            else
            {
                WHSReplenWorkLink::insertReplenWorkLink(runningQtyToKeepOnNewWorkLine,
                                                        _newWorkLine.WorkId,
                                                        _newWorkLine.LineNum,
                                                        replenWorkLink.DemandWorkId,
                                                        replenWorkLink.DemandLineNum);

                replenWorkLink.InventQty -= runningQtyToKeepOnNewWorkLine;
                replenWorkLink.ReplenLineNum = origWorkLineNum;
                runningQtyToKeepOnNewWorkLine = 0;
            }
            replenWorkLink.update();
            
            if (runningQtyToKeepOnNewWorkLine == 0)
            {
                break;
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveWorkInventTransToOriginalWorkLineAndUpdateInventTransOrigin</Name>
				<Source><![CDATA[
    private void moveWorkInventTransToOriginalWorkLineAndUpdateInventTransOrigin(
        WHSWorkInventTrans _workInventTrans,
        WHSWorkLine _workLine)
    {
        if (WHSInventoryTransactionConfigurationProvider::shouldUseWarehouseInventoryTransactionStack(_workLine.WorkId))
        {
            WHSInventoryTransaction inventoryTransaction;
            inventoryTransaction.skipDataMethods(true);
            inventoryTransaction.skipEvents(true);

            update_recordset inventoryTransaction
                setting ReferenceId = _workLine.WorkId
                where inventoryTransaction.InventoryTransactionOriginId == _workInventTrans.InventoryTransactionOriginId;
        }
        else
        {
            // Update the reference ID for the from transaction.
            InventTransOrigin inventTransOrigin = InventTransOrigin::findByInventTransId(_workInventTrans.InventTransIdFrom, true);
            inventTransOrigin.ReferenceId = _workLine.WorkId;
            inventTransOrigin.update();

            // Update the reference ID for the to transaction.
            inventTransOrigin = InventTransOrigin::findByInventTransId(_workInventTrans.InventTransIdTo, true);
            inventTransOrigin.ReferenceId = _workLine.WorkId;
            inventTransOrigin.update();
        }

        // Move WHSWorkInventTrans record back to the original work line.
        _workInventTrans.WorkId  = _workLine.WorkId;
        _workInventTrans.LineNum = _workLine.LineNum;
        _workInventTrans.doUpdate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSplitWorkLine</Name>
				<Source><![CDATA[
    private boolean shouldSplitWorkLine()
    {
        return currentLineNum == lineNum
            || (WHSEnableFullQtyGroupPickFlight::instance().isEnabled()
                && groupPickLineNumber != 0
                && currentLineNum == groupPickLineNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleRemainingPickTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the remaining pick transactions associated with the original work.
    /// </summary>
    /// <param name="_workLineRecId">
    /// The record identifier for the original <c>WHSWorkLine</c> record
    /// </param>
    protected void handleRemainingPickTransaction(RefRecId _workLineRecId)
    {
        WHSWorkLine         workLine;
        Qty                 convertedQtyToPick;
        EcoResReleasedProductUnitConverter  releasedProductUnitConverter;

        ttsbegin;

        workLine = WHSWorkLine::findByRecId(_workLineRecId, true);
        
        this.initializeChangedToDoFields(workLine);

        if (this.shouldSplitWorkLine())
        {
            // Must add the qty that was already picked from this work line
            origQtyToPick = qtyToPick;

            // No need to consider QtyRemain for packing work when closing it as we expect to split Qty that is already packed therefore QtyRemain is reduced.
            if (!isSplitOnClosingPackingWork)
            {
                qtyToPick += workLine.InventQtyWork - workLine.InventQtyRemain;
            }

            releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();

            convertedQtyToPick = releasedProductUnitConverter.convert(qtyToPick,
                                                                 UnitOfMeasure::UnitOfMeasureIdBySymbol(WHSCatchWeightHelper::inventHandlingUnitId(workLine.ItemId)),
                                                                 UnitOfMeasure::unitOfMeasureIdBySymbol(workLine.UnitId),
                                                                 NoYes::No,
                                                                 workLine.ItemId,
                                                                 workLine.InventDimId,
                                                                 NoYes::No);

            origConvertedQtyToPick = releasedProductUnitConverter.convert(origQtyToPick,
                                                                 UnitOfMeasure::UnitOfMeasureIdBySymbol(WHSCatchWeightHelper::inventHandlingUnitId(workLine.ItemId)),
                                                                 UnitOfMeasure::unitOfMeasureIdBySymbol(workLine.UnitId),
                                                                 NoYes::No,
                                                                 workLine.ItemId,
                                                                 workLine.InventDimId,
                                                                 NoYes::No);
            // Already took remaining quantity into account if needed.
            qtyToDo         += workLine.QtyWork - convertedQtyToPick;
            qtyToDoInvent   += workLine.InventQtyWork - qtyToPick;

            qtyDone         += convertedQtyToPick;
            qtyDoneInvent   += qtyToPick;
        }
        else
        {
            qtyToDo         += workLine.QtyRemain;
            qtyToDoInvent   += workLine.InventQtyRemain;
        }

        prevToDoUnitId      = workLine.UnitId;
        prevToDoItemId      = workLine.ItemId;
        prevToDoInventDimId = workLine.InventDimId;

        if (this.shouldSplitWorkLine())
        {
            this.handleOrignalWorkLine(_workLineRecId, convertedQtyToPick);
        }
        else
        {
            this.handleFullOriginalWorkLine(workLine);
        }

        ++origWorkLineNum;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkLineLinksForNonInitialPickWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the links of a non initial pick line.
    /// </summary>
    [Hookable(false)]
    internal void updateWorkLineLinksForNonInitialPickWorkLine()
    {
        this.updateWorkInventoryTransactionReference(newWorkId, newWorkLineNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>increaseWorkLineCounter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the line counter when handling the non initial pick lines.
    /// </summary>
    [Hookable(false)]
    internal void increaseWorkLineCounter()
    {
        ++origWorkLineNum;
        ++newWorkLineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>renumberWorkLineOriginalWork</Name>
				<Source><![CDATA[
    private void renumberWorkLineOriginalWork(WHSWorkLine _workline)
    {
        if (isEnabledSplitWorkLineResolveDuplicateKeyFlight)
        {
            this.setWorkLineLineNum(_workline);
        }
        else 
        {
            _workLine.LineNum = origWorkLineNum;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processRemainingTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes any remaining transactions associated with the original work.
    /// </summary>
    /// <param name="_workLineRecId">
    /// The record identifier for the original work line record.
    /// </param>
    protected void processRemainingTransaction(RefRecId _workLineRecId)
    {
        ttsbegin;

        WHSWorkLine workLine = WHSWorkLine::findByRecId(_workLineRecId, true);

        this.generateNewWorkLine(workLine);

        if (workLine)
        {
            if(this.shouldRenumberWorkLineOriginalWork())
            {
                this.renumberWorkLineOriginalWork(workLine);
            }

            if (changedToDoItemId)
            {
                workLine.ItemId = prevToDoItemId;
            }

            workLine.InventDimId = this.getInventDimIdForNonInitialPickWorkLines(changedToDoProductVariants, changedToDoInventDimId, prevToDoInventDimId, prevToDoItemId);

            if ((changedToDoUnitId
                && workLine.UnitId)  // If multiple items exists for work type pick and unit id is null for the work type put, it should not update unit id of work line type put for the first work id.
                || (workLine.WorkType == WHSWorkType::Put
                     && workLine.LineNum == 2))   // If different items with multiple pick lines are present and only one pick line remains after splitting the work excluding staging pick put & Print scenario.
            {
                workLine.UnitId = prevToDoUnitId;
            }

            workLine.InventQtyWork      = qtyToDoInvent;
            workLine.InventQtyRemain    = qtyToDoInvent;
            this.updateWorkLineQuantities(workLine, qtyToDo);

            if(!changedToDoItemId || !changedToDoProductVariants)
            {
                workLine.ItemId = '';
            }
            workLine.update();
        }

        this.updateWorkLineLinksForNonInitialPickWorkLine();
        WHSWorkLine::rebuildItemSetOnPutLineBasedOnPreviousPicks(newWorkId, newWorkLineNum);

        this.increaseWorkLineCounter();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the values for the <c>WHSSplitWork</c> class
    /// </summary>
    protected void initValues()
    {
        changedDoneUnitId       = true;
        changedDoneItemId       = true;
        changedDoneInventDimId  = true;
        changedDoneProductVariants = true;
        changedToDoItemId       = true;
        changedToDoUnitId       = true;
        changedToDoInventDimId  = true;
        changedToDoProductVariants = true;

        origWorkLineNum = 1;
        newWorkLineNum  = 1;
        workLineNumCounter = 1;
        
        if (isEnabledSplitWorkLineResolveDuplicateKeyFlight)
        {
            this.initWorkLineNumMap();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initWorkLineNumMap</Name>
				<Source><![CDATA[
    internal void initWorkLineNumMap()
    {
        WHSWorkLine workLine;
        int num = 1;
        workLineNumMap = new Map(Types::Integer, Types::Real);

        while select workLine
            order by LineNum
            where workLine.WorkId == origWorkId
        {
            workLineNumMap.insert(num, workLine.LineNum);
            num++;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWorkLineWithQuantity</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal final Map parmWorkLineWithQuantity(Map _workLineWithQuantity = workLineWithQuantity)
    {
        workLineWithQuantity = _workLineWithQuantity;

        return workLineWithQuantity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineNum</Name>
				<Source><![CDATA[
    public LineNum parmLineNum(LineNum _lineNum = lineNum)
    {
        lineNum = _lineNum;

        return lineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOrigWorkId</Name>
				<Source><![CDATA[
    public WHSWorkId parmOrigWorkId(WHSWorkId _origWorkId = origWorkId)
    {
        origWorkId = _origWorkId;

        return origWorkId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUserId</Name>
				<Source><![CDATA[
    public WHSUserId parmUserId(WHSUserId _userId = userId)
    {
        userId = _userId;

        return userId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQtyToPick</Name>
				<Source><![CDATA[
    public Qty parmQtyToPick(Qty _qtyToPick = qtyToPick)
    {
        qtyToPick = _qtyToPick;

        return qtyToPick;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsSplitOnClosingPackingWork</Name>
				<Source><![CDATA[
    internal boolean parmIsSplitOnClosingPackingWork(boolean _isSplitOnClosingPackingWork = isSplitOnClosingPackingWork)
    {
        isSplitOnClosingPackingWork = _isSplitOnClosingPackingWork;

        return isSplitOnClosingPackingWork;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmGroupPickLineNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// The work line number that is at the end of the grouped sequence not being split
    /// </summary>
    /// <param name = "_groupPickLineNumber">
    /// <c>LineNum</c> record.
    /// </param>
    /// <returns>
    /// <c>LineNum</c> record.
    /// </returns>
    public final LineNum parmGroupPickLineNum(LineNum _groupPickLineNumber = groupPickLineNumber)
    {
        groupPickLineNumber = _groupPickLineNumber;

        return groupPickLineNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setChangedDoneValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the variables used to determine if values have been changed on closed pick transactions
    /// </summary>
    /// <param name="_workLine">
    /// The <c>WHSWorkLine</c> table record
    /// </param>
    private void setChangedDoneValues(WHSWorkLine _workLine)
    {
        if (prevDoneUnitId && prevDoneUnitId != _workLine.UnitId && prevDoneWorkType == _workLine.WorkType)
        {
            changedDoneUnitId = false;
        }
        
        if (prevDoneInventDimId && !InventDim::isInventDimEqual(InventDim::find(prevDoneInventDimId), _workLine.inventDim()))
        {
            changedDoneInventDimId = false;
        }

        if (prevDoneItemId && (prevDoneItemId != _workLine.ItemId || InventTable::areProductVariantsDifferent(_workLine.ItemId, _workLine.InventDimId, prevDoneInventDimId)))
        {
            changedDoneItemId = false;
        }

        if (prevDoneInventDimId && InventDim::areProductVariantsDifferent(_workLine.ItemId, _workLine.InventDimId, prevDoneInventDimId))
        {
            changedDoneProductVariants = false;
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeChangedToDoFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the variables used to determine if values have been changed on open pick transactions.
    /// </summary>
    /// <param name="_workLine">
    /// The <c>WHSWorkLine</c> table record
    /// </param>
    protected final void initializeChangedToDoFields(WHSWorkLine _workLine)
    {
        if (prevToDoUnitId && prevToDoUnitId != _workLine.UnitId)
        {
            changedToDoUnitId = false;
        }
        
        if (prevToDoInventDimId && !InventDim::isInventDimEqual(InventDim::find(prevToDoInventDimId), _workLine.inventDim()))
        {
            changedToDoInventDimId = false;
        }

        if (prevToDoItemId && (prevToDoItemId != _workLine.ItemId || InventTable::areProductVariantsDifferent(_workLine.ItemId, _workLine.InventDimId, prevToDoInventDimId)))
        {
            changedToDoItemId = false;
        }

        if (prevToDoInventDimId && InventDim::areProductVariantsDifferent(_workLine.ItemId, _workLine.InventDimId, prevToDoInventDimId))
        {
            changedToDoProductVariants = false;
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLockOrigWork</Name>
				<Source><![CDATA[
    public boolean parmLockOrigWork(boolean _lockOrigWork = lockOrigWork)
    {
        lockOrigWork = _lockOrigWork;

        return lockOrigWork;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreateNewWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates work quantities and pick lines, if new work must be created.
    /// </summary>
    /// <param name = "_workLine">The work line record.</param>
    /// <returns>true if new work must be created; otherwise, false.</returns>
    protected boolean mustCreateNewWork(WHSWorkLine _workLine)
    {
        return (qtyToPick != _workLine.InventQtyRemain)
            || WHSWorkTable::find(origWorkId).hasOpenPickLinesPriorToFirstPut();
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitMultipleWorkLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Splits the specified work lines from the current work ID.
    /// </summary>
    /// <returns>Returns the newly created work ID</returns>    
    protected internal final WHSWorkId splitMultipleWorkLines()
    {
        MapEnumerator me = workLineWithQuantity.getEnumerator();

        while (me.moveNext())
        {
            var origWorkLine = WHSWorkLine::find(origWorkId, me.currentKey());
            if (!this.validateSplitQuantityDecimals(origWorkLine, me.currentValue()))
            {
                throw error("@SYS18447");
            }
        }

        ttsbegin;

        this.updateHeaderRecords();

        WHSWorkLine workLine;

        while select LineNum, WorkType, WorkStatus, RecId from workLine
            order by LineNum
            where workLine.WorkId == origWorkId
        {
            currentLineNum = workLine.LineNum;

            if (workLine.LineNum > 1 &&
                workLine.WorkType != WHSWorkType::Pick &&
                workLine.WorkStatus != WHSWorkStatus::Cancelled)
            {
                doneWithPicks = true;
            }

            if (workLine.WorkStatus == WHSWorkStatus::Cancelled)
            {
                this.handleCancelledWorkLineStayingOnOriginalWorkHeader(workLine.RecId);
            }
            else if (!workLineWithQuantity.exists(currentLineNum)
                && workLine.WorkStatus == WHSWorkStatus::Closed)  // Picks that have been done
            {
                this.updateClosedPickTransaction(workLine.RecId);
            }
            else if (!doneWithPicks)    // Picks remaining
            {
                if (workLineWithQuantity.exists(currentLineNum))
                {
                    // Setting these from the map so handleRemainingPickTransactions() will know its a line that could be partial quantity.
                    lineNum = currentLineNum;
                    qtyToPick = workLineWithQuantity.lookup(currentLineNum);
                }

                this.handleRemainingPickTransaction(workLine.RecId);

                // reset the class variables
                lineNum = 0;
                qtyToPick = 0;

            }
            else if (doneWithPicks)     // Everything else
            {
                this.processRemainingTransaction(workLine.RecId);
            }

            if (isEnabledSplitWorkLineResolveDuplicateKeyFlight)
            {
                this.setNextWorkLineCounters(workLine);
            }
        }

        WHSWorkTable::updateWorkStatusFromWorkLines(newWorkId);

        ttscommit;
        
        WHSWorkLineCache::remove(origWorkId);

        return newWorkId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Splits the specified work from the current work ID
    /// </summary>
    /// <returns>
    /// Returns the newly created work ID
    /// </returns>
    public WHSWorkId splitWork()
    {
        var origWorkLine = WHSWorkLine::find(origWorkId, lineNum);
        if (!this.validateSplitQuantityDecimals(origWorkLine, qtyToPick))
        {
            throw error("@SYS18447");
        }

        doneWithPicks = false;

        if (this.mustCreateNewWork(origWorkLine))
        {
            ttsbegin;

            this.updateHeaderRecords();

            this.splitWorkLines();
           
            WHSWorkTable::updateWorkStatusFromWorkLines(newWorkId);

            ttscommit;
        }
        else
        {
            newWorkId = origWorkId;
        }

        WHSWorkLineCache::remove(origWorkId);

        return newWorkId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitWorkLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the movement of the work lines from the original work to the new work.
    /// </summary>
    [Hookable(false)]
    protected void splitWorkLines()
    {
        WHSWorkLine workLine;

        while select workLine
            order by LineNum
            where workLine.WorkId == origWorkId
        {
            currentLineNum = workLine.LineNum;

            if (workLine.LineNum > 1 &&
                workLine.WorkType != WHSWorkType::Pick &&
                workLine.WorkStatus != WHSWorkStatus::Cancelled)
            {
                doneWithPicks = true;
            }

            if (workLine.WorkStatus == WHSWorkStatus::Cancelled)
            {
                this.handleCancelledWorkLineStayingOnOriginalWorkHeader(workLine.RecId);
            }
            else if (this.shouldWorkLineBeMovedToNewWork(workLine))
            {
                this.handleWorkLineMovingToNewWorkHeader(workLine.RecId);
            }
            else if (!doneWithPicks)
            {
                this.handleWorkLineStayingOnOriginalWorkHeader(workLine.RecId);
            }
            else if (doneWithPicks)
            {
                this.handleNonInitialPickWorkLine(workLine.RecId);
            }

            if (isEnabledSplitWorkLineResolveDuplicateKeyFlight)
            {
                this.setNextWorkLineCounters(workLine);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldWorkLineBeMovedToNewWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the passed work line should be moved to the new work header.
    /// </summary>
    /// <param name = "_workLine">The workLine.</param>
    /// <returns>true, if the work is blocked by the passed reason type; otherwise, false.</returns>
    [Hookable(false)]
    protected boolean shouldWorkLineBeMovedToNewWork(WHSWorkLine _workLine)
    {
        return (_workLine.LineNum != lineNum && _workLine.WorkStatus == WHSWorkStatus::Closed
                || (this.parmGroupPickLineNum() != 0
                        && _workLine.LineNum >= lineNum
                        && _workLine.LineNum < this.parmGroupPickLineNum()));

    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldRenumberWorkLineOriginalWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the work lines should be renumbered on original work.
    /// </summary>
    ///<returns>true, if the work lines should be renumbered on original work; otherwise, false.</returns>
    protected boolean shouldRenumberWorkLineOriginalWork()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleNonInitialPickWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the non initial pick work lines when splitting work.
    /// </summary>
    /// <param name = "_workLineRecId">The RecId of the workLine.</param>
    [Hookable(false)]
    protected void handleNonInitialPickWorkLine(WHSWorkLineRecId _workLineRecId)
    {
        this.processRemainingTransaction(_workLineRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleWorkLineMovingToNewWorkHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the work lines which are moving to the new work header when splitting work.
    /// </summary>
    /// <param name = "_workLineRecId">The RecId of the workLine.</param>
    [Hookable(false)]
    protected void handleWorkLineMovingToNewWorkHeader(WHSWorkLineRecId _workLineRecId)
    {
        this.updateClosedPickTransaction(_workLineRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleWorkLineStayingOnOriginalWorkHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the work lines which are staying on the original work header when splitting work.
    /// </summary>
    /// <param name = "_workLineRecId">The RecId of the workLine.</param>
    [Hookable(false)]
    protected void handleWorkLineStayingOnOriginalWorkHeader(WHSWorkLineRecId _workLineRecId)
    {
        this.handleRemainingPickTransaction(_workLineRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSplitQuantityDecimals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the number of decimals in qtyToPick is less than or equal to the number of decimals of the inventory handling unit of item.
    /// </summary>
    /// <param name = "_workLine">Work line record.</param>
    /// <param name = "_qtyToCheck">Quantity to be validated.</param>
    /// <returns>true if validation is successful; otherwise, false.</returns>
    protected final boolean validateSplitQuantityDecimals(
        WHSWorkLine _workLine,
        Qty         _qtyToCheck)
    {
        boolean result = true;

        var inventUnitDecimals = WHSCatchWeightHelper::inventHandlingUnitDecimals(_workLine.ItemId);
        if (numOfDec(_qtyToCheck) > inventUnitDecimals)
        {
            result = checkFailed(strfmt("@SYS83631", inventUnitDecimals));
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveCurrentWorkLineToNewWorkHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Moves the current work line from the original work to the new work.
    /// </summary>
    /// <param name = "_whsWorkLine">The work line which will be moved.</param>
    protected void moveCurrentWorkLineToNewWorkHeader(WHSWorkLine _whsWorkLine)
    {
        _whsWorkLine.WorkId     = newWorkId;
        
        if (isEnabledSplitWorkLineResolveDuplicateKeyFlight)
        {
            this.setWorkLineLineNum(_whsWorkLine, newWorkLineNum);
        }
        else 
        {
            _whsWorkLine.LineNum    = newWorkLineNum;
        }
        
        _whsWorkLine.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveCurrentWorkLineLinksToNewWorkHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Moves the links related to the current work line from the original work to the new work.
    /// </summary>
    protected void moveCurrentWorkLineLinksToNewWorkHeader()
    {
        this.updateWorkInventoryTransactionReference(newWorkId, newWorkLineNum);
        this.updateWorkTransactionReference(newWorkId, newWorkLineNum);
        this.updateDimensionTrackingReference(newWorkId, newWorkLineNum);
        this.updateWorkExceptionLog(newWorkId, newWorkLineNum);
        this.updateReplenishmentWorkLinks(newWorkId, newWorkLineNum);

        this.updateFrozenWorkReference(newWorkId);
        
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateClosedPickTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the closed pick transactions associated with the original work.
    /// </summary>
    /// <param name="_workLineRecId">
    /// The record identifier for the original work line record.
    /// </param>
    protected void updateClosedPickTransaction(RefRecId _workLineRecId)
    {
        ttsbegin;

        WHSWorkLine workLine = WHSWorkLine::findByRecId(_workLineRecId, true);

        this.setChangedDoneValues(workLine);

        qtyDone            += workLine.QtyWork;
        qtyDoneInvent      += workLine.InventQtyWork;

        this.setPrevDoneValuesFromWorkLine(workLine);

        this.moveCurrentWorkLineLinksToNewWorkHeader();

        if (workLine)
        {
            this.moveCurrentWorkLineToNewWorkHeader(workLine);
           
            if (!doneWithPicks)
            {
                this.setItemIdRemainLineOfNewWork(workLine);
            }
        }

        ++newWorkLineNum;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPrevDoneValuesFromWorkLine</Name>
				<Source><![CDATA[
    private void setPrevDoneValuesFromWorkLine(WHSWorkLine _workLine)
    {
        prevDoneUnitId      = _workLine.UnitId;
        prevDoneItemId      = _workLine.ItemId;
        prevDoneWorkType    = _workLine.WorkType;
        prevDoneInventDimId = _workLine.InventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDimensionTrackingReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the work identifier and line number for <c>WHSDimTracking</c> records
    /// </summary>
    /// <param name="_workId">
    /// The new work identifier
    /// </param>
    /// <param name="_lineNum">
    /// The new line number
    /// </param>
    private void updateDimensionTrackingReference(WHSWorkId _workId, LineNum _lineNum)
    {
        WHSDimTracking::moveToNewWorkLine(origWorkId, currentLineNum, _workId, _lineNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateHeaderRecords</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates all header records tied to the original work and generates a new work table header.
    /// </summary>
    protected final void updateHeaderRecords()
    {
        ttsbegin;

        WHSWorkTable origWorkTable = WHSWorkTable::find(origWorkId, true);
        WHSInventoryTransactionMechanismEnum origTransactionMechanism = origWorkTable.InventoryTransactionMechanism;

        // When splitting work enforce using the same inventory transaction mechanism for the new work
        using (var context = WHSEnforceInventoryTransactionMechanismContext::defaultInventoryTransactionMechanism(origTransactionMechanism))
        {
            WHSLicensePlateId targetLicensePlateId;

            if (origWorkTable)
            {
                targetLicensePlateId = origWorkTable.TargetLicensePlateId;

                this.initializeOriginalWorkTableForUpdate(origWorkTable);

                origWorkTable.update();
            }

            WHSWorkTable newWorkTable;
            buf2Buf(origWorkTable, newWorkTable);

            newWorkTable.setWorkId();

            newWorkTable.TargetLicensePlateId = targetLicensePlateId;
            newWorkTable.insert();

            newWorkId = newWorkTable.WorkId;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeOriginalWorkTableForUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the original work header for update.
    /// </summary>
    /// <param name = "_workTable">The work header record.</param>
    protected void initializeOriginalWorkTableForUpdate(WHSWorkTable _workTable)
    {
        _workTable.TargetLicensePlateId      = '';
        _workTable.WorkStatus                = WHSWorkStatus::Open;
        _workTable.WorkClosedUTCDateTime     = utcDateTimeNull();
        _workTable.WorkInProcessUTCDateTime  = utcDateTimeNull();

        if (!lockOrigWork)
        {
            _workTable.LockedUser = '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkInventoryTransactionReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the reference and line number for the original <c>WHSWorkInventTrans</c> and <c>InventTransOrigin</c> records.
    /// </summary>
    /// <param name="_workId">
    /// The new work identifier.
    /// </param>
    /// <param name="_lineNum">
    /// The new line number.
    /// </param>
    protected final void updateWorkInventoryTransactionReference(WHSWorkId _workId, LineNum _lineNum)
    {
        WHSWorkInventTrans::moveToNewWorkLine(origWorkId, currentLineNum, _workId, _lineNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkTransactionReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the work identifier and line number for work transaction records.
    /// </summary>
    /// <param name="_workId">
    /// The new work identifier.
    /// </param>
    /// <param name="_lineNum">
    /// The new line number.
    /// </param>
    protected final void updateWorkTransactionReference(WHSWorkId _workId, LineNum _lineNum)
    {
        WHSWorkTrans::moveToNewWorkLine(origWorkId, currentLineNum, _workId, _lineNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkExceptionLog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the work exception log with the new work identifier and line number.
    /// This applies to work lines that were short picked, for example.
    /// </summary>
    /// <param name = "_workId">The new work identifier.</param>
    /// <param name = "_lineNum">The new line number.</param>
    protected final void updateWorkExceptionLog(WHSWorkId _workId, LineNum _lineNum)
    {
        WHSWorkExceptionLog::moveToNewWorkLine(origWorkId, currentLineNum, _workId, _lineNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReplenishmentWorkLinks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update replenishment work links.
    /// </summary>
    /// <param name = "_workId">Work id.</param>
    /// <param name = "_lineNum">Line Number.</param>
    protected final void updateReplenishmentWorkLinks(WHSWorkId _workId, LineNum _lineNum)
    {
        WHSReplenWorkLink::moveToNewWorkLine(origWorkId, currentLineNum, _workId, _lineNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    private static WHSSplitWork construct()
    {
        return new WHSSplitWork();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newStandard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>WHSSplitWork</c> class.
    /// </summary>
    /// <param name="_origWorkId">
    /// The original work identifier
    /// </param>
    /// <param name="_lineNum">
    /// The original line number from the <c>WHSWorkLine</c> table
    /// </param>
    /// <param name="_qtyToPick">
    /// The quantity that remains to be picked for the specified line
    /// </param>
    /// <param name="_lockOrigWork">
    /// True if the original work should remain locked by the worker who split the work; otherwise false
    /// </param>
    /// <param name="_userId">
    /// The RF user processing the work.
    /// </param>
    /// <returns>
    /// An instance of the <c>WHSSplitWork</c> class.
    /// </returns>
    public static WHSSplitWork newStandard(
        WHSWorkId   _origWorkId,
        LineNum     _lineNum,
        Qty         _qtyToPick,
        boolean     _lockOrigWork = false,
        WHSUserId   _userId = '')
    {
        WHSSplitWork  whsSplitWork = WHSSplitWork::construct();

        whsSplitWork.parmOrigWorkId(_origWorkId);
        whsSplitWork.parmLineNum(_lineNum);
        whsSplitWork.parmQtyToPick(_qtyToPick);
        whsSplitWork.parmLockOrigWork(_lockOrigWork);
        whsSplitWork.parmUserId(_userId);

        whsSplitWork.initValues();

        return whsSplitWork;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromMultipleWorkLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>WHSSplitWork</c> class for processing several work lines at once.
    /// </summary>
    /// <param name = "_origWorkId">The original work ID.</param>
    /// <param name = "_workLineWithQuantity">A map containing the work lines and quantity that should be split.</param>
    /// <param name = "_lockOrigWork">True if the original work should remain locked by the worker who split the work; otherwise false</param>
    /// <param name="_userId">The RF user processing the work.</param>
    /// <returns>An instance of the <c>WHSSplitWork</c> class.</returns>
    [Hookable(false)]
    internal static WhsSplitWork newFromMultipleWorkLines(
        WHSWorkId   _origWorkId,
        Map         _workLineWithQuantity,
        boolean     _lockOrigWork,
        WHSUserId   _userId)
    {
        WHSSplitWork  whsSplitWork = WHSSplitWork::construct();

        whsSplitWork.parmOrigWorkId(_origWorkId);
        whsSplitWork.parmWorkLineWithQuantity(_workLineWithQuantity);
        whsSplitWork.parmLockOrigWork(_lockOrigWork);
        whsSplitWork.parmUserId(_userId);

        whsSplitWork.initValues();

        return whsSplitWork;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromGroupedWorkLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>WHSSplitWork</c> class for grouped work.
    /// </summary>
    /// <param name="_origWorkId">
    /// The original work identifier
    /// </param>
    /// <param name="_lineNum">
    /// The original line number that is at the beginning of the grouped sequence not being split
    /// </param>
    /// <param name="_groupLineNum">
    /// The original work line number that is at the end of the grouped sequence not being split
    /// </param>
    /// <param name="_qtyToPick">
    /// The quantity that remains to be picked for the specified line
    /// </param>
    /// <param name="_lockOrigWork">
    /// True if the original work should remain locked by the worker who split the work; otherwise false
    /// </param>
    /// <param name="_userId">
    /// The RF user processing the work.
    /// </param>
    /// <returns>
    /// An instance of the <c>WHSSplitWork</c> class.
    /// </returns>
    [Hookable(false)]
    internal static WhsSplitWork newFromGroupedWorkLines(
        WHSWorkId   _origWorkId,
        LineNum     _lineNum,
        LineNum     _groupLineNum,
        Qty         _qtyToPick,
        boolean     _lockOrigWork,
        WHSUserId   _userId)
    {
        WhsSplitWork splitWork = WhsSplitWork::newStandard(_origWorkId, _lineNum, _qtyToPick, _lockOrigWork, _userId);

        splitWork.parmGroupPickLineNum(_groupLineNum);

        return splitWork;
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitFrozenWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Splits a frozen work line to pick the frozen quantity from a new location
    /// </summary>
    /// <param name = "_workLine">
    /// The original work line that will be split.
    /// </param>
    /// <param name = "_workInventTrans">
    /// The <c>WHSWorkInventTrans</c> record that is being reduced.
    /// </param>
    /// <param name = "_newLocationId">
    /// The location that the new work line will pick from.
    /// </param>
    /// <param name = "_newPickDimId">
    /// The <c>InventDimId</c> with the new location for the new WIT.
    /// </param>
    public static void splitFrozenWorkLine(
        WHSWorkLine         _workLine,
        WHSWorkInventTrans  _workInventTrans,
        WMSLocationId       _newLocationId,
        InventDimId         _newPickDimId)
    {
        WHSWorkLine        workLine = _workLine;
        WHSWorkLine        newWorkLine;
        WHSWorkInventTrans newWorkInventTrans;
        WHSWorkInventTrans workInventTrans = _workInventTrans;
        InventHandlingUnitId inventHandlingUnit = WHSCatchWeightHelper::inventHandlingUnitId(workLine.ItemId);

        #WHSLineNumSplit

        InventHandlingQty newInventHandlingQty = workLine.InventQtyWork - workInventTrans.Qty;

        if (newInventHandlingQty <= 0
        ||  workLine.WMSLocationId == _newLocationId)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        ttsbegin;

        WhsSplitWork::initializeNewWorkLineFromOriginalWorkLine(workLine, newWorkLine);
        buf2Buf(workInventTrans, newWorkInventTrans);

        workLine.InventQtyWork   = workInventTrans.Qty;
        workLine.InventQtyRemain = workInventTrans.InventQtyRemain;
        workLine.QtyWork         = workLine.InventQtyWork;
        workLine.QtyRemain       = workLine.InventQtyRemain;
        workLine.UnitId          = inventHandlingUnit;
        workLine.update();
        
        newWorkLine.UnitId          = inventHandlingUnit;
        newWorkLine.LineNum         = WHSWorkLine::getNewLineNumForSplittedWorkLine(workLine.WorkId, workLine.LineNum);
        newWorkLine.WMSLocationId   = _newLocationId;
        newWorkLine.InventQtyWork   = newInventHandlingQty;
        newWorkLine.InventQtyRemain = newInventHandlingQty;
        newWorkLine.QtyWork         = newInventHandlingQty;
        newWorkLine.QtyRemain       = newInventHandlingQty;
        newWorkLine.insert();

        newWorkInventTrans.Qty             = newInventHandlingQty;
        newWorkInventTrans.InventQtyRemain = newInventHandlingQty;
        newWorkInventTrans.LineNum         = newWorkLine.LineNum;
        newWorkInventTrans.InventDimIdFrom = _newPickDimId;

        if (PdsGlobal::pdsIsCWItem(newWorkInventTrans.ItemId))
        {
            newWorkInventTrans.TransactionWeight           = WhsInvent::defaultCatchWeightReserveQuantity(newWorkInventTrans.ItemId, newWorkInventTrans.Qty);
            newWorkInventTrans.RemainingTransactionWeight  = newWorkInventTrans.TransactionWeight;
        }

        newWorkInventTrans.insert();
        
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkLineQuantities</Name>
				<Source><![CDATA[
    private void updateWorkLineQuantities(WHSWorkLine _workLine, Qty _qtyToCheck)
    {
        if (_workLine.itemId)
        {
            if (_qtyToCheck == _workLine.InventQtyWork)
            {
                _workLine.QtyWork   = _workLine.InventQtyWork;

                // For packing work split QtyRemain on the original work line should keep the value as QtyRemain being cut from it should be zero.
                if (!isSplitOnClosingPackingWork)
                {
                    _workLine.QtyRemain = _workLine.InventQtyRemain;
                }

                _workLine.UnitId = WHSCatchWeightHelper::inventHandlingUnitId(_workLine.ItemId);
            }
            else
            {
                UnitOfMeasureSymbol inventHandlingUnitId = WHSCatchWeightHelper::inventHandlingUnitId(_workLine.ItemId);
                [_workLine.QtyWork, _workLine.UnitId] = WHSInventTable::getHighestUnitQtyByUOMSeqGroup(
                                                                            _workLine.itemId,
                                                                            _workLine.InventQtyWork,
                                                                            inventHandlingUnitId,
                                                                            _workLine.InventDimId);

                // For packing work split QtyRemain on the original work line should keep the value as QtyRemain being cut from it should be zero.
                if (!isSplitOnClosingPackingWork)
                {
                    if (_workLine.InventQtyWork == _workLine.InventQtyRemain)
                    {
                        _workLine.QtyRemain = _workLine.QtyWork;
                    }
                    else
                    {
                        _workLine.QtyRemain = EcoResReleasedProductUnitConverter::construct().convert(_workLine.InventQtyRemain,
                                                                   UnitOfMeasure::unitOfMeasureIdBySymbol(inventHandlingUnitId),
                                                                   UnitOfMeasure::unitOfMeasureIdBySymbol(_workLine.UnitId),
                                                                   NoYes::No,
                                                                   _workLine.itemId,
                                                                   _workLine.InventDimId,
                                                                   NoYes::No);
                    }
                }
            }
        }
        else
        {
            _workLine.QtyWork       = _workLine.InventQtyWork;
            _workLine.QtyRemain     = _workLine.InventQtyRemain;
            _workLine.UnitId = '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setItemIdRemainLineOfNewWork</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Set the item ID value for remain work line except the pick line before the first put.
    /// </summary>
    /// <param name="_workLinePickOfNewWork">
    ///     The pick line before first put of the new work.
    /// </param>
    private void setItemIdRemainLineOfNewWork(WHSWorkLine  _workLinePickOfNewWork)
    {
        if (!newWorkHasMultiItems)
        {
            if ((prevItemIdOfNewWork && prevItemIdOfNewWork != _workLinePickOfNewWork.ItemId)
            || (prevInventDimIdOfNewWork && InventDim::areProductVariantsDifferent(_workLinePickOfNewWork.ItemId, _workLinePickOfNewWork.InventDimId, prevInventDimIdOfNewWork)))
            {
                itemIdRemainLine = '';
                newWorkHasMultiItems = true;
            }
            else
            {
                itemIdRemainLine = _workLinePickOfNewWork.ItemId;
            }

            prevItemIdOfNewWork = _workLinePickOfNewWork.ItemId;
            prevInventDimIdOfNewWork = _workLinePickOfNewWork.InventDimId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFrozenWorkReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the work identifier for <c>WHSWorkFrozen</c> records
    /// </summary>
    /// <param name="_workId">
    /// The new work identifier
    /// </param>
    private void updateFrozenWorkReference(WHSWorkId _workId)
    {
        WHSWorkFrozen::moveToNewWork(origWorkId, _workId);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>