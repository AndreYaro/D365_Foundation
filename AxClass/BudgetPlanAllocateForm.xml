<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BudgetPlanAllocateForm</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>BudgetPlanAllocateForm</c> class supports the business logic of the <c>BudgetPlanAllocate</c> form.
/// </summary>
public class BudgetPlanAllocateForm
{
    FormComboboxControl         allocationMethod;
    FormStringControl           ledgerAllocateKey;
    FormStringControl           ledgerAllocationRule;
    FormStringControl           allocationTerm;
    FormStringControl           sourceDocumentNumber;
    FormStringControl           sourceScenarioName;
    FormStringControl           basisScenarioName;
    FormStringControl           targetScenarioName;
    FormRealControl             factor;
    FormCheckBoxControl         appendLines;
    FormCheckBoxControl         useSourceEffectiveDates;
    FormCommandButtonControl    okButton;

    BudgetPlanAllocateContract  allocateContract;

    boolean                     canAddLinesOnParent;
    BudgetPlanLineActiveView    budgetPlanLineActiveView;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>validateBudgetPlanAllocateType</Name>
				<Source><![CDATA[
    //
    // Allocate Type form control methods
    //
    /// <summary>
    /// Validates the modification of the <c>BudgetPlanAllocateType</c> field.
    /// </summary>
    /// <param name="_allocationMethod"> The modified <c>BudgetPlanAllocateType</c> type. </param>
    /// <returns> true, if the modification is valid; otherwise, false. </returns>
    public boolean validateBudgetPlanAllocateType(BudgetPlanAllocateType _allocationMethod)
    {
        boolean isValid = true;

        if (!BudgetPlan::doesBudgetPlanHaveChild(allocateContract.parmParentBudgetPlanHeaderRecId()))
        {
            switch (_allocationMethod)
            {
                case BudgetPlanAllocateType::AllocateByChildren:
                    isValid = checkFailed("@Budget:NoAssociatedPlansForAggregationWarning");

                    break;

                case BudgetPlanAllocateType::AllocateByParent:
                    isValid = checkFailed("@Budget:NoAssociatedPlansForDistributionWarning");

                    break;
            }
        }

        if (isValid)
        {
            switch (_allocationMethod)
            {
                case BudgetPlanAllocateType::AllocateByChildren,
                        BudgetPlanAllocateType::AllocateByDimension,
                        BudgetPlanAllocateType::AllocateByPeriod,
                        BudgetPlanAllocateType::AllocateByLedgerRule:

                    if (!canAddLinesOnParent)
                    {
                        // Parent(Destination budget plan) MUST allow adding line for the process and current workflow stage.
                        isValid = checkFailed("@Budget:CannotAddLinesToBudgetPlanWarning");
                    }
                    break;
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allocationMethodSelectionChange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the allocate contract data member attribute and modifies the form control visibility when the allocation method control is modified.
    /// </summary>
    /// <param name = "_isModified"> A boolean determining if the field was modified or not. </param>
    public void allocationMethodSelectionChange(boolean _isModified)
    {
        if (_isModified)
        {
            allocateContract.parmAllocationMethod(allocationMethod.selection());

            this.clearScenarioControls();
            this.setControlsVisibility();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>jumpRefAllocateKey</Name>
				<Source><![CDATA[
    //
    // Ledger Allocate Key form control methods
    //
    /// <summary>
    /// Navigates the user to the selected ledger allocate key record.
    /// </summary>
    public void jumpRefAllocateKey()
    {
        changeCompany(CompanyInfo::getDataArea(allocateContract.parmLegalEntityRecId()))
        {
            LedgerAllocateKey ledgerAllocateKeyRecord = LedgerAllocateKey::find(ledgerAllocateKey.text());

            LedgerAllocateKey::jumpRefLedgerAllocateKey(ledgerAllocateKeyRecord, ledgerAllocateKey);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupAllocateKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves ledger allocate key records for selection.
    /// </summary>
    public void lookupAllocateKey()
    {
        BudgetPlanAllocateByPeriod::ledgerAllocateKeyLookup(ledgerAllocateKey, allocateContract.parmLegalEntityRecId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedAllocateKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the allocate contract data member attribute and modifies the form control visibility when the allocate key control is modified.
    /// </summary>
    /// <param name = "_isModified"> A boolean determining if the field was modified or not. </param>
    public void modifiedAllocateKey(boolean _isModified)
    {
        if (_isModified)
        {
            allocateContract.parmLedgerAllocateKeyId(ledgerAllocateKey.valueStr());
            this.setEnabledAllocatePlanButton();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAllocateKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the selected allocate key.
    /// </summary>
    /// <param name = "_allocateKeyId"> The <c>LedgerAllocateKeyId</c> to validate. </param>
    /// <returns> true, if the allocate key is valid; otherwise, false. </returns>
    public boolean validateAllocateKey(LedgerAllocateKeyId _allocateKeyId)
    {
        return BudgetPlanAllocateByPeriod::validatePeriodAllocationKey(_allocateKeyId, allocateContract.parmLegalEntityRecId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupLedgerAllocationRule</Name>
				<Source><![CDATA[
    //
    // Ledger Allocation Rule form control methods
    //
    /// <summary>
    /// Retrieves ledger allocation rule records for selection.
    /// </summary>
    public void lookupLedgerAllocationRule()
    {
        BudgetPlanAllocateByLedgerAllocationRule::ledgerAllocationRuleLookup(ledgerAllocationRule, allocateContract.parmLegalEntityRecId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedLedgerAllocationRule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the allocate contract data member attribute and modifies the form control visibility when the ledger allocation rule control is modified.
    /// </summary>
    /// <param name = "_isModified"> A boolean determining if the field was modified or not. </param>
    public void modifiedLedgerAllocationRule(boolean _isModified)
    {
        if (_isModified)
        {
            allocateContract.parmLedgerAllocationRuleID(ledgerAllocationRule.valueStr());
            this.setControlsVisibility();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLedgerAllocationRule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the selected ledger allocation rule.
    /// </summary>
    /// <param name = "_ledgerAllocationRuleID"> The <c>LedgerAllocationRuleID</c> to validate. </param>
    /// <returns> true, if the ledger allocation rule is valid; otherwise, false. </returns>
    public boolean validateLedgerAllocationRule(LedgerAllocationRuleID _ledgerAllocationRuleID)
    {
        return BudgetPlanAllocateByLedgerAllocationRule::validateLedgerAllocationRule(_ledgerAllocationRuleID, allocateContract.parmLegalEntityRecId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>jumpRefAllocationTerm</Name>
				<Source><![CDATA[
    //
    // Allocation term form control methods
    //
    /// <summary>
    /// Navigates the user to the selected budget allocation term record.
    /// </summary>
    public void jumpRefAllocationTerm()
    {
        changeCompany(CompanyInfo::getDataArea(allocateContract.parmLegalEntityRecId()))
        {
            BudgetAllocationTerm::jumpRefBudgetAllocationTerm(BudgetAllocationTerm::findByTermId(allocationTerm.text()), allocationTerm);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupAllocationTerm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves ledger allocation term records for selection.
    /// </summary>
    public void lookupAllocationTerm()
    {
        BudgetPlanAllocateByDimension::budgetAllocationTermLookup(allocationTerm, allocateContract.parmLegalEntityRecId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedAllocationTerm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the allocate contract data member attribute and modifies the form control visibility when the allocation term control is modified.
    /// </summary>
    /// <param name = "_isModified"> A boolean determining if the field was modified or not. </param>
    public void modifiedAllocationTerm(boolean _isModified)
    {
        if (_isModified)
        {
            allocateContract.parmBudgetAllocationTermId(allocationTerm.valueStr());
            this.setEnabledAllocatePlanButton();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAllocationTerm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the selected allocation term.
    /// </summary>
    /// <param name = "_budgetAllocationTermId"> The <c>BudgetAllocationTermId</c> to validate. </param>
    /// <returns> true, if the allocation term is valid; otherwise, false. </returns>
    public boolean validateAllocationTerm(BudgetAllocationTermId _budgetAllocationTermId)
    {
        return BudgetPlanAllocateByDimension::validateAllocationTerm(_budgetAllocationTermId, allocateContract.parmLegalEntityRecId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupSourceDocumentNumber</Name>
				<Source><![CDATA[
    //
    // Source document number form control methods
    //
    /// <summary>
    /// Retrieves document number records for selection.
    /// </summary>
    public void lookupSourceDocumentNumber()
    {
        BudgetPlanLookupHelper::lookupBudgetPlanHeaderAncestors(
                sourceDocumentNumber,
                allocateContract.parmParentBudgetPlanHeaderRecId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedSourceDocumentNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the allocate contract data member attribute and modifies the form control visibility when the source document number control is modified.
    /// </summary>
    /// <param name = "_isModified"> A boolean determining if the field was modified or not. </param>
    public void modifiedSourceDocumentNumber(boolean _isModified)
    {
        if (_isModified)
        {
            allocateContract.parmSourceBudgetPlanHeaderRecId(BudgetPlanHeader::findByDocumentNumber(sourceDocumentNumber.valueStr()).RecId);
            this.setEnabledAllocatePlanButton();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSourceBudgetPlanDocumentNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether the source document number is the ancestor of the target budget plan.
    /// </summary>
    /// <param name = "_sourceDocumentNumber"> The <c>DocumentNumber</c> field of the source budget plan. </param>
    /// <returns> true if validates successfully; otherwise false. </returns>
    public boolean validateSourceBudgetPlanDocumentNumber(BudgetPlanDocumentNumber _sourceDocumentNumber)
    {
        boolean          isValid = true;
        BudgetPlanHeader budgetPlanHeader = BudgetPlanHeader::findByDocumentNumber(_sourceDocumentNumber);

        if (!budgetPlanHeader.RecId)
        {
            isValid = checkFailed(strfmt("@Budget:UnableToFindUniqueRecord", extendedTypeId2pname(extendedTypeNum(BudgetPlanHeaderRecId))));
        }

        if (isValid)
        {
            BudgetPlanHeaderTmp budgetPlanHeaderTmp = BudgetPlanLookupHelper::populateBudgetPlanHeaderAncestors(allocateContract.parmParentBudgetPlanHeaderRecId());

            select firstonly RecId from budgetPlanHeaderTmp
                where budgetPlanHeaderTmp.DocumentNumber == _sourceDocumentNumber;

            isValid = budgetPlanHeaderTmp.RecId;

            if (!isValid)
            {
                checkFailed(strFmt("@Budget:BudgetPlanIsNotTheAncestor", _sourceDocumentNumber));
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupSourceScenario</Name>
				<Source><![CDATA[
    //
    // Source and basis scenario form control methods
    //
    /// <summary>
    /// Retrieves budget plan scenario records for selection for the source scenario field.
    /// </summary>
    public void lookupSourceScenario()
    {
        BudgetPlanHeader localBudgetPlanHeader;

        if (allocateContract.parmAllocationMethod() == BudgetPlanAllocateType::AllocateByAncestor)
        {
            BudgetPlanFormHelper::validateLookupControlFilledIn(sourceDocumentNumber);
            localBudgetPlanHeader = BudgetPlanHeader::find(allocateContract.parmSourceBudgetPlanHeaderRecId());
        }
        else
        {
            localBudgetPlanHeader = BudgetPlanHeader::find(allocateContract.parmParentBudgetPlanHeaderRecId());
        }

        BudgetPlanLookupHelper::lookupAllocationScenarios(
                sourceScenarioName,
                localBudgetPlanHeader,
                allocateContract.parmAllocationMethod(),
                false,
                targetScenarioName.text(),
                true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedSourceScenario</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the allocate contract data member attribute and modifies the form control visibility when the source scenario control is modified.
    /// </summary>
    /// <param name = "_isModified"> A boolean determining if the field was modified or not. </param>
    public void modifiedSourceScenario(boolean _isModified)
    {
        if (_isModified)
        {
            allocateContract.parmSourceBudgetPlanScenarioRecId(BudgetPlanScenario::findByLocalizedName(sourceScenarioName.text()).RecId);
            this.setEnabledAllocatePlanButton();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupBasisScenario</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves budget plan scenario records for selection for the basis scenario field.
    /// </summary>
    public void lookupBasisScenario()
    {
        BudgetPlanLookupHelper::lookupAllocationScenarios(
                basisScenarioName,
                BudgetPlanHeader::find(allocateContract.parmParentBudgetPlanHeaderRecId()),
                allocateContract.parmAllocationMethod(),
                false,
                targetScenarioName.text(),
                true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSourceBudgetPlanScenario</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the source budget plan scenario.
    /// </summary>
    /// <param name="_sourceBudgetPlanScenarioName"> The name of the source <c>BudgetPlanScenario</c> record. </param>
    /// <returns> true, if the source budget plan scenario is valid; otherwise, false. </returns>
    public boolean validateSourceBudgetPlanScenario(BudgetPlanScenarioName  _sourceBudgetPlanScenarioName)
    {
        boolean             isValid = true;
        BudgetPlanScenario  budgetPlanSourceScenario = BudgetPlanScenario::findByLocalizedName(_sourceBudgetPlanScenarioName);

        if (!budgetPlanSourceScenario.RecId)
        {
            isValid = checkFailed(strfmt("@Budget:UnableToFindUniqueRecord", extendedTypeId2pname(extendedTypeNum(BudgetPlanScenarioRecId))));
        }

        if (isValid && allocateContract.parmTargetBudgetPlanScenarioRecId())
        {
            if (budgetPlanSourceScenario.UnitOfMeasureClass != BudgetPlanScenario::find(allocateContract.parmTargetBudgetPlanScenarioRecId()).UnitOfMeasureClass)
            {
                isValid = checkFailed("@Budget:ScenarioUnitOfMeasuresNotEqual");
            }
        }

        if (isValid)
        {
            switch (allocateContract.parmAllocationMethod())
            {
                case BudgetPlanAllocateType::AllocateByChildren:
                    if (!BudgetPlan::existScenarioForChildBudgetPlan(allocateContract.parmParentBudgetPlanHeaderRecId(), budgetPlanSourceScenario.RecId))
                    {
                        isValid = checkFailed(strFmt("@Budget:BudgetPlanNoLinesExistForScenario", BudgetPlanScenarioTranslation::getLocalizedName(budgetPlanSourceScenario.RecId)));
                    }
                    break;

                case BudgetPlanAllocateType::AllocateByAncestor:
                    if (BudgetPlanLine::findByPlanHeaderScenario(allocateContract.parmSourceBudgetPlanHeaderRecId(), budgetPlanSourceScenario.RecId) == null)
                    {
                        isValid = checkFailed(strFmt("@Budget:BudgetPlanNoLinesExistForScenario", BudgetPlanScenarioTranslation::getLocalizedName(budgetPlanSourceScenario.RecId)));
                    }
                    break;

                default:
                    if (BudgetPlanLayoutElement::findFirstByLayoutScenario(BudgetPlanHeader::find(allocateContract.parmParentBudgetPlanHeaderRecId()).Layout, budgetPlanSourceScenario.RecId) == null)
                    {
                        isValid = checkFailed("@Budget:LayoutElementDoesNotExistForScenario");
                    }

                    if (isValid
                        && BudgetPlanLine::findByPlanHeaderScenario(allocateContract.parmParentBudgetPlanHeaderRecId(), budgetPlanSourceScenario.RecId) == null)
                    {
                        isValid = checkFailed(strFmt("@Budget:BudgetPlanNoLinesExistForScenario", BudgetPlanScenarioTranslation::getLocalizedName(budgetPlanSourceScenario.RecId)));
                    }
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedBasisScenario</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the allocate contract data member attribute and modifies the form control visibility when the basis scenario control is modified.
    /// </summary>
    /// <param name = "_isModified"> A boolean determining if the field was modified or not. </param>
    public void modifiedBasisScenario(boolean _isModified)
    {
        if (_isModified)
        {
            allocateContract.parmBasisBudgetPlanScenarioRecId(BudgetPlanScenario::findByLocalizedName(basisScenarioName.text()).RecId);
            this.setEnabledAllocatePlanButton();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupTargetScenario</Name>
				<Source><![CDATA[
    //
    // Target scenario form control methods
    //
    /// <summary>
    /// Retrieves budget plan scenario records for selection for the target scenario field.
    /// </summary>
    public void lookupTargetScenario()
    {
        BudgetPlanLookupHelper::lookupAllocationScenarios(
                targetScenarioName,
                BudgetPlanHeader::find(allocateContract.parmParentBudgetPlanHeaderRecId()),
                allocateContract.parmAllocationMethod(),
                true,
                sourceScenarioName.text(),
                false,
                true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedTargetScenario</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the allocate contract data member attribute and modifies the form control visibility when the target scenario control is modified.
    /// </summary>
    /// <param name = "_isModified"> A boolean determining if the field was modified or not. </param>
    public void modifiedTargetScenario(boolean _isModified)
    {
        if (_isModified)
        {
            allocateContract.parmTargetBudgetPlanScenarioRecId(BudgetPlanScenario::findByLocalizedName(targetScenarioName.text()).RecId);
            this.setEnabledAllocatePlanButton();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTargetBudgetPlanScenario</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the target budget plan scenario.
    /// </summary>
    /// <param name="_sourceBudgetPlanScenarioName"> The name of the source <c>BudgetPlanScenario</c> record. </param>
    /// <param name="_targetBudgetPlanScenarioName"> The name of the target <c>BudgetPlanScenario</c> record. </param>
    /// <returns> true, if the target budget plan scenario is valid; otherwise, false. </returns>
    public boolean validateTargetBudgetPlanScenario(
        BudgetPlanScenarioName _sourceBudgetPlanScenarioName,
        BudgetPlanScenarioName _targetBudgetPlanScenarioName)
    {
        boolean            isValid                  = true;
        BudgetPlanScenario budgetPlanSourceScenario = BudgetPlanScenario::findByLocalizedName(_sourceBudgetPlanScenarioName);
        BudgetPlanScenario budgetPlanTargetScenario = BudgetPlanScenario::findByLocalizedName(_targetBudgetPlanScenarioName);

        if (!budgetPlanTargetScenario.RecId)
        {
            isValid = checkFailed(strfmt("@Budget:UnableToFindUniqueRecord", extendedTypeId2pname(extendedTypeNum(BudgetPlanScenarioRecId))));
        }

        if (isValid && budgetPlanSourceScenario.UnitOfMeasureClass != budgetPlanTargetScenario.UnitOfMeasureClass)
        {
            isValid = checkFailed("@Budget:ScenarioUnitOfMeasuresNotEqual");
        }

        if (isValid && allocateContract.parmAllocationMethod() == BudgetPlanAllocateType::AllocateByParent)
        {
            if (!BudgetPlanLayoutHelper::allChildPlansHaveAccessSetForScenario(allocateContract.parmParentBudgetPlanHeaderRecId(), budgetPlanTargetScenario.RecId, NoYes::Yes))
            {
                isValid = checkFailed("@Budget:NoneditableDestinationPlanForAllocation");
            }
        }
        else if (isValid && !BudgetPlanLayoutHelper::canEditBudgetPlanForScenario(allocateContract.parmParentBudgetPlanHeaderRecId(), budgetPlanTargetScenario.RecId))
        {
            isValid = checkFailed("@Budget:NoneditableDestinationPlanForAllocation");
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedFactor</Name>
				<Source><![CDATA[
    //
    // Factor form control methods
    //
    /// <summary>
    /// Sets the allocate contract data member attribute when the factor control is modified.
    /// </summary>
    /// <param name = "_isModified"> A boolean determining if the field was modified or not. </param>
    public void modifiedFactor(boolean _isModified)
    {
        if (_isModified)
        {
            allocateContract.parmFactor(factor.realValue());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedAppendLines</Name>
				<Source><![CDATA[
    //
    // Append lines form control methods
    //
    /// <summary>
    /// Sets the allocate contract data member attribute when the append lines control is modified.
    /// </summary>
    /// <param name = "_isModified"> A boolean determining if the field was modified or not. </param>
    public void modifiedAppendLines(boolean _isModified)
    {
        if (_isModified)
        {
            allocateContract.parmAppendLines(appendLines.checked());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedUseSourceEffectiveDate</Name>
				<Source><![CDATA[
    //
    // Use source effective date form control methods
    //
    /// <summary>
    /// Sets the allocate contract data member attribute when the use source effective date control is modified.
    /// </summary>
    /// <param name = "_isModified"> A boolean determining if the field was modified or not. </param>
    public void modifiedUseSourceEffectiveDate(boolean _isModified)
    {
        if (_isModified)
        {
            allocateContract.parmUseSourceEffectiveDateForAllocation(useSourceEffectiveDates.checked());
            this.setControlsVisibility();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearScenarioControls</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears the values of the scenario controls.
    /// </summary>
    protected void clearScenarioControls()
    {
        if (sourceScenarioName.text() != BudgetPlanningConstants::emptyString)
        {
            sourceScenarioName.text(BudgetPlanningConstants::emptyString);
        }

        if (targetScenarioName.text() != BudgetPlanningConstants::emptyString)
        {
            targetScenarioName.text(BudgetPlanningConstants::emptyString);
        }

        if (basisScenarioName.text() != BudgetPlanningConstants::emptyString)
        {
            basisScenarioName.text(BudgetPlanningConstants::emptyString);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setControlsVisibility</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the visibility of all the <c>BudgetPlanAllocate</c> form controls.
    /// </summary>
    public void setControlsVisibility()
    {
        this.setLedgerAllocateKeyVisibility(this.isLedgerRequired());
        this.setAllocationTermControlsVisibility(this.isAllocationTermRequired());
        this.setSourceScenarioControlsVisibility(this.isSourceScenarioRequired());
        this.setLedgerAllocationRuleControlsVisibility(this.isLedgerAllocationRuleRequired());
        this.setBasisScenarioControlsVisibility(this.isBasisScenarioRequired());
        this.setSourceDocumentNumberControlVisibility(this.isSourceBudgetPlanDocumentNumberRequired());

        this.setEnabledAllocatePlanButton();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setEnabledAllocatePlanButton</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the enabled property of the allocate button.
    /// </summary>
    public void setEnabledAllocatePlanButton()
    {
        oKButton.enabled(this.canPerformAllocation());
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAllocationTermControlsVisibility</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the visibility of the allocation term form control.
    /// </summary>
    /// <param name = "_showControls"> The boolean value to switch the visibility to. </param>
    protected void setAllocationTermControlsVisibility(boolean _showControls)
    {
        allocationTerm.visible(_showControls);
        allocationTerm.enabled(_showControls);
        allocationTerm.skip(!_showControls);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBasisScenarioControlsVisibility</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the visibility of the basis scenario form control.
    /// </summary>
    /// <param name = "_showControls"> The boolean value to switch the visibility to. </param>
    protected void setBasisScenarioControlsVisibility(boolean _showControls)
    {
        basisScenarioName.visible(_showControls);
        basisScenarioName.enabled(_showControls);
        basisScenarioName.skip(!_showControls);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLedgerAllocationRuleControlsVisibility</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the visibility of the ledger allocate rules form controls.
    /// </summary>
    /// <param name = "_showControls"> The boolean value to switch the visibility to. </param>
    protected void setLedgerAllocationRuleControlsVisibility(boolean _showControls)
    {
        ledgerAllocationRule.visible(_showControls);
        ledgerAllocationRule.enabled(_showControls);
        ledgerAllocationRule.skip(!_showControls);

        useSourceEffectiveDates.visible(_showControls);
        useSourceEffectiveDates.enabled(_showControls);
        useSourceEffectiveDates.skip(!_showControls);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLedgerAllocateKeyVisibility</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the visibility of the ledger allocate key form control.
    /// </summary>
    /// <param name = "_showControls"> The boolean value to switch the visibility to. </param>
    protected void setLedgerAllocateKeyVisibility(boolean _showControls)
    {
        ledgerAllocateKey.visible(_showControls);
        ledgerAllocateKey.enabled(_showControls);
        ledgerAllocateKey.skip(!_showControls);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSourceScenarioControlsVisibility</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the visibility of the source scenario form control.
    /// </summary>
    /// <param name = "_showControls"> The boolean value to switch the visibility to. </param>
    protected void setSourceScenarioControlsVisibility(boolean _showControls)
    {
        sourceScenarioName.enabled(_showControls);
        sourceScenarioName.skip(!_showControls);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSourceDocumentNumberControlVisibility</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the visibility of the source document number form control.
    /// </summary>
    /// <param name = "_showControls"> The boolean value to switch the visibility to. </param>
    protected void setSourceDocumentNumberControlVisibility(boolean _showControls)
    {
        sourceDocumentNumber.visible(_showControls);
        sourceDocumentNumber.skip(!_showControls);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPerformAllocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the allocation process can be performed.
    /// </summary>
    /// <returns> true, if the allocation can be performed; otherwise, false. </returns>
    public boolean canPerformAllocation()
    {
        boolean canPerform;

        if (allocateContract.parmTargetBudgetPlanScenarioRecId())
        {
            switch (allocateContract.parmAllocationMethod())
            {
                case BudgetPlanAllocateType::AllocateByPeriod:
                    canPerform = this.canPerformAllocationForAllocateByPeriodType();
                    break;

                case BudgetPlanAllocateType::AllocateByDimension:
                    canPerform = this.canPerformAllocationForAllocateByDimensionType();
                    break;

                case BudgetPlanAllocateType::AllocateByChildren:
                    canPerform = this.canPerformAllocationForAllocateByChildrenType();
                    break;

                case BudgetPlanAllocateType::AllocateByParent:
                    canPerform = this.canPerformAllocationForAllocateByParentType();
                    break;

                case BudgetPlanAllocateType::AllocateByLedgerRule:
                    canPerform = this.canPerformAllocationForAllocateByLedgerRuleType();
                    break;

                case BudgetPlanAllocateType::AllocateByAncestor:
                    canPerform = this.canPerformAllocationForAllocateByAncestorType();
                    break;
            }
        }

        return canPerform;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPerformAllocationForAllocateByPeriodType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the allocation process can be performed for the <c>AllocateByPeriod</c> type.
    /// </summary>
    /// <returns> true, if the allocation can be performed; otherwise, false. </returns>
    protected boolean canPerformAllocationForAllocateByPeriodType()
    {
        return canAddLinesOnParent && allocateContract.parmLedgerAllocateKeyId() && budgetPlanLineActiveView;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPerformAllocationForAllocateByDimensionType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the allocation process can be performed for the <c>AllocateByDimension</c> type.
    /// </summary>
    /// <returns> true, if the allocation can be performed; otherwise, false. </returns>
    protected boolean canPerformAllocationForAllocateByDimensionType()
    {
        return canAddLinesOnParent && allocateContract.parmBudgetAllocationTermId() && budgetPlanLineActiveView;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPerformAllocationForAllocateByChildrenType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the allocation process can be performed for the <c>AllocateByChildren</c> type.
    /// </summary>
    /// <returns> true if the allocation can be performed; otherwise, false. </returns>
    protected boolean canPerformAllocationForAllocateByChildrenType()
    {
        return canAddLinesOnParent && allocateContract.parmSourceBudgetPlanScenarioRecId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPerformAllocationForAllocateByParentType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the allocation process can be performed for the <c>AllocateByParent</c> type.
    /// </summary>
    /// <returns> true, if the allocation can be performed; otherwise, false. </returns>
    protected boolean canPerformAllocationForAllocateByParentType()
    {
        return allocateContract.parmSourceBudgetPlanScenarioRecId() && budgetPlanLineActiveView;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPerformAllocationForAllocateByLedgerRuleType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the allocation process can be performed for the <c>AllocateByLedgerRule</c> type.
    /// </summary>
    /// <returns> true, if the allocation can be performed; otherwise, false. </returns>
    protected boolean canPerformAllocationForAllocateByLedgerRuleType()
    {
        boolean canPerform;

        if (canAddLinesOnParent
            && allocateContract.parmSourceBudgetPlanScenarioRecId()
            && allocateContract.parmLedgerAllocationRuleID())
        {
            canPerform = true;

            if ((this.isBasisScenarioRequired()) && (allocateContract.parmBasisBudgetPlanScenarioRecId() == 0))
            {
                canPerform = false;
            }
        }

        return canPerform;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPerformAllocationForAllocateByAncestorType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the allocation process can be performed for the <c>AllocateByAncestor</c> type.
    /// </summary>
    /// <returns> true, if the allocation can be performed; otherwise, false. </returns>
    protected boolean canPerformAllocationForAllocateByAncestorType()
    {
        return allocateContract.parmSourceBudgetPlanScenarioRecId() && allocateContract.parmTargetBudgetPlanScenarioRecId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAllocationTermRequired</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the allocate term is required for allocation.
    /// </summary>
    /// <returns> true, if the allocate term is required; otherwise, false. </returns>
    protected boolean isAllocationTermRequired()
    {
        return allocateContract.parmAllocationMethod() == BudgetPlanAllocateType::AllocateByDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSourceBudgetPlanDocumentNumberRequired</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the source document number is required for allocation.
    /// </summary>
    /// <returns> true, if the source document number is required; otherwise, false. </returns>
    protected boolean isSourceBudgetPlanDocumentNumberRequired()
    {
        return allocateContract.parmAllocationMethod() == BudgetPlanAllocateType::AllocateByAncestor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBasisScenarioRequired</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the basis scenario is required for allocation.
    /// </summary>
    /// <returns> true, if the basis scenario is required; otherwise, false. </returns>
    protected boolean isBasisScenarioRequired()
    {
        changecompany(CompanyInfo::getDataArea(allocateContract.parmLegalEntityRecId()))
        {
            return (allocateContract.parmAllocationMethod() == BudgetPlanAllocateType::AllocateByLedgerRule) &&
                   (LedgerAllocationRule::find(allocateContract.parmLedgerAllocationRuleID()).AllocationMethod == LedgerAllocationMethod::Basis);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLedgerAllocationRuleRequired</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the ledger allocation rule is required for allocation.
    /// </summary>
    /// <returns> true, if the ledger allocation rule is required; otherwise, false. </returns>
    protected boolean isLedgerAllocationRuleRequired()
    {
        return allocateContract.parmAllocationMethod() == BudgetPlanAllocateType::AllocateByLedgerRule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLedgerRequired</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the ledger is required for allocation.
    /// </summary>
    /// <returns> true, if the ledger is required; otherwise, false. </returns>
    protected boolean isLedgerRequired()
    {
        return allocateContract.parmAllocationMethod() == BudgetPlanAllocateType::AllocateByPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSourceScenarioRequired</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the source scenario is required for allocation.
    /// </summary>
    /// <returns> true, if the source scenario is required; otherwise, false. </returns>
    protected boolean isSourceScenarioRequired()
    {
        boolean isValid = true;

        changecompany(CompanyInfo::getDataArea(allocateContract.parmLegalEntityRecId()))
        {
            isValid = LedgerAllocationRule::find(allocateContract.parmLedgerAllocationRuleID()).DataSource != LedgerAllocationSource::FixedValue;
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the budget plan allocation request is valid.
    /// </summary>
    /// <returns> true, if the budget plan allocation request is valid; otherwise, false. </returns>
    public boolean validate()
    {
        boolean isValid = true;

        switch (allocateContract.parmAllocationMethod())
        {
            case BudgetPlanAllocateType::AllocateByPeriod:
            case BudgetPlanAllocateType::AllocateByDimension:

                if (!BudgetPlanLayoutHelper::canEditBudgetPlanForScenario(budgetPlanLineActiveView.BudgetPlanHeader, allocateContract.parmTargetBudgetPlanScenarioRecId()))
                {
                    isValid = checkFailed("@Budget:NoneditableDestinationPlanForAllocation");
                }

                if (isValid
                    && BudgetPlan::existScenarioForBudgetPlan(budgetPlanLineActiveView.BudgetPlanHeader, allocateContract.parmTargetBudgetPlanScenarioRecId())
                    && !allocateContract.parmAppendLines()
                    && (Box::okCancel("@Budget:LinesAlreadyExistForAllocation", DialogButton::Cancel) == DialogButton::Cancel))
                {
                    isValid = false;
                }

                break;

            case BudgetPlanAllocateType::AllocateByChildren:

                if (!BudgetPlanLayoutHelper::canEditBudgetPlanForScenario(allocateContract.parmParentBudgetPlanHeaderRecId(), allocateContract.parmTargetBudgetPlanScenarioRecId()))
                {
                    isValid = checkFailed("@Budget:NoneditableDestinationPlanForAllocation");
                }

                // Checking whether the budget plan allocate request have budget plan line to allocate.
                if (isValid
                    && !BudgetPlan::existScenarioForChildBudgetPlan(allocateContract.parmParentBudgetPlanHeaderRecId(), allocateContract.parmSourceBudgetPlanScenarioRecId()))
                {
                    isValid = checkFailed("@Budget:NoSourceLinesForAllocation");
                }

                break;

            case BudgetPlanAllocateType::AllocateByParent:

                if (!BudgetPlanLayoutHelper::allChildPlansHaveAccessSetForScenario(allocateContract.parmParentBudgetPlanHeaderRecId(), allocateContract.parmTargetBudgetPlanScenarioRecId(), NoYes::Yes))
                {
                    isValid = checkFailed("@Budget:NoneditableDestinationPlanForAllocation");
                }

                // Checking whether the budget plan allocate request have budget plan line to allocate.
                if (isValid
                    && !BudgetPlan::existScenarioForBudgetPlan(allocateContract.parmParentBudgetPlanHeaderRecId(), allocateContract.parmSourceBudgetPlanScenarioRecId()))
                {
                    isValid = checkFailed("@Budget:NoSourceLinesForAllocation");
                }

                break;

            case BudgetPlanAllocateType::AllocateByLedgerRule:

                changeCompany (CompanyInfo::getDataArea(allocateContract.parmLegalEntityRecId()))
                {
                    if (LedgerAllocationRule::find(allocateContract.parmLedgerAllocationRuleID()).DataSource != LedgerAllocationSource::FixedValue)
                    {
                        if (!BudgetPlanLayoutHelper::canEditBudgetPlanForScenario(budgetPlanLineActiveView.BudgetPlanHeader, allocateContract.parmTargetBudgetPlanScenarioRecId()))
                        {
                            isValid = checkFailed("@Budget:NoneditableDestinationPlanForAllocation");
                        }

                        //
                        // Checking whether the budget plan allocate request have budget plan line to allocate.
                        // This check is avoided if the allocation rule is fixed value.
                        //
                        if (isValid
                            && !BudgetPlan::existScenarioForBudgetPlan(allocateContract.parmParentBudgetPlanHeaderRecId(), allocateContract.parmSourceBudgetPlanScenarioRecId()))
                        {
                            isValid = checkFailed("@Budget:NoSourceLinesForAllocation");
                        }

                        //
                        // Checking whether the source and target budget plan line scenario are same and prompting user that the source budget plan lines
                        // that are used for calculation will be deleted from the scenario along with the budget plan lines with the matching financial dimensions.
                        // This check is avoided if the allocation rule is fixed value.
                        //
                        if (isValid
                            && allocateContract.parmSourceBudgetPlanScenarioRecId() == allocateContract.parmTargetBudgetPlanScenarioRecId()
                            && !allocateContract.parmAppendLines()
                            && Box::okCancel("@Budget:LinesAlreadyExistForAllocation", DialogButton::Cancel) == DialogButton::Cancel)
                        {
                            isValid = false;
                        }
                    }
                }

                break;

            case BudgetPlanAllocateType::AllocateByAncestor:
                // Checking whether the budget plan allocate request has budget plan lines to allocate.
                if (isValid
                    && !BudgetPlan::existScenarioForBudgetPlan(allocateContract.parmSourceBudgetPlanHeaderRecId(), allocateContract.parmSourceBudgetPlanScenarioRecId()))
                {
                    isValid = checkFailed("@Budget:NoSourceLinesForAllocation");
                }

                if (isValid
                    && BudgetPlan::existScenarioForBudgetPlan(budgetPlanLineActiveView.BudgetPlanHeader, allocateContract.parmTargetBudgetPlanScenarioRecId())
                    && !allocateContract.parmAppendLines()
                    && Box::okCancel("@Budget:LinesAlreadyExistForAllocation", DialogButton::Cancel) == DialogButton::Cancel)
                {
                    isValid = false;
                }

                break;
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanAddLinesOnParent</Name>
				<Source><![CDATA[
    public boolean parmCanAddLinesOnParent(boolean _canAddlinesOnParent = canAddlinesOnParent)
    {
        canAddlinesOnParent = _canAddlinesOnParent;
        return canAddlinesOnParent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBudgetPlanLineActiveView</Name>
				<Source><![CDATA[
    public BudgetPlanLineActiveView parmBudgetPlanLineActiveView(BudgetPlanLineActiveView _budgetPlanLineActiveView = budgetPlanLineActiveView)
    {
        budgetPlanLineActiveView = _budgetPlanLineActiveView;
        return budgetPlanLineActiveView;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initControls</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the local references to the <c>BudgetPlanAllocate</c> form controls.
    /// </summary>
    /// <param name = "_formRun"> The <c>FormRun</c> object of the <c>BudgetPlanAllocate</c> form. </param>
    public void initControls(FormRun _formRun)
    {
        allocationMethod        = _formRun.control(_formRun.controlId(formControlStr(BudgetPlanAllocate, AllocationMethod)));
        ledgerAllocateKey       = _formRun.control(_formRun.controlId(formControlStr(BudgetPlanAllocate, LedgerAllocateKey_Key)));
        ledgerAllocationRule    = _formRun.control(_formRun.controlId(formControlStr(BudgetPlanAllocate, LedgerAllocationRule)));
        allocationTerm          = _formRun.control(_formRun.controlId(formControlStr(BudgetPlanAllocate, BudgetAllocationTerm_Name)));
        sourceDocumentNumber    = _formRun.control(_formRun.controlId(formControlStr(BudgetPlanAllocate, SourceBudgetPlanDocumentNumber)));
        sourceScenarioName      = _formRun.control(_formRun.controlId(formControlStr(BudgetPlanAllocate, SourceScenarioName)));
        basisScenarioName       = _formRun.control(_formRun.controlId(formControlStr(BudgetPlanAllocate, BasisScenarioName)));
        targetScenarioName      = _formRun.control(_formRun.controlId(formControlStr(BudgetPlanAllocate, TargetScenarioName)));
        factor                  = _formRun.control(_formRun.controlId(formControlStr(BudgetPlanAllocate, MultiplyBy)));
        appendLines             = _formRun.control(_formRun.controlId(formControlStr(BudgetPlanAllocate, AppendLines)));
        useSourceEffectiveDates = _formRun.control(_formRun.controlId(formControlStr(BudgetPlanAllocate, AllocateByEffectiveDate_LedgerAllocationRule)));
        okButton                = _formRun.control(_formRun.controlId(formControlStr(BudgetPlanAllocate, OkButton)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllocateContract</Name>
				<Source><![CDATA[
    public BudgetPlanAllocateContract parmAllocateContract(BudgetPlanAllocateContract _allocateContract = allocateContract)
    {
        allocateContract = _allocateContract;
        return allocateContract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static BudgetPlanAllocateForm construct()
    {
        return new BudgetPlanAllocateForm();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new <c>BudgetPlanAllocateForm</c> object from a given form.
    /// </summary>
    /// <param name = "_formRun"> The <c>FormRun</c> object of the <c>BudgetPlanAllocate</c> form. </param>
    /// <returns> The <c>BudgetPlanAllocateForm</c> object. </returns>
    public static BudgetPlanAllocateForm newFromForm(FormRun _formRun)
    {
        BudgetPlanAllocateForm allocateForm = BudgetPlanAllocateForm::construct();
        allocateForm.initControls(_formRun);

        return allocateForm;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>