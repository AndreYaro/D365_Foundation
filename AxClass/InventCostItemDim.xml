<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventCostItemDim</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>InventCostItemDim</c> class does the cost calculations for a single item.
/// </summary>
/// <remarks>
///    This class creates the settlements and eventually closes the inventory transactions according to
///    the inventory model. It may also create records in the <c>InventCostList</c> table and in the
///    <c>InventCostListTrans</c> table in order to move adjustments to other items or transactions.
/// </remarks>
class InventCostItemDim
{
    protected const int InitLedgerAlways = 2;
    protected const int InitLedgerAsPosted = 1;
    protected const int InitLedgerDrop = 0;

    protected const int UpdatePhysicalSettlement = 1;

    protected const int CommitCountMax = 50;
    protected boolean errorAdjustment = true;
    private boolean checkSameFinDim = CostClosingCheckSameFinDimOnReworkOrderFlight::instance().isEnabled();
    private boolean isInventCostPreCloseMatchReturnCheckQtyFlightEnabled = InventCostPreCloseMatchReturnCheckQtyFlight::instance().isEnabled();
    private boolean skipFormulaKeyAdjustmentIfNoParentAndCoBy = InventCostSkipFormulaKeyAdjustmentIfNoParentAndCoByFlight::instance().isEnabled();
    private boolean isInventCostRecalcIncludePhysicalValueForAverageModelFeatureEnabled = InventCostRecalcIncludePhysicalValueForAverageModelFeature::isEnabled();

    #localmacro.settlementFieldList
        recId,
        qtySettled,
        costAmountSettled,
        costAmountAdjustment,
        transDate,
        voucher,
        transRecId,
        settleTransId,
        settleType
    #endmacro

    #localmacro.WhereInventTransFitsRanges
        // %1 An InventTrans record.
        // %2 A status issue.
        // %3 A status receipt.
        // %4 Whether only transfer orders must be taken into account.
        // %5 Whether there's a physical value in the cost.

        where %1.ItemId         == inventCostList.ItemId
            && %1.ValueOpen     == InventTransOpen::Yes
            && %1.StatusReceipt >= StatusReceipt::None
            && %1.StatusReceipt <= %3
            && %1.StatusIssue   >= StatusIssue::None
            && %1.StatusIssue   <= %2
            && ((%4 == false && %1.MarkingRefInventTransOrigin == 0)
                || (%4 == true))
            && ((%1.DatePhysical <= inventClosing.TransDate && %5)
                || (%1.DateFinancial <= inventClosing.TransDate && !%5))
    #endmacro

    #localmacro.JoinInventTransOrigin
        // %1 An InventTrans record.
        // %2 An InventTransOrigin record.
        // %3 Whether only transfer orders must be taken into account.

        join ReferenceCategory, InventTransId from %2
            where %2.RecId == %1.InventTransOrigin
                && (%3 == false
                    || (%3 == true
                        && (%2.ReferenceCategory == InventTransType::TransferOrderShip
                            || %2.ReferenceCategory == InventTransType::TransferOrderReceive)))
     #endmacro

    // <GCN><GEERU>
    #ISOcountryRegionCodes
    // </GEERU></GCN>

    // global objects
    protected InventClosing  inventClosing;          // record representing the current closing (parameter)
    protected InventCostList inventCostList;         // record representing the current work item
    InventCostHelpTaskBase   inventCostHelpTaskBase; // reference to helper we run under (parameter)
    InventCostListParm       inventCostListParm;     // record representing parameters for the current work item

    // maps to load input data
    Map                 mapInventTrans;         // all transactions that must be processed, bulk read by load
    TmpInventModel      tmpInventModel;         // temp table as index over mapInventTrans, created   by load

    // maps to keep intermediate data
    Map                 mapSettleQty;           // updated by updateClosingCosting, accessed through financialOpenQty
    Map                 mapSettleValue;         // updated by updateClosingCosting, accessed through financialOpenValue
    Map                 pdsMapSettleCWQty;      // updated by updateClosingCosting, accessed through financialOpenQty

    // maps to store output data
    Map                 mapAdjustment;          // added to by updateClosingCosting, bulk write by updateModelAdjustment
    Map                 mapKeyAdjust;           // added to by addKeyAdjustment    , bulk write by updateTransKeyAdjust
    Set                 setSameItem;            // added to by addKeyAdjustment    , used       by updateTransKeyAdjust
    Map                 mapOpenIssue;           // added to by updateMapOpenIssue  , bulk write by openIssueToInfoLog

    // maps for caching method results
    Map                 mapInventTable;         // cache for inventTable method - NOTE: not all fields
    Map                 mapInventModelGroup;    // cache for inventModelGroup method
    Map                 mapAdjustmentLater;     // cache for calcLaterAdjustment

    Map                 mapInventDimGroupSetup;
    Map                 mapInventDimParm;
    Map                 mapQueryRun;

    // read-only variables initialized by new
    Types               recIdType;
    RoundOff            roundOffunit;
    CurrencyCode        standardCurrency;
    boolean             needCalcAllocation;

    // self-looping optimization
    boolean             selfUpdate;
    Integer             selfLoopCount;

    // frequent-commit optimization
    Integer             commitCount;

    // <GEERU>
    InventTransCurrency_RU  inventTransCurrency;
    InventModelTypeCache    inventModelTypeCache;
    boolean                 calculationProdWIP_RU;
    boolean                 featuresRUIsEnabled_RU;
    Map                     mapProdIdWIPCalc_RU;
    Map                     mapcalculatingWIPBySite_RU;
    boolean                 countryRegion_RU;
    // </GEERU>
    boolean                             isCatchWeightItem;
    boolean                             isWHSItem;
    InventCostReferenceCategoryCache    referenceCategoryCache;
    int                                 startTime;
    Map                                 mapInventTransId;
    Map                                 mapItemGroupId;

    // Statistics
    InventCostUpdateReturnAdjustmentsTime   updateReturnAdjustmentsTime;
    InventCostUpdateLevelAdjustmentTime     updateLevelAdjustmentTime;
    InventCostUpdateReceiptAdjustmentTime   updateReceiptAdjustmentTime;
    InventCostLoadTransferOrderTime         loadTransferOrderTime;
    InventCostPreCloseTransferOrderTime     preCloseTransferOrderTime;
    InventCostUpdateMarkingTime             updateMarkingTime;
    InventCostLoadTime                      loadTime;
    InventCostPreCloseNonFinancialTime      preCloseNonFinancialTime;
    InventCostUpdateModelTime               updateModelTime;

    InventCostUpdateReturnAdjustmentsCount  updateReturnAdjustmentsCount;
    InventCostUpdateLevelAdjustmentCount    updateLevelAdjustmentCount;
    InventCostUpdateReceiptAdjustmentCount  updateReceiptAdjustmentCount;
    InventCostLoadTransferOrderCount        loadTransferOrderCount;
    InventCostPreCloseTransferOrderCount    preCloseTransferOrderCount;
    InventCostUpdateMarkingCount            updateMarkingCount;
    InventCostLoadCount                     loadCount;
    InventCostPreCloseNonFinancialCount     preCloseNonFinancialCount;
    InventCostUpdateModelCount              updateModelCount;
    Set                                     keysToBeDeleted;
    Qty                                     preSettledQty;
    Amount                                  preSettledAmount;
    int                                     updateCount;
    int                                     commitTickCount;
    InventCostInventTransCount              openInventTransCount;
    InventCostInventTransCount              closedInventTransCount;
    private boolean                         considerBatchAndSerialForTransferOrder;

    private Enumerator inventDimEnumeratorForMarking;

    private CostManagementInstrumentationLogger logger;
    private boolean useLabelWithLotIdForFormulaAdjustError = CostCloseShowLotIdOnFormulaAdjustErrorFlight::instance().isEnabled();

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>instrumentationLogger</Name>
				<Source><![CDATA[
    final internal CostManagementInstrumentationLogger instrumentationLogger()
    {
        if (!logger)
        {
            logger = CostManagementInstrumentationLogger::createLogger(classStr(InventCostItemDim));
        }

        return logger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFormulaKeyAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Makes cost adjustments for the co-products or by-products and any main item parent that might exist.
    /// </summary>
    /// <param name="_inventTransOriginId">
    /// The origin ID of the transactions to which this adjustment will eventually be made.
    /// </param>
    /// <param name="_adjustment">
    /// The amount of adjustment to make.
    /// </param>
    protected void addFormulaKeyAdjustment(
        InventTransOriginId _inventTransOriginId,
        Amount      _adjustment)
    {
        Amount allocation = 0;

        #COSNumbers

        InventTransOrigin parent = InventTrans::findByInventTransOrigin(_inventTransOriginId).assemblyInventTransOrigin();

        if (!parent && skipFormulaKeyAdjustmentIfNoParentAndCoBy)
        {
            InventTransOrigin inventTransOrigin = InventTransOrigin::find(_inventTransOriginId);
            ProdTable prodTable = ProdTable::find(inventTransOrigin.ReferenceId);
            if (!prodTable)
            {
                PmfProdCoBy                     prodCoBy;
                InventTransOriginPmfProdCoBy    inventTransOriginPmfProdCoBy;
                InventTrans                     inventTrans;
                InventTransOrigin               inventTransOriginLocal;

                select firstonly RecId from inventTransOriginLocal
                    where inventTransOriginLocal.ReferenceId        == inventTransOrigin.ReferenceId 
                        && inventTransOriginLocal.ReferenceCategory == InventTransType::Production
                    exists join inventTrans
                    where inventTrans.inventTransOrigin == inventTransOriginLocal.RecId;

                if (!inventTransOriginLocal.RecId)
                {
                    inventTrans = null;

                    select firstonly RecId from prodCoBy
                        where  prodCoBy.ProdId      == inventTransOrigin.ReferenceId
                            && prodCoBy.ProductType == PmfProductType::Co_Product
                        join InventTransOrigin from inventTransOriginPmfProdCoBy
                        where  inventTransOriginPmfProdCoBy.PmfProdCoByDataAreaId   == prodCoBy.DataAreaId
                            && inventTransOriginPmfProdCoBy.PmfProdCoByRecId        == prodCoBy.RecId
                        exists join inventTrans
                        where  inventTrans.InventTransOrigin == inventTransOriginPmfProdCoBy.InventTransOrigin;

                    if (!prodCoBy.RecId)
                    {
                        _adjustment = 0;
                    }
                }
            }
        }

        if (needCalcAllocation && (_adjustment != 0 || !skipFormulaKeyAdjustmentIfNoParentAndCoBy))
        {
            InventTransOrigin inventTransOrigin = InventTransOrigin::find(_inventTransOriginId);
            Common inventTransOriginator = inventTransOrigin.originator();
            if (inventTransOriginator.TableId == tableNum(ProdBOM))
            {
                ProdBOM prodBOM = inventTransOriginator;
                if (!prodBom.ProdId)
                {
                    prodBom.ProdId = inventTransOrigin.ReferenceId;
                }
                if (!prodBom.InventTransId)
                {
                    prodBom.InventTransId = inventTransOrigin.InventTransId;
                }

                allocation = this.calcKeyAdjustmentAllocation(prodBOM, _adjustment, parent);
            }
        }

        if (!parent && decRound(_adjustment - allocation, #4) != 0)
        {
            if (useLabelWithLotIdForFormulaAdjustError)
            {
                throw error(strFmt("@SCM:UnallocatedCostOnPlanningFormulaWithRecIdErrorMessage", int642Str(_inventTransOriginId)));
            }
            else
            {
                throw error("@PRO997");
            }
        }

        if (parent)  //main item InventTransOrigin
        {
            Amount adjAmt = _adjustment - allocation;
            this.addkeyAdjustment(false, parent.RecId, adjAmt , 0, '');
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addkeyAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds an adjustment to the <c>mapKeyAdjustment</c> map.
    /// </summary>
    /// <param name="_sameItem">
    /// A Boolean value that determines whether the adjustment is made to the same item it comes from.
    /// </param>
    /// <param name="_inventTransOriginId">
    /// The origin ID of the transactions to which this adjustment will eventually be made.
    /// </param>
    /// <param name="_adjustment">
    /// The amount by which the cost will eventually be adjusted.
    /// </param>
    /// <param name="_returnInventTransOriginId">
    /// The return origin ID of the transactions to which this adjustment will eventually be made.
    /// </param>
    /// <param name="_voucherPhysical">
    /// The physical voucher of the transactions to which this adjustment will eventually be made.
    /// </param>
    protected void addkeyAdjustment(
        boolean             _sameItem,
        InventTransOriginId _inventTransOriginId,
        CostAmount          _adjustment,
        InventTransOriginId _returnInventTransOriginId,
        Voucher             _voucherPhysical
        )
    {
        str             s = InventCostItemDim::keyAdjust2String(_inventTransOriginId,_returnInventTransOriginId,_voucherPhysical);
        CostAmount      adjustSum;

        if (! mapKeyAdjust)
            mapKeyAdjust = new Map(Types::String,Types::Real);

        if (mapKeyAdjust.exists(s))
            adjustSum = mapKeyAdjust.lookup(s);

        adjustSum += _adjustment;

        mapKeyAdjust.insert(s,adjustSum);

        if (_sameItem)
        {
            selfUpdate = true;
            setSameItem.add(_inventTransOriginId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcKeyAdjustmentAllocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the adjustments for the co-products.
    /// </summary>
    /// <param name="_prodBOM">
    /// The <c>ProdBOM</c> record that will be calculated.
    /// </param>
    /// <param name="_adjustment">
    /// The amount of adjustment to make.
    /// </param>
    /// <param name="_parent">
    /// The parent <c>InventTransOrigin</c>.
    /// </param>
    /// <returns>
    /// The amount of adjustment that will be allocated to the item parent.
    /// </returns>
    protected Amount calcKeyAdjustmentAllocation(   ProdBOM     _prodBOM,
                                                    Amount            _adjustment,
                                                    InventTransOrigin _parent = InventTrans::findTransId(_prodBOM.InventTransId).assemblyInventTransOrigin())
    {
        #COSNumbers
        Amount                          allocatedAmount;
        PmfCostAllocationPct            allocatedPercent;
        PmfProdCoBy                     prodCoBy;
        InventTransOriginPmfProdCoBy    inventTransOriginPmfProdCoBy;
        InventTrans                     inventTrans;

        if (_adjustment)
        {
            while select RecId, CostAllocationPct from prodCoBy
            where prodCoBy.ProdId == _prodBOM.ProdId
            &&    prodCoBy.ProductType == PmfProductType::Co_Product

                join InventTransOrigin from inventTransOriginPmfProdCoBy
                where  inventTransOriginPmfProdCoBy.PmfProdCoByDataAreaId   == prodCoBy.DataAreaId
                    && inventTransOriginPmfProdCoBy.PmfProdCoByRecId        == prodCoBy.RecId
                exists join inventTrans
                where  inventTrans.InventTransOrigin    == inventTransOriginPmfProdCoBy.InventTransOrigin
            {
                Amount adjustmentAmount = CurrencyExchangeHelper::amount(_adjustment - allocatedAmount - (100 - allocatedPercent - prodCoBy.CostAllocationPct) / 100 * _adjustment, standardCurrency);
                allocatedPercent += prodCoBy.CostAllocationPct;

                if (adjustmentAmount != 0)
                {
                    this.addkeyAdjustment(false, inventTransOriginPmfProdCoBy.InventTransOrigin, adjustmentAmount, 0, '');
                    allocatedAmount += adjustmentAmount;
                }
            }

            if (!_parent && decRound(100 - allocatedPercent, #4) != 0)
            {
                if (useLabelWithLotIdForFormulaAdjustError)
                {
                    // allocation must be 100 for a planning item
                    throw error(strFmt("@SCM:UnallocatedCostOnPlanningFormulaWithProdIdLotIdErrorMessage", _prodBOM.ProdId, _prodBOM.InventTransId));
                }
                else
                {
                    throw error(strFmt("@SCM:UnallocatedCostOnPlanningFormulaErrorMessage", _prodBOM.ProdId));  //allocation must be 100 for a planning item
                }
            }
        }

        return allocatedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcLaterAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Computes the total adjustment on an inventory transaction after the closing date.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The inventory transaction on which to compute the total adjustment after the closing date.
    /// </param>
    /// <returns>
    ///    The total adjustment after the closing date on the given inventory transaction.
    /// </returns>
    protected CostAmount calcLaterAdjustment(InventTrans _inventTrans)
    {
        InventSettlement inventSettlement;

        // These cases return 0 by default.
        if (this.isUpdatedFinancialLater(_inventTrans))
        {
            return 0;
        }

        if (_inventTrans.Qty < 0 && inventClosing.CancelRecalculation)
        {
            return 0;
        }

        // Common case: for future adjustments on the current item, we fill the cache in one bulk read.
        if (! mapAdjustmentLater)
        {
            mapAdjustmentLater = new Map(recIdType, Types::Real);

            // Optimization note: All columns are expected to be included in the index
            while select TransRecId, sum(CostAmountAdjustment) from inventSettlement
                group by TransRecId
                where inventSettlement.ItemId               == inventCostList.ItemId
                    // <GEERU>
                    && ((countryRegion_RU
                   && inventSettlement.InventTransCurrency_RU == inventTransCurrency)
                   || !countryRegion_RU)
                   // </GEERU>
                   && inventSettlement.TransDate            >  inventClosing.TransDate
                   && inventSettlement.CostAmountAdjustment != 0
            {
                mapAdjustmentLater.insert(inventSettlement.TransRecId, CurrencyExchangeHelper::amount(inventSettlement.CostAmountAdjustment, standardCurrency));
            }
        }

        // Rare case: for future adjustments on other items, we fill the cache on demand.
        if (_inventTrans.ItemId != inventCostList.ItemId && ! mapAdjustmentLater.exists(_inventTrans.RecId))
        {
            // Optimization note: RecIdTypeIdx is cluster index
            select sum(CostAmountAdjustment) from inventSettlement
                where inventSettlement.TransRecId           == _inventTrans.RecId
                   // <GEERU>
                   && (!countryRegion_RU
                   || inventSettlement.InventTransCurrency_RU == inventTransCurrency)
                   // </GEERU>
                   && inventSettlement.TransDate            >  inventClosing.TransDate
                   && inventSettlement.Cancelled            == NoYes::No
                   && inventSettlement.CostAmountAdjustment != 0;

            mapAdjustmentLater.insert(_inventTrans.RecId, CurrencyExchangeHelper::amount(inventSettlement.CostAmountAdjustment, standardCurrency));
        }

        // Return the result from the cache.
        if (mapAdjustmentLater.exists(_inventTrans.RecId))
        {
            return mapAdjustmentLater.lookup(_inventTrans.RecId);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcMinAdjustment</Name>
				<Source><![CDATA[
    protected CostAmount calcMinAdjustment(InventTrans _inventTrans)
    {
        InventSettlement    inventSettlement;

        if (inventClosing.AdjustmentType == InventAdjustmentType::Recalculation)
        {
            // Optimization note: RecIdTypeIdx is cluster index
            select firstonly CostAmountAdjustment from inventSettlement
                where   inventSettlement.TransRecId           == _inventTrans.RecId
                     // <GEERU>
                     && (!countryRegion_RU
                     || inventSettlement.InventTransCurrency_RU == inventTransCurrency)
                     // </GEERU>
                     && inventSettlement.SettleType           == InventSettleType::CompleteAdjustment
                     && inventSettlement.TransDate            == inventClosing.TransDate
                     && inventSettlement.Voucher              == inventClosing.Voucher
                     && inventSettlement.Cancelled            == 0
                     && inventSettlement.CostAmountAdjustment <  inventClosing.MinTransferValue
                     && inventSettlement.CostAmountAdjustment > -inventClosing.MinTransferValue;
        }

        return abs(inventSettlement.CostAmountAdjustment) < inventClosing.MinTransferValue ? inventSettlement.CostAmountAdjustment : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcWIPProdHistoricalCost_RU</Name>
				<Source><![CDATA[
    protected boolean calcWIPProdHistoricalCost_RU(InventTransId    _inventTransId,
                                                   Voucher          _voucherPhysical)
    {
        ProdId prodId = this.prodIdWIPCalc_RU(_inventTransId);
        if (prodId)
        {
            ProdCalculatingWIPEngine_RU::runFromInventClosing(prodId,
                                                              inventClosing.TransDate,
                                                              inventClosing.Voucher,
                                                              this,
                                                              inventTransCurrency,
                                                              mapInventTable,
                                                              mapInventModelGroup,
                                                              _voucherPhysical);
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costAmountPosted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the posted cost amount from an inventory transaction.
    /// </summary>
    /// <param name="_inventTrans">
    /// The inventory transaction.
    /// </param>
    /// <returns>
    /// The posted cost amount from an inventory transaction.
    /// </returns>
    protected CostAmountPosted costAmountPosted(InventTrans _inventTrans)
    {
        return _inventTrans.CostAmountPosted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costValue</Name>
				<Source><![CDATA[
    protected CostAmount costValue(InventTrans _inventTrans)
    {
        return _inventTrans.costValue() - this.calcLaterAdjustment(_inventTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAdjustSettlement</Name>
				<Source><![CDATA[
    protected void createAdjustSettlement(
        InventTrans            inventTrans,
        CostAmount             adjustment,
        InventSettleTransId    transaction
        )
    {
        InventSettlement        inventSettlementUpdate;

        if (!adjustment)
            return;

        InventSettlement inventSettlementInsert = this.initInventSettlement(  inventTrans,
                                                                              0,
                                                                              0,
                                                                              adjustment,
                                                                              InventSettleModel::Adjustment,
                                                                              InventSettleType::CompleteAdjustment,
                                                                              inventClosing.Ledger ? InitLedgerAsPosted : InitLedgerDrop);

        // Optimization note: RecIdTypeIdx is cluster index
        select forupdate firstonly inventSettlementUpdate
            where inventSettlementUpdate.TransRecId                     == inventTrans.RecId
               && inventSettlementUpdate.TransDate                      == inventSettlementInsert.TransDate
               && inventSettlementUpdate.Voucher                        == inventSettlementInsert.Voucher
               && inventSettlementUpdate.SettleModel                    == inventSettlementInsert.SettleModel
               && inventSettlementUpdate.SettleType                     == inventSettlementInsert.SettleType
               && inventSettlementUpdate.OperationsLedgerDimension      == inventSettlementInsert.OperationsLedgerDimension
               && inventSettlementUpdate.OperationsPosting              == inventSettlementInsert.OperationsPosting
               && inventSettlementUpdate.BalanceSheetLedgerDimension    == inventSettlementInsert.BalanceSheetLedgerDimension
               && inventSettlementUpdate.BalanceSheetPosting            == inventSettlementInsert.BalanceSheetPosting
               && inventSettlementUpdate.Cancelled                      == 0;

        if (inventSettlementUpdate.RecId)
        {
            inventSettlementUpdate.CostAmountAdjustment += adjustment;
            inventSettlementUpdate.update(); // Adjustments without a value is deleted in the class InventCostLedgerPostingTask.
        }
        else
        {
            inventSettlementInsert.SettleTransId = transaction;
            inventSettlementInsert.insert(transaction);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAdjustSettlementRecalc</Name>
				<Source><![CDATA[
    protected void createAdjustSettlementRecalc(
        InventTrans            _inventTrans,
        CostAmount             _adjustment,
        InventSettleTransId    _transaction)
    {
        InventSettlement        inventSettlement;
        InventSettlement        inventSettlementMin;

        if (!_adjustment)
            return;

        // Optimization note: RecIdTypeIdx is cluster index
        select forupdate firstonly inventSettlement
              where inventSettlement.SettleType             == InventSettleType::CompleteAdjustment
                // <GEERU>
                &&  (!countryRegion_RU || inventSettlement.InventTransCurrency_RU == inventTransCurrency)
                // </GEERU>
                &&  inventSettlement.Cancelled              == 0
                &&  inventSettlement.TransDate              == inventClosing.TransDate
                &&  inventSettlement.Voucher                == inventClosing.Voucher
                &&  inventSettlement.TransRecId             == _inventTrans.RecId
                && (inventSettlement.CostAmountAdjustment   >= inventClosing.MinTransferValue
                ||  inventSettlement.CostAmountAdjustment   <= -inventClosing.MinTransferValue);

        select forupdate firstonly inventSettlementMin
              where inventSettlementMin.SettleType              == InventSettleType::CompleteAdjustment
                // <GEERU>
                &&  (!countryRegion_RU || inventSettlementMin.InventTransCurrency_RU  == inventTransCurrency)
                // </GEERU>
                &&  inventSettlementMin.Cancelled               == 0
                &&  inventSettlementMin.TransDate               == inventClosing.TransDate
                &&  inventSettlementMin.Voucher                 == inventClosing.Voucher
                &&  inventSettlementMin.TransRecId              == _inventTrans.RecId
                &&  inventSettlementMin.CostAmountAdjustment    < inventClosing.MinTransferValue
                &&  inventSettlementMin.CostAmountAdjustment    > -inventClosing.MinTransferValue;

        if (inventSettlementMin.RecId)
        {
            if (inventSettlement.RecId && abs(inventSettlementMin.CostAmountAdjustment + _adjustment) > inventClosing.MinTransferValue)
            {
                inventSettlement.CostAmountAdjustment += inventSettlementMin.CostAmountAdjustment + _adjustment;

                inventSettlementMin.delete();
                inventSettlement.update(); // Adjustments without a value is deleted in the class InventCostLedgerPostingTask.
            }
            else
            {
                if (_inventTrans.inventTransOrigin().ReferenceCategory == InventTransType::SummedUp
                    && (inventSettlementMin.BalanceSheetLedgerDimension
                    || inventSettlementMin.OperationsLedgerDimension)
                    && InventCostSkipVirtualTransferPostingFlight::instance().isEnabled())
                {
                    inventSettlementMin.BalanceSheetPosting = 0;
                    inventSettlementMin.OperationsPosting = 0;
                    inventSettlementMin.BalanceSheetLedgerDimension = 0;
                    inventSettlementMin.OperationsLedgerDimension = 0;
                }

                inventSettlementMin.CostAmountAdjustment += _adjustment;
                inventSettlementMin.update(); // Adjustments without a value is deleted in the class InventCostLedgerPostingTask.
            }
        }
        else
        {
            if (inventSettlement.RecId && abs(_adjustment) >= inventClosing.MinTransferValue)
            {
                inventSettlement.CostAmountAdjustment += _adjustment;
                inventSettlement.update(); // Adjustments without a value is deleted in the class InventCostLedgerPostingTask.
            }
            else
            {
                inventSettlement.clear();
                inventSettlement = this.initInventSettlement(_inventTrans,
                                                                0,
                                                                0,
                                                                 _adjustment,
                                                                 InventSettleModel::Adjustment,
                                                                 InventSettleType::CompleteAdjustment,
                                                                 inventClosing.Ledger ? InitLedgerAsPosted : InitLedgerDrop);

                inventSettlement.SettleTransId = _transaction;
                inventSettlement.insert(_transaction);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createErrorAdjustment</Name>
				<Source><![CDATA[
    protected void createErrorAdjustment(
        InventTrans     _receipt,
        CostAmount      _adjustment
        )
    {
        InventSettlement inventSettlement = this.initInventSettlement(_receipt, 0, 0, _adjustment, InventSettleModel::Adjustment, InventSettleType::CompleteAdjustment, InitLedgerAlways, errorAdjustment);
        inventSettlement.insert();

        // <GEERU>
        if ((countryRegion_RU
            && inventTransCurrency == InventTransCurrency_RU::PrimaryCur)
            || !countryRegion_RU)
        {
            // </GEERU>
            _receipt.CostAmountAdjustment += _adjustment;
            // <GEERU>
        }
        else
        {
            _receipt.CostAmountSecCurAdjustment_RU += _adjustment;
        }
        // </GEERU>

        this.updateInventTrans(_receipt);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createErrorQtySettled</Name>
				<Source><![CDATA[
    protected void createErrorQtySettled(InventTrans _inventTrans,
                                         Qty            _qty,
                                         PdsCWInventQty _cwQty = 0
                                         )
    {
        InventSettlement inventSettlement = this.initInventSettlement(_inventTrans,_qty,0,0,InventSettleModel::Adjustment,_inventTrans.Qty >= 0 ? InventSettleType::Receipt : InventSettleType::Issue, InitLedgerDrop, false, _cwQty);

        inventSettlement.insert();

        _inventTrans.QtySettled     += _qty;
        _inventTrans.PdsCWSettled   += _cwQty;

        this.updateInventTrans(_inventTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyTransfer_RU</Name>
				<Source><![CDATA[
    protected boolean currencyTransfer_RU(InventTrans _inventTrans)
    {
        return _inventTrans.CostAmountPosted != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>financialOpenQty</Name>
				<Source><![CDATA[
    protected Qty financialOpenQty(InventTrans _inventTrans)
    {
        if (mapSettleQty.exists(_inventTrans.RecId))
            return _inventTrans.financialOpenQty() + mapSettleQty.lookup(_inventTrans.RecId);

        return _inventTrans.financialOpenQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>financialOpenValue</Name>
				<Source><![CDATA[
    protected CostAmount financialOpenValue(InventTrans _inventTrans)
    {
        CostAmount  costAmount = _inventTrans.isUpdatedFinancial() && _inventTrans.DateFinancial <= inventClosing.TransDate ? _inventTrans.financialOpenValue() : _inventTrans.CostAmountPhysical;

        if (mapSettleValue.exists(_inventTrans.RecId))
            return costAmount + mapSettleValue.lookup(_inventTrans.RecId);

        return costAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFinDimCombinationEnumerator</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an enumerator for a collection of financial dimension combinations, that must be processed for a particular item.
    /// </summary>
    /// <param name="_inventTable">
    /// An <c>InventTable</c> table buffer.
    /// </param>
    /// <returns>
    /// The enumerator.
    /// </returns>
    protected Enumerator getFinDimCombinationEnumerator(InventTable _inventTable)
    {
        List listInventDim = new List(Types::Record);

        if (inventCostListParm.MinOfDateStatus <= inventClosing.TransDate)
        {
            QueryRun queryRun = this.initQueryRunTrans(_inventTable, this.inventModelGroup(_inventTable.ItemId));
            while (queryRun.next())
            {
                InventDim inventDim = queryRun.get(tableNum(InventDim));

                inventDim.checkInvalidFieldAccess(false);
                listInventDim.addEnd(inventDim);
            }
        }

        return listInventDim.getEnumerator();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustInitializeInventSettlementPostingAdjustmentFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the adjustment posting fields on the <c>InventSettlement</c> record must be initialized.
    /// </summary>
    /// <param name = "_inventTransPosting">The posting transaction.</param>
    /// <returns>true if the adjustment posting fields must be initialized; otherwise, false.</returns>
    protected boolean mustInitializeInventSettlementPostingAdjustmentFields(InventTransPosting _inventTransPosting)
    {
        // Adjustments should only be posted if the original posting reflects the inventory value
        return _inventTransPosting.PostingType != LedgerPostingType::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventSettlement</Name>
				<Source><![CDATA[
    protected InventSettlement initInventSettlement(
        InventTrans         _inventTrans,
        InventQty           _qtySettle,
        CostAmount          _valueSettle,
        CostAmount          _adjustment,
        InventSettleModel   _inventSettleModel,
        InventSettleType    _inventSettleType,
        Integer             _initLedger,
        boolean             _errorAdjustment = false,
        PdsCWSettled        _pdsCWSettled = 0.00
        )
    {
        InventTransPosting inventTransPosting;
        InventTransPosting inventTransPostingCharge;

        ItemGroupId itemGroupId = this.itemGroupId(_inventTrans.ItemId);

        if (_inventTrans.isUpdatedFinancial())
        {
            inventTransPosting = this.getInventTransPosting(_inventTrans, inventTransPostingType::Financial, _inventTrans.Voucher, _inventTrans.DateFinancial);
    
            if (_inventTrans.InventTransOrigin().ReferenceCategory == InventTransType::Purch && _inventTrans.qty < 0)
            {
                inventTransPostingCharge = this.getInventTransPosting(_inventTrans, inventTransPostingType::FinancialCharge, _inventTrans.Voucher, _inventTrans.DateFinancial);
            }
        }
        else
        {
            if (! UpdatePhysicalSettlement)
            {
                throw error(strFmt("@SYS19378",funcName()));
            }

            inventTransPosting = this.getInventTransPosting(_inventTrans, inventTransPostingType::Physical, _inventTrans.VoucherPhysical, _inventTrans.DatePhysical);
    
            if (_inventTrans.InventTransOrigin().ReferenceCategory == InventTransType::Purch &&  _inventTrans.qty < 0)
            {
                inventTransPostingCharge = this.getInventTransPosting(_inventTrans, inventTransPostingType::PhysicalCharge, _inventTrans.VoucherPhysical, _inventTrans.DatePhysical);
            }
        }

        InventSettlement inventSettlement;
        inventSettlement.InventTransId    = this.inventTransId(_inventTrans.InventTransOrigin);
        inventSettlement.ItemId           = _inventTrans.ItemId;
        inventSettlement.ItemGroupId      = itemGroupId;
        inventSettlement.TransRecId       = _inventTrans.RecId;
        inventSettlement.DefaultDimension = inventSettlement.copyDimension(inventTransPosting.DefaultDimension);
        inventSettlement.TransDate               = inventClosing.TransDate;
        inventSettlement.Voucher                 = inventClosing.Voucher;
        inventSettlement.QtySettled              = _qtySettle;
        inventSettlement.PdsCWSettled            = _pdsCWSettled;
        inventSettlement.CostAmountSettled       = _valueSettle;
        inventSettlement.CostAmountAdjustment    = _adjustment;
        inventSettlement.SettleModel             = _inventTrans.isUpdatedFinancial() ? _inventSettleModel : InventSettleModel::PhysicalValue;
        inventSettlement.SettleType              = _inventSettleType;

        // <GEERU>
        if (countryRegion_RU)
        {
            inventSettlement.InventTransCurrency_RU  = inventTransCurrency;
        }
        // </GEERU>

        if (this.mustInitializeInventSettlementPostingAdjustmentFields(inventTransPosting))
        {
            if (_initLedger == InitLedgerAlways || (_initLedger == InitLedgerAsPosted && inventTransPosting.IsPosted))
            {
                inventSettlement.BalanceSheetPosting     = inventTransPosting.PostingType;
                inventSettlement.BalanceSheetLedgerDimension     = inventTransPosting.LedgerDimension;
                if (! inventSettlement.BalanceSheetLedgerDimension)
                {
                    // <GCN>
                    if (InventPostingExtendParm_CN::checkExtendParmEnabled())
                    {
                        inventSettlement.BalanceSheetLedgerDimension = InventAdj::errorAccountBalanceSheet_CN(
                            _inventTrans.ItemId,
                            itemGroupId,
                            _inventTrans.Qty,
                            InventPostingExtendParm_CN::constructInventDim(_inventTrans.inventDim()));
                    }
                    else
                    // </GCN>
                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        inventSettlement.BalanceSheetLedgerDimension = InventAdj::errorAccountBalanceSheet(_inventTrans.ItemId,
                                                                                                itemGroupId,
                                                                                               _inventTrans.Qty,
                                                                                               _inventTrans.inventDim());
                    }
                    else
                    {
                        // </GEERU>
                        inventSettlement.BalanceSheetLedgerDimension  = InventAdj::errorAccountBalanceSheet(_inventTrans.ItemId,
                                                                                               itemGroupId,
                                                                                               _inventTrans.Qty);
                        // <GEERU><GCN>
                    }
                    // </GCN></GEERU>
                }

                if (inventTransPostingCharge)
                {
                    inventSettlement.OperationsPosting = inventTransPostingCharge.PostingTypeOffset;
                }
                else
                {
                    inventSettlement.OperationsPosting = inventTransPosting.PostingTypeOffset;
                }
    
                if (! inventSettlement.OperationsPosting || _errorAdjustment)
                {
                    inventSettlement.OperationsPosting = InventAdj::errorPostingOperations(_adjustment);
                }	
    
                if (inventTransPostingCharge)
                {
                    inventSettlement.OperationsLedgerDimension = inventTransPostingCharge.OffsetLedgerDimension;
                }
                else
                {
                    inventSettlement.OperationsLedgerDimension = inventTransPosting.OffsetLedgerDimension;
                }

                if (! inventSettlement.OperationsLedgerDimension || _errorAdjustment)
                {
                    inventSettlement.OperationsLedgerDimension = InventAdj::errorAccountOperations(_inventTrans.ItemId,
                            itemGroupId,
                            // <GEERU>
                            _adjustment,
                            _inventTrans.inventDim());
                            // </GEERU>
                }
            }
        }

        return inventSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMaps</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes objects that store transactions information.
    /// </summary>
    protected void initMaps()
    {
        tmpInventModel      = null;
        mapInventTrans      = new Map(recIdType, Types::Record);
        mapSettleQty        = new Map(recIdType, Types::Real);
        mapSettleValue      = new Map(recIdType, Types::Real);
        mapAdjustment       = null;

        pdsMapSettleCWQty   = new Map(recIdType, Types::Real);

        referenceCategoryCache = InventCostReferenceCategoryCache::construct();

        mapInventTransId    = new Map(recIdType, Types::String);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCostListTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes an adjustment to the database so that it can be handled later.
    /// </summary>
    /// <param name="_itemId">
    ///    The item to which the adjustment must be made.
    /// </param>
    /// <param name="_inventTransOrigin">
    ///    The origin ID of the transactions to which this adjustment will eventually be made.
    /// </param>
    /// <param name="_adjustment">
    ///    The amount by which the cost will eventually be adjusted.
    /// </param>
    /// <param name="_returnInventTransOrigin">
    ///    The return origin ID of the transactions to which this adjustment will eventually be made.
    /// </param>
    /// <param name="_voucherPhysical">
    ///    The physical voucher of the transactions to which this adjustment will eventually be made.
    /// </param>
    /// <param name="_connection">
    ///    Obsolete; optional.
    /// </param>
    /// <returns>
    ///    Always return null.
    /// </returns>
    /// <remarks>
    ///    If the item in <paramref name="_itemId" /> does not occur in the inventory closing work list, it
    ///    will automatically be put on the work list.
    /// </remarks>
    protected Connection insertCostListTrans(
        ItemId                  _itemId,
        InventTransOriginId     _inventTransOrigin,
        CostAmount              _adjustment,
        InventTransOriginId     _returnInventTransOrigin,
        Voucher                 _voucherPhysical,
        Connection              _connection = null
        )
    {
        InventCostListTrans     inventCostListTrans;
        InventCostList          inventCostListNext;

        if (_itemId && inventClosing.NumOfIteration + 1 <= inventClosing.MaxIterations)
        {
            inventCostListTrans.ItemId                  = _itemId;
            inventCostListTrans.InventTransOrigin       = _inventTransOrigin;
            inventCostListTrans.ItemIdChild             = inventCostList.ItemId;
            inventCostListTrans.ReturnInventTransOrigin = _returnInventTransOrigin;
            inventCostListTrans.VoucherPhysical         = _voucherPhysical;
            inventCostListTrans.Adjustment              = _adjustment;

            inventCostListTrans.NumOfIteration          = inventClosing.NumOfIteration + 1;
            inventCostListTrans.Voucher                 = inventClosing.Voucher;
            InventClosingRecordInventDimForTransferOrderContext context = InventClosingRecordInventDimForTransferOrderContext::current();
            if (context)
            {
                inventCostListTrans.InventSerialId = context.inventSerialId;
                inventCostListTrans.InventBatchId = context.inventBatchId;
            }

            inventCostListTrans.insert();

            if (! InventCostList::existItemLevel(inventCostListTrans.Voucher,inventCostListTrans.ItemId,inventCostListTrans.NumOfIteration))
            {
                inventCostListNext.initFromInventCostListTrans(inventCostListTrans);

                inventCostListNext.bomLevel = 0; // In the coming iterations we don't want the helpers to wait for each other because of BOM Levels.
                inventCostListNext.insert();
            }
        }
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventModelGroup</Name>
				<Source><![CDATA[
    protected InventModelGroup inventModelGroup(ItemId _itemId)
    {
        if (mapInventModelGroup.exists(_itemId))
        {
            return mapInventModelGroup.lookup(_itemId);
        }

        InventModelGroup inventModelGroup = InventTable::modelGroupByItemId(_itemId);

        mapInventModelGroup.insert(_itemId, inventModelGroup);

        return inventModelGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventModelType_RU</Name>
				<Source><![CDATA[
    protected InventModelType inventModelType_RU(ItemId _itemId)
    {
        return inventModelTypeCache.inventModelType(InventTable::modelGroupIdByItemId(_itemId), inventTransCurrency);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTable</Name>
				<Source><![CDATA[
    protected InventTable inventTable(ItemId _itemId)
    {
        InventTable inventTable;

        if (mapInventTable.exists(_itemId))
        {
            return mapInventTable.lookup(_itemId);
        }

        inventTable.disableCache(true);
        select firstonly
            ItemId,
            Product,
            ItemType,
            DataAreaId,
            PmfProductType
        from inventTable
        where inventTable.ItemId == _itemId;

        inventTable.disableCache(false);

        mapInventTable.insert(_itemId, inventTable);

        return inventTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransFinancialOpenQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the financial open quantity on a inventory transaction.
    /// </summary>
    /// <param name="_inventTrans">
    /// The inventory transaction.
    /// </param>
    /// <returns>
    /// The financial open quantity.
    /// </returns>
    protected InventQty inventTransFinancialOpenQty(InventTrans _inventTrans)
    {
        return _inventTrans.financialOpenQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTranspdsCWFinancialOpenQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the financial open catch weight quantity on a inventory transaction.
    /// </summary>
    /// <param name="_inventTrans">
    /// The inventory transaction.
    /// </param>
    /// <returns>
    /// The financial open catch weight quantity.
    /// </returns>
    protected InventQty inventTranspdsCWFinancialOpenQty(InventTrans _inventTrans)
    {
        return _inventTrans.pdsCWFinancialOpenQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventTransOpen</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the receipt transaction is open.
    /// </summary>
    /// <param name="_receipt">
    /// The receipt transaction that should be updated.
    /// </param>
    /// <returns>
    /// true if the receipt transaction is open; otherwise, false.
    /// </returns>
    protected boolean isInventTransOpen(InventTrans _receipt)
    {
        return _receipt.ValueOpen == InventTransOpen::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUpdatedFinancialLater</Name>
				<Source><![CDATA[
    protected boolean isUpdatedFinancialLater(InventTrans _inventTrans)
    {
        return _inventTrans.DateFinancial > inventClosing.TransDate && _inventTrans.isUpdatedFinancial();
    }

]]></Source>
			</Method>
			<Method>
				<Name>load</Name>
				<Source><![CDATA[
    protected void load(
        InventDim   _inventDimCriteria,
        boolean     _transferOrdersOnly)
    {
        StatusReceipt       statusReceipt   = StatusReceipt::Purchased;
        StatusIssue         statusIssue     = StatusIssue::Sold;

        boolean             physicalDateCriteria;

        if (this.considerPhysicalTransactions(this.inventModelGroup(inventCostList.ItemId)))
        {
            statusReceipt           = StatusReceipt::Received;
            statusIssue             = StatusIssue::Deducted;
            physicalDateCriteria    = true;
        }

        InventDimParm inventDimParm = this.inventDimParmFinancial(this.inventDimGroupSetup(this.inventTable(inventCostList.ItemId)));

        InventTrans         inventTrans;
        InventDim           inventDim;
        InventTransOrigin   inventTransOrigin;

        #inventDimDevelop

        if (inventDimParm.InventSerialIdFlag && _inventDimCriteria.InventSerialId)
        {
            while #inventDimSelect(inventDim, _inventDimCriteria, inventDimParm, forcePlaceholders, SerialIdIdx)
            join forupdate inventTrans
                #WhereInventTransFitsRanges(inventTrans, statusIssue, statusReceipt, _transferOrdersOnly, physicalDateCriteria)
            && inventTrans.InventDimId == inventDim.InventDimId
                #JoinInventTransOrigin(inventTrans, inventTransOrigin, _transferOrdersOnly)
            {
                this.loadTrans(inventTrans, _transferOrdersOnly, inventTransOrigin);
            }
        }
        else if (inventDimParm.InventBatchIdFlag && _inventDimCriteria.InventBatchId)
        {
            while #inventDimSelect(inventDim, _inventDimCriteria, inventDimParm, forcePlaceholders, BatchIdIdx)
            join forupdate inventTrans
                #WhereInventTransFitsRanges(inventTrans, statusIssue, statusReceipt, _transferOrdersOnly, physicalDateCriteria)
            && inventTrans.InventDimId == inventDim.InventDimId
                #JoinInventTransOrigin(inventTrans, inventTransOrigin, _transferOrdersOnly)
            {
                this.loadTrans(inventTrans, _transferOrdersOnly, inventTransOrigin);
            }
        }
        else
        {
            this.loadInventTransWithNoTrackingDimension(
                _inventDimCriteria,
                _transferOrdersOnly,
                inventDimParm,
                statusIssue,
                statusReceipt,
                physicalDateCriteria);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>receiptIssueQtyDifference</Name>
				<Source><![CDATA[
    protected InventQty receiptIssueQtyDifference()
    {
        return 5000;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadInventTransWithNoTrackingDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads inventory transactions that match passed parameters with no active tracking dimension.
    /// </summary>
    /// <param name = "_inventDimCriteria">An inventory dimension record for the current financial dimensions combination.</param>
    /// <param name = "_transferOrdersOnly">Whether only transfer orders must be taken into account.</param>
    /// <param name = "_inventDimParmFinancial">Financially active inventory dimensions.</param>
    /// <param name = "_statusIssue">A status issue.</param>
    /// <param name = "_statusReceipt">A receipt issue.</param>
    /// <param name = "_physicalDateCriteria">Whether there's a physical value in the cost.</param>
    [Replaceable]
    protected void loadInventTransWithNoTrackingDimension(
        InventDim _inventDimCriteria,
        boolean _transferOrdersOnly,
        InventDimParm _inventDimParmFinancial,
        StatusIssue _statusIssue,
        StatusReceipt _statusReceipt,
        boolean _physicalDateCriteria)
    {
        InventTrans inventTrans;
        InventDim inventDim;
        InventTransOrigin inventTransOrigin;

        #inventDimDevelop

        if ((this.inventModelGroup(inventCostList.ItemId).NegativePhysical 
            || (_inventDimParmFinancial.InventLocationIdFlag && _inventDimCriteria.inventLocation().RetailInventNegPhysical))
            && InventCostItemDimFlexiblyLoadInventTransFlight::instance().isEnabled())
        {
            InventQty receiptOpenQty;
            InventQty issueOpenQty;
            InventQty qtyDifference = this.receiptIssueQtyDifference();

            while select forupdate forceplaceholders inventTrans
                #WhereInventTransFitsRanges(inventTrans, StatusIssue::None, _statusReceipt, _transferOrdersOnly, _physicalDateCriteria)
            #JoinInventTransOrigin(inventTrans, inventTransOrigin, _transferOrdersOnly)
            #inventDimExistsJoin(inventTrans.inventDimId, inventDim, _inventDimCriteria, _inventDimParmFinancial)
            {
                receiptOpenQty += inventTrans.openQty();
                this.loadTrans(inventTrans, _transferOrdersOnly, inventTransOrigin);
            }

            if (receiptOpenQty != 0)
            {
                InventModel inventModel = this.getInventModel();

                if (inventModel == InventModel::LIFO || inventModel == InventModel::LIFODate)
                {
                    if (_physicalDateCriteria)
                    {
                        while select forupdate forceplaceholders inventTrans
                        order by DatePhysical desc
                            #WhereInventTransFitsRanges(inventTrans, _statusIssue, StatusReceipt::None, _transferOrdersOnly, _physicalDateCriteria)
                        #JoinInventTransOrigin(inventTrans, inventTransOrigin, _transferOrdersOnly)
                        #inventDimExistsJoin(inventTrans.inventDimId, inventDim, _inventDimCriteria, _inventDimParmFinancial)
                        {
                            if (issueOpenQty <= receiptOpenQty + qtyDifference)
                            {
                                this.loadTrans(inventTrans, _transferOrdersOnly, inventTransOrigin);
                            }
                            else
                            {
                                break;
                            }

                            issueOpenQty += inventTrans.openQty();
                        }
                    }
                    else
                    {
                        while select forupdate forceplaceholders inventTrans
                        order by DateFinancial desc
                            #WhereInventTransFitsRanges(inventTrans, _statusIssue, StatusReceipt::None, _transferOrdersOnly, _physicalDateCriteria)
                        #JoinInventTransOrigin(inventTrans, inventTransOrigin, _transferOrdersOnly)
                        #inventDimExistsJoin(inventTrans.inventDimId, inventDim, _inventDimCriteria, _inventDimParmFinancial)
                        {
                            if (issueOpenQty <= receiptOpenQty + qtyDifference)
                            {
                                this.loadTrans(inventTrans, _transferOrdersOnly, inventTransOrigin);
                            }
                            else
                            {
                                break;
                            }

                            issueOpenQty += inventTrans.openQty();
                        }
                    }
                }
                else
                {
                    if (_physicalDateCriteria)
                    {
                        while select forupdate forceplaceholders inventTrans
                        order by DatePhysical asc
                            #WhereInventTransFitsRanges(inventTrans, _statusIssue, StatusReceipt::None, _transferOrdersOnly, _physicalDateCriteria)
                        #JoinInventTransOrigin(inventTrans, inventTransOrigin, _transferOrdersOnly)
                        #inventDimExistsJoin(inventTrans.inventDimId, inventDim, _inventDimCriteria, _inventDimParmFinancial)
                        {
                            if (issueOpenQty <= receiptOpenQty + qtyDifference)
                            {
                                this.loadTrans(inventTrans, _transferOrdersOnly, inventTransOrigin);
                            }
                            else
                            {
                                break;
                            }

                            issueOpenQty += inventTrans.openQty();
                        }
                    }
                    else
                    {
                        while select forupdate forceplaceholders inventTrans
                        order by DateFinancial asc
                            #WhereInventTransFitsRanges(inventTrans, _statusIssue, StatusReceipt::None, _transferOrdersOnly, _physicalDateCriteria)
                        #JoinInventTransOrigin(inventTrans, inventTransOrigin, _transferOrdersOnly)
                        #inventDimExistsJoin(inventTrans.inventDimId, inventDim, _inventDimCriteria, _inventDimParmFinancial)
                        {
                            if (issueOpenQty <= receiptOpenQty + qtyDifference)
                            {
                                this.loadTrans(inventTrans, _transferOrdersOnly, inventTransOrigin);
                            }
                            else
                            {
                                break;
                            }

                            issueOpenQty += inventTrans.openQty();
                        }
                    }
                }
            }
        }
        else
        {
            // Optimization note: All columns in the where clause are expected to be included in the index
            while select forupdate forceplaceholders inventTrans
                #WhereInventTransFitsRanges(inventTrans, _statusIssue, _statusReceipt, _transferOrdersOnly, _physicalDateCriteria)
            #JoinInventTransOrigin(inventTrans, inventTransOrigin, _transferOrdersOnly)
            #inventDimExistsJoin(inventTrans.inventDimId, inventDim, _inventDimCriteria, _inventDimParmFinancial)
            {
                this.loadTrans(inventTrans, _transferOrdersOnly, inventTransOrigin);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadTrans</Name>
				<Source><![CDATA[
    protected void loadTrans(
        InventTrans _inventTrans,
        boolean             _transferOrdersOnly,
        InventTransOrigin   _inventTransOrigin)
    {
        referenceCategoryCache.addReferenceCategory(_inventTrans.InventTransOrigin, _inventTransOrigin.ReferenceCategory);
        mapInventTransId.insert(_inventTrans.InventTransOrigin, _inventTransOrigin.InventTransId);

        if (_transferOrdersOnly)
        {
            if (_inventTrans.MarkingRefInventTransOrigin == 0)
            {
                // add any transfer order records without marking
                mapInventTrans.insert(_inventTrans.RecId, _inventTrans);
            }
            else
            {
                InventTransType markingReferenceCategory = referenceCategoryCache.getReferenceCategory(_inventTrans.MarkingRefInventTransOrigin);

                // Allow pre-closing of transfer order records with marking in the following 2 cases
                if ((_inventTrans.Qty < 0 && markingReferenceCategory == InventTransType::TransferOrderShip)
                 || (_inventTrans.Qty > 0 && markingReferenceCategory == InventTransType::TransferOrderReceive)
                // <GEERU>
                // for storned items shipped previously  from the issue warehouse to the transit one (without receiving to the target warehouse)
                || (countryRegion_RU && _inventTrans.Qty > 0 && markingReferenceCategory == InventTransType::TransferOrderShip  && _inventTrans.ReturnInventTransOrigin)
                // for the storno records
                || (countryRegion_RU && _inventTrans.isTransferOrderStorno_RU())
                // </GEERU>
                )
                {
                    mapInventTrans.insert(_inventTrans.RecId, _inventTrans);
                }
            }
        }
        else
        {
            if (_inventTrans.RecId)
            {
                mapInventTrans.insert(_inventTrans.RecId,_inventTrans);
            }
        }
        
        openInventTransCount++;
    }

]]></Source>
			</Method>
			<Method>
				<Name>matchIssuesAndReceipts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Matches issues and receipts for inventory closing or recalculation.
    /// </summary>
    /// <param name="_isServiceItem">
    /// A Boolean value that indicates whether the current item is a service.
    /// </param>
    /// <param name="_inventTable">
    /// An <c>InventTable</c> table buffer that represents the current item.
    /// </param>
    /// <remarks>
    /// The issues and receipts are settled for inventory closing and adjusted for recalculation.
    /// </remarks>
    protected void matchIssuesAndReceipts(
        boolean     _isServiceItem,
        InventTable _inventTable)
    {
        Enumerator      inventDimEnumerator;

        if (!_isServiceItem)
        {
            if (inventCostListParm.HasReceipts && inventCostListParm.HasIssues && inventCostListParm.HasMarking == NoYes::Yes)
            {
                // first close non-financial transfers among transfer orders, as their markings should be ignored in this case
                inventDimEnumerator = this.preCloseItem();
            }

            if (! inventDimEnumerator)
            {
                inventDimEnumerator = this.getFinDimCombinationEnumerator(_inventTable);
            }
            else
            {
                inventDimEnumerator.reset();
            }

            if (inventCostListParm.HasMarking)
            {
                if (InventCostItemUpdateMarkingByFinancialDimFlight::instance().isEnabled())
                {
                    inventDimEnumeratorForMarking = inventDimEnumerator;
                }

                // then match issues and receipts that are marked and remove invalid markings (issue without receipt etc.)
                this.updateMarking(_inventTable.ItemId);
            }

            if (InventCostItemUpdateMarkingByFinancialDimFlight::instance().isEnabled())
            {
                inventDimEnumerator.reset();
            }

            // finally, match remaining issues and receipts according to inventory model, per financial dimension combination
            while (inventDimEnumerator.moveNext())
            {
                InventDim inventDim = inventDimEnumerator.current();

                this.initMaps();

                this.startTimer();
                this.load(inventDim, false);
                loadTime+=this.getTimer();
                loadCount++;

                // non-financial transfers and returns will be closed before the model is processed
                if (inventCostListParm.HasReceipts && inventCostListParm.HasIssues)
                {
                    this.startTimer();
                    this.preCloseNonFinancial();
                    preCloseNonFinancialTime+=this.getTimer();
                    preCloseNonFinancialCount++;
                }

                this.updateReceiptAdjustment();

                if (inventCostListParm.HasReceipts && inventCostListParm.HasIssues)
                {
                    this.updateModel(inventDim);
                }
            }
        }
        else
        {
            // match issues and receipts that are marked
            if (inventCostListParm.HasMarking)
            {
                this.updateMarking(_inventTable.ItemId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new(
        InventCostHelpTaskBase _inventCostHelpTaskBase,
        InventClosing          _inventClosing,
        InventTransCurrency_RU _inventTransCurrency = InventTransCurrency_RU::PrimaryCur
        )
    {
        inventCostHelpTaskBase  = _inventCostHelpTaskBase;
        inventClosing           = _inventClosing;

        // <GEERU>
        countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

        if (!countryRegion_RU)
        {
            // </GEERU>
            roundOffunit        = Currency::roundingPrecisionAdjusted(Ledger::accountingCurrency());
            // <GEERU>
        }
        // </GEERU>
        standardCurrency    = CompanyInfoHelper::standardCurrency();
        recIdType           = typeName2Type(extendedTypeStr(RecId));

        mapInventTable      = new Map(Types::String, Types::Record);
        mapInventModelGroup = new Map(Types::String, Types::Record);
        mapItemGroupId      = new Map(Types::String, Types::String);

        // <GEERU>
        mapProdIdWIPCalc_RU         = new Map(Types::String, Types::String);
        mapcalculatingWIPBySite_RU  = new Map(Types::String, Types::Enum);
        if (countryRegion_RU)
        {
            calculationProdWIP_RU = (select firstonly RecId from prodParametersDim
                                         where prodParametersDim.CalculatingWIP_RU == NoYes::Yes).RecId ? true : false;

            inventTransCurrency = _inventTransCurrency;

            if (inventTransCurrency == InventTransCurrency_RU::SecondaryCur)
            {
                standardCurrency = CompanyInfoHelper::secondaryCurrency_RU();
            }
            inventModelTypeCache = InventModelTypeCache::construct();

            roundOffunit = Currency::roundingPrecisionAdjusted(standardCurrency);
        }
        // </GEERU>

        needCalcAllocation = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openIssueToInfoLog</Name>
				<Source><![CDATA[
    protected void openIssueToInfoLog()
    {
        Integer    logPoint = infologLine();
        boolean    shouldSummarize = false;

        MapEnumerator me = mapOpenIssue.getEnumerator();

        if (inventClosing.ShouldSummarizeInfolog)
        {
            shouldSummarize = true;
            if (!mapOpenIssue.empty())
            {
                warning(strFmt("@SCM:InventCostOpenIssueInfolog", inventCostList.ItemId));
            }
        }
        else
        {
            while (me.moveNext())
            {
                InventTrans inventTrans = me.currentValue();
                InventTransOrigin inventTransOrigin = inventTrans.inventTransOrigin();
                setPrefix(#prefixfield(inventTransOrigin, itemId));
                setPrefix(strFmt("@SYS96345",inventTransOrigin.ReferenceCategory, inventTransOrigin.ReferenceId, inventTransOrigin.InventTransId));
                warning(strFmt("@SYS96346",inventTrans.costPrice()));
            }
        }
        

        if (infologLine() > logPoint)
        {
            if (shouldSummarize)
            {
                InfologData infologDataSummary = infolog.cut(logPoint+1, infologLine());
                inventClosing.writeLogWithSummary(infologDataSummary, LogType::Item, inventCostList.ItemId);
            }
            else
            {
                InfologData infologData = infolog.cut(logPoint+1, infologLine());
                inventClosing.writeLog(infologData, LogType::Item, inventCostList.ItemId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventCostList</Name>
				<Source><![CDATA[
    public InventCostList parmInventCostList(InventCostList    _inventCostList = inventCostList)
    {
        inventCostList = _inventCostList;

        return inventCostList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMapInventTrans</Name>
				<Source><![CDATA[
    protected Map parmMapInventTrans(Map _mapInventTrans = mapInventTrans)
    {
        mapInventTrans = _mapInventTrans;

        return mapInventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWFinancialOpenQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates and returns financial quantity open for an active <c>InventTrans</c> record.
    /// </summary>
    /// <param name="_inventTrans">
    /// An active <c>InventTrans</c> record.
    /// </param>
    /// <returns>
    /// The calculated financial quantity that is open for the active <c>InventTrans</c> record.
    /// </returns>
    protected PdsCWInventQty pdsCWFinancialOpenQty(InventTrans _inventTrans)
    {
        if (pdsMapSettleCWQty.exists(_inventTrans.RecId))
        {
            return _inventTrans.pdsCWFinancialOpenQty()
                + pdsMapSettleCWQty.lookup(_inventTrans.RecId);
        }

        return _inventTrans.pdsCWFinancialOpenQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>preCloseNonFinancial</Name>
				<Source><![CDATA[
    protected void preCloseNonFinancial()
    {
        InventTrans                             inventTrans;
        RecordInsertList                        rilInventClosingNonFinancialInventTrans = new RecordInsertList(tableNum(InventClosingNonFinancialInventTrans));
        InventClosingNonFinancialInventTrans    inventClosingNonFinancialInventTrans;
        boolean                                 isRecordInserted;

        InventCostPreCloseMatchTransfer transferMatch = InventCostPreCloseMatchTransfer::construct(inventTransCurrency);
        InventCostPreCloseMatchReturn returnMatch = InventCostPreCloseMatchReturn::construct(this.inventModelGroup(inventCostList.ItemId).inventModelType(), inventTransCurrency);
        transferMatch.parmReferenceCategoryCache(referenceCategoryCache);

        MapEnumerator mapEnumerator = mapInventTrans.getEnumerator();
        while (mapEnumerator.moveNext())
        {
            inventTrans = mapEnumerator.currentValue();

            if (inventTrans.Qty != 0 || !isInventCostPreCloseMatchReturnCheckQtyFlightEnabled)
            {
                returnMatch.addInventTrans(inventTrans);
                transferMatch.addInventTrans(inventTrans);
            }
        }

        // Close transfers and returns
        keysToBeDeleted = new Set(recIdType);
        mapEnumerator.reset();
        while (mapEnumerator.moveNext())
        {
            inventTrans = mapEnumerator.currentValue();
            isRecordInserted = false;

            if (inventTrans.Qty != 0 || !isInventCostPreCloseMatchReturnCheckQtyFlightEnabled)
            {
                if (returnMatch.isMatching(inventTrans))
                {
                    this.preCloseNonFinanacialTransfersAndReturns(
                        inventTrans,
                        mapEnumerator,
                        rilInventClosingNonFinancialInventTrans,
                        isRecordInserted);
                    isRecordInserted = true;
                }

                if (transferMatch.isMatching(inventTrans))
                {
                    this.preCloseNonFinanacialTransfersAndReturns(
                        inventTrans,
                        mapEnumerator,
                        rilInventClosingNonFinancialInventTrans,
                        isRecordInserted);
                }
            }
        }

        if (preSettledQty != 0.0 && preSettledAmount != 0.0)
        {
            throw error(strFmt("@SYS19378", funcName()));
        }

        if (updateCount)
        {
            rilInventClosingNonFinancialInventTrans.insertDatabase();
            ttsCommit;
            ttsBegin;
        }

        SetEnumerator setEnumerator = keysToBeDeleted.getEnumerator();
        while (setEnumerator.moveNext())
        {
            mapInventTrans.remove(setEnumerator.current());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>preCloseNonFinanacialTransfersAndReturns</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processing seperate inventory closing for transfers and returns.
    /// </summary>
    /// <param name="_inventTrans">
    /// The inventory transaction that will be used to get the transaction posting.
    /// </param>
    /// <param name="_mapEnumerator">
    /// _mapEnumerator to get the current transaction key.
    /// </param>
    /// <param name="_rilInventClosingNonFinancialInventTrans">
    /// List of records of InventClosingNonFinancialInventTrans table.
    /// </param>
    /// <param name="_isRecordInserted">
    /// Checking record already inserted in to the List.
    /// </param>
    private void preCloseNonFinanacialTransfersAndReturns(
        InventTrans _inventTrans,
        MapEnumerator _mapEnumerator,
        RecordInsertList _rilInventClosingNonFinancialInventTrans,
        boolean _isRecordInserted = false)
    {

        if (inventClosing.InventTransCurrency_RU == InventTransCurrency_RU::SecondaryCur)
        {
            this.setNonFinancialInventTransToClosed(_inventTrans);

            _inventTrans.clearMarking();

            _inventTrans.skipTTSCheck(true);
            _inventTrans.update();
        }
        else
        {
            InventTrans inventTransUpdate;

            inventTransUpdate.skipDataMethods(true);
            // Optimization: Where clause must be equal to the clustered index on InventTrans.
            update_recordSet inventTransUpdate
            setting ValueOpen = InventTransOpen::No,
                    DateClosed = inventClosing.TransDate,
                    MarkingRefInventTransOrigin = 0
            where inventTransUpdate.InventTransOrigin == _inventTrans.InventTransOrigin
               && inventTransUpdate.inventDimId == _inventTrans.inventDimId
               && inventTransUpdate.RecId == _inventTrans.RecId;
        }

        if (_inventTrans.Voucher != inventClosing.Voucher)
        {
            closedInventTransCount++;
        }

        if (!_isRecordInserted)
        {
            InventClosingNonFinancialInventTrans inventClosingNonFinancialInventTrans;

            inventClosingNonFinancialInventTrans.InventClosing = inventClosing.RecId;
            inventClosingNonFinancialInventTrans.InventTrans = _inventTrans.RecId;
            inventClosingNonFinancialInventTrans.AllowCancel = _inventTrans.ReturnInventTransOrigin != 0;
            _rilInventClosingNonFinancialInventTrans.add(inventClosingNonFinancialInventTrans);
        }

        keysToBeDeleted.add(_mapEnumerator.currentKey());

        preSettledQty += _inventTrans.Qty;
        preSettledAmount += this.costAmountPosted(_inventTrans);
        updateCount++;

        if (updateCount > CommitCountMax && preSettledQty == 0.0 && preSettledAmount == 0.0)
        {
            _rilInventClosingNonFinancialInventTrans.insertDatabase();
            _rilInventClosingNonFinancialInventTrans = new RecordInsertList(tableNum(InventClosingNonFinancialInventTrans));
            ttsCommit;
            ttsBegin;
            updateCount=0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>prodIdWIPCalc_RU</Name>
				<Source><![CDATA[
    protected ProdId prodIdWIPCalc_RU(InventTransId _inventTransId)
    {
        ProdTable   prodTable;
        InventDim   inventDim;

        if (mapProdIdWIPCalc_RU.exists(_inventTransId))
        {
            return mapProdIdWIPCalc_RU.lookup(_inventTransId);
        }

        select firstonly ProdId, InventDimId from prodTable
            where prodTable.InventTransId == _inventTransId &&
                  prodTable.ProjId        == ''
        join InventSiteId from inventDim
            where inventDim.InventDimId   == prodTable.InventDimId;

        ProdId prodId = prodTable.ProdId;
        if (prodId)
        {
            if (!mapcalculatingWIPBySite_RU.exists(inventDim.InventSiteId))
            {
                mapcalculatingWIPBySite_RU.insert(inventDim.InventSiteId, prodTable.prodParametersDim().CalculatingWIP_RU);
            }

            if (mapcalculatingWIPBySite_RU.lookup(inventDim.InventSiteId) == NoYes::No)
            {
                prodId = '';
            }
        }

        mapProdIdWIPCalc_RU.insert(_inventTransId, prodId);
        return prodId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Processes a single item during the inventory closing process.
    /// </summary>
    /// <exception cref="M:Exception::UpdateConflict">
    ///    An update conflict occurred.
    /// </exception>
    /// <exception cref="M:Exception::UpdateConflictNotRecovered">
    ///    An update conflict occurred and continued to occur when it was retried.
    /// </exception>
    public void run()
    {
        #OCCRetryCount
        
        using (AppConsistencyCheckSkipInventTransUpdateSingleton flag = AppConsistencyCheckSkipInventTransUpdateSingleton::instance())
        {
            flag.parmSkip(true);

            try
            {
                if (inventCostList.RecId && inventCostList.ItemId)
                {
                    inventCostHelpTaskBase.progressCalculation(inventCostList);
                    setPrefix(#PrefixField(inventCostList,itemId));

                    inventCostListParm = InventCostListParm::find(inventClosing.RecId, inventCostList.ItemId);
                    Integer selfLoopMax = (inventCostList.NumOfIteration == 0) ? inventClosing.MaxIterations : 0;

                    do
                    {
                        selfUpdate = false;

                        ttsbegin;
                        if (InventClosing.AdjustmentType == InventAdjustmentType::PreClose)
                        {
                            this.preCloseItem();
                        }
                        else
                        {
                            this.updateItem();
                        }
                        ttscommit;
                        selfLoopCount++;
                    }
                    while (selfUpdate && selfLoopCount <= selfLoopMax);
                }
                else
                {
                    throw error("@SYS4001032");
                }
            }
            catch (Exception::Deadlock)
            {
                retry;
            }
            catch (Exception::UpdateConflict)
            {
                if (appl.ttsLevel() == 0)
                {
                    if (xSession::currentRetryCount() >= #RetryNum)
                    {
                        throw Exception::UpdateConflictNotRecovered;
                    }
                    else
                    {
                        retry;
                    }
                }
                else
                {
                    throw Exception::UpdateConflict;
                }
            }
            catch (Exception::TransientSqlConnectionError)
            {
                if (ReqTransientSqlConnectionErrorHandlingHelper::retryTransientSqlConnectionError())
                {
                    retry;
                }
                else
                {
                    throw Exception::TransientSqlConnectionError;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectInventClosing</Name>
				<Source><![CDATA[
    protected void selectInventClosing(InventClosing _inventClosing)
    {
        select forupdate _inventClosing
            where _inventClosing.TransDate       == inventClosing.TransDate  &&
                  _inventClosing.Voucher         == inventClosing.Voucher;

        if (! _inventClosing.RecId || _inventClosing.InventCostStatus == InventCostStatus::Ended)
            throw error(strFmt("@SYS19378",funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>setNonFinancialInventTransToClosed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set the inventory transaction to closed.
    /// </summary>
    /// <param name="_inventTrans">
    /// The inventory transaction to close.
    /// </param>
    protected void setNonFinancialInventTransToClosed(InventTrans _inventTrans)
    {
        _inventTrans.ValueOpen = InventTransOpen::No;
        _inventTrans.DateClosed = inventClosing.TransDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpIssue2Trans</Name>
				<Source><![CDATA[
    protected InventTrans tmpIssue2Trans(TmpInventModel _tmpIssue)
    {
        InventTrans inventTrans;
        if (_tmpIssue.Direction    == InventDirection::Issue   && mapInventTrans.exists(_tmpIssue.TransRecId))
            inventTrans = mapInventTrans.lookup(_tmpIssue.TransRecId);
        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpReceipt2Trans</Name>
				<Source><![CDATA[
    protected InventTrans tmpReceipt2Trans(TmpInventModel _tmpReceipt)
    {
        InventTrans inventTrans;
        if (_tmpReceipt.Direction  == InventDirection::Receipt && mapInventTrans.exists(_tmpReceipt.TransRecId))
            inventTrans = mapInventTrans.lookup(_tmpReceipt.TransRecId);
        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unloadTrans</Name>
				<Source><![CDATA[
    protected void unloadTrans(RecId _recId)
    {
        mapInventTrans.remove(_recId);

        delete_from tmpInventModel
        where tmpInventModel.TransRecId == _recId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateClosingCosting</Name>
				<Source><![CDATA[
    protected InventSettlement updateClosingCosting(
        InventTrans         _receipt,
        InventTrans         _issue,
        Qty                 _settleQty,
        InventSettleModel   _inventSettleModel,
        InventSettlement    _reuseSettlement = null,
        PdsCWSettled        _pdsCWSettled   = 0
        )
    {
        InventSettlement    settlementIssue;
        InventSettlement    settlementReceipt;

        CostAmount valueReceipt = max(0, this.financialOpenValue(_receipt));

        if (_settleQty < this.financialOpenQty(_receipt))
            valueReceipt = _settleQty * (valueReceipt / this.financialOpenQty(_receipt));

        CostAmount adjustment = 0;

        boolean skipOverAdjustment = this.needSkipOverAdjustment();
       
        if (inventClosing.AdjustmentType == InventAdjustmentType::Recalculation && !skipOverAdjustment)
        {
            // During recalculation, an issue is always adjusted for all its open quantity.
            // For example, if the issue is open for 10 at $0, and the receipt is only 1 at $1, then the issue will have its price adjusted to $10.
            // If this is the only receipt left for this issue, the user will see 10 at $10 ($1 a piece) when the recalculation is finished.
            // If there are more receipts for this issue, the $9 'overadjustment' is automatically adjusted away again.
            // Note that this behavior is not needed for closing, because with a closing the user can see how much has been settled.
            // (An issue of 10 at $1: 1 settled at $1, and the remaining 9 still open.)

            if (_settleQty < -this.financialOpenQty(_issue) && !this.isUpdatedFinancialLater(_issue))
            {
                adjustment = -CurrencyExchangeHelper::amount(valueReceipt / _settleQty * this.financialOpenQty(_issue) - this.financialOpenValue(_issue), standardCurrency);
                if (mapSettleValue.exists(_issue.RecId))
                {
                    mapSettleValue.insert(_issue.RecId, mapSettleValue.lookup(_issue.RecId) - adjustment);
                }
                else
                {
                    mapSettleValue.insert(_issue.RecId, 0 - adjustment);
                }
            }
        }

        CostAmount valueIssue = this.financialOpenValue(_issue);

        if (_settleQty < -this.financialOpenQty(_issue))
        {
            valueIssue  = -_settleQty * (valueIssue  / this.financialOpenQty(_issue));
        }

        valueReceipt    = CurrencyExchangeHelper::amount(valueReceipt, standardCurrency);
        valueIssue      = CurrencyExchangeHelper::amount(valueIssue, standardCurrency);
        adjustment     += valueReceipt + valueIssue;

        if (inventClosing.AdjustmentType == InventAdjustmentType::Recalculation ||
            !_receipt.isUpdatedFinancial()                                      ||
            !_issue.isUpdatedFinancial()                                        ||
            this.isUpdatedFinancialLater(_receipt)                              ||
            this.isUpdatedFinancialLater(_issue))
        {
            if (mapSettleValue.exists(_receipt.RecId))
            {
                mapSettleValue.insert(_receipt.RecId, mapSettleValue.lookup(_receipt.RecId) - valueReceipt);
            }
            else
            {
                mapSettleValue.insert( _receipt.RecId, 0 - valueReceipt);
            }

            if (mapSettleValue.exists(_issue.RecId))
            {
                mapSettleValue.insert( _issue.RecId, mapSettleValue.lookup(_issue.RecId) - valueIssue);
            }
            else
            {
                mapSettleValue.insert(_issue.RecId, 0 - valueIssue);
            }

            if (mapSettleQty.exists(_receipt.RecId))
            {
                mapSettleQty.insert(  _receipt.RecId, mapSettleQty.lookup(_receipt.RecId) - _settleQty);
            }
            else
            {
                mapSettleQty.insert(  _receipt.RecId, 0 - _settleQty);
            }

            if (mapSettleQty.exists(_issue.RecId))
            {
                mapSettleQty.insert(  _issue.RecId, mapSettleQty.lookup(_issue.RecId) + _settleQty);
            }
            else
            {
                mapSettleQty.insert(  _issue.RecId, 0 + _settleQty);
            }

            PdsCWInventQty valueCWSettled = 0;
            if (pdsMapSettleCWQty.exists(_receipt.RecId))
            {
                valueCWSettled = pdsMapSettleCWQty.lookup(_receipt.RecId);
            }
            pdsMapSettleCWQty.insert(_receipt.RecId, valueCWSettled -_pdsCWSettled);

            valueCWSettled = 0;
            if (pdsMapSettleCWQty.exists(_issue.RecId))
            {
                valueCWSettled = pdsMapSettleCWQty.lookup(_issue.RecId);
            }
            pdsMapSettleCWQty.insert(_issue.RecId, valueCWSettled + _pdsCWSettled);

            // Don't adjust an issue if it's updated financially, because it would give
            // an adjustment to a posting on a date where the posting doesn't even exist yet.
            // The adjustments will also hit incorrect accounts in GL.
            if (!this.isUpdatedFinancialLater(_issue))
            {
                if (! mapAdjustment)
                    mapAdjustment = new Map(recIdType, Types::Real);

                if (mapAdjustment.exists(_issue.RecId))
                {
                    mapAdjustment.insert( _issue.RecId, mapAdjustment.lookup(_issue.RecId) - adjustment);
                }
                else
                {
                    mapAdjustment.insert( _issue.RecId, 0 - adjustment);
                }
            }
        }
        else
        {
            if (_reuseSettlement.RecId && _reuseSettlement.SettleType == InventSettleType::Issue)
            {
                settlementIssue = _reuseSettlement;

                settlementIssue.QtySettled           -= _settleQty;
                settlementIssue.PdsCWSettled         -= _pdsCWSettled;
                settlementIssue.CostAmountSettled    -= valueReceipt;
                settlementIssue.CostAmountAdjustment -= adjustment;

                settlementIssue.skipTTSCheck(true);
                settlementIssue.update();
            }
            else
            {
                settlementIssue = this.initInventSettlement(_issue,-_settleQty,-valueReceipt,-adjustment,_inventSettleModel,InventSettleType::Issue,inventClosing.Ledger ? InitLedgerAsPosted : InitLedgerDrop, false, -_pdsCWSettled);
                settlementIssue.insert(_reuseSettlement.SettleTransId);
            }

            this.initClosingSettledTrans(_issue, _receipt, inventTransCurrency, _settleQty, _pdsCWSettled, valueReceipt, adjustment);

            if (_reuseSettlement.RecId && _reuseSettlement.SettleType == InventSettleType::Receipt)
            {
                settlementReceipt = _reuseSettlement;

                settlementReceipt.QtySettled         += _settleQty;
                settlementReceipt.PdsCWSettled       += _pdsCWSettled;
                settlementReceipt.CostAmountSettled  += valueReceipt;

                settlementReceipt.skipTTSCheck(true);

                settlementReceipt.update();
            }
            else
            {
                settlementReceipt = this.initInventSettlement(_receipt,_settleQty,valueReceipt,0,_inventSettleModel,InventSettleType::Receipt,InitLedgerDrop, false, _pdsCWSettled);
                settlementReceipt.insert(settlementIssue.SettleTransId);
            }

            // <GEERU>
            if (!countryRegion_RU)
            {
                // </GEERU>

                _receipt.QtySettled          += _settleQty;
                _receipt.PdsCWSettled        += _pdsCWSettled;
                _receipt.CostAmountSettled   += valueReceipt;
                // <GEERU>
            }
            // </GEERU>

            this.adjustTrans(_issue, -adjustment);
        }

        return (_reuseSettlement.SettleType == InventSettleType::Issue) ? settlementIssue : settlementReceipt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initClosingSettledTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes issue and receipt inventory transactions with settled values.
    /// </summary>
    /// <param name = "_issue">The <c>InventTrans</c> table for ussue transaction.</param>
    /// <param name = "_receipt">The <c>InventTrans</c> table for receipt transaction.</param>
    /// <param name = "_inventTransCurrency">Inventory transaction currency type.</param>
    /// <param name = "_settleQty">Settled quantity.</param>
    /// <param name = "_pdsCWSettled">Covered CV settled quantity.</param>
    /// <param name = "_valueReceipt">Receipt cost value.</param>
    /// <param name = "_adjustment">Adjustment cost value.</param>
    protected void initClosingSettledTrans(InventTrans _issue,
        InventTrans _receipt,
        InventTransCurrency_RU _inventTransCurrency,
        InventQtySettled _settleQty,
        PdsCWSettled _pdsCWSettled,
        CostAmountSettled _valueReceipt,
        CostAmountAdjusted _adjustment)
    {
        if (countryRegion_RU)
        {
            if (_inventTransCurrency == InventTransCurrency_RU::PrimaryCur)
            {
                _issue.QtySettled           -= _settleQty;
                _issue.PdsCWSettled         -= _pdsCWSettled;
                _issue.CostAmountSettled    -= _valueReceipt;
                _issue.CostAmountAdjustment -= _adjustment;

                _receipt.QtySettled         += _settleQty;
                _receipt.CostAmountSettled  += _valueReceipt;
            }
            else if (_inventTransCurrency == InventTransCurrency_RU::SecondaryCur)
            {
                _issue.PdsCWSettled                  -= _pdsCWSettled;
                _issue.QtySettledSecCur_RU           -= _settleQty;
                _issue.CostAmountSettledSecCur_RU    -= _valueReceipt;
                _issue.CostAmountSecCurAdjustment_RU -= _adjustment;

                _receipt.QtySettledSecCur_RU         += _settleQty;
                _receipt.CostAmountSettledSecCur_RU  += _valueReceipt;
            }
        }
        else
        {
            _issue.QtySettled           -= _settleQty;
            _issue.PdsCWSettled         -= _pdsCWSettled;
            _issue.CostAmountSettled    -= _valueReceipt;
            _issue.CostAmountAdjustment -= _adjustment;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCommitCount</Name>
				<Source><![CDATA[
    protected boolean updateCommitCount()
    {
        commitCount++;
        if (commitCount > CommitCountMax)
        {
            commitCount = 0;

            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isItTimeToCommit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if it is time to commit.
    /// </summary>
    /// <param name = "_milliseconds">Time in milliseconds; default 2000 milliseconds.</param>
    /// <returns>true if it is time to commit; otherwise false.</returns>
    /// <remarks>The method returns true when the specified time in milliseconds passed since the last time the method returned true.</remarks>
    internal boolean isItTimeToCommit(int _milliseconds = 2000)
    {
        int tickCount = WinAPIServer::getTickCount();
        if (tickCount - commitTickCount > _milliseconds)
        {
            commitTickCount = tickCount;

            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCostAmountStd</Name>
				<Source><![CDATA[
    protected void updateCostAmountStd(InventTrans _inventTrans)
    {
        //  If we're NOT running under 'old' standard cost (fixed receipt price),
        //  we update the standard cost price fields of all receipts, so that 'old' standard cost can be switched on
        //  at any given time, and so that cancellation also works well

        if (_inventTrans.Qty > 0 && !this.inventModelGroup(_inventTrans.ItemId).StandardCost)
        {
            // <GEERU>
            if (!countryRegion_RU
                || inventTransCurrency == InventTransCurrency_RU::PrimaryCur)
            {
                // </GEERU>
                _inventTrans.CostAmountStd = _inventTrans.costValue();
                // <GEERU>
            }
            else
            {
                _inventTrans.CostAmountStdSecCur_RU = _inventTrans.costValueSecCur_RU();
            }
            // </GEERU>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateIndirectCosts</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Triggers the calculation of the indirect cost for ended production orders.
    /// </summary>
    /// <remarks>
    ///    All the settlements that have to be done for an ended production order will be passed to the
    ///    <c>InventCostProdAdjust</c> class. As a result, a map with the additional adjustments (indirect
    ///    cost), which must be added to the closing process will be returned.
    /// </remarks>
    protected void updateIndirectCosts()
    {
        InventCostListTrans             inventCostListTrans;
        InventTrans                     inventTrans;
        InventTransOrigin               inventTransOrigin;

        InventTransAdjustDataMap        inventTransAdjustDataMap = InventTransAdjustDataMap::construct();

        MapEnumerator                   mapEnumerator;

        Map mapTransIdReceiptAdjustment = new Map(Types::String,Types::Real);

        void addToMapTransIdReceiptAdjustment(InventCostListTrans _inventCostListTrans)
        {
            str key = InventCostItemDim::keyAdjust2String(_inventCostListTrans.InventTransOrigin, _inventCostListTrans.ReturnInventTransOrigin, _inventCostListTrans.VoucherPhysical);
            if (mapTransIdReceiptAdjustment.exists(key))
            {
                CostAmount adjustment = mapTransIdReceiptAdjustment.lookup(key);
                mapTransIdReceiptAdjustment.insert(key, adjustment + _inventCostListTrans.Adjustment);
            }
            else
            {
                mapTransIdReceiptAdjustment.insert(key, _inventCostListTrans.Adjustment);
            }
        }

        void processIndirectCostAdjustments()
        {
            Map mapIndirectCostAdjustment = InventCostProdAdjust::adjustFromInventClosing(inventTransAdjustDataMap, inventClosing);

            if (mapIndirectCostAdjustment && mapIndirectCostAdjustment.elements() != 0)
            {

                mapEnumerator = mapIndirectCostAdjustment.getEnumerator();
                while (mapEnumerator.moveNext())
                {
                    inventCostListTrans.ItemId                  = inventCostList.ItemId;
                    inventCostListTrans.InventTransOrigin       = InventTransOrigin::findByInventTransId(mapEnumerator.currentKey()).RecId;
                    inventCostListTrans.ItemIdChild             = '';
                    inventCostListTrans.ReturnInventTransOrigin = 0;
                    inventCostListTrans.VoucherPhysical         = '';
                    inventCostListTrans.Adjustment              = -1 * mapEnumerator.currentValue();
                    inventCostListTrans.NumOfIteration          = inventClosing.NumOfIteration;
                    inventCostListTrans.Voucher                 = inventClosing.Voucher;

                    addToMapTransIdReceiptAdjustment(inventCostListTrans);
                }
            }
            inventTransAdjustDataMap = InventTransAdjustDataMap::construct();
        }

        void processReceiptAdjustments()
        {
            MapEnumerator me = new MapEnumerator(mapTransIdReceiptAdjustment);
            while (me.moveNext())
            {
                InventTransOriginId inventTransOriginId, returnInventTransOriginId;
                Voucher voucherPhysical;
                [inventTransOriginId, returnInventTransOriginId, voucherPhysical] = InventCostItemDim::string2keyAdjust(me.currentKey());

                this.updateTransIdReceipt(inventTransOriginId,
                                              me.currentValue(),
                                              returnInventTransOriginId,
                                              voucherPhysical);
            }
            mapTransIdReceiptAdjustment = new Map(Types::String,Types::Real);
        }

        List inventCostListTransList = new List(Types::Record);

        this.isItTimeToCommit();

        while select ReferenceId, InventTransId from inventTransOrigin
                group by ReferenceId, InventTransId
                order by ReferenceId, InventTransId
            where (inventTransOrigin.ReferenceCategory   == InventTransType::Production
                || inventTransOrigin.ReferenceCategory   == InventTransType::PmfProdCoBy)
            join InventTransOrigin, ItemIdChild, ReturnInventTransOrigin, VoucherPhysical, sum(Adjustment) from inventCostListTrans
                group by InventTransOrigin, ItemIdChild, ReturnInventTransOrigin, VoucherPhysical
                order by InventTransOrigin
            where inventCostListTrans.ItemId            == inventCostList.ItemId
               && inventCostListTrans.Voucher           == inventCostList.Voucher
               && inventCostListTrans.NumOfIteration    == inventCostList.NumOfIteration
               && inventCostListTrans.InventTransOrigin == inventTransOrigin.RecId
            exists join inventTrans
            where inventTrans.InventTransOrigin == inventCostListTrans.InventTransOrigin
               && inventTrans.StatusReceipt     <= StatusReceipt::Purchased
               && inventTrans.StatusIssue       <= StatusIssue::Sold
        {
            inventCostListTransList.addEnd(inventCostListTrans);
            mapInventTransId.insert(inventCostListTrans.InventTransOrigin, inventTransOrigin.InventTransId);
        }

        if (inventCostListTransList.elements())
        {
            InventTransRefId previousReferenceId;
            ListEnumerator enumerator = inventCostListTransList.getEnumerator();
            while (enumerator.moveNext())
            {
                inventCostListTrans = enumerator.current();
                // No need to pass an inventItemPrice or a inventItemCostGroupRollupList, because this is NOT a standard cost item
                inventTransAdjustDataMap.add(this.inventTransId(inventCostListTrans.InventTransOrigin),
                                                 inventCostListTrans.ItemIdChild,
                                                 inventCostListTrans.Adjustment);

                addToMapTransIdReceiptAdjustment(inventCostListTrans);

                InventCostListTrans deleteInventCostListTrans;

                delete_from deleteInventCostListTrans
                    where deleteInventCostListTrans.Voucher           == inventClosing.Voucher
                      &&  deleteInventCostListTrans.NumOfIteration    == inventCostList.NumOfIteration
                      &&  deleteInventCostListTrans.ItemId            == inventCostList.ItemId
                      &&  deleteInventCostListTrans.InventTransOrigin == inventCostListTrans.InventTransOrigin;

                if (previousReferenceId !=  inventTransOrigin.ReferenceId)
                {
                    if (previousReferenceId)
                    {
                        processIndirectCostAdjustments();
                        processReceiptAdjustments();

                        if (this.isItTimeToCommit())
                        {
                            this.updateTransKeyAdjust();
                            ttscommit;
                            ttsbegin;
                        }
                    }
                    previousReferenceId = inventTransOrigin.ReferenceId;
                }
            }

            processIndirectCostAdjustments();
            processReceiptAdjustments();
            this.updateTransKeyAdjust();
            ttscommit;
            ttsbegin;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventCostListParm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the calculation parameter list based on updated inventory transactions.
    /// </summary>
    /// <param name="_inventTrans">
    /// The inventory transaction that has been adjusted.
    /// </param>
    protected void updateInventCostListParm(InventTrans _inventTrans)
    {
        InventCostListParm  inventCostListParmLocal;

        if (inventCostListParm.ItemId == _inventTrans.ItemId)
        {
            if (inventCostListParm.updateParm(_inventTrans))
            {
                inventCostListParmLocal = InventCostListParm::find(inventClosing.RecId, _inventTrans.ItemId, true);
                inventCostListParmLocal.initFromInventCostListParm(inventCostListParm);
                inventCostListParmLocal.update();
            }
        }
        else
        {
            UserConnection connection = new UserConnection();
            try
            {
                connection.ttsbegin();
                inventCostListParmLocal.setConnection(connection);
                inventCostListParmLocal = InventCostListParm::find(inventClosing.RecId, _inventTrans.ItemId, true);
                if (!inventCostListParmLocal)
                {
                    inventCostListParmLocal.initFromInventClosing(inventClosing);
                    inventCostListParmLocal.initFromInventTrans(_inventTrans);
                    inventCostListParmLocal.insert();
                }
                else
                {
                    if (inventCostListParmLocal.updateParm(_inventTrans))
                    {
                        inventCostListParmLocal.update();
                    }
                }
                connection.ttscommit();
            }
            finally
            {
                if (connection != null)
                {
                    connection.finalize();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventTrans</Name>
				<Source><![CDATA[
    protected void updateInventTrans(InventTrans _inventTrans)
    {
        if (_inventTrans.RecId)
        {
            _inventTrans.skipTTSCheck(true);
            this.updateCostAmountStd(_inventTrans);
            _inventTrans.update();

            if (_inventTrans.ValueOpen == InventTransOpen::No && _inventTrans.Voucher != inventClosing.Voucher)
            {
                closedInventTransCount++;
            }
        }

        this.updateInventTransMap(_inventTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventTransMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the collection of inventory transaction records.
    /// </summary>
    /// <param name="_inventTrans">
    /// The <c>InventTrans</c> record for which the collection must be updated.
    /// </param>
    private void updateInventTransMap(InventTrans _inventTrans)
    {
        if (mapInventTrans)
        {
            mapInventTrans.insert(_inventTrans.RecId, _inventTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Computes one iteration of the inventory closing process for an item.
    /// </summary>
    /// <remarks>
    ///    Multiple iterations may be required.
    /// </remarks>
    protected void updateItem()
    {
        // specifically resetting all global variables except those that should be preserved across multiple invocations of updateItem

        mapKeyAdjust        = null;
        setSameItem         = new Set(Types::Int64);
        mapOpenIssue        = new Map(Types::Int64, Types::Record);
        commitCount         = 0;
        considerBatchAndSerialForTransferOrder = InventTransferOrderRecordInventDimForCostFlight::instance().isEnabled();

        this.initMaps();

        // if this is the first time this item is processed, apply the adjustments necessary because of item returns
        if (inventCostList.NumOfIteration == 0 && selfLoopCount == 0 && inventCostListParm.HasReturn == NoYes::Yes)
        {
            this.startTimer();
            this.updateItemReturnAdjustments();
            updateReturnAdjustmentsTime+=this.getTimer();
            updateReturnAdjustmentsCount++;
        }

        // read and apply delayed adjustments, from for example production orders (adjustment in raw material gives change in finished good) or transfers
        this.updateLevelAdjustment();

        InventTable inventTable = this.inventTable(inventCostList.ItemId);
        // don't do any further processing on new-standard-cost items
        // don't do any further processing on standard-cost and moving average items
        // <GEERU>
        if ((countryRegion_RU
            && this.inventModelType_RU(inventCostList.ItemId).mustBeClosed() == false)
            || (!countryRegion_RU
            && (inventTable.modelGroup().inventModelType().mustBeClosed() == false)))
        // </GEERU>
        {
            return;
        }

        boolean isServiceItem = inventTable.inventItemType().isServiceItem();
        isCatchWeightItem = inventTable.pdsCWItem();
        isWHSItem = inventTable.whsItemIsWHSControlled();

        if (!(inventCostList.NumOfIteration == 0 && selfLoopCount == 0) && inventClosing.AdjustmentType == InventAdjustmentType::Closing)
        {
            // if this is a closing and this item has been processed before, just propagate adjustments following settlements
            this.updateReceiptAdjustment();
        }
        else
        {
            // if this is not a closing, or if this is the first time, then match (settle for closing, adjust for recalculation) issues and receipts
            this.matchIssuesAndReceipts(isServiceItem, inventTable);
        }

        // close service items if this is a closing
        if (inventClosing.AdjustmentType == InventAdjustmentType::Closing && isServiceItem)
        {
            this.updateServiceItemTrans(inventCostList.ItemId);
        }

        // write delayed open issue warnings to the infolog
        this.openIssueToInfoLog();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateItemReturnAdjustmentInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adjusts the cost of item return receipts.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The inventory transaction to perform the adjustment.
    /// </param>
    protected void updateItemReturnAdjustmentInventTrans(InventTrans _inventTrans)
    {
        InventTrans         issue;

        select sum(Qty), sum(CostAmountAdjustment), sum(CostAmountPosted) from issue
            where issue.InventTransOrigin        == _inventTrans.ReturnInventTransOrigin
                && issue.StatusReceipt           == StatusReceipt::None
                && issue.StatusIssue             == StatusIssue::Sold
                && issue.PackingSlipReturned     == 0
                && issue.ReturnInventTransOrigin == _inventTrans.InventTransOrigin;

        if (issue.Qty)
        {
            Price costPrice = (issue.CostAmountPosted + issue.CostAmountAdjustment) / issue.Qty;
            CostAmount adjustment = CurrencyExchangeHelper::amount(_inventTrans.Qty * costPrice - _inventTrans.CostAmountPosted - _inventTrans.CostAmountAdjustment, standardCurrency);

            if (abs(adjustment) >= inventClosing.MinTransferValue && !InventAdj::isOnhandAdjusted(_inventTrans.InventTransOrigin, _inventTrans.ReturnInventTransOrigin, ''))
            {
                this.updateTransIdReturnReceipt(_inventTrans.InventTransOrigin, _inventTrans.ReturnInventTransOrigin, costPrice);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateItemReturnAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adjusts the cost of item return receipts to that of the corresponding issues.
    /// </summary>
    /// <param name="_itemId">
    ///    The item ID for which to adjust the return receipts; optional.
    /// </param>
    protected void updateItemReturnAdjustments(ItemId _itemId = inventCostList.ItemId)
    {
        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;
        // <GEERU>
        InventDim           inventDim;
        InventLocation      inventLocation;
        // </GEERU>

        while select sum(Qty), sum(CostAmountAdjustment), sum(CostAmountPosted) from inventTrans
            group by   InventTransOrigin, ReturnInventTransOrigin
            where inventTrans.ItemId                        == _itemId
                && inventTrans.ValueOpen                     == InventTransOpen::Yes
                && inventTrans.StatusReceipt                 == StatusReceipt::Purchased
                && inventTrans.StatusIssue                   == StatusIssue::None
                && inventTrans.DateStatus                    <= inventClosing.TransDate
                && inventTrans.PackingSlipReturned           == 0
                && inventTrans.ReturnInventTransOrigin       != 0
            exists join inventTransOrigin
            where inventTransOrigin.RecId                   == inventTrans.InventTransOrigin
                && (  inventTransOrigin.ReferenceCategory    == InventTransType::Sales
                    || inventTransOrigin.ReferenceCategory    == InventTransType::Statement
                    || inventTransOrigin.ReferenceCategory    == InventTransType::BOMLine
                    || inventTransOrigin.ReferenceCategory    == InventTransType::InventLossProfit
                    || inventTransOrigin.ReferenceCategory    == InventTransType::InventTransaction
                    || inventTransOrigin.ReferenceCategory    == InventTransType::Project
                    || inventTransOrigin.ReferenceCategory    == InventTransType::ProdLine
                    // <GEERU>
                    || inventTransOrigin.ReferenceCategory    == InventTransType::ProdRelease_RU
                    // </GEERU>
                    )
        {
            this.updateItemReturnAdjustmentInventTrans(inventTrans);
        }

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            while select sum(Qty), sum(CostAmountAdjustment), sum(CostAmountPosted) from inventTrans
                group by   InventTransOrigin, ReturnInventTransOrigin
                where inventTrans.ItemId                        == _itemId
                   && inventTrans.ValueOpen                     == InventTransOpen::Yes
                   && inventTrans.StatusReceipt                 == StatusReceipt::Purchased
                   && inventTrans.StatusIssue                   == StatusIssue::None
                   && inventTrans.DateStatus                    <= inventClosing.TransDate
                   && inventTrans.PackingSlipReturned           == 0
                   && inventTrans.ReturnInventTransOrigin       != 0
                exists join inventTransOrigin
                where inventTransOrigin.RecId                   == inventTrans.InventTransOrigin
                   && (  inventTransOrigin.ReferenceCategory    == InventTransType::TransferOrderScrap
                      || inventTransOrigin.ReferenceCategory    == InventTransType::TransferOrderShip
                      || inventTransOrigin.ReferenceCategory    == InventTransType::TransferOrderReceive
                      )
                 exists join inventDim
                    where inventDim.InventDimId                 == inventTrans.InventDimId
                 exists join inventLocation
                    where inventLocation.InventLocationId       == inventDim.InventLocationId
                       && (inventTransOrigin.ReferenceCategory  == InventTransType::TransferOrderScrap
                       || (inventTransOrigin.ReferenceCategory  == InventTransType::TransferOrderShip
                       &&  inventLocation.InventLocationType    == InventLocationType::Standard)
                       || (inventTransOrigin.ReferenceCategory  == InventTransType::TransferOrderReceive
                       &&  inventLocation.InventLocationType    == InventLocationType::Transit))
            {
                this.updateItemReturnAdjustmentInventTrans(inventTrans);
            }
        }
        // </GEERU>
        this.updateTransKeyAdjust();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLevelAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reads delayed adjustments from the database, applies them, and deletes them from the database.
    /// </summary>
    /// <remarks>
    /// Before adjustments are passed, update the indirect cost.
    /// </remarks>
    protected void updateLevelAdjustment()
    {
        InventCostListTrans     inventCostListTrans;

        this.startTimer();
        select firstonly ItemId from inventCostListTrans
            where inventCostListTrans.Voucher           == inventClosing.Voucher
              &&  inventCostListTrans.ItemId            == inventCostList.ItemId;

        if (! inventCostListTrans.ItemId)
        {
            updateLevelAdjustmentTime+=this.getTimer();
            updateLevelAdjustmentCount++;
            return;
        }

        if (inventCostList.NumOfIteration <= inventClosing.MaxIterations)
        {
            // For iteration zero include cost from raw materials. For the next iterations only include cost from the item we are processing.
            // Including other items results in non deterministic behavior when the items are processed in parallel.
            InventTable inventTable;
            
            inventCostListTrans.skipDataMethods(true);
            update_recordset inventCostListTrans
                setting NumOfIteration = inventCostList.NumOfIteration
                where inventCostListTrans.Voucher           == inventClosing.Voucher
                  &&  inventCostListTrans.NumOfIteration    == inventCostList.NumOfIteration + 1
                  &&  inventCostListTrans.ItemId            == inventCostList.ItemId
                exists join InventTable
                    where inventTable.ItemId      == inventCostListTrans.ItemIdChild
                        && ((inventTable.bomLevel > inventCostList.BOMLevel && inventCostList.NumOfIteration == 0) || inventTable.ItemId == inventCostList.ItemId);

            if (inventClosing.ProdJournal == NoYes::Yes)
            {
                inventTable = this.inventTable(inventCostList.ItemId);
                if (inventTable.inventItemType().canHaveBOM() || (#PmfEnabled && inventTable.isCoProduct()))
                {
                    this.updateIndirectCosts();  // Ended production orders are not recalculated when posting to ledger.
                }
            }

            if (considerBatchAndSerialForTransferOrder)
            {
                while select sum(Adjustment) from inventCostListTrans
                group by InventTransOrigin, ReturnInventTransOrigin, VoucherPhysical, InventBatchId, InventSerialId
                where inventCostListTrans.Voucher           == inventClosing.Voucher
                  &&  inventCostListTrans.NumOfIteration    == inventCostList.NumOfIteration
                  &&  inventCostListTrans.ItemId            == inventCostList.ItemId
                {
                    // <GEERU>
                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) &&
                    calculationProdWIP_RU                 &&
                    inventCostListTrans.InventTransOrigin &&
                    this.calcWIPProdHistoricalCost_RU(InventTransOrigin::find(inventCostListTrans.InventTransOrigin).InventTransId,
                                                      inventCostListTrans.VoucherPhysical))
                    {
                        continue;
                    }
                    // </GEERU>

                    using (InventClosingRecordInventDimForTransferOrderContext context = new InventClosingRecordInventDimForTransferOrderContext())
                    {
                        context.inventSerialId = inventCostListTrans.InventSerialId;
                        context.inventBatchId = inventCostListTrans.InventBatchId;
                        this.updateTransIdReceipt(inventCostListTrans.InventTransOrigin,
                                              inventCostListTrans.Adjustment,
                                              inventCostListTrans.ReturnInventTransOrigin,
                                              inventCostListTrans.VoucherPhysical);
                    }
                }
            }
            else
            {
                while select sum(Adjustment) from inventCostListTrans
                group by InventTransOrigin, ReturnInventTransOrigin, VoucherPhysical
                where inventCostListTrans.Voucher           == inventClosing.Voucher
                  &&  inventCostListTrans.NumOfIteration    == inventCostList.NumOfIteration
                  &&  inventCostListTrans.ItemId            == inventCostList.ItemId
                {
                    // <GEERU>
                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) &&
                    calculationProdWIP_RU                 &&
                    inventCostListTrans.InventTransOrigin &&
                    this.calcWIPProdHistoricalCost_RU(InventTransOrigin::find(inventCostListTrans.InventTransOrigin).InventTransId,
                                                      inventCostListTrans.VoucherPhysical))
                    {
                        continue;
                    }
                    // </GEERU>
                    this.updateTransIdReceipt(inventCostListTrans.InventTransOrigin,
                                              inventCostListTrans.Adjustment,
                                              inventCostListTrans.ReturnInventTransOrigin,
                                              inventCostListTrans.VoucherPhysical);
                }
            }
        }

        delete_from inventCostListTrans
            where inventCostListTrans.Voucher           == inventClosing.Voucher
              &&  inventCostListTrans.NumOfIteration    == inventCostList.NumOfIteration
              &&  inventCostListTrans.ItemId            == inventCostList.ItemId;

        this.updateTransKeyAdjust();
        updateLevelAdjustmentTime+=this.getTimer();
        updateLevelAdjustmentCount++;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMapOpenIssue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds an issue to <c>mapOpenIssue</c> because it could not be closed.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The issue transaction that could not be closed.
    /// </param>
    /// <remarks>
    ///    Messages about these will later be written to the Infolog.
    /// </remarks>
    protected void updateMapOpenIssue(InventTrans _inventTrans)
    {
        if (inventClosing.AdjustmentType    == InventAdjustmentType::Closing    &&
            inventClosing.NumOfIteration    == 0                                &&
            selfLoopCount                   == 0                                &&
            _inventTrans.StatusIssue        == StatusIssue::Sold                &&
            _inventTrans.StatusReceipt      == StatusReceipt::None              &&
            _inventTrans.ValueOpen          == InventTransOpen::Yes             &&
            _inventTrans.DateFinancial      <= inventClosing.TransDate)
        {
            mapOpenIssue.insert(_inventTrans.InventTransOrigin, _inventTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMarking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Closes the marked transactions before main logic (FIFO, LIFO, Average, etc.) is invoked.
    /// </summary>
    /// <param name="_itemId">
    /// The item on which to close the marked transactions.
    /// </param>
    /// <remarks>
    /// Illegal marking will be cleared, and those transactions will then go into the main logic afterward.
    /// </remarks>
    protected void updateMarking(ItemId _itemId)
    {
        Map mapReceipt = new Map(Types::String, Types::Class);
        Map mapIssue   = new Map(Types::String, Types::Class);

        Qty qty;
        Set setSkip = new Set(Types::String);

        StatusReceipt statusReceipt = StatusReceipt::Purchased;
        StatusIssue   statusIssue   = StatusIssue::Sold;
        boolean physicalDateCriteria = false;

        List financialInventFields = this.inventDimGroupSetup(this.inventTable(_itemId)).activeFinancialInventoryFields();

        str mapKey(InventTrans _inventTrans, InventDim _inventDim)
        {
            return _inventDim.mapKey(financialInventFields) + '#' + InventCostItemDim::settleRefMapKey(_inventTrans, _inventTrans.Qty < 0.0);
        }

        boolean skipInventTrans(InventTrans _inventTrans)
        {
            boolean _useInventTrans = _inventTrans.StatusReceipt >= StatusReceipt::None && _inventTrans.StatusReceipt <= statusReceipt &&
                                      _inventTrans.StatusIssue   >= StatusIssue::None   && _inventTrans.StatusIssue   <= statusIssue   &&
                                      (physicalDateCriteria ? _inventTrans.DatePhysical : _inventTrans.DateFinancial) <= inventClosing.TransDate;

            return !_useInventTrans;
        }

        void mapInsert(Map _map, InventTrans _inventTrans, InventDim _inventDim)
        {
            str _key = mapKey(_inventTrans, _inventDim);

            if (!_map.exists(_key))
            {
                mapReceipt.insert(_key, new Map(Types::Int64, Types::Record));
                mapIssue  .insert(_key, new Map(Types::Int64, Types::Record));
            }

            _map.lookup(_key).insert(_inventTrans.RecId, _inventTrans);

            if (skipInventTrans(_inventTrans))
            {
                setSkip.add(_key);
            }
        }

        void splitIfPartiallySettled(InventTrans _inventTrans)
        {
            InventTrans _inventTransSplit;

            if (this.financialOpenQty(_inventTrans) != _inventTrans.Qty)
            {
                qty = _inventTrans.Qty;
                _inventTransSplit = _inventTrans.updateSplit(this.financialOpenQty(_inventTrans));
                
                if (mapAdjustment && mapAdjustment.exists(_inventTransSplit.RecId))
                {
                    mapAdjustment.insert(_inventTransSplit.RecId,
                         CurrencyExchangeHelper::amount(mapAdjustment.lookup(_inventTransSplit.RecId) * _inventTransSplit.Qty / qty));
                }

                this.updateMapOpenIssue(_inventTransSplit);
                this.updateInventTransMap(_inventTransSplit);
            }
        }

        void clearMarking(InventTrans _inventTrans)
        {
            if (isWHSItem)
            {
                // Allow the illegal marking before WHS process synchronizes marking dimensions below location.
                if (_inventTrans.StatusReceipt == StatusReceipt::None
                    && _inventTrans.StatusIssue > StatusIssue::Picked)
                {
                    return;
                }

                if (_inventTrans.StatusIssue == StatusIssue::None)
                {
                    InventTrans markingIssueTrans;
                    select firstonly RecId from markingIssueTrans
                        where markingIssueTrans.InventTransOrigin == _inventTrans.MarkingRefInventTransOrigin
                           && markingIssueTrans.StatusIssue        > StatusIssue::Picked;

                    if (markingIssueTrans.RecId)
                    {
                        return;
                    }
                } 
            }

            _inventTrans.clearMarking();
            _inventTrans.skipTTSCheck(true);
            _inventTrans.doUpdate();
        }

        void clearIterator(MapIterator _mi)
        {
            while (_mi.more())
            {
                clearMarking(_mi.value());

                _mi.next();
            }
        }

        this.startTimer();

        if (this.considerPhysicalTransactions(this.inventModelGroup(_itemId)))
        {
            statusReceipt           = StatusReceipt::Received;
            statusIssue             = StatusIssue::Deducted;
            physicalDateCriteria    = true;
        }

        // Load
        InventTrans inventTrans;
        InventDim   inventDim;

        if (InventCostItemUpdateMarkingByFinancialDimFlight::instance().isEnabled())
        {
            if (! inventDimEnumeratorForMarking)
            {
                inventDimEnumeratorForMarking = this.getFinDimCombinationEnumerator(this.inventTable(_itemId));
            }
            else
            {
                inventDimEnumeratorForMarking.reset();
            }

            InventDimParm inventDimParm = this.inventDimParmFinancial(this.inventDimGroupSetup(this.inventTable(_itemId)));

            while (inventDimEnumeratorForMarking.moveNext())
            {
                mapReceipt = new Map(Types::String, Types::Class);
                mapIssue = new Map(Types::String, Types::Class);
                setSkip = new Set(Types::String);

                InventDim inventDimCriteria = inventDimEnumeratorForMarking.current();
                inventDim = null;

                while select forupdate inventTrans
                // <GEERU>
                where (countryRegion_RU
                   && ((inventTransCurrency                     == InventTransCurrency_RU::PrimaryCur
                   &&   inventTrans.ValueOpen                   == InventTransOpen::Yes)
                   ||  (inventTransCurrency                     == InventTransCurrency_RU::SecondaryCur
                   &&   inventTrans.ValueOpenSecCur_RU          == InventTransOpen::Yes))
                   || (!countryRegion_RU
                   && (inventTrans.ValueOpen                    == InventTransOpen::Yes)))
                // </GEERU>
                && inventTrans.ItemId                        == _itemId
                   && inventTrans.MarkingRefInventTransOrigin
                #InventDimInnerJoin(inventTrans.InventDimId, inventDim, inventDimCriteria, inventDimParm)
                {
                    InventTrans currentInventTrans = inventTrans;

                    if (!skipInventTrans(currentInventTrans))
                    {
                        if (mapInventTrans.exists(currentInventTrans.RecId))
                        {
                            currentInventTrans = mapInventTrans.lookup(currentInventTrans.RecId);
                        }

                        CostAmount adjustmentLater = this.calcLaterAdjustment(currentInventTrans);

                        if (adjustmentLater)
                        {
                            mapSettleValue.insert(currentInventTrans.RecId, -adjustmentLater);
                        }

                        if (currentInventTrans.Qty > 0)
                        {
                            this.updateReceiptAdjustmentTrans(currentInventTrans, adjustmentLater);
                        }
                        else if (currentInventTrans.Qty < 0)
                        {
                            if (   currentInventTrans.isUpdatedFinancial()
                            && abs(this.financialOpenQty(currentInventTrans)) < InventAdj::settleQtyDiff()
                            && this.financialOpenValue(currentInventTrans)
                            && !adjustmentLater)
                            {
                                this.createErrorAdjustment(currentInventTrans, -this.financialOpenValue(currentInventTrans));
                                this.updateMapOpenIssue(currentInventTrans);
                                continue;
                            }
                        }
                    }

                    if (abs(this.financialOpenQty(currentInventTrans)) < InventAdj::settleQtyDiff())
                    {
                        this.updateMapOpenIssue(currentInventTrans);
                        continue;
                    }

                    if (currentInventTrans.Qty > 0.0)
                    {
                        mapInsert(mapReceipt, currentInventTrans, inventDim);
                    }
                    else if (currentInventTrans.Qty < 0.0)
                    {
                        mapInsert(mapIssue, currentInventTrans, inventDim);
                    }
                }

                // Loop over equivalence classes (combination of financial inventory dimensions, InventTransOrigin, and MarkingRefInventTransOrigin)
                MapEnumerator keyEnumerator = mapIssue.getEnumerator();

                while (keyEnumerator.moveNext())
                {
                    str key = keyEnumerator.currentKey();

                    Map markingReceipts = mapReceipt.lookup(key);
                    Map markingIssues   = mapIssue.lookup(key);

                    MapIterator receiptIterator = new MapIterator(markingReceipts);
                    MapIterator issueIterator = new MapIterator(markingIssues);

                    InventTrans receipt = null;
                    InventTrans issue = null;

                    // Settle legal markings
                    while (receiptIterator.more() && issueIterator.more())
                    {
                        if (receipt == null)
                        {
                            receipt = receiptIterator.value();
                        }
                        if (issue   == null)
                        {
                            issue   = issueIterator.value();
                        }

                        // retrieve the lastest issue record from database as mapIssue may be out of date in certain scenario
                        if (mapInventTrans.exists(issue.RecId))
                        {
                            issue = mapInventTrans.lookup(issue.RecId);
                        }

                        if (mapInventTrans.exists(receipt.RecId))
                        {
                            receipt = mapInventTrans.lookup(receipt.RecId);
                        }

                        if (skipInventTrans(receipt))
                        {
                            receipt = null;
                            receiptIterator.next();
                            continue;
                        }
                        if (skipInventTrans(issue))
                        {
                            issue = null;
                            issueIterator.next();
                            continue;
                        }

                        qty = min(this.financialOpenQty(receipt), -this.financialOpenQty(issue));

                        this.updateClosingCosting(receipt, issue, qty, InventSettleModel::OpenTrans);

                        this.updateInventTrans(receipt);
                        this.updateInventTrans(issue);

                        if (abs(this.financialOpenQty(receipt)) < InventAdj::settleQtyDiff())
                        {
                            receipt = null;
                            receiptIterator.next();
                        }
                        if (abs(this.financialOpenQty(issue  )) < InventAdj::settleQtyDiff())
                        {
                            issue = null;
                            issueIterator.next();
                        }
                    }

                    boolean nothingToMatch  = markingReceipts.empty() || markingIssues.empty();

                    // Clear illegal markings
                    if (!setSkip.in(key) || nothingToMatch)
                    {
                        if (receipt != null)
                        {
                            splitIfPartiallySettled(receipt);
                            clearMarking(receipt);

                            receipt = null;
                            receiptIterator.next();
                        }

                        if (issue != null)
                        {
                            splitIfPartiallySettled(issue);
                            clearMarking(issue);

                            issue = null;
                            issueIterator.next();
                        }

                        clearIterator(receiptIterator);
                        clearIterator(issueIterator);
                    }
                    else
                    {
                        if (issue != null)
                        {
                            this.updateMapOpenIssue(issue);
                        }
                    }
                }
            }
        }
        else
        {
            while select forupdate inventTrans
                // <GEERU>
                where (countryRegion_RU
                   && ((inventTransCurrency                     == InventTransCurrency_RU::PrimaryCur
                   &&   inventTrans.ValueOpen                   == InventTransOpen::Yes)
                   ||  (inventTransCurrency                     == InventTransCurrency_RU::SecondaryCur
                   &&   inventTrans.ValueOpenSecCur_RU          == InventTransOpen::Yes))
                   || (!countryRegion_RU
                   && (inventTrans.ValueOpen                    == InventTransOpen::Yes)))
                // </GEERU>
                && inventTrans.ItemId                        == _itemId
                   && inventTrans.MarkingRefInventTransOrigin
                join inventDim
                where inventDim.InventDimId == inventTrans.InventDimId
            {
                InventTrans currentInventTrans = inventTrans;

                if (!skipInventTrans(currentInventTrans))
                {
                    if (mapInventTrans.exists(currentInventTrans.RecId))
                    {
                        currentInventTrans = mapInventTrans.lookup(currentInventTrans.RecId);
                    }

                    CostAmount adjustmentLater = this.calcLaterAdjustment(currentInventTrans);

                    if (adjustmentLater)
                    {
                        mapSettleValue.insert(currentInventTrans.RecId, -adjustmentLater);
                    }

                    if (currentInventTrans.Qty > 0)
                    {
                        this.updateReceiptAdjustmentTrans(currentInventTrans, adjustmentLater);
                    }
                    else if (currentInventTrans.Qty < 0)
                    {
                        if (   currentInventTrans.isUpdatedFinancial()
                            && abs(this.financialOpenQty(currentInventTrans)) < InventAdj::settleQtyDiff()
                            && this.financialOpenValue(currentInventTrans)
                            && !adjustmentLater)
                        {
                            this.createErrorAdjustment(currentInventTrans, -this.financialOpenValue(currentInventTrans));
                            this.updateMapOpenIssue(currentInventTrans);
                            continue;
                        }
                    }
                }

                if (abs(this.financialOpenQty(currentInventTrans)) < InventAdj::settleQtyDiff())
                {
                    this.updateMapOpenIssue(currentInventTrans);
                    continue;
                }

                if (currentInventTrans.Qty > 0.0)
                {
                    mapInsert(mapReceipt, currentInventTrans, inventDim);
                }
                else if (currentInventTrans.Qty < 0.0)
                {
                    mapInsert(mapIssue, currentInventTrans, inventDim);
                }
            }

            // Loop over equivalence classes (combination of financial inventory dimensions, InventTransOrigin, and MarkingRefInventTransOrigin)
            MapEnumerator keyEnumerator = mapIssue.getEnumerator();

            while (keyEnumerator.moveNext())
            {
                str key = keyEnumerator.currentKey();

                Map markingReceipts = mapReceipt.lookup(key);
                Map markingIssues   = mapIssue.lookup(key);

                MapIterator receiptIterator = new MapIterator(markingReceipts);
                MapIterator issueIterator = new MapIterator(markingIssues);

                InventTrans receipt = null;
                InventTrans issue = null;

                // Settle legal markings
                while (receiptIterator.more() && issueIterator.more())
                {
                    if (receipt == null)
                    {
                        receipt = receiptIterator.value();
                    }
                    if (issue   == null)
                    {
                        issue   = issueIterator.value();
                    }

                    // retrieve the lastest issue record from database as mapIssue may be out of date in certain scenario
                    if (mapInventTrans.exists(issue.RecId))
                    {
                        issue = mapInventTrans.lookup(issue.RecId);
                    }

                    if (mapInventTrans.exists(receipt.RecId))
                    {
                        receipt = mapInventTrans.lookup(receipt.RecId);
                    }

                    if (skipInventTrans(receipt))
                    {
                        receipt = null;
                        receiptIterator.next();
                        continue;
                    }
                    if (skipInventTrans(issue  ))
                    {
                        issue   = null;
                        issueIterator  .next();
                        continue;
                    }

                    qty = min(this.financialOpenQty(receipt), -this.financialOpenQty(issue));

                    this.updateClosingCosting(receipt, issue, qty, InventSettleModel::OpenTrans);

                    this.updateInventTrans(receipt);
                    this.updateInventTrans(issue);

                    if (abs(this.financialOpenQty(receipt)) < InventAdj::settleQtyDiff())
                    {
                        receipt = null;
                        receiptIterator.next();
                    }
                    if (abs(this.financialOpenQty(issue  )) < InventAdj::settleQtyDiff())
                    {
                        issue   = null;
                        issueIterator  .next();
                    }
                }

                boolean nothingToMatch  = markingReceipts.empty() || markingIssues.empty();

                // Clear illegal markings
                if (!setSkip.in(key) || nothingToMatch)
                {
                    if (receipt != null)
                    {
                        splitIfPartiallySettled(receipt);
                        clearMarking(receipt);

                        receipt = null;
                        receiptIterator.next();
                    }

                    if (issue != null)
                    {
                        splitIfPartiallySettled(issue);
                        clearMarking(issue);

                        issue = null;
                        issueIterator.next();
                    }

                    clearIterator(receiptIterator);
                    clearIterator(issueIterator);
                }
                else
                {
                    if (issue != null)
                    {
                        this.updateMapOpenIssue(issue);
                    }
                }
            }
        }

        this.updateModelAdjustment(InventSettleModel::OpenTrans);
        this.updateTransKeyAdjust();

        updateMarkingTime += this.getTimer();
        updateMarkingCount++;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventModel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets inventory model.
    /// </summary>
    /// <returns>The <c>Invent model</c> table.</returns>
    protected InventModel getInventModel()
    {
        InventModel inventModel;
        if (countryRegion_RU)
        {
            if (inventTransCurrency == InventTransCurrency_RU::PrimaryCur)
            {
                inventModel = this.inventModelGroup(inventCostList.ItemId).InventModel;
            }
            else if (inventTransCurrency == InventTransCurrency_RU::SecondaryCur)
            {
                inventModel = this.inventModelGroup(inventCostList.ItemId).InventModelSecCur_RU;
            }
        }
        else
        {
            inventModel = this.inventModelGroup(inventCostList.ItemId).InventModel;
        }

        return inventModel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateModel</Name>
				<Source><![CDATA[
    protected void updateModel(InventDim _inventDim)
    {
        InventModel inventModel;

        this.startTimer();
        this.loadTmpInventModel();

        inventModel = this.getInventModel();

        switch (inventModel)
        {
            case InventModel::FIFO:
                this.updateModelFIFOLIFO(InventSettleModel::FIFO);
                break;

            case InventModel::LIFO:
                this.updateModelFIFOLIFO(InventSettleModel::LIFO);
                break;

            case InventModel::LIFODate:
                this.updateModelLIFODate(InventSettleModel::LIFODate);
                break;

            case InventModel::AverageCost:
                this.updateModelAverage(InventSettleModel::AverageCost, _inventDim);
                break;

            case InventModel::AverageCostDate:
                this.updateModelAverage(InventSettleModel::AverageCostDate, _inventDim);
                break;

            case InventModel::MonthlyAverageCost:
                this.updateModelAverage(InventSettleModel::MonthlyAverageCost, _inventDim);
                break;

            default:
                throw error("@SYS25223");
        }

        this.updateTransKeyAdjust();
        updateModelTime+=this.getTimer();
        updateModelCount++;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateModelAdjustment</Name>
				<Source><![CDATA[
    protected void updateModelAdjustment(
        InventSettleModel   _inventSettleModel
        )
    {
        InventSettlement    settlementIssue;

        if (mapAdjustment && mapInventTrans)
        {
            MapIterator mi = new MapIterator(mapAdjustment);
            mi.begin();
            while (mi.more())
            {
                if (mapInventTrans.exists(mi.key()) && mi.value())
                {
                    InventTrans issue = mapInventTrans.lookup(mi.key());

                    if (issue.isUpdatedPhysical() && ! UpdatePhysicalSettlement)
                        throw error(strFmt("@SYS19378",funcName()));

                    select firstonly forupdate RecId,CostAmountAdjustment,QtySettled,CostAmountSettled from settlementIssue
                        where settlementIssue.TransRecId    == issue.RecId
                           && settlementIssue.SettleType    == InventSettleType::Issue
                           && settlementIssue.TransDate     == inventClosing.TransDate
                           && settlementIssue.Voucher       == inventClosing.Voucher
                           && settlementIssue.Cancelled     == 0
                           && settlementIssue.SettleModel   == _inventSettleModel;

                    if (settlementIssue.RecId)
                    {
                        settlementIssue.CostAmountAdjustment   += mi.value();

                        if (settlementIssue.CostAmountAdjustment || settlementIssue.QtySettled || settlementIssue.CostAmountSettled)
                        {
                            settlementIssue.update();
                        }
                        else
                        {
                            settlementIssue.delete();
                        }
                    }
                    else
                    {
                        settlementIssue = this.initInventSettlement(issue,0,0,mi.value(),_inventSettleModel,InventSettleType::Issue,inventClosing.Ledger ? InitLedgerAsPosted : InitLedgerDrop);
                        settlementIssue.insert('');
                    }

                    if (issue.isUpdatedPhysical())
                    {
                        // <GEERU>
                        if (!countryRegion_RU
                            || inventTransCurrency == InventTransCurrency_RU::PrimaryCur)
                        {
                            // </GEERU>
                            issue.CostAmountPhysical      += mi.value();
                            // <GEERU>
                        }
                        else
                        {
                            issue.CostAmountSecCurPhysical_RU   += mi.value();
                        }
                        // </GEERU>
                    }
                    else
                    {
                        // <GEERU>
                        if (!countryRegion_RU
                            || inventTransCurrency == InventTransCurrency_RU::PrimaryCur)
                        {
                            // </GEERU>
                            issue.CostAmountAdjustment    += mi.value();
                            // <GEERU>
                        }
                        else
                        {
                            issue.CostAmountSecCurAdjustment_RU += mi.value();
                        }
                        // </GEERU>
                    }

                    this.updateInventTrans(issue);

                    if (this.isNotUpdatedFinancialLater(issue))
                    {
                        this.adjustTrans(issue, mi.value());
                    }
                }

                mi.next();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNotUpdatedFinancialLater</Name>
				<Source><![CDATA[
    protected boolean isNotUpdatedFinancialLater(InventTrans _inventTrans)
    {
        return _inventTrans.isUpdatedFinancial() && !this.isUpdatedFinancialLater(_inventTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDistributionReceiptValueOpen</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes open value.
    /// </summary>
    /// <param name = "_distributionReceipt">the inventory tranzaction.</param>
    /// <param name = "_inventTransCurrency">The inventory transaction currency.</param>
    protected void initDistributionReceiptValueOpen(InventTrans _distributionReceipt, InventTransCurrency_RU _inventTransCurrency)
    {
        if (countryRegion_RU)
        {
            if (_inventTransCurrency == InventTransCurrency_RU::PrimaryCur)
            {
                _distributionReceipt.ValueOpen = InventTransOpen::Yes;
            }
            else if (_inventTransCurrency == InventTransCurrency_RU::SecondaryCur)
            {
                _distributionReceipt.ValueOpenSecCur_RU = InventTransOpen::Yes;
            }
        }
        else
        {
            _distributionReceipt.ValueOpen = InventTransOpen::Yes;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateModelAverage</Name>
				<Source><![CDATA[
    protected void updateModelAverage(InventSettleModel _inventSettleModel, InventDim _inventDim)
    {
        TmpInventModel      tmpDates;               // used to find the end-of-period dates in WA-date
        TmpInventModel      tmpreceiptScan;         // used to scan the receipts in advance, to find their number, open quantity, and open value
        TmpInventModel      tmpReceipt;             // used to actually settle receipts
        TmpInventModel      tmpIssue;               // used to actually settle issues

        InventTrans         receipt;
        InventTransType     receiptReferenceCategory;
        InventTrans         issue;

        InventTransOriginId transferOriginId;       // InventTransOriginId  of the current transfer (if a transfer is used for this period)
        InventTrans         transferIssue;          // Issue   record of the current transfer (if a transfer is used for this period)
        InventTrans         transferReceipt;        // Receipt record of the current transfer (if a transfer is used for this period)

        InventSettlement    inventSettlement;       // Keep inventSettlement from updateClosingCosting in memory instead of selecting each time

        InventTrans         distributionReceipt;    // receipt used to settle issues against (the transfer receipt or a single normal receipt)

        boolean includePreviousDistributionReceipt; // whether the previous iteration's period in WA-date still has open quantity on its receipt

        Qty     receiptScanQty;                     // total quantity of open receipts for the current period
        Amount  receiptScanValue;                   // total value    of open receipts for the current period
        int     receiptScanCount;                   // total number   of open receipts for the current period

        Qty     settleQty;

        InventDim     inventDim;                    // used to determine inventDimId for the virtual transfer that can be created
        InventDimParm inventDimParm;                // used to inspect system when an error occurs to generate good error message

        PdsCWInventQty   pdsCWReceiptScanQty;       // CW total CW quantity of open receipts for the current period
        PdsCWSettled     pdsCWSettled;

        // Set up temporary tables

        tmpDates      .setTmpData(tmpInventModel);
        tmpreceiptScan.setTmpData(tmpInventModel);
        tmpReceipt    .setTmpData(tmpInventModel);
        tmpIssue      .setTmpData(tmpInventModel);

        select tmpDates
            index DateIdx group by TransDate;

        select tmpreceiptScan
            index DateIdx
            where tmpreceiptScan.Direction == InventDirection::Receipt;

        select tmpReceipt
            index DateIdx
            where tmpReceipt.Direction == InventDirection::Receipt;

        select tmpIssue
            index DateIdx
            where tmpIssue.Direction == InventDirection::Issue;

        // Create empty distributionReceipt in memory

        this.initDistributionReceiptValueOpen(distributionReceipt, inventTransCurrency);

        distributionReceipt.StatusReceipt = StatusReceipt::Purchased;
        distributionReceipt.StatusIssue   = StatusIssue::None;
        distributionReceipt.DateFinancial = inventClosing.TransDate;

        // Loop over the issue groups by day (WA-date) or period (WA)

        while (tmpDates.TransDate)
        {
            date endDate = _inventSettleModel == InventSettleModel::AverageCostDate ? tmpDates.TransDate : inventClosing.TransDate;

            // <GCN>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCN]))
            {
                if (_inventSettleModel == InventSettleModel::MonthlyAverageCost)
                {
                    endDate = LedgerFiscalCalendar::findLastDayofPeriod(CompanyInfoHelper::fiscalCalendarRecId(), tmpDates.TransDate);
                    if (inventClosing.TransDate < endDate)
                    {
                        endDate = inventClosing.TransDate;
                    }
                }
            }
            // </GCN>

            // If there are no open issues in this or previous periods, go to the next period

            if (!tmpIssue.RecId || tmpIssue.TransDate > endDate)
            {
                next tmpDates;
                continue;
            }

            // If we still have open quantity on the previous distribution receipt, take it into account.

            if (this.financialOpenQty(distributionReceipt) >= InventAdj::settleQtyDiff())
            {
                includePreviousDistributionReceipt = true;

                receiptScanQty      = this.financialOpenQty  (distributionReceipt);
                pdsCWReceiptScanQty = this.pdsCWFinancialOpenQty(distributionReceipt);
                receiptScanValue    = this.financialOpenValue(distributionReceipt);

                receiptScanCount = 1;
            }
            else
            {
                includePreviousDistributionReceipt = false;

                receiptScanQty   = 0.0;
                receiptScanValue = 0.0;

                pdsCWReceiptScanQty = 0;

                receiptScanCount = 0;
            }

            // Sum the receipts over the relevant period

            boolean transferAlreadyExists = false;

            while (tmpreceiptScan.RecId && tmpreceiptScan.TransDate <= endDate)
            {
                InventTrans receiptScan = this.tmpReceipt2Trans(tmpreceiptScan);
                InventTransType receiptScanReferenceCategory = referenceCategoryCache.getReferenceCategory(receiptScan.inventTransOrigin);

                // <GEERU>
                if (InventoryCloseWeightedAverageFight::instance().isEnabled()
                    || !countryRegion_RU
                    || receiptScanReferenceCategory != InventTransType::SummedUp || this.currencyTransfer_RU(receiptScan))
                {
                    // </GEERU>
                    if (receiptScanReferenceCategory == InventTransType::SummedUp && receiptScan.DateFinancial == endDate)
                    {
                        // We are apparently recovering from a hard shutdown (i.e. from hardware failure).
                        // We keep this transfer receipt separate from the other receipts, at least for the time being.

                        transferAlreadyExists = true;
                        transferReceipt       = receiptScan;
                        transferOriginId      = receiptScan.InventTransOrigin;
                    }
                    else
                    {
                        receiptScanQty      += this.financialOpenQty  (receiptScan);
                        pdsCWReceiptScanQty += this.pdsCWFinancialOpenQty(receiptScan);
                        receiptScanValue    += this.financialOpenValue(receiptScan);

                        receiptScanCount++;
                    }
                    // <GEERU>
                }
                // </GEERU>

                next tmpreceiptScan;
            }

            // If we are recovering from a hard shutdown, but have no receipts other than the transfer receipt,
            // then all original receipts must have been settled against the transfer already, and we can just
            // use the transfer receipt as a single ordinary receipt and settle all (remaining) issues against it.

            if (transferAlreadyExists && receiptScanCount == 0)
            {
                receiptScanQty      = this.financialOpenQty  (transferReceipt);
                pdsCWReceiptScanQty = this.financialOpenQty(transferReceipt);
                receiptScanValue    = this.financialOpenValue(transferReceipt);

                receiptScanCount = 1;

                transferAlreadyExists = false;
            }

            // If there are no receipts, we can't settle any issue(s), no matter what:

            if (receiptScanCount == 0)
            {
                next tmpDates;
                continue;
            }

            // The number of digits of real value is 16, and if receiptScanQty value's digit numbers are more than 16 such as 17, then the receiptScanQty value will be
            // rounded when assigning it to InventTrans buffer in estimation of InventUpd_Financial and leads to unexpected error "Cannot receive quantity 0.00 because
            // inventory transactions with status Ordered, Arrived or Registered are insufficient."
            // So here use inventTrans buffer to round the qty firstly. i.e., if receiptScanQty with value 23390661611.489558,and it will be converted to 23390661611.48956.
            if (receiptScanQty > 10000000000.0 && receiptScanQty < realMax())
            {
                InventTrans inventTransLocal;
                inventTransLocal.Qty = receiptScanQty;
                if (abs(inventTransLocal.Qty - receiptScanQty) < 1.0)
                {
                    receiptScanQty = inventTransLocal.Qty;
                }
            }

            // Create a distribution receipt to settle all issues against:

            if (inventClosing.AdjustmentType == InventAdjustmentType::Recalculation)
            {
                // If this is a recalculation, we create a distribution receipt in memory, which will never hit the database

                distributionReceipt.clear();

                this.initDistributionReceiptValueOpen(distributionReceipt, inventTransCurrency);

                distributionReceipt.StatusReceipt    = StatusReceipt::Purchased;
                distributionReceipt.StatusIssue      = StatusIssue::None;
                distributionReceipt.DateFinancial    = endDate;

                distributionReceipt.Qty              = receiptScanQty;
                // <GEERU>
                if (!countryRegion_RU
                    || inventTransCurrency == InventTransCurrency_RU::PrimaryCur)
                {
                    // </GEERU>
                    distributionReceipt.CostAmountPosted = receiptScanValue;
                    // <GEERU>
                }
                else
                {
                    distributionReceipt.CostAmountSecCurPosted_RU = receiptScanValue;
                }
                // </GEERU>

                distributionReceipt.PdsCWQty        = pdsCWReceiptScanQty;

                mapSettleQty.remove(0);
                mapSettleValue.remove(0);
                pdsMapSettleCWQty.remove(0);
            }
            else
            {
                // If this is a closing and there is only one receipt, we will use that receipt to settle the issues against:

                if (receiptScanCount == 1 && !includePreviousDistributionReceipt)  // (do nothing if this already is the distribution receipt)
                {
                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        while (tmpReceipt.RecId && tmpReceipt.TransDate <= endDate)
                        {
                            receipt = this.tmpReceipt2Trans(tmpReceipt);
                            receiptReferenceCategory = referenceCategoryCache.getReferenceCategory(receipt.inventTransOrigin);

                            next tmpReceipt;

                            if (receiptReferenceCategory != InventTransType::SummedUp
                                || (receipt.DateFinancial != endDate && this.currencyTransfer_RU(receipt)))
                            {
                                break;
                            }
                        }
                    }
                    else
                    {
                        // </GEERU>
                        receipt = this.tmpReceipt2Trans(tmpReceipt);

                        next tmpReceipt;
                        // <GEERU>
                    }
                    // </GEERU>
                    distributionReceipt.data(receipt.data());
                }

                // If this is a closing and there are multiple receipts, we combine them through a local transfer to end up with just one receipt:

                if (receiptScanCount >= 2)
                {
                    if (!transferAlreadyExists)
                    {
                        // Create a transfer

                        this.updateTransKeyAdjust();    // flush mapKeyAdjust to the database, otherwise these updates could be lost if execution stops unexpectedly

                        ttscommit;

                        try
                        {
                            ttsbegin;

                            inventDim = _inventDim.InventDimId ? _inventDim : InventDim::findOrCreate(_inventDim);
                            // <GEERU>
                            if (countryRegion_RU)
                            {
                                transferOriginId = InventTransOrigin::findByInventTransId(InventUpd_Financial::updateVirtuelTransferClosing(inventCostList.ItemId,
                                                                                               inventDim.InventDimId,
                                                                                               endDate,
                                                                                               receiptScanQty,
                                                                                               pdsCWReceiptScanQty,
                                                                                               inventTransCurrency == InventTransCurrency_RU::PrimaryCur   ? receiptScanValue : 0,
                                                                                               inventClosing.Voucher,
                                                                                               inventTransCurrency == InventTransCurrency_RU::SecondaryCur ? receiptScanValue : 0)).RecId;
                            }
                            else
                            {
                                // </GEERU>
                                transferOriginId = InventTransOrigin::findByInventTransId(InventUpd_Financial::updateVirtuelTransferClosing(inventCostList.ItemId,
                                                                                               inventDim.InventDimId,
                                                                                               endDate,
                                                                                               receiptScanQty,
                                                                                               pdsCWReceiptScanQty,
                                                                                               receiptScanValue,
                                                                                               inventClosing.Voucher)).RecId;
                                // <GEERU>
                            }
                            // </GEERU>
                            ttscommit;
                        }
                        catch (Exception::Error)
                        {
                            inventDimParm.initFromInventDim(inventDim);

                            InventOnhand inventOnhand = InventOnhand::newParameters(inventCostList.ItemId, inventDim, inventDimParm);

                            if (this.inventModelGroup(inventCostList.ItemId).NegativePhysical == NoYes::No && !inventOnhand.checkItemDraw(0, false, false))
                            {
                                warning(strFmt("@SYS112627", inventCostList.ItemId));
                            }

                            if (this.inventModelGroup(inventCostList.ItemId).NegativeFinancial == NoYes::No && !inventOnhand.checkItemDrawFinancial(0, false, false))
                            {
                                warning(strFmt("@SYS112628", inventCostList.ItemId));
                            }

                            throw Exception::Error;
                        }

                        ttsbegin;
                    }

                    // Put the transfer's transactions in the right variables and caches

                    select firstonly forupdate transferReceipt where transferReceipt.InventTransOrigin == transferOriginId && transferReceipt.Qty > 0.0;
                    select firstonly forupdate transferIssue   where transferIssue  .InventTransOrigin == transferOriginId && transferIssue  .Qty < 0.0;

                    mapInventTrans.insert(transferReceipt.RecId, transferReceipt);
                    mapInventTrans.insert(transferIssue  .RecId, transferIssue  );

                    // Settle all current receipts against special transfer issue

                    inventSettlement.clear();
                    inventSettlement.SettleType = InventSettleType::Issue;

                    while (tmpReceipt.RecId && tmpReceipt.TransDate <= endDate)
                    {
                        receipt = includePreviousDistributionReceipt ? distributionReceipt : this.tmpReceipt2Trans(tmpReceipt);
                        receiptReferenceCategory = referenceCategoryCache.getReferenceCategory(receipt.inventTransOrigin);

                        // <GEERU>
                        if (receiptReferenceCategory == InventTransType::SummedUp && (receipt.DateFinancial == endDate ||
                                                                                             (countryRegion_RU && ! this.currencyTransfer_RU(receipt))))
                        // </GEERU>
                        {
                            next tmpReceipt;
                        }
                        else
                        {
                            settleQty = this.financialOpenQty(receipt);

                            pdsCWSettled = this.pdsCWFinancialOpenQty(receipt);
                            inventSettlement = this.updateClosingCosting(receipt, transferIssue, settleQty, _inventSettleModel, inventSettlement, pdsCWSettled);

                            this.updateInventTrans(receipt);

                            if (this.updateCommitCount())
                            {
                                this.updateInventTrans(transferIssue);
                                this.updateTransKeyAdjust();

                                ttscommit;
                                ttsbegin;
                            }

                            if (includePreviousDistributionReceipt)
                                includePreviousDistributionReceipt = false;
                            else
                                next tmpReceipt;
                        }
                    }

                    this.updateInventTrans(transferIssue);
                    this.updateMapOpenIssue(transferIssue);

                    distributionReceipt.data(transferReceipt.data());
                }
            }

            // Settle the issues from this period that can be (entirely or partially) covered against distribution receipt

            inventSettlement.clear();
            inventSettlement.SettleType = InventSettleType::Receipt;

            while (tmpIssue.RecId && tmpIssue.TransDate <= endDate && this.financialOpenQty(distributionReceipt) >= InventAdj::settleQtyDiff())
            {
                issue = this.tmpIssue2Trans(tmpIssue);
                InventTransType issueReferenceCategory = referenceCategoryCache.getReferenceCategory(issue.inventTransOrigin);
                // <GEERU>
                if (issueReferenceCategory == InventTransType::SummedUp && (issue.DateFinancial == endDate ||
                                                                                   (countryRegion_RU && ! this.currencyTransfer_RU(issue))))
                // </GEERU>
                {
                    // <GEERU>
                    if (! countryRegion_RU
                        || this.currencyTransfer_RU(issue))
                    {
                        // </GEERU>
                        this.updateMapOpenIssue(issue);
                        // <GEERU>
                    }
                    // </GEERU>

                    next tmpIssue;
                }
                else
                {
                    settleQty       = min(-this.financialOpenQty(issue), this.financialOpenQty(distributionReceipt));
                    pdsCWSettled    = min(-this.pdsCWFinancialOpenQty(issue), this.pdsCWFinancialOpenQty(distributionReceipt));

                    inventSettlement = this.updateClosingCosting(distributionReceipt, issue, settleQty, _inventSettleModel, inventSettlement, pdsCWSettled);

                    this.updateInventTrans(issue);

                    if (this.updateCommitCount())
                    {
                        this.updateInventTrans(distributionReceipt);
                        this.updateTransKeyAdjust();

                        ttscommit;
                        ttsbegin;
                    }

                    if (-this.financialOpenQty(issue) < InventAdj::settleQtyDiff())
                    {
                        this.updateMapOpenIssue(issue);

                        next tmpIssue;
                    }
                }
            }

            this.updateInventTrans(distributionReceipt);

            next tmpDates;
        }

        // Log all remaining open issues

        while (tmpIssue.RecId)
        {
            issue = this.tmpIssue2Trans(tmpIssue);

            this.updateMapOpenIssue(issue);

            next tmpIssue;
        }

        // Update adjustments

        this.updateModelAdjustment(_inventSettleModel);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateModelFIFOLIFO</Name>
				<Source><![CDATA[
    protected void updateModelFIFOLIFO(InventSettleModel   _inventSettleModel)
    {
        TmpInventModel      tmpIssue;
        TmpInventModel      tmpReceipt;

        tmpIssue.setTmpData(tmpInventModel);
        tmpReceipt.setTmpData(tmpInventModel);

        if (_inventSettleModel == InventSettleModel::LIFO)
        {
            select tmpIssue
                index DateIdx
                where tmpIssue.Direction  == InventDirection::Issue;

            select reverse tmpReceipt
                index DateIdx
                where tmpReceipt.Direction == InventDirection::Receipt;
        }
        else
        {
            select tmpIssue
                index DateIdx
                where tmpIssue.Direction  == InventDirection::Issue;

            select tmpReceipt
                index DateIdx
                where tmpReceipt.Direction == InventDirection::Receipt;
        }

        InventTrans issue = this.tmpIssue2Trans(tmpIssue);
        InventTrans receipt = this.tmpReceipt2Trans(tmpReceipt);

        while (issue.RecId && receipt.RecId)
        {
            if (this.financialOpenQty(issue)   > -InventAdj::settleQtyDiff())
            {
                this.updateInventTrans(issue);
                this.updateMapOpenIssue(issue);

                next tmpIssue;
                issue   = this.tmpIssue2Trans(tmpIssue);
            }

            if (issue.RecId && this.financialOpenQty(receipt) < InventAdj::settleQtyDiff())
            {
                this.updateInventTrans(receipt);

                next tmpReceipt;

                receipt = this.tmpReceipt2Trans(tmpReceipt);
            }

            if (issue.RecId && receipt.RecId)
            {
                Qty settleQty = min(-this.financialOpenQty(issue),this.financialOpenQty(receipt));
                PdsCWSettled pdsCWSettleQty = min(-this.pdsCWFinancialOpenQty(issue), this.pdsCWFinancialOpenQty(receipt));

                if (settleQty >= InventAdj::settleQtyDiff())
                {
                    this.updateClosingCosting(receipt,issue,settleQty,_inventSettleModel,null,pdsCWSettleQty);

                    if (this.updateCommitCount())
                    {
                        this.updateInventTrans(receipt);
                        this.updateInventTrans(issue);

                        this.updateTransKeyAdjust();

                        ttscommit;
                        ttsbegin;
                    }
                }
                else
                {
                    setPrefix(#prefixfield(inventCostList,itemId));
                    error(strFmt("@SYS19378",funcName()));
                    break;
                }
            }
        }

        if (receipt.RecId)
            this.updateInventTrans(receipt);

        if (issue.RecId)
            this.updateInventTrans(issue);

        while (issue.RecId)
        {
            this.updateMapOpenIssue(issue);
            next tmpIssue;
            issue   = this.tmpIssue2Trans(tmpIssue);
        }

        this.updateModelAdjustment(_inventSettleModel);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateModelLIFODate</Name>
				<Source><![CDATA[
    protected void updateModelLIFODate(InventSettleModel   _inventSettleModel)
    {
        InventTrans         issue;
        InventTrans         receipt;

        TmpInventModel      tmpIssue;
        TmpInventModel      tmpReceipt;

        boolean             fifo;

        void selectIssue()
        {
            select tmpIssue
                index DateIdx
                where tmpIssue.Direction  == InventDirection::Issue;

            issue = this.tmpIssue2Trans(tmpIssue);
        }

        void selectReceipt()
        {
            fifo = false;
            select reverse tmpReceipt
                index DateIdx
                where tmpReceipt.Direction == InventDirection::Receipt &&
                      tmpReceipt.TransDate <= tmpIssue.TransDate;

            if (tmpReceipt.Direction != InventDirection::Receipt)
            {
                select tmpReceipt
                    index DateIdx
                    where tmpReceipt.Direction == InventDirection::Receipt;

                fifo = true;
            }

            receipt = this.tmpReceipt2Trans(tmpReceipt);
        }

        tmpIssue.setTmpData(tmpInventModel);
        tmpReceipt.setTmpData(tmpInventModel);

        selectIssue();
        selectReceipt();

        while (receipt.RecId && issue.RecId)
        {
            if (this.financialOpenQty(issue) > -InventAdj::settleQtyDiff())
            {
                this.updateInventTrans(issue);

                if (receipt.RecId)
                    this.updateInventTrans(receipt);

                this.updateMapOpenIssue(issue);

                next tmpIssue;
                issue = this.tmpIssue2Trans(tmpIssue);

                if (issue.RecId)
                {
                    selectReceipt();
                }
                else
                {
                    receipt = null;
                }
            }

            if (receipt.RecId && this.financialOpenQty(receipt) < InventAdj::settleQtyDiff())
            {
                this.updateInventTrans(receipt);

                while (receipt.RecId)
                {
                    tmpReceipt.delete();

                    next tmpReceipt;

                    if (tmpReceipt.Direction != InventDirection::Receipt && ! fifo)
                    {
                        select tmpReceipt
                           index DateIdx
                           where tmpReceipt.Direction == InventDirection::Receipt;

                        fifo = true;
                    }
                    receipt = this.tmpReceipt2Trans(tmpReceipt);

                    if (this.financialOpenQty(receipt) >= InventAdj::settleQtyDiff())
                        break;
                }
            }

            if (issue.RecId && receipt.RecId)
            {
                Qty settleQty = min(-this.financialOpenQty(issue),this.financialOpenQty(receipt));
                PdsCWSettled pdsCWSettled = min(-this.pdsCWFinancialOpenQty(issue), this.pdsCWFinancialOpenQty(receipt));

                if (settleQty >= InventAdj::settleQtyDiff())
                {
                    this.updateClosingCosting(receipt,issue,settleQty,_inventSettleModel, null, pdsCWSettled);

                    if (this.updateCommitCount())
                    {
                        this.updateInventTrans(receipt);
                        this.updateInventTrans(issue);

                        this.updateTransKeyAdjust();

                        ttscommit;
                        ttsbegin;
                    }
                }
                else
                {
                    setPrefix(#prefixfield(inventCostList,itemId));
                    error(strFmt("@SYS19378",funcName()));
                    break;
                }
            }
        }

        if (receipt.RecId)
        {
            this.updateInventTrans(receipt);
        }

        if (issue.RecId)
        {
            this.updateInventTrans(issue);
        }

        while (issue.RecId)
        {
            this.updateMapOpenIssue(issue);
            next tmpIssue;
            issue   = this.tmpIssue2Trans(tmpIssue);
        }

        this.updateModelAdjustment(_inventSettleModel);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the receipt transaction and the calculation parameter list.
    /// </summary>
    /// <param name="_receipt">
    /// The receipt transaction that should be updated.
    /// </param>
    protected void updateReceipt(InventTrans _receipt)
    {
        boolean wasClosed = (!this.isInventTransOpen(_receipt));

        _receipt.update();

        if (wasClosed && this.isInventTransOpen(_receipt))
        {
            this.updateInventCostListParm(_receipt);
            if (!inventCostListParm && _receipt.ItemId == inventCostList.ItemId)
            {
                inventCostListParm = InventCostListParm::find(inventClosing.RecId, inventCostList.ItemId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReceiptAdjustment</Name>
				<Source><![CDATA[
    protected void updateReceiptAdjustment()
    {
        CostAmount      adjustmentMin;

        if (! mapInventTrans || ! mapInventTrans.elements())
        {
            return;
        }

        this.startTimer();

        SetEnumerator setEnumInventTrans = mapInventTrans.keySet().getEnumerator();
        while (setEnumInventTrans.moveNext())
        {
            InventTrans inventTrans = mapInventTrans.lookup(setEnumInventTrans.current());

            CostAmount adjustmentLater = this.calcLaterAdjustment(inventTrans);

            if (inventTrans.Qty > 0)
            {
                if (adjustmentLater)
                {
                    mapSettleValue.insert(inventTrans.RecId,-adjustmentLater);
                }

                if (inventClosing.AdjustmentType == InventAdjustmentType::Recalculation)
                {
                    adjustmentMin = this.calcMinAdjustment(inventTrans);
                    if (adjustmentMin)
                    {
                        if (mapSettleValue.exists(inventTrans.RecId))
                        {
                            mapSettleValue.insert(inventTrans.RecId,mapSettleValue.lookup(inventTrans.RecId) - adjustmentMin);
                        }
                        else
                        {
                            mapSettleValue.insert(inventTrans.RecId,0-adjustmentMin);
                        }
                    }
                }

                this.updateReceiptAdjustmentTrans(inventTrans,adjustmentLater + adjustmentMin);
            }
            else
            if (inventTrans.Qty < 0)
            {
                if (adjustmentLater)
                {
                    mapSettleValue.insert(inventTrans.RecId,-adjustmentLater);
                }

                if (abs(this.financialOpenQty(inventTrans)) < InventAdj::settleQtyDiff() && this.financialOpenValue(inventTrans))
                {
                    this.createErrorAdjustment(inventTrans,-this.financialOpenValue(inventTrans));
                }
            }
        }

        this.updateTransKeyAdjust();
        updateReceiptAdjustmentTime+=this.getTimer();
        updateReceiptAdjustmentCount++;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReceiptAdjustmentTrans</Name>
				<Source><![CDATA[
    protected void updateReceiptAdjustmentTrans(
        InventTrans   _receipt,
        CostAmount    _adjustmentLater
        )
    {
        InventSettlement        settlementReceipt;
        InventSettlement        settlementIssue;
        InventTrans             issue;
        InventQty               allocateQty;
        Map                     mapAllocateQty;
        CostAmount              settleValue;
        CostAmount              adjustment;

        if (this.isUpdatedFinancialLater(_receipt))
        {
            return;
        }

        if (this.inventModelGroup(inventCostList.ItemId).StandardCost)
        {
            // <GEERU>
            if ((countryRegion_RU
                && this.inventModelType_RU(_receipt.ItemId).allowTransactionAdjustment(_receipt))
                || (!countryRegion_RU
                && (this.inventModelGroup(_receipt.ItemId).inventModelType().allowTransactionAdjustment(_receipt))))
            // </GEERU>
            {
                adjustment = CurrencyExchangeHelper::amount(_receipt.CostAmountStd, standardCurrency) - CurrencyExchangeHelper::amount(this.costValue(_receipt), standardCurrency);
                if (adjustment != 0)
                {
                    _receipt.skipTTSCheck(true);
                    _receipt.updateStdCostAdjust(
                                adjustment,
                                inventClosing.TransDate,
                                inventClosing.Voucher,
                                _receipt.dimensionFinancialDefaultDimension());
                    mapInventTrans.insert(_receipt.RecId,_receipt);
                }
            }
        }

        if (_receipt.Qty != 0 && _receipt.QtySettled > 0)
        {
            CostAmount costAmount = CurrencyExchangeHelper::amount((_receipt.costValue() - _adjustmentLater) / _receipt.Qty * _receipt.QtySettled);
            adjustment = costAmount - _receipt.CostAmountSettled;

            if (adjustment != 0
                && abs(adjustment) < inventClosing.MinTransferValue
                && _receipt.costValue() > _receipt.CostAmountSettled)
            {
                if (! this.financialOpenQty(_receipt))  // Error adjustment must only be done when the transaction is completely settled
                {
                    this.createErrorAdjustment(_receipt,-adjustment);
                }

                adjustment  = 0;
            }

            CostAmount allocateValue = adjustment;

            if (allocateValue != 0)
            {
                while select forceplaceholders pessimisticlock RecId,
                    QtySettled,
                    CostAmountSettled,
                    CostAmountAdjustment,
                    TransDate,
                    Voucher,
                    TransRecId,
                    SettleTransId,
                    SettleType from settlementReceipt
                    where settlementReceipt.TransRecId      == _receipt.RecId
                       && settlementReceipt.SettleType      == InventSettleType::Receipt
                       && settlementReceipt.InventTransId   == _receipt.inventTransOrigin().InventTransId
                       // <GEERU>
                       && (!countryRegion_RU || settlementReceipt.InventTransCurrency_RU == inventTransCurrency)
                       // </GEERU>
                       && settlementReceipt.Cancelled       == 0
                       && settlementReceipt.QtySettled      >  0
                join forupdate RecId,
                    QtySettled,
                    CostAmountSettled,
                    CostAmountAdjustment,
                    TransDate,
                    Voucher,
                    TransRecId,
                    SettleTransId,
                    SettleType from settlementIssue
                    where settlementIssue.SettleTransId     == settlementReceipt.SettleTransId
                       && settlementIssue.SettleType        == InventSettleType::Issue
                       // <GEERU>
                       && (!countryRegion_RU || settlementReceipt.InventTransCurrency_RU == inventTransCurrency)
                       // </GEERU>
                       && settlementIssue.Cancelled         == 0
                       && settlementIssue.QtySettled        <  0
                {
                    if (!mapAllocateQty)
                    {
                        mapAllocateQty = new Map(Types::String,Types::Real);
                    }

                    if (mapAllocateQty.exists(settlementReceipt.SettleTransId))
                    {
                        allocateQty = mapAllocateQty.lookup(settlementReceipt.SettleTransId);
                    }
                    else
                    {
                        allocateQty = (select sum(QtySettled) from inventSettlement
                                        where inventSettlement.SettleTransId == settlementReceipt.SettleTransId  &&
                                              inventSettlement.SettleType    == InventSettleType::Issue          &&
                                              inventSettlement.Cancelled     == 0                                &&
                                              inventSettlement.QtySettled    <  0).QtySettled;
                        mapAllocateQty.insert(settlementReceipt.SettleTransId,allocateQty);
                    }

                    CostAmount settleValueDec = (settlementIssue.QtySettled * adjustment / allocateQty);
                    if (_receipt.QtySettled)
                    {
                        settleValueDec = settleValueDec * settlementReceipt.QtySettled / _receipt.QtySettled;
                    }

                    if (abs(settleValueDec) > abs(roundOffunit))
                    {
                        settleValue = CurrencyExchangeHelper::amount(settleValueDec, standardCurrency);
                    }
                    else
                    {
                        settleValue = sign(settleValueDec) * roundOffunit;
                    }

                    settleValue     = abs(settleValue) > abs(allocateValue) ? allocateValue: settleValue;
                    allocateValue  -= settleValue;

                    if (settleValue != 0)
                    {
                        if (mapInventTrans && mapInventTrans.exists(settlementIssue.TransRecId))
                        {
                            issue = mapInventTrans.lookup(settlementIssue.TransRecId);
                        }
                        else
                        {
                            issue = settlementIssue.inventTrans(true);
                        }

                        if (! issue.RecId)
                        {
                            this.createErrorAdjustment(_receipt,-settleValue);
                        }
                        else
                        {
                            if (this.costValue(issue) - settleValue > 0)
                            {
                                CostAmount errorAmount = this.costValue(issue) - settleValue;
                                this.createErrorAdjustment(_receipt,errorAmount);
                                settleValue += errorAmount;
                            }

                            _receipt.CostAmountSettled             += settleValue;

                            issue.CostAmountSettled                -= settleValue;
                            issue.CostAmountAdjustment             -= settleValue;

                            this.updateInventTrans(issue);

                            if (settlementReceipt.TransDate == inventClosing.TransDate &&
                                settlementReceipt.Voucher   == inventClosing.Voucher)
                            {
                                settlementReceipt.reread();
                                settlementReceipt.CostAmountSettled    += settleValue;
                                settlementReceipt.update();

                                settlementIssue.CostAmountSettled      -= settleValue;
                                settlementIssue.CostAmountAdjustment   -= settleValue;
                                settlementIssue.update();
                            }
                            else
                            {
                                this.updateSettlementReceipt(settlementReceipt,settleValue);
                                this.updateSettlementIssue(settlementIssue,settleValue);
                            }
                            this.adjustTrans(issue, -settleValue);
                        }
                    }
                }

                this.updateInventTrans(_receipt);

                if (allocateValue != 0)
                {
                    if (!this.financialOpenQty(_receipt) ||
                        CurrencyExchangeHelper::price(_receipt.CostAmountSettled / _receipt.QtySettled) != CurrencyExchangeHelper::price(costAmount / _receipt.QtySettled))
                    {
                        this.createErrorAdjustment(_receipt,-allocateValue);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateServiceItemTrans</Name>
				<Source><![CDATA[
    protected void updateServiceItemTrans(ItemId _itemId)
    {
        InventTrans         inventTrans;
        InventSettlement    inventSettlement;

        RecordInsertList    recordInsertList = new RecordInsertList(tableNum(InventSettlement),true,true);

        // Optimization note: All columns are expected to be included in the index
        while select forupdate inventTrans
            // <GEERU>
            where ((countryRegion_RU
               && ((inventTransCurrency             == InventTransCurrency_RU::PrimaryCur
               &&   inventTrans.ValueOpen           == InventTransOpen::Yes)
               ||  (inventTransCurrency             == InventTransCurrency_RU::SecondaryCur
               &&   inventTrans.ValueOpenSecCur_RU  == InventTransOpen::Yes)))
               || (!countryRegion_RU
               && inventTrans.ValueOpen         == InventTransOpen::Yes))
            // </GEERU>
            &&  inventTrans.ItemId            == _itemId
              && (inventTrans.StatusIssue       == StatusIssue::Sold
              ||  inventTrans.StatusReceipt     == StatusReceipt::Purchased)
              &&  inventTrans.DateStatus        <= inventClosing.TransDate
              &&  inventTrans.MarkingRefInventTransOrigin   == 0 // marked service item transactions will be settled according to marking principle

        {
            // <GEERU>
            if (countryRegion_RU)
            {
                inventSettlement = this.initInventSettlement(inventTrans,
                                                             inventTransCurrency == InventTransCurrency_RU::PrimaryCur ? inventTrans.financialOpenQty()   : inventTrans.financialOpenQtySecCur_RU(),
                                                             inventTransCurrency == InventTransCurrency_RU::PrimaryCur ? inventTrans.financialOpenValue() : inventTrans.financialOpenValueSecCur_RU(),
                                                             0,
                                                             InventSettleModel::ServiceItem,
                                                             inventTrans.Qty >= 0 ? InventSettleType::Receipt : InventSettleType::Issue,
                                                             InitLedgerDrop
                );
            }
            else
            {
                // </GEERU>
                inventSettlement = this.initInventSettlement(inventTrans,
                                                             inventTrans.financialOpenQty(),
                                                             inventTrans.financialOpenValue(),
                                                             0,
                                                             InventSettleModel::ServiceItem,
                                                             inventTrans.Qty >= 0 ? InventSettleType::Receipt : InventSettleType::Issue,
                                                             InitLedgerDrop
                );
                // <GEERU>
            }
            // </GEERU>

            inventSettlement.SettleTransId      = InventSettlement::nextSettleTransId();
            inventSettlement.insertUsingInsertList(recordInsertList);

            // <GEERU>
            if (!countryRegion_RU
                || inventTransCurrency == InventTransCurrency_RU::PrimaryCur)
            {
                // </GEERU>
                inventTrans.QtySettled             += inventTrans.financialOpenQty();
                inventTrans.CostAmountSettled      += inventTrans.financialOpenValue();
                // <GEERU>
            }
            else
            {
                inventTrans.QtySettledSecCur_RU        += inventTrans.financialOpenQtySecCur_RU();
                inventTrans.CostAmountSettledSecCur_RU += inventTrans.financialOpenValueSecCur_RU();
            }
            // </GEERU>
            this.updateCostAmountStd(inventTrans);
            inventTrans.update();

            if (inventTrans.ValueOpen == InventTransOpen::No && inventTrans.Voucher != inventClosing.Voucher)
            {
                closedInventTransCount++;
            }
        }

        recordInsertList.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSettlementIssue</Name>
				<Source><![CDATA[
    protected void updateSettlementIssue(
        InventSettlement    _settlementIssue,
        CostAmount          _settleValue
        )
    {
        InventSettlement    settlementIssueAdd;

        select firstonly forupdate RecId,CostAmountSettled,CostAmountAdjustment from settlementIssueAdd
            where settlementIssueAdd.TransRecId      == _settlementIssue.TransRecId
              &&  settlementIssueAdd.SettleTransId   == _settlementIssue.SettleTransId
              &&  settlementIssueAdd.SettleType      == _settlementIssue.SettleType
              &&  settlementIssueAdd.Cancelled       == 0
              &&  settlementIssueAdd.QtySettled      == 0
              &&  settlementIssueAdd.TransDate       == inventClosing.TransDate
              &&  settlementIssueAdd.Voucher         == inventClosing.Voucher;

        if (! settlementIssueAdd.RecId)
        {
            settlementIssueAdd = InventSettlement::findRecId(_settlementIssue.RecId,true);

            settlementIssueAdd.TransDate                = inventClosing.TransDate;
            settlementIssueAdd.Voucher                  = inventClosing.Voucher;
            settlementIssueAdd.CostAmountSettled        = -_settleValue;
            settlementIssueAdd.CostAmountAdjustment     = -_settleValue;
            settlementIssueAdd.QtySettled               = 0;
            settlementIssueAdd.PdsCWSettled             = 0;

            settlementIssueAdd.Posted                   = NoYes::No;

            settlementIssueAdd.insert();
        }
        else
        {
            settlementIssueAdd.CostAmountSettled       -= _settleValue;
            settlementIssueAdd.CostAmountAdjustment    -= _settleValue;
            settlementIssueAdd.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSettlementReceipt</Name>
				<Source><![CDATA[
    protected void updateSettlementReceipt(
        InventSettlement    _settlementReceipt,
        CostAmount          _settleValue
        )
    {
        InventSettlement    settlementReceiptAdd;

        select firstonly forupdate RecId,CostAmountSettled from settlementReceiptAdd
            where settlementReceiptAdd.TransRecId      == _settlementReceipt.TransRecId
              &&  settlementReceiptAdd.SettleTransId   == _settlementReceipt.SettleTransId
              &&  settlementReceiptAdd.SettleType      == _settlementReceipt.SettleType
              &&  settlementReceiptAdd.Cancelled       == 0
              &&  settlementReceiptAdd.QtySettled      == 0
              &&  settlementReceiptAdd.TransDate       == inventClosing.TransDate
              &&  settlementReceiptAdd.Voucher         == inventClosing.Voucher;

        if (! settlementReceiptAdd.RecId)
        {
            settlementReceiptAdd = InventSettlement::findRecId(_settlementReceipt.RecId,true);

            settlementReceiptAdd.TransDate              = inventClosing.TransDate;
            settlementReceiptAdd.Voucher                = inventClosing.Voucher;
            settlementReceiptAdd.CostAmountSettled      = _settleValue;
            settlementReceiptAdd.CostAmountAdjustment   = 0;
            settlementReceiptAdd.QtySettled             = 0;
            settlementReceiptAdd.PdsCWSettled           = 0;
            settlementReceiptAdd.Posted                 = NoYes::No;

            settlementReceiptAdd.insert();
        }
        else
        {
            settlementReceiptAdd.CostAmountSettled     += _settleValue;
            settlementReceiptAdd.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransIdReceipt</Name>
				<Source><![CDATA[
    protected void updateTransIdReceipt(
        InventTransOriginId      inventTransOriginId,
        CostAmount               adjustment,
        InventTransOriginId      returnInventTransOriginId,
        Voucher                  voucherPhysical
        )
    {
        InventTrans         receipt;
        InventTransOrigin   receiptInventTransOrigin;
        CostAmount          amountTotal;
        InventQty           qtyTotal;
        boolean             onHandIsAdjusted;
        CostAmount          allocatedAmount;
        InventQty           allocatedQty;

        if (returnInventTransOriginId)
        {
            this.updateTransIdReturnReceipt(inventTransOriginId, returnInventTransOriginId);
            return;
        }

        if (inventTransOriginId && adjustment)
        {
            RecordSortedList inventTransCache = new RecordSortedList(tableNum(InventTrans));
            inventTransCache.sortOrder(fieldNum(InventTrans,RecId));

            InventDim inventDim;
            InventClosingRecordInventDimForTransferOrderContext context = InventClosingRecordInventDimForTransferOrderContext::current();

            if (considerBatchAndSerialForTransferOrder && context && (context.inventSerialId || context.inventBatchId))
            {
                while select forupdate receipt
                    where receipt.InventTransOrigin                 == inventTransOriginId
                      &&  receipt.StatusReceipt                     == StatusReceipt::Purchased
                      &&  receipt.StatusIssue                       == StatusIssue::None
                      &&  receipt.PackingSlipReturned               == 0
                      &&  receipt.NonFinancialTransferInventClosing == 0
                      && (receipt.VoucherPhysical                   == voucherPhysical || !voucherPhysical)
                    exists join receiptInventTransOrigin
                        where   receiptInventTransOrigin.RecId == receipt.InventTransOrigin
                    exists join inventDim
                        where receipt.inventDimId == inventDim.inventDimId
                           && (!context.inventSerialId || inventDim.inventSerialId == context.inventSerialId)
                           && (!context.inventBatchId || inventDim.inventBatchId == context.inventBatchId)
                {
                    // <GEERU>
                    if (countryRegion_RU && receipt.isNonFinancialTransfer())
                    {
                        continue;
                    }
                    // </GEERU>

                    qtyTotal  += receipt.Qty;
                    amountTotal += this.costValue(receipt);

                    inventTransCache.ins(receipt);
                }
            }
            else
            {
                while select forupdate receipt
                    where receipt.InventTransOrigin                 == inventTransOriginId
                      &&  receipt.StatusReceipt                     == StatusReceipt::Purchased
                      &&  receipt.StatusIssue                       == StatusIssue::None
                      &&  receipt.PackingSlipReturned               == 0
                      &&  receipt.NonFinancialTransferInventClosing == 0
                      && (receipt.VoucherPhysical                   == voucherPhysical || !voucherPhysical)
                    exists join receiptInventTransOrigin
                        where   receiptInventTransOrigin.RecId == receipt.InventTransOrigin
                {
                    // <GEERU>
                    if (countryRegion_RU && receipt.isNonFinancialTransfer())
                    {
                        continue;
                    }
                    // </GEERU>

                    qtyTotal  += receipt.Qty;
                    amountTotal += this.costValue(receipt);

                    inventTransCache.ins(receipt);
                }
            }

            if (inventTransCache.len() == 0)
            {
                InventTransOrigin inventTransOrigin = InventTransOrigin::find(inventTransOriginId);

                if (inventTransOrigin.ReferenceCategory == InventTransType::PmfProdCoBy
                    || inventTransOrigin.ReferenceCategory == InventTransType::TransferOrderShip
                    || inventTransOrigin.ReferenceCategory == InventTransType::TransferOrderReceive
                    || inventTransOrigin.ReferenceCategory == InventTransType::Production)
                {
                    return;
                }
            }

            // <GEERU>
            if (countryRegion_RU)
            {
                onHandIsAdjusted = InventAdj::isOnhandAdjusted(inventTransOriginId, returnInventTransOriginId, voucherPhysical, inventTransCurrency);
            }
            else
            {
                // </GEERU>
                onHandIsAdjusted = InventAdj::isOnhandAdjusted(inventTransOriginId, returnInventTransOriginId, voucherPhysical);
                // <GEERU>
            }
            // </GEERU>

            CostAmount adjusted;

            if (qtyTotal && inventTransCache.first(receipt))
            do
            {
                CostAmount newCostValue = CurrencyExchangeHelper::amount(amountTotal - adjustment - allocatedAmount - (qtyTotal - allocatedQty - receipt.Qty) / qtyTotal * (amountTotal - adjustment), standardCurrency);

                allocatedAmount += newCostValue;
                allocatedQty    += receipt.Qty;

                CostAmount adjustNow = newCostValue - this.costValue(receipt);

                if (adjustNow)
                {
                    // <GEERU>
                    if (!countryRegion_RU
                        || inventTransCurrency == InventTransCurrency_RU::PrimaryCur)
                    {
                        // </GEERU>
                        receipt.CostAmountAdjustment += adjustNow;
                        // <GEERU>
                    }
                    else
                    {
                        receipt.CostAmountSecCurAdjustment_RU += adjustNow;
                    }
                    // </GEERU>

                    if (inventClosing.AdjustmentType == InventAdjustmentType::Recalculation)
                    {
                        this.createAdjustSettlementRecalc(receipt,adjustNow,'');
                    }
                    else
                    {
                        this.createAdjustSettlement(receipt,adjustNow,'');
                    }

                    // The adjustment for a standard cost item will always be
                    // reverted to bring the item cost down to standard cost
                    // So there is no need to create an adjustment.
                    // <GEERU>
                    if ((countryRegion_RU   &&  this.inventModelType_RU(receipt.ItemId).mustBeClosed()) ||
                        (! countryRegion_RU &&  this.inventModelGroup(receipt.ItemId).inventModelType().mustBeClosed()))
                    // </GEERU>
                    {
                        if (onHandIsAdjusted)
                        {
                            using (InventAdjErrorPostingOperationsContext inventAdjErrorPostingOperationsContext = InventAdjErrorPostingOperationsContext::construct())
                            {
                                inventAdjErrorPostingOperationsContext.parmDoNotUseRoundingPosting(countryRegion_RU);
                            
                                this.createErrorAdjustment(receipt, -adjustNow);
                            }                           
                        }

                        if (inventClosing.AdjustmentType == InventAdjustmentType::Closing)
                        {
                            if (abs(adjustNow) < inventClosing.MinTransferValue || inventClosing.NumOfIteration >= inventClosing.MaxIterations)
                            {
                                this.createErrorAdjustment(receipt,-adjustNow);
                            }
                        }

                        if (this.costValue(receipt) < 0 && !(this.inventModelGroup(receipt.ItemId).StandardCost && !receipt.isTransfer()))
                        {
                            this.createErrorAdjustment(receipt,-this.costValue(receipt));
                        }
                    }
                    else
                    {
                        // <GEERU>
                        if (countryRegion_RU)
                        {
                            this.inventModelType_RU(receipt.ItemId).postUpdateFinancialAdjustment(receipt, inventClosing.Voucher, inventClosing.TransDate, adjustNow);
                        }
                        else
                        {
                            // </GEERU>
                            this.inventModelGroup(receipt.ItemId).inventModelType().postUpdateFinancialAdjustment(receipt, inventClosing.Voucher, inventClosing.TransDate, adjustNow);
                            // <GEERU>
                        }
                        // </GEERU>
                    }

                    this.updateCostAmountStd(receipt);
                    this.updateReceipt(receipt);
                }

                mapInventTrans.insert(receipt.RecId,receipt);

                adjusted -= adjustNow;
            }
            while (inventTransCache.next(receipt));

            if (adjustment != adjusted)
            {
                using (var activityContext = this.instrumentationLogger().adjustmentAmountCheckActivities().AdjustmentAmountCheck(
                    AdjustmentAmountCheckBuilder::construct().setInventClosingId(inventClosing.RecId).setInventTransOriginId(inventTransOriginId)
                        .setReturnInventTransOriginId(returnInventTransOriginId).setMethodName(funcName()).setVoucherPhysical(voucherPhysical)
                        .setAmountTotal(amountTotal).setQtyTotal(qtyTotal).setAllocatedAmount(allocatedAmount).setAllocatedQty(allocatedQty)
                        .setAdjustmentAmount(adjustment).setAdjustedAmount(adjusted).setTransCount(inventTransCache.len()).setRoundOffUnit(roundOffunit)))
                {
                    if (!InventReceiptAdjustmentCheckingDisabledFlight::instance().isEnabled()
                        && abs(adjustment - adjusted) > roundOffunit * inventTransCache.len())
                    {
                        InventTransOrigin inventTransOrigin = InventTransOrigin::find(inventTransOriginId);
                        InventTransOrigin returnInventTransOrigin = InventTransOrigin::find(returnInventTransOriginId);

                        throw Error(strFmt("@SCM:InventCostItemDimAdjustmentCheckFailureErrorMessage",
                                            inventTransOrigin ? enum2Str(inventTransOrigin.ReferenceCategory) : '',
                                            inventTransOrigin ? inventTransOrigin.ReferenceId : '',
                                            returnInventTransOrigin ? enum2Str(returnInventTransOrigin.ReferenceCategory) : '',
                                            returnInventTransOrigin ? returnInventTransOrigin.ReferenceId : '',
                                            voucherPhysical,
                                            allocatedQty,
                                            qtyTotal,
                                            allocatedAmount,
                                            amountTotal,
                                            (onHandIsAdjusted ?
                                            "@SCM:InventCostItemDimOnHandIsAdjusted" :
                                            "@SCM:InventCostItemDimOnHandIsNotAdjusted"),
                                            adjusted,
                                            adjustment));
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransIdReceiptForWIPCalc_RU</Name>
				<Source><![CDATA[
    public void updateTransIdReceiptForWIPCalc_RU(InventTransId _inventTransId,
                                                  CostAmount    _adjustment,
                                                  Voucher       _closingVoucherPhysical)
    {
        this.updateTransIdReceipt(InventTransOrigin::findByInventTransId(_inventTransId).RecId, -_adjustment, 0, _closingVoucherPhysical);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransIdReturnReceipt</Name>
				<Source><![CDATA[
    protected void updateTransIdReturnReceipt(
        InventTransOriginId     _inventTransOriginId,
        InventTransOriginId     _returnInventTransOriginId,
        Price                   _costPrice  = 0             // if 0 then it will be recalculated
        )
    {
        InventTrans         receipt;
        InventTrans         issue;

        if (!_inventTransOriginId || !_returnInventTransOriginId)
        {
            return;
        }

        if (!_costPrice)
        {
            select sum(Qty), sum(CostAmountAdjustment), sum(CostAmountPosted) from issue
                where issue.InventTransOrigin       == _returnInventTransOriginId
                  &&  issue.StatusReceipt           == StatusReceipt::None
                  &&  issue.StatusIssue             == StatusIssue::Sold
                  &&  issue.PackingSlipReturned     == 0
                  &&  issue.ReturnInventTransOrigin == _inventTransOriginId;

            if (!issue.Qty )
            {
                return;
            }

            _costPrice = (issue.CostAmountPosted + issue.CostAmountAdjustment) / issue.Qty;
        }

        boolean onHandIsAdjusted = InventAdj::isOnhandAdjusted(_inventTransOriginId, _returnInventTransOriginId, '');

        while select forupdate receipt
            where receipt.InventTransOrigin         == _inventTransOriginId
              &&  receipt.StatusReceipt             == StatusReceipt::Purchased
              &&  receipt.StatusIssue               == StatusIssue::None
              &&  receipt.PackingSlipReturned       == 0
              &&  receipt.ReturnInventTransOrigin   == _returnInventTransOriginId
              &&  receipt.DateStatus                <=  inventClosing.TransDate
        {
            CostAmount adjustNow = CurrencyExchangeHelper::amount(receipt.Qty * _costPrice - receipt.CostAmountPosted - receipt.CostAmountAdjustment, standardCurrency);

            if (adjustNow)
            {
                receipt.CostAmountAdjustment += adjustNow;

                this.createAdjustSettlement(receipt, adjustNow, '');

                // The adjustment for a standard cost item will always be
                // reverted to bring the item cost down to standard cost
                // So there is no need to create an adjustment.
                // <GEERU>
                if ((countryRegion_RU   &&  this.inventModelType_RU(receipt.ItemId).mustBeClosed()) ||
                    (!countryRegion_RU  &&  this.inventModelGroup(receipt.ItemId).inventModelType().mustBeClosed()))
                // </GEERU>
                {
                    if (onHandIsAdjusted)
                    {
                        this.createErrorAdjustment(receipt, -adjustNow);
                    }

                    if (this.costValue(receipt) < 0)
                    {
                        this.createErrorAdjustment(receipt, -adjustNow);
                    }

                    if ((inventClosing.AdjustmentType == InventAdjustmentType::Closing) &&
                        (abs(adjustNow) < inventClosing.MinTransferValue || inventClosing.NumOfIteration >= inventClosing.MaxIterations))
                    {
                        this.createErrorAdjustment(receipt, -adjustNow);
                    }
                }
                else
                {
                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        this.inventModelType_RU(receipt.ItemId).postUpdateFinancialAdjustment(receipt, inventClosing.Voucher, inventClosing.TransDate, adjustNow);
                    }
                    else
                    {
                        // </GEERU>
                        this.inventModelGroup(receipt.ItemId).inventModelType().postUpdateFinancialAdjustment(receipt, inventClosing.Voucher, inventClosing.TransDate, adjustNow);
                        // <GEERU>
                    }
                    // </GEERU>
                }

                this.updateCostAmountStd(receipt);
                this.updateReceipt(receipt);
            }

            mapInventTrans.insert(receipt.RecId, receipt);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransKeyAdjust</Name>
				<Source><![CDATA[
    protected void updateTransKeyAdjust()
    {
        InventTransOriginId     inventTransOriginId;
        InventTransOriginId     returnInventTransOriginId;
        Voucher                 voucherPhysical;
        InventBatchId           inventBatchId;
        InventSerialId          inventSerialId;

        Connection              secConnection;
        ItemId                  itemId;

        if (mapKeyAdjust)
        {
            MapIterator mi = new MapIterator(mapKeyAdjust);
            mi.begin();
            while (mi.more())
            {
                if (considerBatchAndSerialForTransferOrder)
                {
                    [inventTransOriginId, returnInventTransOriginId, voucherPhysical, inventSerialId, inventBatchId] = InventCostItemDim::string2keyAdjust(mi.key());
                }
                else
                {
                    [inventTransOriginId, returnInventTransOriginId, voucherPhysical] = InventCostItemDim::string2keyAdjust(mi.key());
                }
                if (! setSameItem.in(inventTransOriginId))
                {
                    itemId = InventTransOrigin::find(inventTransOriginId).ItemId;
                }
                else
                    itemId = inventCostList.ItemId;

                CostAmount adjustment = mapKeyAdjust.lookup(mi.key());
                using (InventClosingRecordInventDimForTransferOrderContext context = new InventClosingRecordInventDimForTransferOrderContext())
                {
                    context.inventBatchId = inventBatchId;
                    context.inventSerialId = inventSerialId;
                    secConnection = this.insertCostListTrans(itemId,inventTransOriginId, adjustment,returnInventTransOriginId,voucherPhysical,secConnection);
                }

                mi.next();
            }
            mapKeyAdjust = null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    static InventCostItemDim construct(
        InventCostHelpTaskBase  _inventCostHelpTaskBase,
        InventClosing           _inventClosing,
        InventTransCurrency_RU  _inventTransCurrency = InventTransCurrency_RU::PrimaryCur
        )
    {
        // <GEERU>
        boolean     countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        if (countryRegion_RU)
        {
            var factoryAttr = new InventTransCurrencyFactoryAttribute(_inventTransCurrency);
            var instatiationStrategy = new SysExtensionGenericInstantiation(_inventCostHelpTaskBase, _inventClosing, _inventTransCurrency);

            var instance = SysExtensionAppClassFactory::getClassFromSysAttributeWithInstantiationStrategy(classStr(InventCostItemDim),
            factoryAttr, instatiationStrategy);

            if (instance == null)
            {
                instance = new InventCostItemDim(_inventCostHelpTaskBase, _inventClosing, _inventTransCurrency);
            }
        
            return instance;
        }
        else
        {
            return new InventCostItemDim(_inventCostHelpTaskBase, _inventClosing);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>keyAdjust2String</Name>
				<Source><![CDATA[
    static str keyAdjust2String(
        InventTransOriginId _inventTransOriginId,
        InventTransOriginId _returnInventTransOriginId,
        Voucher         _voucher
        )
    {
        const str spliter = '<>';
        InventClosingRecordInventDimForTransferOrderContext context = InventClosingRecordInventDimForTransferOrderContext::current();
        if (context)
        {
            return int642str(_inventTransOriginId) + '#' + int642str(_returnInventTransOriginId) + '#' + _voucher + spliter + (context.inventSerialId ? context.inventSerialId : '') + spliter + (context.inventBatchId ? context.inventBatchId : '');
        }
        return int642str(_inventTransOriginId) + '#' + int642str(_returnInventTransOriginId) + '#' + _voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventClosing</Name>
				<Source><![CDATA[
    static InventCostItemDim newInventClosing(
        InventCostHelpTaskBase _inventCostHelpTaskBase,
        InventClosing          _inventClosing,
        InventTransCurrency_RU _inventTransCurrency = InventTransCurrency_RU::PrimaryCur
        )
    {
        // <GEERU>
        return InventCostItemDim::construct(_inventCostHelpTaskBase, _inventClosing, _inventTransCurrency);
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleRefMapKey</Name>
				<Source><![CDATA[
    static str settleRefMapKey(InventTrans _inventTrans, boolean reverseTransIds = false)
    {
        if (reverseTransIds)
            return int642str(_inventTrans.MarkingRefInventTransOrigin) + '#' + int642str(_inventTrans.InventTransOrigin);

        return int642str(_inventTrans.InventTransOrigin) + '#' + int642str(_inventTrans.MarkingRefInventTransOrigin);
    }

]]></Source>
			</Method>
			<Method>
				<Name>string2keyAdjust</Name>
				<Source><![CDATA[
    public static container string2keyAdjust(str _string)
    {
        Integer         p1,p2;
        Integer         p3,p4;
        const str       spliter = '<>';

        p1 = strFind(_string,'#',1,strLen(_string));
        p2 = strFind(_string,'#',p1+1,strLen(_string));
        p3 = strScan(_string,spliter,p2+1,strLen(_string));
        p4 = strScan(_string,spliter,p3+2,strLen(_string));
        
        InventTransOriginId inventTransOriginId = str2int64(subStr(_string,1,p1-1));
        InventTransOriginId returnInventTransOriginId = str2int64(subStr(_string,p1+1,p2-p1-1));
        Voucher voucher;
        if (InventTransferOrderRecordInventDimForCostFlight::instance().isEnabled() && p3 > 0 && p4 > 0)
        {
            voucher = subStr(_string,p2+1,p3-p2-1);
            InventSerialId inventSerialId = subStr(_string, p3+2, p4-p3-2);
            InventBatchId inventBatchId = subStr(_string, p4+2, strLen(_string)-p4-1);
            return [inventTransOriginId, returnInventTransOriginId, voucher, inventSerialId, inventBatchId];
        }
        else
        {
            voucher = subStr(_string,p2+1,strLen(_string)-p2);
            return [inventTransOriginId, returnInventTransOriginId, voucher];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts and inventory transaction.
    /// </summary>
    /// <param name="_inventTrans">
    /// The <c>InventTrans</c> to adjust.
    /// </param>
    /// <param name="_adjustment">
    /// The adjustment.
    /// </param>
    protected void adjustTrans(
        InventTrans         _inventTrans,
        CostAmount          _adjustment
        )
    {
        if (_adjustment && _inventTrans.Qty < 0)
        {
            InventTransType referenceCategory = referenceCategoryCache.getReferenceCategory(_inventTrans.InventTransOrigin);

            // adjust related receipts - according to referenceCategory
            switch (referenceCategory)
            {
                case InventTransType::QuarantineOrder:
                    // The only way to determine if the issue is transfer or scrap is to determine if there is a receipt related to the physical voucher.
                    InventTrans inventTrans;

                    select firstonly RecId from inventTrans
                    where inventTrans.InventTransOrigin == _inventTrans.InventTransOrigin
                       && inventTrans.VoucherPhysical == _inventTrans.VoucherPhysical
                       && inventTrans.StatusIssue == StatusIssue::None;

                    if (inventTrans.RecId)
                    {
                        this.addkeyAdjustment(true,_inventTrans.InventTransOrigin,_adjustment,0,_inventTrans.VoucherPhysical);
                    }
                    break;

                case InventTransType::SummedUp:
                case InventTransType::InventTransfer:
                    this.addkeyAdjustment(true,_inventTrans.transferInventTransOrigin().RecId,_adjustment,0,'');
                    break;
                // <GEERU>
                case InventTransType::TransferOrderShip:
                case InventTransType::TransferOrderReceive:
                    if (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU])
                        || _inventTrans.InventTransOrigin().isInventTransferIssue_RU())
                    {
                        boolean useContext = false;
                        InventDim transInventDim;
                        InventDimParm inventDimParm;

                        if (considerBatchAndSerialForTransferOrder)
                        {
                            inventDimParm = this.inventDimParmFinancial(this.inventDimGroupSetup(InventTable::find(_inventTrans.ItemId)));
                            transInventDim = InventDim::find(_inventTrans.inventDimId);
                            if ((inventDimParm.InventSerialIdFlag && transInventDim.inventSerialId) || (inventDimParm.InventBatchIdFlag && transInventDim.inventBatchId))
                            {
                                useContext = true;
                            }
                        }
                        if (useContext)
                        {
                            using (InventClosingRecordInventDimForTransferOrderContext context = new InventClosingRecordInventDimForTransferOrderContext())
                            {
                                if (inventDimParm.InventSerialIdFlag)
                                {
                                    context.inventSerialId = transInventDim.inventSerialId;
                                }
                                if (inventDimParm.InventBatchIdFlag)
                                {
                                    context.inventBatchId = transInventDim.inventBatchId;
                                }
                                this.addkeyAdjustment(true, _inventTrans.transferInventTransOrigin().RecId, _adjustment, 0, _inventTrans.VoucherPhysical);
                            }
                        }
                        else
                        {
                            this.addkeyAdjustment(true, _inventTrans.transferInventTransOrigin().RecId, _adjustment, 0, _inventTrans.VoucherPhysical);
                        }
                    }
                    break;
                // </GEERU>

                case InventTransType::WMSTransport:
                    this.addkeyAdjustment(true,_inventTrans.InventTransOrigin,_adjustment,0,'');
                    break;

                case InventTransType::ProdLine :
                    inventTransOrigin assemblyInventTransOrigin = _inventTrans.assemblyInventTransOrigin();
                    if (!this.isCircleAdjusment(_inventTrans, assemblyInventTransOrigin))
                    {
                        if (#PmfEnabled)
                        {
                            if (assemblyInventTransOrigin
                            && InventTable::find(assemblyInventTransOrigin.ItemId).PmfProductType == PmfProductType::BOM)
                            {
                                this.addkeyAdjustment(false,assemblyInventTransOrigin.RecId,_adjustment, 0, '');
                            }
                            else
                            {
                                this.addFormulaKeyAdjustment(_inventTrans.InventTransOrigin, _adjustment);
                            }
                        }
                        else
                        {
                            this.addkeyAdjustment(false,assemblyInventTransOrigin.RecId,_adjustment,0,'');
                        }
                        this.insertReferenceForDeferredAssemblyUpdate(assemblyInventTransOrigin, _inventTrans);
                    }
                    break;
                case InventTransType::BOMLine  :
                    assemblyInventTransOrigin = _inventTrans.assemblyInventTransOrigin();
                    this.addkeyAdjustment(false,assemblyInventTransOrigin.RecId,_adjustment,0,'');
                    this.insertReferenceForDeferredAssemblyUpdate(assemblyInventTransOrigin, _inventTrans);
                    break;
                case InventTransType::PmfProdCoBy :
                    assemblyInventTransOrigin = _inventTrans.assemblyInventTransOrigin();
                    this.insertReferenceForDeferredAssemblyUpdate(assemblyInventTransOrigin, _inventTrans);
                    break;
                case InventTransType::WHSWork:
                case InventTransType::WHSContainer:
                case InventTransType::WHSQuarantine:
                    this.addkeyAdjustment(true, _inventTrans.transferInventTransOrigin().RecId, _adjustment, 0, '');
                    break;
            }

            // adjust related receipts if ReturnInventTransOrigin is specified (returning of an issue)
            if (_inventTrans.useReturnTransToSyncCostPrice(referenceCategory))
            {
                this.addkeyAdjustment(true, _inventTrans.ReturnInventTransOrigin, _adjustment, _inventTrans.InventTransOrigin,'');
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCircleAdjusment</Name>
				<Source><![CDATA[
    private boolean isCircleAdjusment(InventTrans _inventTransIssue, InventTransOrigin _inventTransOriginReceipt)
    {
        if (CostClosingPreventReworkOrderCircleAdjustmentFlight::instance().isEnabled()
            && _inventTransOriginReceipt.ItemId == inventCostList.ItemId)
        {
            if (checkSameFinDim && !this.hasSameFinancialInventDimOnReworkOrder(_inventTransIssue, _inventTransOriginReceipt))
            {
                return false;
            }

            return this.hasTransactionSettlement(_inventTransIssue, _inventTransOriginReceipt);
            
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasTransactionLoaded</Name>
				<Source><![CDATA[
    private boolean hasTransactionLoaded(InventTransOrigin _inventTransOrigin)
    {
        if (mapInventTrans)
        {
            // The transaction is loaded in closing.
            InventTrans inventTrans;
            while select RecId from inventTrans
                where inventTrans.InventTransOrigin == _inventTransOrigin.RecId
            {
                if (mapInventTrans.exists(inventTrans.RecId))
                {
                    return true;
                }
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasTransactionSettlement</Name>
				<Source><![CDATA[
    private boolean hasTransactionSettlement(InventTrans _inventTransIssue, InventTransOrigin _inventTransOriginReceipt)
    {
        // The transaction has settlement for this closing.
        InventSettlement inventSettlement, inventSettlementIssue;
        InventTrans inventTrans;

        while select RecId from inventTrans
            where inventTrans.InventTransOrigin == _inventTransOriginReceipt.RecId
        {
            if (mapSettleQty.exists(inventTrans.RecId))
            {
                return true;
            }
        }

        InventModel inventModel = this.inventModelGroup(inventCostList.ItemId).InventModel;

        if (inventModel == InventModel::FIFO
            || inventModel == InventModel::LIFO
            || inventModel == InventModel::LIFODate)
        {
            select firstonly RecId from inventSettlement
                where inventSettlement.Voucher == inventCostList.Voucher
                exists join inventTrans
                    where inventTrans.InventTransOrigin == _inventTransOriginReceipt.RecId
                       && inventTrans.RecId == inventSettlement.TransRecId
                exists join inventSettlementIssue
                    where inventSettlementIssue.SettleTransId == inventSettlement.SettleTransId
                       && inventSettlementIssue.TransRecId == _inventTransIssue.RecId;
        }
        else
        {
            select firstonly RecId from inventSettlement
                where inventSettlement.Voucher == inventCostList.Voucher
                   && (inventSettlement.CostAmountAdjustment != 0)
                exists join inventTrans
                    where inventTrans.InventTransOrigin == _inventTransOriginReceipt.RecId
                        && inventTrans.RecId == inventSettlement.TransRecId;
        }

        if (inventSettlement.RecId != 0)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasSameFinancialInventDimOnReworkOrder</Name>
				<Source><![CDATA[
    private boolean hasSameFinancialInventDimOnReworkOrder(InventTrans _inventTransIssue, InventTransOrigin _inventTransOriginReceipt)
    {   
        if (_inventTransIssue.ItemId == _inventTransOriginReceipt.ItemId)
        {
            InventDimGroupSetup inventDimGroupSetup = this.inventDimGroupSetup(_inventTransIssue.inventTable());
            InventDimParm inventDimParmFinancial = this.inventDimParmFinancial(inventDimGroupSetup);
            InventDim inventDimCriteria = _inventTransIssue.inventDim();

            InventTrans inventTrans;
            InventDim   inventDim;

            select firstonly RecId from inventTrans
                where inventTrans.InventTransOrigin == _inventTransOriginReceipt.RecId
                #inventDimExistsJoin(inventTrans.inventDimId, inventDim, inventDimCriteria, inventDimParmFinancial);
        
            if (inventTrans.RecId)
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventTransPosting</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the financial or physical inventory transaction posting for an inventory transaction and a posting type.
    /// </summary>
    /// <param name="_inventTrans">
    ///     The inventory transaction that will be used to get the transaction posting.
    /// </param>
    /// <param name="_inventTransPostingType">
    ///     The inventory transaction posting type.
    /// </param>
    /// <param name="_voucher">
    ///     Voucher number that the transaction is attached to.
    /// </param>
    /// <param name="_transDate">
    ///     Physical or financial date that the transaction is attached to.
    /// </param>
    /// <returns>
    ///     An <c>InventTransPosting</c> record of financial or physical posting.
    /// </returns>
    protected InventTransPosting getInventTransPosting(
                InventTrans            _inventTrans,
                InventTransPostingType _inventTransPostingType,
                Voucher                _voucher,
                TransDate              _transDate)
    {
        InventTransPosting  inventTransPosting;
    
        select firstonly DefaultDimension, PostingType, IsPosted,
            LedgerDimension, PostingTypeOffset, OffsetLedgerDimension from inventTransPosting
            where inventTransPosting.Voucher                 == _voucher
               && inventTransPosting.TransDate               == _transDate
               && inventTransPosting.InventTransOrigin       == _inventTrans.InventTransOrigin
               && inventTransPosting.InventTransPostingType  == _inventTransPostingType;
    
        return inventTransPosting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTimer</Name>
				<Source><![CDATA[
    private TimeInMS getTimer()
    {
        return WinAPIServer::getTickCount() - startTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertReferenceForDeferredAssemblyUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a reference for deferred assembly update.
    /// </summary>
    /// <param name="_inventTransOrigin">
    /// The <c>InventTransOrigin</c> for the assembly.
    /// </param>
    /// <param name="_inventTrans">
    /// The <c>InventTrans</c> related to the assembly.
    /// </param>
    /// <remarks>
    /// The deferred assembly update calculates variances for ended production orders.
    /// </remarks>
    private void insertReferenceForDeferredAssemblyUpdate(
        InventTransOrigin  _inventTransOrigin,
        InventTrans        _inventTrans
        )
    {
        InventCostListAssembly      costListAssembly;
        UserConnection              connection;
        Integer                     logPointBegin;

        if (_inventTrans.StatusIssue <= StatusIssue::Sold &&
            _inventTrans.StatusReceipt <= StatusReceipt::Purchased &&
            this.inventModelGroup(_inventTransOrigin.ItemId).inventModelType().stdCostBased())
        {
            try
            {
                select firstonly RecId
                    from costListAssembly
                        where costListAssembly.InventClosing == inventClosing.RecId
                           && costListAssembly.inventTransOrigin == _inventTransOrigin.RecId;

                if (!costListAssembly)
                {
                    logPointBegin = infologLine();

                    InventTrans assemblyInventTrans = InventTrans::findByInventTransOrigin(_inventTransOrigin.RecId);
                    connection = new UserConnection();
                    connection.ttsbegin();

                    costListAssembly.setConnection(connection);
                    costListAssembly.inventClosing     = inventClosing.RecId;
                    costListAssembly.inventTransOrigin = _inventTransOrigin.RecId;
                    costListAssembly.itemId            = _inventTransOrigin.itemId;
                    costListAssembly.ReferenceId       = _inventTransOrigin.referenceId;
                    costListAssembly.ReferenceCategory = _inventTransOrigin.ReferenceCategory;
                    costListAssembly.CostGroupId       = this.inventTable(_inventTransOrigin.ItemId).costGroup();
                    costListAssembly.ModelGroupId      = this.inventModelGroup(_inventTransOrigin.ItemId).ModelGroupId;
                    costListAssembly.DateFinancial     = assemblyInventTrans.DateFinancial;
                    costListAssembly.DefaultDimension  = assemblyInventTrans.dimensionFinancialDefaultDimension();
                    costListAssembly.insert();
                    connection.ttscommit();
                }
            }
            catch (Exception::DuplicateKeyException)
            {
                if (connection != null)
                {
                    connection.ttsabort();
                }
                infolog.cut(logPointBegin + 1, infologLine());
            }
            finally
            {
                if (connection != null)
                {
                    connection.finalize();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransId</Name>
				<Source><![CDATA[
    protected InventTransId inventTransId(InventTransOriginId _inventTransOrigin)
    {
        if (!mapInventTransId.exists(_inventTransOrigin))
        {
            mapInventTransId.insert(_inventTransOrigin, InventTransOrigin::find(_inventTransOrigin).InventTransId);
        }

        return mapInventTransId.lookup(_inventTransOrigin);
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemGroupId</Name>
				<Source><![CDATA[
    protected ItemGroupId itemGroupId(ItemId _itemId)
    {
        if (!mapItemGroupId.exists(_itemId))
        {
            mapItemGroupId.insert(_itemId, this.inventTable(_itemId).itemGroupId());
        }

        return mapItemGroupId.lookup(_itemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadTmpInventModel</Name>
				<Source><![CDATA[
    protected void loadTmpInventModel()
    {
        boolean             physicalDateCriteria;

        if (this.considerPhysicalTransactions(this.inventModelGroup(inventCostList.ItemId)))
        {
            physicalDateCriteria    = true;
        }

        MapEnumerator mapEnumerator = mapInventTrans.getEnumerator();
        while (mapEnumerator.moveNext())
        {
            InventTrans inventTrans = mapEnumerator.currentValue();

            Qty openQty = this.inventTransFinancialOpenQty(inventTrans);

            PdsCWInventQty cwOpenQty = this.inventTranspdsCWFinancialOpenQty(inventTrans);

            // checks if openQty has wrong sign - could be the case as a result of increased precision introduced in version 3.0 SP3
            if ( (inventTrans.Qty > 0 && openQty < 0 && openQty > - InventAdj::settleQtyDiff(true)) ||
                    (inventTrans.Qty < 0 && openQty > 0 && openQty <   InventAdj::settleQtyDiff(true)))
            {
                this.createErrorQtySettled(inventTrans,openQty, cwOpenQty);
                openQty = inventTrans.financialOpenQty();
            }

            if (abs(openQty) >= InventAdj::settleQtyDiff())
            {
                tmpInventModel.Direction    = inventTrans.Qty >= 0 ? InventDirection::Receipt : InventDirection::Issue;
                if (physicalDateCriteria)
                {
                    tmpInventModel.TransDate    = inventTrans.DatePhysical;
                }
                else
                {
                    tmpInventModel.TransDate    = inventTrans.DateFinancial;
                }
                tmpInventModel.TransRecId   = inventTrans.RecId;
                tmpInventModel.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLoadCount</Name>
				<Source><![CDATA[
    public InventCostLoadCount parmLoadCount()
    {
        return loadCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLoadTime</Name>
				<Source><![CDATA[
    public InventCostLoadTime parmLoadTime()
    {
        return loadTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLoadTransferOrderCount</Name>
				<Source><![CDATA[
    public InventCostLoadTransferOrderCount parmLoadTransferOrderCount()
    {
        return loadTransferOrderCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLoadTransferOrderTime</Name>
				<Source><![CDATA[
    public InventCostLoadTransferOrderTime parmLoadTransferOrderTime()
    {
        return loadTransferOrderTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPreCloseNonFinancialCount</Name>
				<Source><![CDATA[
    public InventCostPreCloseNonFinancialCount parmPreCloseNonFinancialCount()
    {
        return preCloseNonFinancialCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPreCloseNonFinancialTime</Name>
				<Source><![CDATA[
    public InventCostPreCloseNonFinancialTime parmPreCloseNonFinancialTime()
    {
        return preCloseNonFinancialTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPreCloseTransferOrderCount</Name>
				<Source><![CDATA[
    public InventCostPreCloseTransferOrderCount parmPreCloseTransferOrderCount()
    {
        return preCloseTransferOrderCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPreCloseTransferOrderTime</Name>
				<Source><![CDATA[
    public InventCostPreCloseTransferOrderTime parmPreCloseTransferOrderTime()
    {
        return preCloseTransferOrderTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateLevelAdjustmentCount</Name>
				<Source><![CDATA[
    public InventCostUpdateLevelAdjustmentCount parmUpdateLevelAdjustmentCount()
    {
        return updateLevelAdjustmentCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateLevelAdjustmentTime</Name>
				<Source><![CDATA[
    public InventCostUpdateLevelAdjustmentTime parmUpdateLevelAdjustmentTime()
    {
        return updateLevelAdjustmentTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateMarkingCount</Name>
				<Source><![CDATA[
    public InventCostUpdateMarkingCount parmUpdateMarkingCount()
    {
        return updateMarkingCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateMarkingTime</Name>
				<Source><![CDATA[
    public InventCostUpdateMarkingTime parmUpdateMarkingTime()
    {
        return updateMarkingTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateModelCount</Name>
				<Source><![CDATA[
    public InventCostUpdateModelCount parmUpdateModelCount()
    {
        return updateModelCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateModelTime</Name>
				<Source><![CDATA[
    public InventCostUpdateModelTime parmUpdateModelTime()
    {
        return updateModelTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateReceiptAdjustmentCount</Name>
				<Source><![CDATA[
    public InventCostUpdateReceiptAdjustmentCount parmUpdateReceiptAdjustmentCount()
    {
        return updateReceiptAdjustmentCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateReceiptAdjustmentTime</Name>
				<Source><![CDATA[
    public InventCostUpdateReceiptAdjustmentTime parmUpdateReceiptAdjustmentTime()
    {
        return updateReceiptAdjustmentTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateReturnAdjustmentsCount</Name>
				<Source><![CDATA[
    public InventCostUpdateReturnAdjustmentsCount parmUpdateReturnAdjustmentsCount()
    {
        return updateReturnAdjustmentsCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateReturnAdjustmentsTime</Name>
				<Source><![CDATA[
    public InventCostUpdateReturnAdjustmentsTime parmUpdateReturnAdjustmentsTime()
    {
        return updateReturnAdjustmentsTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOpenInventTransCount</Name>
				<Source><![CDATA[
    public InventCostInventTransCount parmOpenInventTransCount()
    {
        return openInventTransCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmClosedInventTransCount</Name>
				<Source><![CDATA[
    public InventCostInventTransCount parmClosedInventTransCount()
    {
        return closedInventTransCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>preCloseItem</Name>
				<Source><![CDATA[
    private Enumerator preCloseItem()
    {
        Enumerator      inventDimEnumerator;

        mapKeyAdjust        = null;
        setSameItem         = new Set(Types::Int64);
        mapOpenIssue        = new Map(Types::Int64, Types::Record);
        commitCount         = 0;

        this.initMaps();

        InventTable inventTable = this.inventTable(inventCostList.ItemId);

        if (inventTable.modelGroup().inventModelType().mustBeClosed() == true &&
            inventTable.inventItemType().isServiceItem() == false &&
            inventCostListParm.HasReceipts &&
            inventCostListParm.HasIssues)
        {
            if (countryRegion_RU || inventClosing.InventTransCurrency_RU == InventTransCurrency_RU::SecondaryCur)
            {
                boolean reInitMaps = false;
                inventDimEnumerator = this.getFinDimCombinationEnumerator(inventTable);

                while (inventDimEnumerator.moveNext())
                {
                    InventDim inventDim = inventDimEnumerator.current();

                    this.initMaps();

                    this.startTimer();
                    this.load(inventDim, true);
                    loadTime+=this.getTimer();
                    loadCount++;

                    this.startTimer();
                    this.preCloseNonFinancial();
                    preCloseNonFinancialTime+=this.getTimer();
                    preCloseNonFinancialCount++;

                    reInitMaps = true;
                }

                if (reInitMaps)
                {
                    this.initMaps();
                }
            }
            else
            {
                this.startTimer();
                this.preCloseNonFinancialOnServer(inventTable);
                preCloseNonFinancialTime+=this.getTimer();
                preCloseNonFinancialCount++;
            }
        }

        return inventDimEnumerator;
    }

]]></Source>
			</Method>
			<Method>
				<Name>preCloseNonFinancialOnServer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Pre-close non financial transaction for the specified <c>InventTable</c> using a stored
    /// procedure on server.
    /// </summary>
    /// <param name="_inventTable">
    /// The <c>InventTable</c> buffer for which transactions to pre-close.
    /// </param>
    private void preCloseNonFinancialOnServer(InventTable _inventTable)
    {
        int                             errorOutput = 0;

        InventDimParm inventDimParm = this.inventDimParmFinancial(this.inventDimGroupSetup(_inventTable));

        str sqlStmt = InventCostPreCloseNonFinTransferHelper::buildSPCallStmt(_inventTable, inventDimParm, inventClosing);

        Connection connection = new Connection();
        Statement statement = connection.createStatement();

        SqlStatementExecutePermission permission = new SqlStatementExecutePermission(sqlStmt);
        permission.assert();

        ResultSet resultSet;
        #OCCRetryCount

        try
        {
            resultSet = statement.executeQueryWithParameters(sqlStmt, SqlParams::create());
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (ReqTransientSqlConnectionErrorHandlingHelper::retryTransientSqlConnectionError())
            {
                retry;
            }
            else
            {
                throw;
            }
        }
        catch (Exception::Error)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::Error;
            }
            else
            {
                retry;
            }
        }

        if (!resultSet.next())
        {
            throw error("@SYS99562");
        }
        errorOutput = resultSet.getInt(1);

        if (errorOutput)
        {
            throw error("@SYS99562");
        }

        permission = null;
        connection = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>startTimer</Name>
				<Source><![CDATA[
    private void startTimer()
    {
        startTime = WinAPIServer::getTickCount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initQueryRunTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the query that determines which financial dimensions that needs to be processed for the specified item.
    /// </summary>
    /// <param name="_inventTable">
    /// The <c>InventTable</c> record for the item.
    /// </param>
    /// <param name="_inventModelGroup">
    /// An <c>InventModelGroup</c> record related to the item.
    /// </param>
    /// <returns>
    /// A <c>QueryRun</c> object.
    /// </returns>
    protected QueryRun initQueryRunTrans(InventTable _inventTable, InventModelGroup _inventModelGroup)
    {
        QueryRun                    queryRun;
        QueryBuildDataSource        qbsTrans;

        StatusReceipt               statusReceipt = StatusReceipt::Purchased;
        StatusIssue                 statusIssue   = StatusIssue::Sold;

        if (this.considerPhysicalTransactions(_inventModelGroup))
        {
            statusReceipt = StatusReceipt::Received;
            statusIssue   = StatusIssue::Deducted;
        }

        if (! mapQueryRun)
        {
            mapQueryRun = new Map(Types::String, Types::Class);
        }

        InventDimGroupSetup inventDimGroupSetup = this.inventDimGroupSetup(_inventTable);
        if (! mapQueryRun.exists(inventDimGroupSetup.hashString()))
        {
            // query
            Query query = new Query();
            query.literals(2);

            // InventDim
            QueryBuildDataSource qbsDim = query.addDataSource(tableNum(InventDim));
            qbsDim.update(false);
            qbsDim.fetchMode(0);

            this.inventDimParmFinancial(inventDimGroupSetup).queryAddSortField(qbsDim);
            // To make sure we only return one row, if there are no financial dimensions
            qbsDim.addSelectionField(fieldNum(InventDim,RecId),SelectionField::Count);

            qbsDim.addSortIndex(indexNum(InventDim,DimIdIdx));
            qbsDim.indexIsHint(true);

            // InventTrans
            qbsTrans = qbsDim.addDataSource(tableNum(InventTrans));
            qbsTrans.update(false);
            qbsTrans.joinMode(JoinMode::ExistsJoin);
            qbsTrans.relations(true);

            this.addCurrencyTypeRangeToTrans(qbsTrans);

            qbsTrans.addRange(fieldNum(InventTrans,ItemId)).value(queryValue(_inventTable.ItemId));
            qbsTrans.addRange(fieldNum(InventTrans,StatusIssue)).value(SysQuery::range(queryValue(StatusIssue::None),queryValue(statusIssue)));
            qbsTrans.addRange(fieldNum(InventTrans,StatusReceipt)).value(SysQuery::range(queryValue(StatusReceipt::None),queryValue(statusReceipt)));
            qbsTrans.addRange(fieldNum(InventTrans,DateStatus)).value(SysQuery::range(dateNull(), inventClosing.TransDate));

            qbsTrans.addSortIndex(indexNum(InventTrans,OpenItemIdx));
            qbsTrans.indexIsHint(true);

            // queryRun
            queryRun = new QueryRun(query);

            mapQueryRun.insert(inventDimGroupSetup.hashString(),queryRun);
        }
        else
        {
            queryRun = mapQueryRun.lookup(inventDimGroupSetup.hashString());
            queryRun.reset();

            qbsTrans = queryRun.query().dataSourceTable(tableNum(InventTrans));
            qbsTrans.findRange(fieldNum(InventTrans,ItemId)).value(queryValue(_inventTable.ItemId));
            qbsTrans.findRange(fieldNum(InventTrans,StatusIssue)).value(SysQuery::range(queryValue(StatusIssue::None),queryValue(statusIssue)));
            qbsTrans.findRange(fieldNum(InventTrans,StatusReceipt)).value(SysQuery::range(queryValue(StatusReceipt::None),queryValue(statusReceipt)));
        }

        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCurrencyTypeRangeToTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds range value to transaction transactions datasource.
    /// </summary>
    /// <param name = "_qbsTrans">The instance of <c>QueryBuildDataSource</c> class with <c>InventTrans</c> table as a source.</param>
    protected void addCurrencyTypeRangeToTrans(QueryBuildDataSource _qbsTrans)
    {
        if (inventTransCurrency == InventTransCurrency_RU::PrimaryCur)
        {
            _qbsTrans.addRange(fieldNum(InventTrans, ValueOpen)).value(queryValue(InventTransOpen::Yes));
        }
        else if (inventTransCurrency == InventTransCurrency_RU::SecondaryCur)
        {
            _qbsTrans.addRange(fieldNum(InventTrans, ValueOpenSecCur_RU)).value(queryValue(InventTransOpen::Yes));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimGroupSetup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns an instance <c>InventDimGroupSetup</c> class for the specified <c>InventTable</c> record.
    /// </summary>
    /// <param name="_inventTable">
    /// The <c>InventTable</c> record.
    /// </param>
    /// <returns>
    /// Returns an instance <c>InventDimGroupSetup</c> class.
    /// </returns>
    protected InventDimGroupSetup inventDimGroupSetup(InventTable _inventTable)
    {
        InventDimGroupSetup inventDimGroupSetup;

        if (! mapInventDimGroupSetup)
        {
            mapInventDimGroupSetup = new Map(Types::String,Types::Class);
        }

        if (mapInventDimGroupSetup.exists(_inventTable.ItemId))
        {
            inventDimGroupSetup = mapInventDimGroupSetup.lookup(_inventTable.ItemId);
        }
        else
        {
            inventDimGroupSetup = InventDimGroupSetup::newInventTable(_inventTable);
            mapInventDimGroupSetup.insert(_inventTable.ItemId, inventDimGroupSetup);
        }

        return inventDimGroupSetup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmFinancial</Name>
				<Source><![CDATA[
    protected InventDimParm inventDimParmFinancial(InventDimGroupSetup _inventDimGroupSetup)
    {
        InventDimParm   inventDimParm;

        if (! mapInventDimParm)
        {
            mapInventDimParm = new Map(Types::String,Types::Record);
        }

        if (mapInventDimParm.exists(_inventDimGroupSetup.hashString()))
        {
            inventDimParm = mapInventDimParm.lookup(_inventDimGroupSetup.hashString());
        }
        else
        {
            _inventDimGroupSetup.inventDimParmActiveFinancialInventory(inventDimParm);
            mapInventDimParm.insert(_inventDimGroupSetup.hashString(), inventDimParm);
        }

        return inventDimParm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>considerPhysicalTransactions</Name>
				<Source><![CDATA[
    protected boolean considerPhysicalTransactions(InventModelGroup _inventModelGroup)
    {
        boolean ret;

        if (_inventModelGroup.InclPhysicalValueInCost)
        {
            InventModel inventModel = _inventModelGroup.InventModel;

            if ( inventModel == InventModel::AverageCost ||
                 inventModel == InventModel::AverageCostDate ||
                 inventModel == InventModel::MonthlyAverageCost)
            {
                if (isInventCostRecalcIncludePhysicalValueForAverageModelFeatureEnabled &&
                    _inventModelGroup.InventCostRecalcIncludePhysicalValueForAverageModel &&
                    inventClosing.AdjustmentType == InventAdjustmentType::Recalculation)
                {
                    using (var activityContext = this.instrumentationLogger().includePhysicalValueForAverageModelActivities().includePhysicalValueForAverageModel(true))
                    {
                        ret = true;
                    }
                }
            }
            else
            {
                ret = true;
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>needSkipOverAdjustment</Name>
				<Source><![CDATA[
    private boolean needSkipOverAdjustment()
    {
        boolean skipOverAdjustment = false;

        if (inventClosing.AdjustmentType == InventAdjustmentType::Recalculation)
        {
            InventModelGroup inventModelGroup = this.inventModelGroup(inventCostList.ItemId);

            boolean InventCostRecalculationSkipOverAdjustmentIsEnabled =
            InventCostRecalculationSkipOverAdjustmentFlight::instance().isEnabled() ||
            (isInventCostRecalcIncludePhysicalValueForAverageModelFeatureEnabled &&
             inventModelGroup.InventCostRecalcIncludePhysicalValueForAverageModel);

            InventModel inventModel = this.getInventModel();

            // Skip over adjustment for weight average cost model when including physical value is checked
            if ((inventModel == InventModel::AverageCost ||
                inventModel == InventModel::AverageCostDate ||
                inventModel == InventModel::MonthlyAverageCost) &&
                inventModelGroup.InclPhysicalValueInCost &&
                InventCostRecalculationSkipOverAdjustmentIsEnabled)
            {
                skipOverAdjustment = true;
            }
        }

        return skipOverAdjustment;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>