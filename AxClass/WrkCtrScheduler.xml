<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WrkCtrScheduler</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>WrkCtrScheduler</c> class implements the base functionality for job scheduling.
/// </summary>
/// <remarks>
///    This class can be specialized to implement specific job scheduling needs, such as production orders
///    scheduling.
/// </remarks>
class WrkCtrScheduler implements Microsoft.Dynamics.AX.Planning.JobScheduling.IWrkCtrScheduler
{
    #OCCRetryCount

    WrkCtrSchedulerEngineInterface  scheduleEngine;
    WrkCtrSchedulerRuntimes         wrkCtrSchedulerRuntimes;

    WrkCtrCapacityConflictHandlerInterface capacityConflictHandler;

    List                            listWrkCtrParmSchedule;
    Set                             setRescheduleQueue;
    boolean                         resetWorkingTimesCacheForEachRun;
    boolean                         needRereadJob;
    private boolean                 isRunningMultipleWrkCtrSchedulerInstances;

    Map                             masterData;                 // Key = this.keyMaster, Value = Record
    Map                             masterDataParms;            // Key = master data id, Value = WrkCtrParmSchedule
    Map                             routeData;                  // Key = this.keyRoute, Value = Record
    Map                             masterDataJobRecId;         // Key = RecId, Value = Record
    Map                             jobData;                    // Key = RecId, Value = Record
    Map                             mapOrderData;               // Key = RefId, Value = [fromDate, fromTime, toDate, toTime]
    Map                             mapOperationData;           // Key = RefId, Value = [fromDate, fromTime, toDate, toTime, resourceId]
    Map                             mapUpdatedOrders;
    Set                             temporaryJobs;              // Temporary jobs that are deleted after scheduling. Key = RecId.
    Set                             temporaryOperations;        // Temporary operations that are deleted after scheduling. Key = RecId.
    Set                             constraintJobs;             // Jobs merely added to form constraints. Key = RecId 

    Set                             loadedResources;
    Set                             loadedResourceGroups;
    Set                             loadedCalendars;
    Map                             loadedWorkingTimesToDate;   // Key = Resource, Value = transDate

    Common                          tmpRoute;

    Map                             oprEndPointJobIds;          // Key = (RefId, OprNum), Value = [firstJobRecId, lastJobRecId]
    Map                             oprProcessJobIds;
    Map                             oprOverlapJobIds;           // Key = this.keyRoute(), Value = Overlap job RecId
    Map                             overlapJobLinks;
    Map                             processScheduleResult;      // Key = this.keyRoute(), Value = scheduled process job time
    Map                             overlapScheduleResult;      // Key = this.keyRoute(), Value = scheduled overlap job time
    Map                             mapParallelJobs;

    FieldId                         routeRefIdField;
    FieldId                         refIdField;
    FieldId                         routeOprNumField;
    List                            capacityReservationsSaveList;
    RecordInsertList                capacityReservationsInsertList;
    RefRecId                        reqPlanVersionRefRecId;
    boolean                         initialized;
    Map                             jobCapResProperties;
    Set                             routeLessRecordSet;

    // map used in overlap constraint to store all jobs
    // between the overlap job and the next process job. Key = this.KeyRoute(RefId, OprNum, OprPriority); Value = List<JobRecId>
    Map                             overlapSucessorJobs;

    Map                             mapPreviouslyUsedResources;
    UserConnection                  saveReservationsConnection;

    WrkCtrApplicableResourceListCache   wrkCtrApplicableResourceListCache;

    boolean                         schedulingErrorOccured;
    boolean                         checkLockingTTSLevel;

    boolean                         usePlanVersion;
    WrkCtrCapResHandler             wrkCtrCapResHandler;
    WrkCtrCapResTimestamp           timestamp;
    WrkCtrCapResConflictCheckIntervals wrkCtrCapResConflictCheckIntervals;
    RouteJobNumType                 overlapNumType;
    RouteJobNumType                 processNumType;

    Map                             mapOrderExclusiveJobsToSchedule; // Key = wrkCtrParmSchedule.schedNumId, Value = Set of RecId
    boolean                         hasOverlapJob;
    boolean                         canUpdateCompletedRoute;

    boolean                         finiteCapacityUsed;
    private boolean                 canUseSeparateConnection;
    private boolean                 hasRunCleanupOfTerminatedSessions;
    private static boolean          hasRunCleanupOfTerminatedSessionsStatic;
    private boolean                 isPreventCleanupDeadlockToggleEnabled;
    private boolean inconsistentDataSchedulingErrorOccured;

    private const int               TimeoutErrorLikelyCausedByResourceCombinationThreshold = 2000;
    private Set                     timeoutErrorLikelyCausedByResourceCombination;
    protected OprNum	            oprNumDerivedLatestMaterialAvailability;
    protected BOMRefRecId	        bomRefRecIdDerivedLatestMaterialAvailability;

    Microsoft.Dynamics.AX.Planning.JobScheduling.LoggingOptions loggingOptions;

    #TimeConstants
    #WrkCtrScheduler

    #define.ScheduleEngineRun('ScheduleEngineRun')
    #define.CreateEngine('CreateEngine')
    #define.LoadData('LoadData')
    #define.SaveData('SaveData')
    #define.EmptyResource('EmptyRes')
    #define.MaxRetry(42)
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addExclusiveJobToSchedule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a job to an exclusive list of jobs of a certain order that should be scheduled.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// The scheduling parameters.
    /// </param>
    /// <param name="_jobId">
    /// The ID of the job to be scheduled.
    /// </param>
    public void addExclusiveJobToSchedule(WrkCtrParmSchedule _wrkCtrParmSchedule, RecId _jobId)
    {
        Set                 exclusiveJobsToSchedule;
        InventTransRefId    orderId = _wrkCtrParmSchedule.schedNumId();

        if (!mapOrderExclusiveJobsToSchedule.exists(orderId))
        {
            exclusiveJobsToSchedule = new Set(Types::Int64);
            mapOrderExclusiveJobsToSchedule.insert(orderId, exclusiveJobsToSchedule);
        }
        else
        {
            exclusiveJobsToSchedule = mapOrderExclusiveJobsToSchedule.lookup(orderId);
        }

        exclusiveJobsToSchedule.add(_jobId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addGroupProperties</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the required properties to a property map.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> object that contains scheduling settings.
    /// </param>
    /// <param name="_propertiesMap">
    /// A <c>Map</c> object to which the required properties should be added.
    /// </param>
    /// <param name="_prodUnitId">
    /// A production unit ID that should be added as required property to the map.
    /// </param>
    /// <param name="_inputWarehouse">
    /// A input warehouse ID that should be added as required property to the map.
    /// </param>
    protected void addGroupProperties(WrkCtrParmSchedule     _wrkCtrParmSchedule,
                                      Map                    _propertiesMap,
                                      ProdUnitId             _prodUnitId,
                                      InventLocationIdInput  _inputWarehouse)
    {
        if (_prodUnitId)
        {
            _propertiesMap.insert(WrkCtrSchedulingProperty::prodUnitSchedulingProperty(_prodUnitId), 0.0);
        }

        if (_inputWarehouse)
        {
            _propertiesMap.insert(WrkCtrSchedulingProperty::inputWarehouseSchedulingProperty(_inputWarehouse), 0.0);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForHighNumberOfResourceCombinations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for high number of resource combinations. Orders with high number of combinations is 
    /// added to the <c>timeoutErrorLikelyCausedByResourceCombination</c> set.
    /// </summary>
    /// <param name = "_wrkCtrParmSchedule">A work schedule.</param>
    /// <param name = "_wrkCtrActivityRequirementSet">An activity requirements.</param>
    /// <param name = "_resourceList">A Resource list.</param>
    [Hookable(false)]
    protected void checkForHighNumberOfResourceCombinations(
        WrkCtrParmSchedule           _wrkCtrParmSchedule,
        WrkCtrActivityRequirementSet _wrkCtrActivityRequirementSet,
        List                          _resourceList)
    {
        if (_wrkCtrActivityRequirementSet.Quantity > _resourceList.elements() &&
            _wrkCtrActivityRequirementSet.Quantity * _resourceList.elements() >= TimeoutErrorLikelyCausedByResourceCombinationThreshold)
        {
            timeoutErrorLikelyCausedByResourceCombination.add(_wrkCtrParmSchedule.schedNumId());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addInfologMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds an Infolog entry for an order that failed scheduling.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> object that contains the order scheduling parameters.
    /// </param>
    /// <param name="_jobSchedulingError">
    /// A <c>WrkCtrJobSchedulingError</c> value indicating the error to report; optional.
    /// If the parameter value is <c>WrkCtrJobSchedulingError::None</c> then a call is
    /// made to the scheduling engine in order to get the scheduling error.
    /// </param>
    /// <param name="_infologMessage">
    /// A string that should be placed in the Infolog as error or info.
    /// </param>
    /// <param name="_common">
    /// A <c>Common</c> table buffer that identifies the record that triggered the failure.
    /// </param>
    /// <param name="_throwError">
    /// true if an error should be thrown; false if the message should be added as an info.
    /// </param>
    protected void addInfologMessage(WrkCtrParmSchedule         _wrkCtrParmSchedule,
                                     WrkCtrJobSchedulingError   _jobSchedulingError = WrkCtrJobSchedulingError::None,
                                     str                        _infologMessage     = '',
                                     Common                     _common             = null,
                                     boolean                    _throwError         = true)
    {
        int64                       jobId;
        WrkCtrJobSchedulingError    jobSchedulingError;
        str                         prefix;
        Common                      common = _common;
        int64                       firstErrorJobId;
        str                         errorString;
        int                         solutionConstraintLevel;

        if (_jobSchedulingError == WrkCtrJobSchedulingError::None)
        {
            if (masterDataJobRecId.exists(_wrkCtrParmSchedule.schedNumId()))
            {
                jobId = masterDataJobRecId.lookup(_wrkCtrParmSchedule.schedNumId());

                // get the job scheduling error information for the entire sequence
                [jobSchedulingError, firstErrorJobId, solutionConstraintLevel] = scheduleEngine.getJobSchedulingSequenceResult(jobId);
            }
        }
        else
        {
            jobSchedulingError = _jobSchedulingError;
        }

        // get the job in order to get the operation number.
        if (!_common &&
            jobData.exists(firstErrorJobId))
        {
            common = jobData.lookup(firstErrorJobId);
        }

        prefix = this.infologPrefixOprNum(common);
        setPrefix(prefix);

        switch (jobSchedulingError)
        {
            case WrkCtrJobSchedulingError::NotEnoughCapacity:
            case WrkCtrJobSchedulingError::NoMatchingResources:
            case WrkCtrJobSchedulingError::Timeout:
            case WrkCtrJobSchedulingError::CyclicGraph:
            case WrkCtrJobSchedulingError::InternalError:
                inconsistentDataSchedulingErrorOccured = jobSchedulingError == WrkCtrJobSchedulingError::Timeout ? false : true;
                errorString = strFmt("%1 %2", _infologMessage, jobSchedulingError);

                if (jobSchedulingError == WrkCtrJobSchedulingError::Timeout &&
                    timeoutErrorLikelyCausedByResourceCombination.in(_wrkCtrParmSchedule.schedNumId()))
                {
                    errorString = strFmt("%1. %2", errorString, "@SCM:WrkCtrScheduler_TimeoutErrorLikelyCausedByResourceCombination");
                }

                this.setSchedulingErrorOccured();

                if (_throwError)
                {
                    throw error(errorString);
                }
                else
                {
                    error(errorString);
                }
                break;

            case WrkCtrJobSchedulingError::None:
            default:
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addInfologMessages</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds Infolog messages for the orders that failed scheduling and that have not been added to the
    ///    reschedule queue.
    /// </summary>
    /// <param name="_lstWrkCtrParmSchedule">
    ///    A list of order schedule parameters to check for successful scheduling and to add Infolog messages
    ///    for errors.
    /// </param>
    protected void addInfologMessages(List _lstWrkCtrParmSchedule)
    {
        ListEnumerator      listEnumerator = _lstWrkCtrParmSchedule.getEnumerator();
        WrkCtrParmSchedule  wrkCtrParmSchedule;

        while (listEnumerator && listEnumerator.moveNext())
        {
            wrkCtrParmSchedule = listEnumerator.current();
            if (!mapOrderData.exists(wrkCtrParmSchedule.schedNumId()) &&
                !setRescheduleQueue.in(wrkCtrParmSchedule))
            {
                this.addInfologMessage(wrkCtrParmSchedule);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ordersDescription</Name>
				<Source><![CDATA[
    /// <summary>
    /// Concatenates order references into a single delimited string.
    /// </summary>
    /// <param name = "_listWrkCtrParmSchedule">The list of orders.</param>
    /// <returns>The concatenated string of references.</returns>
    protected str ordersDescription(List _listWrkCtrParmSchedule)
    {
        ListEnumerator      listEnumerator = _listWrkCtrParmSchedule.getEnumerator();
        WrkCtrParmSchedule  wrkCtrParmSchedule;
        str result;

        while (listEnumerator && listEnumerator.moveNext())
        {
            wrkCtrParmSchedule = listEnumerator.current();

            if (result)
            {
                result += ', ';
            }
            result += wrkCtrParmSchedule.schedNumId();
        }
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addJobToOverlapJobList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a job to the overlap job list to be included when emitting the overlap constraint.
    /// </summary>
    /// <param name="_routeJobMap">
    /// A <c>RouteJobMap</c> instance that contains the job data.
    /// </param>
    /// <param name="_oprNumNext">
    /// The next operation number.
    /// </param>
    /// <remarks>
    /// Jobs after the overlap job are added to the next operation job list.Jobs before the process job are
    /// added to the current operation list.Jobs are added regardless of their priority.
    /// </remarks>
    protected void addJobToOverlapJobList(RouteJobMap   _routeJobMap,
                                          OprNumNext    _oprNumNext)
    {
        str routeKey;
        List sucessorJobsList;

        if (_routeJobMap.NumType > overlapNumType)
        {
            routeKey = this.keyRoute(_routeJobMap.RefId, _oprNumNext, RouteOprPriority::Primary);
        }

        if (_routeJobMap.NumType < processNumType)
        {
            routeKey = this.keyRoute(_routeJobMap.RefId, _routeJobMap.OprNum, RouteOprPriority::Primary);
        }

        if (routeKey)
        {
            if (overlapSucessorJobs.exists(routeKey))
            {
                sucessorJobsList = overlapSucessorJobs.lookup(routeKey);
            }
            else
            {
                sucessorJobsList = new List(Types::Int64);
                overlapSucessorJobs.insert(routeKey, sucessorJobsList);
            }

            sucessorJobsList.addEnd(_routeJobMap.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addPropertyAggregations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds property aggregations to the scheduling engine.
    /// </summary>
    protected void addPropertyAggregations()
    {
        scheduleEngine.addPropertyToGroupAggregation(WrkCtrSchedulingProperty::capabilityPropertyPrefix());
        scheduleEngine.addPropertyToGroupAggregation(WrkCtrSchedulingProperty::wrkctrTypePropertyPrefix());
    }

]]></Source>
			</Method>
			<Method>
				<Name>addResourceGroupMembership</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds resource to resource group membership records to the scheduling engine data model.
    /// </summary>
    /// <param name="_resourceId">
    /// A <c>WrkCtrId</c> value that identifies the resource to add the membership information for.
    /// </param>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>wrkCtrParmSchedule</c> object with the order scheduling parameters.
    /// </param>
    protected void addResourceGroupMembership(WrkCtrId _resourceId, WrkCtrParmSchedule _wrkCtrParmSchedule)
    {
        var wrkCtrResourceGroupResource = WrkCtrTable::resourceGroupResource(_resourceId, dateNull(), dateMax());

        // Add all groups current resource may belong to
        while (wrkCtrResourceGroupResource)
        {
            var wrkCtrResourceGroup = WrkCtrResourceGroup::find(wrkCtrResourceGroupResource.ResourceGroup);
            var groupName = wrkCtrResourceGroup.WrkCtrId;
            if (!loadedResourceGroups.in(groupName))
            {
                var wrkCtrGroup = WrkCtrTable::find(groupName);
                var limitedCapacityEndDate = this.limitedCapacityToDate(_wrkCtrParmSchedule, wrkCtrGroup, dateMax());
                scheduleEngine.addResourceGroup(
                                                groupName,
                                                (wrkCtrGroup.OperationSchedPct/100.0),
                                                (wrkCtrGroup.CapLimited == NoYes::Yes),
                                                DateTimeUtil::newDateTime(limitedCapacityEndDate,0));
                loadedResourceGroups.add(groupName);

                // Add all resources that may belong to the resource group.
                var resourceGroupMember = WrkCtrResourceGroupResource::resourceGroupMembers(wrkCtrResourceGroupResource.ResourceGroup, dateNull(), dateMax());
                while (resourceGroupMember)
                {
                    if (!loadedResources.in(resourceGroupMember.WrkCtrId))
                    {
                        this.insertResource(_wrkCtrParmSchedule, resourceGroupMember.findExistingWrkCtrTable(), false);
                    }

                    scheduleEngine.addResourceGroupMembership(
                                    groupName,
                                    resourceGroupMember.WrkCtrId,
                                    DateTimeUtil::newDateTime(resourceGroupMember.ValidFrom, 0),
                                    DateTimeUtil::newDateTime(resourceGroupMember.ValidTo, 0) );

                    next resourceGroupMember;
                }
            }

            next wrkCtrResourceGroupResource;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToRescheduleQueue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a <c>WrkCtrParmSchedule</c> record that contains the parameters that are used to schedule an
    ///    order into the reschedule queue of the engine.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> object that contains the scheduling parameters for a specific order.
    /// </param>
    protected void addToRescheduleQueue(WrkCtrParmSchedule _wrkCtrParmSchedule)
    {
        setRescheduleQueue.add(_wrkCtrParmSchedule);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToUpdatedOrdersMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a new order to the map of updated orders.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> table buffer that contains all the scheduling parameters needed for
    /// scheduling the order.
    /// </param>
    /// <param name="_order">
    /// The order to add.
    /// </param>
    /// <param name="_bomCalcData">
    /// The BOM data to add.
    /// </param>
    protected void addToUpdatedOrdersMap(WrkCtrParmSchedule  _wrkCtrParmSchedule,
                                         Common              _order,
                                         BOMCalcData         _bomCalcData)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>addWrkCtrParmSchedule</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a <c>WrkCtrParmSchedule</c> record that contains the parameters that are used to schedule an
    ///    order into the scheduling list of the engine.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> object that contains the scheduling parameters for a specific order.
    /// </param>
    public void addWrkCtrParmSchedule(WrkCtrParmSchedule _wrkCtrParmSchedule)
    {
        RefRecId    newReqPlanVersionRefRecId;

        if (!_wrkCtrParmSchedule)
        {
            inconsistentDataSchedulingErrorOccured = true;
            throw error(strFmt("@SYS22828", funcName()));
        }

        // get the plan version identifier for the order
        newReqPlanVersionRefRecId = _wrkCtrParmSchedule.parmReqPlanVersionRefRecId();
        if (reqPlanVersionRefRecId &&
            newReqPlanVersionRefRecId != reqPlanVersionRefRecId)
        {
            inconsistentDataSchedulingErrorOccured = true;
            throw error(strFmt("@SYS22828", funcName()));
        }

        this.validateWrkCtrParmSchedule(_wrkCtrParmSchedule);

        reqPlanVersionRefRecId = newReqPlanVersionRefRecId;

        // add the order scheduling parameters to the list of orders
        listWrkCtrParmSchedule.addEnd(_wrkCtrParmSchedule);
    }

]]></Source>
			</Method>
			<Method>
				<Name>applicableResourceGroupsFromResources</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets applicable resource groups from list of applicable resources.
    /// </summary>
    /// <param name="_resources">
    /// List of applicable resources.
    /// </param>
    /// <returns>
    /// List of applicable resource groups.
    /// </returns>
    protected List applicableResourceGroupsFromResources(List   _resources)
    {
        Set             applicableGroupsSet;
        List            applicableGroupsList;
        ListEnumerator  listEnumerator;
        WrkCtrId        resourceId;
        WrkCtrId        groupName;
        WrkCtrResourceGroupResource wrkCtrResourceGroupResource;
        WrkCtrResourceGroup         wrkCtrResourceGroup;

        applicableGroupsSet = new Set(Types::String);
        applicableGroupsList = new List(Types::String);

        listEnumerator = _resources.getEnumerator();
        while (listEnumerator && listEnumerator.moveNext())
        {
            resourceId = listEnumerator.current();

            wrkCtrResourceGroupResource = WrkCtrTable::resourceGroupResource(resourceId, dateNull(), dateMax());
            while (wrkCtrResourceGroupResource)
            {
                wrkCtrResourceGroup = WrkCtrResourceGroup::find(wrkCtrResourceGroupResource.ResourceGroup);
                groupName = wrkCtrResourceGroup.WrkCtrId;
                if (!applicableGroupsSet.in(groupName))
                {
                    applicableGroupsSet.add(groupName);
                    applicableGroupsList.addEnd(groupName);
                }

                next wrkCtrResourceGroupResource;
            }
        }

        return applicableGroupsList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>blankRoute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a blank route operation record as a <c>Common</c> table buffer.
    /// </summary>
    /// <returns>
    /// A <c>Common</c> table buffer that contains an empty route operation record.
    /// </returns>
    protected Common blankRoute()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateResourcePriority</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the resource priority based on the requirements and the priority date.
    /// </summary>
    /// <param name="_resource">
    /// The <c>WrkCtrTable</c> instance to calculate the priority for.
    /// </param>
    /// <param name="_requirementProperties">
    /// A map of the property requirements.
    /// </param>
    /// <param name="_priorityDate">
    /// The date to calculate the priority for.
    /// </param>
    /// <returns>
    /// The resource priority.
    /// </returns>
    protected real calculateResourcePriority(WrkCtrTable _resource,
                                             Map         _requirementProperties,
                                             date        _priorityDate)
    {
        WrkCtrCapabilityResource    resourceCapability;
        real                        priority;
        int                         numberOfCapabilities;

        while select validtimestate(_priorityDate) Priority, Capability from resourceCapability where
                (resourceCapability.WrkCtrId == _resource.WrkCtrId) &&
                (resourceCapability.ResourceDataAreaId == _resource.DataAreaId)
        {
            if (_requirementProperties.exists(WrkCtrSchedulingProperty::capabilitySchedulingProperty(resourceCapability.Capability)))
            {
                ++numberOfCapabilities;
                priority += resourceCapability.Priority;
            }
        }

        if (numberOfCapabilities > 0)
        {
            priority = priority / numberOfCapabilities;
        }

        if (numberOfCapabilities < this.countNumberOfCapabilities(_requirementProperties))
        {
            priority = -1.0;
        }

        return priority;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSchedule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if an order can be scheduled.
    /// </summary>
    /// <param name="_common">
    /// A <c>Common</c> table buffer that contains the order record.
    /// </param>
    /// <returns>
    /// true if the order meets all requirements for being scheduled; otherwise, false.
    /// </returns>
    protected boolean canSchedule(Common _common)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>capacityRefType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the capacity reservation type.
    /// </summary>
    /// <returns>
    ///    A <c>WrkCtrCapRefType</c> enumeration value with the capacity reservation type.
    /// </returns>
    public WrkCtrCapRefType capacityRefType()
    {
        return WrkCtrCapRefType::Blank;
    }

]]></Source>
			</Method>
			<Method>
				<Name>capacityTypeReservation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the type of scheduling being done, job or operation scheduling, for a specific order
    ///    scheduling parameters record.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> object that has the order scheduling parameters.
    /// </param>
    /// <returns>
    ///    A <c>WrkCtrCapacityType</c> enumeration value of <c>job</c> or <c>operation</c> that specifies the
    ///    type of scheduling.
    /// </returns>
    protected WrkCtrCapacityType capacityTypeReservation(WrkCtrParmSchedule _wrkCtrParmSchedule)
    {
        if (_wrkCtrParmSchedule.schedMethod() == SchedMethod::Rough)
        {
            return WrkCtrCapacityType::OperationSched;
        }
        else
        {
            return WrkCtrCapacityType::JobSched;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSchedulingDirectionChange</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the scheduling direction was changed during scheduling.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> record that contains the order scheduling parameters.
    /// </param>
    /// <param name="_common">
    ///    A <c>Common</c> table buffer that contains the order master data (this can be a <c>ProdTable</c>
    ///    buffer, ...).
    /// </param>
    /// <param name="_messageText">
    ///    A string with the message to display in the Infolog in case the scheduling direction was changed.
    /// </param>
    protected void checkSchedulingDirectionChange(WrkCtrParmSchedule _wrkCtrParmSchedule,
                                                  Common             _common,
                                                  str                _messageText)
    {
        RecId jobId = masterDataJobRecId.lookup(_wrkCtrParmSchedule.schedNumId());
        container sequenceScheduleResult = scheduleEngine.getJobSchedulingSequenceResult(jobId);

        // check for a direction change
        if (conPeek(sequenceScheduleResult, 3) == 0 &&
            _wrkCtrParmSchedule.schedDirection() == SchedDirection::Backward)
        {
            info(strFmt("@SYS76498", _messageText, "@SYS26422"));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSingleJobSchedApplicableResources</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks that a resource meets the requirements of an operation in a specified time period when a job
    /// is scheduled.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// The scheduling parameters.
    /// </param>
    /// <param name="_activityRequirementSet">
    /// The requirements of the operation.
    /// </param>
    /// <param name="_siteId">
    /// The site ID.
    /// </param>
    /// <param name="_lowerBound">
    /// The lower bound for the requirements check date.
    /// </param>
    /// <param name="_upperBound">
    /// The upper bound for the requirements check date.
    /// </param>
    /// <returns>
    /// false if scheduling is not being done on a single job and the specified resource does not meet
    /// operation requirements; otherwise, true.
    /// </returns>
    protected boolean checkSingleJobSchedApplicableResources(
        WrkCtrParmSchedule              _wrkCtrParmSchedule,
        WrkCtrActivityRequirementSet    _activityRequirementSet,
        InventSiteId                    _siteId,
        date                            _lowerBound,
        date                            _upperBound)
    {
        List            resourceList;
        ListEnumerator  en;
        WrkCtrId        resourceId;

        date validFrom;
        date validTo;

        boolean meetsRequirements = true;

        if (_wrkCtrParmSchedule.schedSingleJob() && _wrkCtrParmSchedule.schedToWrkCtrId())
        {
            meetsRequirements = false;

            if (_wrkCtrParmSchedule.schedDirection() == SchedDirection::Backward)
            {
                validFrom = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone());
                validTo = _wrkCtrParmSchedule.schedDate();
            }
            else
            {
                validFrom = _wrkCtrParmSchedule.schedDate();
                validTo = dateMax();
            }

            if (_lowerBound)
            {
                validFrom = max(validFrom, _lowerBound);
            }

            if (_upperBound)
            {
                validTo = min(validTo, _upperBound);
            }

            resourceList = _activityRequirementSet.applicableResourcesList(validFrom, validTo, _siteId, true, false);
            en = resourceList.getEnumerator();
            while (en.moveNext())
            {
                resourceId = en.current();
                if (resourceId == _wrkCtrParmSchedule.schedToWrkCtrId())
                {
                    meetsRequirements = true;
                    break;
                }
            }

            if (!meetsRequirements)
            {
                warning(strFmt("@GLS3800017", _wrkCtrParmSchedule.schedToWrkCtrId()));
            }
        }

        return meetsRequirements;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanUpOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Cleans up the order data when the scheduling fails.
    /// </summary>
    /// <param name="_common">
    ///    A <c>Common</c> table buffer with the order data.
    /// </param>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> object that contains the scheduling parameters.
    /// </param>
    protected void cleanUpOrder(Common              _common,
                                WrkCtrParmSchedule  _wrkCtrParmSchedule)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearListWrkCtrParmSchedule</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears the list that contains all orders to schedule.
    /// </summary>
    public void clearListWrkCtrParmSchedule()
    {
        listWrkCtrParmSchedule = new List(Types::Class);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearAllCachedData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets the working times cache.
    /// </summary>
    public void clearAllCachedData()
    {
        if (scheduleEngine)
        {
            scheduleEngine.clearAllCachedData();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>computeJobGoal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Computes the job goal depending on the current bill of materials (BOM) level.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> object that contains all the scheduling parameters needed for
    /// scheduling the production order.
    /// </param>
    /// <param name="_collectRefLevel">
    /// The current BOM level that is used to determine the job goals.
    /// </param>
    /// <param name="_startCollectRefLevel">
    /// The initial BOM level that is used to determine the job goals.
    /// </param>
    /// <returns>
    /// A <c>WrkCtrScheduleGoal::LatestStartTime</c> enumeration value if the job is backward scheduled;
    /// otherwise, a <c>WrkCtrScheduleGoal::EarliestEndTime</c> enumeration value.
    /// </returns>
    protected WrkCtrSchedulerGoal computeJobGoal(WrkCtrParmSchedule _wrkCtrParmSchedule,
                                                 BOMLevel           _collectRefLevel = 0,
                                                 BOMLevel           _startCollectRefLevel = 0)
    {
        WrkCtrSchedulerGoal goal;

        // Get the goal of the job
        if (_wrkCtrParmSchedule.synchronizeReference() && _collectRefLevel != _startCollectRefLevel)
        {
            if (_collectRefLevel < _startCollectRefLevel)
            {
                // Forward scheduling
                goal = WrkCtrSchedulerGoal::EarliestEndTime;
            }
            else
            {
                // Backward scheduling
                goal = WrkCtrSchedulerGoal::LatestStartTime;
            }
        }
        else
        {
            if (_wrkCtrParmSchedule.schedDirection() == SchedDirection::Backward)
            {
                goal = WrkCtrSchedulerGoal::LatestStartTime;
            }
            else
            {
                goal = WrkCtrSchedulerGoal::EarliestEndTime;
            }
        }

        return goal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>computeJobTime</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Computes the runtime of a job.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    An <c>WrkCtrParmSchedule</c> object that contains the order scheduling parameters for the order to
    ///    which the job belongs.
    /// </param>
    /// <param name="_jobRecord">
    ///    A <c>Common</c> table buffer that contains the job record.
    /// </param>
    /// <param name="_route">
    ///    A <c>Common</c> table buffer that contains the route record.
    /// </param>
    /// <param name="_routeOpr">
    ///    A <c>Common</c> table buffer that contains the route operation record.
    /// </param>
    /// <param name="_jobType">
    ///    A <c>RouteJobType</c> value that specifies the type of job to schedule; (Setup, Process, etc.).
    /// </param>
    /// <param name="_bomCalcData">
    ///    An <c>BOMCalcData</c> object that is used when calculating the runtimes of the job.
    /// </param>
    /// <param name="_useJobTime">
    ///    The <c>_useJobTime</c> object is true if the job time should be used; false if the job time should
    ///    be 0.
    /// </param>
    /// <param name="_prodJobType">
    ///    A <c>ProdJobType</c> object that can be used to compute the runtime of the job.
    /// </param>
    /// <param name="_useCalcJobSchedJobTime">
    ///    A Boolean value that indicates whether to calculate job schedule times.
    /// </param>
    /// <param name="_itemId">
    ///    An <c>ItemId</c> object that is used when calculating the runtimes of the job.
    /// </param>
    /// <param name="_inventDimId">
    ///    A <c>InventDimId</c> object that is used when calculating the runtimes of the job.
    /// </param>
    /// <param name="_resourceId">
    ///     Work id.
    /// </param>
    /// <param name="_numberOfResources">
    ///     Required number of resources.
    /// </param>
    /// <returns>
    ///    A <c>Map</c> that contains (resource, jobTime) pairs.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The resources parameter is invalid.
    /// </exception>
    protected Hours computeJobTime(WrkCtrParmSchedule    _wrkCtrParmSchedule,
                                  Common                _jobRecord,
                                  RouteMap              _route,
                                  RouteOprMap           _routeOpr,
                                  RouteJobType          _jobType,
                                  BOMCalcData           _bomCalcData,
                                  boolean               _useJobTime,
                                  ProdJobType           _prodJobType = null,
                                  boolean               _useCalcJobSchedJobTime= true,
                                  ItemId                _itemId = '', // BOM itemId
                                  InventDimId           _inventDimId = '', // BOM item's dimension
                                  WrkCtrId              _resourceId = '',
                                  int                   _numberOfResources = 1
                                  )
    {
        Hours           calcTime = 0.0;
        ProdJobType     prodJobType = _prodJobType;

        if (!prodJobType)
        {
            prodJobType = ProdJobType::construct(_jobType);
        }

        if (_jobRecord      &&
            _routeOpr       &&
            _useJobTime     &&
            !_wrkCtrParmSchedule.isJobTypeCancelled(_jobType))
        {
            // compute the job time
            calcTime = this.calculateJobTime(_jobRecord,
                                             prodJobType,
                                             _bomCalcData,
                                             _route,
                                             _routeOpr,
                                             _useCalcJobSchedJobTime,
                                             _itemId,
                                             _inventDimId,
                                             _resourceId,
                                             _numberOfResources);
        }

        return calcTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateJobTime</Name>
				<Source><![CDATA[
    private hours calculateJobTime(Common           _jobRecord,
                                   ProdJobType      _prodJobType,
                                   BOMCalcData      _bomCalcData,
                                   RouteMap         _route,
                                   RouteOprMap      _routeOpr,
                                   boolean          _useCalcJobSchedJobTime= true,
                                   ItemId           _itemId = '',
                                   InventDimId      _inventDimId = '',
                                   WrkCtrId         _resourceId = '',
                                   int              _numberOfResources = 1)
    {
        Hours calcTime = 0.0;
        calcTime = _prodJobType.calcWrkCtrHours(_bomCalcData,
                                                _route,
                                                _routeOpr,
                                                _resourceId,
                                                _route,
                                                _routeOpr,
                                                _itemId,
                                                _inventDimId) * #SecondsPerHour / _numberOfResources;

        if (_useCalcJobSchedJobTime)
        {
            calcTime = _prodJobType.calcJobSchedJobTime(_jobRecord, _routeOpr, calcTime);
        }
        return calcTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>computeJobTimes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Computes the runtime of a job for each resource in a given list.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> object that contains the order scheduling parameters for the order that the job belongs to.
    /// </param>
    /// <param name="_jobRecord">
    /// A <c>Common</c> table buffer that contains the job record.
    /// </param>
    /// <param name="_route">
    /// A <c>Common</c> table buffer that contains the route record.
    /// </param>
    /// <param name="_routeOpr">
    /// A <c>Common</c> table buffer that contains the route operation record.
    /// </param>
    /// <param name="_jobType">
    /// A <c>RouteJobType</c> value that specifies the type of job to schedule (Setup, Process, etc.).
    /// </param>
    /// <param name="_resources">
    /// A <c>List</c> with all resources that the job can be scheduled on.
    /// </param>
    /// <param name="_bomCalcData">
    /// A <c>BOMCalcData</c> object that is used when calculating the runtimes of the job.
    /// </param>
    /// <param name="_useJobTime">
    /// The <c>_useJobTime</c> object is set to true if the job time should be used; Set to false if the job time should be 0.
    /// </param>
    /// <param name="_prodJobType">
    /// A <c>ProdJobType</c> object that can be used to compute the runtime of the job.
    /// </param>
    /// <param name="_useCalcJobSchedJobTime">
    /// A Boolean that indicates whether to calculate job schedule times.
    /// </param>
    /// <param name="_itemId">
    /// A <c>ItemId</c> object that is used when calculating the runtimes of the job.
    /// </param>
    /// <param name="_inventDimId">
    /// A <c>InventDimId</c> object that is used when calculating the runtimes of the job.
    /// </param>
    /// <param name="_numberOfResources">
    /// Required number of resources; optional.
    /// </param>
    /// <returns>
    /// A <c>Map</c> that contains (resource, jobTime) pairs.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// This exception is thrown if the resources parameter is invalid.
    /// </exception>
    protected Map computeJobTimes(WrkCtrParmSchedule    _wrkCtrParmSchedule,
                                  Common                _jobRecord,
                                  RouteMap              _route,
                                  RouteOprMap           _routeOpr,
                                  RouteJobType          _jobType,
                                  List                  _resources,
                                  BOMCalcData           _bomCalcData,
                                  boolean               _useJobTime,
                                  ProdJobType           _prodJobType = null,
                                  boolean               _useCalcJobSchedJobTime= true,
                                  ItemId                _itemId         = '', // BOM itemId
                                  InventDimId           _inventDimId    = '', // BOM item's dimension
                                  int                   _numberOfResources = 1
                                  )
    {
        Map             jobTimes = new Map(Types::String, Types::Real);
        ListEnumerator  listEnumerator;
        WrkCtrId        resourceId;
        Hours           calcTime;
        ProdJobType     prodJobType = _prodJobType;

        if (!_resources)
        {
            throw error(strFmt("@SYS54195", funcName()));
        }

        if (!prodJobType)
        {
            prodJobType = ProdJobType::construct(_jobType);
        }

        if (_jobRecord      &&
            _routeOpr       &&
            _useJobTime     &&
            !_wrkCtrParmSchedule.isJobTypeCancelled(_jobType))
        {
            if (_prodJobType.isWrkCtrHoursResourceIndependent(_routeOpr))
            {
                _numberOfResources = 1;
            }

            // for each resource compute the job time
            listEnumerator = _resources.getEnumerator();
            while (listEnumerator && listEnumerator.moveNext())
            {
                resourceId = listEnumerator.current();

                calcTime = this.calculateEachJobTime(_jobRecord,
                                                     prodJobType,
                                                     _bomCalcData,
                                                     _route,
                                                     _routeOpr,
                                                     _useCalcJobSchedJobTime,
                                                     _itemId,
                                                     _inventDimId,
                                                     resourceId,
                                                     _numberOfResources);

                jobTimes.insert(resourceId, calcTime);
            }
        }
        else
        {
            jobTimes = this.fixedJobTimesForResources(_resources, 0);
        }

        return jobTimes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateEachJobTime</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the runtime of a specific job in the jobs list.
    /// </summary>
    /// <param name="_jobRecord">
    ///    A <c>Common</c> table buffer that contains the job record.
    /// </param>
    /// <param name="_prodJobType">
    ///    A <c>ProdJobType</c> object that can be used to compute the runtime of the job.
    /// </param>
    /// <param name="_bomCalcData">
    ///    An <c>BOMCalcData</c> object that is used when calculating the runtimes of the job.
    /// </param>
    /// <param name="_route">
    ///    A <c>Common</c> table buffer that contains the route record.
    /// </param>
    /// <param name="_routeOpr">
    ///    A <c>Common</c> table buffer that contains the route operation record.
    /// </param>
    /// <param name="_useCalcJobSchedJobTime">
    ///    A Boolean value that indicates whether to calculate job schedule times.
    /// </param>
    /// <param name="_itemId">
    ///    An <c>ItemId</c> object that is used when calculating the runtimes of the job.
    /// </param>
    /// <param name="_inventDimId">
    ///    A <c>InventDimId</c> object that is used when calculating the runtimes of the job.
    /// </param>
    /// <param name="_resourceId">
    ///     Work id.
    /// </param>
    /// <param name="_numberOfResources">
    ///     Required number of resources.
    /// </param>
    /// <returns>
    ///    Returns the number of hours needed for this job.
    /// </returns>
    /// <remarks>
    ///    This method is an extension point to control the calculation of each job time in the jobs list.
    /// </remarks>
    protected hours calculateEachJobTime(Common                _jobRecord,
                                         ProdJobType           _prodJobType,
                                         BOMCalcData           _bomCalcData,
                                         RouteMap              _route,
                                         RouteOprMap           _routeOpr,
                                         boolean               _useCalcJobSchedJobTime= true,
                                         ItemId                _itemId = '',
                                         InventDimId           _inventDimId = '',
                                         WrkCtrId              _resourceId = '',
                                         int                   _numberOfResources = 1)
    {
        return this.calculateJobTime(_jobRecord,
                                    _prodJobType,
                                    _bomCalcData,
                                    _route,
                                    _routeOpr,
                                    _useCalcJobSchedJobTime,
                                    _itemId,
                                    _inventDimId,
                                    _resourceId,
                                    _numberOfResources);
    }

]]></Source>
			</Method>
			<Method>
				<Name>countNumberOfCapabilities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Counts the number of capability requirements.
    /// </summary>
    /// <param name="_requirementProperties">
    /// A Map of property requirements.
    /// </param>
    /// <returns>
    /// The number of capability requirements in the map.
    /// </returns>
    protected int countNumberOfCapabilities(Map _requirementProperties)
    {
        MapEnumerator   propertyEnumerator = _requirementProperties.getEnumerator();
        str             propertyKey;
        int             capabilityCount;
        str             prefix = WrkCtrSchedulingProperty::capabilityPropertyPrefix();
        int             lenPrefix = strLen(prefix);

        while (propertyEnumerator.moveNext())
        {
            propertyKey = propertyEnumerator.currentKey();
            if (strScan(propertyKey, prefix, 1, lenPrefix) > 0)
            {
                ++capabilityCount;
            }
        }

        return capabilityCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBOMCalcData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>BOMCalcData</c> class for a given order.
    /// </summary>
    /// <param name="_order">
    /// The order for which BOM calculation data is needed.
    /// </param>
    /// <returns>
    /// A <c>BOMCalcData</c> instance that is used for runtime computation.
    /// </returns>
    protected BOMCalcData createBOMCalcData(Common _order)
    {
        throw error(strFmt("@SYS22828", funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createEngine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the C# job scheduling engine and the appropriate engine data provider.
    /// </summary>
    /// <param name="_loggingOptions">
    ///     An object with logging parameters; optional.
    /// </param>
    /// <returns>
    ///    A job scheduling engine as an instance of the
    ///    <c>Microsoft.Dynamics.AX.Planning.JobScheduling.ISchedulingEngine</c> class.
    /// </returns>
    protected WrkCtrSchedulerEngineInterface createEngine(Microsoft.Dynamics.AX.Planning.JobScheduling.LoggingOptions _loggingOptions = null)
    {
        return WrkCtrSchedulerJobSchedulingEngine::newSchedulingEngine(wrkCtrSchedulerRuntimes, this, _loggingOptions);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTmpRoute</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a temporary route operation record as a <c>Common</c> table buffer.
    /// </summary>
    /// <param name="_refId">
    ///    The order ID for which to create the temporary operation.
    /// </param>
    /// <returns>
    ///    A <c>Common</c> table buffer that contains the temporary route operation data.
    /// </returns>
    protected Common createTmpRoute(InventRefId _refId)
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTmpRouteJob</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a temporary job record and returns it as a <c>Common</c> table buffer.
    /// </summary>
    /// <param name="_refId">
    ///    The order ID to create the temporary job for.
    /// </param>
    /// <returns>
    ///    A <c>Common</c> table buffer that contains the temporary job information.
    /// </returns>
    protected Common createTmpRouteJob(InventRefId _refId)
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteAllTemporaryJobs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes all of the temporary jobs.
    /// </summary>
    protected void deleteAllTemporaryJobs()
    {
        SetEnumerator temporyJobEnumerator = temporaryJobs.getEnumerator();

        while (temporyJobEnumerator.moveNext())
        {
            this.deleteTemporaryJob(temporyJobEnumerator.current());
        }

        temporaryJobs = new Set(Types::Int64);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTemporaryJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes a temporary job.
    /// </summary>
    /// <param name="_recId">
    /// The identifier of the temporary job to delete.
    /// </param>
    protected void deleteTemporaryJob(RecId _recId)
    {
        // do nothing implemented by sub-classes
    }

]]></Source>
			</Method>
			<Method>
				<Name>dispose</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Disposes of the resources that are held by the scheduling engine.
    /// </summary>
    public void dispose()
    {
        if (scheduleEngine)
        {
            scheduleEngine.dispose();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findJobWrkCtrParmSchedule</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the <c>WrkCtrParmSchedule</c> object for the order that a specific job belongs to.
    /// </summary>
    /// <param name="_jobId">
    ///    A record ID that identifies the job for which the scheduling parameters are being looked up.
    /// </param>
    /// <returns>
    ///    A <c>WrkCtrParmSchedule</c> object that contains the scheduling parameters for the order of the
    ///    specified job.
    /// </returns>
    protected WrkCtrParmSchedule findJobWrkCtrParmSchedule(RecId _jobId)
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRefId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds an order in the master data and returns the order record.
    /// </summary>
    /// <param name="_refId">
    ///    The order ID.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that specifies whether the record is to be selected for update.
    /// </param>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> record that contains the order scheduling parameters.
    /// </param>
    /// <returns>
    ///    A <c>Common</c> table buffer that contains the order data.
    /// </returns>
    protected Common findRefId(InventRefId          _refId,
                               boolean              _forUpdate = false,
                               WrkCtrParmSchedule   _wrkCtrParmSchedule = null)
    {
        Common common;
        return common;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findWrkCtrParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the correct <c>WrkCtrParametersDim</c> for an order.
    /// </summary>
    /// <param name="_listWrkCtrParmSchedule">
    /// A List of orders.
    /// </param>
    /// <returns>
    /// An appropriate record in the <c>WrkCtrParametersDim</c> table for the order.
    /// </returns>
    protected WrkCtrParametersDim findWrkCtrParameters(List _listWrkCtrParmSchedule)
    {
        ListEnumerator                      listEnumerator;
        WrkCtrParmSchedule                  wrkCtrParmSchedule;
        InventDimId                         inventDimId;
        WrkCtrParametersDim                 wrkCtrParametersDim;

        if (!_listWrkCtrParmSchedule || _listWrkCtrParmSchedule.elements() < 1)
        {
            return WrkCtrParametersDim::findDefault();
        }

        listEnumerator = listWrkCtrParmSchedule.getEnumerator();
        listEnumerator.moveNext();
        wrkCtrParmSchedule = listEnumerator.current();
        inventDimId = wrkCtrParmSchedule.parmInventDimId();
        wrkCtrParametersDim = WrkCtrParametersDim::find(inventDimId);

        return wrkCtrParametersDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fixedJobTimesForResources</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Fills a map that contains a fixed job time for each resource in a given resource list.
    /// </summary>
    /// <param name="_resources">
    ///    A <c>List</c> object that has all resources that the job can be scheduled on.
    /// </param>
    /// <param name="_jobTime">
    ///    The fixed job time that should be assigned to each resource in the given resource list.
    /// </param>
    /// <returns>
    ///    A <c>Map</c> that contains the resource and job time pairs.
    /// </returns>
    protected Map fixedJobTimesForResources(List   _resources,
                                            Hours  _jobTime)
    {
        Map             jobTimes = new Map(Types::String, Types::Real);
        ListEnumerator  listEnumerator;

        if (!_resources)
        {
            throw error(strFmt("@SYS54195", funcName()));
        }

        listEnumerator = _resources.getEnumerator();
        while (listEnumerator && listEnumerator.moveNext())
        {
            jobTimes.insert(listEnumerator.current(), _jobTime);
        }

        return jobTimes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>flushCachedSaveData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Flushes the saved capacity reservation and the capacity reservation properties records to the
    /// database.
    /// </summary>
    public void flushCachedSaveData()
    {
        capacityReservationsInsertList.insertDatabase();
        this.writeAllCapacityReservationProperties();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExclusiveJobList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a set of jobs that should be scheduled for a certain order, if only some of the jobs should be
    /// scheduled.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// The scheduling parameters.
    /// </param>
    /// <returns>
    /// A set with the exclusive list of jobs to schedule; or an empty set if all jobs should be scheduled.
    /// </returns>
    public Set getExclusiveJobList(WrkCtrParmSchedule _wrkCtrParmSchedule)
    {
        Set                 exclusiveJobsToSchedule = null;
        InventTransRefId    orderId = _wrkCtrParmSchedule.schedNumId();

        if (mapOrderExclusiveJobsToSchedule.exists(orderId))
        {
            exclusiveJobsToSchedule = mapOrderExclusiveJobsToSchedule.lookup(orderId);
        }

        return exclusiveJobsToSchedule == null ? new Set(Types::Int64) : exclusiveJobsToSchedule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductionUnitAndWarehouse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the production unit and warehouse that is assigned to the route.
    /// </summary>
    /// <param name="_currentRecId">
    /// The current Record ID record identifier.
    /// </param>
    /// <param name="_previousRecId">
    /// The previous Record ID record identifier.
    /// </param>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> table buffer that contains all the scheduling parameters that are
    /// required for scheduling the production order.
    /// </param>
    /// <param name="_prodUnitId">
    /// The previous <c>ProdUnitId</c> production unit identifier.
    /// </param>
    /// <param name="_inputWarehouse">
    /// The previous <c>InventLocationIdInput</c> warehouse identifier.
    /// </param>
    /// <param name="_routeMap">
    /// A <c>RouteMap</c> table map that has the current route.
    /// </param>
    /// <returns>
    /// A container that contains the identifier of the current record, the production unit identifier and
    /// the input warehouse identifier.
    /// </returns>
    protected container getProductionUnitAndWarehouse(
                                                      RecId                 _currentRecId,
                                                      RecId                 _previousRecId,
                                                      WrkCtrParmSchedule    _wrkCtrParmSchedule,
                                                      ProdUnitId            _prodUnitId,
                                                      InventLocationIdInput _inputWarehouse,
                                                      RouteMap              _routeMap)
    {
        ProdUnitId              prodUnitId      = _prodUnitId;
        InventLocationIdInput   inputWarehouse  = _inputWarehouse;
        RecId                   previousRecId   = _previousRecId;

        if (_currentRecId != _previousRecId)
        {
            if (_wrkCtrParmSchedule.parmKeepProductionUnit())
            {
                if (_routeMap.OprPriority == RouteOprPriority::Primary)
                {
                    prodUnitId = this.productionUnit(_routeMap.OprNum);
                }
                else
                {
                    // Like for the input warehouse, the currently used production unit should only be kept for the
                    // primary operation during rescheduling, since it's assumed that is main constraint of the process
                    prodUnitId = '';
                }
            }
            if (_wrkCtrParmSchedule.parmKeepWarehouseFromResource())
            {
                inputWarehouse = this.inputWarehouse(_routeMap);
            }
            previousRecId = _currentRecId;
        }

        return [previousRecId, prodUnitId, inputWarehouse];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResourceRequirement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the resource ID when the requirements map contains a resource requirement.
    /// Otherwise an empty string is returned.
    /// </summary>
    /// <param name="_requirementProperties">
    /// A map of requirements.
    /// </param>
    /// <returns>
    /// The resource ID.
    /// </returns>
    protected WrkCtrId getResourceRequirement(Map _requirementProperties)
    {
        MapEnumerator   requirementEnumerator = _requirementProperties.getEnumerator();
        str             resourceRequirementPrefix = WrkCtrSchedulingProperty::getWrkCtrSchedulingProperty('');
        int             lenPrefix = strLen(resourceRequirementPrefix);
        str             currentRequirement;

        while (requirementEnumerator.moveNext())
        {
            currentRequirement = requirementEnumerator.currentKey();
            if (strScan(currentRequirement, resourceRequirementPrefix, 1, lenPrefix) == 1)
            {
                return subStr(currentRequirement, lenPrefix+1, strLen(currentRequirement));
            }
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResourceRequirementProperties</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets a map of requirement properties for the specific resource used by a given job.
    /// </summary>
    /// <param name="_wrkCtrId">
    ///     The ID of the resource to use as requirement.
    /// </param>
    /// <returns>
    ///     A new Map instance with requirement properties.
    /// </returns>
    protected Map getResourceRequirementProperties(WrkCtrId _wrkCtrId)
    {
        Map propertyMap = new Map(Types::String, Types::Real);
        WrkCtrActivityResourceRequirement resourceRequirement;

        resourceRequirement.WrkCtrId = _wrkCtrId;
        resourceRequirement.addToPropertyMap(propertyMap);

        return propertyMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleCapacityConflicts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the capacity reservation conflicts.
    /// </summary>
    /// <param name="_failedJobList">
    /// A list of jobs that have capacity conflicts.
    /// </param>
    protected void handleCapacityConflicts(System.Collections.ArrayList _failedJobList)
    {
        int                             conflictJobCount;
        int                             i;
        WrkCtrParmSchedule              wrkCtrParmSchedule;

        try
        {
            ttsbegin;

            if (_failedJobList != null)
            {
                conflictJobCount = _failedJobList.get_Count();
            }

            // mark for reschedule all of the conflicted jobs
            if (conflictJobCount > 0)
            {
                WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::WrkCtrSchedulerSaveJobs, 'Conflicts detected: ' + int2str(conflictJobCount));
            }

            for (i = 0; i < conflictJobCount; i++)
            {
                wrkCtrParmSchedule = this.findJobWrkCtrParmSchedule(_failedJobList.get_Item(i));
                this.addToRescheduleQueue(wrkCtrParmSchedule);
                if (capacityConflictHandler)
                {
                    capacityConflictHandler.capacityConflict(wrkCtrParmSchedule.schedNumId());
                }
            }

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            retry;
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (ReqTransientSqlConnectionErrorHandlingHelper::retryTransientSqlConnectionError())
            {
                retry;
            }
            else
            {
                throw;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleRouteLessOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a placeholder job to enable the engine to schedule orders without routes.
    /// </summary>
    /// <param name="_order">
    /// A record that contains the scheduling order data ( <c>ProdTable</c> , <c>ReqTrans</c> , etc.).
    /// </param>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> object that contains the order scheduling parameters.
    /// </param>
    /// <param name="_itemId">
    /// The item identifier.
    /// </param>
    /// <param name="_inventDimId">
    /// The inventory dimension identifier.
    /// </param>
    /// <param name="_refId">
    /// The top level order identifier.
    /// </param>
    /// <param name="_refIdOrig">
    /// The original order identifier.
    /// </param>
    /// <param name="_startCollectRefLevel">
    /// A starting route level that determines the order of the operations.
    /// </param>
    /// <param name="_currentCollectRefLevel">
    /// A current route level.
    /// </param>
    /// <param name="_reqRefType">
    /// The type of the order to schedule.
    /// </param>
    /// <param name="_leadTime">
    /// A lead time to use as the length for the job that is created as a placeholder for the whole order.
    /// </param>
    /// <param name="_calendarDays">
    /// A Boolean value that indicates whether to use calendar days or a calendar.
    /// </param>
    /// <param name="_minSchedDate">
    /// The minimum schedule date.
    /// </param>
    /// <param name="_minSchedTime">
    /// The minimum schedule time.
    /// </param>
    /// <returns>
    /// The fake job ID.
    /// </returns>
    protected int64 handleRouteLessOrder(Common                _order,
                                         WrkCtrParmSchedule    _wrkCtrParmSchedule,
                                         ItemId                _itemId,
                                         InventDimId           _inventDimId,
                                         InventRefId           _refId,
                                         InventRefId           _refIdOrig,
                                         BOMLevel              _startCollectRefLevel,
                                         BOMLevel              _currentCollectRefLevel,
                                         ReqRefType            _reqRefType,
                                         Days                  _leadTime = 0,
                                         CalendarDays          _calendarDays = 0,
                                         SchedDate             _minSchedDate = _wrkCtrParmSchedule.minimumSchedDate(),
                                         SchedTime             _minSchedTime = 0
                                        )
    {
        ReqSetupDim     setupDim;
        RecId           jobNumRouteLast;
        Days            leadTime = _leadTime;
        CalendarDays    calendarDays = _calendarDays;

        if (routeLessRecordSet == null)
        {
            routeLessRecordSet = new Set(Types::Int64);
        }
        routeLessRecordSet.add(_order.RecId);

        setupDim = ReqSetupDim::newInventTable(InventTable::find(_itemId), _inventDimId);

        [leadTime, calendarDays] = this.leadTimeParameters(_order);

        jobNumRouteLast = this.insertLeadTimeJob(
                                _wrkCtrParmSchedule,
                                _refId,
                                _refIdOrig,
                                setupDim,
                                leadTime,
                                calendarDays,
                                _startCollectRefLevel,
                                _currentCollectRefLevel,
                                _minSchedDate,
                                _minSchedTime);

        this.limitOrderMaterialDate(_wrkCtrParmSchedule, _order, 0, jobNumRouteLast);

        oprEndPointJobIds.insert(this.keyRoute(_refIdOrig,0, RouteOprPriority::Primary), [jobNumRouteLast, jobNumRouteLast]);

        return jobNumRouteLast;
    }

]]></Source>
			</Method>
			<Method>
				<Name>infologPrefixOprNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the prefix to be displayed in the Infolog based on a specific job ID.
    /// </summary>
    /// <param name="_common">
    /// A <c>Common</c> table buffer that identifies the job to compute the message prefix for.
    /// </param>
    /// <returns>
    /// A string value that contains the Infolog prefix.
    /// </returns>
    protected str infologPrefixOprNum(Common _common)
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the engine variables.
    /// </summary>
    /// <param name="_loggingOptions">
    ///     An object with logging parameters; optional.
    /// </param>
    /// <remarks>
    ///    All data structures needed for a scheduling run are created here instead of in the new method, in
    ///    order to avoid unnecessary operations when just instantiating a processor just to retrieve
    ///    parameters.
    /// </remarks>
    public void init(Microsoft.Dynamics.AX.Planning.JobScheduling.LoggingOptions _loggingOptions = null)
    {
        if (initialized)
        {
            return;
        }

        setRescheduleQueue          = new Set(Types::Class);

        loadedWorkingTimesToDate    = new Map(Types::String, Types::Date);
        loadedResources             = new Set(Types::String);
        loadedResourceGroups        = new Set(Types::String);
        loadedCalendars             = new Set(Types::String);

        this.initOrderData();

        wrkCtrApplicableResourceListCache = WrkCtrApplicableResourceListCache::construct();

        wrkCtrSchedulerRuntimes.startMeasurement(#CreateEngine);
        scheduleEngine = this.createEngine(_loggingOptions);
        wrkCtrSchedulerRuntimes.endMeasurement(#CreateEngine);

        initialized = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears the scheduling engine caches.
    /// </summary>
    public void initCache()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCapacityReservationData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Fills the capacity reservation record with the appropriate scheduler data.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> object that contains the order scheduling parameters.
    /// </param>
    /// <param name="_wrkCtrCapRes">
    ///    A <c>WrkCtrCapRes</c> record that identifies the capacity reservation.
    /// </param>
    /// <param name="_jobId">
    ///    A record ID that identifies the job that the capacity reservation belongs to.
    /// </param>
    protected void initCapacityReservationData(WrkCtrParmSchedule   _wrkCtrParmSchedule,
                                               WrkCtrCapRes         _wrkCtrCapRes,
                                               RecId                _jobId)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCapResHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the capacity reservation flags that are used to determine how overbooking checks are
    /// performed.
    /// </summary>
    /// <param name="_planVersion">
    /// The plan version to pass to the capacity reservation handler.
    /// </param>
    /// <param name="_siteId">
    /// A site ID used in determining the capacity reservation flags.
    /// </param>
    protected void initCapResHandler(RecId          _planVersion,
                                     InventSiteId   _siteId)
    {
        InventDim   inventDim;
        InventDimId inventDimId;

        inventDim.InventSiteId = _siteId;
        if (inventDim.InventSiteId)
        {
            inventDimId = InventDim::findDim(inventDim).InventDimId;
        }
        else
        {
            inventDimId = InventDim::inventDimIdBlank();
        }

        wrkCtrCapResHandler.parmPlanVersion(_planVersion);
        wrkCtrCapResHandler.parmLimitCapPO(this.limitCapPO(inventDimId));
        wrkCtrCapResHandler.parmLimitCapProd(this.limitCapProd(inventDimId));
        wrkCtrCapResHandler.parmLimitCapProject(this.limitCapProject(inventDimId));     
   
        wrkCtrCapResHandler.parmHasTakenReadLock(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initNumTypes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the typically used values for job types.
    /// </summary>
    protected void initNumTypes()
    {
        overlapNumType = ProdJobType::construct(RouteJobType::Overlap).numType();
        processNumType = ProdJobType::construct(RouteJobType::Process).numType();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOrderData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the master data structures.
    /// </summary>
    protected void initOrderData()
    {
        masterData                  = new Map(Types::String, Types::Record);
        masterDataJobRecId          = new Map(Types::String, Types::Int64);
        routeData                   = new Map(Types::String, Types::Record);
        jobData                     = new Map(Types::Int64, Types::Record);
        temporaryJobs               = new Set(Types::Int64);
        temporaryOperations         = new Set(Types::Int64);
        constraintJobs              = new Set(Types::Int64);

        masterDataParms             = new Map(Types::String, Types::Class);
        mapUpdatedOrders            = new Map(Types::Record, Types::Class);
        mapOrderData                = new Map(Types::String, Types::Container);
        mapOperationData            = new Map(Types::String, Types::Container);

        mapOrderExclusiveJobsToSchedule = new Map(Types::String, Types::Class);

        finiteCapacityUsed          = false;

        this.initOverlapMaps();

        // Make new temp buffers for "fake" routes and jobs
        tmpRoute = this.blankRoute();
        tmpRoute.setTmp();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOverlapMaps</Name>
				<Source><![CDATA[
    protected void initOverlapMaps()
    {
        overlapSucessorJobs = new Map(Types::String, Types::Class);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParallelJobsMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the map that tracks the parallel jobs for each job type.
    /// </summary>
    protected void initParallelJobsMap()
    {
        mapParallelJobs = new Map(Types::Enum, Types::Class);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inputWarehouse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the input warehouse ID for a specific operation record.
    /// </summary>
    /// <param name="_routeMap">
    /// A record that contains the production route operation data.
    /// </param>
    /// <returns>
    /// The input warehouse ID assigned to the BOM line that is connected to the operation.
    /// </returns>
    protected InventLocationIdInput inputWarehouse(RouteMap _routeMap)
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCalendarResource</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts an scheduling engine resource into the scheduling engine.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> object that contains the scheduling parameters.
    /// </param>
    /// <param name="_calendarId">
    ///    The calendar ID of the calendar to be added as a resource to the scheduling engine.
    /// </param>
    /// <remarks>
    ///    The resource being inserted corresponds to an AX calendar.
    /// </remarks>
    [SysObsolete('This method is deprecated use addCalendarResource instead.', false, 3\6\2021)]
    protected void insertCalendarResource(WrkCtrParmSchedule    _wrkCtrParmSchedule,
                                          CalendarId            _calendarId)
    {
        this.addCalendarResource(_wrkCtrParmSchedule, _calendarId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCalendarResource</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts an scheduling engine resource into the scheduling engine.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> object that contains the scheduling parameters.
    /// </param>
    /// <param name="_calendarId">
    ///    The calendar ID of the calendar to be added as a resource to the scheduling engine.
    /// </param>
    /// <remarks>
    ///    The resource being inserted corresponds to an AX calendar.
    /// </remarks>
    protected void addCalendarResource(WrkCtrParmSchedule    _wrkCtrParmSchedule,
                                       str                   _calendarId)
    {
        if (loadedCalendars.in(_calendarId))
        {
            return;
        }

        scheduleEngine.addResource(_calendarId,
                                   false,
                                   1,
                                   WrkCtrSchedulerWorkingTimesType::Calendar,
                                   _wrkCtrParmSchedule.parmLoadJobSchedulingCapacity(),
                                   _wrkCtrParmSchedule.parmLoadOperationSchedulingCapacity());

        loadedCalendars.add(_calendarId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertEmptyJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts an empty job to enable the engine to schedule jobless operations.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> object that contains the order scheduling parameters.
    /// </param>
    /// <param name="_refIdOrig">
    /// The original order ID.
    /// </param>
    /// <param name="_startCollectRefLevel">
    /// A starting route level that determines the order of the operations.
    /// </param>
    /// <param name="_currentCollectRefLevel">
    /// A current route level.
    /// </param>
    /// <param name="_minSchedDate">
    /// The minimum schedule date; when forward scheduling is used, this is passed as a <c>StartsAt</c>
    /// constraint.
    /// </param>
    /// <param name="_minSchedTime">
    /// The minimum schedule time; when forward scheduling is used, this is passed as a <c>StartsAt</c>
    /// constraint.
    /// </param>
    /// <returns>
    /// A Record ID that identifies the temporary table buffer that contains the created placeholder job.
    /// </returns>
    protected RecId insertEmptyJob(WrkCtrParmSchedule       _wrkCtrParmSchedule,
                                   InventRefId              _refIdOrig,
                                   BOMLevel                 _startCollectRefLevel,
                                   BOMLevel                 _currentCollectRefLevel,
                                   SchedDate                _minSchedDate = _wrkCtrParmSchedule.minimumSchedDate(),
                                   SchedTime                _minSchedTime = _wrkCtrParmSchedule.minimumSchedTime())
    {
        WrkCtrSchedulerGoal         goal;

        Common                      routeJob;

        goal = this.computeJobGoal(_wrkCtrParmSchedule, _currentCollectRefLevel, _startCollectRefLevel);

        // Create new temporary route and job record for the original refId (not the collect ref)
        routeJob = this.createTmpRouteJob(_refIdOrig);

        // Add the job
        scheduleEngine.addJobInfo(routeJob.RecId,
                                  WrkCtrSchedulerGoal::EarliestEndTime,
                                  false,
                                  false);

        // add the maximal job days
        scheduleEngine.addConstraintMaxJobDays(routeJob.RecId, _wrkCtrParmSchedule.maxJobDays());

        masterDataJobRecId.insert(_wrkCtrParmSchedule.schedNumId(), routeJob.RecId);

        // Insert the resource
        this.addCalendarResource(_wrkCtrParmSchedule, #EmptyResource);

        scheduleEngine.addJobResourceRuntime(routeJob.RecId,
                                             #EmptyResource,
        0);

        this.insertJobGoalConstraints(routeJob.RecId, goal, _minSchedDate, _minSchedTime, _wrkCtrParmSchedule.schedDate(), _wrkCtrParmSchedule.schedTime());

        return routeJob.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a job to be scheduled into the engine data pool.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> object that contains the order scheduling parameters for the order that
    /// the job belongs to.
    /// </param>
    /// <param name="_jobRecId">
    /// A <c>RecId</c> value that identifies the job record.
    /// </param>
    /// <param name="_jobRecord">
    /// A <c>Common</c> table buffer that contains the job record.
    /// </param>
    /// <param name="_jobType">
    /// A <c>RouteJobType</c> value that specifies the type of job to schedule (Setup, Process, etc.).
    /// </param>
    /// <param name="_jobPropertyId">
    /// The property ID for property scheduling.
    /// </param>
    /// <param name="_prodUnitId">
    /// The production unit used for filtering resources available for scheduling.
    /// </param>
    /// <param name="_inputWarehouse">
    /// The input warehouse used for filtering resources available for scheduling.
    /// </param>
    /// <param name="_requirementProperties">
    /// A <c>Map</c> with all properties that the resource or working time should have to run the job.
    /// </param>
    /// <param name="_jobTimes">
    /// A <c>Map</c> with all resources that the job can be scheduled on and the runtime of the job on each
    /// resource.
    /// </param>
    /// <param name="_jobLoadPct">
    /// A <c>WrkCtrLoadPct</c> value that specifies by how much the job is loading the resource.
    /// </param>
    /// <param name="_oprNum">
    /// An <c>OprNum</c> value that specifies the current operation number.
    /// </param>
    /// <param name="_oprNumNext">
    /// An <c>OprNumNext</c> value that specifies the next operation.
    /// </param>
    /// <param name="_jobSchedWorkTime">
    /// A Boolean value that indicates whether working times are considered when scheduling the job.
    /// </param>
    /// <param name="_jobSchedCapacity">
    /// A Boolean value that indicates if capacity should be reserved when the job is scheduled.
    /// </param>
    /// <param name="_jobGoal">
    /// A <c>WrkCtrSchedulerGoal</c> value that specifies the goal to use for scheduling the job.
    /// </param>
    /// <param name="_resourceQuantity">
    /// A number that determines the number of required resources when scheduling method is rough.
    /// </param>
    /// <param name="_useFastSetup">
    /// A Boolean value that indicates if fast setup should be used.
    /// </param>
    /// <param name="_jobTimeForAllResources">
    /// A number that determines the runtime for all resources when fast setup is used.
    /// </param>
    /// <param name="_jobIsPrimary">
    /// A Boolean value that indicates that the job is the primary job.
    /// </param>
    /// <param name="_primaryParallelJobRecId">
    /// A <c>RecId</c> value that identifies the primary job of a set of parallel jobs.
    /// </param>
    protected void insertJob(WrkCtrParmSchedule       _wrkCtrParmSchedule,
                             RecId                    _jobRecId,
                             Common                   _jobRecord,
                             RouteJobType             _jobType,
                             PropertyId               _jobPropertyId,
                             ProdUnitId               _prodUnitId,
                             InventLocationIdInput    _inputWarehouse,
                             Map                      _requirementProperties,
                             Map                      _jobTimes,
                             WrkCtrLoadPct            _jobLoadPct,
                             OprNum                   _oprNum,
                             OprNum                   _oprNumNext,
                             boolean                  _jobSchedWorkTime  = false,
                             boolean                  _jobSchedCapacity  = false,
                             WrkCtrSchedulerGoal      _jobGoal           = WrkCtrSchedulerGoal::EarliestEndTime,
                             int                      _resourceQuantity  = 1,
                             boolean                  _useFastSetup      = false,
                             real                     _jobTimeForAllResources = 0.0,
                             boolean                  _jobIsPrimary       = true,
                             RecId                    _primaryParallelJobRecId = 0)
    {
        MapEnumerator   mapEnumerator;
        WrkCtrTable     wrkCtrTable;

        TransDate       limitedCapacityToDate;
        boolean         limitedProperty;
        boolean         limitedCapacity;
        boolean         ignoreResourceEfficiency = (_jobType == RouteJobType::QueueBefore || _jobType == RouteJobType::QueueAfter) && !_jobSchedCapacity;
        Map             roughRequirementProperties;
        Map             requirementProperties;

        RealBase        wrkCtrJobTime;

        WrkCtrId        resourceId;
        real            resourcePriority;
        str             keyRoute;

        if ((!_useFastSetup) && (!_jobTimes))
        {
            throw error(strFmt("@SYS54195", funcName()));
        }

        if (_jobRecord)
        {
            jobData.insert(_jobRecord.RecId, _jobRecord);
        }

        InventTransRefId keyRouteRefid;

        if(WrkCtrSchedUseRouteJobProdIdForOverlapJobLinksToggle::instance().isEnabled())
        {
            keyRouteRefid = (_jobRecord is RouteJobMap) ? (_jobRecord as RouteJobMap).Refid : _wrkCtrParmSchedule.schedNumId();
        }
        else
        {
            keyRouteRefid = _wrkCtrParmSchedule.schedNumId();
        }

        keyRoute = this.keyRoute(keyRouteRefid, _oprNum, RouteOprPriority::Primary);

        // memorize overlap job link information
        if (_jobType == RouteJobType::Process && !oprProcessJobIds.exists(keyRoute))
        {
            oprProcessJobIds.insert(keyRoute, _jobRecId);
        }
        else if (_jobType == RouteJobType::Overlap && !oprOverlapJobIds.exists(keyRoute))
        {
            oprOverlapJobIds.insert(keyRoute, _jobRecId);
            overlapJobLinks.insert(keyRoute, this.keyRoute(keyRouteRefid, _oprNumNext, RouteOprPriority::Primary));
        }

        // Add the job
        scheduleEngine.addJobInfo(_jobRecId,
                                  WrkCtrSchedulerGoal::EarliestEndTime,
                                  _jobSchedWorkTime,
                                  _jobSchedCapacity);

        if (_primaryParallelJobRecId != 0)
        {
            scheduleEngine.setPrimaryParallelJob(_jobRecId, _primaryParallelJobRecId);
        }

        if (_wrkCtrParmSchedule.schedMethod() == SchedMethod::Rough)
        {
            roughRequirementProperties = new Map(Types::String, Types::Real);
            this.addGroupProperties(_wrkCtrParmSchedule,
                                    roughRequirementProperties,
                                    _prodUnitId,
                                    _inputWarehouse);

            scheduleEngine.scheduleJobOnResourceGroup(_jobRecId, roughRequirementProperties);
            if (_resourceQuantity > 1)
            {
                scheduleEngine.setRequiredNumberOfResources(_jobRecId, _resourceQuantity);
            }
        }

        masterDataJobRecId.insert(_wrkCtrParmSchedule.schedNumId(), _jobRecId);

        this.insertJobGoalConstraints(
            _jobRecId,
            _jobGoal,
            _wrkCtrParmSchedule.minimumSchedDate(),
            _wrkCtrParmSchedule.minimumSchedTime(),
            _wrkCtrParmSchedule.schedDate(),
            _wrkCtrParmSchedule.schedTime(),
            !_wrkCtrParmSchedule.schedJobRecId() || _wrkCtrParmSchedule.schedSingleJob() || _wrkCtrParmSchedule.schedJobRecId() == _jobRecId);

        // add the maximal job days
        scheduleEngine.addConstraintMaxJobDays(_jobRecId, _wrkCtrParmSchedule.maxJobDays());

        // if standard formula is used all run times are identical and we only need to add a list of resources with the corresponding run times
        if (_useFastSetup)
        {
            if (_jobSchedWorkTime)
            {
                limitedCapacityToDate = _jobSchedWorkTime && _jobSchedCapacity && _wrkCtrParmSchedule.capacityLimited() ? dateMax() : dateNull();
                scheduleEngine.addJobCapacity(_jobRecId,
                                              _jobTimeForAllResources,
                                              _jobLoadPct / 100,
                                              DateTimeUtil::newDateTime(limitedCapacityToDate, 0),
                                              _requirementProperties,
                                              _jobSchedCapacity, // property id missing
                                              ignoreResourceEfficiency);
                return;
            }
            else
            {
                scheduleEngine.addJobRuntime(_jobRecId,
                                           _jobTimeForAllResources,
                                           _requirementProperties);
            }
        }
        else
        {
            // Loop through resources available for the job to use
            mapEnumerator = _jobTimes.getEnumerator();

            while (mapEnumerator && mapEnumerator.moveNext())
            {
                wrkCtrTable = WrkCtrTable::find(mapEnumerator.currentKey());

                requirementProperties = Map::create(_requirementProperties.pack());
                this.addGroupProperties(_wrkCtrParmSchedule,
                                        requirementProperties,
                                        _prodUnitId,
                                        _inputWarehouse);

                // Insert the resource
                this.insertResource(_wrkCtrParmSchedule, wrkCtrTable);

                // Set work center specific values
                limitedCapacity = _jobSchedWorkTime && _jobSchedCapacity && this.limitedCapacity(_wrkCtrParmSchedule, wrkCtrTable);
                limitedCapacityToDate = _jobSchedWorkTime && _jobSchedCapacity ? this.limitedCapacityToDate(_wrkCtrParmSchedule, wrkCtrTable, dateMax()) : dateNull();
                limitedProperty = _wrkCtrParmSchedule.propertyLimited() && wrkCtrTable.PropertyLimited && _jobPropertyId;

                wrkCtrJobTime = mapEnumerator.currentValue();

                // Set job time for Setup to zero if using finite property scheduling
                if (WrkCtrSchedulerFinitePropertySecondaryOperationFlight::instance().isEnabled())
                {
                    wrkCtrJobTime = this.setupTimeWithFiniteProperty(wrkCtrJobTime, limitedProperty, _jobType, _jobIsPrimary, _wrkCtrParmSchedule, _primaryParallelJobRecId);
                }
                else
                {
                    if (limitedProperty && _jobType == RouteJobType::Setup)
                    {
                        wrkCtrJobTime = 0;
                    }
                }

                // Add work center to job
                if (_jobSchedWorkTime)
                {
                    // Some scheduling properties are resource dependent as the job property should only be respected if
                    // the resource has the Limited property flag set.
                    if (limitedProperty)
                    {
                        requirementProperties.insert(WrkCtrSchedulingProperty::propertySchedulingProperty(_jobPropertyId), 0.0);
                    }

                    scheduleEngine.addJobResourceCapacity(_jobRecId,
                                                            wrkCtrTable.WrkCtrId,
                                                            wrkCtrJobTime,
                                                            _jobLoadPct / 100,
                                                            DateTimeUtil::newDateTime(limitedCapacityToDate, 0),
                                                            requirementProperties,
                                                            limitedCapacity,
                                                            ignoreResourceEfficiency);

                    if (limitedProperty)
                    {
                        scheduleEngine.setJobResourcePreemptionAllowed(_jobRecId, wrkCtrTable.WrkCtrId, true);
                    }
                }
                else
                {
                    scheduleEngine.addJobResourceRuntime(_jobRecId,
                                                         wrkCtrTable.WrkCtrId,
                                                         wrkCtrJobTime);
                }

                // Set resource priorities for job scheduling
                if (_wrkCtrParmSchedule.schedMethod() == SchedMethod::Detail)
                {
                    resourcePriority = this.calculateResourcePriority(wrkCtrTable, _requirementProperties, _wrkCtrParmSchedule.schedDate());
                    if (resourcePriority != 0.0)
                    {
                        scheduleEngine.addJobResourcePriority(_jobRecId, wrkCtrTable.WrkCtrId, resourcePriority);
                    }
                }
            }
        }

        if (_wrkCtrParmSchedule.schedMethod() == SchedMethod::Rough)
        {
            resourceId = this.getResourceRequirement(_requirementProperties);
            if (resourceId != '')
            {
                scheduleEngine.addConstraintResourceRequirement( _jobRecId, resourceId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupTimeWithFiniteProperty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finite property scheduling uses either resource with Property or Setup time.
    /// If Operation has Setup time and Property then only the following is possible:
    /// Given: Operation requires a Resource group
    ///        Resource group has two resources: Resource1 with Property and Resource2 without Property
    /// When/Then: Scheduling with Finite property is run:
    ///    If Resource1 is used for Operation then no Setup job is created
    ///    If Resource2 is used for Operation then Setup job is created
    /// </summary>
    /// <returns>Return Setup time</returns>
    protected RealBase setupTimeWithFiniteProperty(RealBase _wrkCtrJobTime, boolean _limitedProperty, RouteJobType _jobType, boolean _jobIsPrimary, WrkCtrParmSchedule _wrkCtrParmSchedule, RecId _primaryParallelJobRecId)
    {
        RealBase wrkCtrJobTime = _wrkCtrJobTime;

        if (_limitedProperty && _jobType == RouteJobType::Setup)
        {
            wrkCtrJobTime = 0;
        }

        //Setup job time for Secondary Setup to zero if using finite property scheduling
        //It can't be identifed what resource will be used by the Primary Setup job with or without property limited.
        //If Primary Setup job is 1 hour the Secondary Setup job will be adjusted automatically to 1 hour in DLL
        if (_jobIsPrimary == false &&
            _jobType == RouteJobType::Setup &&
            _wrkCtrParmSchedule.propertyLimited())
        {
            if (jobData && jobData.exists(_primaryParallelJobRecId))
            {
                RouteJobMap job = jobData.lookup(_primaryParallelJobRecId);

                if (job.PropertyId)
                {
                    wrkCtrJobTime = 0;
                }
            }
        }

        return wrkCtrJobTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertJobAndConstraints</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts jobs and constraints to be scheduled into the engine data pool.
    /// </summary>
    /// <param name="_routeJobMap">
    /// A <c>RouteMap</c> table map that contains the current route.
    /// </param>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> object that contains the order scheduling parameters for the order to
    /// which the job belongs.
    /// </param>
    /// <param name="_prodUnitId">
    /// The production unit to use for filtering resources that are available for scheduling.
    /// </param>
    /// <param name="_inputWarehouse">
    /// The input warehouse to use for filtering resources that are available for scheduling.
    /// </param>
    /// <param name="_requirementProperties">
    /// A <c>Map</c> that contains all the properties that the resource or working time should have to run
    /// the job.
    /// </param>
    /// <param name="_jobTimes">
    /// A <c>Map</c> that contains all the resources on which the job can be scheduled and the runtime of
    /// the job on each resource.
    /// </param>
    /// <param name="_wrkCtrActivityRequirementSet">
    /// A <c>WrkCtrActivityRequirementSet</c> record that is connected to the operation data.
    /// </param>
    /// <param name="_oprNumNext">
    /// An <c>OprNum</c> value that specifies the next operation number.
    /// </param>
    /// <param name="_prodJobType">
    /// A <c>RouteJobType</c> value that specifies the type of job to schedule (Setup, Process, etc.).
    /// </param>
    /// <param name="_routeGroup">
    /// A <c>RouteGroup</c> table buffer that defines the run time calculation parameters.
    /// </param>
    /// <param name="_goal">
    /// A <c>WrkCtrSchedulerGoal</c> value that specifies the goal to use for scheduling the job.
    /// </param>
    /// <param name="_useFastSetup">
    /// A Boolean value that indicates whether fast setup should be used.
    /// </param>
    /// <param name="_jobTimeForAllResources">
    /// A number that determines the runtime for all resources when fast setup is used.
    /// </param>
    /// <param name="_jobNumPrev">
    /// The Record ID identifier of the previous job.
    /// </param>
    /// <param name="_mapJobNumPrevNumPrimSec">
    /// A <c>Map</c> that contains the already created jobs.
    /// </param>
    /// <param name="_resourceList">
    /// A <c>List</c> of all applicable resources.
    /// </param>
    /// <param name="_isFirstJob">
    /// A Boolean value that indicates whether the job is the first job.
    /// </param>
    /// <param name="_jobTypePrev">
    /// A <c>RouteJobType</c> enumeration value that specifies the previous job type.
    /// </param>
    /// <param name="_primaryLink">
    /// A <c>SchedJobLink</c> enumeration value that specifies the primary link.
    /// </param>
    /// <param name="_primaryLinkType">
    /// A <c>SchedJobLinkType</c> enumeration that specifies the primary link type.
    /// </param>
    /// <param name="_jobNumFirst">
    /// A Record ID identifier that specifies the first job.
    /// </param>
    /// <param name="_primaryParallelJobRecId">
    /// A <c>RecId</c> value that identifies the primary job of a set of parallel jobs.
    /// </param>
    /// <returns>
    /// A Container that contains the new job state.
    /// </returns>
    protected container insertJobAndConstraints(RouteJobMap                    _routeJobMap,
                                                WrkCtrParmSchedule             _wrkCtrParmSchedule,
                                                ProdUnitId                     _prodUnitId,
                                                InventLocationIdInput          _inputWarehouse,
                                                Map                            _requirementProperties,
                                                Map                            _jobTimes,
                                                WrkCtrActivityRequirementSet   _wrkCtrActivityRequirementSet,
                                                OprNum                         _oprNumNext,
                                                ProdJobType                    _prodJobType,
                                                RouteGroup                     _routeGroup,
                                                WrkCtrSchedulerGoal            _goal,
                                                boolean                        _useFastSetup,
                                                real                           _jobTimeForAllResources,
                                                RecId                          _jobNumPrev,
                                                Map                            _mapJobNumPrevNumPrimSec,
                                                List                           _resourceList,
                                                boolean                        _isFirstJob,
                                                RouteJobType                   _jobTypePrev,
                                                SchedJobLink                   _primaryLink,
                                                SchedJobLinkType               _primaryLinkType,
                                                RecId                          _jobNumFirst,
                                                RecId                          _primaryParallelJobRecId = 0
                                                )
    {
        RecId  jobNum = _routeJobMap.RecId ;
        str    numPrimSec;
        RecId  jobNumPrevNumPrimSec;
        str    numPrim;
        RecId  jobNumPrimary;

        SchedJobLink                   primaryLink      = _primaryLink ;
        SchedJobLinkType               primaryLinkType  = _primaryLinkType;
        boolean                        isFirstJob       = _isFirstJob;
        RecId                          jobNumFirst      = _jobNumFirst;
        RecId                          jobNumPrev       = _jobNumPrev;
        RouteJobType                   jobTypePrev      = _jobTypePrev;

        // clear the calculated (estimated) time for the job
        _routeJobMap.CalcTimeHours   = 0;

        //Insert job and work center combinations (where the work center from the Route is expanded)
        this.insertJob(_wrkCtrParmSchedule,
                       jobNum,
                       _routeJobMap,
                       _routeJobMap.JobType,
                       _routeJobMap.PropertyId,
                       _prodUnitId,
                       _inputWarehouse,
                       _requirementProperties,
                       _jobTimes,
                       _wrkCtrActivityRequirementSet.LoadPercent,
                       _routeJobMap.OprNum,
                       _oprNumNext,
                       !this.shouldIgnoreJobCapacityConstraints(_routeJobMap) && _prodJobType.scheduleWorkTime(_routeGroup),
                       !this.shouldIgnoreJobCapacityConstraints(_routeJobMap) && _prodJobType.scheduleCapacity(_routeGroup),
                       _goal,
                       _wrkCtrActivityRequirementSet.Quantity,
                       _useFastSetup,
                       _jobTimeForAllResources,
                       (_routeJobMap.OprPriority == RouteOprPriority::Primary),
                       _primaryParallelJobRecId);

        // insert parallel job
        this.insertParallelJob(_routeJobMap.JobType, _routeJobMap.RecId, _wrkCtrParmSchedule.schedMethod());

        //Create link between previous job (on this operation) and the current job
        if (_jobNumPrev)
        {
            if (_routeJobMap.OprPriority != RouteOprPriority::Primary)
            {
                scheduleEngine.addJobLink(_jobNumPrev, jobNum, any2int(SchedJobLink::SS), any2int(SchedJobLinkType::Hard));
                scheduleEngine.addJobLink(_jobNumPrev, jobNum, any2int(SchedJobLink::FF), any2int(SchedJobLinkType::Hard));
            }
        }

        numPrimSec = strFmt('%1#%2#%3', _routeJobMap.OprPriority, _routeJobMap.NumPrimary, _routeJobMap.NumSecondary);
        if (_mapJobNumPrevNumPrimSec.exists(numPrimSec))
        {
            //All jobs with same primary/secondary number on the same operation should be connected to the same work center
            jobNumPrevNumPrimSec = _mapJobNumPrevNumPrimSec.lookup(numPrimSec);
            scheduleEngine.addConstraintOnSameResource(jobNum, jobNumPrevNumPrimSec);
        }
        //Save the last job number per NumPrimary/NumSecondary
        _mapJobNumPrevNumPrimSec.insert(numPrimSec,jobNum);

        if ((_wrkCtrParmSchedule.schedMethod() == SchedMethod::Rough) &&
            (_routeJobMap.OprPriority != RouteOprPriority::Primary))
        {
            // Operations scheduling. Secondary operation.
            // Find primary job and add constraint

            numPrim = strFmt('%1#%2#%3', RouteOprPriority::Primary, _routeJobMap.NumSecondary, 0);
            jobNumPrimary = _mapJobNumPrevNumPrimSec.lookup(numPrim);

            scheduleEngine.addJobSameReservations(jobNum, jobNumPrimary, _resourceList, _wrkCtrActivityRequirementSet.LoadPercent / 100.0);
        }

        if (!_isFirstJob)
        {
            if (_jobTypePrev != _routeJobMap.JobType)
            {
                // insert constraints for parallel jobs for a specific job type
                this.insertParallelJobsConstraints(_jobTypePrev,
                                                   jobNum,
                                                   any2int(_primaryLink),
                                                   any2int(_primaryLinkType),
                                                   _wrkCtrParmSchedule.schedMethod());
            }
            else
            {
                if (_routeJobMap.OprPriority == RouteOprPriority::Primary)
                {
                    scheduleEngine.addJobLink(_jobNumPrev,
                                              jobNum,
                                              any2int(_primaryLink),
                                              any2int(_primaryLinkType));
                }
            }
        }

        if (_routeJobMap.OprPriority == RouteOprPriority::Primary)
        {
            //Save the link to the next primary operation
            primaryLink        = _routeJobMap.Link;
            primaryLinkType    = _routeJobMap.LinkType;
        }

        if (_isFirstJob)
        {
            jobNumFirst = jobNum;
            isFirstJob = false;
        }

        jobNumPrev = jobNum;
        jobTypePrev = _routeJobMap.JobType;

        return [primaryLink, primaryLinkType, jobNumFirst, isFirstJob, jobNumPrev, jobTypePrev];
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldIgnoreJobCapacityConstraints</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the scheduling engine needs to ignore the job capacity constraints.
    /// </summary>
    /// <param name="_routeJobMap">
    /// A <c>RouteMap</c> table map that contains the current route.
    /// </param>
    /// <returns>Return true if the scheduling engine needs to ignore the job capacity constraints.</returns>
    protected boolean shouldIgnoreJobCapacityConstraints(RouteJobMap _routeJobMap)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertJobGoalConstraints</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates constraints that depend on the scheduling goal for a given job.
    /// </summary>
    /// <param name="_jobRecId">
    /// The job ID.
    /// </param>
    /// <param name="_goal">
    /// The scheduling goal (latest start, earliest end).
    /// </param>
    /// <param name="_minSchedDate">
    /// The minimal scheduling date.
    /// </param>
    /// <param name="_minSchedTime">
    /// The minimal scheduling time of the day.
    /// </param>
    /// <param name="_schedDate">
    /// The target scheduling date.
    /// </param>
    /// <param name="_schedTime">
    /// The target scheduling time.
    /// </param>
    /// <param name="_scheduleStartPointIsSequenceStartPoint">
    /// A Boolean value indicating whether the scheduling starting point is
    /// one of the sequence's starting points (beginning or end).
    /// If false, this means that the sequence is being scheduled from the middle,
    /// so the level zero start date constraints will be emitted on today's date
    /// (and not on the chosen scheduling date).
    /// </param>
    protected void insertJobGoalConstraints(RecId               _jobRecId,
                                            WrkCtrSchedulerGoal _goal,
                                            SchedDate           _minSchedDate,
                                            TimeOfDay           _minSchedTime,
                                            SchedDate           _schedDate,
                                            TimeOfDay           _schedTime,
                                            boolean             _scheduleStartPointIsSequenceStartPoint = true
                                            )
    {
        TransDate startsAtDate = _minSchedDate;
        TimeOfDay startsAtTime = _minSchedTime;

        // Restrict end/start times depending on direction
        if (_goal == WrkCtrSchedulerGoal::LatestStartTime)
        {
            if (_scheduleStartPointIsSequenceStartPoint)
            {
                scheduleEngine.addConstraintJobEndsAt(_jobRecId,
                                                      1,
                                                      DateTimeUtil::newDateTime(_schedDate, _schedTime));
            }

            scheduleEngine.addJobGoal(_jobRecId, 1, _goal);
        }
        else if (_scheduleStartPointIsSequenceStartPoint)
        {
            if (_schedDate > startsAtDate ||
                (_schedDate == startsAtDate && _schedTime > startsAtTime))
            {
                startsAtDate = _schedDate;
                startsAtTime = _schedTime;
            }
        }

        scheduleEngine.addConstraintJobStartsAt(_jobRecId,
                                                0,
                                                DateTimeUtil::newDateTime(startsAtDate, startsAtTime));
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertLeadTimeJob</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts a lead time job to enable the engine to schedule routeless orders.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> object that contains the order scheduling parameters.
    /// </param>
    /// <param name="_refId">
    ///    The top level collect order ID.
    /// </param>
    /// <param name="_refIdOrig">
    ///    The original order ID.
    /// </param>
    /// <param name="_setupDim">
    ///    A <c>ReqSetupDim</c> object that is used to determine which calendar to use for lead times.
    /// </param>
    /// <param name="_leadTime">
    ///    A lead time that is that will be used as length for the job that is created as a placeholder for
    ///    the whole order.
    /// </param>
    /// <param name="_calendarDays">
    ///    true if calendar days should be used; false if a 24 hours a day, seven days a week calendar is used.
    /// </param>
    /// <param name="_startCollectRefLevel">
    ///    A starting route level that determines the order of the operations.
    /// </param>
    /// <param name="_currentCollectRefLevel">
    ///    A current route level.
    /// </param>
    /// <param name="_minSchedDate">
    ///    The minimum schedule date. If forward scheduling is used this will be passed as a <c>StartsAt</c>
    ///    constraint.
    /// </param>
    /// <param name="_minSchedTime">
    ///    The minimum schedule time. If forward scheduling is used this will be passed as a <c>StartsAt</c>
    ///    constraint.
    /// </param>
    /// <returns>
    ///    A <c>RecId</c> object that identifies the temporary table buffer with the created placeholder job.
    /// </returns>
    protected RecId insertLeadTimeJob(WrkCtrParmSchedule       _wrkCtrParmSchedule,
                                      InventRefId              _refId,
                                      InventRefId              _refIdOrig,
                                      ReqSetupDim              _setupDim,
                                      Days                     _leadTime,
                                      CalendarDays             _calendarDays,
                                      BOMLevel                 _startCollectRefLevel,
                                      BOMLevel                 _currentCollectRefLevel,
                                      SchedDate                _minSchedDate = _wrkCtrParmSchedule.minimumSchedDate(),
                                      SchedTime                _minSchedTime = 0)
    {
        // Create new temporary route and job record for the original refId (not the collect ref)
        Common route = this.createTmpRoute(_refIdOrig);
        Common routeJob = this.createTmpRouteJob(_refIdOrig);

        this.insertLeadTimeJobByRecId(
            routeJob.RecId,
            _wrkCtrParmSchedule,
            _setupDim,
            _leadTime,
            _calendarDays,
            _startCollectRefLevel,
            _currentCollectRefLevel,
            _minSchedDate,
            _minSchedTime);

        return routeJob.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertLeadTimeJobAsConstraint</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts a lead time job that is only to be used as an additional constraint between other jobs.
    ///    No capacity will be reserved for the job and it will not affect the overall start/end of the order.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> object that contains the order scheduling parameters.
    /// </param>
    /// <param name="_setupDim">
    ///    A <c>ReqSetupDim</c> object that is used to determine which calendar to use for lead times.
    /// </param>
    /// <param name="_leadTime">
    ///    A lead time that will be used as length for the job that is created as a placeholder for
    ///    the whole order.
    /// </param>
    /// <param name="_calendarDays">
    ///    true if calendar days should be used; false if a 24 hours a day, seven days a week calendar is used.
    /// </param>
    /// <param name="_startCollectRefLevel">
    ///    A starting route level that determines the order of the operations.
    /// </param>
    /// <param name="_currentCollectRefLevel">
    ///    A current route level.
    /// </param>
    /// <param name="_minSchedDate">
    ///    The minimum schedule date. If forward scheduling is used this will be passed as a <c>StartsAt</c>
    ///    constraint.
    /// </param>
    /// <param name="_minSchedTime">
    ///    The minimum schedule time. If forward scheduling is used this will be passed as a <c>StartsAt</c>
    ///    constraint.
    /// </param>
    /// <returns>
    ///    A <c>RecId</c> object that identifies the job.
    /// </returns>
    protected RecId insertLeadTimeJobAsConstraint(
        WrkCtrParmSchedule       _wrkCtrParmSchedule,                                      
        ReqSetupDim              _setupDim,
        Days                     _leadTime,
        CalendarDays             _calendarDays,
        BOMLevel                 _startCollectRefLevel,
        BOMLevel                 _currentCollectRefLevel,
        SchedDate                _minSchedDate = _wrkCtrParmSchedule.minimumSchedDate(),
        SchedTime                _minSchedTime = 0)
    {
        // Create a new fake recId that is unique within this scheduling run.
        RecId jobRecId = constraintJobs.elements() + 1;

        this.insertLeadTimeJobByRecId(
            jobRecId,
            _wrkCtrParmSchedule,
            _setupDim,
            _leadTime,
            _calendarDays,
            _startCollectRefLevel,
            _currentCollectRefLevel,
            _minSchedDate,
            _minSchedTime);

        constraintJobs.add(jobRecId);

        return jobRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertLeadTimeJobByRecId</Name>
				<Source><![CDATA[
    private void insertLeadTimeJobByRecId(
        RecId _jobRecId,                              
        WrkCtrParmSchedule       _wrkCtrParmSchedule,                                      
        ReqSetupDim              _setupDim,
        Days                     _leadTime,
        CalendarDays             _calendarDays,
        BOMLevel                 _startCollectRefLevel,
        BOMLevel                 _currentCollectRefLevel,
        SchedDate                _minSchedDate = _wrkCtrParmSchedule.minimumSchedDate(),
        SchedTime                _minSchedTime = 0)
    {
        WrkCtrSchedulerGoal         goal;
        RealBase                    jobTime;

        CalendarDays                calendarDays = _calendarDays;

        str                         calendarId = _setupDim.reqCalendarId();

        goal = this.computeJobGoal(_wrkCtrParmSchedule, _currentCollectRefLevel, _startCollectRefLevel);

        // Calculate job time
        jobTime = _leadTime * #secondsPerDay;

        if (!calendarId)
        {
            calendarId = #EmptyResource;
            calendarDays = NoYes::No;
        }

        calendarId = #CalendarResourceIdPrefix + calendarId;

        // Add the job
        scheduleEngine.addJobInfo(_jobRecId,
                                  WrkCtrSchedulerGoal::EarliestEndTime,
                                  _calendarDays,
                                  false);

        // add the maximal job days
        scheduleEngine.addConstraintMaxJobDays(_jobRecId, _wrkCtrParmSchedule.maxJobDays());

        masterDataJobRecId.insert(_wrkCtrParmSchedule.schedNumId(), _jobRecId);

        // Insert the resource
        this.addCalendarResource(_wrkCtrParmSchedule, calendarId);

        if (_calendarDays)
        {
            // Add work center to job
            scheduleEngine.addJobResourceCapacity(_jobRecId,
                                                  calendarId,
                                                  jobTime,
                                                  1,
                                                  DateTimeUtil::newDateTime(dateNull(),0),
                                                  new Map(Types::String, Types::Real),
                                                  false);
        }
        else
        {
            scheduleEngine.addJobResourceRuntime(_jobRecId,
                                                 calendarId,
                                                 jobTime);
        }

        this.insertJobGoalConstraints(_jobRecId, goal, _minSchedDate, _minSchedTime, _wrkCtrParmSchedule.schedDate(), _wrkCtrParmSchedule.schedTime());
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertOverlapLinks</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts the links that are generated by the overlap jobs.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    An instance of the <c>WrkCtrParmSchedule</c> class that contains the schedule parameters for the
    ///    scheduled order.
    /// </param>
    /// <param name="_overlapSuccessorJobs">
    ///     Map from operation to list of its jobs.
    ///     Key = this.KeyRoute(RefId, OprNum, OprPriority); Value = List(Types::Int64)
    /// </param>
    /// <param name="_operationTransferBatchToProcessTimeRatios">
    ///     Map from operation to ratio between transfer batch time and process time.
    ///     Key = this.KeyRoute(RefId, OprNum, OprPriority); Value = ratio between transfer batch time and process time.
    /// </param>
    /// <remarks>
    ///    The links that are generated due to the existence of any overlap jobs are between the process job
    ///    of the current operation and the process job of the next operation.
    /// </remarks>
    protected void insertOverlapLinks(
        WrkCtrParmSchedule _wrkCtrParmSchedule,
        Map _overlapSuccessorJobs,
        Map _operationTransferBatchToProcessTimeRatios)
    {
        str currOprKey;
        str nextOprKey;
        List overlapSuccesorJobList;

        MapEnumerator mapEnumerator = overlapJobLinks.getEnumerator();
        while (mapEnumerator && mapEnumerator.moveNext())
        {
            currOprKey = mapEnumerator.currentKey();
            nextOprKey = mapEnumerator.currentValue();

            if (oprProcessJobIds.exists(currOprKey) &&
                oprProcessJobIds.exists(nextOprKey) &&
                _operationTransferBatchToProcessTimeRatios.exists(currOprKey))
            {
                if (_overlapSuccessorJobs.exists(nextOprKey))
                {
                    overlapSuccesorJobList = _overlapSuccessorJobs.lookup(nextOprKey);
                }
                else
                {
                    overlapSuccesorJobList = new List(Types::Int64);
                }

                scheduleEngine.addConstraintJobOverlap(oprOverlapJobIds.lookup(currOprKey),
                                                       oprProcessJobIds.lookup(currOprKey),
                                                       oprProcessJobIds.lookup(nextOprKey),
                                                       _operationTransferBatchToProcessTimeRatios.lookup(currOprKey),
                                                       overlapSuccesorJobList);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertParallelJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a parallel job in the internal map used to track parallel jobs for each job type.
    /// </summary>
    /// <param name="_jobType">
    /// A <c>RouteJobType</c> value that specifies the job type to be added to the parallel jobs map.
    /// </param>
    /// <param name="_jobNum">
    /// A <c>RecId</c> value that identifies the job.
    /// </param>
    /// <param name="_schedMethod">
    /// A <c>SchedMethod</c> value defining the scheduling method.
    /// </param>
    protected void insertParallelJob(RouteJobType   _jobType,
                                     RecId          _jobNum,
                                     SchedMethod     _schedMethod = SchedMethod::Detail)
    {
        List            lstJobsNotOnSameResource;

        // constraint the job not to be on the same resource with other jobs from the same pool
        if (!mapParallelJobs.exists(_jobType))
        {
            lstJobsNotOnSameResource = new List(Types::Int64);
            mapParallelJobs.insert(_jobType, lstJobsNotOnSameResource);
        }
        else
        {
            lstJobsNotOnSameResource = mapParallelJobs.lookup(_jobType);
        }

        lstJobsNotOnSameResource.addEnd(_jobNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertParallelJobsConstraints</Name>
				<Source><![CDATA[
    /// <summary>
    /// Emits all the constraints for all the parallel jobs of a certain type.
    /// </summary>
    /// <param name="_jobType">
    /// A <c>RouteJobType</c> value that specifies the type of job.
    /// </param>
    /// <param name="_jobNumNext">
    /// A <c>RecId</c> for the link next job.
    /// </param>
    /// <param name="_link">
    /// A <c>SchedJobLink</c> value defining the link relation.
    /// </param>
    /// <param name="_linkType">
    /// A <c>SchedJobLinkType</c> value defining the type of link (Soft or Hard).
    /// </param>
    /// <param name="_schedMethod">
    /// A <c>SchedMethod</c> value defining the scheduling method.
    /// </param>
    protected void insertParallelJobsConstraints(RouteJobType       _jobType,
                                                 RecId              _jobNumNext,
                                                 SchedJobLink       _link,
                                                 SchedJobLinkType   _linkType,
                                                 SchedMethod        _schedMethod = SchedMethod::Detail)
    {
        List            parallelJobs;
        ListEnumerator  jobEnumerator;
        Array           parallelJobsArr;
        int             jobIdx;
        RouteJobMap     jobRecord1;
        RouteJobMap     jobRecord2;

        if (mapParallelJobs.exists(_jobType))
        {
            parallelJobs = mapParallelJobs.lookup(_jobType);
            if ((_schedMethod==SchedMethod::Detail) && (parallelJobs.elements() > 1))
            {
                // add the constraint that the jobs in the list must intersect their working times when scheduled
                scheduleEngine.addConstraintJobListWorkingTimeIntersect(parallelJobs);

                // Add constraint between all job combinations in the list that they must not run on the same resource
                parallelJobsArr = new Array(Types::Int64);
                jobEnumerator = parallelJobs.getEnumerator();
                while (jobEnumerator && jobEnumerator.moveNext())
                {
                    if (jobData.exists(jobEnumerator.current()))
                    {
                        jobRecord1 = jobData.lookup(jobEnumerator.current());
                        for (jobIdx = 1; jobIdx <= parallelJobsArr.lastIndex(); jobIdx++)
                        {
                            jobRecord2 = jobData.lookup(parallelJobsArr.value(jobIdx));

                            // The same primary job's secondary job shouldn't have this constraints as they can be scheduled
                            // on the same resource when load percent on the same resource has enough capacity
                            if (jobRecord1.NumSecondary && (jobRecord1.OprNum == jobRecord2.OprNum) && (jobRecord1.NumSecondary == jobRecord2.NumSecondary))
                            {
                                continue;
                            }

                            scheduleEngine.addConstraintNotOnSameResource(parallelJobsArr.value(jobIdx), jobEnumerator.current());
                        }

                        parallelJobsArr.value(jobIdx, jobEnumerator.current());
                    }
                }
            }

            if (_jobNumNext)
            {
                jobEnumerator = parallelJobs.getEnumerator();
                while (jobEnumerator && jobEnumerator.moveNext())
                {
                    scheduleEngine.addJobLink(jobEnumerator.current(),
                                              _jobNumNext,
                                              _link,
                                              _linkType);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertResource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a resource in the resource list of the scheduling engine.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>wrkCtrParmSchedule</c> object with the order scheduling parameters.
    /// </param>
    /// <param name="_wrkCtrTable">
    /// A <c>WrkCtrTable</c> table buffer that contains the resource data.
    /// </param>
    /// <param name="_addResourceGroupMembership">
    /// A Boolean value that indicates whether to add resource group membership information; optional.
    /// </param>
    protected void insertResource(WrkCtrParmSchedule    _wrkCtrParmSchedule,
                                  WrkCtrTable           _wrkCtrTable,
                                  boolean               _addResourceGroupMembership = true)
    {
        boolean roughScheduling = _wrkCtrParmSchedule.schedMethod() == SchedMethod::Rough;
        str resourceId = _wrkCtrTable.WrkCtrId;

        if (_wrkCtrTable.IsIndividualResource)
        {
            if (loadedResources.in(resourceId))
            {
                return;
            }

            scheduleEngine.addResource(resourceId,
                                       _wrkCtrTable.Exclusive,
                                       roughScheduling ? _wrkCtrTable.OperationSchedPct / 100 : 1,
                                       WrkCtrSchedulerWorkingTimesType::Resource,
                                       _wrkCtrParmSchedule.parmLoadJobSchedulingCapacity(),
                                       _wrkCtrParmSchedule.parmLoadOperationSchedulingCapacity(),
                                       _wrkCtrTable.EffectivityPct / 100);

            loadedResources.add(resourceId);
        }
        else
        {
            if (loadedResourceGroups.in(resourceId))
            {
                return;
            }

            scheduleEngine.addResourceGroup(
                                            resourceId,
                                            (_wrkCtrTable.OperationSchedPct/100.0),
                                            (_wrkCtrTable.CapLimited == NoYes::Yes),
                                            DateTimeUtil::newDateTime(dateNull(),0));

            // Add all resources that may belong to the resource group.
            var resourceGroup = WrkCtrTable::resourceGroup(resourceId,  dateNull(), dateMax());
            var resourceGroupMember = WrkCtrResourceGroupResource::resourceGroupMembers(resourceGroup.RecId, dateNull(), dateMax());
            while (resourceGroupMember)
            {
                if (!loadedResources.in(resourceGroupMember.WrkCtrId))
                {
                    this.insertResource(_wrkCtrParmSchedule, resourceGroupMember.findExistingWrkCtrTable(), false);
                }

                scheduleEngine.addResourceGroupMembership(
                                resourceId,
                                resourceGroupMember.WrkCtrId,
                                DateTimeUtil::newDateTime(resourceGroupMember.ValidFrom, 0),
                                DateTimeUtil::newDateTime(resourceGroupMember.ValidTo, 0) );

                next resourceGroupMember;
            }

            loadedResourceGroups.add(resourceId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertWrkCtrCapResUsingInsertList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the given capacity reservation using the internal record insert list.
    /// </summary>
    /// <param name="_wrkCtrCapRes">
    /// The capacity reservation to insert.
    /// </param>
    protected void insertWrkCtrCapResUsingInsertList(WrkCtrCapRes _wrkCtrCapRes)
    {
        if (this.mustInsertWrkCtrCapRes(_wrkCtrCapRes))
        {
            capacityReservationsInsertList.add(_wrkCtrCapRes);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustInsertWrkCtrCapRes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the given capacity reservation must be inserted.
    /// </summary>
    /// <param name="_wrkCtrCapRes">
    /// The capacity reservation to insert.
    /// </param>
    /// <returns>
    /// true if the given capacity reservation must be inserted; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method is an extension point to control the insertion of the capacity reservation.
    /// </remarks>
    protected boolean mustInsertWrkCtrCapRes(WrkCtrCapRes _wrkCtrCapRes)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>keyOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a value that can be used in maps that have the order ID as their key.
    /// </summary>
    /// <param name="_common">
    ///    A <c>Common</c> table buffer that contains the order data.
    /// </param>
    /// <returns>
    ///    A string that contains the value that will be used as the key for the specified order record.
    /// </returns>
    protected str keyOrder(Common _common)
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>keyRoute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Computes a key for an operation.
    /// </summary>
    /// <param name="_refId">
    /// Order identifier used for computing the key.
    /// </param>
    /// <param name="_oprNum">
    /// Operation number used for computing the key.
    /// </param>
    /// <param name="_oprPriority">
    /// Operation priority used for computing the key.
    /// </param>
    /// <returns>
    /// A string that contains the key value that uniquely identifies the specified operation of the order.
    /// </returns>
    /// <remarks>
    /// The key is used for storing operation information in maps.
    /// </remarks>
    protected str keyRoute(InventTransRefId _refId,
                           OprNum           _oprNum,
                           RouteOprPriority _oprPriority)
    {
        return _refId + '#' + int2str(_oprNum) + '#' + enum2str(_oprPriority);
    }

]]></Source>
			</Method>
			<Method>
				<Name>leadTimeParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Computes the lead time parameters for a given order.
    /// </summary>
    /// <param name="_order">
    /// The order for which to retrieve the lead time parameters.
    /// </param>
    /// <returns>
    /// A container in the format lead time. Lead time uses calendar days.
    /// </returns>
    protected container leadTimeParameters(Common _order)
    {
        return [0, 0];
    }

]]></Source>
			</Method>
			<Method>
				<Name>limitCapPO</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies whether the capacity reservations that are derived from planned orders will be included
    /// in the calculation of available capacity when scheduling is executed.
    /// </summary>
    /// <param name="_inventDimId">
    /// The <c>InventDimId</c> value that identifies the dimension by which to return the option to use the
    /// planned production orders capacity reservations.
    /// </param>
    /// <returns>
    /// Always returns true. The overriding methods should return the value according to the specific needs
    /// of the overriding class.
    /// </returns>
    /// <remarks>
    /// Should be overridden in derived classes, as the derived class represents a module from where this
    /// functionality should be parameter-controlled.
    /// </remarks>
    public boolean limitCapPO(InventDimId _inventDimId)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>limitCapProd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the capacity reservations that are derived from production orders will be
    /// included in the calculation of available capacity when it executes scheduling.
    /// </summary>
    /// <param name="_inventDimId">
    /// The <c>InventDimId</c> value that identifies the dimension by which to return the option to use the
    /// production orders capacity reservations.
    /// </param>
    /// <returns>
    /// Always returns true.
    /// </returns>
    /// <remarks>
    /// The overriding methods should return the value according to the specific needs of the overriding
    /// class.Should be overridden in derived classes, as the derived class represents a module from which
    /// this functionality should be parameter-controlled.
    /// </remarks>
    public boolean limitCapProd(InventDimId _inventDimId)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>limitCapProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies whether the reservations that are derived from projects will be included in the
    /// calculation of available capacity when executing scheduling.
    /// </summary>
    /// <param name="_inventDimId">
    /// The <c>InventDimId</c> value that identifies the dimension by which to return the option to use the
    /// project hour forecast capacity reservations.
    /// </param>
    /// <returns>
    /// Always returns true.
    /// </returns>
    /// <remarks>
    /// The overriding methods should return the value according to the specific needs of the overriding
    /// class.Should be overridden in derived classes, as the derived class represents a module from which
    /// this functionality should be parameter-controlled.
    /// </remarks>
    public boolean limitCapProject(InventDimId _inventDimId)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>limitedCapacity</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Computes whether limited capacity should be used when scheduling a certain order and using a
    ///    specific resource.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> object that uses the order scheduling parameters.
    /// </param>
    /// <param name="_wrkCtrTable">
    ///    A <c>WrkCtrTable</c> record with the resource data.
    /// </param>
    /// <returns>
    ///    true if limited capacity should be used; otherwise, false.
    /// </returns>
    protected boolean limitedCapacity(WrkCtrParmSchedule    _wrkCtrParmSchedule,
                                      WrkCtrTable           _wrkCtrTable)
    {
        boolean result = false;

        if (_wrkCtrParmSchedule.capacityLimited() &&
            _wrkCtrTable.CapLimited)
        {
            result = true;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>limitedCapacityToDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Computes the capacity time fence for an order and a specific resource.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> object that contains order scheduling parameters.
    /// </param>
    /// <param name="_wrkCtrTable">
    ///    A <c>WrkCtrTable</c> record that contains the resource details.
    /// </param>
    /// <param name="_workTimeToDate">
    ///    A maximal date up to which limited capacity can be used.
    /// </param>
    /// <returns>
    ///    A <c>Date</c> object that has the limited capacity fence.
    /// </returns>
    protected TransDate limitedCapacityToDate(WrkCtrParmSchedule    _wrkCtrParmSchedule,
                                              WrkCtrTable           _wrkCtrTable,
                                              TransDate             _workTimeToDate)
    {
        TransDate finiteDate = dateNull();

        if (_wrkCtrParmSchedule.capacityLimited() &&
            _wrkCtrTable.CapLimited)
        {
            finiteDate = _workTimeToDate;
        }

        return finiteDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLatestMaterialAvailabilityDate</Name>
				<Source><![CDATA[
    [Replaceable]
    protected ReqDateTime getLatestMaterialAvailabilityDate(
        WrkCtrParmSchedule	_wrkCtrParmSchedule,
        Common              _order,
        OprNum				_oprNum)
    {
        ReqTrans	reqTransDerived;
        ReqTrans    reqTransReceipt;
        ReqTransCov reqTransCov;
        ProdTable   prodTableLocal;

        // Find the last futures date/time
        select firstonly FuturesDate, FuturesTime, OprNum, BOMRefRecId from reqTransDerived
            order by FuturesDate desc, FuturesTime desc
            where reqTransDerived.PlanVersion   == _wrkCtrParmSchedule.parmReqPlanVersionRefRecId()
                && reqTransDerived.RefType       == this.refLineType(_order)
                && reqTransDerived.RefId         == this.refId(_wrkCtrParmSchedule, _order)
                && (reqTransDerived.OprNum       == _oprNum || !reqTransDerived.OprNum || !_oprNum)
                && reqTransDerived.Direction     == InventDirection::Issue
            notexists join reqTransCov
                where reqTransCov.IssueRecId        == reqTransDerived.RecId
            exists join reqTransReceipt
                where reqTransReceipt.RecId         == reqTransCov.ReceiptRecId
            exists join prodTableLocal
                where _wrkCtrParmSchedule.schedReference()
                   && reqTransReceipt.RefId             == prodTableLocal.ProdId
                   && reqTransReceipt.RefType           == ReqRefType::Production
                   && prodTableLocal.CollectRefProdId   == _wrkCtrParmSchedule.schedNumId();

        oprNumDerivedLatestMaterialAvailability = reqTransDerived.OprNum;
        bomRefRecIdDerivedLatestMaterialAvailability = reqTransDerived.BOMRefRecId;

        return new ReqDateTime(reqTransDerived.FuturesDate, reqTransDerived.FuturesTime);
    }

]]></Source>
			</Method>
			<Method>
				<Name>limitOrderMaterialDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Enforces the rule that an operation cannot start earlier than the materials are available when
    ///    scheduling with finite materials.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> table buffer that contains all the scheduling parameters needed for
    ///    scheduling the production order.
    /// </param>
    /// <param name="_order">
    ///    The order to find material date for.
    /// </param>
    /// <param name="_oprNum">
    ///    The operation for which to find the material date for.
    /// </param>
    /// <param name="_jobId">
    ///    The ID of the first job on the operation.
    /// </param>
    protected void limitOrderMaterialDate(
        WrkCtrParmSchedule	_wrkCtrParmSchedule,
        Common              _order,
        OprNum				_oprNum,
        RecId				_jobId)
    {
        if (_wrkCtrParmSchedule.materialLimited())
        {
            var latestMaterialAvailabilityDate = this.getLatestMaterialAvailabilityDate(_wrkCtrParmSchedule, _order, _oprNum);            
            if (latestMaterialAvailabilityDate.parmDate())
            {
                if (oprNumDerivedLatestMaterialAvailability
                        && bomRefRecIdDerivedLatestMaterialAvailability
                        && BOM::findRecId(bomRefRecIdDerivedLatestMaterialAvailability).EndSchedConsump)
                {
                    scheduleEngine.addConstraintJobEndsAtOrAfter(
                        _jobId,
                        0,
                        DateTimeUtil::newDateTime(latestMaterialAvailabilityDate.parmDate(), latestMaterialAvailabilityDate.parmTime()));
                }
                else
                {
                    // Emit new constraint to limit the from date
                    scheduleEngine.addConstraintJobStartsAt(_jobId, 0, DateTimeUtil::newDateTime(latestMaterialAvailabilityDate.parmDate(), latestMaterialAvailabilityDate.parmTime()));
                }
            }

            if (#PmfEnabled)
            {
                ReqTrans    planningItemReqTrans;
                ReqTrans    coDerivedReqTransReceipt;
                ReqTrans    coDerivedReqTransIssue;
                ReqTransCov reqTransCov;


                // Add constraint from planning item and co-product
                select firstonly FuturesDate, FuturesTime from planningItemReqTrans
                    order by FuturesDate desc, FuturesTime desc
                        where planningItemReqTrans.PlanVersion   == _wrkCtrParmSchedule.parmReqPlanVersionRefRecId()
                           && planningItemReqTrans.RefType       == ReqRefType::PmfPlannedProdBatch
                    exists join coDerivedReqTransReceipt
                        where coDerivedReqTransReceipt.RefId             == planningItemReqTrans.RefId
                           && coDerivedReqTransReceipt.PlanVersion       == planningItemReqTrans.PlanVersion
                           && coDerivedReqTransReceipt.PMFPlanningItemId == planningItemReqTrans.ItemId
                    exists join reqTransCov
                        where reqTransCov.ReceiptRecId == coDerivedReqTransReceipt.RecId
                           && reqTransCov.PlanVersion  == coDerivedReqTransReceipt.PlanVersion
                    exists join coDerivedReqTransIssue
                        where coDerivedReqTransIssue.RecId         == reqTransCov.IssueRecid
                           && coDerivedReqTransIssue.PlanVersion   == _wrkCtrParmSchedule.parmReqPlanVersionRefRecId()
                           && coDerivedReqTransIssue.RefType       == this.refLineType(_order)
                           && coDerivedReqTransIssue.RefId         == _wrkCtrParmSchedule.schedNumId()
                           && (coDerivedReqTransIssue.OprNum       == _oprNum || !coDerivedReqTransReceipt.OprNum || !_oprNum)
                           && coDerivedReqTransIssue.Direction     == InventDirection::Issue;

                if (planningItemReqTrans && planningItemReqTrans.FuturesDate)
                {
                    // Emit new constraint to limit the from date
                    scheduleEngine.addConstraintJobStartsAt(_jobId,
                                                            0,
                                                            DateTimeUtil::newDateTime(planningItemReqTrans.FuturesDate, planningItemReqTrans.FuturesTime));
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads the data needed for the engine to schedule a list of production orders.
    /// </summary>
    /// <param name="_wrkCtrParmScheduleList">
    /// A <c>List</c> that contains the order schedule parameters for the orders to be scheduled.
    /// </param>
    protected void loadData(List _wrkCtrParmScheduleList)
    {
        Common common;

        ListEnumerator                          listEnumerator;
        WrkCtrParmSchedule                      wrkCtrParmSchedule;
        boolean                                 roughSchedulingUsed = false;
        WrkCtrSchedulerPrimaryResourceSelection primaryResourceSelection = WrkCtrSchedulerPrimaryResourceSelection::Duration;

        listEnumerator = _wrkCtrParmScheduleList.getEnumerator();
        while (listEnumerator && listEnumerator.moveNext())
        {
            wrkCtrParmSchedule = listEnumerator.current();

            // We just use the optimization goal available
            primaryResourceSelection = wrkCtrParmSchedule.parmPrimaryResourceSelection();

            // Get the referenced order record
            common = this.findRefId(wrkCtrParmSchedule.schedNumId(), true, wrkCtrParmSchedule);

            finiteCapacityUsed = finiteCapacityUsed || wrkCtrParmSchedule.capacityLimited();

            if (this.canSchedule(common))
            {
                this.loadOrder(wrkCtrParmSchedule, common);
                if (wrkCtrParmSchedule.schedMethod() == SchedMethod::Rough)
                {
                    roughSchedulingUsed = true;
                }
            }
        }

        if (roughSchedulingUsed)
        {
            this.addPropertyAggregations();
        }

        scheduleEngine.addOptimizationGoal(wrkCtrParmSchedule.parmPrimaryResourceSelection());
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadJobsDetail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads the job information for the jobs of one operation into the scheduling engine.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> table buffer that contains all the scheduling parameters that are
    /// required to schedule the order.
    /// </param>
    /// <param name="_order">
    /// A record that contains the data for the order being scheduled (a <c>ProdTable</c> record, a
    /// <c>ReqTrans</c> record, etc.).
    /// </param>
    /// <param name="_bomCalcData">
    /// An instance of the <c>BomCalcData</c> class that is used to calculate the runtime of the job.
    /// </param>
    /// <param name="_routeMap">
    /// A <c>RouteMap</c> map that contains the operation data.
    /// </param>
    /// <param name="_siteId">
    /// The ID of the site stamped on the order.
    /// </param>
    /// <param name="_orderNext">
    /// A record that contains the data for the next (reference) order.
    /// </param>
    /// <param name="_startCollectRefLevel">
    /// The start BOM level to use for determining the job goals.
    /// </param>
    /// <param name="_maxCollectRefLevel">
    /// The maximal BOM level to use for determining the job goals.
    /// </param>
    /// <param name="_jobNumNextOprFirst">
    /// The Record ID of the first job of the next operation.
    /// </param>
    /// <param name="_jobNumNextOprLast">
    /// The Record ID of the last job of the next operation.
    /// </param>
    /// <returns>
    /// A container that contains the Record ID values for the first and last job.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The resource that is specified as target resource for an operation is already in the scheduling
    /// that operation.
    /// </exception>
    protected container loadJobsDetail(WrkCtrParmSchedule           _wrkCtrParmSchedule,
                                       Common                       _order,
                                       BOMCalcData                  _bomCalcData,
                                       RouteMap                     _routeMap,
                                       InventSiteId                 _siteId,
                                       Common                       _orderNext,
                                       BOMLevel                     _startCollectRefLevel,
                                       BOMLevel                     _maxCollectRefLevel,
                                       RecId                        _jobNumNextOprFirst,
                                       RecId                        _jobNumNextOprLast)
    {
        return [0, 0];
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads data for one order that is scheduled.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> record that contains order scheduling parameters.
    /// </param>
    /// <param name="_common">
    /// A <c>Common</c> table buffer that contains the order data.
    /// </param>
    protected void loadOrder(WrkCtrParmSchedule _wrkCtrParmSchedule,
                             Common             _common)
    {
        WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::WrkCtrSchedulerLoadOrder, strFmt('Loading order %1, Item: %2', _wrkCtrParmSchedule.schedNumId(), _wrkCtrParmSchedule.itemId()));

        oprEndPointJobIds = new Map(Types::String, Types::Container);
        oprProcessJobIds = new Map(Types::String, Types::Int64);
        oprOverlapJobIds = new Map(Types::String, Types::Int64);
        overlapJobLinks = new Map(Types::String, Types::String);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadPreviouslyUsedResources</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads the previously used resources for each primary operation.
    /// </summary>
    /// <param name="_order">
    /// A <c>WrkCtrSchedulerOrder</c> record that contains the order information.
    /// </param>
    /// <param name="_planVersion">
    /// The plan version record Id to use for filtering based on the given plan.
    /// </param>
    /// <remarks>
    /// The resources are loaded from the capacity reservations table.
    /// </remarks>
    protected void loadPreviouslyUsedResources(WrkCtrSchedulerOrder _order,
                                               RefRecId             _planVersion)
    {
        RouteMap        routeMap = this.blankRoute();
        WrkCtrCapRes    wrkCtrCapRes;

        mapPreviouslyUsedResources = new Map(Types::Integer, Types::Container);

        while select RecId from routeMap
            order by OprNum
            where   routeMap.RefId          == _order.RefId
                &&  (!usePlanVersion ||
                     routeMap.PlanVersion    == _planVersion)
                &&  routeMap.OprPriority    == RouteOprPriority::Primary
        join firstonly OprNum, WrkCtrId, TransDate from wrkCtrCapRes
            where   wrkCtrCapRes.RefId          == routeMap.RefId
                &&  wrkCtrCapRes.RefType        == this.capacityRefType()
                &&  (!usePlanVersion ||
                     wrkCtrCapRes.PlanVersion == _planVersion)
                &&  wrkCtrCapRes.OprPriority    == RouteOprPriority::Primary
        {
            mapPreviouslyUsedResources.insert(wrkCtrCapRes.OprNum, [wrkCtrCapRes.WrkCtrId, wrkCtrCapRes.TransDate]);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadRoute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads into the scheduling engine all information needed for scheduling a route for an order.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> table buffer that contains all the scheduling parameters needed for
    /// scheduling the order.
    /// </param>
    /// <param name="_order">
    /// A record that contains the data for the order begin scheduled.
    /// </param>
    /// <param name="_siteId">
    /// The order site ID.
    /// </param>
    /// <param name="_orderNext">
    /// A record that contains the next order that is linked to the order that is being scheduled; optional.
    /// </param>
    /// <param name="_orderNextOprNum">
    /// The operation number of the next order to which we have to link; optional.
    /// </param>
    /// <param name="_startCollectRefLevel">
    /// The initial BOM level that is used to determine the job goals; optional.
    /// </param>
    /// <param name="_maxCollectRefLevel">
    /// The maximal BOM level that is used to determine the job goals; optional.
    /// </param>
    public void loadRoute(WrkCtrParmSchedule     _wrkCtrParmSchedule,
                          Common                 _order,
                          InventSiteId           _siteId,
                          Common                 _orderNext = null,
                          OprNum                 _orderNextOprNum = 0,
                          BOMLevel               _startCollectRefLevel = 0,
                          BOMLevel               _maxCollectRefLevel = 0)
    {
        RouteMap        routeMap = this.blankRoute();

        RecId           jobNumOprFirst;
        RecId           jobNumOprLast;

        RecId           jobNumNextProd;
        RecId           jobNumRouteLast;

        RecId           jobNumNextOprFirst;
        RecId           jobNumNextOprLast;
        str             oprKey;
        str             oprNextKey;

        // map used in overlap constraint. Key = this.KeyRoute(RefId, OprNum, OprPriority); Value = ratio between transfer batch time and process time
        Map             operationTransferBatchToProcessTimeRatios = new Map(Types::String, Types::Real);

        OprNum          oprNumNext;
        BOMCalcData     bomCalcData;

        WrkCtrSchedulerOrder    schedulerOrder = _order;
        WrkCtrSchedulerOrder    schedulerOrderNext = _orderNext;

        WrkCtrCapRefType    refType = this.capacityRefType();
        RefRecId            planVersion;

        this.initOverlapMaps();

        if (usePlanVersion)
        {
            planVersion = schedulerOrder.PlanVersion;
        }

        this.initCapResHandler(_wrkCtrParmSchedule.parmReqPlanVersionRefRecId(), _siteId);

        bomCalcData = this.createBOMCalcData(_order);

        // Get the maximum route level (branch depth)
        select firstonly RecId from routeMap
            where routeMap.RefId == schedulerOrder.RefId
              && (!usePlanVersion ||
                  routeMap.PlanVersion == planVersion)
              && (routeMap.OprNum == _wrkCtrParmSchedule.schedOprNum() || ! _wrkCtrParmSchedule.schedSingleJob())
              && (routeMap.OprNum == _wrkCtrParmSchedule.schedOprNum() || ! _wrkCtrParmSchedule.schedOnlyOprNum());

        // load the previously used resources
        if (_wrkCtrParmSchedule.parmKeepProductionUnit())
        {
            this.loadPreviouslyUsedResources(_order, planVersion);
        }

        // Delete already made capacity reservations
        if (this.mustDeleteOrderReservations())
        {
            wrkCtrCapResHandler.deleteOrderReservations(refType,
                                                        schedulerOrder.RefId,
                                                        _wrkCtrParmSchedule.schedOnlyOprNum() ? _wrkCtrParmSchedule.schedOprNum() : 0,
                                                        planVersion,
                                                        _wrkCtrParmSchedule.schedSingleJob() ? _wrkCtrParmSchedule.schedJobId() : '');
        }

        // check if we are having a routeless production order
        if (!routeMap)
        {
            jobNumRouteLast = this.handleRouteLessOrder(_order,
                                                        _wrkCtrParmSchedule,
                                                        schedulerOrder.ItemId,
                                                        schedulerOrder.InventDimId,
                                                        schedulerOrder.CollectRefId,
                                                        schedulerOrder.RefId,
                                                        _startCollectRefLevel,
                                                        schedulerOrder.CollectRefLevel,
                                                        this.refLineType(_order));
        }
        else
        {
            if (!mapUpdatedOrders.exists(_order))
            {
                this.addToUpdatedOrdersMap(_wrkCtrParmSchedule, _order, bomCalcData);
            }

            // Loop route "backwards" meaning last operation first
            SysDaSearchObject searchObject = new SysDaSearchObject(this.createQueryForLoadingRoutes(routeMap, schedulerOrder, _wrkCtrParmSchedule, planVersion));
            SysDaSearchStatement searchStatement = new SysDaSearchStatement();

            while (searchStatement.nextRecord(searchObject))
            {
                oprKey = this.keyRoute(routeMap.RefId, routeMap.OprNum, routeMap.OprPriority);
                routeData.insert(oprKey, routeMap);

                oprNumNext = this.nextOperationNumber(_wrkCtrParmSchedule, routeMap);

                if (routeMap.OprPriority == RouteOprPriority::Primary)
                {
                    if (oprNumNext)
                    {
                        oprNextKey = this.keyRoute(routeMap.RefId, oprNumNext, routeMap.OprPriority);
                        if (oprEndPointJobIds.exists(oprNextKey))
                        {
                            [jobNumNextOprFirst, jobNumNextOprLast] = oprEndPointJobIds.lookup(oprNextKey);
                        }
                        else
                        {
                            inconsistentDataSchedulingErrorOccured = true;
                            throw error("@SYS134518");
                        }
                    }

                    [jobNumOprFirst, jobNumOprLast] = this.loadJobsDetail(_wrkCtrParmSchedule,
                                                                          _order,
                                                                          bomCalcData,
                                                                          routeMap,
                                                                          _siteId,
                                                                          _orderNext,
                                                                          _startCollectRefLevel,
                                                                          _maxCollectRefLevel,
                                                                          jobNumNextOprFirst,
                                                                          jobNumNextOprLast);

                    operationTransferBatchToProcessTimeRatios.insert(oprKey, this.transferBatchTimeToProcessTimeRatio(routeMap, _order));

                    if (jobNumOprFirst == 0 &&
                        jobNumOprLast == 0)
                    {
                        jobNumOprFirst = this.insertEmptyJob(_wrkCtrParmSchedule,
                                                             schedulerOrder.RefId,
                                                             _startCollectRefLevel,
                                                             schedulerOrder.CollectRefLevel);
                        // Add link for empty job
                        if (jobNumNextOprFirst
                            && routeMap.OprPriority == RouteOprPriority::Primary)
                        {
                            scheduleEngine.addJobLink(jobNumOprFirst, jobNumNextOprFirst, SchedJobLink::FS, routeMap.LinkType);
                        }

                        jobNumOprLast = jobNumOprFirst;
                    }

                    this.limitOrderMaterialDate(_wrkCtrParmSchedule, _order, routeMap.OprNum, jobNumOprFirst);

                    if (!jobNumRouteLast)
                    {
                        jobNumRouteLast = jobNumOprLast;
                    }

                    // Save the RecId of the first job for the current operation
                    oprEndPointJobIds.insert(oprKey, [jobNumOprFirst, jobNumOprLast]);
                }
            }
        }

        this.processLastJob(_order, jobNumRouteLast, _wrkCtrParmSchedule, schedulerOrder.RefId, _startCollectRefLevel, _maxCollectRefLevel, schedulerOrder.CollectRefLevel);

        this.insertOverlapLinks(_wrkCtrParmSchedule,
                                overlapSucessorJobs,
                                operationTransferBatchToProcessTimeRatios);

        ReqSetupDim setupDim;
        ReqPlanData reqPlanData;

        if (_wrkCtrParmSchedule.applyReorderMargin())
        {
            setupDim = ReqSetupDim::newInventTable(InventTable::find(schedulerOrder.ItemId), schedulerOrder.InventDimId);
            reqPlanData = ReqPlanData::newReqPlanId(ReqPlanSched::defaultDynamicId());

            var orderMargin = setupDim.marginOrder();
            if (orderMargin)
            {
                scheduleEngine.addConstraintJobStartsAt(
                    jobNumOprFirst,
                    0,
                    reqPlanData.schedMarginForward(this.today(), orderMargin, setupDim));
            }
        }

        // Create links between productions
        if (_orderNext)
        {
            // Find job that production should link to
            if (oprEndPointJobIds.exists(this.keyRoute(schedulerOrderNext.RefId, _orderNextOprNum, RouteOprPriority::Primary)))
            {
                // read the first job of the operation for the next order
                jobNumNextProd = conPeek(oprEndPointJobIds.lookup(this.keyRoute(schedulerOrderNext.RefId, _orderNextOprNum, RouteOprPriority::Primary)), 1);
            }
            else
            {
                if (oprEndPointJobIds.exists(this.keyRoute(schedulerOrderNext.RefId, 0, RouteOprPriority::Primary)))
                {
                    jobNumNextProd = conPeek(oprEndPointJobIds.lookup(this.keyRoute(schedulerOrderNext.RefId, 0, RouteOprPriority::Primary)), 1);
                }
            }

            if (jobNumNextProd && jobNumRouteLast)
            {
                jobNumNextProd = this.insertIssueAndReceiptMarginJobs(_wrkCtrParmSchedule, schedulerOrder, jobNumNextProd, setupDim, reqPlanData, _startCollectRefLevel);

                // Insert link
                scheduleEngine.addJobLink(jobNumRouteLast,
                                          jobNumNextProd,
                                          any2int(SchedJobLink::FS),
                                          any2int(SchedJobLinkType::Soft));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertIssueAndReceiptMarginJobs</Name>
				<Source><![CDATA[
    private RecId insertIssueAndReceiptMarginJobs(
        WrkCtrParmSchedule _wrkCtrParmSchedule,
        WrkCtrSchedulerOrder _schedulerOrder,
        RecId _jobNumNextProd,
        ReqSetupDim _setupDim,
        ReqPlanData _reqPlanData,
        BOMLevel _startCollectRefLevel)
    {
        if (!_wrkCtrParmSchedule.applyIssueMargin() && !_wrkCtrParmSchedule.applyReceiptMargin())
        {
            return _jobNumNextProd;
        }
        
        RecId jobNumNextProd = _jobNumNextProd;
        
        if (!_setupDim)
        {
            _setupDim = ReqSetupDim::newInventTable(InventTable::find(_schedulerOrder.ItemId), _schedulerOrder.InventDimId);
        }
                
        if (!_reqPlanData)
        {
            _reqPlanData = ReqPlanData::newReqPlanId(ReqPlanSched::defaultDynamicId());
        }

        var issueMargin = _setupDim.marginIssue();
        if (issueMargin && _wrkCtrParmSchedule.applyIssueMargin())
        {
            jobNumNextProd = this.insertMarginBeforeNextJob(
                issueMargin,
                jobNumNextProd,
                _wrkCtrParmSchedule,
                _schedulerOrder,
                _setupDim,
                _reqPlanData,
                _startCollectRefLevel);
        }

        var receiptMargin = _setupDim.marginReceipt();
        if (receiptMargin && _wrkCtrParmSchedule.applyReceiptMargin())
        {
            jobNumNextProd = this.insertMarginBeforeNextJob(
                receiptMargin,
                jobNumNextProd,
                _wrkCtrParmSchedule,
                _schedulerOrder,
                _setupDim,
                _reqPlanData,
                _startCollectRefLevel);
        }
        
        return jobNumNextProd;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertMarginBeforeNextJob</Name>
				<Source><![CDATA[
    private RecId insertMarginBeforeNextJob(
        Days _marginDays,
        RecId _jobNumNextProd,
        WrkCtrParmSchedule _wrkCtrParmSchedule,
        WrkCtrSchedulerOrder _schedulerOrder,        
        ReqSetupDim _setupDim,
        ReqPlanData _reqPlanData,
        BOMLevel _startCollectRefLevel)
    {
        RecId marginJobRecId = this.insertLeadTimeJobAsConstraint(
            _wrkCtrParmSchedule,
            _setupDim,
            _marginDays,
            _reqPlanData.marginCalendarDays(),
            _startCollectRefLevel,
            _schedulerOrder.CollectRefLevel);

        scheduleEngine.addJobLink(
            marginJobRecId,
            _jobNumNextProd,
            any2int(SchedJobLink::FS),
            any2int(SchedJobLinkType::Soft));

        return marginJobRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDeleteOrderReservations</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether existing order reservations should be deleted or not.
    /// </summary>
    /// <returns>
    ///     true if the reservations should be deleted, otherwise false.
    /// </returns>
    protected boolean mustDeleteOrderReservations()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>nextOperationNumber</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates the next operation number based on scheduling parameters and the current job.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///     The scheduling parameters for the current order.
    /// </param>
    /// <param name="_routeMap">
    ///     The job that is currently being processed.
    /// </param>
    /// <returns>
    ///     The next operation number.
    /// </returns>
    protected OprNum nextOperationNumber(WrkCtrParmSchedule _wrkCtrParmSchedule, RouteMap _routeMap)
    {
        if (_wrkCtrParmSchedule.schedOnlyOprNum() || _wrkCtrParmSchedule.schedSingleJob())        
        {
            return 0;
        }

        return _routeMap.OprNumNext;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createQueryForLoadingRoutes</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a query on the table that is represented in the RouteMap.
    /// </summary>
    /// <param name="_routeMap">
    ///     The mapped table.
    /// </param>
    /// <param name="_wrkCtrSchedulerOrder">
    ///     The table buffer that contains all the scheduling parameters.
    /// </param>
    /// <param name="_wrkCtrParmSchedule">
    ///     The object that contains the scheduling parameters.
    /// </param>
    /// <param name="_planVersion">
    ///     The plan version to use, if usePlanVersion is set to true.
    /// </param>
    /// <returns>
    ///     A generic SysDa query that can be extended/modified.
    /// </returns>
    protected SysDaQueryObject createQueryForLoadingRoutes(RouteMap _routeMap, WrkCtrSchedulerOrder _wrkCtrSchedulerOrder, WrkCtrParmSchedule _wrkCtrParmSchedule, RefRecId _planVersion)
    {
        SysDaQueryObject queryObject = new SysDaQueryObject(_routeMap);

        queryObject.optimisticLockHint = true;

        this.addMappedOrderBy(queryObject.orderByClause(), this.mappedFieldStr(fieldNum(RouteMap, Level), _routeMap.TableId));
        this.addMappedOrderBy(queryObject.orderByClause(), this.mappedFieldStr(fieldNum(RouteMap, OprNum), _routeMap.TableId), SortOrder::Descending);
        this.addMappedOrderBy(queryObject.orderByClause(), this.mappedFieldStr(fieldNum(RouteMap, OprPriority), _routeMap.TableId));

        SysDaQueryExpression whereClause = this.createMappedQueryRange(this.mappedFieldStr(fieldNum(RouteMap, RefId), _routeMap.TableId), _routeMap, _wrkCtrSchedulerOrder.RefId);
        if (usePlanVersion)
        {
            whereClause = this.createAndQueryRange(whereClause, this.createMappedQueryRange(this.mappedFieldStr(fieldNum(RouteMap, PlanVersion), _routeMap.TableId), _routeMap, _planVersion));
        }
        if (_wrkCtrParmSchedule.schedOnlyOprNum() || _wrkCtrParmSchedule.schedSingleJob())
        {
            whereClause = this.createAndQueryRange(whereClause, this.createMappedQueryRange(this.mappedFieldStr(fieldNum(RouteMap, OprNum), _routeMap.TableId), _routeMap, _wrkCtrParmSchedule.schedOprNum()));
        }
        queryObject.whereClause(whereClause);

        return queryObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndQueryRange</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Takes two query expression and creates a new concatenated expression
    /// </summary>
    /// <param name="_whereClause">
    ///     The expression to concatenate with.
    /// </param>
    /// <param name="_queryExpression">
    ///     The expression to be concatenated.
    /// </param>
    /// <returns>
    ///     A new query expression.
    /// </returns>
    [Wrappable(false)]
    protected final SysDaQueryExpression createAndQueryRange(SysDaQueryExpression _whereClause, SysDaQueryExpression _queryExpression)
    {
        if (_whereClause == null)
        {
            return _queryExpression;
        }
        else if (_queryExpression != null)
        {
            return _whereClause.and(_queryExpression);
        }

        return _whereClause;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMappedQueryRange</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a table range.
    /// </summary>
    /// <param name="_fieldName">
    ///     The field name that will be used to create range on.
    /// </param>
    /// <param name="_common">
    ///     The table instance.
    /// </param>
    /// <param name="_value">
    ///     The value that is used in the range.
    /// </param>
    /// <returns>
    ///     A new query range.
    /// </returns>
    [Wrappable(false)]
    protected final SysDaQueryExpression createMappedQueryRange(FieldName _fieldName, Common _common, System.Object _value)
    {
        if (_fieldName)
        {
            return new SysDaEqualsExpression(new SysDaFieldExpression(_common, _fieldName), new SysDaValueExpression(_value));
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addMappedOrderBy</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Adds a field to the order by clause.
    /// </summary>
    /// <param name="_orderBy">
    ///     The sort order object to add the sort field to.
    /// </param>
    /// <param name="_fieldName">
    ///     The field name that will be used as sort field.
    /// </param>
    /// <param name="_sortOrder">
    ///     The sort order direction.
    /// </param>
    /// <returns>
    ///     The modified sort order object.
    /// </returns>
    [Wrappable(false)]
    protected final SysDaOrderBys addMappedOrderBy(SysDaOrderBys _orderBy, FieldName _fieldName, SortOrder _sortOrder = SortOrder::Ascending)
    {
        if (_fieldName)
        {
            if (_sortOrder == SortOrder::Ascending)
            {
                _orderBy.add(_fieldName);
            }
            else
            {
                _orderBy.addDescending(_fieldName);
            }
        }

        return _orderBy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mappedFieldStr</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Converts a field id on a map to field string on an actual mapped table.
    /// </summary>
    /// <param name="_mapFieldId">
    ///     The field id from the map.
    /// </param>
    /// <param name="_tableId">
    ///     The table id of the map.
    /// </param>
    /// <returns>
    ///     The modified sort order object.
    /// </returns>
    [Wrappable(false)]
    protected final FieldName mappedFieldStr(FieldId _mapFieldId, TableId _tableId)
    {
        FieldId fieldId = SysDictField::findMappedFieldId(tableNum(RouteMap), _mapFieldId, _tableId);

        return fieldId2Name(_tableId, fieldId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustKeepJobResourceAssignment</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Computes a Boolean value that indicates whether the
    ///     current job resource assignment must be kept.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///     The scheduling parameters for the current order.
    /// </param>
    /// <param name="_routeJobMap">
    ///     The job about to be loaded into the scheduling engine.
    /// </param>
    /// <returns>
    ///     <c>true</c> if the resource assignment must be kept;
    ///     otherwise, <c>false</c>.
    /// </returns>
    protected boolean mustKeepJobResourceAssignment(
        WrkCtrParmSchedule      _wrkCtrParmSchedule,
        RouteJobMap             _routeJobMap)
    {
        return _wrkCtrParmSchedule.mustKeepResourceAssignments()
            && _routeJobMap.WrkCtrId
            && (_wrkCtrParmSchedule.schedJobRecId() == 0
            || !this.mustUseSameResource(_wrkCtrParmSchedule.schedJobRecId(), _routeJobMap));
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUseSameResource</Name>
				<Source><![CDATA[
    protected boolean mustUseSameResource(RecId _schedJobRecId, RouteJobMap _routeJobMap)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        canUseSeparateConnection = !isFlightEnabled(ProdFlighting::SchedulerLockKeepSameConnection);
        isPreventCleanupDeadlockToggleEnabled = WrkCtrSchedulerPreventCleanupDeadlockToggle::instance().isEnabled();

        wrkCtrSchedulerRuntimes = WrkCtrSchedulerRuntimes::construct();
        wrkCtrCapResHandler = WrkCtrCapResHandler::construct();
        wrkCtrCapResConflictCheckIntervals = WrkCtrCapResConflictCheckIntervals::construct();

        this.initNumTypes();

        this.initCache();

        this.clearListWrkCtrParmSchedule();
        checkLockingTTSLevel = true;

        timeoutErrorLikelyCausedByResourceCombination = new set(Types::String);
    }

]]></Source>
			</Method>
			<Method>
				<Name>onSaveJobsDone</Name>
				<Source><![CDATA[
    /// <summary>
    /// Occurs when the save operation for the jobs in the database is finished.
    /// </summary>
    delegate void onSaveJobsDone()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>onSaveJobsStart</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes before a save operation starts for the scheduled jobs in the database.
    /// </summary>
    delegate void onSaveJobsStart()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCapResHandler</Name>
				<Source><![CDATA[
    public WrkCtrCapResHandler parmCapResHandler(WrkCtrCapResHandler _wrkCtrCapResHandler = wrkCtrCapResHandler)
    {
        wrkCtrCapResHandler = _wrkCtrCapResHandler;
        return wrkCtrCapResHandler;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheckLockingTTSLevel</Name>
				<Source><![CDATA[
    public boolean parmCheckLockingTTSLevel(boolean _checkLockingTTSLevel = checkLockingTTSLevel)
    {
        checkLockingTTSLevel = _checkLockingTTSLevel;
        return checkLockingTTSLevel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRefIdField</Name>
				<Source><![CDATA[
    protected FieldId parmRefIdField(FieldId _refIdField = refIdField)
    {
        if (!prmisDefault(_refIdField))
        {
            refIdField = _refIdField;
        }
        return refIdField;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReqPlanVersionRefRecId</Name>
				<Source><![CDATA[
    public RefRecId parmReqPlanVersionRefRecId(RefRecId _reqPlanVersionRefRecId = reqPlanVersionRefRecId)
    {
        reqPlanVersionRefRecId = _reqPlanVersionRefRecId;
        return reqPlanVersionRefRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmResetWorkingTimesCacheForEachRun</Name>
				<Source><![CDATA[
    public boolean parmResetWorkingTimesCacheForEachRun(boolean _resetWorkingTimesCacheForEachRun = resetWorkingTimesCacheForEachRun)
    {
        resetWorkingTimesCacheForEachRun = _resetWorkingTimesCacheForEachRun;
        return resetWorkingTimesCacheForEachRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsRunningMultipleWrkCtrSchedulerInstances</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean parmIsRunningMultipleWrkCtrSchedulerInstances(boolean _isRunningMultipleWrkCtrSchedulerInstances = isRunningMultipleWrkCtrSchedulerInstances)
    {
        isRunningMultipleWrkCtrSchedulerInstances = _isRunningMultipleWrkCtrSchedulerInstances;
        return isRunningMultipleWrkCtrSchedulerInstances;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRouteOprNumField</Name>
				<Source><![CDATA[
    protected FieldId parmRouteOprNumField(FieldId _routeOprNumField = routeOprNumField)
    {
        if (!prmisDefault(_routeOprNumField))
        {
            routeOprNumField = _routeOprNumField;
        }
        return routeOprNumField;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRouteRefIdField</Name>
				<Source><![CDATA[
    protected FieldId parmRouteRefIdField(FieldId _routeRefIdField = routeRefIdField)
    {
        if (!prmisDefault(_routeRefIdField))
        {
            routeRefIdField = _routeRefIdField;
        }
        return routeRefIdField;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSchedulingEngine</Name>
				<Source><![CDATA[
    public WrkCtrSchedulerEngineInterface parmSchedulingEngine(WrkCtrSchedulerEngineInterface _scheduleEngine = scheduleEngine)
    {
        scheduleEngine = _scheduleEngine;
        return scheduleEngine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWrkCtrCapResConflictCheckIntervals</Name>
				<Source><![CDATA[
    public WrkCtrCapResConflictCheckIntervals parmWrkCtrCapResConflictCheckIntervals(WrkCtrCapResConflictCheckIntervals _wrkCtrCapResConflictCheckIntervals = wrkCtrCapResConflictCheckIntervals)
    {
        wrkCtrCapResConflictCheckIntervals = _wrkCtrCapResConflictCheckIntervals;

        return wrkCtrCapResConflictCheckIntervals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWrkCtrCapResHandler</Name>
				<Source><![CDATA[
    public WrkCtrCapResHandler parmWrkCtrCapResHandler(WrkCtrCapResHandler _wrkCtrCapResHandler = wrkCtrCapResHandler)
    {
        wrkCtrCapResHandler = _wrkCtrCapResHandler;
        return wrkCtrCapResHandler;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareCapacityCheckIntervals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the conflict check intervals.
    /// </summary>
    /// <returns>
    /// The ID that is used to query the inserted intervals.
    /// </returns>
    protected guid prepareCapacityCheckIntervals()
    {
        guid conflictCheckSessionId;

        ttsbegin;

        conflictCheckSessionId = scheduleEngine.prepareCapacityCheckIntervals();

        ttscommit;

        return conflictCheckSessionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processLastJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs post processing actions on the last inserted job for an order.
    /// </summary>
    /// <param name="_order">
    /// A record with the data for the order being scheduled.
    /// </param>
    /// <param name="_jobNumRouteLast">
    /// The ID of the last job of the route.
    /// </param>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> object that contains the order scheduling parameters.
    /// </param>
    /// <param name="_refIdOrig">
    /// The original order ID.
    /// </param>
    /// <param name="_startCollectRefLevel">
    /// A starting route level determining the order of the operations.
    /// </param>
    /// <param name="_maxCollectRefLevel">
    /// A maximal route level determining the order of the operations.
    /// </param>
    /// <param name="_currentCollectRefLevel">
    /// A current route level.
    /// </param>
    protected void processLastJob(Common                _order,
                                  RecId                 _jobNumRouteLast,
                                  WrkCtrParmSchedule    _wrkCtrParmSchedule,
                                  InventRefId           _refIdOrig,
                                  BOMLevel              _startCollectRefLevel,
                                  BOMLevel              _maxCollectRefLevel,
                                  BOMLevel              _currentCollectRefLevel)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>productionUnit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the production unit ID assigned to the resource or resource group previously used to
    ///    schedule a specific operation.
    /// </summary>
    /// <param name="_oprNumKey">
    ///    The key value that is used to find the resource or resource group used for the previous scheduling
    ///    run.
    /// </param>
    /// <returns>
    ///    The production unit ID or an empty string of no production unit is assigned.
    /// </returns>
    protected ProdUnitId productionUnit(anytype _oprNumKey)
    {
        WrkCtrId    previousResourceId;
        TransDate   previousResourceDate;
        ProdUnitId  prodUnitId;

        if (mapPreviouslyUsedResources)
        {
            if (mapPreviouslyUsedResources.exists(_oprNumKey))
            {
                [previousResourceId, previousResourceDate] = mapPreviouslyUsedResources.lookup(_oprNumKey);

                prodUnitId = WrkCtrTable::resourceGroup(previousResourceId,
                                                        previousResourceDate,
                                                        previousResourceDate).ProdUnitId;
            }
        }

        return prodUnitId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>refLineType</Name>
				<Source><![CDATA[
    /// <summary>
    /// The reference line type that is on the <c>ReqTrans</c> records for the current order.
    /// </summary>
    /// <param name="_order">
    /// A record that contains the data for the order that is being scheduled.
    /// </param>
    /// <returns>
    /// A <c>ReqRefType</c> enumeration value.
    /// </returns>
    protected ReqRefType refLineType(Common _order)
    {
        return ReqRefType::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>refId</Name>
				<Source><![CDATA[
    /// <summary>
    /// The reference identifier that is on the <c>ReqTrans</c> records for the current order.
    /// </summary>
    /// <param name="_order">
    /// A record that contains the data for the order that is being scheduled.
    /// </param>
    /// <returns>
    /// A reference identifier.
    /// </returns>
    protected InventTransRefId refId(WrkCtrParmSchedule	_wrkCtrParmSchedule, Common _order)
    {
        return _wrkCtrParmSchedule.schedNumId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>requirementsAllowFastSetup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the requirements support a fast setup.
    /// </summary>
    /// <param name="_requirements">
    ///    A map of requirements.
    /// </param>
    /// <returns>
    ///    true when fast setup is permitted; otherwise, false.
    /// </returns>
    protected boolean requirementsAllowFastSetup(Map _requirements)
    {
        boolean         result = true;
        MapEnumerator   enumerator;
        str             property;
        boolean         resourceGroupRequirementFound = false;

        enumerator = _requirements.getEnumerator();
        while (enumerator.moveNext())
        {
            property = enumerator.currentKey();
            if (strStartsWith(property,WrkCtrSchedulingProperty::resourceGroupPropertyPrefix()))
            {
                resourceGroupRequirementFound = true;
            }

            if (!(strStartsWith(property, WrkCtrSchedulingProperty::resourceGroupPropertyPrefix()) ||
                  strStartsWith(property, WrkCtrSchedulingProperty::inventSiteSchedulingPropertyPrefix())
                 )
               )
            {
                result = false;
            }
        }

        return result && resourceGroupRequirementFound;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reset</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets the scheduler, preparing it for a new scheduling run.
    /// </summary>
    public void reset()
    {
        this.clearListWrkCtrParmSchedule();
        this.initOrderData();

        if (scheduleEngine)
        {
            scheduleEngine.reset();
        }
        schedulingErrorOccured = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs a scheduling run.
    /// </summary>
    /// <remarks>
    ///    This method is creating the scheduling engine, running the scheduling, and triggering the post
    ///    processing which saves the results to the database.
    /// </remarks>
    public void run()
    {
        int                                 errorCode;
        SetEnumerator                       setEnumerator;
        int                                 retryCounter;
        WrkCtrParametersDim                 wrkCtrParametersDim;
        SequenceScheduleRuntimeLimit        sequenceScheduleRuntimeLimit;
        SequenceOptimizationRuntimeLimit    sequenceOptimizationRuntimeLimit;

        retryCounter = 0;

        WrkCtrSchedulerTrace trace;
        str traceName;

        try
        {
            using (var m = ReqInstrumentationSegmentFactory::create(ReqInstrumentationActivities::SchedulingRun, ReqInstrumentationActivities::DefaultActivityId, this.getParametersForTelemetry()))
            {
                wrkCtrParametersDim = this.findWrkCtrParameters(listWrkCtrParmSchedule);

                if (wrkCtrParametersDim.EnableLog)
                {
                    Microsoft.Dynamics.AX.Planning.JobScheduling.Logger::set_Enabled(true);

                    traceName = this.ordersDescription(listWrkCtrParmSchedule);
                    trace = new WrkCtrSchedulerTrace(wrkCtrParametersDim);
                    loggingOptions = trace.loggingOptions();
                    //recreate the engine each time for individual model output
                    initialized = false;
                }
                else if (loggingOptions)
                {
                    //recreate the engine to stop data provider tracing
                    initialized = false;
                    loggingOptions = null;
                }

                this.init(loggingOptions);

                if (loggingOptions)
                {
                    scheduleEngine.setupLogging(loggingOptions);
                }
                else
                {
                    Microsoft.Dynamics.AX.Planning.JobScheduling.Logger::set_Enabled(false);
                }

                if (canUseSeparateConnection)
                {
                    if (isPreventCleanupDeadlockToggleEnabled)
                    {
                        if (!hasRunCleanupOfTerminatedSessionsStatic)
                        {
                            WrkCtrCapResHandler::cleanupTerminatedSessions();
                            hasRunCleanupOfTerminatedSessionsStatic = true;
                        }
                    }
                    else if (!hasRunCleanupOfTerminatedSessions)
                    {
                        WrkCtrCapResHandler::cleanupTerminatedSessions();
                        hasRunCleanupOfTerminatedSessions = true;
                    }
                }

                while (listWrkCtrParmSchedule.elements() > 0)
                {
                    if (checkLockingTTSLevel && appl.ttsLevel() > 0)
                    {
                        throw error("@SYS329290");
                    }

                    ttsbegin;

                    // Load all primary data into the engine
                    WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::Private, 'Loading scheduling data');
                    wrkCtrSchedulerRuntimes.startMeasurement(#LoadData);
                    this.loadData(listWrkCtrParmSchedule);
                    wrkCtrSchedulerRuntimes.endMeasurement(#LoadData);
                    WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::Private, 'Loaded scheduling data');

                    // Run engine
                    wrkCtrSchedulerRuntimes.startMeasurement(#ScheduleEngineRun);

                    if (!wrkCtrParametersDim)
                    {
                        wrkCtrParametersDim = this.findWrkCtrParameters(listWrkCtrParmSchedule);
                    }

                    if (wrkCtrParametersDim.SequenceScheduleTimeoutEnabled)
                    {
                        sequenceScheduleRuntimeLimit = wrkCtrParametersDim.SequenceScheduleRuntimeLimit * #MillisecondsPerSecond;
                    }
                    else
                    {
                        sequenceScheduleRuntimeLimit = -1;
                    }
                    if (wrkCtrParametersDim.SequenceOptimizationTimeoutEnabled)
                    {
                        sequenceOptimizationRuntimeLimit = wrkCtrParametersDim.SequenceOptimizationRuntimeLimit * #MillisecondsPerSecond;
                    }
                    else
                    {
                        sequenceOptimizationRuntimeLimit = -1;
                    }

                    if (resetWorkingTimesCacheForEachRun)
                    {
                        scheduleEngine.clearAllCachedData();
                    }

                    var isResourcesAssignmentRandomizationEnabled = wrkCtrParametersDim.RandomizeEqualResources;
                    var isTreatDefaultJobBindPriorityAsLowestToggleEnabled = WrkCtrSchedTreatDefaultJobBindPriorityAsLowestToggle::instance().isEnabled();
                    var isSortGraphPrimaryFirstFlightEnabled = WrkCtrSchedulerSortGraphPrimaryFirstFlight::instance().isEnabled();
                    var isSkipDifferentEfficiencyCapacitiesAdjustmentToggleEnabled = WrkCtrSchedulerSkipDifferentEfficiencyCapacitiesAdjustmentToggle::instance().isEnabled();
                    var isSkipCapabilitiesFromCalendarToggleEnabled = ReqSkipCapabilitiesFromCalendarToggle::instance().isEnabled();
                    var isSkipSingleResourceOptimizationFlightEnabled = WrkCtrSchedulerSkipSingleResourceOptimizationFlight::instance().isEnabled();
                    var isUseWokenConstraintsListsFlightEnabled = WrkCtrSchedulerUseWokenConstraintsListsFlight::instance().isEnabled();
                    var isRespectJobGoalFlightEnabled = WrkCtrSchedulerOptimizationConstraintsRespectJobGoalFlight::instance().isEnabled();
                    var isRoundUpRuntimeWhenTrimmingCapacitySlotFlightEnabled = WrkCtrSchedulerRoundUpRuntimeWhenTrimmingFlight::instance().isEnabled();
                    var isIgnoreCapacityReservationsHavingSameStartAndEndTimeFlightEnabled = WrkCtrSchedulerIgnoreFiniteCapacityHavingSameStartAndEndTimeFlight::instance().isEnabled();
                    var isWrkCtrSchedOperationReservedTimeHardLinkDelayFlightEnabled = WrkCtrSchedOperationReservedTimeHardLinkDelayFlight::instance().isEnabled();
                    var isStartEndTimeOptimizationFlightEnabled = WrkCtrSchedulerStartEndTimeOptimizationFlight::instance().isEnabled();

                    scheduleEngine.setFlightStatus(ReqCalcFlighting::WrkCtrSchedulerResourcesAssignmentRandomization, isResourcesAssignmentRandomizationEnabled);
                    scheduleEngine.setFlightStatus(classStr(WrkCtrSchedTreatDefaultJobBindPriorityAsLowestToggle), isTreatDefaultJobBindPriorityAsLowestToggleEnabled);
                    scheduleEngine.setFlightStatus(classStr(WrkCtrSchedulerSortGraphPrimaryFirstFlight), isSortGraphPrimaryFirstFlightEnabled);
                    scheduleEngine.setFlightStatus(classStr(WrkCtrSchedulerSkipDifferentEfficiencyCapacitiesAdjustmentToggle), isSkipDifferentEfficiencyCapacitiesAdjustmentToggleEnabled);
                    scheduleEngine.setFlightStatus(classStr(ReqSkipCapabilitiesFromCalendarToggle), isSkipCapabilitiesFromCalendarToggleEnabled);
                    scheduleEngine.setFlightStatus(classStr(WrkCtrSchedulerSkipSingleResourceOptimizationFlight), isSkipSingleResourceOptimizationFlightEnabled);
                    scheduleEngine.setFlightStatus(classStr(WrkCtrSchedulerUseWokenConstraintsListsFlight), isUseWokenConstraintsListsFlightEnabled);
                    scheduleEngine.setFlightStatus(classStr(WrkCtrSchedulerOptimizationConstraintsRespectJobGoalFlight), isRespectJobGoalFlightEnabled);
                    scheduleEngine.setFlightStatus(classStr(WrkCtrSchedulerRoundUpRuntimeWhenTrimmingFlight), isRoundUpRuntimeWhenTrimmingCapacitySlotFlightEnabled);
                    scheduleEngine.setFlightStatus(classStr(WrkCtrSchedulerIgnoreFiniteCapacityHavingSameStartAndEndTimeFlight), isIgnoreCapacityReservationsHavingSameStartAndEndTimeFlightEnabled);
                    scheduleEngine.setFlightStatus(classStr(WrkCtrSchedOperationReservedTimeHardLinkDelayFlight), isWrkCtrSchedOperationReservedTimeHardLinkDelayFlightEnabled);
                    scheduleEngine.setFlightStatus(classStr(WrkCtrSchedulerStartEndTimeOptimizationFlight), isStartEndTimeOptimizationFlightEnabled);

                    errorCode = scheduleEngine.run(any2int(sequenceScheduleRuntimeLimit),
                                                   any2int(sequenceOptimizationRuntimeLimit));
                    wrkCtrSchedulerRuntimes.endMeasurement(#ScheduleEngineRun);

                    // If pessimistic capacity reservation lock are not taken during scheduling,
                    // then the initial updates to routes etc can be committed here,
                    // otherwise commit must wait until the capacity reservations has been written in the saveData method
                    if (!wrkCtrCapResHandler.parmUsePessimisticReadLock())
                    {
                        ttscommit;
                    }

                    if (errorCode == 0)
                    {
                        // Save the results (capacity reservations and jobs) 
                        wrkCtrSchedulerRuntimes.startMeasurement(#SaveData);
                        this.saveData();

                        if (wrkCtrCapResHandler.parmUsePessimisticReadLock())
                        {
                            // Commit to release the lock on capacity reservations
                            ttscommit;
                        }

                        // Update the route information and other released order data
                        this.saveOrdersAndRelated();

                        wrkCtrSchedulerRuntimes.endMeasurement(#SaveData);
                    }
                    else
                    {
                        this.setSchedulingErrorOccured();
                        WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::WrkCtrSchedulerSaveJobs, 'Error: Saving failed');
                        throw error("@SYS134375");
                    }

                    // Add infolog messages for orders that failed
                    this.addInfologMessages(listWrkCtrParmSchedule);

                    this.clearListWrkCtrParmSchedule();
                    wrkCtrParametersDim = null;

                    setEnumerator = setRescheduleQueue.getEnumerator();

                    if (!setRescheduleQueue.empty())
                    {
                        WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::WrkCtrSchedulerSaveJobs, strFmt('Reschedule of %1 orders needed, preparing retry', setRescheduleQueue.elements()));

                        retryCounter++;
                        if (retryCounter < #MaxRetry)
                        {
                            this.reset();
                            while (setEnumerator && setEnumerator.moveNext())
                            {
                                this.addWrkCtrParmSchedule(setEnumerator.current());
                            }
                        }

                        WrkCtrSchedulerLogger::Instance().writeToLog(WrkCtrSchedulerLogEvent::WrkCtrSchedulerSaveJobs, 'Reschedule prepared');
                    }
                }

                if (!setRescheduleQueue.empty())
                {
                    // add infolog messages for the remaining items in the reschedule queue
                    setEnumerator = setRescheduleQueue.getEnumerator();
                    while (setEnumerator && setEnumerator.moveNext())
                    {
                        this.addInfologMessage(setEnumerator.current());
                    }
                }
            }
        }
        catch (Exception::CLRError)
        {
            this.setSchedulingErrorOccured();
            warning(WrkCtrSchedulerJobSchedulingEngine::getLastClrException());
            throw error("@SYS135501");
        }
        catch
        {
            this.setSchedulingErrorOccured();
            throw error("@SYS134375");
        }
        finally
        {
            if (scheduleEngine && loggingOptions)
            {
                scheduleEngine.finishLogging(loggingOptions);
            }
            if (trace)
            {
                boolean saveLog = !trace.isLoggingOnlyOnErrorEnabled() || this.schedulingErrorOccured();

                if (saveLog)
                {
                    trace.saveAndClose(traceName);
                }

                trace.Dispose();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSchedulingErrorOccured</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Mark scheduling instance as failed
    /// </summary>
    [Hookable(false)]
    protected void setSchedulingErrorOccured()
    {
        schedulingErrorOccured = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Saves the data for all the scheduled orders to the AX database.
    /// </summary>
    /// <remarks>
    ///    The saving of the operation specific information is handled by the <c>this.saveRoute</c> method.The
    ///    saving of the job specific information is handled by the <c>this.saveJobs</c> method.
    /// </remarks>
    protected void saveData()
    {
        setRescheduleQueue = new Set(Types::Class);
        mapOrderData = new Map(Types::String, Types::Container);
        mapOperationData = new Map(Types::String, Types::Container);
        processScheduleResult = new Map(Types::String, Types::Real);
        overlapScheduleResult = new Map(Types::String, Types::Real);

        // Save the job information
        this.saveJobs();
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveJobs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves job information to the database.
    /// </summary>
    protected void saveJobs()
    {
        System.Collections.ArrayList    failedJobList;
        guid                            conflictCheckSessionId;

        jobCapResProperties = new Map(Types::Int64, Types::Container);

        conflictCheckSessionId = this.prepareCapacityCheckIntervals();

        try
        {
            failedJobList = this.validateCapacityConflicts(conflictCheckSessionId);
            this.handleCapacityConflicts(failedJobList);
        }
        catch
        {
            wrkCtrCapResConflictCheckIntervals.cleanUp(conflictCheckSessionId);
            throw Exception::Error;
        }

        wrkCtrCapResConflictCheckIntervals.cleanUp(conflictCheckSessionId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveOperation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Saves the scheduling results for an operation to the database.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> record that contains the order scheduling parameters.
    /// </param>
    /// <param name="_common">
    ///    A <c>Common</c> table buffer that contains the operation record.
    /// </param>
    /// <param name="_operationData">
    ///    A <c>container</c> with the scheduling result data for the operation.
    /// </param>
    protected void saveOperation(WrkCtrParmSchedule _wrkCtrParmSchedule,
                                 Common             _common,
                                 container          _operationData)
    {
        _common.skipTTSCheck(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Saves the scheduling results for an order.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> record that contains the order scheduling parameters.
    /// </param>
    /// <param name="_common">
    ///    A <c>Common</c> table buffer that contains the order master data. For example, a <c>ProdTable</c>
    ///    buffer.
    /// </param>
    /// <param name="_orderData">
    ///    A <c>container</c> with the scheduling result data for the order.
    /// </param>
    protected void saveOrder(WrkCtrParmSchedule _wrkCtrParmSchedule,
                             Common             _common,
                             container          _orderData)
    {
        _common.reread();
        _common.skipTTSCheck(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveOrdersAndRelated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves order and related data.
    /// </summary>
    /// <exception cref="M:Exception::Error">
    /// An error exception is thrown.
    /// </exception>
    /// <exception cref="M:Exception::UpdateConflictNotRecovered">
    /// The update conflict could not be resolved after retry.
    /// </exception>
    /// <exception cref="M:Exception::UpdateConflict">
    /// The call was performed in a nested transaction.
    /// </exception>
    protected void saveOrdersAndRelated()
    {
        Common                      common;
        WrkCtrParmSchedule          wrkCtrParmSchedule;
        MapEnumerator               mapEnumerator;
        int64                       jobId;
        WrkCtrJobSchedulingError    schedulingError;
        RecId                       firstErrorJobId;
        int                         solutionConstraintLevel;

        try
        {
            ttsbegin;

            // Save the route/job information
            this.saveRoutes();

            // Loop through all production orders and update
            mapEnumerator = mapOrderData.getEnumerator();
            while (mapEnumerator.moveNext())
            {
                // Get the production order from the map
                common = masterData.lookup(mapEnumerator.currentKey());

                // Get the production order schedule parameters
                wrkCtrParmSchedule = masterDataParms.lookup(common.(refIdField));

                if (!setRescheduleQueue.in(wrkCtrParmSchedule))
                {
                    // save the order data
                    this.saveOrder(wrkCtrParmSchedule, common, mapEnumerator.currentValue());
                }
            }

            this.deleteAllTemporaryJobs();

            // Loop through all orders and clean up if not scheduled
            mapEnumerator = mapUpdatedOrders.getEnumerator();
            while (mapEnumerator.moveNext())
            {
                common = mapEnumerator.currentKey();
                if (masterDataJobRecId.exists(this.keyOrder(common)))
                {
                    jobId = masterDataJobRecId.lookup(this.keyOrder(common));
                    [schedulingError, firstErrorJobId, solutionConstraintLevel] = scheduleEngine.getJobSchedulingSequenceResult(jobId);

                    if (schedulingError != WrkCtrJobSchedulingError::None)
                    {
                        // an error occurred during scheduling, clean up the order
                        this.cleanUpOrder(mapEnumerator.currentKey(), mapEnumerator.currentValue());
                    }
                }
            }

            ttscommit;
        }
        catch (Exception::Error)
        {
            throw Exception::Error;
        }
        catch (Exception::Deadlock)
        {
            retry;
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (ReqTransientSqlConnectionErrorHandlingHelper::retryTransientSqlConnectionError())
            {
                retry;
            }
            else
            {
                throw;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveRoutes</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Saves the route information, or operation information, to the database.
    /// </summary>
    protected void saveRoutes()
    {
        MapEnumerator       mapEnumerator;
        SchedDate           fromDate;
        SchedTime           fromTime;
        SchedDate           toDate;
        SchedTime           toTime;

        Common              common;

        WrkCtrParmSchedule  wrkCtrParmSchedule;
        WrkCtrId            resourceId;

        // Loop through all operations and update them with the data we got from saving the jobs
        mapEnumerator = mapOperationData.getEnumerator();
        while (mapEnumerator.moveNext())
        {
            [fromDate, fromTime, toDate, toTime, resourceId] = mapEnumerator.currentValue();
            if (routeData.exists(mapEnumerator.currentKey()))
            {
                common = routeData.lookup(mapEnumerator.currentKey());
            }

            if (common)
            {
                wrkCtrParmSchedule = masterDataParms.lookup(common.(routeRefIdField));

                // save each operation data
                this.saveOperation(wrkCtrParmSchedule,
                                   common,
                                   [fromDate, fromTime, toDate, toTime]);
                common.clear();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the scheduling status, either Job scheduled or Operation scheduled, based scheduling
    ///    method requested for a certain order.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> record that contains the order scheduling parameters.
    /// </param>
    /// <returns>
    ///    A <c>ProdSchedStatus</c> enumeration value that represents the scheduling status.
    /// </returns>
    public ProdSchedStatus schedStatus(WrkCtrParmSchedule _wrkCtrParmSchedule)
    {
        if (_wrkCtrParmSchedule.schedMethod() == SchedMethod::Detail)
        {
            return ProdSchedStatus::JobScheduled;
        }
        else
        {
            return ProdSchedStatus::OperationScheduled;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedulingErrorOccured</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether any errors occurred during scheduling.
    /// </summary>
    /// <returns>
    ///    true if any errors occurred during scheduling; otherwise, false.
    /// </returns>
    public boolean schedulingErrorOccured()
    {
        return schedulingErrorOccured;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inconsistentDataSchedulingErrorOccured</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the inconsistent data error occurred during scheduling.
    /// </summary>
    /// <returns>
    ///    true if the the inconsistent data error occurred during scheduling; otherwise, false.
    /// </returns>
    public boolean inconsistentDataSchedulingErrorOccured()
    {
        return inconsistentDataSchedulingErrorOccured;
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedulingProperties</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the scheduling properties for a given activity requirement set, site and scheduling
    /// method.
    /// </summary>
    /// <param name="_wrkCtrActivityRequirementSet">
    /// A <c>WrkCtrActivityRequirementSet</c> record that contains the activity requirement set data.
    /// </param>
    /// <param name="_siteId">
    /// The site identifier.
    /// </param>
    /// <param name="_schedMethod">
    /// The scheduling method (job or operation scheduling).
    /// </param>
    /// <returns>
    /// A <c>Map</c> object that contains the scheduling properties.
    /// </returns>
    protected Map schedulingProperties(WrkCtrActivityRequirementSet    _wrkCtrActivityRequirementSet,
                                        InventSiteId                    _siteId,
                                        SchedMethod                     _schedMethod)
    {
        return _wrkCtrActivityRequirementSet.schedulingProperties(_siteId, _schedMethod == SchedMethod::Detail, _schedMethod == SchedMethod::Rough);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCapacityConflictHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the capacity conflict handler that will be used during resource scheduling.
    /// </summary>
    /// <param name="_capacityConflictHandler">
    /// The capacity conflicts handler instance that will be used during scheduling.
    /// </param>
    public void setCapacityConflictHandler(WrkCtrCapacityConflictHandlerInterface _capacityConflictHandler)
    {
        capacityConflictHandler = _capacityConflictHandler;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferBatchTimeToProcessTimeRatio</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the ratio between the time that is required to process one transferrable batch and the
    /// total time of the specified operation.
    /// </summary>
    /// <param name="_operationReference">
    /// A record that contains a reference to the operation for which to calculate the ratio.
    /// </param>
    /// <param name="_order">
    /// The order to which the operation belongs.
    /// </param>
    /// <returns>
    /// The ratio between the time that is required to process one transferrable batch and the total time
    /// of the specified operation; otherwise, 1.If there is no transfer batch quantity on the specified
    /// operation, 1 is returned.
    /// </returns>
    protected real transferBatchTimeToProcessTimeRatio(RouteMap _operationReference, Common _order)
    {
        return 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRequirementSetAndPropertiesMaps</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the maps of the requirements and properties.
    /// </summary>
    /// <param name="_mapOprPriorityToRequirementProperties">
    /// A <c>Map</c> with the properties.
    /// </param>
    /// <param name="_routeJobMap">
    /// A <c>RouteMap</c> table map with the current route.
    /// </param>
    /// <param name="_wrkCtrActivityRequirementSet">
    /// A <c>WrkCtrActivityRequirementSet</c> record connected to the operation data.
    /// </param>
    /// <param name="_siteId">
    /// The ID of the production site.
    /// </param>
    /// <param name="_schedMethod">
    /// The scheduling method to use.
    /// </param>
    protected void updateRequirementSetAndPropertiesMaps(
                                                         Map                             _mapOprPriorityToRequirementProperties,
                                                         RouteJobMap                     _routeJobMap,
                                                         WrkCtrActivityRequirementSet    _wrkCtrActivityRequirementSet,
                                                         InventSiteId                    _siteId,
                                                         SchedMethod                     _schedMethod )
    {
        if (!_mapOprPriorityToRequirementProperties.exists(_routeJobMap.OprPriority))
        {
            _mapOprPriorityToRequirementProperties.insert(_routeJobMap.OprPriority, this.schedulingProperties(_wrkCtrActivityRequirementSet, _siteId, _schedMethod));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCapacityConflicts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates capacity reservation conflicts.
    /// </summary>
    /// <param name="_conflictCheckSessionId">
    /// The ID that is used to query the conflict check intervals.
    /// </param>
    /// <returns>
    /// A list of jobs for which validation failed.
    /// </returns>
    protected System.Collections.ArrayList validateCapacityConflicts(guid _conflictCheckSessionId)
    {
        System.Collections.ArrayList    failedJobList;

        try
        {
            ttsbegin;

            WrkCtrCapRes insertBuffer;
            if (canUseSeparateConnection && !wrkCtrCapResHandler.parmUsePessimisticReadLock())
            {
                saveReservationsConnection = new UserConnection();
                saveReservationsConnection.ttsbegin();
                insertBuffer.setConnection(saveReservationsConnection);
            }

            // these RecordInsertList receive all the capacity reservations that are written
            // by the WriteCapacityReservation method. This method is called back from the
            // scheduling interface (from the C# engine).
            capacityReservationsInsertList = new RecordInsertList(tableNum(WrkCtrCapRes), true, false, false, false, false, insertBuffer);

            this.onSaveJobsStart();

            if (finiteCapacityUsed)
            {
                timestamp = WrkCtrScheduler::incrementWrkCtrCapResTimestampUsingConnection(saveReservationsConnection);

                if (!wrkCtrCapResHandler.parmUsePessimisticReadLock())
                {
                    // Must lock and do validation before the reservations can be written
                    failedJobList = scheduleEngine.validateJobCapacityReservations(_conflictCheckSessionId);
                }
            }
            else
            {
                // When finite capacity is NOT used there is no need to take a lock to increment the time stamp, so just get the current value.
                timestamp = WrkCtrScheduler::currentWrkCtrCapResTimestamp();
            }
            
            scheduleEngine.setReservationsTimeStamp(timestamp);

            scheduleEngine.writeScheduledData();

            this.flushCachedSaveData();

            this.onSaveJobsDone();

            if (saveReservationsConnection)
            {
                saveReservationsConnection.ttscommit();
            }

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            this.disposeSaveReservationsConnection();
            retry;
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (ReqTransientSqlConnectionErrorHandlingHelper::retryTransientSqlConnectionError())
            {
                this.disposeSaveReservationsConnection();
                retry;
            }
            else
            {
                throw;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    this.disposeSaveReservationsConnection();
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        finally
        {
            this.disposeSaveReservationsConnection();
        }

        return failedJobList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>disposeSaveReservationsConnection</Name>
				<Source><![CDATA[
    private void disposeSaveReservationsConnection()
    {
        if (saveReservationsConnection)
        {
            saveReservationsConnection.finalize();
            saveReservationsConnection = null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeAllCapacityReservationProperties</Name>
				<Source><![CDATA[
    /// <summary>
    /// Writes all of the properties of an object to the <c>WrkCtrCapResProperty</c> table.
    /// </summary>
    protected void writeAllCapacityReservationProperties()
    {
        int                     propertyIndex;
        str                     propertyString;
        WrkCtrCapResProperty    wrkCtrCapResProperty;
        RecId                   jobId;
        container               properties;
        ListEnumerator          parmScheduleEnumerator;
        ListEnumerator          le;
        WrkCtrParmSchedule      wrkCtrParmSchedule;
        List                    capResIdentifiers;
        RecId                   capResRecId;

        WrkCtrCapResProperty    insertBuffer;
        Session session;

        if (saveReservationsConnection)
        {
            insertBuffer.setConnection(saveReservationsConnection);
            session = new Session();
        }

        RecordInsertList        recordInsertList = new RecordInsertList(tableNum(WrkCtrCapResProperty), true, false, false, false, false, insertBuffer);

        // loop orders
        parmScheduleEnumerator = listWrkCtrParmSchedule.getEnumerator();
        while (parmScheduleEnumerator.moveNext())
        {
            wrkCtrParmSchedule = parmScheduleEnumerator.current();

            // re-read reservation identifiers

            if (WrkCtrResSelectUsingUserConnectionFlight::instance().isEnabled())
            {
                capResIdentifiers = WrkCtrCapRes::getCapResIdentifiersUserConnection(wrkCtrParmSchedule.schedNumId(),
                    this.capacityRefType(),
                    wrkCtrParmSchedule.parmReqPlanVersionRefRecId(),
                    saveReservationsConnection);
            }
            else
            {
                capResIdentifiers = WrkCtrCapRes::getCapResIdentifiersUserConnection(wrkCtrParmSchedule.schedNumId(),
                    this.capacityRefType(),
                    wrkCtrParmSchedule.parmReqPlanVersionRefRecId());
            }
            // loop capacity reservations
            le = capResIdentifiers.getEnumerator();
            while (le.moveNext())
            {
                [capResRecId, jobId] = le.current();

                // find the properties for the job marked on the reservation
                if (jobCapResProperties.exists(jobId))
                {
                    properties = jobCapResProperties.lookup(jobId);

                    // insert the properties
                    for (propertyIndex=1; propertyIndex <= conLen(properties); ++propertyIndex)
                    {
                        propertyString = conPeek(properties, propertyIndex);
                        wrkCtrCapResProperty.SchedulingPropertyId = propertyString;
                        wrkCtrCapResProperty.CapResRefRecId = capResRecId;
                        if (saveReservationsConnection)
                        {
                            wrkCtrCapResProperty.RecordState = WrkCtrCapResRecordState::PendingInsert;
                            wrkCtrCapResProperty.RecordStateSessionId = session.sessionId();
                            wrkCtrCapResProperty.RecordStateSessionLoginDateTime = session.loginDateTime();
                        }
                        recordInsertList.add(wrkCtrCapResProperty);
                    }
                }
            }
        }

        recordInsertList.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeCapacityReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Writes a capacity reservation record to the database.
    /// </summary>
    /// <param name="_capacityReservationTemplate">
    /// A <c>WrkCtrCapRes</c> buffer with all the job information already filled in.
    /// </param>
    /// <param name="_fromDate">
    /// The Start date of the capacity reservation.
    /// </param>
    /// <param name="_fromTime">
    /// The Start time of the capacity reservation.
    /// </param>
    /// <param name="_toDate">
    /// The End date of the capacity reservation.
    /// </param>
    /// <param name="_toTime">
    /// The End time of the capacity reservation.
    /// </param>
    /// <param name="_loadPct">
    /// The Load percentage for the capacity reservation.
    /// </param>
    /// <param name="_capacitySeconds">
    /// The Capacity seconds to be written into the capacity reservation.
    /// </param>
    /// <param name="_properties">
    /// A container of properties to write.
    /// </param>
    /// <remarks>
    /// A <c>RecordInsertList</c> is used when the reservations are being written.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    /// An Exception is thrown in the case that no record insert list was created for the writing capacity
    /// reservations.
    /// </exception>
    public void writeCapacityReservation(WrkCtrCapRes   _capacityReservationTemplate,
                                         date           _fromDate,
                                         TimeOfDay      _fromTime,
                                         date           _toDate,
                                         TimeOfDay      _toTime,
                                         WrkCtrLoadPct  _loadPct,
                                         CapacitySec    _capacitySeconds,
                                         container      _properties = conNull())
    {
        WrkCtrCapRes        wrkCtrCapRes;
        WrkCtrLoadPct       loadPct = _loadPct * 100;
        TimeOfDay           toTime = _toTime;

        wrkCtrCapRes.data(_capacityReservationTemplate);

        if ((_toDate != _fromDate))
        {
            if (toTime == 0)
            {
                // crossing midnight - represent as 24:00:00
                toTime = #secondsPerDay;
            }
            else
            {
                throw error("@SYS134376");
            }
        }

        wrkCtrCapRes.WrkCtrLoadPct   = loadPct;

        wrkCtrCapRes.TransDate     = _fromDate;
        if (wrkCtrCapRes.LoadType != WrkCtrCapacityType::OperationSched)
        {
            wrkCtrCapRes.StartTime     = _fromTime;
            wrkCtrCapRes.EndTime       = toTime;
        }

        wrkCtrCapRes.WrkCtrSec     = _capacitySeconds;
        wrkCtrCapRes.initIntvFields();

        this.insertWrkCtrCapResUsingInsertList(wrkCtrCapRes);
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeJobCapacityReservations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Writes the capacity reservations for one job to the database.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> instance that contains all of the scheduling options for the order
    /// being scheduled.
    /// </param>
    /// <param name="_jobId">
    /// A <c>RecId</c> field that identifies the job for which the data is written back to the database.
    /// </param>
    /// <param name="_resourceId">
    /// An identifier of the resource on which the job was scheduled.
    /// </param>
    /// <param name="_reservationProperties">
    /// A <c>Container</c> value with the reservation properties for the job.
    /// </param>
    /// <param name="_capacityReservations">
    /// A <c>Container</c> value with the capacity reservations for the scheduled job.
    /// </param>
    protected void writeJobCapacityReservations(WrkCtrParmSchedule  _wrkCtrParmSchedule,
                                                RecId               _jobId,
                                                WrkCtrId            _resourceId,
                                                container           _reservationProperties,
                                                container           _capacityReservations)
    {
        date                reservationFromDate;
        TimeOfDay           reservationFromTime;
        date                reservationToDate;
        TimeOfDay           reservationToTime;
        WrkCtrLoadPct       reservationLoadPct;
        CapacitySec         reservationCapSec;
        int                 capacityReservationCount;
        WrkCtrCapRes        wrkCtrCapRes;
        int                 i;

        capacityReservationCount = conLen(_capacityReservations);

        if (capacityReservationCount > 0)
        {
            wrkCtrCapRes = this.initWrkCtrCapRes(_wrkCtrParmSchedule, _jobId, _resourceId);

            if (wrkCtrCapRes.LoadType == WrkCtrCapacityType::OperationSched &&
                conLen(_reservationProperties) > 0)
            {
                // The properties required by the job must be stored, writing to the database is deferred
                // until all job reservations are written to the database
                jobCapResProperties.insert(_jobId, _reservationProperties);
            }
        }

        for (i = 1; i <= capacityReservationCount; i += WrkCtrSchedulerCapacityReservation::CapacityReservationFields)
        {
            reservationFromDate = conPeek(_capacityReservations, i + WrkCtrSchedulerCapacityReservation::FromDateIndex);
            reservationFromTime = conPeek(_capacityReservations, i + WrkCtrSchedulerCapacityReservation::FromTimeIndex);
            reservationToDate = conPeek(_capacityReservations, i + WrkCtrSchedulerCapacityReservation::ToDateIndex);
            reservationToTime = conPeek(_capacityReservations, i + WrkCtrSchedulerCapacityReservation::ToTimeIndex);
            reservationLoadPct = conPeek(_capacityReservations, i + WrkCtrSchedulerCapacityReservation::LoadPctIndex);
            reservationCapSec = conPeek(_capacityReservations, i + WrkCtrSchedulerCapacityReservation::CapacitySecondsIndex);

            this.writeCapacityReservation(wrkCtrCapRes,
                                          reservationFromDate,
                                          reservationFromTime,
                                          reservationToDate,
                                          reservationToTime,
                                          reservationLoadPct,
                                          reservationCapSec);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initWrkCtrCapRes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize <c>WrkCtrCapRes</c> record.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> instance that contains all of the scheduling options for the order
    /// being scheduled.
    /// </param>
    /// <param name="_jobId">
    /// A <c>RecId</c> field that identifies the job for which the data is written back to the database.
    /// </param>
    /// <param name="_resourceId">
    /// An identifier of the resource on which the job was scheduled.
    /// </param>
    /// <returns>
    /// The <c>WrkCtrCapRes</c> initialized record.
    /// </returns>
    protected WrkCtrCapRes initWrkCtrCapRes(WrkCtrParmSchedule _wrkCtrParmSchedule, RecId _jobId, WrkCtrId _resourceId)
    {
        WrkCtrCapRes wrkCtrCapRes;

        wrkCtrCapRes.PlanVersion     = _wrkCtrParmSchedule.parmReqPlanVersionRefRecId();
        wrkCtrCapRes.Timestamp       = timestamp;
        wrkCtrCapRes.WrkCtrId        = _resourceId;
        this.initCapacityReservationData(_wrkCtrParmSchedule,
                                             wrkCtrCapRes,
                                             _jobId);

        wrkCtrCapRes.LoadType        = this.capacityTypeReservation(_wrkCtrParmSchedule);
        wrkCtrCapRes.RefType         = this.capacityRefType();
        wrkCtrCapRes.OrigJobRecId  = _jobId;

        if (saveReservationsConnection)
        {
            Session session = new Session();

            wrkCtrCapRes.RecordState = WrkCtrCapResRecordState::PendingInsert;
            wrkCtrCapRes.RecordStateSessionId = session.sessionId();
            wrkCtrCapRes.RecordStateSessionLoginDateTime = session.loginDateTime();
        }

        return wrkCtrCapRes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeJobData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Writes the job data to the database.
    /// </summary>
    /// <param name="_jobId">
    /// A <c>RecId</c> field that identifies the job for which the data is written back to the database.
    /// </param>
    /// <param name="_resourceId">
    /// An identifier of the resource on which the job was scheduled.
    /// </param>
    /// <param name="_fromDate">
    /// A <c>Date</c> value that represents the start schedule date for the job.
    /// </param>
    /// <param name="_fromTime">
    /// A <c>Date</c> value that represents the start schedule time for the job.
    /// </param>
    /// <param name="_toDate">
    /// A <c>Date</c> value that represents the ending schedule date for the job.
    /// </param>
    /// <param name="_toTime">
    /// A <c>Date</c> value that represents the ending schedule time for the job.
    /// </param>
    /// <param name="_runtime">
    /// A <c>Date</c> value that represents the runtime of the scheduled job.
    /// </param>
    /// <param name="_reservationProperties">
    /// A <c>Container</c> with the reservation properties for the job.
    /// </param>
    /// <param name="_capacityReservations">
    /// A <c>Container</c> value with the capacity reservations for the scheduled job.
    /// </param>
    /// <param name="_physicalUpdateJobs">
    /// Optional; A Boolean value indicating whether to do a physical database update,
    /// or update only the relevant internal maps and write capacity reservations.
    /// By default, jobs are physically updated when doing job scheduling.
    /// </param>
    /// <remarks>
    /// This method can be overridden.
    /// </remarks>
    public void writeJobData(RecId          _jobId,
                             WrkCtrId       _resourceId,
                             date           _fromDate,
                             TimeOfDay      _fromTime,
                             date           _toDate,
                             TimeOfDay      _toTime,
                             Seconds        _runtime,
                             container      _reservationProperties,
                             container      _capacityReservations
                             , boolean        _physicalUpdateJobs = true
                             )
    {
        SchedMethod         schedMethod;
        WrkCtrParmSchedule  wrkCtrParmSchedule;
        RouteJobMap         job;
        date                routeFromDate;
        TimeOfDay           routeFromTime;
        date                routeToDate;
        TimeOfDay           routeToTime;
        WrkCtrId            resourceId;
        str                 keyRoute;

        if (constraintJobs.in(_jobId))
        {
            // Jobs that are only added to form additional constraints between other jobs should never be written,
            // nor should they affect the from/to time of operations or orders.
            return;
        }

        if (saveReservationsConnection)
        {
            WrkCtrCapResHandler::initializeTransactionScopeHandlers();
        }

        job = jobData.lookup(_jobId);
        wrkCtrParmSchedule = this.findJobWrkCtrParmSchedule(_jobId);
        schedMethod = wrkCtrParmSchedule.schedMethod();

        keyRoute = this.keyRoute( job.RefId, job.OprNum, job.OprPriority);

        // Aggregate times on route (operation) level
        if (!mapOperationData.exists(keyRoute))
        {
            routeFromDate = _fromDate;
            routeFromTime = _fromTime;
            routeToDate = _toDate;
            routeToTime = _toTime;
            resourceId = _resourceId;
        }
        else
        {
            [routeFromDate, routeFromTime, routeToDate, routeToTime, resourceId] = mapOperationData.lookup(keyRoute);

            if ((_fromDate < routeFromDate) || (_fromDate == routeFromDate && _fromTime < routeFromTime))
            {
                routeFromDate = _fromDate;
                routeFromTime = _fromTime;
            }

            if ((_toDate > routeToDate) || (_toDate == routeToDate && _toTime > routeToTime))
            {
                routeToDate = _toDate;
                routeToTime = _toTime;
            }
        }

        mapOperationData.insert(keyRoute, [routeFromDate, routeFromTime, routeToDate, routeToTime, resourceId]);

        if (job.OprPriority == RouteOprPriority::Primary && job.JobType == RouteJobType::Process)
        {
            processScheduleResult.insert(keyRoute, _runtime / #SecondsPerHour);
        }

        if (job.OprPriority == RouteOprPriority::Primary && job.JobType == RouteJobType::Overlap)
        {
            overlapScheduleResult.insert(keyRoute, _runtime / #SecondsPerHour);
        }

        // Update job records if doing Job Scheduling
        if (!job.isTmp()
            && schedMethod == SchedMethod::Detail
            && _physicalUpdateJobs
            )
        {
            if (needRereadJob)
            {
                job.reread();
            }

            job.SchedTimeHours = (_runtime / #SecondsPerHour);
            job.CalcTimeHours = job.SchedTimeHours;

            job.FromDate    = _fromDate;
            job.FromTime    = _fromTime;
            job.ToDate      = _toDate;
            job.ToTime      = _toTime;

            job.WrkCtrId    = _resourceId;

            if ((job.FromDate    == job.ToDate &&
                 job.FromTime    == job.ToTime) || _runtime == 0)
            {
                job.SchedCancelled = NoYes::Yes;
            }
            else
            {
                job.SchedCancelled = NoYes::No;
            }

            if (!this.skipUpdateJob(job, _resourceId, _fromDate, _fromTime, _toDate, _toTime, _runtime))
            {
                job.skipTTSCheck(true);
                job.update();
            }
        }

        this.writeJobCapacityReservations(wrkCtrParmSchedule, _jobId, _resourceId, _reservationProperties, _capacityReservations);
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipUpdateJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Skip <c>RouteJobMap</c> update.
    /// </summary>
    /// <param name="_job">
    /// A <c>RouteJobMap</c> instance.
    /// </param>
    /// <param name="_resourceId">
    /// An identifier of the resource on which the job was scheduled.
    /// </param>
    /// <param name="_fromDate">
    /// A <c>Date</c> value that represents the start schedule date for the job.
    /// </param>
    /// <param name="_fromTime">
    /// A <c>Date</c> value that represents the start schedule time for the job.
    /// </param>
    /// <param name="_toDate">
    /// A <c>Date</c> value that represents the ending schedule date for the job.
    /// </param>
    /// <param name="_toTime">
    /// A <c>Date</c> value that represents the ending schedule time for the job.
    /// </param>
    /// <param name="_runtime">
    /// A <c>Date</c> value that represents the runtime of the scheduled job.
    /// </param>
    /// <returns>
    /// True if the job update must be skipped; otherwise; false.
    /// </returns>
    /// <remarks>
    /// This method is an extension point to control the job update based on the passed arguments.
    /// </remarks>
    protected boolean skipUpdateJob(RouteJobMap _job,
                                    WrkCtrId    _resourceId,
                                    date        _fromDate,
                                    TimeOfDay   _fromTime,
                                    date        _toDate,
                                    TimeOfDay   _toTime,
                                    Seconds     _runtime)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static WrkCtrScheduler construct()
    {
        return new WrkCtrScheduler();
    }

]]></Source>
			</Method>
			<Method>
				<Name>incrementWrkCtrCapResTimestamp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Increments the timestamp value to be used for capacity reservations timestamps.
    /// Holds a lock on WrkCtrSchedulerLock until the transaction is completed.
    /// </summary>
    /// <returns>
    /// The result of the increment.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Thrown if this method is not called inside a transaction.
    /// </exception>
    [SysObsolete("This method is deprecated and will be removed in future releases. Use incrementWrkCtrCapResTimestampUsingConnection instead.", false, 30\06\2020)]
    public static WrkCtrCapResTimestamp incrementWrkCtrCapResTimestamp()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>incrementWrkCtrCapResTimestampUsingConnection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Increments the timestamp value to be used for capacity reservations timestamps.
    /// Holds a lock on WrkCtrSchedulerLock until the transaction is completed.
    /// </summary>
    /// <param name="_connection">
    /// The <c>UserConnection</c> that will be used to hold the lock.
    /// </param>
    /// <returns>
    /// The result of the increment.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Thrown if this method is not called inside a transaction.
    /// </exception>
    public static WrkCtrCapResTimestamp incrementWrkCtrCapResTimestampUsingConnection(UserConnection _connection = null)
    {
        WrkCtrCapResTimestamp legacyTimestamp = WrkCtrScheduler::incrementWrkCtrCapResTimestamp();

        WrkCtrSchedulerLockManager schedulerlockManager = WrkCtrSchedulerLockManager::construct();
        schedulerlockManager.parmUserConnection(_connection);
        return max(schedulerLockManager.acquireLock(), legacyTimestamp);
    }

]]></Source>
			</Method>
			<Method>
				<Name>currentWrkCtrCapResTimestamp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the current timestamp value that should be applied to capacity reservations.
    /// </summary>
    /// <returns>
    /// The timestamp value.
    /// </returns>    
    public static WrkCtrCapResTimestamp currentWrkCtrCapResTimestamp()
    {
        return WrkCtrSchedulerLockManager::currentTimestamp();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newRefType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new engine based on the type of order that needs to be scheduled.
    /// </summary>
    /// <param name="_wrkCtrCapRefType">
    /// Order type.
    /// </param>
    /// <param name="_reqPlanVersionRefRecId">
    /// Plan version record ID.
    /// </param>
    /// <returns>
    /// A instance of <c>WrkCtrScheduler</c>.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// An exception is thrown if an invalid order type enumeration value is passed as argument.
    /// </exception>
    public static WrkCtrScheduler newRefType(WrkCtrCapRefType _wrkCtrCapRefType, RefRecId _reqPlanVersionRefRecId = 0)
    {
        WrkCtrScheduler scheduler;

        switch (_wrkCtrCapRefType)
        {
            case WrkCtrCapRefType::Production:
                scheduler = WrkCtrScheduler_Prod::construct();
                break;

            case WrkCtrCapRefType::PlannedOrder:
                scheduler = WrkCtrScheduler_Req::construct();
                break;

            case WrkCtrCapRefType::Project:
                scheduler = WrkCtrScheduler_Proj::construct();
                break;

            default:
                throw error("@SYS133608");
        }

        scheduler.parmReqPlanVersionRefRecId(_reqPlanVersionRefRecId);

        return scheduler;
    }

]]></Source>
			</Method>
			<Method>
				<Name>propertyHashtable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Converts a <c>Map</c> object that contains job requirement properties to a
    ///    <c>System.Collections.Hashtable</c> object.
    /// </summary>
    /// <param name="_requirementProperties">
    ///    The <c>Map</c> object to convert.
    /// </param>
    /// <returns>
    ///    An <c>System.Collections.Hashtable</c> object that contains the converted job requirement
    ///    properties.
    /// </returns>
    public static System.Collections.Hashtable propertyHashtable(Map _requirementProperties)
    {
        System.Collections.Hashtable    propertyMap;
        MapEnumerator                   mapEnumerator;

        propertyMap = new System.Collections.Hashtable();

        mapEnumerator = _requirementProperties.getEnumerator();
        while (mapEnumerator.moveNext())
        {
            propertyMap.Add(mapEnumerator.currentKey(), mapEnumerator.currentValue());
        }

        return propertyMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resourceAsList</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a list that contains only one resource identifier.
    /// </summary>
    /// <param name="_wrkCtrId">
    ///    A <c>WrkCtrId</c> value that identifies the resource to add to the list.
    /// </param>
    /// <returns>
    ///    A <c>List</c> object that contains only one resource, the one specified by the <param name="_wrkCtrId" /> parameter.
    /// </returns>
    protected static List resourceAsList(WrkCtrId _wrkCtrId)
    {
        List listWorkCenters = new List(Types::String);

        listWorkCenters.addEnd(_wrkCtrId);

        return listWorkCenters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanUpdateCompletedRoute</Name>
				<Source><![CDATA[
    public boolean parmCanUpdateCompletedRoute(boolean _canUpdateCompletedRoute = canUpdateCompletedRoute)
    {
        canUpdateCompletedRoute = _canUpdateCompletedRoute;
        return canUpdateCompletedRoute;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHasOverlapJob</Name>
				<Source><![CDATA[
    public boolean parmHasOverlapJob(boolean _hasOverlapJob = hasOverlapJob)
    {
        hasOverlapJob = _hasOverlapJob;
        return hasOverlapJob;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getParametersForTelemetry</Name>
				<Source><![CDATA[
    private SysInstrumentationAdditionalParameters getParametersForTelemetry()
    {
        SysInstrumentationAdditionalParameters instrumentationAdditionalParameters;
        var listEnumerator = listWrkCtrParmSchedule.getEnumerator();
        if (listEnumerator && listEnumerator.moveNext())
        {
            WrkCtrParmSchedule wrkCtrParmSchedule = listEnumerator.current();

            instrumentationAdditionalParameters = wrkCtrParmSchedule.getParametersForTelemetry();
        }

        return instrumentationAdditionalParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrkCtrParmSchedule</Name>
				<Source><![CDATA[
    private void validateWrkCtrParmSchedule(WrkCtrParmSchedule _wrkCtrParmSchedule)
    {
        if (_wrkCtrParmSchedule.schedJobRecId()
            && !_wrkCtrParmSchedule.synchronizeReference()
            && _wrkCtrParmSchedule.schedReference())
        {
            throw error(strFmt("@SCMPlanning:ProdSchedJobIdAndSchedRefWithoutSyncRefError", _wrkCtrParmSchedule.schedNumId()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>today</Name>
				<Source><![CDATA[
    private date today()
    {
        return DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>