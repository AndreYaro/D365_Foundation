<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerJournalTransUpdate</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>LedgerJournalTransUpdate</c> class contains logic to validate, update, and post journal lines.
/// </summary>
class LedgerJournalTransUpdate
{
    boolean             isOffset;
    TaxVoucherService   taxVoucherService;
    RecId               custVendNegInstSettleTransRecId;
    boolean             accrual;
    Map                 tmpVoucherMap;
    container           intercompanyRecIds;
    boolean             isVoucherValid;
    #ISOCountryRegionCodes
    // <GIN>
    TaxAmountCur        loiAmount;
    TaxAmountCur        nonTaxableAmount;
    TaxAmountCur        totLoiAmount;
    boolean             approval;
    boolean             inclTax;
    // </GIN>
    // <GJP>
    // This map stores the mapping between journal line and its related journal line in foreign company.
    Map                 ledgerJournalTransIntercompanyMap;
    // </GJP>

    RetailCustTrans        rboCustTrans;
    RetailTransactionId    rboTransactionId;
    RetailStoreId          rboStoreId;
    RetailTerminalId       rboTerminalId;

    // <GTE>
    Map taxDocumentLedgerVoucherMap;
    // </GTE>

    protected DataAreaId taxGroupCompany;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>check</Name>
				<Source><![CDATA[
    boolean check(LedgerJournalTrans        _ledgerJournalTrans,
                  boolean                   _checkNoSettlement = true,
                  LedgerVoucher             _ledgerVoucher = null,
                  LedgerPostingMessageLog   _ledgerPostingMessageCollection = null)
    {
        boolean ok;

        ok = _ledgerJournalTrans.checkCurrency(_ledgerPostingMessageCollection);

        // elimination journals are valid for consolidation companies but the company must be marked elimination
        if (_ledgerJournalTrans.TransactionType == LedgerTransType::Elimination)
        {
            ok = this.checkElimination(_ledgerJournalTrans, _ledgerPostingMessageCollection) && ok;
        }
        else
        {
            ok = this.checkConsolidation(_ledgerJournalTrans, _ledgerPostingMessageCollection) && ok;
        }

        ok = this.checkTaxAmount(_ledgerJournalTrans, _ledgerPostingMessageCollection) && ok;

        if ((_ledgerJournalTrans.AmountCurCredit != CurrencyExchangeHelper::amount(_ledgerJournalTrans.AmountCurCredit, _ledgerJournalTrans.CurrencyCode)) ||
           (_ledgerJournalTrans.AmountCurDebit != CurrencyExchangeHelper::amount(_ledgerJournalTrans.AmountCurDebit, _ledgerJournalTrans.CurrencyCode)))
        {
            if (_ledgerPostingMessageCollection)
            {
                ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS25053");
            }
            else
            {
                ok = checkFailed("@SYS25053");
            }
        }

        if (ok && LedgerParameters::find().IsZakatEnabled_SA)
        {
            ok =  LedgerJournalTransZakat_SA::validateSubContratorGroup(_ledgerJournalTrans.RecId);
        }

        ok = _ledgerJournalTrans.checkTaxCode(_ledgerPostingMessageCollection) && ok;

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkMultipleTransactionsWithinOneVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the journal contains "One voucher" transactions.  There is a parameter
    /// that determines if these transactions are permitted.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> table record to be checked.
    /// </param>
    /// <param name="_ledgerPostingMessageCollection">
    /// The posting messages collection.
    /// </param>
    /// <returns>
    /// true when either "One voucher" transactions are permitted or none exist for the
    /// specified journal line; otherwise false.
    /// </returns>
    /// <remarks>
    /// The exclusion of the "Fee" type transaction allows for an LedgerTransType::Fee
    /// transaction to be posted inside the same voucher grouping.
    /// </remarks>
    [SysObsolete('The checkMultipleTransactionsWithinOneVoucher method is no longer used in the LedgerJournalTransUpdate class, use the checkMultipleTransactionsWithinOneVoucher method in the LedgerJournalCheckPost class instead', false, 31\03\2019)]
    protected boolean checkMultipleTransactionsWithinOneVoucher(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerPostingMessageLog _ledgerPostingMessageCollection)
    {
        boolean ok = true;

        if (LedgerParameters::find().AllowMultipleTransactionsWithinOneVoucher == NoYes::No)
        {
            // Company context for this validation must the journal's company ID.
            changecompany(_ledgerJournalTrans.company())
            {
                int numCustVend, numBank, numFixedAssets, numProject;
                LedgerJournalTrans ledgerJournalTrans;

                while select count(RecId) from ledgerJournalTrans
                    group by ledgerJournalTrans.AccountType
                    where
                        ledgerJournalTrans.Voucher == _ledgerJournalTrans.Voucher &&
                        ledgerJournalTrans.JournalNum == _ledgerJournalTrans.JournalNum &&
                        ledgerJournalTrans.TransactionType != LedgerTransType::Fee &&
                        (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend ||
                         ledgerJournalTrans.AccountType == LedgerJournalACType::Cust ||
                         ledgerJournalTrans.AccountType == LedgerJournalACType::Bank ||
                         ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets ||
                         ledgerJournalTrans.AccountType == LedgerJournalACType::Project)
                {
                    if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend || ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
                    {
                        numCustVend += int642int(ledgerJournalTrans.RecId);
                    }
                    else if (ledgerJournalTrans.AccountType == LedgerJournalACType::Bank)
                    {
                        numBank = int642int(ledgerJournalTrans.RecId);
                    }
                    else if (ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets)
                    {
                        numFixedAssets = int642int(ledgerJournalTrans.RecId);
                    }
                    else if (ledgerJournalTrans.AccountType == LedgerJournalACType::Project)
                    {
                        numProject = int642int(ledgerJournalTrans.RecId);
                    }
                }

                while select count(RecId) from ledgerJournalTrans
                    group by ledgerJournalTrans.OffsetAccountType
                    where
                        ledgerJournalTrans.Voucher == _ledgerJournalTrans.Voucher &&
                        ledgerJournalTrans.JournalNum == _ledgerJournalTrans.JournalNum &&
                        ledgerJournalTrans.OffsetLedgerDimension != 0 &&
                        ledgerJournalTrans.TransactionType != LedgerTransType::Fee &&
                        (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend ||
                         ledgerJournalTrans.AccountType == LedgerJournalACType::Cust ||
                         ledgerJournalTrans.AccountType == LedgerJournalACType::Bank ||
                         ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets ||
                         ledgerJournalTrans.AccountType == LedgerJournalACType::Project)
                {
                    if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend || ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust)
                    {
                        numCustVend += int642int(ledgerJournalTrans.RecId);
                    }
                    else if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank)
                    {
                        numBank += int642int(ledgerJournalTrans.RecId);
                    }
                    else if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets)
                    {
                        numFixedAssets += int642int(ledgerJournalTrans.RecId);
                    }
                    else if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project)
                    {
                        numProject += int642int(ledgerJournalTrans.RecId);
                    }
                }

                if (numCustVend > 1)
                {
                    if (_ledgerPostingMessageCollection)
                    {
                        ok = _ledgerPostingMessageCollection.logCheckFailed("@GeneralLedger:MultipleTransactionsWithinOneVoucherNotAllowedCustVend");
                    }
                    else
                    {
                        ok = checkFailed("@GeneralLedger:MultipleTransactionsWithinOneVoucherNotAllowedCustVend");
                    }
                }

                if (numBank > 1)
                {
                    if (_ledgerPostingMessageCollection)
                    {
                        ok = _ledgerPostingMessageCollection.logCheckFailed("@GeneralLedger:MultipleTransactionsWithinOneVoucherNotAllowedBank");
                    }
                    else
                    {
                        ok = checkFailed("@GeneralLedger:MultipleTransactionsWithinOneVoucherNotAllowedBank");
                    }
                }

                if (numFixedAssets > 1)
                {
                    if (_ledgerPostingMessageCollection)
                    {
                        ok = _ledgerPostingMessageCollection.logCheckFailed("@GeneralLedger:MultipleTransactionsWithinOneVoucherNotAllowedFixedAssets");
                    }
                    else
                    {
                        ok = checkFailed("@GeneralLedger:MultipleTransactionsWithinOneVoucherNotAllowedFixedAssets");
                    }
                }

                if (numProject > 1)
                {
                    if (_ledgerPostingMessageCollection)
                    {
                        ok = _ledgerPostingMessageCollection.logCheckFailed("@GeneralLedger:MultipleTransactionsWithinOneVoucherNotAllowedProject");
                    }
                    else
                    {
                        ok = checkFailed("@GeneralLedger:MultipleTransactionsWithinOneVoucherNotAllowedProject");
                    }
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCashDiscCodeAmount</Name>
				<Source><![CDATA[
    boolean checkCashDiscCodeAmount(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        if (_ledgerJournalTrans.CashDiscAmount && !_ledgerJournalTrans.CashDiscCode && !TaxParameters::find().CashDiscOnInvoice)
        {
            if (_ledgerPostingMessageCollection)
            {
                return _ledgerPostingMessageCollection.logCheckFailed("@SYS70370");
            }
            else
            {
                return checkFailed("@SYS70370");
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkConsolidation</Name>
				<Source><![CDATA[
    boolean checkConsolidation(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        if (_ledgerJournalTrans.Company && _ledgerJournalTrans.Company != curext())
        {
            if (! xDataArea::exist(_ledgerJournalTrans.Company))
            {
                if (_ledgerPostingMessageCollection)
                {
                    _ledgerPostingMessageCollection.logAndThrowError(strFmt("@SYS10666", _ledgerJournalTrans.Company));
                }
                else
                {
                    throw error(strFmt("@SYS10666", _ledgerJournalTrans.Company));
                }
            }

            changecompany(_ledgerJournalTrans.Company)
            {
                if (CompanyInfo::isConsolidationCompany(_ledgerJournalTrans.Company) == NoYes::Yes)
                {
                    if (_ledgerPostingMessageCollection)
                    {
                        return _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS25229", _ledgerJournalTrans.Company));
                    }
                    else
                    {
                        return checkFailed(strFmt("@SYS25229", _ledgerJournalTrans.Company));
                    }
                }
            }
        }
        else
        {
            if (CompanyInfo::isConsolidationCompany(_ledgerJournalTrans.Company) == NoYes::Yes)
            {
                if (_ledgerPostingMessageCollection)
                {
                    return _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS25229", _ledgerJournalTrans.Company));
                }
                else
                {
                    return checkFailed(strFmt("@SYS25229", _ledgerJournalTrans.Company));
                }
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkElimination</Name>
				<Source><![CDATA[
    boolean checkElimination(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        if (_ledgerJournalTrans.Company && _ledgerJournalTrans.Company != curext())
        {
            if (! xDataArea::exist(_ledgerJournalTrans.Company))
            {
                if (_ledgerPostingMessageCollection)
                {
                    _ledgerPostingMessageCollection.logAndThrowError(strFmt("@SYS10666", _ledgerJournalTrans.Company));
                }
                else
                {
                    throw error(strFmt("@SYS10666", _ledgerJournalTrans.Company));
                }
            }

            changecompany(_ledgerJournalTrans.Company)
            {
                if (CompanyInfo::isEliminationCompany(_ledgerJournalTrans.Company) == NoYes::No)
                {
                    if (_ledgerPostingMessageCollection)
                    {
                        return _ledgerPostingMessageCollection.logCheckFailed("@SYS107559");
                    }
                    else
                    {
                        return checkFailed("@SYS107559");
                    }
                }
            }
        }
        else
        {
            if (CompanyInfo::isEliminationCompany(_ledgerJournalTrans.Company) == NoYes::No)
            {
                if (_ledgerPostingMessageCollection)
                {
                    return _ledgerPostingMessageCollection.logCheckFailed("@SYS107559");
                }
                else
                {
                    return checkFailed("@SYS107559");
                }
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPaymStatus</Name>
				<Source><![CDATA[
    public boolean checkPaymStatus(LedgerJournalType   _ledgerJournalType,
                                    LedgerJournalTrans  _ledgerJournalTrans)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPrepayments_W</Name>
				<Source><![CDATA[
    protected boolean checkPrepayments_W(
        LedgerJournalTrans _ledgerJournalTrans,
        boolean _taxOnPrepayment,
        LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        boolean ret = true;

        if (_taxOnPrepayment                 &&
            _ledgerJournalTrans.Prepayment   &&
            _ledgerJournalTrans.TaxGroup     &&
            _ledgerJournalTrans.TaxItemGroup &&
            ! _ledgerJournalTrans.ledgerJournalTable().LedgerJournalInclTax &&
            (_ledgerJournalTrans.AccountType != LedgerJournalACType::Vend   ||
             ! VendTable::find(_ledgerJournalTrans.parmAccount()).vatTaxAgent_RU))
        {
            if (_ledgerPostingMessageCollection)
            {
                ret = _ledgerPostingMessageCollection.logCheckFailed("@GLS106911");
            }
            else
            {
                ret = checkFailed("@GLS106911");
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks the VAT amount of the transaction line.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table record to be checked.
    /// </param>
    /// <param name="_ledgerPostingMessageCollection">
    ///    The posting messages collection; optional.
    /// </param>
    /// <returns>
    ///    true when VAT amount is valid; otherwise false
    /// </returns>
    /// <remarks>
    ///    This method generates an error if the VAT amount verification fails.
    /// </remarks>
    boolean checkTaxAmount(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        LedgerJournalTable ledgerJournalTable;
        boolean ok = true;

        ledgerJournalTable = _ledgerJournalTrans.ledgerJournalTable();

        if (ledgerJournalTable.LedgerJournalInclTax
            && ledgerJournalTable.isTaxSupported()
            && ((_ledgerJournalTrans.isPrimaryTaxable() && !isOffset) ||
                (_ledgerJournalTrans.isOffsetTaxable() && isOffset)))
        {
            Amount actualTaxAmountForSourceLineWithCompany;
            if (!TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
            {
                actualTaxAmountForSourceLineWithCompany = TaxUncommitted::getActualTaxAmountForSourceLineWithCompany(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId, false, true);
            }

            if (abs(_ledgerJournalTrans.amount()) < abs(actualTaxAmountForSourceLineWithCompany))
            {
                if (_ledgerPostingMessageCollection)
                {
                    ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS121769");
                }
                else
                {
                    ok = checkFailed("@SYS121769");
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxCombination</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the tax information on a journal line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_ledgerPostingMessageCollection">
    /// The <c>LedgerPostingMessageLog</c> instance.
    /// </param>
    /// <returns>
    /// true if the tax information on the journal line is in a valid state; otherwise, false.
    /// </returns>
    boolean checkTaxCombination(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        boolean ret = true;
        CheckTaxGroups checkIntersection = TaxParameters::find().CheckIntersection;

        if (_ledgerJournalTrans.shouldSuppressTaxValidation())
        {
            return true;
        }

        if (checkIntersection != CheckTaxGroups::None
            && this.shouldCheckTaxCombination(_ledgerJournalTrans)
            && this.checkTaxCombinationTaxGroup(_ledgerJournalTrans))
        {
            switch (checkIntersection)
            {
                case CheckTaxGroups::Error:
                    if (_ledgerPostingMessageCollection)
                    {
                        _ledgerPostingMessageCollection.logAndThrowError(strFmt("@Tax:Validation_GroupItemGroupIntersectionInvalid", _ledgerJournalTrans.TaxGroup, _ledgerJournalTrans.TaxItemGroup));
                    }
                    else
                    {
                        throw error(strFmt("@Tax:Validation_GroupItemGroupIntersectionInvalid", _ledgerJournalTrans.TaxGroup, _ledgerJournalTrans.TaxItemGroup));
                    }
                    ret = false;
                    break;

                case CheckTaxGroups::Warning:
                    if (_ledgerPostingMessageCollection)
                    {
                        _ledgerPostingMessageCollection.logAndThrowWarning(strFmt("@Tax:Validation_GroupItemGroupIntersectionInvalid", _ledgerJournalTrans.TaxGroup, _ledgerJournalTrans.TaxItemGroup));
                    }
                    else
                    {
                        throw warning(strFmt("@Tax:Validation_GroupItemGroupIntersectionInvalid", _ledgerJournalTrans.TaxGroup, _ledgerJournalTrans.TaxItemGroup));
                    }
                    break;

                default:
                    break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCheckTaxCombination</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the Tax information is provided in <c>LedgerJournalTrans</c> and if the journal line is an invoice.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// Returns true if the Tax information is available and if the journal line is an invoice; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean shouldCheckTaxCombination(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalType ledgerJournalType = _ledgerJournalTrans.ledgerJournalTable().JournalType;

        return ((ledgerJournalType == LedgerJournalType::VendInvoiceRegister || _ledgerJournalTrans.Invoice)
                && (_ledgerJournalTrans.TaxGroup && _ledgerJournalTrans.TaxItemGroup));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxCombinationTaxGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if taxes are derived for the provided combination of Tax Group and Tax item group from <c>LedgerJournalTrans</c> in <c>TaxGroupData</c> table.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// Returns true if taxes are derived for the tax group and tax item group; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean checkTaxCombinationTaxGroup(LedgerJournalTrans _ledgerJournalTrans)
    {
        TaxGroupData taxGroupData;
        TaxOnItem taxOnItem;

        select firstonly RecId from taxGroupData
            where taxGroupData.TaxGroup == _ledgerJournalTrans.TaxGroup
        exists join taxOnItem
            where taxOnItem.TaxCode == taxGroupData.TaxCode
                && taxOnItem.TaxItemGroup == _ledgerJournalTrans.TaxItemGroup;

        return !taxGroupData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWhenPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the journal line during posting.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_originalLedgerJournalTrans">
    /// The original <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_checkNoSettlement">
    /// Not used; optional.
    /// </param>
    /// <param name = "_ledgerPostingMessageCollection">
    /// The <c>LedgerPostingMessageLog</c> instance; optional.
    /// </param>
    /// <returns>
    /// true if the the journal line is in a valid state for posting; otherwise, false.
    /// </returns>
    public boolean checkWhenPost(LedgerJournalTrans         _ledgerJournalTrans,
                                 LedgerJournalTrans         _originalLedgerJournalTrans,
                                 boolean                    _checkNoSettlement = true,
                                 LedgerPostingMessageLog    _ledgerPostingMessageCollection = null)
    {
        boolean                     ok;
        LedgerJournalTrans_Asset    ledgerJournalTrans_Asset = _ledgerJournalTrans.findLedgerJournalTransAssetSibling();
        MainAccount                 mainAccount;
        DataAreaId                  companyId;
        MainAccountLegalEntity      mainAccountLegalEntity;

        if (!ledgerJournalTrans_Asset && isOffset)
        {
            ledgerJournalTrans_Asset = _ledgerJournalTrans.orig().findLedgerJournalTransAssetSibling();
        }

        ok = _ledgerJournalTrans.checkCurrency(_ledgerPostingMessageCollection);
        ok = _ledgerJournalTrans.checkZeroAmount(ledgerJournalTrans_Asset.TransType, _ledgerPostingMessageCollection
            // <GJP>
            ,ledgerJournalTrans_Asset.isAssembling_JP()
            // </GJP>
            ) && ok;

        if (_ledgerJournalTrans.TransactionType == LedgerTransType::Elimination)
        {
            ok = this.checkElimination(_ledgerJournalTrans, _ledgerPostingMessageCollection) && ok;
        }
        else
        {
            ok = this.checkConsolidation(_ledgerJournalTrans, _ledgerPostingMessageCollection) && ok;
        }

        ok = this.checkTaxAmount(_originalLedgerJournalTrans, _ledgerPostingMessageCollection) && ok;

        // For Iceland verify if Payment reference option is required.
        if (ok && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIS]))
        {
            ok = _ledgerJournalTrans.checkPaymentReferenceIS();
        }

        // If Tax Code Valication is enabled and the ledger account requires a Tax Code,
        // and the voucher does not have the tax information, an error will be raised.
        if (ok && _ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger)
        {
            // When sales tax is posted at the invoice register, the invoice approval journal should skip tax validation.
            boolean validateApprovalJournal = _ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::Approval && VendParameters::find().VendTaxRegisterApproval == VendTaxRegisterApproval::Register;
            
            if (TaxParameters::find().ValidateTaxCode && !validateApprovalJournal)
            {
                // Verify that the company exists.
                if (xDataArea::exist(_ledgerJournalTrans.Company))
                {
                    companyId = _ledgerJournalTrans.Company;
                }
                else
                {
                    companyId = curext();
                }

                changecompany(companyId)
                {
                    mainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(_ledgerJournalTrans.parmLedgerDimension());
                    mainAccountLegalEntity = MainAccountLegalEntity::findByMainAccountLegalEntity(mainAccount.RecId, CompanyInfo::findDataArea(companyId).RecId);
                }

                if (mainAccountLegalEntity.ValidateTaxCode)
                {
                    ok = Tax::checkNoTax(mainAccount,
                                                 _ledgerJournalTrans.TaxGroup,
                                                 _ledgerJournalTrans.TaxItemGroup,
                                                 _ledgerJournalTrans.TaxCode);
                }
            }
        }

        if (ok
            && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoMX])
            && _ledgerJournalTrans.TaxGroup != ''
            && _ledgerJournalTrans.TaxItemGroup != '')
        {
            changecompany(_ledgerJournalTrans.company())
            {
                ok = DIOTAddlInfoForNoVendorLedger_MX::validateDeleteAdditionalInfo(_ledgerJournalTrans.RecId) && ok;
            }
        }

        if (ok && LedgerParameters::find().IsZakatEnabled_SA)
        {
            ok = LedgerJournalTransZakat_SA::validateSubContratorGroup(_ledgerJournalTrans.RecId);
        }

        ok = _ledgerJournalTrans.checkTaxCode(_ledgerPostingMessageCollection) && ok;

        ok = _originalLedgerJournalTrans.checkBridgingBankAccount() && ok;

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    private void init(boolean _isOffset)
    {
        isOffset = _isOffset;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPaymentStatusOfNone</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the payment status of the passed in <c>LedgerJournalTable</c> record and the <c>CustVendPaymModeTable</c> payment status are equivalent to None.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The <c>LedgerJournalTrans</c> record.</param>
    /// <param name = "_paymStatus">The payment status of the <c>CustVendPaymModeTable</c> record.</param>
    /// <returns>true if the payment status is equivalent to null for both parameters; otherwise, false.</returns>
    protected boolean isPaymentStatusOfNone(LedgerJournalTrans _ledgerJournalTrans, CustVendPaymStatus _paymStatus)
    {
        return (_ledgerJournalTrans.PaymentStatus == CustVendPaymStatus::None && _paymStatus == CustVendPaymStatus::None);
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>LedgerDimensionDefaultAccount</c> value for the specified <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <param name = "_journalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// A <c>LedgerDimensionDefaultAccount</c> value.
    /// </returns>
    public LedgerDimensionDefaultAccount ledgerDimension(LedgerJournalTrans _journalTrans)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerVoucherCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks and updates the ledger voucher.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_ledgerVoucher">
    /// The <c>LedgerVoucher</c> class instance.
    /// </param>
    /// <param name = "_checkNoSettlement">
    /// Not used; optional.
    /// </param>
    /// <param name = "_reversalsMayExist">
    /// true if reversals may exist for this <c>LedgerJournalTrans</c> record; otherwise, false. Optional.
    /// </param>
    /// <returns>
    /// true if the journal voucher is in a valid state; otherwise, false.
    /// </returns>
    public boolean ledgerVoucherCheck(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerVoucher _ledgerVoucher,
        boolean _checkNoSettlement = true
        , boolean _reversalsMayExist = false
        )
    {
        boolean                     ok                  = true;
        LedgerJournalTrans          journalTrans        = _ledgerJournalTrans.data();
        LedgerJournalType           ledgerJournalType   = _ledgerJournalTrans.ledgerJournalTable().JournalType;
        boolean                     isInterCompany      = true;
        TaxAmountCur                taxAmount;
        LedgerVoucherObject         postingReference;
        CurrencyExchangeHelper      exchangeRateHelper;
        LedgerJournalTable          ledgerJournalTable;
        LedgerVoucherTransObject    ledgerVoucherTransObject;
        LedgerPostingMessageLog     ledgerPostingMessageCollection;

        ledgerPostingMessageCollection = _ledgerVoucher.parmLedgerPostingMessageLog();

        if (ledgerPostingMessageCollection)
        {
            ledgerPostingMessageCollection.setTableIdRecId(
                _ledgerJournalTrans.TableId,
                _ledgerJournalTrans.RecId);
        }

        // if approval journal create ledger transactions for the amount of tax
        // on the ledger journal trans.  This is done so the ledger transactions will balance during validation
        if (!_ledgerJournalTrans.Cancel)
        {
            ledgerJournalTable = _ledgerJournalTrans.ledgerJournalTable();

            if (ledgerJournalTable.JournalType == LedgerJournalType::Approval
                && ledgerJournalTable.LedgerJournalInclTax == NoYes::No)
            {
                taxAmount = _ledgerJournalTrans.totalTaxAmountSingleLine(true, false, true);
                TaxAmount transactionalTaxAmount = taxVoucherService.getTransactionalTaxAmountForLine(_ledgerJournalTrans);

                changecompany (_ledgerJournalTrans.Company ? _ledgerJournalTrans.Company : curext())
                {
                    // if there is a tax amount create ledger voucher for this amount
                    if (taxAmount)
                    {
                        if (!_ledgerVoucher.findLedgerVoucherObject(_ledgerJournalTrans.Voucher, _ledgerJournalTrans.TransDate))
                        {
                            _ledgerVoucher.addVoucher(LedgerVoucherObject::newVoucher(_ledgerJournalTrans.Voucher,
                                                                                      _ledgerJournalTrans.TransDate));
                        }

                        exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), _ledgerJournalTrans.TransDate);
                        exchangeRateHelper.parmExchangeRate1(_ledgerJournalTrans.ExchRate);
                        exchangeRateHelper.parmExchangeRate2(_ledgerJournalTrans.ExchRateSecond);
                        exchangeRateHelper.parmReportingExchangeRate1(_ledgerJournalTrans.ReportingCurrencyExchRate);
                        exchangeRateHelper.parmReportingExchangeRate2(_ledgerJournalTrans.ReportingCurrencyExchRateSecondary);

                        // create ledger voucher record for correct tax amount for the journal trans,
                        // do not need to calculate the individual tax amount since this is only used
                        // to make sure the ledger journals will balance.
                        _ledgerVoucher.addTrans(
                            LedgerVoucherTransObject::newTransactionAmountDefault(
                                _ledgerVoucher.findLedgerVoucherObject(_ledgerJournalTrans.Voucher, _ledgerJournalTrans.TransDate),
                                LedgerPostingType::Tax,
                                taxVoucherService.operationAccount(_ledgerJournalTrans),
                                _ledgerJournalTrans.CurrencyCode,
                                transactionalTaxAmount,
                                exchangeRateHelper));
                    }
                }
            }
        }

        isInterCompany = _ledgerJournalTrans.Company != curext();

        changecompany (_ledgerJournalTrans.Company ? _ledgerJournalTrans.Company : curext())
        {
            if (isInterCompany)
            {
                ok = this.check(_ledgerJournalTrans, _checkNoSettlement, null, ledgerPostingMessageCollection);
            }
            else
            {
                ok = this.check(_ledgerJournalTrans, _checkNoSettlement, _ledgerVoucher, ledgerPostingMessageCollection);
            }

            _ledgerVoucher.parmSkipBlockedForManualEntryCheck(journalTrans.canSkipBlockedForManualEntryCheck());

            // Note: offsets are handled with OffsetLedgerDimension passed in the LedgerDimension field so no special checking is needed here
            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger)
            {
                journalTrans.parmLedgerDimension(_ledgerJournalTrans.LedgerDimension);
            }
            else
            {
                journalTrans.parmLedgerDimension(LedgerDimensionFacade::serviceCreateLedgerDimension(this.ledgerDimension(_ledgerJournalTrans), _ledgerJournalTrans.DefaultDimension));
            }
        }

        _ledgerVoucher.parmJournalNumber(journalTrans.JournalNum);

        postingReference = _ledgerVoucher.findLedgerVoucherObject(journalTrans.Voucher, journalTrans.TransDate);
        if (postingReference == null)
        {
            postingReference = LedgerVoucherObject::newReference(
                journalTrans.Voucher,
                journalTrans.TransDate,
                _ledgerVoucher.parmSysModuleDefault());

            postingReference.parmAcknowledgementDate(journalTrans.AcknowledgementDate);

            _ledgerVoucher.addVoucher(postingReference);
        }

        postingReference.parmSourceRecIdDefault(journalTrans.RecId);
        postingReference.parmSourceTableIdDefault(tableNum(LedgerJournalTrans));

        CurrencyCode currentCompanyAccountingCurrency = Ledger::accountingCurrency();

        changecompany (_ledgerJournalTrans.Company ? _ledgerJournalTrans.Company : curext())
        {
            CurrencyCode accountCompanyAccountingCurrency = Ledger::accountingCurrency();

            // Allocations is a special case as the process uses transaction amounts to calculate exchange
            // rate values to balance properly, vs. using the exchange rate to calculate accounting/reporting
            // amounts.
            boolean forceExchangeRate = ((ledgerJournalType == LedgerJournalType::Allocation) || (currentCompanyAccountingCurrency == accountCompanyAccountingCurrency));

            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransLedgerJournal(
                journalTrans, 0, false, conNull(), _reversalsMayExist, forceExchangeRate);

            // the LVO normally controls the company context internally, but this LVO may contain transactions
            // from multiple legal entities so we use that in this check (not posting) scenario
            ok = _ledgerVoucher.addTrans(ledgerVoucherTransObject) && ok;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeLedgerDimensionAndDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Merges the ledger dimension default account and the default dimensions to create a ledger dimension.
    /// </summary>
    /// <param name="_ledgerDimension">
    /// The ledger dimension default account.
    /// </param>
    /// <param name="_defaultDimension">
    /// The default dimensions.
    /// </param>
    /// <returns>
    /// A ledger dimension.
    /// </returns>
    protected LedgerDimensionAccount mergeLedgerDimensionAndDefaultDimension(
        LedgerDimensionDefaultAccount _ledgerDimension,
        DimensionDefault _defaultDimension)
    {
        LedgerDimensionAccount mergedLedgerDimension;
        List dimensionSources;

        dimensionSources = new List(Types::Class);

        dimensionSources.addEnd(LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(_defaultDimension));
        mergedLedgerDimension = LedgerDimensionDefaultingEngine::createLedgerDimension(_ledgerDimension, dimensionSources);

        return mergedLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccrual</Name>
				<Source><![CDATA[
    public boolean parmAccrual(boolean _accrual)
    {
        accrual = _accrual;
        return accrual;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmApproval_IN</Name>
				<Source><![CDATA[
    public boolean parmApproval_IN(boolean _approval = approval)
    {
        approval = _approval;
        return approval;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInclTax_IN</Name>
				<Source><![CDATA[
    public boolean parmInclTax_IN(boolean _inclTax = inclTax)
    {
        inclTax = _inclTax;
        return inclTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIntercompanyRecIds</Name>
				<Source><![CDATA[
    container parmIntercompanyRecIds(container _intercompanyRecIds = intercompanyRecIds)
    {
        intercompanyRecIds = _intercompanyRecIds;
        return intercompanyRecIds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalTransIntercompanyMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the mapping between journal line and its related journal line in foreign company.
    /// </summary>
    /// <param name="_ledgerJournalTransIntercompanyMap">
    /// The mapping between journal line and its related journal line in foreign company.
    /// </param>
    /// <returns>
    /// The mapping between journal line and its related journal line in foreign company.
    /// </returns>
    /// <remarks>
    /// This map stores the mapping between journal line and its related journal line in foreign company.
    /// </remarks>
    public Map parmLedgerJournalTransIntercompanyMap(Map _ledgerJournalTransIntercompanyMap = ledgerJournalTransIntercompanyMap)
    {
        ledgerJournalTransIntercompanyMap = _ledgerJournalTransIntercompanyMap;

        return ledgerJournalTransIntercompanyMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsVoucherValid</Name>
				<Source><![CDATA[
    public NoYes parmIsVoucherValid(NoYes _isVoucherValid = isVoucherValid)
    {
        isVoucherValid = _isVoucherValid;
        
        return isVoucherValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTmpVoucherMap</Name>
				<Source><![CDATA[
    Map parmTmpVoucherMap(Map _tmpVoucherMap = _tmpVoucherMap)
    {
        tmpVoucherMap = _tmpVoucherMap;
        return tmpVoucherMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postNonReoverableTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts non recoverable tax.
    /// </summary>
    /// <param name="_ledgerVoucher">
    /// The <c>LedgerVoucher</c> instance.
    /// </param>
    /// <param name="_ledgerPostingController">
    /// The <c>LedgerPostingController</c> instance.
    /// </param>
    /// <param name="_originalLedgerJournalTrans">
    /// The original <c>LedgerJournalTrans</c> to post.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> to post.
    /// </param>
    /// <param name="_ledgerDimensionId">
    /// The ledger account dimension that non recoverable tax to be post.
    /// </param>
    /// <param name="_interCompany">
    /// True if this is an intercompany journal; otherwise, false.
    /// </param>
    /// <param name="_isDueToDueFromAccountLocal">
    /// True if this is a due to or due from account; otherwise, false.
    /// </param>
    public void postNonReoverableTax(
        LedgerVoucher           _ledgerVoucher,
        LedgerPostingController _ledgerPostingController,
        LedgerJournalTrans      _originalLedgerJournalTrans,
        LedgerJournalTrans      _ledgerJournalTrans,
        LedgerDimensionAccount  _ledgerDimensionId,
        boolean                 _interCompany               = false,
        boolean                 _isDueToDueFromAccountLocal = false
        )
    {
        List                        nonRecoverableTaxAmountCurList;
        ListEnumerator              nonRecoverableTaxAmountCurListEnumerator;
        TaxAmountCur                nonRecoverableTaxAmountCur;
        LedgerPostingType           nonRecoverableTaxLedgerPostingType;
        CurrencyExchangeHelper      exchangeRateHelper;
        LedgerVoucherTransObject    ledgerVoucherTransObject;
        ProjLedger                  projLedger;

        //<GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled()
            && _originalLedgerJournalTrans.Transferred == NoYes::No)
        {
            nonRecoverableTaxAmountCurList = this.getNonRecoverableTaxAmountCurListFromGTE(_originalLedgerJournalTrans);
        }
        else
        {
            //</GTE>
            nonRecoverableTaxAmountCurList = taxVoucherService.getNonRecoverableTaxAmountCurList(_originalLedgerJournalTrans, _interCompany, _isDueToDueFromAccountLocal);
            //<GTE>
        }
        //</GTE>
        // if apply sales tax taxation rules, all tax amount is not recoverable. The tax amount is posted in previous steps, so it should not call post again here.
        if (!TaxParameters::find().PurchTaxOnOperations)
        {
            if (nonRecoverableTaxAmountCurList)
            {
                exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), _ledgerPostingController.getReference().parmAccountingDate());
                exchangeRateHelper.parmExchangeRate1(_ledgerJournalTrans.ExchRate);
                exchangeRateHelper.parmExchangeRate2(_ledgerJournalTrans.ExchRateSecond);
                exchangeRateHelper.parmReportingExchangeRate1(_ledgerJournalTrans.ReportingCurrencyExchRate);
                exchangeRateHelper.parmReportingExchangeRate2(_ledgerJournalTrans.ReportingCurrencyExchRateSecondary);

                nonRecoverableTaxAmountCurListEnumerator = nonRecoverableTaxAmountCurList.getEnumerator();
                while (nonRecoverableTaxAmountCurListEnumerator.moveNext())
                {
                    [nonRecoverableTaxLedgerPostingType, nonRecoverableTaxAmountCur] = nonRecoverableTaxAmountCurListEnumerator.current();

                    if (nonRecoverableTaxAmountCur)
                    {
                        ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                            _ledgerPostingController.getReference(),
                            nonRecoverableTaxLedgerPostingType,
                            _ledgerDimensionId,
                            _ledgerJournalTrans.CurrencyCode,
                            nonRecoverableTaxAmountCur,
                            exchangeRateHelper);

                        ledgerVoucherTransObject.parmTaxParentReferenceRecId(_ledgerJournalTrans.RecId);
                        ledgerVoucherTransObject.parmTaxParentReferenceTableId(_ledgerJournalTrans.TableId);
                        ledgerVoucherTransObject.parmText(_ledgerJournalTrans.Txt);
                        ledgerVoucherTransObject.setTaxTransRelationshipType(TaxTransRelationshipType::TaxInCostPrice);

                        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Project)
                        {
                            projLedger  = ProjLedger::newLedgerJournalTax(_ledgerJournalTrans);
                            ledgerVoucherTransObject.parmProjLedger(projLedger);
                        }

                        ledgerVoucherTransObject.parmReasonRefRecID(_ledgerJournalTrans.ReasonRefRecID);
                        _ledgerVoucher.addTrans(ledgerVoucherTransObject);
                    }

                    if (TaxEnginePostingProcessor::isAsyncTaxDocumentPostingMode())
                    {
                        GeneralJournalAccountEntryTransactionLink transactionLink;

                        ttsbegin;
                        transactionLink.LedgerDimension = _ledgerDimensionId;
                        transactionLink.SourceRecId = _ledgerJournalTrans.RecId;
                        transactionLink.SourceTableId = tableNum(LedgerJournalTrans);
                        transactionLink.AccountingCurrentAmount = exchangeRateHelper.calculateTransactionToAccounting(_ledgerJournalTrans.CurrencyCode, nonRecoverableTaxAmountCur, true);
                        transactionLink.TransactionCurrency = _ledgerJournalTrans.CurrencyCode;
                        transactionLink.TransactionCurrencyAmount = nonRecoverableTaxAmountCur;
                        transactionLink.IsTaxInCostPrice = NoYes::Yes;
                        transactionLink.insert();
                        ttscommit;
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>rboParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the Retail vales.
    /// </summary>
    /// <param name = "_rboParameters">
    /// A container that has the Retail values.
    /// </param>
    void rboParameters(container _rboParameters)
    {
        [rboCustTrans, rboTransactionId, rboStoreId, rboTerminalId] = _rboParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// The base implementation does nothing.
    /// </summary>
    /// <param name = "_ledgerVoucher">
    /// The <c>LedgerVoucher</c> class instance.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    void reverseTax(LedgerVoucher      _ledgerVoucher,
                    LedgerJournalTrans _ledgerJournalTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxVoucherService</Name>
				<Source><![CDATA[
    void setTaxVoucherService(TaxVoucherService _taxVoucherService)
    {
        taxVoucherService = _taxVoucherService;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInterCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the intercompany journal line.
    /// </summary>
    /// <param name = "_ledgerVoucher">
    /// The <c>LedgerVoucher</c> class instance.
    /// </param>
    /// <param name = "_ledgerPostingType">
    /// The posting type enumeration value.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_originalLedgerJournalTrans">
    /// The original <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_ledgerJournalTransUpdate">
    /// The <c>LedgerJournalTransUpdate</c> class instance.
    /// </param>
    /// <param name = "_company">
    /// The company ID.
    /// </param>
    /// <param name = "_ledgerJournalTransHasOffsetAccount">
    /// A boolean value indicating that the journal has offset accounts.
    /// </param>
    /// <param name = "_isAllocation">
    /// A boolean value indicating if the journal type is Allocation.
    /// </param>
    public void updateInterCompany(LedgerVoucher               _ledgerVoucher,
                              LedgerPostingType         _ledgerPostingType,
                              LedgerJournalTrans        _ledgerJournalTrans,
                              LedgerJournalTrans        _originalLedgerJournalTrans,
                              LedgerJournalTransUpdate  _ledgerJournalTransUpdate,
                              CompanyId                 _company,
                              boolean                   _ledgerJournalTransHasOffsetAccount,
                              boolean                   _isAllocation)
    {
        LedgerJournalTrans interCompanyTrans;
            
        interCompanyTrans = this.populateInterCompanyTrans(this.populateInterCompanyTransParameters(_ledgerVoucher, _ledgerJournalTrans, _originalLedgerJournalTrans, _company, _ledgerJournalTransHasOffsetAccount, _isAllocation));

        intercompanyRecIds += interCompanyTrans.RecId;

        _ledgerJournalTransUpdate.updateNow(_ledgerVoucher, LedgerPostingType::InterCompany, interCompanyTrans, _originalLedgerJournalTrans, false, true, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateInterCompanyTransParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the <c>LedgerJournalTransUpdatePopulateInterCompanyTransArgs</c> instance which is used to populate the <c>LedgerJournalTrans</c> table buffer.
    /// </summary>
    /// <param name = "_ledgerVoucher">
    /// The <c>LedgerVoucher</c> class instance.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_originalLedgerJournalTrans">
    /// The original <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_company">
    /// The company ID.
    /// </param>
    /// <param name = "_ledgerJournalTransHasOffsetAccount">
    /// A boolean value indicating that the journal has offset accounts.
    /// </param>
    /// <param name = "_isAllocation">
    /// A boolean value indicating if the journal type is Allocation.
    /// </param>
    /// <returns>
    /// An <c>LedgerJournalTransUpdatePopulateInterCompanyTransArgs</c> instance.
    /// </returns>
    private LedgerJournalTransUpdatePopulateInterCompanyTransArgs populateInterCompanyTransParameters(
                                                                            LedgerVoucher _ledgerVoucher,
                                                                            LedgerJournalTrans _ledgerJournalTrans,
                                                                            LedgerJournalTrans _originalLedgerJournalTrans,
                                                                            CompanyId          _company,
                                                                            boolean            _ledgerJournalTransHasOffsetAccount,
                                                                            boolean            _isAllocation)
    {
        LedgerJournalTransUpdatePopulateInterCompanyTransArgs _parameters = LedgerJournalTransUpdatePopulateInterCompanyTransArgs::construct();
        
        _parameters.parmLedgerVoucher(_ledgerVoucher);
        _parameters.parmLedgerJournalTrans(_ledgerJournalTrans);
        _parameters.parmOriginatingLedgerJournalTrans(_originalLedgerJournalTrans);
        _parameters.parmOriginatingCompany(_company);
        _parameters.parmLedgerJournalTransHasOffsetAccount(_ledgerJournalTransHasOffsetAccount);
        _parameters.parmIsAllocation(_isAllocation);

        return _parameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInterCompanyDefaultDimension</Name>
				<Source><![CDATA[
    private DimensionDynamicAccount getInterCompanyDefaultDimension(LedgerJournalTransUpdatePopulateInterCompanyTransArgs _parameters, LedgerDimensionDefaultAccount _defaultAccount)
    {
        LedgerDimensionDefaultAccount defaultAccount = _defaultAccount;
        LedgerInterCompany ledgerInterCompany =
            LedgerInterCompany::findCompanyPair(_parameters.parmOriginatingLedgerJournalTrans().Company, _parameters.parmOriginatingLedgerJournalTrans().OffsetCompany);

        if (ledgerInterCompany)
        {
            DimensionDefault journalHeaderDefaultDimension = LedgerJournalName::find(ledgerInterCompany.JournalName).DefaultDimension;
            if (journalHeaderDefaultDimension)
            {
                return LedgerDimensionFacade::serviceCreateLedgerDimension(defaultAccount, journalHeaderDefaultDimension);
            }
        }

        return defaultAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateInterCompanyTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the <c>LedgerJournalTrans</c> table buffer.
    /// </summary>
    /// <param name = "_parameters">
    /// An <c>LedgerJournalTransUpdatePopulateInterCompanyTransArgs</c> instance with parameters to populate the <c>LedgerJournalTrans</c> table buffer.
    /// </param>
    /// <returns>
    /// The populated <c>LedgerJournalTrans</c> table buffer.
    /// </returns>
    [Wrappable(true)]
    protected final LedgerJournalTrans populateInterCompanyTrans(LedgerJournalTransUpdatePopulateInterCompanyTransArgs _parameters)
    {
        LedgerDimensionDefaultAccount defaultAccount;
        LedgerJournalTrans interCompanyTrans;

        interCompanyTrans = _parameters.parmLedgerJournalTrans().data();
        interCompanyTrans.Company = curext();
        interCompanyTrans.AccountType = LedgerJournalACType::Ledger;
       
        if (interCompanyTrans.Txt == '')
        {
            interCompanyTrans.Txt = _parameters.parmOriginatingLedgerJournalTrans().Txt;
        }

        if (FinTagConfiguration::isFinTagConfigurationSet(interCompanyTrans.Company))
        {
            if (interCompanyTrans.Company == _parameters.parmOriginatingLedgerJournalTrans().Company)
            {
                interCompanyTrans.FinTag = _parameters.parmOriginatingLedgerJournalTrans().FinTag;
            }
            else if (interCompanyTrans.Company == _parameters.parmOriginatingLedgerJournalTrans().OffSetCompany)
            {
                interCompanyTrans.FinTag = _parameters.parmOriginatingLedgerJournalTrans().OffSetFinTag;
            }
        }

        AmountMSTDebCred transactionAmount = _parameters.parmLedgerJournalTrans().AmountCurDebit ?
                abs(_parameters.parmLedgerJournalTrans().AmountCurDebit) :
                - abs(_parameters.parmLedgerJournalTrans().AmountCurCredit);

        defaultAccount = LedgerInterCompany::getOriginatingCompanyLedgerDimensionWithAmount(
            transactionAmount,
            curExt(),
            _parameters.parmOriginatingCompany());

        if (_parameters.parmLedgerJournalTransHasOffsetAccount() && (_parameters.parmLedgerJournalTrans().OffsetCompany == interCompanyTrans.Company))
        {
            // Because the Journal posting copies the offset values into the primary fields to simplify the posting code.  And because
            // the OffsetLedgerDimension is not set to the primary LedgerDimenion when the switch occurs, we need to get the dimension values
            // from the Original buffer but we need to determine which side we should be pulling from.

            // Use the Primary Account side of the Original LedgerJournalTrans.
            if (_parameters.parmOriginatingLedgerJournalTrans().Company == interCompanyTrans.Company)
            {
                // The AccountType is ledger so use the LedgertDimension field to pull in the dimensions for the InterCompany ledger account.
                if (_parameters.parmOriginatingLedgerJournalTrans().AccountType == LedgerJournalACType::Ledger)
                {
                    interCompanyTrans.LedgerDimension = LedgerDimensionFacade::serviceMergeLedgerDimensions(this.getInterCompanyDefaultDimension(_parameters, defaultAccount), _parameters.parmOriginatingLedgerJournalTrans().LedgerDimension);
                }
                // The AccountType is not ledger so use the DefaultDimension field to pull in the dimensions for the InterCompany ledger account.
                else
                {
                    interCompanyTrans.LedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultAccount, _parameters.parmOriginatingLedgerJournalTrans().DefaultDimension);
                }
            }
            // Use the Offset Account side of the Original LedgerJournalTrans.
            else
            {
                // The OffsetAccountType is ledger so use the OffsetLedgertDimension field to pull in the dimensions for the InterCompany ledger account.
                if (_parameters.parmOriginatingLedgerJournalTrans().OffsetAccountType == LedgerJournalACType::Ledger)
                {
                    interCompanyTrans.LedgerDimension = LedgerDimensionFacade::serviceMergeLedgerDimensions(defaultAccount, _parameters.parmOriginatingLedgerJournalTrans().OffsetLedgerDimension);
                }
                // The OffsetAccountType is not ledger so use the OffsetDefaultDimension field to pull in the dimensions for the InterCompany ledger account.
                else
                {
                    interCompanyTrans.LedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultAccount, _parameters.parmOriginatingLedgerJournalTrans().OffsetDefaultDimension);
                }
            }
        }
        else if (_parameters.parmIsAllocation())
        {
            LedgerDimensionAccount ledgerDimension = LedgerJournalTrans_Allocation::getIntercompanyLedgerDimension(_parameters.parmLedgerJournalTrans(), defaultAccount, _parameters.parmLedgerVoucher());

            interCompanyTrans.parmLedgerDimension(ledgerDimension);
        }
        else
        {
            // We do not apply dimensions from the source company as the dimension value constraints can be different
            // between companies, fixed dimensions are applied here to meet structure requirements.
            LedgerDimensionAccount ledgerDimensionOrig = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultAccount);
            LedgerDimensionAccount ledgerDimension = LedgerDimensionFacade::serviceApplyFixedDimensions(ledgerDimensionOrig);

            // Applying fixed dimensions can result in a change in the structures applied to the combination.
            // Since DimensionStorage is agnostic to the setup of structures, if the resulting combination has changed
            // after applying the fixed dimensions; the combination must be fully regenerated to properly apply
            // the structures.
            if (ledgerDimensionOrig != ledgerDimension)
            {
                ledgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimension);
            }

            interCompanyTrans.parmLedgerDimension(ledgerDimension);
        }

        interCompanyTrans.DefaultDimension = 0;

        interCompanyTrans.TaxGroup      = '';
        interCompanyTrans.TaxCode       = '';

        return interCompanyTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the journal line.
    /// </summary>
    /// <param name = "_ledgerVoucher">
    /// The <c>LedgerVoucher</c> class instance.
    /// </param>
    /// <param name = "_posting">
    /// The posting type enumeration value.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_originalLedgerJournalTrans">
    /// The original <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_interCompany">
    /// A boolean value indicating that the posting process is updating transactions in a different
    /// company than the original logged in company; optional.
    /// </param>
    /// <param name = "_reversalsMayExist">
    /// A boolean value indicating that reverals may exist; optional.
    /// </param>
    /// <param name = "_isDueToDueFromAccount">
    /// A boolean value indicating a due to due from account; optional.
    /// </param>
    void updateNow(LedgerVoucher        _ledgerVoucher,
                   LedgerPostingType    _posting,
                   LedgerJournalTrans   _ledgerJournalTrans,
                   LedgerJournalTrans   _originalLedgerJournalTrans,
                   boolean              _interCompany = false,
                   boolean              _reversalsMayExist = true,
                   boolean              _isDueToDueFromAccount =  false)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    static LedgerJournalTransUpdate construct(LedgerJournalTrans _ledgerJournalTrans, boolean _isOffset = false)
    {
        LedgerJournalTransUpdate ledgerJournalTransUpdate = LedgerJournalTransUpdate::constructForJournalTrans(_ledgerJournalTrans);

        if (ledgerJournalTransUpdate == null)
        {
            throw error ("@SYS20764");
        }

        ledgerJournalTransUpdate.init(_isOffset);

        return ledgerJournalTransUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructForJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of a subclass of the <c>LedgerJournalTransUpdate</c> class based on account type.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The <c>LedgerJournalTrans</c> record.</param>
    /// <returns>The new instance of an <c>LedgerJournalTransUpdate</c> subclass.</returns>
    public static LedgerJournalTransUpdate constructForJournalTrans(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTransUpdate ledgerJournalTransUpdate;

        switch (_ledgerJournalTrans.AccountType)
        {
            case LedgerJournalACType::Cust:
                ledgerJournalTransUpdate = new LedgerJournalTransUpdateCust();
                break;

            case LedgerJournalACType::Vend:
                if (_ledgerJournalTrans.Cancel == NoYes::Yes)
                {
                    ledgerJournalTransUpdate = new LedgerJournalTransUpdateVendCancel();
                }
                else
                {
                    if (BankLCImportFeatureChecker::checkBankLCImportEnabled()
                        && _ledgerJournalTrans.getLedgerJournalTransBankLC().TransType == BankLCLedgerJournalTransType::Settlement)
                    {
                        ledgerJournalTransUpdate = new LedgerJournalTransUpdateBankLC();
                    }
                    else
                    {
                        ledgerJournalTransUpdate = new LedgerJournalTransUpdateVend();
                    }
                }
                break;

            case LedgerJournalACType::Ledger:
                ledgerJournalTransUpdate = new LedgerJournalTransUpdateLedger();
                break;

            case LedgerJournalACType::Bank:
                ledgerJournalTransUpdate = new LedgerJournalTransUpdateBank();
                break;

            case LedgerJournalACType::Project:
                ledgerJournalTransUpdate = new LedgerJournalTransUpdateProject();
                break;

            case LedgerJournalACType::FixedAssets:
                ledgerJournalTransUpdate = new LedgerJournalTransUpdateAsset();
                break;

            // <GEERU>
            case LedgerJournalACType::FixedAssets_RU:
                ledgerJournalTransUpdate = new LedgerJournalTransUpdateAsset_ru();
                break;

            case LedgerJournalACType::RDeferrals:
                ledgerJournalTransUpdate = new LedgerJournalTransUpdateRDeferrals();
                break;
            // </GEERU>

            // <GEEU>
            case LedgerJournalACType::Employee_RU:
                ledgerJournalTransUpdate = new LedgerJournalTransUpdateEmpl_RU();
                break;
            // </GEEU>

            case LedgerJournalACType::RCash:
                if (BankParameters::getEnablePettyCash())
                {
                    ledgerJournalTransUpdate = new LedgerJournalTransUpdateRCash();
                }
                break;

            default:
                break;
        }

        return ledgerJournalTransUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNonRecoverableTaxAmountCurListFromGTE</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the ledgerposting type and non-recoverable tax amount list for ledger line.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> to post.
    /// </param>
    /// <returns>
    /// The tax amount list for the ledger account.
    /// </returns>
    //<GTE>
    protected List getNonRecoverableTaxAmountCurListFromGTE(LedgerJournalTrans _ledgerJournalTrans)
    {
        ITaxableDocument                    taxableDocument;
        ITaxDocument                        taxDocumentObject;
        ITaxDocumentLine                    taxDocumentLineObject;
        ITaxDocumentComponentLineEnumerator componentLineEnumerator;
        ITaxDocumentComponentLine           taxDocumentComponentLineObject;
        ITaxDocumentMeasureValue            measureValueObject;
        List                                nonRecoverableTaxAmountCurList;

        nonRecoverableTaxAmountCurList = new List(Types::Container);

        taxableDocument = TaxableDocumentObject::construct(
        TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(_ledgerJournalTrans));

        taxDocumentObject = TaxBusinessService::calculateTax(taxableDocument);
        if (taxDocumentObject)
        {
            taxDocumentLineObject = taxDocumentObject.findLineBySource(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId);
            if (taxDocumentLineObject)
            {
                componentLineEnumerator = taxDocumentLineObject.componentLines();
                while (componentLineEnumerator.moveNext())
                {
                    taxDocumentComponentLineObject = componentLineEnumerator.current();
                    measureValueObject = taxDocumentComponentLineObject.sumByTaxAccountingProvider(TaxAccountingProvider::Inventory, TaxAccountingPostingProfileDistributionSide::Debit);
                    if (measureValueObject.amountTransactionCurrency() != 0)
                    {
                        nonRecoverableTaxAmountCurList.addEnd([LedgerPostingType::GST_IN, measureValueObject.amountTransactionCurrency()]);
                    }
                    measureValueObject = taxDocumentComponentLineObject.sumByTaxAccountingProvider(TaxAccountingProvider::Inventory, TaxAccountingPostingProfileDistributionSide::Credit);
                    if (measureValueObject.amountTransactionCurrency() != 0)
                    {
                        nonRecoverableTaxAmountCurList.addEnd([LedgerPostingType::GST_IN, -measureValueObject.amountTransactionCurrency()]);
                    }
                }
            }
        }

        return nonRecoverableTaxAmountCurList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxDocumentLedgerVoucherMap</Name>
				<Source><![CDATA[
    //</GTE>

    /// <summary>
    /// Gets the tax document ledger voucher map.
    /// </summary>
    /// <returns>Tax document ledger voucher map.</returns>
    public Map getTaxDocumentLedgerVoucherMap()
    {
        return taxDocumentLedgerVoucherMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxGroupCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the company for sales tax group.
    /// </summary>
    /// <param name = "_taxGroupCompany">DataAreaId for sales tax group.</param>
    /// <returns>Sales tax group company.</returns>
    [Hookable(false)]
    public DataAreaId parmTaxGroupCompany(DataAreaId _taxGroupCompany = taxGroupCompany)
    {
        taxGroupCompany = _taxGroupCompany;

        return taxGroupCompany;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxCombinationInTaxGroupCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if tax combination exists.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">Buffered value on table <c>LedgerJournalTrans</c>.</param>
    /// <param name = "_ledgerPostingMessageCollection">Logs for ledger posting message.</param>
    /// <returns>true if the sales tax combination exists; otherwise, false.</returns>
    protected boolean checkTaxCombinationInTaxGroupCompany(LedgerJournalTrans _ledgerJournalTrans, LedgerPostingMessageLog _ledgerPostingMessageCollection)
    {
        boolean ok = true;

        if (taxGroupCompany)
        {
            changecompany(taxGroupCompany)
            {
                ok = this.checkTaxCombination(_ledgerJournalTrans, _ledgerPostingMessageCollection);
            }
        }
        else
        {
            ok = this.checkTaxCombination(_ledgerJournalTrans, _ledgerPostingMessageCollection);
        }

        return ok;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>