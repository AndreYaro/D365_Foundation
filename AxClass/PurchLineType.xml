<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PurchLineType</Name>
	<SourceCode>
		<Declaration><![CDATA[
abstract class PurchLineType extends InventType
implements SalesPurchIModifiedDefaulter, InventDistinctProductOrderDefaulting, SalesPurchIModifiedDefaulterValidator
{
    PurchLine                   purchLine;
    PurchTable                  purchTable;
    PurchStatus                 statusUpdateResults;
    boolean                     isPurchTableInterCompanyOrder;
    boolean                     isInterCompanyOrderSet;

    InventDim                   preDefaultingInventDim;
    InventDimParm               preDefaultingInventDimParm;
    InventDimId                 mergedInventDimId;
    PurchQty                    acceptedPurchQty;
    PurchUnit                   acceptedPurchUnitId;
    TradeStockedProduct         prevStockedProduct;

    private PurchInstrumentationLogger instrumentationLogger;

    #AssetRules
    #ISOCountryRegionCodes

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>allowEditReturnActionId</Name>
				<Source><![CDATA[
    boolean allowEditReturnActionId()
    {
        return this.creditNoteLine();
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditScrap</Name>
				<Source><![CDATA[
    boolean allowEditScrap()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>associateWithAgreementLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Associates the purchase line with the agreement line.
    /// </summary>
    public void associateWithAgreementLine()
    {
        AgreementLineReleasedLine agreementLineReleasedLine;

        if (!purchLine.MatchingAgreementLine)
        {
            return;
        }

        ttsbegin;

        agreementLineReleasedLine = AgreementLineReleasedLine::findByPurchLine(purchLine, true);

        agreementLineReleasedLine.AgreementLine = purchLine.MatchingAgreementLine;

        if (!agreementLineReleasedLine.RecId)
        {
            agreementLineReleasedLine.initFromPurchLine(purchLine);
            agreementLineReleasedLine.insert();
        }
        else
        {
            if (agreementLineReleasedLine.IsDeleted)
            {
                // If we are reusing link that was once soft deleted
                // we need resurrect it first.
                agreementLineReleasedLine.IsDeleted = NoYes::No;
                agreementLineReleasedLine.IsModified = NoYes::Yes;
            }
            agreementLineReleasedLine.update();
        }

        // Clear existing PriceDiscChangePolicies...
        this.clearAllPriceDiscChangePolicies();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAgreementBeLinked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the purchase line can be linked to an agreement line.
    /// </summary>
    /// <returns>
    /// Always returns false.
    /// </returns>
    public boolean canAgreementBeLinked()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canFiscalDocTextBeRegistrated_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if Fiscal document texts can be registered to the Purchase header
    /// </summary>
    /// <returns>
    /// True if the Fiscal document text can be registered; false otherwise.
    /// </returns>
    public boolean canFiscalDocTextBeRegistrated_BR()
    {
        return  purchLine.RecId
                &&  (purchLine.PurchaseType == PurchaseType::Purch
                    || purchLine.PurchaseType == PurchaseType::ReturnItem);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canLineAmountBeUpdated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies whether the <c>LineAmount</c> field can be updated.
    /// </summary>
    /// <returns>
    /// true if the field can be updated; otherwise, false.
    /// </returns>
    boolean canLineAmountBeUpdated()
    {
        return purchLine.PriceDiscResultFields::canLineAmountBeUpdated();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canLineAmountBeUpdatedWithNonInteractiveSession</Name>
				<Source><![CDATA[
    boolean canLineAmountBeUpdatedWithNonInteractiveSession()
    {
        return purchLine.PriceDiscResultFields::canLineAmountBeUpdatedWithNonInteractiveSession();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAgreementDimension_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates agreement dimension in the purchase line.
    /// </summary>
    /// <returns>
    ///     true if the agreement dimension in the purchase line is blank or equals to the header agreement dimension; otherwise, false.
    /// </returns>
    protected boolean checkAgreementDimension_RU()
    {
        DimensionAttributeValueSetStorage dimAttrValueSetStorage;
        DimensionAttributeValue dimAttrValue;
        RecId dimAttrRecId = AgreementHeaderExt_RU::getAgreementDimensionAttribute();
        boolean ok = true;
        PurchTable_RU   purchTable_RU = purchTable.purchTable_RU();

        if (purchLine.DefaultDimension && dimAttrRecId)
        {
            dimAttrValueSetStorage = DimensionAttributeValueSetStorage::find(purchLine.DefaultDimension);
            dimAttrValue = DimensionAttributeValue::find(
                dimAttrValueSetStorage.getValueByDimensionAttribute(dimAttrRecId));

            if (dimAttrValue &&
                dimAttrValue.EntityInstance != purchTable_RU.AgreementHeaderExt_RU)
            {
                ok = checkFailed(strFmt("@GLS220871",
                    dimAttrValue.getValue(), PurchAgreementHeaderExt_RU::find(purchTable_RU.AgreementHeaderExt_RU).AgreementId));
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCFOP_BR</Name>
				<Source><![CDATA[
    private boolean checkCFOP_BR()
    {
        boolean                     ok = true;

        if (!purchLine.cfopTable_BR
            && purchTable.PurchaseType != PurchaseType::Journal
            && purchLine.inventTable().ItemType == ItemType::Item)
        {
            ok = checkFailed(strFmt("@SYS26332", fieldPName(CFOPTable_BR, cfopId)));
        }

        if (purchLine.cfopTable_BR)
        {
            ok = ok && CFOPValidation_BR::validate(purchLine);
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxServiceCode_BR</Name>
				<Source><![CDATA[
    private boolean checkTaxServiceCode_BR()
    {
        boolean ok = true;

        if (purchLine.TaxServiceCode_BR
            && purchLine.inventTable().ItemType != ItemType::Service)
        {
            ok = checkFailed("@GLS60421");
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDelete</Name>
				<Source><![CDATA[
    boolean checkDelete(boolean _useWarning = true)
    {
        return !purchLine.isInvoiceMatched();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInventDimUpdateValidNonStocked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the inventory dimensions changes are allowed for the lines.
    /// </summary>
    /// <param name = "_purchLineOrig">
    /// The original purchase order line which is updated.
    /// </param>
    /// <returns>
    /// true if inventory dimension changes are valid; otherwise, false.
    /// </returns>
    protected boolean checkInventDimUpdateValidNonStocked(PurchLine _purchLineOrig)
    {
        boolean                         ok = true;
        InventDim                       newInventDim;
        InventDim                       origInventDim;
        InventDimGroupSetup             inventDimGroupSetup;
        List                            dimFields;

        if (!purchLine.isStocked())
        {
            newInventDim     = purchLine.inventDim();
            origInventDim    = _purchLineOrig.inventDim();

            if (newInventDim.InventDimId != origInventDim.InventDimId
                && !purchLine.isDropShipment()
                && (purchLine.isPackingSlipOrInvoiceUpdated() || purchLine.registeredInPurchUnit()))
            {
                if (purchLine.isCategoryBased())
                {
                    //Only the dimension site is applicable for category based lines and cannot be modified.
                    dimFields = new List(Types::Integer);
                    dimFields.addEnd(fieldNum(InventDim, InventSiteId));
                    if (!InventDim::isInventDimEqual(origInventDim, newInventDim, dimFields))
                    {
                        ok = checkFailed(strFmt("@SYS301592", fieldId2pname(tableNum(InventDim), fieldNum(InventDim, InventSiteId))));
                    }
                }
                else
                {
                    //Product dimensions which are marked as consistent cannot be modified.
                    inventDimGroupSetup = InventDimGroupSetup::newItemId(purchLine.ItemId);
                    if (!InventDim::isInventDimEqualConsistent(inventDimGroupSetup, newInventDim, origInventDim))
                    {
                        ok = InventDim::checkUpdateConsistent(inventDimGroupSetup, newInventDim, origInventDim, purchLine.isStocked());
                    }
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInventOwner_RU</Name>
				<Source><![CDATA[
    protected boolean checkInventOwner_RU(InventDim _inventDim = purchLine.inventDim())
    {
        if (_inventDim.InventOwnerId_RU &&
            _inventDim.inventProfile_RU().InventOwnerIdCheckPurchOrder &&
            ! InventOwner_RU::checkPurchOrder(_inventDim.InventOwnerId_RU, purchTable))
        {
            return checkFailed(strFmt("@GLS115705", _inventDim.InventOwnerId_RU, fieldId2pname(tableNum(InventDim), fieldNum(InventDim, InventOwnerId_RU))));
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInventProfile_RU</Name>
				<Source><![CDATA[
    protected boolean checkInventProfile_RU(InventDim _inventDim = purchLine.inventDim())
    {
        boolean             ok = true;
        MarkupTrans         markupTrans;
        MarkupTable         markupTable;
        InventProfile_RU    inventProfile;
        PurchTable_RU       purchTable_RU = purchTable.purchTable_RU();

        if (! _inventDim.InventProfileId_RU)
        {
            if (purchLine.isCategoryBased())
            {
                if (purchTable_RU.InventProfileType_RU != InventProfileType_RU::NotSpecified &&
                    purchTable_RU.InventProfileType_RU != InventProfileType_RU::General)
                {
                    ok = checkFailed(strFmt("@GLS220092", purchTable_RU.InventProfileType_RU));
                }
                if (purchTable_RU.InventProfileType_RU == InventProfileType_RU::General &&
                    InventProfile_RU::find(purchTable_RU.InventProfileId_RU).StockInTransit == StockInTransit_RU::BoughtInTransit)
                {
                    ok = checkFailed(strFmt("@GLS220091", purchTable_RU.InventProfileId_RU));
                }
            }

            return ok;
        }

        if (purchTable_RU.InventProfileType_RU &&
            purchTable_RU.InventProfileType_RU != InventProfile_RU::find(_inventDim.InventProfileId_RU).InventProfileType)
        {
            ok = checkFailed(strFmt("@GLS113737",
                                    _inventDim.InventProfileId_RU,
                                    purchTable_RU.InventProfileType_RU));
        }
        if (purchTable_RU.InventProfileId_RU &&
            purchTable_RU.InventProfileId_RU != _inventDim.InventProfileId_RU)
        {
            ok = checkFailed(strFmt("@GLS113734",
                                    _inventDim.InventProfileId_RU,
                                    purchTable_RU.InventProfileId_RU));
        }

        inventProfile = _inventDim.inventProfile_RU();

        if (inventProfile.LockCostAdjustment)
        {
            select firstonly RecId from markupTrans
                where markupTrans.TransTableId  == purchLine.TableId
                   && markupTrans.TransRecId    == purchLine.RecId
                   && ! markupTrans.Voucher
            exists join markupTable
                where markupTable.MarkupCode    == markupTrans.MarkupCode
                   && markupTable.ModuleType    == MarkupModuleType::Vend
                   && (markupTable.CustType == MarkupType::Item ||
                       markupTable.VendType == MarkupType::Item);

            if (markupTrans.RecId)
            {
                ok = checkFailed("@SYS16770");
            }
        }

        if (inventProfile.LockMarkupCustVend)
        {
            select firstonly RecId from markupTrans
                where markupTrans.TransTableId  == purchLine.TableId
                   && markupTrans.TransRecId    == purchLine.RecId
                   && ! markupTrans.Voucher
            exists join markupTable
                where markupTable.MarkupCode    == markupTrans.MarkupCode
                   && markupTable.ModuleType    == MarkupModuleType::Vend
                   && (markupTable.CustType == MarkupType::CustVend ||
                       markupTable.VendType == MarkupType::CustVend);

            if (markupTrans.RecId)
            {
                ok = checkFailed("@GLS115688");
            }
        }

        if (!purchLine.isStocked())
        {
            if (inventProfile.InventProfileType != InventProfileType_RU::NotSpecified &&
                inventProfile.InventProfileType != InventProfileType_RU::General)
            {
                ok = checkFailed(strFmt("@GLS220092", inventProfile.InventProfileType));
            }
            else if (inventProfile.InventProfileType == InventProfileType_RU::General &&
                     inventProfile.StockInTransit    == StockInTransit_RU::BoughtInTransit)
            {
                ok = checkFailed(strFmt("@GLS220091", inventProfile.InventProfileId));
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInventTransDeleteContraints</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Validates if there exist invent transactions that would fail the delete later on.
    /// </summary>
    /// <returns>
    /// If no constraint exists - return true; Otherwise false.
    /// </returns>
    protected boolean checkInventTransDeleteContraints()
    {
        InventTrans        inventTrans;
        InventTransOrigin  inventTransOrigin;
        boolean            ok = true;

        if (purchTable.ChangeRequestRequired
            && purchLine.creditNoteLine())
        {
            select firstonly RecId from inventTrans
                where inventTrans.StatusIssue == StatusIssue::Picked
                   && inventTrans.StatusReceipt == StatusReceipt::None
                exists join inventTransOrigin
                where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                    && inventTransOrigin.InventTransId == purchLine.InventTransId;

            if (inventTrans.RecId)
            {
                ok = checkFailed(strFmt("@SYS19413", StatusIssue::Picked));
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPurchUnit</Name>
				<Source><![CDATA[
    boolean checkPurchUnit()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkQuantityUpdateValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the line quantity that is being updated is valid and throws an error if not
    /// valid.
    /// </summary>
    /// <returns>
    /// true if line quantity being updated are valid; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Line quantity cannot be changed below the invoiced or received quantity.
    /// </remarks>
    public boolean checkQuantityUpdateValid()
    {
        PurchLine   purchLineOrig;
        UnitQty     qtyRegistered;
        boolean     ok = true;

        if (!purchLine.isStocked() || this.isChangeRequestRequired())
        {
            purchLineOrig = purchLine.orig();
            qtyRegistered = purchLine.registeredInPurchUnit();

            if (purchLineOrig)
            {
                //Quantity cannot be reduced if the remaining update quantity changes sign.
                if ((abs(purchLine.PurchQty)  <  abs(purchLineOrig.PurchQty) && purchLine.PurchQty * purchLineOrig.PurchQty >= 0)
                || (abs(purchLine.RemainPurchPhysical)  <  abs(purchLineOrig.RemainPurchPhysical) && purchLine.RemainPurchPhysical * purchLineOrig.RemainPurchPhysical >= 0))
                {
                    if ((purchLineOrig.RemainPurchPhysical == 0 && purchLineOrig.RemainPurchFinancial == 0)
                        || purchLine.RemainPurchPhysical * purchLineOrig.RemainPurchPhysical   < 0
                        || purchLine.RemainPurchPhysical * purchLineOrig.RemainPurchFinancial  < 0
                        || abs(purchLine.PurchQty) < qtyRegistered
                        || abs(purchLine.RemainPurchPhysical) < qtyRegistered)
                    {
                        ok = checkFailed("@SYS25508");
                        checkFailed(strFmt("@SYS56628",StatusReceipt::Purchased,StatusReceipt::Received,StatusReceipt::Registered));
                    }
                }

                //Quantity may not change sign if the line is partially received or invoiced
                if (purchLine.PurchQty * purchLineOrig.PurchQty < 0)
                {
                    if (purchLine.RemainPurchPhysical != purchLine.PurchQty
                        || purchLine.RemainPurchFinancial != 0
                        || qtyRegistered != 0)
                    {
                        ok = checkFailed("@SYS25506");
                        checkFailed(strFmt("@SYS56628",StatusReceipt::Purchased,StatusReceipt::Received,StatusReceipt::Registered));
                    }
                }
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdatePhysical</Name>
				<Source><![CDATA[
    boolean checkUpdatePhysical()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearAllPriceDiscChangePolicies</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes all existing price discount change policies from a corresponding <c>PurchLine</c> record.
    /// </summary>
    /// <remarks>
    /// Removes policies from both the manual and system groups.
    /// </remarks>
    void clearAllPriceDiscChangePolicies()
    {
        purchLine.ManualEntryChangepolicy = 0;
        purchLine.SystemEntryChangePolicy = 0;
        purchLine.SystemEntrySource       = PriceDiscSystemSource::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditNoteLine</Name>
				<Source><![CDATA[
    boolean creditNoteLine()
    {
        if (purchLine.PurchQty < 0)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic before a purchase order line record is deleted.
    /// </summary>
    public void deleting()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic after a purchase order line record has been deleted.
    /// </summary>
    public void deleted()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteRetailSumLinesFromPurch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the information about purchase order line from retail sum lines
    /// </summary>
    public void deleteRetailSumLinesFromPurch()
    {
        RetailSumLines::deleteLineFromPurch(purchLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteSalesLine</Name>
				<Source><![CDATA[
    void deleteSalesLine()
    {
        SalesLine salesLine = SalesLine::findInventTransId(purchLine.InventRefTransId, true);

        if (salesLine)
        {
			if (purchLine.SkipUpdate == InterCompanySkipUpdate::Internal
			||  purchLine.SkipUpdate == InterCompanySkipUpdate::Both
            ||  purchLine.InterCompanyInventTransId != salesLine.InventTransId
			|| !this.isPurchTableInterCompanyOrder()
			|| !PurchTableType::construct(purchTable).interCompanyCreateAllowed())
				return;

            if (salesLine.RemainSalesFinancial != 0 && salesLine.isDropShipment())
            {
                throw error ("@SYS191052");
            }

            salesLine.SkipUpdate = InterCompanySkipUpdate::Internal;
            salesLine.delete();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes <c>TaxUncommitted</c> records for the line or for the entire document if it has not yet been confirmed.
    /// </summary>
    /// <param name="_lineDeleted">
    /// A Boolean value indicating if the line was deleted.
    /// </param>
    public void deleteTaxUncommitted(boolean _lineDeleted = false)
    {
        const boolean DeleteSourceDocumentLineTrue = true;
        const boolean MaintainExistingTaxUncommittedTrue = true;
        const boolean MaintainExistingTaxUncommittedFalse = false;
        const boolean NeedToCheckEventStateTrue = true;

        boolean doIsolateTransactionScope = false;
        
        if (purchTable.maintainTaxUncommitted())
        {
            if (_lineDeleted)
            {
                TaxUncommitted::deleteForDocumentLine(purchLine.TableId, purchLine.RecId, DeleteSourceDocumentLineTrue, MaintainExistingTaxUncommittedTrue, doIsolateTransactionScope);
            }
        }
        else
        {
            TaxUncommitted::deleteForDocumentHeader(purchTable.TableId, purchTable.RecId, DeleteSourceDocumentLineTrue, NeedToCheckEventStateTrue, MaintainExistingTaxUncommittedFalse, doIsolateTransactionScope);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteChargeTaxUncommited</Name>
				<Source><![CDATA[
    internal void deleteChargeTaxUncommited(MarkupTrans _markupTrans)
    {
        if (PurchCalcTaxConsiderMarkupChangesOnRecalcSkipFlight::instance().isEnabled()
            && purchTable.maintainTaxUncommitted())
        {
            TaxUncommitted::deleteForDocumentLine(_markupTrans.TableId, _markupTrans.RecId, true, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTaxWithholdUncommitted_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes <c>TaxWithholdUncommitted_IN</c> records for the line or for the entire document if it has not yet been confirmed.
    /// </summary>
    /// <param name="_lineDeleted">
    /// A Boolean value indicating if the line was deleted.
    /// </param>
    public void deleteTaxWithholdUncommitted_IN(boolean _lineDeleted = false)
    {
        if (purchTable.maintainTaxUncommitted())
        {
            if (_lineDeleted)
            {
                TaxWithholdUncommitted_IN::deleteForDocumentLine(purchLine.TableId, purchLine.RecId);
            }
        }
        else
        {
            TaxWithholdUncommitted_IN::deleteForDocumentHeader(purchTable.TableId, purchTable.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTaxWithholdUncommitted</Name>
				<Source><![CDATA[
    public void deleteTaxWithholdUncommitted()
    {
        TaxWithholdUncommitted::deleteForDocumentHeader(purchTable.TableId, purchTable.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDeleteWarning</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the alternative warning message for deleting the order line.
    /// </summary>
    /// <returns>
    /// The alternative warning message; otherwise, an empty string.
    /// </returns>
    str getDeleteWarning()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>deletePurchLinkFromProdBom</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes <c>ProdBom</c> references when <c>PurchLine</c> is deleted.
    /// </summary>
    internal void deletePurchLinkFromProdBom()
    {
        ProdBOM prodBOM;

        select firstonly InventRefId from prodBOM
            where prodBOM.InventRefId == purchLine.PurchId
               && prodBOM.InventRefType == InventRefType::Purch
               && prodBOM.InventRefTransId == purchLine.InventTransId;

        if(prodBOM.InventRefId)
        {
            ttsbegin;
            update_recordset prodBOM
                   setting InventRefId = '',
                           InventRefType = InventRefType::None
                where prodBOM.InventRefId == purchLine.PurchId
                   && prodBOM.InventRefType == InventRefType::Purch
                   && prodBOM.InventRefTransId == purchLine.InventTransId;
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromAgreementLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>PurchLine</c> record from the <c>AgreementLine</c> record.
    /// </summary>
    /// <param name="_agreementLine">
    /// The <c>AgreementLine</c> record from which to initialize the <c>PurchLine</c> record.
    /// </param>
    public void initFromAgreementLine(AgreementLine _agreementLine)
    {
        InventDim            inventDim            = purchLine.inventDim();
        InventDim            agreementInventDim   = _agreementLine.inventDim();
        AgreementLineDefault agreementLineDefault = AgreementLineDefault::findAgreementLine(_agreementLine.RecId);
        List                 dimFields            = InventDim::dimAgreementFieldList();
        ListEnumerator       enumerator           = dimFields.getEnumerator();
        FieldId              inventDimFieldId;

        FiscalCalendarYear        fiscalCalendarYear;
        SourceDocumentLine        sourceDocumentLine;
        PurchCommitmentLine_PSN   purchCommitmentLine;
        PurchCommitmentHeader_PSN purchCommitmentHeader;

        while (enumerator.moveNext())
        {
            inventDimFieldId = enumerator.current();
            if (agreementInventDim.(inventDimFieldId))
            {
                inventDim.(inventDimFieldId) = agreementInventDim.(inventDimFieldId);
            }
        }
        inventDim.InventDimId    = InventDim::findOrCreate(inventDim).InventDimId;

        purchLine.setInventDimId(inventDim.InventDimId, inventDim);

        purchLine.ProjId = _agreementLine.ProjectProjId ? _agreementLine.ProjectProjId : purchLine.ProjId;
        if (agreementLineDefault.ProjectCategory)
        {
            purchLine.ProjCategoryId = agreementLineDefault.ProjectCategory;
            if (agreementLineDefault.ProjectActivityNumber)
            {
                purchLine.ActivityNumber = agreementLineDefault.ProjectActivityNumber;
            }
        }

        if (purchLine.PurchReqLineRefId 
            && PurchLineSkipAgreementPriceWhenPurchReqExistsFlight::instance().isEnabled())
        {
            PurchReqLine reqLine = PurchReqLine::findLineRefId(purchLine.PurchReqLineRefId);
            if (reqLine.mustSearchPriceForPurchaseLine(purchLine))
            {
                purchLine.salesPurchLineInterface().setAgreementQtyAndPrice(_agreementLine);
            }
        }
        else 
        {
            purchLine.salesPurchLineInterface().setAgreementQtyAndPrice(_agreementLine);
        }

        // Merging financial dimensions from AgreementLine and currently set on purchLine
        if (!purchLine.PurchReqLineRefId)
        {
            purchLine.DefaultDimension = purchLine.mergeDimension(_agreementLine.DefaultDimension, purchLine.DefaultDimension);
        }

        purchLine.MatchingAgreementLine = _agreementLine.RecId;
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            purchLine.DefaultDimension = AgreementHeaderExt_RU::createAgreementDimension(purchTable.purchTable_RU().AgreementHeaderExt_RU, purchLine.DefaultDimension);
        }
        // </GEERU>

        //select all purchCommitmentLines that are associated with the current agreement
        if (PublicSectorUtils::isFrenchRegulatoryEnabled())
        {
            fiscalCalendarYear = FiscalCalendarYear::findYearByCalendarDate(Ledger::fiscalCalendar(CompanyInfo::current()), purchTable.AccountingDate);

            select count (RecId), PurchCommitmentHeader_PSN, SourceDocumentLine from purchCommitmentLine
            exists join purchCommitmentHeader
            exists join sourceDocumentLine
                where purchCommitmentLine.AgreementLine == _agreementLine.RecId &&
                        purchCommitmentLine.LineDate >= fiscalCalendarYear.StartDate &&
                        purchCommitmentLine.LineDate <=  fiscalCalendarYear.EndDate &&
                        purchCommitmentHeader.RecId == purchCommitmentLine.PurchCommitmentHeader_PSN &&
                        purchCommitmentHeader.DocumentStatus == PurchCommitmentDocumentStatus_PSN::Complete &&
                        sourceDocumentLine.RecId == purchCommitmentLine.SourceDocumentLine &&
                        sourceDocumentLine.AccountingStatus != SourceDocumentLineAccountingStatus::Finalized;

            //if only one line is found then assign it to the current Purchase Order Line
            if (purchCommitmentLine.RecId == 1)
            {
                select RecId from purchCommitmentLine
                exists join purchCommitmentHeader
                exists join sourceDocumentLine
                    where purchCommitmentLine.AgreementLine == _agreementLine.RecId &&
                            purchCommitmentLine.LineDate >= fiscalCalendarYear.StartDate &&
                            purchCommitmentLine.LineDate <=  fiscalCalendarYear.EndDate &&
                            purchCommitmentHeader.RecId == purchCommitmentLine.PurchCommitmentHeader_PSN &&
                            purchCommitmentHeader.DocumentStatus == PurchCommitmentDocumentStatus_PSN::Complete &&
                            sourceDocumentLine.RecId == purchCommitmentLine.SourceDocumentLine &&
                            sourceDocumentLine.AccountingStatus != SourceDocumentLineAccountingStatus::Finalized;

                purchLine.PurchCommitmentLine_PSN = purchCommitmentLine.RecId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromEcoResCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>PurchLine</c> record, depending on the <c>ProcurementCategory</c> record.
    /// </summary>
    /// <param name="_procurementCategory">
    /// The <c>ProcurementCategory</c> record with which to initialize the purchase line.
    /// </param>
    /// <param name="_name">
    /// The name to be assigned to the line.
    /// </param>
    protected void initFromEcoResCategory(PurchCategory _procurementCategory, ItemFreeTxt _name)
    {
        TaxItemGroupHeading taxItemGroupHeading;

        purchLine.ProcurementCategory   = _procurementCategory;
        purchLine.Name                  = _name;
        purchLine.PriceUnit             = 1.00;  //default value for description based lines
        this.setStockedProduct();

        taxItemGroupHeading = EcoResCategory::getProcurementCategoryItemTaxGroup(_procurementCategory, CompanyInfo::current());
        if (taxItemGroupHeading)
        {
            purchLine.TaxItemGroup = taxItemGroupHeading.TaxItemGroup;
        }

        if (purchLine.isCategoryBased())
        {
            purchLine.MatchingPolicy = PurchMatchingPolicyManager::findMatchingPolicy(null, purchTable.vendTable_OrderAccount(), purchLine.ProcurementCategory, FormDataUtil::isFormDataSource(purchLine));
        }

        purchLine.DefaultDimension = purchLine.copyDimension(purchLine.DefaultDimension);

        if (purchLine.canApplyAllocationOrDistributionTemplate())
        {
            purchLine.AccountingDistributionTemplate = purchTable.AccountingDistributionTemplate;
        }

        purchLine.TaxWithholdItemGroupHeading_TH = ProcCategoryItemTaxGroup::getProcCategoryTaxItemWithholdItemGroup(_procurementCategory).TaxWithholdItemGroupHeadingId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcDimensionsSpecificPurchQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the <c>PurchQty</c> of the <c>PurchLine</c>.
    /// </summary>
    /// <param name = "_inventTable">An <c>InventTable</c> record.</param>
    /// <returns>The <c>PurchQty</c> of the <c>PurchLine</c>.</returns>
    protected PurchQty calcDimensionsSpecificPurchQty(InventTable _inventTable)
    {
        if (PdsCWPurchSalesLineDefaultQuantityThreeWayConversionDisabled::instance().isEnabled())
        {
            if (PdsGlobal::pdsIsCWItem(_inventTable.ItemId))
            {
                return this.calcDimensionsSpecificPurchQtyForCWItem();
            }
            else
            {
                return this.calcDimensionsSpecificPurchQtyForNonCWItem(_inventTable);
            }
        }

        purchLine.PurchQty = purchLine.PurchQty ? purchLine.PurchQty : _inventTable.purchStandardQty(purchLine.inventDim().InventDimId);

        if (!purchLine.PurchQty && PdsGlobal::pdsIsCWItem(purchLine.ItemId))
        {
            // Multiply with CW qty in case it has been prepopulated
            PdsNominalQty nominalQty = PdsCatchWeightItem::find(purchLine.ItemId).nominalQty() * minOne(purchLine.PdsCWQty);

            return purchLine.unitConvertInvent2Purch(nominalQty);
        }

        return purchLine.PurchQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcDimensionsSpecificPurchQtyForCWItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the <c>PurchQty</c> of the <c>PurchLine</c> in case of catch weight item.
    /// </summary>
    /// <returns>The <c>PurchQty</c> of the <c>PurchLine</c>.</returns>
    protected PurchQty calcDimensionsSpecificPurchQtyForCWItem()
    {
        return PdsCatchWeight::inventQty(purchLine.ItemId, purchLine.PdsCWQty, purchLine.PurchUnit);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcDimensionsSpecificPurchQtyForNonCWItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the <c>PurchQty</c> of the <c>PurchLine</c> in case of non catch weight item.
    /// </summary>
    /// <param name = "_inventTable">An <c>InventTable</c> record.</param>
    /// <returns>The <c>PurchQty</c> of the <c>PurchLine</c>.</returns>

    protected PurchQty calcDimensionsSpecificPurchQtyForNonCWItem(InventTable _inventTable)
    {
        return purchLine.PurchQty ? purchLine.PurchQty : _inventTable.purchStandardQty(purchLine.InventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcDimensionsSpecificPdsCWQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the <c>PdsCWQty</c> of the <c>PurchLine</c>.
    /// </summary>
    /// <param name = "_inventTable">An <c>InventTable</c> record.</param>
    /// <returns>The <c>PdsCWQty</c> of the <c>PurchLine</c>.</returns>
    protected PdsCWQty calcDimensionsSpecificPdsCWQty(InventTable _inventTable)
    {
        if (PdsCWPurchSalesLineDefaultQuantityThreeWayConversionDisabled::instance().isEnabled())
        {
            PdsCWQty pdsCWQty = purchLine.PdsCWQty;
        
            if (PdsGlobal::pdsIsCWItem(_inventTable.ItemId))
            {
                if (!pdsCWQty)
                {
                    InventDim inventDim = purchLine.inventDim();
                    UnitOfMeasureSymbol cwUnitId = PdsCatchWeightItem::find(_inventTable.ItemId).PdsCWUnitId;
                    if (_inventTable.purchUnitId() == cwUnitId)
                    {
                        InventHandlingQty purchStandardQty = InventTableModule::unitConvert(purchLine.ItemId,
                                                                                            ModuleInventPurchSales::Purch,
                                                                                            _inventTable.inventUnitId(),
                                                                                            _inventTable.purchStandardQty(purchLine.InventDimId));
                
                        pdsCWQty = PdsCatchWeight::convertQtyToCWQty(purchLine.ItemId,
                                                                     purchStandardQty,
                                                                     purchLine.PurchUnit);
                    }
                    else
                    {
                        pdsCWQty = PdsCatchWeight::convertQtyToCWQty(purchLine.ItemId,
                                                                     _inventTable.purchStandardQty(inventDim.InventDimId),
                                                                     purchLine.PurchUnit);
                    }

                    if (!pdsCWQty)
                    {
                        pdsCWQty = 1;
                    }
                }
            }
        
            return pdsCWQty;
        }

        if (!purchLine.PdsCWQty && PdsGlobal::pdsIsCWItem(purchLine.ItemId))
        {
            return PdsCatchWeight::convertQtyToCWQty(purchLine.ItemId, purchLine.PurchQty, purchLine.PurchUnit);
        }

        return purchLine.PdsCWQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDimensionsSpecificDefaulting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes product dimension specific order defaulting.
    /// </summary>
    /// <param name = "_inventDistinctProductDimensionSpecificDefaultingArgs">Product dimension specific order defaulting arguments.</param>
    public void initDimensionsSpecificDefaulting(InventDistinctProductDimensionSpecificDefaultingArgs _inventDistinctProductDimensionSpecificDefaultingArgs)
    {
        #ISOCountryRegionCodes

        InventDistinctProductDimensionSpecificDefaultingArgsPurchLine arguments = _inventDistinctProductDimensionSpecificDefaultingArgs as InventDistinctProductDimensionSpecificDefaultingArgsPurchLine;
        InventTable inventTable = arguments.InventTable;
        InventDim inventDim = this.initDimensionsSpecificDefaultingInventDim(arguments);

        inventDim = InventDim::findOrCreate(inventDim);
        purchLine.setInventDimId(inventDim.InventDimId, inventDim);


        if (arguments.SetAddressFromInventDim)
        {
            purchLine.setAddressFromInventDim(inventDim);
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
        {
            InventDimCombination variant = InventDimCombination::findByInventDim(purchLine.ItemId, inventDim);
            if (variant)
            {
                purchLine.VariantId = variant.RetailVariantId;
            }
        }

        if (PdsCWPurchSalesLineDefaultQuantityThreeWayConversionDisabled::instance().isEnabled())
        {
            purchLine.PdsCWQty = this.calcDimensionsSpecificPdsCWQty(inventTable);
            purchLine.PurchQty = this.calcDimensionsSpecificPurchQty(inventTable);
        }
        else
        {
            purchLine.PurchQty = this.calcDimensionsSpecificPurchQty(inventTable);
            purchLine.PdsCWQty = this.calcDimensionsSpecificPdsCWQty(inventTable);
        }

        InventTableModule inventTableModule = InventTableModule::find(inventTable.ItemId, ModuleInventPurchSales::Purch);

        if (EcoResProductVariantItemSalesTaxGroupFeature::isFeatureEnabled()
            && _inventDistinctProductDimensionSpecificDefaultingArgs.parmIsProductDimensionModified()
            && (!EcoResProductVariantItemSalesTaxGroupNoBRFlight::instance().isEnabled() || !(BrazilParameters::isEnabled() && purchLine.CFOPTable_BR)))
        {
            purchLine.TaxItemGroup = InventTable::getTaxItemGroupId(ModuleInventPurchSales::Purch, purchLine.ItemId, inventDim.InventDimId);
        }

        purchLine.QtyOrdered = purchLine.calcQtyOrdered();

        purchLine.initBarcode(inventDim);

        if (arguments.SearchPrice)
        {
            purchLine.setPriceDisc(inventDim, arguments.InitDateFields);
        }

        // <GIN>
        PurchLine_IN purchLine_IN;

        if (TaxParameters::isCustomsEnable_IN()
            && purchLine.purchTable().purchTable_W().CustomsImportOrder_IN)
        {
            purchLine_IN = purchLine.purchLine_IN();
            purchLine_IN.CustomsMaxRetailPrice  = inventTableModule.MaximumRetailPrice_IN;
            purchLine.packPurchLine_IN(purchLine_IN);
        }
        if (TaxParameters::isServiceTaxEnable_IN()
            && inventTable.ItemType == ItemType::Service)
        {
            purchLine_IN = purchLine.purchLine_IN();
            purchLine.packPurchLine_IN(purchLine_IN);
        }
        // </GIN>

        this.initForeignTradeFromInventTable(inventTable);

        // <GEERU>
        PurchLine_W purchLine_W;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            purchLine_W = purchLine.purchLine_W();
            purchLine_W.MarkupCode_RU = inventTable.isMarkupCodeEnabled_RU() ? inventTable.MarkupCode_RU : '';
            purchLine.packPurchLine_W(purchLine_W);
            if (FormDataUtil::getFormDataSource(purchLine))
            {
                FormDataUtil::getFormDataSource(purchLine).refresh();
            }
        }
        // </GEERU>

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            purchLine.setTaxGroupAndTaxItemGroupFields_BR();

            LogisticsPostalAddress deliveryAddress = purchTable.purchTable_BR().ServiceCodeOnDlvAddress_BR == NoYes::Yes ? purchLine.deliveryAddress() : null;
            purchLine.TaxServiceCode_BR = inventTable.serviceCode_BR(deliveryAddress).ServiceCodeId;
        }
        // </GBR>
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDimensionsSpecificDefaultingInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>InventDim</c> record used to initialize product dimension specific order defaulting.
    /// </summary>
    /// <param name = "_arguments">Product dimension specific order defaulting arguments.</param>
    /// <returns>The initialized <c>InventDim</c> record.</returns>
    protected InventDim initDimensionsSpecificDefaultingInventDim(InventDistinctProductDimensionSpecificDefaultingArgsPurchLine _arguments)
    {
        InventDim inventDim = purchLine.inventDim();

        // For drop shipments, populate the line with the drop ship warehouse.
        MCRInventTable mcrInventTable = _arguments.InventTable.mcrInventTable();

        if (purchLine.MCRDropShipment)
        {
            if (mcrInventTable.DropShipment && mcrInventTable.DefaultDropShipmentWarehouse)
            {
                inventDim.InventLocationId = mcrInventTable.DefaultDropShipmentWarehouse;
                inventDim.InventSiteId = InventLocation::find(inventDim.InventLocationId).InventSiteId;
            }
        }

        // Default Status
        if (!inventDim.InventStatusId && WHSInventEnabled::exist(purchLine.ItemId))
        {
            inventDim.InventStatusId = WHSInvent::getDefaultStatus(inventDim, null, purchLine);
        }

        return inventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initReleasedProductSpecificDefaulting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes settings that are based on the released product.
    /// </summary>
    /// <param name = "_inventTable">An <c>InventTable</c> record buffer.</param>
    public void initReleasedProductSpecificDefaulting(InventTable _inventTable)
    {
        #ISOCountryRegionCodes
        // <GIN>
        PurchLine_IN        purchLine_IN;
        // </GIN>
        // <GEERU>
        PurchLine_W         purchLine_W;
        // </GEERU>

        // If this is not an item based (but category based) line then we should not initialize from inventTable.
        if (!_inventTable)
        {
            return;
        }

        // initializing the item id for the purchase order
        purchLine.ItemId = _inventTable.ItemId;
        // initializing product dimensions
        InventDim inventDimDefaultProductDimensions = _inventTable.getDefaultProductDimensions(purchLine.inventDim());
        purchLine.setInventDimId(inventDimDefaultProductDimensions.inventDimId, inventDimDefaultProductDimensions);

        purchLine.ProcurementCategory = EcoResProductCategory::findByItemIdCategoryHierarchyRole(
                                            _inventTable.ItemId,
                                            EcoResCategoryNamedHierarchyRole::Procurement).Category;
        this.setStockedProduct();

        InventTableModule inventTableModule = InventTableModule::find(_inventTable.ItemId, ModuleInventPurchSales::Purch);

        purchLine.TaxItemGroup = inventTableModule.TaxItemGroupId;

        purchLine.ProjCategoryId    = _inventTable.ProjCategoryId ? _inventTable.ProjCategoryId : purchLine.ProjCategoryId;
        purchLine.PurchUnit         = inventTableModule.UnitId;
        if (purchLine.ProjId)
        {
            purchLine.ProjSalesUnitId = purchLine.PurchUnit;
        }
        purchLine.OverDeliveryPct   = inventTableModule.OverDeliveryPct;
        purchLine.UnderDeliveryPct  = inventTableModule.UnderDeliveryPct;

        purchLine.initName(_inventTable);

        purchLine.initFromVendExternalItemDescription();

        purchLine.DefaultDimension  = DefaultDimensionDefaultingStrategy::newServiceMerge(
            DefaultDimensionDefaultingDimensionTarget::newFromRecord(purchLine),
            DefaultDimensionDefaultingDimensionCollection::construct()
                .add(DefaultDimensionDefaultingDimensionSource::newFromDimensionDefaultMap(purchLine))
                .add(DefaultDimensionDefaultingDimensionSource::newFromDimensionDefaultMap(_inventTable))).getDefaultDimension();

        purchLine.MatchingPolicy    = PurchMatchingPolicyManager::findMatchingPolicy(_inventTable, purchTable.vendTable_OrderAccount());
       
        if ((TaxWithholdingGlobalFeature::isExtendedWHTSupportedInCountryRegionOrParamEnabled() || BrazilParameters::isEnabled())
            && inventTableModule.TaxWithholdCalculate_TH)
        {
            purchLine.TaxWithholdItemGroupHeading_TH = inventTableModule.TaxWithholdItemGroupHeading_TH;
        }

        if (purchLine.canApplyAllocationOrDistributionTemplate())
        {
            purchLine.AccountingDistributionTemplate = purchTable.AccountingDistributionTemplate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromInventTable</Name>
				<Source><![CDATA[
    [Hookable()]
    /// <summary>
    ///     Initiates a <c>PurchLine</c> table buffer from an <c>InventTable</c> table buffer.
    /// </summary>
    /// <param name="_inventTable">
    ///     A buffer of the <c>InventTable</c>.
    /// </param>
    /// <param name="_searchPrice">
    ///     A Boolean that specifies whether prices and discounts should be initiated; optional.
    /// </param>
    /// <param name="_setAddressFromInventDim">
    ///     A Boolean that specifies whether the address should be initiated from the inventory dimension; optional.
    /// </param>
    /// <param name="_initDateFields">
    ///     A Boolean that specifies whether the delivery dates should be recalculated; optional.
    /// </param>
    /// <param name="_executeOnlyIfProductIsFullySpecified">
    ///     A Boolean value that indicates whether product variant validation should be performed and pass before executing variant specific defaulting; optional.
    /// </param>
    public void initFromInventTable(
        InventTable     _inventTable,
        boolean         _searchPrice = true,
        boolean         _setAddressFromInventDim = true,
        boolean         _initDateFields = true,
        boolean         _executeOnlyIfProductIsFullySpecified = false)
    {
        if (!purchLine.RecId)
        {
            SalesPurchLineInterface::flushPriceDiscCache();
        }

        InventDistinctProductOrderDefaultingController::itemIdModified(this, InventDistinctProductDimensionSpecificDefaultingArgsPurchLine::construct(_inventTable, _searchPrice, _setAddressFromInventDim, _initDateFields, _executeOnlyIfProductIsFullySpecified));

        this.initForeignTradeFromInventTable(_inventTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromItemOrCategory</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initiates a <c>PurchLine</c> table buffer from an <c>InventTable</c> buffer or based on the category.
    /// </summary>
    /// <param name="_itemId">
    ///     A <c>ItemId</c> type.
    /// </param>
    /// <param name="_procurementCategory">
    ///     A <c>PurchCategory</c> type.
    /// </param>
    /// <param name="_name">
    ///     The name of the category item.
    /// </param>
    /// <param name="_searchPrice">
    ///     A Boolean that specifies whether prices and discounts should be initiated; optional.
    /// </param>
    /// <param name="_setAddressFromInventDim">
    ///     A Boolean that specifies whether the address should be initiated from the inventory dimension; optional.
    /// </param>
    public void initFromItemOrCategory(
        ItemId          _itemId,
        PurchCategory   _procurementCategory,
        ItemFreeTxt     _name,
        boolean         _searchPrice = true,
        boolean         _setAddressFromInventDim = true)
    {
        purchLine.ItemId = _itemId;
        if (purchLine.ItemId)
        {
            this.initFromInventTable(purchLine.inventTable(), _searchPrice, _setAddressFromInventDim);
        }
        else
        {
            this.initFromEcoResCategory(_procurementCategory, _name);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromPurchTable</Name>
				<Source><![CDATA[
    public void initFromPurchTable(PurchTable  _purchTable, boolean _ignoreInventDim = false)
    {
        ProjTable   projTable;
        InventDim   inventDim;
        // <GIN>
        PurchLine_IN    purchLine_IN;
        PurchTable_W    purchTable_W;
        // </GIN>
        // <GEERU>
        PurchLine_W     purchLine_W;
        PurchTable_RU   purchTable_RU;
        #ISOcountryRegionCodes
        // </GEERU>

        purchLine.PurchaseType              = _purchTable.PurchaseType;
        purchLine.PurchId                   = _purchTable.PurchId;
        purchLine.CurrencyCode              = _purchTable.CurrencyCode;
        purchLine.TaxGroup                  = _purchTable.TaxGroup;
        purchLine.OverrideSalesTax          = _purchTable.OverrideSalesTax;
        purchLine.DeliveryDate              = _purchTable.DeliveryDate;
        purchLine.ProjId                    = _purchTable.ProjId;
        purchLine.Requester                 = _purchTable.Requester;
        purchLine.CustomerRef               = _purchTable.VendorRef;
        purchLine.CustPurchaseOrderFormNum  = _purchTable.PurchOrderFormNum;

        if (PurchParameters::find().IsSupplierShipmentDatesEnabled)
        {
            purchLine.ShipCalendarId = _purchTable.ShipCalendarId;

            if (purchLine.PurchaseType == PurchaseType::ReturnItem)
            {
                purchLine.RequestedShipDate = dateNull();
            }
            else
            {                
                purchLine.RequestedShipDate = _purchTable.RequestedShipDate != dateNull()
                    ? _purchTable.RequestedShipDate
                    : _purchTable.DeliveryDate;
            }            
        }

        if (purchLine.ProjId)
        {
            projTable = ProjTable::find(purchLine.ProjId);
            purchLine.initFromProjTable(projTable);
        }

        if (!_ignoreInventDim)
        {
            this.initStorageDimensionsFromPurchTable(_purchTable);
        }

        purchLine.VendAccount       = _purchTable.OrderAccount;
        purchLine.VendGroup         = _purchTable.VendGroup;
        purchLine.initFromVendTable();

        purchLine.setAddressFromPurchTable(_purchTable);

        purchLine.calculateRequestedAndConfirmedShipAndReceiptDate(purchLine.RequestedShipDate, purchLine.ConfirmedShipDate);

        purchLine.TransactionCode   = _purchTable.TransactionCode;
        purchLine.Transport         = _purchTable.Transport;
        purchLine.Port              = _purchTable.Port;
        purchLine.StatProcId        = _purchTable.StatProcId;
        purchLine.CountyOrigDest    = _purchTable.CountyOrigDest;

        if (_purchTable.InterCompanyOrder
        &&  _purchTable.InterCompanyDirectDelivery)
        {
            purchLine.DeliveryType  = TradeLineDlvType::DropShip;
        }
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            purchTable_RU = _purchTable.purchTable_RU();

            purchLine_W = purchLine.purchLine_W();
            purchLine_W.PriceAgreementDate_RU  = purchTable_RU.PriceAgreementDate_RU;
            purchLine.packPurchLine_W(purchLine_W);
        }
        // </GEERU>

        // Default dimension should be merged considering previous dimension on line and dimension on header
        purchLine.DefaultDimension = purchLine.mergeDimension(purchLine.DefaultDimension,
                                     _purchTable.DefaultDimension);
        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            purchLine.psaRetainScheduleId = ProjPWPVendorRetentionSetting::findByProjVendor(_purchTable.ProjId, _purchTable.OrderAccount).RuleId;
        }

        // <GIN>
        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            purchTable_W = _purchTable.purchTable_W();
            purchLine_IN = purchLine.purchLine_IN();
            purchLine_IN.tdsGroup       = purchTable_W.tdsGroup_IN;
            purchLine_IN.tcsGroup       = purchTable_W.tcsGroup_IN;
            purchLine.packPurchLine_IN(purchLine_IN);
        }
        // </GIN>

        // <GEEHU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoHU]))
        {
            purchLine.IntrastatFulfillmentDate_HU = _purchTable.IntrastatFulfillmentDate_HU;
        }
        // </GEEHU>
        // <GEECZ>
        if (SysExtensionSerializerExtensionMap::isExtensionEnabled(tableNum(PurchLine_Intrastat)))
        {
            var purchLine_Intrastat = purchLine.purchLine_Intrastat();
            purchLine_Intrastat.SpecialMovement_CZ = _purchTable.purchTable_Intrastat().SpecialMovement_CZ;
            purchLine.packPurchLine_Intrastat(purchLine_Intrastat);
        }
        // </GEECZ>

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoMX]))
        {
            purchLine_W = purchLine.purchLine_W();
            purchLine_W.initFromVendTable(purchLine.purchTable().vendTable_InvoiceAccount());
            purchLine.packPurchLine_W(purchLine_W);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initStorageDimensionsFromPurchTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes storage dimensions from header.
    /// </summary>
    /// <param name = "_purchTable">A <c>PurchTable</c> record buffer.</param>
    public void initStorageDimensionsFromPurchTable(PurchTable _purchTable)
    {
        InventDim inventDim = this.initInventDimFromPurchTable(_purchTable);

        purchLine.setInventDimIdFromInventDim(inventDim);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventDimFromPurchTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes an instance of the <c>InventDim</c>.
    /// </summary>
    /// <param name = "_purchTable">
    /// Parameters used to initialize the <c>PurchTable</c> instance with.
    /// </param>
    /// <returns>
    /// The <c>InventDim</c> instance.
    /// </returns>
    protected InventDim initInventDimFromPurchTable(PurchTable _purchTable)
    {
        InventDim inventDim = purchLine.inventDim();
        if (_purchTable.InventLocationId && !inventDim.InventLocationId)
        {
            inventDim.InventLocationId  = _purchTable.InventLocationId;
        }

        if (_purchTable.InventSiteId && !inventDim.InventSiteId)
        {
            inventDim.InventSiteId  = _purchTable.InventSiteId;
        }

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            PurchTable_RU purchTable_RU = _purchTable.purchTable_RU();

            if (purchTable_RU.InventProfileId_RU)
            {
                inventDim.InventProfileId_RU = purchTable_RU.InventProfileId_RU;
            }
        }
        // </GEERU>

        return inventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initStorageDimensionsFromHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes storage dimensions from header.
    /// </summary>
    public void initStorageDimensionsFromHeader()
    {
        this.initStorageDimensionsFromPurchTable(purchTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets an <c>InventDim</c> relation.
    /// </summary>
    /// <param name = "_inventDim">A <c>InventDim</c> record buffer.</param>
    public void setInventDim(InventDim _inventDim)
    {
        purchLine.setInventDimIdFromInventDim(_inventDim);
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipUpdateAndNoChangeRequired</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether intercompany update can be skipped for the purchase line and if purchase line changes do not require change requests.
    /// </summary>
    /// <returns>true if intercompany update can be skipped for the purchase line and purchase line changes do not require change requests; otherwise, false.</returns>
    protected boolean skipUpdateAndNoChangeRequired()
    {
        return ((purchline.SkipUpdate == InterCompanySkipUpdate::Internal || purchline.SkipUpdate == InterCompanySkipUpdate::Both)
                && !(purchline.isStocked() && this.isChangeRequestRequired() && purchTable.DocumentState == VersioningDocumentState::Draft));
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipUpdateAndNoReferenceLot</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether intercompany update can be skipped for the purchase line and if the purchase line has no reference lot.
    /// </summary>
    /// <returns>true if intercompany update can be skipped for the purchase line and if the purchase line has no reference lot; otherwise false.</returns>
    protected boolean skipUpdateAndNoReferenceLot()
    {
        return ((purchline.SkipUpdate  == InterCompanySkipUpdate::Internal
                || purchline.SkipUpdate  == InterCompanySkipUpdate::Both
                || !purchLine.isDropShipment()
                || this.isPurchTableInterCompanyOrder())
                && !purchline.InventRefTransId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the associated <c>InventDim</c> record.
    /// </summary>
    /// <returns>the associated <c>InventDim</c> record.</returns>
    public InventDim inventDim()
    {
        return purchLine.inventDim();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromTmpPurchLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the PurchLine record from the <c>TmpPurchLine</c> record.
    /// </summary>
    /// <param name="_tmpPurchLine">
    /// The <c>TmpPurchLine</c> record from which to initialize the <c>PurchLine</c> record.
    /// </param>
    public void initFromTmpPurchLine(TmpPurchLine _tmpPurchLine)
    {
        purchLine.ItemId = _tmpPurchLine.ItemId;

        if (_tmpPurchLine.ItemId)
        {
            this.initFromInventTable(InventTable::find(_tmpPurchLine.ItemId));
        }
        purchLine.setInventDimId(_tmpPurchLine.InventDimId);

        purchLine.initName();
        purchLine.VariantId  = _tmpPurchLine.VariantId;
        purchLine.PurchQty   = _tmpPurchLine.PurchQty;
        purchLine.PurchUnit  = _tmpPurchLine.Units;
        purchLine.QtyOrdered = _tmpPurchLine.PurchQty;
        purchLine.PdsCWQty   = _tmpPurchLine.PdsCWQty;

        purchLine.DeliveryDate            = _tmpPurchLine.DeliveryDate;
        purchLine.DeliveryPostalAddress   = _tmpPurchLine.DeliveryPostalAddress;
        purchLine.DeliveryName            = _tmpPurchLine.DeliveryName;
        purchLine.AddressRefRecId         = _tmpPurchLine.AddressRecId;
        purchLine.AddressRefTableId       = _tmpPurchLine.AddressRefTableId;
        
        if (PurchParameters::find().IsSupplierShipmentDatesEnabled)
        {
            purchLine.RequestedShipDate   = _tmpPurchLine.RequestedShipDate;
            purchLine.ShipCalendarId      = _tmpPurchLine.ShipCalendarId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInventDimFromSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the inventory dimension id on the specified <c>AxSalesLine</c> instance.
    /// </summary>
    /// <param name = "_axSalesLine">The <c>AxSalesLine</c> instance for which to set the inventory dimension id.</param>
    /// <param name = "_purchLine">The <c>PurchLine</c> record from which to initialize a <c>SalesLine</c> record.</param>
    /// <param name = "_create">true if a purchase order line is being created; otherwise, false.</param>
    protected void initializeInventDimFromSalesLine(AxSalesLine _axSalesLine, PurchLine _purchLine, boolean _create)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPurchQty</Name>
				<Source><![CDATA[
    void initPurchQty()
    {
        purchLine.QtyOrdered = purchLine.calcQtyOrdered();
        this.initReturn();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initReturn</Name>
				<Source><![CDATA[
    void initReturn()
    {
        if (this.creditNoteLine())
            purchLine.Scrap = false;
        else
            purchLine.ReturnActionId = '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    void initValue()
    {
        purchLine.WorkflowState = TradeWorkflowState::NotSubmitted;
        purchLine.PurchStatus = PurchStatus::Backorder;
        purchLine.PurchaseOrderLineCreationMethod = PurchPurchaseOrderCreationMethod::Purchase;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inserting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic before a purchase order line record is inserted.
    /// </summary>
    public void inserting()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>inserted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic after a purchase order line record has been inserted.
    /// </summary>
    public void inserted()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyCalcDisc</Name>
				<Source><![CDATA[
    void interCompanyCalcDisc()
    {
        SalesTable                          salesTableLocal;
        SalesLine                           salesLineLocal;
        InterCompanyEndpointActionPolicy    salesEndpointActionPolicy;

        if (purchTable.InterCompanyCompanyId
        &&  purchTable.InterCompanySalesId
        &&  purchLine.InterCompanyInventTransId
        && !purchTable.isInvoiceMatched())
        {
            changecompany(purchTable.InterCompanyCompanyId)
            {
                ttsbegin;
                salesTableLocal           = SalesTable::find(purchTable.InterCompanySalesId,true);
                salesEndpointActionPolicy = salesTableLocal.interCompanyEndpointActionPolicy();
                if (salesEndpointActionPolicy.PriceDiscountSearch)
                {
                    salesLineLocal  = SalesLine::findInventTransId(purchLine.InterCompanyInventTransId);
                    salesTableLocal.PriceDiscHeading::updateMultiLineDiscount(salesLineLocal);
                    salesTableLocal.PriceDiscHeading::updateFinalDiscount(salesLineLocal);
                }
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyCreateReturnMarkupTrans</Name>
				<Source><![CDATA[
    protected void interCompanyCreateReturnMarkupTrans(AxSalesLine _axSalesLine)
    {
        //  Override for Return orders
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyDelete</Name>
				<Source><![CDATA[
    void interCompanyDelete()
    {
        SalesLine  salesLine;

        if (purchLine.SkipUpdate == InterCompanySkipUpdate::InterCompany
        ||  purchLine.SkipUpdate == InterCompanySkipUpdate::Both
        || !this.isPurchTableInterCompanyOrder()
        || !PurchTableType::construct(purchTable).interCompanyCreateAllowed())
            return;

        if (! TradeInterCompany::checkDataAreaAccess(purchTable.InterCompanyCompanyId))
            return;

        changecompany(purchTable.InterCompanyCompanyId)
        {
            setPrefix(strFmt("@SYS93821",TradeInterCompany::curCompanyName()));

            salesLine = SalesLine::findInventTransId(purchLine.InterCompanyInventTransId, true);

            if (salesLine)
            {
                salesLine.SkipUpdate = InterCompanySkipUpdate::InterCompany;

                if (!salesLine.validateDelete())
                {
                    throw error(strFmt("@WAX:IntercompanySalesLineDeleteError", salesLine.SalesId, salesLine.LineNum));
                }

                salesLine.delete();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyIsPriceDiscSearchNeeded</Name>
				<Source><![CDATA[
    public boolean interCompanyIsPriceDiscSearchNeeded()
    {
        boolean       ret = false;
        Object        callerFormRun;

        if (FormDataUtil::getFormDataSource(purchLine))
        {
            callerFormRun = FormDataUtil::getFormDataSource(purchLine).formRun();

            if (callerFormRun && formHasMethod(callerFormRun, identifierStr(interCompanyIsPriceDiscSearchNeeded)))
                ret = (purchLine.RecId == callerFormRun.interCompanyIsPriceDiscSearchNeeded());
        }

        ret = ret || purchLine.fieldChanged(fieldNum(PurchLine, PurchQty))
                  || purchLine.fieldChanged(fieldNum(PurchLine, PurchUnit))
                  || purchLine.fieldChanged(fieldNum(PurchLine, MatchingAgreementLine))
                  || purchLine.fieldChanged(fieldNum(PurchLine, DeliveryDate));

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyMarkupMirror</Name>
				<Source><![CDATA[
    void interCompanyMarkupMirror()
    {
        SalesLine   salesLine;
        MarkupTrans markupTrans;

        if (!this.isPurchTableInterCompanyOrder())
        {
            return;
        }

        changecompany(purchTable.InterCompanyCompanyId)
        {
            setPrefix(strFmt("@SYS93821",TradeInterCompany::curCompanyName()));

            salesLine = SalesLine::findInventTransId(purchLine.InterCompanyInventTransId);
            if (salesLine)
            {
                while select forupdate markupTrans
                      index hint TableRecIdIdx
                      where markupTrans.TransTableId == salesLine.TableId
                      &&    markupTrans.TransRecId   == salesLine.RecId
                      &&   !markupTrans.IsDeleted
                {
                    markupTrans.update();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanySyncEngine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the line-level synchronization engine for intercompany trade.
    /// </summary>
    /// <returns>A new instance of <c>InterCompanySyncPurchLineType</c> or one of its subclasses.</returns>
    public InterCompanySyncPurchLineType interCompanySyncEngine()
    {
        return InterCompanySyncPurchLineType::newFromPurchLineType(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyValidateDelete</Name>
				<Source><![CDATA[
    protected boolean interCompanyValidateDelete(SalesLine _salesLine)
    {
        boolean ret = true;
        setPrefix(strFmt("@SYS93821",TradeInterCompany::curCompanyName()));

        if (_salesLine)
        {
            setPrefix(#PreFixField(_salesLine,SalesId));

            _salesLine.SkipUpdate = InterCompanySkipUpdate::InterCompany;
            ret = _salesLine.validateDelete();
            if (ret)
            {
                WHSLoadLine loadLine;
                while select loadLine
                    where loadLine.InventTransId == _salesLine.InventTransId
                          && loadLine.InventTransType == InventTransType::Sales
                {
                    ret = loadLine.intercompanyValidateDelete();
                    if (!ret)
                    {
                        break;
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyValidateDeleteQty</Name>
				<Source><![CDATA[
    protected boolean interCompanyValidateDeleteQty(SalesLine _salesLine)
    {
        boolean ok = true;
        if (_salesLine)
        {
            if (ok && _salesLine.RemainSalesPhysical  != purchLine.RemainPurchPhysical)
                ok = checkFailed("@SYS13406");

            if (ok && _salesLine.RemainSalesFinancial != purchLine.RemainPurchFinancial)
                ok = checkFailed("@SYS13406");
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>internalCalendarId</Name>
				<Source><![CDATA[
    CalendarId internalCalendarId()
    {
        InventTable         inventTable         = InventTable::find(purchLine.ItemId);
        InventDim           inventDim           = InventDim::find(purchLine.InventDimId);
        ReqCovInventDimId   covInventDimId      = inventDim.reqCovDimId(InventDimGroupSetup::newInventTable(inventTable));
        ReqItemTable        reqItemTable        = ReqItemTable::find(purchLine.ItemId, covInventDimId);
        ReqGroup            reqGroup            = ReqGroup::defaultTable(inventTable.ReqGroupId, reqItemTable.ReqGroupId);
        CalendarId          internalCalendarId  = reqGroup.CalendarId;

        if (!internalCalendarId)
        {
            if (inventDim.InventLocationId)
            {
                internalCalendarId = InventLocation::find(inventDim.InventLocationId).ReqCalendarId;
            }
        }

        return internalCalendarId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoicedInTotal</Name>
				<Source><![CDATA[
    public PurchQty invoicedInTotal()
    {
        PurchQty qtyPurch = 0;

        if (purchLine.InventTransId)
        {
            qtyPurch = (select sum(Qty) from vendInvoiceTrans
                            where vendInvoiceTrans.InventTransId == purchLine.InventTransId).Qty;
        }

        return qtyPurch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoicedInTotalAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the sum of the posted <c>LineAmount</c> and <c>LineAmountMST</c> for a given <c>PurchLine</c>.
    /// </summary>
    /// <returns>
    /// A container with the sum <c>LineAmount</c> in element one and <c>LineAmountMST</c> in element two.
    /// </returns>
    public container invoicedInTotalAmount()
    {
        container   amts;
        VendInvoiceTrans    vendInvoiceTrans;

        if (purchLine.InventTransId)
        {
            select sum(LineAmount),sum(LineAmountMST) from vendInvoiceTrans
                            where vendInvoiceTrans.InventTransId == purchLine.InventTransId;
        }

        amts = [vendInvoiceTrans.LineAmount,vendInvoiceTrans.LineAmountMST];

        return amts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoicedInTotalAmountTax</Name>
				<Source><![CDATA[
    internal container invoicedInTotalAmountTax()
    {
        LineAmountTax lineAmountTax = 0;
        LineAmountTaxMST lineAmountTaxMST = 0;

        if (purchLine.InventTransId)
        {
            VendInvoiceTrans vendInvoiceTrans;
            VendInvoiceJour vendInvoiceJour;
            while select LineAmountTax from vendInvoiceTrans
                    where vendInvoiceTrans.OrigPurchId == purchLine.PurchId
                        && vendInvoiceTrans.PurchaseLineLineNumber == purchLine.LineNumber
                        && vendInvoiceTrans.InventTransId == purchLine.InventTransId
                join CurrencyCode, ExchRate, InvoiceDate, ExchRateSecondary, Triangulation from vendInvoiceJour
                    where vendInvoiceTrans.PurchId == vendInvoiceJour.PurchId
                        && vendInvoiceTrans.InvoiceId == vendInvoiceJour.InvoiceId
                        && vendInvoiceTrans.InvoiceDate == vendInvoiceJour.InvoiceDate
                        && vendInvoiceTrans.numberSequenceGroup == vendInvoiceJour.numberSequenceGroup
                        && vendInvoiceTrans.InternalInvoiceId == vendInvoiceJour.InternalInvoiceId
            {
                lineAmountTax += vendInvoiceTrans.LineAmountTax;
                lineAmountTaxMST += CurrencyExchangeHelper::amountCur2MST(
                    vendInvoiceTrans.LineAmountTax,
                    vendInvoiceJour.CurrencyCode,
                    vendInvoiceJour.ExchRate,
                    vendInvoiceJour.InvoiceDate,
                    vendInvoiceJour.ExchRateSecondary,
                    vendInvoiceJour.Triangulation);
            }
        }

        return [lineAmountTax, lineAmountTaxMST];
    }

]]></Source>
			</Method>
			<Method>
				<Name>isChangeRequestRequired</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether line changes require change request.
    /// </summary>
    /// <returns>
    /// true if line changes require change request; otherwise, false.
    /// </returns>
    boolean isChangeRequestRequired()
    {
        return purchTable.ChangeRequestRequired;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPendingRegistrationsToBeCreated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether pending registrations for non-stocked lines are to be newly created.
    /// </summary>
    /// <returns>
    /// A Boolean value that specifies if pending registrations are to be created.
    /// </returns>
    public boolean isPendingRegistrationsToBeCreated()
    {
        PurchLine purchLineOrig = purchLine.findApproved();

        return (purchLine.PurchQty > 0 && purchLineOrig.PurchQty <= 0)
            || (purchLine.PurchaseType == PurchaseType::Purch && purchLineOrig.PurchaseType != PurchaseType::Purch);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPurchTableInterCompanyOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether the purchase order in question is an intercompany type.
    /// </summary>
    /// <returns>
    ///     true if the purchase order is an intercompany type; otherwise, false.
    /// </returns>
    public boolean isPurchTableInterCompanyOrder()
    {
        if (!isInterCompanyOrderSet)
        {
            isPurchTableInterCompanyOrder   = purchTable.isInterCompanyOrder();
            isInterCompanyOrderSet          = true;
        }
        return isPurchTableInterCompanyOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies whether the line can have miscellaneous charges associated with it.
    /// </summary>
    /// <returns>
    /// Always returns true.
    /// </returns>
    public boolean markupAllowed()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultInventDirection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether it is per default an issue or a receipt transaction.
    /// </summary>
    /// <returns>
    /// The default inventory direction.
    /// </returns>
    public InventDirection defaultInventDirection()
    {
        return InventDirection::Receipt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>positiveInventDirection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether it is an issue or a receipt transaction for a positive quantity ordered amount.
    /// </summary>
    /// <returns>
    /// The inventory direction for positive quantities.
    /// </returns>
    public InventDirection positiveInventDirection()
    {
        return InventDirection::Receipt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustInventUpdEstimated</Name>
				<Source><![CDATA[
    boolean mustInventUpdEstimated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSyncDefaultInventDimFromSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the default inventory dimension id from the sales line should be used.
    /// </summary>
    /// <param name = "_axSalesLine">The <c>AxSalesLine</c> instance for which to set the inventory dimension id.</param>
    /// <returns>true if the default inventory dimension id from the sales line should be used; otherwise, false.</returns>
    protected boolean mustSyncDefaultInventDimFromSalesLine(AxSalesLine _axSalesLine)
    {
        boolean ret;

        if (_axSalesLine.axInventDim().parmInventDimId())
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateSalesLineOnDeletePurchLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the sales order line should be updated when the purchase order line is deleted.
    /// </summary>
    /// <returns>true if the sales order line should be updated; otherwise, false.</returns>
    public boolean mustUpdateSalesLineOnDeletePurchLine()
    {
        if (this.skipUpdateAndNoChangeRequired() || this.skipUpdateAndNoReferenceLot())
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new(PurchLine _purchLine, PurchTable _purchTable = _purchLine.purchTable())
    {
        purchLine       = _purchLine;
        purchTable      = _purchTable;

        super(purchLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPurchLine</Name>
				<Source><![CDATA[
    public PurchLine parmPurchLine()
    {
        return purchLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPurchTable</Name>
				<Source><![CDATA[
    public PurchTable parmPurchTable()
    {
        return purchTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmStatusUpdateResults</Name>
				<Source><![CDATA[
    public PurchStatus parmStatusUpdateResults(PurchStatus _statusUpdateResults = statusUpdateResults)
    {
        statusUpdateResults = _statusUpdateResults;
        return statusUpdateResults;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsApprovedVendorListCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get an instance of PdsApprovedVendorListCheck appropriate for this line type.
    /// </summary>
    /// <returns>
    /// Instance of PdsApprovedVendorListCheck appropriate for this line type.
    /// </returns>
    /// <remarks>
    /// The base implementation in PurchLineType always returns an instance of
    /// PdsApprovedVendorListCheck_Valid.
    /// </remarks>
    public PdsApprovedVendorListCheck pdsApprovedVendorListCheck()
    {
        return PdsApprovedVendorListCheck_AllValid::construct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWInvoicedInTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates catch weight total invoiced quantity for the current purchase order line.
    /// </summary>
    /// <returns>
    /// Catch weight invoiced quantity.
    /// </returns>
    public PdsCWInvoiced pdsCWInvoicedInTotal()
    {
        InventTransIdSum    inventTransIdSum;
        PdsCWInventQty      pdsCWQty;

        if (purchLine.InventTransId && purchLine.isStocked())
        {
            inventTransIdSum = InventTransIdSum::newTransOriginId(
                InventTransOriginPurchLine::findInventTransOriginId(purchLine.DataAreaId, purchLine.InventTransId));

            pdsCWQty = inventTransIdSum.pdsCWFinancial();
        }

        return pdsCWQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWReceivedInTotal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates catch weight total received quantity for the current purchase order line.
    /// </summary>
    /// <returns>
    /// Catch weight received quantity.
    /// </returns>
    public PdsCWInventQty pdsCWReceivedInTotal()
    {
        InventTransIdSum    inventTransIdSum;
        PdsCWInventQty      pdsCWQty;

        if (purchLine.InventTransId && purchLine.isStocked())
        {
            inventTransIdSum = InventTransIdSum::newTransOriginId(
                InventTransOriginPurchLine::findInventTransOriginId(purchLine.DataAreaId, purchLine.InventTransId));

            pdsCWQty = (inventTransIdSum.pdsCWPhysical() + inventTransIdSum.pdsCWFinancial());
        }

        return pdsCWQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchQtyAllowEdit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies whether the <c>Quantity</c> field can be edited.
    /// </summary>
    /// <returns>
    /// true if the <c>Quantity</c> field can be edited; otherwise, false.
    /// </returns>
    boolean purchQtyAllowEdit()
    {
        return PriceDiscPolicyRule::createInstance(purchLine).launchPolicyDialogForAllPolicyFields(false, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPurchQtyIsEditable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the <c>Quantity</c> field is editable.
    /// </summary>
    /// <returns>true if the <c>Quantity</c> field can be edited; otherwise, false.</returns>
    public boolean checkPurchQtyIsEditable()
    {
        return this.purchQtyAllowEdit();
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTableSelectForupdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Ensures the <c>PurchTable</c> buffer is selected for update when the class member Boolean update is true.
    /// </summary>
    /// <returns>
    ///     A <c>PurchTable</c> buffer selected for update.
    /// </returns>
    protected PurchTable purchTableSelectForupdate()
    {
        if (!purchTable.selectForUpdate())
        {
            purchTable = purchLine.purchTable(true);
        }
        return purchTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recalculateDeliveryScheduleOrderLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Recalculates the <c>Quantity</c> field as a sum of the <c>Quantity</c> fields on all the delivery
    /// lines and delivery dates and as a minimum of corresponding dates on delivery lines.
    /// </summary>
    /// <param name = "_purchLineOrig">
    /// The original purchase order line which is updated.
    /// </param>
    /// <remarks>
    /// If the <c>Quantity</c> field has to be changed and the line does not have an agreement reference,
    /// it resets the commercial attributes by looking for trade agreements.
    /// </remarks>
    public void recalculateDeliveryScheduleOrderLine(PurchLine _purchLineOrig)
    {
        throw error(error::missingOverride(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>receivedInTotal</Name>
				<Source><![CDATA[
    PurchQty   receivedInTotal()
    {
        PurchQty   qtyPurch;

        if (purchLine.InventTransId)
        {
            qtyPurch   = (select sum(QtyPhysical) from vendInvoiceTrans
                            index hint TransIdIdx
                            where vendInvoiceTrans.InventTransId == purchLine.InventTransId).QtyPhysical;

            qtyPurch  += purchLine.receivedOnPackingSlipInTotal();
        }

        return qtyPurch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeSalesLineReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates inventory information on the sales order line if the purchase order line is deleted.
    /// </summary>
    /// <param name = "_salesLine">The sales order line to update.</param>
    /// <param name = "_purchLineDeleted">true if the purchase order line is deleted; otherwise, false.</param>
    protected void removeSalesLineReservation(SalesLine _salesLine, boolean _purchLineDeleted)
    {
        if (_salesLine.isStocked())
        {
            InventMovement movement = InventMovement::construct(_salesLine);

            if (movement.transIdSum().reserved())
            {
                InventUpd_Reservation reservation = InventUpd_Reservation::newParameters(movement,null,null,0,-movement.transIdSum().reserved(),true);
                reservation.updateNow();
            }

            InventUpd_Reservation::updateReserveRefTransId(movement);
        }

        if (_purchLineDeleted)
        {
            _salesLine.clearInventReference();
            _salesLine.DeliveryType = TradeLineDlvType::None;
            _salesLine.SourcingOrigin = SalesSourcingOrigin::Inventory;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>returnExpectedRetQty</Name>
				<Source><![CDATA[
    protected ReturnExpectedRetQty returnExpectedRetQty(SalesQty _salesQty)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPriceDiscChangePolicyMultiLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Applies a multi line discount related price discount change policy to the related header record.
    /// </summary>
    public void setPriceDiscChangePolicyMultiLine()
    {
        if (PriceDiscPolicyMakePolicy::construct().checkPolicyParmSetup(PriceDiscSystemSource::ManualEntry, ModuleSalesPurch::Purch)
            && !purchLine.purchTable().PriceDiscResultFields::multiLineDiscPolicyExist())
        {
            PurchTable purchTableLocal;
            
            ttsbegin;

            purchTableLocal = this.purchTableSelectForupdate();
            purchTableLocal.setPriceDiscChangePolicyMultiLine();
            purchTableLocal.write();

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePurchStatus</Name>
				<Source><![CDATA[
    /// <summary>Sets the status of the <c>PurchLine</c></summary>
    /// <param name="_purchLineOrig">
    /// The original purchase order line which is updated.
    /// </param>
    /// <param name="_inventTransIdSum">
    /// InventTrans Id sum class
    /// </param>
    /// <param name="_updateHeader">
    /// Specifies whether order header status should be updated in effect of line status change
    /// </param>
    public void updatePurchStatus(PurchLine _purchLineOrig, InventTransIdSum  _inventTransIdSum, boolean _updateHeader)
    {
        InventTransIdSum inventTransIdSum = _inventTransIdSum;

        if (purchLine.isStocked())
        {
            if (purchLine.isCanceled() && purchLine.RemainPurchPhysical == 0 && purchLine.RemainPurchFinancial == 0)
            {
                if (!inventTransIdSum)
                {
                    inventTransIdSum = InventTransIdSum::newTransOriginId(InventTransOriginPurchLine::findInventTransOriginId(purchLine.DataAreaId, purchLine.InventTransId));
                }

                if (inventTransIdSum.physical() == 0 && inventTransIdSum.financial() == 0)
                {
                    if (this.statusChangeAllowed(purchLine, PurchStatus::Canceled))
                    {
                        return;
                    }
                    else
                    {
                        // PurchLine is presently canceled and never had any activity against it, but user has added a pending invoice.
                        purchLine.PurchStatus = PurchStatus::Backorder;
                        return;
                    }
                }
            }
        }

        ttsbegin;

        if (purchLine.isStocked())
        {
            this.setPurchStatusStocked(_purchLineOrig, inventTransIdSum);
        }
        else
        {
            this.setPurchStatusNonStocked(purchLine);
        }

        if (!purchLine.checkStatusChange())
        {
            throw error("@SYS18738");
        }

        if (_updateHeader && purchLine.PurchStatus != _purchLineOrig.PurchStatus)
        {
            purchLine.update();
            purchLine.purchTable(true).updateStatusFromPurchLines();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPurchStatusNonStocked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the purchase status for a non stocked purchase line.
    /// </summary>
    /// <param name="_purchLine">
    /// The purchase line for which to set the status.
    /// </param>
    protected void setPurchStatusNonStocked(PurchLine _purchLine)
    {
        VendInvoiceTrans     vendInvoiceTrans;

        if (_purchLine.isCanceled() && _purchLine.RemainPurchPhysical == 0 && _purchLine.RemainPurchFinancial == 0)
        {
            select sum(Qty) from vendInvoiceTrans
                where vendInvoiceTrans.InventTransId     == _purchLine.InventTransId;

            if (vendInvoiceTrans.Qty == 0 && _purchLine.receivedOnPackingSlipInTotal() == 0)
            {
                if (this.statusChangeAllowed(_purchLine, PurchStatus::Canceled))
                {
                    return;
                }
                else
                {
                    // PurchLine is presently canceled and never had any activity against it, but user has added a pending invoice.
                    _purchLine.PurchStatus = PurchStatus::Backorder;
                    return;
                }
            }
        }

        if (_purchLine.PurchQty == 0 && _purchLine.orig().PurchQty == 0)
        {
            _purchLine.PurchStatus = PurchStatus::Backorder;
        }
        else
        {
            if (_purchLine.RemainPurchPhysical  == 0 && _purchLine.RemainPurchFinancial == 0)
            {
                select sum(Qty) from vendInvoiceTrans
                    where vendInvoiceTrans.InventTransId     == _purchLine.InventTransId;

                if (vendInvoiceTrans.Qty == 0)
                {
                    if (this.statusChangeAllowed(_purchLine, PurchStatus::Canceled))
                    {
                        _purchLine.PurchStatus = PurchStatus::Canceled;
                    }
                    else
                    {
                        _purchLine.PurchStatus = PurchStatus::Backorder;
                    }
                }
                else
                {
                    if (this.statusChangeAllowed(_purchLine, PurchStatus::Invoiced))
                    {
                        _purchLine.PurchStatus = PurchStatus::Invoiced;
                    }
                    else
                    {
                        _purchLine.PurchStatus = PurchStatus::Backorder;
                    }
                }
            }
            else
            {
                if (_purchLine.RemainPurchPhysical == 0)
                {
                    _purchLine.PurchStatus = PurchStatus::Received;
                }
                else
                {
                    _purchLine.PurchStatus = PurchStatus::Backorder;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPurchStatusStocked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the purchase status for a stocked purchase order line.
    /// </summary>
    /// <param name="_purchLineOrig">The original purchase order line which is updated.</param>
    /// <param name="_inventTransIdSum">An <c>InventTransIdSum</c> instance.</param>
    protected void setPurchStatusStocked(PurchLine _purchLineOrig, InventTransIdSum _inventTransIdSum)
    {
        InventTransIdSum inventTransIdSum = _inventTransIdSum;

        if (purchLine.QtyOrdered == 0 && _purchLineOrig.QtyOrdered == 0)
        {
            purchLine.PurchStatus = PurchStatus::Backorder;
        }
        else
        {
            if (purchLine.RemainPurchPhysical  == 0 && purchLine.RemainPurchFinancial == 0)
            {
                if (!inventTransIdSum)
                {
                    inventTransIdSum = InventTransIdSum::newTransOriginId(InventTransOriginPurchLine::findInventTransOriginId(purchLine.DataAreaId, purchLine.InventTransId));
                }

                if (inventTransIdSum.physical() == 0 && inventTransIdSum.financial() == 0)
                {
                    if (this.statusChangeAllowed(purchLine, PurchStatus::Canceled))
                    {
                        purchLine.PurchStatus = PurchStatus::Canceled;
                    }
                    else
                    {
                        purchLine.PurchStatus = PurchStatus::Backorder;
                    }
                }
                else
                {
                    if (inventTransIdSum.financial() == 0)
                    {
                        if (this.statusChangeAllowed(purchLine, PurchStatus::Canceled))
                        {
                            purchLine.PurchStatus = PurchStatus::Canceled;
                        }
                        else
                        {
                            purchLine.PurchStatus = PurchStatus::Backorder;
                        }
                    }
                    else
                    {
                        if (this.statusChangeAllowed(purchLine, PurchStatus::Invoiced))
                        {
                            purchLine.PurchStatus = PurchStatus::Invoiced;
                        }
                        else
                        {
                            purchLine.PurchStatus = PurchStatus::Backorder;
                        }
                    }
                }
            }
            else
            {
                if (purchLine.RemainPurchPhysical == 0)
                {
                    purchLine.PurchStatus = PurchStatus::Received;
                }
                else
                {
                    purchLine.PurchStatus = PurchStatus::Backorder;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>statusChangeAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether it is allowed to change the purchase status for a purchase order line.
    /// </summary>
    /// <param name = "_purchLine">The purchase order line for which to change the purchase status.</param>
    /// <param name = "_requestedStatus">The requested purchase status.</param>
    /// <returns>true if it is allowed to change the purchase status for the relevant purchase order line; otherwise, false.</returns>
    protected boolean statusChangeAllowed(PurchLine _purchLine, PurchStatus _requestedStatus)
    {
        boolean statusChangeAllowed = true;

        if (PurchLineTypeValidationContextFlight::instance().isEnabled())
        {
            PurchLineTypeValidationContext context = PurchLineTypeValidationContext::current();

            if (context && context.parmSkipPendingInvoiceStatusValidation())
            {
                return statusChangeAllowed;
            }
        }

        VendInvoiceInfoLine vendInvoiceInfoLine;
        VendInvoiceInfoTable vendInvoiceInfoTable;

        select firstonly RecId from vendInvoiceInfoLine
            where vendInvoiceInfoLine.InventTransId == _purchLine.InventTransId
                && vendInvoiceInfoLine.ParmId == ''
            exists join vendInvoiceInfoTable
                where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLine.ParmId
                    && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLine.TableRefId
                    && vendInvoiceInfoTable.ParmJobStatus != ParmJobStatus::Executed;

        if (vendInvoiceInfoLine)
        {
            this.parmStatusUpdateResults(_requestedStatus);
            statusChangeAllowed = false;
        }

        return statusChangeAllowed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setStockedProduct</Name>
				<Source><![CDATA[
    [Hookable()]
    /// <summary>
    /// Sets the <c>StockedProduct</c> field for the line based on line type and item model group for the associated item.
    /// </summary>
    public void setStockedProduct()
    {
        InventModelGroup inventModelGroup;

        if (purchLine.isCategoryBased())
        {
            purchLine.StockedProduct = NoYes::No;
        }
        else
        {
            inventModelGroup = InventTable::find(purchLine.ItemId).modelGroup();
            purchLine.StockedProduct = inventModelGroup.isStocked()? NoYes::Yes : NoYes::No;
        }

        // <GBR>
        if (BrazilParameters::isEnabled() && purchLine.StockedProduct)
        {
            purchLine.StockedProduct = purchTable.createInventTrans_BR();
        }
        // </GBR>
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxGroup</Name>
				<Source><![CDATA[
    void setTaxGroup(TaxGroup  _taxGroup)
    {
        purchLine.TaxGroup = _taxGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>syncSalesLine</Name>
				<Source><![CDATA[
    AxSalesLine syncSalesLine(PurchLine _purchLine, SalesLine _salesLine = null, boolean _create = false)
    {
        SalesTable                                  salesTable;
        SalesLine                                   salesLine        = SalesLine::findInventTransId(_purchLine.InventRefTransId, true);
        InterCompanyEndpointActionPolicyTransfer    transferInternal = purchTable.interCompanyEndpointActionPolicy().getOrCreateInterCompanyPolicyTransfer(InterCompanyFieldTransferType::Internal);
        boolean                                     create           = _create;

        AxSalesLine axSalesLine = this.constructAxSalesLine(_purchLine, _salesLine);

        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().purchaseOrderTypeActivities().syncSalesLine(_purchLine, _salesLine, transferInternal))
        {
            if (axSalesLine.salesLine().RecId == 0)
                create = true;

            if (!axSalesLine.salesLine().RecId)
            {
                salesTable = SalesTable::find(purchTable.InterCompanyOriginalSalesId);
            
                // SalesLine is initiated from the PurchLine
                salesLine.clear();
                salesLine.initValue(salesTable.SalesType);
                salesLine.initFromSalesTable(salesTable);
                salesLine.initFromPurchLine(_purchLine);
                salesLine.LineNum = any2real(_purchLine.LineNumber);

                salesLine.DeliveryType      = _purchLine.DeliveryType;

                if (salesLine.SourcingVendAccount != purchLine.VendAccount)
                {
                    salesLine.SourcingVendAccount = purchLine.VendAccount;
                    salesLine.modifiedField(FieldNum(SalesLine, SourcingVendAccount));
                }

                if (purchTable.InterCompanyDirectDelivery)
                {
                    InventDim inventDim = salesLine.inventDim();
                    inventDim.InventLocationId = _purchLine.inventDim().InventLocationId
                                               ? _purchLine.inventDim().InventLocationId
                                               :  salesLine.inventDim().InventLocationId;
                    inventDim.initFromInventLocation(inventDim.inventLocation());
                    salesLine.setInventDimIdFromInventDim(inventDim);
                    salesLine.SalesUnit      = _purchLine.PurchUnit;
                    salesLine.SalesQty       = _purchLine.RemainPurchPhysical;
                    salesLine.QtyOrdered     = salesLine.calcQtyOrdered();
                    salesLine.ExpectedRetQty = this.returnExpectedRetQty(salesLine.SalesQty);
                }
            
                // A price search is performed when the SalesLine is created
                salesLine.setPriceDisc(salesLine.inventDim());
                axSalesLine.salesLine(salesLine);

                axSalesLine.parmSalesPrice          (axSalesLine.salesLine().SalesPrice);
                axSalesLine.parmSalesUnit           (axSalesLine.salesLine().SalesUnit);
                axSalesLine.parmSalesMarkup         (axSalesLine.salesLine().SalesMarkup);
                axSalesLine.parmLinePercent         (axSalesLine.salesLine().LinePercent);
                axSalesLine.parmLineDisc            (axSalesLine.salesLine().LineDisc);
                axSalesLine.parmMultiLnPercent      (axSalesLine.salesLine().MultiLnPercent);
                axSalesLine.parmMultiLnDisc         (axSalesLine.salesLine().MultiLnDisc);
                axSalesLine.parmSourcingVendAccount (axSalesLine.salesLine().SourcingVendAccount);
            }

            if (this.mustSyncDefaultInventDimFromSalesLine(axSalesLine))
            {
                // always set the inventDimId on the axSalesLine, so item dimensions are not overwritten by axClass defaulting
                axSalesLine.parmInventDimId(axSalesLine.axInventDim().parmInventDimId());
            }
            else
            {
                this.initializeInventDimFromSalesLine(axSalesLine, _purchLine, _create);
            }

            if (_purchLine.fieldChanged(fieldNum(PurchLine, DeliveryType)))
            {
                axSalesLine.parmDeliveryType(_purchLine.DeliveryType);
            }

            if (purchTable.InterCompanyDirectDelivery)
            {
                if (_purchLine.fieldChanged(fieldNum(PurchLine, PurchQty)))
                {
                    axSalesLine.parmSalesQty(_purchLine.PurchQty);
                    axSalesLine.parmExpectedRetQty(this.returnExpectedRetQty(_purchLine.PurchQty));
                }

                if (_purchLine.fieldChanged(fieldNum(PurchLine, PurchUnit)))
                    axSalesLine.parmSalesUnit(_purchLine.PurchUnit);
            }

            if (create || _purchLine.fieldChanged(fieldNum(PurchLine, ReturnDispositionCodeId)))
                axSalesLine.parmReturnDispositionCodeId(_purchLine.ReturnDispositionCodeId);

            if (create || _purchLine.fieldChanged(fieldNum(PurchLine, ReturnStatus)))
                axSalesLine.parmReturnStatus(_purchLine.ReturnStatus);

            if (_purchLine.ReturnDispositionCodeId
            &&  ReturnDispositionCode::find(_purchLine.ReturnDispositionCodeId).setPrice2Zero())
            {
                // Set price to 0, when return disposition code says so
                axSalesLine.parmSalesPrice    (0);
                axSalesLine.parmSalesMarkup   (0);
                axSalesLine.parmLinePercent   (0);
                axSalesLine.parmLineDisc      (0);
                axSalesLine.parmMultiLnPercent(0);
                axSalesLine.parmMultiLnDisc   (0);
            }
            else if (_purchLine.ReturnDispositionCodeId
                 &&  ReturnDispositionCode::find(_purchLine.ReturnDispositionCodeId).createReplacement()
                 &&  _purchLine.PurchQty > 0)
            {
                //  Perform price search Set price to 0, when return disposition code says so
                axSalesLine.salesLine().setPriceDisc(axSalesLine.salesLine().inventDim());
                axSalesLine.parmSalesPrice    (axSalesLine.salesLine().SalesPrice);
                axSalesLine.parmSalesUnit     (axSalesLine.salesLine().SalesUnit);
                axSalesLine.parmSalesMarkup   (axSalesLine.salesLine().SalesMarkup);
                axSalesLine.parmLinePercent   (axSalesLine.salesLine().LinePercent);
                axSalesLine.parmLineDisc      (axSalesLine.salesLine().LineDisc);
                axSalesLine.parmMultiLnPercent(axSalesLine.salesLine().MultiLnPercent);
                axSalesLine.parmMultiLnDisc   (axSalesLine.salesLine().MultiLnDisc);
            }
            else
            {
                boolean notExistIntercompanyDirectDeliveryPurchaseLine = this.notExistIntercompanyPurchaseLineForDirectDelivery(_purchLine, axSalesLine);

                if (transferInternal.PriceDiscount)
                {
                    if (notExistIntercompanyDirectDeliveryPurchaseLine
                        && InterCompanySyncPriceAndDiscountOnLineFlight::instance().isEnabled())
                    {
                        // The intercompany purchase order line is not inserted yet, the sync should happen after super call.
                        axSalesLine.parmSkipUpdate(InterCompanySkipUpdate::InterCompany);
                    }

                    // Synchronize prices from the PurchLine, when settings says so
                    axSalesLine.parmSalesPrice    (ExchangeRateHelper::curPrice2CurPrice(_purchLine.PurchPrice, _purchLine.CurrencyCode, axSalesLine.salesLine().CurrencyCode));
                    axSalesLine.parmPriceUnit     (_purchLine.PriceUnit);
                    axSalesLine.parmSalesMarkup   (ExchangeRateHelper::curPrice2CurPrice(_purchLine.PurchMarkup, _purchLine.CurrencyCode, axSalesLine.salesLine().CurrencyCode));
                    axSalesLine.parmLinePercent   (_purchLine.LinePercent);
                    axSalesLine.parmLineDisc      (ExchangeRateHelper::curPrice2CurPrice(_purchLine.LineDisc, _purchLine.CurrencyCode, axSalesLine.salesLine().CurrencyCode));
                    axSalesLine.parmMultiLnPercent(_purchLine.MultiLnPercent);
                    axSalesLine.parmMultiLnDisc   (ExchangeRateHelper::curPrice2CurPrice(_purchLine.MultiLnDisc, _purchLine.CurrencyCode, axSalesLine.salesLine().CurrencyCode));
                }
                else
                {
                    // Set prices to the existing values, to prevent a setting in the axSalesLine class
                    axSalesLine.parmSalesPrice    (axSalesLine.salesLine().SalesPrice);
                    axSalesLine.parmSalesUnit     (axSalesLine.salesLine().SalesUnit);
                    axSalesLine.parmSalesMarkup   (axSalesLine.salesLine().SalesMarkup);
                    axSalesLine.parmLinePercent   (axSalesLine.salesLine().LinePercent);
                    axSalesLine.parmLineDisc      (axSalesLine.salesLine().LineDisc);
                    axSalesLine.parmMultiLnPercent(axSalesLine.salesLine().MultiLnPercent);
                    axSalesLine.parmMultiLnDisc   (axSalesLine.salesLine().MultiLnDisc);
                }

                if (axSalesLine.parmSkipUpdate() != InterCompanySkipUpdate::InterCompany
                    && notExistIntercompanyDirectDeliveryPurchaseLine
                    && PurchParameters::find().IsSupplierShipmentDatesEnabled
                    && PurchIntercompanyPurchaseOriginWithTransportDaysFlight::instance().isEnabled())
                {
                    axSalesLine.parmSkipUpdate(InterCompanySkipUpdate::InterCompany);
                }
            }            

            if (transferInternal.PriceDiscount
            &&  axSalesLine.isPriceDisc_FieldsEmpty()
            && (create || _purchLine.fieldChanged(fieldNum(PurchLine, LineAmount))))
                axSalesLine.parmLineAmount(CurrencyExchangeHelper::curAmount2CurAmount(_purchLine.LineAmount, _purchLine.CurrencyCode, axSalesLine.salesLine().CurrencyCode));
            else
                axSalesLine.parmLineAmount(axSalesLine.salesLine().calcLineAmount());

            if (!create && transferInternal.PriceDiscount)
            {
                axSalesLine.salesLine().setManualEntryChangePolicyFromPurchLine(_purchLine);
            }

            if (purchTable.InterCompanyDirectDelivery)
            {
                if (new DictConfigurationKey(configurationKeyNum(SalesDeliveryDateControl)).enabled())
                {
                    axSalesLine.parmReceiptDateRequested (_purchLine.DeliveryDate);
                    axSalesLine.parmReceiptDateConfirmed (_purchLine.ConfirmedDlv);
                    axSalesLine.parmShippingDateRequested(_purchLine.ShippingDateRequested ? _purchLine.ShippingDateRequested : _purchLine.DeliveryDate);
                    axSalesLine.parmShippingDateConfirmed(_purchLine.ShippingDateConfirmed ? _purchLine.ShippingDateConfirmed : _purchLine.ConfirmedDlv);
                }
                else
                {
                    axSalesLine.parmShippingDateRequested(_purchLine.DeliveryDate);
                    axSalesLine.parmShippingDateConfirmed(_purchLine.ConfirmedDlv);
                }

                if (PurchParameters::find().IsSupplierShipmentDatesEnabled && _purchLine.RequestedShipDate)
                {
                    axSalesLine.parmShippingDateRequested(_purchLine.RequestedShipDate);
                }

                if (create
                ||  _purchLine.fieldChanged(fieldNum(PurchLine, OverDeliveryPct)))
                    axSalesLine.parmOverDeliveryPct(_purchLine.OverDeliveryPct);

                if (create
                ||  _purchLine.fieldChanged(fieldNum(PurchLine, UnderDeliveryPct)))
                    axSalesLine.parmUnderDeliveryPct(_purchLine.UnderDeliveryPct);

                if (create
                ||  _purchLine.fieldChanged(fieldNum(PurchLine, Complete)))
                    axSalesLine.parmComplete(_purchLine.Complete);

                if (create
                ||  _purchLine.fieldChanged(fieldNum(PurchLine, Blocked)))
                    axSalesLine.parmBlocked(_purchLine.Blocked);
            }
            else if (_purchLine.isDropShipment())
            {
                if (create
                ||  _purchLine.fieldChanged(fieldNum(PurchLine, OverDeliveryPct)))
                    axSalesLine.parmOverDeliveryPct(_purchLine.OverDeliveryPct);

                if (create
                || _purchLine.fieldChanged(fieldNum(PurchLine, UnderDeliveryPct)))
                   axSalesLine.parmUnderDeliveryPct(_purchLine.UnderDeliveryPct);

                if (create
                || _purchLine.fieldChanged(fieldNum(PurchLine, RemainInventPhysical)))
                   axSalesLine.parmRemainInventPhysical(_purchLine.RemainInventPhysical);

                if (create
                || _purchLine.fieldChanged(fieldNum(PurchLine, RemainPurchPhysical)))
                   axSalesLine.parmRemainSalesPhysical(_purchLine.RemainPurchPhysical);

                if (PurchParameters::find().IsSupplierShipmentDatesEnabled)
                {
                    axSalesLine.parmShippingDateRequested(_purchLine.RequestedShipDate ? _purchLine.RequestedShipDate : axSalesLine.salesLine().ShippingDateRequested);
                    axSalesLine.parmReceiptDateRequested(_purchLine.DeliveryDate ? _purchLine.DeliveryDate : axSalesLine.salesLine().ReceiptDateRequested);
                    axSalesLine.parmShippingDateConfirmed(_purchLine.ConfirmedShipDate ? _purchLine.ConfirmedShipDate : _purchLine.ConfirmedDlv);
                }
                else
                {
                    axSalesLine.parmShippingDateRequested(axSalesLine.salesLine().ShippingDateRequested);
                    axSalesLine.parmReceiptDateRequested(axSalesLine.salesLine().ReceiptDateRequested);
                    axSalesLine.parmShippingDateConfirmed(_purchLine.ConfirmedDlv);
                }

                axSalesLine.parmReceiptDateConfirmed(_purchLine.ConfirmedDlv);

                // Keep integrity for the drop ship comment from SO to PO
                if (create
                    ||  _purchLine.fieldChanged(fieldNum(PurchLine, mcrDropShipComment)))
                {
                    AxMCRSalesLineDropShipment  axMCRSalesLineDropShipment = AxMCRSalesLineDropShipment::construct();
                    axMCRSalesLineDropShipment.parmDropShipComment(_purchLine.mcrDropShipComment);
                }
            }
            else if (axSalesLine.salesLine().InterCompanyOrigin == InterCompanyOrigin::Derived)
            {
                if (create || _purchLine.fieldChanged(fieldNum(PurchLine, DeliveryDate)))
                {
                    LeadTime leadTimeInternal = IntercompanySalesCalcAvailableDlvDates_SalesLine::safetyMarginLeadTimeForSourcingPurchaseLine(_purchLine);

                    if (PurchParameters::find().IsSupplierShipmentDatesEnabled && _purchLine.RequestedShipDate)
                    {
                        axSalesLine.parmShippingDateRequested(_purchLine.RequestedShipDate + leadTimeInternal);
                    }
                    else
                    {
                        axSalesLine.parmShippingDateRequested(_purchLine.DeliveryDate + leadTimeInternal);
                    }
                }

                if (create
                    && new DictConfigurationKey(configurationKeyNum(SalesDeliveryDateControl)).enabled())
                {
                    SalesLine salesLineLocal;
                    buf2Buf(axSalesLine.salesLine(),salesLineLocal);

                    if (salesTable)
                    {
                        salesLineLocal.initFromSalesTable(salesTable);
                    }

                    salesLineLocal.InventDimId             = InventDim::findOrCreate(axSalesLine.salesLine().inventDim()).InventDimId;
                    salesLineLocal.ReceiptDateConfirmed    = axSalesLine.salesLine().ReceiptDateConfirmed;
                    salesLineLocal.ReceiptDateRequested    = axSalesLine.salesLine().ReceiptDateRequested;
                    salesLineLocal.ShippingDateConfirmed   = axSalesLine.salesLine().ShippingDateConfirmed;
                    salesLineLocal.ShippingDateRequested   = axSalesLine.salesLine().ShippingDateRequested;
                    salesLineLocal.DeliveryDateControlType = axSalesLine.salesLine().DeliveryDateControlType;

                    SalesCalcAvailableDlvDates salesCalcAvailableDlvDates = SalesCalcAvailableDlvDates::newCommonSalesDlvDateType(salesLineLocal);
                    if (salesCalcAvailableDlvDates.validateWritePrompt(salesLineLocal,false,true,true))
                        axSalesLine.parmShippingDateConfirmed(salesLineLocal.ShippingDateConfirmed);
                    else
                        axSalesLine.parmShippingDateConfirmed(purchLine.DeliveryDate);
                }
            }

            if (axSalesLine.salesLine().DeliveryType == TradeLineDlvType::DropShip)
            {
                PurchLineType::syncDeliveryAddress(_purchLine, axSalesLine);
            }

            axSalesLine.parmLineAmount(axSalesLine.salesLine().calcLineAmount());

            if (!create
                && (!PurchLineTypeIntercompanySetSourcingSiteWarehouseFlight::instance().isEnabled()
                    || this.shouldResetSourcingInformation(axSalesLine, _purchLine)))
            {
                axSalesLine.parmSourcingInventSiteId(_purchLine.IntercompanyOSOSourcingInventSiteId);
                axSalesLine.parmSourcingInventLocationId(_purchLine.IntercompanyOSOSourcingInventLocationId);
            }

            if (create || _purchLine.fieldChanged(fieldNum(PurchLine, PlanningPriority)))
            {
                axSalesLine.parmPlanningPriority(_purchLine.PlanningPriority);
            }

            activityContext
                .addCustomProperty('Create', int2Str(create))
                .addCustomProperty('SkipUpdate', enum2Symbol(enumNum(InterCompanySkipUpdate), axSalesLine.parmSkipUpdate()))
                .addCustomProperty('InterCompanyDirectDelivery', int2Str(purchTable.InterCompanyDirectDelivery));
        }

        return axSalesLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldResetSourcingInformation</Name>
				<Source><![CDATA[
    private boolean shouldResetSourcingInformation(AxSalesLine _axSalesLine, PurchLine _purchLine)
    {
        return (_axSalesLine.salesLine().SourcingOrigin == SalesSourcingOrigin::Intercompany
                && (_purchLine.fieldChanged(fieldNum(PurchLine, IntercompanyOSOSourcingInventSiteId))
                    || _purchLine.fieldChanged(fieldNum(PurchLine, IntercompanyOSOSourcingInventLocationId))));
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveSynchronizedSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves synchronized sales order line maintained based on purchase order line.
    /// </summary>
    /// <param name = "_purchLineOrig">
    /// The original purchase order line which is saved.
    /// </param>
    /// <param name = "_create">
    /// True, if purchase order line is being created; otherwise, false.
    /// </param>
    public void saveSynchronizedSalesLine(PurchLine _purchLineOrig, boolean _create)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().purchaseOrderTypeActivities().saveSynchronizedSalesLine(_purchLineOrig))
        {
            AxSalesLine     axSalesLine;
            PurchTable      purchTableLocal;
            SalesTable      salesTable;

            if (!purchLine)
                return;

            if (purchLine.SkipUpdate == InterCompanySkipUpdate::Internal
            || purchLine.SkipUpdate == InterCompanySkipUpdate::Both)
                return;

            purchTableLocal = purchLine.purchTable();
            //
            // When purchase order is NOT intercompany && NOT direct delivery, the sales order line must not be updated
            //
            if (!this.isPurchTableInterCompanyOrder()
                &&  !purchLine.isDropShipment()
                && (!PurchParameters::find().DeliveryInfoSyncOnUpdateStock
                    || !SalesPurchSyncDeliveryInfoFeature::instance().isEnabled()))
                return;


            if (!purchTableLocal.InterCompanyOriginalSalesId
                && purchLine.creditNoteLine()
                && purchLine.InventRefId)
            {
                return;
            }

            //
            // When NON intercompany purchase order without attached original sales order line
            //
            if (!purchTableLocal.InterCompanyOriginalSalesId && !purchLine.InventRefTransId)
            {
                if (IntercompanyAutoCreatePurchaseOrderFeature::instance().isEnabled()
                    && IntercompanyAddAutoCreatePOParameterFlight::instance().isEnabled()
                    && PurchParameters::find().InterCompanyAutoCreatePurchaseOrder
                    && this.isPurchTableInterCompanyOrder()
                    && TradeInterCompany::checkDataAreaAccess(purchTableLocal.InterCompanyCompanyId, false)
                    && new SalesTableForm(purchTableLocal.interCompanySalesTable()).canInterCompanyAutoCreateOrders())
                {
                    SalesLine intercompanySalesLine = purchLine.interCompanySalesLine();
                    changecompany(purchTableLocal.InterCompanyCompanyId)
                    {
                        if (!PurchLineTypeSkipAutoCreateOrderIfAlreadyCreatedFlight::instance().isEnabled()
                            || !intercompanySalesLine.sourcedPurchLineExist())
                        {
                            TradeInterCompany::autoCreateOrder(intercompanySalesLine);
                        }
                    }
                }
            }
            else
            {
                if (!SalesPurchSyncDeliveryInfoFeature::instance().isEnabled()
                    || this.isPurchTableInterCompanyOrder()
                    || purchLine.isDropShipment())
                {
                    axSalesLine = this.syncSalesLine(purchLine, null, _create);
                    if (SalesTableType::construct(axSalesLine.salesLine().salesTable()).canCreatePurchOrder())
                    {
                        if (axSalesLine.salesLine().RecId || _create)
                        {
                            if (axSalesLine.parmSkipUpdate() != InterCompanySkipUpdate::InterCompany
                                || !InterCompanySyncPriceAndDiscountOnLineFlight::instance().isEnabled())
                            {
                                axSalesLine.parmSkipUpdate(InterCompanySkipUpdate::Internal);
                            }

                            axSalesLine.validateInput(true);
                            axSalesLine.setConfirmedDatesAsTouched();
                            axSalesLine.setRequestedDatesAsTouched();
                            axSalesLine.setPriceUnitAsTouched();

                            if (!_create
                            &&  purchLine.InterCompanyInventTransId
                            && (purchLine.ReturnDispositionCodeId != _purchLineOrig.ReturnDispositionCodeId
                                || purchLine.ReturnStatus         != _purchLineOrig.ReturnStatus)
                            &&  purchLine.ReturnStatus)
                            {
                                salesTable = axSalesLine.salesLine().salesTable(true);

                                if (purchLine.ReturnStatus != ReturnStatusLine::Awaiting)
                                {
                                    salesTable.ReturnStatus = ReturnStatusHeader::Open;
                                }
                                else
                                {
                                    salesTable.ReturnStatus = axSalesLine.salesLine().returnExistMoreOpenLines() ?
                                        ReturnStatusHeader::Open : ReturnStatusHeader::Created;
                                }

                                salesTable.update();
                            }

                            if (!_create
                        &&  purchLine.InterCompanyInventTransId
                        &&  purchLine.ReturnDispositionCodeId != _purchLineOrig.ReturnDispositionCodeId
                        &&  purchLine.ReturnStatus            == _purchLineOrig.ReturnStatus)
                            {
                                axSalesLine.salesLine().returnUpdateBasedOnDispcode();
                            }
                            axSalesLine.save();

                            // <GEEPL>
                            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
                            {
                                TaxServiceTariff::insertTaxServiceTariffForNewParent(salesTable.TableId, salesTable.RecId, axSalesLine.currentRecord().TableId, axSalesLine.currentRecord().RecId);
                            }
                            // </GEEPL>

                            if (!_create
                            &&  purchLine.InterCompanyInventTransId
                            &&  purchLine.ReturnDispositionCodeId != _purchLineOrig.ReturnDispositionCodeId)
                            {
                                this.interCompanyCreateReturnMarkupTrans(axSalesLine);
                            }

                            purchLine.ItemRefType      = InventRefType::Sales;
                            purchLine.InventRefId      = axSalesLine.salesLine().SalesId;
                            purchLine.InventRefTransId = axSalesLine.salesLine().InventTransId;
                        }
                    }
                }
                else
                {
                    this.saveStockSalesLine(_create);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructAxSalesLine</Name>
				<Source><![CDATA[
    internal AxSalesLine constructAxSalesLine(PurchLine _purchLine, SalesLine _salesLine)
    {
        SalesLine salesLine = SalesLine::findInventTransId(_purchLine.InventRefTransId, true);
        AxSalesLine axSalesLine;

        if (salesLine)
        {
            axSalesLine = AxSalesLine::newSalesLine(salesLine);
        }
        else
        {
            if (_salesLine)
            {
                axSalesLine = AxSalesLine::newSalesLine(SalesLine::findRecId(_salesLine.RecId, true));
            }
            else
            {
                axSalesLine = AxSalesLine::newSalesLine(_salesLine);
            }
        }

        return axSalesLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveStockSalesLine</Name>
				<Source><![CDATA[
    protected void saveStockSalesLine(boolean _create)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updating</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic before a purchase order line record is updated.
    /// </summary>
    public void updating()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic after a purchase order line record has been updated.
    /// </summary>
    /// <param name="_purchLineOrig">
    /// The original purchase order line which is updated.
    /// </param>
    public void updated(PurchLine _purchLineOrig)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateApprovedLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the inventory movements for stocked lines and expected arrival records for non-stocked
    /// lines.
    /// </summary>
    /// <remarks>
    /// When change management is used, transactions that require an approval are not updated on the line
    /// save and are updated when the line is approved.
    /// </remarks>
    public void updateApprovedLine()
    {
        if (purchTable.ChangeRequestRequired)
        {
            if (purchLine.isStocked())
            {
                InventTrans inventTrans = InventTrans::findTransId(purchLine.InventTransId);
                
                this.updateInventory();
                this.updateWHSPurchLine();
                // Sync only for the first approval.
                if (!inventTrans)
                {
                    this.updateAutoCreatedLoadLines();
                }
            }
            else
            {
                this.updatePendingRegistrationsNonStocked(!purchLine.isVersioned());
            }
            purchLine.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAutoCreatedLoadLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sync inventory dimensions from purchase line to auto-created load lines.
    /// </summary>
    public void updateAutoCreatedLoadLines()
    {
        if (!purchLine.IsDeleted)
        {
            WHSLoadLine loadLine;

            update_recordset loadLine
                setting InventDimId = purchLine.InventDimId
                where loadLine.InventTransType  == InventTransType::Purch
                    && loadLine.InventTransId   == purchLine.InventTransId; 
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDistribution</Name>
				<Source><![CDATA[
    public void updateDistribution()
    {
        if (purchLine.sourceDocumentLine().AccountingStatus == SourceDocumentLineAccountingStatus::Completed)
        {

            SourceDocumentProcessorCaller caller;
			if (purchLine.BudgetReservationLine_PSN)
            {
				caller = ReferenceDistributionProcessorCaller::construct(true);
            }
            SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(purchLine, false, SourceDocumentLineAccountingStatus::FullyDistributed, caller);
        }
        else
        {
            SysTransactionScopeCache::clear(classStr(AccountingDistributionRule));

            SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(purchLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFiscalDocumentText_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the Fiscal document texts of a specific type on the Purchase line.
    /// </summary>
    /// <param name="_type">
    /// A <c>FiscalDocumentTextType_BR</c> value indicating the type.
    /// </param>
    /// <remarks>
    /// This method does nothing if the Purchase line has not been inserted yet.
    /// </remarks>
    public void updateFiscalDocumentText_BR(FiscalDocumentTextType_BR _type)
    {
        if (this.canFiscalDocTextBeRegistrated_BR())
        {
            FiscalDocumentTextUpdate_BR::newFromRecord(purchLine).updateTexts(_type);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the inventory movements associated with the line.
    /// </summary>
    /// <remarks>
    /// When change management is used inventory movements are not updated on line save.
    /// </remarks>
    protected void updateInventory()
    {
        if (purchLine.isStocked() && purchTable.ChangeRequestRequired)
        {
            if (purchLine.IsDeleted)
            {
                InventUpd_DeleteMovement::newMovement(InventMovement::construct(purchLine)).updateNow();
            }
            else
            {
                InventUpd_Estimated estimated = this.instantiateInventUpd_Estimated(InventMovSubType::None);
                if (estimated)
                {
                    estimated.updateNow();
                    estimated.updateReservation();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWHSPurchLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the WHS tag table on the purchase line with the quantity after inventory transactions have been updated for WHS or TMS enabled items.
    /// </summary>
    /// <remarks>
    /// Used with change management.
    /// </remarks>
	private void updateWHSPurchLine()
    {
		if (purchLine.isStocked() && 
            (WHSInventEnabled::exist(purchLine.ItemId) || TMSInventEnabled::exist(purchLine.ItemId)))
        {
            WHSPurchLine whsPurchLine = WHSPurchLine::find(purchLine.InventTransId, true);
            whsPurchLine.updateQtyLeftToLoad();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOrderLineOfDeliverySchedule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the order line of the delivery schedule to which the delivery line belongs.
    /// </summary>
    /// <remarks>
    /// This method is used by update and delete methods to trigger recalculation of the order line.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    /// The order line of the selected delivery line was deleted.
    /// </exception>
    void updateOrderLineOfDeliverySchedule()
    {
        PurchLine purchLineOrderLine = PurchDeliverySchedule::findOrderLineForDeliveryLine(purchLine.InventTransId, true);
        if (!purchLineOrderLine)
        {
            // The order line of the selected delivery line was deleted.
            throw error("@SYS131419");
        }
        else
        {
            purchLineOrderLine.recalculateDeliveryScheduleOrderLine();
            // calling update without updating delivery schedule line to indicate that this is a DS synchronization update
            // and thus PurchQty changes are allowed.
            purchLineOrderLine.updateWithoutUpdatingDeliveryScheduleLines();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePendingRegistrationsNonStocked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the pending registrations for non-stocked lines.
    /// </summary>
    /// <param name="_isPendingRegistrationsToBeCreated">
    /// Specifies whether to create new pending registrations for the line.
    /// </param>
    /// <remarks>
    /// If the line is new then pending registrations will be created; otherwise, the pending registrations
    /// will be synchronized with the line.
    /// </remarks>
    public void updatePendingRegistrationsNonStocked(boolean _isPendingRegistrationsToBeCreated)
    {
        PurchNonStockedRegistrationHelper   purchNonStockedRegistrationHelper;
        PurchLine                           purchLineApproved;
        boolean                             isPendingRegistrationsToBeCreated;

        purchLineApproved = purchLine.findApproved();

        purchNonStockedRegistrationHelper = TradeNonStockedRegistrationHelper::newFromSalesPurchLine(purchLine);

        //Synchronize only for non-stocked tangible lines for which the entire line quantity has not been registered.
        if (purchNonStockedRegistrationHelper.isPendingRegistrationsApplicable(_isPendingRegistrationsToBeCreated, purchLineApproved))
        {
            //If purchase order has been cancelled or soft deleted in case of change request based lines
            //Or if line was changed from positive to negative, then pending registrations need to be deleted.
            if (purchNonStockedRegistrationHelper.shouldPendingRegistrationsBeDeleted(purchLineApproved))
            {
                purchNonStockedRegistrationHelper.deletePendingRegistration();
            }
            else
            {
                isPendingRegistrationsToBeCreated = !purchLineApproved || _isPendingRegistrationsToBeCreated;

                if (purchNonStockedRegistrationHelper.shouldPendingRegistrationsBeSynced(isPendingRegistrationsToBeCreated, purchLineApproved))
                {
                    //If an original record exists exists for the line then only the difference in quantity should be updated for pending registrations.
                    purchNonStockedRegistrationHelper.synchronizePendingRegistration(
                        (isPendingRegistrationsToBeCreated)? purchLine.RemainPurchPhysical: purchLine.RemainPurchPhysical-purchLineApproved.RemainPurchPhysical,
                        _isPendingRegistrationsToBeCreated);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePurchLine</Name>
				<Source><![CDATA[
    public void updatePurchLine(InventTransIdSum  _inventTransIdSum = null)
    {
        PurchLine purchLineOrig = purchLine.extensionOrig();
        
        PurchTable purchTableOrig;
        purchTableOrig.data(purchTable);

        purchLine.PurchReceivedNow          = 0;
        purchLine.InventReceivedNow         = 0;
        purchLine.PdsCWInventReceivedNow    = 0;

        this.updatePurchStatus(purchLineOrig, _inventTransIdSum, false);

        purchLine.updateDropShipStatus(purchLineOrig, purchTable, purchTableOrig);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRetailSumLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates information about purchase order line changes in retail sum lines
    /// </summary>
    /// <returns>
    /// true if the <c>RetailSumLines</c> table buffer has been changed; otherwise, false.
    /// </returns>
    public boolean updateRetailSumLines()
    {
        RetailSumLines  localRetailSumLines;
        RetailSumLines  origRetailSumLines;
        LineNum origRetailLineNumEx1 = purchLine.RetailLineNumEx1;

        // This code is executed when PO line is being changed, so to reflect the changes in the appropriate RetailSumLines records (e.g. quantity update).
        // RetailLineNumEx1 shows whether PO line is the part of variant explosion or not.
        // If not, we should not do anything.
        if (purchLine.RetailLineNumEx1 != 0)
        {
            localRetailSumLines = RetailSumLines::find(purchLine.PurchId, purchLine.RetailLineNumEx1, true);
            origRetailSumLines.data(localRetailSumLines);
            RetailSumLines::updateLineFromPurch(purchLine, false, localRetailSumLines);
        }

        return origRetailLineNumEx1 != purchLine.RetailLineNumEx1
               || origRetailSumLines.RecVersion != localRetailSumLines.RecVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesLine</Name>
				<Source><![CDATA[
    [SysObsolete('Replaced by updateSalesLineOnDeletePurchLine', false, 30\06\2018)]
    void updateSalesLine(PurchLine _purchLine, boolean _purchLineDeleted = false)
    {
        if (!this.skipUpdateAndNoReferenceLot())
        {
            this.updateSalesLineOnDeletePurchLine(_purchLineDeleted);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesLineOnDeletePurchLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates information on the sales order line if the purchase order line is deleted.
    /// </summary>
    /// <param name = "_purchLineDeleted">true if the purchase order line is deleted; otherwise, false.</param>
    public void updateSalesLineOnDeletePurchLine(boolean _purchLineDeleted = false)
    {
        SalesLine salesLine = SalesLine::findInventTransId(purchLine.InventRefTransId, true); 

        if (salesLine)
        {
            if (salesLine.InventRefId != purchLine.PurchId)
            {
                return;
            }
            else
            {
                this.removeSalesLineReservation(salesLine, _purchLineDeleted);
                salesLine.SkipUpdate = InterCompanySkipUpdate::Internal;
                salesLine.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    boolean validateDelete(boolean _interCompanyForce = false)
    {
        PurchLine   purchLine_Orig = purchLine.extensionOrig();

        boolean     ok = true;

        SalesLine               salesLine;
        PurchDeliverySchedule   purchDeliverySchedule;
        PurchDeliverySchedule   purchDeliveryScheduleOther;
        PurchLine               purchLineOther;

        setPrefix(#PreFixField(purchLine,ItemId));

        if (isConfigurationkeyEnabled(configurationKeyNum(Retail))
            && RetailReplenishmentTransferOrder::findTransferOrderLine(tableNum(PurchLine), purchLine.RecId))
        {
            if (FormDataUtil::isFormDataSource(purchLine))
            {
                ok = Box::yesNo("@Retail:PurchaseLineHasReferenceToTransferLine" + ' ' + "@Retail:DoYouWhishToContinue", DialogButton::No) == DialogButton::Yes;
            }
            else
            {
                return checkFailed("@Retail:PurchaseLineHasReferenceToTransferLine");
            }
        }

        if (purchLine.existInvoice())
        {
            ok = checkFailed("@SYS113342");
        }

        if (ok && purchLine.RemainPurchFinancial)
        {
            ok = checkFailed("@SYS2288");
        }

        if (ok && purchLine.interCompanyIsBeingUpdated(true))
        {
            ok = false;
        }

        if (ok && FormDataUtil::isFormDataSource(purchLine))
        {
            ok = purchLine.warningForReference();
        }

        if (purchLine_Orig.creditNoteLine(purchTable)
        &&  TaxWorkRegulation::exist(tableNum(PurchTable), purchTable.RecId))
        {
            ok = checkFailed("@SYS53183");
        }
        //
        //  Validation of intercompany sales line
        //
        if (ok
        &&  purchLine.SkipUpdate != InterCompanySkipUpdate::InterCompany
        &&  purchLine.SkipUpdate != InterCompanySkipUpdate::Both
        &&  this.isPurchTableInterCompanyOrder())
        {
            salesLine = null;
            changecompany(purchTable.InterCompanyCompanyId)
            {
                salesLine = SalesLine::findInventTransId(purchLine.InterCompanyInventTransId);
                ok = this.interCompanyValidateDelete(salesLine);
            }

            if (ok)
            {
                ok = this.interCompanyValidateDeleteQty(salesLine);
            }
        }

        if (ok
        &&  !_interCompanyForce
        &&  this.isPurchTableInterCompanyOrder()
        &&  purchLine.SkipUpdate         != InterCompanySkipUpdate::InterCompany
        &&  purchLine.SkipUpdate         != InterCompanySkipUpdate::Both
        &&  purchLine.InterCompanyOrigin == InterCompanyOrigin::Derived)
        {
            ok = checkFailed(this.interCompanyCheckOnDeleteMessage());
        }
        //
        //  Validation of original sales line
        //
        if (ok
        &&  purchLine.SkipUpdate  != InterCompanySkipUpdate::Internal
        &&  purchLine.SkipUpdate  != InterCompanySkipUpdate::Both
        &&  purchLine.ItemRefType == InventRefType::Sales
        &&  purchLine.InventRefTransId
        &&  this.isPurchTableInterCompanyOrder())
        {
            salesLine = null;
            salesLine = SalesLine::findInventTransId(purchLine.InventRefTransId);
            if (salesLine)
            {
                salesLine.SkipUpdate = InterCompanySkipUpdate::Internal;
                ok = salesLine.validateDelete(true);
            }

            if (salesLine)
            {
                if (ok  &&  salesLine.RemainSalesPhysical != purchLine.RemainPurchPhysical)
                    ok = checkFailed("@SYS13406");

                if (ok  &&  salesLine.RemainSalesFinancial != purchLine.RemainPurchFinancial)
                    ok = checkFailed("@SYS13406");
            }
        }

        if (ok
            && purchLine.LineDeliveryType   == LineDeliveryType::DeliveryLine
            && purchLine.isInvoiced())
        {
            select firstonly RecId from purchDeliverySchedule
                where purchDeliverySchedule.DeliveryLine == purchLine.InventTransId
                   && !purchDeliverySchedule.IsDeleted
                join RecId from purchDeliveryScheduleOther
                    where purchDeliveryScheduleOther.OrderLine == purchDeliverySchedule.OrderLine
                       && !purchDeliveryScheduleOther.IsDeleted
                    exists join RecId from purchLineOther
                        where purchDeliveryScheduleOther.DeliveryLine == purchLineOther.InventTransId
                           && !purchLineOther.IsDeleted
                            && (purchLineOther.PurchStatus != PurchStatus::Invoiced);

            if (purchDeliverySchedule.RecId)
            {
                // The invoiced delivery line cannot be deleted unless all delivery lines are invoiced.
                ok = checkFailed("@SYS131425");
            }
        }

        ok = InventQualityOrderTable::checkNoOpenQualityOrders(purchLine) && ok;

        ok = ok && this.checkInventTransDeleteContraints();

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>notExistIntercompanyPurchaseLineForDirectDelivery</Name>
				<Source><![CDATA[
    private boolean notExistIntercompanyPurchaseLineForDirectDelivery(PurchLine _purchLine, AxSalesLine _axSalesLine)
    {
        return purchTable.isInterCompanyOrderChain()
                && _purchLine.isDropShipment()
                && _axSalesLine.parmInterCompanyInventTransId()
                && !_axSalesLine.salesLine().interCompanyPurchLine().RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyCheckOnDeleteMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the label that says the order cannot be deleted because it has been created through an intercompany order.
    /// </summary>
    /// <returns>The message.</returns>
    [Replaceable]
    protected str interCompanyCheckOnDeleteMessage()
    {
        return "@SYS98647";
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    [Hookable()]
    boolean validateField(FieldId  fieldId)
    {
        boolean  ok = true;

        PurchQty        qtyLeftToReturn, qtyAlreadyReturned, totalInvoiced;
        PdsCWInventQty  pdsCWqtyLeftToReturn, pdsCWqtyAlreadyReturned, totalCWInvoiced;
        PurchLine       originalPurchLine;
        HcmWorkerRecId  worker;

        // <GIN>
        boolean         taxParameters = TaxParameters::checkTaxParameters_IN();
        // </GIN>

        switch (fieldId)
        {
            case fieldNum(PurchLine, ItemId):
                ok = purchLine.checkItemId();
                break;

            case fieldNum(PurchLine, ProcurementCategory):
                ok = purchLine.checkProcurementCategory();
                break;

            case fieldNum(PurchLine, OverDeliveryPct):
                ok = purchLine.checkOverDelivery();
                break;

            case fieldNum(PurchLine, UnderDeliveryPct):
                ok = purchLine.checkUnderDelivery();
                break;

            case fieldNum(PurchLine, PurchUnit):
                ok = purchLine.checkPurchUnit();
                break;

            case fieldNum(PurchLine, ActivityNumber):
                ok = purchLine.checkActivity();
                break;

            case fieldNum(PurchLine, PdsCWQty):
                ok = this.checkPurchQtyIsEditable();

                if (ok && purchLine.InventRefTransId && purchLine.creditNoteLine())
                {
                    originalPurchLine = PurchLine::findInventTransId(purchLine.InventRefTransId);
                    if (originalPurchLine)
                    {
                        totalCWInvoiced = originalPurchLine.pdsCWInvoicedInTotal();
                        [qtyAlreadyReturned, pdsCWqtyAlreadyReturned] = PurchLine::returnedLotQty(originalPurchLine.InventTransId, purchLine.InventTransId);
                        pdsCWqtyLeftToReturn = totalCWInvoiced - pdsCWqtyAlreadyReturned;

                        // Check if the new catch weight quantity value is bigger than the quantity left to return
                        if (-purchLine.PdsCWQty > pdsCWqtyLeftToReturn)
                        {
                            // will only show informational warning - still return true; user is allowed to proceed
                            // warning: "The catch weight quantity being returned is greater than what can be covered by the return lot."
                            warning("@SYS4004079");
                            // The total catch weight quantity that was invoiced for the order: %1.
                            info(strFmt("@SYS4004080", totalCWInvoiced));
                            // The catch weight quantity already credited: %1.
                            info(strFmt("@SYS4004081", pdsCWqtyAlreadyReturned));
                            // The catch weight quantity available for crediting: %1.
                            info(strFmt("@SYS4004082", pdsCWqtyLeftToReturn));
                        }
                    }
                }
                break;

            case fieldNum(PurchLine, PurchQty):
                ok = this.checkPurchQtyIsEditable();

                if (ok && purchLine.InventRefTransId && purchLine.creditNoteLine())
                {
                    originalPurchLine = PurchLine::findInventTransId(purchLine.InventRefTransId);
                    if (originalPurchLine)
                    {
                        totalInvoiced = originalPurchLine.invoicedInTotal();
                        [qtyAlreadyReturned,pdsCWqtyAlreadyReturned] = PurchLine::returnedLotQty(originalPurchLine.InventTransId, purchLine.InventTransId);
                        qtyLeftToReturn =  totalInvoiced - qtyAlreadyReturned;

                        // Check if the new quantity value is bigger than the quantity left to return
                        if (-purchLine.PurchQty > qtyLeftToReturn)
                        {
                            // will only show informational warning - still return true; user is allowed to proceed
                            // warning: "The quantity being returned is greater than what can be covered by the return lot."
                            warning("@SYS53004");
                            // The total invoiced quantity for the order: %1.
                            info(strFmt("@SYS310092", totalInvoiced));
                            // The quantity already credited: %1.
                            info(strFmt("@SYS310093", qtyAlreadyReturned));
                            // The quantity available for crediting: %1."
                            info(strFmt("@SYS310094", qtyLeftToReturn));
                        }
                    }
                }

                // <GIN>
                if (ok && taxParameters)
                {
                    ok = purchLine.checkIfInvoiceRegistered_IN();
                }
                // </GIN>
                break;

            case fieldNum(PurchLine, MatchingPolicy):
                ok = purchLine.checkMatchingPolicy();
                break;

            case fieldNum(PurchLine, PurchPrice)        :
            case fieldNum(PurchLine, LineDisc)          :
            case fieldNum(PurchLine, LinePercent)       :
            case fieldNum(PurchLine, MultiLnDisc)       :
            case fieldNum(PurchLine, MultiLnPercent)    :
            case fieldNum(PurchLine, PurchMarkup)       :
                ok = this.canLineAmountBeUpdated();
                // <GIN>
                if (ok && taxParameters && fieldId == fieldNum(PurchLine, PurchPrice))
                {
                    ok = purchLine.checkIfInvoiceRegistered_IN();
                }
                // </GIN>
                break;
            case fieldNum(PurchLine, AssetBookId)       :   ok = purchLine.checkAssetBookId();
                break;

            case fieldNum (PurchLine, DeliveryDate)     :
                if (PurchParameters::find().PriceDateType == PurchPriceDateType::DeliveryDate)
                {
                    ok = PriceDiscPolicyRule::createInstance(purchLine).launchPolicyDialogForAllPolicyFields(false, false);
                }


                if (ok
                    && PurchParameters::find().IsSupplierShipmentDatesEnabled
                    && purchLine.DeliveryDate
                    && purchLine.DeliveryDate < DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())
                    && PurchParameters::find().RequestedShipDateInPast == RequestedShipDateInPast::DisallowWarning)
                {
                    ok = checkFailed(strFmt("@SCM:VendorDispatchDateRequestedReceiptDateTodayWarning", purchLine.DeliveryDate));
                }
                
                break;
            
            case fieldNum(PurchLine, RequestedShipDate):
                if (ok
                    && PurchParameters::find().IsSupplierShipmentDatesEnabled
                    && purchLine.RequestedShipDate
                    && purchLine.RequestedShipDate < DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())
                    && PurchParameters::find().RequestedShipDateInPast == RequestedShipDateInPast::DisallowWarning)
                {
                    ok = checkFailed(strFmt("@SCM:VendorDispatchDateRequestedShipDateTodayWarning", purchLine.RequestedShipDate));
                }
                break;

            case fieldNum(PurchLine, LineNumber):
                ok = purchLine.checkLineNumber();
                break;

            case fieldNum(PurchLine, InventReceivedNow):
                ok = purchLine.checkInventReceivedNow();
                break;

            case fieldNum(PurchLine, PurchReceivedNow):
                ok = purchLine.checkPurchReceivedNow();
                break;

            case fieldNum(PurchLine, OperationType_MX):
                if (VendTable::find(purchLine.orderAccount()).VendorType_MX == VendorType_MX::ForeignVendor
                    && purchLine.OperationType_MX == VendorOperationType_MX::RentLease)
                {
                    ok = checkFailed(strFmt("@SYS312599", purchLine.OperationType_MX));
                }
                break;

            // <GIN>
            case fieldNum(PurchLine, LineAmount):
                if (taxParameters)
                {
                    ok = purchLine.checkIfInvoiceRegistered_IN();
                }
                break;
            // </GIN>

            case fieldNum(PurchLine, ProjWorker):
                if (purchLine.ProjWorker &&
                ProjParameters::find().ShowInactiveEmployees == false)
                {
                    worker = purchLine.ProjWorker;
                    if (worker && HcmWorker::find(worker).workerStatus() == HcmWorkerStatus::Terminated)
                    {
                        ok = checkFailed("@SYS39651");
                    }
                }
                break;
        }

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            ok = this.validateField_BR(fieldId, ok);
        }
        // </GBR>

        ok = ok && this.checkInterCompany(purchLine, fieldId);

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInterCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate fields for inter-company scenario.
    /// </summary>
    /// <param name = "_tableBuffer">A table record whose field to check.</param>
    /// <param name = "_fieldId">A field ID to check.</param>
    /// <returns>true if no errors encountered; otherwise false.</returns>
    private boolean checkInterCompany(Common _tableBuffer, FieldId _fieldId)
    {        
        if (this.isPurchTableInterCompanyOrder()
            && !purchTable.checkUpdateInterCompanyOrder()
            && this.isFieldNotEditableForInterCompany(_tableBuffer.TableId, _fieldId)
            && _tableBuffer.(_fieldId) != _tableBuffer.orig().(_fieldId))
        {
            return checkFailed("@SCM:PurchaseOrderIntercompanyModificationError");
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFieldNotEditableForInterCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a field is a return action ID, 
    /// which allows modification in inter-company scenario.
    /// </summary>
    /// <param name = "_tableId">A table ID whose field to check.</param>
    /// <param name = "_fieldId">A field ID to check.</param>
    /// <returns>true if a field ID is not one of the allowed fields; otherwise false.</returns>
    private boolean isFieldNotEditableForInterCompany(TableId _tableId, FieldId _fieldId)
    {
        if (_tableId != tableNum(PurchLine)
            || (_tableId == tableNum(PurchLine)
                && _fieldId != fieldNum(PurchLine, ReturnActionId)))
        {
            return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField_BR</Name>
				<Source><![CDATA[
    private boolean validateField_BR(FieldId fieldId, boolean _returnValue = false)
    {
        boolean ok = _returnValue;

        switch (fieldId)
        {
            case fieldNum(PurchLine, cfopTable_BR):
                ok = this.checkCFOP_BR();
                break;

            case fieldNum(PurchLine, TaxServiceCode_BR):
                ok = this.checkTaxServiceCode_BR();
                break;
        }

        return _returnValue && ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates India fields.
    /// </summary>
    /// <param name="fieldId">
    /// The field ID to be validated.
    /// </param>
    /// <returns>
    /// true if the field value is valid; otherwise, false.
    /// </returns>
    boolean validateField_IN(FieldId  fieldId)
    {
        boolean  ok = true;

        PurchLine_IN    purchLine_IN;
        boolean         taxParameters = TaxParameters::checkTaxParameters_IN();

        switch (fieldId)
        {
            case fieldNum(PurchLine_IN, MaximumRetailPrice)  :
                if (taxParameters)
                {
                    ok = TransTaxInformationHelper::checkMaximumRetailPrice(purchLine_IN.MaximumRetailPrice);
                }
                break;

            case fieldNum(PurchLine_IN, AssessableValueTransactionCurrency):
                if (taxParameters && purchLine.PurchQty * purchLine_IN.AssessableValueTransactionCurrency < 0)
                {
                    ok = checkFailed("@GLS5572");
                }
                break;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates countries' fields.
    /// </summary>
    /// <param name="fieldId">
    /// The field ID to be validated.
    /// </param>
    /// <returns>
    /// true if the field value is valid; otherwise, false.
    /// </returns>
    boolean validateField_W(FieldId  fieldId)
    {
        boolean  ok = true;

        switch (fieldId)
        {
            case fieldNum(PurchLine_W, PostingProfile_RU) :
                ok = purchLine.allowPostingProfileChange_RU() &&
                        purchLine.checkPostingProfile_RU();
                break;

            case fieldNum(PurchLine_W, MarkupCode_RU) :
                ok = purchLine.checkMarkupCode_RU();
                break;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateModifyInventDim</Name>
				<Source><![CDATA[
    /*
        Should be called if inventory dimensions are changed for the line
        Returns true if the inventDim modification is ok
    */
    public boolean validateModifyInventDim(
        InventDim           _inventDim,
        FieldId             _dimFieldId)
    {
        boolean ok = true;

        // <GEERU>
        #ISOcountryRegionCodes
        // </GEERU>
        InventDimGroupSetup         inventDimGroupSetup = InventDimGroupSetup::newItemId(purchLine.ItemId);
        // <GEERU>
        if (_dimFieldId == fieldNum(InventDim, InventProfileId_RU))
        {
            ok = purchLine.allowInventProfileIdChange_RU();
        }
        // </GEERU>

        //Changes in financial dimensions for marked lines are not allowed
        // If marked with virtual inventTrans, show allow changes
        if (purchLine.InventRefTransId
         && _inventDim.(_dimFieldId) != _inventDim.orig().(_dimFieldId)
         && (!purchLine.isDropShipment()
         ||  ((purchLine.isStocked() && InventTransOrigin::findByInventTransId(purchLine.InventRefTransId).ReferenceId)
         ||   _dimFieldId == fieldNum(InventDim, InventSiteId)
         ||   InventDim::isFieldIdProductDimension(_dimFieldId))))
        {
            if (inventDimGroupSetup.getFieldSetup(_dimFieldId).isFinancialInventoryEnabled())
            {
                ok = checkFailed("@SYS98272");
            }
        }

        if (ok && _inventDim.LicensePlateId != '')
        {
            ok = checkFailed("@WAX4683");
        }

        if (ok && purchLine.RecId && purchLine.purchTable().MatchingAgreement)
        {
            purchLine.InventDimId = InventDim::findOrCreate(_inventDim).InventDimId;
            if (!purchLine.refreshAgreementLink(new AgreementAutolinkHelperPurchLine()))
            {
                ok = purchLine.unLinkAgreementLinePrompt(_dimFieldId, tableNum(InventDim));
            }
        }

        if (ok
            && InventDim::mustUseFieldPurchPriceDisc(_dimFieldId, inventDimGroupSetup))
        {
            ok = PriceDiscPolicyRule::createInstance(purchLine).launchPolicyDialogForAllPolicyFields(false, true);
        }
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            if (_dimFieldId == fieldNum(InventDim, InventProfileId_RU))
            {
                ok = this.checkInventProfile_RU(_inventDim) && this.checkInventOwner_RU(_inventDim);
            }
            else if (_dimFieldId == fieldNum(InventDim, InventOwnerId_RU))
            {
                ok = this.checkInventOwner_RU(_inventDim);
            }
        }
        // </GEERU>

        ok = ok && this.checkInterCompany(_inventDim, _dimFieldId);

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates a <see cref="T:PurchLine" /> buffer based on logic that spans several current table
    ///    buffers.
    /// </summary>
    /// <returns>
    ///    true if the table buffer has valid information and may be saved; otherwise, false.
    /// </returns>
    public boolean validateWrite()
    {
        PurchLine       purchLine_Orig = purchLine.extensionOrig();
        boolean         ok          = true;
        InventTable     inventTable = purchLine.inventTable();

        PurchNonStockedRegistrationHelper   purchNonStockedRegistrationHelper;
        #ISOCountryRegionCodes

        if (purchLine.ItemId && !inventTable)
            ok = checkFailed(strFmt("@SYS5307", purchLine.ItemId));

        if (this.isPurchTableInterCompanyOrder() && (!inventTable || inventTable.interCompanyBlockedPurch()))
        {
            if (purchLine.isCategoryBased())
            {
                ok = checkFailed("@SYS313739");
            }
            else
            {
                ok = checkFailed(strFmt("@SYS74812", purchLine.ItemId));
            }
        }

        if (!purchLine.purchTable())
            ok = checkFailed("@SYS26869");

        if (purchLine_Orig.creditNoteLine(purchTable)
        &&  TaxWorkRegulation::exist(tableNum(PurchTable), purchTable.RecId))
            ok = checkFailed("@SYS53183");

        if (!purchLine.checkTaxItemGroup()
            || !purchLine.checkPurchType()
            || !purchLine.checkCurrencyCode()
            || !purchLine.checkItemId()
            || purchLine.isProductStopped()
            || (!purchLine.RecId && !purchLine.checkProcurementCategory()))
        {
            ok = false;
        }

        if (!purchLine.ItemId && !purchLine.ProcurementCategory)
        {
            ok = checkFailed("@SYS134349");
        }

        if (!purchLine.RecId
            && EcoResProductUnitConverter::hasRequiredProductDimensionsForUnitConversion(purchLine.ItemId, purchLine.inventDim())
            && !EcoResProductUnitConverter::canBeConvertedGivenUnitSymbolsForReleasedProduct(inventTable.ItemId,
                                                                                             purchLine.InventDimId,
                                                                                             purchLine.PurchUnit,
                                                                                             inventTable.inventUnitId()))
        {
            ok = checkFailed(strFmt("@SCM:ProductVariantConversionMissing",
                                    purchLine.PurchUnit, 
                                    inventTable.inventUnitId(), 
                                    EcoResProductMaster::find(inventTable.Product).productNumber()));
        }

        if (purchLine.Transport && !purchLine.Port && IntrastatTransportMode::isPortMandatory(purchLine.Transport))
            warning("@SYS26970");

        if (purchLine.BarCodeType)
            if (!BarcodeSetup::find(purchLine.BarCodeType).validateBarcode(purchLine.BarCode))
                ok = false;

        if (purchLine.PurchQty * purchLine.LineAmount < 0)
            ok = checkFailed("@SYS78848");

        if (!purchLine.checkReqActivity())
            ok = checkFailed("@Proj:ActivityNumberMissingForPurchaseOrder");

        if (this.isFixedAssetGroupNotAllowed())
        {
            ok = checkFailed("@SYS71123");
        }

        if (ok)
        {
            ok = purchLine.pdsCWQtyValidation();
        }
        if (ok && #PmfEnabled)
        {
            ok = purchLine.inventTable().pmfInventProductType().validateInventUpd();
        }

        if (ok && #PdsApprovedVendorListEnabled)
        {
            ok = purchLine.pdsCheckApprovedVendorList();
        }

        if (ok && #PdsCatchWeightEnabled)
        {
            ok = purchLine.inventTable().pdsCheckCWItemSetup();
        }

        if (purchLine.IsFinalized)
        {
            ok = checkFailed("@SYS332458");
        }

        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]) && TaxParameters::checkTaxParameters_IN() && purchLine.PurchQty * purchLine.purchLine_IN().AssessableValueTransactionCurrency < 0)
        {
            ok = checkFailed("@GLS5572");
        }
        // </GIN>

        ok = ok && this.checkInventDimUpdateValidNonStocked(purchLine_Orig);

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            ok = this.checkAgreementDimension_RU() && ok;
            ok = this.checkInventProfile_RU() && ok;
            ok = this.checkInventOwner_RU() && ok;
            ok = purchLine.checkMarkupCode_RU() && ok;

            if (ok &&
                inventTable.AssetGroupId_RU &&
                purchLine.PurchUnit != inventTable.inventUnitId())
            {
                ok = checkFailed("@GLS116063");
            }
        }
        // </GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoMX]))
        {
            if (!purchLine.checkOperationType_MX())
            {
                ok = false;
            }

            ok = CFDIWithholdingType_MX::checkWithholdingType(purchLine.purchLine_W().WithholdingTypeCode_MX, purchLine.TaxGroup, purchLine.TaxItemGroup) && ok;
        }

        purchNonStockedRegistrationHelper = TradeNonStockedRegistrationHelper::newFromSalesPurchLine(purchLine);
        if (purchNonStockedRegistrationHelper.isPendingRegistrationsApplicable(true, purchLine.findApproved()))
        {
            ok = ok && purchNonStockedRegistrationHelper.validateOrderLineUpdate();
        }

        if (purchTable.ProjId && !purchLine.ProjId)
        {
            ok = checkFailed("@SYS78501");
        }

        if (!purchTable.ProjId && purchLine.ProjId)
        {
            ok = checkFailed("@SYS339382");
        }

        if (purchLine.ProjId && !purchLine.ProjCategoryId)
        {
            ok = checkFailed(strFmt("@SYS84753", fieldPName(PurchLine, ProjCategoryId)));
        }

        if (purchLine.ProjId
            && purchLine.ProjCategoryId
            && !purchLine.ProjWorker
            && !ProjProjectOperationsIntegrationFeatureHelper::isProcurementCategoriesEnabledWithProjOps())
        {
            ProjCategory projCategory = ProjCategory::find(purchLine.ProjCategoryId);
            if (ProjParameters::find().DisableExpenseCategoryResourceCheckProcurement == NoYes::Yes)
            {
                // Only validate Hour categories
                if (projCategory.CategoryType == ProjCategoryType::Hour && (ProjParameters::find().ValidationEmplProj == ProjValParameter::Mandatory || projCategory.ProjCategoryEmplOption == ProjCategoryEmplOption::Mandatory))
                {
                    warning(strFmt("@SYS84753", fieldPName(PurchLine, ProjWorker)));
                }
            }
            else
            {
                // Validate all supported categories except Item
                if (projCategory.CategoryType != ProjCategoryType::Item  && (ProjParameters::find().ValidationEmplProj == ProjValParameter::Mandatory || projCategory.ProjCategoryEmplOption == ProjCategoryEmplOption::Mandatory))
                {
                    warning(strFmt("@SYS84753", fieldPName(PurchLine, ProjWorker)));
                }
            }
        }

        if (ok && PurchParameters::find().IsSupplierShipmentDatesEnabled && purchLine.RequestedShipDate && purchLine.DeliveryDate && purchLine.RequestedShipDate > purchLine.DeliveryDate)
        {
            ok = checkFailed(strFmt("@SCM:VendorDispatchDateRequestedReceiptDateGreaterThanError", purchLine.DeliveryDate, purchLine.RequestedShipDate));
        }

        if (ok && PurchParameters::find().IsSupplierShipmentDatesEnabled && purchLine.ConfirmedShipDate && purchLine.ConfirmedDlv && purchLine.ConfirmedShipDate > purchLine.ConfirmedDlv)
        {
            ok = checkFailed(strFmt("@SCM:VendorDispatchDateConfirmedReceiptDateGreaterThanError", purchLine.ConfirmedDlv, purchLine.ConfirmedShipDate));
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFixedAssetGroupNotAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if the fixed asset group is not allowed.
    /// </summary>
    /// <returns>
    /// true, if the fixed asset group is not allowed; otherwise, false.
    /// </returns>
    protected boolean isFixedAssetGroupNotAllowed()
    {
        return (purchLine.CreateFixedAsset == NoYes::Yes) && (!purchLine.AssetGroup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    static PurchLineType construct(PurchLine purchLine, PurchTable purchTable = purchLine.purchTable())
    {
        if (purchLine.LineDeliveryType == LineDeliveryType::OrderLineWithMultipleDeliveries)
        {
            // order lines with multiple deliveries are handled independently of order type
            return PurchLineType_WithMultipleDeliveries::construct(purchLine, purchTable);
        }

        return PurchLineType::constructBasedOnPurchaseType(purchLine, purchTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructBasedOnPurchaseType</Name>
				<Source><![CDATA[
    static PurchLineType constructBasedOnPurchaseType(PurchLine _purchLine, PurchTable _purchTable)
    {
        switch (_purchLine.PurchaseType)
        {
            case  PurchaseType::Journal: 
                return PurchLineType_Journal::construct(_purchLine, _purchTable);
            case  PurchaseType::Purch: 
                return PurchLineType_Purch::construct(_purchLine, _purchTable);
            case  PurchaseType::ReturnItem: 
                return PurchLineType_ReturnItem::construct(_purchLine, _purchTable);
            default:
                EventHandlerResult resultPurchLineType = new EventHandlerResult();
                PurchLineType::constructBasedOnPurchaseTypeDelegate(_purchLine, _purchTable, resultPurchLineType);
                if (resultPurchLineType.hasResult())
                {
                    return resultPurchLineType.result();
                }

                throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructBasedOnPurchaseTypeDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for instantiating the corresponding <c>PurchLineType</c> derived class for the specified purchase order.
    /// </summary>
    /// <param name = "_purchLine">Purchase order line record.</param>
    /// <param name = "_purchTable">Purchase order header record.</param>
    /// <param name = "_result">An instance of <c>EventHandlerResult</c> class subscribers can use to return the instantiated class.</param>
    static delegate void constructBasedOnPurchaseTypeDelegate(PurchLine _purchLine, PurchTable _purchTable, EventHandlerResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>syncDeliveryAddress</Name>
				<Source><![CDATA[
    static void syncDeliveryAddress(PurchLine      _purchLine,
                                    AxSalesLine    _axSalesLine,
                                    boolean        _create = false)
    {
        if (_create || _purchLine.fieldChanged(fieldNum(PurchLine, DeliveryPostalAddress)))
        {
            _axSalesLine.parmDeliveryPostalAddress(_purchLine.DeliveryPostalAddress);
        }

        if (_create || _purchLine.fieldChanged(fieldNum(PurchLine, DeliveryName)))
            _axSalesLine.parmDeliveryName(_purchLine.DeliveryName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initForeignTradeFromInventTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes purchase line foreign trade fields from the <c>InventTable</c> record.
    /// </summary>
    /// <param name = "_inventTable"><c>InventTable</c> record.</param>
    private void initForeignTradeFromInventTable(InventTable _inventTable)
    {
        purchLine.IntrastatCommodity = _inventTable.IntrastatCommodity;
        purchLine.OrigCountryRegionId = _inventTable.OrigCountryRegionId;
        purchLine.OrigStateId = _inventTable.OrigStateId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>userProvidedInventDimFields</Name>
				<Source><![CDATA[
    private Set userProvidedInventDimFields()
    {
        return InventDim::dimFieldList2Set(preDefaultingInventDimParm.selectedDimFields());
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultFromField</Name>
				<Source><![CDATA[
    public void defaultFromField(FieldId _fieldId, boolean _userInput)
    {
        switch (_fieldId)
        {
            case fieldNum(PurchLine, InventDimId):
                InventDim mergedDim = purchLine.inventDim();

                if (preDefaultingInventDim.InventSiteId && mergedDim.InventSiteId != preDefaultingInventDim.InventSiteId && !preDefaultingInventDim.InventLocationId)
                {
                    preDefaultingInventDim.InventStorageDimMap::modifiedInventSiteFromParent(purchLine);
                    preDefaultingInventDimParm.InventLocationIdFlag = NoYes::Yes;
                }

                if (preDefaultingInventDim.InventLocationId
                    && !preDefaultingInventDim.InventSiteId
                    && (mergedDim.InventLocationId != preDefaultingInventDim.InventLocationId || !mergedDim.InventSiteId))
                {
                    preDefaultingInventDim.InventStorageDimMap::modifiedInventLocationFromParent(purchLine);
                    preDefaultingInventDimParm.InventSiteIdFlag = mergedDim.InventSiteId != preDefaultingInventDim.InventSiteId;
                }

                mergedDim.initFromInventDim(preDefaultingInventDim, preDefaultingInventDimParm.selectedDimFields());
                purchLine.modifyInventDimSet(mergedDim, this.userProvidedInventDimFields(), true);
                mergedInventDimId = purchLine.InventDimId;
                break;

            case fieldNum(PurchLine, PurchId):
                purchLine.initFromPurchTable(PUrchTable::find(purchLine.PurchId));
                this.modifiedPurchQty();
                break;

            case fieldNum(PurchLine, ItemId):
                purchLine.initFromInventTable(purchLine.inventTable());

                AgreementHeaderRecId matchingAgreement = purchLine.purchTable().MatchingAgreement;
                if (matchingAgreement)
                {
                    purchLine.salesPurchLineInterface().autoMatchAgreementLine(matchingAgreement);
                }
              
                // For purchase line, default dimension will be affected by itemId, so should check if dimension link exist, then update dimension.
                if (PurchLineTypeConsiderDefaultDimensionUpdateFlight::instance().isEnabled()
                    && preDefaultingInventDim.InventSiteId)
                {
                    preDefaultingInventDim.InventStorageDimMap::modifiedInventSiteFromParent(purchLine);
                }                

                this.modifiedPurchQty();
                break;

            case fieldNum(PurchLine, VariantId):
                purchLine.initInventDimIdFromVariantId();
                break;

            case fieldNum(PurchLine, PurchQty):
                this.modifiedPurchQty();
                break;

            case fieldNum(PurchLine, PurchUnit):
                this.modifiedPurchQty();
                break;
        }

        purchLine.modifiedField(_fieldId, _userInput);

        switch (_fieldId)
        {
            case fieldNum(PurchLine, PdsCWQty):
                InventMovement::bufferSetRemainQty(purchLine);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultingFields</Name>
				<Source><![CDATA[
    public List defaultingFields()
    {
        List result = new List(Types::Integer);

        result.addEnd(fieldNum(PurchLine, PurchId));
        result.addEnd(fieldNum(PurchLine, ItemId));
        result.addEnd(fieldNum(PurchLine, VariantId));
        result.addEnd(fieldNum(PurchLine, ProcurementCategory));
        result.addEnd(fieldNum(PurchLine, InventDimId));
        result.addEnd(fieldNum(PurchLine, PdsCWQty));
        result.addEnd(fieldNum(PurchLine, PurchQty));
        result.addEnd(fieldNum(PurchLine, PurchUnit));
        result.addEnd(fieldNum(PurchLine, PurchReceivedNow));
        result.addEnd(fieldNum(PurchLine, PriceUnit));
        result.addEnd(fieldNum(PurchLine, PurchPrice));
        result.addEnd(fieldNum(PurchLine, LinePercent));
        result.addEnd(fieldNum(PurchLine, LineDisc));
        result.addEnd(fieldNum(PurchLine, LineAmount));
        result.addEnd(fieldNum(PurchLine, PurchMarkup));
        result.addEnd(fieldNum(PurchLine, MultiLnDisc));
        result.addEnd(fieldNum(PurchLine, MultiLnPercent));
        result.addEnd(fieldNum(PurchLine, ProjId));
        result.addEnd(fieldNum(PurchLine, ActivityNumber));
        result.addEnd(fieldNum(PurchLine, ProjCategoryId));
        result.addEnd(fieldNum(PurchLine, ProjWorker));
        result.addEnd(fieldNum(PurchLine, ProjSalesCurrencyId));
        result.addEnd(fieldNum(PurchLine, AssetId));
        result.addEnd(fieldNum(PurchLine, AssetBookId));
        result.addEnd(fieldNum(PurchLine, CreateFixedAsset));
        result.addEnd(fieldNum(PurchLine, DeliveryPostalAddress));
        result.addEnd(fieldNum(PurchLine, Requester));
        result.addEnd(fieldNum(PurchLine, DeliveryDate));
        result.addEnd(fieldNum(PurchLine, ConfirmedDlv));
        result.addEnd(fieldNum(PurchLine, OrigCountryRegionId));
        result.addEnd(fieldNum(PurchLine, MatchingPolicy));
        
        if (PurchParameters::find().IsSupplierShipmentDatesEnabled)
        {
            result.addEnd(fieldNum(PurchLine, ShippingDateRequested));
            result.addEnd(fieldNum(PurchLine, ShippingDateConfirmed));

            result.addEnd(fieldNum(PurchLine, RequestedShipDate));
            result.addEnd(fieldNum(PurchLine, ConfirmedShipDate));
            result.addEnd(fieldNum(PurchLine, ShipCalendarId));
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDefaults</Name>
				<Source><![CDATA[
    public void initDefaults()
    {
        preDefaultingInventDim = purchLine.inventDim();
        preDefaultingInventDimParm = preDefaultingInventDim.toDimParm();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeChanges</Name>
				<Source><![CDATA[
    public void mergeChanges()
    {
        if (mergedInventDimId)
        {
            purchLine.InventDimId = mergedInventDimId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergableFields</Name>
				<Source><![CDATA[
    public Set mergableFields()
    {
        Set result = new Set(Types::Integer);
        result.add(fieldNum(PurchLine, InventDimId));
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validationFields</Name>
				<Source><![CDATA[
    public Set validationFields()
    {
        Set result = new Set(Types::Integer);
        result.add(fieldNum(PurchLine, PurchQty));
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedPurchQty</Name>
				<Source><![CDATA[
    private void modifiedPurchQty()
    {
        if ((purchLine.PurchUnit || purchLine.isCategoryBased())
            && (acceptedPurchQty != purchLine.PurchQty || acceptedPurchUnitId != purchLine.PurchUnit || prevStockedProduct != purchLine.isStocked()))
        {
            prevStockedProduct = purchLine.isStocked();
            var quantityErrorCorrectionMethods = InventMovementQuantityErrorCorrectionMethods::acceptUserInputWithWarning();
            boolean resetPrice = true;
            PurchLine::modifyPurchQty(purchLine, purchLine.inventDim(), resetPrice, quantityErrorCorrectionMethods);
            InventMovement::bufferSetRemainQty(purchLine);
            acceptedPurchQty = purchLine.PurchQty;
            acceptedPurchUnitId = purchLine.PurchUnit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifyInventoryDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Modifies the inventory dimensions on the purchase line.
    /// </summary>
    /// <param name = "_newInventDim">The new inventory dimension record.</param>
    public void modifyInventoryDimensions(InventDim _newInventDim)
    {
        InventDimGroupSetup inventDimGroupSetup     = InventDimGroupSetup::newItemId(purchLine.ItemId);
        List                dimProductFields        = inventDimGroupSetup.ecoResProductDimGroupSetup().activeDimensionFields();
        ListEnumerator      enumerator              = dimProductFields.getEnumerator();
        boolean             priceDiscSearchNeeded   = false;
        FieldId             inventDimFieldId;
        InventDim           inventDimOrig;

        inventDimOrig.data(purchLine.inventDim());

        purchLine.InventDimId = _newInventDim.InventDimId;
        purchLine.initFromProductDimensions(_newInventDim);

        if (enumerator)
        {
            while (enumerator.moveNext() && !priceDiscSearchNeeded)
            {
                inventDimFieldId = enumerator.current();

                // If a dimension was changed
                if (inventDimOrig.(inventDimFieldId) != _newInventDim.(inventDimFieldId))
                {
                    // and it is active for price search
                    if (InventDim::mustUseFieldPurchPriceDisc(inventDimFieldId, inventDimGroupSetup))
                    {
                        priceDiscSearchNeeded = true;
                    }
                }
                // then trigger price recalculation
                if (priceDiscSearchNeeded)
                {
                    purchLine.modifyInventDim(purchLine.inventDim(), inventDimFieldId, !purchLine.MatchingAgreementLine);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPurchLineForPurchReqBudgetRes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a purchase order line based on the currently referenced budget reservation line and its referenced purchase requisition line.
    /// </summary>
    public void createPurchLineForPurchReqBudgetRes()
    {
        PurchLine purchLineLocal;
        purchLineLocal.data(purchLine);

        List purchReqLineRecordList  = new List(Types::Record);
        BudgetReservationLine_PSN budgetReservationLine   = BudgetReservationLine_PSN::find(purchLineLocal.BudgetReservationLine_PSN);
        PurchReqLine purchReqLine = PurchReqLine::find(budgetReservationLine.PurchReqLine);
        PurchReqTable purchReqTable = PurchReqTable::find(purchReqLine.PurchReqTable);

        purchReqLineRecordList.addEnd(purchReqLine);
        purchTable.selectForUpdate(true);

        PurchAutoCreate_PurchReq purchAutoCreate_PurchReq = PurchAutoCreate_PurchReq::construct(purchReqTable);
        purchAutoCreate_PurchReq.setPurchReqLines([purchReqLine]);
        purchAutoCreate_PurchReq.parmPurchTable(purchTable);
        purchAutoCreate_PurchReq.parmPurchLine(purchLineLocal);
        purchAutoCreate_PurchReq.parmPurchReqLineRecordList(purchReqLineRecordList);
        purchAutoCreate_PurchReq.parmRequisitionPurchaseOrderGeneration(RequisitionPurchaseOrderGeneration::construct());

        //
        // Needs to delete current purchase line and all its reference data first,
        // then re-create a new purchase line and its reference data based on new reference.
        //
        ttsBegin;

        purchLine.delete();

        purchAutoCreate_PurchReq.createPurchLine();

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiateInventUpd_Estimated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates an instance of the <c>InventUpd_Estimated</c>.
    /// </summary>
    /// <param name = "_inventMovSubType">An <c>InventMovSubType</c> value.</param>
    /// <returns>An <c>InventUpd_Estimated</c> instance.</returns>
    protected InventUpd_Estimated instantiateInventUpd_Estimated(InventMovSubType _inventMovSubType)
    {
        return InventUpd_Estimated::newInventMovement(this.instantiateInventMovement(_inventMovSubType));
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiateInventUpd_DeleteMovement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates an instance of the <c>InventUpd_DeleteMovement</c>.
    /// </summary>
    /// <param name = "_inventMovSubType">An <c>InventMovSubType</c> value.</param>
    /// <param name = "_showInfoDelReserv">A Boolean value indicating whether an info message should be shown.</param>
    /// <returns>An <c>InventUpd_DeleteMovement</c> instance.</returns>
    protected InventUpd_DeleteMovement instantiateInventUpd_DeleteMovement(InventMovSubType _inventMovSubType, boolean _showInfoDelReserv)
    {
        return InventUpd_DeleteMovement::newMovement(this.instantiateInventMovement(_inventMovSubType), _showInfoDelReserv);
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiateInventMovement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates an instance of the <c>InventMovement</c> class.
    /// </summary>
    /// <param name = "_inventMovSubType">An <c>InventMovSubType</c> value.</param>
    /// <returns>An <c>InventMovement</c> instance.</returns>
    protected InventMovement instantiateInventMovement(InventMovSubType _inventMovSubType)
    {
        return InventMovement::construct(purchLine, _inventMovSubType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventoryOnInsert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the inventory when a purchase line is inserted into the database.
    /// </summary>
    /// <returns>A new instance of the <c>InventUpd_Estimated</c> class.</returns>
    public InventUpd_Estimated updateInventoryOnInsert()
    {
        InventUpd_Estimated estimated = this.instantiateInventUpd_Estimated(InventMovSubType::None);
        if (estimated)
        {
            estimated.updateNow();
        }

        return estimated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventoryOnUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the inventory when a purchase line is updated.
    /// </summary>
    /// <returns>A new instance of the <c>InventUpd_Estimated</c> class.</returns>
    public InventUpd_Estimated updateInventoryOnUpdate()
    {
        InventUpd_Estimated estimated = this.instantiateInventUpd_Estimated(InventMovSubType::None);
        if (estimated)
        {
            estimated.updateNow();
        }

        return estimated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventoryOnDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the inventory on deletion of a purchase order line record.
    /// </summary>
    /// <param name = "_showInfoDelReserv">A Boolean value indicating whether an info message should be shown.</param>
    /// <returns>The deletion movement class.</returns>
    public InventUpd_DeleteMovement updateInventoryOnDelete(boolean _showInfoDelReserv)
    {
        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            // Remove ref on ForcastSales
            ForecastSales forecastSales;

            while select forupdate * from forecastSales
            index PSARefPurchRecIdIdx
            where forecastSales.psaRefPurchLine == purchLine.RecId
            {
                forecastSales.psaRefPurchLine = 0;
                forecastSales.update();
            }
        }

        InventUpd_DeleteMovement deleteMovement = this.instantiateInventUpd_DeleteMovement(InventMovSubType::None, _showInfoDelReserv);
        if (deleteMovement)
        {
            deleteMovement.updateNow();
        }

        return deleteMovement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deletePendingRegistrationsNonStocked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the pending registration records for the line.
    /// </summary>
    public void deletePendingRegistrationsNonStocked()
    {
        if (purchLine.isTangible())
        {
            TradeNonStockedRegistrationHelper::newFromSalesPurchLine(purchLine).deletePendingRegistration();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseList</Name>
				<Source><![CDATA[
    private List reverseList(List _list)
    {
        List result = new List(Types::Integer);
        Enumerator enum = _list.getEnumerator();

        while (enum.moveNext())
        {
            result.addStart(enum.current());
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPriceDiscTriggeringFieldWithLargestIndex</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the price/discount triggering field that has the largest index in the defaulting fields list.
    /// </summary>
    /// <param name = "_inputFieldsSet">Set containing the fields input by the user during an import.</param>
    /// <returns>The price/discount triggering field that has the largest index in the defaulting fields list</returns>
    /// <remarks>
    /// This method uses 2 sets (_inputFieldsSet and setPriceDiscCalcTriggeringFields) and a list (defaultingFields) to
    /// figure out the best field on <c>PurchLine</c> that PurchLine::setPriceDisc should be called. Because,
    /// we want to guarantee that price/discount calculation always happens at least once, a fallback to ItemId is added.
    /// </remarks>
    public FieldId findPriceDiscTriggeringFieldWithLargestIndex(Set _inputFieldsSet)
    {
        // Get the set of fields that trigger price/discount calculation on the PurchLine table.
        Set setPriceDiscCalcTriggeringFields = PurchLineTypeHelper::instance().getPriceCalcTriggeringFieldsSet();

        // Find the fields that are in the triggering field set that are also in the input field set
        // in order to know if it is necessary to traverse the full list of defaulting fields.
        Set commonPriceDiscCalcTriggeringFields = Set::intersection(_inputFieldsSet, setPriceDiscCalcTriggeringFields);
        if (!commonPriceDiscCalcTriggeringFields.empty())
        {
            // Use the reverse list of defaulting fields to guarantee that we get the last price/discount calculation triggering field to be defaulted.
            List reversedDefaultingFields = this.reverseList(this.defaultingFields());
            Enumerator reversedDefaultingFieldsEnumerator = reversedDefaultingFields.getEnumerator();

            while (reversedDefaultingFieldsEnumerator.moveNext())
            {
                FieldId currentFieldId = reversedDefaultingFieldsEnumerator.current();
                if (commonPriceDiscCalcTriggeringFields.in(currentFieldId))
                {
                    return currentFieldId;
                }
            }
        }

        return fieldNum(PurchLine, ItemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>instrumentationLogger</Name>
				<Source><![CDATA[
    final internal PurchInstrumentationLogger instrumentationLogger()
    {
        if (!instrumentationLogger)
        {
            instrumentationLogger = PurchInstrumentationLogger::createLogger(classId2Name(classIdGet(this)));
        }

        return instrumentationLogger;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>