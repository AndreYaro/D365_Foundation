<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailPricingDataManagerV2</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>RetailPricingDataManagerV2</c> class implements the queries for <c>IPricingDataAccessor</c>.
/// These queries search for pricing rules and product details from the AX database using caching strategy.
/// </summary>
public class RetailPricingDataManagerV2 extends RetailPricingDataManager
{
    private static readonly str InventDimAllBlank = InventDim::inventDimIdBlank();

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>ReadRetailDiscounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets retail discounts.
    /// </summary>
    /// <param name = "items">An object of item number.</param>
    /// <param name = "priceGroups">An object of price group.</param>
    /// <param name = "minActiveDate">A minimum active date to read retail discount.</param>
    /// <param name = "maxActiveDate">A maximum active date to read retail discount.</param>
    /// <param name = "currencyCode">A currency code to read retail discount.</param>
    /// <param name = "settings">Settings.</param>
    /// <returns>Retail discounts.</returns>
    /// <remarks>
    /// Uses a caching strategy to retreive discounts for products and variant categories 
    /// Skip DB calls when discount configuration for product, variant, inventDim and categories does not exists
    /// </remarks>
    public System.Object ReadRetailDiscounts(
            System.Object items,
            System.Object priceGroups,
            System.DateTimeOffset minActiveDate,
            System.DateTimeOffset maxActiveDate,
            System.String currencyCode,
            Microsoft.Dynamics.Commerce.Runtime.DataModel.QueryResultSettings settings)
    {
        using(var ReadRetailDiscountsTelemetry = RetailPricingInstrumentationSegment::construct(
            RetailInstrumentationSegmentArea, methodStr(RetailPricingDataManagerV2, ReadRetailDiscounts)))
        {
            ValidFromDate minFromDate =  this.GetDateInChannelTimeZone(minActiveDate);
            ValidFromDate maxToDate =  this.GetDateInChannelTimeZone(maxActiveDate);
            UserId userId = curUserId();

            RetailPeriodicDiscount periodicDiscount;
            RetailPeriodicDiscountLine periodicDiscountLine;

            RetailDiscountPriceGroup discountPriceGroup;
            RetailGroupMemberLine retailGroupMemberLine;
            EcoResProductCategory productCategory;
            RetailSpecialCategoryMember variantCategory;
            RetailCategoryContainmentLookup categoryLookup;
            RetailGroupMemberLine groupMemberLineForCategoryVariant;
            offerIdSet = new Set(Types::String);

            Map validationPeriodLookup = new Map(Types::String, Types::AnyType);
            Microsoft.Dynamics.Commerce.Runtime.DataModel.PeriodicDiscount crtDiscount;

            // convert price group record ids into temp table for join
            TmpRecIdFilter priceDiscGroupTmp = this.getTmpPriceGroupTableFromGroupIds(priceGroups);

            delete_from mTmpOrderData;

            CLRObject discountList = this.createCLRList(new Microsoft.Dynamics.Commerce.Runtime.DataModel.PeriodicDiscount());

            Set discountIdProductDiscountsSet = new Set(Types::Int64); // Collection of RecIds of discounts which have lines with only product in applicability.
            Set discountIdVariantDiscountsSet = new Set(Types::Int64); // Collection of RecIds of discounts which have lines with variant in applicability.
            Set discountIdInventDimDiscountsSet = new Set(Types::Int64); // Collection of RecIds of discounts which have lines with product dimension values in applicability.
            Set discountIdCategoryDiscountsSet = new Set(Types::Int64); // Collection of RecIds of discounts which have lines with category in applicability.

            Set couponOfferIds = this.getCouponCodeOfferIds();

            // Get discount data table for MatchAllAssociatedPriceGroups set as yes and associated price groups.
            RetailTmpOfferIdWithPriceGroups offerIdWithPriceDiscGroupTmp = this.getOfferIdAndAssociatedPriceGroupList();

            RetailPricingDataManagerV2::getRetailDiscountApplicableOffers(
                minFromDate,
                maxToDate,
                priceDiscGroupTmp,
                couponOfferIds,
                discountIdProductDiscountsSet,
                discountIdVariantDiscountsSet,
                discountIdInventDimDiscountsSet,
                discountIdCategoryDiscountsSet);

            this.readRetailDiscountsForProductCategories(
                discountIdCategoryDiscountsSet,
                discountList,
                minFromDate,
                maxToDate,
                priceDiscGroupTmp,
                validationPeriodLookup,
                offerIdWithPriceDiscGroupTmp);

            this.readRetailDiscountsForProducts(
                discountIdProductDiscountsSet,
                discountList,
                minFromDate,
                maxToDate,
                priceDiscGroupTmp,
                validationPeriodLookup,
                offerIdWithPriceDiscGroupTmp);

            this.readRetailDiscountsForVariants(
                discountIdVariantDiscountsSet,
                discountList,
                minFromDate,
                maxToDate,
                priceDiscGroupTmp,
                validationPeriodLookup,
                offerIdWithPriceDiscGroupTmp);

            this.readRetailDiscountsForProductDimensions(
                discountIdInventDimDiscountsSet,
                discountList,
                minFromDate,
                maxToDate,
                priceDiscGroupTmp,
                validationPeriodLookup,
                offerIdWithPriceDiscGroupTmp);

            tmpOrderDataInsertList.insertDatabase();

            return discountList.AsReadOnly();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRetailDiscountApplicableOffers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get list of discounts which are active for the given period and linked to the given set of price groups.
    /// </summary>
    /// <param name = "_fromDate">From date.</param>
    /// <param name = "_toDate">To date.</param>
    /// <param name = "_priceDiscGroupTmp">Temp table containing price group RecId.</param>
    /// <param name = "_couponOfferIds">Collection of coupon offer Ids.</param>
    /// <param name = "_discountIdProductsDiscountsSet">List of discount RecIds which has applicability for Product.</param>
    /// <param name = "_discountIdVariantsDiscountsSet">List of discount RecIds which has applicability for Product variant.</param>
    /// <param name = "_discountIdInventDimDiscountsSet">List of discount RecIds which has applicability for product dimensions.</param>
    /// <param name = "_discountIdCategoryDiscountsSet">List of discount RecIds which has applicability for categories.</param>
    private static void getRetailDiscountApplicableOffers(ValidFromDate _fromDate, 
                                ValidFromDate _toDate, 
                                TmpRecIdFilter _priceDiscGroupTmp, 
                                Set _couponOfferIds,
                                Set _discountIdProductsDiscountsSet,
                                Set _discountIdVariantsDiscountsSet,
                                Set _discountIdInventDimDiscountsSet,
                                Set _discountIdCategoryDiscountsSet)
    {
        RetailPeriodicDiscount periodicDiscount;
        RetailDiscountPriceGroup discountPriceGroup;

        using(var t = RetailInstrumentationSegment::construct(RetailInstrumentationSegmentArea, 'RetailPricingDataManagerV2.ReadRetailDiscounts.CacheApplicableOffersProperties'))
        {
            int applicableOffers = 0;
            while select RecId, IsDiscountCodeRequired, OfferId from periodicDiscount
                    where periodicDiscount.PeriodicDiscountType != RetailDiscountOfferTypeBase::Promotion && periodicDiscount.PeriodicDiscountType != RetailDiscountOfferTypeBase::Shipping
                        && periodicDiscount.Status == RetailDisabledEnabled::Enabled
                        && ((periodicDiscount.ValidFrom <= _fromDate || periodicDiscount.ValidFrom <= noDate)
                        && (periodicDiscount.ValidTo >= _toDate || periodicDiscount.ValidTo <= noDate))
                    exists join discountPriceGroup
                        where discountPriceGroup.OfferId == periodicDiscount.OfferId
                    exists join RefRecId from _priceDiscGroupTmp
                        where _priceDiscGroupTmp.RefRecId == discountPriceGroup.PriceDiscGroup
            {
                // Only add coupon discounts for further processing when:
                // Manully apply coupon code to return transaction is false (so discount may apply even when no coupon code is given).
                // and coupon code matches transaction coupons.
                // Note: Do not check if there is line with negative quantity, since the line may well be the last line and not saved to DB yet.
                // The recalculation is only triggered when certain fields are set (based on price discount policy), and no recaluclation is triggered upon saving thus discount will be incorrect for this last line.
                if (periodicDiscount.IsDiscountCodeRequired
                    && !_couponOfferIds.in(periodicDiscount.OfferId)
                    && RetailConfigurationParameters::getManuallyApplyDiscountsToReturnProduct())
                {
                    continue;
                }

                boolean offerHasDiscountForProducts, offerHasDiscountForVariants, offerHasDiscountsForInventDim, offerHasDiscountsForCategories;
                [offerHasDiscountForProducts, offerHasDiscountForVariants, offerHasDiscountsForInventDim, offerHasDiscountsForCategories] = RetailPricingCacheManager::checkAvailableItemDiscountsForOffer(periodicDiscount.DataAreaId, periodicDiscount.OfferId);

                if (offerHasDiscountForProducts)
                {
                    _discountIdProductsDiscountsSet.add(periodicDiscount.RecId);
                }

                if (offerHasDiscountForVariants)
                {
                    _discountIdVariantsDiscountsSet.add(periodicDiscount.RecId);
                }

                if (offerHasDiscountsForInventDim)
                {
                    _discountIdInventDimDiscountsSet.add(periodicDiscount.RecId);
                }

                if (offerHasDiscountsForCategories)
                {
                    _discountIdCategoryDiscountsSet.add(periodicDiscount.RecId);
                }

                applicableOffers++;
            }

            t.rowCount = applicableOffers;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ReadPriceAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets price adjustments.
    /// </summary>
    /// <param name = "items">An object of item number.</param>
    /// <param name = "priceGroups">An object of price group.</param>
    /// <param name = "minActiveDate">A minimum active date.</param>
    /// <param name = "maxActiveDate">A maximum active date.</param>
    /// <param name = "settings">The query result settings.</param>
    /// <returns>The adjusted price.</returns>
    /// <remarks>
    /// Check for exists configuration for given price groups, skip all calls if no configuration found
    /// </remarks>
    public System.Object ReadPriceAdjustments(
            System.Object items,
            System.Object priceGroups,
            System.DateTimeOffset minActiveDate,
            System.DateTimeOffset maxActiveDate,
            Microsoft.Dynamics.Commerce.Runtime.DataModel.QueryResultSettings settings)
    {
        RetailDiscountPriceGroup promoPriceGroup;

        ValidFromDate minFromDate = this.GetDateInChannelTimeZone(minActiveDate);
        ValidToDate maxToDate = this.GetDateInChannelTimeZone(maxActiveDate);

        TmpRecIdFilter priceDiscGroupTmp = this.getTmpPriceGroupTableFromGroupIds(priceGroups);

        RetailPeriodicDiscount promo;
        select firstonly RecId from promo 
            where promo.PeriodicDiscountType == RetailDiscountOfferTypeBase::Promotion
                   && promo.Status == RetailDisabledEnabled::Enabled
                   && ((promo.ValidFrom <= minFromDate || promo.ValidFrom <= noDate)
                   && (promo.ValidTo >= maxToDate || promo.ValidTo <= noDate))
            exists join promoPriceGroup
                where promoPriceGroup.OfferId == promo.OfferId
            exists join priceDiscGroupTmp
                where priceDiscGroupTmp.RefRecId == promoPriceGroup.PriceDiscGroup;

        if (!promo)
        {
            return this.createCLRList(new Microsoft.Dynamics.Commerce.Runtime.DataModel.PriceAdjustment());
        }

        return super(items, priceGroups, minActiveDate, maxActiveDate, settings);
    }

]]></Source>
			</Method>
			<Method>
				<Name>ReadPriceTradeAgreements</Name>
				<Source><![CDATA[
    public System.Object ReadPriceTradeAgreements(
                System.Object itemIds,
                System.Object priceGroups,
                System.String customerAccount,
                System.DateTimeOffset minActiveDate,
                System.DateTimeOffset maxActiveDate,
                System.String currencyCode,
                Microsoft.Dynamics.Commerce.Runtime.DataModel.QueryResultSettings settings)
    {
        RetailChannelTable retailChannelTable = RetailChannelTable::findByRecId(mChannelRecId);
        ValidFromDate minFromDate = this.GetDateInChannelTimeZone(minActiveDate);
        ValidToDate maxToDate = this.GetDateInChannelTimeZone(maxActiveDate);

        CLRObject clrPriceGroups = priceGroups;

        CLRObject tradeAgreementList = this.createCLRList(new Microsoft.Dynamics.Commerce.Runtime.DataModel.TradeAgreement());

        if (RetailPricingKillSwitch::useLegacyPriceTradeAgreementDataAccess())
        {
            this.readPriceTradeAgreementsInternalLegacy(minFromDate, maxToDate, customerAccount, currencyCode, retailChannelTable, clrPriceGroups, tradeAgreementList);
        }
        else
        {
            this.readPriceTradeAgreementsInternalV2(minFromDate, maxToDate, customerAccount, currencyCode, retailChannelTable, clrPriceGroups, tradeAgreementList);
        }

        return tradeAgreementList.AsReadOnly();
    }

]]></Source>
			</Method>
			<Method>
				<Name>readPriceTradeAgreementsInternalV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Read price trade agreements.
    /// </summary>
    /// <param name = "_minFromDate">Minimum from date of the order lines.</param>
    /// <param name = "_maxToDate">Max to date of the order lines.</param>
    /// <param name = "_customerAccount">Customer account of the order.</param>
    /// <param name = "_currencyCode">Currency code.</param>
    /// <param name = "_retailChannelTable">RetailChannelTable buffer.</param>
    /// <param name = "_clrPriceGroups">Collection of price groups.</param>
    /// <param name = "_tradeAgreementList">Collection of trade agreements to be populated.</param>
    private void readPriceTradeAgreementsInternalV2(
        ValidFromDate _minFromDate,
        ValidToDate _maxToDate,
        System.String _customerAccount,
        System.String _currencyCode,
        RetailChannelTable _retailChannelTable,
        CLRObject _clrPriceGroups,
        CLRObject _tradeAgreementList)
    {
        // Trade agreements with price sales type and item code = PriceDiscItemRelation::Table.
        // For Price trade agreement, Item code is restricted to PriceDiscProductCodeType::Table.
        PriceDiscTable tradeAgreement;
        InventDim inventDim;
        SysDaQueryExpression accountCodeClause;

        // Account code = PriceDiscPartyCodeType::All
        accountCodeClause = new SysDaEqualsExpression(
            new SysDaFieldExpression(tradeAgreement, fieldStr(PriceDiscTable, AccountCode)),
            new SysDaValueExpression(PriceDiscPartyCodeType::All));

        // Account code = PriceDiscPartyCodeType::Table
        SysDaQueryExpression accountCodeTableClause = new SysDaEqualsExpression(
            new SysDaFieldExpression(tradeAgreement, fieldStr(PriceDiscTable, AccountCode)),
            new SysDaValueExpression(PriceDiscPartyCodeType::Table));
        accountCodeTableClause = new SysDaAndExpression(
            accountCodeTableClause,
            new SysDaEqualsExpression(new SysDaFieldExpression(tradeAgreement, fieldStr(PriceDiscTable, AccountRelation)), new SysDaValueExpression(_customerAccount)));
        accountCodeClause = new SysDaOrExpression(accountCodeClause, accountCodeTableClause);

        SysDaQueryObject itemRelationCustomerQuery =
            RetailPricingDataManagerTradeAgreementsQuery::getQueryForItemRelationTable(
            _currencyCode,
            _minFromDate,
            _maxToDate,
            tradeAgreement,
            inventDim,
            mTmpOrderItem,
            _retailChannelTable);
        itemRelationCustomerQuery.whereClause(new SysDaAndExpression(itemRelationCustomerQuery.whereClause(), accountCodeClause));

        SysDaSearchObject searchObject = new SysDaSearchObject(itemRelationCustomerQuery);
        SysDaSearchStatement searchStatement = new SysDaSearchStatement();
        while (searchStatement.findNext(searchObject))
        {
            _tradeAgreementList.Add(this.ConvertToTradeAgreement(tradeAgreement, inventDim));
        }

        // Account code = PriceDiscPartyCodeType::Group
        if (_clrPriceGroups.get_Count() > 0)
        {
            RetailPricingPriceDiscGroupTmp priceDiscGroupTmp;
            System.Collections.IEnumerator enumerator = _clrPriceGroups.GetEnumerator();

            if (RetailPricingCalcBulkInsertTempTableFlight::instance().isEnabled())
            {
                RecordInsertList recordInsertList = new RecordInsertList(
                    tableNum(RetailPricingPriceDiscGroupTmp),
                    true, // skip insert
                    true, // skip database log
                    true, // skip events
                    true, // skip aos validation
                    true, // skip RLS validation
                    priceDiscGroupTmp); // buffer where records will be inserted

                while (enumerator.MoveNext())
                {
                    priceDiscGroupTmp.clear();
                    priceDiscGroupTmp.GroupId = enumerator.Current;
                    recordInsertList.add(priceDiscGroupTmp);
                }
                recordInsertList.insertDatabase();
            }
            else
            {
                while (enumerator.MoveNext())
                {
                    priceDiscGroupTmp.GroupId = enumerator.Current;
                    priceDiscGroupTmp.doInsert();
                }
            }

            SysDaQueryObject itemRelationCustomerGroupQuery =
                RetailPricingDataManagerTradeAgreementsQuery::getQueryForItemRelationTableAccountCodeGroup(
                _currencyCode,
                _minFromDate,
                _maxToDate,
                tradeAgreement,
                inventDim,
                mTmpOrderItem,
                priceDiscGroupTmp,
                _retailChannelTable);

            SysDaQueryExpression accountCodeGroupClause = new SysDaEqualsExpression(
                new SysDaFieldExpression(tradeAgreement, fieldStr(PriceDiscTable, AccountCode)), new SysDaValueExpression(PriceDiscPartyCodeType::GroupId));
            itemRelationCustomerGroupQuery.whereClause(new SysDaAndExpression(itemRelationCustomerGroupQuery.whereClause(), accountCodeGroupClause));

            searchObject = new SysDaSearchObject(itemRelationCustomerGroupQuery);
            searchStatement = new SysDaSearchStatement();
            while (searchStatement.findNext(searchObject))
            {
                _tradeAgreementList.Add(this.ConvertToTradeAgreement(tradeAgreement, inventDim));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>readPriceTradeAgreementsInternalLegacy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Read price trade agreements (legacy).
    /// </summary>
    /// <param name = "_minFromDate">Minimum from date of the order lines.</param>
    /// <param name = "_maxToDate">Max to date of the order lines.</param>
    /// <param name = "_customerAccount">Customer account of the order.</param>
    /// <param name = "_currencyCode">Currency code.</param>
    /// <param name = "_retailChannelTable">RetailChannelTable buffer.</param>
    /// <param name = "_clrPriceGroups">Collection of price groups.</param>
    /// <param name = "_tradeAgreementList">Collection of trade agreements to be populated.</param>
    private void readPriceTradeAgreementsInternalLegacy(
        ValidFromDate _minFromDate,
        ValidToDate _maxToDate,
        System.String _customerAccount,
        System.String _currencyCode,
        RetailChannelTable _retailChannelTable,
        CLRObject _clrPriceGroups,
        CLRObject _tradeAgreementList)
    {
        // Trade agreements with price sales type and item code = PriceDiscItemRelation::Table.
        // For Price trade agreement, Item code is restricted to PriceDiscProductCodeType::Table.
        PriceDiscTable tradeAgreement;
        InventDim inventDim;
        SysDaQueryExpression accountCodeClause;

        // Account code = PriceDiscPartyCodeType::All
        accountCodeClause = new SysDaEqualsExpression(
            new SysDaFieldExpression(tradeAgreement, fieldStr(PriceDiscTable, AccountCode)),
            new SysDaValueExpression(PriceDiscPartyCodeType::All));

        // Account code = PriceDiscPartyCodeType::Table
        SysDaQueryExpression accountCodeTableClause = new SysDaEqualsExpression(
            new SysDaFieldExpression(tradeAgreement, fieldStr(PriceDiscTable, AccountCode)),
            new SysDaValueExpression(PriceDiscPartyCodeType::Table));
        accountCodeTableClause = new SysDaAndExpression(
            accountCodeTableClause,
            new SysDaEqualsExpression(new SysDaFieldExpression(tradeAgreement, fieldStr(PriceDiscTable, AccountRelation)), new SysDaValueExpression(_customerAccount)));
        accountCodeClause = new SysDaOrExpression(accountCodeClause, accountCodeTableClause);

        // Account code = PriceDiscPartyCodeType::Group
        SysDaQueryExpression accountCodeGroupClause = new SysDaEqualsExpression(
            new SysDaFieldExpression(tradeAgreement, fieldStr(PriceDiscTable, AccountCode)), new SysDaValueExpression(PriceDiscPartyCodeType::GroupId));
        accountCodeClause = new SysDaOrExpression(accountCodeClause, accountCodeGroupClause);

        SysDaQueryObject itemRelationCustomerGroupQuery =
            RetailPricingDataManagerTradeAgreementsQuery::getQueryForItemRelationTable(
            _currencyCode,
            _minFromDate,
            _maxToDate,
            tradeAgreement,
            inventDim,
            mTmpOrderItem,
            _retailChannelTable);
        itemRelationCustomerGroupQuery.whereClause(new SysDaAndExpression(itemRelationCustomerGroupQuery.whereClause(), accountCodeClause));
        SysDaSearchObject searchObject = new SysDaSearchObject(itemRelationCustomerGroupQuery);
        SysDaSearchStatement searchStatement = new SysDaSearchStatement();
        while (searchStatement.findNext(searchObject))
        {
            // skip if group-specific but not channel group or customer group
            // Cannot add all price groups into the where clause as it risks running over SQL statement's max length.
            if (tradeAgreement.AccountCode == PriceDiscPartyCodeType::GroupId
                && !_clrPriceGroups.Contains(tradeAgreement.AccountRelation))
            {
                continue;
            }

            _tradeAgreementList.Add(this.ConvertToTradeAgreement(tradeAgreement, inventDim));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ReadRetailDiscountsForProductCategories</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds category based periodic discount lines and convert to PeriodicDiscount with ItemId and InventDimId.
    /// </summary>
    /// <param name = "_offerCategoryDiscountsSet">Collection of disocunts which have category based lines.</param>
    /// <param name = "_discountList">Collection of <c>PeriodicDiscount</c> to which applicable <c>PeriodicDiscount</c> found will be added.</param>
    /// <param name = "_minFromDate">Minimum from date in the order lines.</param>
    /// <param name = "_maxToDate">Maximum to date in the order lines.</param>
    /// <param name = "_priceDiscGroupTmp">Temp table containing price group RecId.</param>
    /// <param name = "_validationPeriodLookup">Validation period lookup.</param>
    /// <param name = "_offerIdWithPriceGroups">Discount data table for MatchAllAssociatedPriceGroups set as yes and associated price groups.</param>
    private void ReadRetailDiscountsForProductCategories(
        Set _offerCategoryDiscountsSet,
        CLRObject _discountList,
        ValidFromDate _minFromDate,
        ValidFromDate _maxToDate,
        TmpRecIdFilter _priceDiscGroupTmp,
        Map _validationPeriodLookup,
        RetailTmpOfferIdWithPriceGroups _offerIdWithPriceGroups)
    {
        if (_offerCategoryDiscountsSet.elements())
        {
            using(var t = RetailPricingInstrumentationSegment::construct(
                classStr(RetailPricingDataManagerV2), 'ReadRetailDiscounts.ForCachedProductsAndVariantCategories'))
            {
                if (!RetailPricingCacheForDataManager::shouldQueryRetailDiscountsCategory())
                {
                    return;
                }

                // Single record caching takes around 0.5ms to retrieve.
                // Dict based caching is much faster in this case, and works well for category-based discounts where the cache has high hit percentage.
                // And data does not get updated during this transaction.
                Map discountMap = new Map(Types::Int64, Types::Record);
                Map discountLineMap = new Map(Types::Int64, Types::Record);

                while select mTmpOrderItem
                        order by mTmpOrderItem.Product
                        where mTmpOrderItem.Product != 0 || mTmpOrderItem.Variant != 0
                {
                    container variantCategoriesRecId = conNull();
                    container productCategoriesRecId = conNull();

                    if (mTmpOrderItem.Variant != 0)
                    {
                        variantCategoriesRecId = RetailPricingCacheManager::getVariantCategories(mTmpOrderItem.Variant);
                    }

                    productCategoriesRecId = RetailPricingCacheManager::getProductCategories(mTmpOrderItem.Product);

                    SetEnumerator enumerator = _offerCategoryDiscountsSet.getEnumerator();

                    while (enumerator.moveNext())
                    {
                        RefrecId discountRecId = enumerator.current();

                        Common discount;

                        if (discountMap.exists(discountRecId))
                        {
                            discount = discountMap.lookup(discountRecId);
                        }
                        else
                        {
                            discount = RetailPeriodicDiscount::find(discountRecId);

                            if (!discount)
                            {
                                continue;
                            }

                            // Downcast to actual child table type before putting it into map. Otherwise it will remain as parent table type.
                            if (discount is RetailDiscountOffer)
                            {
                                discount = discount as RetailDiscountOffer;
                            }
                            else if (discount is RetailDiscountMultibuy)
                            {
                                discount = discount as RetailDiscountMultibuy;
                            }
                            else if (discount is RetailDiscountMixAndMatch)
                            {
                                discount = discount as RetailDiscountMixAndMatch;
                            }
                            else if (discount is RetailDiscountThreshold)
                            {
                                discount = discount as RetailDiscountThreshold;
                            }

                            discountMap.insert(discountRecId, discount);
                        }

                        RetailPeriodicDiscount periodicDiscount = discount as RetailPeriodicDiscount;

                        if (this.isDiscountApplicable(periodicDiscount.OfferId, periodicDiscount.MatchAllAssociatedPriceGroups, _priceDiscGroupTmp, _offerIdWithPriceGroups))
                        {
                            // We need ItemId and InventDimId in the PeriodicDiscount object since Pricing engine uses it to see if the PeriodicDiscount applies.
                            this.buildCrtPeriodicDiscountForCategoryDiscountLine(
                                discount, mTmpOrderItem.itemId, mTmpOrderItem.inventDimId, productCategoriesRecId, _discountList, _validationPeriodLookup, discountLineMap);

                            if (variantCategoriesRecId != conNull())
                            {
                                this.buildCrtPeriodicDiscountForCategoryDiscountLine(
                                    discount, mTmpOrderItem.itemId, mTmpOrderItem.inventDimId, variantCategoriesRecId, _discountList, _validationPeriodLookup, discountLineMap);
                            }
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCrtPeriodicDiscountForCategoryDiscountLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds CRT discount line object for all category-based discount lines in the given discount which matches one of the categories in the list.
    /// </summary>
    /// <param name = "_discount">Periodic discount.</param>
    /// <param name = "_itemId">Item Id which will be used to generate PeriodicDiscount.</param>
    /// <param name = "_inventDimId">InventDimId which will be used to generate <c>PeriodicDiscount</c>.</param>
    /// <param name = "_categoriesRecId">Collection of category RecIds to which line item belongs to (including current category and ancestor category). </param>
    /// <param name = "_discountList">Collection of <c>PeriodicDiscount</c> to which applicable <c>PeriodicDiscount</c> found will be added.</param>
    /// <param name = "_validationPeriodLookup">Validation period lookup.</param>
    /// <param name = "_sharedDiscountLineMap">Shared discount line map.</param>
    [Hookable(false), Wrappable(false)]
    protected void buildCrtPeriodicDiscountForCategoryDiscountLine(
        RetailPeriodicDiscount _discount,
        str _itemId,
        str _inventDimId,
        container _categoriesRecId,
        CLRObject _discountList,
        Map _validationPeriodLookup,
        Map _sharedDiscountLineMap)
    {
        using(var t = RetailInstrumentationSegment::construct(RetailInstrumentationSegmentArea, funcName()))
        {
            Microsoft.Dynamics.Commerce.Runtime.DataModel.PeriodicDiscount crtDiscount;
            Set categoryIdList = RetailPricingCacheManager::getCategoryIdListForPeriodicDiscount(_discount.RecId);

            if (!categoryIdList.empty())
            {
                for (int i = 1; i <= conLen(_categoriesRecId); i++)
                {
                    RecId categoryRecId = conpeek(_categoriesRecId, i);

                    if (categoryIdList.in(categoryRecId))
                    {
                        container discountLineIds =
                            RetailPricingCacheManager::getCategoryLineIdForDiscount(_discount.RecId, categoryRecId);

                        if (discountLineIds)
                        {
                            int conLength = conLen(discountLineIds);
                            for (int j = 1; j <= conLength; j++)
                            {
                                RefRecId discountLineRecId = conPeek(discountLineIds, j);

                                RetailPeriodicDiscountLine discountLine;
                                if(_sharedDiscountLineMap.exists(discountLineRecId))
                                {
                                    discountLine = _sharedDiscountLineMap.lookup(discountLineRecId);
                                }
                                else
                                {
                                    discountLine = RetailPeriodicDiscountLine::find(discountLineRecId);

                                    if (!discountLine)
                                    {
                                        continue;
                                    }

                                    // Cast to actual sub type.
                                    if (discountLine is RetailDiscountLineOffer)
                                    {
                                        discountLine = discountLine as RetailDiscountLineOffer;
                                    }
                                    else if (discountLine is RetailDiscountLineMixAndMatch)
                                    {
                                        discountLine = discountLine as RetailDiscountLineMixAndMatch;
                                    }
                                    else if (discountLine is RetailDiscountLineMultibuy)
                                    {
                                        discountLine = discountLine as RetailDiscountLineMultibuy;
                                    }
                                    else if (discountLine is RetailDiscountLineThresholdApplying)
                                    {
                                        discountLine = discountLine as RetailDiscountLineThresholdApplying;
                                    }

                                    _sharedDiscountLineMap.insert(discountLineRecId, discountLine);
                                }

                                crtDiscount = this.ConvertToCrtPeriodicDiscountV2(
                                    _discount,
                                    discountLine,
                                    UnitOfMeasure::find(discountLine.unitOfMeasure),
                                    0, // discount type as required by the method.
                                    _itemId,
                                    _inventDimId);

                                _discountList.Add(crtDiscount);

                                crtDiscount.ValidationPeriod = this.setValidationPeriod(_discount.ValidationPeriodId, _validationPeriodLookup);
                                this.addOfferIdToTmpOrderDataList(_discount.OfferId, offerIdSet);
                            }
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>readRetailDiscountsForProducts</Name>
				<Source><![CDATA[
    private void readRetailDiscountsForProducts(
        Set _offerProductDiscountsSet,
        CLRObject _discountList,
        ValidFromDate _minFromDate,
        ValidFromDate _maxToDate,
        TmpRecIdFilter _priceDiscGroupTmp,
        Map _validationPeriodLookup,
        RetailTmpOfferIdWithPriceGroups _offerIdWithPriceGroups)
    {
        if (_offerProductDiscountsSet.elements())
        {
            using(var t = RetailPricingInstrumentationSegment::construct(
                    classStr(RetailPricingDataManagerV2), 'ReadRetailDiscounts.ForProducts'))
            {
                if (!RetailPricingCacheForDataManager::shouldQueryRetailDiscountsProductNoDim())
                {
                    return;
                }

                Microsoft.Dynamics.Commerce.Runtime.DataModel.PeriodicDiscount crtDiscount;

                RetailPeriodicDiscount periodicDiscount;
                RetailPeriodicDiscountLine periodicDiscountLine;
                RetailGroupMemberLine retailGroupMemberLine;
                RetailDiscountPriceGroup discountPriceGroup;

                RetailPeriodicDiscount periodicDiscountData;
                RefRecId periodicDiscountRecId = 0;
                RetailPeriodicDiscountLine periodicDiscountLineData;
                RefRecId periodicDiscountLineRecId = 0;

                // get lines matching the product
                // while select RecId, PeriodicDiscountType, Status, ValidFrom, ValidTo, OfferId from periodicDiscount
                while select RecId, OfferId, MatchAllAssociatedPriceGroups from periodicDiscount
                    where periodicDiscount.PeriodicDiscountType != RetailDiscountOfferTypeBase::Promotion && periodicDiscount.PeriodicDiscountType != RetailDiscountOfferTypeBase::Shipping
                        && periodicDiscount.Status == RetailDisabledEnabled::Enabled
                        && ((periodicDiscount.ValidFrom <= _minFromDate || periodicDiscount.ValidFrom <= noDate)
                        && (periodicDiscount.ValidTo >= _maxToDate || periodicDiscount.ValidTo <= noDate))
                join RecId from periodicDiscountLine
                    order by periodicDiscount.OfferId, periodicDiscountLine.RecId
                    where periodicDiscount.OfferId == periodicDiscountLine.OfferId
                join RecId from retailGroupMemberLine
                    where retailGroupMemberLine.RecId == periodicDiscountLine.RetailGroupMemberLine
                join mTmpOrderItem
                    where retailGroupMemberLine.Variant == 0
                        && (retailGroupMemberLine.InventDimId == '' || retailGroupMemberLine.InventDimId == InventDimAllBlank)
                        && retailGroupMemberLine.Product != 0
                        && retailGroupMemberLine.Product == mTmpOrderItem.Product
                exists join discountPriceGroup
                    where discountPriceGroup.OfferId == periodicDiscount.OfferId
                exists join RefRecId from _priceDiscGroupTmp
                    where _priceDiscGroupTmp.RefRecId == discountPriceGroup.PriceDiscGroup
                {
                    if (this.isDiscountApplicable(periodicDiscount.OfferId, periodicDiscount.MatchAllAssociatedPriceGroups, _priceDiscGroupTmp, _offerIdWithPriceGroups))
                    {
                        if (periodicDiscountRecId != periodicDiscount.RecId)
                        {
                            periodicDiscountRecId = periodicDiscount.RecId;
                            periodicDiscountData = RetailPeriodicDiscount::find(periodicDiscount.RecId);
                        }

                        if (periodicDiscountLineRecId != periodicDiscountLine.RecId)
                        {
                            periodicDiscountLineRecId = periodicDiscountLine.RecId;
                            periodicDiscountLineData = RetailPeriodicDiscountLine::find(periodicDiscountLine.RecId);
                        }

                        crtDiscount = this.ConvertToCrtPeriodicDiscountV2(
                            periodicDiscountData,
                            periodicDiscountLineData,
                            UnitOfMeasure::find(periodicDiscountLineData.UnitOfMeasure),
                            0, // discount type as required by the method.
                            mTmpOrderItem.itemId,
                            mTmpOrderItem.inventDimId);
                        _discountList.Add(crtDiscount);

                        crtDiscount.ValidationPeriod = this.setValidationPeriod(periodicDiscountData.ValidationPeriodId, _validationPeriodLookup);
                        this.addOfferIdToTmpOrderDataList(periodicDiscountData.OfferId, offerIdSet);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>readRetailDiscountsForVariants</Name>
				<Source><![CDATA[
    private void readRetailDiscountsForVariants(
        Set _offerVariantDiscountsSet,
        CLRObject _discountList,
        ValidFromDate _minFromDate,
        ValidFromDate _maxToDate,
        TmpRecIdFilter _priceDiscGroupTmp,
        Map _validationPeriodLookup,
        RetailTmpOfferIdWithPriceGroups _offerIdWithPriceGroups)
    {
        if (_offerVariantDiscountsSet.elements())
        {
            Microsoft.Dynamics.Commerce.Runtime.DataModel.PeriodicDiscount crtDiscount;

            RetailPeriodicDiscount periodicDiscount;
            RetailPeriodicDiscountLine periodicDiscountLine;
            RetailGroupMemberLine retailGroupMemberLine;
            RetailDiscountPriceGroup discountPriceGroup;

            RetailPeriodicDiscount periodicDiscountData;
            RefRecId periodicDiscountRecId = 0;
            RetailPeriodicDiscountLine periodicDiscountLineData;
            RefRecId periodicDiscountLineRecId = 0;

            using(var t = RetailPricingInstrumentationSegment::construct(
                    classStr(RetailPricingDataManagerV2), 'ReadRetailDiscounts.ForVariants'))
            {
                if (!RetailPricingCacheForDataManager::shouldQueryRetailDiscountsVariant())
                {
                    return;
                }

                // get lines matching the variant
                while select RecId, OfferId, MatchAllAssociatedPriceGroups from periodicDiscount
                    where periodicDiscount.PeriodicDiscountType != RetailDiscountOfferTypeBase::Promotion && periodicDiscount.PeriodicDiscountType != RetailDiscountOfferTypeBase::Shipping
                        && periodicDiscount.Status == RetailDisabledEnabled::Enabled
                        && ((periodicDiscount.ValidFrom <= _minFromDate || periodicDiscount.ValidFrom <= noDate)
                        && (periodicDiscount.ValidTo >= _maxToDate || periodicDiscount.ValidTo <= noDate))
                join RecId from periodicDiscountLine
                    order by periodicDiscount.OfferId, periodicDiscountLine.RecId
                    where periodicDiscount.OfferId == periodicDiscountLine.OfferId
                join RecId from retailGroupMemberLine
                    where retailGroupMemberLine.RecId == periodicDiscountLine.RetailGroupMemberLine
                join mTmpOrderItem
                    where retailGroupMemberLine.Variant != 0
                        && (retailGroupMemberLine.InventDimId == '' || retailGroupMemberLine.InventDimId == InventDimAllBlank)
                        && retailGroupMemberLine.Variant == mTmpOrderItem.Variant
                exists join discountPriceGroup
                    where discountPriceGroup.OfferId == periodicDiscount.OfferId
                exists join RefRecId from _priceDiscGroupTmp
                    where _priceDiscGroupTmp.RefRecId == discountPriceGroup.PriceDiscGroup
                {
                    if (this.isDiscountApplicable(periodicDiscount.OfferId, periodicDiscount.MatchAllAssociatedPriceGroups, _priceDiscGroupTmp, _offerIdWithPriceGroups))
                    {
                        if (periodicDiscountRecId != periodicDiscount.RecId)
                        {
                            periodicDiscountRecId = periodicDiscount.RecId;
                            periodicDiscountData = RetailPeriodicDiscount::find(periodicDiscount.RecId);
                        }

                        if (periodicDiscountLineRecId != periodicDiscountLine.RecId)
                        {
                            periodicDiscountLineRecId = periodicDiscountLine.RecId;
                            periodicDiscountLineData = RetailPeriodicDiscountLine::find(periodicDiscountLine.RecId);
                        }

                        crtDiscount = this.ConvertToCrtPeriodicDiscountV2(
                            periodicDiscountData,
                            periodicDiscountLineData,
                            UnitOfMeasure::find(periodicDiscountLineData.UnitOfMeasure),
                            0, // discount type as required by the method.
                            mTmpOrderItem.itemId,
                            mTmpOrderItem.inventDimId);
                        _discountList.Add(crtDiscount);

                        crtDiscount.ValidationPeriod = this.setValidationPeriod(periodicDiscountData.ValidationPeriodId, _validationPeriodLookup);
                        this.addOfferIdToTmpOrderDataList(periodicDiscountData.OfferId, offerIdSet);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>readRetailDiscountsForProductDimensions</Name>
				<Source><![CDATA[
    private void readRetailDiscountsForProductDimensions(
        Set _offerInventDimDiscountsSet,
        CLRObject _discountList,
        ValidFromDate _minFromDate,
        ValidFromDate _maxToDate,
        TmpRecIdFilter _priceDiscGroupTmp,
        Map _validationPeriodLookup,
        RetailTmpOfferIdWithPriceGroups _offerIdWithPriceGroups)
    {
        Microsoft.Dynamics.Commerce.Runtime.DataModel.PeriodicDiscount crtDiscount;

        RetailPeriodicDiscount periodicDiscount;
        RetailPeriodicDiscountLine periodicDiscountLine;
        RetailGroupMemberLine retailGroupMemberLine;
        RetailDiscountPriceGroup discountPriceGroup;

        RetailPeriodicDiscount periodicDiscountData;
        RefRecId periodicDiscountRecId = 0;
        RetailPeriodicDiscountLine periodicDiscountLineData;
        RefRecId periodicDiscountLineRecId = 0;

        if (_offerInventDimDiscountsSet.elements())
        {
            // Note that number of discount lines is usually at a different magnitude compared to number of discounts.
            using(var t = RetailPricingInstrumentationSegment::construct(
                    classStr(RetailPricingDataManagerV2), 'ReadRetailDiscounts.ForProductDimensions'))
            {
                if (!RetailPricingCacheForDataManager::shouldQueryRetailDiscountsProductWithDim())
                {
                    return;
                }

                int countDiscountLines = 0;

                using(var tDiscountLineEnumerated = RetailPricingInstrumentationSegment::construct(
                        classStr(RetailPricingDataManagerV2), 'Discount lines enumerated in ForProductDimensions'))
                {
                    // get lines matching the dimension
                    while select RecId, OfferId, MatchAllAssociatedPriceGroups from periodicDiscount
                        where periodicDiscount.PeriodicDiscountType != RetailDiscountOfferTypeBase::Promotion && periodicDiscount.PeriodicDiscountType != RetailDiscountOfferTypeBase::Shipping
                            && periodicDiscount.Status == RetailDisabledEnabled::Enabled
                            && ((periodicDiscount.ValidFrom <= _minFromDate || periodicDiscount.ValidFrom <= noDate)
                            && (periodicDiscount.ValidTo >= _maxToDate || periodicDiscount.ValidTo <= noDate))
                    join RecId from periodicDiscountLine
                        order by periodicDiscount.OfferId, periodicDiscountLine.RecId
                        where periodicDiscount.OfferId == periodicDiscountLine.OfferId
                    join RecId, InventDimId from retailGroupMemberLine
                        where retailGroupMemberLine.RecId == periodicDiscountLine.RetailGroupMemberLine
                    join mTmpOrderItem
                        where retailGroupMemberLine.Variant == 0
                            && retailGroupMemberLine.Product != 0
                            && retailGroupMemberLine.Product == mTmpOrderItem.Product
                            && mTmpOrderItem.Variant != 0
                            && retailGroupMemberLine.InventDimId != ''
                            && retailGroupMemberLine.InventDimId != InventDimAllBlank
                    exists join discountPriceGroup
                        where discountPriceGroup.OfferId == periodicDiscount.OfferId
                    exists join RefRecId from _priceDiscGroupTmp
                        where _priceDiscGroupTmp.RefRecId == discountPriceGroup.PriceDiscGroup
                    {
                        countDiscountLines++;

                        if (this.isDiscountApplicable(periodicDiscount.OfferId, periodicDiscount.MatchAllAssociatedPriceGroups, _priceDiscGroupTmp, _offerIdWithPriceGroups))
                        {
                            if (periodicDiscountRecId != periodicDiscount.RecId)
                            {
                                periodicDiscountRecId = periodicDiscount.RecId;
                                periodicDiscountData = RetailPeriodicDiscount::find(periodicDiscount.RecId);
                            }

                            if (periodicDiscountLineRecId != periodicDiscountLine.RecId)
                            {
                                periodicDiscountLineRecId = periodicDiscountLine.RecId;
                                periodicDiscountLineData = RetailPeriodicDiscountLine::find(periodicDiscountLine.RecId);
                            }

                            // Only need to check discount which has not yet qualified.
                            if (this.isVariantMatch(mTmpOrderItem.Variant, retailGroupMemberLine.InventDimId))
                            {
                                crtDiscount = this.ConvertToCrtPeriodicDiscountV2(
                                        periodicDiscountData,
                                        periodicDiscountLineData,
                                        UnitOfMeasure::find(periodicDiscountLineData.UnitOfMeasure),
                                        0, // discount type as required by the method.
                                        mTmpOrderItem.itemId,
                                        mTmpOrderItem.inventDimId);
                                _discountList.Add(crtDiscount);

                                crtDiscount.ValidationPeriod = this.setValidationPeriod(periodicDiscountData.ValidationPeriodId, _validationPeriodLookup);
                                this.addOfferIdToTmpOrderDataList(periodicDiscountData.OfferId, offerIdSet);
                            }
                        }
                    }

                    tDiscountLineEnumerated.addExtendedData('RowCount', int2Str(countDiscountLines));
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCouponCodeOfferIds</Name>
				<Source><![CDATA[
    protected Set getCouponCodeOfferIds()
    {
        return super();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>