<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>GanttData_WrkCtr</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>GanttData_WrkCtr</c> class is the work center Gantt data handling class.
/// </summary>
/// <remarks>
///    The class handles:
///    <list type="bullet">
///       <item>
///          <description>loading of Gantt work center data</description>
///       </item>
///       <item>
///          <description>saving Gantt work center data including update of the routes and capacity
///          reservations</description>
///       </item>
///       <item>
///          <description>validation of Gantt work center modifications</description>
///       </item>
///    </list>
/// </remarks>
class GanttData_WrkCtr extends GanttData
{
    Set                     setLoadWrkCtrIds;
    Set                     setEmptyWrkCtrIds;
    Set                     setModifiedRefIds;

    FromDate                callerFromDate;
    ToDate                  callerToDate;

    Map                     mapProdTables;
    Map                     mapReqPOs;
    Map                     mapLinkGroups2RecIds;
    Map                     mapRecId2LinkGroup;
    int64                   linkGroupNo;

    ReqPlanId               reqPlanIdDefaultDynamic;

    GanttTable_WrkCtrJob    ganttTableWrkCtrJob;    // work center activities (productions, planned productions and projects)
    GanttTable_Link         ganttTableLink;         // links between activities

    boolean                 hasProdJobs;
    boolean                 hasPlannedProdJobs;
    boolean                 hasProjJobs;
    boolean                 loadOnlySpecific;

    GanttTmpMaterials       ganttTmpMaterials;
    WrkCtrTmpFilter         tmpWrkCtrIdLoaded;
    private static List capacityReservations;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addRecId2LinkGroup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a job to a link group by the record ID of the job in the temporary Gantt table.
    /// </summary>
    /// <param name="_recId">
    ///    The <c>RecId</c> identifying which job to add to the specified link group.
    /// </param>
    /// <param name="_linkGroupNo">
    ///    Link group to add the job to.
    /// </param>
    /// <remarks>
    ///    The job is only added to the link group if it is not already in a link group.
    /// </remarks>
    protected void addRecId2LinkGroup(RecId     _recId,
                                      int64     _linkGroupNo)
    {
        Set setRecIds;

        if (!mapRecId2LinkGroup.exists(_recId))
        {
            if (!mapLinkGroups2RecIds.exists(_linkGroupNo))
            {
                setRecIds = new Set(Types::Int64);
                mapLinkGroups2RecIds.insert(_linkGroupNo, setRecIds);
            }
            else
            {
                setRecIds = mapLinkGroups2RecIds.lookup(_linkGroupNo);
            }

            setRecIds.add(_recId);
            mapRecId2LinkGroup.insert(_recId, _linkGroupNo);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustLoadingDatesInterval</Name>
				<Source><![CDATA[
    protected void adjustLoadingDatesInterval(FromDate _fromDate, ToDate _toDate)
    {
        if (_fromDate > _toDate     ||
            _fromDate <= dateNull() ||
            _toDate   <= dateNull() ||
            _toDate   >= naDate())
        {
            return;
        }

        GanttTimescale scaleUnit = ganttClient.parmGanttSetup().parmTimescaleUnit();
        GanttTimeStep scaleStep = ganttClient.parmGanttSetup().parmTimescaleStep();

        ToDate adjustedToDate = this.shiftDate(_toDate, scaleUnit, scaleStep);
        super(_fromDate, adjustedToDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shiftDate</Name>
				<Source><![CDATA[
    protected TransDate shiftDate(TransDate _transDate, GanttTimescale _scaleUnit, GanttTimeStep _scaleStep)
    {
        utcdatetime dt = DateTimeUtil::newDateTime(_transDate, 0);
        
        switch (_scaleUnit)
        {
            case GanttTimescale::Minutes:
                // Do nothing
                break;

            case GanttTimescale::Hours:
                dt = DateTimeUtil::addDays(dt, 1);
                break;

            case GanttTimescale::Days:
                dt = DateTimeUtil::addDays(dt, _scaleStep);
                break;
            
            case GanttTimescale::Weeks:
                dt = DateTimeUtil::addDays(dt, 7 * _scaleStep);
                break;

            case GanttTimescale::Months:
                dt = DateTimeUtil::addMonths(dt, _scaleStep);
                break;
        }

        return DateTimeUtil::date(dt);
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustIntervalFromOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adjusts the loading interval with regard to loading all orders and loading delivery dates.
    /// </summary>
    /// <param name="_adjustDeliveryDate">
    ///    Set to true if the loading interval should be adjusted so that it includes order delivery date;
    ///    optional.
    /// </param>
    /// <param name="_adjustEntireOrder">
    ///    Set to true if the loading interval should be adjusted so that all orders are loaded; optional.
    /// </param>
    protected void adjustIntervalFromOrder(boolean _adjustDeliveryDate  = true,
                                           boolean _adjustEntireOrder   = true)
    {
        boolean             adjustInterval      = false;
        GanttView_WrkCtr    localGanttView      = this.parmGanttClient().parmGanttView() as GanttView_WrkCtr;
        GanttSetup_WrkCtr   localGanttSetup     = this.parmGanttClient().parmGanttSetup() as GanttSetup_WrkCtr;

        // check if we need to adjust interval because of delivery date flag
        if (_adjustDeliveryDate                                             &&
            this.parmGanttClient().parmGanttView()                          &&
            localGanttView.mustLoadDeliveryDate())
        {
            adjustInterval = true;
        }

        // check if we need to adjust interval because of entire order load flag
        if (_adjustEntireOrder                                                          &&
            this.parmGanttClient().parmGanttSetup()                                     &&
            (localGanttSetup.parmLoadEntireProdOrder()          ||
             localGanttSetup.parmLoadEntirePlannedProdOrder()   ||
             localGanttSetup.parmLoadEntireProject()))
        {
            adjustInterval = true;
        }

        if (adjustInterval)
        {
            this.adjustIntervalFromProd();

            this.adjustIntervalFromPlannedProd();

            this.adjustIntervalFromProj();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustIntervalFromPlannedProd</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adjusts the loading interval so that the start and end dates include the delivery date of the
    ///    planned production order.
    /// </summary>
    /// <param name="_adjustDeliveryDate">
    ///    Set to true if the loading interval should be adjusted so that it includes the order delivery date;
    ///    optional.
    /// </param>
    /// <param name="_adjustEntireOrder">
    ///    Set to true if the loading interval should be adjusted so that complete orders are loaded; optional.
    /// </param>
    /// <remarks>
    ///    The method is making a call to the server to obtain purchase order records in one RPC call that are
    ///    packed in one set to increase performance.
    /// </remarks>
    protected void adjustIntervalFromPlannedProd(boolean _adjustDeliveryDate   = true,
                                                 boolean _adjustEntireOrder    = true)
    {
        GanttClient_WrkCtr localGanttClient = this.parmGanttClient() as GanttClient_WrkCtr;
        GanttSetup_WrkCtr localGanttSetup = localGanttClient.parmGanttSetup() as GanttSetup_WrkCtr;
        GanttView_WrkCtr  localGanttView  = localGanttClient.parmGanttView();

        ReqPO           reqPO;
        SetEnumerator   setEnumerator;
        ReqPlanId       reqPlanId   = localGanttSetup.parmReqPlanIdPlannedProd();
        Set             setDataPlannedProd;
        boolean         adjustDeliveryDate = _adjustDeliveryDate;
        boolean         adjustEntireOrder = _adjustEntireOrder;

        if (!this.canLoadPlannedProdData()                               ||
           !this.parmGanttClient().parmGanttView()                      ||
           !this.parmGanttClient().parmGanttSetup())
        {
            return;
        }

        if (!localGanttView.mustLoadDeliveryDate())
        {
            adjustDeliveryDate = false;
        }
        if (!localGanttSetup.parmLoadEntirePlannedProdOrder())
        {
            adjustEntireOrder = false;

            // delivery dates expand the loading interval only if load entire order is marked
            adjustDeliveryDate = false;
        }

        if (!adjustDeliveryDate &&
            !adjustEntireOrder)
        {
            return;
        }

        setDataPlannedProd = Set::create(GanttData_WrkCtr::getDataInIntervalPlannedProd(setLoadWrkCtrIds.pack(),
                                                                                        callerFromDate,
                                                                                        callerToDate,
                                                                                        reqPlanId));

        // find all planned production orders in the original dates interval
        setEnumerator = setDataPlannedProd.getEnumerator();
        while (setEnumerator && setEnumerator.moveNext())
        {
            [reqPO] = setEnumerator.current();

            if (adjustDeliveryDate)
            {
                this.adjustLoadingDatesInterval(reqPO.ReqDateDlv, reqPO.ReqDateDlv);
            }

            if (adjustEntireOrder)
            {
                this.adjustLoadingDatesInterval(reqPO.SchedFromDate, reqPO.SchedToDate);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustIntervalFromProd</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adjusts the loading interval so that the start and end dates include the delivery date of the
    ///    production order.
    /// </summary>
    /// <param name="_adjustDeliveryDate">
    ///    Set to true if the loading interval should be adjusted so that it includes the order delivery date;
    ///    optional.
    /// </param>
    /// <param name="_adjustEntireOrder">
    ///    Set to true if the loading interval should be adjusted so that all orders are loaded; optional.
    /// </param>
    /// <remarks>
    ///    The method is making a call to the server to obtain all the needed production table records in one
    ///    RPC call that are packed in one set.
    /// </remarks>
    protected void adjustIntervalFromProd(boolean _adjustDeliveryDate   = true,
                                          boolean _adjustEntireOrder    = true)
    {
        ProdTable       prodTable;
        SetEnumerator   setEnumerator;
        Set             setDataProd;
        boolean         adjustDeliveryDate = _adjustDeliveryDate;
        boolean         adjustEntireOrder = _adjustEntireOrder;
        GanttSetup_WrkCtr localGanttSetup = this.parmGanttClient().parmGanttSetup() as GanttSetup_WrkCtr;
        GanttView_WrkCtr  localGanttView  = this.parmGanttClient().parmGanttView() as GanttView_WrkCtr;

        if (!this.canLoadProdData()                                      ||
           !this.parmGanttClient().parmGanttView()                      ||
           !this.parmGanttClient().parmGanttSetup())
        {
            return;
        }

        if (!localGanttView.mustLoadDeliveryDate())
        {
            adjustDeliveryDate = false;
        }
        if (!localGanttSetup.parmLoadEntireProdOrder())
        {
            adjustEntireOrder = false;

            // delivery dates expand the loading interval only if load entire order is marked
            adjustDeliveryDate = false;
        }

        if (!adjustDeliveryDate &&
            !adjustEntireOrder)
        {
            return;
        }

        setDataProd = Set::create(GanttData_WrkCtr::getDataInIntervalProd(setLoadWrkCtrIds.pack(),
                                                                          callerFromDate,
                                                                          callerToDate));

        // find all production orders in the original dates interval
        setEnumerator = setDataProd.getEnumerator();
        while (setEnumerator && setEnumerator.moveNext())
        {
            [prodTable] = setEnumerator.current();

            if (adjustDeliveryDate)
            {
                this.adjustLoadingDatesInterval(prodTable.DlvDate, prodTable.DlvDate);
            }

            if (adjustEntireOrder)
            {
                this.adjustLoadingDatesInterval(prodTable.SchedStart, prodTable.SchedEnd);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustIntervalFromProj</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adjusts the loading interval so that the start and end dates include the delivery date of the
    ///    project.
    /// </summary>
    /// <param name="_adjustDeliveryDate">
    ///    Set to true if the loading interval should be adjusted so that it includes the project delivery
    ///    date; optional.
    /// </param>
    /// <param name="_adjustEntireOrder">
    ///    Set to true if the loading interval should be adjusted so that complete projects are loaded;
    ///    optional.
    /// </param>
    /// <remarks>
    ///    The method is making a call to the server to obtain all the needed project table records in one RPC
    ///    call that are packed in one set.
    /// </remarks>
    protected void adjustIntervalFromProj(boolean _adjustDeliveryDate   = true,
                                          boolean _adjustEntireOrder    = true)
    {
        ProjTable           projTable;
        SetEnumerator       setEnumerator;
        Set                 setDataProj;
        boolean             adjustDeliveryDate = _adjustDeliveryDate;
        boolean             adjustEntireOrder = _adjustEntireOrder;
        GanttSetup_WrkCtr   localGanttSetup = this.parmGanttClient().parmGanttSetup() as GanttSetup_WrkCtr;
        GanttView_WrkCtr    localGanttView  = this.parmGanttClient().parmGanttView() as GanttView_WrkCtr;

        if (!this.canLoadProjData()                                      ||
           !this.parmGanttClient().parmGanttView()                      ||
           !this.parmGanttClient().parmGanttSetup())
        {
            return;
        }

        if (!localGanttView.mustLoadDeliveryDate())
        {
            adjustDeliveryDate = false;
        }
        if (!localGanttSetup.parmLoadEntireProject())
        {
            adjustEntireOrder = false;

            // delivery dates expand the loading interval only if load entire order is marked
            adjustDeliveryDate = false;
        }

        if (!adjustDeliveryDate &&
            !adjustEntireOrder)
        {
            return;
        }

        setDataProj = Set::create(GanttData_WrkCtr::getDataInIntervalProj(setLoadWrkCtrIds.pack(),
                                                                          callerFromDate,
                                                                          callerToDate));

        // find all projects in the original dates interval
        setEnumerator = setDataProj.getEnumerator();
        while (setEnumerator && setEnumerator.moveNext())
        {
            [projTable] = setEnumerator.current();

            if (adjustDeliveryDate)
            {
                this.adjustLoadingDatesInterval(projTable.EndDate, projTable.EndDate);
            }

            if (adjustEntireOrder)
            {
                this.adjustLoadingDatesInterval(projTable.StartDate, projTable.EndDate);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustLinks</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adjusts the links that are to be loaded in Gantt Visualization by adding new links that compensate
    ///    for jobs that are not to be shown that were hidden by the user.
    /// </summary>
    /// <remarks>
    ///    For each displayed node (that has <c>IsDisplayed = NoYes:Yes</c>) all outgoing links are examined.
    ///    On each outgoing link the method recurses until a displayed node is encountered. The endpoints are
    ///    from the start node and the first displayed node found when recursing.
    /// </remarks>
    protected void adjustLinks()
    {
        Set                 setProcessedNodes = new Set(Types::Int64);
        Set                 setNewLinks;
        SetEnumerator       setEnumerator;
        RecId               recId;
        GanttLinkType       firstLink;
        GanttLinkType       lastLink;
        RecId               linkRecId;
        Map                 mapNodeLinks = new Map(Types::Int64, Types::Class);
        Set                 setLinks;
        RecId               predecessorRecId;
        RecId               successorRecId;
        GanttTmpLink        localGanttTableLink      = this.parmGanttTableLink().parmTableBuffer() as GanttTmpLink;
        GanttTmpWrkCtrJob   localGanttTableWrkCtrJob = this.parmGanttTableWrkCtrJob().parmTableBuffer() as GanttTmpWrkCtrJob;

        GanttLinkType   composeLinkType(GanttLinkType _firstLink, GanttLinkType _lastLink)
        {
            switch (_firstLink)
            {
                case GanttLinkType::SF:
                case GanttLinkType::SS:
                    switch (_lastLink)
                    {
                        case GanttLinkType::SS:     return GanttLinkType::SS;
                        case GanttLinkType::SF:     return GanttLinkType::SF;
                        case GanttLinkType::FS:     return GanttLinkType::SS;
                        case GanttLinkType::FF:     return GanttLinkType::SF;
                        case GanttLinkType::None:   return GanttLinkType::None;
                        default:
                            throw error("@SYS117264");
                    }
                case GanttLinkType::FS:
                case GanttLinkType::FF:
                    switch (_lastLink)
                    {
                        case GanttLinkType::SS:     return GanttLinkType::FS;
                        case GanttLinkType::SF:     return GanttLinkType::FF;
                        case GanttLinkType::FS:     return GanttLinkType::FS;
                        case GanttLinkType::FF:     return GanttLinkType::FF;
                        case GanttLinkType::None:   return GanttLinkType::None;
                        default:
                            throw error("@SYS117264");
                    }
                default:
                    throw error("@SYS117264");
            }

            //return GanttLinkType::None;
        }
        this.parmGanttTableLink().findFirst();
        while (this.parmGanttTableLink().parmTableBuffer())
        {
            this.parmGanttTableWrkCtrJob().findRecId(localGanttTableLink.SuccessorRecId);

            predecessorRecId = localGanttTableLink.PredecessorRecId;
            successorRecId = localGanttTableLink.SuccessorRecId;
            if (!mapNodeLinks.exists(predecessorRecId))
            {
                setLinks = new Set(Types::Container);
                mapNodeLinks.insert(predecessorRecId, setLinks);
            }
            else
            {
                setLinks = mapNodeLinks.lookup(predecessorRecId);
            }
            setLinks.add([successorRecId,
                    localGanttTableWrkCtrJob.IsDisplayed,
                    localGanttTableLink.LinkType]);

            this.parmGanttTableLink().findNext();
        }

        this.parmGanttTableWrkCtrJob().findFirst();
        while (this.parmGanttTableWrkCtrJob().parmTableBuffer())
        {
            if (localGanttTableWrkCtrJob.IsDisplayed)
            {
                recId = this.parmGanttTableWrkCtrJob().parmTableBuffer().RecId;
                
                setNewLinks = this.getAllNewLinks(recId, mapNodeLinks);
                setEnumerator = setNewLinks.getEnumerator();

                while (setEnumerator && setEnumerator.moveNext())
                {
                    // for each link insert a new record in the links table
                    this.parmGanttTableLink().cleanTableBuffer();

                    [linkRecId, firstLink, lastLink] = setEnumerator.current();
                    this.parmGanttTableLink().setLinkData(recId,
                                                          linkRecId,
                                                          NoYes::Yes,
                                                          NoYes::No,
                                                          composeLinkType(firstLink, lastLink));
                    this.parmGanttTableLink().insert();
                }
            }

            this.parmGanttTableWrkCtrJob().findNext();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canLoadPlannedProdData</Name>
				<Source><![CDATA[
    protected boolean canLoadPlannedProdData()
    {
        GanttSetup_WrkCtr   localGanttSetup = this.parmGanttClient().parmGanttSetup() as GanttSetup_WrkCtr;
        if (!localGanttSetup.parmLoadPlannedProdJobData())
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canLoadProdData</Name>
				<Source><![CDATA[
    protected boolean canLoadProdData()
    {
        GanttSetup_WrkCtr   localGanttSetup = this.parmGanttClient().parmGanttSetup() as GanttSetup_WrkCtr;
        if (!localGanttSetup.parmLoadProdJobData())
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canLoadProdRouteJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the production order route job satisfies all checks in order to be loaded in the Gantt
    /// chart.
    /// </summary>
    /// <param name="_prodRouteJob">
    /// A <see cref="T:ProdRouteJob" /> record that contains the most important job data.
    /// </param>
    /// <param name="_prodRoute">
    /// A <see cref="T:ProdRoute" /> record that contains information about the operation the job belongs
    /// to; optional.
    /// </param>
    /// <param name="_routeGroup">
    /// A <see cref="T:RouteGroup" /> record that contains information about the route group assigned to
    /// the operation; optional.
    /// </param>
    /// <param name="_prodTable">
    /// A <see cref="T:ProdTable" /> record that contains information about production order the job
    /// belongs to; optional.
    /// </param>
    /// <param name="_dateStart">
    /// A date variable specifying the start date of the interval constraint; optional.
    /// </param>
    /// <param name="_dateEnd">
    /// A date variable specifying the end date of the interval constraint; optional.
    /// </param>
    /// <returns>
    /// true if the job should be loaded in the Gantt chart; otherwise, false.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// Exception thrown in case the job does not have a valid job type.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    /// Exception thrown in the case where the operation identified by the production route is not valid
    /// (invalid <c>RecId</c>).
    /// </exception>
    /// <exception cref="M:Exception::Error">
    /// Exception thrown in the case where the route group identified by the <see cref="T:RouteGroup" />
    /// buffer is not valid (invalid <c>RecId</c>).
    /// </exception>
    /// <exception cref="M:Exception::Error">
    /// Exception thrown in case the production order identified by <see cref="T:ProdTable" /> buffer is
    /// not valid (invalid <c>RecId</c>).
    /// </exception>
    protected boolean canLoadProdRouteJob(ProdRouteJob   _prodRouteJob,
                                          ProdRoute      _prodRoute     = null, // set for better performance
                                          RouteGroup     _routeGroup    = null, // set for better performance
                                          ProdTable      _prodTable     = null, // set for better performance
                                          date           _dateStart     = dateNull(),
                                          date           _dateEnd       = naDate())
    {
        ProdJobType         prodJobType;
        GanttSetup_WrkCtr   localGanttSetup = this.parmGanttClient().parmGanttSetup() as GanttSetup_WrkCtr;

        if (!_prodRouteJob.RecId)
        {
            return false;
        }

        // can add production data?
        if (!localGanttSetup.parmLoadProdJobData())
        {
            return false;
        }

        if (_prodRouteJob.FromDate   > _prodRouteJob.ToDate  ||
           _prodRouteJob.FromDate   <= dateNull()           ||
           _prodRouteJob.ToDate     <= dateNull()           ||
           _prodRouteJob.ToDate     >= naDate())
        {
            return false;
        }

        // is the job within the desired interval
        if (_prodRouteJob.FromDate  > _dateEnd     ||
            _prodRouteJob.ToDate    < _dateStart)
        {
            return false;
        }

        // can add finished jobs?
        if (_prodRouteJob.JobFinished == NoYes::Yes                           &&
           !localGanttSetup.parmShowFinishedProdJobs())
        {
            return false;
        }

        // can add job types?
        switch (_prodRouteJob.JobType)
        {
            case RouteJobType::QueueBefore:

                if (!localGanttSetup.parmShowProdJobTypeQueueBefore())
                {
                    return false;
                }
                break;

            case RouteJobType::Setup:

                if (!localGanttSetup.parmShowProdJobTypeSetup())
                {
                    return false;
                }
                break;

            case RouteJobType::Process:

                if (!localGanttSetup.parmShowProdJobTypeProcess())
                {
                    return false;
                }
                break;

            case RouteJobType::Overlap:

                if (!localGanttSetup.parmShowProdJobTypeOverlap())
                {
                    return false;
                }
                break;

            case RouteJobType::Transport:

                if (!localGanttSetup.parmShowProdJobTypeTransport())
                {
                    return false;
                }
                break;

            case RouteJobType::QueueAfter:

                if (!localGanttSetup.parmShowProdJobTypeQueueAfter())
                {
                    return false;
                }
                break;
        }

        // show jobs not reserving capacity?
        if (!localGanttSetup.parmShowProdJobsNoCapRes())
        {
            prodJobType = _prodRouteJob.prodJobType();

            if (prodJobType == null)
            {
                throw error(strfmt("@SYS18707", funcname()));
            }

            // get _routeGroup if not passed in the parameters
            if (!_routeGroup.RecId)
            {
                // get _prodRoute if not passed in the parameters
                if (!_prodRoute.RecId)
                {
                    _prodRoute = _prodRouteJob.prodRoute();

                    if (!_prodRoute.RecId)
                    {
                        throw error("@SYS102208");
                    }
                }

                 _routeGroup = _prodRoute.routeGroup();

                if (!_routeGroup.RecId)
                {
                    throw error("@SYS102208");
                }
            }

            if (!prodJobType.scheduleCapacity(_routeGroup))
            {
                return false;
            }
        }

        // get _prodTable if not passed in the parameters
        if (!_prodTable.RecId)
        {
            _prodTable = ProdTable::find(_prodRouteJob.ProdId);

            if (!_prodTable.RecId)
            {
                throw error(strfmt(ProdTable::txtNotExist(), _prodRouteJob.ProdId));
            }
        }

        // is production order job scheduled?
        if (!_prodTable.status().runGanttChart())
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canLoadProjData</Name>
				<Source><![CDATA[
    protected boolean canLoadProjData()
    {
        GanttSetup_WrkCtr   localGanttSetup = this.parmGanttClient().parmGanttSetup() as GanttSetup_WrkCtr;
        if (!localGanttSetup.parmLoadProjData())
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canLoadProjForecastEmpl</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks if the project hour forecast job satisfies all checks in order to be loaded in the Gantt
    ///    chart.
    /// </summary>
    /// <param name="_projForecastEmpl">
    ///    A <see cref="T:ProjForecastEmpl" /> buffer that contains the job data.
    /// </param>
    /// <param name="_showWarningInfo">
    ///    If set to true, the method shows a warning notifying the user who the project hour forecast record
    ///    could not be loaded.
    /// </param>
    /// <param name="_dateStart">
    ///    A date variable specifying the start date of the interval constraint; optional.
    /// </param>
    /// <param name="_dateEnd">
    ///    A date variable specifying the end date of the interval constraint; optional.
    /// </param>
    /// <returns>
    ///    true if the job should be loaded in the Gantt chart; otherwise, false.
    /// </returns>
    protected boolean canLoadProjForecastEmpl(ProjForecastEmpl   _projForecastEmpl,
                                             boolean            _showWarningInfo    = false,
                                             date               _dateStart          = dateNull(),
                                             date               _dateEnd            = naDate())
    {
        GanttSetup_WrkCtr   localGanttSetup = this.parmGanttClient().parmGanttSetup() as GanttSetup_WrkCtr;
        setprefix(strfmt("@SYS80304" + ' %1', _projForecastEmpl.ProjId));

        if (!_projForecastEmpl.RecId)
        {
            return false;
        }

        // can add project data?
        if (!localGanttSetup.parmLoadProjData())
        {
            return false;
        }

        if (_projForecastEmpl.SchedFromDate  <= dateNull()   ||
           _projForecastEmpl.SchedToDate    <= dateNull()   ||
           _projForecastEmpl.SchedToDate    >= naDate())
        {
            return false;
        }

        // is the job within the desired interval
        if (_projForecastEmpl.SchedFromDate  > _dateEnd     ||
            _projForecastEmpl.SchedToDate    < _dateStart)
        {
            return false;
        }

        if (_projForecastEmpl.SchedFromDate  > _projForecastEmpl.SchedToDate)
        {
            if (_showWarningInfo)
            {
                checkFailed(strfmt("@SYS113382", date2StrUsr(_projForecastEmpl.SchedFromDate, DateFlags::FormatAll),
                                                 date2StrUsr(_projForecastEmpl.SchedToDate, DateFlags::FormatAll),
                                                 _projForecastEmpl.TransId));
            }

            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canLoadReqRouteJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the planned production order route job satisfies all checks in order to be loaded in the
    /// Gantt chart.
    /// </summary>
    /// <param name="_reqRouteJob">
    /// A <see cref="T:ReqRouteJob" /> table buffer that contains the job data.
    /// </param>
    /// <param name="_reqRoute">
    /// A <see cref="T:ReqRoute" /> table buffer that contains information about the operation the job
    /// belongs to; optional.
    /// </param>
    /// <param name="_routeOpr">
    /// A <see cref="T:RouteOpr" /> table buffer that contains planned production order operation data;
    /// optional.
    /// </param>
    /// <param name="_routeGroup">
    /// A <see cref="T:RouteGroup" /> table buffer that contains information about the route group assigned
    /// to the operation; optional.
    /// </param>
    /// <param name="_reqPO">
    /// A <see cref="T:ReqPO" /> table buffer that contains information about planned production order the
    /// job belongs to; optional.
    /// </param>
    /// <param name="_dateStart">
    /// A date variable specifying the start date of the interval constraint; optional.
    /// </param>
    /// <param name="_dateEnd">
    /// A date variable specifying the end date of the interval constraint; optional.
    /// </param>
    /// <returns>
    /// true if the job should be loaded in the Gantt chart; otherwise, false.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// Exception thrown in the case where the job does not have a valid job type.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    /// Exception thrown in the case where the operation identified by the production route is not valid
    /// (invalid <c>RecId</c>).
    /// </exception>
    /// <exception cref="M:Exception::Error">
    /// Exception thrown in the case the where the <see cref="T:RouteOpr" /> buffer is not valid (invalid
    /// <c>RecId</c>).
    /// </exception>
    /// <exception cref="M:Exception::Error">
    /// Exception thrown in the case where the route group identified by the <see cref="T:RouteGroup" />
    /// buffer is not valid (invalid <c>RecId</c>).
    /// </exception>
    /// <exception cref="M:Exception::Error">
    /// Exception thrown in the case where the production order identified by <see cref="T:ReqPO" /> buffer
    /// is not valid (invalid <c>RecId</c>).
    /// </exception>
    protected boolean canLoadReqRouteJob(ReqRouteJob _reqRouteJob,
                                         ReqRoute    _reqRoute      = null, // set for better performance
                                         RouteOpr    _routeOpr      = null, // set for better performance
                                         RouteGroup  _routeGroup    = null, // set for better performance
                                         ReqPO       _reqPO         = null, // set for better performance
                                         date        _dateStart     = dateNull(),
                                         date        _dateEnd       = naDate())
    {
        RouteOprRefRecId    routeOprRefRecId;
        ProdJobType         prodJobType;
        GanttSetup_WrkCtr   localGanttSetup = this.parmGanttClient().parmGanttSetup() as GanttSetup_WrkCtr;

        if (!_reqRouteJob.RecId)
        {
            return false;
        }

        // can add planned production data?
        if (!localGanttSetup.parmLoadPlannedProdJobData())
        {
            return false;
        }

        if (_reqRouteJob.FromDate    > _reqRouteJob.ToDate   ||
           _reqRouteJob.FromDate    <= dateNull()           ||
           _reqRouteJob.ToDate      <= dateNull()           ||
           _reqRouteJob.ToDate      >= naDate())
        {
            return false;
        }

        // is the job within the desired interval
        if (_reqRouteJob.FromDate  > _dateEnd     ||
            _reqRouteJob.ToDate    < _dateStart)
        {
            return false;
        }

        // can add job types?
        switch (_reqRouteJob.JobType)
        {
            case RouteJobType::QueueBefore:
                if (!localGanttSetup.parmShowPlannedProdJobTypeQueueBefore())
                    return false;
                break;

            case RouteJobType::Setup:
                if (!localGanttSetup.parmShowPlannedProdJobTypeSetup())
                    return false;
                break;

            case RouteJobType::Process:
                if (!localGanttSetup.parmShowPlannedProdJobTypeProcess())
                    return false;
                break;

            case RouteJobType::Overlap:
                if (!localGanttSetup.parmShowPlannedProdJobTypeOverlap())
                    return false;
                break;

            case RouteJobType::Transport:
                if (!localGanttSetup.parmShowPlannedProdJobTypeTransport())
                    return false;
                break;

            case RouteJobType::QueueAfter:
                if (!localGanttSetup.parmShowPlannedProdJobTypeQueueAfter())
                    return false;
                break;
        }

        // show jobs not reserving capacity?
        if (!localGanttSetup.parmShowPlannedProdJobsNoCapRes())
        {
            prodJobType = ProdJobType::construct(_reqRouteJob.JobType);

            if (prodJobType == null)
            {
                throw error(strfmt("@SYS18707", funcname()));
            }

            // get _routeGroup if not passed in the parameters
            if (!_routeGroup.RecId)
            {
                // get _routeOpr if not passed in the parameters
                if (!_routeOpr.RecId)
                {
                    // get _reqRoute if not passed in the parameters
                    if (!_reqRoute.RecId)
                    {
                        _reqRoute = _reqRouteJob.reqRoute();

                        if (!_reqRoute.RecId)
                        {
                            throw error("@SYS102208");
                        }
                    }

                    routeOprRefRecId    = _reqRoute.RouteOprRefRecId;
                    _routeOpr           = RouteOpr::findRecId(routeOprRefRecId);

                    if (!_routeOpr.RecId)
                    {
                        throw error(strfmt("@SYS102169", routeOprRefRecId));
                    }
                }

                 _routeGroup = _routeOpr.routeGroup();

                if (!_routeGroup.RecId)
                {
                    throw error("@SYS102208");
                }
            }

            if (!prodJobType.scheduleCapacity(_routeGroup))
            {
                return false;
            }
        }

        // get _reqPO if not passed in the parameters
        if (!_reqPO.RecId)
        {
            _reqPO = ReqPO::find(
                _reqRouteJob.PlanVersion,
                _reqRouteJob.ReqPOId);

            if (!_reqPO.RecId)
            {
                throw error(strfmt("@SYS102169", routeOprRefRecId));
            }
        }

        // is planned production order job scheduled?
        if (!_reqPO.RouteJobsUpdated)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCalendars</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the combined calendars that are needed for parallel operations.
    /// </summary>
    /// <returns>
    ///    true if calendars were successfully created; otherwise, false.
    /// </returns>
    protected boolean createCalendars()
    {
        GanttTmpWrkCtrJob   ganttTmpWrkCtrJobSecondary;
        GanttTmpWrkCtrJob   ganttTmpWrkCtrJobPrimary;
        GanttTmpWrkCtrJob   ganttTmpWrkCtrJobUpdate;
        Set                 setCombinedCalendarsNames = new Set(Types::String);
        Set                 setGroupRecIds = null;
        MapEnumerator       mapEnumerator;
        SetEnumerator       setEnumeratorGroup;
        GanttTmpWrkCtrJob   localGanttTableWrkCtrJob;

        void createCombinedCalendar()
        {
            SetEnumerator           setEnumerator;
            GanttCalendarId         combinedCalendarName;
            GanttCalendarCombined   ganttCombinedCalendar;
            GanttCalendar           ganttCalendar;

            // check that we have at least one calendar to combine
            if (setCombinedCalendarsNames.elements() > 1)
            {
                setEnumerator = setCombinedCalendarsNames.getEnumerator();

                //create new calendar instance
                ganttCombinedCalendar = GanttCalendar::newGanttCalendarType(GanttCalendarType::Combined);

                // create the combined calendar name
                combinedCalendarName = '';
                while (setEnumerator && setEnumerator.moveNext())
                {
                    if (combinedCalendarName)
                    {
                        combinedCalendarName += ',';
                    }
                    combinedCalendarName += setEnumerator.current();

                    ganttCalendar = ganttCalendarCollection.findCalendarName(setEnumerator.current());

                    if (!ganttCalendar)
                    {
                        throw error(strfmt("@SYS119187", setEnumerator.current()));
                    }

                    ganttCombinedCalendar.parmSetCombinedCalendars().add(ganttCalendar);
                }

                if (!ganttCalendarCollection.findCalendarName(combinedCalendarName))
                {
                    ganttCombinedCalendar.parmCalendarName(combinedCalendarName);
                    ganttCalendarCollection.insert(ganttCombinedCalendar);
                }

                ttsbegin;

                // update the calendar id on all records that get a combined calendar
                setEnumerator = setGroupRecIds.getEnumerator();
                while (setEnumerator && setEnumerator.moveNext())
                {
                    // update the loaded data
                    update_recordset ganttTmpWrkCtrJobUpdate
                        setting CalendarId = combinedCalendarName
                        where ganttTmpWrkCtrJobUpdate.RecId == setEnumerator.current();

                    // update the data in the recordsorted list
                    this.parmGanttTableWrkCtrJob().updateField(
                        setEnumerator.current(),
                        fieldstr(GanttTmpWrkCtrJob, CalendarId),
                        combinedCalendarName);
                }

                ttscommit;
            }
        }

        if (!super())
        {
            return false;
        }

        // attach the table buffers to the rest of the temporary data
        ganttTmpWrkCtrJobPrimary.setTmpData(this.parmGanttTableWrkCtrJob().parmTableBuffer());
        ganttTmpWrkCtrJobSecondary.setTmpData(this.parmGanttTableWrkCtrJob().parmTableBuffer());
        ganttTmpWrkCtrJobUpdate.setTmpData(this.parmGanttTableWrkCtrJob().parmTableBuffer());

        mapEnumerator = mapLinkGroups2RecIds.getEnumerator();
        while (mapEnumerator && mapEnumerator.moveNext())
        {
            setGroupRecIds = mapEnumerator.currentValue();

            setCombinedCalendarsNames = new Set(Types::String);

            // iterate through all jobs belonging to a link group and get the calendar Ids
            setEnumeratorGroup = setGroupRecIds.getEnumerator();
            while (setEnumeratorGroup && setEnumeratorGroup.moveNext())
            {
                this.parmGanttTableWrkCtrJob().findRecId(setEnumeratorGroup.current());
                localGanttTableWrkCtrJob = this.parmGanttTableWrkCtrJob().parmTableBuffer() as GanttTmpWrkCtrJob;
                setCombinedCalendarsNames.add(localGanttTableWrkCtrJob.CalendarId);
            }

            createCombinedCalendar();
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createModifiedRefIdSet</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Analyzes the modified records and constructs a set of modified orders and projects.
    /// </summary>
    /// <param name="_setModifiedRecIds">
    ///    A set that contains the modified record Ids.
    /// </param>
    /// <returns>
    ///    A set of <c>RecIds</c>.
    /// </returns>
    /// <remarks>
    ///    The set of record IDs contains exactly one record from each modified order/project.This method
    ///    stores the modified <c>RefIds</c> in the member variable <c>setModifiedRefIds</c>.
    /// </remarks>
    protected Set createModifiedRefIdSet(Set _setModifiedRecIds)
    {
        Set                 setRecIds = new Set(Types::Int64);
        SetEnumerator       setEnumerator;
        GanttTmpWrkCtrJob   ganttTmpWrkCtrJob;

        setModifiedRefIds = new Set(Types::String);

        if (_setModifiedRecIds)
        {
            setEnumerator = _setModifiedRecIds.getEnumerator();

            while (setEnumerator && setEnumerator.moveNext())
            {
                if (ganttTableWrkCtrJob.findRecId(setEnumerator.current(), true))
                {
                    if (!setModifiedRefIds.in(ganttTmpWrkCtrJob.RefId))
                    {
                        ganttTmpWrkCtrJob = ganttTableWrkCtrJob.parmTableBuffer();

                        setModifiedRefIds.add(ganttTmpWrkCtrJob.RefId);
                        setRecIds.add(ganttTmpWrkCtrJob.RecId);
                    }
                }
            }
        }

        return setRecIds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ganttCalendarType</Name>
				<Source><![CDATA[
    public GanttCalendarType ganttCalendarType()
    {
        return GanttCalendarType::WrkCtr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGanttTableByRecId</Name>
				<Source><![CDATA[
    public GanttTableBase getGanttTableByRecId(tableName _tableName, recId _recId)
    {
        return super(_tableName, _recId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGroupRecIds</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a set of records that are grouped into the same link group.
    /// </summary>
    /// <param name="_linkGroup">
    ///    The link group number to retrieve the record IDs for.
    /// </param>
    /// <returns>
    ///    A <c>Set</c> that contains all of the jobs that belong to the link group number <c>_linkGroup</c>.
    /// </returns>
    public Set getGroupRecIds(int64 _linkGroup)
    {
        if (mapLinkGroups2RecIds.exists(_linkGroup))
        {
            return mapLinkGroups2RecIds.lookup(_linkGroup);
        }
        else
        {
            return new Set(Types::Int64);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIdentifierFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Constructs a field list as a container with the fields used for identifying a job when displaying
    ///    an error or warning to the user.
    /// </summary>
    /// <param name="_refType">
    ///    The type of order for which to return the fields used to identify the jobs.
    /// </param>
    /// <returns>
    ///    A container holding the IDs of the fields to use when it builds the job identification string.
    /// </returns>
    private container getIdentifierFields(WrkCtrCapRefType _refType)
    {
        container       identifierFieldIds;
        boolean         ret = true;

        switch (_refType)
        {
            case WrkCtrCapRefType::Production   :
                identifierFieldIds = [fieldnum(RouteJobMap, OprNum),
                                      fieldnum(RouteJobMap, JobType),
                                      fieldnum(RouteJobMap, WrkCtrId)];
                break;

            case WrkCtrCapRefType::PlannedOrder :
                identifierFieldIds = [fieldnum(RouteJobMap, OprNum),
                                      fieldnum(RouteJobMap, JobType),
                                      fieldnum(RouteJobMap, WrkCtrId)];
                break;

            case WrkCtrCapRefType::Project      :
                identifierFieldIds = [fieldnum(RouteJobMap, LineNum)];
                break;

            default                             :
                ret = ret && checkFailed(strfmt("@SYS26908", _refType));
        }

        return identifierFieldIds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLinkGroupByRecId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the link group number for a specific job.
    /// </summary>
    /// <param name="_recId">
    ///    The <c>RecId</c> that identifies the job for which to return the link group number.
    /// </param>
    /// <returns>
    ///    The link group number as an Int64.
    /// </returns>
    public int64 getLinkGroupByRecId(RecId _recId)
    {
        if (mapRecId2LinkGroup.exists(_recId))
        {
            return mapRecId2LinkGroup.lookup(_recId);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAllNewLinks</Name>
				<Source><![CDATA[
    private Set getAllNewLinks(RecId _recId, Map _mapNodeLinks)
    {
        GanttLinkType       linkDataLinkType;
        RecId               linkDataSuccessorRecId;
        container           setNewLinksResultReturn;
        container           setGetMoreLinksReturn;
        Set                 setNewLinks;
        Set                 setGetMoreLinks;
        Set                 moreLinksToProcess;
        Set                 moreLinksToSkip;
        SetEnumerator       moreLinksToProcessEnumerator;
        
        [setNewLinksResultReturn, setGetMoreLinksReturn] = this.getNewLinks(_recId, _mapNodeLinks, true, GanttLinkType::None);
        
        setNewLinks = Set::create(setNewLinksResultReturn);
        moreLinksToProcess = Set::create(setGetMoreLinksReturn);
        
        moreLinksToSkip = new Set(Types::Container);
        moreLinksToSkip.add([_recId, GanttLinkType::None]);
        
        while (moreLinksToProcess.elements() > 0)
        {
            moreLinksToProcessEnumerator = moreLinksToProcess.getEnumerator();
            setGetMoreLinks = new Set(Types::Container);
            
            while (moreLinksToProcessEnumerator.moveNext())
            {
                [linkDataSuccessorRecId, linkDataLinkType] = moreLinksToProcessEnumerator.current();
                if (moreLinksToSkip.in([linkDataSuccessorRecId, linkDataLinkType]))
                {
                    continue;
                }
                
                [setNewLinksResultReturn, setGetMoreLinksReturn] = this.getNewLinks(linkDataSuccessorRecId, _mapNodeLinks, false, linkDataLinkType);
                
                setGetMoreLinks = Set::union(setGetMoreLinks, Set::create(setGetMoreLinksReturn));
                setNewLinks = Set::union(setNewLinks, Set::create(setNewLinksResultReturn));
                moreLinksToSkip.add([linkDataSuccessorRecId, linkDataLinkType]);
            }
            
            moreLinksToProcess = Set::create(setGetMoreLinks.pack());
        }
        
        return setNewLinks;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewLinks</Name>
				<Source><![CDATA[
    private container getNewLinks(RecId _recId, Map _mapNodeLinks, boolean _firstCall = false, GanttLinkType _ganttLinkType = GanttLinkType::None)
    {
        Set                     setNewLinksResult = new Set(Types::Container);
        Set                     setGetMoreLinks = new Set(Types::Container);
        Set                     setNodeLinks;
        SetEnumerator           setLinksEnumerator;
        container               linkData;
        GanttLinkType           linkDataLinkType;
        RecId                   linkDataSuccessorRecId;
        NoYes                   linkDataSuccessorIsDisplayed;
        
        if (_mapNodeLinks.exists(_recId))
        {
            setNodeLinks = _mapNodeLinks.lookup(_recId);

            setLinksEnumerator = setNodeLinks.getEnumerator();
            while (setLinksEnumerator && setLinksEnumerator.moveNext())
            {
                linkData = setLinksEnumerator.current();
                [linkDataSuccessorRecId, linkDataSuccessorIsDisplayed, linkDataLinkType] = linkData;
                
                // check if node is displayed
                if (linkDataSuccessorIsDisplayed == NoYes::Yes)
                {
                    if (!_firstCall)
                    {
                        // add the new link info
                        setNewLinksResult.add([linkDataSuccessorRecId, _ganttLinkType, linkDataLinkType]);
                    }
                }
                else
                {
                    if (_firstCall)
                    {
                        _ganttLinkType = linkDataLinkType;
                    }

                    if (_recId != linkDataSuccessorRecId)
                    {
                        setGetMoreLinks.add([linkDataSuccessorRecId, _ganttLinkType]);
                    }
                }
            }
        }
        
        return [setNewLinksResult.pack(), setGetMoreLinks.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRecordByRecId</Name>
				<Source><![CDATA[
    public Common getRecordByRecId(tableName _tableName, recId _recId)
    {
        return super(_tableName, _recId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSetEmptyWrkCtrIds</Name>
				<Source><![CDATA[
    public Set getSetEmptyWrkCtrIds()
    {
        return setEmptyWrkCtrIds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWrkCtrDataFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a map that contains the data fields for a specified resource such as a site, production
    ///    unit, and resource group.
    /// </summary>
    /// <param name="_wrkCtrId">
    ///    A resource ID that specifies the resource identifier for which to get the data.
    /// </param>
    /// <param name="_wrkCtrResourceGroup">
    ///    A resource group record for which to get the data.
    /// </param>
    /// <returns>
    ///    A map of field names to field values that contains the data for the resource.
    /// </returns>
    protected Map getWrkCtrDataFields(WrkCtrId _wrkCtrId, WrkCtrResourceGroup _wrkCtrResourceGroup)
    {
        Map                 mapFieldValues = new Map(Types::String, Types::String);

        mapFieldValues.insert(fieldstr(GanttTmpWrkCtrJob, WrkCtrId), _wrkCtrId);
        mapFieldValues.insert(fieldstr(GanttTmpWrkCtrJob, InventSiteId), _wrkCtrResourceGroup.SiteId);
        mapFieldValues.insert(fieldstr(GanttTmpWrkCtrJob, ProdUnitId), _wrkCtrResourceGroup.ProdUnitId);
        mapFieldValues.insert(fieldstr(GanttTmpWrkCtrJob, WrkCtrGroupId), _wrkCtrResourceGroup.WrkCtrId);

        return mapFieldValues;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initEmptyWrkCtrIds</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the internal data regarding empty work centers.
    /// </summary>
    /// <remarks>
    ///    Empty work centers are work centers that do not have any jobs displayed.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    ///    Exception thrown if the set that is to hold the empty work center data (<c>setEmptyWrkCtrIds</c>)
    ///    could not be initialized.
    /// </exception>
    public void initEmptyWrkCtrIds()
    {
        SetEnumerator                   setEnumerator;
        WrkCtrId                        wrkCtrId;
        WrkCtrResourceGroup             wrkCtrResourceGroup;
        WrkCtrResourceGroupResource     wrkCtrResourceGroupResource;
        date                            searchFromDate = this.parmLoadingFromDate();
        date                            searchToDate   = this.parmLoadingToDate();

        this.resetEmptyWrkCtrIds();

        if (setEmptyWrkCtrIds == null)
        {
            throw error(strfmt("@SYS27147", classId2Name(classidget(this))));
        }

        setEnumerator = setLoadWrkCtrIds.getEnumerator();

        while (setEnumerator && setEnumerator.moveNext())
        {
            wrkCtrId = setEnumerator.current();

            // For each resource find the distinct resource groups that it can be member of for the shown period
            // and if that combination is not shown then add it
            while select validTimeState(searchFromDate, searchToDate) wrkCtrResourceGroup
                exists join wrkCtrResourceGroupResource
                    where wrkCtrResourceGroupResource.ResourceGroup == wrkCtrResourceGroup.RecId
                       && wrkCtrResourceGroupResource.WrkCtrId      == wrkCtrId
            {
                if (!this.parmGanttTableWrkCtrJob().existWrkCtrJobs(wrkCtrId, wrkCtrResourceGroup.WrkCtrId))
                {
                    setEmptyWrkCtrIds.add(this.getWrkCtrDataFields(wrkCtrId, wrkCtrResourceGroup));

                    this.addCalendarName(wrkCtrId);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFieldCollection</Name>
				<Source><![CDATA[
    protected void initFieldCollection()
    {
        super();

        this.initFieldCollectionWrkCtrJob();

        this.initFieldCollectionLinks();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFieldCollectionLinks</Name>
				<Source><![CDATA[
    protected void initFieldCollectionLinks()
    {
        ganttTableLink.initDefaultFieldCollection();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFieldCollectionWrkCtrJob</Name>
				<Source><![CDATA[
    protected void initFieldCollectionWrkCtrJob()
    {
        ganttTableWrkCtrJob.initDefaultFieldCollection();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLoadingDataFromCallerDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate raised to populate the set of WrkCtr Ids to load.
    /// </summary>
    /// <param name = "_ganttData_WrkCtr">The caller of the delegate.</param>
    /// <param name = "_setLoadWrkCtrIds">The set to populate.</param>
    delegate void initLoadingDataFromCallerDelegate(
        GanttData_WrkCtr    _ganttData_WrkCtr,
        Set                 _setLoadWrkCtrIds)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLoadingDataFromCaller</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the work center list and the time interval used at later load stages for loading the
    /// actual table data.
    /// </summary>
    /// <remarks>
    /// If Gantt is opened from the work center or the Gantt table, then the work center list is taken from
    /// the <see cref="T:GanttClient" /> class directly because it should have been set up already from the
    /// caller. If Gantt is opened from the production orders, the planned production orders, or the
    /// project hour forecast, and then the work center list is computed based on the selected orders and
    /// also, if it is needed, the time interval is expanded to load complete orders.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    /// Exception thrown if the caller was not correctly specified when the <see cref="T:GanttClient" />
    /// was created.
    /// </exception>
    protected void initLoadingDataFromCaller()
    {
        SetEnumerator       setEnumerator;

        ProdRouteJob        prodRouteJob;
        ProdRoute           prodRoute;
        ProdTable           prodTable;

        ReqRouteJob         reqRouteJob;
        ReqRoute            reqRoute;
        ReqPO               reqPO;

        ProjForecastEmpl    projForecastEmpl;
        ProjTable           projTable;

        Set                 setLoadData;
        GanttClient_WrkCtr  localGanttClient = this.parmGanttClient() as GanttClient_WrkCtr;
        GanttSetup_WrkCtr   localGanttSetup = this.parmGanttClient().parmGanttSetup() as GanttSetup_WrkCtr;
        GanttView_WrkCtr    localGanttView  = this.parmGanttClient().parmGanttView() as GanttView_WrkCtr;

        if (!localGanttClient.isCalledFromWrkCtr()             &&
           !localGanttClient.parmIsTimeScaleIntervalModified())
        {
            this.resetLoadingDatesInterval();
        }

        switch (localGanttClient.parmGanttCaller())
        {
            // called from work center
            case GanttCallerWrkCtr::WrkCtr:
            case GanttCallerWrkCtr::GanttTable:
                setLoadWrkCtrIds = Set::create(this.conSetLoadIds());
                break;

            // called from production order
            case GanttCallerWrkCtr::Prod            :

                localGanttSetup.parmLoadProdJobData(NoYes::Yes);

                setLoadData     = Set::create(GanttData_WrkCtr::getDataProdForIds(this.conSetLoadIds()));

                setEnumerator   = setLoadData.getEnumerator();
                while (setEnumerator && setEnumerator.moveNext())
                {
                    [prodRouteJob, prodRoute, prodTable] = setEnumerator.current();
                    if (this.canLoadProdRouteJob(prodRouteJob, prodRoute, null, prodTable))
                    {
                        // Use the production job dates for the loading dates only if the time scale interval was not modified by user.
                        // Otherwise, the loading dates equal the time scale interval's dates.
                        if (!this.parmGanttClient().parmIsTimeScaleIntervalModified())
                        {
                            this.adjustLoadingDatesInterval(prodRouteJob.FromDate,
                                                            prodRouteJob.ToDate);

                            if (localGanttView.mustLoadDeliveryDate())
                            {
                                this.adjustLoadingDatesInterval(prodTable.DlvDate,
                                                                prodTable.DlvDate);
                            }
                        }

                        setLoadWrkCtrIds.add(prodRouteJob.WrkCtrId);
                    }
                }

                break;

            // called from planned production order
            case GanttCallerWrkCtr::PlannedProd     :

                localGanttSetup.parmLoadPlannedProdJobData(NoYes::Yes);

                localGanttSetup.parmReqPlanIdPlannedProd(localGanttClient.parmReqPlanIdPlannedProd());

                setLoadData     = Set::create(GanttData_WrkCtr::getDataPlannedProdForIds(this.conSetLoadIds(),
                                                                                         localGanttClient.parmReqPlanIdPlannedProd()));

                setEnumerator = setLoadData.getEnumerator();
                while (setEnumerator && setEnumerator.moveNext())
                {
                    [reqRouteJob, reqRoute, reqPO] = setEnumerator.current();
                    if (this.canLoadReqRouteJob(reqRouteJob, reqRoute, null, null, reqPO))
                    {
                        // Use the planned production job dates for the loading dates only if the time scale interval was not modified by user.
                        // Otherwise, the loading dates equal the time scale interval's dates.
                        if (!this.parmGanttClient().parmIsTimeScaleIntervalModified())
                        {
                            this.adjustLoadingDatesInterval(reqRouteJob.FromDate,
                                                            reqRouteJob.ToDate);

                            if (localGanttView.mustLoadDeliveryDate())
                            {
                                this.adjustLoadingDatesInterval(reqPO.ReqDateDlv,
                                                                reqPO.ReqDateDlv);
                            }
                        }

                        setLoadWrkCtrIds.add(reqRouteJob.WrkCtrId);
                    }
                }

                break;

            // called from project
            case GanttCallerWrkCtr::Proj            :
                localGanttSetup.parmLoadProjData(NoYes::Yes);

                setLoadData     = Set::create(GanttData_WrkCtr::getDataProjForIds(this.conSetLoadIds()));

                setEnumerator = setLoadData.getEnumerator();
                while (setEnumerator && setEnumerator.moveNext())
                {
                    [projForecastEmpl, projTable] = setEnumerator.current();
                    if (this.canLoadProjForecastEmpl(projForecastEmpl, this.parmGanttClient().isFirstLoad()))
                    {
                        // Use the project hour forecast dates for the loading dates only if the time scale interval was not modified by user.
                        // Otherwise, the loading dates equal the time scale interval's dates.
                        if (!localGanttClient.parmIsTimeScaleIntervalModified())
                        {
                            this.adjustLoadingDatesInterval(projForecastEmpl.SchedFromDate,
                                                            projForecastEmpl.SchedToDate);

                            if (localGanttView.mustLoadDeliveryDate())
                            {
                                this.adjustLoadingDatesInterval(projTable.EndDate,
                                                                projTable.EndDate);
                            }
                        }

                        setLoadWrkCtrIds.add(projForecastEmpl.SchedWrkCtrId);
                    }
                }
                break;

            default:
                this.initLoadingDataFromCallerDelegate(this, setLoadWrkCtrIds);
                break;
        }

        this.setCallerDates();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLoadingDataFromEntirePlannedProd</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the work center list that is used for loading data and extends the time interval, if it
    ///    is needed, so that the loaded planned production orders are completely loaded.
    /// </summary>
    protected void initLoadingDataFromEntirePlannedProd()
    {
        GanttSetup_WrkCtr localGanttSetup = this.parmGanttClient().parmGanttSetup() as GanttSetup_WrkCtr;

        SetEnumerator   setEnumerator;

        ReqRouteJob     reqRouteJob;

        Set             setReqPoIds = new Set(Types::String);
        ReqPlanId       reqPlanId = localGanttSetup.parmReqPlanIdPlannedProd();
        Set             setDataPlannedProd;

        if (!this.canLoadPlannedProdData()                                           ||
           !localGanttSetup.parmLoadEntirePlannedProdOrder())
        {
            return;
        }

        setDataPlannedProd = Set::create(GanttData_WrkCtr::initLoadingDataFromEntireReqPOOnServer(setLoadWrkCtrIds.pack(),
                                                                                                 callerFromDate,
                                                                                                 callerToDate,
                                                                                                 reqPlanId));

        // find all planned production orders in the original dates interval
        setEnumerator = setDataPlannedProd.getEnumerator();
        while (setEnumerator && setEnumerator.moveNext())
        {
            [reqRouteJob] = setEnumerator.current();
            if (this.canLoadReqRouteJob(reqRouteJob))
            {
                this.adjustLoadingDatesInterval(reqRouteJob.FromDate, reqRouteJob.ToDate);

                setLoadWrkCtrIds.add(reqRouteJob.WrkCtrId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLoadingDataFromEntireProd</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the work center list that is used for loading data and extends the time interval, if
    ///    needed, so that the loaded production orders are completely loaded.
    /// </summary>
    protected void initLoadingDataFromEntireProd()
    {
        ProdRouteJob    prodRouteJob;
        SetEnumerator   setEnumerator;
        Set             setDataProd;
        GanttSetup_WrkCtr localGanttSetup = this.parmGanttClient().parmGanttSetup() as GanttSetup_WrkCtr;

        if (!this.canLoadProdData()                                          ||
           !localGanttSetup.parmLoadEntireProdOrder())
        {
            return;
        }

        setDataProd = Set::create(GanttData_WrkCtr::initLoadingDataFromEntireProdOnServer(setLoadWrkCtrIds.pack(),
                                                                                          callerFromDate,
                                                                                          callerToDate));

        // find all production orders in the original dates interval
        setEnumerator = setDataProd.getEnumerator();
        while (setEnumerator && setEnumerator.moveNext())
        {
            [prodRouteJob] = setEnumerator.current();
            if (this.canLoadProdRouteJob(prodRouteJob))
            {
                this.adjustLoadingDatesInterval(prodRouteJob.FromDate, prodRouteJob.ToDate);

                setLoadWrkCtrIds.add(prodRouteJob.WrkCtrId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLoadingDataFromEntireProj</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the work center list that is used for loading data and extends the time interval, if it
    ///    is needed, so that the loaded project hour forecasts are completely loaded.
    /// </summary>
    protected void initLoadingDataFromEntireProj()
    {
        ProjForecastEmpl    projForecastEmpl;
        SetEnumerator       setEnumerator;
        Set                 setDataProj;
        GanttSetup_WrkCtr   localGanttSetup = this.parmGanttClient().parmGanttSetup() as GanttSetup_WrkCtr;

        if (!this.canLoadProjData()                                          ||
           !localGanttSetup.parmLoadEntireProject())
        {
            return;
        }

        setDataProj = Set::create(GanttData_WrkCtr::initLoadingDataFromEntireProjOnServer(setLoadWrkCtrIds.pack(),
                                                                                          callerFromDate,
                                                                                          callerToDate));

        // find all projects in the original dates interval
        setEnumerator = setDataProj.getEnumerator();
        while (setEnumerator && setEnumerator.moveNext())
        {
            [projForecastEmpl] = setEnumerator.current();
            if (this.canLoadProjForecastEmpl(projForecastEmpl))
            {
                this.adjustLoadingDatesInterval(projForecastEmpl.SchedFromDate, projForecastEmpl.SchedToDate);

                setLoadWrkCtrIds.add(projForecastEmpl.SchedWrkCtrId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPostLoadingData</Name>
				<Source><![CDATA[
    protected void initPostLoadingData()
    {
        super();

        this.sortNodeData();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPreLoadingData</Name>
				<Source><![CDATA[
    protected void initPreLoadingData()
    {
        super();

        this.initLoadingDataFromCaller();

        this.initLoadingDataFromEntireProd();

        this.initLoadingDataFromEntirePlannedProd();

        this.initLoadingDataFromEntireProj();

        this.adjustIntervalFromOrder();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTableCollection</Name>
				<Source><![CDATA[
    protected void initTableCollection()
    {
        super();

        this.parmGanttTableCollection().insert(ganttTableWrkCtrJob);
        this.parmGanttTableCollection().insert(ganttTableLink);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTables</Name>
				<Source><![CDATA[
    protected void initTables()
    {
        super();

        if (!ganttTableWrkCtrJob)
        {
            ganttTableWrkCtrJob = GanttTable_WrkCtrJob::newAllowUserModification(true);
        }

        if (!ganttTableLink)
        {
            ganttTableLink = GanttTable_Link::newAllowUserModification(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCalendarName</Name>
				<Source><![CDATA[
    protected void insertCalendarName(GanttTable_WrkCtrJob _ganttTableWrkCtrJob)
    {
        GanttTmpWrkCtrJob localGanttTableWrkCtrJob = _ganttTableWrkCtrJob.parmTableBuffer();
        this.addCalendarName(localGanttTableWrkCtrJob.CalendarId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertDataPlannedProd</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts data into the <see cref="GanttTmpWrkCtrJob Table" /> based on a planned production order
    ///    data.
    /// </summary>
    /// <param name="_reqRouteJob">
    ///    The <see cref="ReqRouteJob Table" /> buffer containing the job details.
    /// </param>
    /// <param name="_reqRoute">
    ///    The <see cref="ReqRoute Table" /> buffer containing details about the operation to which the job
    ///    belongs.
    /// </param>
    /// <param name="_reqPO">
    ///    The <see cref="ReqPO Table" /> buffer containing details about the planned order to which the job
    ///    belongs.
    /// </param>
    /// <param name="_wrkCtrTable">
    ///    The <see cref="WrkCtrTable Table" /> buffer containing information about the associated work center.
    /// </param>
    /// <param name="_isDisplayed">
    ///    Set to true if the job should be displayed in the Gantt chart; otherwise set to false.
    /// </param>
    /// <param name="_wrkCtrResourceGroup">
    ///    The <see cref="WrkCtrResourceGroup Table" /> buffer containing information about the associated resource group.
    /// </param>
    /// <param name="_allowEdit">
    ///    Determines if the job is allowed to be edited (moved); optional.
    /// </param>
    /// <param name="_materialAvailabilityDateTime">
    ///    The material availability date/time of the operation; optional.
    /// </param>
    protected void insertDataPlannedProd(ReqRouteJob            _reqRouteJob,
                                         ReqRoute               _reqRoute,
                                         ReqPO                  _reqPO,
                                         WrkCtrTable            _wrkCtrTable,
                                         boolean                _isDisplayed,
                                         WrkCtrResourceGroup    _wrkCtrResourceGroup = null,
                                         boolean                _allowEdit = true,
                                         utcdatetime            _materialAvailabilityDateTime = DateTimeUtil::minValue())
    {
        if (_isDisplayed)
        {
            hasPlannedProdJobs = true;
        }

        // insert production job data
        ganttTableWrkCtrJob.cleanTableBuffer();

        ganttTableWrkCtrJob.setAllowEdit(_allowEdit);
        ganttTableWrkCtrJob.initFromReqRouteJob(_reqRouteJob, _reqRoute);
        ganttTableWrkCtrJob.initFromReqRoute(_reqRoute);
        ganttTableWrkCtrJob.initFromReqPO(_reqPO);

        if (prmisDefault(_wrkCtrResourceGroup))
        {
            ganttTableWrkCtrJob.initFromWrkCtrTable(_wrkCtrTable, _reqRouteJob.FromDate, _reqRouteJob.ToDate);
        }
        else
        {
            ganttTableWrkCtrJob.initFromWrkCtrResourceGroup(_wrkCtrResourceGroup);
        }

        ganttTableWrkCtrJob.initFromGanttSetup(this.parmGanttClient().parmGanttSetup());
        ganttTableWrkCtrJob.initFromGanttColor(this.parmGanttClient().parmGanttColor());

        ganttTableWrkCtrJob.initEmptyGroupNames();
        ganttTableWrkCtrJob.setIsDisplayed(_isDisplayed);
        
        GanttTmpWrkCtrJob duplicateRecord = ganttTableWrkCtrJob.findDuplicate();
        if (!duplicateRecord)
        {
            ganttTableWrkCtrJob.setMaterialAvailabilityDateTime(_materialAvailabilityDateTime);
            
            ganttTableWrkCtrJob.insert(_reqRouteJob.RecId, _reqRouteJob.RecVersion);

            // insert calendar name
            this.insertCalendarName(ganttTableWrkCtrJob);
        }
        else
        {
            if (_isDisplayed && duplicateRecord.IsDisplayed == NoYes::No)
            {
                ganttTableWrkCtrJob.updateField(duplicateRecord.RecId, fieldstr(GanttTmpWrkCtrJob, IsDisplayed), NoYes::Yes);
            }
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>insertDataProd</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts data into the <see cref="GanttTmpWrkCtrJob Table" /> based on a production order data.
    /// </summary>
    /// <param name="_prodRouteJob">
    ///    The <see cref="ProdRouteJob Table" /> buffer containing the job details.
    /// </param>
    /// <param name="_prodRoute">
    ///    The <see cref="ProdRoute Table" /> buffer containing details about the operation to which the job
    ///    belongs.
    /// </param>
    /// <param name="_prodTable">
    ///    The <see cref="ProdTable Table" /> buffer containing details about the production order to which
    ///    the job belongs.
    /// </param>
    /// <param name="_wrkCtrTable">
    ///    The <see cref="WrkCtrTable Table" /> buffer containing information about the associated work center.
    /// </param>
    /// <param name="_isDisplayed">
    ///    Set to true if the job should be displayed in the Gantt chart; otherwise set to false.
    /// </param>
    /// <param name="_wrkCtrResourceGroup">
    ///    The <see cref="WrkCtrResourceGroup Table" /> buffer containing information about the associated resource group.
    /// </param>
    /// <param name="_allowEdit">
    ///    Determines if the job is allowed to be edited (moved); optional.
    /// </param>
    /// <param name="_materialAvailabilityDateTime">
    ///    The material availability date/time of the operation; optional.
    /// </param>
    protected void insertDataProd(ProdRouteJob          _prodRouteJob,
                                  ProdRoute             _prodRoute,
                                  ProdTable             _prodTable,
                                  WrkCtrTable           _wrkCtrTable,
                                  boolean               _isDisplayed,
                                  WrkCtrResourceGroup   _wrkCtrResourceGroup = null,
                                  boolean               _allowEdit = true,
                                  utcdatetime           _materialAvailabilityDateTime = DateTimeUtil::minValue())
    {
        if (_isDisplayed)
        {
            hasProdJobs = true;
        }
                
        // insert production job data
        ganttTableWrkCtrJob.cleanTableBuffer();
        ganttTableWrkCtrJob.setAllowEdit(_allowEdit);
        ganttTableWrkCtrJob.initFromProdRouteJob(_prodRouteJob, _prodRoute);
        ganttTableWrkCtrJob.initFromProdRoute(_prodRoute);
        ganttTableWrkCtrJob.initFromProdTable(_prodTable);

        if (prmisDefault(_wrkCtrResourceGroup))
        {
            ganttTableWrkCtrJob.initFromWrkCtrTable(_wrkCtrTable, _prodRouteJob.FromDate, _prodRouteJob.ToDate);
        }
        else
        {
            ganttTableWrkCtrJob.initFromWrkCtrResourceGroup(_wrkCtrResourceGroup);
        }

        ganttTableWrkCtrJob.setReqPlanId(reqPlanIdDefaultDynamic);

        ganttTableWrkCtrJob.initFromGanttSetup(this.parmGanttClient().parmGanttSetup());
        ganttTableWrkCtrJob.initFromGanttColor(this.parmGanttClient().parmGanttColor());

        ganttTableWrkCtrJob.initEmptyGroupNames();
        ganttTableWrkCtrJob.setIsDisplayed(_isDisplayed);
        ganttTableWrkCtrJob.setMaterialAvailabilityDateTime(_materialAvailabilityDateTime);

        GanttTmpWrkCtrJob duplicateRecord = ganttTableWrkCtrJob.findDuplicate();
        if (!duplicateRecord)
        {
            ganttTableWrkCtrJob.insert(_prodRouteJob.RecId, _prodRouteJob.RecVersion);

            // insert calendar name
            this.insertCalendarName(ganttTableWrkCtrJob);
        }
        else
        {
            if (_isDisplayed && duplicateRecord.IsDisplayed == NoYes::No)
            {
                ganttTableWrkCtrJob.updateField(duplicateRecord.RecId, fieldstr(GanttTmpWrkCtrJob, IsDisplayed), NoYes::Yes);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertDataProj</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts data into the <see cref="GanttTmpWrkCtrJob Table" /> based on project hour forecast data.
    /// </summary>
    /// <param name="_projForecastEmpl">
    ///    The <see cref="ProjForecastEmpl Table" /> buffer containing the activity details.
    /// </param>
    /// <param name="_projTable">
    ///    The <see cref="ProjTable Table" /> buffer containing details about the project to which the
    ///    activity belongs.
    /// </param>
    /// <param name="_smmActivities">
    ///    The <see cref="smmActivities Table" /> buffer containing details about the activity the project
    ///    hour forecast record belongs to.
    /// </param>
    /// <param name="_wrkCtrTable">
    ///    The <see cref="WrkCtrTable Table" /> buffer containing information about the associated work center.
    /// </param>
    /// <param name="_isDisplayed">
    ///    Set to true if the job should be displayed in the Gantt chart; otherwise set to false.
    /// </param>
    /// <param name="_wrkCtrResourceGroup">
    ///    The <see cref="WrkCtrResourceGroup Table" /> buffer containing information about the associated resource group.
    /// </param>
    /// <param name="_allowEdit">
    ///    Determines if the job is allowed to be edited (moved); optional.
    /// </param>
    protected void insertDataProj(ProjForecastEmpl      _projForecastEmpl,
                                  ProjTable             _projTable,
                                  smmActivities         _smmActivities,
                                  WrkCtrTable           _wrkCtrTable,
                                  boolean               _isDisplayed,
                                  WrkCtrResourceGroup   _wrkCtrResourceGroup = null,
                                  boolean               _allowEdit = true)
    {
        if (_isDisplayed)
        {
            hasProjJobs = true;
        }

        // insert production job data
        ganttTableWrkCtrJob.cleanTableBuffer();

        ganttTableWrkCtrJob.setAllowEdit(_allowEdit);
        ganttTableWrkCtrJob.initFromProjForecastEmpl(_projForecastEmpl);
        ganttTableWrkCtrJob.initFromProjTable(_projTable);
        ganttTableWrkCtrJob.initFromsmmActivities(_smmActivities);

        if (prmisDefault(_wrkCtrResourceGroup))
        {
            ganttTableWrkCtrJob.initFromWrkCtrTable(_wrkCtrTable, _projForecastEmpl.SchedFromDate, _projForecastEmpl.SchedToDate);
        }
        else
        {
            ganttTableWrkCtrJob.initFromWrkCtrResourceGroup(_wrkCtrResourceGroup);
        }

        ganttTableWrkCtrJob.setReqPlanId(reqPlanIdDefaultDynamic);

        ganttTableWrkCtrJob.initFromGanttSetup(this.parmGanttClient().parmGanttSetup());
        ganttTableWrkCtrJob.initFromGanttColor(this.parmGanttClient().parmGanttColor());

        ganttTableWrkCtrJob.initEmptyGroupNames();
        ganttTableWrkCtrJob.setIsDisplayed(_isDisplayed);

        GanttTmpWrkCtrJob duplicateRecord = ganttTableWrkCtrJob.findDuplicate();
        if (!duplicateRecord)
        {
            ganttTableWrkCtrJob.insert(_projForecastEmpl.RecId, _projForecastEmpl.RecVersion);

            // insert calendar name
            this.insertCalendarName(ganttTableWrkCtrJob);
        }
        else
        {
            if (_isDisplayed && duplicateRecord.IsDisplayed == NoYes::No)
            {
                ganttTableWrkCtrJob.updateField(duplicateRecord.RecId, fieldstr(GanttTmpWrkCtrJob, IsDisplayed), NoYes::Yes);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadData</Name>
				<Source><![CDATA[
    protected void loadData()
    {
        super();

        this.loadDataWrkCtrIdSet(setLoadWrkCtrIds);        
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadDataWrkCtrIdSet</Name>
				<Source><![CDATA[
    private void loadDataWrkCtrIdSet(Set _wrkCtrIds, boolean _alwaysInitEmpty = false)
    {
        // load production data
        this.loadDataProdWrkCtrIdSet(_wrkCtrIds);

        // load planned production data
        this.loadDataPlannedProdWrkCtrIdSet(_wrkCtrIds);

        // load project data
        this.loadDataProjWrkCtrIdSet(_wrkCtrIds);

        // load links between jobs
        this.loadDataLinks();

        // adjust the links after loading
        this.adjustLinks();

        // create a map of work centers without jobs
        GanttClient_WrkCtr localGanttClient = this.parmGanttClient() as GanttClient_WrkCtr;
        if (_alwaysInitEmpty || localGanttClient.isCalledFromWrkCtr())
        {
            this.initEmptyWrkCtrIds();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadAdditionalResources</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads data for additional resources.
    /// </summary>
    /// <param name = "_wrkCtrIds">The set of new resource Ids to load data for.</param>
    public void loadAdditionalResources(Set _wrkCtrIds)
    {
        // Merge the set of already loaded data with the new set
        setLoadWrkCtrIds = Set::union(setLoadWrkCtrIds, _wrkCtrIds);
        tmpWrkCtrIdLoaded = null;

        // Load new data
        this.loadDataWrkCtrIdSet(_wrkCtrIds, true);

        // Load calendars
        this.createCalendars();
        this.loadCalendarData();
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadAdditionalDates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads data for additional dates as specified in the client. Only call this when the date range has been expanded.
    /// </summary>
    public void loadAdditionalDates()
    {
        // Set loading dates to client dates
        this.initLoadingDatesInterval();

        // Load new data
        this.loadDataWrkCtrIdSet(setLoadWrkCtrIds, true);

        // Load calendars
        this.createCalendars();
        this.loadCalendarData(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadDataLinks</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads the links information for work center data.
    /// </summary>
    /// <remarks>
    ///    There are two distinct parts for constructing the links:
    ///    <list type="number">
    ///       <item>
    ///          <description>The links between the primary job nodes and the next primary job node are
    ///          constructed.</description>
    ///       </item>
    ///       <item>
    ///          <description>The links for secondary nodes copy the links present on the primary job
    ///          nodes.</description>
    ///       </item>
    ///    </list>
    /// </remarks>
    protected void loadDataLinks()
    {
        SetEnumerator       setEnumerator;
        GanttTmpWrkCtrJob   currentJob    = null;
        GanttTmpWrkCtrJob   allJobs       = null;
        GanttTmpWrkCtrJob   nextJob       = null;
        GanttTmpWrkCtrJob   primaryJob;
        GanttLinkType       ganttLinkType;
        GanttSetup_WrkCtr   localGanttSetup = this.parmGanttClient().parmGanttSetup() as GanttSetup_WrkCtr;

        // Returns the link group if it has already been set for any of the records in the set _setRecIds
        int64 getLinkGroup(Set _setRecords)
        {
            SetEnumerator       setEnumeratorGroup;
            int64               resultLinkGroup = 0;
            GanttTmpWrkCtrJob   jobTmp;

            setEnumeratorGroup = _setRecords.getEnumerator();
            while (setEnumeratorGroup && setEnumeratorGroup.moveNext())
            {
                jobTmp = setEnumeratorGroup.current();
                resultLinkGroup = this.getLinkGroupByRecId(jobTmp.RecId);

                if (resultLinkGroup)
                {
                    break;
                }
            }

            return resultLinkGroup;
        }

        // inserts links between the current job and all next jobs
        void loadLinksByRecIds(GanttTmpWrkCtrJob _currentJob, GanttTmpWrkCtrJob _primaryJob = null)
        {
            Set                 setRecords;
            container           conRecords;
            GanttTmpWrkCtrJob   jobTmp;
            int64               nextJobsLinkGroup;

            // the _primaryJob is passed so this is treated as the master job to which the links should be attached
            if (_primaryJob)
            {
                jobTmp = _primaryJob;
            }
            else
            {
                jobTmp = _currentJob;
            }

            // get the next nodes for the job
            conRecords = GanttTmpWrkCtrJob::getNextJobsRecords(jobTmp, allJobs, _primaryJob ? true : false);

            // if no link group is already set on the link predecessor then set it to a new number
            if (!mapRecId2LinkGroup.exists(jobTmp.RecId))
            {
                if (_currentJob.IsDisplayed)
                {
                    this.addRecId2LinkGroup(_currentJob.RecId, linkGroupNo);
                }
                linkGroupNo ++;
            }
            else
            {
                // if we don't exist in the link group map and we have a primary job which exists in the link group map
                if (_primaryJob                                 &&
                    mapRecId2LinkGroup.exists(_primaryJob.RecId))
                {
                    this.addRecId2LinkGroup(_currentJob.RecId, mapRecId2LinkGroup.lookup(_primaryJob.RecId));
                }
            }

            if (conRecords != connull())
            {
                setRecords = Set::create(conRecords);

                // if the link type is not enforcing start or end then make sure that the next jobs get the same group id
                if (jobTmp.Link != SchedJobLink::SS &&
                    jobTmp.Link != SchedJobLink::FF)
                {
                    nextJobsLinkGroup   = getLinkGroup(setRecords);
                    if (!nextJobsLinkGroup)
                    {
                        // if none of the jobs already has a link group id, take a new one
                        nextJobsLinkGroup = linkGroupNo;
                        linkGroupNo ++;
                    }
                }

                // create all links to the next jobs
                setEnumerator = setRecords.getEnumerator();
                while (setEnumerator && setEnumerator.moveNext())
                {
                    nextJob = setEnumerator.current();
                    if (nextJob.RecId)
                    {
                        ganttTableLink.cleanTableBuffer();

                        // Update the link group number on the nextJob
                        if (nextJob.IsDisplayed)
                        {
                            //
                            // Check if the link is a SS or and FF link.
                            // Also check that the previous job does exist in the Rec to link group id map
                            // (it could be that it is not in the map because it is not displayed)
                            //
                            if ((jobTmp.Link == SchedJobLink::SS ||
                                jobTmp.Link == SchedJobLink::FF) &&
                                mapRecId2LinkGroup.exists(_currentJob.RecId))
                            {
                                this.addRecId2LinkGroup(nextJob.RecId, mapRecId2LinkGroup.lookup(_currentJob.RecId));
                            }
                            else
                            {
                                this.addRecId2LinkGroup(nextJob.RecId, nextJobsLinkGroup);
                            }
                        }

                        // take the link type from the primary job always
                        ganttLinkType = GanttTmpLink::schedJobLink2GanttLinkType(jobTmp.Link);

                        boolean isDisplayed = _currentJob.IsDisplayed && nextJob.IsDisplayed;
                        ganttTableLink.setLinkData(_currentJob.RecId,
                                                    nextJob.RecId,
                                                    isDisplayed,
                                                    NoYes::No,
                                                    ganttLinkType);

                        GanttTmpLink duplicateLink = ganttTableLink.findDuplicate();
                        if (!duplicateLink)
                        {
                            ganttTableLink.insert();
                        }
                        else
                        {
                            if (isDisplayed && duplicateLink.Visible == NoYes::No)
                            {
                                ganttTableLink.updateField(duplicateLink.RecId, fieldstr(GanttTmpLink, Visible), NoYes::Yes);
                            }
                        }

                    }
                }
            }
        }

        // fetch all data and stuff it into allJobs so that we can use it for looking up jobs
        currentJob = ganttTableWrkCtrJob.findFirst();

        while (currentJob.RecId)
        {
            allJobs.clear();
            allJobs.data(currentJob);
            allJobs.doInsert();

            currentJob = ganttTableWrkCtrJob.findNext();
        }

        currentJob.setTmpData(allJobs);
        nextJob.setTmpData(allJobs);

        // iterate through every job (node)
        while select currentJob
        {
            // Get the primary last workcenter job for the current job
            // For the multiple workcenters case it will get the last workcenter node,
            // since the last workcenter node actually contains the link to the next job/operation
            primaryJob = GanttTmpWrkCtrJob::find(allJobs, currentJob.RefId, currentJob.ReqPlanId, currentJob.ProjLineNum, currentJob.OprNum, currentJob.NumType, RouteOprPriority::Primary, true);

            // add links cloned from the primary job so that the secondary jobs
            // have the same successors like the primary
            loadLinksByRecIds(currentJob, primaryJob);

            // calling loadLinksByRecIds again without the primaryJob parameter is done to create StartStart links between the
            // currentJob and parallel jobs when having multiple workcenters
            if (currentJob.OprPriority == RouteOprPriority::Primary)
            {
                loadLinksByRecIds(currentJob);
            }            
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadDataPlannedProd</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads all the planned production orders that are to be used in the Gantt chart.
    /// </summary>
    /// <remarks>
    ///    All jobs that satisfy the given time interval and workcenter are loaded, regardless that they are
    ///    displayed or not in the control.
    /// </remarks>
    protected void loadDataPlannedProd()
    {
        this.loadDataPlannedProdWrkCtrIdSet(setLoadWrkCtrIds);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadDataPlannedProdWrkCtrIdSet</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads all the planned production orders that are to be used in the Gantt chart.
    /// </summary>
    /// <param name="_wrkCtrIds">
    ///    The set of resource Ids to load.
    /// </param>
    /// <remarks>
    ///    All jobs that satisfy the given time interval and workcenter are loaded, regardless that they are
    ///    displayed or not in the control.
    /// </remarks>
    private void loadDataPlannedProdWrkCtrIdSet(Set _wrkCtrIds)
    {
        SetEnumerator       setEnumerator;

        ReqRouteJob         reqRouteJob;
        ReqRoute            reqRoute;
        ReqPO               reqPO;
        WrkCtrTable         wrkCtrTable;
        WrkCtrResourceGroup wrkCtrResourceGroup;
        Set                 setDataPlannedProd;

        GanttSetup_WrkCtr localGanttSetup = this.parmGanttClient().parmGanttSetup() as GanttSetup_WrkCtr;
        ReqPlanId         reqPlanId       = localGanttSetup.parmReqPlanIdPlannedProd();

        hasPlannedProdJobs = false;

        if (!this.canLoadPlannedProdData())
        {
            return;
        }

        setDataPlannedProd = Set::create(GanttData_WrkCtr::loadDataPlannedProdOnServer(_wrkCtrIds.pack(),
                                                                                       this.parmLoadingFromDate(),
                                                                                       this.parmLoadingToDate(),
                                                                                       reqPlanId,
                                                                                       (loadOnlySpecific ? this.conSetLoadIds() : conNull())));

        boolean allowEdit = GanttTable_WrkCtrJob::allowEditPlannedProd(false);
        
        Map mapProdMaterialAvailability = new Map(Types::String, Types::Class);
        
        // iterate through the planned production order jobs received from the server
        setEnumerator = setDataPlannedProd.getEnumerator();
        while (setEnumerator && setEnumerator.moveNext())
        {
            [reqRouteJob, reqRoute, reqPO, wrkCtrTable, wrkCtrResourceGroup] = setEnumerator.current();

            Map mapOperationMaterialAvailability;
            if (!mapProdMaterialAvailability.exists(reqPO.RefId))
            {
                mapOperationMaterialAvailability = this.loadMaterialAvailbilityPlannedProd(reqPO);
                mapProdMaterialAvailability.insert(reqPO.RefId, mapOperationMaterialAvailability);
            }
            else
            {
                mapOperationMaterialAvailability = mapProdMaterialAvailability.lookup(reqPO.RefId);
            }
                        
            utcdatetime materialAvailabilityDateTime;
            if (mapOperationMaterialAvailability.exists(reqRoute.OprNum))
            {
                materialAvailabilityDateTime = mapOperationMaterialAvailability.lookup(reqRoute.OprNum);
            }
            
            this.insertDataPlannedProd(reqRouteJob,
                                       reqRoute,
                                       reqPO,
                                       wrkCtrTable,
                                       setLoadWrkCtrIds.in(reqRouteJob.WrkCtrId)  &&
                                       this.canLoadReqRouteJob(reqRouteJob, reqRoute, null, null, reqPO, this.parmLoadingFromDate(), this.parmLoadingToDate()),
                                       wrkCtrResourceGroup,
                                       allowEdit,
                                       materialAvailabilityDateTime
                                       );
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadDataProd</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads the production orders that are to be used in the Gantt chart.
    /// </summary>
    /// <remarks>
    ///    All jobs that satisfy the given time interval and work center are loaded, regardless whether they
    ///    are displayed or not in the control.
    /// </remarks>
    protected void loadDataProd()
    {
        this.loadDataProdWrkCtrIdSet(setLoadWrkCtrIds);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadDataProdWrkCtrIdSet</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads the production orders that are to be used in the Gantt chart for a set of resources.
    /// </summary>
    /// <param name="_wrkCtrIds">
    ///    The set of resource Ids to load.
    /// </param>
    /// <remarks>
    ///    All jobs that satisfy the given time interval and work center are loaded, regardless whether they
    ///    are displayed or not in the control.
    /// </remarks>
    private void loadDataProdWrkCtrIdSet(Set _wrkCtrIds)
    {
        SetEnumerator       setEnumerator;

        ProdRouteJob        prodRouteJob;
        ProdRoute           prodRoute;
        ProdTable           prodTable;
        WrkCtrTable         wrkCtrTable;
        WrkCtrResourceGroup wrkCtrResourceGroup;
        Set                 setDataProd;
                
        hasProdJobs = false;

        if (!this.canLoadProdData())
        {
            return;
        }

        boolean allowEdit = GanttTable_WrkCtrJob::allowEditProd(false);

        setDataProd = Set::create(GanttData_WrkCtr::loadDataProdOnServer(_wrkCtrIds.pack(),
                                                                         this.parmLoadingFromDate(),
                                                                         this.parmLoadingToDate(),
                                                                         (loadOnlySpecific ? this.conSetLoadIds() : conNull())));

        Map mapProdMaterialAvailability = new Map(Types::String, Types::Class);
        GanttSetup_WrkCtr ganttSetup = this.parmGanttClient().parmGanttSetup() as GanttSetup_WrkCtr;

        // iterate through the production order jobs received from the server
        setEnumerator = setDataProd.getEnumerator();
        while (setEnumerator && setEnumerator.moveNext())
        {
            [prodRouteJob, prodRoute, prodTable, wrkCtrTable, wrkCtrResourceGroup] = setEnumerator.current();
                        
            Map mapOperationMaterialAvailability;
            if (!mapProdMaterialAvailability.exists(ProdTable.ProdId))
            {
                mapOperationMaterialAvailability = this.loadMaterialAvailbilityProd(prodTable);
                mapProdMaterialAvailability.insert(ProdTable.ProdId, mapOperationMaterialAvailability);
            }
            else
            {
                mapOperationMaterialAvailability = mapProdMaterialAvailability.lookup(ProdTable.ProdId);
            }    
                        
            utcdatetime materialAvailabilityDateTime;
            if (mapOperationMaterialAvailability.exists(ProdRoute.OprNum))
            {
                materialAvailabilityDateTime = mapOperationMaterialAvailability.lookup(ProdRoute.OprNum);
            }
            

            this.insertDataProd(prodRouteJob,
                                prodRoute,
                                prodTable,
                                wrkCtrTable,
                                setLoadWrkCtrIds.in(prodRouteJob.WrkCtrId)  &&
                                this.canLoadProdRouteJob(prodRouteJob, prodRoute, null, prodTable, this.parmLoadingFromDate(), this.parmLoadingToDate()),
                                wrkCtrResourceGroup,
                                allowEdit,
                                materialAvailabilityDateTime
                                );
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadDataProj</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads the project hour forecast data that is to be used in the Gantt chart.
    /// </summary>
    /// <remarks>
    ///    All jobs that satisfy the given time interval and workcenter are loaded, regardless that they are
    ///    displayed or not in the control.
    /// </remarks>
    protected void loadDataProj()
    {
        this.loadDataProjWrkCtrIdSet(setLoadWrkCtrIds);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadDataProjWrkCtrIdSet</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads the project hour forecast data that is to be used in the Gantt chart.
    /// </summary>
    /// <param name="_wrkCtrIds">The set of resource Ids to load.</param>
    /// <remarks>
    ///    All jobs that satisfy the given time interval and workcenter are loaded, regardless that they are
    ///    displayed or not in the control.
    /// </remarks>
    private void loadDataProjWrkCtrIdSet(Set _wrkCtrIds)
    {
        SetEnumerator       setEnumerator;

        ProjForecastEmpl    projForecastEmpl;
        ProjTable           projTable;
        WrkCtrTable         wrkCtrTable;
        WrkCtrResourceGroup wrkCtrResourceGroup;
        smmActivities       smmActivities;
        Set                 setDataProj;

        hasProjJobs = false;

        if (!this.canLoadProjData())
        {
            return;
        }

        setDataProj = Set::create(GanttData_WrkCtr::loadDataProjOnServer(_wrkCtrIds.pack(),
                                                                         this.parmLoadingFromDate(),
                                                                         this.parmLoadingToDate(),
                                                                         (loadOnlySpecific ? this.conSetLoadIds() : conNull())));

        boolean allowEdit = GanttTable_WrkCtrJob::allowEditProj(false);

        // iterate through the project jobs received from the server
        setEnumerator = setDataProj.getEnumerator();
        while (setEnumerator && setEnumerator.moveNext())
        {
            [projForecastEmpl, projTable, smmActivities, wrkCtrTable, wrkCtrResourceGroup] = setEnumerator.current();
            this.insertDataProj(projForecastEmpl,
                                projTable,
                                smmActivities,
                                wrkCtrTable,
                                setLoadWrkCtrIds.in(projForecastEmpl.SchedWrkCtrId)  &&
                                this.canLoadProjForecastEmpl(projForecastEmpl, false, this.parmLoadingFromDate(), this.parmLoadingToDate()),
                                wrkCtrResourceGroup,
                                allowEdit
                                );
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifyModificationBeforeValidation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds values for the site, production unit, resource group, and calendar fields to the modification.
    /// </summary>
    /// <param name="_ganttDataModification">
    ///    The modification class to which to add values.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    No calendar ID could be resolved.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    ///    No resource group was found.
    /// </exception>
    public void modifyModificationBeforeValidation(GanttDataModification _ganttDataModification)
    {
        Map                 mapModifiedFields;

        ProdUnitId          prodUnitId;
        GanttCalendarId     calendarId;

        WrkCtrId            wrkCtrId;
        WrkCtrResourceGroup wrkCtrResourceGroup;
        str                 emptyGroupName = GanttView::emptyGroupName();
        date                fromDate;
        date                toDate;

        if (_ganttDataModification                                      == null ||
           _ganttDataModification.parmMapModifiedFields()               == null ||
           _ganttDataModification.parmMapModifiedFields().elements()    == 0)
        {
            return;
        }

        this.parmGanttTableWrkCtrJob().findRecId(_ganttDataModification.parmModifiedRecId(), true);
        GanttTmpWrkCtrJob  localGanttTableWrkCtrJob = this.parmGanttTableWrkCtrJob().parmTableBuffer() as GanttTmpWrkCtrJob;

        mapModifiedFields = _ganttDataModification.parmMapModifiedFields();
        if (mapModifiedFields.exists(fieldstr(GanttTmpWrkCtrJob, WrkCtrId)))
        {
            wrkCtrId = mapModifiedFields.lookup(fieldstr(GanttTmpWrkCtrJob, WrkCtrId));
        }
        else
        {
            wrkCtrId = localGanttTableWrkCtrJob.WrkCtrId;
        }

        if (mapModifiedFields.exists(fieldstr(GanttTmpWrkCtrJob, SchedFromDate)))
        {
            fromDate = str2date(mapModifiedFields.lookup(fieldstr(GanttTmpWrkCtrJob, SchedFromDate)),GanttTableField::date2StrSequence());
        }
        else
        {
            fromDate = localGanttTableWrkCtrJob.SchedFromDate;
        }

        if (mapModifiedFields.exists(fieldstr(GanttTmpWrkCtrJob, SchedToDate)))
        {
            toDate = str2date(mapModifiedFields.lookup(fieldstr(GanttTmpWrkCtrJob, SchedToDate)),GanttTableField::date2StrSequence());
        }
        else
        {
            toDate = localGanttTableWrkCtrJob.SchedToDate;
        }

        // Refresh the resource group dependent information since this can change over time
        wrkCtrResourceGroup = WrkCtrTable::resourceGroup(wrkCtrId,
                                                         fromDate,
                                                         toDate);
        if (!wrkCtrResourceGroup.RecId)
        {
            throw error(strfmt(WrkCtrTable::txtNotExist(), wrkCtrId));
        }

        if (wrkCtrId != localGanttTableWrkCtrJob.WrkCtrId ||
            wrkCtrResourceGroup.WrkCtrId != localGanttTableWrkCtrJob.WrkCtrGroupId)
        {
            prodUnitId      = wrkCtrResourceGroup.ProdUnitId    ? wrkCtrResourceGroup.ProdUnitId    : emptyGroupName;

            calendarId      = this.parmGanttTableWrkCtrJob().getCalendarName(wrkCtrId);
            if (!calendarId)
            {
                throw error("@SYS25956");
            }

            // insert resource group
            _ganttDataModification.insertExtraModifiedField(fieldstr(GanttTmpWrkCtrJob, WrkCtrGroupId),
                                                            wrkCtrResourceGroup.WrkCtrId,
                                                            false); // do not insert if exists
            // insert production unit
            _ganttDataModification.insertExtraModifiedField(fieldstr(GanttTmpWrkCtrJob, ProdUnitId),
                                                            prodUnitId,
                                                            false); // do not insert if exists
            // insert site
            _ganttDataModification.insertExtraModifiedField(fieldstr(GanttTmpWrkCtrJob, InventSiteId),
                                                            wrkCtrResourceGroup.SiteId,
                                                            false); // do not insert if exists
            // insert calendarId
            _ganttDataModification.insertExtraModifiedField(fieldstr(GanttTmpWrkCtrJob, CalendarId),
                                                            calendarId,
                                                            false); // do not insert if exists
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();

        mapProdTables           = new Map(Types::String,Types::Record);
        mapReqPOs               = new Map(Types::String,Types::Record);

        setLoadWrkCtrIds        = new Set(Types::String);
        setModifiedRefIds       = new Set(Types::String);
        setEmptyWrkCtrIds       = new Set(Types::Class);

        this.resetLinkGroups ();

        reqPlanIdDefaultDynamic = ReqPlanSched::defaultDynamicId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmGanttClient</Name>
				<Source><![CDATA[
    public GanttClient parmGanttClient(GanttClient _ganttClient = ganttClient)
    {
        return super(_ganttClient);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmGanttTableLink</Name>
				<Source><![CDATA[
    public GanttTable_Link parmGanttTableLink(GanttTable_Link _ganttTableLink = ganttTableLink)
    {
        ganttTableLink = _ganttTableLink;
        return ganttTableLink;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmGanttTableWrkCtrJob</Name>
				<Source><![CDATA[
    public GanttTable_WrkCtrJob parmGanttTableWrkCtrJob(GanttTable_WrkCtrJob _ganttTableWrkCtrJob = ganttTableWrkCtrJob)
    {
        ganttTableWrkCtrJob = _ganttTableWrkCtrJob;
        return ganttTableWrkCtrJob;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHasPlannedProdJobs</Name>
				<Source><![CDATA[
    public boolean parmHasPlannedProdJobs(boolean _hasPlannedProdJobs = hasPlannedProdJobs)
    {
        hasPlannedProdJobs = _hasPlannedProdJobs;
        return hasPlannedProdJobs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHasProdJobs</Name>
				<Source><![CDATA[
    public boolean parmHasProdJobs(boolean _hasProdJobs = hasProdJobs)
    {
        hasProdJobs = _hasProdJobs;
        return hasProdJobs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHasProjJobs</Name>
				<Source><![CDATA[
    public boolean parmHasProjJobs(boolean _hasProjJobs = hasProjJobs)
    {
        hasProjJobs = _hasProjJobs;
        return hasProjJobs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetEmptyWrkCtrIds</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Resets the internally stored data regarding work centers that do not have any jobs displayed in
    ///    Gantt.
    /// </summary>
    protected void resetEmptyWrkCtrIds()
    {
        setEmptyWrkCtrIds   = new Set(Types::Class);
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetLinkGroups</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears all the data that was used for mapping link group numbers to records and for records to
    ///    group numbers.
    /// </summary>
    /// <remarks>
    ///    This method is invoked when the data is initialized or reloaded.
    /// </remarks>
    protected void resetLinkGroups()
    {
        mapLinkGroups2RecIds    = new Map(Types::Int64, Types::Class);
        mapRecId2LinkGroup      = new Map(Types::Int64, Types::Int64);
        linkGroupNo = 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetLoadingData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Resets the relevant data when a reload occurs.
    /// </summary>
    protected void resetLoadingData()
    {
        super();

        this.resetLoadWrkCtrIds();

        this.resetLinkGroups();

        this.resetMaterials();
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetMaterials</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears the material information.
    /// </summary>
    protected void resetMaterials()
    {
        ttsbegin;
        delete_from ganttTmpMaterials;
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetLoadWrkCtrIds</Name>
				<Source><![CDATA[
    protected void resetLoadWrkCtrIds()
    {
        setLoadWrkCtrIds = new Set(Types::String);
        tmpWrkCtrIdLoaded = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Saves or validates the data modified by the user in the Gantt chart.
    /// </summary>
    /// <param name="_onlyValidate">
    ///    A Boolean indicating whether to perform only a validation, true, or to also save the data, false;
    ///    optional.
    /// </param>
    /// <param name="_skipValidation">
    ///    A Boolean value set to true to skip the validation, or false if validation is to be performed;
    ///    optional.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    An exception is thrown if one of the records in the database was modified by another user.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    ///    An exception is thrown if invalid data is detected in the gantt chart data to be saved.
    /// </exception>
    protected void saveData(boolean _onlyValidate   = false,
                            boolean _skipValidation = true)
    {
        Set                     setRecIdsToBeSaved = new Set(Types::Int64);
        Set                     setModifiedRefRecIds = new Set(Types::Int64);
        SetEnumerator           setEnumerator;
        GanttTmpWrkCtrJob       gantTmpWrkCtrJob;
        super();

        if (_onlyValidate)
        {
            this.progressInitValidating();
        }
        else
        {
            this.progressInitSaving();
        }

        setRecIdsToBeSaved  = Set::union(setRecIdsToBeSaved, ganttTableWrkCtrJob.parmSetUserModifiedRecIds());

        if (!_skipValidation)
        {
            setModifiedRefRecIds = this.createModifiedRefIdSet(setRecIdsToBeSaved);
        }

        setEnumerator       = setRecIdsToBeSaved.getEnumerator();

        this.progressTotal(setRecIdsToBeSaved.elements());

        // load in one server call all the data needed by the validation procedure later
        this.parmGanttTableWrkCtrJob().loadAllValidationRecords();

        while (setEnumerator && setEnumerator.moveNext())
        {
            ganttTableWrkCtrJob.findRecId(setEnumerator.current(), true);

            if (GanttControlSchedulerTimeZoneFlight::instance().isEnabled())
            {
                capacityReservations = new List(Types::Class);
                Map capacityReservationMap = this.parmGanttClient().parmGanttData().parmCapacityReservationsByActivityId();

                if (capacityReservationMap.exists(setEnumerator.current()))
                {
                    capacityReservations = capacityReservationMap.lookup(setEnumerator.current());
                }
            }

            gantTmpWrkCtrJob = ganttTableWrkCtrJob.parmTableBuffer();

            // update modified data
            if (ganttTableWrkCtrJob.parmSetUserModifiedRecIds().in(gantTmpWrkCtrJob.RecId))
            {
                if (!_skipValidation)
                {
                    // check if we should validate the sequence
                    if (setModifiedRefRecIds.in(gantTmpWrkCtrJob.RecId))
                    {
                        if (!this.validateRefId(gantTmpWrkCtrJob.RefType, gantTmpWrkCtrJob.RefId))
                        {
                            throw Exception::Error;
                        }
                    }

                    if (!ganttTableWrkCtrJob.validateWrite())
                    {
                        throw Exception::Error;
                    }
                }

                switch (gantTmpWrkCtrJob.RefType)
                {
                    case WrkCtrCapRefType::Production   :

                        GanttData_WrkCtr::updateOrigDataProd(gantTmpWrkCtrJob,          _onlyValidate);
                        break;

                    case WrkCtrCapRefType::PlannedOrder :

                        GanttData_WrkCtr::updateOrigDataPlannedProd(gantTmpWrkCtrJob,   _onlyValidate);
                        break;

                    case WrkCtrCapRefType::Project      :

                        GanttData_WrkCtr::updateOrigDataProj(gantTmpWrkCtrJob,          _onlyValidate);
                        break;

                    default:
                        throw error("@SYS6144");
                }
            }

            this.progressUpdate();
        }

        // clear the data that was used for validation (data that was loaded in one server call)
        this.parmGanttTableWrkCtrJob().clearAllValidationRecords();

        this.progressFinish();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCallerDates</Name>
				<Source><![CDATA[
    protected void setCallerDates()
    {
        callerFromDate  = this.parmLoadingFromDate();
        callerToDate    = this.parmLoadingToDate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>sortNodeData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sorts the node data and creates the sort order data for workcenter groups if <c>Gantt</c> was
    ///    started from the production orders form, planned production orders form, or project hour forecast
    ///    form.
    /// </summary>
    protected void sortNodeData()
    {
        GanttCallerWrkCtr   ganttCallerWrkCtr;
        GanttClient_WrkCtr  localGanttClient = this.parmGanttClient() as GanttClient_WrkCtr;
        if (this.parmGanttClient() == null)
        {
            throw error(strfmt("@SYS27147", classId2Name(classidget(this))));
        }
        ganttCallerWrkCtr = localGanttClient.parmGanttCaller();

        this.parmGanttTableWrkCtrJob().sortGanttWrkCtrJobData();

        if (ganttCallerWrkCtr == GanttCallerWrkCtr::Prod ||
            ganttCallerWrkCtr == GanttCallerWrkCtr::PlannedProd ||
            ganttCallerWrkCtr == GanttCallerWrkCtr::Proj)
        {
            this.parmGanttTableWrkCtrJob().createWrkCtrSortOrder();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateIsRefModified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates an order with regard to whether one of the job records has been modified.
    /// </summary>
    /// <param name="_wrkCtrCapRefType">
    ///    A <see cref="T:WrkCtrCapRefType" /> value indicating the order type such as production order,
    ///    planned production order, and project hour forecast.
    /// </param>
    /// <param name="_wrkCtrRefId">
    ///    A <see cref="T:WrkCtrRefId" /> specifying the order ID.
    /// </param>
    /// <returns>
    ///    true if no record has been modified; otherwise, false.
    /// </returns>
    public boolean validateIsRefModified(WrkCtrCapRefType _wrkCtrCapRefType, WrkCtrRefId _wrkCtrRefId)
    {
        boolean validateProdIsModified()
        {
            ProdRouteJob prodRouteJob;

            while select RecId, RecVersion, TableId from prodRouteJob
                where prodRouteJob.ProdId == _wrkCtrRefId
            {
                if (this.parmGanttTableWrkCtrJob().recVersionForOrigRecId(prodRouteJob.RecId) != prodRouteJob.RecVersion)
                {
                    return checkFailed(strfmt("@SYS113557", tableid2name(prodRouteJob.TableId)));
                }
            }

            return true;
        }

        boolean validatePlannedProdIsModified()
        {
            ReqRouteJob         reqRouteJob;
            GanttClient_WrkCtr  localGanttClient = this.parmGanttClient() as GanttClient_WrkCtr;
            ReqPlanVersion      reqPlanVersion =
                                                 ReqPlan::findReqPlanId(localGanttClient.parmReqPlanIdPlannedProd()).findActiveVersion();

            while select RecId, RecVersion, TableId from reqRouteJob
                where   reqRouteJob.ReqPOId                  == _wrkCtrRefId    &&
                        reqRouteJob.PlanVersion              == reqPlanVersion.RecId
            {
                if (this.parmGanttTableWrkCtrJob().recVersionForOrigRecId(reqRouteJob.RecId) != reqRouteJob.RecVersion)
                {
                    return checkFailed(strfmt("@SYS113557", tableid2name(reqRouteJob.TableId)));
                }
            }

            return true;
        }

        boolean validateProjIsModified()
        {
            ProjForecastEmpl projForecastEmpl;

            while select RecId, RecVersion, TableId from projForecastEmpl
                where projForecastEmpl.ProjId == _wrkCtrRefId
            {
                if (this.parmGanttTableWrkCtrJob().recVersionForOrigRecId(projForecastEmpl.RecId) != projForecastEmpl.RecVersion)
                {
                    return checkFailed(strfmt("@SYS113557", tableid2name(projForecastEmpl.TableId)));
                }
            }

            return true;
        }

        switch (_wrkCtrCapRefType)
        {
            case WrkCtrCapRefType::Production:
                return validateProdIsModified();

            case WrkCtrCapRefType::PlannedOrder:
                return validatePlannedProdIsModified();

            case WrkCtrCapRefType::Project:
                return validateProjIsModified();

            default:
                return checkFailed(strfmt("@SYS26908", _wrkCtrCapRefType));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLoad</Name>
				<Source><![CDATA[
    public boolean validateLoad()
    {
        boolean ret;

        ret = super();

        if (ret)
        {
            if (!ganttTableWrkCtrJob || !ganttTableLink)
            {
                return checkFailed(strfmt("@SYS27147", classId2Name(classidget(this))));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateModification</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates one modification that the user performed in the Gantt chart data.
    /// </summary>
    /// <param name="_ganttDataModification">
    ///    The <c>GanttDataModification</c> object that contains the modified fields and additional
    ///    modification information.
    /// </param>
    /// <param name="_modifyModificationBeforeValidation">
    ///    A Boolean value that indicates whether the <c>modifyModificationBeforeValidation</c> hook method
    ///    should be called to allow additional information to the modification before validating; optional.
    /// </param>
    /// <returns>
    ///    true if the validation of the modification was successful; otherwise, false.
    /// </returns>
    public boolean validateModification(GanttDataModification _ganttDataModification, boolean _modifyModificationBeforeValidation = false)
    {
        boolean ret;

        if (!this.parmGanttClient().parmGanttSetup().parmLoadCalendar())
        {
            return checkFailed("@SYS109250");
        }

        if (loadOnlySpecific)
        {
            return checkFailed("@SYP4881580");
        }

        ret = super(_ganttDataModification);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateRefId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the data for one order based on a reference ID, with regard to a job sequence and that
    ///    all jobs in one operation have the same work center.
    /// </summary>
    /// <param name="_wrkCtrCapRefType">
    ///    A <c>WrkCtrCapRefType</c> enum value indicating the type of order we are validating (production
    ///    order or planned production order or project data).
    /// </param>
    /// <param name="_wrkCtrRefId">
    ///    The reference ID identifying the project or planned production order to validate.
    /// </param>
    /// <returns>
    ///    true if the validation of sequence passes; otherwise, false.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    An exception is thrown if the <see cref="T:GanttData" /> parameter is invalid.
    /// </exception>
    protected boolean validateRefId(WrkCtrCapRefType _wrkCtrCapRefType, WrkCtrRefId _wrkCtrRefId)
    {
        boolean                 ret = true;
        GanttTmpWrkCtrJob       ganttTmpWrkCtrJob;
        GanttTmpWrkCtrJob       nextJob;
        RouteJobMap             nextJobMap;
        RouteJobMap             currentJobMap;
        ProdJobType             prodJobType;
        Map                     mapRoute = new Map(Types::Int64, Types::Container);
        GanttTmpWrkCtrJob       saveGanttTmpWrkCtrJob;

        // this function updates the map that contains the cached operation information
        void updateMapRoute(GanttTmpWrkCtrJob _jobData)
        {
            container con;
            #define.SchedToDateIndex(1)
            #define.SchedToTimeIndex(2)
            #define.HasOverlapIndex(3)

            if (!mapRoute.exists(_jobData.OprNum))
            {
                con = [_jobData.SchedToDate,
                       _jobData.SchedToTime,
                       (_jobData.JobType == RouteJobType::Overlap) ? true : false,
                       _jobData.OprNumNext];
            }
            else
            {
                con = mapRoute.lookup(_jobData.OprNum);

                if (_jobData.SchedToDate   >   conpeek(con, #SchedToDateIndex) ||
                    (_jobData.SchedToDate  ==  conpeek(con, #SchedToDateIndex) &&
                     _jobData.SchedToTime  >   conpeek(con, #SchedToTimeIndex)))
                {
                    con = conpoke(con, #SchedToDateIndex, _jobData.SchedToDate);
                    con = conpoke(con, #SchedToTimeIndex, _jobData.SchedToTime);
                }

                con = conpoke(con, #HasOverlapIndex, conpeek(con, #HasOverlapIndex) || (_jobData.JobType == RouteJobType::Overlap));
            }

            mapRoute.insert(_jobData.OprNum, con);
        }

        // this function validates the sequence correctness for all the jobs in an order
        boolean validateSequence()
        {
            container identifierFields = this.getIdentifierFields(_wrkCtrCapRefType);
            // save the current table buffer used by ganttTableWrkCtrJob
            ganttTmpWrkCtrJob.setTmpData(ganttTableWrkCtrJob.parmTableBuffer());
            nextJob.setTmpData(ganttTableWrkCtrJob.parmTableBuffer());

            // iterate through all jobs in order to validate the sequence
            while select ganttTmpWrkCtrJob
                where ganttTmpWrkCtrJob.RefType  == _wrkCtrCapRefType    &&
                      ganttTmpWrkCtrJob.RefId    == _wrkCtrRefId
            {
                // update the route map
                ganttTableWrkCtrJob.findRecId(ganttTmpWrkCtrJob.RecId);
                updateMapRoute(ganttTableWrkCtrJob.parmTableBuffer());

                // check if we have a primary or secondary job
                if (ganttTmpWrkCtrJob.OprPriority == RouteOprPriority::Primary)
                {
                    currentJobMap.data(ganttTableWrkCtrJob.parmTableBuffer());

                    // primary job, get the next job
                    nextJob = GanttTmpWrkCtrJob::findNextJob(ganttTmpWrkCtrJob);
                    ganttTableWrkCtrJob.findRecId(nextJob.RecId);
                    nextJobMap.data(ganttTableWrkCtrJob.parmTableBuffer());

                    // validate sequence for this record
                    prodJobType = ProdJobType::construct(currentJobMap.JobType);
                    if (!prodJobType)
                    {
                        return false;
                    }
                    else
                    {
                        if (!prodJobType.checkJobSequence(currentJobMap, null, nextJobMap, identifierFields))
                        {
                            return false;
                        }
                    }

                    // check that we have the same workcenter and that the group do not change
                    if (!this.validateSameWrkCtr(_wrkCtrCapRefType, currentJobMap, nextJobMap, ganttTmpWrkCtrJob, nextJob, identifierFields))
                    {
                        return false;
                    }
                }
                else
                {
                    // secondary operation/job, check that we have the same start date like the primary one
                    nextJobMap.data(ganttTableWrkCtrJob.parmTableBuffer());

                    ganttTableWrkCtrJob.findRecId(GanttTmpWrkCtrJob::findPrimaryJob(ganttTmpWrkCtrJob).RecId);
                    currentJobMap.data(ganttTableWrkCtrJob.parmTableBuffer());

                    // validate sequence for this record
                    prodJobType = ProdJobType::construct(currentJobMap.JobType);
                    if (!prodJobType)
                    {
                        return false;
                    }
                    else
                    {
                        if (!prodJobType.checkJobSequence(currentJobMap, null, nextJobMap, identifierFields, SchedJobLink::SS))
                        {
                            return false;
                        }
                    }
                }
            }

            return true;
        }

        // this function validates the overlap correctness for all operations in the order being validated
        boolean validateOverlap()
        {
            MapEnumerator   mapEnumerator;
            container       con;
            date            nextToDate;
            timeOfDay       nextToTime;
            boolean         nextHasOverlap;
            OprNum          nextNextOprNum;
            date            currentToDate;
            timeOfDay       currentToTime;
            boolean         currentHasOverlap;
            OprNum          currentNextOprNum;

            // iterate through all operations in order to check overlap
            mapEnumerator = mapRoute.getEnumerator();
            while (mapEnumerator && mapEnumerator.moveNext())
            {
                con = mapEnumerator.currentValue();

                // get data for the
                [currentToDate, currentToTime, currentHasOverlap, currentNextOprNum] = con;

                if (currentNextOprNum               &&
                    mapRoute.exists(currentNextOprNum))
                {
                    // get next operation
                    [nextToDate, nextToTime, nextHasOverlap, nextNextOprNum] = mapRoute.lookup(currentNextOprNum);

                    if (currentHasOverlap)
                    {
                        if (nextToDate      <   currentToDate ||
                            (nextToDate     ==  currentToDate &&
                             nextToTime     <   currentToTime))
                        {
                            return checkFailed(strfmt("@SYS66093", mapEnumerator.currentKey(), currentNextOprNum));
                        }
                    }
                }
            }

            return true;
        }

        saveGanttTmpWrkCtrJob.data(ganttTableWrkCtrJob.parmTableBuffer());

        ret = this.validateIsRefModified(_wrkCtrCapRefType, _wrkCtrRefId);

        if (ret)
        {
            ret = validateSequence();
        }

        if (ret)
        {
            ret = validateOverlap();
        }

        ganttTableWrkCtrJob.parmTableBuffer().data(saveGanttTmpWrkCtrJob);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSameWrkCtr</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that two jobs are on the same work center and that the group does not change if they
    ///    belong to the same operation.
    /// </summary>
    /// <param name="_refType">
    ///    The <c>WrkCtrCapRefType</c> field that indicates the type of order displayed.
    /// </param>
    /// <param name="_prevJob">
    ///    A <c>RouteJobMap</c> table that contains the data for the first job.
    /// </param>
    /// <param name="_currentJob">
    ///    A <c>RouteJobMap</c> table that contains the data for the second job.
    /// </param>
    /// <param name="_prevGanttTmpWrkCtrJob">
    ///    A <c>GanttTmpWrkCtrJob</c> record that contains the data for the first job.
    /// </param>
    /// <param name="_currentGanttTmpWrkCtrJob">
    ///    A <c>GanttTmpWrkCtrJob</c> record that contains the data for the second job.
    /// </param>
    /// <param name="_identifierFieldIds">
    ///    A container with the field IDs to be used in building the identifier of a job.
    /// </param>
    /// <returns>
    ///    true if validation passes; otherwise, false.
    /// </returns>
    protected boolean validateSameWrkCtr(WrkCtrCapRefType   _refType,
                                         RouteJobMap        _prevJob,
                                         RouteJobMap        _currentJob,
                                         GanttTmpWrkCtrJob  _prevGanttTmpWrkCtrJob,
                                         GanttTmpWrkCtrJob  _currentGanttTmpWrkCtrJob,
                                         container          _identifierFieldIds)
    {
        if ((_refType                == WrkCtrCapRefType::Production        ||
             _refType                == WrkCtrCapRefType::PlannedOrder)     &&
            _prevJob.RefId          == _currentJob.RefId                    &&
            _prevJob.OprNum         == _currentJob.OprNum                   &&
            _prevJob.OprPriority    == _currentJob.OprPriority              &&
            _prevJob.NumPrimary     == _currentJob.NumPrimary               &&
            _prevJob.NumSecondary   == _currentJob.NumSecondary)
        {
            if (_prevJob.WrkCtrId != _currentJob.WrkCtrId)
            {
                return checkFailed(strfmt("@SYS119351",
                                          _prevJob.composeJobDescriptionText(_identifierFieldIds),
                                          _currentJob.composeJobDescriptionText(_identifierFieldIds)));
            }

            if (_prevGanttTmpWrkCtrJob.WrkCtrGroupId != _currentGanttTmpWrkCtrJob.WrkCtrGroupId)
            {
                return checkFailed(strfmt("@SYS312190",
                                          _prevJob.composeJobDescriptionText(_identifierFieldIds),
                                          _currentJob.composeJobDescriptionText(_identifierFieldIds)));
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static GanttData_WrkCtr construct()
    {
        return new GanttData_WrkCtr();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJobCapacityReservations</Name>
				<Source><![CDATA[
    protected static WrkCtrSlotData createJobCapacityReservations(FromDate    _firstDate,
                                                                         timeOfDay   _firstTime,
                                                                         ToDate      _lastDate,
                                                                         timeOfDay   _lastTime,
                                                                         WrkCtrId    _wrkCtrId)
    {
        #TimeConstants
        WrkCtrSlotData      capacitySlotData;
        WrkCtrSlotData      reserveSlotData = new WrkCtrSlotData();

        GanttCalendarId     calendarId;

        TransDate           transDate;
        Seconds             fromTime;
        Seconds             toTime;
        RealBase            capacity;
        boolean             foundSlot;

        RealBase            capPrSec;
        RealBase            capRoundedOff;

        boolean             hasReservations = false;

        if (GanttControlSchedulerTimeZoneFlight::instance().isEnabled() &&
            capacityReservations && 
            capacityReservations.elements())
        {
            ListEnumerator capResEnum = capacityReservations.getEnumerator();

            while (capResEnum.moveNext())
            {
                WrkCtrSchedulerCapacityReservation capacityReservation = capResEnum.current();
                toTime = capacityReservation.parmReservationFromDate() != capacityReservation.parmReservationToDate() ?
                    #secondsPerDay :
                    capacityReservation.parmReservationToTime();

                if (capacityReservation.parmReservationFromTime() < toTime)
                {
                    reserveSlotData.insert(capacityReservation.parmReservationFromDate(),
                            capacityReservation.parmReservationFromTime(),
                            toTime,
                            capacityReservation.parmReservationCapSec(),
                            capacityReservation.parmReservationLoadPct(),
                            '');

                    hasReservations = true;
                }
            }
        }
        else
        {
            transDate   = _firstDate;

            while (transDate <= _lastDate)
            {
                capacitySlotData = new WrkCtrSlotData();

                GanttData_WrkCtr::loadCapacitySlotData(capacitySlotData, transDate, _wrkCtrId);

                if (transDate == _firstDate && !capacitySlotData.qty())
                {
                    calendarId = GanttCalendarWrkCtr::getWrkCtrCalendarId(transDate, _wrkCtrId);

                    throw error(strfmt("@SYS109215", calendarId, date2StrUsr(transDate, DateFlags::FormatAll)),
                                '',
                                WorkCalendar::infoActionWorkCalendarTable(calendarId));
                }
                else if (transDate == _lastDate && !capacitySlotData.qty())
                {
                    calendarId = GanttCalendarWrkCtr::getWrkCtrCalendarId(transDate, _wrkCtrId);

                    throw error(strfmt("@SYS109215", calendarId, date2StrUsr(transDate, DateFlags::FormatAll)),
                                '',
                                WorkCalendar::infoActionWorkCalendarTable(calendarId));
                }

                if (capacitySlotData.qty() > 0)
                {
                    foundSlot = capacitySlotData.first();

                    while (foundSlot)
                    {
                        if ((transDate == _firstDate && capacitySlotData.rec_ToTime() < _firstTime) ||
                           (transDate == _lastDate && capacitySlotData.rec_FromTime() > _lastTime))
                        {
                            foundSlot = capacitySlotData.next();
                            continue;
                        }

                        fromTime   = capacitySlotData.rec_FromTime();
                        toTime     = capacitySlotData.rec_ToTime();
                        capacity   = capacitySlotData.rec_Capacity();

                        if (transDate == _firstDate && capacitySlotData.firstTime() == fromTime && fromTime > _firstTime)
                        {
                            calendarId = GanttCalendarWrkCtr::getWrkCtrCalendarId(transDate, _wrkCtrId);

                            throw error(strfmt("@SYS109216",
                                                calendarId,
                                                date2StrUsr(transDate, DateFlags::FormatAll),
                                                time2str(_firstTime, GanttTableField::time2StrSeparator1(), GanttTableField::time2StrSeparator2())),
                                                '',
                                                WorkCalendar::infoActionWorkCalendarTable(calendarId));
                        }
                        else if (transDate == _lastDate && capacitySlotData.lastTime() == toTime && toTime < _lastTime)
                        {
                            calendarId = GanttCalendarWrkCtr::getWrkCtrCalendarId(transDate, _wrkCtrId);

                            throw error(strfmt("@SYS109216",
                                                calendarId,
                                                date2StrUsr(transDate, DateFlags::FormatAll),
                                                time2str(_lastTime, GanttTableField::time2StrSeparator1(), GanttTableField::time2StrSeparator2())),
                                                '',
                                                WorkCalendar::infoActionWorkCalendarTable(calendarId));
                        }

                        if (fromTime > toTime)
                        {
                            throw error("@SYS39558");
                        }

                        capPrSec = capacity / (toTime - fromTime);

                        if (transDate == _firstDate && fromTime <= _firstTime)
                        {
                            fromTime = _firstTime;
                        }

                        if (transDate == _lastDate && toTime >= _lastTime)
                        {
                            toTime = _lastTime;
                        }

                        capRoundedOff = (toTime - fromTime) * capPrSec;
                        capRoundedOff = roundDownDec(capRoundedOff,0);

                        reserveSlotData.insert(transDate, fromTime, toTime, capRoundedOff);

                        hasReservations = true;

                        foundSlot       = capacitySlotData.next();
                    }
                }

                transDate++;
            }
        }

        if (!hasReservations)
        {
            throw error("@SYS113559");
        }

        return reserveSlotData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteCapacityProdRouteJob</Name>
				<Source><![CDATA[
    protected static void deleteCapacityProdRouteJob(ProdRouteJob    _prodRouteJob,
                                                            ReqPlanId       _reqPlanId = ReqPlanSched::defaultDynamicId())
    {
        // delete capacity reservations
        GanttData_WrkCtr::deleteJobCapacityReservations(_prodRouteJob.JobId,
                                                        _prodRouteJob.JobType,
                                                        _prodRouteJob.ProdId,
                                                        WrkCtrCapRefType::Production,
                                                        _reqPlanId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteCapacityProjForecastEmpl</Name>
				<Source><![CDATA[
    protected static void deleteCapacityProjForecastEmpl(ProjForecastEmpl    _projForecastEmpl,
                                                                ReqPlanId           _reqPlanId = ReqPlanSched::defaultDynamicId())
    {
        // delete capacity reservations
        GanttData_WrkCtr::deleteJobCapacityReservations(int642str(_projForecastEmpl.RecId),
                                                        RouteJobType::Process,
                                                        _projForecastEmpl.ProjId,
                                                        WrkCtrCapRefType::Project,
                                                        _reqPlanId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteCapacityReqRouteJob</Name>
				<Source><![CDATA[
    protected static void deleteCapacityReqRouteJob(ReqRouteJob  _reqRouteJob)
    {
        // delete capacity reservations
        GanttData_WrkCtr::deleteJobCapacityReservations(int642str(_reqRouteJob.RecId),
                                                        _reqRouteJob.JobType,
                                                        _reqRouteJob.ReqPOId,
                                                        WrkCtrCapRefType::PlannedOrder,
                                                        ReqPlanVersion::find(_reqRouteJob.PlanVersion).ReqPlanId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteJobCapacityReservations</Name>
				<Source><![CDATA[
    protected static void deleteJobCapacityReservations(ProdJobId          _jobId,
                                                               RouteJobType       _jobType,
                                                               WrkCtrRefId        _refId,
                                                               WrkCtrCapRefType   _refType,
                                                               ReqPlanId          _reqPlanId,
                                                               WrkCtrCapacityType _loadType   = WrkCtrCapacityType::JobSched)
    {
        ReqPlanVersion  reqPlanVersion;

        reqPlanVersion = WrkCtrCapRes::determineReqPlanVersion(_reqPlanId, _refType);

        WrkCtrCapRes::deleteCapJobId(_jobId, _jobType, _refId, _refType, _loadType, reqPlanVersion.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDataInIntervalPlannedProd</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the data needed by executing the statements on the server side.
    /// </summary>
    /// <param name="_conLoadWrkCtrIds">
    ///    A container which is the packed set of work center IDs to be loaded.
    /// </param>
    /// <param name="_callerFromDate">
    ///    A <c>Date</c> value indicating the start date for the data fetch interval.
    /// </param>
    /// <param name="_callerToDate">
    ///    A <c>Date</c> value indicating the end date for the data fetch interval.
    /// </param>
    /// <param name="_reqPlanId">
    ///    A <c>ReqPlanId</c> indicating which master plan to use for loading planned production orders.
    /// </param>
    /// <returns>
    ///    A container with the packed set of <see cref="T:ReqPO" /> records that were fetched.
    /// </returns>
    /// <remarks>
    ///    The method retrieves the <see cref="T:ReqPO" /> records for the planned production orders that
    ///    satisfy the given interval and have at least a job on one of the work centers passed as parameters.
    /// </remarks>
    protected static container getDataInIntervalPlannedProd(container   _conLoadWrkCtrIds,
                                                                   date        _callerFromDate,
                                                                   date        _callerToDate,
                                                                   ReqPlanId   _reqPlanId)
    {
        ReqRouteJob     reqRouteJob;
        ReqPO           reqPO;
        SetEnumerator   setEnumerator;
        WrkCtrId        wrkCtrId;
        Set             setReqPOIds         = new Set(Types::String);
        Set             setDataPlannedProd  = new Set(Types::Container);
        Set             setLoadWrkCtrIds;
        ReqPlanVersion  reqPlanVersion      = ReqPlan::findReqPlanId(_reqPlanId).findActiveVersion();

        if (_conLoadWrkCtrIds)
        {
            setLoadWrkCtrIds = Set::create(_conLoadWrkCtrIds);
        }
        else
        {
            setLoadWrkCtrIds = new Set(Types::String);
        }

        // find all planned production orders in the original dates interval
        setEnumerator = setLoadWrkCtrIds.getEnumerator();

        while (setEnumerator && setEnumerator.moveNext())
        {
            wrkCtrId = setEnumerator.current();

            while select ReqPOId from reqRouteJob
                group ReqPOId
                where reqRouteJob.WrkCtrId               == wrkCtrId         &&
                      reqRouteJob.PlanVersion            == reqPlanVersion.RecId &&
                      reqRouteJob.FromDate               <= _callerToDate    &&
                      reqRouteJob.ToDate                 >= _callerFromDate
            {
                setReqPOIds.add(reqRouteJob.ReqPOId);
            }
        }

        // extend loading dates interval according to the delivery date of planned production orders
        setEnumerator = setReqPOIds.getEnumerator();

        while (setEnumerator && setEnumerator.moveNext())
        {
            reqPO = ReqPO::find(
                reqPlanVersion.RecId,
                setEnumerator.current());
            setDataPlannedProd.add([reqPO]);
        }

        return setDataPlannedProd.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDataInIntervalProd</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the data needed by executing the statements on the server side.
    /// </summary>
    /// <param name="_conLoadWrkCtrIds">
    ///    A container which is the packed set of work center IDs to be loaded.
    /// </param>
    /// <param name="_callerFromDate">
    ///    A <c>Date</c> value indicating the start date for the data fetch interval.
    /// </param>
    /// <param name="_callerToDate">
    ///    A <c>Date</c> value indicating the end date for the data fetch interval.
    /// </param>
    /// <returns>
    ///    A container with the packed set of <see cref="T:ProdTable" /> records that were fetched.
    /// </returns>
    /// <remarks>
    ///    The method retrieves the <see cref="T:ProdTable" /> records for the production orders that satisfy
    ///    the given interval and have at least a job on one of the work centers passed as parameters.
    /// </remarks>
    protected static container getDataInIntervalProd(container   _conLoadWrkCtrIds,
                                                            date        _callerFromDate,
                                                            date        _callerToDate)
    {
        ProdRouteJob    prodRouteJob;
        ProdTable       prodTable;
        SetEnumerator   setEnumerator;
        WrkCtrId        wrkCtrId;
        Set             setProdIds      = new Set(Types::String);
        Set             setDataProd     = new Set(Types::Container);
        Set             setLoadWrkCtrIds;

        if (_conLoadWrkCtrIds)
        {
            setLoadWrkCtrIds = Set::create(_conLoadWrkCtrIds);
        }
        else
        {
            setLoadWrkCtrIds = new Set(Types::String);
        }

        // find all production orders in the original dates interval
        setEnumerator = setLoadWrkCtrIds.getEnumerator();
        while (setEnumerator && setEnumerator.moveNext())
        {
            wrkCtrId = setEnumerator.current();

            while select ProdId from prodRouteJob
                group ProdId
                where prodRouteJob.WrkCtrId == wrkCtrId         &&
                      prodRouteJob.FromDate <= _callerToDate    &&
                      prodRouteJob.ToDate   >= _callerFromDate
            {
                setProdIds.add(prodRouteJob.ProdId);
            }
        }

        // extend loading dates interval according to the delivery date of production orders
        setEnumerator = setProdIds.getEnumerator();

        while (setEnumerator && setEnumerator.moveNext())
        {
            prodTable = ProdTable::find(setEnumerator.current());
            setDataProd.add([prodTable]);
        }

        return setDataProd.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDataInIntervalProj</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the data needed by executing the statements on the server side.
    /// </summary>
    /// <param name="_conLoadWrkCtrIds">
    ///    A container which is the packed set of work center IDs to be loaded.
    /// </param>
    /// <param name="_callerFromDate">
    ///    A <c>Date</c> value indicating the start date for the data fetch interval.
    /// </param>
    /// <param name="_callerToDate">
    ///    A <c>Date</c> value indicating the end date for the data fetch interval.
    /// </param>
    /// <returns>
    ///    A container with the packed set of <see cref="T:ProjTable" /> records retrieved.
    /// </returns>
    /// <remarks>
    ///    The method retrieves the <see cref="T:ProjTable" /> records for the projects that satisfy the given
    ///    interval and have at least a job on one of the work centers passed as parameters.
    /// </remarks>
    protected static container getDataInIntervalProj(container   _conLoadWrkCtrIds,
                                                            date        _callerFromDate,
                                                            date        _callerToDate)
    {
        ProjForecastEmpl    projForecastEmpl;
        ProjTable           projTable;
        SetEnumerator       setEnumerator;
        WrkCtrId            wrkCtrId;
        Set                 setProjIds  = new Set(Types::String);
        Set                 setDataProj = new Set(Types::Container);
        Set                 setLoadWrkCtrIds;

        if (_conLoadWrkCtrIds)
        {
            setLoadWrkCtrIds = Set::create(_conLoadWrkCtrIds);
        }
        else
        {
            setLoadWrkCtrIds = new Set(Types::String);
        }

        // find all projects in the original dates interval
        setEnumerator = setLoadWrkCtrIds.getEnumerator();

        while (setEnumerator && setEnumerator.moveNext())
        {
            wrkCtrId = setEnumerator.current();

            while select ProjId from projForecastEmpl
                group ProjId
                where projForecastEmpl.SchedWrkCtrId == wrkCtrId        &&
                      projForecastEmpl.SchedFromDate <= _callerToDate   &&
                      projForecastEmpl.SchedToDate   >= _callerFromDate
            {
                setProjIds.add(projForecastEmpl.ProjId);
            }
        }

        // extend loading dates interval according to the end date of projects
        setEnumerator = setProjIds.getEnumerator();

        while (setEnumerator && setEnumerator.moveNext())
        {
            projTable = ProjTable::find(setEnumerator.current());
            setDataProj.add([projTable]);
        }

        return setDataProj.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDataPlannedProdForIds</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the planned production order data from the <see cref="T:ReqPO" /> records specified in the
    ///    <paramref name="_conSetLoadIds" /> parameter by their ID.
    /// </summary>
    /// <param name="_conSetLoadIds">
    ///    A container which is the packed set of planned production order IDs to load.
    /// </param>
    /// <param name="_reqPlanId">
    ///    A <c>ReqPlanId</c> indicating which master plan to use for loading planned production orders.
    /// </param>
    /// <returns>
    ///    A packed set of containers holding <see cref="T:ReqRouteJob" />, <see cref="T:ReqRoute" />, and
    ///    <see cref="T:ReqPO" /> record pairs that were fetched.
    /// </returns>
    protected static container getDataPlannedProdForIds(container    _conSetLoadIds,
                                                               ReqPlanId    _reqPlanId)
    {
        Set             setDataProd = new Set(Types::Container);
        Set             setLoadIds;
        ReqPOId         reqPOId;
        SetEnumerator   setEnumerator;
        ReqRouteJob     reqRouteJob;
        ReqRoute        reqRoute;
        ReqPO           reqPO;
        ReqPlanVersion  reqPlanVersion =
                                         ReqPlan::findReqPlanId(_reqPlanId).findActiveVersion();

        if (_conSetLoadIds)
        {
            setLoadIds = Set::create(_conSetLoadIds);
        }
        else
        {
            setLoadIds = new Set(Types::String);
        }

        setEnumerator = setLoadIds.getEnumerator();
        while (setEnumerator && setEnumerator.moveNext())
        {
            reqPOId = setEnumerator.current();

            while select reqRouteJob
                where reqRouteJob.ReqPOId                == reqPOId  &&
                      reqRouteJob.PlanVersion            == reqPlanVersion.RecId
            join reqRoute
                where reqRoute.RefId                    == reqRouteJob.ReqPOId  &&
                      reqRoute.PlanVersion              == reqPlanVersion.RecId
            join reqPO
                where reqPO.RefId                     == reqRouteJob.ReqPOId  &&
                      reqRoute.PlanVersion            == reqPlanVersion.RecId
            {
                setDataProd.add([reqRouteJob, reqRoute, reqPO]);
            }
        }

        return setDataProd.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDataProdForIds</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the production order data from the <see cref="ReqPO Table" /> records specified in <paramref
    ///    name="_conSetLoadIds" /> by their ID.
    /// </summary>
    /// <param name="_conSetLoadIds">
    ///    A container which is the packed set of production order IDs to load.
    /// </param>
    /// <returns>
    ///    A packed set of containers holding the <see cref="ProdRouteJob Table" />, <see cref="ProdRoute
    ///    Table" />, and the <see cref="ProdTable Table" /> record pairs retrieved.
    /// </returns>
    protected static container getDataProdForIds(container _conSetLoadIds)
    {
        Set             setDataProd = new Set(Types::Container);
        Set             setLoadIds;
        ProdId          prodId;
        SetEnumerator   setEnumerator;
        ProdRouteJob    prodRouteJob;
        ProdRoute       prodRoute;
        ProdTable       prodTable;

        if (_conSetLoadIds)
        {
            setLoadIds = Set::create(_conSetLoadIds);
        }
        else
        {
            setLoadIds = new Set(Types::String);
        }

        setEnumerator   = setLoadIds.getEnumerator();
        while (setEnumerator && setEnumerator.moveNext())
        {
            prodId = setEnumerator.current();

            while select prodRouteJob
                where prodRouteJob.ProdId   == prodId
            join prodRoute
                where prodRoute.ProdId      == prodRouteJob.ProdId
            join prodTable
                where prodTable.ProdId      == prodRouteJob.ProdId
            {
                setDataProd.add([prodRouteJob, prodRoute, prodTable]);
            }
        }

        return setDataProd.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDataProjForIds</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the project data from the <see cref="T:ReqPO" /> records specified in the <paramref
    ///    name="_conSetLoadIds" /> parameter by their ID.
    /// </summary>
    /// <param name="_conSetLoadIds">
    ///    A container which is the packed set of project IDs to load.
    /// </param>
    /// <returns>
    ///    A packed set of containers holding <see cref="T:ProjForecastEmpl" /> records that were fetched.
    /// </returns>
    protected static container getDataProjForIds(container _conSetLoadIds)
    {
        Set                 setDataProj = new Set(Types::Container);
        Set                 setLoadIds;
        ProjId              projId;
        SetEnumerator       setEnumerator;
        ProjForecastEmpl    projForecastEmpl;
        ProjTable           projTable;

        if (_conSetLoadIds)
        {
            setLoadIds = Set::create(_conSetLoadIds);
        }
        else
        {
            setLoadIds = new Set(Types::String);
        }

        setEnumerator   = setLoadIds.getEnumerator();
        while (setEnumerator && setEnumerator.moveNext())
        {
            projId = setEnumerator.current();

            while select projForecastEmpl
                where projForecastEmpl.ProjId == projId
                join projTable
                    where projTable.ProjId == projId
            {
                setDataProj.add([projForecastEmpl, projTable]);
            }
        }

        return setDataProj.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWrkCtrEffectivityPct</Name>
				<Source><![CDATA[
    public static Percent getWrkCtrEffectivityPct(WrkCtrId     _wrkCtrId,
                                                  WrkCtrTable  _wrkCtrTable = null) // set this parameter for better performance
    {
        if (!_wrkCtrTable)
        {
            _wrkCtrTable = WrkCtrTable::find(_wrkCtrId);
        }

        if (!_wrkCtrTable)
        {
            throw error(strfmt(WrkCtrTable::txtNotExist(), _wrkCtrId));
        }

        return _wrkCtrTable.effectivityPct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLoadingDataFromEntireProdOnServer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the data needed by <see cref="M:GanttData_WrkCtr.initLoadingDataFromEntireProd" /> by
    ///    executing the statements on the server side.
    /// </summary>
    /// <param name="_conLoadWrkCtrIds">
    ///    A container which is the packed set of work center IDs to be loaded.
    /// </param>
    /// <param name="_callerFromDate">
    ///    A <c>Date</c> value indicating the start date for the data fetch interval.
    /// </param>
    /// <param name="_callerToDate">
    ///    A <c>Date</c> value indicating the end date for the data fetch interval.
    /// </param>
    /// <returns>
    ///    A container with the packed set of <see cref="T:ProdRouteJob" /> records retrieved.
    /// </returns>
    /// <remarks>
    ///    The method fetches all the <see cref="T:ProdRouteJob" /> records that belongs to the production
    ///    orders that have jobs on one of the work centers specified in the <paramref
    ///    name="_conLoadWrkCtrIds" /> parameter and which satisfy the date interval <paramref
    ///    name="_callerFromDate" />, and <paramref name="_callerToDate" />.
    /// </remarks>
    protected static container initLoadingDataFromEntireProdOnServer(container _conLoadWrkCtrIds,
                                                                            date      _callerFromDate,
                                                                            date      _callerToDate)
    {
        ProdRouteJob    prodRouteJob;
        SetEnumerator   setEnumerator;
        WrkCtrId        wrkCtrId;
        Set             setProdIds  = new Set(Types::String);
        Set             setDataProd = new Set(Types::Container);
        ProdId          prodId;
        Set             setLoadWrkCtrIds;

        if (_conLoadWrkCtrIds)
        {
            setLoadWrkCtrIds = Set::create(_conLoadWrkCtrIds);
        }
        else
        {
            setLoadWrkCtrIds = new Set(Types::String);
        }

        // find all production orders in the original dates interval
        setEnumerator = setLoadWrkCtrIds.getEnumerator();

        while (setEnumerator && setEnumerator.moveNext())
        {
            wrkCtrId = setEnumerator.current();

            while select ProdId from prodRouteJob
                group ProdId
                where prodRouteJob.WrkCtrId == wrkCtrId         &&
                      prodRouteJob.FromDate <= _callerToDate    &&
                      prodRouteJob.ToDate   >= _callerFromDate
            {
                setProdIds.add(prodRouteJob.ProdId);
            }
        }

        // extend loading dates interval according to start and end dates of the production orders
        setEnumerator = setProdIds.getEnumerator();
        while (setEnumerator && setEnumerator.moveNext())
        {
            prodId = setEnumerator.current();

            while select prodRouteJob
                where prodRouteJob.ProdId == prodId
            {
                setDataProd.add([prodRouteJob]);
            }
        }

        return setDataProd.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLoadingDataFromEntireProjOnServer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the data needed by <see cref="M:GanttData_WrkCtr.initLoadingDataFromEntireProj" /> by
    ///    executing the statements on the server side.
    /// </summary>
    /// <param name="_conLoadWrkCtrIds">
    ///    A container which is the packed set of work center IDs to be loaded.
    /// </param>
    /// <param name="_callerFromDate">
    ///    A <c>Date</c> value indicating the start date for the data fetch interval.
    /// </param>
    /// <param name="_callerToDate">
    ///    A <c>Date</c> value indicating the end date for the data fetch interval.
    /// </param>
    /// <returns>
    ///    A container with the packed set of <see cref="T:ProjForecastEmpl" /> records that were fetched.
    /// </returns>
    /// <remarks>
    ///    The method fetches all the <see cref="T:ProjForecastEmpl" /> records that belongs to the projects
    ///    that have jobs on one of the work centers specified in the <paramref name="_conLoadWrkCtrIds" />
    ///    parameter and which satisfy the date interval parameters <paramref name="_callerFromDate" /> and
    ///    <paramref name="_callerToDate" />.
    /// </remarks>
    protected static container initLoadingDataFromEntireProjOnServer(container _conLoadWrkCtrIds,
                                                                            date      _callerFromDate,
                                                                            date      _callerToDate)
    {
        ProjForecastEmpl    projForecastEmpl;
        SetEnumerator       setEnumerator;
        WrkCtrId            wrkCtrId;
        Set                 setProjIds  = new Set(Types::String);
        Set                 setDataProj = new Set(Types::Container);
        ProjId              projId;
        Set                 setLoadWrkCtrIds;

        if (_conLoadWrkCtrIds)
        {
            setLoadWrkCtrIds = Set::create(_conLoadWrkCtrIds);
        }
        else
        {
            setLoadWrkCtrIds = new Set(Types::String);
        }

        // find all projects in the original dates interval
        setEnumerator = setLoadWrkCtrIds.getEnumerator();

        while (setEnumerator && setEnumerator.moveNext())
        {
            wrkCtrId = setEnumerator.current();

            while select ProjId from projForecastEmpl
                group ProjId
                where projForecastEmpl.SchedWrkCtrId    == wrkCtrId         &&
                      projForecastEmpl.SchedFromDate    <= _callerToDate    &&
                      projForecastEmpl.SchedToDate      >= _callerFromDate
            {
                setProjIds.add(projForecastEmpl.ProjId);
            }
        }

        // extend loading dates interval according to start and end dates of the projects
        setEnumerator = setProjIds.getEnumerator();
        while (setEnumerator && setEnumerator.moveNext())
        {
            projId = setEnumerator.current();

            while select projForecastEmpl
                where projForecastEmpl.ProjId == projId
            {
                setDataProj.add([projForecastEmpl]);
            }
        }

        return setDataProj.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLoadingDataFromEntireReqPOOnServer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the data needed by <see cref="M:GanttData_WrkCtr.initLoadingDataFromEntirePlannedProd" /> by
    ///    executing the statements on the server side.
    /// </summary>
    /// <param name="_conLoadWrkCtrIds">
    ///    A container which is the packed set of work center IDs to be loaded.
    /// </param>
    /// <param name="_callerFromDate">
    ///    A <c>Date</c> value indicating the start date for the data fetch interval.
    /// </param>
    /// <param name="_callerToDate">
    ///    A <c>Date</c> value indicating the end date for the data fetch interval.
    /// </param>
    /// <param name="_reqPlanId">
    ///    A <c>ReqPlanId</c> indicating which master plan to use for loading planned production order data.
    /// </param>
    /// <returns>
    ///    A container with the packed set of <see cref="T:ReqRouteJob" /> records that were fetched.
    /// </returns>
    /// <remarks>
    ///    The method fetches all the <see cref="T:ReqRouteJob" /> records that belongs to the planned
    ///    production orders that have jobs on one of the work centers specified in the <paramref
    ///    name="_conLoadWrkCtrIds" /> parameter and which satisfy the date interval parameters for <paramref
    ///    name="_callerFromDate" /> and <paramref name="_callerToDate" />.
    /// </remarks>
    protected static container initLoadingDataFromEntireReqPOOnServer(container   _conLoadWrkCtrIds,
                                                                             date        _callerFromDate,
                                                                             date        _callerToDate,
                                                                             ReqPlanId   _reqPlanId)
    {
        WrkCtrId        wrkCtrId;
        SetEnumerator   setEnumerator;

        ReqRouteJob     reqRouteJob;

        Set             setReqPoIds         = new Set(Types::String);
        Set             setDataPlannedProd  = new Set(Types::Container);
        ReqPOId         reqPOId;
        Set             setLoadWrkCtrIds;
        ReqPlanVersion  reqPlanVersion      =
                                              ReqPlan::findReqPlanId(_reqPlanId).findActiveVersion();

        if (_conLoadWrkCtrIds)
        {
            setLoadWrkCtrIds = Set::create(_conLoadWrkCtrIds);
        }
        else
        {
            setLoadWrkCtrIds = new Set(Types::String);
        }

        // find all planned production orders in the original dates interval
        setEnumerator = setLoadWrkCtrIds.getEnumerator();

        while (setEnumerator && setEnumerator.moveNext())
        {
            wrkCtrId = setEnumerator.current();

            while select ReqPOId from reqRouteJob
                group ReqPOId
                where reqRouteJob.WrkCtrId               == wrkCtrId               &&
                      reqRouteJob.PlanVersion            == reqPlanVersion.RecId   &&
                      reqRouteJob.FromDate               <= _callerToDate          &&
                      reqRouteJob.ToDate                 >= _callerFromDate
            {
                setReqPoIds.add(reqRouteJob.ReqPOId);
            }
        }

        // extend loading dates interval according to start and end dates of the planned production orders
        setEnumerator = setReqPoIds.getEnumerator();

        while (setEnumerator && setEnumerator.moveNext())
        {
            reqPOId = setEnumerator.current();

            while select reqRouteJob
                where reqRouteJob.ReqPOId                == reqPOId             &&
                      reqRouteJob.PlanVersion            == reqPlanVersion.RecId
            {
                setDataPlannedProd.add([reqRouteJob]);
            }
        }

        return setDataPlannedProd.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertJobCapacityReservations</Name>
				<Source><![CDATA[
    protected static void insertJobCapacityReservations(WrkCtrSlotData           _reserveSlotData,
                                                               ProdJobId                _jobId,
                                                               RouteJobType             _jobType,
                                                               WrkCtrRefId              _refId,
                                                               WrkCtrCapRefType         _refType,
                                                               OprNum                   _oprNum,
                                                               RouteOprPriority         _oprPriority,
                                                               WrkCtrId                 _wrkCtrId,
                                                               WrkCtrLoadPct            _wrkCtrLoadPct,
                                                               ReqPlanId                _reqPlanId,
                                                               ProdJobLocked            _locked     = NoYes::No,
                                                               WrkCtrCapacityType       _loadType   = WrkCtrCapacityType::JobSched)
    {
        WrkCtrCapRes        wrkCtrCapRes;
        WrkCtrTable         wrkCtrTable = WrkCtrTable::find(_wrkCtrId);
        WrkCtrLoadPct       wrkCtrLoadPct;
        RefRecId            reqPlanVersionRefRecId = WrkCtrCapRes::determineReqPlanVersion(_reqPlanId, _refType).RecId;

        if (_reserveSlotData == null)
        {
            throw error(strfmt("@SYS54195", funcname()));
        }

        if (_reserveSlotData.first())
        {
            do
            {
                wrkCtrCapRes.JobId          = _jobId;
                wrkCtrCapRes.JobType        = _jobType;

                wrkCtrCapRes.RefId          = _refId;
                wrkCtrCapRes.RefType        = _refType;

                wrkCtrCapRes.OprNum         = _oprNum;
                wrkCtrCapRes.OprPriority    = _oprPriority;

                wrkCtrCapRes.WrkCtrId       = _wrkCtrId;

                wrkCtrCapRes.WrkCtrLoadPct  = _wrkCtrLoadPct;

                wrkCtrCapRes.PlanVersion    = reqPlanVersionRefRecId;

                wrkCtrCapRes.Locked         = _locked;

                wrkCtrCapRes.LoadType       = _loadType;

                wrkCtrCapRes.TransDate      = _reserveSlotData.rec_TransDate();
                wrkCtrCapRes.StartTime      = _reserveSlotData.rec_FromTime();
                wrkCtrCapRes.EndTime        = _reserveSlotData.rec_ToTime();

                wrkCtrLoadPct               = wrkCtrTable.Exclusive ? 100 : _wrkCtrLoadPct;
                wrkCtrLoadPct               = wrkCtrLoadPct ? wrkCtrLoadPct : 100;
                wrkCtrCapRes.WrkCtrSec      = _reserveSlotData.rec_Capacity() * wrkCtrLoadPct / 100;

                wrkCtrCapRes.initIntvFields();

                wrkCtrCapRes.doInsert();
            } while (_reserveSlotData.next());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadCapacitySlotData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads capacity slots based on working calendars.
    /// </summary>
    /// <param name="_slotData">
    ///    The collection to which the capacity slots is added.
    /// </param>
    /// <param name="_transDate">
    ///    The date for which the slots must be loaded.
    /// </param>
    /// <param name="_wrkCtrId">
    ///    The ID of the resource.
    /// </param>
    /// <param name="_wrkCtrTable">
    ///    A resource record that is used to avoid looking up the resource ID; optional.
    /// </param>
    protected static void loadCapacitySlotData(WrkCtrSlotData  _slotData,
                                               TransDate       _transDate,
                                               WrkCtrId        _wrkCtrId,
                                               WrkCtrTable     _wrkCtrTable = null)
    {
        GanttCalendarId         calendarId;
        WorkCalendarDateLine    workCalendarDateLine;
        
        calendarId = GanttCalendarWrkCtr::getWrkCtrCalendarId(_transDate, _wrkCtrId);

        while select workCalendarDateLine
        where workCalendarDateLine.CalendarId   == calendarId &&
              workCalendarDateLine.TransDate    == _transDate
        {
            if (workCalendarDateLine.FromTime <  workCalendarDateLine.ToTime)
            {
                _slotData.insert(workCalendarDateLine.TransDate,
                        workCalendarDateLine.FromTime,
                        workCalendarDateLine.ToTime,
                        workCalendarDateLine.capacity(GanttData_WrkCtr::getWrkCtrEffectivityPct(_wrkCtrId, _wrkCtrTable)),
                        100,
                        '');
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadDataPlannedProdOnServer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the data needed by <see cref="M:GanttData_WrkCtr.loadDataPlannedProd" /> by executing the
    ///    statements on the server side.
    /// </summary>
    /// <param name="_conLoadWrkCtrIds">
    ///    A container which is the packed set of work center IDs to be loaded.
    /// </param>
    /// <param name="_loadingFromDate">
    ///    A <c>Date</c> value indicating the start date for the data fetch interval.
    /// </param>
    /// <param name="_loadingToDate">
    ///    A <c>Date</c> value indicating the end date for the data fetch interval.
    /// </param>
    /// <param name="_reqPlanId">
    ///    A <c>ReqPlanId</c> indicating which master plan to use for loading planned production orders.
    /// </param>
    /// <param name="_conRefIdsToLoad">
    ///    A <c>container</c> with a packed set of the Ids of specific planned production orders to load instead of all orders on the work centers; optional.
    /// </param>
    /// <returns>
    ///    A packed set of containers holding <see cref="T:ReqRouteJob" />, <see cref="T:ReqRoute" />, <see
    ///    cref="T:ReqPO" />, <see cref="T:WrkCtrTable" /> and <see cref="T:WrkCtrResourceGroup" /> record pairs that were fetched.
    /// </returns>
    /// <remarks>
    ///    The method fetches all the holding <see cref="T:ReqRouteJob" /> records that belongs to the planned
    ///    production orders that have jobs on one of the work centers specified in the <paramref
    ///    name="_conLoadWrkCtrIds" /> parameter and which satisfy the date interval parameters for <paramref
    ///    name="_loadingFromDate" />, and <paramref name="_loadingToDate" />.
    /// </remarks>
    protected static container loadDataPlannedProdOnServer(container _conLoadWrkCtrIds,
                                                                  date      _loadingFromDate,
                                                                  date      _loadingToDate,
                                                                  ReqPlanId _reqPlanId,
                                                                  container _conRefIdsToLoad = conNull())
    {
        WrkCtrId            wrkCtrId;
        SetEnumerator       setEnumerator;

        ReqRouteJob         reqRouteJob;
        ReqRoute            reqRoute;
        ReqPO               reqPO;
        WrkCtrTable         wrkCtrTable;
        WrkCtrResourceGroup wrkCtrResourceGroup;
        Set                 setRefIdsToLoad     = new Set(Types::String);
        Set                 setDataPlannedProd  = new Set(Types::Container);
        Set                 setLoadWrkCtrIds;
        ReqPlanVersion      reqPlanVersion      =
                                              ReqPlan::findReqPlanId(_reqPlanId).findActiveVersion();

        if (_conRefIdsToLoad != conNull())
        {
            // Load only specific orders
            setRefIdsToLoad = Set::create(_conRefIdsToLoad);
        }
        else
        {
            if (_conLoadWrkCtrIds)
            {
                setLoadWrkCtrIds = Set::create(_conLoadWrkCtrIds);
            }
            else
            {
                setLoadWrkCtrIds = new Set(Types::String);
            }

            // gather all planned production orders to load in a set
            setEnumerator = setLoadWrkCtrIds.getEnumerator();
            while (setEnumerator && setEnumerator.moveNext())
            {
                wrkCtrId = setEnumerator.current();
                while select ReqPOId from reqRouteJob
                    group by ReqPOId
                    where reqRouteJob.WrkCtrId                  == wrkCtrId                 &&
                          reqRouteJob.PlanVersion               == reqPlanVersion.RecId     &&
                          reqRouteJob.ToDate                    >= _loadingFromDate         &&
                          reqRouteJob.FromDate                  <= _loadingToDate
                {
                    setRefIdsToLoad.add(reqRouteJob.ReqPOId);
                }
            }
        }

        setEnumerator = setRefIdsToLoad.getEnumerator();
        while (setEnumerator && setEnumerator.moveNext())
        {
            while select reqRouteJob
                where reqRouteJob.ReqPOId                   == setEnumerator.current()      &&
                      reqRouteJob.PlanVersion               == reqPlanVersion.RecId
                join reqRoute
                    where reqRoute.RefId                    == reqRouteJob.ReqPOId          &&
                          reqRoute.PlanVersion              == reqPlanVersion.RecId         &&
                          reqRoute.OprNum                   == reqRouteJob.OprNum           &&
                          reqRoute.OprPriority              == reqRouteJob.OprPriority
                join reqPO
                    where reqPO.PlanVersion                 == reqPlanVersion.RecId         &&
                          reqPO.RefId                       == reqRouteJob.ReqPOId
                join wrkCtrTable
                    where wrkCtrTable.WrkCtrId              == reqRouteJob.WrkCtrId
            {
                wrkCtrResourceGroup = WrkCtrTable::resourceGroup(wrkCtrTable.WrkCtrId, reqRouteJob.FromDate, reqRouteJob.ToDate);
                setDataPlannedProd.add([reqRouteJob, reqRoute, reqPO, wrkCtrTable, wrkCtrResourceGroup]);
            }
        }

        return setDataPlannedProd.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadDataProdOnServer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the data needed by <see cref="M:GanttData_WrkCtr.loadDataProd" /> by executing the statements
    ///    on the server side.
    /// </summary>
    /// <param name="_conLoadWrkCtrIds">
    ///    A container which is the packed set of work center IDs to be loaded.
    /// </param>
    /// <param name="_loadingFromDate">
    ///    A <c>Date</c> value indicating the start date for the data fetch interval.
    /// </param>
    /// <param name="_loadingToDate">
    ///    A <c>Date</c> value indicating the end date for the data fetch interval.
    /// </param>
    /// <param name="_conRefIdsToLoad">
    ///    A <c>container</c> with a packed set of the Ids of specific production orders to load instead of all orders on the work centers; optional.
    /// </param>
    /// <returns>
    ///    A packed set of containers holding <see cref="T:ProdRouteJob" />, <see cref="T:ProdRoute" />, <see
    ///    cref="T:ProdTable" />, <see cref="T:WrkCtrTable" /> and <see cref="T:WrkCtrResourceGroup" /> record pairs that were fetched.
    /// </returns>
    /// <remarks>
    ///    The method fetches all the <see cref="T:ProdRouteJob" /> records that belongs to the production
    ///    orders that have jobs on one of the work centers specified in the <paramref
    ///    name="_conLoadWrkCtrIds" /> parameter and which satisfy the date interval parameters for <paramref
    ///    name="_loadingFromDate" />, and <paramref name="_loadingToDate" />.
    /// </remarks>
    protected static container loadDataProdOnServer(container    _conLoadWrkCtrIds,
                                                           date         _loadingFromDate,
                                                           date         _loadingToDate,
                                                           container    _conRefIdsToLoad = conNull())
    {
        SetEnumerator       setEnumerator;
        WrkCtrId            wrkCtrId;

        ProdRouteJob        prodRouteJob;
        ProdRoute           prodRoute;
        ProdTable           prodTable;
        WrkCtrTable         wrkCtrTable;
        WrkCtrResourceGroup wrkCtrResourceGroup;

        Set             setRefIdsToLoad = new Set(Types::String);
        Set             setDataProd     = new Set(Types::Container);
        Set             setLoadWrkCtrIds;

        if (_conRefIdsToLoad != conNull())
        {
            // Load only specific orders
            setRefIdsToLoad = Set::create(_conRefIdsToLoad);
        }
        else
        {
            if (_conLoadWrkCtrIds)
            {
                setLoadWrkCtrIds = Set::create(_conLoadWrkCtrIds);
            }
            else
            {
                setLoadWrkCtrIds = new Set(Types::String);
            }

            // gather all production orders to load in a set
            setEnumerator = setLoadWrkCtrIds.getEnumerator();
            while (setEnumerator && setEnumerator.moveNext())
            {
                wrkCtrId = setEnumerator.current();

                while select ProdId from prodRouteJob
                    group by ProdId
                    where prodRouteJob.WrkCtrId     == wrkCtrId             &&
                          prodRouteJob.ToDate       >= _loadingFromDate     &&
                          prodRouteJob.FromDate     <= _loadingToDate
                {
                    setRefIdsToLoad.add(prodRouteJob.ProdId);
                }
            }
        }

        // load data for each production order
        setEnumerator = setRefIdsToLoad.getEnumerator();
        while (setEnumerator && setEnumerator.moveNext())
        {
            while select prodRouteJob
                where prodRouteJob.ProdId           == setEnumerator.current()
                join prodRoute
                    where prodRoute.ProdId          == prodRouteJob.ProdId          &&
                          prodRoute.OprNum          == prodRouteJob.OprNum          &&
                          prodRoute.OprPriority     == prodRouteJob.OprPriority
                join prodTable
                    where prodTable.ProdId          == prodRouteJob.ProdId
                join wrkCtrTable
                    where wrkCtrTable.WrkCtrId      == prodRouteJob.WrkCtrId
            {
                wrkCtrResourceGroup = WrkCtrTable::resourceGroup(wrkCtrTable.WrkCtrId, prodRouteJob.FromDate, prodRouteJob.ToDate);
                setDataProd.add([prodRouteJob, prodRoute, prodTable, wrkCtrTable, wrkCtrResourceGroup]);
            }
        }

        return setDataProd.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadDataProjOnServer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the data needed by <see cref="GanttData_WrkCtr.loadDataProj Method" /> by executing the
    ///    statements on the server side.
    /// </summary>
    /// <param name="_conLoadWrkCtrIds">
    ///    A container which is the packed set of work center IDs to be loaded.
    /// </param>
    /// <param name="_loadingFromDate">
    ///    A <c>Date</c> value indicating the start date for the data fetch interval.
    /// </param>
    /// <param name="_loadingToDate">
    ///    A <c>Date</c> value indicating the end date for the data fetch interval.
    /// </param>
    /// <returns>
    ///    A packed set of containers holding <see cref="ProjForecastEmpl Table" />, <see cref="ProjTable
    ///    Table" />, <see cref="smmActivities Table" />, <see cref="T:WrkCtrTable" /> and <see cref="T:WrkCtrResourceGroup" /> record pairs
    ///    that were fetched.
    /// </returns>
    /// <param name="_conRefIdsToLoad">
    ///    A <c>container</c> with a packed set of the Ids of specific projects to load instead of all orders on the work centers; optional.
    /// </param>
    /// <remarks>
    ///    The method fetches all of the holding <see cref="ProjForecastEmpl Table" /> records belonging to
    ///    the projects that have jobs on one of the work centers specified in the <paramref
    ///    name="_conLoadWrkCtrIds" /> parameter and which satisfy the date interval parameters for <paramref
    ///    name="_loadingFromDate" />, and <paramref name="_loadingToDate" />.
    /// </remarks>
    protected static container loadDataProjOnServer(container    _conLoadWrkCtrIds,
                                                           date         _loadingFromDate,
                                                           date         _loadingToDate,
                                                           container    _conRefIdsToLoad = conNull())
    {
        WrkCtrId            wrkCtrId;
        SetEnumerator       setEnumerator;

        ProjForecastEmpl    projForecastEmpl;
        ProjTable           projTable;
        WrkCtrTable         wrkCtrTable;
        WrkCtrResourceGroup wrkCtrResourceGroup;
        smmActivities       smmActivities;
        Set                 setRefIdsToLoad = new Set(Types::String);
        Set                 setDataProj     = new Set(Types::Container);
        Set                 setLoadWrkCtrIds;

        if (_conRefIdsToLoad != conNull())
        {
            // Load only specific orders
            setRefIdsToLoad = Set::create(_conRefIdsToLoad);
        }
        else
        {
        if (_conLoadWrkCtrIds)
        {
            setLoadWrkCtrIds = Set::create(_conLoadWrkCtrIds);
        }
        else
        {
            setLoadWrkCtrIds = new Set(Types::String);
        }

        setEnumerator = setLoadWrkCtrIds.getEnumerator();
        while (setEnumerator && setEnumerator.moveNext())
        {
            wrkCtrId = setEnumerator.current();
            while select ProjId from projForecastEmpl
                group by ProjId
                where projForecastEmpl.SchedWrkCtrId    == wrkCtrId                 &&
                      projForecastEmpl.SchedToDate      >= _loadingFromDate           &&
                      projForecastEmpl.SchedFromDate    <= _loadingToDate
            {
                setRefIdsToLoad.add(projForecastEmpl.ProjId);
            }
        }
        }

        setEnumerator = setRefIdsToLoad.getEnumerator();
        while (setEnumerator && setEnumerator.moveNext())
        {
            while select projForecastEmpl
                where projForecastEmpl.ProjId                   == setEnumerator.current()
                outer join smmActivities
                    where smmActivities.ActivityNumber          == projForecastEmpl.ActivityNumber
                join projTable
                    where projTable.ProjId                      == projForecastEmpl.ProjId
                join wrkCtrTable
                    where wrkCtrTable.WrkCtrId          == projForecastEmpl.SchedWrkCtrId
            {
                wrkCtrResourceGroup = WrkCtrTable::resourceGroup(wrkCtrTable.WrkCtrId, projForecastEmpl.SchedFromDate, projForecastEmpl.SchedToDate);
                setDataProj.add([projForecastEmpl, projTable, smmActivities, wrkCtrTable, wrkCtrResourceGroup]);
            }
        }

        return setDataProj.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newGanttClient</Name>
				<Source><![CDATA[
    public static GanttData_WrkCtr newGanttClient(GanttClient_WrkCtr _ganttClient)
    {
        GanttData_WrkCtr ganttData = GanttData_WrkCtr::construct();
        ganttData.parmGanttClient(_ganttClient);

        return ganttData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserveCapacityProdRouteJob</Name>
				<Source><![CDATA[
    protected static void reserveCapacityProdRouteJob(ProdRouteJob   _prodRouteJob,
                                                             ReqPlanId      _reqPlanId      = ReqPlanSched::defaultDynamicId(),
                                                             boolean        _onlyValidate   = false)
    {
        WrkCtrSlotData  reserveSlotData;
        ProdRoute       prodRoute   = _prodRouteJob.prodRoute() ;
        // delete capacity reservations
        if (!_onlyValidate)
        {
            GanttData_WrkCtr::deleteCapacityProdRouteJob(_prodRouteJob, _reqPlanId);
        }

        // create capacity slots to be reserved
        reserveSlotData = GanttData_WrkCtr::createJobCapacityReservations(_prodRouteJob.FromDate,
                                                                          _prodRouteJob.FromTime,
                                                                          _prodRouteJob.ToDate,
                                                                          _prodRouteJob.ToTime,
                                                                          _prodRouteJob.WrkCtrId);

        // reserve capacity
        if (reserveSlotData && !_onlyValidate)
        {
            GanttData_WrkCtr::insertJobCapacityReservations(reserveSlotData,
                                                            _prodRouteJob.JobId,
                                                            _prodRouteJob.JobType,
                                                            _prodRouteJob.ProdId,
                                                            WrkCtrCapRefType::Production,
                                                            _prodRouteJob.OprNum,
                                                            _prodRouteJob.OprPriority,
                                                            _prodRouteJob.WrkCtrId,
                                                            prodRoute.activityRequirementSet().LoadPercent,
                                                            _reqPlanId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserveCapacityProjForecastEmpl</Name>
				<Source><![CDATA[
    protected static void reserveCapacityProjForecastEmpl(ProjForecastEmpl   _projForecastEmpl,
                                                                 ReqPlanId          _reqPlanId          = ReqPlanSched::defaultDynamicId(),
                                                                 boolean            _onlyValidate       = false)
    {
        WrkCtrSlotData  reserveSlotData;
        // delete capacity reservations
        if (!_onlyValidate)
        {
            GanttData_WrkCtr::deleteCapacityProjForecastEmpl(_projForecastEmpl);
        }

        // create capacity slots to be reserved
        reserveSlotData = GanttData_WrkCtr::createJobCapacityReservations(_projForecastEmpl.SchedFromDate,
                                                                          _projForecastEmpl.SchedFromTime,
                                                                          _projForecastEmpl.SchedToDate,
                                                                          _projForecastEmpl.SchedToTime,
                                                                          _projForecastEmpl.SchedWrkCtrId);
        // reserve capacity
        if (reserveSlotData && !_onlyValidate)
        {
            GanttData_WrkCtr::insertJobCapacityReservations(reserveSlotData,
                                                            strfmt('%1', _projForecastEmpl.RecId),
                                                            RouteJobType::Process,
                                                            _projForecastEmpl.ProjId,
                                                            WrkCtrCapRefType::Project,
                                                            1,
                                                            RouteOprPriority::Primary,
                                                            _projForecastEmpl.SchedWrkCtrId,
                                                            _projForecastEmpl.activityRequirementSet().LoadPercent,
                                                            _reqPlanId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserveCapacityReqRouteJob</Name>
				<Source><![CDATA[
    protected static void reserveCapacityReqRouteJob(ReqRouteJob _reqRouteJob,
                                                            boolean     _onlyValidate = false)
    {
        WrkCtrSlotData  reserveSlotData;
        RouteOpr        routeOpr    = _reqRouteJob.reqRoute().refRouteOpr();
        // delete capacity reservations
        if (!_onlyValidate)
        {
            GanttData_WrkCtr::deleteCapacityReqRouteJob(_reqRouteJob);
        }

        // create capacity slots to be reserved
        reserveSlotData = GanttData_WrkCtr::createJobCapacityReservations(_reqRouteJob.FromDate,
                                                                          _reqRouteJob.FromTime,
                                                                          _reqRouteJob.ToDate,
                                                                          _reqRouteJob.ToTime,
                                                                          _reqRouteJob.WrkCtrId);

        // reserve capacity
        if (reserveSlotData && !_onlyValidate)
        {
            GanttData_WrkCtr::insertJobCapacityReservations(reserveSlotData,
                                                            int642str(_reqRouteJob.RecId),
                                                            _reqRouteJob.JobType,
                                                            _reqRouteJob.ReqPOId,
                                                            WrkCtrCapRefType::PlannedOrder,
                                                            _reqRouteJob.OprNum,
                                                            _reqRouteJob.OprPriority,
                                                            _reqRouteJob.WrkCtrId,
                                                            routeOpr.activityRequirementSet().LoadPercent,
                                                            ReqPlanVersion::find(_reqRouteJob.PlanVersion).ReqPlanId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOrigDataPlannedProd</Name>
				<Source><![CDATA[
    protected static void updateOrigDataPlannedProd(GanttTmpWrkCtrJob    _ganttTmpWrkCtrJob,
                                                           boolean              _onlyValidate       = false)
    {
        ReqRouteJob     reqRouteJob;
        ProdJobType     prodJobType;

        NoYes           scheduleCapacity;
        NoYes           scheduleWorkTime;

        ReqPO           reqPO;
        boolean         needToUpdateReqPO       = false;

        ReqRoute        reqRoute;
        boolean         needToUpdateReqRoute    = false;
        boolean         isGanttDataUpdateRawMaterialsWhenDateTimeChangeFlightEnabled = GanttDataUpdateRawMaterialsWhenDateTimeChangeFlight::instance().isEnabled();

        setprefix(strfmt("@SYS108495"   + ' %1', _ganttTmpWrkCtrJob.RefId));
        setprefix(strfmt("@SYS75245", _ganttTmpWrkCtrJob.WrkCtrId, _ganttTmpWrkCtrJob.OprNum, _ganttTmpWrkCtrJob.OprPriority, _ganttTmpWrkCtrJob.OprId));
        setprefix(strfmt("@SYS9942"     + ' %1', _ganttTmpWrkCtrJob.JobType));

        if (_ganttTmpWrkCtrJob.RefType != WrkCtrCapRefType::PlannedOrder)
        {
            throw error(strfmt("@SYS23264", funcname()));
        }

        // find planned production order
        reqPO = ReqPO::find(
            _ganttTmpWrkCtrJob.reqPlan().findActiveVersion().RecId,
            _ganttTmpWrkCtrJob.RefId,
            true);

        if (!reqPO.RecId)
        {
            throw error(strfmt("@SYS113076", _ganttTmpWrkCtrJob.RefId));
        }

        // find the current planned production operation
        reqRoute = ReqRoute::find(
                                  _ganttTmpWrkCtrJob.reqPlan().findActiveVersion().RecId,
                                  _ganttTmpWrkCtrJob.RefId,
                                  _ganttTmpWrkCtrJob.OprNum,
                                  _ganttTmpWrkCtrJob.OprPriority,
                                  true);

        if (!reqRoute.RecId)
        {
            throw error(strfmt("@SYS113077", _ganttTmpWrkCtrJob.OprNum, _ganttTmpWrkCtrJob.RefId));
        }

        // update planned production job

        reqRouteJob = ReqRouteJob::findRecId(str2recId(_ganttTmpWrkCtrJob.JobId), true);

        if (!reqRouteJob.RecId)
        {
            throw error(strfmt("@SYS113078", _ganttTmpWrkCtrJob.JobId, _ganttTmpWrkCtrJob.RefId));
        }

        reqRouteJob.FromDate   = _ganttTmpWrkCtrJob.SchedFromDate;
        reqRouteJob.FromTime   = _ganttTmpWrkCtrJob.SchedFromTime;
        reqRouteJob.ToDate     = _ganttTmpWrkCtrJob.SchedToDate;
        reqRouteJob.ToTime     = _ganttTmpWrkCtrJob.SchedToTime;

        reqRouteJob.WrkCtrId   = _ganttTmpWrkCtrJob.WrkCtrId;

        if (!_onlyValidate)
        {
            reqRouteJob.update();
        }

        // check the route group setup
        prodJobType = reqRouteJob.prodJobType();

        scheduleCapacity    = prodJobType.scheduleCapacity(reqRoute.routeGroup());
        scheduleWorkTime    = prodJobType.scheduleWorkTime(reqRoute.routeGroup());

        // if Capacity parameter is specified in the route group, then Work time parameter must also be specified
        if (scheduleCapacity && !scheduleWorkTime)
        {
            throw error("@SYS68284" + "@SYS68285" + '.');
        }

        // reserve work center's capacity
        if (scheduleCapacity)
        {
            GanttData_WrkCtr::reserveCapacityReqRouteJob(reqRouteJob, _onlyValidate);
        }
        else
        {
            // delete any existing capacity reservations
            if (!_onlyValidate)
            {
                GanttData_WrkCtr::deleteCapacityReqRouteJob(reqRouteJob);
            }
        }

        // if it is the first job in the operation
        if (reqRouteJob.RecId == ReqRouteJob::findFirstWithPriority(reqRouteJob.PlanVersion, reqRouteJob.ReqPOId, reqRouteJob.OprNum, reqRouteJob.OprPriority).RecId)
        {
            // change the start date on the operation
            reqRoute.FromDate   = _ganttTmpWrkCtrJob.SchedFromDate;
            reqRoute.FromTime   = _ganttTmpWrkCtrJob.SchedFromTime;

            needToUpdateReqRoute    = true;
        }

        // if it is the last job in the operation
        if (reqRouteJob.RecId == ReqRouteJob::findLastWithPriority(reqRouteJob.PlanVersion, reqRouteJob.ReqPOId, reqRouteJob.OprNum, reqRouteJob.OprPriority).RecId)
        {
            // change the finish date on the operation
            reqRoute.ToDate = _ganttTmpWrkCtrJob.SchedToDate;
            reqRoute.ToTime = _ganttTmpWrkCtrJob.SchedToTime;

            needToUpdateReqRoute    = true;
        }

        // if it is the first operation in the planned production order
        if (reqRoute.OprNum == ReqRoute::findFirst(reqRoute.PlanVersion, reqRoute.RefId).OprNum)
        {
            if (reqPO.SchedFromDate != reqRoute.FromDate ||
                !isGanttDataUpdateRawMaterialsWhenDateTimeChangeFlightEnabled)
            {        
                // change the start date on the planned production order only when scheduling start datetime is changed.
                reqPO.SchedFromDate = reqRoute.FromDate;

                needToUpdateReqPO   = true;
            }
        }

        // if it is the last operation in the planned production order
        if (reqRoute.OprNum == ReqRoute::findLast(reqRoute.PlanVersion, reqRoute.RefId).OprNum)
        {
            if (reqPO.SchedToDate != reqRoute.ToDate  ||
                !isGanttDataUpdateRawMaterialsWhenDateTimeChangeFlightEnabled)
            {        
                // change the end date on the planned production order only when scheduling start datetime is changed.
                reqPO.SchedToDate   = reqRoute.ToDate;

                needToUpdateReqPO   = true;
            }
        }

        if (!_onlyValidate)
        {
            if (needToUpdateReqRoute)
            {
                reqRoute.update();
            }

            if (needToUpdateReqPO)
            {
                reqPO.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOrigDataProd</Name>
				<Source><![CDATA[
    protected static void updateOrigDataProd(GanttTmpWrkCtrJob   _ganttTmpWrkCtrJob,
                                                    boolean             _onlyValidate       = false)
    {
        ProdRouteJob    prodRouteJob;
        ProdJobType     prodJobType;

        NoYes           scheduleCapacity;
        NoYes           scheduleWorkTime;

        ProdTable       prodTable;
        boolean         needToUpdateProdTable   = false;

        ProdRoute       prodRoute;
        boolean         needToUpdateProdRoute   = false;

        ProdParmScheduling  schedulingParameters;
        boolean         isGanttDataUpdateRawMaterialsWhenDateTimeChangeFlightEnabled = GanttDataUpdateRawMaterialsWhenDateTimeChangeFlight::instance().isEnabled();

        setprefix(strfmt("@SYS90210", _ganttTmpWrkCtrJob.RefId));
        setprefix(strfmt("@SYS75245", _ganttTmpWrkCtrJob.WrkCtrId, _ganttTmpWrkCtrJob.OprNum, _ganttTmpWrkCtrJob.OprPriority, _ganttTmpWrkCtrJob.OprId));
        setprefix(strfmt("@SYS9942"     + ' %1', _ganttTmpWrkCtrJob.JobType));
        setprefix(strfmt("@SYS22890"    + ' %1', _ganttTmpWrkCtrJob.JobId));

        if (_ganttTmpWrkCtrJob.RefType != WrkCtrCapRefType::Production)
        {
            throw error(strfmt("@SYS23264", funcname()));
        }

        // find production order
        prodTable = ProdTable::find(_ganttTmpWrkCtrJob.RefId, true);

        if (!prodTable.RecId)
        {
            throw error(strfmt(ProdTable::txtNotExist(), _ganttTmpWrkCtrJob.RefId));
        }

        // find the current production operation
        prodRoute = ProdRoute::find(_ganttTmpWrkCtrJob.RefId,
                                    _ganttTmpWrkCtrJob.OprNum,
                                    _ganttTmpWrkCtrJob.OprPriority,
                                    true);

        if (!prodRoute.RecId)
        {
            throw error(strfmt("@SYS113049", _ganttTmpWrkCtrJob.OprNum, _ganttTmpWrkCtrJob.RefId));
        }

        // update production job

        prodRouteJob = ProdRouteJob::findJobId(_ganttTmpWrkCtrJob.JobId, true);

        if (!prodRouteJob.RecId)
        {
            throw error(strfmt("@SYS113059", _ganttTmpWrkCtrJob.JobId, _ganttTmpWrkCtrJob.RefId));
        }

        prodRouteJob.FromDate   = _ganttTmpWrkCtrJob.SchedFromDate;
        prodRouteJob.FromTime   = _ganttTmpWrkCtrJob.SchedFromTime;
        prodRouteJob.ToDate     = _ganttTmpWrkCtrJob.SchedToDate;
        prodRouteJob.ToTime     = _ganttTmpWrkCtrJob.SchedToTime;

        prodRouteJob.WrkCtrId   = _ganttTmpWrkCtrJob.WrkCtrId;

        if (!_onlyValidate)
        {
            prodRouteJob.update();
        }

        // check the route group setup
        prodJobType = prodRouteJob.prodJobType();

        scheduleCapacity    = prodJobType.scheduleCapacity(prodRoute.routeGroup());
        scheduleWorkTime    = prodJobType.scheduleWorkTime(prodRoute.routeGroup());

        // if Capacity parameter is specified in the route group, then Work time parameter must also be specified
        if (scheduleCapacity && !scheduleWorkTime)
        {
            throw error("@SYS68284"+"@SYS68285" + '.');
        }

        // reserve work center's capacity
        if (scheduleCapacity)
        {
            GanttData_WrkCtr::reserveCapacityProdRouteJob(prodRouteJob, _ganttTmpWrkCtrJob.ReqPlanId, _onlyValidate);
        }
        else
        {
            // delete any existing capacity reservations
            if (!_onlyValidate)
            {
                GanttData_WrkCtr::deleteCapacityProdRouteJob(prodRouteJob, _ganttTmpWrkCtrJob.ReqPlanId);
            }
        }

        // check whether it is the first job in the operation
        if (prodRouteJob.RecId == ProdRouteJob::findFirst(_ganttTmpWrkCtrJob.RefId, prodRoute.OprNum, _ganttTmpWrkCtrJob.OprPriority).RecId)
        {
            // change the start date on the operation
            prodRoute.FromDate      = _ganttTmpWrkCtrJob.SchedFromDate;
            prodRoute.FromTime      = _ganttTmpWrkCtrJob.SchedFromTime;
            
            needToUpdateProdRoute   = true;
        }

        // check whether it is the last job in the operation
        if (prodRouteJob.RecId == ProdRouteJob::findLastWithPriority(_ganttTmpWrkCtrJob.RefId, prodRoute.OprNum, _ganttTmpWrkCtrJob.OprPriority).RecId)
        {
            // change the finish date on the operation
            prodRoute.ToDate        = _ganttTmpWrkCtrJob.SchedToDate;
            prodRoute.ToTime        = _ganttTmpWrkCtrJob.SchedToTime;
            
            needToUpdateProdRoute   = true;
        }

        // check whether it is the first operation in the production
        if (prodRoute.OprNum == ProdRoute::findFirst(prodRoute.ProdId).OprNum)
        {
            if (prodTable.SchedStart    != prodRoute.FromDate ||
                prodTable.SchedFromTime != prodRoute.FromTime ||
                !isGanttDataUpdateRawMaterialsWhenDateTimeChangeFlightEnabled)
            {
                // change the start date on the production order only when scheduling start datetime is changed.
                prodTable.SchedStart    = prodRoute.FromDate;
                prodTable.SchedFromTime = prodRoute.FromTime;

                needToUpdateProdTable   = true;
            }
        }

        // check whether it is the last operation in the production
        if (prodRoute.OprNum == ProdRoute::findLast(prodRoute.ProdId).OprNum)
        {
            if (prodTable.SchedEnd    != prodRoute.ToDate ||
                prodTable.SchedToTime != prodRoute.ToTime ||
                !isGanttDataUpdateRawMaterialsWhenDateTimeChangeFlightEnabled)
            {
                // change the finish date on the production order only when scheduling end datetime is changed.
                prodTable.SchedEnd      = prodRoute.ToDate;
                prodTable.SchedToTime   = prodRoute.ToTime;

                needToUpdateProdTable   = true;
            }
        }

        if (!_onlyValidate)
        {
            if (needToUpdateProdRoute)
            {
                prodRoute.update();
            }

            if (needToUpdateProdTable)
            {
                prodTable.update();

                // get the last posted job scheduling parameters
                schedulingParameters = ProdParmScheduling::findLast(prodTable.ProdId, ProdSchedMethod::JobScheduling);
                prodTable.updateRawMaterialDates(!schedulingParameters.SchedRef);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOrigDataProj</Name>
				<Source><![CDATA[
    protected static void updateOrigDataProj(GanttTmpWrkCtrJob   _ganttTmpWrkCtrJob,
                                                    boolean             _onlyValidate       = false)
    {
        ProjForecastEmpl    projForecastEmpl;

        ProjTable           projTable;
        boolean             needToUpdateProjTable   = false;
        setprefix(strfmt("@SYS4534"  + ' %1', _ganttTmpWrkCtrJob.RefId));
        setprefix(strfmt("@SYS75252", _ganttTmpWrkCtrJob.WrkCtrId));

        projForecastEmpl = ProjForecastEmpl::findRecId(str2int64(_ganttTmpWrkCtrJob.JobId), true);

        if (!projForecastEmpl.RecId)
        {
            throw error(strfmt("@SYS113080", _ganttTmpWrkCtrJob.JobId, tablepname(ProjForecastEmpl)));
        }

        setprefix(fieldpname(ProjForecastEmpl, TransId) + ': ' + projForecastEmpl.TransId);

        if (_ganttTmpWrkCtrJob.RefType != WrkCtrCapRefType::Project)
        {
            throw error(strfmt("@SYS23264", funcname()));
        }

        // find project
        projTable = ProjTable::find(_ganttTmpWrkCtrJob.RefId, true);

        if (!projTable.RecId)
        {
            throw error(strfmt("@SYS113076", _ganttTmpWrkCtrJob.RefId));
        }

        // update project hour forecast

        projForecastEmpl.SchedFromDate  = _ganttTmpWrkCtrJob.SchedFromDate;
        projForecastEmpl.SchedFromTime  = _ganttTmpWrkCtrJob.SchedFromTime;
        projForecastEmpl.SchedToDate    = _ganttTmpWrkCtrJob.SchedToDate;
        projForecastEmpl.SchedToTime    = _ganttTmpWrkCtrJob.SchedToTime;

        projForecastEmpl.SchedWrkCtrId  = _ganttTmpWrkCtrJob.WrkCtrId;

        if (!_onlyValidate)
        {
            projForecastEmpl.update();
        }

        // if Capacity parameter is specified, then Work time parameter must also be specified
        if (projForecastEmpl.SchedCapacity && !projForecastEmpl.SchedWorkTime)
        {
            throw error("@SYS68284" + "@SYS68285" + '.');
        }

        // reserve work center's capacity
        if (projForecastEmpl.SchedCapacity)
        {
            GanttData_WrkCtr::reserveCapacityProjForecastEmpl(projForecastEmpl, _ganttTmpWrkCtrJob.ReqPlanId, _onlyValidate);
        }
        else
        {
            // delete any existing capacity reservations
            if (!_onlyValidate)
            {
                GanttData_WrkCtr::deleteCapacityProjForecastEmpl(projForecastEmpl);
            }
        }

        // update of the project's start date is commented out in WrkCtrMasterData_Proj->update(), so it is here
        /*
        // if it is the first transaction in the project
        if (projForecastEmpl.RecId == ProjForecastEmpl::findFirst(projForecastEmpl.ProjId, projForecastEmpl.ModelId).RecId)
        {
            // change the start date on the project
            projTable.StartDate     = projForecastEmpl.SchedFromDate;

            needToUpdateProjTable   = true;
        }
        */

        // if it is the last transaction in the project
        if (!_onlyValidate)
        {
            if (projForecastEmpl.RecId == ProjForecastEmpl::findLast(projForecastEmpl.ProjId, projForecastEmpl.ModelId).RecId)
            {
                if (projTable.EndDate != dateNull() && projForecastEmpl.SchedToDate > projTable.EndDate)
                {
                    if (Box::yesNo("@SYS106796", DialogButton::Yes) == DialogButton::Yes)
                    {
                        // change the end date on the project
                        projTable.EndDate       = projForecastEmpl.SchedToDate;

                        needToUpdateProjTable   = true;
                    }
                }
            }
        }

        if (!_onlyValidate)
        {
            if (needToUpdateProjTable)
            {
                projTable.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>conSetLoadIds</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the set of Ids to load packed into a container.
    /// </summary>
    /// <returns>
    /// A <c>container</c> representing the set of Ids to load.
    /// </returns>
    protected container conSetLoadIds()
    {
        return this.parmGanttClient().parmSetLoadIds().pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLoadOnlySpecific</Name>
				<Source><![CDATA[
    public boolean parmLoadOnlySpecific(boolean _loadOnlySpecific = loadOnlySpecific)
    {
        loadOnlySpecific = _loadOnlySpecific;
        return loadOnlySpecific;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateColors</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the colors on all data.
    /// </summary>
    public void updateColors()
    {
        ganttTableWrkCtrJob.updateColorOnAll(this.parmGanttClient().parmGanttColor());
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadMaterialAvailbilityProd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads material availability information for a production order.
    /// </summary>
    /// <param name = "_prodTable">The production order record to load for.</param>
    /// <returns>A <c>Map</c> with the maximum material availability date per operation number.</returns>
    protected Map loadMaterialAvailbilityProd(ProdTable _prodTable)
    {
        RefRecId                    reqPlanVersionRefRecId = ReqPlanVersion::findActiveReqPlanIdDynamic().RecId;
        ProdBOM                     prodBOM;
        ReqTrans                    reqTrans;
        InventTransOriginProdBOM    inventTransOriginProdBOM;
        ProdRoute                   firstProdRoute;
        Map                         mapOperationMaterialDateTime = new Map(Types::Int64, Types::UtcDateTime);        
        RecordInsertList            ril = new RecordInsertList(tableNum(GanttTmpMaterials), false, false, false, false, false, ganttTmpMaterials);
        
        ganttTmpMaterials.clear();

        while select prodBOM
            where ProdBOM.ProdId == _prodTable.ProdId
            join inventTransOriginProdBOM
                where inventTransOriginProdBOM.ProdBOMDataAreaId    == prodBOM.DataAreaId
                   && inventTransOriginProdBOM.ProdBOMInventTransId == prodBOM.InventTransId
            outer join reqTrans
                where reqTrans.PlanVersion  == reqPlanVersionRefRecId
                   && reqTrans.RefType      == ReqRefType::ProdLine
                   && reqTrans.RefId        == _prodTable.ProdId
                   && reqTrans.InventTransOrigin == inventTransOriginProdBOM.InventTransOrigin
        {
            OprNum oprNum = prodBOM.OprNum;
            if (!oprNum)
            {
                // In case the OprNum is not explicitly set on the ProdBOM it must be defaulted.
                if (!firstProdRoute)
                {
                    firstProdRoute = ProdRoute::findFirst(prodBOM.ProdId);
                }
                oprNum = firstProdRoute.OprNum;
            }
            
            if (prodBOM.RecId != ganttTmpMaterials.RefRecId)
            {
                if (ganttTmpMaterials.RefRecId)
                {
                    ril.add(ganttTmpMaterials);                    
                    ganttTmpMaterials.clear();
                }

                ganttTmpMaterials.RefRecId = prodBOM.RecId;
                ganttTmpMaterials.RefId = _prodTable.ProdId;
                ganttTmpMaterials.RefType = WrkCtrCapRefType::Production;
                ganttTmpMaterials.OprNum = oprNum;
                ganttTmpMaterials.ItemId = prodBOM.ItemId;
                ganttTmpMaterials.InventDimId = prodBOM.InventDimId;
                ganttTmpMaterials.ReqQty = prodBOM.QtyBOMCalc;
                ganttTmpMaterials.DisplayProductNumber = InventTable::getProductNumberForItemDim(prodBOM.ItemId, prodBOM.inventDim());

                ganttTmpMaterials.AvailabilityDate = reqTrans.FuturesDate;
                ganttTmpMaterials.AvailabilityTime = reqTrans.FuturesTime;
            }
            else
            {
                // There can be multiple demand records per BOM line (in case that some part is reserved against onhand etc) so need to find the maximum
                // futuresDate/time per BOM line
                if (reqTrans.FuturesDate > ganttTmpMaterials.AvailabilityDate ||
                    (reqTrans.FuturesDate == ganttTmpMaterials.AvailabilityDate && reqTrans.FuturesTime == ganttTmpMaterials.AvailabilityTime))
                {
                    ganttTmpMaterials.AvailabilityDate = reqTrans.FuturesDate;
                    ganttTmpMaterials.AvailabilityTime = reqTrans.FuturesTime;
                }
            }
            
            // Determine the maximum futures date/time per operation
            utcdatetime futuresDateTime = DateTimeUtil::newDateTime(reqTrans.FuturesDate, reqTrans.FuturesTime, DateTimeUtil::getUserPreferredTimeZone());
            utcDateTime maxFuturesDateTime;
            if (mapOperationMaterialDateTime.exists(oprNum))
            {
                maxFuturesDateTime = mapOperationMaterialDateTime.lookup(oprNum);
            }
            if (futuresDateTime > maxFuturesDateTime)
            {
                mapOperationMaterialDateTime.insert(oprNum, futuresDateTime);
            }
        }

        if (ganttTmpMaterials.RefRecId)
        {
            ril.add(ganttTmpMaterials);
        }
        ril.insertDatabase();

        return mapOperationMaterialDateTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadMaterialAvailbilityPlannedProd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads material availability information for a planned production order.
    /// </summary>
    /// <param name = "_reqPO">The planned production order record to load for.</param>
    /// <returns>A <c>Map</c> with the maximum material availability date per operation number.</returns>
    protected Map loadMaterialAvailbilityPlannedProd(ReqPo _reqPO)
    {
        ReqTrans            reqTrans;                
        ReqRoute            firstReqRoute;
        Map                 mapOperationMaterialDateTime = new Map(Types::Int64, Types::UtcDateTime);
        RecordInsertList    ril = new RecordInsertList(tableNum(GanttTmpMaterials), false, false, false, false, false, ganttTmpMaterials);
                
        while select reqTrans
                where reqTrans.PlanVersion  == _reqPO.PlanVersion
                   && (reqTrans.RefType == ReqRefType::BOMLine || reqTrans.RefType == ReqRefType::PmfFormulaLine)
                   && reqTrans.RefId        == _reqPO.RefId
        {
            OprNum oprNum = reqTrans.OprNum;
            if (!oprNum)
            {
                // In case the OprNum is not explicitly set on the ReqTrans it must be defaulted.                
                if (!firstReqRoute)
                {
                    firstReqRoute = ReqRoute::findFirst(reqTrans.PlanVersion, reqTrans.RefId);
                }
                oprNum = firstReqRoute.OprNum;
            }            
            
            ganttTmpMaterials.clear();
            ganttTmpMaterials.RefId = reqTrans.RefId;
            ganttTmpMaterials.RefType = WrkCtrCapRefType::PlannedOrder;
            ganttTmpMaterials.OprNum = oprNum;
            ganttTmpMaterials.ItemId = reqTrans.ItemId;
            ganttTmpMaterials.InventDimId = reqTrans.CovInventDimId;
            ganttTmpMaterials.ReqQty = -1 * reqTrans.Qty;
            ganttTmpMaterials.DisplayProductNumber = InventTable::getProductNumberForItemDim(reqTrans.ItemId, reqTrans.inventDim());
            ganttTmpMaterials.AvailabilityDate = reqTrans.FuturesDate;
            ganttTmpMaterials.AvailabilityTime = reqTrans.FuturesTime;
            ril.add(ganttTmpMaterials);

            utcdatetime futuresDateTime = DateTimeUtil::newDateTime(reqTrans.FuturesDate, reqTrans.FuturesTime, DateTimeUtil::getUserPreferredTimeZone());
            utcDateTime maxFuturesDateTime;
            if (mapOperationMaterialDateTime.exists(oprNum))
            {
                maxFuturesDateTime = mapOperationMaterialDateTime.lookup(oprNum);
            }
            if (futuresDateTime > maxFuturesDateTime)
            {
                mapOperationMaterialDateTime.insert(oprNum, futuresDateTime);
            }
        }

        ril.insertDatabase();

        return mapOperationMaterialDateTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmGanttTmpMaterials</Name>
				<Source><![CDATA[
    public GanttTmpMaterials parmGanttTmpMaterials(GanttTmpMaterials _ganttTmpMaterials = ganttTmpMaterials)
    {
        ganttTmpMaterials = _ganttTmpMaterials;
        return ganttTmpMaterials;
    }

]]></Source>
			</Method>
			<Method>
				<Name>jobRequiresMaterials</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a job requires any materials.
    /// </summary>
    /// <param name = "_ganttTmpWrkCtrJob">The job to find materials for.</param>
    /// <returns>true if the job requires materials; otherwise, false.</returns>
    public boolean jobRequiresMaterials(GanttTmpWrkCtrJob _ganttTmpWrkCtrJob)
    {
        select firstonly RecId from ganttTmpMaterials
            where ganttTmpMaterials.RefType == _ganttTmpWrkCtrJob.RefType
               && ganttTmpMaterials.RefId == _ganttTmpWrkCtrJob.RefId
               && ganttTmpMaterials.OprNum == _ganttTmpWrkCtrJob.OprNum;
    
        return ganttTmpMaterials.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTmpWrkCtrIdLoaded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a temporary table containing the Ids of all the loaded resources.
    /// </summary>
    /// <returns>A temporary table containing the Ids of all the loaded resources.</returns>
    public WrkCtrTmpFilter getTmpWrkCtrIdLoaded()
    {
        if (!tmpWrkCtrIdLoaded)
        {
            SetEnumerator wrkCtrIdEnumerator = setLoadWrkCtrIds.getEnumerator();
            while (wrkCtrIdEnumerator.moveNext())
            {
                tmpWrkCtrIdLoaded.WrkCtrId = wrkCtrIdEnumerator.current();
                tmpWrkCtrIdLoaded.Insert();
            }
        }
        
        return tmpWrkCtrIdLoaded;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>