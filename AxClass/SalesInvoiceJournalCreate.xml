<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SalesInvoiceJournalCreate</Name>
	<SourceCode>
		<Declaration><![CDATA[
[DocumentStatusFactoryAttribute(DocumentStatus::Invoice)]
[DocumentStatusFactoryAttribute(DocumentStatus::FreeTextInvoice)]
class SalesInvoiceJournalCreate extends SalesInvoiceJournalCreateBase
{
    #ISOCountryRegionCodes

    SalesTable      salesTable;
    SalesLine       salesLine;
    SalesTotals     salesTotals;

    Map mapInventTransToOldQty;
    RecordInsertList recordListInvoicePricingCalculation;

    boolean isCountryRegionPL;
    RecordInsertList recordListPdsRebateCustInvoiceTrans;

    private SalesInstrumentationLogger instrumentationLogger;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addPricingCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Adds the attribute-based pricing information including the original sales price (unadjusted) from the specified sales order line to the customer invoice.
    /// </summary>
    /// <param name="_salesLine">
    ///     The sales line to set the associated attribute-based pricing information from.
    /// </param>
    protected void addPricingCalculation(SalesLine _salesLine)
    {
        PDSCustInvoiceTransPricingCalculation custInvoiceTransPricingCalculation;

        if (#PDSPotencyEnabled)
        {
            PDSSalesLinePricingCalculation salesLinePricingCalculation = salesLine.pdsSalesLinePricingCalculation();

            if (salesLinePricingCalculation.PriceCalculation)
            {
                custInvoiceTransPricingCalculation.PriceCalculation = salesLinePricingCalculation.PriceCalculation;
                custInvoiceTransPricingCalculation.CustInvoiceTrans = custInvoiceTrans.RecId;
                custInvoiceTransPricingCalculation.OriginalSalesPrice = salesLine.SalesPrice;
                recordListInvoicePricingCalculation.add(custInvoiceTransPricingCalculation);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allocateNumAndVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allocates a journal and a voucher number from the number sequences of a sales invoice.
    /// </summary>
    /// <returns>
    /// A <c>NumberSeq</c> object.
    /// </returns>
    protected NumberSeq allocateNumAndVoucher()
    {
        SalesParmLine tmpSalesParmLine;

        // <GMY>
        boolean isIsoMY = TaxGSTFeatureChecker_MY::isCountryRegionMY();
        // </GMY>

        if (isUnrealizedVATEnabled)
        {
            isDebitNote = this.isDebitNote();
            isNoneFormatWithRealizedVAT = this.isNoneFormatWithRealizedVAT();
        }

        // <GMY>
        if (isIsoMY)
        {
            isDebitNote_MY = this.isDebitNote_MY();
        }
        // </GMY>

        NumberSeq tmpNumberSeq = super();

        // Italian functionality of VAT books and VAT book sections
        if (MultipleTaxIdReportingHelper::isLegalEntityOrTaxInCountryRegion(
            this.parmTax(), [#isoIT], MultipleTaxIdScope::VATDeclaration))
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceIT00028, funcName());
            if (! TaxBookSection::checkTaxBookSection(tmpNumberSeq.parmNumberSequenceId(), this.updateDate()))
            {
                throw error("@SYS21533");
            }
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT]))
        {
            boolean isTaxIntegrationCheckTaxCodeFlightEnabled = TaxIntegrationCheckTaxCode_ITFlight::instance().isEnabled();
            if ((isTaxIntegrationCheckTaxCodeFlightEnabled
                    && !Tax::isTaxIntegrationEnabledForBusinessProcess(TaxIntegrationBusinessProcess::Sales))
                || (!isTaxIntegrationCheckTaxCodeFlightEnabled
                    && !TaxIntegrationUtils::isMultipleTaxIdEnabled()))
            {
                boolean allowBlankItemSalesTaxGroup = salesTable.isRetailSale() &&
                        FeatureStateProvider::IsFeatureEnabled(RetailAllowBlankItemSalesTaxGroupInInvoiceFlight_IT::instance());

                recordListSalesParmLine.first(tmpSalesParmLine);
            
                while (tmpSalesParmLine)
                {
                    SalesLine tmpSalesLine = this.getSalesLine(tmpSalesParmLine);
                
                    if (!allowBlankItemSalesTaxGroup || tmpSalesLine.TaxItemGroup)
                    {
                        if (! TaxGroupData::checkTaxGroups(tmpSalesLine.TaxGroup, tmpSalesLine.TaxItemGroup))
                        {
                            throw error("@SYS21533");
                        }
                    }
                    if (!recordListSalesParmLine.next(tmpSalesParmLine))
                    {
                        break;
                    }
                }
            }
        }

        if (BrazilParameters::isEnabled())
        {
            return this.postAllocateNumAndVoucher_BR(tmpNumberSeq);
        }

        return tmpNumberSeq;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcLineAmountExclTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the journal line amount excluded tax.
    /// </summary>
    /// <returns>
    /// The calculated line amount excluded tax.
    /// </returns>
    protected AmountCur calcLineAmountExclTax()
    {
        return salesLine.calcLineAmountExclTax(custInvoiceTrans.Qty, this.updateDate(), salesTotals.tax()) + salesTotals.lineAdjustment(salesLine.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcLineAmountTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the tax amount for a journal line.
    /// </summary>
    /// <returns>
    /// The tax amount for the journal line.
    /// </returns>
    protected AmountCur calcLineAmountTax()
    {
        return salesLine.calcLineAmount(custInvoiceTrans.Qty) - custInvoiceTrans.LineAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcLineDiscExclTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the discount amount excluded tax for a journal line.
    /// </summary>
    /// <returns>
    /// The discount amount excluded tax for the journal line.
    /// </returns>
    protected DiscAmount calcLineDiscExclTax()
    {
        return salesLine.calcLineDiscExclTax(custInvoiceTrans.Qty, this.updateDate(), salesTotals.tax());
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCatchWeightValue</Name>
				<Source><![CDATA[
    protected void calcCatchWeightValue(InventTableModule inventTableModuleInvent,
                                        SalesParmLine localSalesParmLine,
                                        SalesParmSubLine localSalesParmSubLine = null)
    {
        SalesQty salesQtyDelta;

        SalesLine localSalesLine = localSalesParmLine.salesLine(true);
        InventMov_Sales inventMovement = InventMov_Sales::newFromSalesLine(localSalesLine);

        // Transactions must be picked to get the correct weight
        PdsCatchWeightAutoPickingHelper::newSalesInvoice(
               localSalesParmLine,
               inventMovement,
               localSalesParmSubLine).pick();

        salesTable = localSalesParmLine.salesTable(true); // Might be updated by reservation and/or picking code.

        // Find the catch weight from the transactions
        InventQty qtyAssigned = this.getCatchWeight(inventMovement, localSalesParmLine, localSalesParmSubLine);

        if (qtyAssigned > 0
               && localSalesParmLine.InventNow != qtyAssigned)

        {
            // Update salesParmLine with new values for weight
            InventQty inventQtyDelta = qtyAssigned - localSalesParmLine.InventNow;
            localSalesLine = localSalesParmLine.salesLine();
            if (localSalesLine.SalesUnit == inventTableModuleInvent.UnitId)

            {
                // Same unit so update sales qty related field too
                salesQtyDelta = inventQtyDelta;
                localSalesParmLine.DeliverNow += salesQtyDelta;
                localSalesParmLine.RemainBefore = localSalesLine.RemainSalesFinancial;
                localSalesParmLine.RemainAfter -= salesQtyDelta;
            }
            else if (UnitOfMeasure::findBySymbol(localSalesLine.SalesUnit).UnitOfMeasureClass
                           == UnitOfMeasure::findBySymbol(inventTableModuleInvent.UnitId).UnitOfMeasureClass)

            {
                // Same unit class so update sales qty related field too, but convert to proper unit
                salesQtyDelta = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(localSalesLine.ItemId,
																									  localSalesLine.InventDimId,
																								      qtyAssigned,
																								      inventTableModuleInvent.UnitId,
																								      localSalesLine.SalesUnit,
																								      NoYes::No)
                 - localSalesParmLine.DeliverNow;

                localSalesParmLine.DeliverNow += salesQtyDelta;
                localSalesParmLine.RemainBefore = localSalesLine.RemainSalesFinancial;
                localSalesParmLine.RemainAfter -= salesQtyDelta;
            }
            localSalesParmLine.InventNow += inventQtyDelta;
            localSalesParmLine.RemainBeforeInvent = localSalesLine.RemainInventFinancial;
            localSalesParmLine.RemainAfterInvent -= inventQtyDelta;
            localSalesParmLine.update();
            recordListSalesParmLine = null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>check</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the journal can be created.
    /// </summary>
    /// <returns>
    /// true if the journal can be created; otherwise, false.
    /// </returns>
    protected boolean check()
    {
        boolean ok = super();

        if (!ok ||
            !this.checkPackingSlipDlvDate_IT())
        {
            ok = false;
        }

        if (ok)
        {
            if (TaxVATNumTable::isVATNumMandatory(CustParameters::find().MandatoryInvoiceVATNum, salesTable))
            {
                ok = checkFailed(strFmt("@SYS54450", salesTable.SalesId));
            }

            ok = ok && this.checkEInvoiceCust();

            ok = ok && PaymMoneyTransferSlip::checkPaymentSlip_DK(salesTable.GiroType, salesTable.CurrencyCode);

            if (isCountryRegionPL)
            {
                ok = ok && this.checkPKWiUCode();
            }

            this.checkCreditNoteReason();
            ok = ok && this.checkDocumentData_PL();

            if (isUnrealizedVATEnabled)
            {
                ok = ok && this.isSingleTaxType();
            }
        }

        if (ok 
            && this.salesTable
            && InterCompanyValidateInvoiceJourCreationAccessFlight::instance().isEnabled())
        {
            ok = this.salesTable.hasRightsPostInterCompanyPurchaseOrder();
        }

        ok = SalesInvoiceJournalCreate::checkDocumentDate_W(salesParmTable.DeliveryPostalAddress,
                                                                salesParmTable.DocumentDate,
                                                                salesParmTable.Transdate,
                                                                this.isInvoiceCreditNote(),
                                                                fieldPName(CustInvoiceJour, DocumentDate),
                                                                "@SYS57610") && ok;

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCreditNoteReason</Name>
				<Source><![CDATA[
    private void checkCreditNoteReason()
    {
        salesTable.checkCreditNoteReason();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createQueryForSalesLines_PL</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates the query to get sales lines during posting.
    /// </summary>
    /// <param name = "_salesParmTable">
    ///     The <c>SalesParmTable</c> to set the query ranges from
    /// </param>
    /// <returns><c>Query</c> object</returns>
    protected Query createQueryForSalesLines_PL(SalesParmTable _salesParmTable)
    {
        Query q;
        QueryBuildDataSource qbd;

        q = new Query();
        qbd = q.addDataSource(TableNum(SalesParmLine));
          
        QueryBuildRange qbr;
        qbr = qbd.addRange(FieldNum(SalesParmLine, TableRefId));
        qbr.value(queryValue(_salesParmTable.TableRefId));

        qbr = qbd.addRange(FieldNum(SalesParmLine, ParmId));
        qbr.value(queryValue(_salesParmTable.ParmId));

        return q;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDocumentData_PL</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks various attributes of a sales order invoice during posting.
    /// </summary>
    /// <returns>
    /// True if document is postable.
    /// </returns>
    final protected boolean checkDocumentData_PL()
    {
        #EECountryRegionCodes
        SalesParmTable salesParmTableLocal;

        boolean ret = true;
        boolean dateValidationEnabled = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAll) && isConfigurationkeyEnabled(configurationKeyNum(TradeDates_W));

        if (isCountryRegionPL || dateValidationEnabled)
        {            
            while select salesParmTableLocal
                where salesParmTableLocal.ParmId == salesParmTable.ParmId &&
                    salesParmTableLocal.TableRefId == salesParmTable.TableRefId
            {
                SalesTable salesTableLocal = salesParmTableLocal.salesTable();

                if (isCountryRegionPL)
                {                   
                    if (!salesParmTableLocal.DocumentDate)
                    {
                        ret = checkFailed(strFmt("@GLS110211",
                            salesParmTableLocal.SalesId,
                            fieldId2pname(tableNum(SalesParmTable), fieldNum(SalesParmTable, DocumentDate))));
                    }

                    boolean isCreditNote = salesTableLocal.isCreditNote_PL();

                    if (!isCreditNote &&
                        CustTable::find(salesParmTableLocal.CustAccount).MandatoryVatDate_PL &&
                        !salesParmTableLocal.VatDueDate_W)
                    {
                        ret = checkFailed(strFmt("@GLS220903",
                            salesParmTableLocal.SalesId));
                    }

                    if (!salesParmTableLocal.Transdate)
                    {
                        ret = checkFailed(strFmt("@GLS110211",
                            salesParmTableLocal.SalesId,
                            fieldId2pname(tableNum(SalesParmTable), fieldNum(SalesParmTable, Transdate))));
                    }

                    SalesParameters salesParameters = SalesParameters::find();
                    boolean isSkipCheckDocumentDate = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL])
                        && salesParameters.CreditNoteDocumentDateControlType_W == DateControlType_W::None
                        && salesParameters.DocumentDateControlType_W == DateControlType_W::None;

                    if (!isSkipCheckDocumentDate)
                    {
                        boolean isInvoiceCreditNote;

                        if (isCreditNote
                            && !this.isExistNoneCreditNoteLine_PL(salesParmTableLocal.SalesId))
                        {
                            isInvoiceCreditNote = true;
                        }
                        else
                        {
                            isInvoiceCreditNote = this.isInvoiceCreditNote();
                        }

                        ret = SalesInvoiceJournalCreate::checkDocumentDate_W(
                            salesParmTableLocal.DeliveryPostalAddress,
                            salesParmTableLocal.DocumentDate,
                            salesParmTableLocal.SalesDate_W,
                            isInvoiceCreditNote,
                            fieldPName(CustInvoiceTable, DocumentDate),
                            fieldPName(CustInvoiceTable, SalesDate_W)) && ret;
                    }

                    if (fiscalDocType == PlFiscalDocType::FiscalDocument &&
                        salesParmUpdate.Proforma)
                    {
                        ret = checkFailed("@GLS111788");
                    }

                    if (fiscalDocType == PlFiscalDocType::FiscalDocument &&
                        !salesTableLocal.InclTax)
                    {
                        ret = checkFailed("@GLS109942");
                    }
                }

                if (!salesParmTableLocal.SalesDate_W
                    && (isCountryRegionPL ||
                    (dateValidationEnabled && TaxGroupHeading::find(salesTableLocal.TaxGroup).MandatorySalesDate_W)))
                {
                    ret = checkFailed(strFmt("@GLS110211",
                        salesParmTableLocal.SalesId,
                        fieldId2pname(tableNum(SalesParmTable), fieldNum(SalesParmTable, SalesDate_W))));
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkEInvoiceCust</Name>
				<Source><![CDATA[
    protected boolean checkEInvoiceCust()
    {
        LogisticsPostalAddress deliveryAddress = salesTable.deliveryAddress();

        if (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])
            && CustTable::isCustDKPublic(salesTable.InvoiceAccount) == NoYes::Yes
            && !salesTable.ProjId)
        {
            if (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT])
                && !salesTable.contactPersonName())
            {
                warning(strFmt("@SYS26332", "@SYS100792"));
            }

            if (!deliveryAddress.Street)
            {
                warning(strFmt("@SYS26332", "@SYS23438"));
            }

            if (!deliveryAddress.ZipCode)
            {
                warning(strFmt("@SYS26332", "@SYS12463"));
            }

            if (!deliveryAddress.City)
            {
                warning(strFmt("@SYS26332", "@SYS22249"));
            }

            if (!deliveryAddress.CountryRegionId)
            {
                warning(strFmt("@SYS26332", "@SYS7437"));
            }

            if (!CompanyInfo::find().CoRegNum)
            {
                warning(strFmt("@SYS26332", "@SYS969"));
            }

            if (LogisticsAddressCountryRegion::find(deliveryAddress.CountryRegionId).isOcode)
            {
                if (strLen(LogisticsAddressCountryRegion::find(deliveryAddress.CountryRegionId).isOcode) != 2)
                {
                    warning(strFmt("@SYS101033", deliveryAddress.CountryRegionId));
                }
            }
            else
            {
                warning(strFmt("@SYS101034", deliveryAddress.CountryRegionId));
            }

            if (Currency::find(salesTable.CurrencyCode).CurrencyCodeISO)
            {
                if (strLen(Currency::find(salesTable.CurrencyCode).CurrencyCodeISO) != 3)
                {
                    warning(strFmt("@SYS344733", salesTable.CurrencyCode));
                }
            }
            else
            {
                warning(strFmt("@SYS101036", salesTable.CurrencyCode));
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPackingSlipDlvDate_IT</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether there are selected packing slips where the delivery date is later than the invoice
    ///    date.
    /// </summary>
    /// <returns>
    ///    false if the <c>salesParmUpdate.SpecQty</c> field equals the <c>SalesUpdate::PackingSlip</c> field,
    ///    the <c>CustParameters.PackingSlipDateCheck_IT</c> field is set to true, and all packing slips have
    ///    delivery dates later than or equal to the invoice date; otherwise, true.
    /// </returns>
    /// <remarks>
    ///    The check runs only when the <c>PackinSlip</c> field is selected and when the feature is in the
    ///    <c>CustParameters.PackingSlipDateCheck_IT</c> table. This is a country specific feature for Italy.
    /// </remarks>
    protected boolean checkPackingSlipDlvDate_IT()
    {
        GlobalizationInstrumentationHelper::featureRunByCountryRegionCodes(
                    [ [#isoIT, GlobalizationConstants::FeatureReferenceIT00005] ],
                    funcName()
                );

        SalesParmSubTable salesParmSubTable;
        CustPackingSlipJour custPackingSlipJour;

        boolean ok = true;

        if (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT])
            || salesParmUpdate.SpecQty != SalesUpdate::PackingSlip)
        {
            return ok;
        }

        while select PackingSlipId, DeliveryDate from custPackingSlipJour
            exists join salesParmSubTable
            where custPackingSlipJour.TableId == salesParmSubTable.JournalRefTableId
                && custPackingSlipJour.RecId == salesParmSubTable.JournalRefRecId
                && salesParmSubTable.ParmId == salesParmTable.ParmId
                && salesParmSubTable.TableRefId == salesParmTable.TableRefId
                && custPackingSlipJour.DeliveryDate > salesParmTable.Transdate
        {
            ok = checkFailed(strFmt("@SYS127005",
                                    custPackingSlipJour.PackingSlipId, /* %1 */
                                    custPackingSlipJour.DeliveryDate, /* %2 */
                                    salesParmTable.Transdate)); /* %3 */
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPKWiUCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the Infolog warnings or errors must be displayed to a user if the PKWiU code is
    /// missing from the sales order and free text invoice lines.
    /// </summary>
    /// <returns>
    /// true if no error messages are encountered and posting can continue; otherwise, false.
    /// </returns>
    protected boolean checkPKWiUCode()
    {
        boolean ok = true;
        boolean errorWarningFound;
        CustPKWiUErrorLevel pkwiuErrorLevel = CustParameters::find().pkWiUCodeRequirement;
        SalesParmLine salesParmLineCheck;
        PlPKWiUCode itemPKWiUCode, salesCategoryPKWiUCode;

        if (pkwiuErrorLevel == CustPKWiUErrorLevel::None)
        {
            return true;
        }

        // Otherwise the PKWiUCodeRequirement must be a Warning or Error
        // Go through each of the sales lines and determine if any of them will be missing a PKWiU code.
        // Keep a list of the ones that aren't setup correctly and display at the end
        recordListSalesParmLine.first(salesParmLineCheck);
        List list = new List(Types::Container);

        while (salesParmLineCheck)
        {
            SalesLine salesLineCheck = salesParmLineCheck.salesLine();
            itemPKWiUCode = InventTable::find(salesLineCheck.ItemId).pkWiUCode_PL;
            EcoResCategory ecoResCategory = EcoResCategory::find(salesLineCheck.SalesCategory);
            salesCategoryPKWiUCode = ecoResCategory.pkWiUCode;

            // If the PKWiU code does not exist on the Released Product or Category Hierarchy, add the line to the list
            if (!itemPKWiUCode && !salesCategoryPKWiUCode)
            {
                errorWarningFound = true;
                list.addEnd([salesLineCheck.ItemId, ecoResCategory.Name]);
            }

            if (!recordListSalesParmLine.next(salesParmLineCheck))
            {
                break;
            }
        }

        // If there are errors or warning messages to display
        if (errorWarningFound)
        {
            switch (pkwiuErrorLevel)
            {
                case CustPKWiUErrorLevel::Warning :
                    ok = true;
                    warning("@GLS220259");
                    break;
                case CustPKWiUErrorLevel::Error :
                    ok = false;
                    error("@GLS220259");
                    break;
            }

            // Display the error or warning lines in the infolog
            ListEnumerator listEnumerator = list.getEnumerator();
            while (listEnumerator.moveNext())
            {
                container conLines = listEnumerator.current();

                info(strFmt("@GLS220288", conPeek(conLines,1), conPeek(conLines,2)));
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAgreementLinks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the links between the invoice journal lines and the agreement lines.
    /// </summary>
    protected void createAgreementLinks()
    {
        AgreementLineReleasedLine agreementLineReleasedLineInsert;
        AgreementLineReleasedLine agreementLineReleasedLine;
        CustInvoiceTrans invoiceTrans;
        CustInvoiceJour invoiceJour = this.getJournal() as CustInvoiceJour;
        RefTableId refRelationType = tableNum(CustInvoiceTrans);

        insert_recordset agreementLineReleasedLineInsert (ReferenceRelationType, CustInvoiceTrans, AgreementLine)
            select refRelationType, RecId from invoiceTrans
                where // lines for the journal invoiceJour
                    invoiceTrans.InvoiceId == invoiceJour.InvoiceId
                    && invoiceTrans.SalesId == invoiceJour.SalesId
                    && invoiceTrans.InvoiceDate == invoiceJour.InvoiceDate
                    && invoiceTrans.numberSequenceGroup == invoiceJour.numberSequenceGroup
            join AgreementLine from agreementLineReleasedLine
                where invoiceTrans.InventTransId == agreementLineReleasedLine.SalesLineInventTransId
                    && invoiceTrans.DataAreaId == agreementLineReleasedLine.SalesLineDataAreaId
                    && agreementLineReleasedLine.ReferenceRelationType == tableNum(SalesLine)
                    && !agreementLineReleasedLine.IsDeleted;
        
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDiscardedJournalLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles a discarded journal line.
    /// </summary>
    /// <param name="_common">
    /// The record to base the journal line upon.
    /// </param>
    protected void createDiscardedJournalLine(Common _common)
    {
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoPL, #isoHU, #isoCZ, #isoLT, #isoLV, #isoEE]))
        {
            this.updateCredit_PL(_common);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the journal header for the sales invoice.
    /// </summary>
    protected void createJournalHeader()
    {
        CustInvoiceJourExtension_CN custInvoiceJourExtensionCN;

        super();

        if (CustParameters::isTaxIntegrationSystem_CN())
        {
            if (salesParmTable)
            {
                custInvoiceJourExtensionCN.insertFromSalesParmTable(salesParmTable.RecId, this.getJournal().RecId);
            }
        }

        if (isCountryRegionPL)
        {
            PlInventPackageTrans::updateFinancialFromTable(salesParmTable, custInvoiceJour);
        }

        if (SalesInvoiceJournalCreateAddLoggingFlight::instance().isEnabled())
        {
            this.instrumentationLogger().logInformation("Created CustInvoiceJour with recID : " + any2Str(this.getJournal().RecId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an invoice journal line.
    /// </summary>
    /// <param name="_salesParmLine">
    /// The <c>SalesParmLine</c> record for which to create the invoice journal line.
    /// </param>
    protected void createJournalLine(Common _salesParmLine)
    {
        // If the associated sales order contains attribute based pricing, set it now. This will affect the amounts recorded in CustInvoiceTrans.
        this.setPricingCalculation(_salesParmLine as SalesParmLine);

        super(_salesParmLine);

        // Add attribute-based pricing information, if any, to the customer invoice.
        this.addPricingCalculation(salesLine);

        if (salesTable.mcrIsCallCenter())
        {
            // Save the old qty before the write.
            if (MCRCustCreditTable::findByInventTransID(custInvoiceTrans.InventTransId))
            {
                mapInventTransToOldQty.insert(custInvoiceTrans.InventTransId, salesLine.invoicedInTotal());
            }
        }

        if (isCountryRegionPL)
        {
            this.postCreateJournalLinePackage(_salesParmLine);
        }

        // Create Rebate Specific CustInvoiceTrans
        if (this.allowCreatePdsCustInvoiceTrans())
        {
            this.createPdsCustInvoiceTrans();
        }

        if (SalesInvoiceJournalCreateAddLoggingFlight::instance().isEnabled())
        {
            this.instrumentationLogger().logInformation("Created CustInvoiceTrans with RecId : " + any2Str(custInvoiceTrans.RecId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowCreatePdsCustInvoiceTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the creation of rebate specific <c>CustInvoiceTrans</c>.
    /// </summary>
    /// <returns>
    /// true if rebate creation is allowed; otherwise, false.
    /// </returns>
    protected boolean allowCreatePdsCustInvoiceTrans()
    {
        return #PdsRebateEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the journal lines when updating the sales order, the purchase order, or the request for
    /// quote.
    /// </summary>
    protected void createJournalLines()
    {
        super();

        ttsbegin;
        if (foundRemains)
        {
            custInvoiceJour.Backorder = foundRemains;
            custInvoiceJour.update();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalLink</Name>
				<Source><![CDATA[
    protected void createJournalLink(Common _salesParmLine)
    {
        SalesParmLine salesParmLine = _salesParmLine as SalesParmLine;
        CustInvoiceSalesLink custInvoiceSalesLink;

        custInvoiceSalesLink.initFromSalesParmLine (salesParmLine);
        custInvoiceSalesLink.initFromSalesTable (SalesTable::find(salesParmLine.OrigSalesId));
        custInvoiceSalesLink.initFromCustInvoiceJour (custInvoiceJour);
        this.insertJournalLink(custInvoiceSalesLink);
    }

]]></Source>
			</Method>
			<Method>
				<Name>endCreate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes when a journal creation is finished.
    /// </summary>
    protected void endCreate()
    {
        CustInvoiceTrans     custInvoiceTransLoc;
        SalesParmLine salesParmLineLoc;
        #ISOCountryRegionCodes

        super();

        if (salesTable.mcrIsCallCenter())
        {
            this.mcrGenerateRemainingCredit();
        }

        this.mcrCopyNotes();

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            boolean isMatchedPackingSlipInquiryEnabled = TaxParameters::checkTaxParameters_IN()
                                                        && isConfigurationkeyEnabled(configurationKeyNum(LedgerBasic))
                                                        && CustParameters::find().MatchedPackingSlipsInquiry;

            if (isMatchedPackingSlipInquiryEnabled)
            {
                this.setCustInvoiceTransRef();
            }

            this.endCreateTrans_IN();
        }
        else if (CustFormletterParameters::find().PckSlpInfoOnInvoice)
        {
            this.setCustInvoiceTransRef();
        }

        if (isCountryRegionPL)
        {
            CustInvoiceJour_PL custInvoiceJour_PL = custInvoiceJour.custInvoiceJour_PL();
            custInvoiceJour_PL.FiscalDocState_PL = this.fiscalDocType2State_PL();
            custInvoiceJour.packCustInvoiceJour_PL(custInvoiceJour_PL);

            this.postEndCreateDomesticSalesTax_PL();
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            switch (custInvoiceJour.custInvoiceJour_RU().CustInvoicePrintoutType_RU)
            {
                case CustInvoicePrintoutType_RU::TORG_12 :
                    break;
                case CustInvoicePrintoutType_RU::M_15    :
                    PrintoutTableReports_RU::createInvoiceM15(custInvoiceJour);
                    break;
                default                                  :
                    throw error(Error::wrongUseOfFunction(funcName()));
            }
        }

        if (TaxIntegrationUtils::isTransitDocumentEnabled())
        {
            this.transitDocument();
        }

        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            TaxBusinessService::transferTaxDocument(salesParmTable, custInvoiceJour);
        }
        // </GTE>
        
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCustInvoiceTransRef</Name>
				<Source><![CDATA[
    private void setCustInvoiceTransRef()
    {
        CustInvoiceTrans custInvoiceTransLoc;
        SalesParmSubLine salesParmSubLineLoc;
        CustPackingSlipTrans custPackingSlipTransLoc;
        SalesParmLine salesParmLineLoc;

        ttsbegin;

        update_recordset custPackingSlipTransLoc
            setting InvoiceTransRefRecId = custInvoiceTransLoc.RecId
            join custPackingSlipTransLoc
                join JournalRefTableId, JournalRefRecId from salesParmSubLineLoc
                    where custPackingSlipTransLoc.TableId == salesParmSubLineLoc.JournalRefTableId
                        && custPackingSlipTransLoc.RecId == salesParmSubLineLoc.JournalRefRecId
                join RecId, ParmId, TableRefId from salesParmLineLoc
                    where salesParmSubLineLoc.LineRefRecId == salesParmLineLoc.RecId
                        && salesParmLineLoc.ParmId == salesParmTable.ParmId
                        && salesParmLineLoc.TableRefId == salesParmTable.TableRefId
                join custInvoiceTransLoc
                    where salesParmLineLoc.InventTransId == custInvoiceTransLoc.InventTransId
                        && custInvoiceTransLoc.InvoiceId == custInvoiceJour.InvoiceId
                        && custInvoiceTransLoc.SalesId == custInvoiceJour.SalesId
                        && custInvoiceTransLoc.InvoiceDate == custInvoiceJour.InvoiceDate
                        && custInvoiceTransLoc.NumberSequenceGroup == custInvoiceJour.NumberSequenceGroup;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>endCreateTrans_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ends the create trans procedure.
    /// </summary>
    protected void endCreateTrans_IN()
    {
        CustInvoiceTrans custInvoiceTransLoc;
        CustInvoiceTrans_IN custInvoiceTransLoc_IN;
        CustInvoiceTransTaxExtensionIN custInvoiceTransTaxExtensionIN;

        if (TaxParameters::isCustomsEnable_IN() && salesTable.CustomsExportOrder_IN)
        {
            while select RecId,InventTransId, Qty from custInvoiceTransLoc
                where custInvoiceTransLoc.InvoiceId == custInvoiceJour.InvoiceId &&
                      custInvoiceTransLoc.SalesId == custInvoiceJour.SalesId &&
                      custInvoiceTransLoc.InvoiceDate == custInvoiceJour.InvoiceDate &&
                      custInvoiceTransLoc.NumberSequenceGroup == custInvoiceJour.NumberSequenceGroup
                outer join AssessableValue_IN, CustomsTariffCodeTable_IN from custInvoiceTransLoc_IN
                    where custInvoiceTransLoc_IN.CustInvoiceTrans == custInvoiceTransLoc.RecId
            {
                EximCustInvoiceTrans_IN::insertEximCustInvoiceTrans(custInvoiceTransLoc.RecId,
                                                                    custInvoiceTransLoc.salesLine().RecId,
                                                                    custInvoiceTransLoc_IN.AssessableValue_IN,
                                                                    custInvoiceTransLoc_IN.CustomsTariffCodeTable_IN);
            }
        }
        while select RecId, InventTransId from custInvoiceTransLoc
            where custInvoiceTransLoc.InvoiceId == custInvoiceJour.InvoiceId
                && custInvoiceTransLoc.SalesId == custInvoiceJour.SalesId
                && custInvoiceTransLoc.InvoiceDate == custInvoiceJour.InvoiceDate
                && custInvoiceTransLoc.NumberSequenceGroup == custInvoiceJour.NumberSequenceGroup
        {
            custInvoiceTransTaxExtensionIN.TaxModelDocLineExtensionIN::initFromBaseTable(custInvoiceTransLoc);
            custInvoiceTransTaxExtensionIN.TaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(custInvoiceTransLoc.salesLine()).TaxInformation;
            custInvoiceTransTaxExtensionIN.insert();

            CustReturnReplacementTransHandler_IN::updateCustReturnTransReplacementTrans(custInvoiceTransLoc);

            SalesParmLine salesParmLineLoc = SalesParmLine::findByInventTransId_IN(
                salesParmTable.ParmId, salesParmTable.TableRefId, custInvoiceTransLoc.InventTransId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fiscalDocType2State_PL</Name>
				<Source><![CDATA[
    private PlFiscalDocState fiscalDocType2State_PL()
    {
        PlFiscalDocState ret;

        switch (fiscalDocType)
        {
            case PlFiscalDocType::Invoice :
                ret = PlFiscalDocState::Invoice;
                break;
            case PlFiscalDocType::FiscalDocument :
                ret = PlFiscalDocState::FiscalDocument;
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCatchWeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the catch weight picked for the specified line.
    /// </summary>
    /// <param name="_inventMovement">
    /// The inventory movement related to the line.
    /// </param>
    /// <param name="_localSalesParmLine">
    /// The line being processed.
    /// </param>
    /// <param name="_localSalesParmSubLine">
    /// The line being processed.
    /// </param>
    /// <returns>
    /// The weight for the catch weight quantity.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// Insufficient inventory transactions with the picked status.
    /// </exception>
    protected InventQty getCatchWeight(
        InventMov_Sales _inventMovement,
        SalesParmLine _localSalesParmLine,
        SalesParmSubLine _localSalesParmSubLine = null)
    {
        PdsCWInventQty cwQtyNotAssigned = _localSalesParmLine.PdsCWDeliverNow;

        PdsCatchWeightMovementQtyAdjustment pdsCatchWeightMovementQtyAdjustment = PdsCatchWeightMovementQtyAdjustment::newSalesInvoice(
            _inventMovement,
            _localSalesParmLine,
            _localSalesParmSubLine);

        InventQty qtyAssigned = pdsCatchWeightMovementQtyAdjustment.salesIssueQty(
            DocumentStatus::Invoice,
            cwQtyNotAssigned,
            _inventMovement.inventTableInvent().UnitId);

        if (!pdsCatchWeightMovementQtyAdjustment.isFullCatchWeightQuantityAssigned())
        {
            warning("@SCM:ItemFullCatchWeightQuantityNotAssigned");
            Info("@SCM:InventOrderPickingGeneralGuide");
            throw error(strFmt("@SYS54028",StatusIssue::Picked));
        }
        return qtyAssigned;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumAndVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets a journal and a voucher number.
    /// </summary>
    /// <returns>
    ///   A <c>Container</c> with a journal and voucher number.
    /// </returns>
    protected container getNumAndVoucher()
    {
        super();

        // If CustParameters.InvoiceEditing_W is enabled and SalesParmTable.Num_W has a value,
        // then the invoice number will be replaced by the Num_W entered by the user.
        if (salesParmTable.Num_W )
        {
            journalNumber = salesParmTable.Num_W;
        }

        return [journalNumber, voucher];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesLine</Name>
				<Source><![CDATA[
    protected SalesLine getSalesLine(SalesParmLine _salesParmLine,
                                      boolean _forUpdate = false)
    {
        SalesLine salesLineLocal = SalesLine::findRecId(_salesParmLine.SalesLineRecId,_forUpdate);

        if (! SalesTable::exist(salesLineLocal.SalesId))
            throw error("@SYS16740");

        return salesLineLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    protected void init()
    {
        SalesParmLine localSalesParmLine;
        SalesLine localSalesLine;

        super();

        mapInventTransToOldQty = new Map(Types::String, Types::Real);

        isCountryRegionPL = SysCountryRegionCode::isLegalEntityInCountryRegion([#IsoPL]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCatchWeightValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts inventory quantities for catch weight items which have been reserved or picked.
    /// </summary>
    /// <exception cref="M:Exception::Error">
    /// Insufficient inventory transactions with the picked status.
    /// </exception>
    protected void initCatchWeightValues()
    {
        SalesParmLine localSalesParmLine;
        InventTransOrigin inventTransOrigin;
        InventTableModule inventTableModuleInvent;

        #ISOCountryRegionCodes

        if (!#pdsCatchWeightEnabled)
        {
            // catch weight not enabled, so no need to try to select
            return;
        }
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

        while select forupdate localSalesParmLine
            where localSalesParmLine.ParmId == salesParmTable.ParmId
               && localSalesParmLine.TableRefId == salesParmTable.TableRefId
               && localSalesParmLine.PdsCWDeliverNow > 0 // only select lines with catch weight being issued
               && (!countryRegion_RU ||
                   localSalesParmLine.InventOwnerId_RU == salesParmTable.InventOwnerId_RU)
            join RecId from inventTransOrigin
                where inventTransOrigin.InventTransId == localSalesParmLine.InventTransId
            join UnitId from inventTableModuleInvent
                where inventTableModuleInvent.ItemId == localSalesParmLine.ItemId
                  && inventTableModuleInvent.ModuleType == ModuleInventPurchSales::Invent
        {
            if (!this.checkDiscardLine(localSalesParmLine))
            {
                setPrefix(localSalesParmLine.FormletterJournalTrans::getLinePrefix());

                List list = SalesParmSubLine::buildSalesParmSubLineList(localSalesParmLine.RecId);

                if (!list.empty())
                {
                    ListEnumerator le = list.getEnumerator();
                    while (le.moveNext())
                    {
                        SalesParmSubLine localSalesParmSubLine = le.current();

                        localSalesParmLine.DeliverNow = localSalesParmSubLine.DeliverNow;
                        localSalesParmLine.InventNow = localSalesParmSubLine.InventNow;
                        localSalesParmLine.PdsCWDeliverNow = localSalesParmSubLine.PdsCWDeliverNow;

                        this.calcCatchWeightValue(inventTableModuleInvent, localSalesParmLine, localSalesParmSubLine);
                    }
                }
                else
                {
                    this.calcCatchWeightValue(inventTableModuleInvent, localSalesParmLine);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustInvoiceTrans</Name>
				<Source><![CDATA[
    protected void initCustInvoiceTrans()
    {
        super();

        //If the salesline is from a dropshipment the vendors country or region must be stored to determine Intrastat reporting

        if (salesLine.DeliveryType == TradeLineDlvType::DropShip)
        {
            //if the salesLine is not linked to a different purchase the Vendor country or region need not be found again
            if ( (vendInvoiceJour && vendInvoiceJour.PurchId == salesLine.InventRefId)
               ||(vendPackingSlipJour && vendPackingSlipJour.PurchId == salesLine.InventRefId))
            {
                custInvoiceTrans.CountryRegionOfShipment = vendCountryRegionId;
                custInvoiceTrans.StateOfShipment = vendStateId;
            }
            else //Either a vendInvoiceJour or VendPackingSlipJour will exist for a dropshipment salesline being invoiced
            {
                vendInvoiceJour = VendInvoiceJour::findFromPurchId(salesLine.InventRefId);

                if (vendInvoiceJour)
                {
                    LogisticsPostalAddress postalAddress = VendTable::find(vendInvoiceJour.OrderAccount).postalAddress();
                    vendCountryRegionId = postalAddress.CountryRegionId;
                    vendStateId = postalAddress.State;
                    custInvoiceTrans.CountryRegionOfShipment = vendCountryRegionId;
                    custInvoiceTrans.StateOfShipment = vendStateId;
                }
                else
                {
                    vendPackingSlipJour = VendPackingSlipJour::findFromPurchId(salesLine.InventRefId);

                    if (vendPackingSlipJour)
                    {
                        LogisticsPostalAddress postalAddress = VendTable::find(vendPackingSlipJour.OrderAccount).postalAddress();
                        vendCountryRegionId = postalAddress.CountryRegionId;
                        vendStateId = postalAddress.State;
                        custInvoiceTrans.CountryRegionOfShipment = vendCountryRegionId;
                        custInvoiceTrans.StateOfShipment = vendStateId;
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromForeignTradeCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes an invoice journal line by using foreign trade information for the category based lines.
    /// </summary>
    protected void initFromForeignTradeCategory()
    {
        custInvoiceTrans.initFromSalesLineForeignTradeCategory(SalesLineForeignTradeCategory::findSalesLine(salesLine));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInvoiceHeaderFromSourceTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes an invoice journal header from the source table.
    /// </summary>
    protected void initInvoiceHeaderFromSourceTable()
    {
        custInvoiceJour.initFromSalesTable(salesTable, salesParmTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInvoiceLineFromSourceLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes an invoice journal line from the source line.
    /// </summary>
    /// <param name="_salesParmLine">
    /// The <c>SalesParmLine</c> record from which the invoice journal line is created.
    /// </param>
    protected void initInvoiceLineFromSourceLine(SalesParmLine _salesParmLine)
    {
        Label label = new Label(custInvoiceJour.LanguageId);

        salesLine = _salesParmLine.salesLine();

        InventQualityManagementBlockHandler::blockSalesInvoice(salesLine);

        custInvoiceTrans.initFromSalesLine(salesLine,_salesParmLine);

        SalesTable salesTableFromParmLine = salesLine.salesTable();
        custInvoiceTrans.LineHeader = label.extractString(literalStr("@SYS9694")) + ' ' + this.invoiceLineHeaderSalesId() + ' '
                                    + label.extractString(literalStr("@SYS24704")) + ' ' + salesTableFromParmLine.CustAccount + ' '
                                    + (!this.splitDeliveryInformation() ? (label.extractString(literalStr("@SYS7924")) + ' ' + salesLine.deliveryAddress().Address + ' ') : '')
                                    + (salesTableFromParmLine.PurchOrderFormNum ? (label.extractString(literalStr("@SYS9452")) + ' ' + salesTableFromParmLine.PurchOrderFormNum + ' ') : '')
                                    + custInvoiceTrans.LineHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceLineHeaderSalesId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>SalesId</c> that to be printed on the invoice journal line.
    /// </summary>
    /// <returns>
    /// A <c>SalesId</c>.
    /// </returns>
    protected SalesId invoiceLineHeaderSalesId()
    {
        return salesLine.SalesId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initJournalHeader</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Instantiates the <c>CustInvoice</c> journal record.
    /// </summary>
    protected void initJournalHeader()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRecordList</Name>
				<Source><![CDATA[
    protected void initRecordList()
    {
        super();

        recordListInvoicePricingCalculation = new RecordInsertList(tableNum(PDSCustInvoiceTransPricingCalculation));

        if (#PdsRebateEnabled)
        {
            recordListPdsRebateCustInvoiceTrans = new RecordInsertList(tableNum(PdsRebateCustInvoiceTrans));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSourceTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the source table record.
    /// </summary>
    protected void initSourceTable()
    {
        salesTable = salesParmTable.salesTable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the total calculation.
    /// </summary>
    protected void initTotals()
    {
        this.initCatchWeightValues();
        salesTotals = SalesTotals::construct(salesParmTable, salesParmUpdate.SpecQty, salesParmUpdate.SumBy, salesParmUpdate.ParmId, salesParmUpdate.SumSalesId, documentStatus);
        
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            // calculate positive and negative lines separately,
            // to create separate general journal transactions for
            // correcting and normal transactions later
            salesTotals.parmCalculateTotalsBySigns_RU(true);
        }

        salesTotals.prepareTotalAmountCalculation();
        salesTotals.prepareQuantitiesCalculation();

        salesTotals.parmGoodsInRouteId_RU(salesParmTable.GoodsInRouteId_RU);
        salesTotals.parmSalesInvoicePostingType_RU(salesParmTable.InvoicePostingType_RU);
        salesTotals.fillRecordSortedListLine();
        recordListSalesParmLine = salesTotals.recordSortedListLine();
        if (TaxIntegrationUtils::isMultipleTaxIdEnabledForBusinessProcess(TaxIntegrationBusinessProcess::Sales))
        {
            this.parmTax(salesTotals.tax());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertRecordList</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts records in the record lists into the database.
    /// </summary>
    protected void insertRecordList()
    {
        ttsbegin;

        if (recordListInvoicePricingCalculation)
        {
            recordListInvoicePricingCalculation.insertDatabase();
        }

        ttscommit;

        super();

        WHSJourLoadLine::insertJourLoadLines(custInvoiceJour, this.isInvoiceCreditNote());

        if (#PdsRebateEnabled)
        {
            recordListPdsRebateCustInvoiceTrans.insertDatabase();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransIdReturn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the return lot ID from the order line.
    /// </summary>
    /// <returns>
    /// A return lot ID.
    /// </returns>
    protected InventTransIdReturn inventTransIdReturn()
    {
        return salesLine.InventTransIdReturn;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isConfigkeyEnabledShipCarrier</Name>
				<Source><![CDATA[
    protected boolean isConfigkeyEnabledShipCarrier()
    {
        return Global::isConfigurationkeyEnabled(configurationKeyNum(ShipCarrier));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDebitNote</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether current sales invoice is debit note format.
    /// </summary>
    /// <returns>
    ///     Returns true if sales invoice is debit note format. Otherwise, returns false.
    /// </returns>
    private boolean isDebitNote()
    {
        SalesTableExtensionTH salesTableExtensionTH = salesTable.salesTableExtensionTH();
        return (salesTableExtensionTH.NoteFormat == TaxUnrealizedSalesNoteFormat::DebitNoteQuantity
            || salesTableExtensionTH.NoteFormat == TaxUnrealizedSalesNoteFormat::DebitNoteValue);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInvoiceCreditNote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the invoice that is being created is a credit note.
    /// </summary>
    /// <returns>
    /// true if invoice that is being created is a credit note; otherwise, false.
    /// </returns>
    protected boolean isInvoiceCreditNote()
    {
        return salesTotals.isCreditNote();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isJournalLinePartDelivery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a journal line is a part delivery.
    /// </summary>
    /// <returns>
    /// true if the journal line is a part delivery; otherwise, false.
    /// </returns>
    protected NoYes isJournalLinePartDelivery()
    {
        return !(salesLine.SalesStatus == SalesStatus::Invoiced
            && salesLine.SalesQty == custInvoiceTrans.Qty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNoneFormatWithRealizedVAT</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether current sales invoice is NONE format and with realized VAT.
    /// </summary>
    /// <returns>
    ///     Returns true if sales invoice is NONE format and with realized VAT. Otherwise, returns false.
    /// </returns>
    private boolean isNoneFormatWithRealizedVAT()
    {
        return (salesTable.salesTableExtensionTH().NoteFormat == TaxUnrealizedSalesNoteFormat::None
            && isRealizedVAT);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSingleTaxType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether only either realized VAT or unrealized VAT exists in current posting invoice.
    /// </summary>
    /// <returns>
    ///     Returns false if both realized and unrealized VAT exist. Otherwise, returns true.
    /// </returns>
    private boolean isSingleTaxType()
    {
        TaxTable taxTableRealized;
        TaxTable taxTableUnrealized;
        TaxGroupData taxGroupData;
        TaxOnItem taxOnItem;
        SalesParmLine salesParmLineLocal;
        SalesLine salesLineLocal;
        boolean ret = true;

        // Tries to find realized tax.
        select firstonly TaxCode from taxTableRealized
            where (taxTableRealized.TaxType_TH == TaxType_TH::Normal
                && taxTableRealized.PaymentTaxCode == '')
                || taxTableRealized.TaxType_TH == TaxType_TH::AverageRealized
            exists join taxGroupData
                where taxTableRealized.TaxCode == taxGroupData.TaxCode
            exists join taxOnItem
                where taxTableRealized.TaxCode == taxOnItem.TaxCode
            exists join salesParmLineLocal
                where salesParmLineLocal.ParmId == salesParmTable.ParmId
                    && salesParmLineLocal.TableRefId == salesParmTable.TableRefId
            exists join salesLineLocal
                where taxGroupData.TaxGroup == salesLineLocal.TaxGroup
                    && taxOnItem.TaxItemGroup == salesLineLocal.TaxItemGroup
                    && salesLineLocal.RecId == salesParmLineLocal.SalesLineRecId;
        if (taxTableRealized)
        {
            isRealizedVAT = true;
        }

        select firstonly TaxCode from taxTableUnrealized
            where (taxTableUnrealized.TaxType_TH == TaxType_TH::Normal
                && taxTableUnrealized.PaymentTaxCode != '')
                || taxTableUnrealized.TaxType_TH == TaxType_TH::AverageUnrealized
            exists join taxGroupData
                where taxTableUnrealized.TaxCode == taxGroupData.TaxCode
            exists join taxOnItem
                where taxTableUnrealized.TaxCode == taxOnItem.TaxCode
            exists join salesParmLineLocal
                where salesParmLineLocal.ParmId == salesParmTable.ParmId
                    && salesParmLineLocal.TableRefId == salesParmTable.TableRefId
            exists join salesLineLocal
                where taxGroupData.TaxGroup == salesLineLocal.TaxGroup
                    && taxOnItem.TaxItemGroup == salesLineLocal.TaxItemGroup
                    && salesLineLocal.RecId == salesParmLineLocal.SalesLineRecId;

        if (taxTableRealized && taxTableUnrealized)
        {
            // Both realized VAT and unrealized VAT exist in current posting invoice.
            ret = checkFailed("@SYS4082809");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>linksTableId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the table ID for the journal link table.
    /// </summary>
    /// <returns>
    /// The table ID for the journal link table.
    /// </returns>
    protected TableId linksTableId()
    {
        return tableNum(CustInvoiceSalesLink);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrCopyNotes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies notes from the <c>SalesLine</c> record to invoice line record.
    /// </summary>
    private void mcrCopyNotes()
    {
        List listLineLocal = this.getJournalLines();
        ListEnumerator listEnumerator = listLineLocal.getEnumerator();

        while (listEnumerator.moveNext())
        {
            Common common = listEnumerator.current();
            if (common.TableId == tableNum(CustInvoiceTrans))
            {
                CustInvoiceTrans custInvoiceTransLocal = common as CustInvoiceTrans;
                salesLine salesLineLocal = custInvoiceTransLocal.salesLine();

                // If the line type is child, copy the parent's order notes to the custPickingListTrans.
                if (salesLine.LineDeliveryType == LineDeliveryType::DeliveryLine)
                {
                    Docu::copy(SalesDeliverySchedule::findOrderLineForDeliveryLine(salesLine.InventTransId), custInvoiceTransLocal);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrGenerateRemainingCredit</Name>
				<Source><![CDATA[
    private void mcrGenerateRemainingCredit()
    {
        MapEnumerator mapEnumerator = mapInventTransToOldQty.getEnumerator();
        while (mapEnumerator.moveNext())
        {
            InventTransId inventTransId = mapEnumerator.currentKey();
            Qty oldQty = mapEnumerator.currentValue();
            MCRCustCreditTable::generateRemainingCredit(inventTransId, oldQty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>noLinesForPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs actions when there are no lines selected for posting.
    /// </summary>
    /// <param name="_throwError">
    /// true if the error message will be thrown as an exception; otherwise, false.
    /// </param>
    /// <remarks>
    /// This method informs the user that there are no lines selected for posting.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    /// Posting has been canceled.
    /// </exception>
    protected void noLinesForPosting(boolean _throwError = false)
    {
        //Invoices should always throw the exception so that the service runs its code to handle errors and job status updated correctly in the invoice history.
        super(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberSequenceGroupId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the number sequence group ID from the order header.
    /// </summary>
    /// <returns>
    /// A number sequence group ID.
    /// </returns>
    protected NumberSequenceGroupId numberSequenceGroupId()
    {
        NumberSequenceGroupId numSeqGroupId;
        if (TaxIntegrationUtils::isMultipleTaxIdAllowedWithinOneSalesOrder())
        {
            numSeqGroupId = TaxIntegrationTaxIdUtility::getNumberSequenceGroupIdByTaxId(salesParmTable.TaxId);
        }
        return numSeqGroupId ? numSeqGroupId : salesTable.NumberSequenceGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onlyServiceItemsToInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the only products of type service are invoiced.
    /// </summary>
    /// <returns>
    /// true if the only products of type service are invoiced; otherwise, false.
    /// </returns>
    protected boolean onlyServiceItemsToInvoice()
    {
        SalesLine salesLineLoc;
        boolean onlyServiceItem = true;
        InventTable inventTable;

        select firstonly RecId from salesLineLoc
                 exists join inventTable
                       where salesLineLoc.SalesId == salesTable.SalesId
                       && salesLineLoc.ItemId == inventTable.ItemId
                       && inventTable.ItemType != ItemType::Service;

        if (salesLineLoc.RecId)
        {
            onlyServiceItem = false;
        }
        return onlyServiceItem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInterCompanyFormletterContract</Name>
				<Source><![CDATA[
    public FormLetterContract parmInterCompanyFormletterContract(FormLetterContract _interCompanyFormletterContract = interCompanyFormletterContract)
    {
        interCompanyFormletterContract = _interCompanyFormletterContract as SalesFormLetterInvoiceContract;
        return interCompanyFormletterContract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postAllocateNumAndVoucher_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes the Brazilian localization logic after the <c>allocateNumAndVoucher</c> method.
    /// </summary>
    /// <param name="_returnValue">
    /// The main method <c>NumberSeq</c> object.
    /// </param>
    /// <returns>
    /// A <c>NumberSeq</c> object.
    /// </returns>
    protected NumberSeq postAllocateNumAndVoucher_BR(NumberSeq _returnValue = null)
    {
        NumberSeq tmpNumberSeq = _returnValue;

        if (this.isInvoiceCreditNote()
            && salesTable.ReturnStatus == ReturnStatusHeader::None
            || this.isMCRGiftCardSalesParmTable_BR())
        {
            return _returnValue;
        }

        if (salesTable.isCancellingSalesReturn_BR())
        {
            // When cancelling a sales return, uses the credit note number sequence
            tmpNumberSeq = NumberSeq::newGetNumAndVoucher(SalesParameters::numRefSalesCreditNoteId(),
                                                          SalesParameters::numRefSalesCreditNoteVoucher());
        }
        else
        {
            if (salesTable.hasIssueFiscalDocument_BR())
            {
                if (!salesParmTable.FiscalDocumentType_BR)
                {
                    throw error("@GLS62");
                }

                NumberSequenceTable numberSequenceTableNum = FiscalDocumentType_BR::getFiscalDocumentNumberSequence(salesParmTable.FiscalDocumentType_BR);

                tmpNumberSeq.parmNumberSequenceId(numberSequenceTableNum.RecId);
                tmpNumberSeq.parmNumberSequenceCode(numberSequenceTableNum.NumberSequence);
                tmpNumberSeq.parmNumTableNum(numberSequenceTableNum);
            }
        }

        return tmpNumberSeq;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCreateJournalLinePackage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates and creates the package lines for an invoice line.
    /// </summary>
    /// <param name="_salesParmLine">
    /// The parameter line that is an origin for invoice line.
    /// </param>
    /// <remarks>
    /// This method is the post event handler for the <c>createJournalHeader</c> method.
    /// </remarks>
    protected void postCreateJournalLinePackage(SalesParmLine _salesParmLine)
    {
        if (custInvoiceTrans.Qty != 0)
        {
            PlInventPackageTrans::updateFinancial(_salesParmLine, custInvoiceTrans, this.proforma());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postEndCreateDomesticSalesTax_PL</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post event handler for the <c>endCreate</c> method to calculate and create domestic VAT for export sales.
    /// </summary>
    protected void postEndCreateDomesticSalesTax_PL()
    {
        CustInvoiceTrans localCustInvoiceTrans;
        ExportSalesInvoice exportSalesInvoice;
        SalesParameters salesParameter;
        ExportSalesInvoiceLineDomesticTaxGroup exportSalesInvoiceLineDomesticTaxGroup;

        insert_recordset exportSalesInvoiceLineDomesticTaxGroup (CustInvoiceTrans, exportSalesInvoice, DomesticSalesTaxGroup)
            select RecId from localCustInvoiceTrans
                    where localCustInvoiceTrans.SalesId == custInvoiceJour.SalesId &&
                        localCustInvoiceTrans.InvoiceId == custInvoiceJour.InvoiceId &&
                        localCustInvoiceTrans.InvoiceDate == custInvoiceJour.InvoiceDate &&
                        localCustInvoiceTrans.NumberSequenceGroup == custInvoiceJour.NumberSequenceGroup
                join RecId from exportSalesInvoice
                    where exportSalesInvoice.CustInvoiceJour == custInvoiceJour.RecId
                join DomesticSalesTaxGroup_PL from salesParameter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordListParmLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a <c>RecordSortedList</c> object that has all posting parameter line records.
    /// </summary>
    /// <returns>
    /// A <c>RecordSortedList</c> object.
    /// </returns>
    protected RecordSortedList recordListParmLine()
    {
        return salesTotals.recordSortedListLine();
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a journal.
    /// </summary>
    public void run()
    {
        isUnrealizedVATEnabled = TaxThaiGovCertificationFeatureChecker::isUnrealizedVATEnabled();

        salesParmTable.researchSalesOrderAutoCharges();

        if (SalesInvoiceJournalCreateAddLoggingFlight::instance().isEnabled())
        {                                             
            using (var activityContext = this.instrumentationLogger().salesFormLetterActivities().invoiceSingleOrder())
            {                       
                SalesTableRefRecId salesTableRefRecId = salesParmTable.salesTable().RecId;
                instrumentationLogger.logInformation("Sales Order with RecId " + any2Str(salesTableRefRecId) + " journal creation started");
                activityContext.addCustomProperty('salesOrderRecId', any2Str(salesTableRefRecId));
        
                super();
            }
        }
        else
        {
            super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDeliveryFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set the delivery fields for an invoice.
    /// </summary>
    /// <remarks>
    /// This method is used when the journal header is created.
    /// </remarks>
    protected void setDeliveryFields()
    {
        SalesParmLine salesParmLine;

        select firstonly salesParmLine
            where salesParmLine.ParmId == salesParmTable.ParmId
            && salesParmLine.TableRefId == salesParmTable.TableRefId;

        SalesLine localSalesLine = salesParmLine.salesLine();

        if (salesParmTable.DeliveryPostalAddress)
        {
            custInvoiceJour.DeliveryPostalAddress = salesParmTable.DeliveryPostalAddress;
        }
        else if (salesLine.DeliveryPostalAddress)
        {
            custInvoiceJour.DeliveryPostalAddress = localSalesLine.DeliveryPostalAddress;
        }
        else
        {
            SalesTable localSalesTable = salesLine.salesTable();
            if (localSalesTable.DeliveryPostalAddress)
            {
                custInvoiceJour.DeliveryPostalAddress = localSalesTable.DeliveryPostalAddress;
            }
        }

        custInvoiceJour.DeliveryName = salesParmTable.DeliveryName ? salesParmTable.DeliveryName
                                                                           : localSalesLine.defaultDeliveryName();
        custInvoiceJour.DlvMode = salesParmTable.DlvMode ? salesParmTable.DlvMode
                                                                           : (localSalesLine.DlvMode ? localSalesLine.DlvMode : localSalesLine.salesTable().DlvMode);

        custInvoiceJour.PrintMgmtSiteId = salesParmTable.InventSiteId ? salesParmTable.InventSiteId : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPricingCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets the sales pricing calculation associated with the specified sales parameter line permanently.
    /// </summary>
    /// <param name="_salesParmLine">
    ///     The sales parameter line to set the associated sales pricing calculation from.
    /// </param>
    /// <remarks>
    ///     If the associated sales order from the specified sales parameter line contains attribute based pricing, then the adjusted unit price for the sales order is calculated and made
    ///     permanent. This will affect the amounts on the invoice to be based on the adjusted unit amounts and not on the amounts on the sales order.
    /// </remarks>
    protected void setPricingCalculation(SalesParmLine _salesParmLine)
    {
        if (#PDSPotencyEnabled)
        {
            PDSSalesLinePricingCalculation salesLinePricingCalculation = _salesParmLine.salesLine().pdsSalesLinePricingCalculation();

            if (salesLinePricingCalculation.PriceCalculation)
            {
                ttsBegin;

                // Make the pricing calculation permanent. This will override the original unit price and net amount on the sales order.
                salesLinePricingCalculation.selectForUpdate(true);
                salesLinePricingCalculation.calculatePrice();
                salesLinePricingCalculation.update();

                ttsCommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the source table for the journal.
    /// </summary>
    /// <returns>
    /// A record.
    /// </returns>
    protected Common sourceTable()
    {
        return salesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total object.
    /// </summary>
    /// <returns>
    /// A total object.
    /// </returns>
    protected Object totals()
    {
        return salesTotals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCredit_PL</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a zero <c>CustInvoiceTrans</c> record if posting a Polish return.
    /// </summary>
    /// <param name="_salesParmLine">
    /// The <c>SalesParmLine</c> that is currently being posted.
    /// </param>
    protected void updateCredit_PL(Common _salesParmLine)
    {
        SalesParmLine      salesParmLine = _salesParmLine as SalesParmLine;
        SalesLine          tmpSalesLine = salesParmLine.salesLine();
        Label              label = new Label(custInvoiceJour.LanguageId);
        CustInvoiceTrans   custInvoiceTransLoc;
        CustInvoiceTrans_W custInvoiceTransLoc_W;

        // create zero CustInvoiceTrans in case of Polish return
        if (tmpSalesLine.CreditNoteInternalRef_PL &&
            salesParmLine.DeliverNow == 0)
        {
            lineNum++;
            salesLine = this.getSalesLine(salesParmLine, true);

            setPrefix(#PreFixField(salesLine, SalesId));

            custInvoiceTrans.clear();

            // Allocate RecId early. Since CustInvoiceTrans is inserted via RecordInsertList,
            // child tables need the RecId so we don't lose the link between it and the TaxServiceTariff table.
            custInvoiceTrans.RecId = systemSequence.reserveValues(1, custInvoiceTrans.TableId);
            this.initCustInvoiceTrans();
            custInvoiceTrans.initFromSalesLine(tmpSalesLine, salesParmLine);

            custInvoiceTrans.Qty = 0;
            custInvoiceTrans.InventQty = 0;

            custInvoiceTrans.LineAmount = 0;
            custInvoiceTrans.LineAmountTax = 0;

            custInvoiceTrans.SumLineDisc = 0;
            custInvoiceTrans.PartDelivery = !(salesLine.SalesStatus == SalesStatus::Invoiced &&
                                                salesLine.SalesQty == custInvoiceTrans.Qty);

            if (isCountryRegionPL)
            {
                CustInvoiceTrans_W custInvoiceTrans_W = custInvoiceTrans.custInvoiceTrans_W();
                if (salesLine.InventTransIdReturn)
                {
                    select pkWiUCode_PL from custInvoiceTransLoc_W
                        exists join custInvoiceTransLoc
                            where custInvoiceTransLoc.RecId == custInvoiceTransLoc_W.CustInvoiceTrans
                                && custInvoiceTransLoc.InventTransId == salesLine.InventTransIdReturn;

                    custInvoiceTrans_W.pkWiUCode_PL = custInvoiceTransLoc_W.pkWiUCode_PL;
                }
                else
                {
                    // If the Sales order has an Item specified, use the PKWiU code off of the Item (InventTable)
                    if (custInvoiceTrans.ItemId)
                    {
                        custInvoiceTrans_W.pkWiUCode_PL = InventTable::find(custInvoiceTrans.ItemId).pkWiUCode_PL;
                    }
                    else
                    {
                        // Otherwise, assume that Sales category has been entered instead and get PKWiU code
                        //  from the Sales category hierarchy
                        custInvoiceTrans_W.pkWiUCode_PL = EcoResCategory::find(custInvoiceTrans.SalesCategory).pkWiUCode;
                    }
                }
                custInvoiceTrans.packCustInvoiceTrans_W(custInvoiceTrans_W);
            }

            SalesTable salesTableFromParmLine = salesLine.salesTable();
            custInvoiceTrans.LineHeader = label.extractString(literalStr("@SYS9694")) + ' ' + salesLine.SalesId + ' '
                                        + label.extractString(literalStr("@SYS24704")) + ' ' + salesTableFromParmLine.CustAccount + ' '
                                        + (!this.splitDeliveryInformation() ? (label.extractString(literalStr("@SYS7924")) + ' ' + salesLine.deliveryAddress().Address + ' ') : '')
                                        + (salesTableFromParmLine.PurchOrderFormNum ? (label.extractString(literalStr("@SYS9452")) + ' ' + salesTableFromParmLine.PurchOrderFormNum + ' ') : '')
                                        + custInvoiceTrans.LineHeader;

            custInvoiceTrans.LineAmountMST = custInvoiceJour.amountMST(custInvoiceTrans.LineAmount);
            custInvoiceTrans.LineAmountTaxMST = custInvoiceJour.amountMST(custInvoiceTrans.LineAmountTax);
            custInvoiceTrans.SumLineDiscMST = custInvoiceJour.amountMST(custInvoiceTrans.SumLineDisc);
            custInvoiceTrans.StatLineAmountMST = 0 ;

            if (custInvoiceTrans.Remain)
            {
                foundRemains = NoYes::Yes;
            }

            if (custInvoiceTrans.Qty != 0)
            {
                InventPackagingMaterialTrans::createFromSalesParmLine(salesParmLine, custInvoiceJour);
                //PlInventPackageTrans::updateFinancial(salesParmLine, custInvoiceTrans, this.proforma());
            }

            SourceDocumentLine sourceDocumentLine;
            this.initializeSourceDocumentLine(custInvoiceJour.SourceDocumentHeader, sourceDocumentLine);
            custInvoiceTrans.SourceDocumentLine = SourceDocumentLine::createSourceDocumentLine(tableNum(custInvoiceTrans), sourceDocumentLine);

            this.insertJournalLine(custInvoiceTrans);

            if (custInvoiceTrans.Remain)
            {
                foundRemains = NoYes::Yes;
            }

            #if.never //#speedtest
            if (speedExecute_Sales)
                speedExecute_Sales.timing(SpeedSalesTiming::LineInvoice, salesParmLine.ItemId);
            #endif
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDocumentDate_W</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks the date control options and provides warning or error messages.
    /// </summary>
    /// <param name="_postalAddress">
    ///     A <c>RecId</c> value that specified link to delivery address.
    /// </param>
    /// <param name="_documentDate">
    ///     A document date value that is checked.
    /// </param>
    /// <param name="_deliveryDate">
    ///     A delivery date value that is used for calculation issue date.
    /// </param>
    /// <param name="_creditNote">
    ///     A boolean value that specified whether current document a credit note; true if document is a credit note, otherwise false; optional.
    /// </param>
    /// <param name="_documentDateLabel">
    ///     A string value that specified the name of Document date in UI.
    /// </param>
    /// <param name="_deliveryDateLabel">
    ///     A string value that specified the name of Delivery date in UI.
    /// </param>
    /// <returns>
    ///     true if all checks are successful; otherwise, false and displays warning or error message.
    /// </returns>
    static public boolean checkDocumentDate_W(
        RecId _postalAddress,
        TransDate _documentDate,
        TransDate _deliveryDate,
        boolean _creditNote = false,
        str _documentDateLabel = fieldPName(CustInvoiceJour, DocumentDate),
        str _deliveryDateLabel = fieldPName(CustPackingSlipJour, InvoiceIssueDueDate_W))
    {
        SalesParameters salesParameters = SalesParameters::find();
        boolean ret = true;

        DateControlType_W dateControlType = _creditNote ? salesParameters.CreditNoteDocumentDateControlType_W : salesParameters.DocumentDateControlType_W;
        if (!_documentDate || dateControlType == DateControlType_W::None)
        {
            return ret;
        }

        LogisticsPostalAddress postalAddress = LogisticsPostalAddress::findRecId(_postalAddress);
        TransDate deadline = LedgerInvoiceIssueDueDateSetup_W::findPostalAddressIssueDate(postalAddress, _documentDate).getInvoiceIssueDueDate(_deliveryDate);
        if (deadline
            && _documentDate > deadline)
        {
            str message = strFmt("@SYS4009632", _documentDateLabel, _documentDate, _deliveryDateLabel, deadline);
            switch (dateControlType)
            {
                case DateControlType_W::Warning:
                    checkFailed(message);
                    break;
                case DateControlType_W::Error:
                    error(message);
                    ret = false;
                    break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static SalesInvoiceJournalCreate construct()
    {
        return new SalesInvoiceJournalCreate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPdsCustInvoiceTrans</Name>
				<Source><![CDATA[
    private void createPdsCustInvoiceTrans()
    {
        PdsRebateCustInvoiceTrans pdsRebateCustInvoiceTrans;

        pdsRebateCustInvoiceTrans.initFromSalesTableSalesLine(salesTable, salesLine);
        pdsRebateCustInvoiceTrans.CustInvoiceTransRecId = custInvoiceTrans.RecId;
        recordListPdsRebateCustInvoiceTrans.add(pdsRebateCustInvoiceTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDebitNote_MY</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether current sales invoice is debit note format for MalaySia.
    /// </summary>
    /// <returns>
    ///     Returns true if sales invoice is debit note format. Otherwise, returns false.
    /// </returns>
    private boolean isDebitNote_MY()
    {
        return (!this.isInvoiceCreditNote() && salesTable.hasLinesWithRefrence_MY());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isMCRGiftCardSalesParmTable_BR</Name>
				<Source><![CDATA[
    private boolean isMCRGiftCardSalesParmTable_BR()
    {
        SalesParmLine tmpSalesParmLine;

        recordListSalesParmLine.first(tmpSalesParmLine);

        return MCRGiftCard::isGiftCardOperation(salesTable, tmpSalesParmLine.ItemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeSourceDocumentLine</Name>
				<Source><![CDATA[
    private void initializeSourceDocumentLine(SourceDocumentHeaderRecId _sourceDocumentHeaderRecId, SourceDocumentLine _sourceDocumentLine)
    {
        _sourceDocumentLine.SourceDocumentHeader = _sourceDocumentHeaderRecId;
        _sourceDocumentLine.TypeEnumName = enumStr(SourceDocumentLine_CustomerInvoice);
        _sourceDocumentLine.TypeEnumValue = SourceDocumentLine_CustomerInvoice::CustomerInvoiceLine;
        _sourceDocumentLine.AccountingStatus = SourceDocumentLineAccountingStatus::Completed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxableDocumentDescriptor</Name>
				<Source><![CDATA[
    public TaxableDocumentDescriptor parmTaxableDocumentDescriptor()
    {
        return TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(this.parmParmTable());
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberSequenceReferenceNum</Name>
				<Source><![CDATA[
    /// <summary>
    ///     The method use the number sequence to generate invoice number.
    /// </summary>
    /// <returns>
    ///     The number sequence reference.
    /// </returns>
    protected NumberSequenceReference numberSequenceReferenceNum()
    {
        NumberSequenceReference ret = super();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberSequenceReferenceVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///     The method use the number sequence to generate voucher number.
    /// </summary>
    /// <returns>
    ///     The number sequence reference.
    /// </returns>
    protected NumberSequenceReference numberSequenceReferenceVoucher()
    {
        NumberSequenceReference ret = super();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transitDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Transit documents
    /// </summary>
    private void transitDocument()
    {
        CustInvoiceTrans     custInvoiceTransLoc;
        SalesParmLine        salesParmLineLoc;
        TransitDocumentManager_IN transitDocManager = TransitDocumentManager_IN::newManager();

        transitDocManager.transit(salesParmTable, custInvoiceJour);

        while select custInvoiceTransLoc
            where custInvoiceTransLoc.SalesId == custInvoiceJour.SalesId
                && custInvoiceTransLoc.InvoiceId == custInvoiceJour.InvoiceId
                && custInvoiceTransLoc.InvoiceDate == custInvoiceJour.InvoiceDate
                && custInvoiceTransLoc.numberSequenceGroup == custInvoiceJour.numberSequenceGroup
            join salesParmLineLoc
                where salesParmLineLoc.ParmId == custInvoiceJour.ParmId
                && salesParmLineLoc.TableRefId == salesParmTable.TableRefId
                && salesParmLineLoc.InventTransId == custInvoiceTransLoc.InventTransId
        {
            transitDocManager.transit(salesParmLineLoc, custInvoiceTransLoc, custInvoiceJour);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isExistNoneCreditNoteLine_PL</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks to see if any of the lines associated with sales header is not a credit note.
    /// </summary>
    /// <param name = "_salesId">Sales identifier.</param>
    /// <returns> True, if at least one line is not a credit note.</returns>
    private boolean isExistNoneCreditNoteLine_PL(SalesId _salesId)
    {
        SalesLine localSalesLine;

        select firstonly RecId from localSalesLine
            where localSalesLine.SalesId == _salesId
               && localSalesLine.CreditNoteInternalRef_PL == 0;

        return localSalesLine.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instrumentationLogger</Name>
				<Source><![CDATA[
    internal SalesInstrumentationLogger instrumentationLogger()
    {
        if (!instrumentationLogger)
        {
            instrumentationLogger = SalesInstrumentationLogger::createLogger(classStr(SalesInvoiceJournalCreate));
        }

        return instrumentationLogger;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>