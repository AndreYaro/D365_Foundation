<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>KanbanBoardController</Name>
	<SourceCode>
		<Declaration><![CDATA[
using System.Web.Security.AntiXss;

/// <summary>
/// Controller class for the Kanban board.
/// </summary>
public class KanbanBoardController extends RunBase
{
    private const int DefaultGridWidth = 580;
    private const int DefaultNumberPlanningPeriods = 5;
    private const str WarningSymbolName = 'Warning';
    private const str OverdueSymbolName = 'Recent';
    private const str JobCompletedSymbolName = 'Done';
    private const str JobInProgressSymbolName = 'Next';
    private const container WarningColor = [255, 0, 0];
    private const container SummaryBarColor = [43, 136, 216];
    private const int NumberHigherThan100 = 142;

    private const str tooltipTableStart       = '<table class="ganttTooltipTable">';
    private const str tooltipEmptyCell        = '&nbsp;';
    private const str tooltipTemplateOneCell  = '<tr><td colspan="2"><b>%1</b></td></tr>';
    private const str tooltipTemplateTwoCells = '<tr><td><b>%1</b>&nbsp;</td><td>%2</td></tr>';
    private const str tooltipTableEnd         = '</table>';
        
    private WrkCtrId wrkCtrId;
    private WrkCtrResourceGroup resourceGroup;
    private LeanPlanningPeriods numberPlanningPeriods;
    private boolean useThemeColors;
    private int refreshCycle;
    private NoYes hideCompletedJobs;
    
    private date viewFromDate;
    private date firstPeriodStart;
    private utcdatetime viewPortFromDateTime;
    private utcdatetime viewPortToDateTime;
    private int64 viewPortDaySeconds;
    private KanbanPeriodTmp periods;
    
    private LeanPlanningPeriodType leanPlanningPeriodType;
    private LeanSchedulePlanningPeriod planningPeriod;

    private GanttControl ganttControl;

    private Map activityMap;
    private List periodHeaders;
    private Map summaryActivityCollapsedMap;
    private Map summaryActivityPeriodMap;

    str lastSelectedActivityId;
    GanttControlActivityIdCollection allSelectedActivityIds;

    Map postponedMoveMap;
    ParmId parmIdChangeStatus;

    TimeOfDay minWorkingDayTime;
    TimeOfDay maxWorkingDayTime;

    #Define.CurrentVersion(1)
    #localmacro.CurrentList
        wrkCtrId,
        numberPlanningPeriods,
        useThemeColors,
        refreshCycle
    #endmacro

    #TimeConstants

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmViewFromDate</Name>
				<Source><![CDATA[
    public date parmViewFromDate(date _viewFromDate = viewFromDate)
    {
        viewFromDate = _viewFromDate;
        return viewFromDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNumberPlanningPeriods</Name>
				<Source><![CDATA[
    public LeanPlanningPeriods parmNumberPlanningPeriods(LeanPlanningPeriods _numberPlanningPeriods = numberPlanningPeriods)
    {
        numberPlanningPeriods = _numberPlanningPeriods;
        return numberPlanningPeriods;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHideCompletedJobs</Name>
				<Source><![CDATA[
    public NoYes parmHideCompletedJobs(NoYes _hideCompletedJobs = hideCompletedJobs)
    {
        hideCompletedJobs = _hideCompletedJobs;
        return hideCompletedJobs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRefreshCycle</Name>
				<Source><![CDATA[
    public int parmRefreshCycle(int _refreshCycle = refreshCycle)
    {
        refreshCycle = _refreshCycle;
        return refreshCycle;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWrkCtrResourceGroup</Name>
				<Source><![CDATA[
    public WrkCtrResourceGroup parmWrkCtrResourceGroup(WrkCtrResourceGroup _resourceGroup = resourceGroup)
    {
        if (!prmIsDefault(_resourceGroup))
        {
            resourceGroup = _resourceGroup;
            this.initViewFromDate();
        }
        return resourceGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmGanttControl</Name>
				<Source><![CDATA[
    public GanttControl parmGanttControl(GanttControl _ganttControl = ganttControl)
    {
        if (!prmIsDefault(_ganttControl))
        {
            ganttControl = _ganttControl;
            allSelectedActivityIds = _ganttControl.parmSelectedActivityIds();
        }
        return ganttControl;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        wrkCtrId = resourceGroup.WrkCtrId;
        return [#CurrentVersion, #CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        boolean  ret;
        Integer  version = conpeek(packedClass,1);

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList] = packedClass;
                resourceGroup = WrkCtrResourceGroup::findWrkCtrId(wrkCtrId);
                ret = true;
                break;

            default:
                ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    public void initParmDefault()
    {
        super();

        numberPlanningPeriods = DefaultNumberPlanningPeriods;        
        useThemeColors = true;        
        refreshCycle = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>toggleUseThemeColors</Name>
				<Source><![CDATA[
    /// <summary>
    /// Toggles the use of theme colors.
    /// </summary>
    public void toggleUseThemeColors()
    {
        useThemeColors = !useThemeColors;
    }

]]></Source>
			</Method>
			<Method>
				<Name>themeColorToggleText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the text for a toggle button to switch on/off theme colors.
    /// </summary>
    /// <returns>The text that should be applied on the button.</returns>
    public str themeColorToggleText() 
    {
        if (!useThemeColors)
        {
            return "@SCM:UseThemeColors";
        }
        else
        {
            return "@SCM:UseKanbanColors";
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reload</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reloads all data and populates the Gantt control.
    /// </summary>
    public void reload()
    {
        this.initPeriods();
        
        ganttControl.parmCalendars(this.getCalendars());
        ganttControl.parmConfiguration(this.getConfiguration());
        ganttControl.parmColumns(this.getColumns());
        ganttControl.parmActivities(this.getActivities());        
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPeriods</Name>
				<Source><![CDATA[
    private void initPeriods()
    {
        if (this.isValidWorkCell())
        {
            leanPlanningPeriodType = KanbanJobScheduleOperation::workCellPlanningPeriodType(resourceGroup.RecId, viewFromDate);
            planningPeriod = LeanSchedulePlanningPeriod::newWrkCtrResourceGroup(resourceGroup.RecId);

            KanbanJobScheduleOperation scheduleOperation = KanbanJobScheduleOperation::newStandard(resourceGroup.RecId);

            firstPeriodStart = planningPeriod.planningPeriodStartDate(viewFromDate);

            periods = scheduleOperation.initPlanningPeriods(planningPeriod, viewFromDate, numberPlanningPeriods);
        }
        else
        {
            leanPlanningPeriodType = LeanPlanningPeriodTypes::Day;
            planningPeriod = null;
            periods = null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberOfUnplannedJobs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the number of unplanned jobs in the current work cell.
    /// </summary>
    /// <returns>The number of unplanned jobs in the current work cell.</returns>
    public int numberOfUnplannedJobs()
    {
        KanbanJob kanbanJob;
        select count(RecId) from kanbanJob
            where kanbanJob.Type       == LeanKanbanJobType::Process
               && kanbanJob.Status     == LeanKanbanJobStatus::NotPlanned
               && kanbanJob.Executable == NoYes::Yes
               && kanbanJob.WorkCell   == resourceGroup.RecId;

        return int642int(kanbanJob.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodDateToCalendarId</Name>
				<Source><![CDATA[
    private GanttCalendarId periodDateToCalendarId(date _periodStartDate)
    {
        return date2StrXpp(_periodStartDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCalendars</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a list of calendar and working time information.
    /// </summary>
    /// <returns>A <c>List</c> of <c>GanttControlCalendar</c> objects.</returns>
    protected List getCalendars()
    {
        List calendars = new List(Types::Class);
        
        if (leanPlanningPeriodType == LeanPlanningPeriodTypes::Week)
        {
            return calendars;
        }

        WrkCtrResourceCalendar resourceCalendar;
        date calendarSearchFromDate = dateNull();
        date calendarSearchToDate = maxDate();
        date previousPeriodStartDate;
        
        boolean minMaxTimeSet = false;

        while select validtimestate(calendarSearchFromDate, calendarSearchToDate) periods
            order by StartDate
            join resourceCalendar
                where resourceCalendar.WrkCtrId == resourceGroup.WrkCtrId
                   && resourceCalendar.ValidFrom <= periods.StartDate
                   && resourceCalendar.ValidTo >= periods.StartDate
        {
            GanttControlCalendar calendar;
            
            if (previousPeriodStartDate != periods.StartDate)
            {
                calendar = GanttControlCalendar::newParameters(this.periodDateToCalendarId(periods.StartDate));
                calendars.addEnd(calendar);
                previousPeriodStartDate = periods.StartDate;
            }
            
            workCalendarDateLine workCalendarDateLine;

            while select workCalendarDateLine
            where workCalendarDateLine.CalendarId == WorkCalendar::defined(resourceCalendar.CalendarId, periods.StartDate, false)
                && workCalendarDateLine.TransDate == periods.StartDate
            {
                if (!minMaxTimeSet)
                {
                    minWorkingDayTime = WorkCalendarDateLine.FromTime;
                    maxWorkingDayTime = WorkCalendarDateLine.ToTime;
                    minMaxTimeSet = true;
                }
                else
                {
                    minWorkingDayTime = min(minWorkingDayTime, WorkCalendarDateLine.FromTime);
                    maxWorkingDayTime = max(maxWorkingDayTime, WorkCalendarDateLine.ToTime);
                }
                    
                // Add the working time
                calendar.addWorkingTimeInterval(DateTimeUtil::newDateTime(firstPeriodStart, WorkCalendarDateLine.FromTime, DateTimeUtil::getUserPreferredTimeZone()),
                                                DateTimeUtil::newDateTime(firstPeriodStart, WorkCalendarDateLine.ToTime, DateTimeUtil::getUserPreferredTimeZone()));
            }            
        }

        if (!minMaxTimeSet)
        {
            // In case no valid calendar information was found then set a default.
            // Should only happen if no work cell was set.
            minWorkingDayTime = 8 * #secondsPerHour;
            maxWorkingDayTime = 16 * #secondsPerHour;            
        }

        return calendars;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getConfiguration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the control view settings.
    /// </summary>
    /// <returns>A <c>GanttControlConfiguration</c> object with values set based on the user options and planning period.</returns>
    protected GanttControlConfiguration getConfiguration()
    {
        GanttControlConfiguration configuration = GanttControlConfiguration::construct();

        List timeScales = new List(Types::Class);        
        
        switch (leanPlanningPeriodType)
        {
            case LeanPlanningPeriodTypes::Day:
                timeScales.addEnd(GanttControlTimeScale::newFromScaleUnit(GanttTimescale::Hours, GanttControlDateTimeFormat::LocalizedShortTime, 1));
                
                viewPortFromDateTime = DateTimeUtil::newDateTime(firstPeriodStart, minWorkingDayTime, DateTimeUtil::getUserPreferredTimeZone());
                viewPortToDateTime = DateTimeUtil::newDateTime(firstPeriodStart, maxWorkingDayTime, DateTimeUtil::getUserPreferredTimeZone());

                configuration.parmUseCalendars(true);
                break;
            case LeanPlanningPeriodTypes::Week:
                timeScales.addEnd(GanttControlTimeScale::newFromScaleUnit(GanttTimescale::Days, "@SYS312", 1, true));
                
                viewPortFromDateTime = DateTimeUtil::newDateTime(firstPeriodStart, 0, DateTimeUtil::getUserPreferredTimeZone());
                viewPortToDateTime = DateTimeUtil::newDateTime(firstPeriodStart + 1, 0, DateTimeUtil::getUserPreferredTimeZone());
                viewPortDaySeconds = DateTimeUtil::getDifference(viewPortToDateTime, viewPortFromDateTime);
                
                configuration.parmUseCalendars(false);
                break;
        }

        configuration.parmFromDateTime(viewPortFromDateTime);
        configuration.parmToDateTime(viewPortToDateTime);
        configuration.parmTimeScales(timeScales);
                
        configuration.parmShowAllLinks(true);
        configuration.parmUseThemeColors(useThemeColors);
        configuration.parmGridWidth(DefaultGridWidth);
        configuration.parmAllowMoveActivities(false);
        configuration.parmVerticalMoveMode(GanttControlVerticalMoveMode::SameLevel);
        configuration.parmAllowMultiChange(true);
        configuration.parmExplicitOrdering(true);

        return configuration;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getColumns</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the columns to display in the control.
    /// </summary>
    /// <returns>A <c>List</c> of <c>GanttControlColumn</c> objects.</returns>
    public List getColumns()
    {
        List columns = new List(Types::Class);

        columns.addEnd(GanttControlColumn::newParameters("@SYS302381", 0,   true, SysAlignment::AlignLeft));   
        columns.addEnd(GanttControlColumn::newParameters("@SYS131897", 100, true, SysAlignment::AlignLeft));
        columns.addEnd(GanttControlColumn::newParameters("@SYS131576", 100, true, SysAlignment::AlignLeft));
        columns.addEnd(GanttControlColumn::newParameters("@SYS133863", 100, true, SysAlignment::AlignLeft));
        columns.addEnd(GanttControlColumn::newParameters("@SYS131606", 130, true, SysAlignment::AlignLeft));
        
        return columns;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the activities to display in the control.
    /// </summary>
    /// <returns>A <c>List</c> of <c>GanttControlActivity</c> objects.</returns>
    protected List getActivities()
    {
        List activityList = new List(Types::Class);
        activityMap = new Map(Types::String, Types::Class);
        real activitySequenceNumber = 0;
        periodHeaders = new List(Types::String);
        summaryActivityPeriodMap = new Map(Types::String, Types::Record);
        
        KanbanJob kanbanJob;
        KanbanJobSchedule kanbanJobSchedule;
        KanbanJobCapacitySum kanbanJobCapacitySum;
        kanbanJobCapacitySum kanbanJobCapacitySumTotal;
        Kanban kanban;
                
        KanbanPeriodTmp previousPeriod;
        GanttControlSummaryActivity periodActivity;

        boolean filterCompletedJobs = KanbanBoardHideShowCompletedStatusFeature::instance().isEnabled() && this.parmHideCompletedJobs();

        utcdatetime previousJobSchedToDateTime;
                        
        while select periods
            order by StartDate 
            outer join kanbanJobSchedule
                order by Sequence
                where kanbanJobSchedule.WorkCell      == resourceGroup.RecId
                   && kanbanJobSchedule.PlannedPeriod == periods.StartDate
            outer join kanbanJob
                where kanbanJob.RecId    == kanbanJobSchedule.Job
                   && kanbanJob.Type     == LeanKanbanJobType::Process
                   && ((filterCompletedJobs && kanbanJob.Status   != LeanKanbanJobStatus::Completed)
                   || !filterCompletedJobs)
            outer join kanbanJobCapacitySum
                where kanbanJobCapacitySum.Job == kanbanJob.RecId
            outer join kanban
                where kanban.RecId       == kanbanJob.Kanban       
        {
            if (previousPeriod.RecId != periods.RecId)
            {
                // Add a summary activity that represents the period
                activitySequenceNumber++;
                periodActivity = this.createPeriodActivity(periods, activitySequenceNumber);
                
                activityList.addEnd(periodActivity);
                activityMap.insert(periodActivity.parmId(), periodActivity);
                periodHeaders.addEnd(periodActivity.parmText());
                summaryActivityPeriodMap.insert(periodActivity.parmId(), periods);
                
                kanbanJobCapacitySumTotal.clear();

                previousJobSchedToDateTime = viewPortFromDateTime;

                previousPeriod.data(periods);                
            }

            if (kanbanJob && kanbanJobSchedule && kanbanJobCapacitySum)
            {
                kanbanJobCapacitySumTotal.PlannedCapacitySumSeconds += kanbanJobCapacitySum.PlannedCapacitySumSeconds;
                kanbanJobCapacitySumTotal.PlannedCapacitySumThroughput += kanbanJobCapacitySum.PlannedCapacitySumThroughput;

                boolean showOverlapIndicator = (periods.ConsumptionType == LeanProdFlowModelTypes::Hours && kanbanJobCapacitySumTotal.PlannedCapacitySumSeconds > periods.TotalCapacitySeconds)
                                            || (periods.ConsumptionType == LeanProdFlowModelTypes::Throughput && kanbanJobCapacitySumTotal.PlannedCapacitySumThroughput > periods.TotalCapacityThroughput);
                
                activitySequenceNumber++;

                GanttControlTaskActivity activity = this.createKanbanJobActivity(periods, 
                                                                                 kanbanJob, 
                                                                                 kanbanJobSchedule, 
                                                                                 kanbanJobCapacitySum, 
                                                                                 kanban, 
                                                                                 periodActivity.parmId(), 
                                                                                 showOverlapIndicator, 
                                                                                 previousJobSchedToDateTime, 
                                                                                 activitySequenceNumber);

                activityList.addEnd(activity);
                activityMap.insert(activity.parmId(), activity);

                previousJobSchedToDateTime = activity.parmToDateTime();
            }
            else
            {
                summaryActivityCollapsedMap.insert(periodActivity.parmId(), false);
                periodActivity.parmCollapsed(false);
            }
        }      

        return activityList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createKanbanJobActivity</Name>
				<Source><![CDATA[
    protected GanttControlActivity createKanbanJobActivity(KanbanPeriodTmp      _period, 
                                                           KanbanJob            _kanbanJob, 
                                                           KanbanJobSchedule    _kanbanJobSchedule,
                                                           KanbanJobCapacitySum _kanbanJobCapacitySum,
                                                           Kanban               _kanban,
                                                           str                  _periodActivityId,
                                                           boolean              _showOverlapIndicator,
                                                           utcdatetime          _previousJobSchedToDateTime,
                                                           real                 _activitySequenceNumber)
    {
        GanttControlTaskActivity activity = GanttControlTaskActivity::construct(this.kanbanJobRecIdToActivityId(_kanbanJob.RecId));
                
        utcdatetime schedFromDateTime;
        utcdatetime schedToDateTime;
                
        if (leanPlanningPeriodType == LeanPlanningPeriodTypes::Day)
        {
            // Use the persisted datetime values
            schedFromDateTime = _kanbanJobSchedule.ExpectedStartDateTime;
            schedToDateTime = _kanbanJobSchedule.ExpectedDateTime;

            if (!schedFromDateTime && schedToDateTime && _kanbanJobCapacitySum.PlannedCapacitySumSeconds)
            {
                // This case should only happen in an upgrade scenario for old completed jobs
                schedFromDateTime = DateTimeUtil::addSeconds(schedToDateTime, -1 * _kanbanJobCapacitySum.PlannedCapacitySumSeconds);
            }
                
            activity.parmFromDateTime(this.convertDBDateTimeToView(schedFromDateTime, _period.StartDate));
            activity.parmToDateTime(this.convertDBDateTimeToView(schedToDateTime, _period.StartDate));
        }
        else
        {
            // For week view the from/to date must always be calculated as the view does not use exact calendars
            real capacityFactor;

            if (periods.ConsumptionType == LeanProdFlowModelTypes::Hours)
            {
                if (periods.TotalCapacitySeconds)
                {
                    capacityFactor = _kanbanJobCapacitySum.PlannedCapacitySumSeconds / _period.TotalCapacitySeconds;
                }
            }
            else
            {
                if (periods.TotalCapacityThroughput)
                {
                    capacityFactor = _kanbanJobCapacitySum.PlannedCapacitySumThroughput / _period.TotalCapacityThroughput;
                }
            }
                    
            int64 capacityInDaySeconds = real2int(capacityFactor * viewPortDaySeconds);
                    
            if (DateTimeUtil::getDifference(viewPortToDateTime, _previousJobSchedToDateTime) >= capacityInDaySeconds)
            {
                schedFromDateTime = _previousJobSchedToDateTime;
                schedToDateTime = DateTimeUtil::addSeconds(_previousJobSchedToDateTime, capacityInDaySeconds);
            }
            else
            {
                schedFromDateTime = DateTimeUtil::addSeconds(viewPortToDateTime, -1 * capacityInDaySeconds);
                schedToDateTime = viewPortToDateTime;
            }
                                   
            activity.parmFromDateTime(schedFromDateTime);
            activity.parmToDateTime(schedToDateTime);
        }
                                
        activity.parmGroupLoad(_kanbanJob.LoadPercent);
        activity.parmText(_kanban.KanbanCardId);
        activity.parmCalendarId(this.periodDateToCalendarId(periods.StartDate));
        activity.parmColumnTexts(this.getActivityColumnTexts(_kanbanJob, _kanban, _kanbanJobSchedule));
        activity.parmStyle().parmColor(KanbanBoardController::hex2color(_kanbanJob.LeanScheduleGroupColor));
        activity.parmCompletionPct(0);
                
        if (_showOverlapIndicator)
        {
            // Will ensure that the overlap indicator is shown for the duration of this activity
            activity.parmGroupLoad(NumberHigherThan100);
        }
                
        activity.parmParentId(_periodActivityId);
        activity.parmIsActive(true);
        activity.parmAllowResize(false);
        activity.parmAllowCompletionChange(false);
        
        if (_kanbanJob.Status == LeanKanbanJobStatus::Completed)
        {
            activity.parmSymbolName(JobCompletedSymbolName);
            activity.parmAllowMove(false);
        }
        else
        {
            // While move is disabled globally, this makes sure the activity is not read-only and can still be moved vertically
            activity.parmAllowMove(true);
            if (_kanbanJobSchedule.ExpectedDateTime > _kanbanJob.DueDateTime)
            {
                activity.parmSymbolName(OverdueSymbolName);
            }
            else if (_kanbanJob.Status == LeanKanbanJobStatus::InProgress)
            {
                activity.parmSymbolName(JobInProgressSymbolName);
            }
        }
        
        this.setActivityTooltip(activity, _kanbanJob, _kanban, _kanbanJobSchedule);

        activity.parmSequenceNumber(_activitySequenceNumber);

        return activity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formatOneCell</Name>
				<Source><![CDATA[
    private str formatOneCell(anytype text)
    {
        return strFmt(tooltipTemplateOneCell, AntiXssEncoder::HtmlEncode(text, true));
    }

]]></Source>
			</Method>
			<Method>
				<Name>formatTwoCells</Name>
				<Source><![CDATA[
    private str formatTwoCells(str label, anytype text)
    {
        return strFmt(tooltipTemplateTwoCells, AntiXssEncoder::HtmlEncode(label, true), AntiXssEncoder::HtmlEncode(text, true));
    }

]]></Source>
			</Method>
			<Method>
				<Name>setActivityTooltip</Name>
				<Source><![CDATA[
    private void setActivityTooltip(GanttControlTaskActivity _activity,
                                    KanbanJob                _kanbanJob,
                                    Kanban                   _kanban,
                                    KanbanJobSchedule        _kanbanJobSchedule)
    {
        InventTable                       inventTable        = _kanban.inventTable();
        LanguageId                        companyLanguage    = CompanyInfo::languageId();
        EcoResProductName                 productName        = inventTable.productName(companyLanguage, _kanbanJob.InventDimId);
        EcoResProductDisplayProductNumber productNumber      = InventTable::getProductNumberForItemDim(_kanban.ItemId, _kanbanJob.inventDim());
        EcoResDescription                 productDescription = inventTable.productDescription(companyLanguage, _kanbanJob.InventDimId);

        boolean isOverdue = (_activity.parmSymbolName() == OverdueSymbolName);

        utcdatetime localStartDateTime =  DateTimeUtil::applyTimeZoneOffset(_kanbanJobSchedule.ExpectedStartDateTime,
                                                                            DateTimeUtil::getUserPreferredTimeZone());

        str tooltip = tooltipTableStart
                    + this.formatOneCell(strFmt("@SYS76785", productName, productNumber))
                    + (isOverdue ? this.formatOneCell("@SYS300384") : '')
                    + strFmt(tooltipTemplateOneCell, tooltipEmptyCell)
                    + this.formatTwoCells("@SYS300382", productDescription)
                    + this.formatTwoCells("@SYS300381", _kanban.KanbanId)
                    + this.formatTwoCells("@SYS301593", _kanban.KanbanCardId)
                    + this.formatTwoCells("@SYS301595", _kanbanJob.PlanActivityName)
                    + this.formatTwoCells("@SYS301594", _kanbanJob.InventLocationId)
                    + this.formatTwoCells("@SYS303799", enum2Str(_kanban.kanbanRule().ReplenishmentStrategy))
                    + this.formatTwoCells("@SYS300379", _kanbanJob.QuantityOrdered)
                    + this.formatTwoCells("@SYS300385", enum2Str(_kanbanJob.Status))
                    + this.formatTwoCells("@SCM:KanbanJobExpectedStartDateTimeField", strFmt('%1', localStartDateTime))
                    + tooltipTableEnd;

        _activity.parmTooltipText(tooltip);
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertDBDateTimeToView</Name>
				<Source><![CDATA[
    private utcdatetime convertDBDateTimeToView(utcdatetime _dbDateTime, date _planningPeriodDate)
    {
        return DateTimeUtil::addDays(_dbDateTime, firstPeriodStart - _planningPeriodDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertViewDateTimeToDB</Name>
				<Source><![CDATA[
    private utcdatetime convertViewDateTimeToDB(utcdatetime _viewDateTime, date _planningPeriodDate)
    {
        return DateTimeUtil::addDays(_viewDateTime, -1 * (firstPeriodStart - _planningPeriodDate));
    }

]]></Source>
			</Method>
			<Method>
				<Name>hex2color</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts a color in hex format (as used in the KanbanJob.LeanScheduleGroupColor field) into an argb int value.
    /// </summary>
    /// <param name = "_color">The hex color to convert.</param>
    /// <returns>The corresponding argb int value.</returns>
    public static OLE_Color hex2color(Color _color)
    {
        System.Drawing.Color color = System.Drawing.Color::FromArgb(hex2Int(_color));
        return System.Drawing.ColorTranslator::ToOle(color);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivityColumnTexts</Name>
				<Source><![CDATA[
    protected List getActivityColumnTexts(KanbanJob _kanbanJob, Kanban _kanban, KanbanJobSchedule _kanbanJobSchedule)
    {
        List columnTexts = new List(Types::String);
        columnTexts.addEnd(_kanbanJob.PlanActivityName);
        columnTexts.addEnd(_kanban.KanbanCardId);
        columnTexts.addEnd(_kanban.KanbanId);
        columnTexts.addEnd(InventTable::getProductNumberForItemDim(_kanban.ItemId, _kanban.inventDim()));        
        columnTexts.addEnd(strFmt('%1', DateTimeUtil::applyTimeZoneOffset(_kanbanJob.DueDateTime, DateTimeUtil::getUserPreferredTimeZone())));
        return columnTexts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>kanbanJobRecIdToActivityId</Name>
				<Source><![CDATA[
    private str kanbanJobRecIdToActivityId(RecId _recId)
    {
        return int642Str(_recId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaskActivity</Name>
				<Source><![CDATA[
    private boolean isTaskActivity(str _activityId)
    {
        return isInteger(_activityId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>activityIdToKanbanJobRecId</Name>
				<Source><![CDATA[
    private RecId activityIdToKanbanJobRecId(str _activityId)
    {
        if (this.isTaskActivity(_activityId))
        {
            return str2Int64(_activityId);
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPeriodActivity</Name>
				<Source><![CDATA[
    protected GanttControlSummaryActivity createPeriodActivity(KanbanPeriodTmp _period, real _activitySequenceNumber)
    {
        str periodActivityId = 'g-' + date2StrXpp(_period.StartDate);
            
        str periodText;
        if (_period.ConsumptionType == LeanProdFlowModelTypes::Throughput)
        {
            periodText = strFmt("@SCM:KanbanBoardHeaderFormat", dayName(dayOfWk(_period.StartDate)), _period.StartDate, _period.PlannedCapacityThroughput, _period.TotalCapacityThroughput, _period.UnitOfMeasureSymbol);
        }
        else
        {
            periodText = Global::strLRTrim(strFmt("@SCM:KanbanBoardHeaderFormat", dayName(dayOfWk(_period.StartDate)), _period.StartDate, time2StrHMS(_period.PlannedCapacitySeconds), time2StrHMS(_period.TotalCapacitySeconds), ''));
        }
        
        GanttControlSummaryActivity periodActivity =  new GanttControlSummaryActivity();         
        periodActivity.parmId(periodActivityId);
        periodActivity.parmParentId('');
        periodActivity.parmText(periodText);
        periodActivity.parmCalendarId(this.periodDateToCalendarId(_period.StartDate));
        periodActivity.parmStyle().parmColor(WinAPI::RGBCon2int(SummaryBarColor));
        periodActivity.parmShowBar(true);
        periodActivity.parmSummaryType(GanttControlSummaryType::TaskPreviewWithOverlapExt);
        periodActivity.parmChildStyleInSummary(true);
        periodActivity.parmCollapsed(this.groupCollapseDefault(periodActivityId));
        periodActivity.parmTooltipText('');
        periodActivity.parmIsActive(true);
        
        // Set a warning symbol based on capacity
        if (_period.PlannedCapacitySeconds > _period.TotalCapacitySeconds || 
            _period.PlannedCapacityThroughput > _period.TotalCapacityThroughput)
        {
            periodActivity.parmSymbolName(WarningSymbolName);
            periodActivity.parmSymbolColor(WinAPI::RGBCon2int(WarningColor));
        }

        periodActivity.parmSequenceNumber(_activitySequenceNumber);

        return periodActivity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupCollapseDefault</Name>
				<Source><![CDATA[
    private boolean groupCollapseDefault(str _periodActivityId)
    {
        boolean collapsed = true;
        if (summaryActivityCollapsedMap.exists(_periodActivityId))
        {
            collapsed = summaryActivityCollapsedMap.lookup(_periodActivityId);
        }
        return collapsed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onSummaryActivityExpand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handler for expansion of summary activities.
    /// </summary>
    /// <param name = "_activityId">The id of the summary activity that was expanded.</param>
    public void onSummaryActivityExpand(str _activityId)
    {
        summaryActivityCollapsedMap.insert(_activityId, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>onSummaryActivityCollapse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handler for collapse of summary activities.
    /// </summary>
    /// <param name = "_activityId">The id of the summary activity that was collapsed.</param>
    public void onSummaryActivityCollapse(str _activityId)
    {
        summaryActivityCollapsedMap.insert(_activityId, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPeriodHeaders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a list containing all the period header strings.
    /// </summary>
    /// <returns>A list containing all the period header strings.</returns>
    public List getPeriodHeaders()
    {
        return periodHeaders;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrentSelectedPeriodNo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the relative period number (the first displayed period is number 0) that the currently selected task is in. 
    /// </summary>
    /// <returns>An <c>int</c> of the period that the currently selected task is in.</returns>
    public int getCurrentSelectedPeriodNo()
    {
        int periodNo = 0;
        KanbanPeriodTmp periodTmp;

        GanttControlActivity selectedActivity = this.getSelectedActivity();
        if (selectedActivity is GanttControlSummaryActivity)
        {
            periodTmp = summaryActivityPeriodMap.lookup(selectedActivity.parmId());
        }
        else if (selectedActivity is GanttControlTaskActivity)
        {
            periodTmp = summaryActivityPeriodMap.lookup(selectedActivity.parmParentId());
        }

        if (periodTmp)
        {
            periodNo = this.periodDate2PeriodNo(periodTmp.StartDate); 
        }

        return periodNo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodDate2PeriodNo</Name>
				<Source><![CDATA[
    private int periodDate2PeriodNo(date _periodDate)
    {
        int ret = 0;
        while select periods order by StartDate
        {
            if (periods.StartDate >= _periodDate)
            {
                break;
            }
            ret++;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodNo2PeriodDate</Name>
				<Source><![CDATA[
    private date periodNo2PeriodDate(int _periodNo)
    {
        int i = 0;
        while select periods order by StartDate
        {
            if (i == _periodNo)
            {
                break;
            }
            i++;
        }
        return periods.StartDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSelectedActivity</Name>
				<Source><![CDATA[
    protected GanttControlActivity getSelectedActivity()
    {
        if (lastSelectedActivityId && activityMap.exists(lastSelectedActivityId))
        {
            return activityMap.lookup(lastSelectedActivityId) as GanttControlActivity;
        }
        
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getKanbanJobFromActivity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>KanbanJob</c> record that an activity represents.
    /// </summary>
    /// <param name = "_activityId">The id of the activity to get the job for.</param>
    /// <param name="_forUpdate">A boolean value that indicates whether to read the record for update; optional.</param>
    /// <returns>The kanban job record.</returns>
    public KanbanJob getKanbanJobFromActivity(str _activityId, boolean _forUpdate = false)
    {
        return KanbanJob::find(this.activityIdToKanbanJobRecId(_activityId), _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>planUnplannedKanbanJobs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Plans a set of unplanned kanban jobs in a specific period.
    /// </summary>
    /// <param name = "_kanbanJobRecIds">A <c>Set</c> of kanban jobs.</param>
    /// <param name = "_autoPlan">Whether to plan the jobs automatically.</param>
    /// <param name = "_periodNo">The period number in which to place the jobs, if _autoPlan is set to false.</param>
    public void planUnplannedKanbanJobs(Set _kanbanJobs, boolean _autoPlan, int _periodNo)
    {
        SetEnumerator jobs = _kanbanJobs.getEnumerator();
        if (_autoPlan)
        {
            while (jobs.moveNext())
            {
                KanbanJob job = jobs.current();
                KanbanJobAutoPlan::newKanbanJob(job, true).run();
            }
        }
        else
        {
            date periodDate = this.periodNo2PeriodDate(_periodNo);
            postponedMoveMap = new Map(Types::Date, Types::Container);

            KanbanJobSchedule otherKjs;
            KanbanJob prev;
            select firstonly prev join otherKjs order by otherKjs.Sequence desc
                where otherKjs.Job           == prev.RecId
                   && otherKjs.PlannedPeriod == periodDate
                   && otherKjs.WorkCell      == resourceGroup.RecId;
            
            while (jobs.moveNext())
            {
                KanbanJob job = jobs.current();
                KanbanJobScheduleOperation::move(job, periodDate, prev, NoYes::Yes);
                this.addToPostponeMoveMap(job);
                prev = job;
            }

            KanbanJobScheduleOperation::performPostponedMove(postponedMoveMap);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>onActivtySelected</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handler of the activity selection event.
    /// </summary>
    /// <param name = "_activityId">The id of the activity that was selected.</param>
    /// <param name = "_allSelectedActivityIds">A collection of all the ids of the selected activities.</param>
    public void onActivtySelected(str _activityId, GanttControlActivityIdCollection _allSelectedActivityIds)
    {
        lastSelectedActivityId = _activityId;
        allSelectedActivityIds = _allSelectedActivityIds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onActivitiesChangedHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles change of activities done in the Kanban board.
    /// </summary>
    /// <param name = "_modifications">The modification information.</param>
    /// <param name = "_response">A response class for getting any server side changes back into the control.</param>
    public void onActivitiesChangedHandler(List _modifications, GanttControlActivityModificationResponse _response)
    {
        KanbanJob prev;
        date periodDate;

        postponedMoveMap = new Map(Types::Date, Types::Container);
        ListEnumerator modificationEnumerator = _modifications.getEnumerator();
        while (modificationEnumerator.moveNext())
        {
            GanttControlActivityModification modification = modificationEnumerator.current();
            if (!prev)
            {
                prev = this.getKanbanJobFromActivity(modification.parmNewPredecessorActivityId());
                KanbanPeriodTmp period = summaryActivityPeriodMap.lookup(modification.parmNewParentId());
                periodDate = period.StartDate;
            }
                
            KanbanJob job = this.getKanbanJobFromActivity(modification.parmActivityId());
            this.addToPostponeMoveMap(job);
            KanbanJobScheduleOperation::move(job, periodDate, prev, NoYes::Yes);
            prev = job;
        }

        KanbanJobScheduleOperation::performPostponedMove(postponedMoveMap);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isValidWorkCell</Name>
				<Source><![CDATA[
    private boolean isValidWorkCell()
    {
        return resourceGroup.WrkCtrId && resourceGroup.IsWorkCell;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();

        summaryActivityCollapsedMap = new Map(Types::String, Types::Enum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initViewFromDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the view from date.
    /// </summary>
    public void initViewFromDate()
    {
        if (this.isValidWorkCell())
        {
            viewFromDate = KanbanJobScheduleOperation::getPlannedKanbanMinDate(resourceGroup.RecId);
        }
        
        date todaysDate = DateTimeUtil::getToday(DateTimeUtil::getCompanyTimeZone());
        if (!viewFromDate || viewFromDate > todaysDate)
        {
            viewFromDate = todaysDate;
        }        
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodBackward</Name>
				<Source><![CDATA[
    /// <summary>
    /// Changes the view from date to the previous period.
    /// </summary>
    public void periodBackward()
    {
        if (planningPeriod)
        {
            viewFromDate = planningPeriod.previousPlanningPeriod(firstPeriodStart);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>periodForward</Name>
				<Source><![CDATA[
    /// <summary>
    /// Changes the view from date to the next period.
    /// </summary>
    public void periodForward()
    {
        if (planningPeriod)
        {
            viewFromDate = planningPeriod.nextPlanningPeriod(firstPeriodStart);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static KanbanBoardController construct()
    {
        KanbanBoardController controller = new KanbanBoardController();
        
        return controller;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToPostponeMoveMap</Name>
				<Source><![CDATA[
    private void addToPostponeMoveMap(KanbanJob _kanbanJob)
    {
        var kanbanJobScheduleToProcess = KanbanJobSchedule::findJob(_kanbanJob.RecId);
        if (!postponedMoveMap.exists(kanbanJobScheduleToProcess.PlannedPeriod))
        {
            postponedMoveMap.insert(kanbanJobScheduleToProcess.PlannedPeriod, [buf2Con(_kanbanJob), buf2Con(kanbanJobScheduleToProcess)]);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>planSelectedKanbanJobsForward</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Plans the selected kanban jobs forward from the specified date.
    /// </summary>
    /// <param name="_fromDate">
    ///    A date from which the selected jobs should be planned forward.
    /// </param>
    /// <param name="_overrideCapacityShortageReaction">
    ///    A <c>boolean</c> value that indicates if the standard capacity shortage reaction should be overridden.
    /// </param>
    /// <param name="_capacityShortageReaction">
    ///    The capacity shortage reaction that should override the default reaction.
    /// </param>
    public void planSelectedKanbanJobsForward(
        TransDate                     _fromDate,
        boolean                       _overrideCapacityShortageReaction,
        LeanCapacityShortageReaction  _capacityShortageReaction)
    {
        Set selectedJobIds = new Set(Types::Int64);
        MapEnumerator selectedIdsEnumerator = this.selectedActivityIdsMapSorted().getEnumerator();
        while (selectedIdsEnumerator.moveNext())
        {
            selectedJobIds.add(this.activityIdToKanbanJobRecId(selectedIdsEnumerator.currentValue()));
        }

        KanbanJobAutoPlanForward::planKanbanJobsSet(selectedJobIds,
                                                    _fromDate,
                                                    _overrideCapacityShortageReaction,
                                                    _capacityShortageReaction,
                                                    true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>openLeanRuleReassignmentWizard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the Lean rule reassignment wizard for the selected kanban jobs.
    /// </summary>
    public void openLeanRuleReassignmentWizard()
    {
        Set kanbans = new Set(Types::Int64);

        MapEnumerator selectedIdsEnumerator = this.selectedActivityIdsMapSorted().getEnumerator();
        while (selectedIdsEnumerator.moveNext())
        {
            KanbanJob kanbanJob = this.getKanbanJobFromActivity(selectedIdsEnumerator.currentValue(), true);
            kanbans.add(kanbanJob.Kanban);
        }

        if (kanbans.elements() > 0)
        {
            Args args = new Args();
            args.object(kanbans);
            LeanRuleReassignmentWizard::main(args);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>openKanban</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the Kanban of the specified kanban job, or of the selected job if none is specified.
    /// </summary>
    /// <param name = "_activityId">The activity id of the kanban job for which to open the Kanban; optional.</param>
    public void openKanban(str _activityId = lastSelectedActivityId)
    {
        if (this.isTaskActivity(_activityId))
        {
            Kanban kanban = this.getKanbanJobFromActivity(_activityId).kanban();

            Args args = new Args(this);
            args.record(kanban);
            MenuFunction menuFunction = new MenuFunction(menuitemDisplayStr(Kanban), MenuItemType::Display);
            menuFunction.formViewOption(FormViewOption::Details);
            menuFunction.run(args);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>openKanbanRule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the Kanban rule of the selected kanban job
    /// </summary>
    public void openKanbanRule()
    {
        if (this.isTaskActivity(lastSelectedActivityId))
        {
            KanbanRule kanbanRule = this.getKanbanJobFromActivity(lastSelectedActivityId).kanban().kanbanRule();

            Args args = new Args(this);
            args.record(kanbanRule);
            new MenuFunction(menuitemDisplayStr(KanbanRules), MenuItemType::Display).run(args);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>printKanbans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prints the Kanbans of the selected kanban jobs
    /// </summary>
    public void printKanbans()
    {
        const boolean showPrintDialog = true;
        Map cardsByWorkCell = new Map(Types::Int64, Types::Class);

        MapEnumerator selectedIdsEnumerator = this.selectedActivityIdsMapSorted().getEnumerator();
        while (selectedIdsEnumerator.moveNext())
        {
            KanbanJob kanbanJob = this.getKanbanJobFromActivity(selectedIdsEnumerator.currentValue());

            if (cardsByWorkCell.exists(kanbanJob.WorkCell))
            {
                List cards = cardsByWorkCell.lookup(kanbanJob.WorkCell);
                cards.addEnd(any2str(kanbanJob.kanbanId()));
            }
            else
            {
                List cards = new List(Types::String);
                cards.addEnd(any2str(kanbanJob.kanbanId()));
                cardsByWorkCell.insert(kanbanJob.WorkCell, cards);
            }
        }

        KanbanPrinter::printKanbansByWorkCell(cardsByWorkCell, showPrintDialog, KanbanPrintLocation::WorkCell);
    }

]]></Source>
			</Method>
			<Method>
				<Name>viewPeggingTree</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the Pegging tree the selected kanban job
    /// </summary>
    public void viewPeggingTree()
    {
        if (this.isTaskActivity(lastSelectedActivityId))
        {
            Kanban kanban = this.getKanbanJobFromActivity(lastSelectedActivityId).kanban();

            Args args = new Args(this);
            args.record(kanban);
            new MenuFunction(menuitemDisplayStr(LeanPeggingTree), MenuItemType::Display).run(args);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedulingListPage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the Kanban job scheduling list page with the work cell filter set to the currently selected work cell.
    /// </summary>
    public void schedulingListPage()
    {
        Args args = new Args(this);
        args.record(resourceGroup);
        new MenuFunction(menuitemDisplayStr(KanbanJobSchedulingListPage), MenuItemType::Display).run(args);
    }

]]></Source>
			</Method>
			<Method>
				<Name>changeStatusProd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reverts the status of the selected kanban jobs.
    /// </summary>
    public void changeStatusProd()
    {
        this.processSelectedKanbanJob(KanbanListPageOperationType::ChangeProdStatus);

        Args args = new Args();
        args.parm(parmIdChangeStatus);
        new MenuFunction(menuitemActionStr(KanbanJobResetNotPlanned), MenuItemType::Action).run(args);
    }

]]></Source>
			</Method>
			<Method>
				<Name>numOfTasksSelected</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the number of Kanban jobs selected.
    /// </summary>
    /// <returns>The number of Kanban jobs selected.</returns>
    public int numOfTasksSelected()
    {
        int ret = 0;
        ListEnumerator selectedIdsEnumerator = allSelectedActivityIds.parmActivityIds().getEnumerator();
        while (selectedIdsEnumerator.moveNext())
        {
            if (this.isTaskActivity(selectedIdsEnumerator.current().parmId()))
            {
                ret++;
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectedActivityIdsMapSorted</Name>
				<Source><![CDATA[
    private Map selectedActivityIdsMapSorted()
    {
        Map selectedActivityIdsMap = new Map(Types::Real, Types::String);
        
        ListEnumerator selectedIdsEnumerator = allSelectedActivityIds.parmActivityIds().getEnumerator();
        while (selectedIdsEnumerator.moveNext())
        {
            GanttControlActivityId selectedActivityId = selectedIdsEnumerator.current();
            if (activityMap.exists(selectedActivityId.parmId()))
            {
                GanttControlTaskActivity taskActivity = activityMap.lookup(selectedActivityId.parmId()) as GanttControlTaskActivity;
                if (taskActivity)
                {
                    selectedActivityIdsMap.insert(taskActivity.parmSequenceNumber(), taskActivity.parmId());
                }
            }
        }

        return selectedActivityIdsMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSelectedKanbanJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes an operation on the selected kanban jobs.
    /// </summary>
    /// <param name = "_processType">The type of operation to execute.</param>
    public void processSelectedKanbanJob(KanbanListPageOperationType _processType)
    {
        boolean             firstJob = true;
        LeanKanbanJobStatus currentJobStatus;        
        container           jobsToMoveForward;

        postponedMoveMap = new Map(Types::Date, Types::Container);
        
        MapEnumerator selectedIdsEnumerator = this.selectedActivityIdsMapSorted().getEnumerator();
        while (selectedIdsEnumerator.moveNext())
        {
            KanbanJob kanbanJob = this.getKanbanJobFromActivity(selectedIdsEnumerator.currentValue(), true);
            
            switch (_processType)
            {
                case KanbanListPageOperationType::MoveForward:
                case KanbanListPageOperationType::MoveStartNext:
                case KanbanListPageOperationType::MoveStartPrev:
                    // These moves be added to the postpone map in ascending order but must be processed in descending order
                    this.addToPostponeMoveMap(kanbanJob);
                    jobsToMoveForward += kanbanJob;
                    break;
                case KanbanListPageOperationType::MoveBackward:
                    this.addToPostponeMoveMap(kanbanJob);
                    KanbanJobScheduleOperation::moveBackward(kanbanJob);                    
                    break;
                case KanbanListPageOperationType::MoveEndNext:
                    this.addToPostponeMoveMap(kanbanJob);
                    KanbanJobScheduleOperation::moveEndNextPeriod(kanbanJob);
                    break;
                case KanbanListPageOperationType::MoveEndPrev:
                    this.addToPostponeMoveMap(kanbanJob);
                    KanbanJobScheduleOperation::moveEndPreviousPeriod(kanbanJob);
                    break;
                case KanbanListPageOperationType::CreateEventKanbans:
                    KanbanJobScheduleOperation::createEventKanbans(kanbanJob);
                    break;
                case KanbanListPageOperationType::PlanKanbanPeggingTree:
                    KanbanJobScheduleOperation::planPeggingTree(kanbanJob);
                    break;
                case KanbanListPageOperationType::CheckPeggingTreeAvailable:
                    KanbanJobScheduleOperation::checkPeggingTreeAvailable(kanbanJob);
                    break;
                case KanbanListPageOperationType::ChangeProdStatus:
                    parmIdChangeStatus = KanbanJobScheduleOperation::changeStatus(kanbanJob, parmIdChangeStatus, firstJob);
                    firstJob = false;
                    break;                
            }                        
        }

        for (int forwardMoveCount = conLen(jobsToMoveForward); forwardMoveCount > 0; forwardMoveCount--)
        {
            switch (_processType)
            {
                case KanbanListPageOperationType::MoveForward:
                    KanbanJobScheduleOperation::moveForward(conPeek(jobsToMoveForward, forwardMoveCount));
                    break;
                case KanbanListPageOperationType::MoveStartNext:
                    KanbanJobScheduleOperation::moveStartNextPeriod(conPeek(jobsToMoveForward, forwardMoveCount));
                    break;
                case KanbanListPageOperationType::MoveStartPrev:
                    KanbanJobScheduleOperation::moveStartPreviousPeriod(conPeek(jobsToMoveForward, forwardMoveCount));
                    break;
            }
        }

        KanbanJobScheduleOperation::performPostponedMove(postponedMoveMap);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>