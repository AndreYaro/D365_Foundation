<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WrkCtrScheduler_Proj</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>WrkCtrScheduler_Proj</c> class is a resource scheduler processor for project hour forecasts.
/// </summary>
/// <remarks>
///    This processor is in charge of loading the project hour forecast information and feeding it  to the
///    C# scheduling engine. It also writes the results provided by the C# scheduling engine back to the
///    AX database.
/// </remarks>
class WrkCtrScheduler_Proj extends WrkCtrScheduler
{    
    #define.defaultOprNum(1)

    RecId   jobNumFirst;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addInfologMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds an Infolog entry for an order that did not schedule.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// An instance of the <c>WrkCtrParmSchedule</c> class that contains the order scheduling parameters.
    /// </param>
    /// <param name="_jobSchedulingError">
    /// A <c>WrkCtrJobSchedulingError</c> value that specifies the error to report; optional.
    /// </param>
    /// <param name="_infologMessage">
    /// A string that should be added to the Infolog as either error or information.
    /// </param>
    /// <param name="_common">
    /// A <c>Common</c> table buffer that identifies the record that triggered the failure.
    /// </param>
    /// <param name="_throwError">
    /// true if the message should be added as an error; false if the message should be added as an
    /// information.
    /// </param>
    protected void addInfologMessage(WrkCtrParmSchedule         _wrkCtrParmSchedule,
                                     WrkCtrJobSchedulingError   _jobSchedulingError = WrkCtrJobSchedulingError::None,
                                     str                        _infologMessage     = '',
                                     Common                     _common             = null,
                                     boolean                    _throwError         = true)
    {
        super(_wrkCtrParmSchedule,
              _jobSchedulingError,
              strFmt("@SYS136148", _wrkCtrParmSchedule.schedNumId()),
              _common);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSchedule</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks if a project can be scheduled.
    /// </summary>
    /// <param name="_projTable">
    ///    A <c>ProjTable</c> table buffer that contains the project data.
    /// </param>
    /// <returns>
    ///    true if the project meets all requirements for being scheduled; otherwise, false.
    /// </returns>
    protected boolean canSchedule(Common _projTable)
    {
        ProjTable projTable = _projTable as ProjTable;
        boolean ret;

        ret = super(_projTable);

        return ret && projTable.checkValid();
    }

]]></Source>
			</Method>
			<Method>
				<Name>capacityRefType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the capacity reservation type.
    /// </summary>
    /// <returns>
    /// A <c>WrkCtrCapRefType</c> value with the capacity reservation type.
    /// </returns>
    public WrkCtrCapRefType capacityRefType()
    {
        return WrkCtrCapRefType::Project;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTmpRouteJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a temporary production job record and retrieves it as a <c>Common</c> table buffer.
    /// </summary>
    /// <param name="_refId">
    /// The order ID for which to create the temporary job record.
    /// </param>
    /// <returns>
    /// A <c>Common</c> table buffer that contains the temporary job information.
    /// </returns>
    protected Common createTmpRouteJob(InventRefId _refId)
    {
        ProjForecastEmpl projForecastEmpl;

        projForecastEmpl.ProjId = _refId;
        projForecastEmpl.insert();

        jobData.insert(projForecastEmpl.RecId, projForecastEmpl);

        temporaryJobs.add(projForecastEmpl.RecId);
        projForecastEmpl.selectForUpdate();

        return projForecastEmpl;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTemporaryJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes a temporary job.
    /// </summary>
    /// <param name="_recId">
    /// The identifier of the job to delete.
    /// </param>
    protected void deleteTemporaryJob(recId _recId)
    {
        ProjForecastEmpl  projForecastEmpl;

        delete_from projForecastEmpl where projForecastEmpl.RecId == _recId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findJobWrkCtrParmSchedule</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the <c>WrkCtrParmSchedule</c> object for the order that a specific job belongs to.
    /// </summary>
    /// <param name="_jobId">
    ///    A record ID that identifies the job for which the scheduling parameters are being looked up.
    /// </param>
    /// <returns>
    ///    A <c>WrkCtrParmSchedule</c> object that contains the scheduling parameters for the order of the
    ///    specified job.
    /// </returns>
    protected WrkCtrParmSchedule findJobWrkCtrParmSchedule(RecId _jobId)
    {
        ProjForecastEmpl projForecastEmpl;

        projForecastEmpl = jobData.lookup(_jobId);

        return masterDataParms.lookup(projForecastEmpl.ProjId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRefId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds a project in the master data and returns the order record.
    /// </summary>
    /// <param name="_projId">
    ///    A project ID.
    /// </param>
    /// <param name="_forUpdate">
    ///    true if the record is to be selected for update; otherwise, false.
    /// </param>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> record that contains the order scheduling parameters.
    /// </param>
    /// <returns>
    ///    A <c>ProjTable</c> table buffer that contains the project data.
    /// </returns>
    protected Common findRefId(ProjId                _projId,
                                  boolean               _forUpdate          = false,
                                  WrkCtrParmSchedule    _wrkCtrParmSchedule = null)
    {
        return ProjTable::find(_projId, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>infologPrefixOprNum</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the prefix to display in the Infolog based on a specific job ID.
    /// </summary>
    /// <param name="_common">
    ///    A <c>Common</c> table buffer that identifies the job for which to compute the message prefix.
    /// </param>
    /// <returns>
    ///    A string value that contains the Infolog prefix.
    /// </returns>
    protected str infologPrefixOprNum(Common _common)
    {
        ProjForecastEmpl    projForecastEmpl = _common as ProjForecastEmpl;
        str                 result = '';

        if (projForecastEmpl)
        {
            result = strFmt("@SYS302656",
                            projForecastEmpl.LineNum);
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCapacityReservationData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Fills the capacity reservation record with the appropriate scheduler data.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> object that contains the order scheduling parameters.
    /// </param>
    /// <param name="_wrkCtrCapRes">
    ///    A <c>WrkCtrCapRes</c> record that identifies the capacity reservation.
    /// </param>
    /// <param name="_jobId">
    ///    A record ID that identifies the job that the capacity reservation belongs to.
    /// </param>
    protected void initCapacityReservationData(WrkCtrParmSchedule   _wrkCtrParmSchedule,
                                               WrkCtrCapRes         _wrkCtrCapRes,
                                               RecId                _jobId)
    {
        ProjForecastEmpl projForecastEmpl;

        projForecastEmpl = jobData.lookup(_jobId);

        // set order ID
        _wrkCtrCapRes.RefId           = projForecastEmpl.ProjId;

        _wrkCtrCapRes.PlanVersion     = 0;
        _wrkCtrCapRes.OprPriority     = RouteOprPriority::Primary;
        _wrkCtrCapRes.JobType         = RouteJobType::Process;
        _wrkCtrCapRes.JobId           = strFmt('%1',projForecastEmpl.RecId);
        _wrkCtrCapRes.PropertyId      = '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertChildProjects</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts child projects recursively.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> table buffer that contains all the scheduling parameters needed for
    ///    scheduling the project.
    /// </param>
    /// <param name="_projTable">
    ///    A <c>ProjTable</c> table buffer with the project master data.
    /// </param>
    /// <param name="_startCollectRefLevel">
    ///    The level at which the original selected project is on.
    /// </param>
    /// <param name="_currentCollectRefLevel">
    ///    The level at which the current project is on.
    /// </param>
    protected void insertChildProjects(WrkCtrParmSchedule   _wrkCtrParmSchedule,
                                       ProjTable            _projTable,
                                       BOMLevel             _startCollectRefLevel,
                                       BOMLevel             _currentCollectRefLevel)
    {
        ProjTable   childProjTable;

        while select forupdate childProjTable
            where childProjTable.ParentId == _projTable.ProjId
        {
            this.insertOrder(_wrkCtrParmSchedule,
                             childProjTable,
                             _projTable,
                             _startCollectRefLevel,
                             _currentCollectRefLevel - 1);

            this.insertChildProjects(_wrkCtrParmSchedule, childProjTable, _startCollectRefLevel, _currentCollectRefLevel - 1 );
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts an order into the master data and triggers the loading of the route information into the
    ///    scheduling engine.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> table buffer that contains all of the scheduling parameters that are
    ///    required to schedule the project.
    /// </param>
    /// <param name="_projTable">
    ///    A <c>ProjTable</c> table buffer with the project information.
    /// </param>
    /// <param name="_projTableNext">
    ///    A <c>ProjTable</c> table buffer that contains the next project that is linked to the project being
    ///    scheduled.
    /// </param>
    /// <param name="_startCollectRefLevel">
    ///    The level on which to locate the original selected project.
    /// </param>
    /// <param name="_currentCollectRefLevel">
    ///    The level on which to locate the current project.
    /// </param>
    protected void insertOrder(WrkCtrParmSchedule     _wrkCtrParmSchedule,
                               ProjTable              _projTable,
                               ProjTable              _projTableNext = null,
                               BOMLevel               _startCollectRefLevel = 0,
                               BOMLevel               _currentCollectRefLevel = 0)
    {
        RecId               routeJobNumFirst;
        RecId               routeJobNumLast;

        RecId               jobNumNextProj;

        masterData.insert(_projTable.ProjId, _projTable);
        masterDataParms.insert(_projTable.ProjId, _wrkCtrParmSchedule);

        // Delete existing capacity reservations
        wrkCtrCapResHandler.deleteOrderReservations(WrkCtrCapRefType::Project, _projTable.ProjId);

        [routeJobNumFirst, routeJobNumLast] = this.loadProjRoute(_wrkCtrParmSchedule,
                                                                 _projTable,
                                                                 _startCollectRefLevel,
                                                                 _currentCollectRefLevel);

        if (routeJobNumFirst == 0 &&
            routeJobNumLast == 0)
        {
            routeJobNumFirst = this.insertEmptyJob(_wrkCtrParmSchedule,
                                                   _projTable.ProjId,
                                                   _startCollectRefLevel,
                                                   _currentCollectRefLevel);
            routeJobNumLast = routeJobNumFirst;
        }

        // Save the RecId of the first job for the project, so that we can build the links between
        // projects
        oprEndPointJobIds.insert(this.keyRoute(_projTable.ProjId, #defaultOprNum,  RouteOprPriority::Primary), [routeJobNumFirst, routeJobNumLast]);

        // Create links between projects
        if (_projTableNext)
        {
            //Find job that project should link to
            if (oprEndPointJobIds.exists(this.keyRoute(_projTableNext.ProjId, #defaultOprNum, RouteOprPriority::Primary)))
            {
                jobNumNextProj = conPeek(oprEndPointJobIds.lookup(this.keyRoute(_projTableNext.ProjId, #defaultOprNum, RouteOprPriority::Primary)),1);
            }

            if (jobNumNextProj)
            {
                // Insert link
                scheduleEngine.addJobLink(routeJobNumLast,
                                          jobNumNextProj,
                                          any2int(SchedJobLink::FS),
                                          any2int(SchedJobLinkType::Soft));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>limitCapPO</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether capacity reservations that are derived from planned orders will be included in
    ///    the calculation of available capacity when executing scheduling.
    /// </summary>
    /// <param name="_inventDimId">
    ///    An <c>InventDimId</c> object that identifies the dimension by which to retrieve the option to use
    ///    the planned production orders capacity reservations.
    /// </param>
    /// <returns>
    ///    true if the capacity reservations derived from planned orders should be considered;
    ///    otherwise false.
    /// </returns>
    public boolean limitCapPO(InventDimId _inventDimId)
    {
        return WrkCtrParameters::find().LimitCapProjectPO;
    }

]]></Source>
			</Method>
			<Method>
				<Name>limitCapProd</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Specifies whether capacity reservations that are derived from production orders will be included in
    ///    the calculation of available capacity when scheduling is executed.
    /// </summary>
    /// <param name="_inventDimId">
    ///    An <c>InventDimId</c> value identifying the dimension by which to return the option to use the
    ///    production orders capacity reservations.
    /// </param>
    /// <returns>
    ///    true if the capacity reservations derived from production orders should be considered;
    ///    otherwise, false.
    /// </returns>
    public boolean limitCapProd(InventDimId _inventDimId)
    {
        return WrkCtrParameters::find().LimitCapProjectProd;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRequirementProperties</Name>
				<Source><![CDATA[
    /// <summary>
    ///     A Map with all the requirements converted to text based scheduling properties.
    /// </summary>
    /// <param name = "_wrkCtrActivityRequirementSet">
    ///     Instance of <c>WrkCtrActivityRequirementSet</c>.
    /// </param>
    /// <param name = "_wrkCtrParmSchedule">
    ///     Instance of <c>WrkCtrParmSchedule</c>.
    /// </param>
    /// <returns>
    ///     Returns a map with all the requirements converted to text based scheduling properties.
    /// </returns>
    protected Map getRequirementProperties(WrkCtrActivityRequirementSet _wrkCtrActivityRequirementSet,
                                        WrkCtrParmSchedule  _wrkCtrParmSchedule)
    {
        return _wrkCtrActivityRequirementSet.schedulingProperties('',
                                                            _wrkCtrParmSchedule.schedMethod()==SchedMethod::Detail,
                                                            _wrkCtrParmSchedule.schedMethod()==SchedMethod::Rough);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads the data needed for scheduling a job into the engine.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    /// A <c>WrkCtrParmSchedule</c> record containing the order scheduling parameters.
    /// </param>
    /// <param name="_projTable">
    /// A <c>ProjTable</c> table buffer containing the project data.
    /// </param>
    /// <param name="_projForecastEmpl">
    /// A <c>ProjForecastEmp</c> table buffer containing the project hour forecast line.
    /// </param>
    /// <param name="_jobNumPrev">
    /// The <c>RecId</c> value for the previous job record.
    /// </param>
    /// <param name="_jobLink">
    /// A <c>SchedJobLink</c> value that specifies the link between the previous job and the current job.
    /// </param>
    /// <param name="_jobLinkType">
    /// A <c>SchedJobLinkType</c> value that specifies the link type between the previous job and the current job.
    /// </param>
    /// <param name="_isFirstJob">
    /// true if the job is the first in the operation; otherwise, false.
    /// </param>
    /// <param name="_isLastJob">
    /// true if the job is the last in the operation; otherwise, false.
    /// </param>
    /// <param name="_jobNumberInSequence">
    /// A number that determines the order in which the scheduling engine should process the job.
    /// </param>
    /// <param name="_startCollectRefLevel">
    /// The level at which the original selected project is on.
    /// </param>
    /// <param name="_currentCollectRefLevel">
    /// The level at which the current project is on.
    /// </param>
    protected void loadJob( WrkCtrParmSchedule           _wrkCtrParmSchedule,
                            ProjTable                    _projTable,
                            ProjForecastEmpl             _projForecastEmpl,
                            RecId                        _jobNumPrev,
                            SchedJobLink                 _jobLink,
                            SchedJobLinkType             _jobLinkType,
                            boolean                      _isFirstJob,
                            boolean                      _isLastJob,
                            int                          _jobNumberInSequence,
                            BOMLevel                     _startCollectRefLevel,
                            BOMLevel                     _currentCollectRefLevel)
    {
        RecId                           jobNum;
        WrkCtrSchedulerGoal             goal;
        Map                             jobTimes;
        List                            resourceList;
        WrkCtrActivityRequirementSet    wrkCtrActivityRequirementSet;
        ProdUnitId                      prodUnitId;
        WrkCtrId                        resourceId;
        Map                             requirementProperties;

        jobNum = _projForecastEmpl.RecId;
        if (!jobNumFirst)
        {
            jobNumFirst = jobNum;
        }

        wrkCtrActivityRequirementSet = _projForecastEmpl.activityRequirementSet();

        if (_projForecastEmpl.SchedWrkCtrId &&
            _wrkCtrParmSchedule.parmKeepProductionUnit())
        {
            prodUnitId = WrkCtrTable::resourceGroup(_projForecastEmpl.SchedWrkCtrId).ProdUnitId;
        }

        // Resources based on the requirements
        resourceList = wrkCtrApplicableResourceListCache.applicableResourceList(wrkCtrActivityRequirementSet,
                                                                                '',
                                                                                dateNull(),
                                                                                _wrkCtrParmSchedule.schedMethod()==SchedMethod::Detail,
                                                                                _wrkCtrParmSchedule.schedMethod()==SchedMethod::Rough,
                                                                                _wrkCtrParmSchedule.schedMethod()==SchedMethod::Rough);
        // operations scheduling is done on resource groups
        if (_wrkCtrParmSchedule.schedMethod()==SchedMethod::Rough)
        {
            requirementProperties = this.getRequirementProperties(wrkCtrActivityRequirementSet, _wrkCtrParmSchedule);

             // operations scheduling with specific resource requirement
            resourceId = this.getResourceRequirement(requirementProperties);
            if (resourceId != '')
            {
                resourceList.addEnd(resourceId);
            }
        }

        if (resourceList.elements() == 0)
        {
            this.addInfologMessage(_wrkCtrParmSchedule,
                                   WrkCtrJobSchedulingError::NoMatchingResources,
                                   '',
                                   _projForecastEmpl);
        }

        jobTimes = this.fixedJobTimesForResources(resourceList,
                                                  _projForecastEmpl.Qty * (100 - min(smmActivities::find(_projForecastEmpl.ActivityNumber).PercentageCompleted, 100)) / 100 * #SecondsPerHour);

        goal = this.computeJobGoal(_wrkCtrParmSchedule,
                                   _currentCollectRefLevel,
                                   _startCollectRefLevel);

        // add the job
        this.insertJob(_wrkCtrParmSchedule,
                       jobNum,
                       _projForecastEmpl,
                       RouteJobType::Process,
                       '',
                       prodUnitId,
                       '',
                       wrkCtrActivityRequirementSet.schedulingProperties('',
                                                                         _wrkCtrParmSchedule.schedMethod()==SchedMethod::Detail,
                                                                         _wrkCtrParmSchedule.schedMethod()==SchedMethod::Rough),
                       jobTimes,
                       wrkCtrActivityRequirementSet.LoadPercent,
                       0,
                       0,
                       _projForecastEmpl.SchedWorkTime,
                       _projForecastEmpl.SchedCapacity,
                       goal);

        jobData.insert(_projForecastEmpl.RecId, _projForecastEmpl);

        // Create link between previous job (on this operation) and the current job
        if (_jobNumPrev)
        {
            if (_jobLink == SchedJobLink::FF)
            {
                scheduleEngine.addJobLink(jobNum,
                                          _jobNumPrev,
                                          any2int(_jobLink),
                                          any2int(_jobLinkType));
            }
            else
            {
                // Insert link
                scheduleEngine.addJobLink(_jobNumPrev,
                                          jobNum,
                                          any2int(_jobLink),
                                          any2int(_jobLinkType));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads data for one project that is scheduled.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> record that contains project scheduling parameters.
    /// </param>
    /// <param name="_projTable">
    ///    A <c>ProjTable</c> record that contains the project data.
    /// </param>
    protected void loadOrder(WrkCtrParmSchedule _wrkCtrParmSchedule,
                             Common             _projTable)
    {
        ProjTable           topProjTable;
        Set                 parentRecords = new Set(Types::String);

        BOMLevel            startCollectRefLevel = 0;

        super(_wrkCtrParmSchedule, _projTable);

        if (!_wrkCtrParmSchedule.schedReference())
        {
            this.insertOrder(_wrkCtrParmSchedule, _projTable as ProjTable);
        }
        else
        {
            // Find the top-most project in the hierarchy and calculate the level of the _projTable record
            topProjTable = _projTable as ProjTable;
            while (topProjTable.ParentId)
            {
                if (parentRecords.in(topProjTable.ParentId))
                {
                    throw error("@SYS25845");
                }

                parentRecords.add(topProjTable.ParentId);
                startCollectRefLevel--;
                topProjTable = ProjTable::find(topProjTable.ParentId, true);
            }

            // Insert the top-most project
            this.insertOrder(_wrkCtrParmSchedule, topProjTable, null, startCollectRefLevel, 0);

            // Insert all referenced projects recursively
            this.insertChildProjects(_wrkCtrParmSchedule, topProjTable, startCollectRefLevel, 0);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadProjRoute</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads job information for all project hour forecast lines for the project into the scheduling
    ///    engine.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> table buffer that contains all the scheduling parameters required to
    ///    schedule the project.
    /// </param>
    /// <param name="_projTable">
    ///    A <c>ProjTable</c> table buffer with the project information.
    /// </param>
    /// <param name="_startCollectRefLevel">
    ///    The level at which the original selected project is on.
    /// </param>
    /// <param name="_currentCollectRefLevel">
    ///    The level at which the current project is on.
    /// </param>
    /// <returns>
    ///    A container with the record IDs for the first and last job.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The resource specified as target resource for an operation is already in the scheduling that
    ///    operation.
    /// </exception>
    protected container loadProjRoute(WrkCtrParmSchedule     _wrkCtrParmSchedule,
                                      ProjTable              _projTable,
                                      BOMLevel               _startCollectRefLevel,
                                      BOMLevel               _currentCollectRefLevel)
    {
        ProjForecastEmpl            projForecastEmpl;
        RecId                       jobNum = 0;
        RecId                       jobNumLast;

        smmActivities               smmActivities;
        smmActivityParentLinkTable  smmActivityParentLinkTable;

        RefRecId                    refRecId;
        boolean                     isFirstJob = true;

        SchedJobLink                jobLink = SchedJobLink::None;
        SchedJobLinkType            jobLinkType = SchedJobLinkType::None;

        int                         jobNumberInSequence;
        int                         countFFLinksInSequence;

        jobNumFirst = 0;
        jobNumberInSequence = 0;
        countFFLinksInSequence = 0;

        this.initCapResHandler(_wrkCtrParmSchedule.parmReqPlanVersionRefRecId(), '');

        switch (_wrkCtrParmSchedule.projSchedSort())
        {
            case ProjSchedSort::TransOrder:
                // get the last line
                select firstonly RecId from projForecastEmpl
                    order by LineNum desc
                    where projForecastEmpl.ProjId        == _projTable.ProjId   &&
                          projForecastEmpl.ModelId       == _wrkCtrParmSchedule.modelId();

                jobNumLast = projForecastEmpl.RecId;

                while select forupdate projForecastEmpl
                    where projForecastEmpl.ProjId        == _projTable.ProjId   &&
                          projForecastEmpl.ModelId       == _wrkCtrParmSchedule.modelId()
                {
                    this.loadJob(_wrkCtrParmSchedule,
                                 _projTable,
                                 projForecastEmpl,
                                 jobNum,
                                 jobLink,
                                 jobLinkType,
                                 isFirstJob,
                                 projForecastEmpl.RecId == jobNumLast,
                                 jobNumberInSequence - 2*countFFLinksInSequence,
                                 _startCollectRefLevel,
                                 _currentCollectRefLevel);

                    jobNumberInSequence++;
                    jobNum = projForecastEmpl.RecId;

                    jobLink = projForecastEmpl.SchedLink;
                    jobLinkType = projForecastEmpl.SchedLinkType;

                    // The normal sort order is reversed by FinishFinish links.
                    // Sortorder on consequtive FinishFinish linked jobs must be reversed.
                    if ((jobLink == SchedJobLink::FF ) &&
                       (jobLinkType == SchedJobLinkType::Soft ))
                    {
                       countFFLinksInSequence++;
                    }
                    else
                    {
                        countFFLinksInSequence = 0;
                    }
                }
                break;

            case ProjSchedSort::Activity:
                refRecId = ProjTable::find(_projTable.ProjId).RecId;

                // get last job
                select firstonly ActivityNumber from smmActivityParentLinkTable
                    order by smmActivities.StartDateTime desc
                    join ActivityNumber from smmActivities
                    where smmActivityParentLinkTable.ActivityNumber == smmActivities.ActivityNumber &&
                          smmActivityParentLinkTable.ParentType     == smmActivityParentType::Project &&
                          smmActivityParentLinkTable.RefRecId       == refRecId
                        join RecId from projForecastEmpl
                        where projForecastEmpl.ProjId         == _projTable.ProjId &&
                              projForecastEmpl.ActivityNumber == smmActivities.ActivityNumber;

                jobNumLast = projForecastEmpl.RecId;

                while select ActivityNumber from smmActivityParentLinkTable
                    order by smmActivities.StartDateTime
                    join ActivityNumber from smmActivities
                    where smmActivityParentLinkTable.ActivityNumber == smmActivities.ActivityNumber &&
                          smmActivityParentLinkTable.ParentType     == smmActivityParentType::Project &&
                          smmActivityParentLinkTable.RefRecId       == refRecId
                        join forupdate projForecastEmpl
                        where projForecastEmpl.ProjId         == _projTable.ProjId &&
                              projForecastEmpl.ActivityNumber == smmActivities.ActivityNumber
                {
                    this.loadJob(_wrkCtrParmSchedule,
                                 _projTable,
                                 projForecastEmpl,
                                 jobNum,
                                 jobLink,
                                 jobLinkType,
                                 isFirstJob,
                                 projForecastEmpl.RecId == jobNumLast,
                                 jobNumberInSequence,
                                 _startCollectRefLevel,
                                 _currentCollectRefLevel);

                    jobNumberInSequence++;
                    jobLink = projForecastEmpl.SchedLink;
                    jobLinkType = projForecastEmpl.SchedLinkType;

                    jobNum = projForecastEmpl.RecId;
                }
                break;

            default:
                throw error("@SYS135684");
        }

        // Return the first job and last job of this operation, which will be used in the next loop
        // for linking the previous operation to this operation
        return [jobNumFirst, jobNum];
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();

        this.parmRouteRefIdField(0);
        this.parmRefIdField(fieldNum(ProjTable, ProjId));
        this.parmRouteOprNumField(0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Saves the scheduling results for a production order.
    /// </summary>
    /// <param name="_wrkCtrParmSchedule">
    ///    A <c>WrkCtrParmSchedule</c> record that contains the order scheduling parameters.
    /// </param>
    /// <param name="_projTable">
    ///    A <c>ProjTable</c> table buffer that contains the project master data. For example this can be a
    ///    <c>ProjTable</c> table buffer.
    /// </param>
    /// <param name="_projTableData">
    ///    A container with the start and end dates for the order. The container holds a <c>fromDate</c>,a
    ///    <c>fromTime</c>, a   <c>toDate</c>,and a <c>toTime</c> object.
    /// </param>
    protected void saveOrder(WrkCtrParmSchedule _wrkCtrParmSchedule,
                             Common             _projTable,
                             container          _projTableData)
    {
        if (this.shouldSaveOrder())
        {
            ProjTable       projTable = _projTable as ProjTable;
            SchedFromDate   fromDate;
            SchedFromTime   fromTime;
            SchedToDate     toDate;
            SchedToTime     toTime;

            super(_wrkCtrParmSchedule,
              _projTable,
              _projTableData);

            this.checkSchedulingDirectionChange(_wrkCtrParmSchedule,
                                            _projTable,
                                            "@SYS305772");

            [fromDate, fromTime, toDate, toTime] = _projTableData;

            if (projTable.orig().EndDate != dateNull() && toDate > projTable.orig().EndDate)
            {
                if (Box::yesNo("@SYS106796",DialogButton::Yes)==DialogButton::Yes)
                {
                    projTable.EndDate = toDate;
                }
            }

            // Modify the status so that it reflects now the project being scheduled
            if (this.shouldUpdateProjectStatus(projTable))
            {
                projTable.Status = ProjStatus::Scheduled;
            }

            projTable.update();
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUpdateProjectStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the project status should be updated.
    /// </summary>
    /// <param name = "_projTable">
    /// A <c>ProjTable</c> record.
    /// </param>
    /// <returns>
    /// true if the project status should be updated; otherwise, false.
    /// </returns>
    protected boolean shouldUpdateProjectStatus(ProjTable _projTable)
    {
        return _projTable.Status == ProjStatus::Created || _projTable.Status == ProjStatus::Estimated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeJobData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Writes job data to the database.
    /// </summary>
    /// <param name="_jobId">
    ///    A record ID that identifies the job for which data is being written back to the database.
    /// </param>
    /// <param name="_resourceId">
    ///    An ID of the resource the job was scheduled on.
    /// </param>
    /// <param name="_fromDate">
    ///    A <c>Date</c> value that represents the start scheduling date for the job.
    /// </param>
    /// <param name="_fromTime">
    ///    A <c>Date</c> value that represents the start scheduling time for the job.
    /// </param>
    /// <param name="_toDate">
    ///    A <c>Date</c> value that represents the end scheduling date for the job.
    /// </param>
    /// <param name="_toTime">
    ///    A <c>Date</c> value that represents the end scheduling time for the job.
    /// </param>
    /// <param name="_runtime">
    ///    A <c>Date</c> value that represents the runtime of the scheduled job.
    /// </param>
    /// <param name="_reservationProperties">
    ///    A <c>Container</c> with the reservation properties for the job.
    /// </param>
    /// <param name="_capacityReservations">
    ///    A <c>Container</c> with the capacity reservations for the scheduled job.
    /// </param>
    /// <param name="_physicalUpdateJobs">
    /// Optional; A boolean value indicating whether to do a physical database update,
    /// or update only the relevant internal maps and write capacity reservations.
    /// By default, jobs are physically updated when doing job scheduling.
    /// </param>
    public void writeJobData(RecId           _jobId,
                             WrkCtrId        _resourceId,
                             date            _fromDate,
                             TimeOfDay       _fromTime,
                             date            _toDate,
                             TimeOfDay       _toTime,
                             Seconds         _runtime,
                             container       _reservationProperties,
                             container       _capacityReservations,
                             boolean         _physicalUpdateJobs = true )
    {
        ProjForecastEmpl    projForecastEmpl;
        WrkCtrParmSchedule  wrkCtrParmSchedule;
        TimeOfDay           fromTime = _fromTime;
        TimeOfDay           toTime = _toTime;
        date                routeFromDate;
        TimeOfDay           routeFromTime;
        date                routeToDate;
        TimeOfDay           routeToTime;
        WrkCtrId            resourceId;

        if (saveReservationsConnection)
        {
            WrkCtrCapResHandler::initializeTransactionScopeHandlers();
        }

        wrkCtrParmSchedule = this.findJobWrkCtrParmSchedule(_jobId);
        projForecastEmpl = jobData.lookup(_jobId);

        if (wrkCtrParmSchedule.schedMethod() == SchedMethod::Rough)
        {
            fromTime = 0;
            toTime = 0;
        }

        // Aggregate times on route (operation) level
        if (!mapOperationData.exists(this.keyRoute(projForecastEmpl.ProjId, #defaultOprNum,  RouteOprPriority::Primary)))
        {
            routeFromDate = _fromDate;
            routeFromTime = fromTime;
            routeToDate = _toDate;
            routeToTime = toTime;
            resourceId = _resourceId;
        }
        else
        {
            [routeFromDate, routeFromTime, routeToDate, routeToTime, resourceId] = mapOperationData.lookup(this.keyRoute(projForecastEmpl.ProjId, #defaultOprNum,  RouteOprPriority::Primary));

            if ((_fromDate < routeFromDate) || (_fromDate == routeFromDate && fromTime < routeFromTime))
            {
                routeFromDate = _fromDate;
                routeFromTime = fromTime;
            }

            if ((_toDate > routeToDate) || (_toDate == routeToDate && toTime > routeToTime))
            {
                routeToDate = _toDate;
                routeToTime = toTime;
            }
        }

        mapOperationData.insert(this.keyRoute(projForecastEmpl.ProjId, #defaultOprNum,  RouteOprPriority::Primary), [routeFromDate, routeFromTime, routeToDate, routeToTime, resourceId]);

        mapOrderData.insert(projForecastEmpl.ProjId, [routeFromDate,routeFromTime,routeToDate, routeToTime]);

        // Update job records if doing Job Scheduling
        projForecastEmpl.SchedTimeHours = (_runtime / #SecondsPerHour);

        projForecastEmpl.SchedFromDate  = _fromDate;
        projForecastEmpl.SchedFromTime  = fromTime;
        projForecastEmpl.SchedToDate    = _toDate;
        projForecastEmpl.SchedToTime    = toTime;
        projForecastEmpl.SchedWrkCtrId  = _resourceId;

        if (this.shouldWriteJobData(projForecastEmpl))
        {
            projForecastEmpl.update();
        }

        this.writeJobCapacityReservations(wrkCtrParmSchedule, _jobId, _resourceId, _reservationProperties, _capacityReservations);

    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static WrkCtrScheduler_Proj construct()
    {
        return new WrkCtrScheduler_Proj();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCheckLockingTTSLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>WrkCtrScheduler_Proj</c> class.
    /// </summary>
    /// <param name="_checkLockingTTSLevel">
    /// A Boolean value that indicates whether the TTS level check is performed when locking is performed
    /// for capacity reservations saving.
    /// </param>
    /// <returns>
    /// A new instance of the <c>WrkCtrScheduler_Proj</c> class.
    /// </returns>
    public static WrkCtrScheduler_Proj newCheckLockingTTSLevel(boolean _checkLockingTTSLevel = true)
    {
        WrkCtrScheduler_Proj scheduler = new WrkCtrScheduler_Proj();

        scheduler.parmCheckLockingTTSLevel(_checkLockingTTSLevel);

        return scheduler;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSaveOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether updates should be saved.
    /// </summary>
    /// <returns>true if updates should be saved; otherwise, false.</returns>
    /// <remarks>
    /// Can be extended to return false for simulation scenarios.
    /// </remarks>
    protected boolean shouldSaveOrder()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldWriteJobData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Decides whether to updates job records if doing Job Scheduling
    /// </summary>
    /// <param name="_projForecastEmpl">
    /// A <c>ProjForecastEmp</c> table buffer containing the project hour forecast line.
    /// </param>
    /// <returns>true if updates should be saved; otherwise, false.</returns>
    /// <remarks>
    /// Can be extended to return false for simulation scenarios.
    /// </remarks>
    protected boolean shouldWriteJobData(ProjForecastEmpl _projForecastEmpl)
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>