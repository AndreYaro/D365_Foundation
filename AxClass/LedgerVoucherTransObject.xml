<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerVoucherTransObject</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>LedgerVoucherTransObject</c> class represents a single transaction in an individual voucher.
/// </summary>
/// <remarks>
///    The transaction is stored in a temporary instance of a <see cref="T:LedgerTrans" /> record buffer.
///    The temporary transaction is inserted into the database during posting and made a permanent record.
/// </remarks>
public class LedgerVoucherTransObject implements SysPackable
{
    // accounting data
    GeneralJournalAccountEntry generalJournalAccountEntry;
    LedgerEntry ledgerEntry;

    // <GEEU>
    GeneralJournalAccountEntry_W generalJournalAccountEntryW;
    // </GEEU>

    // internal
    LedgerDetailLevel transferLevel;
    boolean isChecked;
    boolean isModified;
    boolean isPosted;
    boolean ignoreAllocation;
    boolean discardLastTransTxt;
    boolean skipDimensionValidation;
    boolean skipBlockedForManualEntryCheck;
    boolean useTaxParentTaxUncommitted;

    // do not read this variable directly. It should always be retrieved by calling getTaxRelationshipType()
    TaxTransRelationshipType taxTransRelationshipType;
    boolean isTaxTransRelationshipTypeSet;

    // supporting data
    LedgerPostingOneToManyCollection taxTransGenJourAcctEntryCollection; // instantiate on demand

    // [[TableId, CompanyId], LedgerPostingOneToManyCollection]
    Map crossCompanyTaxLinkCollections; // instantiate on demand

    // <GIN>
    LedgerPostingOneToManyCollection taxWHTTransGenJourAcctEntryCollection;
    boolean isTaxWithholdParametersEnabled;
    // </GIN>

    ProjLedger projLedger;
    TableId accrualRefTableId;
    RecId accrualRefRecId;
    TableId taxParentReferenceTableId;
    RecId taxParentReferenceRecId;
    RecId interunitReference;
    RecId sourceRecId;
    TableId sourceTableId;
    private FinTagRecId finTag;

    // perf
    RecId tempRecId;
    RecId parentTempRecId;

    boolean isFinTagConfigurationSetForCurrent = FinTagConfiguration::isFinTagConfigurationSet(curExt());

    #define.ThrowForDuplicates(false)

    #DEFINE.CurrentVersion(10)
    #LOCALMACRO.CurrentList
        generalJournalAccountEntry.AllocationLevel,
        //generalJournalAccountEntry.GeneralJournalEntry <not included>
        generalJournalAccountEntry.AccountingCurrencyAmount,
        generalJournalAccountEntry.IsCorrection,
        generalJournalAccountEntry.IsCredit,
        generalJournalAccountEntry.LedgerDimension,
        generalJournalAccountEntry.PaymentReference,
        generalJournalAccountEntry.ProjId_SA,
        generalJournalAccountEntry.ProjTableDataAreaId,
        generalJournalAccountEntry.PostingType,
        generalJournalAccountEntry.ReportingCurrencyAmount,
        generalJournalAccountEntry.TransactionCurrencyAmount,
        generalJournalAccountEntry.TransactionCurrencyCode,
        generalJournalAccountEntry.Quantity,
        generalJournalAccountEntry.ReasonRef,
        generalJournalAccountEntry.SkipCreditCalculation,
        generalJournalAccountEntry.Text,
        generalJournalAccountEntry.RecId,
        generalJournalAccountEntry.HistoricalExchangeRateDate,

        // <GEEU>
        generalJournalAccountEntryW.BondBatchTrans_RU,
        generalJournalAccountEntryW.ConsolidatedRefRecId_BR,
        generalJournalAccountEntryW.ConsolidatedVoucher_BR,
        //generalJournalAccountEntryW.GeneralJournalAccountEntry <not included>
        // </GEEU>

        ledgerEntry.BankDataAreaId,
        ledgerEntry.CompanyBankAccount,
        ledgerEntry.ConsolidatedCompany,
        //ledgerEntry.GeneralJournalAccountEntry <not included>
        ledgerEntry.IsBridgingPosting,
        ledgerEntry.PaymentMode,
        ledgerEntry.ThirdPartyBankAccount,
        ledgerEntry.IsExchangeAdjustment,

        // <GIN>
        isTaxWithholdParametersEnabled,
        // </GIN>

        // Local data
        transferLevel,
        isChecked,
        //isModified <not included>
        isPosted,
        ignoreAllocation,
        discardLastTransTxt,
        skipDimensionValidation,
        skipBlockedForManualEntryCheck,
        accrualRefTableId,
        accrualRefRecId,
        taxParentReferenceTableId,
        taxParentReferenceRecId,
        sourceRecId,
        sourceTableId,
        parentTempRecId,
        tempRecId,
        interunitReference
    ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addTaxRelationship</Name>
				<Source><![CDATA[
    private void addTaxRelationship(LedgerVoucherObject _reference)
    {
        TaxTrans taxTrans;
        TaxUncommitted taxUncommitted;
        boolean foundTaxTrans;
        Voucher subledgerVoucher;

        // the default is to use the single company pattern because it
        // has better indexing than the cross company pattern
        subledgerVoucher = _reference.parmSubledgerVoucher();

        if (taxParentReferenceTableId != 0 && taxParentReferenceRecId != 0)
        {
            // if the tax trans is not generate and use async model, execute it.
            if (TaxEnginePostingProcessor::isAsyncTaxDocumentPostingMode()
                && !TaxTrans::existForVoucher(subledgerVoucher))
            {
                //Initialize because the caller shouldn't have to check it is null
                LedgerPostingOneToManyCollection  taxTransGenJourAcctEntryCollectionLoc =  this.parmTaxLinks();

                taxTransGenJourAcctEntryCollectionLoc.add(taxParentReferenceRecId, [taxParentReferenceTableId, this.parmAccountingCurrencyAmount(), this.parmTransactionCurrencyAmount()]);
                this.parmTaxLinks(taxTransGenJourAcctEntryCollectionLoc);
            }
            if (useTaxParentTaxUncommitted)
            {
                foundTaxTrans = false;

                while select RecId from taxTrans
                    where taxTrans.SourceTableId == taxParentReferenceTableId
                       && taxTrans.SourceRecId == taxParentReferenceRecId
                {
                    this.addTaxTransRelationship(taxTrans.RecId, this.getTaxTransRelationshipType(), taxTrans.company(), this.parmAccountingCurrencyAmount(), this.parmTransactionCurrencyAmount());
                    foundTaxTrans = true;
                }

                if (!foundTaxTrans)
                {
                    while select crossCompany RecId from taxTrans
                        where taxTrans.SourceTableId == taxParentReferenceTableId
                           && taxTrans.SourceRecId == taxParentReferenceRecId
                    {
                        this.addTaxTransRelationship(taxTrans.RecId, this.getTaxTransRelationshipType(), taxTrans.company(), this.parmAccountingCurrencyAmount(), this.parmTransactionCurrencyAmount());
                        foundTaxTrans = true;
                    }
                }

                if (!foundTaxTrans)
                {
                    // the requirement is to search TaxUncommitted only if nothing was found in TaxTrans
                    while select Company, RecId from taxUncommitted
                        where taxUncommitted.SourceTableId == taxParentReferenceTableId
                           && taxUncommitted.SourceRecId == taxParentReferenceRecId
                    {
                        this.addTaxUncommittedRelationship(taxUncommitted.RecId, taxUncommitted.Company, this.getTaxTransRelationshipType(), this.parmAccountingCurrencyAmount(), this.parmTransactionCurrencyAmount());
                        foundTaxTrans = true;
                    }
                }

                if (!foundTaxTrans)
                {
                    // the requirement is to search TaxUncommitted only if nothing was found in TaxTrans
                    while select crossCompany Company, RecId from taxUncommitted
                        where taxUncommitted.SourceTableId == taxParentReferenceTableId
                           && taxUncommitted.SourceRecId == taxParentReferenceRecId
                    {
                        this.addTaxUncommittedRelationship(taxUncommitted.RecId, taxUncommitted.Company, this.getTaxTransRelationshipType(), this.parmAccountingCurrencyAmount(), this.parmTransactionCurrencyAmount());
                    }
                }
            }
            else
            {
                while select RecId from taxTrans
                    where taxTrans.SourceTableId == taxParentReferenceTableId
                       && taxTrans.SourceRecId == taxParentReferenceRecId
                       && taxTrans.Voucher == subledgerVoucher
                {
                    this.addTaxTransRelationship(taxTrans.RecId, this.getTaxTransRelationshipType(), curext(), this.parmAccountingCurrencyAmount(), this.parmTransactionCurrencyAmount());
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTaxTransRelationship</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a relationship to the specified <c>TaxTrans</c> record.
    /// </summary>
    /// <param name="_taxTransRecId">
    ///    The record ID of the <c>TaxTrans</c> record.
    /// </param>
    /// <param name="_taxRelationshipType">
    ///    The tax relationship type.
    /// </param>
    /// <param name="_companyId">
    /// The company ID of the <c>TaxTrans</c> record; optional.
    /// </param>
    /// <param name="_accountingCurrencyAmount">
    /// The accounting currency amount to associate with the <c>TaxTransGeneralJournalAccountEntry</c> record; optional.
    /// </param>
    /// <param name="_transactionCurrencyAmount">
    /// The transaction currency amount to associate with the <c>TaxTransGeneralJournalAccountEntry</c> record; optional.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    The record ID of the <c>TaxTrans</c> record is zero.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    /// The company ID is an empty string.
    /// </exception>
    public void addTaxTransRelationship(
        TaxTransRecId _taxTransRecId,
        TaxTransRelationshipType _taxRelationshipType,
        CompanyId _companyId = curext(),    // optional for backward compatibility
        AmountMST _accountingCurrencyAmount = 0,
        AmountCur _transactionCurrencyAmount = 0)
    {
        LedgerPostingOneToManyCollection taxTransLinks;
        container keyValue;

        if (_taxTransRecId == 0 || _companyId == '')
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (_companyId == curext())
        {
            if (taxTransGenJourAcctEntryCollection == null)
            {
                taxTransGenJourAcctEntryCollection = LedgerPostingOneToManyCollection::construct(
                    Types::Int64, // use this instead of RecId for perf
                    Types::Container,
                    #ThrowForDuplicates);
            }

            taxTransGenJourAcctEntryCollection.add(_taxTransRecId, [_taxRelationshipType, _accountingCurrencyAmount, _transactionCurrencyAmount]);
        }
        else
        {
            if (crossCompanyTaxLinkCollections == null)
            {
                crossCompanyTaxLinkCollections = new Map(Types::Container, Types::Class);
            }

            keyValue = [tableNum(TaxTrans), _companyId];

            if (crossCompanyTaxLinkCollections.exists(keyValue))
            {
                taxTransLinks = crossCompanyTaxLinkCollections.lookup(keyValue);
            }
            else
            {
                taxTransLinks = LedgerPostingOneToManyCollection::construct(
                    Types::Int64, // use this instead of RecId for perf
                    Types::Container,
                    #ThrowForDuplicates);

                crossCompanyTaxLinkCollections.insert(keyValue, taxTransLinks);
            }

            taxTransLinks.add(_taxTransRecId, [_taxRelationshipType, _accountingCurrencyAmount, _transactionCurrencyAmount]);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTaxUncommittedRelationship</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a relationship to the specified <c>TaxUncommitted</c> record.
    /// </summary>
    /// <param name="_taxUncommittedRecId">
    /// The record ID of the <c>TaxUncommitted</c> record.
    /// </param>
    /// <param name="_companyId">
    /// The company ID of the <c>TaxUncommitted</c> record.
    /// </param>
    /// <param name="_taxRelationshipType">
    /// The tax relationship type.
    /// </param>
    /// <param name="_accountingCurrencyAmount">
    /// The accounting currency amount to associate with the <c>TaxTransGeneralJournalAccountEntry</c> record; optional.
    /// </param>
    /// <param name="_transactionCurrencyAmount">
    /// The transaction currency amount to associate with the <c>TaxTransGeneralJournalAccountEntry</c> record; optional.
    /// </param>
    /// <exception cref="M:Exception::Error">
    /// The record ID of the <c>TaxUncommitted</c> record is zero.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    /// The company ID is an empty string.
    /// </exception>
    private void addTaxUncommittedRelationship(
        RecId _taxUncommittedRecId,
        CompanyId _companyId,
        TaxTransRelationshipType _taxRelationshipType,
        AmountMST _accountingCurrencyAmount = 0,
        AmountCur _transactionCurrencyAmount = 0)
    {
        LedgerPostingOneToManyCollection taxUncommittedLinks;
        container keyValue;

        if (_taxUncommittedRecId == 0 || _companyId == '')
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (crossCompanyTaxLinkCollections == null)
        {
            crossCompanyTaxLinkCollections = new Map(Types::Container, Types::Class);
        }

        keyValue = [tableNum(TaxUncommitted), _companyId];

        if (crossCompanyTaxLinkCollections.exists(keyValue))
        {
            taxUncommittedLinks = crossCompanyTaxLinkCollections.lookup(keyValue);
        }
        else
        {
            taxUncommittedLinks = LedgerPostingOneToManyCollection::construct(
                Types::Int64, // use this instead of RecId for perf
                Types::Container,
                #ThrowForDuplicates);

            crossCompanyTaxLinkCollections.insert(keyValue, taxUncommittedLinks);
        }

        taxUncommittedLinks.add(_taxUncommittedRecId, [_taxRelationshipType, _accountingCurrencyAmount, _transactionCurrencyAmount]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTaxWHTTransRelationship_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a tax transaction relationship.
    /// </summary>
    /// <param name="_taxWHTransRecId">
    ///    The record ID of the TaxWithholdTrans record.
    /// </param>
    /// <param name="_taxRelationshipType">
    ///    The tax relationship type
    /// </param>
    /// <param name="_accountingCurrencyAmount">
    ///    The accounting currency amount to associate with the <c>TaxTransGeneralJournalAccountEntry</c> record; optional.
    /// </param>
    /// <param name="_transactionCurrencyAmount">
    ///    The transaction currency amount to associate with the <c>TaxTransGeneralJournalAccountEntry</c> record; optional.
    /// </param>
    // <GIN>
    public void addTaxWHTTransRelationship_IN(
        RefRecId _taxWHTransRecId,
        TaxTransRelationshipType _taxRelationshipType,
        AmountMST _accountingCurrencyAmount = 0,
        AmountCur _transactionCurrencyAmount = 0)
    {
        if (_taxWHTransRecId == 0)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (!taxWHTTransGenJourAcctEntryCollection)
        {
            taxWHTTransGenJourAcctEntryCollection = LedgerPostingOneToManyCollection::construct(
                Types::Int64, // use this instead of RecId for perf
                Types::Container,
                #ThrowForDuplicates);
        }

        taxWHTTransGenJourAcctEntryCollection.add(_taxWHTransRecId, [_taxRelationshipType, _accountingCurrencyAmount, _transactionCurrencyAmount]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToGeneralJournal</Name>
				<Source><![CDATA[
    // </GIN>

    /// <summary>
    ///    Adds the transaction to the general journal.
    /// </summary>
    /// <param name="_journal">
    ///    The ledger posting journal containing the transaction.
    /// </param>
    /// <param name="_reference">
    ///    The ledger posting reference containing the transaction.
    /// </param>
    /// <remarks>
    ///    Any changes made to the transaction after it has been added to the general journal will not be
    ///    realized.
    /// </remarks>
    public void addToGeneralJournal(LedgerVoucher _journal, LedgerVoucherObject _reference)
    {
        // <GEERU>
        if (_reference.ledgerBondClient_RU())
        {
            _reference.bondAddToApplier_RU(this, this.getAdjustedTransferLevel(_journal));
        }
        else
        {
        // </GEERU>
            this.addTaxRelationship(_reference);

            // <GIN>
            if ( isTaxWithholdParametersEnabled
                    && (generalJournalAccountEntry.PostingType == LedgerPostingType::TDS_IN
                        || generalJournalAccountEntry.PostingType == LedgerPostingType::TCS_IN) )
            {
                _reference.addToGeneralJournal(
                    _journal,
                    this.getAdjustedTransferLevel(_journal),
                    generalJournalAccountEntry,
                    ledgerEntry,
                    taxWHTTransGenJourAcctEntryCollection,
                    // <GEEU>
                    generalJournalAccountEntryW,
                    // </GEEU>
                    crossCompanyTaxLinkCollections
                    );
            }
            else
            {
            // </GIN>
                _reference.addToGeneralJournal(
                    _journal,
                    this.getAdjustedTransferLevel(_journal),
                    generalJournalAccountEntry,
                    ledgerEntry,
                    taxTransGenJourAcctEntryCollection,
                    // <GEEU>
                    generalJournalAccountEntryW,
                    // </GEEU>
                    crossCompanyTaxLinkCollections
                    );
            // <GIN>
            }
            // </GIN>
        // <GEERU>
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToSubledgerJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the transaction to the subledger journal.
    /// </summary>
    /// <param name="_journal">
    /// The ledger posting journal.
    /// </param>
    /// <param name="_reference">
    /// The ledger posting reference.
    /// </param>
    /// <remarks>
    /// This method is for ledger voucher framework internal use only.
    /// </remarks>
    protected void addToSubledgerJournal(LedgerVoucher _journal, LedgerVoucherObject _reference)
    {
        this.addTaxRelationship(_reference);

        // Cross company tax transactions are not supported.
        if (crossCompanyTaxLinkCollections != null && crossCompanyTaxLinkCollections.elements())
        {
            throw error( Error::wrongUseOfFunction(funcName()));
        }

        _reference.addToSubledgerJournal(
            _journal,
            this.getAdjustedTransferLevel(_journal),
            generalJournalAccountEntry,
            taxTransGenJourAcctEntryCollection);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAccountStructure</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if the specified main account is valid for the current chart of accounts.
    /// </summary>
    /// <param name = "_journal">
    ///    The ledger posting journal of this transaction.
    /// </param>
    /// <param name = "_reference">
    ///    The ledger posting reference of this transaction.
    /// </param>
    /// <param name = "_mainAccount">
    ///    A <c>MainAccount</c> record.
    /// </param>
    /// <returns>
    ///    true if the specified main account is valid for the current chart of accounts; otherwise, false.
    /// </returns>
    protected boolean checkAccountStructure(LedgerVoucher _journal, LedgerVoucherObject _reference, MainAccount _mainAccount)
    {
        return (!skipDimensionValidation && (_mainAccount.LedgerChartOfAccounts != LedgerChartOfAccounts::current()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAccrualUnspecified</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if any accrual information is not specified.
    /// </summary>
    /// <param name = "_journal">
    ///    The ledger posting journal of this transaction.
    /// </param>
    /// <param name = "_reference">
    ///    The ledger posting reference of this transaction.
    /// </param>
    /// <returns>
    ///    true if any accrual information is not specified; otherwise, false.
    /// </returns>
    protected boolean isAccrualUnspecified(LedgerVoucher _journal, LedgerVoucherObject _reference)
    {
        return (accrualRefTableId == 0 || accrualRefRecId == 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>check</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determine whether the date, account, posting type and dimension values for a single ledger line 
    ///    are valid to post it.
    /// </summary>
    /// <param name="_journal">
    ///    The ledger posting journal of this transaction.
    /// </param>
    /// <param name="_reference">
    ///    The ledger posting reference of this transaction.
    /// </param>
    /// <returns>
    ///    true if the ledger line is valid to post; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The <paramref name="_sysModule" /> parameter is necessary because journals can be created in
    ///    multiple modules.
    ///    Use the isModified method to determine if the current object was modified by this method.
    /// </remarks>
    private boolean check(LedgerVoucher _journal, LedgerVoucherObject _reference)
    {
        boolean ok = true;
        boolean needToValidate;
        boolean firstErrorAccount;
        boolean doSuspendedAndActiveDateValidation;
        DimensionAttributeValueCombination dimAttrValueCombo;
        MainAccount mainAccount;
        TransDate accountingDate;
        LedgerPostingMessageLog ledgerPostingMessageCollection;
    
        //
        // This code can be called within the context of different companies during a single posting so all
        // key values in maps and sets must be prefaced by the company.
        //
    
        // isModified is used for a single method call on this object because
        // that is the scope required when checking for object modifications
        isModified = false;
    
        if (isChecked)
        {
            // do nothing if this method has already been called because we
            // may call it more than once to ensure it is called at least once
            return true;
        }
    
        ledgerPostingMessageCollection = _journal.parmLedgerPostingMessageLog();
        ledgerPostingMessageCollection.setTableIdRecId(sourceTableId, sourceRecId);
    
        if (!_journal.checkPostingType(generalJournalAccountEntry.PostingType))
        {
            ok = ledgerPostingMessageCollection.logCheckFailedTableIdRecId(
                sourceTableId,
                sourceRecId,
                strFmt("@TaxEngineTaxPosting:TaxPostingTypeEmpty",
                LedgerDimensionFacade::getDisplayValueForLedgerDimension(generalJournalAccountEntry.LedgerDimension)));
        }

        if (generalJournalAccountEntry.PostingType == LedgerPostingType::TransferOpeningClosing 
            && this.isFiscalCalendarPeriodNotClosingType(_reference.parmFiscalCalendarPeriod()))
        {
            ok = ledgerPostingMessageCollection.logCheckFailedTableIdRecId(
                sourceTableId,
                sourceRecId,
                strFmt("@GeneralLedger:LedgerPostingNotAllowTransferOpeningClosingType",
                generalJournalAccountEntry.PostingType,
                LedgerDimensionFacade::getDisplayValueForLedgerDimension(generalJournalAccountEntry.LedgerDimension)));
        }
        accountingDate = _reference.parmAccountingDate();
    
        if (!_journal.parmReversal())
        {
            if (generalJournalAccountEntry.LedgerDimension == 0)
            {
                ok = ledgerPostingMessageCollection.logCheckFailedTableIdRecId(
                    sourceTableId,
                    sourceRecId,
                    strFmt("@SYS24816", generalJournalAccountEntry.PostingType));
            }
            else
            {
                isModified = generalJournalAccountEntry.applyFixedDimensions();
    
                firstErrorAccount = true;
                needToValidate = true;
                while (needToValidate)
                {
                    needToValidate = false;
    
                    mainAccount = _journal.getMainAccountFromCache(
                        generalJournalAccountEntry.LedgerDimension,
                        accountingDate,
                        generalJournalAccountEntry.PostingType);
    
                    dimAttrValueCombo.DisplayValue = _journal.getLedgerAccountFromCache(generalJournalAccountEntry.LedgerDimension);
    
                    if (mainAccount == null)
                    {
                        // validate the ledger dimension that was not in the cache
                        select firstonly DisplayValue, ImpliedDataAreaId, RecId from dimAttrValueCombo
                            where dimAttrValueCombo.RecId == generalJournalAccountEntry.LedgerDimension
                        join firstonly * from mainAccount
                            where mainAccount.RecId == dimAttrValueCombo.MainAccount;
    
                        str companyId = _journal.parmCompanyId();
                        if (!companyId)
                        {
                            companyId = curext();
                        }
                        if (dimAttrValueCombo.ImpliedDataAreaId && dimAttrValueCombo.ImpliedDataAreaId != companyId)
                        {
                            LedgerVoucherInstrumentation::logError(strFmt(LedgerJournalInstrumentationConstants::VoucherErrorCrossCompanyDimensionCorruption, dimAttrValueCombo.DisplayValue, dimAttrValueCombo.ImpliedDataAreaId, companyId, dimAttrValueCombo.RecId));
                        }
                        if (mainAccount == null)
                        {
                            // consider message -- Account number is not specified.
                            ok = ledgerPostingMessageCollection.logCheckFailedTableIdRecId(
                                sourceTableId,
                                sourceRecId,
                                strFmt("@GeneralLedger:LedgerAccountMissingMainAccount", generalJournalAccountEntry.PostingType,
                                    LedgerDimensionFacade::getDisplayValueForLedgerDimension(generalJournalAccountEntry.LedgerDimension),
                                    sourceRecId));

                            LedgerVoucherInstrumentation::logError(LedgerJournalInstrumentationConstants::VoucherErrorMissingAccountNumber);
                        }
                        else if (this.checkAccountStructure(_journal, _reference, mainAccount))
                        {
                            ok = ledgerPostingMessageCollection.logCheckFailedTableIdRecId(
                                sourceTableId,
                                sourceRecId,
                                strFmt(
                                "@GeneralLedger:AccountStructureCombinationCheckMessage",
                                mainAccount.MainAccountId,
                                LedgerChartOfAccounts::find(LedgerChartOfAccounts::current()).Name,
                                Ledger::find(Ledger::current()).Name,
                                generalJournalAccountEntry.LedgerDimension));

                            LedgerVoucherInstrumentation::logError(strFmt(LedgerJournalInstrumentationConstants::VoucherErrorInvalidLedgerDimensionCombination,
                                DimensionAttributeValueCombination::find(generalJournalAccountEntry.LedgerDimension).AccountStructure,
                                generalJournalAccountEntry.LedgerDimension));
                        }
                        else
                        {
                            LedgerVoucherTransObjectPerformDimensionValidationArgs parameters = LedgerVoucherTransObjectPerformDimensionValidationArgs::construct();
    
                            parameters.parmJournal(_journal);
                            parameters.parmReference(_reference);
                            parameters.parmAccountingDate(accountingDate);
                            parameters.parmOk(ok);
                            parameters.parmLedgerPostingMessageCollection(ledgerPostingMessageCollection);
                            parameters.parmMainAccount(mainAccount);
                            parameters.parmDimAttrValueCombo(dimAttrValueCombo);
                            parameters.parmFirstErrorAccount(firstErrorAccount);
    
                            [ok, firstErrorAccount, needToValidate] = this.performDimensionValidation(parameters);
                        }
                    } // not in cache
    
                    // always validate the currency code because it is not a part of the cache
                    ok = mainAccount.checkAccountCurrencyForPosting(
                        generalJournalAccountEntry.TransactionCurrencyCode,
                        generalJournalAccountEntry.isExchangeAdjustment(),
                        ledgerPostingMessageCollection) && ok;
    
                    if (ok)
                    {
                        generalJournalAccountEntry.LedgerAccount = dimAttrValueCombo.DisplayValue;
                        generalJournalAccountEntry.MainAccount = mainAccount.RecId;
                        isModified = true;
                    }
    
                    this.addBalanceDemand(
                        _journal,
                        mainAccount,
                        accountingDate,
                        this.parmAccountingCurrencyAmount());
                } // while
            } // ledger dimension is not empty
        } // not a reversal
        // validate the amounts
        ok = this.checkRounding(ledgerPostingMessageCollection) && ok;
        ok = this.checkDebitCredit(mainAccount, ledgerPostingMessageCollection) && ok;
    
        if (ok)
        {
            // mark as checked because checking again is a performance drain
            isChecked = true;
            isModified = true;
        }
    
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>performDimensionValidation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the dimension value of a single ledger line is valid to post.
    /// </summary>
    /// <param name = "parameters">
    /// An <c>LedgerVoucherTransObjectPerformDimensionValidationArgs</c> instance.
    /// </param>
    /// <returns>
    /// The container containing the boolean value of ledger line is valid to post, boolean value of Dimension values are modified or not, the boolean value of first error account and boolean value to specify the need to validate the dimensions or not.
    /// </returns>
    [Wrappable(true)]
    protected final container performDimensionValidation(LedgerVoucherTransObjectPerformDimensionValidationArgs parameters)
    {
        boolean needToValidate;
        boolean firstErrorAccount = parameters.parmFirstErrorAccount();
        LedgerVoucher journal = parameters.parmJournal();
        boolean ok = parameters.parmOk();
    
        const boolean NotMandatory = false;
        const boolean CheckUser = true;
        
        LedgerPostingMessageLog ledgerPostingMessageCollection = parameters.parmLedgerPostingMessageCollection();

        if (!skipDimensionValidation)
        {
            DimensionValidationStatusContract dimensionValidationStatusContract = LedgerDimensionValidation::getStatusForAccountingDate(
                                    generalJournalAccountEntry.LedgerDimension,
                                    parameters.parmAccountingDate(),
                                    journal.parmCheckBlockedDimensions());

            if (LedgerJournalDimensionStructureChangePostingFixFlight::instance().isFlightEnabled() && dimensionValidationStatusContract.hasStructureChanged())
            {
                isModified = generalJournalAccountEntry.syncLedgerDimensionStructureChanges();

                //retry validation after syncing structure changes
                dimensionValidationStatusContract = LedgerDimensionValidation::getStatusForAccountingDate(
                    generalJournalAccountEntry.LedgerDimension,
                    parameters.parmAccountingDate(),
                    journal.parmCheckBlockedDimensions());
            }
    
            if (!dimensionValidationStatusContract.isValid())
            {
                ok = false;
                boolean isFirst = true;
    
                List validationMessages = dimensionValidationStatusContract.parmValidationMessages();
    
                ListEnumerator messagesEnumerator = validationMessages.getEnumerator();
    
                while (messagesEnumerator.moveNext())
                {
                    // The first message provided is a warning, additional messages are informational
                    // messages regarding the first message
                    if (isFirst)
                    {
                        ledgerPostingMessageCollection.logAndThrowWarningTableIdRecId(
                                                sourceTableId,
                                                sourceRecId,
                                                messagesEnumerator.current());
    
                        isFirst = false;
                    }
                    else
                    {
                        info(messagesEnumerator.current());
    
                        // TableId and RecId context do not need to be provided for the informational messages
                        // for the originating warning message
                        ledgerPostingMessageCollection.addMessage(messagesEnumerator.current());
                    }
                }
            }
        }
    
        boolean tempIsValid = parameters.parmMainAccount().checkForPosting(
                                generalJournalAccountEntry.PostingType,
                                NotMandatory,
                                this.mustValidateBlockedForManualEntry(journal, parameters.parmReference()),
                                CheckUser,
                                ledgerPostingMessageCollection) && ok;
        
        if (tempIsValid && !skipDimensionValidation)
        {
            // ledger dimension, accounting date, and posting type combination is valid
            journal.addMainAccountToCache(
                                    parameters.parmMainAccount(),
                                    generalJournalAccountEntry.LedgerDimension,
                                    parameters.parmAccountingDate(),
                                    generalJournalAccountEntry.PostingType);
    
            journal.addLedgerAccountToCache(
                                    parameters.parmDimAttrValueCombo().DisplayValue,
                                    generalJournalAccountEntry.LedgerDimension);
        }
        else
        {
            if (firstErrorAccount && !skipDimensionValidation)
            {
                firstErrorAccount = false;
    
                if (LedgerParameters::find().AbortErrorAccount)
                {
                    // vague message for the scenario
                    // Update has been canceled because of an error.
                    ok = ledgerPostingMessageCollection.logCheckFailedTableIdRecId(
                                            sourceTableId,
                                            sourceRecId,
                                            "@SYS21628");
                }
                else
                {
                    LedgerDimensionDefaultAccount defaultAccount = LedgerSystemAccounts::getDefaultAccount(LedgerPostingType::ErrorAccount);
    
                    if (defaultAccount == 0)
                    {
                        // vague message for the scenario
                        // Account number for transaction type %1 does not exist.
                        ok = ledgerPostingMessageCollection.logCheckFailedTableIdRecId(
                                                sourceTableId,
                                                sourceRecId,
                                                strFmt("@SYS24816", LedgerPostingType::ErrorAccount));
                    }
                    else
                    {
                        generalJournalAccountEntry.LedgerDimension =
                                                LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(defaultAccount, generalJournalAccountEntry.LedgerDimension);
    
                        // need to verify the new ledger dimension
                        needToValidate = true;
    
                        // mark as modified because the caller may need to react to the modification
                        isModified = true;
                    }
                }
            }
        }

        return [ok, firstErrorAccount, needToValidate];
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBalanceDemand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds balance demand entries for the ledger posting journal.
    /// </summary>
    /// <param name="_journal">
    /// The ledger posting journal of this transaction.
    /// </param>
    /// <param name="_mainAccount">
    /// The main account.
    /// </param>
    /// <param name="_accountingDate">
    /// The accounting date.
    /// </param>
    /// <param name = "_accountingCurrencyAmount">
    /// The amount in accounting currency.
    /// </param>
    protected void addBalanceDemand(
        LedgerVoucher _journal,
        MainAccount _mainAccount,
        TransDate _accountingDate,
        AmountMST _accountingCurrencyAmount)
    {
        _journal.addBalanceDemand(
                        _mainAccount,
                        _accountingDate,
                        _accountingCurrencyAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustValidateBlockedForManualEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value that indicates whether validation must be executed to check if the record is blocked for manual entry.
    /// </summary>
    /// <param name="_journal">
    /// The ledger posting journal of this transaction.
    /// </param>
    /// <param name="_reference">
    /// The ledger posting reference of this transaction.
    /// </param>
    /// <returns>
    /// true to enable validation; otherwise, false.
    /// </returns>
    protected boolean mustValidateBlockedForManualEntry(LedgerVoucher _journal, LedgerVoucherObject _reference)
    {
        boolean skipBlockedForManualEntryCheckLocal;
        if (this.isAccrualUnspecified(_journal, _reference))
        {
            skipBlockedForManualEntryCheckLocal = skipBlockedForManualEntryCheck;

            if (!skipBlockedForManualEntryCheckLocal)
            {
                skipBlockedForManualEntryCheckLocal = _journal.parmSkipBlockedForManualEntryCheck();
            }
        }
        else
        {
            skipBlockedForManualEntryCheckLocal = true;
        }

        return !skipBlockedForManualEntryCheckLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the ledger posting transaction.
    /// </summary>
    /// <param name="_journal">
    ///    The ledger posting journal of the transaction.
    /// </param>
    /// <param name="_reference">
    ///    The ledger posting reference of the transaction.
    /// </param>
    /// <returns>
    ///    true if the ledger posting transaction is valid; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    If the transaction is an intercompany transaction, this method changes the current company account
    ///    before the <c>check</c> method is called.When validating inter-company transactions, the voucher
    ///    series code of the <c>LedgerVoucher</c> object is temporarily changed to the voucher series code of
    ///    the intercompany company account.
    ///    Use the isModified method to determine if the current object was modified by this method.
    /// </remarks>
    public boolean checkData(LedgerVoucher _journal, LedgerVoucherObject _reference)
    {
        boolean isValid;

        if (isChecked)
        {
            // isModified is used for a single method call on this object because
            // that is the scope required when checking for object modifications
            isModified = false;

            isValid = true;
        }
        else
        {
            // check may be called with checkDuplicate=false as long as we are sure
            // that we only do it when posting from journals.
            // company is only set when posting from journals, that's how we are sure
            isValid = this.check(_journal, _reference);
            if (!isValid)
            {
                info(strFmt("@SYS25424", curext()));
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDebitCredit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that the debit or credit requirement.
    /// </summary>
    /// <param name="_mainAccount">
    ///    The main account.
    /// </param>
    /// <param name="_ledgerPostingMessageCollection">
    ///    The posting messages collection.
    /// </param>
    /// <returns>
    ///    true if no errors were found; otherwise, false.
    /// </returns>
    private boolean checkDebitCredit(MainAccount _mainAccount, LedgerPostingMessageLog _ledgerPostingMessageCollection)
    {
        switch (_mainAccount.DebitCreditCheck)
        {
            case DebCredProposal::Debit:
                if ((generalJournalAccountEntry.AccountingCurrencyAmount < 0 && !generalJournalAccountEntry.IsCorrection) ||
                    (generalJournalAccountEntry.AccountingCurrencyAmount > 0 && generalJournalAccountEntry.IsCorrection))
                {
                    return _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS18433", LedgerDimensionFacade::getDisplayValueForLedgerDimension(generalJournalAccountEntry.LedgerDimension)));
                }
                break;

            case DebCredProposal::Credit:
                if ((generalJournalAccountEntry.AccountingCurrencyAmount > 0 && !generalJournalAccountEntry.IsCorrection) ||
                    (generalJournalAccountEntry.AccountingCurrencyAmount < 0 && generalJournalAccountEntry.IsCorrection))
                {
                    return _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS18434", LedgerDimensionFacade::getDisplayValueForLedgerDimension(generalJournalAccountEntry.LedgerDimension)));
                }
                break;

            default:
                return true;
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkRounding</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that the transaction amounts are properly rounded.
    /// </summary>
    /// <param name="_ledgerPostingMessageCollection">
    ///    The posting messages collection.
    /// </param>
    /// <returns>
    ///    true if the amounts are properly rounded; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The transaction amounts are validated based on to the rounding rules for the specified currency.
    /// </remarks>
    protected boolean checkRounding(LedgerPostingMessageLog _ledgerPostingMessageCollection)
    {
        CurrencyCode accountingCurrency = Ledger::accountingCurrency();

        AmountMST roundedAmount = CurrencyExchange::round(generalJournalAccountEntry.AccountingCurrencyAmount, accountingCurrency); 

        if (generalJournalAccountEntry.AccountingCurrencyAmount != roundedAmount)
        {
            error(strFmt(
                "@SYS27168",
                accountingCurrency,
                Currency::roundingPrecisionAdjusted(accountingCurrency)));

            // the message includes "penny rounding threshhold" which seems wrong
            // The unit of %1 %2 being posted to account %3 is outside the current penny rounding threshold.
            return _ledgerPostingMessageCollection.logCheckFailed(strFmt(
                "@SYS18429",
                num2str(generalJournalAccountEntry.AccountingCurrencyAmount, 0, 16, -1, -1),
                accountingCurrency,
                LedgerDimensionFacade::getDisplayValueForLedgerDimension(generalJournalAccountEntry.LedgerDimension)));
        }

        if (generalJournalAccountEntry.TransactionCurrencyCode != '')
        {
            roundedAmount = CurrencyExchange::round(generalJournalAccountEntry.TransactionCurrencyAmount, generalJournalAccountEntry.TransactionCurrencyCode);

            if (generalJournalAccountEntry.TransactionCurrencyAmount != roundedAmount)
            {
                error(strFmt(
                    "@SYS27168",
                    generalJournalAccountEntry.TransactionCurrencyCode,
                    Currency::roundingPrecisionAdjusted(generalJournalAccountEntry.TransactionCurrencyCode)));

                return _ledgerPostingMessageCollection.logCheckFailed(strFmt(
                    "@SYS18429",
                    num2str(generalJournalAccountEntry.TransactionCurrencyAmount, 0, 16, -1, -1),
                    generalJournalAccountEntry.TransactionCurrencyCode,
                    LedgerDimensionFacade::getDisplayValueForLedgerDimension(generalJournalAccountEntry.LedgerDimension)));
            }
        }

        CurrencyCode reportingCurrency = Ledger::reportingCurrency();

        if (reportingCurrency)
        {
            roundedAmount = CurrencyExchange::round(generalJournalAccountEntry.ReportingCurrencyAmount, reportingCurrency);
        
            if (generalJournalAccountEntry.ReportingCurrencyAmount != roundedAmount)
            {
                error(strFmt(
                    "@SYS27168",
                    reportingCurrency,
                    Currency::roundingPrecisionAdjusted(reportingCurrency)));

                return _ledgerPostingMessageCollection.logCheckFailed(strFmt(
                    "@SYS18429",
                    num2str(generalJournalAccountEntry.ReportingCurrencyAmount, 0, 16, -1, -1),
                    reportingCurrency,
                    LedgerDimensionFacade::getDisplayValueForLedgerDimension(generalJournalAccountEntry.LedgerDimension)));
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFiscalCalendarPeriodNotClosingType</Name>
				<Source><![CDATA[
    private boolean isFiscalCalendarPeriodNotClosingType(FiscalCalendarPeriodRecId _fiscalCalendarPeriod)
    {
        FiscalCalendarPeriod fiscalCalendarPeriod;

        select firstonly Type from fiscalCalendarPeriod
            where fiscalCalendarPeriod.RecId == _fiscalCalendarPeriod;

        return fiscalCalendarPeriod 
            && fiscalCalendarPeriod.Type != FiscalPeriodType::Closing;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clone</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>LedgerVoucherTransObject</c> instance with the values from the current instance.
    /// </summary>
    /// <returns>
    /// A new <c>LedgerVoucherTransObject</c> instance with values from the current instance.
    /// </returns>
    public LedgerVoucherTransObject clone()
    {
        LedgerVoucherTransObject transaction = new LedgerVoucherTransObject(
            this.parmLedgerPostingType(),
            this.parmCurrencyCode(),
            this.parmLedgerDimensionId());

        transaction.parmGeneralJournalAccountEntry(this.parmGeneralJournalAccountEntry());
        transaction.parmLedgerEntry(this.parmLedgerEntry());

        // don't clone the custom transfer level because posting duplicate values is not supported
        transaction.parmCustomTransferLevel(0);

        transaction.parmDiscardLastTransTxt(this.parmDiscardLastTransTxt());
        transaction.parmAccrualInfo(accrualRefTableId, accrualRefRecId);
        transaction.parmLedgerDetailLevel(this.parmLedgerDetailLevel());
        transaction.parmProjLedger(this.parmProjLedger());
        transaction.parmThisIsARoundingTrans(this.parmThisIsARoundingTrans());

        return transaction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAdjustedTransferLevel</Name>
				<Source><![CDATA[
    public DetailSummary getAdjustedTransferLevel(LedgerVoucher _journal)
    {
        DetailSummary adjustedTransferLevel;

        if (_journal.parmCustomDetailLevel() && generalJournalAccountEntry.RecId != 0)
        {
            // custom summarization requires transfer in detail
            adjustedTransferLevel = DetailSummary::Detail;
        }
        else
        {
            // use the standard setting
            adjustedTransferLevel = _journal.getTransferLevel(transferLevel);
        }

        return adjustedTransferLevel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerPostingTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>LedgerPostingTransactionTmp</c> record for the current object.
    /// </summary>
    /// <returns>
    /// The <c>LedgerPostingTransactionTmp</c> record.
    /// </returns>
    public LedgerPostingTransactionTmp getLedgerPostingTransaction()
    {
        LedgerPostingTransactionTmp ledgerPostingTransaction;

        ledgerPostingTransaction.AllocationLevel = generalJournalAccountEntry.AllocationLevel;
        ledgerPostingTransaction.AccountingCurrencyAmount = generalJournalAccountEntry.AccountingCurrencyAmount;
        ledgerPostingTransaction.HistoricalExchangeRateDate = generalJournalAccountEntry.HistoricalExchangeRateDate;
        ledgerPostingTransaction.IsCorrection = generalJournalAccountEntry.IsCorrection;
        ledgerPostingTransaction.IsCredit = generalJournalAccountEntry.IsCredit;
        ledgerPostingTransaction.LedgerDimension = generalJournalAccountEntry.LedgerDimension;
        ledgerPostingTransaction.PaymentReference = generalJournalAccountEntry.PaymentReference;
        ledgerPostingTransaction.PostingType = generalJournalAccountEntry.PostingType;
        ledgerPostingTransaction.ReportingCurrencyAmount = generalJournalAccountEntry.ReportingCurrencyAmount;
        ledgerPostingTransaction.TransactionCurrencyAmount = generalJournalAccountEntry.TransactionCurrencyAmount;
        ledgerPostingTransaction.TransactionCurrencyCode = generalJournalAccountEntry.TransactionCurrencyCode;
        ledgerPostingTransaction.Quantity = generalJournalAccountEntry.Quantity;
        ledgerPostingTransaction.ReasonRef = generalJournalAccountEntry.ReasonRef;
        ledgerPostingTransaction.SkipCreditCalculation = generalJournalAccountEntry.SkipCreditCalculation;
        ledgerPostingTransaction.Text = generalJournalAccountEntry.Text;
        ledgerPostingTransaction.GeneralJournalAccountEntry = generalJournalAccountEntry.RecId;

        ledgerPostingTransaction.BondBatchTrans_RU = generalJournalAccountEntryW.BondBatchTrans_RU;
        ledgerPostingTransaction.ConsolidatedRefRecId_BR = generalJournalAccountEntryW.ConsolidatedRefRecId_BR;
        ledgerPostingTransaction.ConsolidatedVoucher_BR = generalJournalAccountEntryW.ConsolidatedVoucher_BR;

        ledgerPostingTransaction.CompanyBankAccount = ledgerEntry.CompanyBankAccount;
        ledgerPostingTransaction.ThirdPartyBankAccount = ledgerEntry.ThirdPartyBankAccount;
        ledgerPostingTransaction.BankDataAreaId = ledgerEntry.BankDataAreaId;
        ledgerPostingTransaction.ConsolidatedCompany = ledgerEntry.ConsolidatedCompany;
        ledgerPostingTransaction.IsBridgingPosting = ledgerEntry.IsBridgingPosting;
        ledgerPostingTransaction.PaymentMode = ledgerEntry.PaymentMode;
        ledgerPostingTransaction.IsExchangeAdjustment = ledgerEntry.IsExchangeAdjustment;

        ledgerPostingTransaction.TransferLevel = transferLevel;
        ledgerPostingTransaction.IsPosted = isPosted;
        ledgerPostingTransaction.IsChecked = isChecked;
        ledgerPostingTransaction.IgnoreAllocation = ignoreAllocation;
        ledgerPostingTransaction.DiscardLastTransText = discardLastTransTxt;
        ledgerPostingTransaction.SkipDimensionValidation = skipDimensionValidation;
        ledgerPostingTransaction.SkipBlockedForManualEntryCheck = skipBlockedForManualEntryCheck;
        ledgerPostingTransaction.TaxTransRelationshipType = taxTransRelationshipType;
        ledgerPostingTransaction.IsTaxTransRelationshipTypeSet = isTaxTransRelationshipTypeSet;
        ledgerPostingTransaction.FinTag = generalJournalAccountEntry.FinTag;

        // the default is HaveTaxLink = false
        if (taxTransGenJourAcctEntryCollection != null)
        {
            ledgerPostingTransaction.HaveTaxLink = taxTransGenJourAcctEntryCollection.count() > 0;
            // the default is PackedTaxLinks = conNull()
            if (ledgerPostingTransaction.HaveTaxLink)
            {
                ledgerPostingTransaction.PackedTaxLinks = taxTransGenJourAcctEntryCollection.pack();
            }
        }

         // the default is HaveCrossCompanyTaxLinks = false
        if (crossCompanyTaxLinkCollections != null)
        {
            ledgerPostingTransaction.HaveCrossCompanyTaxLinks = crossCompanyTaxLinkCollections.elements() > 0;
            // the default is PackedCrossCompanyTaxLinks = conNull()
            if (ledgerPostingTransaction.HaveCrossCompanyTaxLinks)
            {
                ledgerPostingTransaction.PackedCrossCompanyTaxLinks = crossCompanyTaxLinkCollections.pack();
            }
        }

        // <GIN>
        // the default is HaveTaxWHTLink_IN = false and PackedTaxLinksWithholding_IN = conNull()
        if (isTaxWithholdParametersEnabled && taxWHTTransGenJourAcctEntryCollection)
        {
            ledgerPostingTransaction.HaveTaxWHTLink_IN = taxWHTTransGenJourAcctEntryCollection.count() > 0;
            if (ledgerPostingTransaction.HaveTaxWHTLink_IN)
            {
                ledgerPostingTransaction.PackedTaxLinksWithholding_IN = taxWHTTransGenJourAcctEntryCollection.pack();
            }
        }
        // </GIN>

        ledgerPostingTransaction.HaveProject = projLedger != null;
        // the default is PackedProject = conNull()
        if (ledgerPostingTransaction.HaveProject)
        {
            ledgerPostingTransaction.PackedProject = projLedger.pack();
        }

        ledgerPostingTransaction.AccrualTableId = accrualRefTableId;
        ledgerPostingTransaction.AccrualRecId = accrualRefRecId;
        ledgerPostingTransaction.TaxParentReferenceTableId = taxParentReferenceTableId;
        ledgerPostingTransaction.TaxParentReferenceRecId = taxParentReferenceRecId;
        ledgerPostingTransaction.SourceRecId = sourceRecId;
        ledgerPostingTransaction.SourceTableId = sourceTableId;
        ledgerPostingTransaction.ParentTempRecId = parentTempRecId;
        ledgerPostingTransaction.UseTaxParentTaxUncommitted = useTaxParentTaxUncommitted;
        ledgerPostingTransaction.InterunitReference = interunitReference;
        ledgerPostingTransaction.RecId = tempRecId;

        return ledgerPostingTransaction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxTransRelationshipType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the tax relationship type of the ledger voucher transaction.
    /// </summary>
    /// <returns>
    /// The tax relationship type of the ledger voucher transaction.
    /// </returns>
    /// <remarks>
    /// If the tax relationship type was not specified on the ledger voucher transaction
    /// then return the default value for the tax relationship type.
    /// </remarks>
    public TaxTransRelationshipType getTaxTransRelationshipType()
    {
        // If the tax relationship type was not specified on the ledger voucher transaction
        // then return the default value for the tax relationship type.
        if (!isTaxTransRelationshipTypeSet)
        {
            taxTransRelationshipType = TaxTransRelationshipType::TransactionLineAccount;
        }

        return taxTransRelationshipType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxTransRelationshipType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set the tax relationship type to set on the record created in <c>TaxTransGeneralJournalAccountEntry</c> table.
    /// </summary>
    /// <param name="_taxTransRelationshipType">
    /// The tax relationship type to set.
    /// </param>
    /// <remarks>
    /// This allows the <c>LedgerVoucherTransObject</c> to know what type of transaction it is storing.
    /// </remarks>
    public void setTaxTransRelationshipType(TaxTransRelationshipType _taxTransRelationshipType)
    {
        taxTransRelationshipType = _taxTransRelationshipType;
        isTaxTransRelationshipTypeSet = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromInterunitAccountEntry</Name>
				<Source><![CDATA[
    private void initFromInterunitAccountEntry(LedgerTmpInterunitBalancerAccountEntry _ledgerTmpInterunitBalancerAccountEntry)
    {
        generalJournalAccountEntry.LedgerDimension = _ledgerTmpInterunitBalancerAccountEntry.LedgerDimension;
        generalJournalAccountEntry.PostingType = _ledgerTmpInterunitBalancerAccountEntry.PostingType;
        generalJournalAccountEntry.AccountingCurrencyAmount = _ledgerTmpInterunitBalancerAccountEntry.AccountingCurrencyAmount;
        generalJournalAccountEntry.TransactionCurrencyAmount = _ledgerTmpInterunitBalancerAccountEntry.TransactionCurrencyAmount;
        generalJournalAccountEntry.ReportingCurrencyAmount = _ledgerTmpInterunitBalancerAccountEntry.ReportingCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromLedgerPostingTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the current object from the <c>LedgerPostingTransactionTmp</c> record.
    /// </summary>
    /// <param name="_ledgerPostingTransaction">
    /// The <c>LedgerPostingTransactionTmp</c> record.
    /// </param>
    /// <param name="_projectPostingTransaction">
    /// The <paramref name="_projectPostingTransaction"/> parameter is no longer used.
    /// </param>
    public void initFromLedgerPostingTransaction(
        LedgerPostingTransactionTmp _ledgerPostingTransaction,
        LedgerPostingTransactionProjectTmp _projectPostingTransaction = null)
    {
        generalJournalAccountEntry.AllocationLevel = _ledgerPostingTransaction.AllocationLevel;
        generalJournalAccountEntry.AccountingCurrencyAmount = _ledgerPostingTransaction.AccountingCurrencyAmount;
        generalJournalAccountEntry.IsCorrection = _ledgerPostingTransaction.IsCorrection;
        generalJournalAccountEntry.IsCredit = _ledgerPostingTransaction.IsCredit;
        generalJournalAccountEntry.LedgerDimension = _ledgerPostingTransaction.LedgerDimension;
        generalJournalAccountEntry.PaymentReference = _ledgerPostingTransaction.PaymentReference;
        generalJournalAccountEntry.PostingType = _ledgerPostingTransaction.PostingType;
        generalJournalAccountEntry.ReportingCurrencyAmount = _ledgerPostingTransaction.ReportingCurrencyAmount;
        generalJournalAccountEntry.TransactionCurrencyAmount = _ledgerPostingTransaction.TransactionCurrencyAmount;
        generalJournalAccountEntry.TransactionCurrencyCode = _ledgerPostingTransaction.TransactionCurrencyCode;
        generalJournalAccountEntry.Quantity = _ledgerPostingTransaction.Quantity;
        generalJournalAccountEntry.ReasonRef = _ledgerPostingTransaction.ReasonRef;
        generalJournalAccountEntry.SkipCreditCalculation = _ledgerPostingTransaction.SkipCreditCalculation;
        generalJournalAccountEntry.Text = _ledgerPostingTransaction.Text;
        generalJournalAccountEntry.RecId = _ledgerPostingTransaction.GeneralJournalAccountEntry;
        generalJournalAccountEntry.HistoricalExchangeRateDate = _ledgerPostingTransaction.HistoricalExchangeRateDate;
        generalJournalAccountEntry.FinTag = _ledgerPostingTransaction.FinTag;

        generalJournalAccountEntryW.BondBatchTrans_RU = _ledgerPostingTransaction.BondBatchTrans_RU;
        generalJournalAccountEntryW.ConsolidatedRefRecId_BR = _ledgerPostingTransaction.ConsolidatedRefRecId_BR;
        generalJournalAccountEntryW.ConsolidatedVoucher_BR = _ledgerPostingTransaction.ConsolidatedVoucher_BR;

        ledgerEntry.CompanyBankAccount = _ledgerPostingTransaction.CompanyBankAccount;
        ledgerEntry.ThirdPartyBankAccount = _ledgerPostingTransaction.ThirdPartyBankAccount;
        ledgerEntry.BankDataAreaId = _ledgerPostingTransaction.BankDataAreaId;
        ledgerEntry.ConsolidatedCompany = _ledgerPostingTransaction.ConsolidatedCompany;
        ledgerEntry.IsBridgingPosting = _ledgerPostingTransaction.IsBridgingPosting;
        ledgerEntry.PaymentMode = _ledgerPostingTransaction.PaymentMode;
        ledgerEntry.IsExchangeAdjustment = _ledgerPostingTransaction.IsExchangeAdjustment;

        transferLevel = _ledgerPostingTransaction.TransferLevel;
        isPosted = _ledgerPostingTransaction.IsPosted;
        isChecked = _ledgerPostingTransaction.IsChecked;
        ignoreAllocation = _ledgerPostingTransaction.IgnoreAllocation;
        discardLastTransTxt = _ledgerPostingTransaction.DiscardLastTransText;
        skipDimensionValidation = _ledgerPostingTransaction.SkipDimensionValidation;
        skipBlockedForManualEntryCheck = _ledgerPostingTransaction.SkipBlockedForManualEntryCheck;
        accrualRefTableId = _ledgerPostingTransaction.AccrualTableId;
        accrualRefRecId = _ledgerPostingTransaction.AccrualRecId;
        taxParentReferenceTableId = _ledgerPostingTransaction.TaxParentReferenceTableId;
        taxParentReferenceRecId = _ledgerPostingTransaction.TaxParentReferenceRecId;
        useTaxParentTaxUncommitted = _ledgerPostingTransaction.UseTaxParentTaxUncommitted;
        sourceRecId = _ledgerPostingTransaction.SourceRecId;
        sourceTableId = _ledgerPostingTransaction.SourceTableId;
        interunitReference = _ledgerPostingTransaction.InterunitReference;
        parentTempRecId = _ledgerPostingTransaction.ParentTempRecId;
        tempRecId = _ledgerPostingTransaction.RecId;
        taxTransRelationshipType = _ledgerPostingTransaction.TaxTransRelationshipType;
        isTaxTransRelationshipTypeSet = _ledgerPostingTransaction.IsTaxTransRelationshipTypeSet;

        if (_ledgerPostingTransaction.HaveProject)
        {
            projLedger = ProjLedger::create(_ledgerPostingTransaction.PackedProject);
        }
        else
        {
            projLedger = null;
        }

        if (_ledgerPostingTransaction.HaveTaxLink)
        {
            taxTransGenJourAcctEntryCollection =
                LedgerPostingOneToManyCollection::create(_ledgerPostingTransaction.PackedTaxLinks);
        }

        if (_ledgerPostingTransaction.HaveCrossCompanyTaxLinks)
        {
            crossCompanyTaxLinkCollections = Map::create(_ledgerPostingTransaction.PackedCrossCompanyTaxLinks);
        }

        // <GIN>
        // don't have to check the country context here because it is checked
        // before HaveTaxWHTLink_IN is set to true
        if (_ledgerPostingTransaction.HaveTaxWHTLink_IN)
        {
            taxWHTTransGenJourAcctEntryCollection =
                LedgerPostingOneToManyCollection::create(_ledgerPostingTransaction.PackedTaxLinksWithholding_IN);
        }
        else
        {
            // null because that is allowed/expected
            taxWHTTransGenJourAcctEntryCollection = null;
        }
        // </GIN>

        // setting proper fields to skip validations that are unnecessary
        // when posting adjustment journals.
        if (_ledgerPostingTransaction.SourceTableId == tableNum(LedgerJournalTrans) &&
            FeatureStateProvider::isFeatureEnabled(GeneralLedgerAdjustmentFeature::instance()))
        {
            LedgerJournalTrans journalTransaction = LedgerJournalTrans::findRecId(_ledgerPostingTransaction.SourceRecId, false);
            LedgerJournalTable journal = LedgerJournalTable::find(journalTransaction.JournalNum);

            // If the journal being posted is an adjustment journal, skip the below set of validations
            // when posting
            if (journal.IsAdjustmentJournal == NoYes::Yes)
            {
                skipDimensionValidation = true;
                skipBlockedForManualEntryCheck = true;
                useTaxParentTaxUncommitted = true;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromLedgerVoucherObject</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the parameters of an instance of the <c>LedgerVoucherObject</c> class.
    /// </summary>
    /// <param name="_reference">
    ///    The ledger posting reference of the transaction.
    /// </param>
    public void initFromLedgerVoucherObject(LedgerVoucherObject _reference)
    {
        if (_reference == null)
        {
            return;
        }

        generalJournalAccountEntry.IsCorrection = _reference.parmIsCorrectionDefault();
        generalJournalAccountEntry.PaymentReference = _reference.parmPaymentReferenceDefault();
        generalJournalAccountEntry.ReasonRef = _reference.parmReasonRef();

        if (isFinTagConfigurationSetForCurrent && LedgerVoucherTransObjectFinTagFlight::instance().isEnabled())
        {
            generalJournalAccountEntry.FinTag = _reference.parmFinTag();
        }

        // this will replace the Text being set during LedgerVoucherObject.addTrans when a
        // LedgerVoucherObject default is added to all LedgerVoucherTransObject factory methods
        //generalJournalAccountEntry.Text = _reference.parmTextDefault();
        // <GSA>
        generalJournalAccountEntry.ProjId_SA  = _reference.parmProjIdDefault_SA();
        // </GSA>

        sourceRecId = _reference.parmSourceRecIdDefault();
        sourceTableId = _reference.parmSourceTableIdDefault();
    }

]]></Source>
			</Method>
			<Method>
				<Name>invertAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inverts the sign of the amounts of the current object.
    /// </summary>
    /// <remarks>
    /// Inverting the sign will have the general effect of changing a debit to a
    /// credit or a credit to a debit.
    /// </remarks>
    public void invertAmounts()
    {
        generalJournalAccountEntry.TransactionCurrencyAmount = -generalJournalAccountEntry.TransactionCurrencyAmount;
        generalJournalAccountEntry.AccountingCurrencyAmount = -generalJournalAccountEntry.AccountingCurrencyAmount;
        generalJournalAccountEntry.ReportingCurrencyAmount = -generalJournalAccountEntry.ReportingCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCredit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value that indicates whether this is a credit.
    /// </summary>
    /// <returns>
    /// true if this is a credit; otherwise, false.
    /// </returns>
    public boolean isCredit()
    {
        generalJournalAccountEntry.calculateInternalValues(LedgerParameters::find().ReverseOppositeSignAmounts);
        return generalJournalAccountEntry.IsCredit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInterunitAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value that indicates whether the current object is an interunit adjustment.
    /// </summary>
    /// <returns>
    /// true if the current object is an interunit adjustment; otherwise, false.
    /// </returns>
    public boolean isInterunitAdjustment()
    {
        return interunitReference == -1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value that indicates whether the current object was modified.
    /// </summary>
    /// <returns>
    /// true if the current object was modified; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The methods that support this method are marked in their documentation.
    /// </remarks>
    public boolean isModified()
    {
        return isModified;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPosted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value that indicates whether the current object is posted.
    /// </summary>
    /// <returns>
    /// true if the current object is posted; otherwise, false.
    /// </returns>
    public boolean isPosted()
    {
        return isPosted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>level</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the current level of allocation regarding the calling <c>LedgerVoucherObject</c> object.
    /// </summary>
    /// <returns>
    ///    The current level of allocation.
    /// </returns>
    public Integer level()
    {
        return generalJournalAccountEntry.AllocationLevel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markAsInterunitAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks the current object as an interunit adjustment.
    /// </summary>
    public void markAsInterunitAdjustment()
    {
        interunitReference = -1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new(
        LedgerPostingType _postingType,
        CurrencyCode _transactionCurrencyCode,
        LedgerDimensionAccount _ledgerDimensionId)
    {
        transferLevel = LedgerDetailLevel::AsDefault;

        generalJournalAccountEntry.PostingType = _postingType;
        generalJournalAccountEntry.TransactionCurrencyCode = _transactionCurrencyCode;
        generalJournalAccountEntry.LedgerDimension = _ledgerDimensionId;

        // <GIN>
        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            isTaxWithholdParametersEnabled = true;
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container packedProjLedger;
        container packedTaxTransCollection;
        container packedCrossCompanyTaxLinks;
        // <GIN>
        container packedTaxLinksWithhold;
         // </GIN>

        if (projLedger != null)
        {
            packedProjLedger = projLedger.pack();
        }

        if (taxTransGenJourAcctEntryCollection != null)
        {
           packedTaxTransCollection = taxTransGenJourAcctEntryCollection.pack();
        }

        if (crossCompanyTaxLinkCollections != null)
        {
           packedCrossCompanyTaxLinks = crossCompanyTaxLinkCollections.pack();
        }

        // <GIN>
        if (isTaxWithholdParametersEnabled && taxWHTTransGenJourAcctEntryCollection != null)
        {
            packedTaxLinksWithhold = taxWHTTransGenJourAcctEntryCollection.pack();
        }
       // </GIN>

        container packed = [
            #CurrentVersion,
            #CurrentList,
            packedProjLedger,
            packedTaxTransCollection,
            packedCrossCompanyTaxLinks
            // <GIN>
            , packedTaxLinksWithhold
            // </GIN>
        ];

        packed = this.appendVariableToPack(packed, identifierStr(generalJournalAccountEntry.FinTag), generalJournalAccountEntry.FinTag);
        return packed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>appendVariableToPack</Name>
				<Source><![CDATA[
    private container appendVariableToPack(container _pack, str _variableName, anytype _value)
    {
        XppPrePostArgs packArgs = this.createXppPrePostArgsWithPack(_pack);
        SysPackExtensions::pack(packArgs, this.getVariablePackKey(_variableName), [_value]);
        return packArgs.getReturnValue();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createXppPrePostArgsWithPack</Name>
				<Source><![CDATA[
    private XppPrePostArgs createXppPrePostArgsWithPack(container _pack)
    {
        XppPrePostArgs prePostArgs = new XppPrePostArgs(_pack, '',  XppEventHandlerCalledWhen::Post);
        prePostArgs.setReturnValue(_pack);
        return prePostArgs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVariablePackKey</Name>
				<Source><![CDATA[
    private ClassName getVariablePackKey(str _variableName)
    {
        return classStr(LedgerVoucherTransObject) + '.' + _variableName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>extractPackedVariable</Name>
				<Source><![CDATA[
    private anytype extractPackedVariable(container _pack, str _variableName)
    {
        anytype value;
        [value] = SysPackExtensions::unpack(this.createXppPrePostArgsWithPack(_pack), this.getVariablePackKey(_variableName));
        return value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountingCurrencyAmount</Name>
				<Source><![CDATA[
    public Money parmAccountingCurrencyAmount(Money _accountingCurrencyAmount = generalJournalAccountEntry.AccountingCurrencyAmount)
    {
        generalJournalAccountEntry.AccountingCurrencyAmount = _accountingCurrencyAmount;

        return generalJournalAccountEntry.AccountingCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccrualInfo</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the <c>accrualRefTableid</c> and <c>accrualRecRecId</c> variables.
    /// </summary>
    /// <param name="_refTableid">
    ///    The table ID of the originating record.
    /// </param>
    /// <param name="_refRecid">
    ///    The record ID of the originating record.
    /// </param>
    /// <remarks>
    ///    Used by ledger accrual posting.
    /// </remarks>
    public void parmAccrualInfo(TableId _refTableid, RecId _refRecid)
    {
        accrualRefTableId = _refTableid;
        accrualRefRecId   = _refRecid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllocateLevel</Name>
				<Source><![CDATA[
    // OBSOLETE: use parmAllocationLevel
    public LedgerAllocateLevel parmAllocateLevel(LedgerAllocateLevel _allocateLevel = generalJournalAccountEntry.AllocationLevel)
    {
        generalJournalAccountEntry.AllocationLevel = _allocateLevel;

        return generalJournalAccountEntry.AllocationLevel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllocationLevel</Name>
				<Source><![CDATA[
    public LedgerAllocateLevel parmAllocationLevel(LedgerAllocateLevel _allocationLevel = generalJournalAccountEntry.AllocationLevel)
    {
        generalJournalAccountEntry.AllocationLevel = _allocationLevel;

        return generalJournalAccountEntry.AllocationLevel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAmountCur</Name>
				<Source><![CDATA[
    // OBSOLETE: use parmTransactionCurrencyAmount
    AmountCur parmAmountCur(AmountCur _amountCur = generalJournalAccountEntry.TransactionCurrencyAmount)
    {
        generalJournalAccountEntry.TransactionCurrencyAmount = _amountCur;

        return generalJournalAccountEntry.TransactionCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAmountMST</Name>
				<Source><![CDATA[
    // OBSOLETE: use parmAccountingCurrencyAmount
    public AmountMST parmAmountMST(AmountMST _amountMST = generalJournalAccountEntry.AccountingCurrencyAmount)
    {
        generalJournalAccountEntry.AccountingCurrencyAmount = _amountMST;

        return generalJournalAccountEntry.AccountingCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAmountMSTSecondary</Name>
				<Source><![CDATA[
    // OBSOLETE: use parmReportingCurrencyAmount
    AmountMSTSecondary parmAmountMSTSecondary(AmountMSTSecondary _reportingCurrencyAmount = generalJournalAccountEntry.ReportingCurrencyAmount)
    {
        generalJournalAccountEntry.ReportingCurrencyAmount = _reportingCurrencyAmount;

        return generalJournalAccountEntry.ReportingCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCorrect</Name>
				<Source><![CDATA[
    // OBSOLETE: use parmIsCorrection
    NoYes parmCorrect(NoYes _parmCorrect = generalJournalAccountEntry.IsCorrection)
    {
        generalJournalAccountEntry.IsCorrection = _parmCorrect;

        return generalJournalAccountEntry.IsCorrection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCurrencyCode</Name>
				<Source><![CDATA[
    // OBSOLETE: use parmTransactionCurrencyCode
    public CurrencyCode parmCurrencyCode(CurrencyCode _currencyCode = generalJournalAccountEntry.TransactionCurrencyCode)
    {
        if (generalJournalAccountEntry.TransactionCurrencyCode != _currencyCode)
        {
            isChecked = false;
        }

        generalJournalAccountEntry.TransactionCurrencyCode = _currencyCode;

        return generalJournalAccountEntry.TransactionCurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustomTransferLevel</Name>
				<Source><![CDATA[
    public RecId parmCustomTransferLevel(RecId _customTransferLevel = generalJournalAccountEntry.RecId)
    {
        generalJournalAccountEntry.RecId = _customTransferLevel;

        return generalJournalAccountEntry.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDiscardLastTransTxt</Name>
				<Source><![CDATA[
    // this will no longer be needed to prevent the Text being set during LedgerVoucherObject.addTrans
    // when a LedgerVoucherObject default is added to all LedgerVoucherTransObject factory methods
    public boolean parmDiscardLastTransTxt(boolean _discardLastTransTxt = discardLastTransTxt)
    {
        discardLastTransTxt = _discardLastTransTxt;

        return discardLastTransTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmGeneralJournalAccountEntry</Name>
				<Source><![CDATA[
    public GeneralJournalAccountEntry parmGeneralJournalAccountEntry(GeneralJournalAccountEntry _generalJournalAccountEntry = generalJournalAccountEntry)
    {
        generalJournalAccountEntry.data(_generalJournalAccountEntry);

        return generalJournalAccountEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHistoricalExchangeRateDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the <c>HistoricalExchangeRateDate</c> parameter.
    /// </summary>
    /// <param name="_historicalExchangeRateDate">
    /// The value to set.
    /// </param>
    /// <returns>
    /// The value of the <c>HistoricalExchangeRateDate</c> parameter.
    /// </returns>
    /// <remarks>
    /// If present, the historical exchange rate date is used when converting the amount in
    /// transaction currency to the amount in accounting currency and amount in
    /// reporting currency. If it is not present, the accounting date from the
    /// associated <c>GeneralJournalEntry</c> record is used.
    /// </remarks>
    public HistoricalExchangeRateDate parmHistoricalExchangeRateDate(HistoricalExchangeRateDate _historicalExchangeRateDate = generalJournalAccountEntry.HistoricalExchangeRateDate)
    {
        generalJournalAccountEntry.HistoricalExchangeRateDate = _historicalExchangeRateDate;

        return generalJournalAccountEntry.HistoricalExchangeRateDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIgnoreAllocation</Name>
				<Source><![CDATA[
    public boolean parmIgnoreAllocation(boolean _ignoreAllocation = ignoreAllocation)
    {
        ignoreAllocation = _ignoreAllocation;

        return ignoreAllocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInterunitReference</Name>
				<Source><![CDATA[
    public RecId parmInterunitReference(RecId _interunitReference = interunitReference)
    {
        interunitReference = _interunitReference;

        return interunitReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsBridgingPosting</Name>
				<Source><![CDATA[
    public boolean parmIsBridgingPosting(boolean _isBridgingPosting = ledgerEntry.IsBridgingPosting)
    {
        ledgerEntry.IsBridgingPosting = _isBridgingPosting;

        return ledgerEntry.IsBridgingPosting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsCorrection</Name>
				<Source><![CDATA[
    public NoYes parmIsCorrection(NoYes _isCorrection = generalJournalAccountEntry.IsCorrection)
    {
        generalJournalAccountEntry.IsCorrection = _isCorrection;

        return generalJournalAccountEntry.IsCorrection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsExchangeAdjustment</Name>
				<Source><![CDATA[
    public IsExchangeAdjustment parmIsExchangeAdjustment(IsExchangeAdjustment _isExchangeAdjustment = ledgerEntry.IsExchangeAdjustment)
    {
        ledgerEntry.IsExchangeAdjustment = _isExchangeAdjustment;

        return ledgerEntry.IsExchangeAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsTaxWithholdParametersEnabled_IN</Name>
				<Source><![CDATA[
    public boolean parmIsTaxWithholdParametersEnabled_IN(boolean _isTaxWithholdParametersEnabled = isTaxWithholdParametersEnabled)
    {
        isTaxWithholdParametersEnabled = _isTaxWithholdParametersEnabled;
        return isTaxWithholdParametersEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerDetailLevel</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>LedgerDetailLevel</c> parameter.
    /// </summary>
    /// <param name="_ledgerDetailLevel">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>LedgerDetailLevel</c> parameter.
    /// </returns>
    public LedgerDetailLevel parmLedgerDetailLevel(LedgerDetailLevel _ledgerDetailLevel = transferLevel)
    {
        transferLevel = _ledgerDetailLevel;

        return transferLevel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerDimensionId</Name>
				<Source><![CDATA[
    public LedgerDimensionAccount parmLedgerDimensionId(LedgerDimensionAccount _ledgerDimensionId = generalJournalAccountEntry.LedgerDimension)
    {
        if (!prmisDefault(_ledgerDimensionId))
        {
            generalJournalAccountEntry.LedgerDimension = _ledgerDimensionId;
        }

        return generalJournalAccountEntry.LedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerEntry</Name>
				<Source><![CDATA[
    public LedgerEntry parmLedgerEntry(LedgerEntry _ledgerEntry = ledgerEntry.data())
    {
        ledgerEntry.data(_ledgerEntry);

        return ledgerEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerPostingType</Name>
				<Source><![CDATA[
    // OBSOLETE: use parmPostingType
    LedgerPostingType parmLedgerPostingType(LedgerPostingType _ledgerPostingType = generalJournalAccountEntry.PostingType)
    {
        if (generalJournalAccountEntry.PostingType != _ledgerPostingType)
        {
            isChecked = false;
        }

        generalJournalAccountEntry.PostingType = _ledgerPostingType;

        return generalJournalAccountEntry.PostingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParentTempRecId</Name>
				<Source><![CDATA[
    public RecId parmParentTempRecId(RecId _parentTempRecId = parentTempRecId)
    {
        parentTempRecId = _parentTempRecId;

        return parentTempRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymentReference</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>PaymentReference</c> parameter.
    /// </summary>
    /// <param name="_paymReference">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>PaymentReference</c> parameter.
    /// </returns>
    PaymReference parmPaymentReference(PaymReference _paymReference = generalJournalAccountEntry.PaymentReference)
    {
        generalJournalAccountEntry.PaymentReference = _paymReference;

        return generalJournalAccountEntry.PaymentReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymMode</Name>
				<Source><![CDATA[
    // OBSOLETE: use parmPaymentMode
    PaymMode parmPaymMode(PaymMode _paymMode = ledgerEntry.PaymentMode)
    {
        ledgerEntry.PaymentMode = _paymMode;

        return ledgerEntry.PaymentMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostingType</Name>
				<Source><![CDATA[
    public LedgerPostingType parmPostingType(LedgerPostingType _postingType = generalJournalAccountEntry.PostingType)
    {
        if (generalJournalAccountEntry.PostingType != _postingType)
        {
            isChecked = false;
        }

        generalJournalAccountEntry.PostingType = _postingType;

        return generalJournalAccountEntry.PostingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjLedger</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>ProjLedger</c> parameter.
    /// </summary>
    /// <param name="_projLedger">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>ProjLedger</c> parameter.
    /// </returns>
    ProjLedger parmProjLedger(ProjLedger _projLedger = projLedger)
    {
        projLedger = _projLedger;
        return projLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQty</Name>
				<Source><![CDATA[
    // OBSOLETE: use parmQuantity
    Qty parmQty(Qty _qty = generalJournalAccountEntry.Quantity)
    {
        generalJournalAccountEntry.Quantity = _qty;

        return generalJournalAccountEntry.Quantity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQuantity</Name>
				<Source><![CDATA[
    public Qty parmQuantity(Qty _quantity = generalJournalAccountEntry.Quantity)
    {
        generalJournalAccountEntry.Quantity = _quantity;

        return generalJournalAccountEntry.Quantity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReasonCode</Name>
				<Source><![CDATA[
    public ReasonRefRecID parmReasonCode(ReasonRefRecID _reasonCode = generalJournalAccountEntry.ReasonRef)
    {
        generalJournalAccountEntry.ReasonRef = ReasonTableRef::checkCreateInCompany(_reasonCode, curext());

        return generalJournalAccountEntry.ReasonRef;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReasonRefRecID</Name>
				<Source><![CDATA[
    // OBSOLETE: use parmReasonCode
    public ReasonRefRecID parmReasonRefRecID(ReasonRefRecID _reasonRefRecID = generalJournalAccountEntry.ReasonRef)
    {
        generalJournalAccountEntry.ReasonRef = ReasonTableRef::checkCreateInCompany(_reasonRefRecID, curext());

        return generalJournalAccountEntry.ReasonRef;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRecId</Name>
				<Source><![CDATA[
    // OBSOLETE: use parmCustomTransferLevel
    public RecId parmRecId(RecId _recId = generalJournalAccountEntry.RecId)
    {
        generalJournalAccountEntry.RecId = _recId;

        return generalJournalAccountEntry.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReportingCurrencyAmount</Name>
				<Source><![CDATA[
    public Money parmReportingCurrencyAmount(Money _reportingCurrencyAmount = generalJournalAccountEntry.ReportingCurrencyAmount)
    {
        generalJournalAccountEntry.ReportingCurrencyAmount = _reportingCurrencyAmount;

        return generalJournalAccountEntry.ReportingCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipBlockedForManualEntryCheck</Name>
				<Source><![CDATA[
    public boolean parmSkipBlockedForManualEntryCheck(boolean _skipBlockedForManualEntryCheck = skipBlockedForManualEntryCheck)
    {
        skipBlockedForManualEntryCheck = _skipBlockedForManualEntryCheck;

        return skipBlockedForManualEntryCheck;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipDimensionValidation</Name>
				<Source><![CDATA[
    public boolean parmSkipDimensionValidation(boolean _skipDimensionValidation = skipDimensionValidation)
    {
        skipDimensionValidation = _skipDimensionValidation;

        return skipDimensionValidation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceRecId</Name>
				<Source><![CDATA[
    public RecId parmSourceRecId(RecId _sourceRecId = sourceRecId)
    {
        sourceRecId = _sourceRecId;

        return sourceRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceTableId</Name>
				<Source><![CDATA[
    public TableId parmSourceTableId(TableId _sourceTableId = sourceTableId)
    {
        sourceTableId = _sourceTableId;

        return sourceTableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxLinks</Name>
				<Source><![CDATA[
    public LedgerPostingOneToManyCollection parmTaxLinks(LedgerPostingOneToManyCollection _taxTransGenJourAcctEntryCollection = taxTransGenJourAcctEntryCollection)
    {
        taxTransGenJourAcctEntryCollection = _taxTransGenJourAcctEntryCollection;

        if (taxTransGenJourAcctEntryCollection == null)
        {
            //Initialize because the caller shouldn't have to check it is null
            taxTransGenJourAcctEntryCollection = LedgerPostingOneToManyCollection::construct(
                Types::Int64, // use this instead of RecId for perf
                Types::Container,
                #ThrowForDuplicates);
        }

        return taxTransGenJourAcctEntryCollection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxParentReferenceRecId</Name>
				<Source><![CDATA[
    public RecId parmTaxParentReferenceRecId(RecId _taxParentReferenceRecId = taxParentReferenceRecId)
    {
        taxParentReferenceRecId = _taxParentReferenceRecId;

        return taxParentReferenceRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxParentReferenceTableId</Name>
				<Source><![CDATA[
    public TableId parmTaxParentReferenceTableId(TableId _taxParentReferenceTableId = taxParentReferenceTableId)
    {
        taxParentReferenceTableId = _taxParentReferenceTableId;

        return taxParentReferenceTableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxWHTLinks_IN</Name>
				<Source><![CDATA[
    public LedgerPostingOneToManyCollection parmTaxWHTLinks_IN(LedgerPostingOneToManyCollection _taxWHTTranGenJourAcctEntryCollection = taxWHTTransGenJourAcctEntryCollection)
    {
        taxWHTTransGenJourAcctEntryCollection = _taxWHTTranGenJourAcctEntryCollection;

        return taxWHTTransGenJourAcctEntryCollection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTempRecId</Name>
				<Source><![CDATA[
    public RecId parmTempRecId(RecId _tempRecId = tempRecId)
    {
        if (projLedger != null)
        {
            projLedger.parmTempRecId(_tempRecId);
        }

        tempRecId = _tempRecId;

        return tempRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmText</Name>
				<Source><![CDATA[
    public TransactionTextLarge parmText(TransactionTextLarge _text = generalJournalAccountEntry.Text)
    {
        generalJournalAccountEntry.Text = _text;

        return generalJournalAccountEntry.Text;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmThisIsARoundingTrans</Name>
				<Source><![CDATA[
    // OBSOLETE: use parmIgnoreAllocation
    boolean parmThisIsARoundingTrans(boolean _thisIsARoundingTrans = ignoreAllocation)
    {
        ignoreAllocation = _thisIsARoundingTrans;
        return ignoreAllocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransactionCurrencyAmount</Name>
				<Source><![CDATA[
    public Money parmTransactionCurrencyAmount(Money _transactionCurrencyAmount = generalJournalAccountEntry.TransactionCurrencyAmount)
    {
        generalJournalAccountEntry.TransactionCurrencyAmount = _transactionCurrencyAmount;

        return generalJournalAccountEntry.TransactionCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransactionCurrencyCode</Name>
				<Source><![CDATA[
    public CurrencyCode parmTransactionCurrencyCode(CurrencyCode _transactionCurrencyCode = generalJournalAccountEntry.TransactionCurrencyCode)
    {
        if (generalJournalAccountEntry.TransactionCurrencyCode != _transactionCurrencyCode)
        {
            isChecked = false;
        }

        generalJournalAccountEntry.TransactionCurrencyCode = _transactionCurrencyCode;

        return generalJournalAccountEntry.TransactionCurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransferLevel</Name>
				<Source><![CDATA[
    public LedgerDetailLevel parmTransferLevel(LedgerDetailLevel _transferLevel = transferLevel)
    {
        transferLevel = _transferLevel;

        return transferLevel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransTxt</Name>
				<Source><![CDATA[
    // OBSOLETE: use parmText
    TransactionTextLarge parmTransTxt(TransactionTextLarge _transTxt = generalJournalAccountEntry.Text)
    {
        generalJournalAccountEntry.Text = _transTxt;

        return generalJournalAccountEntry.Text;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseTaxParentTaxUncommitted</Name>
				<Source><![CDATA[
    public boolean parmUseTaxParentTaxUncommitted(boolean _useTaxParentTaxUncommitted = useTaxParentTaxUncommitted)
    {
        useTaxParentTaxUncommitted = _useTaxParentTaxUncommitted;

        return useTaxParentTaxUncommitted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFinTag</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public FinTagRecId parmFinTag(FinTagRecId _finTag = finTag)
    {
        generalJournalAccountEntry.FinTag = _finTag;

        return generalJournalAccountEntry.FinTag;
    }

]]></Source>
			</Method>
			<Method>
				<Name>performInterunitBalancing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs balancing for the interunit dimensions of the current object.
    /// </summary>
    /// <param name="_ledgerTmpInterunitBalancerAccountEntry">
    /// The <c>LedgerTmpInterunitBalancerAccountEntry</c> record.
    /// </param>
    /// <returns>
    /// The <c>LedgerVoucherTransObject</c> object required for balancing; otherwise, null.
    /// </returns>
    public LedgerVoucherTransObject performInterunitBalancing(LedgerTmpInterunitBalancerAccountEntry _ledgerTmpInterunitBalancerAccountEntry)
    {
        LedgerVoucherTransObject newTransaction;

        newTransaction = null;

        if (interunitReference != 0)
        {
            select firstonly * from _ledgerTmpInterunitBalancerAccountEntry
                where _ledgerTmpInterunitBalancerAccountEntry.RecId == interunitReference;

            if (_ledgerTmpInterunitBalancerAccountEntry != null)
            {
                newTransaction = this.clone();
                newTransaction.initFromInterunitAccountEntry(_ledgerTmpInterunitBalancerAccountEntry);
                newTransaction.markAsInterunitAdjustment();
            }
        }

        return newTransaction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>post</Name>
				<Source><![CDATA[
    /// <summary>
    /// Makes the transaction a permanent part of the general ledger.
    /// </summary>
    /// <param name="_journal">
    /// The ledger posting journal containing this transaction.
    /// </param>
    /// <param name="_reference">
    /// The ledger posting reference containing this transaction.
    /// </param>
    /// <returns>
    /// true if the transaction was posted; otherwise, false if it had already been posted.
    /// </returns>
    /// <remarks>
    /// This method contains special integration for project and accrual transactions.
    /// </remarks>
    public boolean post(LedgerVoucher _journal, LedgerVoucherObject _reference)
    {
        boolean didSomething;

        didSomething = !isPosted;

        if (!isPosted)
        {
            // call checkData because we have to make sure it was called at
            // least once, it will short circuit if it was already called
            if (!this.checkData(_journal, _reference))
            {
                throw error("@SYS21533");
            }

            if (accrualRefTableId != 0 && accrualRefRecId != 0)
            {
                LedgerJournalTransAccrualTrans::updateLedgerJournalVoucherChanged(
                    _journal.parmJournalNumber(),
                    _reference.parmSubledgerVoucher(),
                    _reference.parmAccountingDate(),
                    accrualRefTableId,
                    accrualRefRecId);
            }

            if (_reference.shouldPostToSubledgerJournal())
            {
                this.addToSubledgerJournal(_journal, _reference);
            }
            else
            {
                this.addToGeneralJournal(_journal, _reference);
            }

            if (projLedger != null)
            {
                ProjLedgerUpdate::newLedgerPosting(_reference, this, projLedger).insert();
            }

            isPosted = true;
        }

        return didSomething;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setIsCredit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets whether this is a debit or credit.
    /// </summary>
    /// <param name="_isCredit">
    /// true if this is a credit; false if this is a debit.
    /// </param>
    /// <remarks>
    /// This method disables the normal credit calculation.
    /// </remarks>
    private void setIsCredit(boolean _isCredit)
    {
        generalJournalAccountEntry.IsCredit = _isCredit;

        // disable the mechanism to calculate whether it is a credit because this change overrides that
        generalJournalAccountEntry.SkipCreditCalculation = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxTransGenJourAcctEntryCollection_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Returns collection of association with tax transactions
    /// </summary>
    /// <returns>
    /// LedgerPostingOneToManyCollection
    /// </returns>
    LedgerPostingOneToManyCollection taxTransGenJourAcctEntryCollection_RU()
    {
        return taxTransGenJourAcctEntryCollection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        boolean success = false;
        Version version = RunBase::getVersion(_packedClass);
        container packedProjLedger;
        container packedTaxTransCollection;
        container packedCrossCompanyTaxLinks;
        // <GIN>
        container packedTaxLinksWithhold;
        // </GIN>

        switch (version)
        {
            case #CurrentVersion:
                [
                    version,
                    #CurrentList,
                    packedProjLedger,
                    packedTaxTransCollection,
                    packedCrossCompanyTaxLinks
                    // <GIN>
                    , packedTaxLinksWithhold
                    // </GIN>
                ] = _packedClass;

                generalJournalAccountEntry.FinTag = this.extractPackedVariable(_packedClass, identifierStr(generalJournalAccountEntry.FinTag));

                if (packedProjLedger == conNull())
                {
                    projLedger = null;
                }
                else
                {
                    projLedger = ProjLedger::create(packedProjLedger);
                }

                if (packedTaxTransCollection == conNull())
                {
                    taxTransGenJourAcctEntryCollection = null;
                }
                else
                {
                    taxTransGenJourAcctEntryCollection = LedgerPostingOneToManyCollection::create(packedTaxTransCollection);
                }

                if (packedCrossCompanyTaxLinks == conNull())
                {
                    crossCompanyTaxLinkCollections = null;
                }
                else
                {
                    crossCompanyTaxLinkCollections = Map::create(packedCrossCompanyTaxLinks);
                }

                // <GIN>
                // don't have to check the country context here because it is checked before packing
                if (packedTaxLinksWithhold == conNull())
                {
                    taxWHTTransGenJourAcctEntryCollection = null;
                }
                else
                {
                    taxWHTTransGenJourAcctEntryCollection = LedgerPostingOneToManyCollection::create(packedTaxLinksWithhold);
                }
                // </GIN>

                success = true;
                break;
        }

        return success;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSignSide</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the sign and the side of the current object.
    /// </summary>
    /// <param name="_invertSign">
    /// A value that indicates whether to change the sign of the amounts.
    /// </param>
    /// <param name="_invertSide">
    /// A value that indicates whether to change the side of the amounts from
    /// debit to credit or credit to debit.
    /// </param>
    public void updateSignSide(boolean _invertSign = false, boolean _invertSide = false)
    {
        if (_invertSign)
        {
            // change the sign because that is ultimately required to change either the side or the sign
            generalJournalAccountEntry.TransactionCurrencyAmount = -generalJournalAccountEntry.TransactionCurrencyAmount;
            generalJournalAccountEntry.AccountingCurrencyAmount = -generalJournalAccountEntry.AccountingCurrencyAmount;
            generalJournalAccountEntry.ReportingCurrencyAmount = -generalJournalAccountEntry.ReportingCurrencyAmount;
        }

        if (_invertSide)
        {
            this.setIsCredit(!generalJournalAccountEntry.IsCredit);
        }
        else
        {
            this.setIsCredit(generalJournalAccountEntry.IsCredit);
        }

        if (_invertSign && generalJournalAccountEntry.Quantity)
        {
            generalJournalAccountEntry.Quantity = -generalJournalAccountEntry.Quantity;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>create</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the LedgerVoucherTransObject class from a packed class.
    /// </summary>
    /// <param name="_packedClass">
    /// The LedgerVoucherTransObject class packed in a container.
    /// </param>
    /// <returns>
    /// A new instance of the LedgerVoucherTransObject class.
    /// </returns>
    /// <remarks>
    /// This method is for internal use only.
    /// </remarks>
    public static LedgerVoucherTransObject create(container _packedClass)
    {
        LedgerVoucherTransObject transaction;

        transaction = new LedgerVoucherTransObject(LedgerPostingType::None, '', 0);
        transaction.unpack(_packedClass);

        return transaction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newAdjustmentDefault</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the LedgerVoucherTransObject class for an
    /// accounting currency amount or reporting currency amount adjustment.
    /// </summary>
    /// <param name="_defaultLedgerPostingReference">
    /// The ledger posting reference used for defaulting.
    /// </param>
    /// <param name="_postingType">
    /// The posting type of the general journal entry.
    /// </param>
    /// <param name="_ledgerDimensionId">
    /// The dimension attribute value combination of the general journal entry.
    /// </param>
    /// <param name="_transactionCurrencyCode">
    /// The currency code of the general journal entry.
    /// </param>
    /// <param name="_accountingCurrencyAmount">
    /// The amount in the accounting currency.
    /// </param>
    /// <param name="_reportingCurrencyAmount">
    /// The amount in the reporting currency.
    /// </param>
    /// <returns>
    /// A new instance of the LedgerVoucherTransObject class.
    /// </returns>
    /// <remarks>
    /// The transaction currency amount is set to zero.
    /// </remarks>
    public static LedgerVoucherTransObject newAdjustmentDefault(
        LedgerVoucherObject _defaultLedgerPostingReference,
        LedgerPostingType _postingType,
        LedgerDimensionAccount _ledgerDimensionId,
        CurrencyCode _transactionCurrencyCode,
        MoneyMST _accountingCurrencyAmount,
        MoneyMST _reportingCurrencyAmount)
    {
        LedgerVoucherTransObject postingTrans = new LedgerVoucherTransObject(
            _postingType,
            _transactionCurrencyCode,
            _ledgerDimensionId);

        postingTrans.initFromLedgerVoucherObject(_defaultLedgerPostingReference);

        // do not summarize an adjustment
        postingTrans.parmTransferLevel(LedgerDetailLevel::Detail);

        if (_postingType == LedgerPostingType::ExchRateGain || _postingType == LedgerPostingType::ExchRateLoss)
        {
            // gains and losses need to be allocated and ThisIsARoundingTrans is really related to whether it will be allocated
            postingTrans.parmThisIsARoundingTrans(false);
        }
        else
        {
            postingTrans.parmThisIsARoundingTrans(true);
        }

        postingTrans.parmAccountingCurrencyAmount(_accountingCurrencyAmount);
        postingTrans.parmReportingCurrencyAmount(_reportingCurrencyAmount);

        return postingTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newBasicDefault</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the LedgerVoucherTransObject class using a
    /// ledger posting reference for defaulting.
    /// </summary>
    /// <param name="_defaultLedgerPostingReference">
    /// The ledger posting reference used for defaulting.
    /// </param>
    /// <param name="_postingType">
    /// The posting type of the general journal entry.
    /// </param>
    /// <param name="_ledgerDimensionId">
    /// The dimension attribute value combination of the general journal entry.
    /// </param>
    /// <param name="_transactionCurrencyCode">
    /// The currency code of the general journal entry.
    /// </param>
    /// <param name="_transactionCurrencyAmount">
    /// The amount in the transaction currency.
    /// </param>
    /// <param name="_accountingCurrencyAmount">
    /// The amount in the accounting currency.
    /// </param>
    /// <param name="_reportingCurrencyAmount">
    /// The amount in the reporting currency.
    /// </param>
    /// <returns>
    /// A new instance of the LedgerVoucherTransObject class.
    /// </returns>
    public static LedgerVoucherTransObject newBasicDefault(
        LedgerVoucherObject _defaultLedgerPostingReference,
        LedgerPostingType _postingType,
        LedgerDimensionAccount _ledgerDimensionId,
        CurrencyCode _transactionCurrencyCode,
        Money _transactionCurrencyAmount,
        MoneyMST _accountingCurrencyAmount,
        MoneyMST _reportingCurrencyAmount)
    {
        LedgerVoucherTransObject postingTrans = new LedgerVoucherTransObject(
            _postingType,
            _transactionCurrencyCode,
            _ledgerDimensionId);

        postingTrans.initFromLedgerVoucherObject(_defaultLedgerPostingReference);

        postingTrans.parmTransactionCurrencyAmount(_transactionCurrencyAmount);
        postingTrans.parmAccountingCurrencyAmount(_accountingCurrencyAmount);
        postingTrans.parmReportingCurrencyAmount(_reportingCurrencyAmount);

        return postingTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newBasicMST_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the LedgerVoucherTransObject class using a
    /// ledger posting reference for an accounting currency amount
    /// </summary>
    /// <param name="_ledgerVoucherObject">
    /// The ledger posting reference used for defaulting.
    /// </param>
    /// <param name="_posting">
    /// The posting type of the general journal entry.
    /// </param>
    /// <param name="_ledgerDimensionId">
    /// The dimension attribute value combination of the general journal entry.
    /// </param>
    /// <param name="_currencyCode">
    /// The currency code of the general journal entry.
    /// </param>
    /// <param name="_amountMST">
    /// The amount in the accounting currency.
    /// </param>
    /// <param name="_correct">
    /// A boolean parameter that determines if the general journal entry have to be correction.
    /// </param>
    /// <returns>
    /// A new instance of the LedgerVoucherTransObject class.
    /// </returns>
    public static LedgerVoucherTransObject newBasicMST_RU(LedgerVoucherObject           _ledgerVoucherObject,
                                                                 LedgerPostingType      _posting,
                                                                 LedgerDimensionAccount _ledgerDimensionId,
                                                                 CurrencyCode           _currencyCode,
                                                                 AmountMST              _amountMST,
                                                                 boolean                _correct = _ledgerVoucherObject.parmCorrection())
    {
        LedgerVoucherTransObject ret = LedgerVoucherTransObject::newBasicDefault(_ledgerVoucherObject,
                                                                                 _posting,
                                                                                 _ledgerDimensionId,
                                                                                 _currencyCode,
                                                                                 0,
                                                                                 _amountMST,
                                                                                 0);
        ret.parmLedgerDetailLevel(LedgerDetailLevel::AsDefault);
        ret.parmIsCorrection(_correct);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newBasicSecondary_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the LedgerVoucherTransObject class using a
    /// ledger posting reference for an accounting currency amount
    /// </summary>
    /// <param name="_ledgerVoucherObject">
    /// The ledger posting reference used for defaulting.
    /// </param>
    /// <param name="_posting">
    /// The posting type of the general journal entry.
    /// </param>
    /// <param name="_ledgerDimensionId">
    /// The dimension attribute value combination of the general journal entry.
    /// </param>
    /// <param name="_currencyCode">
    /// The currency code of the general journal entry.
    /// </param>
    /// <param name="_amountMSTSecondary">
    /// The amount in the reporting currency.
    /// </param>
    /// <param name="_correct">
    /// A boolean parameter that determines if the general journal entry have to be correction.
    /// </param>
    /// <returns>
    /// A new instance of the LedgerVoucherTransObject class.
    /// </returns>
    public static LedgerVoucherTransObject newBasicSecondary_RU(LedgerVoucherObject _ledgerVoucherObject,
                                                                LedgerPostingType   _posting,
                                                                LedgerDimensionAccount _ledgerDimensionId,
                                                                CurrencyCode        _currencyCode,
                                                                AmountMSTSecondary  _amountMSTSecondary = 0.0,
                                                                boolean             _correct            = _ledgerVoucherObject.parmCorrection())
    {
        LedgerVoucherTransObject ret = LedgerVoucherTransObject::newBasicDefault(_ledgerVoucherObject,
                                                                                 _posting,
                                                                                 _ledgerDimensionId,
                                                                                 _currencyCode,
                                                                                 0,
                                                                                 0,
                                                                                 _amountMSTSecondary);

        ret.parmLedgerDetailLevel(LedgerDetailLevel::AsDefault);
        if (_correct)
        {
            ret.parmCorrect(_correct);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newGeneralJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the LedgerVoucherTransObject class from a general journal entry.
    /// </summary>
    /// <param name="_generalJournalAccountEntry">
    ///    The line of the general journal entry.
    /// </param>
    /// <param name="_ledgerEntry">
    ///    The ledger entry of the general journal entry.
    /// </param>
    /// <returns>
    ///    A new instance of the LedgerVoucherTransObject class.
    /// </returns>
    public static LedgerVoucherTransObject newGeneralJournal(
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        LedgerEntry _ledgerEntry = null)
    {
        LedgerVoucherTransObject transaction = new LedgerVoucherTransObject(
            _generalJournalAccountEntry.PostingType,
            _generalJournalAccountEntry.TransactionCurrencyCode,
            _generalJournalAccountEntry.LedgerDimension);

        transaction.parmGeneralJournalAccountEntry(_generalJournalAccountEntry);
        transaction.parmLedgerEntry(_ledgerEntry);

        return transaction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newLedgerAllocationItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>LedgerVoucherTransObject</c> class from a ledger allocation
    ///    item.
    /// </summary>
    /// <param name="_baseTransaction">
    ///    The base ledger posting transaction.
    /// </param>
    /// <param name="_allocationItem">
    ///    The ledger allocation item.
    /// </param>
    /// <returns>
    ///    A new instance of the <c>LedgerVoucherTransObject</c> class.
    /// </returns>
    public static LedgerVoucherTransObject newLedgerAllocationItem(
        LedgerVoucherTransObject _baseTransaction,
        LedgerAllocationItem _allocationItem)
    {
        LedgerVoucherTransObject transaction = _baseTransaction.clone();
        RecId mainAccountRecId = _allocationItem.parmMainAccountId();
        transaction.parmTransactionCurrencyAmount(_allocationItem.getTransactionCurrencyAmount());
        transaction.parmAccountingCurrencyAmount(_allocationItem.getAccountingCurrencyAmount());
        transaction.parmReportingCurrencyAmount(_allocationItem.getSecondaryCurrencyAmount());
        transaction.parmQuantity(_allocationItem.getQuantity());
        transaction.parmAllocateLevel(_allocationItem.getLevel());

        DimensionHierarchyId accountStructureId = DimensionHierarchy::getAccountStructure(mainAccountRecId);
        if (accountStructureId)
        {
            transaction.parmLedgerDimensionId(LedgerDimensionDefaultingEngine::getLedgerDimensionFromAccountAndDimWithoutDerivedDimensions(mainAccountRecId, accountStructureId, _allocationItem.parmDefaultDimension()));
        }
        else
        {
            throw error(strFmt("@SYS4009834", MainAccount::find(mainAccountRecId).MainAccountId));
        }

        transaction.parmPostingType(LedgerPostingType::Allocation);
        transaction.parmParentTempRecId(_baseTransaction.parmTempRecId());

        return transaction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newLedgerPostingTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>LedgerVoucherTransObject</c> class.
    /// </summary>
    /// <param name="_ledgerPostingTransaction">
    /// The <c>LedgerPostingTransactionTmp</c> record.
    /// </param>
    /// <param name="_projectPostingTransaction">
    /// The <paramref name="_projectPostingTransaction"/> parameter is no longer used.
    /// </param>
    /// <returns>
    /// A new instance of the <c>LedgerVoucherTransObject</c> class.
    /// </returns>
    public static LedgerVoucherTransObject newLedgerPostingTransaction(LedgerPostingTransactionTmp _ledgerPostingTransaction, LedgerPostingTransactionProjectTmp _projectPostingTransaction = null)
    {
        LedgerVoucherTransObject transaction;

        transaction = new LedgerVoucherTransObject(
            _ledgerPostingTransaction.PostingType,
            _ledgerPostingTransaction.TransactionCurrencyCode,
            _ledgerPostingTransaction.LedgerDimension);

        transaction.initFromLedgerPostingTransaction(_ledgerPostingTransaction);

        return transaction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newSubLedgerJournalAccountEntryDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the LedgerVoucherTransObject class using a ledger posting reference
    ///    for defaulting.
    /// </summary>
    /// <param name="_defaultLedgerPostingReference">
    ///    The ledger posting reference used for defaulting.
    /// </param>
    /// <param name="_subledgerJournalAccountEntry">
    ///    The SubledgerJournalAccountEntry record.
    /// </param>
    /// <param name="_obsolete">
    ///    This parameter is obsolete and will be removed in the future. Rely on the default until it is
    ///    removed.
    /// </param>
    /// <returns>
    ///    A new instance of the LedgerVoucherTransObject class.
    /// </returns>
    public static LedgerVoucherTransObject newSubLedgerJournalAccountEntryDefault(
        LedgerVoucherObject _defaultLedgerPostingReference,
        SubledgerJournalAccountEntry _subledgerJournalAccountEntry,
        CurrencyCode _obsolete = '')
    {
        CurrencyExchangeHelper      exchangeRateHelper;
        LedgerVoucherTransObject    transaction;

        Debug::assert(
            _subledgerJournalAccountEntry.IsTransferredInDetail == TransferPolicy::Summarize ||
            _subledgerJournalAccountEntry.IsTransferredInDetail == TransferPolicy::TransferIndividual);

        transaction = LedgerVoucherTransObject::newBasicDefault(
            _defaultLedgerPostingReference,
            _subledgerJournalAccountEntry.PostingType,
            _subledgerJournalAccountEntry.LedgerDimension,
            _subledgerJournalAccountEntry.TransactionCurrency,
            _subledgerJournalAccountEntry.TransactionCurrencyAmount,
            _subledgerJournalAccountEntry.AccountingCurrencyAmount,
            _subledgerJournalAccountEntry.ReportingCurrencyAmount);

        // the sub ledger journal lines handle the allocation
        transaction.parmIgnoreAllocation(true);

        transaction.parmIsCorrection(_subledgerJournalAccountEntry.IsCorrection);

        exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(
            Ledger::primaryLedger(CompanyInfo::findDataArea(_subledgerJournalAccountEntry.company()).RecId),
            _defaultLedgerPostingReference.parmAccountingDate());

        exchangeRateHelper.parmExchangeRate1(_subledgerJournalAccountEntry.ExchangeRate1);
        exchangeRateHelper.parmExchangeRate2(_subledgerJournalAccountEntry.ExchangeRate2);
        exchangeRateHelper.parmReportingExchangeRate1(_subledgerJournalAccountEntry.ReportingExchangeRate1);
        exchangeRateHelper.parmReportingExchangeRate2(_subledgerJournalAccountEntry.ReportingExchangeRate2);

        return transaction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTransactionAccountingAmountsDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the LedgerVoucherTransObject class with a a transaction currency
    ///    amount, an accounting currency amount, and a ledger posting reference for defaulting.
    /// </summary>
    /// <param name="_defaultLedgerPostingReference">
    ///    The ledger posting reference used for defaulting.
    /// </param>
    /// <param name="_postingType">
    ///    The posting type of the general journal entry.
    /// </param>
    /// <param name="_ledgerDimensionId">
    ///    The dimension attribute value combination of the general journal entry.
    /// </param>
    /// <param name="_transactionCurrencyCode">
    ///    The currency code of the general journal entry.
    /// </param>
    /// <param name="_transactionCurrencyAmount">
    ///    The amount in the transaction currency.
    /// </param>
    /// <param name="_accountingCurrencyAmount">
    ///    The amount in the accounting currency.
    /// </param>
    /// <param name="_currencyExchangeHelper">
    ///    An <c>CurrencyExchangeHelper</c> object initialized for the current LedgerVoucherTransObject.
    /// </param>
    /// <returns>
    ///    A new instance of the LedgerVoucherTransObject class.
    /// </returns>
    /// <remarks>
    ///    The default ledger posting reference is used to set the transaction type.
    /// </remarks>
    public static LedgerVoucherTransObject newTransactionAccountingAmountsDefault(
        LedgerVoucherObject _defaultLedgerPostingReference,
        LedgerPostingType _postingType,
        RecId _ledgerDimensionId,
        CurrencyCode _transactionCurrencyCode,
        Money _transactionCurrencyAmount,
        MoneyMST _accountingCurrencyAmount,
        CurrencyExchangeHelper _currencyExchangeHelper)
    {
        LedgerVoucherTransObject postingTrans;

        postingTrans = new LedgerVoucherTransObject(
            _postingType,
            _transactionCurrencyCode,
            _ledgerDimensionId);

        postingTrans.initFromLedgerVoucherObject(_defaultLedgerPostingReference);
        postingTrans.parmTransactionCurrencyAmount(_transactionCurrencyAmount);
        postingTrans.parmAccountingCurrencyAmount(_accountingCurrencyAmount);

        postingTrans.parmReportingCurrencyAmount(_currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(_transactionCurrencyCode, _transactionCurrencyAmount));

        return postingTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTransactionAmountDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>LedgerVoucherTransObject</c> class by using a transaction
    ///    currency amount and a ledger posting reference for defaulting.
    /// </summary>
    /// <param name="_defaultLedgerPostingReference">
    ///    The ledger posting reference to use for defaulting.
    /// </param>
    /// <param name="_postingType">
    ///    The posting type of the general journal entry.
    /// </param>
    /// <param name="_ledgerDimensionId">
    ///    The dimension attribute value combination of the general journal entry.
    /// </param>
    /// <param name="_transactionCurrencyCode">
    ///    The currency code of the general journal entry.
    /// </param>
    /// <param name="_transactionCurrencyAmount">
    ///    The amount in the transaction currency.
    /// </param>
    /// <param name="_exchangeRateHelper">
    ///    The accounting currency amount and secondary currency amount exchange rates.
    /// </param>
    /// <returns>
    ///    A new instance of the <c>LedgerVoucherTransObject</c> class.
    /// </returns>
    /// <remarks>
    ///    The default ledger posting reference is used to set the transaction type and exchange rate date.
    /// </remarks>
    public static LedgerVoucherTransObject newTransactionAmountDefault(
        LedgerVoucherObject _defaultLedgerPostingReference,
        LedgerPostingType _postingType,
        LedgerDimensionAccount _ledgerDimensionId,
        CurrencyCode _transactionCurrencyCode,
        Money _transactionCurrencyAmount,
        CurrencyExchangeHelper _exchangeRateHelper)
    {
        LedgerVoucherTransObject postingTrans;

        postingTrans = new LedgerVoucherTransObject(
            _postingType,
            _transactionCurrencyCode,
            _ledgerDimensionId);

        postingTrans.initFromLedgerVoucherObject(_defaultLedgerPostingReference);

        postingTrans.parmTransactionCurrencyAmount(_transactionCurrencyAmount);

        postingTrans.parmAccountingCurrencyAmount(_exchangeRateHelper.calculateTransactionToAccounting(_transactionCurrencyCode, _transactionCurrencyAmount, true));
        postingTrans.parmReportingCurrencyAmount(_exchangeRateHelper.calculateTransactionCurrencyToReportingCurrency(_transactionCurrencyCode, _transactionCurrencyAmount));

        return postingTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTransLedgerJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>LedgerVoucherTransObject</c> object based on a <c>LedgerJournalTrans</c> table record buffer.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    /// <param name="_taxAmount">
    /// The tax amount; optional. Defaults to 0. Will be deducted from the regular amount of the <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    /// <param name="_bridging">
    /// true if the transation will be bridged; otherwise, false. optional.
    /// </param>
    /// <param name="_intercompanyRecIds">
    /// A container that holds the RecIds of <c>LedgerJournalTrans</c> records that are for intercompany accounts.
    /// </param>
    /// <param name="_reversalsMayExist">
    /// true if reversals may exist for this <c>LedgerJournalTrans</c> record; otherwise, false. Optional.
    /// </param>
    /// <param name="_forcedExchangeRate">
    /// true if the provided <c>LedgerJournalTrans</c> exchange rates should be used for accounting and reporting amount
    /// calculations; otherwise, false. Optional.
    /// </param>
    /// <returns>
    /// A new <c>LedgerVoucherTransObject</c> object.
    /// </returns>
    /// <remarks>
    /// The _reversalsMayExist parameter should only be set to false if the caller has already
    /// verified that reversals do not exist for this <c>LedgerJournalTrans</c> record. This is
    /// provided as a performance optimization because reversals are rare and can easily be
    /// checked at the journal level to save a relatively costly physical database query at
    /// this, the journal line, level.
    /// </remarks>
    public static LedgerVoucherTransObject newTransLedgerJournal(
        LedgerJournalTrans _ledgerJournalTrans,
        TaxAmount _taxAmount = 0,
        boolean _bridging  = false,
        container _intercompanyRecIds = conNull(),
        boolean _reversalsMayExist = true,
        boolean _forcedExchangeRate = false)
    {
        TransDate transDateOrig;
        TransDate exchangeRateDate;
        // <GEERU>
        #ISOCountryRegionCodes
        ExchRate reportingExchRate;
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        // the sign of amountCur is correct here because if the incoming debit or
        // credit is negative, IsCorrection is set to true below and that ensures
        // IsCredit is correct
        AmountCur amountCur = _ledgerJournalTrans.AmountCurDebit - _ledgerJournalTrans.AmountCurCredit - _taxAmount;

        LedgerPostingType postingType = LedgerVoucherTransObject::getPostingTypeForNewTransLedgerJournal(_ledgerJournalTrans, _intercompanyRecIds);

        LedgerVoucherTransObject ledgerTransObject = new LedgerVoucherTransObject(
            postingType,
            _ledgerJournalTrans.CurrencyCode,
            _ledgerJournalTrans.LedgerDimension);

        if (_ledgerJournalTrans.FurtherPostingRecId != 0)
        {
            // skip dimension validation because the bridged transactions were previously posted and may no longer be valid
            ledgerTransObject.parmSkipDimensionValidation(true);
        }
        ledgerTransObject.parmText(_ledgerJournalTrans.Txt);
        ledgerTransObject.parmDiscardLastTransTxt(true);
        ledgerTransObject.parmSkipBlockedForManualEntryCheck(_ledgerJournalTrans.SkipBlockedForManualEntryCheck);

        ledgerTransObject.parmPaymentReference(_ledgerJournalTrans.PaymReference);
        ledgerTransObject.parmPaymMode(_ledgerJournalTrans.PaymMode);
        ledgerTransObject.parmReasonRefRecID(_ledgerJournalTrans.ReasonRefRecID);
        ledgerTransObject.parmQuantity(_ledgerJournalTrans.Qty);
        ledgerTransObject.parmIsCorrection(_ledgerJournalTrans.correct());
        ledgerTransObject.parmTransactionCurrencyAmount(amountCur);

        ledgerTransObject.parmIsBridgingPosting(_bridging);

        ledgerTransObject.parmSourceRecId(_ledgerJournalTrans.RecId);
        ledgerTransObject.parmSourceTableId(_ledgerJournalTrans.TableId);
        ledgerTransObject.parmFinTag(_ledgerJournalTrans.FinTag);

        // Only query for reversals in cases where the caller has not already verified
        // that no reversals exist. Since this query is performed on a non-unique index
        // it will always cause a physical database query.
        if (_reversalsMayExist)
        {
            transDateOrig = LedgerJournalTrans::getTransDateByReverse(_ledgerJournalTrans.RecId);
        }

        if (transDateOrig)
        {
            // There is an original ledger journal trans for the current ledger journal trans - set the exchange rate date to the original
            exchangeRateDate = transDateOrig;
        }
        else
        {
            // There is not an original ledger journal trans - set the exchange rate date to the current ledger journal trans date
            exchangeRateDate = _ledgerJournalTrans.TransDate;
        }

        // <GEERU>
        if (countryRegion_RU)
        {
            switch (_ledgerJournalTrans.ledgerJournalTable().JournalType)
            {
                case LedgerJournalType::Assets_RU:
                    LedgerJournalTrans_RAsset ledgerJournalTrans_RAsset = LedgerJournalTrans_RAsset::find(_ledgerJournalTrans.RecId);
                    exchangeRateDate = ledgerJournalTrans_RAsset.getTransDate(_ledgerJournalTrans);
                    break;

                case LedgerJournalType::RDeferrals:
                    LedgerJournalTrans_RDeferrals ledgerJournalTrans_RDeferrals = LedgerJournalTrans_RDeferrals::find(_ledgerJournalTrans.RecId);
                    exchangeRateDate = ledgerJournalTrans_RDeferrals.getTransDate(_ledgerJournalTrans);
                    break;

                default:
                    transDateOrig = _ledgerJournalTrans.ledgerJournalTable().ledgerJournalTable_W().ReportingDate_RU;
                    if (transDateOrig)
                    {
                        exchangeRateDate = transDateOrig;
                        reportingExchRate = ExchangeRateHelper::exchRate(_ledgerJournalTrans.CurrencyCode, transDateOrig);
                    }
            }
        }
        // </GEERU>

        CurrencyExchangeHelper exchangeRateHelper =
            CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(
                                                                          _ledgerJournalTrans.companyInfo().RecId
                                                                          ), exchangeRateDate);

        if (_ledgerJournalTrans.Company == _ledgerJournalTrans.DataAreaId ||
            _forcedExchangeRate)
        {
            if (countryRegion_RU && reportingExchRate)
            {
                exchangeRateHelper.parmExchangeRate1(reportingExchRate);
            }
            else
            {
                exchangeRateHelper.parmExchangeRate1(_ledgerJournalTrans.ExchRate);
                exchangeRateHelper.parmExchangeRate2(_ledgerJournalTrans.ExchRateSecond);
                exchangeRateHelper.parmReportingExchangeRate1(_ledgerJournalTrans.ReportingCurrencyExchRate);
                exchangeRateHelper.parmReportingExchangeRate2(_ledgerJournalTrans.ReportingCurrencyExchRateSecondary);
            }
        }

        ledgerTransObject.parmAccountingCurrencyAmount(exchangeRateHelper.calculateTransactionToAccounting(_ledgerJournalTrans.CurrencyCode, amountCur, true));
        ledgerTransObject.parmReportingCurrencyAmount(exchangeRateHelper.calculateTransactionCurrencyToReportingCurrency(_ledgerJournalTrans.CurrencyCode, amountCur));

        return ledgerTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTransLedgerReportingCurrencyAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>LedgerVoucherTransObject</c> object based on a <c>LedgerJournalTrans</c> table record buffer for the reporting currency adjustment journal.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> record buffer.
    /// </param>        
    /// <returns>
    /// A new <c>LedgerVoucherTransObject</c> object.
    /// </returns>    
    public static LedgerVoucherTransObject newTransLedgerReportingCurrencyAdjustment(LedgerJournalTrans _ledgerJournalTrans)
    {
        TransDate transDateOrig;
        TransDate exchangeRateDate;       

        // the sign of amountCur is correct here because if the incoming debit or
        // credit is negative, IsCorrection is set to true below and that ensures
        // IsCredit is correct
        AmountCur amountCur = _ledgerJournalTrans.AmountCurDebit - _ledgerJournalTrans.AmountCurCredit;

        LedgerVoucherTransObject ledgerTransObject = new LedgerVoucherTransObject(
            LedgerPostingType::ReportingCurrencyAdjustment,
            _ledgerJournalTrans.CurrencyCode,
            _ledgerJournalTrans.LedgerDimension);

        if (_ledgerJournalTrans.FurtherPostingRecId != 0)
        {
            // skip dimension validation because the bridged transactions were previously posted and may no longer be valid
            ledgerTransObject.parmSkipDimensionValidation(true);
        }
        ledgerTransObject.parmText(_ledgerJournalTrans.Txt);
        ledgerTransObject.parmFinTag(_ledgerJournalTrans.FinTag);
        ledgerTransObject.parmDiscardLastTransTxt(true);
        ledgerTransObject.parmSkipBlockedForManualEntryCheck(_ledgerJournalTrans.SkipBlockedForManualEntryCheck);

        ledgerTransObject.parmReasonRefRecID(_ledgerJournalTrans.ReasonRefRecID);      
        ledgerTransObject.parmSourceRecId(_ledgerJournalTrans.RecId);
        ledgerTransObject.parmSourceTableId(_ledgerJournalTrans.TableId); 

        if (transDateOrig)
        {
            // There is an original ledger journal trans for the current ledger journal trans - set the exchange rate date to the original
            exchangeRateDate = transDateOrig;
        }
        else
        {
            // There is not an original ledger journal trans - set the exchange rate date to the current ledger journal trans date
            exchangeRateDate = _ledgerJournalTrans.TransDate;
        }      

        CurrencyExchangeHelper exchangeRateHelper =
            CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(
                                                                            _ledgerJournalTrans.companyInfo().RecId
                                                                            ), exchangeRateDate);
   
        exchangeRateHelper.parmExchangeRate1(_ledgerJournalTrans.ExchRate);
        exchangeRateHelper.parmExchangeRate2(_ledgerJournalTrans.ExchRateSecond); 
        exchangeRateHelper.parmReportingExchangeRate1(_ledgerJournalTrans.ReportingCurrencyExchRate);
        exchangeRateHelper.parmReportingExchangeRate2(_ledgerJournalTrans.ReportingCurrencyExchRateSecondary);

        // Set the transaction and accounting currency value to zero as the reporting currency adjustment journal posts only reporting currency ledger
        ledgerTransObject.parmTransactionCurrencyAmount(0);     
        ledgerTransObject.parmAccountingCurrencyAmount(0);

        ledgerTransObject.parmReportingCurrencyAmount(exchangeRateHelper.calculateTransactionCurrencyToReportingCurrency(_ledgerJournalTrans.CurrencyCode, amountCur));

        return ledgerTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new <c>LedgerVoucherTransObject</c> object.
    /// </summary>
    /// <param name = "_postingType">The posting type.</param>
    /// <param name = "_transactionCurrencyCode">The transactions currency code.</param>
    /// <param name = "_ledgerDimensionId">The ledger dimension id.</param>
    /// <returns>A new instance of the <c>LedgerVoucherTransObject</c> object.</returns>
    public static LedgerVoucherTransObject construct(
        LedgerPostingType _postingType,
        CurrencyCode _transactionCurrencyCode,
        LedgerDimensionAccount _ledgerDimensionId)
    {
        return new LedgerVoucherTransObject(_postingType, _transactionCurrencyCode, _ledgerDimensionId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPostingTypeForNewTransLedgerJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the posting type for a new <c>LedgerVoucherTransObject</c> object.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    /// <param name = "_intercompanyRecIds">
    /// A container that holds the RecIds of <c>LedgerJournalTrans</c> records that are for intercompany accounts.
    /// </param>
    /// <returns>
    /// A <c>LedgerPostingType</c> enumeration value.
    /// </returns>
    protected static LedgerPostingType getPostingTypeForNewTransLedgerJournal(LedgerJournalTrans _ledgerJournalTrans, container _intercompanyRecIds)
    {
        // <GEERU>
        #ISOCountryRegionCodes
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        LedgerPostingType postingType;

        // for posting on a customer or vendor summary account the posting type must be
        // changed to CustBalance resp VendBalance
        switch (_ledgerJournalTrans.AccountType)
        {
            case LedgerJournalACType::Cust:
                postingType = LedgerPostingType::CustBalance;
                break;

            case LedgerJournalACType::Vend:
                postingType = LedgerPostingType::VendBalance;
                break;

            case LedgerJournalACType::Bank:
                postingType = LedgerPostingType::Bank;
                break;

            case LedgerJournalACType::FixedAssets:
                if (_ledgerJournalTrans.AmountCurDebit)
                {
                    postingType = LedgerPostingType::FixedAssetsDebit;
                }
                else
                {
                    postingType = LedgerPostingType::FixedAssetsCredit;
                }
                break;

                // <GEERU>
            case LedgerJournalACType::FixedAssets_RU:
                if (_ledgerJournalTrans.AmountCurDebit)
                {
                    postingType = LedgerPostingType::FixedAssetsDebit_RU;
                }
                else
                {
                    postingType = LedgerPostingType::FixedAssetsCredit_RU;
                }
                break;
            case LedgerJournalACType::RDeferrals:
                if (_ledgerJournalTrans.AmountCurDebit)
                {
                    postingType = LedgerPostingType::DeferralsDebit_RU;
                }
                else
                {
                    postingType = LedgerPostingType::DeferralsCredit_RU;
                }
                break;
            case LedgerJournalACType::RCash:
                postingType = LedgerPostingType::RCash;
                break;
            case LedgerJournalACType::Employee_RU:
                postingType = LedgerPostingType::EmplPayment_RU;
                break;
            // </GEERU>

            default:
                postingType = LedgerPostingType::LedgerJournal;

                // for the journal line, which has been created during the transfer to the vendor invoice journal
                // with the summary account of the vendor, the posting type must be changed to VendBalance
                if (_ledgerJournalTrans.Transferred)
                {
                    VendTrans vendTrans;
                    LedgerJournalVoucherChanged ledgerJournalVoucherChanged = LedgerJournalVoucherChanged::find(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher);

                    if (ledgerJournalVoucherChanged)
                    {
                        vendTrans = VendTrans::findVoucherDate(ledgerJournalVoucherChanged.FromVoucher, ledgerJournalVoucherChanged.FromDate);
                    }
                    else
                    {
                        vendTrans = VendTrans::findVoucherDate(_ledgerJournalTrans.Voucher, _ledgerJournalTrans.TransDate);
                    }

                    if (!vendTrans && LedgerJournalTable::find(_ledgerJournalTrans.JournalNum).JournalType == LedgerJournalType::Approval)
                    {
                        vendTrans = VendTrans::findByJournalNum(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.TransferredOn);
                    }

                    if (vendTrans)
                    {
                        MainAccount summaryAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(VendLedgerAccounts::summaryLedgerDimension(vendTrans.AccountNum, vendTrans.PostingProfile));
                        MainAccount journalAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(_ledgerJournalTrans.LedgerDimension);
                        MainAccount purchLedgerAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(VendLedgerAccounts::purchasingLedgerDimension(vendTrans.AccountNum, vendTrans.PostingProfile));

                        if (summaryAccount.RecId == journalAccount.RecId
                            || purchLedgerAccount.RecId == journalAccount.RecId)
                        {
                            postingType = LedgerPostingType::VendBalance;
                        }
                    }
                }

                LedgerjournalTable ledgerJournalTable = _ledgerJournalTrans.ledgerJournalTable();
                // <GEERU>
                if (ledgerJournalTable.JournalType == LedgerJournalType::RTax25AmountDifference)
                {
                    if (( _ledgerJournalTrans.CustTransId && _ledgerJournalTrans.AmountCurDebit < 0) ||
                        (!_ledgerJournalTrans.CustTransId && _ledgerJournalTrans.AmountCurDebit > 0))
                    {
                        postingType = LedgerPostingType::AmountDiffGain_RU;
                    }
                    else
                    {
                        postingType = LedgerPostingType::AmountDiffLoss_RU;
                    }
                }

                if (ledgerJournalTable.JournalType == LedgerJournalType::RTax25ExchDifference)
                {
                    if ((_ledgerJournalTrans.CustTransId && _ledgerJournalTrans.amount()) > 0 ||
                        (_ledgerJournalTrans.VendTransId && _ledgerJournalTrans.amount()) < 0)
                    {
                        postingType = LedgerPostingType::AdvanceAdjustmentGain_RU;
                    }
                    else
                    {
                        postingType = LedgerPostingType::AdvanceAdjustmentLoss_RU;
                    }
                }

                if (_ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::RTax25DebtDebitReserve)
                {
                    postingType = LedgerPostingType::CustPayment;
                }
 
                if (countryRegion_RU)
                {
                    if (ledgerJournalTable.JournalType == LedgerJournalType::VendInvoiceRegister &&
                        _ledgerJournalTrans.MarkupCode_RU)
                    {
                        postingType = MarkupTable::find(MarkupModuleType::Vend, _ledgerJournalTrans.MarkupCode_RU).CustPosting;
                    }
                    LedgerJournalTrans_RAsset ledgerJournalTrans_RAsset = LedgerJournalTrans_RAsset::find(_ledgerJournalTrans.RecId);
                    if (ledgerJournalTrans_RAsset.PostValue == RAssetPostValue::BalanceAcq ||
                        ledgerJournalTrans_RAsset.PostValue == RAssetPostValue::BalanceDepr)
                    {
                        postingType = LedgerJournalTransUpdateAsset_ru::getPostingType(ledgerJournalTrans_RAsset.PostValue,
                                                                                       ledgerJournalTrans_RAsset.TransType,
                                                                                       _ledgerJournalTrans.AmountCurDebit != 0);
                    }
                }
                // </GEERU>

                // If the LedgerJournalTrans was created using the intercompany accounts, set the posting type to InterCompany
                if (conFind(_intercompanyRecIds, _ledgerJournalTrans.RecId) != 0)
                {
                    postingType = LedgerPostingType::InterCompany;
                }

                if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled()
                    && TaxEngineTaxJournalUtil::isLedgerJournalTableCreatedFromTaxJournal(ledgerJournalTable.RecId))
                {
                    postingType = TaxEngineTaxJournalUtil::getTaxAccountLedgerPostingType(_ledgerJournalTrans.RecId);
                }

                if (_ledgerJournalTrans.TaxCode && MainAccount::findByLedgerDimension(_ledgerJournalTrans.LedgerDimension).PostingType == LedgerPostingType::Tax)
                {
                    postingType = LedgerPostingType::Tax;
                }

                // Checking if the journal is posted thru tax adjustment, update posting type to TDS or TCS.
                if (_ledgerJournalTrans.ledgerJournalTransTaxExtensionIN().TaxWithholdCode)
                {
                    LedgerPostingType mainAccountPostingType = MainAccount::findByLedgerDimension(_ledgerJournalTrans.LedgerDimension).PostingType;

                    if (mainAccountPostingType == LedgerPostingType::TDS_IN || mainAccountPostingType == LedgerPostingType::TCS_IN)
                    {
                        postingType = mainAccountPostingType;
                    }
                }
        }

        return postingType;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>