<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ResSchedulingSQLObjects</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>ResSchedulingSQLObjects</c> class manages SQL Server objects for project resource scheduling.
/// </summary>
class ResSchedulingSQLObjects extends ApplicationSQLObjects
{
    private const str availabilityByResourceForHour = 'ResAvailabilityByResourceForHour';
    private const str availabilityByResourceForDay = 'ResAvailabilityByResourceForDay';
    private const str availabilityByResourceForWeek = 'ResAvailabilityByResourceForWeek';
    private const str availabilityByResourceForMonth = 'ResAvailabilityByResourceForMonth';
    private const str availabilityByResourceForQuarter = 'ResAvailabilityByResourceForQuarter';
    private const str availabilityByResourceForHalfYear = 'ResAvailabilityByResourceForHalfYear';

    private const str activityByResourceForHour = 'ResActivityByResourceForHour';
    private const str activityByResourceForDay = 'ResActivityByResourceForDay';
    private const str activityByResourceForWeek = 'ResActivityByResourceForWeek';
    private const str activityByResourceForMonth = 'ResActivityByResourceForMonth';
    private const str activityByResourceForQuarter = 'ResActivityByResourceForQuarter';
    private const str activityByResourceForHalfYear = 'ResActivityByResourceForHalfYear';

    private const str activityByPlannedResourceForHour = 'ResActivityByPlannedResourceForHour';
    private const str activityByPlannedResourceForDay = 'ResActivityByPlannedResourceForDay';
    private const str activityByPlannedResourceForWeek = 'ResActivityByPlannedResourceForWeek';
    private const str activityByPlannedResourceForMonth = 'ResActivityByPlannedResourceForMonth';
    private const str activityByPlannedResourceForQuarter = 'ResActivityByPlannedResourceForQuarter';
    private const str activityByPlannedResourceForHalfYear = 'ResActivityByPlannedResourceForHalfYear';

    private const str assignmentByResourceForHour = 'ResAssignmentByResourceForHour';
    private const str assignmentByResourceForDay = 'ResAssignmentByResourceForDay';
    private const str assignmentByResourceForWeek = 'ResAssignmentByResourceForWeek';
    private const str assignmentByResourceForMonth = 'ResAssignmentByResourceForMonth';
    private const str assignmentByResourceForQuarter = 'ResAssignmentByResourceForQuarter';
    private const str assignmentByResourceForHalfYear = 'ResAssignmentByResourceForHalfYear';

    private const str assignmentByPlannedResourceForHour = 'ResAssignmentByPlannedResourceForHour';
    private const str assignmentByPlannedResourceForDay = 'ResAssignmentByPlannedResourceForDay';
    private const str assignmentByPlannedResourceForWeek = 'ResAssignmentByPlannedResourceForWeek';
    private const str assignmentByPlannedResourceForMonth = 'ResAssignmentByPlannedResourceForMonth';
    private const str assignmentByPlannedResourceForQuarter = 'ResAssignmentByPlannedResourceForQuarter';
    private const str assignmentByPlannedResourceForHalfYear = 'ResAssignmentByPlannedResourceForHalfYear';

    private const str deleteResRollupTables = 'ResRollupTablesDelete';
    private const str deleteResProjectResourceTables = 'ResProjectResourceTablesDelete';
    private const str deleteResCalendarCapacityTables = 'ResCalendarCapacityTableDelete';

    private const str reservedStatusThresholdForHour = '0.1';
    private const str reservedStatusThresholdForDay = '0.3';
    private const str reservedStatusThresholdForWeek = '1.0';
    private const str reservedStatusThresholdForMonth = '1.0';
    private const str reservedStatusThresholdForQuarter = '1.0';
    private const str reservedStatusThresholdForHalfYear = '1.0';
    private const str roundingDecimalPrecision = '2';

    // Force project resource scheduling SQL objects to be instantiated upon referencing this class
    private static boolean initSuccess = ResSchedulingSQLObjects::createAll();

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>createAll</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the project resource scheduling SQL objects.
    /// </summary>
    /// <param name="_forceCreate">
    /// Indicates whether to force creating all the project resource scheduling SQL objects
    /// regardless of the state of the cache or the existing objects; optional.
    /// </param>
    /// <returns>
    /// true if the object creation was successful or already exists; False if the creation of the SQL objects failed.
    /// </returns>
    public static boolean createAll(boolean _forceCreate = false)
    {
        boolean isSuccessful = true;
        container cachedResult;
        SysGlobalObjectCache objectCache = ClassFactory.globalObjectCache();
        ResSchedulingSQLObjects schedulingSQLObjects;

        if (_forceCreate || objectCache.find(classStr(ResSchedulingSQLObjects), ApplicationSQLObjects::SQLObjectsCreatedKey) == connull())
        {
            schedulingSQLObjects = new ResSchedulingSQLObjects();
            schedulingSQLObjects.initialize();

            if (_forceCreate ||
                !schedulingSQLObjects.existProcedure(availabilityByResourceForHour) ||
                !schedulingSQLObjects.existProcedure(availabilityByResourceForDay) ||
                !schedulingSQLObjects.existProcedure(availabilityByResourceForWeek) ||
                !schedulingSQLObjects.existProcedure(availabilityByResourceForMonth) ||
                !schedulingSQLObjects.existProcedure(availabilityByResourceForQuarter) ||
                !schedulingSQLObjects.existProcedure(availabilityByResourceForHalfYear) ||

                !schedulingSQLObjects.existProcedure(activityByResourceForHour) ||
                !schedulingSQLObjects.existProcedure(activityByResourceForDay) ||
                !schedulingSQLObjects.existProcedure(activityByResourceForWeek) ||
                !schedulingSQLObjects.existProcedure(activityByResourceForMonth) ||
                !schedulingSQLObjects.existProcedure(activityByResourceForQuarter) ||
                !schedulingSQLObjects.existProcedure(activityByResourceForHalfYear) ||

                !schedulingSQLObjects.existProcedure(activityByPlannedResourceForHour) ||
                !schedulingSQLObjects.existProcedure(activityByPlannedResourceForDay) ||
                !schedulingSQLObjects.existProcedure(activityByPlannedResourceForWeek) ||
                !schedulingSQLObjects.existProcedure(activityByPlannedResourceForMonth) ||
                !schedulingSQLObjects.existProcedure(activityByPlannedResourceForQuarter) ||
                !schedulingSQLObjects.existProcedure(activityByPlannedResourceForHalfYear) ||

                !schedulingSQLObjects.existProcedure(assignmentByResourceForHour) ||
                !schedulingSQLObjects.existProcedure(assignmentByResourceForDay) ||
                !schedulingSQLObjects.existProcedure(assignmentByResourceForWeek) ||
                !schedulingSQLObjects.existProcedure(assignmentByResourceForMonth) ||
                !schedulingSQLObjects.existProcedure(assignmentByResourceForQuarter) ||
                !schedulingSQLObjects.existProcedure(assignmentByResourceForHalfYear) ||

                !schedulingSQLObjects.existProcedure(assignmentByPlannedResourceForHour) ||
                !schedulingSQLObjects.existProcedure(assignmentByPlannedResourceForDay) ||
                !schedulingSQLObjects.existProcedure(assignmentByPlannedResourceForWeek) ||
                !schedulingSQLObjects.existProcedure(assignmentByPlannedResourceForMonth) ||
                !schedulingSQLObjects.existProcedure(assignmentByPlannedResourceForQuarter) ||
                !schedulingSQLObjects.existProcedure(assignmentByPlannedResourceForHalfYear) ||
                
                !schedulingSQLObjects.existProcedure(deleteResRollupTables) ||
                !schedulingSQLObjects.existProcedure(deleteResProjectResourceTables) ||
                !schedulingSQLObjects.existProcedure(deleteResCalendarCapacityTables))
            {
                isSuccessful = schedulingSQLObjects.createSqlObjects();
            }

            if (isSuccessful)
            {
                // Add the SQL objects created indicator to the cache.
                objectCache.insert(classStr(ResSchedulingSQLObjects), ApplicationSQLObjects::SQLObjectsCreatedKey, [true]);
            }
        }

        return isSuccessful;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResAvailabilityByResourceForHour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the 'ResAvailabilityByResourceForHour' store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the 'ResAvailabilityByResourceForHour' procedure.
    /// </returns>
    public static str getResAvailabilityByResourceForHour()
    {
        return availabilityByResourceForHour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResAvailabilityByResourceForDay</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResAvailabilityByResourceForDay</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResAvailabilityByResourceForDay</c> store procedure.
    /// </returns>
    public static str getResAvailabilityByResourceForDay()
    {
        return availabilityByResourceForDay;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResAvailabilityByResourceForWeek</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResAvailabilityByResourceForWeek</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResAvailabilityByResourceForWeek</c> store procedure.
    /// </returns>
    public static str getResAvailabilityByResourceForWeek()
    {
        return availabilityByResourceForWeek;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResAvailabilityByResourceForMonth</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResAvailabilityByResourceForMonth</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResAvailabilityByResourceForMonth</c> store procedure.
    /// </returns>
    public static str getResAvailabilityByResourceForMonth()
    {
        return availabilityByResourceForMonth;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResAvailabilityByResourceForQuarter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResAvailabilityByResourceForQuarter</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResAvailabilityByResourceForQuarter</c> store procedure.
    /// </returns>
    public static str getResAvailabilityByResourceForQuarter()
    {
        return availabilityByResourceForQuarter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResAvailabilityByResourceForHalfYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResAvailabilityByResourceForHalfYear</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResAvailabilityByResourceForHalfYear</c> store procedure.
    /// </returns>
    public static str getResAvailabilityByResourceForHalfYear()
    {
        return availabilityByResourceForHalfYear;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResActivityByResourceForHour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResActivityByResourceForHour</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResActivityByResourceForHour</c> store procedure.
    /// </returns>
    public static str getResActivityByResourceForHour()
    {
        return activityByResourceForHour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResActivityByResourceForDay</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResActivityByResourceForDay</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResActivityByResourceForDay</c> store procedure.
    /// </returns>
    public static str getResActivityByResourceForDay()
    {
        return activityByResourceForDay;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResActivityByResourceForWeek</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResActivityByResourceForWeek</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResActivityByResourceForWeek</c> store procedure.
    /// </returns>
    public static str getResActivityByResourceForWeek()
    {
        return activityByResourceForWeek;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResActivityByResourceForMonth</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResActivityByResourceForMonth</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResActivityByResourceForMonth</c> store procedure.
    /// </returns>
    public static str getResActivityByResourceForMonth()
    {
        return activityByResourceForMonth;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResActivityByResourceForQuarter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResActivityByResourceForQuarter</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResActivityByResourceForQuarter</c> store procedure.
    /// </returns>
    public static str getResActivityByResourceForQuarter()
    {
        return activityByResourceForQuarter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResActivityByResourceForHalfYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResActivityByResourceForHalfYear</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResActivityByResourceForHalfYear</c> store procedure.
    /// </returns>
    public static str getResActivityByResourceForHalfYear()
    {
        return activityByResourceForHalfYear;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResActivityByPlannedResourceForHour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResActivityByPlannedResourceForHour</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResActivityByPlannedResourceForHour</c> store procedure.
    /// </returns>
    public static str getResActivityByPlannedResourceForHour()
    {
        return activityByPlannedResourceForHour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResActivityByPlannedResourceForDay</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResActivityByPlannedResourceForDay</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResActivityByPlannedResourceForDay</c> store procedure.
    /// </returns>
    public static str getResActivityByPlannedResourceForDay()
    {
        return activityByPlannedResourceForDay;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResActivityByPlannedResourceForWeek</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResActivityByPlannedResourceForWeek</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResActivityByPlannedResourceForWeek</c> store procedure.
    /// </returns>
    public static str getResActivityByPlannedResourceForWeek()
    {
        return activityByPlannedResourceForWeek;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResActivityByPlannedResourceForMonth</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResActivityByPlannedResourceForMonth</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResActivityByPlannedResourceForMonth</c> store procedure.
    /// </returns>
    public static str getResActivityByPlannedResourceForMonth()
    {
        return activityByPlannedResourceForMonth;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResActivityByPlannedResourceForQuarter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResActivityByPlannedResourceForQuarter</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResActivityByPlannedResourceForQuarter</c> store procedure.
    /// </returns>
    public static str getResActivityByPlannedResourceForQuarter()
    {
        return activityByPlannedResourceForQuarter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResActivityByPlannedResourceForHalfYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResActivityByPlannedResourceForHalfYear</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResActivityByPlannedResourceForHalfYear</c> store procedure.
    /// </returns>
    public static str getResActivityByPlannedResourceForHalfYear()
    {
        return activityByPlannedResourceForHalfYear;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResAssignmentByResourceForHour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResAssignmentByResourceForHour</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResAssignmentByResourceForHour</c> store procedure.
    /// </returns>
    public static str getResAssignmentByResourceForHour()
    {
        return assignmentByResourceForHour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResAssignmentByResourceForDay</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResAssignmentByResourceForDay</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResAssignmentByResourceForDay</c> store procedure.
    /// </returns>
    public static str getResAssignmentByResourceForDay()
    {
        return assignmentByResourceForDay;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResAssignmentByResourceForWeek</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResAssignmentByResourceForWeek</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResAssignmentByResourceForWeek</c> store procedure.
    /// </returns>
    public static str getResAssignmentByResourceForWeek()
    {
        return assignmentByResourceForWeek;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResAssignmentByResourceForMonth</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResAssignmentByResourceForMonth</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResAssignmentByResourceForMonth</c> store procedure.
    /// </returns>
    public static str getResAssignmentByResourceForMonth()
    {
        return assignmentByResourceForMonth;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResAssignmentByResourceForQuarter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResAssignmentByResourceForQuarter</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResAssignmentByResourceForQuarter</c> store procedure.
    /// </returns>
    public static str getResAssignmentByResourceForQuarter()
    {
        return assignmentByResourceForQuarter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResAssignmentByResourceForHalfYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResAssignmentByResourceForHalfYear</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResAssignmentByResourceForHalfYear</c> store procedure.
    /// </returns>
    public static str getResAssignmentByResourceForHalfYear()
    {
        return assignmentByResourceForHalfYear;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResAssignmentByPlannedResourceForHour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResAssignmentByPlannedResourceForHour</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResAssignmentByPlannedResourceForHour</c> store procedure.
    /// </returns>
    public static str getResAssignmentByPlannedResourceForHour()
    {
        return assignmentByPlannedResourceForHour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResAssignmentByPlannedResourceForDay</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResAssignmentByPlannedResourceForDay</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResAssignmentByPlannedResourceForDay</c> store procedure.
    /// </returns>
    public static str getResAssignmentByPlannedResourceForDay()
    {
        return assignmentByPlannedResourceForDay;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResAssignmentByPlannedResourceForWeek</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResAssignmentByPlannedResourceForWeek</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResAssignmentByPlannedResourceForWeek</c> store procedure.
    /// </returns>
    public static str getResAssignmentByPlannedResourceForWeek()
    {
        return assignmentByPlannedResourceForWeek;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResAssignmentByPlannedResourceForMonth</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResAssignmentByPlannedResourceForMonth</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResAssignmentByPlannedResourceForMonth</c> store procedure.
    /// </returns>
    public static str getResAssignmentByPlannedResourceForMonth()
    {
        return assignmentByPlannedResourceForMonth;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResAssignmentByPlannedResourceForQuarter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResAssignmentByPlannedResourceForQuarter</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResAssignmentByPlannedResourceForQuarter</c> store procedure.
    /// </returns>
    public static str getResAssignmentByPlannedResourceForQuarter()
    {
        return assignmentByPlannedResourceForQuarter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResAssignmentByPlannedResourceForHalfYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SQL name of the <c>ResAssignmentByPlannedResourceForHalfYear</c> store procedure.
    /// </summary>
    /// <returns>
    /// The SQL name of the <c>ResAssignmentByPlannedResourceForHalfYear</c> store procedure.
    /// </returns>
    public static str getResAssignmentByPlannedResourceForHalfYear()
    {
        return assignmentByPlannedResourceForHalfYear;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFunctions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the project resource scheduling SQL functions.
    /// </summary>
    /// <returns>
    /// true if the function creation commands were successful; otherwise, false.
    /// </returns>
    public boolean createFunctions()
    {
        boolean isSuccessful;

        isSuccessful = this.createResSchedulingStoreProcedure(availabilityByResourceForHour)
            && this.createResSchedulingStoreProcedure(availabilityByResourceForDay)
            && this.createResSchedulingStoreProcedure(availabilityByResourceForWeek)
            && this.createResSchedulingStoreProcedure(availabilityByResourceForMonth)
            && this.createResSchedulingStoreProcedure(availabilityByResourceForQuarter)
            && this.createResSchedulingStoreProcedure(availabilityByResourceForHalfYear)

            && this.createResSchedulingStoreProcedure(activityByResourceForHour)
            && this.createResSchedulingStoreProcedure(activityByResourceForDay)
            && this.createResSchedulingStoreProcedure(activityByResourceForWeek)
            && this.createResSchedulingStoreProcedure(activityByResourceForMonth)
            && this.createResSchedulingStoreProcedure(activityByResourceForQuarter)
            && this.createResSchedulingStoreProcedure(activityByResourceForHalfYear)

            && this.createResSchedulingStoreProcedure(activityByPlannedResourceForHour)
            && this.createResSchedulingStoreProcedure(activityByPlannedResourceForDay)
            && this.createResSchedulingStoreProcedure(activityByPlannedResourceForWeek)
            && this.createResSchedulingStoreProcedure(activityByPlannedResourceForMonth)
            && this.createResSchedulingStoreProcedure(activityByPlannedResourceForQuarter)
            && this.createResSchedulingStoreProcedure(activityByPlannedResourceForHalfYear)

            && this.createResSchedulingStoreProcedure(assignmentByResourceForHour)
            && this.createResSchedulingStoreProcedure(assignmentByResourceForDay)
            && this.createResSchedulingStoreProcedure(assignmentByResourceForWeek)
            && this.createResSchedulingStoreProcedure(assignmentByResourceForMonth)
            && this.createResSchedulingStoreProcedure(assignmentByResourceForQuarter)
            && this.createResSchedulingStoreProcedure(assignmentByResourceForHalfYear)

            && this.createResSchedulingStoreProcedure(assignmentByPlannedResourceForHour)
            && this.createResSchedulingStoreProcedure(assignmentByPlannedResourceForDay)
            && this.createResSchedulingStoreProcedure(assignmentByPlannedResourceForWeek)
            && this.createResSchedulingStoreProcedure(assignmentByPlannedResourceForMonth)
            && this.createResSchedulingStoreProcedure(assignmentByPlannedResourceForQuarter)
            && this.createResSchedulingStoreProcedure(assignmentByPlannedResourceForHalfYear)

            && this.createResSchedulingStoreProcedure(deleteResRollupTables)
            && this.createResSchedulingStoreProcedure(deleteResProjectResourceTables)
            && this.createResSchedulingStoreProcedure(deleteResCalendarCapacityTables);

        return isSuccessful;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createResSchedulingStoreProcedure</Name>
				<Source><![CDATA[
    private boolean createResSchedulingStoreProcedure(str _storeProcedureName)
    {
        // Drop the procedure.
        boolean isSuccessful = this.dropProcedure(_storeProcedureName);

        str sqlStatementText;

        if (isSuccessful)
        {
            switch (_storeProcedureName)
            {
                case availabilityByResourceForHour:
                    if (FeatureStateProvider::isFeatureEnabled(ResResourceAvailabilityChartPerfFlight::instance()))
                    {
                        sqlStatementText = this.getAvailabilityByResourceForHourStoreProcedureV2(availabilityByResourceForHour, reservedStatusThresholdForHour);
                    }
                    else
                    {
                        sqlStatementText = this.getAvailabilityByResourceForHourStoreProcedure(availabilityByResourceForHour, reservedStatusThresholdForHour);
                    }
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case availabilityByResourceForDay:
                    if (FeatureStateProvider::isFeatureEnabled(ResResourceAvailabilityChartPerfFlight::instance()))
                    {
                        sqlStatementText = this.getAvailabilityByResourceStoreProcedureV2(availabilityByResourceForDay, reservedStatusThresholdForDay, AVTimeframeType::Day);
                    }
                    else
                    {
                        sqlStatementText = this.getAvailabilityByResourceStoreProcedure(availabilityByResourceForDay, reservedStatusThresholdForDay, AVTimeframeType::Day);
                    }
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case availabilityByResourceForWeek:
                    if (FeatureStateProvider::isFeatureEnabled(ResResourceAvailabilityChartPerfFlight::instance()))
                    {
                        sqlStatementText = this.getAvailabilityByResourceStoreProcedureV2(availabilityByResourceForWeek, reservedStatusThresholdForWeek, AVTimeframeType::Week);
                    }
                    else
                    {
                        sqlStatementText = this.getAvailabilityByResourceStoreProcedure(availabilityByResourceForWeek, reservedStatusThresholdForWeek, AVTimeframeType::Week);
                    }
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case availabilityByResourceForMonth:
                    if (FeatureStateProvider::isFeatureEnabled(ResResourceAvailabilityChartPerfFlight::instance()))
                    {
                        sqlStatementText = this.getAvailabilityByResourceStoreProcedureV2(availabilityByResourceForMonth, reservedStatusThresholdForMonth, AVTimeframeType::Month);
                    }
                    else
                    {
                        sqlStatementText = this.getAvailabilityByResourceStoreProcedure(availabilityByResourceForMonth, reservedStatusThresholdForMonth, AVTimeframeType::Month);
                    }
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case availabilityByResourceForQuarter:
                    if (FeatureStateProvider::isFeatureEnabled(ResResourceAvailabilityChartPerfFlight::instance()))
                    {
                        sqlStatementText = this.getAvailabilityByResourceStoreProcedureV2(availabilityByResourceForQuarter, reservedStatusThresholdForQuarter, AVTimeframeType::Quarter);
                    }
                    else
                    {
                        sqlStatementText = this.getAvailabilityByResourceStoreProcedure(availabilityByResourceForQuarter, reservedStatusThresholdForQuarter, AVTimeframeType::Quarter);
                    }
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case availabilityByResourceForHalfYear:
                    if (FeatureStateProvider::isFeatureEnabled(ResResourceAvailabilityChartPerfFlight::instance()))
                    {
                        sqlStatementText = this.getAvailabilityByResourceStoreProcedureV2(availabilityByResourceForHalfYear, reservedStatusThresholdForHalfYear, AVTimeframeType::HalfYear);
                    }
                    else
                    {
                        sqlStatementText = this.getAvailabilityByResourceStoreProcedure(availabilityByResourceForHalfYear, reservedStatusThresholdForHalfYear, AVTimeframeType::HalfYear);
                    }
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;

                case activityByResourceForHour:
                    if (FeatureStateProvider::isFeatureEnabled(ResResourceAvailabilityChartPerfFlight::instance()))
                    {
                        sqlStatementText = this.getActivityByResourceForHourStoreProcedureV2(activityByResourceForHour, reservedStatusThresholdForHour);
                    }
                    else
                    {
                        sqlStatementText = this.getActivityByResourceForHourStoreProcedure(activityByResourceForHour, reservedStatusThresholdForHour);
                    }
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case activityByResourceForDay:
                    if (FeatureStateProvider::isFeatureEnabled(ResResourceAvailabilityChartPerfFlight::instance()))
                    {
                        sqlStatementText = this.getActivityByResourceStoreProcedureV2(activityByResourceForDay, reservedStatusThresholdForDay, AVTimeframeType::Day);
                    }
                    else
                    {
                        sqlStatementText = this.getActivityByResourceStoreProcedure(activityByResourceForDay, reservedStatusThresholdForDay, AVTimeframeType::Day);
                    }
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case activityByResourceForWeek:
                    if (FeatureStateProvider::isFeatureEnabled(ResResourceAvailabilityChartPerfFlight::instance()))
                    {
                        sqlStatementText = this.getActivityByResourceStoreProcedureV2(activityByResourceForWeek, reservedStatusThresholdForWeek, AVTimeframeType::Week);
                    }
                    else
                    {
                        sqlStatementText = this.getActivityByResourceStoreProcedure(activityByResourceForWeek, reservedStatusThresholdForWeek, AVTimeframeType::Week);
                    }
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case activityByResourceForMonth:
                    if (FeatureStateProvider::isFeatureEnabled(ResResourceAvailabilityChartPerfFlight::instance()))
                    {
                        sqlStatementText = this.getActivityByResourceStoreProcedureV2(activityByResourceForMonth, reservedStatusThresholdForMonth, AVTimeframeType::Month);
                    }
                    else
                    {
                        sqlStatementText = this.getActivityByResourceStoreProcedure(activityByResourceForMonth, reservedStatusThresholdForMonth, AVTimeframeType::Month);
                    }
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case activityByResourceForQuarter:
                    if (FeatureStateProvider::isFeatureEnabled(ResResourceAvailabilityChartPerfFlight::instance()))
                    {
                        sqlStatementText = this.getActivityByResourceStoreProcedureV2(activityByResourceForQuarter, reservedStatusThresholdForQuarter, AVTimeframeType::Quarter);
                    }
                    else
                    {
                        sqlStatementText = this.getActivityByResourceStoreProcedure(activityByResourceForQuarter, reservedStatusThresholdForQuarter, AVTimeframeType::Quarter);
                    }
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case activityByResourceForHalfYear:
                    if (FeatureStateProvider::isFeatureEnabled(ResResourceAvailabilityChartPerfFlight::instance()))
                    {
                        sqlStatementText = this.getActivityByResourceStoreProcedureV2(activityByResourceForHalfYear, reservedStatusThresholdForHalfYear, AVTimeframeType::HalfYear);
                    }
                    else
                    {
                        sqlStatementText = this.getActivityByResourceStoreProcedure(activityByResourceForHalfYear, reservedStatusThresholdForHalfYear, AVTimeframeType::HalfYear);
                    }
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;

                case activityByPlannedResourceForHour:
                    sqlStatementText = this.getActivityByPlannedResourceStoreProcedure(activityByPlannedResourceForHour, reservedStatusThresholdForHour, AVTimeframeType::Hour);
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case activityByPlannedResourceForDay:
                    sqlStatementText = this.getActivityByPlannedResourceStoreProcedure(activityByPlannedResourceForDay, reservedStatusThresholdForDay, AVTimeframeType::Day);
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case activityByPlannedResourceForWeek:
                    sqlStatementText = this.getActivityByPlannedResourceStoreProcedure(activityByPlannedResourceForWeek, reservedStatusThresholdForWeek, AVTimeframeType::Week);
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case activityByPlannedResourceForMonth:
                    sqlStatementText = this.getActivityByPlannedResourceStoreProcedure(activityByPlannedResourceForMonth, reservedStatusThresholdForMonth, AVTimeframeType::Month);
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case activityByPlannedResourceForQuarter:
                    sqlStatementText = this.getActivityByPlannedResourceStoreProcedure(activityByPlannedResourceForQuarter, reservedStatusThresholdForQuarter, AVTimeframeType::Quarter);
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case activityByPlannedResourceForHalfYear:
                    sqlStatementText = this.getActivityByPlannedResourceStoreProcedure(activityByPlannedResourceForHalfYear, reservedStatusThresholdForHalfYear, AVTimeframeType::HalfYear);
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;

                case assignmentByResourceForHour:
                    if (FeatureStateProvider::isFeatureEnabled(ResResourceAvailabilityChartPerfFlight::instance()))
                    {
                        sqlStatementText = this.getAssignmentByResourceForHourStoreProcedureV2(assignmentByResourceForHour, reservedStatusThresholdForHour);
                    }
                    else
                    {
                        sqlStatementText = this.getAssignmentByResourceForHourStoreProcedure(assignmentByResourceForHour, reservedStatusThresholdForHour);
                    }
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case assignmentByResourceForDay:
                    if (FeatureStateProvider::isFeatureEnabled(ResResourceAvailabilityChartPerfFlight::instance()))
                    {
                        sqlStatementText = this.getAssignmentByResourceStoreProcedureV2(assignmentByResourceForDay, reservedStatusThresholdForDay, AVTimeframeType::Day);
                    }
                    else
                    {
                        sqlStatementText = this.getAssignmentByResourceStoreProcedure(assignmentByResourceForDay, reservedStatusThresholdForDay, AVTimeframeType::Day);
                    }
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case assignmentByResourceForWeek:
                    if (FeatureStateProvider::isFeatureEnabled(ResResourceAvailabilityChartPerfFlight::instance()))
                    {
                        sqlStatementText = this.getAssignmentByResourceStoreProcedureV2(assignmentByResourceForWeek, reservedStatusThresholdForWeek, AVTimeframeType::Week);
                    }
                    else
                    {
                        sqlStatementText = this.getAssignmentByResourceStoreProcedure(assignmentByResourceForWeek, reservedStatusThresholdForWeek, AVTimeframeType::Week);
                    }
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case assignmentByResourceForMonth:
                    if (FeatureStateProvider::isFeatureEnabled(ResResourceAvailabilityChartPerfFlight::instance()))
                    {
                        sqlStatementText = this.getAssignmentByResourceStoreProcedureV2(assignmentByResourceForMonth, reservedStatusThresholdForMonth, AVTimeframeType::Month);
                    }
                    else
                    {
                        sqlStatementText = this.getAssignmentByResourceStoreProcedure(assignmentByResourceForMonth, reservedStatusThresholdForMonth, AVTimeframeType::Month);
                    }
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case assignmentByResourceForQuarter:
                    if (FeatureStateProvider::isFeatureEnabled(ResResourceAvailabilityChartPerfFlight::instance()))
                    {
                        sqlStatementText = this.getAssignmentByResourceStoreProcedureV2(assignmentByResourceForQuarter, reservedStatusThresholdForQuarter, AVTimeframeType::Quarter);
                    }
                    else
                    {
                        sqlStatementText = this.getAssignmentByResourceStoreProcedure(assignmentByResourceForQuarter, reservedStatusThresholdForQuarter, AVTimeframeType::Quarter);
                    }
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case assignmentByResourceForHalfYear:
                    if (FeatureStateProvider::isFeatureEnabled(ResResourceAvailabilityChartPerfFlight::instance()))
                    {
                        sqlStatementText = this.getAssignmentByResourceStoreProcedureV2(assignmentByResourceForHalfYear, reservedStatusThresholdForHalfYear, AVTimeframeType::HalfYear);
                    }
                    else
                    {
                        sqlStatementText = this.getAssignmentByResourceStoreProcedure(assignmentByResourceForHalfYear, reservedStatusThresholdForHalfYear, AVTimeframeType::HalfYear);
                    }
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;

                case assignmentByPlannedResourceForHour:
                    sqlStatementText = this.getAssignmentByPlannedResourceStoreProcedure(assignmentByPlannedResourceForHour, reservedStatusThresholdForHour, AVTimeframeType::Hour);
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case assignmentByPlannedResourceForDay:
                    sqlStatementText = this.getAssignmentByPlannedResourceStoreProcedure(assignmentByPlannedResourceForDay, reservedStatusThresholdForDay, AVTimeframeType::Day);
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case assignmentByPlannedResourceForWeek:
                    sqlStatementText = this.getAssignmentByPlannedResourceStoreProcedure(assignmentByPlannedResourceForWeek, reservedStatusThresholdForWeek, AVTimeframeType::Week);
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case assignmentByPlannedResourceForMonth:
                    sqlStatementText = this.getAssignmentByPlannedResourceStoreProcedure(assignmentByPlannedResourceForMonth, reservedStatusThresholdForMonth, AVTimeframeType::Month);
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case assignmentByPlannedResourceForQuarter:
                    sqlStatementText = this.getAssignmentByPlannedResourceStoreProcedure(assignmentByPlannedResourceForQuarter, reservedStatusThresholdForQuarter, AVTimeframeType::Quarter);
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case assignmentByPlannedResourceForHalfYear:
                    sqlStatementText = this.getAssignmentByPlannedResourceStoreProcedure(assignmentByPlannedResourceForHalfYear, reservedStatusThresholdForHalfYear, AVTimeframeType::HalfYear);
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;

                case deleteResRollupTables:
                    sqlStatementText = this.getDeleteResRollupTablesStoreProcedure(deleteResRollupTables);
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case deleteResProjectResourceTables:
                    sqlStatementText = this.getDeleteResProjectResourceTablesStoreProcedure(deleteResProjectResourceTables);
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
                case deleteResCalendarCapacityTables:
                    sqlStatementText = this.getDeleteResCalendarCapacityTablesStoreProcedure(deleteResCalendarCapacityTables);
                    isSuccessful = this.executeSqlStatement(sqlStatementText);
                    break;
            }
            
        }

        return isSuccessful;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAvailabilityByResourceForHourStoreProcedure</Name>
				<Source><![CDATA[
    private str getAvailabilityByResourceForHourStoreProcedure(str _storeProcedureName, str _reservedStatusThreshold)
    {
        str sqlStatementText = @"
            CREATE PROCEDURE %1
                @partition AS BIGINT, @resource AS BIGINT, @starDateTime AS DateTime,
                @hardReservedHours VARCHAR(10) OUTPUT, @availableHours VARCHAR(10) OUTPUT, @status INT OUTPUT, @hasSoftHours INT OUTPUT
            AS
            BEGIN

            SET NOCOUNT ON;

            SELECT
            @hardReservedHours = Convert(varchar(10), T4.HardReservedHours),
            @availableHours = Convert(varchar(10), CASE WHEN T4.Status = 1 AND ABS(T4.AvailableHours) < %2 THEN 0 ELSE T4.AvailableHours END),
            @status = CASE WHEN T4.Status = 1 AND abs(T4.AvailableHours) < %2 THEN 2 ELSE T4.Status END,
            @hasSoftHours = T4.HasSoftHours
            from (
                select
                Convert (Decimal(10,%3),
                    CASE
                        WHEN T2.HardReservedHours is NULL THEN 0
                        ELSE T2.HardReservedHours
                    END) as HardReservedHours,
                Convert (Decimal(10,%3),
                    CASE
                        WHEN T2.HardReservedHours is NULL AND T1.CapacityHours is NULL THEN 0
                        WHEN T2.HardReservedHours is NULL THEN T1.CapacityHours
                        ELSE T1.CapacityHours - T2.HardReservedHours
                    END) as AvailableHours,
                CASE
                    WHEN T2.HardReservedHours is NULL AND T1.CapacityHours is NULL THEN 4
                    WHEN T2.HardReservedHours is NULL AND T1.CapacityHours = 0 THEN 4
                    WHEN T2.HardReservedHours is NULL THEN 0
                    WHEN abs(T2.HardReservedHours - T1.CapacityHours) < %2 THEN 2
                    WHEN T2.HardReservedHours < T1.CapacityHours THEN 1
                    WHEN T2.HardReservedHours > T1.CapacityHours THEN 5
                    ELSE 4
                END as Status,
                CASE
                    WHEN T3.SoftReservedHours is NOT NULL THEN 1
                    ELSE 0
                END as HasSoftHours
                from (
                    select JT1.Partition, JT1.Hour,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as CapacityHours from ResCalendarCapacity JT1
                    join ResCalendarDateTimeRange JT2 on JT2.Partition = JT1.Partition and JT2.Calendar = JT1.Calendar
                        and JT2.VALIDFROMDATETIME < JT1.Hour and JT2.ValidToDateTime > JT1.Hour
                        where JT1.Partition = @partition and JT1.Hour = @starDateTime and JT2.Resource_ = @resource
                    group by JT1.Partition, JT1.Hour) as T1
                left join (
                    select JT1.Partition, JT2.Resource_, JT1.Hour,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as HardReservedHours from ResBooking JT1
                    join PSAProjSchedRole JT2 on JT2.RecId = JT1.ActivityResource and JT2.Partition = JT1.Partition
                        where JT1.Partition = @partition and JT1.CommitType = 1 and JT1.Hour = @starDateTime and JT2.Resource_ = @resource
                    group by JT1.Partition, JT1.Hour, JT2.Resource_) as T2
                on T2.Partition = T1.Partition and T2.Hour = T1.Hour
                left join (
                    select JT1.Partition, JT2.Resource_, JT1.Hour,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as SoftReservedHours from ResBooking JT1
                    join PSAProjSchedRole JT2 on JT2.RecId = JT1.ActivityResource and JT2.Partition = JT1.Partition
                        where JT1.Partition = @partition and JT1.CommitType = 2 and JT1.Hour = @starDateTime and JT2.Resource_ = @resource
                    group by JT1.Partition, JT1.Hour, JT2.Resource_) as T3
                on T3.Partition = T1.Partition and T3.Hour = T1.Hour
                group by T1.Partition, T1.Hour, T1.CapacityHours, T2.Partition,
                    T2.Resource_, T2.HardReservedHours, T3.SoftReservedHours) AS T4
            END ";

        sqlStatementText = strFmt(sqlStatementText, _storeProcedureName, _reservedStatusThreshold, roundingDecimalPrecision);
            
        return sqlStatementText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAvailabilityByResourceForHourStoreProcedureV2</Name>
				<Source><![CDATA[
    private str getAvailabilityByResourceForHourStoreProcedureV2(str _storeProcedureName, str _reservedStatusThreshold)
    {
        str sqlStatementText = @"
            CREATE PROCEDURE %1
                @partition AS BIGINT, @resource AS BIGINT, @starDateTime AS DateTime,
                @hardReservedHours VARCHAR(10) OUTPUT, @availableHours VARCHAR(10) OUTPUT, @status INT OUTPUT, @hasSoftHours INT OUTPUT
            AS
            BEGIN

            SET NOCOUNT ON;

            declare @calendar AS BIGINT
            declare @validDateTime AS DateTime
            declare @invalidDateTime AS DateTime set @invalidDateTime = '1900-01-01 00:00:00.000'
            
            SELECT @calendar = Calendar,
            @validDateTime =
            CASE
                WHEN validFromDateTime <= @starDateTime and validToDateTime >= @starDateTime THEN @starDateTime
                ELSE @invalidDateTime
            END
            from ResCalendarDateTimeRange
            where Partition = @partition and Resource_ = @resource;

            SELECT
            @hardReservedHours = Convert(varchar(10), T4.HardReservedHours),
            @availableHours = Convert(varchar(10), CASE WHEN T4.Status = 1 AND ABS(T4.AvailableHours) < %2 THEN 0 ELSE T4.AvailableHours END),
            @status = CASE WHEN T4.Status = 1 AND abs(T4.AvailableHours) < %2 THEN 2 ELSE T4.Status END,
            @hasSoftHours = T4.HasSoftHours
            from (
                select
                Convert (Decimal(10,%3),
                    CASE
                        WHEN T2.HardReservedHours is NULL THEN 0
                        ELSE T2.HardReservedHours
                    END) as HardReservedHours,
                Convert (Decimal(10,%3),
                    CASE
                        WHEN T2.HardReservedHours is NULL AND T1.CapacityHours is NULL THEN 0
                        WHEN T2.HardReservedHours is NULL THEN T1.CapacityHours
                        ELSE T1.CapacityHours - T2.HardReservedHours
                    END) as AvailableHours,
                CASE
                    WHEN T2.HardReservedHours is NULL AND T1.CapacityHours is NULL THEN 4
                    WHEN T2.HardReservedHours is NULL AND T1.CapacityHours = 0 THEN 4
                    WHEN T2.HardReservedHours is NULL THEN 0
                    WHEN abs(T2.HardReservedHours - T1.CapacityHours) < %2 THEN 2
                    WHEN T2.HardReservedHours < T1.CapacityHours THEN 1
                    WHEN T2.HardReservedHours > T1.CapacityHours THEN 5
                    ELSE 4
                END as Status,
                CASE
                    WHEN T3.SoftReservedHours is NOT NULL THEN 1
                    ELSE 0
                END as HasSoftHours
                from (
                    select JT1.Partition, JT1.Hour,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as CapacityHours from ResCalendarCapacity JT1
                        where JT1.Partition = @partition and JT1.Hour = @validDateTime and JT1.Calendar = @calendar
                    group by JT1.Partition, JT1.Hour) as T1
                left join (
                    select JT1.Partition, JT2.Resource_, JT1.Hour,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as HardReservedHours from ResBooking JT1
                    join PSAProjSchedRole JT2 on JT2.RecId = JT1.ActivityResource and JT2.Partition = JT1.Partition
                        where JT1.Partition = @partition and JT1.CommitType = 1 and JT1.Hour = @starDateTime and JT2.Resource_ = @resource
                    group by JT1.Partition, JT1.Hour, JT2.Resource_) as T2
                on T2.Partition = T1.Partition and T2.Hour = T1.Hour
                left join (
                    select JT1.Partition, JT2.Resource_, JT1.Hour,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as SoftReservedHours from ResBooking JT1
                    join PSAProjSchedRole JT2 on JT2.RecId = JT1.ActivityResource and JT2.Partition = JT1.Partition
                        where JT1.Partition = @partition and JT1.CommitType = 2 and JT1.Hour = @starDateTime and JT2.Resource_ = @resource
                    group by JT1.Partition, JT1.Hour, JT2.Resource_) as T3
                on T3.Partition = T1.Partition and T3.Hour = T1.Hour
                group by T1.Partition, T1.Hour, T1.CapacityHours, T2.Partition,
                    T2.Resource_, T2.HardReservedHours, T3.SoftReservedHours) AS T4
            END ";

        sqlStatementText = strFmt(sqlStatementText, _storeProcedureName, _reservedStatusThreshold, roundingDecimalPrecision);
            
        return sqlStatementText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAvailabilityByResourceStoreProcedure</Name>
				<Source><![CDATA[
    private str getAvailabilityByResourceStoreProcedure(str _storeProcedureName, str _reservedStatusThreshold, AVTimeframeType _timescale)
    {
        str sqlStatementText = @"
            CREATE PROCEDURE %1
                  @partition AS BIGINT, @resource AS BIGINT, @starDateTime AS DateTime, @endDateTime AS DateTime,
                  @hardReservedHours VARCHAR(10) OUTPUT, @availableHours VARCHAR(10) OUTPUT, @status INT OUTPUT, @hasSoftHours INT OUTPUT
            AS
            BEGIN

            SET NOCOUNT ON;

            SELECT
            @hardReservedHours = Convert(varchar(10), T4.HardReservedHours),
            @availableHours = Convert(varchar(10), CASE WHEN T4.Status = 1 AND ABS(T4.AvailableHours) < %2 THEN 0 ELSE T4.AvailableHours END),
            @status = CASE WHEN T4.Status = 1 AND abs(T4.AvailableHours) < %2 THEN 2 ELSE T4.Status END,
            @hasSoftHours = T4.HasSoftHours
            from (
                select
                    Convert (Decimal(10,%3),
                    CASE
                        WHEN T2.HardReservedHours is NULL THEN 0
                        ELSE T2.HardReservedHours
                    END) as HardReservedHours,
                    Convert (Decimal(10,%3),
                    CASE
                        WHEN T2.HardReservedHours is NULL AND T1.CapacityHours is NULL THEN 0
                        WHEN T2.HardReservedHours is NULL THEN T1.CapacityHours
                        ELSE T1.CapacityHours - T2.HardReservedHours
                    END) as AvailableHours,
                    CASE
                        WHEN T2.HardReservedHours is NULL AND T1.CapacityHours is NULL THEN 4
                        WHEN T2.HardReservedHours is NULL AND T1.CapacityHours = 0 THEN 4
                        WHEN T2.HardReservedHours is NULL THEN 0
                        WHEN abs(T2.HardReservedHours - T1.CapacityHours) < %2 THEN 2
                        WHEN T2.HardReservedHours < T1.CapacityHours THEN 1
                        WHEN T2.HardReservedHours > T1.CapacityHours THEN 5
                        ELSE 4
                    END as Status,
                    CASE
                        WHEN T3.SoftReservedHours is NOT NULL THEN 1
                        ELSE 0
                    END as HasSoftHours
                from (
                    select JT1.Partition, JT1.%4,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as CapacityHours from ResCalendarCapacity JT1
                    join ResCalendarDateTimeRange JT2 on JT2.Partition = JT1.Partition and JT2.Calendar = JT1.Calendar
                        and JT2.ValidFromDateTime < JT1.Hour and JT2.ValidToDateTime > JT1.Hour
                        where JT1.Partition = @partition and JT1.Hour >= @starDateTime and JT1.Hour <= @endDateTime and JT2.Resource_ = @resource
                    group by JT1.Partition, JT1.%4) as T1
                left join (
                    select JT1.Partition, JT2.Resource_, JT1.%4,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as HardReservedHours from ResBooking JT1
                    join PSAProjSchedRole JT2 on JT2.RecId = JT1.ActivityResource and JT2.Partition = JT1.Partition
                        where JT1.Partition = @partition and JT1.CommitType = 1 and JT1.%4 = @starDateTime and JT2.Resource_ = @resource
                    group by JT1.Partition, JT1.%4, JT2.Resource_) as T2
                on T2.Partition = T1.Partition and T2.%4 = T1.%4
                left join (
                    select JT1.Partition, JT2.Resource_, JT1.%4,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as SoftReservedHours from ResBooking JT1
                    join PSAProjSchedRole JT2 on JT2.RecId = JT1.ActivityResource and JT2.Partition = JT1.Partition
                        where JT1.Partition = @partition and JT1.CommitType = 2 and JT1.%4 = @starDateTime and JT2.Resource_ = @resource
                    group by JT1.Partition, JT1.%4, JT2.Resource_) as T3
                on T3.Partition = T1.Partition and T3.%4 = T1.%4
                group by T1.Partition, T1.%4, T1.CapacityHours, T2.Partition,
                    T2.Resource_, T2.HardReservedHours, T3.SoftReservedHours) AS T4
            END ";
            
        sqlStatementText = strFmt(sqlStatementText, _storeProcedureName, _reservedStatusThreshold, roundingDecimalPrecision, enum2Symbol(enumNum(AVTimeframeType), _timescale));
            
        return sqlStatementText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAvailabilityByResourceStoreProcedureV2</Name>
				<Source><![CDATA[
    private str getAvailabilityByResourceStoreProcedureV2(str _storeProcedureName, str _reservedStatusThreshold, AVTimeframeType _timescale)
    {
        str sqlStatementText = @"
            CREATE PROCEDURE %1
                  @partition AS BIGINT, @resource AS BIGINT, @starDateTime AS DateTime, @endDateTime AS DateTime,
                  @hardReservedHours VARCHAR(10) OUTPUT, @availableHours VARCHAR(10) OUTPUT, @status INT OUTPUT, @hasSoftHours INT OUTPUT
            AS
            BEGIN

            SET NOCOUNT ON;

            declare @calendar AS BIGINT
            declare @validFromDateTime AS DateTime
            declare @validToDateTime AS DateTime
            declare @invalidDateTime AS DateTime set @invalidDateTime = '1900-01-01 00:00:00.000'
            
            SELECT @calendar = Calendar,
            @validFromDateTime =
            CASE
                WHEN validToDateTime < @starDateTime or validFromDateTime > @endDateTime THEN @invalidDateTime
                WHEN validFromDateTime <= @starDateTime THEN @starDateTime
            ELSE validFromDateTime
            END,
            @validToDateTime =
            CASE
                WHEN validToDateTime < @starDateTime or validFromDateTime > @endDateTime THEN @invalidDateTime
                WHEN @endDateTime <= validToDateTime THEN @endDateTime
            ELSE validToDateTime
            END
            from ResCalendarDateTimeRange
            where Partition = @partition and Resource_ = @resource;

            SELECT
            @hardReservedHours = Convert(varchar(10), T4.HardReservedHours),
            @availableHours = Convert(varchar(10), CASE WHEN T4.Status = 1 AND ABS(T4.AvailableHours) < %2 THEN 0 ELSE T4.AvailableHours END),
            @status = CASE WHEN T4.Status = 1 AND abs(T4.AvailableHours) < %2 THEN 2 ELSE T4.Status END,
            @hasSoftHours = T4.HasSoftHours
            from (
                select
                    Convert (Decimal(10,%3),
                    CASE
                        WHEN T2.HardReservedHours is NULL THEN 0
                        ELSE T2.HardReservedHours
                    END) as HardReservedHours,
                    Convert (Decimal(10,%3),
                    CASE
                        WHEN T2.HardReservedHours is NULL AND T1.CapacityHours is NULL THEN 0
                        WHEN T2.HardReservedHours is NULL THEN T1.CapacityHours
                        ELSE T1.CapacityHours - T2.HardReservedHours
                    END) as AvailableHours,
                    CASE
                        WHEN T2.HardReservedHours is NULL AND T1.CapacityHours is NULL THEN 4
                        WHEN T2.HardReservedHours is NULL AND T1.CapacityHours = 0 THEN 4
                        WHEN T2.HardReservedHours is NULL THEN 0
                        WHEN abs(T2.HardReservedHours - T1.CapacityHours) < %2 THEN 2
                        WHEN T2.HardReservedHours < T1.CapacityHours THEN 1
                        WHEN T2.HardReservedHours > T1.CapacityHours THEN 5
                        ELSE 4
                    END as Status,
                    CASE
                        WHEN T3.SoftReservedHours is NOT NULL THEN 1
                        ELSE 0
                    END as HasSoftHours
                from (
                    select JT1.Partition, JT1.%4,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as CapacityHours from ResCalendarCapacity JT1
                        where JT1.Partition = @partition and JT1.Hour >= @validFromDateTime and JT1.Hour <= @validToDateTime and JT1.Calendar = @calendar
                    group by JT1.Partition, JT1.%4) as T1
                left join (
                    select JT1.Partition, JT2.Resource_, JT1.%4,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as HardReservedHours from ResBooking JT1
                    join PSAProjSchedRole JT2 on JT2.RecId = JT1.ActivityResource and JT2.Partition = JT1.Partition
                        where JT1.Partition = @partition and JT1.CommitType = 1 and JT1.%4 = @starDateTime and JT2.Resource_ = @resource
                    group by JT1.Partition, JT1.%4, JT2.Resource_) as T2
                on T2.Partition = T1.Partition and T2.%4 = T1.%4
                left join (
                    select JT1.Partition, JT2.Resource_, JT1.%4,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as SoftReservedHours from ResBooking JT1
                    join PSAProjSchedRole JT2 on JT2.RecId = JT1.ActivityResource and JT2.Partition = JT1.Partition
                        where JT1.Partition = @partition and JT1.CommitType = 2 and JT1.%4 = @starDateTime and JT2.Resource_ = @resource
                    group by JT1.Partition, JT1.%4, JT2.Resource_) as T3
                on T3.Partition = T1.Partition and T3.%4 = T1.%4
                group by T1.Partition, T1.%4, T1.CapacityHours, T2.Partition,
                    T2.Resource_, T2.HardReservedHours, T3.SoftReservedHours) AS T4
            END ";
            
        sqlStatementText = strFmt(sqlStatementText, _storeProcedureName, _reservedStatusThreshold, roundingDecimalPrecision, enum2Symbol(enumNum(AVTimeframeType), _timescale));
            
        return sqlStatementText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivityByResourceForHourStoreProcedure</Name>
				<Source><![CDATA[
    private str getActivityByResourceForHourStoreProcedure(str _storeProcedureName, str _reservedStatusThreshold)
    {
        str sqlStatementText = @"
            CREATE PROCEDURE %1
                @partition AS BIGINT, @resource AS BIGINT, @activityResource AS BIGINT, @starDateTime AS DateTime,
                @hardReservedHours VARCHAR(10) OUTPUT, @availableHours VARCHAR(10) OUTPUT, @status INT OUTPUT, @hasSoftHours INT OUTPUT
            AS
            BEGIN

            SET NOCOUNT ON;

            SELECT
            @hardReservedHours = Convert(varchar(10), T4.HardReservedHours),
            @availableHours = Convert(varchar(10), CASE WHEN T4.Status = 1 AND ABS(T4.AvailableHours) < %2 THEN 0 ELSE T4.AvailableHours END),
            @status = CASE WHEN T4.Status = 1 AND abs(T4.AvailableHours) < %2 THEN 2 ELSE T4.Status END,
            @hasSoftHours = T4.HasSoftHours
            from (
                select
                    Convert (Decimal(10,%3),
                    CASE
                        WHEN T2.HardReservationHours is NULL THEN 0
                        ELSE T2.HardReservationHours
                    END) as HardReservedHours,
                    Convert (Decimal(10,%3),
                    CASE
                        WHEN T2.HardReservationHours is NULL AND T1.CapacityHours is NULL THEN 0
                        WHEN T2.HardReservationHours is NULL THEN T1.CapacityHours
                        ELSE T1.CapacityHours - T2.HardReservationHours
                    END) as AvailableHours,
                    CASE
                        WHEN T2.HardReservationHours is NULL AND T1.CapacityHours is NULL THEN 4
                        WHEN T2.HardReservationHours is NULL AND T1.CapacityHours = 0 THEN 4
                        WHEN T2.HardReservationHours is NULL THEN 0
                        WHEN abs(T2.HardReservationHours - T1.CapacityHours) < %2 THEN 2
                        WHEN T2.HardReservationHours < T1.CapacityHours THEN 1
                        WHEN T2.HardReservationHours > T1.CapacityHours THEN 5
                        ELSE 4
                    END as Status,
                    CASE
                        WHEN T3.SoftReservationHours is NOT NULL THEN 1
                        ELSE 0
                    END as HasSoftHours
                from (
                    select JT1.Partition, JT1.Hour,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as CapacityHours from ResCalendarCapacity JT1
                    join ResCalendarDateTimeRange JT2 on JT2.Partition = JT1.Partition and JT2.Calendar = JT1.Calendar
                        and JT2.VALIDFROMDATETIME < JT1.Hour and JT2.ValidToDateTime > JT1.Hour
                        where JT1.Partition = @partition and JT1.Hour = @starDateTime and JT2.Resource_ = @resource
                    group by JT1.Partition, JT1.Hour) as T1
                left join (
                    select JT1.Partition, JT1.Hour,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as HardReservationHours from ResBooking JT1
                        where JT1.Partition = @partition and JT1.CommitType = 1 and JT1.Hour = @starDateTime and JT1.ActivityResource = @activityResource
                    group by JT1.Partition, JT1.Hour) as T2
                on T2.Partition = T1.Partition and T2.Hour = T1.Hour
                left join (
                    select JT1.Partition, JT1.Hour,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as SoftReservationHours from ResBooking JT1
                        where JT1.Partition = @partition and JT1.CommitType = 2 and JT1.Hour = @starDateTime and JT1.ActivityResource = @activityResource
                    group by JT1.Partition, JT1.Hour) as T3
                on T3.Partition = T1.Partition and T3.Hour = T1.Hour
                group by T1.Partition, T1.Hour, T1.CapacityHours, T2.Partition, T2.HardReservationHours, T3.SoftReservationHours ) AS T4
            END ";
            
        sqlStatementText = strFmt(sqlStatementText, _storeProcedureName, _reservedStatusThreshold, roundingDecimalPrecision);

        return sqlStatementText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivityByResourceForHourStoreProcedureV2</Name>
				<Source><![CDATA[
    private str getActivityByResourceForHourStoreProcedureV2(str _storeProcedureName, str _reservedStatusThreshold)
    {
        str sqlStatementText = @"
            CREATE PROCEDURE %1
                @partition AS BIGINT, @resource AS BIGINT, @activityResource AS BIGINT, @starDateTime AS DateTime,
                @hardReservedHours VARCHAR(10) OUTPUT, @availableHours VARCHAR(10) OUTPUT, @status INT OUTPUT, @hasSoftHours INT OUTPUT
            AS
            BEGIN

            SET NOCOUNT ON;

            declare @calendar AS BIGINT
            declare @validDateTime AS DateTime
            declare @invalidDateTime AS DateTime set @invalidDateTime = '1900-01-01 00:00:00.000'
            
            SELECT @calendar = Calendar,
            @validDateTime =
            CASE
                WHEN validFromDateTime <= @starDateTime and validToDateTime >= @starDateTime THEN @starDateTime
                ELSE @invalidDateTime
            END
            from ResCalendarDateTimeRange
            where Partition = @partition and Resource_ = @resource;

            SELECT
            @hardReservedHours = Convert(varchar(10), T4.HardReservedHours),
            @availableHours = Convert(varchar(10), CASE WHEN T4.Status = 1 AND ABS(T4.AvailableHours) < %2 THEN 0 ELSE T4.AvailableHours END),
            @status = CASE WHEN T4.Status = 1 AND abs(T4.AvailableHours) < %2 THEN 2 ELSE T4.Status END,
            @hasSoftHours = T4.HasSoftHours
            from (
                select
                    Convert (Decimal(10,%3),
                    CASE
                        WHEN T2.HardReservationHours is NULL THEN 0
                        ELSE T2.HardReservationHours
                    END) as HardReservedHours,
                    Convert (Decimal(10,%3),
                    CASE
                        WHEN T2.HardReservationHours is NULL AND T1.CapacityHours is NULL THEN 0
                        WHEN T2.HardReservationHours is NULL THEN T1.CapacityHours
                        ELSE T1.CapacityHours - T2.HardReservationHours
                    END) as AvailableHours,
                    CASE
                        WHEN T2.HardReservationHours is NULL AND T1.CapacityHours is NULL THEN 4
                        WHEN T2.HardReservationHours is NULL AND T1.CapacityHours = 0 THEN 4
                        WHEN T2.HardReservationHours is NULL THEN 0
                        WHEN abs(T2.HardReservationHours - T1.CapacityHours) < %2 THEN 2
                        WHEN T2.HardReservationHours < T1.CapacityHours THEN 1
                        WHEN T2.HardReservationHours > T1.CapacityHours THEN 5
                        ELSE 4
                    END as Status,
                    CASE
                        WHEN T3.SoftReservationHours is NOT NULL THEN 1
                        ELSE 0
                    END as HasSoftHours
                from (
                    select JT1.Partition, JT1.Hour,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as CapacityHours from ResCalendarCapacity JT1
                        where JT1.Partition = @partition and JT1.Hour = @validDateTime and JT1.Calendar = @calendar
                    group by JT1.Partition, JT1.Hour) as T1
                left join (
                    select JT1.Partition, JT1.Hour, 
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as HardReservationHours from ResBooking JT1
                        where JT1.Partition = @partition and JT1.CommitType = 1 and JT1.Hour = @starDateTime and JT1.ActivityResource = @activityResource
                    group by JT1.Partition, JT1.Hour) as T2
                on T2.Partition = T1.Partition and T2.Hour = T1.Hour
                left join (
                    select JT1.Partition, JT1.Hour, 
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as SoftReservationHours from ResBooking JT1
                        where JT1.Partition = @partition and JT1.CommitType = 2 and JT1.Hour = @starDateTime and JT1.ActivityResource = @activityResource
                    group by JT1.Partition, JT1.Hour) as T3
                on T3.Partition = T1.Partition and T3.Hour = T1.Hour
                group by T1.Partition, T1.Hour, T1.CapacityHours, T2.Partition, T2.HardReservationHours, T3.SoftReservationHours ) AS T4
            END ";
            
        sqlStatementText = strFmt(sqlStatementText, _storeProcedureName, _reservedStatusThreshold, roundingDecimalPrecision);

        return sqlStatementText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivityByResourceStoreProcedure</Name>
				<Source><![CDATA[
    private str getActivityByResourceStoreProcedure(str _storeProcedureName, str _reservedStatusThreshold, AVTimeframeType _timescale)
    {
        str sqlStatementText = @"
            CREATE PROCEDURE %1
                @partition AS BIGINT, @resource AS BIGINT, @activityResource AS BIGINT, @starDateTime AS DateTime, @endDateTime AS DateTime,
                @hardReservedHours VARCHAR(10) OUTPUT, @availableHours VARCHAR(10) OUTPUT, @status INT OUTPUT, @hasSoftHours INT OUTPUT
            AS
            BEGIN

            SET NOCOUNT ON;

            SELECT
            @hardReservedHours = Convert(varchar(10), T4.HardReservedHours),
            @availableHours = Convert(varchar(10), CASE WHEN T4.Status = 1 AND ABS(T4.AvailableHours) < %2 THEN 0 ELSE T4.AvailableHours END),
            @status = CASE WHEN T4.Status = 1 AND abs(T4.AvailableHours) < %2 THEN 2 ELSE T4.Status END,
            @hasSoftHours = T4.HasSoftHours
            from (
                select
                    Convert (Decimal(10,%3),
                    CASE
                        WHEN T2.HardReservationHours is NULL THEN 0
                        ELSE T2.HardReservationHours
                    END) as HardReservedHours,
                    Convert (Decimal(10,%3),
                        CASE
                            WHEN T2.HardReservationHours is NULL AND T1.CapacityHours is NULL THEN 0
                            WHEN T2.HardReservationHours is NULL THEN T1.CapacityHours
                            ELSE T1.CapacityHours - T2.HardReservationHours
                        END) as AvailableHours,
                    CASE
                        WHEN T2.HardReservationHours is NULL AND T1.CapacityHours is NULL THEN 4
                        WHEN T2.HardReservationHours is NULL AND T1.CapacityHours = 0 THEN 4
                        WHEN T2.HardReservationHours is NULL THEN 0
                        WHEN abs(T2.HardReservationHours - T1.CapacityHours) < %2 THEN 2
                        WHEN T2.HardReservationHours < T1.CapacityHours THEN 1
                        WHEN T2.HardReservationHours > T1.CapacityHours THEN 5
                        ELSE 4
                    END as Status,
                    CASE
                        WHEN T3.SoftReservationHours is NOT NULL THEN 1
                        ELSE 0
                    END as HasSoftHours
                from (
                    select JT1.Partition, JT1.%4,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as CapacityHours from ResCalendarCapacity JT1
                    join ResCalendarDateTimeRange JT2 on JT2.Partition = JT1.Partition and JT2.Calendar = JT1.Calendar
                        and JT2.ValidFromDateTime < JT1.Hour and JT2.ValidToDateTime > JT1.Hour
                        where JT1.Partition = @partition and JT1.Hour >= @starDateTime and JT1.Hour <= @endDateTime and JT2.Resource_ = @resource
                     group by JT1.Partition, JT1.%4) as T1
                left join (
                    select JT1.Partition, JT1.%4,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as HardReservationHours from ResBooking JT1
                        where JT1.Partition = @partition and JT1.CommitType = 1 and JT1.%4 = @starDateTime and JT1.ActivityResource = @activityResource
                    group by JT1.Partition, JT1.%4) as T2
                on T2.Partition = T1.Partition and T2.%4 = T1.%4
                left join (
                    select JT1.Partition, JT1.%4,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as SoftReservationHours from ResBooking JT1
                        where JT1.Partition = @partition and JT1.CommitType = 2 and JT1.%4 = @starDateTime and JT1.ActivityResource = @activityResource
                    group by JT1.Partition, JT1.%4) as T3
                on T3.Partition = T1.Partition and T3.%4 = T1.%4
                group by T1.Partition, T1.%4, T1.CapacityHours, T2.Partition, T2.HardReservationHours, T3.SoftReservationHours ) AS T4
            END ";

        sqlStatementText = strFmt(sqlStatementText, _storeProcedureName, _reservedStatusThreshold, roundingDecimalPrecision, enum2Symbol(enumNum(AVTimeframeType), _timescale));

        return sqlStatementText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivityByResourceStoreProcedureV2</Name>
				<Source><![CDATA[
    private str getActivityByResourceStoreProcedureV2(str _storeProcedureName, str _reservedStatusThreshold, AVTimeframeType _timescale)
    {
        str sqlStatementText = @"
            CREATE PROCEDURE %1
                @partition AS BIGINT, @resource AS BIGINT, @activityResource AS BIGINT, @starDateTime AS DateTime, @endDateTime AS DateTime,
                @hardReservedHours VARCHAR(10) OUTPUT, @availableHours VARCHAR(10) OUTPUT, @status INT OUTPUT, @hasSoftHours INT OUTPUT
            AS
            BEGIN

            SET NOCOUNT ON;

            declare @calendar AS BIGINT
            declare @validFromDateTime AS DateTime
            declare @validToDateTime AS DateTime
            declare @invalidDateTime AS DateTime set @invalidDateTime = '1900-01-01 00:00:00.000'
            
            SELECT @calendar = Calendar,
            @validFromDateTime =
            CASE
                WHEN validToDateTime < @starDateTime or validFromDateTime > @endDateTime THEN @invalidDateTime
                WHEN validFromDateTime <= @starDateTime THEN @starDateTime
            ELSE validFromDateTime
            END,
            @validToDateTime =
            CASE
                WHEN validToDateTime < @starDateTime or validFromDateTime > @endDateTime THEN @invalidDateTime
                WHEN @endDateTime <= validToDateTime THEN @endDateTime
            ELSE validToDateTime
            END
            from ResCalendarDateTimeRange
            where Partition = @partition and Resource_ = @resource;

            SELECT
            @hardReservedHours = Convert(varchar(10), T4.HardReservedHours),
            @availableHours = Convert(varchar(10), CASE WHEN T4.Status = 1 AND ABS(T4.AvailableHours) < %2 THEN 0 ELSE T4.AvailableHours END),
            @status = CASE WHEN T4.Status = 1 AND abs(T4.AvailableHours) < %2 THEN 2 ELSE T4.Status END,
            @hasSoftHours = T4.HasSoftHours
            from (
                select
                    Convert (Decimal(10,%3),
                    CASE
                        WHEN T2.HardReservationHours is NULL THEN 0
                        ELSE T2.HardReservationHours
                    END) as HardReservedHours,
                    Convert (Decimal(10,%3),
                        CASE
                            WHEN T2.HardReservationHours is NULL AND T1.CapacityHours is NULL THEN 0
                            WHEN T2.HardReservationHours is NULL THEN T1.CapacityHours
                            ELSE T1.CapacityHours - T2.HardReservationHours
                        END) as AvailableHours,
                    CASE
                        WHEN T2.HardReservationHours is NULL AND T1.CapacityHours is NULL THEN 4
                        WHEN T2.HardReservationHours is NULL AND T1.CapacityHours = 0 THEN 4
                        WHEN T2.HardReservationHours is NULL THEN 0
                        WHEN abs(T2.HardReservationHours - T1.CapacityHours) < %2 THEN 2
                        WHEN T2.HardReservationHours < T1.CapacityHours THEN 1
                        WHEN T2.HardReservationHours > T1.CapacityHours THEN 5
                        ELSE 4
                    END as Status,
                    CASE
                        WHEN T3.SoftReservationHours is NOT NULL THEN 1
                        ELSE 0
                    END as HasSoftHours
                from (
                    select JT1.Partition, JT1.%4,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as CapacityHours from ResCalendarCapacity JT1
                        where JT1.Partition = @partition and JT1.Hour >= @validFromDateTime and JT1.Hour <= @validToDateTime and JT1.Calendar = @calendar
                    group by JT1.Partition, JT1.%4) as T1
                left join (
                    select JT1.Partition, JT1.%4, 
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as HardReservationHours from ResBooking JT1
                        where JT1.Partition = @partition and JT1.CommitType = 1 and JT1.%4 = @starDateTime and JT1.ActivityResource = @activityResource
                    group by JT1.Partition, JT1.%4) as T2
                on T2.Partition = T1.Partition and T2.%4 = T1.%4
                left join (
                    select JT1.Partition, JT1.%4, 
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as SoftReservationHours from ResBooking JT1
                        where JT1.Partition = @partition and JT1.CommitType = 2 and JT1.%4 = @starDateTime and JT1.ActivityResource = @activityResource
                    group by JT1.Partition, JT1.%4) as T3
                on T3.Partition = T1.Partition and T3.%4 = T1.%4
                group by T1.Partition, T1.%4, T1.CapacityHours, T2.Partition, T2.HardReservationHours, T3.SoftReservationHours ) AS T4
            END ";

        sqlStatementText = strFmt(sqlStatementText, _storeProcedureName, _reservedStatusThreshold, roundingDecimalPrecision, enum2Symbol(enumNum(AVTimeframeType), _timescale));

        return sqlStatementText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivityByPlannedResourceStoreProcedure</Name>
				<Source><![CDATA[
    private str getActivityByPlannedResourceStoreProcedure(str _storeProcedureName, str _reservedStatusThreshold, AVTimeframeType _timescale)
    {
        str sqlStatementText = @"
            CREATE PROCEDURE %1
                @partition AS BIGINT, @calendar AS BIGINT, @activityResource AS BIGINT, @starDateTime AS DateTime,
                @hardReservedHours VARCHAR(10) OUTPUT, @availableHours VARCHAR(10) OUTPUT, @status INT OUTPUT, @hasSoftHours INT OUTPUT
            AS
            BEGIN

            SET NOCOUNT ON;

            SELECT
            @hardReservedHours = Convert(varchar(10), T4.HardReservedHours),
            @availableHours = Convert(varchar(10), CASE WHEN T4.Status = 1 AND ABS(T4.AvailableHours) < %2  THEN 0 ELSE T4.AvailableHours END),
            @status = CASE WHEN T4.Status = 1 AND abs(T4.AvailableHours) < %2 THEN 2 ELSE T4.Status END,
            @hasSoftHours = T4.HasSoftHours
            from (
                select
                    Convert (Decimal(10,%3),
                    CASE
                        WHEN T2.HardReservationHours is NULL THEN 0
                        ELSE T2.HardReservationHours
                    END) as HardReservedHours,
                    Convert (Decimal(10,%3),
                        CASE
                            WHEN T2.HardReservationHours is NULL AND T1.CapacityHours is NULL THEN 0
                            WHEN T2.HardReservationHours is NULL THEN T1.CapacityHours
                            ELSE T1.CapacityHours - T2.HardReservationHours
                        END) as AvailableHours,
                    CASE
                        WHEN T2.HardReservationHours is NULL AND T1.CapacityHours is NULL THEN 4
                        WHEN T2.HardReservationHours is NULL AND T1.CapacityHours = 0 THEN 4
                        WHEN T2.HardReservationHours is NULL THEN 0
                        WHEN abs(T2.HardReservationHours - T1.CapacityHours) < %2 THEN 2
                        WHEN T2.HardReservationHours < T1.CapacityHours THEN 1
                        WHEN T2.HardReservationHours > T1.CapacityHours THEN 5
                        ELSE 4
                    END as Status,
                    CASE
                        WHEN T3.SoftReservationHours is NOT NULL THEN 1
                        ELSE 0
                    END as HasSoftHours
                from (
                    select JT1.Partition, JT1.%4, 
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as CapacityHours from ResCalendarCapacity JT1
                        where JT1.Partition = @partition and JT1.Calendar = @calendar and JT1.%4 = @starDateTime
                    group by JT1.Partition, JT1.%4) as T1
                left join (
                    select JT1.Partition, JT1.%4, 
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as HardReservationHours from ResBooking JT1
                        where JT1.Partition = @partition and JT1.CommitType = 1 and JT1.%4 = @starDateTime and JT1.ActivityResource = @activityResource
                    group by JT1.Partition, JT1.%4) as T2
                on T2.Partition = T1.Partition and T2.%4 = T1.%4
                left join (
                    select JT1.Partition, JT1.%4, 
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as SoftReservationHours from ResBooking JT1
                        where JT1.Partition = @partition and JT1.CommitType = 2 and JT1.%4 = @starDateTime and JT1.ActivityResource = @activityResource
                    group by JT1.Partition, JT1.%4) as T3
                on T3.Partition = T1.Partition and T3.%4 = T1.%4
                group by T1.Partition, T1.%4, T1.CapacityHours, T2.Partition, T2.HardReservationHours, T3.SoftReservationHours ) AS T4
            END ";
            
        sqlStatementText = strFmt(sqlStatementText, _storeProcedureName, _reservedStatusThreshold, roundingDecimalPrecision, enum2Symbol(enumNum(AVTimeframeType), _timescale));

        return sqlStatementText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAssignmentByResourceForHourStoreProcedure</Name>
				<Source><![CDATA[
    private str getAssignmentByResourceForHourStoreProcedure(str _storeProcedureName, str _reservedStatusThreshold)
    {
        str sqlStatementText = @"
            CREATE PROCEDURE %1
                @partition AS BIGINT, @resource AS BIGINT, @activityResource AS BIGINT, @starDateTime AS DateTime,
                @hardReservedHours VARCHAR(10) OUTPUT, @availableHours VARCHAR(10) OUTPUT, @status INT OUTPUT, @hasSoftHours INT OUTPUT
            AS
            BEGIN

            SET NOCOUNT ON;

            SELECT
            @hardReservedHours = Convert(varchar(10), T4.HardReservedHours),
            @availableHours = Convert(varchar(10), CASE WHEN T4.Status = 1 AND ABS(T4.AvailableHours) < %2  THEN 0 ELSE T4.AvailableHours END),
            @status = CASE WHEN T4.Status = 1 AND abs(T4.AvailableHours) < %2 THEN 2 ELSE T4.Status END,
            @hasSoftHours = T4.HasSoftHours
            from (
                select
                Convert (Decimal(10,%3),
                    CASE
                        WHEN T3.ThisAssignmentHours is NULL THEN 0
                        ELSE T3.ThisAssignmentHours
                    END) as HardReservedHours,
                    Convert (Decimal(10,%3),
                        CASE
                            WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours is NULL AND T1.CapacityHours is NULL THEN 0
                            WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours is NULL then T1.CapacityHours
                            WHEN T2.OtherHardBookingHours is NULL then T1.CapacityHours - T3.ThisAssignmentHours
                            WHEN T3.ThisAssignmentHours is NULL then T1.CapacityHours - T2.OtherHardBookingHours
                            ELSE T1.CapacityHours - T2.OtherHardBookingHours - T3.ThisAssignmentHours
                        END) as AvailableHours,
                    CASE
                        WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours is NULL AND T1.CapacityHours is NULL THEN 4
                        WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours is NULL AND T1.CapacityHours = 0 THEN 4
                        WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours is NULL THEN 0
                        WHEN T2.OtherHardBookingHours is NULL AND abs(T3.ThisAssignmentHours - T1.CapacityHours) < %2 THEN 2
                        WHEN abs(T2.OtherHardBookingHours - T1.CapacityHours) < %2 AND T3.ThisAssignmentHours is NULL THEN 2
                        WHEN abs(T2.OtherHardBookingHours + T3.ThisAssignmentHours - T1.CapacityHours) < 0.2 THEN 2
                        WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours < T1.CapacityHours THEN 1
                        WHEN T2.OtherHardBookingHours < T1.CapacityHours AND T3.ThisAssignmentHours is NULL THEN 1
                        WHEN T2.OtherHardBookingHours + T3.ThisAssignmentHours < T1.CapacityHours THEN 1
                        WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours > T1.CapacityHours THEN 5
                        WHEN T2.OtherHardBookingHours > T1.CapacityHours AND T3.ThisAssignmentHours is NULL THEN 5
                        WHEN T2.OtherHardBookingHours + T3.ThisAssignmentHours > T1.CapacityHours THEN 5
                        ELSE 4
                        END as Status,
                    CASE
                        WHEN T4.SoftBookingHours is NOT NULL THEN 1
                        ELSE 0
                    END as HasSoftHours
                from (
                    select JT1.Partition, JT1.Hour,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as CapacityHours from ResCalendarCapacity JT1
                        join ResCalendarDateTimeRange JT2 on JT2.Partition = JT1.Partition and JT2.Calendar = JT1.Calendar
                            and JT2.VALIDFROMDATETIME < JT1.Hour and JT2.ValidToDateTime > JT1.Hour
                            where JT1.Partition = @partition and JT1.Hour = @starDateTime and JT2.Resource_ = @resource
                        group by JT1.Partition, JT1.Hour) as T1
                    left join (
                        select JT1.Partition, JT1.Hour,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as OtherHardBookingHours from ResBooking JT1
                        join PSAProjSchedRole JT2 on JT2.RecId = JT1.ActivityResource and JT2.Partition = JT1.Partition
                            where JT1.Partition = @partition and JT1.CommitType = 1 and JT1.Hour = @starDateTime and JT2.Resource_ = @resource and JT1.ActivityResource != @activityResource
                        group by JT1.Partition, JT1.Hour) as T2
                    on T2.Partition = T1.Partition and T2.Hour = T1.Hour
                    left join (
                        select JT1.Partition, JT1.Hour,
                            Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as ThisAssignmentHours from ResAssignment JT1
                            where JT1.Partition = @partition and JT1.CommitType = 1 and JT1.Hour = @starDateTime and JT1.ActivityResource = @activityResource
                        group by JT1.Partition, JT1.Hour) as T3
                    on T3.Partition = T1.Partition and T3.Hour = T1.Hour
                    left join (
                        select JT1.Partition, JT1.Hour,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as SoftBookingHours from ResBooking JT1
                        join PSAProjSchedRole JT2 on JT2.RecId = JT1.ActivityResource and JT2.Partition = JT1.Partition
                            where JT1.Partition = @partition and JT1.CommitType = 2 and JT1.Hour = @starDateTime and JT2.Resource_ = @resource
                        group by JT1.Partition, JT1.Hour) as T4
                    on T4.Partition = T1.Partition and T4.Hour = T1.Hour
                    group by T1.Partition, T1.Hour, T1.CapacityHours, T2.Partition, T2.OtherHardBookingHours, T3.ThisAssignmentHours, T4.SoftBookingHours) AS T4
            END ";
            
        sqlStatementText = strFmt(sqlStatementText, _storeProcedureName, _reservedStatusThreshold, roundingDecimalPrecision);

        return sqlStatementText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAssignmentByResourceForHourStoreProcedureV2</Name>
				<Source><![CDATA[
    private str getAssignmentByResourceForHourStoreProcedureV2(str _storeProcedureName, str _reservedStatusThreshold)
    {
        str sqlStatementText = @" 
            CREATE PROCEDURE %1
                @partition AS BIGINT, @resource AS BIGINT, @activityResource AS BIGINT, @starDateTime AS DateTime,
                @hardReservedHours VARCHAR(10) OUTPUT, @availableHours VARCHAR(10) OUTPUT, @status INT OUTPUT, @hasSoftHours INT OUTPUT
            AS
            BEGIN

            SET NOCOUNT ON;

            declare @calendar AS BIGINT
            declare @validDateTime AS DateTime
            declare @invalidDateTime AS DateTime set @invalidDateTime = '1900-01-01 00:00:00.000'
            
            SELECT @calendar = Calendar,
            @validDateTime =
            CASE
                WHEN validFromDateTime <= @starDateTime and validToDateTime >= @starDateTime THEN @starDateTime
                ELSE @invalidDateTime
            END
            from ResCalendarDateTimeRange
            where Partition = @partition and Resource_ = @resource;

            SELECT
            @hardReservedHours = Convert(varchar(10), T4.HardReservedHours),
            @availableHours = Convert(varchar(10), CASE WHEN T4.Status = 1 AND ABS(T4.AvailableHours) < %2  THEN 0 ELSE T4.AvailableHours END),
            @status = CASE WHEN T4.Status = 1 AND abs(T4.AvailableHours) < %2 THEN 2 ELSE T4.Status END,
            @hasSoftHours = T4.HasSoftHours
            from (
                select
                Convert (Decimal(10,%3),
                    CASE
                        WHEN T3.ThisAssignmentHours is NULL THEN 0
                        ELSE T3.ThisAssignmentHours
                    END) as HardReservedHours,
                    Convert (Decimal(10,%3),
                        CASE
                            WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours is NULL AND T1.CapacityHours is NULL THEN 0
                            WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours is NULL then T1.CapacityHours
                            WHEN T2.OtherHardBookingHours is NULL then T1.CapacityHours - T3.ThisAssignmentHours
                            WHEN T3.ThisAssignmentHours is NULL then T1.CapacityHours - T2.OtherHardBookingHours
                            ELSE T1.CapacityHours - T2.OtherHardBookingHours - T3.ThisAssignmentHours
                        END) as AvailableHours,
                    CASE
                        WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours is NULL AND T1.CapacityHours is NULL THEN 4
                        WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours is NULL AND T1.CapacityHours = 0 THEN 4
                        WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours is NULL THEN 0
                        WHEN T2.OtherHardBookingHours is NULL AND abs(T3.ThisAssignmentHours - T1.CapacityHours) < %2 THEN 2
                        WHEN abs(T2.OtherHardBookingHours - T1.CapacityHours) < %2 AND T3.ThisAssignmentHours is NULL THEN 2
                        WHEN abs(T2.OtherHardBookingHours + T3.ThisAssignmentHours - T1.CapacityHours) < 0.2 THEN 2
                        WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours < T1.CapacityHours THEN 1
                        WHEN T2.OtherHardBookingHours < T1.CapacityHours AND T3.ThisAssignmentHours is NULL THEN 1
                        WHEN T2.OtherHardBookingHours + T3.ThisAssignmentHours < T1.CapacityHours THEN 1
                        WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours > T1.CapacityHours THEN 5
                        WHEN T2.OtherHardBookingHours > T1.CapacityHours AND T3.ThisAssignmentHours is NULL THEN 5
                        WHEN T2.OtherHardBookingHours + T3.ThisAssignmentHours > T1.CapacityHours THEN 5
                        ELSE 4
                        END as Status,
                    CASE
                        WHEN T4.SoftBookingHours is NOT NULL THEN 1
                        ELSE 0
                    END as HasSoftHours
                from (
                    select JT1.Partition, JT1.Hour,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as CapacityHours from ResCalendarCapacity JT1
                        where JT1.Partition = @partition and JT1.Hour = @validDateTime and JT1.Calendar = @calendar
                    group by JT1.Partition, JT1.Hour) as T1
                    left join (
                        select JT1.Partition, JT1.Hour, 
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as OtherHardBookingHours from ResBooking JT1
                        join PSAProjSchedRole JT2 on JT2.RecId = JT1.ActivityResource and JT2.Partition = JT1.Partition
                            where JT1.Partition = @partition and JT1.CommitType = 1 and JT1.Hour = @starDateTime and JT2.Resource_ = @resource and JT1.ActivityResource != @activityResource
                        group by JT1.Partition, JT1.Hour) as T2
                    on T2.Partition = T1.Partition and T2.Hour = T1.Hour
                    left join (
                        select JT1.Partition, JT1.Hour, 
                            Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as ThisAssignmentHours from ResAssignment JT1
                            where JT1.Partition = @partition and JT1.CommitType = 1 and JT1.Hour = @starDateTime and JT1.ActivityResource = @activityResource
                        group by JT1.Partition, JT1.Hour) as T3
                    on T3.Partition = T1.Partition and T3.Hour = T1.Hour
                    left join (
                        select JT1.Partition, JT1.Hour, 
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as SoftBookingHours from ResBooking JT1
                        join PSAProjSchedRole JT2 on JT2.RecId = JT1.ActivityResource and JT2.Partition = JT1.Partition
                            where JT1.Partition = @partition and JT1.CommitType = 2 and JT1.Hour = @starDateTime and JT2.Resource_ = @resource
                        group by JT1.Partition, JT1.Hour) as T4
                    on T4.Partition = T1.Partition and T4.Hour = T1.Hour
                    group by T1.Partition, T1.Hour, T1.CapacityHours, T2.Partition, T2.OtherHardBookingHours, T3.ThisAssignmentHours, T4.SoftBookingHours) AS T4
            END ";
            
        sqlStatementText = strFmt(sqlStatementText, _storeProcedureName, _reservedStatusThreshold, roundingDecimalPrecision);

        return sqlStatementText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAssignmentByResourceStoreProcedure</Name>
				<Source><![CDATA[
    private str getAssignmentByResourceStoreProcedure(str _storeProcedureName, str _reservedStatusThreshold, AVTimeframeType _timescale)
    {
        str sqlStatementText = @"
            CREATE PROCEDURE %1
                @partition AS BIGINT, @resource AS BIGINT, @activityResource AS BIGINT, @starDateTime AS DateTime, @endDateTime AS DateTime,
                @hardReservedHours VARCHAR(10) OUTPUT, @availableHours VARCHAR(10) OUTPUT, @status INT OUTPUT, @hasSoftHours INT OUTPUT
            AS
            BEGIN

            SET NOCOUNT ON;

            SELECT
            @hardReservedHours = Convert(varchar(10), T4.HardReservedHours),
            @availableHours = Convert(varchar(10), CASE WHEN T4.Status = 1 AND ABS(T4.AvailableHours) < %2  THEN 0 ELSE T4.AvailableHours END),
            @status = CASE WHEN T4.Status = 1 AND abs(T4.AvailableHours) < %2 THEN 2 ELSE T4.Status END,
            @hasSoftHours = T4.HasSoftHours
            from (
                select
                    Convert (Decimal(10,%3),
                        CASE
                            WHEN T3.ThisAssignmentHours is NULL  THEN 0
                            ELSE T3.ThisAssignmentHours
                        END) as HardReservedHours,
                    Convert (Decimal(10,%3),
                        CASE
                            WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours is NULL AND T1.CapacityHours is NULL THEN 0
                            WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours is NULL then T1.CapacityHours
                            WHEN T2.OtherHardBookingHours is NULL then T1.CapacityHours - T3.ThisAssignmentHours
                            WHEN T3.ThisAssignmentHours is NULL then T1.CapacityHours - T2.OtherHardBookingHours
                            ELSE T1.CapacityHours - T2.OtherHardBookingHours - T3.ThisAssignmentHours
                        END) as AvailableHours,
                    CASE
                        WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours is NULL AND T1.CapacityHours is NULL THEN 4
                        WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours is NULL AND T1.CapacityHours = 0 THEN 4
                        WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours is NULL THEN 0
                        WHEN T2.OtherHardBookingHours is NULL AND abs(T3.ThisAssignmentHours - T1.CapacityHours) < %2 THEN 2
                        WHEN abs(T2.OtherHardBookingHours - T1.CapacityHours) < 0.2 AND T3.ThisAssignmentHours is NULL THEN 2
                        WHEN abs(T2.OtherHardBookingHours + T3.ThisAssignmentHours - T1.CapacityHours) < %2 THEN 2
                        WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours < T1.CapacityHours THEN 1
                        WHEN T2.OtherHardBookingHours < T1.CapacityHours AND T3.ThisAssignmentHours is NULL THEN 1
                        WHEN T2.OtherHardBookingHours + T3.ThisAssignmentHours < T1.CapacityHours THEN 1
                        WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours > T1.CapacityHours THEN 5
                        WHEN T2.OtherHardBookingHours > T1.CapacityHours AND T3.ThisAssignmentHours is NULL THEN 5
                        WHEN T2.OtherHardBookingHours + T3.ThisAssignmentHours > T1.CapacityHours THEN 5
                        ELSE 4
                        END as Status,
                    CASE
                        WHEN T4.SoftBookingHours is NOT NULL THEN 1
                        ELSE 0
                    END as HasSoftHours
                from (
                    select JT1.Partition, JT1.%4,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as CapacityHours from ResCalendarCapacity JT1
                    join ResCalendarDateTimeRange JT2 on JT2.Partition = JT1.Partition and JT2.Calendar = JT1.Calendar
                        and JT2.ValidFromDateTime < JT1.Hour and JT2.ValidToDateTime > JT1.Hour
                        where JT1.Partition = @partition and JT1.Hour >= @starDateTime and JT1.Hour <= @endDateTime and JT2.Resource_ = @resource
                        group by JT1.Partition, JT1.%4) as T1
                    left join (
                        select JT1.Partition, JT1.%4,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as OtherHardBookingHours from ResBooking JT1
                        join PSAProjSchedRole JT2 on JT2.RecId = JT1.ActivityResource and JT2.Partition = JT1.Partition
                            where JT1.Partition = @partition and JT1.CommitType = 1 and JT1.%4 = @starDateTime and JT2.Resource_ = @resource and JT1.ActivityResource != @activityResource
                        group by JT1.Partition, JT1.%4) as T2
                    on T2.Partition = T1.Partition and T2.%4 = T1.%4
                    left join (
                        select JT1.Partition, JT1.%4,
                            Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as ThisAssignmentHours from ResAssignment JT1
                            where JT1.Partition = @partition and JT1.CommitType = 1 and JT1.%4 = @starDateTime and JT1.ActivityResource = @activityResource
                        group by JT1.Partition, JT1.%4) as T3
                    on T3.Partition = T1.Partition and T3.%4 = T1.%4
                    left join (
                        select JT1.Partition, JT1.%4,
                            Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as SoftBookingHours from ResBooking JT1
                        join PSAProjSchedRole JT2 on JT2.RecId = JT1.ActivityResource and JT2.Partition = JT1.Partition
                            where JT1.Partition = @partition and JT1.CommitType = 2 and JT1.%4 = @starDateTime and JT2.Resource_ = @resource
                        group by JT1.Partition, JT1.%4) as T4
                    on T4.Partition = T1.Partition and T4.%4 = T1.%4
                    group by T1.Partition, T1.%4, T1.CapacityHours, T2.Partition, T2.OtherHardBookingHours, T3.ThisAssignmentHours, T4.SoftBookingHours) AS T4
            END ";

        sqlStatementText = strFmt(sqlStatementText, _storeProcedureName, _reservedStatusThreshold, roundingDecimalPrecision, enum2Symbol(enumNum(AVTimeframeType), _timescale));
        
        return sqlStatementText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAssignmentByResourceStoreProcedureV2</Name>
				<Source><![CDATA[
    private str getAssignmentByResourceStoreProcedureV2(str _storeProcedureName, str _reservedStatusThreshold, AVTimeframeType _timescale)
    {
        str sqlStatementText = @"
            CREATE PROCEDURE %1
                @partition AS BIGINT, @resource AS BIGINT, @activityResource AS BIGINT, @starDateTime AS DateTime, @endDateTime AS DateTime,
                @hardReservedHours VARCHAR(10) OUTPUT, @availableHours VARCHAR(10) OUTPUT, @status INT OUTPUT, @hasSoftHours INT OUTPUT
            AS
            BEGIN

            SET NOCOUNT ON;

            declare @calendar AS BIGINT
            declare @validFromDateTime AS DateTime
            declare @validToDateTime AS DateTime
            declare @invalidDateTime AS DateTime set @invalidDateTime = '1900-01-01 00:00:00.000'
            
            SELECT @calendar = Calendar,
            @validFromDateTime =
            CASE
                WHEN validToDateTime < @starDateTime or validFromDateTime > @endDateTime THEN @invalidDateTime
                WHEN validFromDateTime <= @starDateTime THEN @starDateTime
            ELSE validFromDateTime
            END,
            @validToDateTime =
            CASE
                WHEN validToDateTime < @starDateTime or validFromDateTime > @endDateTime THEN @invalidDateTime
                WHEN @endDateTime <= validToDateTime THEN @endDateTime
            ELSE validToDateTime
            END
            from ResCalendarDateTimeRange
            where Partition = @partition and Resource_ = @resource;

            SELECT
            @hardReservedHours = Convert(varchar(10), T4.HardReservedHours),
            @availableHours = Convert(varchar(10), CASE WHEN T4.Status = 1 AND ABS(T4.AvailableHours) < %2  THEN 0 ELSE T4.AvailableHours END),
            @status = CASE WHEN T4.Status = 1 AND abs(T4.AvailableHours) < %2 THEN 2 ELSE T4.Status END,
            @hasSoftHours = T4.HasSoftHours
            from (
                select
                    Convert (Decimal(10,%3),
                        CASE
                            WHEN T3.ThisAssignmentHours is NULL  THEN 0
                            ELSE T3.ThisAssignmentHours
                        END) as HardReservedHours,
                    Convert (Decimal(10,%3),
                        CASE
                            WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours is NULL AND T1.CapacityHours is NULL THEN 0
                            WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours is NULL then T1.CapacityHours
                            WHEN T2.OtherHardBookingHours is NULL then T1.CapacityHours - T3.ThisAssignmentHours
                            WHEN T3.ThisAssignmentHours is NULL then T1.CapacityHours - T2.OtherHardBookingHours
                            ELSE T1.CapacityHours - T2.OtherHardBookingHours - T3.ThisAssignmentHours
                        END) as AvailableHours,
                    CASE
                        WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours is NULL AND T1.CapacityHours is NULL THEN 4
                        WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours is NULL AND T1.CapacityHours = 0 THEN 4
                        WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours is NULL THEN 0
                        WHEN T2.OtherHardBookingHours is NULL AND abs(T3.ThisAssignmentHours - T1.CapacityHours) < %2 THEN 2
                        WHEN abs(T2.OtherHardBookingHours - T1.CapacityHours) < 0.2 AND T3.ThisAssignmentHours is NULL THEN 2
                        WHEN abs(T2.OtherHardBookingHours + T3.ThisAssignmentHours - T1.CapacityHours) < %2 THEN 2
                        WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours < T1.CapacityHours THEN 1
                        WHEN T2.OtherHardBookingHours < T1.CapacityHours AND T3.ThisAssignmentHours is NULL THEN 1
                        WHEN T2.OtherHardBookingHours + T3.ThisAssignmentHours < T1.CapacityHours THEN 1
                        WHEN T2.OtherHardBookingHours is NULL AND T3.ThisAssignmentHours > T1.CapacityHours THEN 5
                        WHEN T2.OtherHardBookingHours > T1.CapacityHours AND T3.ThisAssignmentHours is NULL THEN 5
                        WHEN T2.OtherHardBookingHours + T3.ThisAssignmentHours > T1.CapacityHours THEN 5
                        ELSE 4
                        END as Status,
                    CASE
                        WHEN T4.SoftBookingHours is NOT NULL THEN 1
                        ELSE 0
                    END as HasSoftHours
                from (
                    select JT1.Partition, JT1.%4,
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as CapacityHours from ResCalendarCapacity JT1
                        where JT1.Partition = @partition and JT1.Hour >= @validFromDateTime and JT1.Hour <= @validToDateTime and JT1.Calendar = @calendar
                    group by JT1.Partition, JT1.%4) as T1
                    left join (
                        select JT1.Partition, JT1.%4, 
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as OtherHardBookingHours from ResBooking JT1
                        join PSAProjSchedRole JT2 on JT2.RecId = JT1.ActivityResource and JT2.Partition = JT1.Partition
                            where JT1.Partition = @partition and JT1.CommitType = 1 and JT1.%4 = @starDateTime and JT2.Resource_ = @resource and JT1.ActivityResource != @activityResource
                        group by JT1.Partition, JT1.%4) as T2
                    on T2.Partition = T1.Partition and T2.%4 = T1.%4
                    left join (
                        select JT1.Partition, JT1.%4, 
                            Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as ThisAssignmentHours from ResAssignment JT1
                            where JT1.Partition = @partition and JT1.CommitType = 1 and JT1.%4 = @starDateTime and JT1.ActivityResource = @activityResource
                        group by JT1.Partition, JT1.%4) as T3
                    on T3.Partition = T1.Partition and T3.%4 = T1.%4
                    left join (
                        select JT1.Partition, JT1.%4, 
                            Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as SoftBookingHours from ResBooking JT1
                        join PSAProjSchedRole JT2 on JT2.RecId = JT1.ActivityResource and JT2.Partition = JT1.Partition
                            where JT1.Partition = @partition and JT1.CommitType = 2 and JT1.%4 = @starDateTime and JT2.Resource_ = @resource
                        group by JT1.Partition, JT1.%4) as T4
                    on T4.Partition = T1.Partition and T4.%4 = T1.%4
                    group by T1.Partition, T1.%4, T1.CapacityHours, T2.Partition, T2.OtherHardBookingHours, T3.ThisAssignmentHours, T4.SoftBookingHours) AS T4
            END ";

        sqlStatementText = strFmt(sqlStatementText, _storeProcedureName, _reservedStatusThreshold, roundingDecimalPrecision, enum2Symbol(enumNum(AVTimeframeType), _timescale));
        
        return sqlStatementText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAssignmentByPlannedResourceStoreProcedure</Name>
				<Source><![CDATA[
    private str getAssignmentByPlannedResourceStoreProcedure(str _storeProcedureName, str _reservedStatusThreshold, AVTimeframeType _timescale)
    {
        str sqlStatementText = @"
            CREATE PROCEDURE %1
                @partition AS BIGINT, @calendar AS BIGINT, @activityResource AS BIGINT, @starDateTime AS DateTime,
                @hardReservedHours VARCHAR(10) OUTPUT, @availableHours VARCHAR(10) OUTPUT, @status INT OUTPUT, @hasSoftHours INT OUTPUT
            AS
            BEGIN

            SET NOCOUNT ON;

            SELECT
            @hardReservedHours = Convert(varchar(10), T4.HardReservedHours),
            @availableHours = Convert(varchar(10),CASE WHEN T4.Status = 1 AND ABS(T4.AvailableHours) < %2 THEN 0 ELSE T4.AvailableHours END),
            @status = CASE WHEN T4.Status = 1 AND abs(T4.AvailableHours) < %2 THEN 2 ELSE T4.Status END,
            @hasSoftHours = T4.HasSoftHours
            from (
                SELECT
                    Convert (Decimal(10,%3),
                        CASE
                            WHEN T3.ThisAssignmentHours is NULL THEN 0 ELSE T3.ThisAssignmentHours
                        END) as HardReservedHours,
                    Convert (Decimal(10,%3),
                        CASE
                            WHEN T3.ThisAssignmentHours is NULL AND T1.CapacityHours is NULL THEN 0
                            WHEN T3.ThisAssignmentHours is NULL then T1.CapacityHours
                            ELSE T1.CapacityHours - T3.ThisAssignmentHours
                        END) as AvailableHours,
                    CASE
                        WHEN T3.ThisAssignmentHours is NULL AND T1.CapacityHours is NULL THEN 4
                        WHEN T3.ThisAssignmentHours is NULL AND T1.CapacityHours = 0 THEN 4
                        WHEN T3.ThisAssignmentHours is NULL THEN 0
                        WHEN abs(T3.ThisAssignmentHours - T1.CapacityHours) < %2 THEN 2
                        WHEN T3.ThisAssignmentHours < T1.CapacityHours THEN 1
                        WHEN T3.ThisAssignmentHours > T1.CapacityHours THEN 5
                        ELSE 4 END as Status,
                    CASE
                        WHEN T4.SoftBookingHours is NOT NULL THEN 1
                        ELSE 0 END as HasSoftHours
                from (
                    select JT1.Partition, JT1.%4, 
                        Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as CapacityHours from ResCalendarCapacity JT1
                        where JT1.Partition = @partition and JT1.Calendar = @calendar and JT1.%4 = @starDateTime
                    group by JT1.Partition, JT1.%4) as T1
                    left join (
                        select JT1.Partition, JT1.%4, 
                            Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as ThisAssignmentHours from ResAssignment JT1
                            where JT1.Partition = @partition and JT1.CommitType = 1 and JT1.%4 = @starDateTime and JT1.ActivityResource = @activityResource
                        group by JT1.Partition, JT1.%4) as T3
                    on T3.Partition = T1.Partition and T3.%4 = T1.%4
                    left join (
                        select JT1.Partition, JT1.%4, 
                            Convert (Decimal(10,%3), (sum(JT1.End_) - sum(JT1.Start_)) / 3600.00) as SoftBookingHours from ResBooking JT1
                            where JT1.Partition = @partition and JT1.CommitType = 2 and JT1.%4 = @starDateTime and JT1.ActivityResource = @activityResource
                        group by JT1.Partition, JT1.%4) as T4
                    on T4.Partition = T1.Partition and T4.%4 = T4.%4
                        group by T1.Partition, T1.%4, T1.CapacityHours, T3.ThisAssignmentHours, T4.SoftBookingHours) as T4
            END ";

        sqlStatementText = strFmt(sqlStatementText, _storeProcedureName, _reservedStatusThreshold, roundingDecimalPrecision, enum2Symbol(enumNum(AVTimeframeType), _timescale));

        return sqlStatementText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateTableTruncationStatement</Name>
				<Source><![CDATA[
    private str generateTableTruncationStatement(str _tableName)
    {
        str sqlStatementText = @"
            SET @hasRecordInOtherPartition = 0;

            IF OBJECT_ID('%1', 'U') IS NOT NULL
                BEGIN
                IF EXISTS(SELECT TOP 1 'x' FROM %1 WHERE Partition != @partition)
                    SET @hasRecordInOtherPartition = 1
                IF @hasRecordInOtherPartition = 1
                    BEGIN
                        DELETE %1 WHERE PARTITION = @partition;
                    END
                ELSE
                    BEGIN
                        TRUNCATE TABLE %1;
                    END
                END
            ";

        sqlStatementText = strFmt(sqlStatementText, _tableName);
        return sqlStatementText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDeleteResRollupTablesStoreProcedure</Name>
				<Source><![CDATA[
    private str getDeleteResRollupTablesStoreProcedure(str _storeProcedureName)
    {
        str sqlStatementStartText = @"
            CREATE PROCEDURE %1
                @partition AS BIGINT
            AS
            BEGIN
            SET NOCOUNT ON;

            DECLARE @hasRecordInOtherPartition INT;
            ";
            
       str sqlStatementEndText = @"
            END";

        str sqlStatementText = strFmt(sqlStatementStartText, _storeProcedureName) + this.generateTableTruncationStatement(tableStr(ResRollup)) 
            + this.generateTableTruncationStatement(tableStr(ResRollupCalendarShared)) + this.generateTableTruncationStatement(tableStr(ResRollupCalendar))
            + sqlStatementEndText;
        
        return sqlStatementText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDeleteResProjectResourceTablesStoreProcedure</Name>
				<Source><![CDATA[
    private str getDeleteResProjectResourceTablesStoreProcedure(str _storeProcedureName)
    {
        str sqlStatementStartText = @"
            CREATE PROCEDURE %1
                @partition AS BIGINT
            AS
            BEGIN
            SET NOCOUNT ON;

            DECLARE @hasRecordInOtherPartition INT;
            ";
            
        str sqlStatementEndText = @"
            END";

        str sqlStatementText = strFmt(sqlStatementStartText, _storeProcedureName) + this.generateTableTruncationStatement(tableStr(ResProjectResource))
            + this.generateTableTruncationStatement(tableStr(ResEffectiveDateTimeRange)) + this.generateTableTruncationStatement(tableStr(ResCalendarDateTimeRange))
            + sqlStatementEndText;
        
        return sqlStatementText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDeleteResCalendarCapacityTablesStoreProcedure</Name>
				<Source><![CDATA[
    private str getDeleteResCalendarCapacityTablesStoreProcedure(str _storeProcedureName)
    {
        str sqlStatementStartText = @"
            CREATE PROCEDURE %1
                @partition AS BIGINT
            AS
            BEGIN
            SET NOCOUNT ON;

            DECLARE @hasRecordInOtherPartition INT;
            ";
            
        str sqlStatementEndText = @"
            END";

        str sqlStatementText = strFmt(sqlStatementStartText, _storeProcedureName) + this.generateTableTruncationStatement(tableStr(ResCalendarCapacity))
            + sqlStatementEndText;
                
        return sqlStatementText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNamedResourceAvailabilitySQLStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get named resource availability coverage SQL statement.
    /// </summary>
    /// <param name = "_timescale">Time scale.</param>
    /// <param name = "_resourceRecId">Resource record ID.</param>
    /// <param name = "_startDateTime">Start date time.</param>
    /// <param name = "_startDateTimeStr">Start date time in string.</param>
    /// <returns>Resource availability SQL statement.</returns>
    public static str getNamedResourceAvailabilitySQLStatement(AVTimeframeType _timescale, ResourceRecId _resourceRecId, utcdatetime _startDateTime, str _startDateTimeStr)
    {
        // %1 SP name, %2 Partition, %3 ResourceRecId, %4 Start date
        str hourSqlStatement = @"
            DECLARE @hardReservedHours Varchar(10) SET @hardReservedHours = '0.00'
            DECLARE @availableHours Varchar(10) SET @availableHours = '0.00'
            DECLARE @status INT SET @status = 4
            DECLARE @hasSoftHours INT SET @hasSoftHours = 0
            EXEC %1 %2, %3, '%4',
            @hardReservedHours OUTPUT, @availableHours OUTPUT, @status OUTPUT, @hasSoftHours OUTPUT
            SELECT @hardReservedHours, @availableHours, @status, @hasSoftHours";

        // %1 SP name, %2 Partition, %3 ResourceRecId, %4 Start date, %5 end date
        str otherSQLStatement = @"
            DECLARE @hardReservedHours Varchar(10) SET @hardReservedHours = '0.00'
            DECLARE @availableHours Varchar(10) SET @availableHours = '0.00'
            DECLARE @status INT SET @status = 4
            DECLARE @hasSoftHours INT SET @hasSoftHours = 0
            EXEC %1 %2, %3, '%4', '%5',
            @hardReservedHours OUTPUT, @availableHours OUTPUT, @status OUTPUT, @hasSoftHours OUTPUT
            SELECT @hardReservedHours, @availableHours, @status, @hasSoftHours";

        str sqlStatement;
        str endDateTimeStr;

        switch(_timescale)
        {
            case AVTimeframeType::Hour:
                sqlStatement = strFmt(hourSqlStatement, ResSchedulingSQLObjects::getResAvailabilityByResourceForHour(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_resourceRecId), _startDateTimeStr);
                break;
            case AVTimeframeType::Day:
                endDateTimeStr = AVUtil::getDateTimeStr(AVTimeframe::getTimeframe(_startDateTime, _timescale).end());
                sqlStatement = strFmt(otherSQLStatement, ResSchedulingSQLObjects::getResAvailabilityByResourceForDay(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_resourceRecId), _startDateTimeStr, endDateTimeStr);
                break;
            case AVTimeframeType::Week:
                endDateTimeStr = AVUtil::getDateTimeStr(AVTimeframe::getTimeframe(_startDateTime, _timescale).end());
                sqlStatement = strFmt(otherSQLStatement, ResSchedulingSQLObjects::getResAvailabilityByResourceForWeek(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_resourceRecId), _startDateTimeStr, endDateTimeStr);
                break;
            case AVTimeframeType::Month:
                endDateTimeStr = AVUtil::getDateTimeStr(AVTimeframe::getTimeframe(_startDateTime, _timescale).end());
                sqlStatement = strFmt(otherSQLStatement, ResSchedulingSQLObjects::getResAvailabilityByResourceForMonth(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_resourceRecId), _startDateTimeStr, endDateTimeStr);
                break;
            case AVTimeframeType::Quarter:
                endDateTimeStr = AVUtil::getDateTimeStr(AVTimeframe::getTimeframe(_startDateTime, _timescale).end());
                sqlStatement = strFmt(otherSQLStatement, ResSchedulingSQLObjects::getResAvailabilityByResourceForQuarter(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_resourceRecId), _startDateTimeStr, endDateTimeStr);
                break;
            case AVTimeframeType::HalfYear:
                endDateTimeStr = AVUtil::getDateTimeStr(AVTimeframe::getTimeframe(_startDateTime, _timescale).end());
                sqlStatement = strFmt(otherSQLStatement, ResSchedulingSQLObjects::getResAvailabilityByResourceForHalfYear(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_resourceRecId), _startDateTimeStr, endDateTimeStr);
                break;
        }

        return sqlStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNamedResourceActivitySQLStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get named resource activity coverage SQL statement.
    /// </summary>
    /// <param name = "_timescale">Time scale.</param>
    /// <param name = "_resourceRecId">Resource record ID.</param>
    /// <param name = "_activityResourceRecId">Activity resource record ID.</param>
    /// <param name = "_startDateTime">Start date time.</param>
    /// <param name = "_startDateTimeStr">Start date time in string.</param>
    /// <returns>Resource availability SQL statement.</returns>
    public static str getNamedResourceActivitySQLStatement(AVTimeframeType _timescale, ResourceRecId _resourceRecId, ActivityResourceRecId _activityResourceRecId, utcdatetime _startDateTime, str _startDateTimeStr)
    {
        // %1 SP name, %2 Partition, %3 ResourceRecId, %4 ActivityResourceRecId, %5 Start date
        str hourSqlTemplate = @"
            DECLARE @hardReservedHours Varchar(10) SET @hardReservedHours = '0.00'
            DECLARE @availableHours Varchar(10) SET @availableHours = '0.00'
            DECLARE @status INT SET @status = 4
            DECLARE @hasSoftHours INT SET @hasSoftHours = 0
            EXEC %1 %2, %3, %4, '%5',
            @hardReservedHours OUTPUT, @availableHours OUTPUT, @status OUTPUT, @hasSoftHours OUTPUT
            SELECT @hardReservedHours, @availableHours, @status, @hasSoftHours";

        // %1 SP name, %2 Partition, %3 ResourceRecId, %4 ActivityResourceRecId, %5 Start date, %6 end date
        str otherSqlTemplate = @"
            DECLARE @hardReservedHours Varchar(10) SET @hardReservedHours = '0.00'
            DECLARE @availableHours Varchar(10) SET @availableHours = '0.00'
            DECLARE @status INT SET @status = 4
            DECLARE @hasSoftHours INT SET @hasSoftHours = 0
            EXEC %1 %2, %3, %4, '%5', '%6',
            @hardReservedHours OUTPUT, @availableHours OUTPUT, @status OUTPUT, @hasSoftHours OUTPUT
            SELECT @hardReservedHours, @availableHours, @status, @hasSoftHours";

        str sqlStatement;
        str endDateTimeStr;

        switch(_timescale)
        {
            case AVTimeframeType::Hour:
                sqlStatement = strFmt(hourSqlTemplate, ResSchedulingSQLObjects::getResActivityByResourceForHour(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_resourceRecId), int642Str(_activityResourceRecID), _startDateTimeStr);
                break;
            case AVTimeframeType::Day:
                endDateTimeStr = AVUtil::getDateTimeStr(AVTimeframe::getTimeframe(_startDateTime, _timescale).end());
                sqlStatement = strFmt(otherSqlTemplate, ResSchedulingSQLObjects::getResActivityByResourceForDay(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_resourceRecId), int642Str(_activityResourceRecID), _startDateTimeStr, endDateTimeStr);
                break;
            case AVTimeframeType::Week:
                endDateTimeStr = AVUtil::getDateTimeStr(AVTimeframe::getTimeframe(_startDateTime, _timescale).end());
                sqlStatement = strFmt(otherSqlTemplate, ResSchedulingSQLObjects::getResActivityByResourceForWeek(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_resourceRecId), int642Str(_activityResourceRecID), _startDateTimeStr, endDateTimeStr);
                break;
            case AVTimeframeType::Month:
                endDateTimeStr = AVUtil::getDateTimeStr(AVTimeframe::getTimeframe(_startDateTime, _timescale).end());
                sqlStatement = strFmt(otherSqlTemplate, ResSchedulingSQLObjects::getResActivityByResourceForMonth(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_resourceRecId), int642Str(_activityResourceRecID), _startDateTimeStr, endDateTimeStr);
                break;
            case AVTimeframeType::Quarter:
                endDateTimeStr = AVUtil::getDateTimeStr(AVTimeframe::getTimeframe(_startDateTime, _timescale).end());
                sqlStatement = strFmt(otherSqlTemplate, ResSchedulingSQLObjects::getResActivityByResourceForQuarter(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_resourceRecId), int642Str(_activityResourceRecID), _startDateTimeStr, endDateTimeStr);
                break;
            case AVTimeframeType::HalfYear:
                endDateTimeStr = AVUtil::getDateTimeStr(AVTimeframe::getTimeframe(_startDateTime, _timescale).end());
                sqlStatement = strFmt(otherSqlTemplate, ResSchedulingSQLObjects::getResActivityByResourceForHalfYear(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_resourceRecId), int642Str(_activityResourceRecID), _startDateTimeStr, endDateTimeStr);
                break;
        }

        return sqlStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPlannedResourceActivitySQLStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get planned resource activity coverage SQL statement.
    /// </summary>
    /// <param name = "_timescale">Time scale.</param>
    /// <param name = "_calendarRecId">Calendar record ID.</param>
    /// <param name = "_activityResourceRecId">Activity resource record ID.</param>
    /// <param name = "_startDateTime">Start date time.</param>
    /// <param name = "_startDateTimeStr">Start date time in string.</param>
    /// <returns>Resource availability SQL statement.</returns>
    public static str getPlannedResourceActivitySQLStatement(AVTimeframeType _timescale, CalendarRecId _calendarRecId, ActivityResourceRecId _activityResourceRecId, utcdatetime _startDateTime, str _startDateTimeStr)
    {
        // %1 SP name, %2 Partition, %3 CalendarRecId, %4 ActivityResourceRecId, %4 Start date
        str sqlTemplate = @"
            DECLARE @hardReservedHours Varchar(10) SET @hardReservedHours = '0.00'
            DECLARE @availableHours Varchar(10) SET @availableHours = '0.00'
            DECLARE @status INT SET @status = 4
            DECLARE @hasSoftHours INT SET @hasSoftHours = 0
            EXEC %1 %2, %3, %4, '%5',
            @hardReservedHours OUTPUT, @availableHours OUTPUT, @status OUTPUT, @hasSoftHours OUTPUT
            SELECT @hardReservedHours, @availableHours, @status, @hasSoftHours";

        str sqlStatement;

        switch(_timescale)
        {
            case AVTimeframeType::Hour:
                sqlStatement = strFmt(sqlTemplate, ResSchedulingSQLObjects::getResActivityByPlannedResourceForHour(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_calendarRecId), int642Str(_activityResourceRecID), _startDateTimeStr);
                break;
            case AVTimeframeType::Day:
                sqlStatement = strFmt(sqlTemplate, ResSchedulingSQLObjects::getResActivityByPlannedResourceForDay(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_calendarRecId), int642Str(_activityResourceRecID), _startDateTimeStr);
                break;
            case AVTimeframeType::Week:
                sqlStatement = strFmt(sqlTemplate, ResSchedulingSQLObjects::getResActivityByPlannedResourceForWeek(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_calendarRecId), int642Str(_activityResourceRecID), _startDateTimeStr);
                break;
            case AVTimeframeType::Month:
                sqlStatement = strFmt(sqlTemplate, ResSchedulingSQLObjects::getResActivityByPlannedResourceForMonth(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_calendarRecId), int642Str(_activityResourceRecID), _startDateTimeStr);
                break;
            case AVTimeframeType::Quarter:
                sqlStatement = strFmt(sqlTemplate, ResSchedulingSQLObjects::getResActivityByPlannedResourceForQuarter(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_calendarRecId), int642Str(_activityResourceRecID), _startDateTimeStr);
                break;
            case AVTimeframeType::HalfYear:
                sqlStatement = strFmt(sqlTemplate, ResSchedulingSQLObjects::getResActivityByPlannedResourceForHalfYear(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_calendarRecId), int642Str(_activityResourceRecID), _startDateTimeStr);
                break;
        }

        return sqlStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNamedResourceAssignmentSQLStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get named resource assignment coverage SQL statement.
    /// </summary>
    /// <param name = "_timescale">Time scale.</param>
    /// <param name = "_resourceRecId">Resource record ID.</param>
    /// <param name = "_activityResourceRecId">Activity resource record ID.</param>
    /// <param name = "_startDateTime">Start date time.</param>
    /// <param name = "_startDateTimeStr">Start date time in string.</param>
    /// <returns>Resource availability SQL statement.</returns>
    public static str getNamedResourceAssignmentSQLStatement(AVTimeframeType _timescale, ResourceRecId _resourceRecId, ActivityResourceRecId _activityResourceRecId, utcdatetime _startDateTime, str _startDateTimeStr)
    {
        // %1 SP name, %2 Partition, %3 ResourceRecId, %4 ActivityResourceRecId, %5 Start date
        str hourSqlTemplate = @"
            DECLARE @hardReservedHours Varchar(10) SET @hardReservedHours = '0.00'
            DECLARE @availableHours Varchar(10) SET @availableHours = '0.00'
            DECLARE @status INT SET @status = 4
            DECLARE @hasSoftHours INT SET @hasSoftHours = 0
            EXEC %1 %2, %3, %4, '%5',
            @hardReservedHours OUTPUT, @availableHours OUTPUT, @status OUTPUT, @hasSoftHours OUTPUT
            SELECT @hardReservedHours, @availableHours, @status, @hasSoftHours";

        // %1 SP name, %2 Partition, %3 ResourceRecId, %4 ActivityResourceRecId, %5 Start date, %6 end date
        str otherSqlTemplate = @"
            DECLARE @hardReservedHours Varchar(10) SET @hardReservedHours = '0.00'
            DECLARE @availableHours Varchar(10) SET @availableHours = '0.00'
            DECLARE @status INT SET @status = 4
            DECLARE @hasSoftHours INT SET @hasSoftHours = 0
            EXEC %1 %2, %3, %4, '%5', '%6',
            @hardReservedHours OUTPUT, @availableHours OUTPUT, @status OUTPUT, @hasSoftHours OUTPUT
            SELECT @hardReservedHours, @availableHours, @status, @hasSoftHours";

        str sqlStatement;
        str endDateTimeStr;

        switch(_timescale)
        {
            case AVTimeframeType::Hour:
                sqlStatement = strFmt(hourSqlTemplate, ResSchedulingSQLObjects::getResAssignmentByResourceForHour(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_resourceRecId), int642Str(_activityResourceRecID), _startDateTimeStr);
                break;
            case AVTimeframeType::Day:
                endDateTimeStr = AVUtil::getDateTimeStr(AVTimeframe::getTimeframe(_startDateTime, _timescale).end());
                sqlStatement = strFmt(otherSqlTemplate, ResSchedulingSQLObjects::getResAssignmentByResourceForDay(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_resourceRecId), int642Str(_activityResourceRecID), _startDateTimeStr, endDateTimeStr);
                break;
            case AVTimeframeType::Week:
                endDateTimeStr = AVUtil::getDateTimeStr(AVTimeframe::getTimeframe(_startDateTime, _timescale).end());
                sqlStatement = strFmt(otherSqlTemplate, ResSchedulingSQLObjects::getResAssignmentByResourceForWeek(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_resourceRecId), int642Str(_activityResourceRecID), _startDateTimeStr, endDateTimeStr);
                break;
            case AVTimeframeType::Month:
                endDateTimeStr = AVUtil::getDateTimeStr(AVTimeframe::getTimeframe(_startDateTime, _timescale).end());
                sqlStatement = strFmt(otherSqlTemplate, ResSchedulingSQLObjects::getResAssignmentByResourceForMonth(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_resourceRecId), int642Str(_activityResourceRecID), _startDateTimeStr, endDateTimeStr);
                break;
            case AVTimeframeType::Quarter:
                endDateTimeStr = AVUtil::getDateTimeStr(AVTimeframe::getTimeframe(_startDateTime, _timescale).end());
                sqlStatement = strFmt(otherSqlTemplate, ResSchedulingSQLObjects::getResAssignmentByResourceForQuarter(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_resourceRecId), int642Str(_activityResourceRecID), _startDateTimeStr, endDateTimeStr);
                break;
            case AVTimeframeType::HalfYear:
                endDateTimeStr = AVUtil::getDateTimeStr(AVTimeframe::getTimeframe(_startDateTime, _timescale).end());
                sqlStatement = strFmt(otherSqlTemplate, ResSchedulingSQLObjects::getResAssignmentByResourceForHalfYear(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_resourceRecId), int642Str(_activityResourceRecID), _startDateTimeStr, endDateTimeStr);
                break;
        }

        return sqlStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPlannedResourceAssignmentSQLStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get planned resource assignment coverage SQL statement.
    /// </summary>
    /// <param name = "_timesacale">Time scale.</param>
    /// <param name = "_calendarRecId">Calendar record ID.</param>
    /// <param name = "_activityResourceRecId">Activity resource record ID.</param>
    /// <param name = "_startDateTime">Start date time.</param>
    /// <param name = "_startDateTimeStr">Start date time in string.</param>
    /// <returns>Resource availability SQL statement.</returns>
    public static str getPlannedResourceAssignmentSQLStatement(AVTimeframeType _timesacale, CalendarRecId _calendarRecId, ActivityResourceRecId _activityResourceRecId, utcdatetime _startDateTime, str _startDateTimeStr)
    {
        // %1 SP name, %2 Partition, %3 CalendarRecId, %4 ActivityResourceRecId, %5 Start date
        str sqlTemplate = @"
            DECLARE @hardReservedHours Varchar(10) SET @hardReservedHours = '0.00'
            DECLARE @availableHours Varchar(10) SET @availableHours = '0.00'
            DECLARE @status INT SET @status = 4
            DECLARE @hasSoftHours INT SET @hasSoftHours = 0
            EXEC %1 %2, %3, %4, '%5',
            @hardReservedHours OUTPUT, @availableHours OUTPUT, @status OUTPUT, @hasSoftHours OUTPUT
            SELECT @hardReservedHours, @availableHours, @status, @hasSoftHours";

        str sqlStatement;

        switch(_timesacale)
        {
            case AVTimeframeType::Hour:
                sqlStatement = strFmt(sqlTemplate, ResSchedulingSQLObjects::getResAssignmentByPlannedResourceForHour(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_calendarRecId), int642Str(_activityResourceRecID), _startDateTimeStr);
                break;
            case AVTimeframeType::Day:
                sqlStatement = strFmt(sqlTemplate, ResSchedulingSQLObjects::getResAssignmentByPlannedResourceForDay(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_calendarRecId), int642Str(_activityResourceRecID), _startDateTimeStr);
                break;
            case AVTimeframeType::Week:
                sqlStatement = strFmt(sqlTemplate, ResSchedulingSQLObjects::getResAssignmentByPlannedResourceForWeek(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_calendarRecId), int642Str(_activityResourceRecID), _startDateTimeStr);
                break;
            case AVTimeframeType::Month:
                sqlStatement = strFmt(sqlTemplate, ResSchedulingSQLObjects::getResAssignmentByPlannedResourceForMonth(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_calendarRecId), int642Str(_activityResourceRecID), _startDateTimeStr);
                break;
            case AVTimeframeType::Quarter:
                sqlStatement = strFmt(sqlTemplate, ResSchedulingSQLObjects::getResAssignmentByPlannedResourceForQuarter(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_calendarRecId), int642Str(_activityResourceRecID), _startDateTimeStr);
                break;
            case AVTimeframeType::HalfYear:
                sqlStatement = strFmt(sqlTemplate, ResSchedulingSQLObjects::getResAssignmentByPlannedResourceForHalfYear(),
                    int642Str(getCurrentPartitionRecId()), int642Str(_calendarRecId), int642Str(_activityResourceRecID), _startDateTimeStr);
                break;
        }

        return sqlStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDeleteResRollupTablesSQLStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get delete <c>ResRollup</c> tables SQL statement.
    /// </summary>
    /// <returns>Delete <c>ResRollup</c> tables SQL statement.</returns>
    public static str getDeleteResRollupTablesSQLStatement()
    {
        // Execute store procedure to delete data - %1 SP name, %2 Partition
        str sqlStatement = strFmt(@'EXEC %1 %2', ResSchedulingSQLObjects::deleteResRollupTables, int642Str(getCurrentPartitionRecId()));
        return sqlStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDeleteResProjectResourceTablesSQLStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get delete <c>ResProjectResource</c> tables SQL statement.
    /// </summary>
    /// <returns>Delete <c>ResProjectResource</c> tables SQL statement.</returns>
    [SysObsoleteAttribute('This method is replaced by ResProjectResourceEventHandler.insertAllResourceRecords() to delete the table records directly using regular X++ logic to avoid truncate table execution.', false, 11\11\2023)]
    public static str getDeleteResProjectResourceTablesSQLStatement()
    {
        // Execute store procedure to delete data - %1 SP name, %2 Partition
        str sqlStatement = strFmt(@'EXEC %1 %2', ResSchedulingSQLObjects::deleteResProjectResourceTables, int642Str(getCurrentPartitionRecId()));
        return sqlStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDeleteResCalendarCapacityTablesSQLStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get delete <c>ResCalendarCapacity</c> tables SQL statement.
    /// </summary>
    /// <returns>Delete <c>ResCalendarCapacity</c> tables SQL statement.</returns>
    public static str getDeleteResCalendarCapacityTablesSQLStatement()
    {
        // Execute store procedure to delete data - %1 SP name, %2 Partition
        str sqlStatement = strFmt(@'EXEC %1 %2', ResSchedulingSQLObjects::deleteResCalendarCapacityTables, int642Str(getCurrentPartitionRecId()));
        return sqlStatement;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>