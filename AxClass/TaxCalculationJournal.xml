<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxCalculationJournal</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>TaxCalculationJournal</c> class is the tax calculation class for journals.
/// </summary>
class TaxCalculationJournal extends TaxCalculation
{
    // <GIN>
    TaxAmount           priceInclTaxAmount;
    boolean             inclTax;
    AmountCur           amountCurCrVat;

    // </GIN>
    // <GEERU>
    boolean             resetExemptTax_RU;
    boolean             useExchRates_RU;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>allowAdjustBaseAmountForTaxAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines whether the transaction supports adjusting the calculated base amount
    ///   when tax is included in item price and the users adjusts the tax amount.
    /// </summary>
    /// <returns>
    ///   true if adjusting the calculated base amount is supported; otherwise, false.
    /// </returns>
    public boolean allowAdjustBaseAmountForTaxAdjustment()
    {
        if (taxIncludedInItemPrice)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowSingleLineAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the transaction supports adjusting a single tax line.
    /// </summary>
    /// <returns>
    ///    true if adjusting a single line is supported; otherwise, false.
    /// </returns>
    public boolean allowSingleLineAdjustment()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates taxes total taxes excluding use taxes. This is the base calculate taxes method derived
    ///    classes are required to implement.
    /// </summary>
    /// <returns>
    ///    The tax amount excluding the use tax.
    /// </returns>
    public TaxAmountCur calculateTax()
    {
        TaxAmount               taxAmount;
        boolean                 linesExist = true;
        boolean                 success = true;

        Debug::assert(taxableDocument != null);

        if (!taxableDocument.getSourceHeader().RecId)
        {
            return 0;
        }

        LedgerJournalTaxDocument taxDocumentJournal = taxableDocument as LedgerJournalTaxDocument;
        if (TaxIntegrationUtils::isTaxIntegrationEnabledForJournalType(taxDocumentJournal.getJournalType()))
        {
            using (var taxIntegrationSkipUpdateContext = TaxIntegrationSkipUpdateContext::getInstance())
            {
                if (!useTaxUncommitted)
                {
                    taxIntegrationSkipUpdateContext.parmSkipUpdate(true);
                }
                taxAmount = this.calcUsingTaxIntegration();
            }
            return taxAmount;
        }
        else
        {
            return super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcUsingTaxIntegration</Name>
				<Source><![CDATA[
    private TaxAmount calcUsingTaxIntegration()
    {
        TaxAmountCur taxAmount;
        Microsoft.Dynamics.Ax.Xpp.ErrorException errorEx;
        Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource taxEventSourceLog = Microsoft.Dynamics.Tax.Instrumentation.TaxEventSource::Log;
        System.Diagnostics.Stopwatch stopWatch;
        guid identifier;
        ReqReaderWriterLock lock = ReqReaderWriterLock::construct();
        str lockName = this.lockName();
        boolean success = true;

        try
        {
            stopWatch = new System.Diagnostics.Stopwatch();
            identifier = newGuid();

            if (TaxCalculationInstrumentationToggle::instance().isEnabled())
            {
                taxEventSourceLog.CalculateTaxStart(identifier, TaxUncommitted::callStackInfo());
            }
            else
            {
                taxEventSourceLog.CalculateTaxStart(identifier);
            }

            stopWatch.Start();

            this.enterTaxableDocumentLock(lock, lockName);
            TaxIntegrationJournalDocumentObject document = TaxIntegrationJournalDocumentObject::constructWithRecord(taxableDocument.getSourceHeader());

            this.setFieldsForTaxIntegrationDocumentObject(document);

            TaxIntegrationFacade::calculate(document);
            amountInclTaxMap = document.getAmountIncludingTax();
            amountExclTaxMap = document.getAmountExcludingTax();

            taxAmount = this.finalizeCalculationForTaxIntegration(true);
        }
        catch (errorEx) // errorEx is the same as Exception::Error
        {
            success = false;
            taxEventSourceLog.TaxProcessError(
                guid2Str(newGuid()),
                errorEx.Message,
                errorEx.StackTrace,
                methodStr(TaxCalculation, calculateTax));
            throw Exception::Error;
        }
        finally
        {
            this.exitTaxableDocumentLock(lock, lockName);
            stopWatch.Stop();
            select count(RecId) from taxWorkTrans;
            taxEventSourceLog.CalculateTaxStop(
                identifier,
                SysCountryRegionCode::countryInfo(),
                tableId2Name(taxableDocument.getSourceHeader().TableId),
                TaxTelemetryConstants::salesTax,
                stopWatch.ElapsedMilliseconds,
                taxableDocumentLines,
                markupTransTaxableDocumentLines,
                taxWorkTrans.RecId,
                taxableDocument.getTaxIncluded(),
                taxableDocument.getSourceHeader().TableId,
                tableId2Name(taxableDocument.getSourceHeader().TableId),
                taxableDocument.getSourceHeader().RecId,
                success);
        }
        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFieldsForTaxIntegrationDocumentObject</Name>
				<Source><![CDATA[
    protected void setFieldsForTaxIntegrationDocumentObject(TaxIntegrationJournalDocumentObject _document)
    {
        _document.setCompany(this.getCompany());
        _document.setHeadingTableId(taxableDocument.getSourceHeader().TableId);
        _document.setHeadingRecId(taxableDocument.getSourceHeader().RecId);

        _document.setSign(1);

        _document.setLegacyTax(this);
        _document.setVoucher(taxableDocument.getReferenceNumber());
        _document.setLegacyTaxableDocument(taxableDocument);
        _document.setShouldSkipDocumentCharge(true);
        _document.setShouldSkipLineCharge(true);

        if (_document.isProjExpenseJournal())
        {
            _document.setBusinessProcess(TaxIntegrationBusinessProcess::Project);
            _document.setSource(TaxModuleType::Project);
        }
        else
        {
            _document.setBusinessProcess(TaxIntegrationBusinessProcess::Journal);
            _document.setSource(taxModuleType);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTaxDifferenceAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates tax difference amount in accounting currency by the difference between accounting exchange rate and tax exchange rate.
    /// </summary>
    protected void calculateTaxDifferenceAmount()
    {
        boolean exchangeRateIsSame;
        boolean linesExist = true;
        RefTableId sourceTableId;
        RefRecId sourceRecordId;
        VatDueDate_W dateOfVATRegister;
        CurrencyExchangeRate taxExchangeRate;
        SalesTaxTransactionExchangeRate salesTaxTransactionExchangeRate;

        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            return;
        }

        linesExist = taxableDocument.getFirstLine();

        while (linesExist)
        {
            Map taxSpecificExchangeRateMapLoc;
            CurrencyExchangeRate accountingExchangeRate;
            CurrencyExchangeRate reportingExchangeRate;

            taxableLineCurrentlyBeingCalculated = taxableDocument.getCurrentLine();
            sourceTableId = taxableLineCurrentlyBeingCalculated.getSourceLine().TableId;
            sourceRecordId = taxableLineCurrentlyBeingCalculated.getSourceLine().RecId;
            boolean isEnabledTaxExchangeRateSpecificFlight = TaxSalesTaxExchangeRateSpecificLegalEntity_PLFlight::instance().isEnabled() && headingTableId == tableNum(LedgerJournalTable);
            boolean isNeedCalculateTaxDiffAmount = true;

            if (isEnabledTaxExchangeRateSpecificFlight)
            {
                LedgerJournalTrans ledgerJournalTrans = taxableLineCurrentlyBeingCalculated.getSourceLine() as LedgerJournalTrans;
                CurrencyCode accountingCurrencyGLTrans = Ledger::accountingCurrency(ledgerJournalTrans.getCompanyLegalEntity());
                isNeedCalculateTaxDiffAmount = accountingCurrencyGLTrans != ledgerJournalTrans.CurrencyCode;
            }

            boolean isTaxSpecificExchRateEnabledByBusinessProcess = TaxSpecificExchangeRateHelper::isTaxSpecificExchRateEnabledByTable(sourceTableId, sourceRecordId);

            if (isTaxSpecificExchRateEnabledByBusinessProcess)
            {
                taxSpecificExchangeRateMapLoc = TaxSpecificExchangeRateHelper::getExchangeRateMap(sourceTableId, sourceRecordId);
                dateOfVATRegister = TaxSpecificExchangeRate::getDateOfVATRegister(sourceTableId, sourceRecordId);

                CurrencyCode accountingCurrencyLocal = accountingCurrency;
                CurrencyCode reportingCurrencyLocal = Ledger::reportingCurrency();

                if (TaxIntegrationBankOrTaxSpecificExchangeRateIntercompanyFlight::instance().isEnabled() && sourceTableId == tableNum(LedgerJournalTrans))
                {
                    LedgerJournalTrans ledgerJournalTransLocal = taxableLineCurrentlyBeingCalculated.getSourceLine() as LedgerJournalTrans;

                    if (ledgerJournalTransLocal.Company && ledgerJournalTransLocal.Company != curExt())
                    {
                        LegalEntity legalEntityRecId = ledgerJournalTransLocal.getCompanyLegalEntity();
                        accountingCurrencyLocal = Ledger::accountingCurrency(legalEntityRecId);
                        reportingCurrencyLocal = Ledger::reportingCurrency(legalEntityRecId);
                    }
                }

                accountingExchangeRate = this.getTaxSpecificExchangeRate(accountingCurrencyLocal, taxSpecificExchangeRateMapLoc);
                reportingExchangeRate = this.getTaxSpecificExchangeRate(reportingCurrencyLocal, taxSpecificExchangeRateMapLoc);
            }
            else
            {
                if (isNeedCalculateTaxDiffAmount)
                {
                    salesTaxTransactionExchangeRate = SalesTaxTransactionExchangeRate::findBySourceRecord(sourceTableId, sourceRecordId);

                    if (salesTaxTransactionExchangeRate)
                    {
                        dateOfVATRegister = salesTaxTransactionExchangeRate.DateOfVATRegister;
                        taxExchangeRate = salesTaxTransactionExchangeRate.SalesTaxExchangeRate;

                        if (taxExchangeRate == this.parmExchRate())
                        {
                            exchangeRateIsSame = true;
                        }
                    }
                    else
                    {
                        dateOfVATRegister = this.parmTaxDate();
                        taxExchangeRate = this.parmExchRate();
                        exchangeRateIsSame = true;
                        SalesTaxExchangeRateHelper::saveSalesTaxTransactionExchangeRate(sourceTableId, sourceRecordId,
                        this.getTransactionalCurrency(), taxExchangeRate, dateOfVATRegister);
                    }
                }
            }

            if (isNeedCalculateTaxDiffAmount || isTaxSpecificExchRateEnabledByBusinessProcess)
            {
                while select forupdate taxWorkTrans
                    where taxWorkTrans.SourceRecId == sourceRecordId
                {
                    if (isTaxSpecificExchRateEnabledByBusinessProcess)
                    {
                        taxWorkTrans.VatDueDate_W = dateOfVATRegister;
                        taxWorkTrans.SalesTaxExchangeRate = accountingExchangeRate;
                        taxWorkTrans.SalesTaxExchangeRateRep = reportingExchangeRate;
                        taxWorkTrans.SalesTaxExchangeRateCur = this.getTaxSpecificExchangeRate(taxWorkTrans.CurrencyCode, taxSpecificExchangeRateMapLoc);

                        this.updateTaxDifferenceAmount(taxWorkTrans);
                        this.updateTaxDifferenceAmountRep(taxWorkTrans);
                        this.updateTaxDifferenceAmountCur(taxWorkTrans);
                    }
                    else
                    {
                        taxWorkTrans.VatDueDate_W = dateOfVATRegister;
                        taxWorkTrans.SalesTaxExchangeRate = taxExchangeRate;

                        LedgerJournalTrans ledgerJournalTrans = taxableLineCurrentlyBeingCalculated.getSourceLine() as LedgerJournalTrans;

                        if (LedgerJournalTrans_W_Extension::isAutomaticDateDeterminationEnabled(ledgerJournalTrans)
                        && this.headingTableId() == tableNum(LedgerJournalTable))
                        {
                            ///On the current <b>Accounts Receivable</b> invoice. In case of CountryRegion Poland(PL), if the Accounts Receivable Parameter
                            ///"Exchange Rate Date" is set as automatic date determination, we bypass the bank exchange rate functionality.
                            taxWorkTrans.SalesTaxExchangeRate = this.parmExchRate();
                            taxWorkTrans.ExchangeRateTaxBaseAmount = taxWorkTrans.TaxBaseAmount;
                            taxWorkTrans.ExchangeRateTaxAmount = taxWorkTrans.TaxAmount;
                            SalesTaxExchangeRateHelper::saveSalesTaxTransactionExchangeRate(this.headingTableId(), this.headingRecId(),
                            this.getTransactionalCurrency(), taxWorkTrans.SalesTaxExchangeRate, taxWorkTrans.VatDueDate_W);
                        }
                        else if (exchangeRateIsSame)
                        {
                            taxWorkTrans.ExchangeRateTaxBaseAmount = taxWorkTrans.TaxBaseAmount;
                            taxWorkTrans.ExchangeRateTaxAmount = taxWorkTrans.TaxAmount;
                        }
                        else
                        {
                            this.updateTaxDifferenceAmount(taxWorkTrans);
                        }
                    }

                    taxWorkTrans.update();
                }
            }

            linesExist = taxableDocument.getNextLine();
        }

        taxableLineCurrentlyBeingCalculated = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTaxForLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates taxes for a transaction line.
    /// </summary>
    /// <returns>
    /// The tax amount, excluding the use tax for the transaction line.
    /// </returns>
    protected TaxAmount calculateTaxForLine()
    {
        TaxAmount ret;

         // <GEEU>
        SalesTaxTransactionExchangeRate salesTaxTransactionExchangeRate;
        TransactionType                 transactionType;
        // </GEEU>

        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            return 0;
        }

        TaxCode taxCode = taxableLineCurrentlyBeingCalculated.getTaxCode();
        if (taxCode)
        {
            if (TaxTable::exist(taxCode))
            {
                this.configureTaxForLine(taxableLineCurrentlyBeingCalculated); 
                ret = this.saveTaxTransfer(taxableLineCurrentlyBeingCalculated);
            }
            else
            {
                throw error(strFmt("@SYS21976", taxCode));
            }
            taxableDocumentLines++;
        }
        else
        {
            taxWorkTrans.clear();
            ret = super();
        }

        // <GEEU>
        CurrencyCode accountingCurrencyLocal = this.parmAccountingCurrency();
        if (TaxSalesTaxExchangeRateSpecificLegalEntity_PLFlight::instance().isEnabled())
        {
            LedgerJournalTrans ledgerJournalTrans = taxableLineCurrentlyBeingCalculated.getSourceLine() as LedgerJournalTrans;

            if (ledgerJournalTrans.Company && ledgerJournalTrans.Company != curExt())
            {
                accountingCurrencyLocal = Ledger::accountingCurrency(ledgerJournalTrans.getCompanyLegalEntity());
            }
        }
        if (this.sourceRecId() &&
            this.parmUseTaxExchangeRate() &&
            accountingCurrencyLocal != this.getTransactionalCurrency())
        {
            salesTaxTransactionExchangeRate = SalesTaxTransactionExchangeRate::findBySourceRecord(this.sourceTableId(), this.sourceRecId());
            boolean isVATDueDateModified = false;
            if (TaxUpdateBankExchRateWhenVATDueDateModifiedFlight::instance().isEnabled() && salesTaxTransactionExchangeRate)
            {
                LedgerJournalTrans ledgerJournalTrans = taxableLineCurrentlyBeingCalculated.getSourceLine() as LedgerJournalTrans;
                isVATDueDateModified = ledgerJournalTrans.VatDueDate_W != salesTaxTransactionExchangeRate.DateOfVATRegister;
            }

            if (!salesTaxTransactionExchangeRate || isVATDueDateModified)
            {
                select firstonly taxWorkTrans
                    where taxWorkTrans.TaxDirection == TaxDirection::IncomingTax ||
                        taxWorkTrans.TaxDirection == TaxDirection::UseTax;

                if (taxWorkTrans)
                {
                    transactionType = TransactionType::Purchase;
                }
                else
                {
                    transactionType = TransactionType::Sales;
                }

                SalesTaxExchangeRateHelper::maintainSalesTaxTransactionExchangeRate(taxableLineCurrentlyBeingCalculated.getSourceLine(),
                    this.currencyCode(), transactionType, taxDate);
            }
        }
        // </GEEU>

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>capitalGoodsAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns invoiceAmount to post for Vat transactions with capitalGoodsAmount
    /// </summary>
    /// <returns>invoice Amount</returns>
    public Amount capitalGoodsAmount_IN()
    {
        boolean                 calcTaxOnOffset = true;
        LedgerJournalTaxLine    taxLine;
        LedgerJournalTrans      ledgerJournalTransVAT = taxableLineCurrentlyBeingCalculated.getSourceLine();

        if (taxableLineCurrentlyBeingCalculated is LedgerJournalTaxLine)
        {
            taxLine = taxableLineCurrentlyBeingCalculated as LedgerJournalTaxLine;
        }

        if (!taxLine.isOffsetBeingCalculated())
        {
            calcTaxOnOffset = false;
        }
        if (ledgerJournalTransVAT.OffsetLedgerDimension && !ledgerJournalTransVAT.Prepayment)
        {
            if (ledgerJournalTransVAT.OffsetAccountType != LedgerJournalACType::Cust &&
                ledgerJournalTransVAT.OffsetAccountType != LedgerJournalACType::Vend &&
                ledgerJournalTransVAT.OffsetAccountType != LedgerJournalACType::Bank)
            {
                if (calcTaxOnOffset && ledgerJournalTransVAT.AmountCurCredit)
                {
                    this.parmAmountCurCrVat_IN(ledgerJournalTransVAT.AmountCurCredit);
                    ledgerJournalTransVAT.AmountCurDebit  = this.parmAmountCurCrVat_IN();
                    ledgerJournalTransVAT.AmountCurCredit = ledgerJournalTransVAT.AmountCurDebit;
                }
            }
        }
        return ledgerJournalTransVAT.amount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIntersection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides the default implementation of an error condition that occurs when the tax groups are
    /// intersected.
    /// </summary>
    /// <param name="_found">
    /// A Boolean value that indicates whether tax codes that match were found in both the tax group and
    /// the item tax group.
    /// </param>
    /// <param name="_taxGroup">
    /// The tax group from the transaction line.
    /// </param>
    /// <param name="_taxItemGroup">
    /// The item tax group from the transaction line.
    /// </param>
    /// <returns>
    /// true if this is a supported tax scenario; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Subclasses may provide transaction-specific implementations of this method.
    /// </remarks>
    protected boolean checkIntersection(boolean _found, TaxGroup _taxGroup, TaxItemGroup _taxItemGroup)
    {
        boolean ret = false;
        boolean isPayment = false;

        isPayment = taxableDocument.isPayment();

        if (!isPayment || (isPayment && this.isPrePayment()))
        {
            ret = super(_found, _taxGroup, _taxItemGroup);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>configureTaxForLine</Name>
				<Source><![CDATA[
    protected void configureTaxForLine(TaxableLine _taxableLine)
    {
        // <GEEU>
        LedgerJournalTrans ledgerJournalTrans;

        if (TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
        {
            ledgerJournalTrans = _taxableLine.getSourceLine();
            this.parmVatRegData_W(this.vatRegData_W(ledgerJournalTrans));
        }
        
        ledgerJournalTrans = _taxableLine.getSourceLine();
        this.setReasonTableRefRecIdBeingCalculated(ledgerJournalTrans.ReasonRefRecID);

        // </GEEU>
        super(_taxableLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineDirection</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the default tax direction for the transaction.
    /// </summary>
    /// <param name="_taxGroupData">
    ///    The <c>TaxGroupData</c> table buffer that represents the tax code being considered.
    /// </param>
    /// <returns>
    ///    The default tax direction.
    /// </returns>
    /// <remarks>
    ///    A customer transaction will typically have a tax direction of Sales Tax Payable.A vendor-facing
    ///    transaction will typically have a tax direction of Sales Tax Receivable.
    /// </remarks>
    protected TaxDirection determineDirection(TaxGroupData _taxGroupData)
    {
        return taxableLineCurrentlyBeingCalculated.getDefaultTaxDirection(_taxGroupData, this.getCompany());
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defines exchange rate.
    /// </summary>
    /// <returns>
    /// Echange rate value.
    /// </returns>

    public ExchRate exchRate()
    {
        if (exchRate)
        {
            return exchRate;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRateSecondary</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defines exchange rate for secondary currency.
    /// </summary>
    /// <returns>
    /// Echange rate value for secondary currency.
    /// </returns>

    public ExchrateSecondary exchRateSecondary()
    {
        if (exchRateSecond)
        {
            return exchRateSecond;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>finalizeCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finalizes tax calculations by processing tax adjustments and optionally inserting records into the
    ///    <c>TaxUncommitted</c> and <c>SourceDoucmentLine</c> tables.
    /// </summary>
    /// <param name="_calculateTaxDifferenceAmount">
    ///    true if tax difference amount need to be calculated; optional.
    /// </param>
    /// <param name="_doIsolateTransactionScope">
    /// true if <c>TaxUncommitted</c> should be maintained in a independent transaction scope; otherwise false.
    /// </param>
    /// <returns>
    ///    The final tax total amount.
    /// </returns>
    protected TaxAmountCur finalizeCalculation(
        boolean _calculateTaxDifferenceAmount = true,
        boolean _doIsolateTransactionScope = false)

    {
        TaxAmountCur    taxAmount;

        taxAmount = super(_calculateTaxDifferenceAmount, _doIsolateTransactionScope);

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the company.
    /// </summary>
    /// <returns>
    ///    The company to which the tax amount for this transaction line applies.
    /// </returns>
    public selectableDataArea getCompany()
    {
        // This override should be deleted as it isn't required on this class.
        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the default dimension.
    /// </summary>
    /// <param name="_sourceRecId">
    /// The record Id of the parent of the tax line.
    /// </param>
    /// <returns>
    ///  A <c>DimensionDefault</c> value.
    /// </returns>
    public DimensionDefault getDefaultDimension(RefRecId _sourceRecId)
    {
        DimensionDefault ret;

        Debug::assert(taxableDocument != null);

        ret = super(_sourceRecId);  //this will set ret to zero in Tax class, this is correct when .useSubLedgerJournalLines() is true.

        if (!this.useSubLedgerJournalLines())
        {
            if (_sourceRecId)
            {
                ret = taxableDocument.getLineByRecId(_sourceRecId).getDefaultDimension();
            }
            else
            {
                ret = taxableLineCurrentlyBeingCalculated.getDefaultDimension();
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes this instance.
    /// </summary>
    /// <param name="_initializationClass">
    ///    The <c>TaxCalculationJournal</c> object is the journal-specific class that contains the transaction
    ///    lines and other information tax requires to calculate taxes.
    /// </param>
    public void init(Object _initializationClass)
    {
        super(_initializationClass);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTaxForLine</Name>
				<Source><![CDATA[
    protected TaxAmountCur initializeTaxForLine(boolean _amountInclTax, TaxBase _baseAmount, TaxBase _baseAmountIncludingTax, DimensionDefault _dimensionDefault, LedgerDimensionAccount _operationLedgerDimension, LedgerPostingType _ledgerPostingType, TaxBase _unitAmount = 0, ItemId _itemId = '', Qty _quantity = 0, UnitOfMeasureSymbol _baseUnit = '', ExchRate _exchRate_W = 0, VatDueDate_W _vatDueDate_W = dateNull())
    {
        TaxAmountCur ret;
        LedgerJournalTrans ledgerJournalTrans = taxableLineCurrentlyBeingCalculated.getSourceLine();

        ret = super(_amountInclTax,
                    _baseAmount,
                    _baseAmountIncludingTax,
                    _dimensionDefault,
                    _operationLedgerDimension,
                    _ledgerPostingType,
                    _unitAmount,
                    _itemId,
                    _quantity,
                    '',
                    0,
                    ledgerJournalTrans.VatDueDate_W
                    );

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertIntersection</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method calls base implementation of the method and updates tax transactions for Tax agent.
    /// </summary>
    /// <param name="_taxGroup">
    /// Tax group.
    /// </param>
    /// <param name="_taxItemGroup">
    /// Tax item group.
    /// </param>
    /// <param name="_inventTransId">
    /// Inventory trans identificator.
    /// </param>
    /// <param name="_txt">
    /// Text of transaction.
    /// </param>
    /// <param name="_taxCalculationDate">
    /// Calculation date.
    /// </param>
    /// <param name="_invoiceId">
    /// Invoice identification.
    /// </param>
    /// <param name="_gsthstTaxType_CA">
    /// GST/HST tax type.
    /// </param>

    protected void insertIntersection(TaxGroup               _taxGroup,
                                      TaxItemGroup           _taxItemGroup,
                                      InventTransId          _inventTransId,
                                      TransactionTextLarge   _txt,
                                      TransDate              _taxCalculationDate,
                                      InvoiceId              _invoiceId        = '',
                                      GSTHSTTaxType_CA       _gsthstTaxType_CA = GSTHSTTaxType_CA::None)
    {
        // <GEERU>
        LedgerJournalTaxLine taxLine;
        if (taxableLineCurrentlyBeingCalculated is LedgerJournalTaxLine)
        {
            taxLine = taxableLineCurrentlyBeingCalculated as LedgerJournalTaxLine;
        }
        // </GEERU>
        super(_taxGroup, _taxItemGroup, _inventTransId, _txt, _taxCalculationDate, _invoiceId, _gsthstTaxType_CA);
        // <GEERU>
        if (resetExemptTax_RU ||
            (taxLine && taxLine.isVatTaxAgentPrepayment_RU()))
        {
            this.updateVATTaxAgentFields_RU(taxLine, taxLine.isVatTaxAgentPrepayment_RU());
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventProfileTaxTrans_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Identifies whether tax transactions should be created.
    /// </summary>
    /// <returns>
    /// True is tax transactions should be created; otherwise false.
    /// </returns>
    protected boolean inventProfileTaxTrans_RU()
    {
        boolean ret;
        LedgerJournalTrans ledgerJournalTrans = taxableLineCurrentlyBeingCalculated.getSourceLine();

        ret = super() && ! ledgerJournalTrans.isNonTaxablePrepayment_RU();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalNum</Name>
				<Source><![CDATA[
    LedgerJournalId journalNum()
    {
        //JournalNum is not found on the interface TaxableDocument because
        //we are working towards removing it from Tax completely.

        LedgerJournalTable ledgerJournalTable;

        ledgerJournalTable = taxableDocument.getSourceHeader();

        return ledgerJournalTable.JournalNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerDimension_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets ledger dimension to be used in tax posting
    /// </summary>
    /// <param name="_tmpTaxWorkTrans">
    /// <c>TmpTaxWorkTrans</c> record ledger dimension calculated for
    /// </param>
    /// <param name="_taxLedgerAccountGroup">
    /// <c>TaxLedgerAccountGroup</c> to be processed
    /// </param>
    /// <returns>
    /// Ledger dimension to be used in tax posting
    /// </returns>
    protected LedgerDimensionDefaultAccount ledgerDimension_RU(TmpTaxWorkTrans       _tmpTaxWorkTrans,
                                                               TaxLedgerAccountGroup _taxLedgerAccountGroup)
    {
        LedgerJournalTrans              ledgerJournalTrans = taxableLineCurrentlyBeingCalculated.getSourceLine();

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) &&
            ledgerJournalTrans.AccountType == LedgerJournalACType::Vend  &&
            ledgerJournalTrans.Prepayment)
        {
            if (ledgerJournalTrans.isVatTaxAgentPrepayment_RU())
            {
                if (TaxTable::find(_tmpTaxWorkTrans.TaxCode).vatChargeSource_RU == VATChargeSource_RU::VendorFunds)
                {
                    return VendLedgerAccounts::summaryLedgerDimension(ledgerJournalTrans.parmAccount(), ledgerJournalTrans.PostingProfile);
                }
            }
            else
            {
                return _taxLedgerAccountGroup.TaxIncomingPaymentLedgerDimension_RU;
            }
        }

        return super(_tmpTaxWorkTrans, _taxLedgerAccountGroup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadFromTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads tax records from the <c>TaxUncommitted</c> table into the <c>TmpTaxWorkTrans</c> table.
    /// </summary>
    protected void loadFromTaxUncommitted()
    {
        taxWorkTrans.loadFromTaxUncommittedForDocumentAndInvo(this.headingTableId(), headingRecId, taxableDocument.getReferenceNumber(), taxableDocument.getInvoiceId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAmountCurCrVat_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns invoiceAmount to post for Vat capitalGoodsAmount transactions for jounals
    /// </summary>
    /// <param name="_amountCurCrVat">invoice amount for VAT capital goods transactions</param>
    /// <returns>invoice amount</returns>
    public AmountCur parmAmountCurCrVat_IN(AmountCur _amountCurCrVat = amountCurCrVat)
    {
        amountCurCrVat = _amountCurCrVat;
        return amountCurCrVat;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInclTax_IN</Name>
				<Source><![CDATA[
    public boolean parmInclTax_IN(boolean _inclTax = inclTax)
    {
        inclTax = _inclTax;
        return inclTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmResetExemptTax_RU</Name>
				<Source><![CDATA[
    public boolean parmResetExemptTax_RU(boolean _value = resetExemptTax_RU)
    {
        resetExemptTax_RU = _value;
        return resetExemptTax_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveTaxTransfer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a <c>TmpTaxWorkTrans</c> record that represents a tax transfer.
    /// </summary>
    /// <param name="_taxableLine">
    ///    The transaction line that represents this tax transfer.
    /// </param>
    /// <returns>
    ///    The tax amount for this tax transfer.
    /// </returns>
    protected TaxAmountCur saveTaxTransfer(TaxableLine _taxableLine)
    {
        this.initTaxWorkTrans(_taxableLine);
        taxWorkTrans.insert();

        return taxWorkTrans.SourceTaxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLedgerDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines what the accounts should be for the <c>TmpTaxWorkTrans</c> record.
    /// </summary>
    /// <param name="_taxWorkTrans">
    ///    The <c>TmpTaxWorkTrans</c> table buffer.
    /// </param>
    /// <param name="_taxTable">
    ///    The <c>TaxTable</c> table buffer.
    /// </param>
    /// <param name="_dimensionDefault">
    ///    The default dimensions.
    /// </param>
    /// <param name="_operationLedgerDimension">
    ///    The default operation ledger dimension.
    /// </param>
    protected void setLedgerDimensions(TmpTaxWorkTrans _taxWorkTrans, TaxTable _taxTable, DimensionDefault _dimensionDefault, LedgerDimensionAccount _operationLedgerDimension)
    {
        LedgerJournalTrans ledgerJournalTrans;
        LedgerJournalTrans_Asset ledgerJournalTrans_Asset;
        LedgerDimensionAccount ledgerDimension;
        LedgerDimensionDefaultAccount ledgerDimensionDefaultAccount;

        super(_taxWorkTrans, _taxTable, _dimensionDefault, _operationLedgerDimension);

        ledgerJournalTrans = taxableLineCurrentlyBeingCalculated.getSourceLine() as LedgerJournalTrans;

        if (this.taxParameters().PurchTaxOnOperations && _taxWorkTrans.TaxDirection == TaxDirection::IncomingTax)
        {
            if (ledgerJournalTrans.isFixedAssetsTransaction() && ledgerJournalTrans.RecId)
            {
                ledgerJournalTrans_Asset = ledgerJournalTrans.findLedgerJournalTransAssetSibling();
                if (ledgerJournalTrans_Asset)
                {
                    ledgerDimensionDefaultAccount = LedgerJournalEngine::getDefaultAccount(ledgerJournalTrans, ledgerJournalTrans_Asset);
                    ledgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimensionDefaultAccount, _dimensionDefault);
                }
            }
            else if (ledgerJournalTrans.isProjectTransaction() && ledgerJournalTrans.RecId)
            {
                ledgerDimensionDefaultAccount = LedgerJournalEngine::getDefaultAccount(ledgerJournalTrans, null);
                ledgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimensionDefaultAccount, _dimensionDefault);
            }

            if (ledgerDimension)
            {
                _taxWorkTrans.LedgerDimension = ledgerDimension;
                _taxWorkTrans.OperationLedgerDimension = ledgerDimension;
            }
            else
            {
                _taxWorkTrans.LedgerDimension = _taxWorkTrans.OperationLedgerDimension;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPrepaymentExchRates_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets exchange rates for prepayments
    /// </summary>
    /// <param name="_exchRate">
    /// Exchange rate for accounting currency
    /// </param>
    /// <param name="_exchrateSecondary">
    /// Exchange rate for reporting currency
    /// </param>
    public void setPrepaymentExchRates_RU(ExchRate _exchRate, ExchrateSecondary _exchrateSecondary)
    {
        exchRate        = _exchRate;
        exchRateSecond  = _exchrateSecondary;
        useExchRates_RU = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipTaxCalculations</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determins if taxes need to be calculated.
    /// </summary>
    /// <returns>
    ///     Return False if the taxes need to be calculated for the source document; otherwise, return false.
    /// </returns>
    public boolean skipTaxCalculations()
    {
        boolean ret;

        ret = super();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes all of the <c>TaxUncommitted</c> records for the current document, voucher, and invoice.
    /// </summary>
    /// <param name="_doIsolateTransactionScope">
    /// true if <c>TaxUncommitted</c> should be maintained in a independent transaction scope; otherwise false.
    /// </param>
    /// <remarks>
    /// For the journals, the current document may actually contain multiple tax documents; therefore, we
    /// must override the default behavior so that only the current tax document is deleted.
    /// </remarks>
    public void updateTaxUncommitted(boolean _doIsolateTransactionScope = false)
    {
        if (useTaxUncommitted)
        {
            if (maintainExistingTaxUncommitted)
            {
                TaxUncommitted::maintainTaxUncommitted(this, _doIsolateTransactionScope); 
            }
            else
            {
                if (TaxUncommitted::existByDocumentAndInvoice(taxableDocument.getSourceHeader().TableId, taxableDocument.getSourceHeader().RecId, taxableDocument.getReferenceNumber(), taxableDocument.getInvoiceId()))
                {
                    TaxUncommitted::deleteForInvoice(taxableDocument.getSourceHeader().TableId, taxableDocument.getSourceHeader().RecId, taxableDocument.getReferenceNumber(), taxableDocument.getInvoiceId());
                }
            }
            // <GIN>
            if (isIndiaCountryRegionEnabled)
            {
                TaxCalculationJournal::resetTaxUncommittedForAdjustment_IN(taxableDocument, salesPurchJournalLineLoc);
            }
            // </GIN>
            boolean skipExistsCheckFalse = false;
            TaxUncommitted::createTaxUncommitted(this, skipExistsCheckFalse, _doIsolateTransactionScope); 
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateVATTaxAgentFields_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates VAT tax agent related fields in tax Work Trans
    /// </summary>
    /// <param name="_line">
    /// <c>LedgerJournalTaxLine</c> object
    /// </param>
    /// <param name="setIncomingTaxDirection">
    /// Determines whether tax direction should be set to incoming tax
    /// </param>
    protected void updateVATTaxAgentFields_RU(LedgerJournalTaxLine _line, boolean setIncomingTaxDirection = false)
    {
        LedgerJournalTrans trans = _line.getJournalizedLine();

        if (setIncomingTaxDirection)
        {
            update_recordset taxWorkTrans
                setting ExemptTax = NoYes::No,
                        vatOperationCode_RU = trans.vatOperationCode_RU,
                        vatTaxAgentVendAccount_RU = trans.parmAccount(),
                        TaxDirection = TaxDirection::IncomingTax
                where taxWorkTrans.HeadingRecId == headingRecId
                    && taxWorkTrans.HeadingTableId == headingTableId
                    && taxWorkTrans.SourceTableId == this.sourceTableId()
                    && taxWorkTrans.SourceRecId == this.sourceRecId();
        }
        else
        {
            update_recordset taxWorkTrans
                setting ExemptTax = NoYes::No,
                        vatOperationCode_RU = trans.vatOperationCode_RU,
                        vatTaxAgentVendAccount_RU = trans.parmAccount()
                where taxWorkTrans.HeadingRecId == headingRecId
                    && taxWorkTrans.HeadingTableId == headingTableId
                    && taxWorkTrans.SourceTableId == this.sourceTableId()
                    && taxWorkTrans.SourceRecId == this.sourceRecId();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>useSalesTaxAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a Boolean value that indicates whether the current transaction being calculated supports
    /// sales tax adjustments.
    /// </summary>
    /// <returns>
    /// true if the current transaction supports sales tax adjustment; otherwise, false.
    /// </returns>
    /// <remarks>
    /// By default, the current transaction does not support sales tax adjustments.
    /// </remarks>
    public boolean useSalesTaxAdjustments()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vatOperationCode_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns VAT operation code value for currently calculated <c>LedgerJournalTrans</c> line
    /// </summary>
    /// <returns>
    /// VAT operation code value for currently calculated <c>LedgerJournalTrans</c> line
    /// </returns>
    protected VATOperationCode_RU vatOperationCode_RU()
    {
        LedgerJournalTrans    ledgerJournalTrans = taxableLineCurrentlyBeingCalculated.getSourceLine();

        return ledgerJournalTrans.vatOperationCode_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetTaxUncommittedForAdjustment_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// When service tax is adjusted in journals, the TaxUncommitted records should be cleared to enable
    /// the creation of taxes after adjustment. Since service tax adjustment used related voucher, standard logic wont work for us.
    /// </summary>
    /// <param name="_taxableDocument">
    /// The passed in object - TaxableDocument
    /// </param>
    /// <param name="_salesPurchJournalLine">
    /// The passed in MAP - SalesPurchJournalLine
    /// </param>

    public static void resetTaxUncommittedForAdjustment_IN(
        TaxableDocument          _taxableDocument,
        SalesPurchJournalLine    _salesPurchJournalLine)
    {
        TaxTable          taxTableServTax;
        TaxWorkRegulation taxWorkRegulation;
        TaxUncommitted    taxUncommittedServTax;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])
            && _taxableDocument.isPayment()
            && TaxParameters::isServiceTaxEnable_IN()
            && _salesPurchJournalLine.SourceRecId)
        {
            ttsbegin;
            delete_from taxUncommittedServTax
                where taxUncommittedServTax.SourceRecId       == _salesPurchJournalLine.SourceRecId
                    && taxUncommittedServTax.SourceTableId    == _salesPurchJournalLine.SourceTableId
                    // For the service tax record, whse voucher is different from incoming payment voucher. Ie, related voucher
                    && taxUncommittedServTax.Voucher          != _taxableDocument.getReferenceNumber()
                    && taxUncommittedServTax.InvoiceId        == _taxableDocument.getInvoiceId()
                    && taxUncommittedServTax.Source           == TaxModuleType::Voucher
            exists join  taxTableServTax
                where taxTableServTax.TaxCode     == taxUncommittedServTax.TaxCode
                    && taxTableServTax.TaxType_IN == TaxType_IN::ServiceTax
            exists join taxWorkRegulation
                where taxWorkRegulation.HeadingRecId   == _salesPurchJournalLine.SourceRecId
                   && taxWorkRegulation.HeadingTableId == _salesPurchJournalLine.SourceTableId
                   && taxWorkRegulation.TaxRegulationAmountCur != 0;
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>emptyBaseForOutgoingTax_W</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Indicates, that tax base amount should not be calculated for inverted outgoing tax transactions
    ///   for reverse charge.
    /// </summary>
    /// <param name="_taxGroupData">
    ///   <c>TaxGroupData</c> record related to current tax calculation.
    /// </param>
    /// <returns>
    ///   True, if tax base must be ignored by UK VAT 100 report; Otherwise, false.
    /// </returns>
    protected NoYes emptyBaseForOutgoingTax_W(TaxGroupData _taxGroupData)
    {
        LedgerJournalTrans              ledgerJournalTrans = taxableLineCurrentlyBeingCalculated.getSourceLine();
        ReverseChargeRule_W             rule;
        CountryRegionType               countryRegionType;
        ReverseChargeDocumentType_W     reverseChargeDocumentType;

        if (_taxGroupData.ReverseCharge_W && TaxTable::find(_taxGroupData.TaxCode).NegativeTax)
        {
            if (FeatureStateProvider::isFeatureEnabled(TaxEmptyOutgoingTaxBaseFeature::instance()))
            {
                if ((ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::VendInvoiceRegister
                    || ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::Daily)
                    && ( ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger
                        || ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets
                        || ledgerJournalTrans.AccountType == LedgerJournalACType::Project)
                    && !ledgerJournalTrans.OffsetLedgerDimension)
                {
                    ledgerJournalTrans = this.findPartyLedgerJournalTrans(ledgerJournalTrans);
                }
            }

            if (ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
            {
                countryRegionType = IntrastatCountryRegionParameters::getCountryRegionType(CustTable::find(ledgerJournalTrans.parmAccount()).postalAddress());
                reverseChargeDocumentType = ReverseChargeDocumentType_W::CustInvoiceJournal;
            }
            else if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust)
            {
                countryRegionType = IntrastatCountryRegionParameters::getCountryRegionType(CustTable::find(ledgerJournalTrans.parmOffsetAccount()).postalAddress());
                reverseChargeDocumentType = ReverseChargeDocumentType_W::CustInvoiceJournal;
            }
            else if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
            {
                countryRegionType = IntrastatCountryRegionParameters::getCountryRegionType(VendTable::find(ledgerJournalTrans.parmAccount()).postalAddress());
                reverseChargeDocumentType = ReverseChargeDocumentType_W::VendInvoiceJournal;
            }
            else if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
            {
                countryRegionType = IntrastatCountryRegionParameters::getCountryRegionType(VendTable::find(ledgerJournalTrans.parmOffsetAccount()).postalAddress());
                reverseChargeDocumentType = ReverseChargeDocumentType_W::VendInvoiceJournal;
            }
        
            if (this.emptyBaseForOutgoingTaxApplyRule_W(reverseChargeDocumentType, ledgerJournalTrans.RecId))
            {
                str featureReference = ReverseChargeTaxSetupToggle::getFeatureReference();

                if (featureReference)
                {
                    GlobalizationInstrumentationHelper::featureRun(featureReference, funcName());
                }

                select firstOnly EmptyTaxBaseForOutgoingTax from rule
                where rule.DocumentType == reverseChargeDocumentType &&
                       ((countryRegionType == CountryRegionType::Domestic &&
                           (rule.PartnerCountryRegionType == ReverseChargePartnerCountryRegionType_W::All ||
                            rule.PartnerCountryRegionType == ReverseChargePartnerCountryRegionType_W::Domestic)) ||
                        (countryRegionType == CountryRegionType::EFTA &&
                           (rule.PartnerCountryRegionType == ReverseChargePartnerCountryRegionType_W::All ||
                            rule.PartnerCountryRegionType == ReverseChargePartnerCountryRegionType_W::Foreign)) ||
                        (countryRegionType == CountryRegionType::EU &&
                           (rule.PartnerCountryRegionType == ReverseChargePartnerCountryRegionType_W::All ||
                            rule.PartnerCountryRegionType == ReverseChargePartnerCountryRegionType_W::Foreign ||
                            rule.PartnerCountryRegionType == ReverseChargePartnerCountryRegionType_W::EU)) ||
                        (countryRegionType == CountryRegionType::SpecialDomestic &&
                           (rule.PartnerCountryRegionType == ReverseChargePartnerCountryRegionType_W::All ||
                            rule.PartnerCountryRegionType == ReverseChargePartnerCountryRegionType_W::Domestic)) ||
                        (countryRegionType == CountryRegionType::ThirdCountryRegion &&
                           (rule.PartnerCountryRegionType == ReverseChargePartnerCountryRegionType_W::All ||
                            rule.PartnerCountryRegionType == ReverseChargePartnerCountryRegionType_W::Foreign ||
                            rule.PartnerCountryRegionType == ReverseChargePartnerCountryRegionType_W::ThirdCountry)));
            }
        }

        return rule.EmptyTaxBaseForOutgoingTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>emptyBaseForOutgoingTaxApplyRule_W</Name>
				<Source><![CDATA[
    private boolean emptyBaseForOutgoingTaxApplyRule_W(ReverseChargeDocumentType_W _reverseChargeDocumentType, RefRecId _ledgerJournalTransRecId)
    {
        boolean applyRule = true;
        ReverseChargeApplyContext reverseChargeApplyContext = ReverseChargeApplyContext::current();
            
        if (reverseChargeApplyContext && reverseChargeApplyContext.reverseChargeApplyContainer)
        {
            if (!_ledgerJournalTransRecId)
            {
                throw error(Error::wrongUseOfFunction(funcName()));
            }
                
            container reverseChargeApplyRuleContainer = reverseChargeApplyContext.reverseChargeApplyContainer;
            Map reverseChargeApplyRuleMap = reverseChargeApplyRuleContainer ? Map::create(reverseChargeApplyRuleContainer) : null;

            if (reverseChargeApplyRuleMap && reverseChargeApplyRuleMap.exists([_reverseChargeDocumentType, _ledgerJournalTransRecId]))
            {
                ReverseChargeApply_W curLineReverseChargeApply = reverseChargeApplyRuleMap.lookup([_reverseChargeDocumentType, _ledgerJournalTransRecId]);
                applyRule = curLineReverseChargeApply == ReverseChargeApply_W::AllLines || curLineReverseChargeApply == ReverseChargeApply_W::CurrentLine;
            }
        }

        return applyRule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPartyLedgerJournalTrans</Name>
				<Source><![CDATA[
    private LedgerJournalTrans findPartyLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTrans ledgerJournalTrans;
        select firstonly ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == _ledgerJournalTrans.JournalNum
                && ledgerJournalTrans.Voucher == _ledgerJournalTrans.Voucher
                && (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend
                    || ledgerJournalTrans.AccountType == LedgerJournalACType::Cust);
        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBaseAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the base amount.
    /// </summary>
    /// <param name = "ledgerJournalTrans">
    /// The buffer of <c>LedgerJournalTrans</c>.
    /// </param>
    /// <param name = "currencyExchangeHelper">
    /// The instance of <c>CurrencyExchangeHelper</c>.
    /// </param>
    protected void updateBaseAmount(LedgerJournalTrans      ledgerJournalTrans,
                                    CurrencyExchangeHelper  currencyExchangeHelper)
    {
        // <GEEPL>
        if (ledgerJournalTrans.TransactionType == LedgerTransType::WriteOff
             || SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            if (ledgerJournalTrans.TaxBase_W)
            {
                TaxCurrencyConversionRoutineHandler handler = TaxCurrencyConversionRoutineHandler::instance();

                taxWorkTrans.SourceBaseAmountCur = sign(taxWorkTrans.SourceTaxAmountCur)*abs(ledgerJournalTrans.TaxBase_W);
                taxWorkTrans.TaxBaseAmount       = CurrencyExchangeHelper::mstAmount(taxWorkTrans.SourceBaseAmountCur, taxWorkTrans.SourceCurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), ledgerJournalTrans.ExchRate, ledgerJournalTrans.ExchRateSecond);
                //Feature Sales Tax Conversion
                if (this.isTaxCurrencyConversionFeatureEnabled())
                {
                    taxWorkTrans.TaxBaseAmountCur = handler.transCurrencyToTaxCurrency(taxWorkTrans.SourceCurrencyCode, taxWorkTrans.CurrencyCode, taxWorkTrans.SourceBaseAmountCur,
                                                                                        taxWorkTrans.ExchRate, taxWorkTrans.ReportingCurrencyExchRate, taxDate);
                }
                else
                {
                    taxWorkTrans.TaxBaseAmountCur    = CurrencyExchangeHelper::curAmount(taxWorkTrans.TaxBaseAmount, taxWorkTrans.CurrencyCode, currencyExchangeHelper.parmExchangeDate());
                }
                taxWorkTrans.TaxBaseAmountRep = handler.transCurrencyToReportingCurrency(taxWorkTrans.SourceCurrencyCode, taxWorkTrans.SourceBaseAmountCur,
                                                                                            taxWorkTrans.ReportingCurrencyExchRate, taxDate);
            }
        }
        // </GEEPL>
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxWorkTransForTaxLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>TmpTaxWorkTrans</c> for line with tax code assigned.
    /// </summary>
    /// <param name = "_taxableLine">
    /// The transaction line that represents this tax transfer.
    /// </param>
    internal void initTaxWorkTransForTaxLine(TaxableLine _taxableLine)
    {
        this.initTaxWorkTrans(_taxableLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxWorkTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>TmpTaxWorkTrans</c>.
    /// </summary>
    /// <param name = "_taxableLine">
    /// The transaction line that represents this tax transfer.
    /// </param>
    [Hookable(true)]
    protected void initTaxWorkTrans(TaxableLine _taxableLine)
    {
        #ISOCountryRegionCodes
        LedgerJournalTaxLine          ledgerJournalTaxLine;
        TaxLedgerAccountGroup         taxLedgerAccountGroup;
        CurrencyExchangeHelper        currencyExchangeHelper;
        LedgerJournalTrans            ledgerJournalTrans;
        // <GIN>
        TaxTable                      taxTableIN;
        LedgerDimensionDefaultAccount defaultMainAccount;
        // </GIN>
        boolean                       isReverseUseTaxTransaction;
        TaxCurrencyConversionRoutineHandler handler = TaxCurrencyConversionRoutineHandler::instance();

        currencyExchangeHelper = _taxableLine.getCurrencyExchangeInformation();
        ledgerJournalTaxLine = _taxableLine as LedgerJournalTaxLine;
        ledgerJournalTrans = _taxableLine.getSourceLine();

        if (TaxConsInvoice_JP::isTaxDifferencePostingOnConsInvoiceEnabled()
            && TaxCalculationJournalClearTmpTaxWorkTransFlight::instance().isEnabled())
        {
            taxWorkTrans.clear();
        }
        taxWorkTrans.HeadingRecId          = taxableDocument.getSourceHeader().RecId;
        taxWorkTrans.HeadingTableId        = taxableDocument.getSourceHeader().TableId;
        taxWorkTrans.SourceTableId         = _taxableLine.getSourceLine().TableId;
        taxWorkTrans.SourceRecId           = _taxableLine.getSourceLine().RecId;
        taxWorkTrans.Voucher               = taxableDocument.getReferenceNumber();
        taxWorkTrans.TransDate             = currencyExchangeHelper.parmExchangeDate();
        taxWorkTrans.TaxCode               = _taxableLine.getTaxCode();
        taxWorkTrans.InvoiceId             = taxableDocument.getInvoiceId();
        taxWorkTrans.Source                = taxableDocument.getModuleType();
        taxWorkTrans.InventTransId         = '';
        taxWorkTrans.TaxDirection          = _taxableLine.getDefaultTaxDirection(null, this.getCompany());
        taxWorkTrans.TaxAutogenerated      = NoYes::Yes;
        taxWorkTrans.TaxReports            = NoYes::Yes;
        taxWorkTrans.Company               = this.getCompany();
        taxWorkTrans.CalculationDate       = _taxableLine.getTaxRateDate(this.getCompany());

        //taxWorkTrans needs the ledger account number which will be the tax account
        //Tax prefers the primary over the offset if both are Ledger accounts.
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) &&
            ledgerJournalTrans.vatTaxAgentVendAccount_RU)
        {
            taxWorkTrans.LedgerDimension = VendLedgerAccounts::summaryLedgerDimension(
                ledgerJournalTrans.parmAccount(),
                ledgerJournalTrans.PostingProfile);

            taxWorkTrans.vatOperationCode_RU       = ledgerJournalTrans.vatOperationCode_RU;
            taxWorkTrans.vatTaxAgentVendAccount_RU = ledgerJournalTrans.vatTaxAgentVendAccount_RU;
        }
        else
        {
            // </GEERU>
            if (ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger)
            {
                taxWorkTrans.LedgerDimension   = ledgerJournalTrans.LedgerDimension;
            }
            else if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
            {
                taxWorkTrans.LedgerDimension   = ledgerJournalTrans.OffsetLedgerDimension;
            }
            // <GEERU>
        }
        // </GEERU>

        // <GIN>
        if (isIndiaCountryRegionEnabled)
        {
            taxTableIN  = TaxTable::find(ledgerJournalTrans.TaxCode);
            if (taxTableIN.TaxType_IN != TaxType_IN::None
                && taxTableIN.TaxType_IN != TaxType_IN::Customs
                && ((taxTableIN.TaxType_IN == TaxType_IN::Excise && isExciseEnabled)
                    || (taxTableIN.TaxType_IN == TaxType_IN::SalesTax && isSalesTaxEnabled)
                    || (taxTableIN.TaxType_IN == TaxType_IN::ServiceTax && isServiceTaxEnabled)
                    || (taxTableIN.TaxType_IN == TaxType_IN::VAT && isVATEnabled)))
            {
                defaultMainAccount = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(ledgerJournalTrans.LedgerDimension);
                if (TaxLedgerAccounts_IN::accountRecoverableExist(defaultMainAccount, taxTableIN.TaxComponentTable_IN, taxTableIN.TaxType_IN))
                {
                    taxWorkTrans.TaxDirection = TaxDirection::IncomingTax;
                }
                else if (TaxLedgerAccounts_IN::accountPayableExist(defaultMainAccount, taxTableIN.TaxComponentTable_IN, taxTableIN.TaxType_IN))
                {
                    taxWorkTrans.TaxDirection = TaxDirection::OutgoingTax;
                }
            }
            salesPurchJournalLineLoc = ledgerJournalTrans;
            taxWorkTrans.TaxRegistrationNumberTable_IN = this.determineTaxRegistrationNumber_IN(taxTableIN.TaxType_IN);
        }
        // </GIN>

        taxWorkTrans.OperationLedgerDimension = taxWorkTrans.LedgerDimension;

        if (taxWorkTrans.TaxDirection == TaxDirection::UseTax)
        {
            changecompany(this.getCompany())
            {
                taxLedgerAccountGroup = TaxLedgerAccountGroup::find(TaxTable::find(taxWorkTrans.TaxCode).TaxAccountGroup);
            }
            
            if (ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger
                && LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(ledgerJournalTrans.LedgerDimension) == taxLedgerAccountGroup.TaxOffsetUseTaxLedgerDimension
                && ledgerJournalTrans.AmountCurDebit)
            {
                isReverseUseTaxTransaction = true;
            }

            if (!taxLedgerAccountGroup.TaxUseTaxLedgerDimension)
                taxWorkTrans.TaxOffsetUseTaxLedgerDimension = taxLedgerAccountGroup.TaxOffsetUseTaxLedgerDimension;
            else
                taxWorkTrans.TaxOffsetUseTaxLedgerDimension = taxLedgerAccountGroup.TaxUseTaxLedgerDimension;
        }

        taxWorkTrans.SourceTaxAmountCur    = ledgerJournalTaxLine.setSignBasedOnAccountType(ledgerJournalTrans, ledgerJournalTrans.amount());
        taxWorkTrans.SourceCurrencyCode    = _taxableLine.getTransactionCurrency();
        taxWorkTrans.TaxOrigin             = TaxOrigin::Transfer;

        taxWorkTrans.TaxType_BR = TaxTable::find(taxWorkTrans.TaxCode).TaxType_BR;

        //
        //  _exchRate & _exchRateSecondary are included in the parameter list to
        //  make sure that the exchange rates used on the transactions are the same
        //  ones used to calculate the tax amounts.
        //
        currencyExchangeHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));
        taxWorkTrans.TaxAmount = currencyExchangeHelper.calculateTransactionToAccounting(_taxableLine.getTransactionCurrency(), taxWorkTrans.SourceTaxAmountCur, true);

        if (ledgerJournalTrans.isCompanyIntercompany())
        {
            changeCompany(this.getCompany())
            {
                taxWorkTrans.CurrencyCode = TaxTable::find(taxWorkTrans.TaxCode).TaxCurrencyCode;
            }
        }
        else
        {
            taxWorkTrans.CurrencyCode = TaxTable::find(taxWorkTrans.TaxCode).TaxCurrencyCode;
        }

        //Feature Sales Tax Conversion
        if (this.isTaxCurrencyConversionFeatureEnabled())
        {
            //here no fixed exchRate/repExchRate provided in this method, so we use value from taxWorkTrans, and they should have correct value for journal
            taxWorkTrans.TaxAmountCur = handler.transCurrencyToTaxCurrency(_taxableLine.getTransactionCurrency(), taxWorkTrans.CurrencyCode, taxWorkTrans.SourceTaxAmountCur,
                                                                            exchRate, reportingCurrencyExchRate, currencyExchangeHelper.parmExchangeDate());
        }
        else
        {
            if (taxWorkTrans.CurrencyCode == taxWorkTrans.SourceCurrencyCode)
            {
                taxWorkTrans.TaxAmountCur = taxWorkTrans.SourceTaxAmountCur;
            }
            else
            {
                //
                //  _exchRate & _exchRateSecondary are not included in the parameter list because those exchange
                //  rates are for Transactional/Master currency - not for the tax code's currency/Master.
                //
                taxWorkTrans.TaxAmountCur = CurrencyExchangeHelper::curAmount(taxWorkTrans.TaxAmount, taxWorkTrans.CurrencyCode, currencyExchangeHelper.parmExchangeDate());
            }
        }
        taxWorkTrans.TaxAmountRep = handler.transCurrencyToReportingCurrency(_taxableLine.getTransactionCurrency(), taxWorkTrans.SourceTaxAmountCur,
                                                                                reportingCurrencyExchRate, currencyExchangeHelper.parmExchangeDate());

        this.updateBaseAmount(ledgerJournalTrans, currencyExchangeHelper);

        // <GEEU>
        if (TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
        {
            taxWorkTrans.VatDueDate_W = ledgerJournalTrans.VatDueDate_W;
        }
        // </GEEU>

        [taxWorkTrans.Reason, taxWorkTrans.ReasonComment] = this.getReasonData();

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCA]))
        {
            taxWorkTrans.gsthstTaxType_CA = ledgerJournalTrans.gsthstTaxType_CA;
        }

        // <GEEPL>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            taxWorkTrans.Addressing_PL = ledgerJournalTrans.Addressing_PL;
            taxWorkTrans.CustVendName_PL = ledgerJournalTrans.CustVendName_PL;
            taxWorkTrans.vatNum_PL = ledgerJournalTrans.vatNumJournal;
            taxWorkTrans.TaxPeriodPaymentCode_PL = ledgerJournalTrans.TaxPeriodPaymentCode_PL;
            taxWorkTrans.DocumentDate_PL = ledgerJournalTrans.DocumentDate;
        }
        // </GEEPL>

        boolean needCurrencyConversion = false;

        if (isReverseUseTaxTransaction)
        {
            TaxData taxData = TaxData::find(
                taxWorkTrans.TaxCode,
                taxWorkTrans.CalculationDate,
                taxWorkTrans.TaxBaseAmount);
            taxWorkTrans.TaxAmount          = taxWorkTrans.TaxAmount * (isReverseUseTaxTransaction ? -1 : 1);
            taxWorkTrans.TaxAmountCur       = taxWorkTrans.TaxAmountCur * (isReverseUseTaxTransaction ? -1 : 1);
            taxWorkTrans.TaxAmountRep       = taxWorkTrans.TaxAmountRep * (isReverseUseTaxTransaction ? -1 : 1);
            taxWorkTrans.SourceTaxAmountCur = taxWorkTrans.SourceTaxAmountCur * (isReverseUseTaxTransaction ? -1 : 1);

            if (TaxParameters::find().PurchTaxOnOperations)
                taxWorkTrans.TaxInCostPrice = taxWorkTrans.SourceTaxAmountCur; //transaction currency
            else
                taxWorkTrans.TaxInCostPrice = taxWorkTrans.SourceTaxAmountCur * (taxData.vatExemptPct / 100);   //transaction currency

            needCurrencyConversion = true;
        }
        else if (TaxConsInvoice_JP::isTaxDifferencePostingOnConsInvoiceEnabled(true))
        {
            if (ledgerJournalTrans.TaxCode)
            {
                LedgerJournalTransTaxExtension taxExtension = ledgerJournalTrans.ledgerJournalTransTaxExtension();

                if (taxExtension.TaxInCostPrice)
                {
                    taxWorkTrans.TaxInCostPrice = taxExtension.TaxInCostPrice;
                    needCurrencyConversion = true;
                }
            }
        }
        if (needCurrencyConversion)
        {
            //Feature Sales Tax Conversion
            if (this.isTaxCurrencyConversionFeatureEnabled())
            {
                taxWorkTrans.TaxInCostPriceMST  = CurrencyExchangeHelper::mstAmount(taxWorkTrans.TaxInCostPrice, taxWorkTrans.SourceCurrencyCode, currencyExchangeHelper.parmExchangeDate(), UnknownNoYes::Unknown);
                
                taxWorkTrans.TaxInCostPriceCur = handler.transCurrencyToTaxCurrency(taxWorkTrans.SourceCurrencyCode, taxWorkTrans.CurrencyCode, taxWorkTrans.TaxInCostPrice,
                                                                                    exchRate, reportingCurrencyExchRate, currencyExchangeHelper.parmExchangeDate());
            }
            else
            {
                if (taxWorkTrans.CurrencyCode == taxWorkTrans.SourceCurrencyCode)
                {
                    taxWorkTrans.TaxInCostPriceCur  = taxWorkTrans.TaxInCostPrice;
                    taxWorkTrans.TaxInCostPriceMST  = taxWorkTrans.TaxInCostPrice;
                }
                else
                {
                    taxWorkTrans.TaxInCostPriceMST  = CurrencyExchangeHelper::mstAmount(taxWorkTrans.TaxInCostPrice, taxWorkTrans.SourceCurrencyCode, currencyExchangeHelper.parmExchangeDate(), UnknownNoYes::Unknown);
                    taxWorkTrans.TaxInCostPriceCur  = CurrencyExchangeHelper::curAmount(taxWorkTrans.TaxInCostPriceMST, taxWorkTrans.CurrencyCode, currencyExchangeHelper.parmExchangeDate());;
                }
            }
            taxWorkTrans.TaxInCostPriceRep = handler.transCurrencyToReportingCurrency(taxWorkTrans.SourceCurrencyCode, taxWorkTrans.TaxInCostPrice,
                                                                                        reportingCurrencyExchRate, currencyExchangeHelper.parmExchangeDate());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>vatRegDataForTaxIntegration_W</Name>
				<Source><![CDATA[
    internal container vatRegDataForTaxIntegration_W(LedgerJournalTrans _ledgerJournalTrans)
    {
        return this.vatRegData_W(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>vatRegData_W</Name>
				<Source><![CDATA[
    private container vatRegData_W(LedgerJournalTrans _ledgerJournalTrans)
    {
        VatDueDate_W           vatDueDateLocal = _ledgerJournalTrans.VatDueDate_W;
        DocumentDate           documentDateLocal;
        PlCustVendName         custVendNameLocal;
        VATNumJournal          vatNumJournalLocal;
        Addressing             addressingLocal;
        PlTaxPeriodPaymentCode taxPeriodPaymentCodeLocal;
        CzPostponeVAT          postponeVATLocal = NoYes::No;
        IntraComVATDueDate_W   intraComVatDueDateLocal;
        #EECountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAll))
        {
            documentDateLocal = _ledgerJournalTrans.DocumentDate;
            custVendNameLocal = _ledgerJournalTrans.CustVendName_PL;
            vatNumJournalLocal = _ledgerJournalTrans.vatNumJournal;
            addressingLocal = _ledgerJournalTrans.Addressing_PL;
            taxPeriodPaymentCodeLocal = _ledgerJournalTrans.TaxPeriodPaymentCode_PL;
            intraComVatDueDateLocal = _ledgerJournalTrans.IntraComVATDueDate_W;
        }

        return [vatDueDateLocal,
                documentDateLocal,
                custVendNameLocal,
                vatNumJournalLocal,
                addressingLocal,
                taxPeriodPaymentCodeLocal,
                postponeVATLocal,
                intraComVatDueDateLocal];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxableLineCurrentlyBeingCalculated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Parm taxable line to tax object for tax integration
    /// </summary>
    /// <param name="_taxableLine">The taxable line</param>
    /// <returns>The taxable line.</returns>
    /// <remarks>
    /// This method is specifically for Tax Service Integration.
    /// Do not use it unless you are working on Tax Service Intergation.
    /// </remarks>
    internal TaxableLine parmTaxableLineCurrentlyBeingCalculated(TaxableLine _taxableLine = taxableLineCurrentlyBeingCalculated)
    {
        taxableLineCurrentlyBeingCalculated = _taxableLine;
        return taxableLineCurrentlyBeingCalculated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxIntegrationEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether current document is supported in tax integration.
    /// </summary>
    /// <returns>Whether currrent document is supported in tax integration.</returns>
    internal boolean isTaxIntegrationEnabled()
    {
        LedgerJournalTaxDocument taxDocument = taxableDocument;
        return TaxIntegrationUtils::isTaxIntegrationEnabledForJournalType(taxDocument.getJournalType());
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>