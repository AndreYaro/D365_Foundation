<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>projStatement</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>projStatement</c> class is the base class that is used to handle any kind of project
/// statement report.
/// </summary>
class ProjStatement
{
    ProjTransPosting            projTransPosting;
    ProjTable                   projTable;
    TmpProjStatisticExcelPivot  tmpProjStatisticExcelPivot;
    ProjFundingSourceRefId      fundingSource;

    ProjWipId                   projWipId;
    ProjInvoiceProjId           projInvoiceProjId;
    ProjGroupId                 projGroupId;
    CustAccount                 custAccount;
    ProjResponsibleWorker             responsible;
    ProjResponsibleFinancialWorker    responsibleFinancial;
    ProjResponsibleSalesWorker        responsibleSales;
    ProjSort                    sorting1;
    ProjSort                    sorting2;
    ProjSort                    sorting3;
    SysDim                      department;
    ProjType                    projType;

    boolean                     clearCache;
    boolean                     rangeOnEmptyFundingSource;

    ProjId                      projId;
    ProjCategoryId              projCategoryId;
    ProjCategoryGroupId         projCategoryGroupId;
    ProjEmplItemId              projEmplItemId;
    ProjActivityNumber          projActivityNumber;

    ProjTransIdBase             transId;

    ProjTransDate               projTransDateFrom;
    ProjTransDate               projTransDateTo;
    ProjCategoryId              psaIndirectComponentCategory;

    TransDate                   ledgerTransDateFrom;
    TransDate                   ledgerTransDateTo;

    boolean                     timeMaterial;
    boolean                     fixedPrice;
    boolean                     investment;
    boolean                     cost;
    boolean                     internalProjType;
    boolean                     time;
    boolean                     summary;

    boolean                     hour;
    boolean                     revenue;
    boolean                     expenses;
    boolean                     item;
    boolean                     onAccount;

    ProjListStateId             listId;
    ProjListStateProjType       stateProjType;
    private boolean enableProjMultipleContractLinesForProjectFeature = ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled();

    boolean                     actual, budget;
    boolean                     sumStat;
    boolean                     deviation;

    QueryBuildDataSource        transDataSource;
    QueryBuildDataSource        projTableDataSource;
    QueryBuildDataSource        projCategoryGroupDataSource;
    Query                       query;
    QueryRun                    queryRun;

    ProjTransBudget             projTransBudget;

    ForecastModelId             forecastModelId;

    ProjAmountQty               amountQty;

    ProjQty             qtyA110, qtyA310,
                        qtyB100, qtyb105, qtyb110, qtyB200, qtyB205, qtyB210, qtyb300,
                        qtyC105, qtyC110, qtyC115,
                        qtyD100,
                        qtyE110,
                        tempProjQty;

    AmountMST           a100, a105, a110, a115, a120,
                        a125,       a135, a200, a205,
                        a210, a215, a220, a225, a230,
                        a235, a240, a265, a245, a250, a255,
                        a260Fee, a260Hour, a260Exp, a260Item,
                        a285Fee, a285Hour, a285Exp, a285Item,
                        a270, a300, a305,
                        a310, a315, a320, a325, a330,
                        a335, a400, a500;

    AmountMST           b100, b105, b110, b115, b120,
                        b125, b128, b130, b155, b135, b140, b145,
                        b150Fee, b150Hour, b150Exp, b150Item,
                        b175Fee, b175Hour, b175Exp, b175Item,
                        b200, b205, b210, b215,
                        b220, b225, b300, b400, b500;

    AmountMST           c100, c105, c110, c115, c120, c122, c125;

    AmountMST           d100;

    AmountMST           e100, e200, e300, e310, e320, e330, e340, e350;

    boolean             c_a100, c_a105, c_a110, c_a110Qty, c_a115, c_a120,
                        c_a125,         c_a135, c_a200, c_a205,
                        c_a210, c_a215, c_a220, c_a225, c_a230,
                        c_a235, c_a240, c_a265, c_a245, c_a250, c_a255,
                        c_a260Fee, c_a260Hour, c_a260Exp, c_a260Item,
                        c_a285Fee, c_a285Hour, c_a285Exp, c_a285Item,
                        c_a270, c_a300, c_a305,
                        c_a310, c_a310Qty,
                        c_a315, c_a320, c_a325, c_a330,
                        c_a335, c_a400, c_a500;

    boolean             c_b100,
                        c_b105, c_b105qty,
                        c_b110, c_b110Qty,
                        c_b115, c_b120,
                        c_b125, c_b128, c_b130, c_b155, c_b135, c_b140, c_b145,
                        c_b150Fee, c_b150Hour, c_b150Exp, c_b150Item,
                        c_b175Fee, c_b175Hour, c_b175Exp, c_b175Item,
                        c_b200, c_b200Qty,
                        c_b205, c_b205qty,
                        c_b210, c_b210Qty,
                        c_b215, c_b220, c_b225,
                        c_b300, c_b300Qty,
                        c_b400,
                        c_b500;

    boolean             c_c100,
                        c_c105, c_c105Qty,
                        c_c110, c_c115, c_c120, c_c122,
                        c_c125;

    boolean             c_d100, c_d100Qty;

    boolean             c_e100, c_e200, c_e300, c_e310, c_e320, c_e330, c_e340, c_e350;
    PSAProjAmountVsUnit m_eProjAmountUnit;
    str                 m_sForecastModelIds;

    ResourceRecId       projResourceRecId;
    ResourceCategoryRecId projResourceCategoryRecId;
    SMASubscriptionId   subscriptionId;
   
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>findCategoryComponentTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>psaIndirectComponentTrans</c> parameter.
    /// </summary>
    /// <param name="_transId">
    ///    The value to set.
    /// </param>
    /// <returns>
    ///    The value of the <c>psaIndirectComponentCategory</c> parameter.
    /// </returns>
    ProjCategoryId findCategoryComponentTrans(ProjTransIdBase _transId )
    {
        ProjEmplTrans projEmplTranslocal;
        PSAIndirectComponentTrans  psaIndirectComponentTrans;
        
        this.setClearCache(true);
        
        projEmplTranslocal = projEmplTrans::find(_transId);
        
        select categoryId from psaIndirectComponentTrans
            where psaIndirectComponentTrans.TransId == _transId &&
                psaIndirectComponentTrans.IndirectComponentGroup == projEmplTranslocal.PSAIndirectComponentGroup;
        
        psaIndirectComponentCategory = psaIndirectComponentTrans.CategoryId;
        
        return psaIndirectComponentCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a100_Total_Revenue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the total revenue for a particular project or for all projects that is used
    ///    on project statement reports. This method can be used to determine either the actual amount or
    ///    budgeted amount. It also caches this value so that it is not recalculated when the method is called
    ///    again.
    /// </summary>
    /// <returns>
    ///    The total revenue for a project or all projects.
    /// </returns>
    /// <remarks>
    ///    The total revenue is determined by adding the total invoiced revenue and the total accrued revenue:
    ///    <see cref="M:projStatement.A105_Invoiced_Revenue" />() + <see
    ///    cref="M:projStatement.A200_Accrued_Revenue" />()
    /// </remarks>
    AmountMST a100_Total_Revenue()
    {
        this.checkCache();

        if (! c_a100)
        {
            a100    = this.a105_Invoiced_Revenue()+this.a200_Accrued_Revenue();
            c_a100  = true;
        }

        return a100;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a105_Invoiced_Revenue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the total invoiced revenue for all the transaction types, such as hour,
    ///    item, expense, revenue, and on-account, for a particular project or for all projects that are used
    ///    on any kind of project statement report.
    /// </summary>
    /// <returns>
    ///    The total invoiced revenue for all the transaction types for a project or all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also
    ///    caches this value and does not recalculate if a value exists in the cache.  The total invoiced
    ///    revenue is determined by the following summation: <see
    ///    cref="M:projStatement.A110_Invoiced_Revenue_Hour" /> + <see
    ///    cref="M:projStatement.A115_Invoiced_Revenue_Item" /> + <see
    ///    cref="M:projStatement.A120_Invoiced_Revenue_Expenses" /> + <see
    ///    cref="M:projStatement.A125_Invoiced_Revenue_Revenue" /> + <see
    ///    cref="M:projStatement.A135_Invoiced_Revenue_OnAccount" />
    /// </remarks>
    AmountMST a105_Invoiced_Revenue()
    {
        this.checkCache();

        if (! c_a105)
        {
            a105    = this.a110_Invoiced_Revenue_Hour()+
                  this.a115_Invoiced_Revenue_Item()+
                  this.a120_Invoiced_Revenue_Expenses()+
                  this.a125_Invoiced_Revenue_Revenue()+
                  this.a135_Invoiced_Revenue_OnAccount();
            c_a105  = true;
        }

        return a105;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a110_Invoiced_Revenue_Hour</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the total revenue for all the invoiced hour transactions for a particular project or for all projects.
    /// </summary>
    /// <returns>
    ///    The total revenue for all the invoiced hour transactions for a project or all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also caches this value and does not recalculate if a value exists in the cache.
    /// </remarks>
    AmountMST a110_Invoiced_Revenue_Hour()
    {
        this.checkCache();

        if (! c_a110 && hour && this.checkHourAmount())
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Hour));

                if (this.ledgerTurnover())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjTurnover));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));

                if (this.ledgerTurnover())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjTurnover));
                }
            }

            [a110, tempProjQty] = this.getQueryValues();
            a110                = -a110;
            c_a110              = true;
        }

        return a110;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a110_Invoiced_Revenue_Hour_Qty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and retrieves the total quantity for all invoiced hour transactions for a particular
    ///    project or for all projects.
    /// </summary>
    /// <returns>
    ///    The total quantity for all invoiced hour transactions for a project or for all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to specify either the actual quantity or the budgeted quantity. It also
    ///    caches this value and does not recalculate if a value exists in the cache.
    /// </remarks>
    AmountMST a110_Invoiced_Revenue_Hour_Qty()
    {
        this.checkCache();

        if (!c_a110Qty && hour && this.checkHourQty())
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Hour));

                if (this.ledgerTurnover())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjTurnover));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));

                if (this.ledgerTurnover())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjTurnover));
                }
            }

            [a110, qtyA110] = this.getQueryValues();
            a110            = 0;
            qtyA110         = -qtyA110;
            c_a110          = false;
            c_a110Qty       = true;
        }

        return qtyA110;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a115_Invoiced_Revenue_Item</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the total revenue for all the invoiced item transactions for a particular
    ///    project or for all projects.
    /// </summary>
    /// <returns>
    ///    The total revenue for all the invoiced item transactions for a project or all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also
    ///    caches this value and does not recalculate if a value exists in the cache.
    /// </remarks>
    AmountMST a115_Invoiced_Revenue_Item()
    {
        this.checkCache();

        if (! c_a115 && item)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Item));

                if (this.ledgerTurnover())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjTurnover));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Item));

                if (this.ledgerTurnover())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjTurnover));
                }
            }

            [a115, tempProjQty] = this.getQueryValues();
            a115                = -a115;
            c_a115              = true;
        }

        return a115;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a120_Invoiced_Revenue_Expenses</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the total revenue for all of the invoiced expense transactions for a particular project or for all projects.
    /// </summary>
    /// <returns>
    ///    The total revenue for all the invoiced expense transactions for a project or all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST a120_Invoiced_Revenue_Expenses()
    {
        this.checkCache();

        if (! c_a120 && expenses)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Cost));

                if (this.ledgerTurnover())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjTurnover));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Cost));

                if (this.ledgerTurnover())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjTurnover));
                }
            }

            [a120, tempProjQty] = this.getQueryValues();
            a120                = -a120;
            c_a120              = true;
        }

        return a120;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a125_Invoiced_Revenue_Revenue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the total revenue for all the invoiced revenue transactions for a particular
    ///    project or for all projects.
    /// </summary>
    /// <returns>
    ///    The total revenue for all the invoiced revenue transactions for a project or all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or budgeted amount. It also caches
    ///    this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST a125_Invoiced_Revenue_Revenue()
    {
        this.checkCache();

        if (! c_a125 && revenue)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Revenue));

                if (this.ledgerTurnover())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjTurnover));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Revenue));

                if (this.ledgerTurnover())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjTurnover));
                }
            }

            [a125, tempProjQty] = this.getQueryValues();
            a125                = -a125;
            c_a125              = true;
        }

        return a125;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a135_Invoiced_Revenue_OnAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the total revenue for all the invoiced on-account transactions for a particular project or for all projects.
    /// </summary>
    /// <returns>
    ///    The total revenue for all the invoiced on-account transactions for a project or all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST a135_Invoiced_Revenue_OnAccount()
    {
        this.checkCache();

        if (! c_a135 && onAccount)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::OnAccount));

                if (this.ledgerTurnover())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjOnAccount));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::OnAccount));

                if (this.ledgerTurnover())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjOnAccount));
                }
            }

            [a135, tempProjQty] = this.getQueryValues();
            a135                = -a135;
            c_a135              = true;
        }

        return a135;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a200_Accrued_Revenue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the total accrued revenue for a particular project or for all projects that
    ///    are used on any kind of project statement report.
    /// </summary>
    /// <returns>
    ///    The total accrued revenue for a project or all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also
    ///    caches this value and does not recalculate it if a value exists in the cache.The total accrued
    ///    revenue is determined by the following summation:<see
    ///    cref="M:projStatement.A210_Accrued_Salesvalue" />() + <see
    ///    cref="M:projStatement.A235_Accrued_Revenue_Salesvalue_Subscrip" />() + <see
    ///    cref="M:projStatement.A240_Accrued_Revenue_Production" />() + <see
    ///    cref="M:projStatement.A265_Accrued_Revenue_Profit" />() + <see
    ///    cref="M:projStatement.A270_Accrued_Revenue_OnAccount" />()
    /// </remarks>
    AmountMST a200_Accrued_Revenue()
    {
        this.checkCache();

        if (! c_a200)
        {
            a200    = this.a210_Accrued_Salesvalue()+
                  this.a235_Accrued_Revenue_Salesvalue_Subscrip()+
                  this.a240_Accrued_Revenue_Production()+
                  this.a265_Accrued_Revenue_Profit()+
                  this.a270_Accrued_Revenue_OnAccount();
            c_a200  = true;
        }

        return a200;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a210_Accrued_Salesvalue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the total accrued revenue in sales for a particular project or for all
    ///    projects that are used on any kind of project statement report.
    /// </summary>
    /// <returns>
    ///    The total accrued revenue in sales for a project or all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also
    ///    caches this value and does not recalculate it if a value exists in the cache.  The total accrued
    ///    revenue in sales is determined by the following summation: <see
    ///    cref="M:projStatement.A215_Accrued_Revenue_Salesvalue_Hour" />() + <see
    ///    cref="M:projStatement.A220_Accrued_Revenue_Salesvalue_Item" />() + <see
    ///    cref="M:projStatement.A225_Accrued_Revenue_Salesvalue_Expenses" />() + <see
    ///    cref="M:projStatement.A230_Accrued_Revenue_Salesvalue_Revenue" />()
    /// </remarks>
    AmountMST a210_Accrued_Salesvalue()
    {
        this.checkCache();

        if (! c_a210)
        {
            a210   = this.a215_Accrued_Revenue_Salesvalue_Hour()+
                 this.a220_Accrued_Revenue_Salesvalue_Item()+
                 this.a225_Accrued_Revenue_Salesvalue_Expenses()+
                 this.a230_Accrued_Revenue_Salesvalue_Revenue();
            c_a210 = true;
        }

        return a210;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a215_Accrued_Revenue_Salesvalue_Hour</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the total accrued revenue in sales for all of the hour transactions for a particular project or for all projects.
    /// </summary>
    /// <returns>
    ///    Returns the total accrued revenue in sales for all the hour transactions for a project or all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST a215_Accrued_Revenue_Salesvalue_Hour()
    {
        this.checkCache();

        if (! c_a215 && hour && this.ledgerSalesvalue() && this.checkHourAmount())
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Hour));
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalue));
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalue));
            }

            [a215, tempProjQty] = this.getQueryValues();
            a215                = -a215;
            c_a215              = true;
        }

        return a215;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a220_Accrued_Revenue_Salesvalue_Item</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the total accrued revenue in sales for all of the item transactions for a particular project or for all projects.
    /// </summary>
    /// <returns>
    ///    The total accrued revenue in sales for all the item transactions for a project or all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST a220_Accrued_Revenue_Salesvalue_Item()
    {
        this.checkCache();

        if (! c_a220 && item && this.ledgerSalesvalue())
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Item));
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalue));
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Item));
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalue));
            }

            [a220, tempProjQty] = this.getQueryValues();
            a220                = -a220;
            c_a220              = true;
        }

        return a220;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a225_Accrued_Revenue_Salesvalue_Expenses</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the total accrued revenue in sales for all the expense transactions for a particular project or for all projects.
    /// </summary>
    /// <returns>
    ///    The total accrued revenue in sales for all the item transactions for a project or all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST a225_Accrued_Revenue_Salesvalue_Expenses()
    {
        this.checkCache();

        if (! c_a225 && expenses && this.ledgerSalesvalue())
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Cost));
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalue));
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Cost));
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalue));
            }

            [a225, tempProjQty] = this.getQueryValues();
            a225                = -a225;
            c_a225              = true;
        }

        return a225;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a230_Accrued_Revenue_Salesvalue_Revenue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the total accrued revenue in sales for all the revenue type transactions for a particular project or for all projects.
    /// </summary>
    /// <returns>
    ///    Total accrued revenue in sales for all the revenue type transactions for a project or all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST a230_Accrued_Revenue_Salesvalue_Revenue()
    {
        this.checkCache();
        // If a value exists in the cache,it does not recalculate the actual amount or budgeted amount
        if (! c_a230 && revenue && this.ledgerSalesvalue())
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Revenue));
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalue));
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Revenue));
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalue));
            }

            [a230, tempProjQty] = this.getQueryValues();
            a230                = -a230;
            c_a230              = true;
        }

        return a230;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a235_Accrued_Revenue_Salesvalue_Subscrip</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the total accrued revenue from service subscriptions on a particular project or on all projects.
    /// </summary>
    /// <returns>
    ///    The total accrued revenue from subscriptions on a project or on all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST a235_Accrued_Revenue_Salesvalue_Subscrip()
    {
        this.checkCache();

        if (! c_a235 && revenue && this.ledgerSalesvalue())
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Revenue));
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjAccruedRevenueSubscription));
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Revenue));
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjAccruedRevenueSubscription));
            }

            [a235, tempProjQty] = this.getQueryValues();
            a235                = -a235;
            c_a235              = true;
        }

        return a235;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a240_Accrued_Revenue_Production</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calls the <see cref="M:projStatement.A260_Accrued_Revenue_Production_Revenue" /> method, which is
    ///    used to calculate and return the total accrued revenue from production on a particular project or
    ///    on all projects.
    /// </summary>
    /// <returns>
    ///    The total accrued revenue from production on a project or on all projects.
    /// </returns>
    /// <remarks>
    ///    This method caches the value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST a240_Accrued_Revenue_Production()
    {
        this.checkCache();

        if (! c_a240)
        {
            a240    = this.a260_Accrued_Revenue_Production_Revenue() +
                  this.a260_Accrued_Revenue_Production_Hour() +
                  this.a260_Accrued_Revenue_Production_Expenses() +
                  this.a260_Accrued_Revenue_Production_Item();
            c_a240  = true;
        }

        return a240;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a260_Accrued_Revenue_Production_Expenses</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the total accrued revenue in production on a particular project or on all projects.
    /// </summary>
    /// <returns>
    ///    The total accrued revenue in production on a project or on all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST a260_Accrued_Revenue_Production_Expenses()
    {
        this.checkCache();

        if (! c_a260Exp && expenses)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Cost));

                if (this.ledgerAccruedTurnoverProd())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjAccruedTurnoverProd));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Cost));

                if (this.ledgerAccruedTurnoverProd())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjAccruedTurnoverProd));
                }
            }

            [a260Exp, tempProjQty] = this.getQueryValues();
            a260Exp                = -a260Exp;
            c_a260Exp              = true;
        }

        return a260Exp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a260_Accrued_Revenue_Production_Hour</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the total accrued revenue in production on a particular project or on all projects.
    /// </summary>
    /// <returns>
    ///    The total accrued revenue in production on a project or on all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST a260_Accrued_Revenue_Production_Hour()
    {
        this.checkCache();

        if (! c_a260Hour && hour)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Hour));

                if (this.ledgerAccruedTurnoverProd())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjAccruedTurnoverProd));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));

                if (this.ledgerAccruedTurnoverProd())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjAccruedTurnoverProd));
                }
            }

            [a260Hour, tempProjQty] = this.getQueryValues();
            a260Hour                = -a260Hour;
            c_a260Hour              = true;
        }

        return a260Hour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a260_Accrued_Revenue_Production_Item</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the total accrued revenue in production on a particular project or on all projects.
    /// </summary>
    /// <returns>
    ///    The total accrued revenue in production on a project or on all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST a260_Accrued_Revenue_Production_Item()
    {
        this.checkCache();

        if (! c_a260Item && item)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Item));

                if (this.ledgerAccruedTurnoverProd())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjAccruedTurnoverProd));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Item));

                if (this.ledgerAccruedTurnoverProd())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjAccruedTurnoverProd));
                }
            }

            [a260Item, tempProjQty] = this.getQueryValues();
            a260Item                = -a260Item;
            c_a260Item              = true;
        }

        return a260Item;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a260_Accrued_Revenue_Production_Revenue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the total accrued revenue in production on a particular project or on all projects.
    /// </summary>
    /// <returns>
    ///    The total accrued revenue in production on a project or on all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST a260_Accrued_Revenue_Production_Revenue()
    {
        this.checkCache();

        if (! c_a260Fee && revenue)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Revenue));

                if (this.ledgerAccruedTurnoverProd())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjAccruedTurnoverProd));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Revenue));

                if (this.ledgerAccruedTurnoverProd())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjAccruedTurnoverProd));
                }
            }

            [a260Fee, tempProjQty] = this.getQueryValues();
            a260Fee                = -a260Fee;
            c_a260Fee              = true;
        }

        return a260Fee;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a265_Accrued_Revenue_Profit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the total accrued revenue from profits on a particular project or on all projects.
    /// </summary>
    /// <returns>
    ///    The total accrued revenue from profits on a project or on all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST a265_Accrued_Revenue_Profit()
    {
        this.checkCache();

        if (! c_a265)
        {
            a265    = this.a285_Accrued_Revenue_Profit_Revenue() +
                  this.a285_Accrued_Revenue_Profit_Hour() +
                  this.a285_Accrued_Revenue_Profit_Expenses() +
                  this.a285_Accrued_Revenue_Profit_Item();
            c_a265  = true;
        }

        return a265;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a270_Accrued_Revenue_OnAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the total accrued revenue for all on-account transactions for a particular project or for all projects.
    /// </summary>
    /// <returns>
    ///    Returns the total accrued revenue for all the on-account transactions for a project or all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST a270_Accrued_Revenue_OnAccount()
    {
        this.checkCache();

        if (! c_a270 && onAccount)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::OnAccount));

                if (this.ledgerAccruedRevenueOnAccount())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjAccruedRevenueOnAccount));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::OnAccount));

                if (this.ledgerAccruedRevenueOnAccount())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjAccruedRevenueOnAccount));
                }
            }

            [a270, tempProjQty] = this.getQueryValues();
            a270                = -a270;
            c_a270              = true;
        }

        return a270;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a285_Accrued_Revenue_Profit_Expenses</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the total accrued revenue from profits on a particular project or on all projects.
    /// </summary>
    /// <returns>
    ///    The total accrued revenue from profits on a project or on all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST a285_Accrued_Revenue_Profit_Expenses()
    {
        this.checkCache();

        if (! c_a285Exp && expenses)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Cost));

                if (this.ledgerAccruedTurnoverProfit())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProJAccruedTurnoverProfit));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Cost));

                if (this.ledgerAccruedTurnoverProfit())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProJAccruedTurnoverProfit));
                }
            }

            [a285Exp, tempProjQty] = this.getQueryValues();
            a285Exp                = -a285Exp;
            c_a285Exp              = true;
        }

        return a285Exp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a285_Accrued_Revenue_Profit_Hour</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the total accrued revenue from profits on a particular project or on all projects.
    /// </summary>
    /// <returns>
    ///    The total accrued revenue from profits on a project or on all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST a285_Accrued_Revenue_Profit_Hour()
    {
        this.checkCache();

        if (! c_a285Hour && hour)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Hour));

                if (this.ledgerAccruedTurnoverProfit())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProJAccruedTurnoverProfit));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));

                if (this.ledgerAccruedTurnoverProfit())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProJAccruedTurnoverProfit));
                }
            }

            [a285Hour, tempProjQty] = this.getQueryValues();
            a285Hour                = -a285Hour;
            c_a285Hour              = true;
        }

        return a285Hour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a285_Accrued_Revenue_Profit_Item</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the total accrued revenue from profits on a particular project or on all projects.
    /// </summary>
    /// <returns>
    ///    The total accrued revenue from profits on a project or on all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST a285_Accrued_Revenue_Profit_Item()
    {
        this.checkCache();

        if (! c_a285Item && item)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Item));

                if (this.ledgerAccruedTurnoverProfit())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProJAccruedTurnoverProfit));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Item));

                if (this.ledgerAccruedTurnoverProfit())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProJAccruedTurnoverProfit));
                }
            }

            [a285Item, tempProjQty] = this.getQueryValues();
            a285Item                = -a285Item;
            c_a285Item              = true;
        }

        return a285Item;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a285_Accrued_Revenue_Profit_Revenue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the total accrued revenue from profits on a particular project or on all projects.
    /// </summary>
    /// <returns>
    ///    The total accrued revenue from profits on a project or on all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST a285_Accrued_Revenue_Profit_Revenue()
    {
        this.checkCache();

        if (! c_a285Fee && revenue)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Revenue));

                if (this.ledgerAccruedTurnoverProfit())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProJAccruedTurnoverProfit));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Revenue));

                if (this.ledgerAccruedTurnoverProfit())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProJAccruedTurnoverProfit));
                }
            }

            [a285Fee, tempProjQty] = this.getQueryValues();
            a285Fee                = -a285Fee;
            c_a285Fee              = true;
        }

        return a285Fee;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a300_Total_Cost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates and returns the total amount that is posted as cost for a particular project or for all
    ///    projects that is used on any kind of project statement report.
    /// </summary>
    /// <param name="noElimination">
    ///    Set to true to exclude eliminations that are posted for hour transactions or false to include
    ///    eliminations; optional.
    /// </param>
    /// <param name="projListStateType">
    ///    A particular type of <c>ProjListStateType</c>; optional.
    /// </param>
    /// <returns>
    ///    The total amount posted as cost for a project or all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or budgeted amount. It also caches
    ///    this value and does not recalculate it if a value exists in the cache.The total cost is determined
    ///    by the following summation:<see cref="M:projStatement.A305_Cost" /> + <see
    ///    cref="M:projStatement.A335_Accrued_Cost" />
    /// </remarks>
    AmountMST a300_Total_Cost(
    boolean             noElimination       = false,
    ProjListStateType   projListStateType   = ProjListStateType::None)
    {
        this.checkCache();

        if (! c_a300)
        {
            a300    = this.a305_Cost(noElimination,projListStateType)+
                  this.a335_Accrued_Cost();
            c_a300  = true;
        }

        return a300;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a305_Cost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total amount that is posted as cost for the transaction types (hour, item, and
    /// expense) for a particular project or for all projects that are used on any kind of project
    /// statement report.
    /// </summary>
    /// <param name="noElimination">
    /// Set to true to exclude eliminations posted for hour transactions or <c>false</c> to include
    /// eliminations; optional.
    /// </param>
    /// <param name="projListStateType">
    /// A particular type of the <c>ProjListStateType</c> type; optional.
    /// </param>
    /// <returns>
    /// The total amount that is posted as cost for the transaction types for a project or all projects.
    /// </returns>
    /// <remarks>
    /// This method can be used to determine either the actual amount or the budgeted amount. It also
    /// caches this value and does not recalculate it if a value exists in the cache. The total cost is
    /// determined by the following summation: <see cref="M:projStatement.A310_Cost_Hour" />() + <see
    /// cref="M:projStatement.A315_Item_Total" />() + <see cref="M:projStatement.A330_Cost_Expenses" />()
    /// </remarks>
    AmountMST a305_Cost(
    boolean             noElimination       = false,
    ProjListStateType   projListStateType   = ProjListStateType::None)
    {
        this.checkCache();

        if (! c_a305)
        {
            a305    = this.a310_Cost_Hour(noElimination,projListStateType)+
                  this.a315_Item_Total()+
                  this.a330_Cost_Expenses();
            c_a305  = true;
        }

        return a305;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a310_Cost_Hour</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total amount that is posted as cost for hour transaction types for a particular
    ///    project or for all projects that are used on any kind of project statement report.
    /// </summary>
    /// <param name="noElimination">
    ///    Set to true to exclude eliminations posted for hour transactions or false to include eliminations;
    ///    optional.
    /// </param>
    /// <param name="projListStateType">
    ///    A particular type of <c>ProjListStateType</c>; optional.
    /// </param>
    /// <returns>
    ///    The total amount posted as cost for hour transaction types for a project or all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also
    ///    caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST a310_Cost_Hour(
    boolean             noElimination       = false,
    ProjListStateType   projListStateType   = ProjListStateType::None)
    {
        this.checkCache(noElimination);

        if (! c_a310 && hour && this.ledgerCost() && this.checkHourAmount())
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Hour));
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjCost));
                if (noElimination)
                {
                    this.transNoEliminationOrigin();
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjCost));
                if (noElimination)
                {
                    this.budgetNoElimination();
                }
            }

            [a310,qtyA310]  = this.getQueryValues();

            qtyA310         = 0;
            c_a310Qty       = false;

            c_a310          = true;
        }

        return a310+this.c110_Consumption_NeverLedger(projListStateType)+this.c115_Consumption_NoLedger(projListStateType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>a310_Cost_Hour_Qty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total number of hours that are posted as cost for hour transaction types for a
    ///    particular project or for all projects that can be used on any kind of project statement report.
    /// </summary>
    /// <param name="noElimination">
    ///    Set to true to exclude eliminations that are posted for hour transactions or false to include
    ///    eliminations; optional.
    /// </param>
    /// <param name="projListStateType">
    ///    A particular type of <c>ProjListStateType</c>; optional.
    /// </param>
    /// <returns>
    ///    The total number of hours posted as cost for hour transaction types for a project or all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also
    ///    caches this value and does not recalculate it if a value exists in the cache
    /// </remarks>
    ProjQty a310_Cost_Hour_Qty(
    boolean             noElimination       = false,
    ProjListStateType   projListStateType   = ProjListStateType::None)
    {
        ProjTransBudget lProjTransBudget;
        real    rQty, rQtyNeverLedger, rQtyNoLedger;
        this.checkCache(noElimination);

        if (! c_a310Qty && hour && this.ledgerCost() && this.checkHourQty())
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Hour));
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjCost));
                if (noElimination)
                {
                    this.transNoEliminationOrigin();
                }
            }
            else if (this.parmBudget())
            {
                if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
                {
                    select PostingType from lProjTransBudget where lProjTransBudget.ProjId == this.parmProjId() && lProjTransBudget.ProjTransType == ProjTransType::Hour;
                    if (lProjTransBudget.PostingType == LedgerPostingType::ProjCost)
                    {
                        transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));
                        transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjCost));
                    }
                    else
                    {
                        transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));
                    }
                }
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjCost));
                if (noElimination)
                {
                    this.budgetNoElimination();
                }
            }

            [a310,qtyA310]  = this.getQueryValues();

            a310            = 0;
            c_a310          = false;

            c_a310Qty       = true;
        }
        rQty = qtyA310;
        rQtyNeverledger = this.c110_Consumption_NeverLedger_qty(projListStateType);
        rQtyNoLedger = this.c115_Consumption_NoLedger_qty(projListStateType);

        if (!isConfigurationkeyEnabled(configurationKeyNum(Project)) || rQtyNeverledger || rQtyNoLedger)
        {
            rQty = rQty + rQtyNeverledger + rQtyNoLedger;
        }

        return rQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a315_Item_Total</Name>
				<Source><![CDATA[
    AmountMST a315_Item_Total(
    boolean noElimination       = false,
    boolean calledFromConsump   = false)
    {
        this.checkCache(noElimination);

        if (! c_a315)
        {
            a315    = this.a320_Cost_Item(noElimination)+
                  this.a325_Cost_Item_Activated(noElimination)+
                  this.c122_Consumption_Item(calledFromConsump);
            c_a315  = true;
        }

        return a315;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a320_Cost_Item</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total amount that is posted by using the <c>ProjCost</c> ledger posting type for
    ///    item transaction types for a particular project or for all projects that are used on any kind of
    ///    project statement report.
    /// </summary>
    /// <param name="noElimination">
    ///    Set to true to exclude eliminations that are posted for hour transactions or false to include
    ///    eliminations; optional.
    /// </param>
    /// <returns>
    ///    The total amount that is posted by using the <c>ProjCost</c> ledger posting type for item
    ///    transactions for a project or all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also
    ///    caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST a320_Cost_Item(boolean noElimination = false)
    {
        this.checkCache(noElimination);

        if (! c_a320 && item)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Item));

                if (this.ledgerCost())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjCost));
                }

                if (noElimination)
                {
                    this.transNoEliminationOrigin();
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Item));

                if (this.ledgerCost())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjCost));
                }

                if (noElimination)
                {
                    this.budgetNoElimination();
                }
            }

            [a320, tempProjQty]    = this.getQueryValues();
            c_a320          = true;
        }

        return a320;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a325_Cost_Item_Activated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total amount that is posted by using the <c>ProjOffsetAccountItem</c> ledger posting
    ///    type for item transactions for a particular project or for all projects that are used on any kind
    ///    of project statement report.
    /// </summary>
    /// <param name="noElimination">
    ///    Set to true to exclude eliminations that are posted for hour transactions or false to include
    ///    eliminations; optional.
    /// </param>
    /// <returns>
    ///    The total amount that is posted by using the <c>ProjOffsetAccountItem</c> ledger posting type for
    ///    item transactions for a project or all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or budgeted amount. It also caches
    ///    this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST a325_Cost_Item_Activated(boolean noElimination   = false)
    {
        this.checkCache(noElimination);

        if (! c_a325 && item)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Item));

                if (this.ledgerOffsetAccountItem())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjOffsetAccountItem));
                }

                if (noElimination)
                {
                    this.transNoEliminationOrigin();
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Item));

                if (this.ledgerOffsetAccountItem())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjOffsetAccountItem));
                }

                if (noElimination)
                {
                    this.budgetNoElimination();
                }
            }

            [a325, tempProjQty]  = this.getQueryValues();
            c_a325  = true;
        }

        return a325;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a330_Cost_Expenses</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total amount that is posted by using the <c>ProjCost</c> ledger posting type for
    ///    expense transaction types for a particular project or for all projects that are used on any kind of
    ///    project statement report.
    /// </summary>
    /// <param name="_noElimination">
    ///    Set to true to exclude eliminations posted for hour transactions or false to include eliminations;
    ///    optional.
    /// </param>
    /// <returns>
    ///    The total amount that is posted by using the <c>ProjCost</c> ledger posting type for expense
    ///    transactions for a project or all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or budgeted amount. It also caches
    ///    this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST a330_Cost_Expenses(boolean    _noElimination  = false)
    {
        this.checkCache(_noElimination);

        if (! c_a330 && expenses)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Cost));

                if (this.ledgerCost())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjCost));
                }

                if (_noElimination)
                {
                    this.transNoEliminationOrigin();
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Cost));

                if (this.ledgerCost())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjCost));
                }

                if (_noElimination)
                {
                    this.budgetNoElimination();
                }
            }

            [a330, tempProjQty]    = this.getQueryValues();
            c_a330          = true;
        }

        return a330;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a335_Accrued_Cost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total amount that is posted by using the <c>ProjAccruedCost</c> ledger posting type
    /// for expense transaction types for a particular project or for all projects that are used on any
    /// type of project statement report.
    /// </summary>
    /// <param name="noElimination">
    /// true to exclude eliminations posted for hour transactions or false to include eliminations;
    /// optional.
    /// </param>
    /// <returns>
    /// The total amount that is posted by using the <c>ProjAccruedCost</c> ledger posting type for expense
    /// transactions for a project or all projects.
    /// </returns>
    /// <remarks>
    /// This method can be used to determine either the actual amount or the budgeted amount. It also
    /// caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST a335_Accrued_Cost(boolean noElimination   = false)
    {
        this.checkCache(noElimination);

        if (! c_a335 && expenses && this.ledgerAccruedCost())
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Cost));
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjAccruedCost));
                if (noElimination)
                {
                    this.transNoEliminationOrigin();
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Cost));
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjAccruedCost));
                if (noElimination)
                {
                    this.budgetNoElimination();
                }
            }

            [a335, tempProjQty]    = this.getQueryValues();
            c_a335          = true;
        }

        return a335;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a400_Value_Added</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total value amount in revenue and cost for a particular project or for all projects
    ///    that can be used on any Profit and Loss project statement report.
    /// </summary>
    /// <returns>
    ///    The total value amount in revenue and cost for a project or all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also
    ///    caches this value and does not recalculate it if a value exists in the cache.The total amount is
    ///    determined by the following:<see cref="M:projStatement.A100_Total_Revenue" />() + <see
    ///    cref="M:projStatement.A300_Total_Cost" />() + <see cref="M:projStatement.A310_Cost_Hour" />()
    /// </remarks>
    AmountMST a400_Value_Added()
    {
        this.checkCache();

        if (! c_a400)
        {
            a400    = this.a100_Total_Revenue()-
                  this.a300_Total_Cost()+
                  this.a310_Cost_Hour();
            c_a400  = true;
        }

        return a400;
    }

]]></Source>
			</Method>
			<Method>
				<Name>a500_Gross_Margin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the gross margin between revenue and cost for a particular project or for all projects
    ///    that can be used on any type of project statement report.
    /// </summary>
    /// <returns>
    ///    The gross margin between the total revenue and the total cost for a project or all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also
    ///    caches this value and does not recalculate it if a value exists in the cache.The total amount is
    ///    determined by the following: <see cref="M:projStatement.A100_Total_Revenue" />() - <see
    ///    cref="M:projStatement.A300_Total_Cost" />()
    /// </remarks>
    AmountMST a500_Gross_Margin()
    {
        this.checkCache();

        if (! c_a500)
        {
            a500    = this.a100_Total_Revenue()-
                  this.a300_Total_Cost();
            c_a500  = true;
        }

        return a500;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b100_Salesvalue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total amount that is posted by using the <c>ProjSalesvalueOffset</c> ledger posting
    /// type for a particular project or for all projects.
    /// </summary>
    /// <returns>
    /// The total amount that is posted by using the <c>ProjSalesvalueOffset</c> ledger posting type for a
    /// project or all projects.
    /// </returns>
    /// <remarks>
    /// This value is used in the various project statement reports. This method can be used to determine
    /// either the actual amount or the budgeted amount. It also caches this value and does not recalculate
    /// it if a value exists in the cache. The total cost is determined by the following summation: <see
    /// cref="M:projStatement.B105_Salesvalue" />() + <see
    /// cref="M:projStatement.B128_Salesvalue_Subscription" />() + <see
    /// cref="M:projStatement.B130_WIP_Production" />() + <see cref="M:projStatement.B155_WIP_Profit" />()
    /// </remarks>
    AmountMST b100_Salesvalue()
    {
        this.checkCache();

        if (! c_b100)
        {
            b100    = this.b105_Salesvalue()+
                  this.b128_Salesvalue_Subscription()+
                  this.b130_wip_Production()+
                  this.b155_wip_Profit();

            qtyB100 = qtyb105;

            c_b100  = true;
        }

        return b100;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b100_Salesvalue_qty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calls the <see cref="M:projStatement.B105_Salesvalue_qty" />, which is used to calculate the total
    /// number of hours that are posted by using the <c>ProjSalesvalueOffset</c> ledger posting type for a
    /// particular project or for all projects.
    /// </summary>
    /// <returns>
    /// The total number of hours that are posted by using the <c>ProjSalesvalueOffset</c> ledger posting
    /// type for a project or for all projects.
    /// </returns>
    /// <remarks>
    /// This method can be used to determine either the actual amount or budgeted amount. It also caches
    /// this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    ProjQty b100_Salesvalue_qty()
    {
        this.checkCache();

        if (! c_b110Qty)
        {
            qtyB100    = this.b105_Salesvalue_qty();
        }
        else
        {
            qtyB100    = qtyb105;
        }

        return qtyB100;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b105_Salesvalue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total amount that is posted by using the <c>ProjSalesvalueOffset</c> ledger posting
    /// type for item, hour, expense, and revenue transactions for a particular project or for all projects.
    /// </summary>
    /// <returns>
    /// The total amount that is posted by using the <c>ProjSalesvalueOffset</c> ledger posting type for
    /// item, hour, expense, and revenue transactions for a project or all projects.
    /// </returns>
    /// <remarks>
    /// This value is used in the various project statement reports. This method can be used to determine
    /// either the actual amount or the budgeted amount. It also caches this value and does not recalculate
    /// it if a value exists in the cache. The total cost is determined by the following summation: <see
    /// cref="M:projStatement.B110_Salesvalue_Hour" />() + <see cref="M:projStatement.B115_Salesvalue_Item"
    /// />() + <see cref="M:projStatement.B120_Salesvalue_Expenses" />() + <see
    /// cref="M:projStatement.B125_Salesvalue_Revenue" />()
    /// </remarks>
    AmountMST b105_Salesvalue()
    {
        this.checkCache();

        if (! c_b105)
        {
            b105    = this.b110_Salesvalue_Hour()+
                  this.b115_Salesvalue_Item()+
                  this.b120_Salesvalue_Expenses()+
                  this.b125_Salesvalue_Revenue();

            if (c_b110Qty)
            {
                qtyb105 = qtyb110;
            }
            else
            {
                qtyb105 = this.b110_Salesvalue_Hour_qty();
            }

            c_b105  = true;
        }

        return b105;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b105_Salesvalue_qty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calls the <see cref="M:projStatement.B110_Salesvalue_Hour_qty" />, which is used to calculate the
    /// total number of hours that are posted by using the <c>ProjSalesvalueOffset</c> ledger posting type
    /// for hour transactions on a particular project or on all projects.
    /// </summary>
    /// <returns>
    /// The total number of hours that are posted by using the <c>ProjSalesvalueOffset</c> ledger posting
    /// type for a project or for all projects.
    /// </returns>
    /// <remarks>
    /// This method can be used to determine either the actual amount or the budgeted amount. It also
    /// caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    ProjQty b105_Salesvalue_qty()
    {
        this.checkCache();

        if (! c_b110Qty)
        {
            qtyb105    = this.b110_Salesvalue_Hour_qty();
        }
        else
        {
            qtyb105    = qtyb110;
        }

        return qtyb105;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b110_Salesvalue_Hour</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total amount that is posted by using the <c>ProjSalesvalueOffset</c> ledger posting type for hour transactions on a particular project or on all projects.
    /// </summary>
    /// <returns>
    ///    The total amount that is posted by using the <c>ProjSalesvalueOffset</c> ledger posting type for hour transactions on a project or on all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST b110_Salesvalue_Hour()
    {
        this.checkCache();

        if (! c_b110 && hour && this.ledgerSalesvalueOffset() && this.checkHourAmount())
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Hour));
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalueOffset));
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalueOffset));
            }

            [b110,qtyb110]  = this.getQueryValues();

            qtyb110         = 0;
            c_b110Qty       = false;

            c_b110          = true;
        }

        return b110;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b110_Salesvalue_Hour_qty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total number of hours that are posted by using the <c>ProjSalesvalueOffset</c> ledger posting type for hour transactions on a particular project or on all projects.
    /// </summary>
    /// <returns>
    ///    The total number of hours that are posted by using the <c>ProjSalesvalueOffset</c> ledger posting type for a project or for all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual number or the budgeted number. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    ProjQty b110_Salesvalue_Hour_qty()
    {
        this.checkCache();

        if (! c_b110Qty && hour && this.checkHourQty())
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Hour));

                if (this.ledgerSalesvalueOffset())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalueOffset));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));

                if (this.ledgerSalesvalueOffset())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalueOffset));
                }
            }

            [b110,qtyb110]  = this.getQueryValues();

            b110            = 0;
            c_b110          = false;

            c_b110Qty       = true;
        }

        return qtyb110;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b115_Salesvalue_Item</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total amount that is posted by using the <c>ProjSalesvalueOffset</c> ledger posting type for item transactions on a particular project or on all projects.
    /// </summary>
    /// <returns>
    ///    The total amount that is posted by using the <c>ProjSalesvalueOffset</c> ledger posting type for item transactions on a project or on all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST b115_Salesvalue_Item()
    {
        this.checkCache();

        if (! c_b115 && item)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Item));

                if (this.ledgerSalesvalueOffset())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalueOffset));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Item));

                if (this.ledgerSalesvalueOffset())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalueOffset));
                }
            }

            [b115, tempProjQty]    = this.getQueryValues();
            c_b115          = true;
        }

        return b115;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b120_Salesvalue_Expenses</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total amount that is posted by using the <c>ProjSalesvalueOffset</c> ledger posting type for expense transactions on a particular project or on all projects.
    /// </summary>
    /// <returns>
    ///    The total amount that is posted by using the <c>ProjSalesvalueOffset</c> ledger posting type for expense transactions on a project or on all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST b120_Salesvalue_Expenses()
    {
        this.checkCache();

        if (! c_b120 && expenses)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Cost));

                if (this.ledgerSalesvalueOffset())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalueOffset));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Cost));

                if (this.ledgerSalesvalueOffset())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalueOffset));
                }
            }

            [b120, tempProjQty]  = this.getQueryValues();
            c_b120        = true;
        }

        return b120;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b125_Salesvalue_Revenue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total amount that is posted by using the <c>ProjSalesvalueOffset</c> ledger posting type for revenue transactions on a particular project or on all projects.
    /// </summary>
    /// <returns>
    ///    The total amount that is posted by using the <c>ProjSalesvalueOffset</c> ledger posting type for revenue transactions on a project or on all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache
    /// </remarks>
    AmountMST b125_Salesvalue_Revenue()
    {
        this.checkCache();

        if (! c_b125 && revenue && this.ledgerSalesvalueOffset())
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Revenue));
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalueOffset));
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Revenue));
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalueOffset));
            }

            [b125, tempProjQty]  = this.getQueryValues();
            c_b125        = true;
        }

        return b125;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b128_Salesvalue_Subscription</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total amount that is posted by using the <c>ProjWIPSubscription</c> ledger posting type for revenue transactions on a particular project or on all projects.
    /// </summary>
    /// <returns>
    ///    The total amount that is posted by using the <c>ProjWIPSubscription</c> ledger posting type for revenue transactions on a project or on all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST b128_Salesvalue_Subscription()
    {
        this.checkCache();

        if (! c_b128 && revenue && this.ledgerSalesvalueOffset())
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Revenue));
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPSubscription));
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Revenue));
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPSubscription));
            }

            [b128, tempProjQty]  = this.getQueryValues();
            c_b128        = true;
        }

        return b128;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b130_wip_Production</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calls the <see cref="M:projStatement.b150_Production_Revenue" /> method, which is used to calculate
    /// the total amount that is posted by using the <c>ProjWIPProduction</c> ledger posting type for
    /// revenue transactions on a particular project or on all projects.
    /// </summary>
    /// <returns>
    /// The total amount that is posted by using the <c>ProjWIPProduction</c> ledger posting type for
    /// revenue transactions on a project or on all projects.
    /// </returns>
    /// <remarks>
    /// This method can be used to determine either the actual amount or the budgeted amount. It also
    /// caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST b130_wip_Production()
    {
        this.checkCache();

        if (! c_b130)
        {
            b130    = this.b150_Production_Revenue() +
                  this.b150_Production_Hour() +
                  this.b150_Production_Expenses() +
                  this.b150_Production_Item();
            c_b130  = true;
        }

        return b130;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b150_Production_Expenses</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total amount that is posted by using the <c>ProjWIPProduction</c> ledger posting type for revenue transactions on a particular project or on all projects.
    /// </summary>
    /// <returns>
    ///    The total amount that is posted by using the <c>ProjWIPProduction</c> ledger posting type for revenue transactions on a project or on all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST b150_Production_Expenses()
    {
        this.checkCache();

        if (! c_b150Exp && expenses)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Cost));

                if (this.ledgerWIPProduction())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProduction));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Cost));

                if (this.ledgerWIPProduction())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProduction));
                }
            }

            [b150Exp, tempProjQty]  = this.getQueryValues();
            c_b150Exp        = true;
        }

        return b150Exp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b150_Production_Hour</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total amount that is posted by using the <c>ProjWIPProduction</c> ledger posting type for revenue transactions on a particular project or on all projects.
    /// </summary>
    /// <returns>
    ///    The total amount that is posted by using the <c>ProjWIPProduction</c> ledger posting type for revenue transactions on a project or on all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST b150_Production_Hour()
    {
        this.checkCache();

        if (! c_b150Hour && hour)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Hour));

                if (this.ledgerWIPProduction())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProduction));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));

                if (this.ledgerWIPProduction())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProduction));
                }
            }

            [b150Hour, tempProjQty]  = this.getQueryValues();
            c_b150Hour        = true;
        }

        return b150Hour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b150_Production_Item</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total amount that is posted by using the <c>ProjWIPProduction</c> ledger posting type for revenue transactions on a particular project or on all projects.
    /// </summary>
    /// <returns>
    ///    The total amount that is posted by using the <c>ProjWIPProduction</c> ledger posting type for revenue transactions on a project or on all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST b150_Production_Item()
    {
        this.checkCache();

        if (! c_b150Item && item)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Item));

                if (this.ledgerWIPProduction())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProduction));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Item));

                if (this.ledgerWIPProduction())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProduction));
                }
            }

            [b150Item, tempProjQty]  = this.getQueryValues();
            c_b150Item        = true;
        }

        return b150Item;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b150_Production_Revenue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total amount that is posted by using the <c>ProjWIPProduction</c> ledger posting type for revenue transactions on a particular project or on all projects.
    /// </summary>
    /// <returns>
    ///    The total amount that is posted by using the <c>ProjWIPProduction</c> ledger posting type for revenue transactions on a project or on all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST b150_Production_Revenue()
    {
        this.checkCache();

        if (! c_b150Fee && revenue)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Revenue));

                if (this.ledgerWIPProduction())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProduction));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Revenue));

                if (this.ledgerWIPProduction())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProduction));
                }
            }

            [b150Fee, tempProjQty]  = this.getQueryValues();
            c_b150Fee        = true;
        }

        return b150Fee;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b155_wip_Profit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total amount that is posted by using the <c>ProjWIPProfit</c> ledger posting type
    /// for revenue transactions on a particular project or on all projects.
    /// </summary>
    /// <returns>
    /// The total amount that is posted by using the <c>ProjWIPProfit</c> ledger posting type for revenue
    /// transactions on a project or on all projects.
    /// </returns>
    /// <remarks>
    /// This method can be used to determine either the actual amount or budgeted amount. It also caches
    /// this value and does not recalculate it if a value is in the cache.
    /// </remarks>
    AmountMST b155_wip_Profit()
    {
        this.checkCache();

        if (! c_b155)
        {
            b155    = this.b175_wip_Profit_Revenue() +
                  this.b175_wip_Profit_Hour() +
                  this.b175_wip_Profit_Expenses() +
                  this.b175_wip_Profit_Item();
            c_b155  = true;
        }

        return b155;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b175_wip_Profit_Expenses</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total amount that is posted by using the <c>ProjWIPProfit</c> ledger posting type
    /// for revenue transactions on a particular project or on all projects.
    /// </summary>
    /// <returns>
    /// The total amount that is posted by using the <c>ProjWIPProfit</c> ledger posting type for revenue
    /// transactions on a project or on all projects.
    /// </returns>
    /// <remarks>
    /// This method can be used to determine either the actual amount or budgeted amount. It also caches
    /// this value and does not recalculate it if a value is in the cache.
    /// </remarks>
    AmountMST b175_wip_Profit_Expenses()
    {
        this.checkCache();

        if (! c_b175Exp && expenses && this.ledgerWIPProfit())
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Cost));
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProfit));
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Cost));
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProfit));
            }

            [b175Exp, tempProjQty]  = this.getQueryValues();
            c_b175Exp        = true;
        }

        return b175Exp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b175_wip_Profit_Hour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total amount that is posted by using the <c>ProjWIPProfit</c> ledger posting type
    /// for revenue transactions on a particular project or on all projects.
    /// </summary>
    /// <returns>
    /// The total amount that is posted by using the <c>ProjWIPProfit</c> ledger posting type for revenue
    /// transactions on a project or on all projects.
    /// </returns>
    /// <remarks>
    /// This method can be used to determine either the actual amount or budgeted amount. It also caches
    /// this value and does not recalculate it if a value is in the cache.
    /// </remarks>
    AmountMST b175_wip_Profit_Hour()
    {
        this.checkCache();

        if (! c_b175Hour && hour && this.ledgerWIPProfit())
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Hour));
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProfit));
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProfit));
            }

            [b175Hour, tempProjQty]  = this.getQueryValues();
            c_b175Hour        = true;
        }

        return b175Hour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b175_wip_Profit_Item</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total amount that is posted by using the <c>ProjWIPProfit</c> ledger posting type
    /// for revenue transactions on a particular project or on all projects.
    /// </summary>
    /// <returns>
    /// The total amount that is posted by using the <c>ProjWIPProfit</c> ledger posting type for revenue
    /// transactions on a project or on all projects.
    /// </returns>
    /// <remarks>
    /// This method can be used to determine either the actual amount or budgeted amount. It also caches
    /// this value and does not recalculate it if a value is in the cache.
    /// </remarks>
    AmountMST b175_wip_Profit_Item()
    {
        this.checkCache();

        if (! c_b175Item && item && this.ledgerWIPProfit())
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Item));
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProfit));
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Item));
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProfit));
            }

            [b175Item, tempProjQty]  = this.getQueryValues();
            c_b175Item        = true;
        }

        return b175Item;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b175_wip_Profit_Revenue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total amount that is posted by using the <c>ProjWIPProfit</c> ledger posting type
    /// for revenue transactions on a particular project or on all projects.
    /// </summary>
    /// <returns>
    /// The total amount that is posted by using the <c>ProjWIPProfit</c> ledger posting type for revenue
    /// transactions on a project or on all projects.
    /// </returns>
    /// <remarks>
    /// This method can be used to determine either the actual amount or budgeted amount. It also caches
    /// this value and does not recalculate it if a value is in the cache.
    /// </remarks>
    AmountMST b175_wip_Profit_Revenue()
    {
        this.checkCache();

        if (! c_b175Fee && revenue && this.ledgerWIPProfit())
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Revenue));
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProfit));
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Revenue));
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProfit));
            }

            [b175Fee, tempProjQty]  = this.getQueryValues();
            c_b175Fee        = true;
        }

        return b175Fee;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b200_TotalCostPrice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total amount that is posted as cost for a particular project or for all projects
    ///    that are used in any work in progress (WIP) project statement report.
    /// </summary>
    /// <returns>
    ///    The total amount that is posted as cost for a project or all projects that are used in any WIP
    ///    project statement report.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also
    ///    caches this value and does not recalculate it if a value exists in the cache The total cost is
    ///    determined by the following summation: <see cref="M:projStatement.B205_Salesvalue" />() + <see
    ///    cref="M:projStatement.B225_WIP_CostAccruals_Expenses" />()
    /// </remarks>
    AmountMST b200_TotalCostPrice()
    {
        this.checkCache();

        if (! c_b200Qty)
        {
            b200    = this.b205_Salesvalue()+
                  this.b225_wip_CostAccruals_Expenses();

            qtyB200     = qtyB205;
            c_b200Qty   = true;
        }

        return b200;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b200_TotalCostPrice_qty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calls the <see cref="M:projStatement.B205_Salesvalue_qty" /> to calculate the total number of hours
    ///    that are posted as cost by using the <c>ProjWIPCostvalue</c> ledger posting type for a particular
    ///    project or for all projects in any work in progress (WIP) project statement report.
    /// </summary>
    /// <returns>
    ///    The total number of hours that are posted as cost by using the <c>ProjWIPCostvalue</c> ledger
    ///    posting type for a project or for all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also
    ///    caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    ProjQty b200_TotalCostPrice_qty()
    {
        this.checkCache();

        if (! c_b205qty)
        {
            qtyB200    = this.b205_Salesvalue_qty();
        }
        else
        {
            qtyB200    = qtyB205;
        }

        return qtyB200;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b205_Salesvalue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total amount that is posted as cost for hour, item, and expense transactions for a
    ///    particular project or for all projects that are used in any work in progress (WIP) project
    ///    statement report.
    /// </summary>
    /// <returns>
    ///    The total amount that is posted as cost for hour, item, and expense transactions for a project or
    ///    for all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also
    ///    caches this value and does not recalculate it if a value exists in the cache.  The total cost is
    ///    determined by the following summation:<see cref="M:projStatement.B210_WIP_CostValue_Hour" />() +
    ///    <see cref="M:projStatement.B215_WIP_CostValue_Item" />() + <see
    ///    cref="M:projStatement.B220_WIP_CostValue_Expenses" />()
    /// </remarks>
    AmountMST b205_Salesvalue()
    {
        this.checkCache();

        if (! c_b205)
        {
            b205    = this.b210_wip_CostValue_Hour()+
                  this.b215_wip_CostValue_Item()+
                  this.b220_wip_CostValue_Expenses();

            qtyB205 = qtyB210;

            c_b205  = true;
        }

        return b205;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b205_Salesvalue_qty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calls the <c>B210_WIP_CostValue_Hour_qty</c> method to calculate the total number of hours posted as cost.
    /// </summary>
    /// <returns>
    ///    The total number of hours posted as cost using the <c>ProjWIPCostvalue</c> ledger posting type for a project or for all projects.
    /// </returns>
    /// <remarks>
    ///    This method uses the <c>ProjWIPCostvalue</c> ledger posting type for a particular project or for all projects in any WIP project statement report.
    ///    This method can be used to determine either the
    ///    actual amount or budgeted amount. It also caches this value and does not recalculate it if a value is in the cache.
    /// </remarks>
    ProjQty b205_Salesvalue_qty()
    {
        this.checkCache();

        if (! c_b210Qty)
        {
            qtyB205    = this.b210_wip_CostValue_Hour_qty();
        }
        else
        {
            qtyB205    = qtyB210;
        }

        return qtyB205;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b210_wip_CostValue_Hour</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total amount that is posted by using the <c>ProjWIPCostvalue</c> ledger posting type for hour transactions on a particular project or all projects that are used toward cost in any work
    ///    in progress (WIP) project statement report.
    /// </summary>
    /// <param name="noElimination">
    ///    Set to true to exclude eliminations that are posted for hour transactions; false to include eliminations; optional.
    /// </param>
    /// <returns>
    ///    The total amount that is posted by using the <c>ProjWIPCostvalue</c> ledger posting type for hour transactions on a project or on all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST b210_wip_CostValue_Hour(boolean   noElimination  = false)
    {
        this.checkCache(noElimination);

        if (! c_b210 && hour && this.ledgerWIPCostvalue() && this.checkHourAmount())
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Hour));
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPCostvalue));
                if (noElimination)
                {
                    this.transNoEliminationOrigin();
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPCostvalue));
                if (noElimination)
                {
                    this.budgetNoElimination();
                }
            }

            [b210,qtyB210]  = this.getQueryValues();

            qtyB210         = 0;
            c_b210Qty       = false;

            c_b210          = true;
        }

        return b210;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b210_wip_CostValue_Hour_qty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total number of hours posted by using the <c>ProjWIPCostvalue</c> ledger posting
    /// type for hour transactions on a particular project or all projects used in any WIP project
    /// statement report.
    /// </summary>
    /// <param name="noElimination">
    /// A Boolean value that determines whether to exclude or include eliminations posted for hour
    /// transactions; optional.
    /// </param>
    /// <returns>
    /// The total number of hours posted using the <c>ProjWIPCostvalue</c> ledger posting type for hour
    /// transactions on a project or all projects.
    /// </returns>
    /// <remarks>
    /// This method can be used to determine either the actual amount or budgeted amount. It also caches
    /// this value and does not recalculate it if a value is in the cache.
    /// </remarks>
    ProjQty b210_wip_CostValue_Hour_qty(boolean noElimination   = false)
    {
        this.checkCache(noElimination);

        if (! c_b210Qty && hour && this.checkHourQty())
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Hour));
                if (this.ledgerWIPCostvalue())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPCostvalue));
                }
                if (noElimination)
                {
                    this.transNoEliminationOrigin();
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));
                if (this.ledgerWIPCostvalue())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPCostvalue));
                }
                if (noElimination)
                {
                    this.budgetNoElimination();
                }
            }

            [b210,qtyB210]  = this.getQueryValues();

            b210            = 0;
            c_b210          = false;

            c_b210Qty       = true;
        }

        return qtyB210;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b215_wip_CostValue_Item</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total amount that is posted by using the <c>ProjStatusAccountItem</c> ledger posting
    /// type for item transactions on a particular project or on all projects that are used toward cost in
    /// any work in progress (WIP) project statement report.
    /// </summary>
    /// <param name="noElimination">
    /// true to exclude eliminations posted for hour transactions; false to include eliminations; optional.
    /// </param>
    /// <returns>
    /// The total amount that is posted by using the <c>ProjStatusAccountItem</c> ledger posting type for
    /// item transactions on a project or all projects.
    /// </returns>
    /// <remarks>
    /// This method can be used to determine either the actual amount or the budgeted amount. It also
    /// caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST b215_wip_CostValue_Item(boolean   noElimination  = false)
    {
        this.checkCache(noElimination);

        if (! c_b215 && item && this.ledgerWIPCostvalue())
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Item));
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjStatusAccountItem));
                if (noElimination)
                {
                    this.transNoEliminationOrigin();
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Item));
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjStatusAccountItem));
                if (noElimination)
                {
                    this.budgetNoElimination();
                }
            }

            [b215,tempProjQty]    = this.getQueryValues();
            c_b215          = true;
        }

        return b215;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b220_wip_CostValue_Expenses</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total amount that is posted by using the <c>ProjWIPCostvalue</c> ledger posting type
    /// for expense transactions on a particular project or all projects that are used toward cost in any
    /// work in progress (WIP) project statement report.
    /// </summary>
    /// <param name="noElimination">
    /// true to exclude eliminations posted for hour transactions; false to include eliminations; optional.
    /// </param>
    /// <returns>
    /// The total amount that is posted by using the <c>ProjWIPCostvalue</c> ledger posting type for
    /// expense transactions on a project or all projects.
    /// </returns>
    /// <remarks>
    /// This method can be used to determine either the actual amount or the budgeted amount. It also
    /// caches this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    AmountMST b220_wip_CostValue_Expenses(boolean noElimination = false)
    {
        this.checkCache(noElimination);

        if (! c_b220 && expenses && this.ledgerWIPCostvalue())
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Cost));
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPCostvalue));
                if (noElimination)
                {
                    this.transNoEliminationOrigin();
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Cost));
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPCostvalue));
                if (noElimination)
                {
                    this.budgetNoElimination();
                }
            }

            [b220,tempProjQty] = this.getQueryValues();
            c_b220       = true;
        }

        return b220;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b225_wip_CostAccruals_Expenses</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total amount that is posted by using the <c>ProjWIPCost</c> ledger posting type for
    /// expense transactions on a particular project or all projects, used towards cost in any WIP project
    /// statement report.
    /// </summary>
    /// <returns>
    /// The total amount posted using the <c>ProjWIPCost</c> ledger posting type for expense transactions
    /// on a project or all projects.
    /// </returns>
    /// <remarks>
    /// This method can be used to determine either the actual amount or budgeted amount. It also caches
    /// this value and does not recalculate it if a value is in the cache.
    /// </remarks>
    AmountMST b225_wip_CostAccruals_Expenses()
    {
        this.checkCache();

        if (! c_b225 && expenses && this.ledgerWIPCostvalue())
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Cost));
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPCost));
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Cost));
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPCost));
            }

            [b225, tempProjQty]    = this.getQueryValues();
            c_b225          = true;
        }

        return b225;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b300_Gross</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the gross amount for a particular project or all projects used in any WIP project
    /// statement report.
    /// </summary>
    /// <returns>
    /// The gross amount for a project or all projects used in any WIP project statement report.
    /// </returns>
    /// <remarks>
    /// This method can be used to determine either the actual amount or budgeted amount. It also caches
    /// this value and does not recalculate it if a value is in the cache.The total amount is determined by
    /// the following: <c>B100_Salesvalue</c>() + <c>B200_TotalCostPrice</c>()
    /// </remarks>
    AmountMST b300_Gross()
    {
        this.checkCache();

        if (! c_b300)
        {
            b300    = this.b100_Salesvalue()+
                  this.b200_TotalCostPrice();

            qtyb300 = qtyB100+qtyB200;

            c_b300  = true;
        }

        return b300;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b300_Gross_qty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the overall total number of hours for a particular project or all projects that are used
    ///    in any work in progress (WIP) project statement report.
    /// </summary>
    /// <returns>
    ///    The total number of hours for a project or all projects that are used in any WIP project statement
    ///    report.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual hours or the budgeted hours. It also caches
    ///    this value and does not recalculate it if a value exists in the cache. The total hours is
    ///    determined by the following:<see cref="M:projStatement.B100_Salesvalue_qty" />() + <see
    ///    cref="M:projStatement.B200_TotalCostPrice_qty" />()
    /// </remarks>
    Qty b300_Gross_qty()
    {
        this.checkCache();

        if (! c_b300Qty)
        {
            qtyb300    = this.b100_Salesvalue_qty() + this.b200_TotalCostPrice_qty();

            c_b300Qty  = true;
        }
        else
        {
            qtyb300    = qtyB100 + qtyB200;
        }

        return qtyb300;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b400_wip_Invoiced_OnAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total amount that is posted by using the <c>ProjWIPInvoicedOnAccount</c> ledger posting type for on-account transactions on a particular project or all projects in any work in progress
    ///    (WIP) project statement report.
    /// </summary>
    /// <returns>
    ///    The total amount that is posted by using the <c>ProjWIPInvoicedOnAccount</c> ledger posting type for on-account transactions on a project or on all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also caches this value and does not recalculate it if a value exists in the cache
    /// </remarks>
    AmountMST b400_wip_Invoiced_OnAccount()
    {
        this.checkCache();

        if (! c_b400 && onAccount)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::OnAccount));

                if (this.ledgerWIPInvoicedOnAccount())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPInvoicedOnAccount));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::OnAccount));

                if (this.ledgerWIPInvoicedOnAccount())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPInvoicedOnAccount));
                }
            }

            [b400, tempProjQty]    = this.getQueryValues();
            b400            = -b400;
            c_b400          = true;
        }

        return b400;
    }

]]></Source>
			</Method>
			<Method>
				<Name>b500_Net</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total net amount that is due on a particular project or on all projects that are
    ///    used in any work in progress (WIP) project statement report.
    /// </summary>
    /// <returns>
    ///    The net amount that is due on a project or on all projects that are used in any WIP project
    ///    statement report.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also
    ///    caches this value and does not recalculate it if a value exists in the cache. The total net amount
    ///    is determined by the following:<see cref="M:projStatement.B300_Gross" />() - <see
    ///    cref="M:projStatement.B400_WIP_Invoiced_OnAccount" />()
    /// </remarks>
    AmountMST b500_Net()
    {
        this.checkCache();

        if (! c_b500)
        {
            b500    = this.b300_Gross() - this.b400_wip_Invoiced_OnAccount();

            c_b500  = true;
        }

        return b500;
    }

]]></Source>
			</Method>
			<Method>
				<Name>budgetNoElimination</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a range to the query to exclude eliminations in the calculations.
    /// </summary>
    void budgetNoElimination()
    {
        transDataSource.addRange(fieldNum(ProjTransBudget,Elimination)).value(queryValue(NoYes::No));
    }

]]></Source>
			</Method>
			<Method>
				<Name>c100_Total_Consumption</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total amount posted for hour, item, and expense transactions on a particular project
    ///    or on all projects that are used in any project consumption statement report.
    /// </summary>
    /// <returns>
    ///    The total amount posted for hour, item, and expense transactions on a project or on all projects
    ///    that are used in any project consumption statement report.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also
    ///    caches this value and does not recalculate it if a value exists in the cache.  The total cost is
    ///    determined by the following:<see cref="M:projStatement.C105_Consumption_Hour" />() + <see
    ///    cref="M:projStatement.C120_Consumption_Item" />() + <see
    ///    cref="M:projStatement.C125_Consumption_Cost" />()
    /// </remarks>
    AmountMST c100_Total_Consumption()
    {
        this.checkCache();

        if (! c_c100)
        {
            c100    = this.c105_Consumption_Hour() +
                  this.c120_Consumption_Item() +
                  this.c125_Consumption_Cost();
            c_c100  = true;
        }

        return c100;
    }

]]></Source>
			</Method>
			<Method>
				<Name>c105_Consumption_Hour</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total amount that is posted by using the <c>ProjWIPCostvalue</c> and <c>ProjCost</c>
    ///    ledger posting types for hour transactions on a particular project or all projects that are used in
    ///    any project consumption statement report.
    /// </summary>
    /// <returns>
    ///    The total amount that is posted by using the <c>ProjWIPCostvalue</c> and <c>ProjCost</c> ledger
    ///    posting type for hour transactions on a project or all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or the budgeted amount. It also
    ///    caches this value and does not recalculate it if a value exists in the cache. The total amount is
    ///    determined by the following:<see cref="M:projStatement.A310_Cost_Hour" />(<c>true,
    ///    ProjListStateType::Consumption</c>) + <see cref="M:projStatement.B210_WIP_CostValue_Hour"
    ///    />(<c>true</c>)
    /// </remarks>
    AmountMST c105_Consumption_Hour()
    {
        this.checkCache();

        if (! c_c105)
        {
            c105    = this.a310_Cost_Hour(true,ProjListStateType::Consumption)+
                  this.b210_wip_CostValue_Hour(true);

            c_c105  = true;
        }

        return c105;
    }

]]></Source>
			</Method>
			<Method>
				<Name>c105_Consumption_Hour_qty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total number of hours that are posted by using the <c>ProjWIPCostvalue</c> and
    ///    <c>ProjCost</c> ledger posting types for hour transactions on a particular project or on all
    ///    projects that are used in any project consumption statement report.
    /// </summary>
    /// <returns>
    ///    The total number of hours that are posted by using the <c>ProjWIPCostvalue</c> and <c>ProjCost</c>
    ///    ledger posting type for hour transactions on a project or all projects.
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual hours or the budgeted hours. It also caches
    ///    this value and does not recalculate it if a value exists in the cache. The total number of hours is
    ///    determined by the following:<see cref="M:projStatement.A310_Cost_Hour_Qty" />(<c>true,
    ///    ProjListStateType::Consumption</c>) + <see cref="M:projStatement.B210_WIP_CostValue_Hour_qty"
    ///    />(<c>true</c>)
    /// </remarks>
    public ProjQty c105_Consumption_Hour_qty()
    {
        this.checkCache();

        if (! c_c105Qty)
        {
            qtyC105    = this.a310_Cost_Hour_Qty(true,ProjListStateType::Consumption)+
                     this.b210_wip_CostValue_Hour_qty(true);
            c_c105Qty  = true;
        }
        else
        {
            qtyC105 = qtyA310+qtyB210;
        }

        return qtyC105;
    }

]]></Source>
			</Method>
			<Method>
				<Name>c110_Consumption_NeverLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total amount that is posted by using the <c>ProjNeverLedger</c> ledger posting type
    /// for hour transactions on a particular project or all projects used in any project consumption
    /// statement report.
    /// </summary>
    /// <param name="_projListStateType">
    /// A particular type of <c>ProjListStateType</c>; optional.
    /// </param>
    /// <returns>
    /// The total amount that is posted by using the <c>ProjNeverLedger</c> ledger posting type for hour
    /// transactions on a project or on all projects.
    /// </returns>
    /// <remarks>
    /// This method can be used to determine either the actual amount or budgeted amount. It also caches
    /// this value and does not recalculate it if a value is in the cache.
    /// </remarks>
    AmountMST c110_Consumption_NeverLedger(
    ProjListStateType   _projListStateType   = ProjListStateType::None)
    {
        this.checkCache();

        if (! c_c110 && this.checkCalculateNoNeverLedger(_projListStateType))
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Hour));
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjNeverLedger));
                this.transNoEliminationOrigin();
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjNeverLedger));
                this.budgetNoElimination();
            }

            [c110,qtyC110]  = this.getQueryValues();

            if (!this.checkHourQty())
            {
                qtyC110 = 0;
            }

            if (!this.checkHourAmount())
            {
                c110 = 0;
            }

            switch (_projListStateType)
            {
                case ProjListStateType::Consumption:
                    if (!ProjParameters::find().StatementConsumpHourCost)
                    {
                        c110        = 0;
                    }
                    break;

                case ProjListStateType::ConsumptionActivity:
                    if (!ProjParameters::find().StatementConsumpHourCost)
                    {
                        c110        = 0;
                    }
                    break;

                case ProjListStateType::ProfitLoss:
                    if (! ProjParameters::find().StatementPLHourCost)
                    {
                        c110        = 0;
                    }
                    break;

                case ProjListStateType::ProfitLossActivity:
                    if (! ProjParameters::find().StatementPLHourCost)
                    {
                        c110        = 0;
                    }
                    break;

                default:
                    c110        = 0;
                    break;
            }

            switch (_projListStateType)
            {
                case ProjListStateType::Consumption:
                    if (!ProjParameters::find().StatementConsumpHourQty)
                    {
                        qtyC110        = 0;
                    }
                    break;

                case ProjListStateType::ConsumptionActivity:
                    if (!ProjParameters::find().StatementConsumpHourQty)
                    {
                        qtyC110        = 0;
                    }
                    break;

                case ProjListStateType::ProfitLoss:
                    if (! ProjParameters::find().StatementPLHourQty)
                    {
                        qtyC110        = 0;
                    }
                    break;

                case ProjListStateType::ProfitLossActivity:
                    if (! ProjParameters::find().StatementPLHourQty)
                    {
                        qtyC110        = 0;
                    }
                    break;

                default:
                    qtyC110        = 0;
                    break;
            }

            c_c110          = true;
        }

        return c110;
    }

]]></Source>
			</Method>
			<Method>
				<Name>c110_Consumption_NeverLedger_qty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total number of hours that are posted by using the <c>ProjNeverLedger</c> ledger
    /// posting type for hour transactions on a particular project or on all projects that are used in any
    /// project consumption statement report.
    /// </summary>
    /// <param name="_projListStateType">
    /// A particular type of <c>ProjListStateType</c>; optional.
    /// </param>
    /// <returns>
    /// The total number of hours that are posted by using the <c>ProjNeverLedger</c> ledger posting type
    /// for hour transactions on a project or on all projects.
    /// </returns>
    /// <remarks>
    /// This method can be used to determine either the actual hours or the budgeted hours. It also caches
    /// this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    ProjQty c110_Consumption_NeverLedger_qty(
    ProjListStateType   _projListStateType   = ProjListStateType::None)
    {
        this.checkCache();

        if (! c_c110 && this.checkCalculateNoNeverLedger(_projListStateType))
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Hour));
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjNeverLedger));
                this.transNoEliminationOrigin();
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjNeverLedger));
                this.budgetNoElimination();
            }

            [c110,qtyC110]  = this.getQueryValues();

            if (! this.checkHourQty())
            {
                qtyC110 = 0;
            }

            if (! this.checkHourAmount())
            {
                c110 = 0;
            }

            switch (_projListStateType)
            {
                case ProjListStateType::Consumption:
                    if (!ProjParameters::find().StatementConsumpHourCost)
                    {
                        c110        = 0;
                    }
                    break;

                case ProjListStateType::ConsumptionActivity:
                    if (!ProjParameters::find().StatementConsumpHourCost)
                    {
                        c110        = 0;
                    }
                    break;

                case ProjListStateType::ProfitLoss:
                    if (! ProjParameters::find().StatementPLHourCost)
                    {
                        c110        = 0;
                    }
                    break;

                case ProjListStateType::ProfitLossActivity:
                    if (! ProjParameters::find().StatementPLHourCost)
                    {
                        c110        = 0;
                    }
                    break;

                default:
                    c110        = 0;
                    break;
            }

            switch (_projListStateType)
            {
                case ProjListStateType::Consumption:
                    if (!ProjParameters::find().StatementConsumpHourQty)
                    {
                        qtyC110        = 0;
                    }
                    break;

                case ProjListStateType::ConsumptionActivity:
                    if (!ProjParameters::find().StatementConsumpHourQty)
                    {
                        qtyC110        = 0;
                    }
                    break;

                case ProjListStateType::ProfitLoss:
                    if (! ProjParameters::find().StatementPLHourQty)
                    {
                        qtyC110        = 0;
                    }
                    break;

                case ProjListStateType::ProfitLossActivity:
                    if (! ProjParameters::find().StatementPLHourQty)
                    {
                        qtyC110        = 0;
                    }
                    break;

                default:
                    qtyC110        = 0;
                    break;
            }

            c_c110          = true;
        }

        return qtyC110;
    }

]]></Source>
			</Method>
			<Method>
				<Name>c115_Consumption_NoLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total amount that is posted by using the <c>ProjNoLedger</c> ledger posting type for
    /// hour transactions on a particular project or all projects that are used in any project consumption
    /// statement report.
    /// </summary>
    /// <param name="_projListStateType">
    /// A particular type of <c>ProjListStateType</c> type; optional.
    /// </param>
    /// <returns>
    /// The total amount that is posted by using the <c>ProjNoLedger</c> ledger posting type for hour
    /// transactions on a project or on all projects.
    /// </returns>
    /// <remarks>
    /// This method can be used to determine either the actual amount or budgeted amount. It also caches
    /// this value and does not recalculate it if a value is in the cache.
    /// </remarks>
    AmountMST c115_Consumption_NoLedger(
    ProjListStateType   _projListStateType   = ProjListStateType::None)
    {
        this.checkCache();

        if (! c_c115 && this.checkCalculateNoNeverLedger(_projListStateType))
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Hour));
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjNoLedger));
                this.transNoEliminationOrigin();
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjNoLedger));
                this.budgetNoElimination();
            }

            [c115,qtyC115]  = this.getQueryValues();

            if (! this.checkHourQty())
            {
                qtyC115 = 0;
            }

            if (! this.checkHourAmount())
            {
                c115 = 0;
            }

            switch (_projListStateType)
            {
                case ProjListStateType::Consumption:
                    if (!ProjParameters::find().StatementConsumpHourCost)
                    {
                        c115        = 0;
                    }
                    break;

                case ProjListStateType::ConsumptionActivity:
                    if (!ProjParameters::find().StatementConsumpHourCost)
                    {
                        c115        = 0;
                    }
                    break;

                case ProjListStateType::ProfitLoss:
                    if (! ProjParameters::find().StatementPLHourCost)
                    {
                        c115        = 0;
                    }
                    break;

                case ProjListStateType::ProfitLossActivity:
                    if (! ProjParameters::find().StatementPLHourCost)
                    {
                        c115        = 0;
                    }
                    break;

                default:
                    c115        = 0;
                    break;
            }

            switch (_projListStateType)
            {
                case ProjListStateType::Consumption:
                    if (!ProjParameters::find().StatementConsumpHourQty)
                    {
                        qtyC115        = 0;
                    }
                    break;

                case ProjListStateType::ConsumptionActivity:
                    if (!ProjParameters::find().StatementConsumpHourQty)
                    {
                        qtyC115        = 0;
                    }
                    break;

                case ProjListStateType::ProfitLoss:
                    if (! ProjParameters::find().StatementPLHourQty)
                    {
                        qtyC115        = 0;
                    }
                    break;

                case ProjListStateType::ProfitLossActivity:
                    if (! ProjParameters::find().StatementPLHourQty)
                    {
                        qtyC115        = 0;
                    }
                    break;

                default:
                    qtyC115        = 0;
                    break;
            }

            c_c115          = true;
        }

        return c115;
    }

]]></Source>
			</Method>
			<Method>
				<Name>c115_Consumption_NoLedger_qty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total number of hours that are posted by using the <c>ProjNoLedger</c> ledger
    /// posting type for hour transactions on a particular project or all projects that are used in any
    /// project consumption statement report.
    /// </summary>
    /// <param name="_projListStateType">
    /// A particular type of the <c>ProjListStateType</c> type; optional.
    /// </param>
    /// <returns>
    /// The total number of hours that are posted by using the <c>ProjNoLedger</c> ledger posting type for
    /// hour transactions on a project or on all projects.
    /// </returns>
    /// <remarks>
    /// This method can be used to determine either the actual hours or the budgeted hours. It also caches
    /// this value and does not recalculate it if a value exists in the cache.
    /// </remarks>
    ProjQty c115_Consumption_NoLedger_qty(
    ProjListStateType   _projListStateType   = ProjListStateType::None)
    {
        this.checkCache();

        if (! c_c115 && this.checkCalculateNoNeverLedger(_projListStateType))
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Hour));
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjNoLedger));
                this.transNoEliminationOrigin();
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjNoLedger));
                this.budgetNoElimination();
            }

            [c115,qtyC115]  = this.getQueryValues();

            if (! this.checkHourQty())
            {
                qtyC115 = 0;
            }

            if (! this.checkHourAmount())
            {
                c115 = 0;
            }

            switch (_projListStateType)
            {
                case ProjListStateType::Consumption:
                    if (!ProjParameters::find().StatementConsumpHourCost)
                    {
                        c115        = 0;
                    }
                    break;

                case ProjListStateType::ConsumptionActivity:
                    if (!ProjParameters::find().StatementConsumpHourCost)
                    {
                        c115        = 0;
                    }
                    break;

                case ProjListStateType::ProfitLoss:
                    if (! ProjParameters::find().StatementPLHourCost)
                    {
                        c115        = 0;
                    }
                    break;

                case ProjListStateType::ProfitLossActivity:
                    if (! ProjParameters::find().StatementPLHourCost)
                    {
                        c115        = 0;
                    }
                    break;

                default:
                    c115        = 0;
                    break;
            }

            switch (_projListStateType)
            {
                case ProjListStateType::Consumption:
                    if (!ProjParameters::find().StatementConsumpHourQty)
                    {
                        qtyC115        = 0;
                    }
                    break;

                case ProjListStateType::ConsumptionActivity:
                    if (!ProjParameters::find().StatementConsumpHourQty)
                    {
                        qtyC115        = 0;
                    }
                    break;

                case ProjListStateType::ProfitLoss:
                    if (! ProjParameters::find().StatementPLHourQty)
                    {
                        qtyC115        = 0;
                    }
                    break;

                case ProjListStateType::ProfitLossActivity:
                    if (! ProjParameters::find().StatementPLHourQty)
                    {
                        qtyC115        = 0;
                    }
                    break;

                default:
                    qtyC115        = 0;
                    break;
            }

            c_c115          = true;
        }

        return qtyC115;
    }

]]></Source>
			</Method>
			<Method>
				<Name>c120_Consumption_Item</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total amount that is posted by using the <c>ProjStatusAccountItem</c> and
    /// <c>ProjCost</c> ledger posting types for item transactions on a particular project or on all
    /// projects that are used in any project consumption statement report.
    /// </summary>
    /// <returns>
    /// The total amount that is posted by using the <c>ProjStatusAccountItem</c> and <c>ProjCost</c>
    /// ledger posting type for item transactions on a project or all projects.
    /// </returns>
    /// <remarks>
    /// This method can be used to determine either the actual amount or the budgeted amount. It also
    /// caches this value and does not recalculate it if a value exists in the cache. The total amount is
    /// determined by the following: the return value of the <see cref="M:projStatement.A315_Item_Total" />
    /// method plus the return value of the <see cref="M:projStatement.B215_WIP_CostValue_Item" /> method.
    /// </remarks>
    AmountMST c120_Consumption_Item()
    {
        this.checkCache();

        if (! c_c120)
        {
            c120    = this.b215_wip_CostValue_Item(true)+
                  this.a315_Item_Total(true,true);

            c_c120  = true;
        }

        return c120;
    }

]]></Source>
			</Method>
			<Method>
				<Name>c122_Consumption_Item</Name>
				<Source><![CDATA[
    AmountMST c122_Consumption_Item(boolean     consump = true)
    {
        c_c122  = false;

        this.checkCache();

        if (! c_c122 && item &&
        ((consump  && ProjParameters::find().ItemNeverLedgerConsum) ||
         (!consump && ProjParameters::find().ItemNeverLedgerPL)))
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Item));
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjNeverLedger));
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Item));
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjNeverLedger));
            }

            [c122, tempProjQty]    = this.getQueryValues();
            c_c122          = true;
        }

        return c122;
    }

]]></Source>
			</Method>
			<Method>
				<Name>c125_Consumption_Cost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total amount that is posted by using the <c>ProjWIPCostvalue</c> and <c>ProjCost</c>
    /// ledger posting types for expense transactions on a particular project or on all projects that are
    /// used in any project consumption statement report.
    /// </summary>
    /// <returns>
    /// The total amount that is posted by using the <c>ProjWIPCostvalue</c> and <c>ProjCost</c> ledger
    /// posting type for expense transactions on a project or on all projects.
    /// </returns>
    /// <remarks>
    /// This method can be used to determine either the actual amount or the budgeted amount. It also
    /// caches this value and does not recalculate it if a value exists in the cache. The total amount is
    /// determined by the following: the return value of the <see cref="M:projStatement.A330_Cost_Expenses"
    /// /> method plus the return value of the <see cref="M:projStatement.B220_WIP_CostValue_Expenses" />
    /// method.
    /// </remarks>
    AmountMST c125_Consumption_Cost()
    {
        this.checkCache();

        if (! c_c125)
        {
            c125    = this.a330_Cost_Expenses(true)+
                  this.b220_wip_CostValue_Expenses(true);
            c_c125  = true;
        }

        return c125;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateControlTrans</Name>
				<Source><![CDATA[
    //TOD:RevRecog
//Classes\ProjControlPosting
    private boolean canCreateControlTrans()
    {
        boolean ret;

        /*if (this.elimination())
    {
        switch (projGroup.CompletePrincip)
        {
            case ProjCompletePrincip::CompletedContract:
                switch (projGroup.InvoicePosting)
                {
                    case ProjLedgerStatusOnAcc::BalanceSheet:
                        switch (projGroup.MatchingPrincip)
                        {
                            case ProjMatchingPrincip::ProductionProfit:
                                switch (projGroup.SalesPriceMatchingPrincip)
                                {
                                    case ProjSalesPriceMatchingPrincip::ValueAddedMarkupPercent:
                                        ret = true;
                                        break;
                                    case ProjSalesPriceMatchingPrincip::ValueAddedHourRate:
                                        ret = true;
                                        break;
                                }
                                break;
                            case ProjMatchingPrincip::SalesValue:
                                switch (projGroup.SalesPriceMatchingPrincip)
                                {
                                    case ProjSalesPriceMatchingPrincip::MarkupPercentTotal:
                                        ret = true;
                                        break;
                                    case ProjSalesPriceMatchingPrincip::MarkupPercentEstimateLine:
                                        ret = true;
                                        break;
                                }
                                break;
                        }
                        break;
                    case ProjLedgerStatusOnAcc::Operations:
                        switch (projGroup.MatchingPrincip)
                        {
                            case ProjMatchingPrincip::ProductionProfit:
                                switch (projGroup.SalesPriceMatchingPrincip)
                                {
                                    case ProjSalesPriceMatchingPrincip::ValueAddedMarkupPercent:
                                        ret = true;
                                        break;
                                    case ProjSalesPriceMatchingPrincip::ValueAddedHourRate:
                                        ret = true;
                                        break;
                                }
                                break;
                            case ProjMatchingPrincip::SalesValue:
                                switch (projGroup.SalesPriceMatchingPrincip)
                                {
                                    case ProjSalesPriceMatchingPrincip::MarkupPercentTotal:
                                        ret = true;
                                        break;
                                    case ProjSalesPriceMatchingPrincip::MarkupPercentEstimateLine:
                                        ret = true;
                                        break;
                                }
                                break;
                        }
                        break;
                }
                break;
            case ProjCompletePrincip::CompletedPercentage:
                switch (projGroup.InvoicePosting)
                {
                    case ProjLedgerStatusOnAcc::BalanceSheet:
                        switch (projGroup.MatchingPrincip)
                        {
                            case ProjMatchingPrincip::ProductionProfit:
                                switch (projGroup.SalesPriceMatchingPrincip)
                                {
                                    case ProjSalesPriceMatchingPrincip::ValueAddedMarkupPercent:
                                        ret = true;
                                        break;
                                    case ProjSalesPriceMatchingPrincip::ValueAddedHourRate:
                                        ret = true;
                                        break;
                                }
                                break;
                            case ProjMatchingPrincip::SalesValue:
                                switch (projGroup.SalesPriceMatchingPrincip)
                                {
                                    case ProjSalesPriceMatchingPrincip::MarkupPercentTotal:
                                        ret = true;
                                        break;
                                    case ProjSalesPriceMatchingPrincip::MarkupPercentEstimateLine:
                                        ret = true;
                                        break;
                                }
                                break;
                        }
                        break;
                    case ProjLedgerStatusOnAcc::Operations:
                        switch (projGroup.MatchingPrincip)
                        {
                            case ProjMatchingPrincip::ProductionProfit:
                                switch (projGroup.SalesPriceMatchingPrincip)
                                {
                                    case ProjSalesPriceMatchingPrincip::ValueAddedMarkupPercent:
                                        ret = true;
                                        break;
                                    case ProjSalesPriceMatchingPrincip::ValueAddedHourRate:
                                        ret = true;
                                        break;
                                }
                                break;
                            case ProjMatchingPrincip::SalesValue:
                                switch (projGroup.SalesPriceMatchingPrincip)
                                {
                                    case ProjSalesPriceMatchingPrincip::MarkupPercentTotal:
                                        ret = true;
                                        break;
                                    case ProjSalesPriceMatchingPrincip::MarkupPercentEstimateLine:
                                        ret = true;
                                        break;
                                }
                                break;
                        }
                        break;
                }
                break;
        }
    }
    else
    {
        switch (projGroup.CompletePrincip)
        {
            case ProjCompletePrincip::CompletedContract:
                switch (projGroup.InvoicePosting)
                {
                    case ProjLedgerStatusOnAcc::BalanceSheet:
                        switch (projGroup.MatchingPrincip)
                        {
                            case ProjMatchingPrincip::ProductionProfit:
                                switch (projGroup.SalesPriceMatchingPrincip)
                                {
                                    case ProjSalesPriceMatchingPrincip::ValueAddedMarkupPercent:
                                        ret = true;
                                        break;
                                    case ProjSalesPriceMatchingPrincip::ValueAddedHourRate:
                                        ret = true;
                                        break;
                                }
                                break;
                            case ProjMatchingPrincip::SalesValue:
                                switch (projGroup.SalesPriceMatchingPrincip)
                                {
                                    case ProjSalesPriceMatchingPrincip::MarkupPercentTotal:
                                        ret = true;
                                        break;
                                    case ProjSalesPriceMatchingPrincip::MarkupPercentEstimateLine:
                                        ret = true;
                                        break;
                                }
                                break;
                        }
                        break;
                    case ProjLedgerStatusOnAcc::Operations:
                        switch (projGroup.MatchingPrincip)
                        {
                            case ProjMatchingPrincip::ProductionProfit:
                                switch (projGroup.SalesPriceMatchingPrincip)
                                {
                                    case ProjSalesPriceMatchingPrincip::ValueAddedMarkupPercent:
                                        ret = true;
                                        break;
                                    case ProjSalesPriceMatchingPrincip::ValueAddedHourRate:
                                        ret = true;
                                        break;
                                }
                                break;
                            case ProjMatchingPrincip::SalesValue:
                                switch (projGroup.SalesPriceMatchingPrincip)
                                {
                                    case ProjSalesPriceMatchingPrincip::MarkupPercentTotal:
                                        ret = true;
                                        break;
                                    case ProjSalesPriceMatchingPrincip::MarkupPercentEstimateLine:
                                        ret = true;
                                        break;
                                }
                                break;
                        }
                        break;
                }
                break;
            case ProjCompletePrincip::CompletedPercentage:
                switch (projGroup.InvoicePosting)
                {
                    case ProjLedgerStatusOnAcc::BalanceSheet:
                        switch (projGroup.MatchingPrincip)
                        {
                            case ProjMatchingPrincip::ProductionProfit:
                                switch (projGroup.SalesPriceMatchingPrincip)
                                {
                                    case ProjSalesPriceMatchingPrincip::ValueAddedMarkupPercent:
                                        ret = true;
                                        break;
                                    case ProjSalesPriceMatchingPrincip::ValueAddedHourRate:
                                        ret = true;
                                        break;
                                }
                                break;
                            case ProjMatchingPrincip::SalesValue:
                                switch (projGroup.SalesPriceMatchingPrincip)
                                {
                                    case ProjSalesPriceMatchingPrincip::MarkupPercentTotal:
                                        ret = true;
                                        break;
                                    case ProjSalesPriceMatchingPrincip::MarkupPercentEstimateLine:
                                        ret = true;
                                        break;
                                }
                                break;
                        }
                        break;
                    case ProjLedgerStatusOnAcc::Operations:
                        switch (projGroup.MatchingPrincip)
                        {
                            case ProjMatchingPrincip::ProductionProfit:
                                switch (projGroup.SalesPriceMatchingPrincip)
                                {
                                    case ProjSalesPriceMatchingPrincip::ValueAddedMarkupPercent:
                                        ret = true;
                                        break;
                                    case ProjSalesPriceMatchingPrincip::ValueAddedHourRate:
                                        ret = true;
                                        break;
                                }
                                break;
                            case ProjMatchingPrincip::SalesValue:
                                switch (projGroup.SalesPriceMatchingPrincip)
                                {
                                    case ProjSalesPriceMatchingPrincip::MarkupPercentTotal:
                                        ret = true;
                                        break;
                                    case ProjSalesPriceMatchingPrincip::MarkupPercentEstimateLine:
                                        ret = true;
                                        break;
                                }
                                break;
                        }
                        break;
                }
                break;
        }
    }*/

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the cache requires clearing. If the cache requires clearing, this method calls the <c>clearCache</c> method.
    /// </summary>
    /// <param name="_alwaysClear">
    ///    A Boolean flag that determines whether to always clear the cache; optional. true to always clear the cache. The default value is false.
    /// </param>
    void checkCache(boolean _alwaysClear  = false)
    {
        if (clearCache || _alwaysClear)
        {
            this.clearCache();
            clearCache  = false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCalculateNoNeverLedger</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the <c>ProjNoLedger</c> posting type should be included in the calculations for a particular type of project statement report.
    /// </summary>
    /// <param name="_projListStateType">
    ///    The type of project statement report.
    /// </param>
    /// <returns>
    ///    true if the <c>NoLedger</c> posting type is to be included in calculations; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This posting type is excluded from the calculation in consumption and P&amp;L statement reports when the hour cost and hour quantity for <c>NoLedger</c> postings are turned off in project setup. All
    ///    other project statement reports include this posting type in the calculations.
    /// </remarks>
    boolean checkCalculateNoNeverLedger(ProjListStateType   _projListStateType)
    {
        boolean calculate   = true;

        if (! hour)
        {
            calculate   = false;
        }

        if (_projListStateType == ProjListStateType::Consumption)
        {
            if (!(ProjParameters::find().StatementConsumpHourCost || ProjParameters::find().StatementConsumpHourQty))
            {
                calculate   = false;
            }
        }
        if (_projListStateType == ProjListStateType::ConsumptionActivity)
        {
            if (!(ProjParameters::find().StatementConsumpHourCost || ProjParameters::find().StatementConsumpHourQty))
            {
                calculate   = false;
            }
        }
        else if (_projListStateType == ProjListStateType::ProfitLoss)
        {
            if (!(ProjParameters::find().StatementPLHourCost || ProjParameters::find().StatementPLHourQty))
            {
                calculate   = false;
            }
        }
        else if (_projListStateType == ProjListStateType::ProfitLossActivity)
        {
            if (!(ProjParameters::find().StatementPLHourCost || ProjParameters::find().StatementPLHourQty))
            {
                calculate   = false;
            }
        }

        return calculate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkHourAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if hour transactions are calculated as an amount.
    /// </summary>
    /// <returns>
    ///    true if an hour transaction should be calculated as an amount; false if it should be calculated as a quantity.
    /// </returns>
    boolean checkHourAmount()
    {
        if (this.parmAmountQty() != ProjAmountQty::Qty)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkHourQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether hour transactions are calculated as quantity.
    /// </summary>
    /// <returns>
    ///    true if an hour transaction should be calculated as a quantity; false if it should be calculated as an amount.
    /// </returns>
    boolean checkHourQty()
    {
        if (this.parmAmountQty() != ProjAmountQty::Amount)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears the cache used by each type of project statement report if the cache is not empty.
    /// </summary>
    void clearCache()
    {
        if (c_a100 ||  c_a105    ||  c_a110 ||  c_a110Qty   || c_a115 ||  c_a120 ||
        c_a125 ||  c_a135    ||  c_a200 ||  c_a205      ||
        c_a210 ||  c_a215    ||  c_a220 ||  c_a225      ||  c_a230 ||
        c_a235 ||  c_a240    ||  c_a265 ||  c_a245 ||  c_a250      ||  c_a255 ||
        c_a260Fee   ||  c_a260Hour  ||  c_a260Exp   ||  c_a260Item  ||
        c_a285Fee   ||  c_a285Hour  ||  c_a285Exp   ||  c_a285Item  ||
        c_a270 ||  c_a300      ||  c_a305 ||
        c_a310 ||  c_a310Qty ||
        c_a315 ||  c_a320    ||  c_a325 ||  c_a330      ||
        c_a335 ||  c_a400    ||  c_a500)
        {
            this.clearCacheA();
        }

        if (c_b100 ||  c_b105 ||
        c_b110 ||  c_b110Qty ||
        c_b115 ||  c_b120 ||
        c_b125 ||  c_b128 ||  c_b130 ||  c_b155 ||  c_b135 ||  c_b140 ||  c_b145 ||
        c_b150Fee   ||  c_b150Hour  ||  c_b150Exp   ||  c_b150Item  ||
        c_b175Fee   ||  c_b175Hour  ||  c_b175Exp   ||  c_b175Item  ||
        c_b200 ||  c_b200Qty ||
        c_b205 ||
        c_b210 ||  c_b210Qty ||
        c_b215 ||  c_b220 ||  c_b225 ||  c_b300 ||  c_b400 ||
        c_b500)
        {
            this.clearCacheB();
        }

        if (c_c100 ||  c_c105 ||  c_c110 ||  c_c115 ||  c_c120 || c_c122 ||
        c_c125 ||  c_c105Qty)
        {
            this.clearCacheC();
        }

        if (c_d100 || c_d100Qty)
        {
            this.clearCacheD();
        }

        if (c_e100 || c_e200 || c_e300 || c_e310 ||
        c_e320 || c_e330 || c_e340 || c_e350)
        {
            this.clearCacheE();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCacheA</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears the cache that is used by the P&amp;L and Hour Rate project statement reports.
    /// </summary>
    void clearCacheA()
    {
        c_a100  = false;
        c_a105  = false;
        c_a110  = false;
        c_a115  = false;
        c_a120  = false;

        c_a110Qty   = false;

        c_a125  = false;
        c_a135  = false;
        c_a200  = false;
        c_a205  = false;

        c_a210  = false;
        c_a215  = false;
        c_a220  = false;
        c_a225  = false;
        c_a230  = false;

        c_a235  = false;
        c_a240  = false;
        c_a265  = false;
        c_a245  = false;
        c_a250  = false;
        c_a255  = false;

        c_a260Fee  = false;
        c_a260Hour  = false;
        c_a260Exp  = false;
        c_a260Item  = false;
        c_a285Fee  = false;
        c_a285Hour  = false;
        c_a285Exp  = false;
        c_a285Item  = false;
        c_a270  = false;
        c_a300  = false;
        c_a305  = false;

        c_a310  = false;

        c_a315  = false;
        c_a320  = false;
        c_a325  = false;
        c_a330  = false;

        c_a335  = false;
        c_a400  = false;
        c_a500  = false;

        c_a310Qty   = false;

        a100  = 0;
        a105  = 0;
        a110  = 0;
        a115  = 0;
        a120  = 0;

        a125  = 0;
        a135  = 0;
        a200  = 0;
        a205  = 0;

        a210  = 0;
        a215  = 0;
        a220  = 0;
        a225  = 0;
        a230  = 0;

        a235  = 0;
        a240  = 0;
        a265  = 0;
        a245  = 0;
        a250  = 0;
        a255  = 0;

        a260Fee  = 0;
        a260Hour  = 0;
        a260Exp  = 0;
        a260Item  = 0;
        a285Fee  = 0;
        a285Hour  = 0;
        a285Exp  = 0;
        a285Item  = 0;
        a270  = 0;
        a300  = 0;
        a305  = 0;

        a310  = 0;
        a315  = 0;
        a320  = 0;
        a325  = 0;
        a330  = 0;

        a335  = 0;
        a400  = 0;
        a500  = 0;

        qtyA110 = 0;
        qtyA310 = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCacheB</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears the cache that is used by the WIP project statement reports.
    /// </summary>
    void clearCacheB()
    {
        c_b100  = false;
        c_b105  = false;
        c_b105qty   = false;
        c_b110  = false;
        c_b110Qty   = false;

        c_b115  = false;
        c_b120  = false;

        c_b125  = false;
        c_b128  = false;
        c_b130  = false;
        c_b155  = false;
        c_b135  = false;
        c_b140  = false;
        c_b145  = false;

        c_b150Fee  = false;
        c_b150Hour  = false;
        c_b150Exp  = false;
        c_b150Item  = false;
        c_b175Fee  = false;
        c_b175Hour  = false;
        c_b175Exp  = false;
        c_b175Item  = false;
        c_b200  = false;
        c_b200Qty = false;

        c_b205  = false;
        c_b205qty = false;
        c_b210  = false;
        c_b210Qty = false;

        c_b215  = false;
        c_b220  = false;
        c_b225  = false;
        c_b300  = false;
        c_b300Qty = false;
        c_b400  = false;

        c_b500  = false;

        qtyB100 = 0;
        qtyb105 = 0;
        qtyb110 = 0;
        qtyB200 = 0;
        qtyB205 = 0;
        qtyB210 = 0;
        qtyb300 = 0;

        b100 = 0;
        b105 = 0;
        b110 = 0;
        b115 = 0;
        b120 = 0;

        b125 = 0;
        b128 = 0;
        b130 = 0;
        b155 = 0;
        b135 = 0;
        b140 = 0;
        b145 = 0;

        b150Fee = 0;
        b150Hour = 0;
        b150Exp = 0;
        b150Item = 0;
        b175Fee = 0;
        b175Hour = 0;
        b175Exp = 0;
        b175Item = 0;
        b200 = 0;
        b205 = 0;
        b210 = 0;

        b215 = 0;
        b220 = 0;
        b225 = 0;
        b300 = 0;
        b400 = 0;

        b500 = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCacheC</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears the cache that is used by the consumption project statement reports.
    /// </summary>
    void clearCacheC()
    {
        c_c100  = false;
        c_c105  = false;
        c_c110  = false;
        c_c115  = false;
        c_c120  = false;
        c_c122  = false;

        c_c125  = false;

        c_c105Qty  = false;
        qtyC105 = 0;
        qtyC110 = 0;
        qtyC115 = 0;

        c100    = 0;
        c105    = 0;
        c110    = 0;
        c115    = 0;
        c120    = 0;
        c122    = 0;

        c125    = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCacheD</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears the cache that is used by the payroll project statement reports.
    /// </summary>
    void clearCacheD()
    {
        c_d100      = false;
        c_d100Qty   = false;

        d100  = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCacheE</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears the cache that is used by the on-account project statement reports.
    /// </summary>
    void clearCacheE()
    {
        c_e100      = false;
        c_e200      = false;
        c_e300      = false;
        c_e310      = false;
        c_e320      = false;
        c_e330      = false;
        c_e340      = false;
        c_e350      = false;

        e100    = 0;
        e200    = 0;
        e300    = 0;
        e310    = 0;
        e320    = 0;
        e330    = 0;
        e340    = 0;
        e350    = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>consumptionExpenseCost</Name>
				<Source><![CDATA[
    void consumptionExpenseCost()
    {
        if (expenses && (this.ledgerCost() || this.ledgerWIPCostvalue()))
        {
            query   = this.queryBuildExcelPivot();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Cost));
                if (this.ledgerCost())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjCost));
                }
                if (this.ledgerWIPCostvalue())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPCostvalue));
                }
                this.transNoEliminationOrigin();
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Cost));
                if (this.ledgerCost())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjCost));
                }
                if (this.ledgerWIPCostvalue())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPCostvalue));
                }
                this.budgetNoElimination();
            }

            this.setTmpProjStatisticExcelPivot(ProjStatisticDimension::ConsumptionExpenseCost, ProjExportToExcelWorksheet::StatConsumption);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>consumptionHourQtyAndCost</Name>
				<Source><![CDATA[
    void consumptionHourQtyAndCost()
    {
        if ((hour && this.checkHourQty()) &&
        (this.ledgerCost() ||
        (ProjParameters::find().StatementConsumpHourQty || ProjParameters::find().StatementConsumpHourCost) ||
        this.ledgerWIPCostvalue()))
        {
            query   = this.queryBuildExcelPivot();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Hour));
                if (this.ledgerCost())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjCost));
                }
                if (ProjParameters::find().StatementConsumpHourQty || ProjParameters::find().StatementConsumpHourCost)
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjNeverLedger));
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjNoLedger));
                }
                if (this.ledgerWIPCostvalue())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPCostvalue));
                }
                this.transNoEliminationOrigin();
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));
                if (this.ledgerCost())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjCost));
                }
                if (ProjParameters::find().StatementConsumpHourQty || ProjParameters::find().StatementConsumpHourCost)
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjNeverLedger));
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjNoLedger));
                }
                if (this.ledgerWIPCostvalue())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPCostvalue));
                }
                this.budgetNoElimination();
            }

            this.setTmpProjStatisticExcelPivot(ProjStatisticDimension::ConsumptionHourQtyAndCost, ProjExportToExcelWorksheet::StatConsumption);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>consumptionItemCost</Name>
				<Source><![CDATA[
    void consumptionItemCost()
    {
        if (item && (this.ledgerWIPCostvalue() || this.ledgerCost() || this.ledgerOffsetAccountItem() || ProjParameters::find().ItemNeverLedgerConsum))
        {
            query   = this.queryBuildExcelPivot();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Item));
                if (this.ledgerWIPCostvalue())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjStatusAccountItem));
                }
                if (this.ledgerCost())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjCost));
                }
                if (this.ledgerOffsetAccountItem())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjOffsetAccountItem));
                }
                if (ProjParameters::find().ItemNeverLedgerConsum)
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjNeverLedger));
                }
                this.transNoEliminationOrigin();
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Item));
                if (this.ledgerWIPCostvalue())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjStatusAccountItem));
                }
                if (this.ledgerCost())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjCost));
                }
                if (this.ledgerOffsetAccountItem())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjOffsetAccountItem));
                }
                if (ProjParameters::find().ItemNeverLedgerConsum)
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjNeverLedger));
                }
                this.budgetNoElimination();
            }

            this.setTmpProjStatisticExcelPivot(ProjStatisticDimension::ConsumptionItemCost, ProjExportToExcelWorksheet::StatConsumption);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>costAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a zero cost amount. This method can be overridden by sub classes that derive from this class.
    /// </summary>
    /// <returns>
    ///    A zero cost amount.
    /// </returns>
    AmountMST costAmount()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>d100_PayrollAllocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total amount that is posted by using the <c>ProjPayrollAllocation</c> ledger posting
    /// type for hour transactions on a particular project or all projects used in any payroll project
    /// statement report.
    /// </summary>
    /// <returns>
    /// The total amount that is posted by using the <c>ProjPayrollAllocation</c> ledger posting type for
    /// hour transactions on a project or all projects.
    /// </returns>
    /// <remarks>
    /// This method can be used to determine either the actual amount or budgeted amount. It also caches
    /// this value and does not recalculate it if a value is in the cache.
    /// </remarks>
    Qty d100_PayrollAllocation()
    {
        this.checkCache();

        if (! c_d100 && hour && this.checkHourAmount())
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Hour));

                if (this.ledgerPayrollAllocation())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjPayrollAllocation));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));

                if (this.ledgerPayrollAllocation())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjPayrollAllocation));
                }
            }

            [d100,qtyD100]  = this.getQueryValues();

            qtyD100         = 0;
            c_d100Qty       = false;

            d100            = -d100;
            c_d100          = true;
        }

        return d100;
    }

]]></Source>
			</Method>
			<Method>
				<Name>d100_PayrollAllocation_Qty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total number of hours that are posted by using the <c>ProjPayrollAllocation</c>
    /// ledger posting type for hour transactions on a particular project or all projects used in any
    /// payroll project statement report.
    /// </summary>
    /// <returns>
    /// The total number of hours that are posted by using the <c>ProjPayrollAllocation</c> ledger posting
    /// type for hour transactions on a project or all projects.
    /// </returns>
    /// <remarks>
    /// This method can be used to determine either the actual quantity or budgeted quantity. It also
    /// caches this value and does not recalculate it if a value is in the cache.
    /// </remarks>
    public ProjQty d100_PayrollAllocation_Qty()
    {
        this.checkCache();

        if (! c_d100Qty && hour && this.checkHourQty())
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Hour));

                if (this.ledgerPayrollAllocation())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjPayrollAllocation));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));

                if (this.ledgerPayrollAllocation())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjPayrollAllocation));
                }
            }

            [d100,qtyD100]  = this.getQueryValues();

            d100            = 0;
            c_d100          = false;

            qtyD100         = -qtyD100;
            c_d100Qty       = true;
        }

        return qtyD100;
    }

]]></Source>
			</Method>
			<Method>
				<Name>e100_Total_Revenue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total revenue posted for on-account transactions on a particular project or on all
    /// projects that are used in any on-account project statement report.
    /// </summary>
    /// <returns>
    /// The total revenue that is posted for on-account transactions on a particular project or on all
    /// projects that are used in any on-account project statement report.
    /// </returns>
    /// <remarks>
    ///  The following ledger posting types are used to determine the amount:
    ///  <list type="bullet">
    ///   <item>
    ///    <description>
    ///    <c>ProjPayrollAllocation</c>
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <description>
    ///    <c>ProjWIPInvoiceOnAccount</c>
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <description>
    ///    <c>ProjAccruedRevenueOnAccount</c>
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <description>
    ///    <c>ProjOnAccount</c>
    ///    </description>
    ///   </item>
    ///  </list>
    ///  Eliminations are not included in this amount. This method can be used to determine either the
    ///  actual amount or budgeted amount. It also caches this value and does not recalculate it if a value
    ///  is in the cache.
    /// </remarks>
    AmountMST e100_Total_Revenue()
    {
        this.checkCache();

        if (!c_e100 && onAccount)
        {
            query = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting, LedgerOrigin)).value(SysQuery::valueNot(enum2Value(ProjOrigin::EliminateEstimate)));
                transDataSource.addRange(fieldNum(ProjTransPosting, LedgerOrigin)).value(SysQuery::valueNot(enum2Value(ProjOrigin::ReverseElimination)));

                transDataSource.addRange(fieldNum(ProjTransPosting, ProjTransType)).value(queryValue(ProjTransType::OnAccount));

                if (this.ledgerPayrollAllocation())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjPayrollAllocation));
                }

                if (this.ledgerWIPInvoicedOnAccount())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPInvoicedOnAccount));
                }

                if (this.ledgerAccruedRevenueOnAccount())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjAccruedRevenueOnAccount));
                }

                if (this.ledgerOnAccount())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjOnAccount));
                }
            }
            else
        if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget, Elimination)).value(queryValue(NoYes::No));
                transDataSource.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::OnAccount));

                if (this.ledgerPayrollAllocation())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjPayrollAllocation));
                }
                if (this.ledgerWIPInvoicedOnAccount())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjWIPInvoicedOnAccount));
                }

                if (this.ledgerAccruedRevenueOnAccount())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjAccruedRevenueOnAccount));
                }

                if (this.ledgerOnAccount())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjOnAccount));
                }
            }

            [e100,tempProjQty]    = this.getQueryValues();
            c_e100          = true;
        }

        return e100;
    }

]]></Source>
			</Method>
			<Method>
				<Name>e200_Invoice_Total</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total invoiced revenue for all transaction types.
    /// </summary>
    /// <returns>
    ///    The total invoiced amount in the company currency.
    /// </returns>
    /// <remarks>
    ///    This method can specify either the actual amount or the budgeted amount. It also caches this value
    ///    and does not recalculate it if a value is in the cache.For the on account type, it includes the
    ///    project WIP-invoiced and invoiced revenues of the on account. For other transaction types, it
    ///    includes the project invoiced revenue.
    /// </remarks>
    public AmountMST e200_Invoice_Total()
    {
        this.checkCache();

        if (!c_e200)
        {
            e200 = this.a110_Invoiced_Revenue_Hour() +
               this.a115_Invoiced_Revenue_Item() +
               this.a120_Invoiced_Revenue_Expenses() +
               this.a125_Invoiced_Revenue_Revenue() +
               this.e300_Invoice_OnAcc();

            c_e200 = true;
        }

        return e200;
    }

]]></Source>
			</Method>
			<Method>
				<Name>e300_Invoice_OnAcc</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total on account invoiced revenue.
    /// </summary>
    /// <returns>
    ///    Return the total invoiced amount in company's currency
    /// </returns>
    /// <remarks>
    ///    For the on account type, it includes the project WIP-invoiced and invoiced revenue. In the actual
    ///    transaction, on account transactions are detailed to these types: prepayment, deduction, progress
    ///    billing, beginning balance, and milestone; in the budget transaction, e310, e320, e330, e340, and
    ///    e350 all return the same amount, without becoming the on account type.This method can be used to
    ///    determine either the actual amount or the budgeted amount. It also caches this value and does not
    ///    recalculate it if a value is in the cache.
    /// </remarks>
    public AmountMST e300_Invoice_OnAcc()
    {
        this.checkCache();

        if (!c_e300)
        {
            if (this.parmActual())
            {
                e300 = this.e310_Invoice_OnAcc_Prepayment() +
                   this.e320_Invoice_OnAcc_Deduction()  +
                   this.e330_Invoice_OnAcc_Milestone()  +
                   this.e350_Invoice_OnAcc_BeginningBalance();
                c_e300 = true;
            }
            else if (this.parmBudget())
            {
                e300 = this.e310_Invoice_OnAcc_Prepayment();
                c_e300 = true;
            }
        }

        return e300;
    }

]]></Source>
			</Method>
			<Method>
				<Name>e310_Invoice_OnAcc_Prepayment</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total on account invoiced revenue for the prepayment type on the account transaction.
    /// </summary>
    /// <returns>
    ///    The total invoiced amount in the company currency.
    /// </returns>
    /// <remarks>
    ///    This method can specify either the actual amount or the budgeted amount. It also caches this value
    ///    and does not recalculate it if a value is in the cache.
    /// </remarks>
    public AmountMST e310_Invoice_OnAcc_Prepayment()
    {
        this.checkCache();

        if (!c_e310 && onAccount)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::OnAccount));
                transDataSource.addRange(fieldNum(ProjTransPosting,TransactionOrigin)).value(queryValue(ProjOrigin::Prepayment));
                transDataSource.addRange(fieldNum(ProjTransPosting,LedgerOrigin)).value(queryValue(ProjOrigin::Invoice));

                if (this.ledgerTurnover())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjOnAccount));
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPInvoicedOnAccount));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::OnAccount));

                if (this.ledgerTurnover())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjOnAccount));
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPInvoicedOnAccount));
                }
            }

            [e310, tempProjQty] = this.getQueryValues();
            e310          = -e310;
            c_e310        = true;
        }

        return e310;
    }

]]></Source>
			</Method>
			<Method>
				<Name>e320_Invoice_OnAcc_Deduction</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total on account invoiced revenue for the deduction type on the account transaction.
    /// </summary>
    /// <returns>
    ///    The total invoiced amount in the company currency.
    /// </returns>
    /// <remarks>
    ///    This method can specify either the actual amount or the budgeted amount. It also caches this value
    ///    and does not recalculate it if a value is in the cache.
    /// </remarks>
    public AmountMST e320_Invoice_OnAcc_Deduction()
    {
        this.checkCache();

        if (!c_e320 && onAccount)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::OnAccount));
                transDataSource.addRange(fieldNum(ProjTransPosting,TransactionOrigin)).value(queryValue(ProjOrigin::Deduction));
                transDataSource.addRange(fieldNum(ProjTransPosting,LedgerOrigin)).value(queryValue(ProjOrigin::Invoice));

                if (this.ledgerTurnover())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjOnAccount));
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPInvoicedOnAccount));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::OnAccount));

                if (this.ledgerTurnover())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjOnAccount));
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPInvoicedOnAccount));
                }
            }

            [e320, tempProjQty] = this.getQueryValues();
            e320          = -e320;
            c_e320        = true;
        }

        return e320;
    }

]]></Source>
			</Method>
			<Method>
				<Name>e330_Invoice_OnAcc_Milestone</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total on account invoiced revenue for the milestone type on the account transaction.
    /// </summary>
    /// <returns>
    ///    The total invoiced amount in the company currency.
    /// </returns>
    /// <remarks>
    ///    This method can specify either the actual amount or the budgeted amount. It also caches this value
    ///    and does not recalculate it if a value is in the cache.
    /// </remarks>
    public AmountMST e330_Invoice_OnAcc_Milestone()
    {
        this.checkCache();

        if (!c_e330 && onAccount)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::OnAccount));
                transDataSource.addRange(fieldNum(ProjTransPosting,TransactionOrigin)).value(queryValue(ProjOrigin::Milestone));
                transDataSource.addRange(fieldNum(ProjTransPosting,TransactionOrigin)).value(queryValue(ProjOrigin::ProgressBillingRule));
                transDataSource.addRange(fieldNum(ProjTransPosting,TransactionOrigin)).value(queryValue(ProjOrigin::UnitOfDeliveryBillingRule));
                transDataSource.addRange(fieldNum(ProjTransPosting,LedgerOrigin)).value(queryValue(ProjOrigin::Invoice));

                if (this.ledgerTurnover())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjOnAccount));
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPInvoicedOnAccount));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::OnAccount));

                if (this.ledgerTurnover())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjOnAccount));
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPInvoicedOnAccount));
                }
            }

            [e330, tempProjQty] = this.getQueryValues();
            e330          = -e330;
            c_e330        = true;
        }

        return e330;
    }

]]></Source>
			</Method>
			<Method>
				<Name>e350_Invoice_OnAcc_BeginningBalance</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the total on account invoiced revenue for beginning balance type on account transaction
    /// </summary>
    /// <returns>
    ///    Return the total invoiced amount in company's currency
    /// </returns>
    /// <remarks>
    ///    This method can be used to determine either the actual amount or budgeted amount. It also caches this value and does not recalculate it if a value is in the cache.
    /// </remarks>
    public AmountMST e350_Invoice_OnAcc_BeginningBalance()
    {
        this.checkCache();

        if (!c_e350 && onAccount)
        {
            query   = this.queryBuild();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::OnAccount));
                transDataSource.addRange(fieldNum(ProjTransPosting,TransactionOrigin)).value(queryValue(ProjOrigin::BeginningBalance));
                transDataSource.addRange(fieldNum(ProjTransPosting,LedgerOrigin)).value(queryValue(ProjOrigin::BeginningBalance));

                if (this.ledgerTurnover())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjOnAccount));
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPInvoicedOnAccount));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::OnAccount));

                if (this.ledgerTurnover())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjOnAccount));
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPInvoicedOnAccount));
                }
            }

            [e350, tempProjQty] = this.getQueryValues();
            e350          = -e350;
            c_e350        = true;
        }

        return e350;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQueryValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total amount and total quantity for all the records in the <c>ProjTransPosting</c> table
    /// or <c>ProjTransBudget</c> table returned by the query built for a project statement report. The two
    /// values are returned in a container.
    /// </summary>
    /// <returns>
    /// A container that contains the total amount and total quantity for posting records returned by the
    /// query.
    /// </returns>
    container getQueryValues()
    {
        AmountMST   amountMST;
        Qty         qty;

        queryRun        = new QueryRun(query);

        while (queryRun.next())
        {
            if (this.parmActual())
            {
                projTransPosting= queryRun.get(tableNum(ProjTransPosting));
                amountMST   += projTransPosting.AmountMst;
                qty         += projTransPosting.Qty;
            }
            else if (this.parmBudget())
            {
                projTransBudget = queryRun.get(tableNum(ProjTransBudget));
                amountMST   += projTransBudget.AmountMst;
                qty         += projTransBudget.Qty;
            }
        }

        return (!isConfigurationkeyEnabled(configurationKeyNum(Project)) ||
            (this.psaParmProjAmountUnit() == PSAProjAmountVsUnit::Amount)
                                        ?  [amountMST, qty]
                                        :  [qty, amountMST]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceOnAccount</Name>
				<Source><![CDATA[
    void invoiceOnAccount()
    {
        query   = this.queryBuildExcelPivot();

        if (this.parmActual())
        {
            transDataSource.addRange(fieldNum(ProjTransPosting, LedgerOrigin)).value(SysQuery::valueNot(enum2Value(ProjOrigin::EliminateEstimate)));
            transDataSource.addRange(fieldNum(ProjTransPosting, LedgerOrigin)).value(SysQuery::valueNot(enum2Value(ProjOrigin::ReverseElimination)));

            if (onAccount && this.ledgerWIPInvoicedOnAccount())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPInvoicedOnAccount));
            }

            if (onAccount && this.ledgerOnAccount())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjOnAccount));
            }
            if (this.ledgerTurnover())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjTurnover));
            }
        }

        else if (this.parmBudget())
        {
            transDataSource.addRange(fieldNum(ProjTransBudget, Elimination)).value(queryValue(NoYes::No));
            if (onAccount && this.ledgerWIPInvoicedOnAccount())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjWIPInvoicedOnAccount));
            }

            if (onAccount && this.ledgerOnAccount())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjOnAccount));
            }
            if (this.ledgerTurnover())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjTurnover));
            }
        }

        this.setTmpProjStatisticExcelPivot(ProjStatisticDimension::InvoiceOnAccount, ProjExportToExcelWorksheet::StatInvoice);
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerAccruedCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether <c>ProjAccruedCost</c> ledger postings are included in the calculations.
    /// </summary>
    /// <returns>
    ///    false.
    /// </returns>
    /// <remarks>
    ///    Returns false so that <c>ProjAccruedCost</c> ledger postings are not included in the calculations. This method can be overridden to change the default behavior.
    /// </remarks>
    boolean ledgerAccruedCost()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerAccruedRevenueOnAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns false so that <c>ProjAccruedRevenueOnAccount</c> ledger postings are not included in the calculations.
    /// </summary>
    /// <returns>
    ///    false.
    /// </returns>
    /// <remarks>
    ///    This method can be overridden to change the default behavior.
    /// </remarks>
    boolean ledgerAccruedRevenueOnAccount()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerAccruedRevenueSubscription</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns false so that subscription ledger postings are not included in the calculations.
    /// </summary>
    /// <returns>
    ///    false.
    /// </returns>
    /// <remarks>
    ///    This method can be overridden to change the default behavior.
    /// </remarks>
    boolean ledgerAccruedRevenueSubscription()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerAccruedTurnoverProd</Name>
				<Source><![CDATA[
    boolean ledgerAccruedTurnoverProd()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerAccruedTurnoverProfit</Name>
				<Source><![CDATA[
    boolean ledgerAccruedTurnoverProfit()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns false so that <c>ProjCost</c> ledger postings are not included in the calculations.
    /// </summary>
    /// <returns>
    ///    false.
    /// </returns>
    /// <remarks>
    ///    This method can be overridden to change the default behavior.
    /// </remarks>
    boolean ledgerCost()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerOffsetAccountItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns false so that <c>ProjOffsetAccountItem</c> ledger postings are not included in the calculations.
    /// </summary>
    /// <returns>
    ///    false.
    /// </returns>
    /// <remarks>
    ///    This method can be overridden to change the default behavior.
    /// </remarks>
    boolean ledgerOffsetAccountItem()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerOnAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns false so that <c>ProjOnAccount</c> ledger postings are not included in the calculations.
    /// </summary>
    /// <returns>
    ///    false.
    /// </returns>
    /// <remarks>
    ///    This method can be overridden to change the default behavior.
    /// </remarks>
    boolean ledgerOnAccount()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerPayrollAllocation</Name>
				<Source><![CDATA[
    boolean ledgerPayrollAllocation()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerSalesvalue</Name>
				<Source><![CDATA[
    boolean ledgerSalesvalue()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerSalesvalueOffset</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns false so that <c>ProjSalesvalueOffset</c> and <c>ProjWIPSubscription</c> ledger postings are not included in the calculations.
    /// </summary>
    /// <returns>
    ///    false.
    /// </returns>
    /// <remarks>
    ///    This method can be overridden to change the default behavior.
    /// </remarks>
    boolean ledgerSalesvalueOffset()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerStatusAccountItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns false so that <c>ProjStatusAccountItem</c> ledger postings are not included in the calculations.
    /// </summary>
    /// <returns>
    ///    false.
    /// </returns>
    /// <remarks>
    ///    This method can be overridden to change the default behavior.
    /// </remarks>
    boolean ledgerStatusAccountItem()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerTurnover</Name>
				<Source><![CDATA[
    boolean ledgerTurnover()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerWIPCostvalue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns false so that <c>ProjWIPCostvalue</c> ledger postings are not included in the calculations.
    /// </summary>
    /// <returns>
    ///    false.
    /// </returns>
    /// <remarks>
    ///    This method can be overridden to change the default behavior.
    /// </remarks>
    boolean ledgerWIPCostvalue()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerWIPInvoicedOnAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns false so that <c>ProjWIPInvoicedOnAccount</c> ledger postings are not included in the calculations.
    /// </summary>
    /// <returns>
    ///    false.
    /// </returns>
    /// <remarks>
    ///    This method can be overridden to change the default behavior.
    /// </remarks>
    boolean ledgerWIPInvoicedOnAccount()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerWIPProduction</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns false so that <c>ProjWIPProduction</c> ledger postings are not included in the calculations.
    /// </summary>
    /// <returns>
    ///    false.
    /// </returns>
    /// <remarks>
    ///    This method can be overridden to change the default behavior.
    /// </remarks>
    boolean ledgerWIPProduction()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerWIPProfit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns false so that <c>ProjWIPProfit</c> ledger postings are not included in the calculations.
    /// </summary>
    /// <returns>
    ///    false.
    /// </returns>
    /// <remarks>
    ///    This method can be overridden to change the default behavior.
    /// </remarks>
    boolean ledgerWIPProfit()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerWIPSubscription</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns false so that subscription ledger postings are not included in the calculations.
    /// </summary>
    /// <returns>
    ///    false.
    /// </returns>
    /// <remarks>
    ///    This method can be overridden to change the default behavior.
    /// </remarks>
    boolean ledgerWIPSubscription()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmActivityNumber</Name>
				<Source><![CDATA[
    ProjActivityNumber parmActivityNumber(
    ProjActivityNumber    _projActivityNumber = projActivityNumber)
    {
        this.setClearCache(true);

        projActivityNumber  = _projActivityNumber;

        return projActivityNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmActual</Name>
				<Source><![CDATA[
    boolean parmActual(
    boolean _actual   = actual)
    {
        actual    = _actual;

        return actual;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAmountQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>AmountQty</c> parameter.
    /// </summary>
    /// <param name="_amountQty">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>AmountQty</c> parameter.
    /// </returns>
    ProjAmountQty   parmAmountQty(ProjAmountQty _amountQty  = amountQty)
    {
        amountQty  = _amountQty;

        return amountQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBudget</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>Budget</c> parameter.
    /// </summary>
    /// <param name="_budget">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>Budget</c> parameter.
    /// </returns>
    boolean parmBudget(
    boolean _budget   = budget)
    {
        budget    = _budget;

        return budget;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCategoryGroupId</Name>
				<Source><![CDATA[
    public  ProjCategoryGroupId parmCategoryGroupId(ProjCategoryGroupId  _projCategoryGroupId = projCategoryGroupId)
    {
        this.setClearCache(true);

        projCategoryGroupId  = _projCategoryGroupId;

        return projCategoryGroupId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCategoryId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>CategoryId</c> parameter.
    /// </summary>
    /// <param name="_projCategoryId">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>CategoryId</c> parameter.
    /// </returns>
    ProjCategoryId parmCategoryId(
    ProjCategoryId  _projCategoryId = projCategoryId)
    {
        this.setClearCache(true);

        projCategoryId  = _projCategoryId;

        return projCategoryId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCost</Name>
				<Source><![CDATA[
    boolean parmCost(
    boolean         _cost           = cost)
    {
        this.setClearCache(true);

        cost    = _cost;

        return cost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>CustAccount</c> parameter.
    /// </summary>
    /// <param name="_custAccount">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>CustAccount</c> parameter.
    /// </returns>
    CustAccount parmCustAccount(
    CustAccount    _custAccount = custAccount)
    {
        this.setClearCache(true);

        custAccount  = _custAccount;

        return custAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDepartment</Name>
				<Source><![CDATA[
    SysDim parmDepartment(
    SysDim    _department = department)
    {
        this.setClearCache(true);

        department  = _department;

        return department;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDeviation</Name>
				<Source><![CDATA[
    boolean parmDeviation(
    boolean _deviation = deviation)
    {
        deviation = _deviation;

        return deviation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEmplItemId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>EmplItemId</c> parameter.
    /// </summary>
    /// <param name="_projEmplItemId">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>EmplItemId</c> parameter.
    /// </returns>
    ProjEmplItemId parmEmplItemId(
    ProjEmplItemId    _projEmplItemId = projEmplItemId)
    {
        this.setClearCache(true);

        projEmplItemId  = _projEmplItemId;

        return projEmplItemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExpenses</Name>
				<Source><![CDATA[
    boolean parmExpenses(
    boolean _expenses  = expenses)
    {
        this.setClearCache(true);

        expenses    = _expenses;

        return expenses;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFixedPrice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>FixedPrice</c> parameter.
    /// </summary>
    /// <param name="_fixedPrice">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>FixedPrice</c> parameter.
    /// </returns>
    boolean parmFixedPrice(
    boolean _fixedPrice  = fixedPrice)
    {
        this.setClearCache(true);

        fixedPrice    = _fixedPrice;

        return fixedPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmforecastModelId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>forecastModelId</c> parameter.
    /// </summary>
    /// <param name="_forecastModelId">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>forecastModelId</c> parameter.
    /// </returns>
    ForecastModelId parmforecastModelId(
    ForecastModelId _forecastModelId   = forecastModelId)
    {
        forecastModelId    = _forecastModelId;

        return forecastModelId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFundingSource</Name>
				<Source><![CDATA[
    public ProjFundingSourceRefId parmFundingSource(ProjFundingSourceRefId  _fundingSource = fundingSource)
    {
        rangeOnEmptyFundingSource = false;
        this.setClearCache(true);

        fundingSource  = _fundingSource;

        if (_fundingSource == 0)
        {
            rangeOnEmptyFundingSource = true;
        }

        return fundingSource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHour</Name>
				<Source><![CDATA[
    boolean parmHour(
    boolean _hour  = hour)
    {
        this.setClearCache(true);

        hour    = _hour;

        return hour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInternal</Name>
				<Source><![CDATA[
    boolean parmInternal(
    boolean _internalProjType  = internalProjType)
    {
        this.setClearCache(true);

        internalProjType    = _internalProjType;

        return internalProjType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInvestment</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>Investment</c> parameter.
    /// </summary>
    /// <param name="_investment">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>Investment</c> parameter.
    /// </returns>
    boolean parmInvestment(
    boolean _investment  = investment)
    {
        this.setClearCache(true);

        investment    = _investment;

        return investment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItem</Name>
				<Source><![CDATA[
    boolean parmItem(
    boolean _item  = item)
    {
        this.setClearCache(true);

        item    = _item;

        return item;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerTransDateFrom</Name>
				<Source><![CDATA[
    TransDate parmLedgerTransDateFrom(
    TransDate _ledgerTransDateFrom = ledgerTransDateFrom)
    {
        this.setClearCache(true);

        ledgerTransDateFrom  = _ledgerTransDateFrom;

        return ledgerTransDateFrom;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerTransDateTo</Name>
				<Source><![CDATA[
    TransDate parmLedgerTransDateTo(
    TransDate _ledgerTransDateTo = ledgerTransDateTo)
    {
        this.setClearCache(true);

        ledgerTransDateTo  = _ledgerTransDateTo;

        return ledgerTransDateTo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmListId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>ListId</c> parameter.
    /// </summary>
    /// <param name="_listId">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>ListId</c> parameter.
    /// </returns>
    ProjListStateId parmListId(
    ProjListStateId _listId = listId)
    {
        this.checkCache();

        listId  = _listId;

        return listId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOnAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>OnAccount</c> parameter.
    /// </summary>
    /// <param name="_onAccount">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>OnAccount</c> parameter.
    /// </returns>
    boolean parmOnAccount(
    boolean _onAccount  = onAccount)
    {
        this.setClearCache(true);

        onAccount    = _onAccount;

        return onAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjGroupId</Name>
				<Source><![CDATA[
    ProjGroupId parmProjGroupId(
    ProjGroupId    _projGroupId = projGroupId)
    {
        this.setClearCache(true);

        projGroupId  = _projGroupId;

        return projGroupId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>ProjId</c> parameter.
    /// </summary>
    /// <param name="_projId">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>ProjId</c> parameter.
    /// </returns>
    ProjId parmProjId(
    ProjId    _projId = projId)
    {
        this.setClearCache(true);

        projId  = _projId;

        return projId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjInvoiceProjId</Name>
				<Source><![CDATA[
    ProjInvoiceProjId parmProjInvoiceProjId(
    ProjInvoiceProjId    _projInvoiceProjId = projInvoiceProjId)
    {
        this.setClearCache(true);

        projInvoiceProjId  = _projInvoiceProjId;

        return projInvoiceProjId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjTransDateFrom</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>ProjTransDateFrom</c> parameter.
    /// </summary>
    /// <param name="_projTransDateFrom">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>ProjTransDateFrom</c> parameter.
    /// </returns>
    ProjTransDate parmProjTransDateFrom(
    ProjTransDate _projTransDateFrom = projTransDateFrom)
    {
        this.setClearCache(true);

        projTransDateFrom  = _projTransDateFrom;

        return projTransDateFrom;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjTransDateTo</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>ProjTransDateTo</c> parameter.
    /// </summary>
    /// <param name="_projTransDateTo">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>ProjTransDateTo</c> parameter.
    /// </returns>
    ProjTransDate parmProjTransDateTo(
    ProjTransDate _projTransDateTo = projTransDateTo)
    {
        this.setClearCache(true);

        projTransDateTo  = _projTransDateTo;

        return projTransDateTo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>ProjType</c> parameter.
    /// </summary>
    /// <param name="_projType">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>ProjType</c> parameter.
    /// </returns>
    ProjType parmProjType(
    ProjType    _projType = projType)
    {
        this.setClearCache(true);

        projType  = _projType;

        return projType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjWIPId</Name>
				<Source><![CDATA[
    ProjWipId parmProjWIPId(
    ProjWipId    _projWipId = projWipId)
    {
        this.setClearCache(true);

        projWipId  = _projWipId;

        return projWipId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmResource</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the value of the <paramref name="projResourceRecId" /> parameter that holds the resource recId that is associated with a project.
    /// </summary>
    /// <param name="_projResourceRecId">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of <paramref name="projResourceRecId" />.
    /// </returns>
    ResourceRecId parmResource(ResourceRecId     _projResourceRecId = projResourceRecId)
    {
        this.setClearCache(true);

        projResourceRecId  = _projResourceRecId;

        return projResourceRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmResourceCategory</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the value of the <paramref name="projResourceCategoryRecId" /> parameter that holds the resource category recId that is associated with a project.
    /// </summary>
    /// <param name="_projResourceCategoryRecId">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of <paramref name="projResourceCategoryRecId" />.
    /// </returns>
    ResourceCategoryRecId parmResourceCategory(ResourceCategoryRecId     _projResourceCategoryRecId = projResourceCategoryRecId)
    {
        this.setClearCache(true);

        projResourceCategoryRecId  = _projResourceCategoryRecId;

        return projResourceCategoryRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmResponsibleFinancialWorker</Name>
				<Source><![CDATA[
    ProjResponsibleFinancialWorker parmResponsibleFinancialWorker(
    ProjResponsibleFinancialWorker _responsibleFinancial = responsibleFinancial)
    {
        this.setClearCache(true);

        responsibleFinancial  = _responsibleFinancial;

        return responsibleFinancial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmResponsibleSalesWorker</Name>
				<Source><![CDATA[
    ProjResponsibleSalesWorker parmResponsibleSalesWorker(
    ProjResponsibleSalesWorker _responsibleSales = responsibleSales)
    {
        this.setClearCache(true);

        responsibleSales  = _responsibleSales;

        return responsibleSales;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmResponsibleWorker</Name>
				<Source><![CDATA[
    ProjResponsibleWorker parmResponsibleWorker(
    ProjResponsibleWorker _responsible = responsible)
    {
        this.setClearCache(true);

        responsible  = _responsible;

        return responsible;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRevenue</Name>
				<Source><![CDATA[
    boolean parmRevenue(
    boolean _revenue  = revenue)
    {
        this.setClearCache(true);

        revenue    = _revenue;

        return revenue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSorting1</Name>
				<Source><![CDATA[
    ProjSort parmSorting1(
    ProjSort    _sorting1 = sorting1)
    {
        this.setClearCache(true);

        sorting1  = _sorting1;

        return sorting1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSorting2</Name>
				<Source><![CDATA[
    ProjSort parmSorting2(
    ProjSort    _sorting2 = sorting2)
    {
        this.setClearCache(true);

        sorting2  = _sorting2;

        return sorting2;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSorting3</Name>
				<Source><![CDATA[
    ProjSort parmSorting3(
    ProjSort    _sorting3 = sorting3)
    {
        this.setClearCache(true);

        sorting3  = _sorting3;

        return sorting3;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmStateProjType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>StateProjType</c> parameter.
    /// </summary>
    /// <param name="_stateProjType">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>StateProjType</c> parameter.
    /// </returns>
    ProjListStateProjType parmStateProjType(
    ProjListStateProjType _stateProjType = stateProjType)
    {
        this.checkCache();

        stateProjType  = _stateProjType;

        return stateProjType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSubscriptionId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the value of the <paramref name="subscriptionId" /> parameter that holds the subscription id that is associated with a project.
    /// </summary>
    /// <param name="_subscriptionId">
    /// The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of <paramref name="subscriptionId" />.
    /// </returns>
    SMASubscriptionId parmSubscriptionId(SMASubscriptionId  _subscriptionId = subscriptionId)
    {
        this.setClearCache(true);

        subscriptionId  = _subscriptionId;

        return subscriptionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSum</Name>
				<Source><![CDATA[
    boolean parmSum(
    boolean _sum = sumStat)
    {
        sumStat = _sum;

        return sumStat;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTime</Name>
				<Source><![CDATA[
    boolean parmTime(
    boolean _time  = time)
    {
        this.setClearCache(true);

        time    = _time;

        return time;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTimeMaterial</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>TimeMaterial</c> parameter.
    /// </summary>
    /// <param name="_timeMaterial">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>TimeMaterial</c> parameter.
    /// </returns>
    boolean parmTimeMaterial(
    boolean _timeMaterial  = timeMaterial)
    {
        this.setClearCache(true);

        timeMaterial    = _timeMaterial;

        return timeMaterial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>TransId</c> parameter.
    /// </summary>
    /// <param name="_transId">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>TransId</c> parameter.
    /// </returns>
    ProjTransIdBase parmTransId(
    ProjTransIdBase  _transId = transId)
    {
        this.setClearCache(true);

        transId  = _transId;

        return transId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>payrollAllocation</Name>
				<Source><![CDATA[
    void payrollAllocation()
    {
        if ((hour) && this.checkHourAmount() && this.ledgerPayrollAllocation())
        {
            query   = this.queryBuildExcelPivot();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting, ProjTransType)).value(queryValue(ProjTransType::Hour));
                transDataSource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjPayrollAllocation));
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::Hour));
                transDataSource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjPayrollAllocation));
            }

            this.setTmpProjStatisticExcelPivot(ProjStatisticDimension::PayrollAllocation, ProjExportToExcelWorksheet::StatPayrollAlloc);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>profitLossHourQty</Name>
				<Source><![CDATA[
    void profitLossHourQty()
    {
        if (hour && this.checkHourQty() && (this.ledgerCost() || ProjParameters::find().StatementPLHourQty))
        {
            query   = this.queryBuildExcelPivot();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Hour));
                if (this.ledgerCost())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjCost));
                }
                if (ProjParameters::find().StatementPLHourQty)
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjNeverLedger));
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjNoLedger));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));
                if (this.ledgerCost())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjCost));
                }
                if (ProjParameters::find().StatementPLHourQty)
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjNeverLedger));
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjNoLedger));
                }
            }

            this.setTmpProjStatisticExcelPivot(ProjStatisticDimension::PLHourQty, ProjExportToExcelWorksheet::StatProfitLoss);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>profitLossTotalCost</Name>
				<Source><![CDATA[
    void profitLossTotalCost()
    {
        if ((((hour) && this.checkHourAmount()) || expenses || item) && this.ledgerCost())
        {
            query   = this.queryBuildExcelPivot();

            if (this.parmActual())
            {
                if ((hour) && this.checkHourAmount())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Hour));
                }
                if (expenses)
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Cost));
                }
                if (item)
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Item));
                }
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjCost));
            }
            else if (this.parmBudget())
            {
                if (hour)
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));
                }
                if (expenses)
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Cost));
                }
                if (item)
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Item));
                }
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjCost));
            }

            this.setTmpProjStatisticExcelPivot(ProjStatisticDimension::PLTotalCost, ProjExportToExcelWorksheet::StatProfitLoss);

            //Item activated and consumption item
            if ((item) && (this.ledgerOffsetAccountItem() || (ProjParameters::find().ItemNeverLedgerPL)))
            {
                query   = this.queryBuildExcelPivot();

                if (this.parmActual())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Item));
                    if (this.ledgerOffsetAccountItem())
                    {
                        transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjOffsetAccountItem));
                    }
                    if (ProjParameters::find().ItemNeverLedgerPL)
                    {
                        transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjNeverLedger));
                    }
                }
                else if (this.parmBudget())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Item));
                    if (this.ledgerOffsetAccountItem())
                    {
                        transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjOffsetAccountItem));
                    }
                    if (ProjParameters::find().ItemNeverLedgerPL)
                    {
                        transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjNeverLedger));
                    }
                }

                this.setTmpProjStatisticExcelPivot(ProjStatisticDimension::PLTotalCost, ProjExportToExcelWorksheet::StatProfitLoss);
            }

            //Consumption NeverLedger and Consumption NoLedger
            if (hour && this.checkHourAmount() && ProjParameters::find().StatementPLHourCost)
            {
                query   = this.queryBuildExcelPivot();

                if (this.parmActual())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Hour));
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjNeverLedger));
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjNoLedger));
                    this.transNoEliminationOrigin();
                }
                else if (this.parmBudget())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjNeverLedger));
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjNoLedger));
                    this.budgetNoElimination();
                }

                this.setTmpProjStatisticExcelPivot(ProjStatisticDimension::PLTotalCost, ProjExportToExcelWorksheet::StatProfitLoss);
            }

            // Accrued loss
            if (expenses)
            {
                query   = this.queryBuildExcelPivot();

                if (this.parmActual())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Cost));
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjAccruedCost));
                }
                else if (this.parmBudget())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Cost));
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjAccruedCost));
                }
                this.setTmpProjStatisticExcelPivot(ProjStatisticDimension::PLTotalCost, ProjExportToExcelWorksheet::StatProfitLoss);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>profitLossTotalRevenue</Name>
				<Source><![CDATA[
    void profitLossTotalRevenue()
    {
        //
        // Calculate LedgerPostingType::ProjTurnover
        //           LedgerPostingType::ProjSalesvalue
        //
        if (((hour && this.checkHourAmount()) || item || expenses || revenue)   &&
        ((this.ledgerTurnover()|| this.ledgerSalesvalue())                  ||
         (this.ledgerAccruedTurnoverProd() || this.ledgerAccruedTurnoverProfit())))
        {
            query   = this.queryBuildExcelPivot();

            if (this.parmActual())
            {
                if (hour)
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Hour));
                }

                if (item)
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Item));
                }

                if (expenses)
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Cost));
                }

                if (revenue)
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Revenue));
                }

                if (this.ledgerTurnover())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjTurnover));
                }

                if (this.ledgerAccruedTurnoverProd())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjAccruedTurnoverProd));
                }

                if (this.ledgerAccruedTurnoverProfit())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProJAccruedTurnoverProfit));
                }

                if (this.ledgerSalesvalue())
                {
                    if (revenue)
                    {
                        transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjAccruedRevenueSubscription));
                    }
                    else
                    {
                        transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalue));
                    }
                }
            }
            else if (this.parmBudget())
            {
                if (hour)
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));
                }

                if (item)
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Item));
                }

                if (expenses)
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Cost));
                }

                if (revenue)
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Revenue));
                }

                if (this.ledgerAccruedTurnoverProd())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjAccruedTurnoverProd));
                }

                if (this.ledgerAccruedTurnoverProfit())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProJAccruedTurnoverProfit));
                }

                if (this.ledgerTurnover())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjTurnover));
                }

                if (this.ledgerSalesvalue())
                {
                    if (revenue)
                    {
                        transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjAccruedRevenueSubscription));
                    }
                    else
                    {
                        transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalue));
                    }
                }
            }

            this.setTmpProjStatisticExcelPivot(ProjStatisticDimension::PLTotalRevenue, ProjExportToExcelWorksheet::StatProfitLoss);
        }

        //
        // Calculate LedgerPostingType::ProjOnAccount
        //           LedgerPostingType::ProjAccruedRevenueOnAccount
        //
        if (onAccount && (this.ledgerTurnover() || this.ledgerAccruedRevenueOnAccount()))
        {
            query   = this.queryBuildExcelPivot();
            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::OnAccount));
                if (this.ledgerTurnover())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjOnAccount));
                }
                if (this.ledgerAccruedRevenueOnAccount())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjAccruedRevenueOnAccount));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::OnAccount));
                if (this.ledgerTurnover())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjOnAccount));
                }
                if (this.ledgerAccruedRevenueOnAccount())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjAccruedRevenueOnAccount));
                }
            }

            this.setTmpProjStatisticExcelPivot(ProjStatisticDimension::PLTotalRevenue, ProjExportToExcelWorksheet::StatProfitLoss);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaParmForecastModelIds</Name>
				<Source><![CDATA[
    // Description    : multiple forecast model Id
    // Parameters     : _sForecastModelIds
    // Return value   : string

    public str psaParmForecastModelIds(str _sForecastModelIds = m_sForecastModelIds)
    {
        m_sForecastModelIds = _sForecastModelIds;
        return m_sForecastModelIds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaParmProjAmountUnit</Name>
				<Source><![CDATA[
    // Description    : flag which decide to aggregate amount or unit
    // Parameters     : _eProjAmountUnit

    PSAProjAmountVsUnit psaParmProjAmountUnit(PSAProjAmountVsUnit _eProjAmountUnit = m_eProjAmountUnit)
    {
        m_eProjAmountUnit = _eProjAmountUnit;
        return m_eProjAmountUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryActualExcelPivot</Name>
				<Source><![CDATA[
    Query queryActualExcelPivot()
    {
        RecId   legalEntity;

        query = new Query();

        transDataSource = query.addDataSource(tableNum(ProjTransPosting));

        switch (listId)
        {
            case ProjListStateId::Project:
                transDataSource.addSortIndex(indexNum(ProjTransPosting, ProjIdx));
                break;

            case ProjListStateId::Category:
                transDataSource.addSortIndex(indexNum(ProjTransPosting, CategoryIdx));
                break;

            case ProjListStateId::EmplItem:
                transDataSource.addSortIndex(indexNum(ProjTransPosting, EmplItemIdx));
                break;

            case ProjListStateId::TransId:
                transDataSource.addSortIndex(indexNum(ProjTransPosting, TransIdx));
                break;

            case ProjListStateId::Activity:
                transDataSource.addSortIndex(indexNum(ProjTransPosting, ProjIdx));
                break;

            default:
                this.addProjTransPostingSortIdxDefault();
                break;
        }

        transDataSource.indexIsHint(true);

        if (projId)
        {
            transDataSource.addRange(fieldNum(ProjTransPosting, ProjId)).value(queryValue(projId));
        }

        if (projCategoryId)
        {
            transDataSource.addRange(fieldNum(ProjTransPosting, CategoryId)).value(projCategoryId);
        }

        if (projEmplItemId)
        {
            transDataSource.addRange(fieldNum(ProjTransPosting, EmplItemId)).value(projEmplItemId);
        }

        if (projResourceRecId)
        {
            legalEntity = CompanyInfo::findDataArea(curext()).RecId;
            transDataSource.addRange(fieldNum(ProjTransPosting, Resource)).value(queryValue(projResourceRecId));
        }

        if (projResourceCategoryRecId)
        {
            transDataSource.addRange(fieldNum(ProjTransPosting, ResourceCategory)).value(queryValue(projResourceCategoryRecId));
        }

        if (subscriptionId)
        {
            transDataSource.addRange(fieldNum(ProjTransPosting, SubscriptionId)).value(queryValue(subscriptionId));
        }

        if (transId)
        {
            transDataSource.addRange(fieldNum(ProjTransPosting, TransId)).value(transId);
        }

        if (projActivityNumber)
        {
            transDataSource.addRange(fieldNum(ProjTransPosting, ActivityNumber)).value(projActivityNumber);
        }

        if ((fundingSource != 0) || (rangeOnEmptyFundingSource == true))
        {
            transDataSource.addRange(fieldNum(ProjTransPosting, ProjFundingSource)).value(queryValue(fundingSource));
        }

        transDataSource.addRange(fieldNum(ProjTransPosting, LedgerTransDate)).value(queryValue(ledgerTransDateFrom) + '..' + queryValue(ledgerTransDateTo));
        transDataSource.addRange(fieldNum(ProjTransPosting, ProjTransDate)).value(queryValue(projTransDateFrom) + '..' + queryValue(projTransDateTo));

        if (!enableProjMultipleContractLinesForProjectFeature)
        {
            if (timeMaterial)
            {
                transDataSource.addRange(fieldNum(ProjTransPosting, ProjType)).value(queryValue(ProjType::TimeMaterial));
            }

            if (fixedPrice)
            {
                transDataSource.addRange(fieldNum(ProjTransPosting, ProjType)).value(queryValue(ProjType::FixedPrice));
            }

            if (investment)
            {
                transDataSource.addRange(fieldNum(ProjTransPosting, ProjType)).value(queryValue(ProjType::Investment));
            }

            if (cost)
            {
                transDataSource.addRange(fieldNum(ProjTransPosting, ProjType)).value(queryValue(ProjType::Cost));
            }

            if (internalProjType)
            {
                transDataSource.addRange(fieldNum(ProjTransPosting, ProjType)).value(queryValue(ProjType::Internal));
            }

            if (time)
            {
                transDataSource.addRange(fieldNum(ProjTransPosting, ProjType)).value(queryValue(ProjType::Time));
            }
        }

        if (custAccount)
        {
            projTableDataSource = transDataSource.addDataSource(tableNum(ProjTable));
            projTableDataSource.addLink(fieldNum(ProjTransPosting, ProjId), fieldNum(ProjTable, ProjId));
            projTableDataSource.addRange(fieldNum(ProjTable, CustAccount)).value(custAccount);
        }

        if (projCategoryGroupId)
        {
            projCategoryGroupDataSource = transDataSource.addDataSource(tableNum(ProjCategory));
            projCategoryGroupDataSource.addLink(fieldNum(ProjTransPosting, CategoryId), fieldNum(ProjCategory, CategoryId));
            projCategoryGroupDataSource.addRange(fieldNum(ProjCategory, CategoryGroupId)).value(projCategoryGroupId);
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addProjTransPostingSortIdxDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Adds <c>ProjTransPosting</c> sorting index to transaction datasource query.
    /// </summary>
    protected void addProjTransPostingSortIdxDefault()
    {
        transDataSource.addSortIndex(indexNum(ProjTransPosting, TransIdx));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addProjTransBudgetSortIdxDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Adds <c>ProjTransBudget</c> sorting index to transaction datasource query.
    /// </summary>
    protected void addProjTransBudgetSortIdxDefault()
    {
        transDataSource.addSortIndex(indexNum(ProjTransBudget, TransIdx));
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryBudget</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Builds the query that is used in running the statement report that shows budget amounts using the <c>ProjTransBudget</c> table as the data source.
    /// </summary>
    /// <returns>
    ///    The query.
    /// </returns>
    Query queryBudget()
    {
        QueryBuildFieldList     queryBuildFieldList;
        QueryBuildDataSource    queryBuildDataSource;

        query = new Query();

        transDataSource = query.addDataSource(tableNum(ProjTransBudget));
        transDataSource.orderMode(OrderMode::GroupBy);
        transDataSource.addRange(fieldNum(ProjTransBudget, Elimination)).value(queryValue(NoYes::No));

        queryBuildDataSource = transDataSource.addDataSource(tableNum(ProjForecastUnion));
        queryBuildDataSource.joinMode(JoinMode::ExistsJoin);
        queryBuildDataSource.addLink(fieldNum(ProjTransBudget, TransId), fieldNum(ProjForecastUnion, TransId));
        queryBuildDataSource.addRange(fieldNum(ProjForecastUnion, Active)).value(queryValue(NoYes::Yes));

        queryBuildFieldList = transDataSource.fields();

        queryBuildFieldList.dynamic(false);
        queryBuildFieldList.addField(fieldNum(ProjTransBudget, AmountMst), SelectionField::Sum);
        queryBuildFieldList.addField(fieldNum(ProjTransBudget, Qty), SelectionField::Sum);

        switch (listId)
        {
            case ProjListStateId::Project:
                transDataSource.addSortIndex(indexNum(ProjTransBudget, ProjIdx));
                break;

            case ProjListStateId::Category:
                transDataSource.addSortIndex(indexNum(ProjTransBudget, CategoryIdx));
                break;

            case ProjListStateId::EmplItem:
                transDataSource.addSortIndex(indexNum(ProjTransBudget, EmplItemIdx));
                break;

            case ProjListStateId::TransId:
                transDataSource.addSortIndex(indexNum(ProjTransBudget, TransIdx));
                break;

            case ProjListStateId::Activity:
                transDataSource.addSortIndex(indexNum(ProjTransBudget, ProjIdx));
                break;

            default:
                this.addProjTransBudgetSortIdxDefault();
                break;
        }
        transDataSource.indexIsHint(true);

        if (projId)
        {
            transDataSource.addRange(fieldNum(ProjTransBudget, ProjId)).value(queryValue(projId));
        }

        if (projCategoryId)
        {
            transDataSource.addRange(fieldNum(ProjTransBudget, CategoryId)).value(projCategoryId);
        }

        if (projEmplItemId)
        {
            transDataSource.addRange(fieldNum(ProjTransBudget, EmplItemId)).value(projEmplItemId);
        }

        if (projResourceRecId)
        {
            transDataSource.addRange(fieldNum(ProjTransBudget, Resource)).value(queryValue(projResourceRecId));
        }

        if (projResourceCategoryRecId)
        {
            transDataSource.addRange(fieldNum(ProjTransBudget, ResourceCategory)).value(queryValue(projResourceCategoryRecId));
        }

        if (subscriptionId)
        {
            transDataSource.addRange(fieldNum(ProjTransBudget, SubscriptionId)).value(queryValue(subscriptionId));
        }

        if (transId)
        {
            transDataSource.addRange(fieldNum(ProjTransBudget, TransId)).value(transId);
        }

        if (projActivityNumber)
        {
            transDataSource.addRange(fieldNum(ProjTransBudget, ActivityNumber)).value(projActivityNumber);
        }

        if ((fundingSource != 0) || (rangeOnEmptyFundingSource == true))
        {
            transDataSource.addRange(fieldNum(ProjTransBudget, ProjFundingSource)).value(queryValue(fundingSource));
        }

        transDataSource.addRange(fieldNum(ProjTransBudget, LedgerTransDate)).value(queryValue(ledgerTransDateFrom) + '..'+queryValue(ledgerTransDateTo));
        transDataSource.addRange(fieldNum(ProjTransBudget, ProjTransDate)).value(queryValue(projTransDateFrom) + '..'+queryValue(projTransDateTo));

        if (!enableProjMultipleContractLinesForProjectFeature)
        {
            if (timeMaterial)
            {
                transDataSource.addRange(fieldNum(ProjTransBudget, ProjType)).value(queryValue(ProjType::TimeMaterial));
            }

            if (fixedPrice)
            {
                transDataSource.addRange(fieldNum(ProjTransBudget, ProjType)).value(queryValue(ProjType::FixedPrice));
            }

            if (investment)
            {
                transDataSource.addRange(fieldNum(ProjTransBudget, ProjType)).value(queryValue(ProjType::Investment));
            }

            if (cost)
            {
                transDataSource.addRange(fieldNum(ProjTransBudget, ProjType)).value(queryValue(ProjType::Cost));
            }

            if (internalProjType)
            {
                transDataSource.addRange(fieldNum(ProjTransBudget, ProjType)).value(queryValue(ProjType::Internal));
            }

            if (time)
            {
                transDataSource.addRange(fieldNum(ProjTransBudget, ProjType)).value(queryValue(ProjType::Time));
            }
        }

        if (forecastModelId)
        {
            transDataSource.addRange(fieldNum(ProjTransBudget, ModelId)).value(queryValue(forecastModelId));
        }

        if (custAccount)
        {
            projTableDataSource = transDataSource.addDataSource(tableNum(ProjTable));
            projTableDataSource.addLink(fieldNum(ProjTransBudget, ProjId), fieldNum(ProjTable, ProjId));
            projTableDataSource.addRange(fieldNum(ProjTable, CustAccount)).value(custAccount);
        }

        if (projCategoryGroupId)
        {
            projCategoryGroupDataSource = transDataSource.addDataSource(tableNum(ProjCategory));
            projCategoryGroupDataSource.addLink(fieldNum(ProjTransBudget, CategoryId), fieldNum(ProjCategory, CategoryId));
            projCategoryGroupDataSource.addRange(fieldNum(ProjCategory, CategoryGroupId)).value(projCategoryGroupId);
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryBudgetEntity</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Builds the query that is used in running the statement report that shows budget amounts using the <c>ProjTransBudget</c> table as the data source.
    /// </summary>
    /// <returns>
    ///    The query.
    /// </returns>
    Query queryBudgetEntity()
    {
        QueryBuildDataSource    queryBuildDataSource;

        query = new Query(querystr(ProjForecastAggregates));

        transDataSource = query.dataSourceTable(tableNum(PSAForecastEntity));
        transDataSource.orderMode(OrderMode::GroupBy);
        transDataSource.addRange(fieldNum(PSAForecastEntity, Elimination)).value(queryValue(NoYes::No));

        queryBuildDataSource = transDataSource.addDataSource(tableNum(ProjForecastUnion));
        queryBuildDataSource.joinMode(JoinMode::ExistsJoin);
        queryBuildDataSource.addLink(fieldNum(PSAForecastEntity, TransId), fieldNum(ProjForecastUnion, TransId));
        queryBuildDataSource.addRange(fieldNum(ProjForecastUnion, Active)).value(queryValue(NoYes::Yes));

        if (projId)
        {
            transDataSource.addRange(fieldNum(PSAForecastEntity, ProjId)).value(queryValue(projId));
        }

        if (projCategoryId)
        {
            transDataSource.addRange(fieldNum(PSAForecastEntity, CategoryId)).value(projCategoryId);
        }

        if (projEmplItemId)
        {
            transDataSource.addRange(fieldNum(PSAForecastEntity, EmplItemId)).value(projEmplItemId);
        }

        if (projResourceRecId)
        {
            transDataSource.addRange(fieldNum(PSAForecastEntity, Resource)).value(queryValue(projResourceRecId));
        }

        if (projResourceCategoryRecId)
        {
            transDataSource.addRange(fieldNum(PSAForecastEntity, ResourceCategory)).value(queryValue(projResourceCategoryRecId));
        }

        if (subscriptionId)
        {
            transDataSource.addRange(fieldNum(PSAForecastEntity, SubscriptionId)).value(queryValue(subscriptionId));
        }

        if (transId)
        {
            transDataSource.addRange(fieldNum(PSAForecastEntity, TransId)).value(transId);
        }

        if (projActivityNumber)
        {
            transDataSource.addRange(fieldNum(PSAForecastEntity, ActivityNumber)).value(projActivityNumber);
        }

        if ((fundingSource != 0) || (rangeOnEmptyFundingSource == true))
        {
            transDataSource.addRange(fieldNum(PSAForecastEntity, ProjFundingSource)).value(queryValue(fundingSource));
        }

        transDataSource.addRange(fieldNum(PSAForecastEntity, LedgerTransDate)).value(queryValue(ledgerTransDateFrom) + '..'+queryValue(ledgerTransDateTo));
        transDataSource.addRange(fieldNum(PSAForecastEntity, ProjTransDate)).value(queryValue(projTransDateFrom) + '..'+queryValue(projTransDateTo));

        if (!enableProjMultipleContractLinesForProjectFeature)
        {
            if (timeMaterial)
            {
                transDataSource.addRange(fieldNum(PSAForecastEntity, ProjType)).value(queryValue(ProjType::TimeMaterial));
            }

            if (fixedPrice)
            {
                transDataSource.addRange(fieldNum(PSAForecastEntity, ProjType)).value(queryValue(ProjType::FixedPrice));
            }

            if (investment)
            {
                transDataSource.addRange(fieldNum(PSAForecastEntity, ProjType)).value(queryValue(ProjType::Investment));
            }

            if (cost)
            {
                transDataSource.addRange(fieldNum(PSAForecastEntity, ProjType)).value(queryValue(ProjType::Cost));
            }

            if (internalProjType)
            {
                transDataSource.addRange(fieldNum(PSAForecastEntity, ProjType)).value(queryValue(ProjType::Internal));
            }

            if (time)
            {
                transDataSource.addRange(fieldNum(PSAForecastEntity, ProjType)).value(queryValue(ProjType::Time));
            }
        }

        if (hour)
        {
            transDataSource.addRange(fieldNum(PSAForecastEntity, ProjTransType)).value(queryValue(ProjTransType::Hour));
        }

        if (revenue)
        {
            transDataSource.addRange(fieldNum(PSAForecastEntity, ProjTransType)).value(queryValue(ProjTransType::Revenue));
        }

        if (expenses)
        {
            transDataSource.addRange(fieldNum(PSAForecastEntity, ProjTransType)).value(queryValue(ProjTransType::Cost));
        }

        if (item)
        {
            transDataSource.addRange(fieldNum(PSAForecastEntity, ProjTransType)).value(queryValue(ProjTransType::Item));
        }

        if (onAccount)
        {
            transDataSource.addRange(fieldNum(PSAForecastEntity, ProjTransType)).value(queryValue(ProjTransType::OnAccount));
        }

        if (forecastModelId)
        {
            transDataSource.addRange(fieldNum(PSAForecastEntity, ModelId)).value(queryValue(forecastModelId));
        }

        if (custAccount)
        {
            projTableDataSource = transDataSource.addDataSource(tableNum(ProjTable));
            projTableDataSource.addLink(fieldNum(PSAForecastEntity, ProjId), fieldNum(ProjTable, ProjId));
            projTableDataSource.addRange(fieldNum(ProjTable, CustAccount)).value(custAccount);
        }

        if (projCategoryGroupId)
        {
            projCategoryGroupDataSource = transDataSource.addDataSource(tableNum(ProjCategory));
            projCategoryGroupDataSource.addLink(fieldNum(PSAForecastEntity, CategoryId), fieldNum(ProjCategory, CategoryId));
            projCategoryGroupDataSource.addRange(fieldNum(ProjCategory, CategoryGroupId)).value(projCategoryGroupId);
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryBudgetExcelPivot</Name>
				<Source><![CDATA[
    Query queryBudgetExcelPivot()
    {
        QueryBuildDataSource    queryBuildDataSource;

        query = new Query();

        transDataSource = query.addDataSource(tableNum(ProjTransBudget));

        queryBuildDataSource = transDataSource.addDataSource(tableNum(ProjForecastUnion));
        queryBuildDataSource.joinMode(JoinMode::ExistsJoin);
        queryBuildDataSource.addLink(fieldNum(ProjTransBudget, TransId), fieldNum(ProjForecastUnion, TransId));
        queryBuildDataSource.addRange(fieldNum(ProjForecastUnion, Active)).value(queryValue(NoYes::Yes));

        switch (listId)
        {
            case ProjListStateId::Project:
                transDataSource.addSortIndex(indexNum(ProjTransBudget, ProjIdx));
                break;

            case ProjListStateId::Category:
                transDataSource.addSortIndex(indexNum(ProjTransBudget, CategoryIdx));
                break;

            case ProjListStateId::EmplItem:
                transDataSource.addSortIndex(indexNum(ProjTransBudget, EmplItemIdx));
                break;

            case ProjListStateId::TransId:
                transDataSource.addSortIndex(indexNum(ProjTransBudget, TransIdx));
                break;

            case ProjListStateId::Activity:
                transDataSource.addSortIndex(indexNum(ProjTransBudget, ProjIdx));
                break;

            default:
                this.addProjTransBudgetSortIdxDefault();
                break;
        }

        transDataSource.indexIsHint(true);

        if (projId)
        {
            transDataSource.addRange(fieldNum(ProjTransBudget, ProjId)).value(queryValue(projId));
        }

        if (projCategoryId)
        {
            transDataSource.addRange(fieldNum(ProjTransBudget, CategoryId)).value(projCategoryId);
        }

        if (projEmplItemId)
        {
            transDataSource.addRange(fieldNum(ProjTransBudget, EmplItemId)).value(projEmplItemId);
        }

        if (projResourceRecId)
        {
            transDataSource.addRange(fieldNum(ProjTransBudget, Resource)).value(queryValue(projResourceRecId));
        }

        if (projResourceCategoryRecId)
        {
            transDataSource.addRange(fieldNum(ProjTransBudget, ResourceCategory)).value(queryValue(projResourceCategoryRecId));
        }

        if (subscriptionId)
        {
            transDataSource.addRange(fieldNum(ProjTransBudget, SubscriptionId)).value(queryValue(subscriptionId));
        }

        if (transId)
        {
            transDataSource.addRange(fieldNum(ProjTransBudget, TransId)).value(transId);
        }

        if (projActivityNumber)
        {
            transDataSource.addRange(fieldNum(ProjTransBudget, ActivityNumber)).value(projActivityNumber);
        }

        if ((fundingSource != 0) || (rangeOnEmptyFundingSource == true))
        {
            transDataSource.addRange(fieldNum(ProjTransBudget, ProjFundingSource)).value(queryValue(fundingSource));
        }

        transDataSource.addRange(fieldNum(ProjTransBudget, LedgerTransDate)).value(queryValue(ledgerTransDateFrom) + '..'+queryValue(ledgerTransDateTo));
        transDataSource.addRange(fieldNum(ProjTransBudget, ProjTransDate)).value(queryValue(projTransDateFrom) + '..'+queryValue(projTransDateTo));

        if (!enableProjMultipleContractLinesForProjectFeature)
        {
            if (timeMaterial)
            {
                transDataSource.addRange(fieldNum(ProjTransBudget, ProjType)).value(queryValue(ProjType::TimeMaterial));
            }

            if (fixedPrice)
            {
                transDataSource.addRange(fieldNum(ProjTransBudget, ProjType)).value(queryValue(ProjType::FixedPrice));
            }

            if (investment)
            {
                transDataSource.addRange(fieldNum(ProjTransBudget, ProjType)).value(queryValue(ProjType::Investment));
            }

            if (cost)
            {
                transDataSource.addRange(fieldNum(ProjTransBudget, ProjType)).value(queryValue(ProjType::Cost));
            }

            if (internalProjType)
            {
                transDataSource.addRange(fieldNum(ProjTransBudget, ProjType)).value(queryValue(ProjType::Internal));
            }

            if (time)
            {
                transDataSource.addRange(fieldNum(ProjTransBudget, ProjType)).value(queryValue(ProjType::Time));
            }
        }

        if (forecastModelId)
        {
            transDataSource.addRange(fieldNum(ProjTransBudget, ModelId)).value(queryValue(forecastModelId));
        }

        if (custAccount)
        {
            projTableDataSource = transDataSource.addDataSource(tableNum(ProjTable));
            projTableDataSource.addLink(fieldNum(ProjTransBudget, ProjId), fieldNum(ProjTable, ProjId));
            projTableDataSource.addRange(fieldNum(ProjTable, CustAccount)).value(custAccount);
        }

        if (projCategoryGroupId)
        {
            projCategoryGroupDataSource = transDataSource.addDataSource(tableNum(ProjCategory));
            projCategoryGroupDataSource.addLink(fieldNum(ProjTransBudget, CategoryId), fieldNum(ProjCategory, CategoryId));
            projCategoryGroupDataSource.addRange(fieldNum(ProjCategory, CategoryGroupId)).value(projCategoryGroupId);
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryBudgetExecuted</Name>
				<Source><![CDATA[
    Query queryBudgetExecuted()
    {
        QueryBuildDataSource    dataSource;

        query       = new Query();

        dataSource  = query.addDataSource(tableNum(ProjTransBudget));

        if (projId)
        {
            dataSource.addRange(fieldNum(ProjTransBudget, ProjId)).value(queryValue(projId));
        }

        if (projCategoryId)
        {
            dataSource.addRange(fieldNum(ProjTransBudget, CategoryId)).value(projCategoryId);
        }

        if (projEmplItemId)
        {
            dataSource.addRange(fieldNum(ProjTransBudget, EmplItemId)).value(projEmplItemId);
        }

        if (projResourceRecId)
        {
            dataSource.addRange(fieldNum(ProjTransBudget, Resource)).value(queryValue(projResourceRecId));
        }

        if (projResourceCategoryRecId)
        {
            dataSource.addRange(fieldNum(ProjTransBudget, ResourceCategory)).value(queryValue(projResourceCategoryRecId));
        }

        if (subscriptionId)
        {
            dataSource.addRange(fieldNum(ProjTransBudget, SubscriptionId)).value(queryValue(subscriptionId));
        }

        if (transId)
        {
            dataSource.addRange(fieldNum(ProjTransBudget, TransId)).value(transId);
        }

        if (projActivityNumber)
        {
            transDataSource.addRange(fieldNum(ProjTransBudget, ActivityNumber)).value(projActivityNumber);
        }

        if (fundingSource)
        {
            transDataSource.addRange(fieldNum(ProjTransBudget, ProjFundingSource)).value(queryValue(fundingSource));
        }

        dataSource.addRange(fieldNum(ProjTransBudget, LedgerTransDate)).value(queryRange(ledgerTransDateFrom,ledgerTransDateTo));
        dataSource.addRange(fieldNum(ProjTransBudget, ProjTransDate)).value(queryRange(projTransDateFrom,projTransDateTo));

        //  project type
        if (!enableProjMultipleContractLinesForProjectFeature)
        {
            if (timeMaterial)
            {
                dataSource.addRange(fieldNum(ProjTransBudget, ProjType)).value(queryValue(ProjType::TimeMaterial));
            }

            if (fixedPrice)
            {
                dataSource.addRange(fieldNum(ProjTransBudget, ProjType)).value(queryValue(ProjType::FixedPrice));
            }

            if (investment)
            {
                dataSource.addRange(fieldNum(ProjTransBudget, ProjType)).value(queryValue(ProjType::Investment));
            }

            if (cost)
            {
                dataSource.addRange(fieldNum(ProjTransBudget, ProjType)).value(queryValue(ProjType::Cost));
            }

            if (internalProjType)
            {
                dataSource.addRange(fieldNum(ProjTransBudget, ProjType)).value(queryValue(ProjType::Internal));
            }

            if (time)
            {
                dataSource.addRange(fieldNum(ProjTransBudget, ProjType)).value(queryValue(ProjType::Time));
            }
        }

        // transaction types
        if (hour)
        {
            dataSource.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::Hour));
        }

        if (expenses)
        {
            dataSource.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::Cost));
        }

        if (item)
        {
            dataSource.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::Item));
        }

        if (revenue)
        {
            dataSource.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::Revenue));
        }

        if (onAccount)
        {
            dataSource.addRange(fieldNum(ProjTransBudget, ProjTransType)).value(queryValue(ProjTransType::OnAccount));
        }

        // posting types
        if (this.ledgerTurnover())
        {
            dataSource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjTurnover));
        }

        if (this.ledgerAccruedCost())
        {
            dataSource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjAccruedCost));
        }

        if (this.ledgerAccruedRevenueOnAccount())
        {
            dataSource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjAccruedRevenueOnAccount));
        }

        if (this.ledgerAccruedTurnoverProd())
        {
            dataSource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjAccruedTurnoverProd));
        }

        if (this.ledgerAccruedTurnoverProfit())
        {
            dataSource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProJAccruedTurnoverProfit));
        }

        if (this.ledgerCost())
        {
            dataSource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjCost));
        }

        if (this.ledgerOffsetAccountItem())
        {
            dataSource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjOffsetAccountItem));
        }

        if (this.ledgerOnAccount())
        {
            dataSource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjOnAccount));
        }

        if (this.ledgerAccruedRevenueSubscription())
        {
            dataSource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjAccruedRevenueSubscription));
        }

        if (this.ledgerPayrollAllocation())
        {
            dataSource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjPayrollAllocation));
        }

        if (this.ledgerSalesvalue())
        {
            dataSource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalue));
        }

        if (this.ledgerSalesvalueOffset())
        {
            dataSource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalueOffset));
        }

        if (this.ledgerStatusAccountItem())
        {
            dataSource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjStatusAccountItem));
        }

        if (this.ledgerWIPCostvalue())
        {
            dataSource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjWIPCostvalue));
        }

        if (this.ledgerWIPInvoicedOnAccount())
        {
            dataSource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjWIPInvoicedOnAccount));
        }

        if (this.ledgerWIPProduction())
        {
            dataSource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjWIPProduction));
        }

        if (this.ledgerWIPProfit())
        {
            dataSource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjWIPProfit));
        }

        if (this.ledgerWIPSubscription())
        {
            dataSource.addRange(fieldNum(ProjTransBudget, PostingType)).value(queryValue(LedgerPostingType::ProjWIPSubscription));
        }

        // Forecast Model
        if (forecastModelId)
        {
            dataSource.addRange(fieldNum(ProjTransBudget, ModelId)).value(queryValue(forecastModelId));
        }
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryBuild</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the statement report should contain actual or budget information and builds the appropriate query used in the report by calling the <c>queryRealized</c> method or the
    ///    <c>queryBudget</c> method.
    /// </summary>
    /// <returns>
    ///    The query.
    /// </returns>
    protected Query queryBuild()
    {
        if (this.parmActual())
        {
            query   = this.queryRealized();
        }
        else
        {
            query   = this.queryBudget();
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryBuildExcelPivot</Name>
				<Source><![CDATA[
    protected Query queryBuildExcelPivot()
    {
        if (this.parmActual())
        {
            query   = this.queryActualExcelPivot();
        }
        else
        {
            query   = this.queryBudgetExcelPivot();
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryExecuted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Builds the query used in running the statement report that shows actual amounts using the <c>ProjTransPosting</c> table as the data source.
    /// </summary>
    /// <returns>
    ///    The query.
    /// </returns>
    Query queryExecuted()
    {
        RecId                   legalEntity;

        QueryBuildDataSource    dataSource;

        query       = new Query();

        dataSource  = query.addDataSource(tableNum(ProjTransPosting));

        if (projId)
        {
            dataSource.addRange(fieldNum(ProjTransPosting, ProjId)).value(queryValue(projId));
        }

        if (projCategoryId)
        {
            dataSource.addRange(fieldNum(ProjTransPosting, CategoryId)).value(projCategoryId);
        }

        if (psaIndirectComponentCategory)
        {
            dataSource.addRange(fieldNum(ProjTransPosting, CategoryId)).value(psaIndirectComponentCategory);
        }

        if (projEmplItemId)
        {
            dataSource.addRange(fieldNum(ProjTransPosting, EmplItemId)).value(projEmplItemId);
        }

        if (projResourceRecId)
        {
            legalEntity = CompanyInfo::findDataArea(curext()).RecId;
            dataSource.addRange(fieldNum(ProjTransPosting, Resource)).value(queryValue(projResourceRecId));
        }

        if (projResourceCategoryRecId)
        {
            dataSource.addRange(fieldNum(ProjTransPosting, ResourceCategory)).value(queryValue(projResourceCategoryRecId));
        }

        if (subscriptionId)
        {
            dataSource.addRange(fieldNum(ProjTransPosting, SubscriptionId)).value(queryValue(subscriptionId));
        }

        if (transId)
        {
            dataSource.addRange(fieldNum(ProjTransPosting, TransId)).value(transId);
        }

        if (projActivityNumber)
        {
            dataSource.addRange(fieldNum(ProjTransPosting, ActivityNumber)).value(projActivityNumber);
        }

        if ((fundingSource != 0) || (rangeOnEmptyFundingSource == true))
        {
            dataSource.addRange(fieldNum(ProjTransPosting, ProjFundingSource)).value(queryValue(fundingSource));
        }

        dataSource.addRange(fieldNum(ProjTransPosting, LedgerTransDate)).value(queryRange(ledgerTransDateFrom,ledgerTransDateTo));
        dataSource.addRange(fieldNum(ProjTransPosting, ProjTransDate)).value(queryRange(projTransDateFrom,projTransDateTo));

        //  project type
        if (!enableProjMultipleContractLinesForProjectFeature)
        {
            if (timeMaterial)
            {
                dataSource.addRange(fieldNum(ProjTransPosting, ProjType)).value(queryValue(ProjType::TimeMaterial));
            }

            if (fixedPrice)
            {
                dataSource.addRange(fieldNum(ProjTransPosting, ProjType)).value(queryValue(ProjType::FixedPrice));
            }

            if (investment)
            {
                dataSource.addRange(fieldNum(ProjTransPosting, ProjType)).value(queryValue(ProjType::Investment));
            }

            if (cost)
            {
                dataSource.addRange(fieldNum(ProjTransPosting, ProjType)).value(queryValue(ProjType::Cost));
            }

            if (internalProjType)
            {
                dataSource.addRange(fieldNum(ProjTransPosting, ProjType)).value(queryValue(ProjType::Internal));
            }
            
            if (time)
            {
                dataSource.addRange(fieldNum(ProjTransPosting, ProjType)).value(queryValue(ProjType::Time));
            }
        }

        // transaction types

        if (hour)
        {
            dataSource.addRange(fieldNum(ProjTransPosting, ProjTransType)).value(queryValue(ProjTransType::Hour));
        }

        if (expenses)
        {
            dataSource.addRange(fieldNum(ProjTransPosting, ProjTransType)).value(queryValue(ProjTransType::Cost));
        }

        if (item)
        {
            dataSource.addRange(fieldNum(ProjTransPosting, ProjTransType)).value(queryValue(ProjTransType::Item));
        }

        if (revenue)
        {
            dataSource.addRange(fieldNum(ProjTransPosting, ProjTransType)).value(queryValue(ProjTransType::Revenue));
        }

        if (onAccount)
        {
            dataSource.addRange(fieldNum(ProjTransPosting, ProjTransType)).value(queryValue(ProjTransType::OnAccount));
        }

        // posting types
        if (this.ledgerTurnover())
        {
            dataSource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjTurnover));
        }

        if (this.ledgerAccruedCost())
        {
            dataSource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjAccruedCost));
        }

        if (this.ledgerAccruedRevenueOnAccount())
        {
            dataSource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjAccruedRevenueOnAccount));
        }

        if (this.ledgerAccruedTurnoverProd())
        {
            dataSource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjAccruedTurnoverProd));
        }

        if (this.ledgerAccruedTurnoverProfit())
        {
            dataSource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProJAccruedTurnoverProfit));
        }

        if (this.ledgerCost())
        {
            dataSource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjCost));
        }

        if (this.ledgerOffsetAccountItem())
        {
            dataSource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjOffsetAccountItem));
        }

        if (this.ledgerOnAccount())
        {
            dataSource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjOnAccount));
        }

        if (this.ledgerAccruedRevenueSubscription())
        {
            dataSource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjAccruedRevenueSubscription));
        }

        if (this.ledgerPayrollAllocation())
        {
            dataSource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjPayrollAllocation));
        }

        if (this.ledgerSalesvalue())
        {
            dataSource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalue));
        }

        if (this.ledgerSalesvalueOffset())
        {
            dataSource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalueOffset));
        }

        if (this.ledgerStatusAccountItem())
        {
            dataSource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjStatusAccountItem));
        }

        if (this.ledgerWIPCostvalue())
        {
            dataSource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjWIPCostvalue));
        }

        if (this.ledgerWIPInvoicedOnAccount())
        {
            dataSource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjWIPInvoicedOnAccount));
        }

        if (this.ledgerWIPProduction())
        {
            dataSource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjWIPProduction));
        }

        if (this.ledgerWIPProfit())
        {
            dataSource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjWIPProfit));
        }

        if (this.ledgerWIPSubscription())
        {
            dataSource.addRange(fieldNum(ProjTransPosting, PostingType)).value(queryValue(LedgerPostingType::ProjWIPSubscription));
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRealized</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Builds the query used in running the statement report that shows actual amounts using the <c>ProjTransPosting</c> table as the data source.
    /// </summary>
    /// <returns>
    ///    The query.
    /// </returns>
    Query queryRealized()
    {
        QueryBuildFieldList queryBuildFieldList;

        query = new Query();

        transDataSource = query.addDataSource(tableNum(ProjTransPosting));
        transDataSource.orderMode(OrderMode::GroupBy);

        queryBuildFieldList = transDataSource.fields();

        queryBuildFieldList.dynamic(false);
        queryBuildFieldList.addField(fieldNum(ProjTransPosting, AmountMst), SelectionField::Sum);
        queryBuildFieldList.addField(fieldNum(ProjTransPosting, Qty), SelectionField::Sum);

        switch (listId)
        {
            case ProjListStateId::Project:
                transDataSource.addSortIndex(indexNum(ProjTransPosting, ProjIdx));
                break;

            case ProjListStateId::Category:
                transDataSource.addSortIndex(indexNum(ProjTransPosting, CategoryIdx));
                break;

            case ProjListStateId::EmplItem:
                transDataSource.addSortIndex(indexNum(ProjTransPosting, EmplItemIdx));
                break;

            case ProjListStateId::TransId:
                transDataSource.addSortIndex(indexNum(ProjTransPosting, TransIdx));
                break;

            case ProjListStateId::Activity:
                transDataSource.addSortIndex(indexNum(ProjTransPosting, ProjIdx));
                break;

            default:
                this.addProjTransPostingSortIdxDefault();
                break;
        }

        transDataSource.indexIsHint(true);

        if (projId)
        {
            transDataSource.addRange(fieldNum(ProjTransPosting, ProjId)).value(queryValue(projId));
        }

        if (projCategoryId)
        {
            transDataSource.addRange(fieldNum(ProjTransPosting, CategoryId)).value(queryValue(projCategoryId));
        }

        if (projEmplItemId)
        {
            transDataSource.addRange(fieldNum(ProjTransPosting, EmplItemId)).value(projEmplItemId);
        }

        if (projResourceRecId)
        {
            transDataSource.addRange(fieldNum(ProjTransPosting, Resource)).value(queryValue(projResourceRecId));
        }

        if (projResourceCategoryRecId)
        {
            transDataSource.addRange(fieldNum(ProjTransPosting, ResourceCategory)).value(queryValue(projResourceCategoryRecId));
        }

        if (subscriptionId)
        {
            transDataSource.addRange(fieldNum(ProjTransPosting, SubscriptionId)).value(queryValue(subscriptionId));
        }

        if (transId)
        {
            transDataSource.addRange(fieldNum(ProjTransPosting, TransId)).value(transId);
        }

        if (projActivityNumber)
        {
            transDataSource.addRange(fieldNum(ProjTransPosting, ActivityNumber)).value(projActivityNumber);
        }

        if ((fundingSource != 0) || (rangeOnEmptyFundingSource == true))
        {
            transDataSource.addRange(fieldNum(ProjTransPosting, ProjFundingSource)).value(queryValue(fundingSource));
        }

        transDataSource.addRange(fieldNum(ProjTransPosting, LedgerTransDate)).value(queryValue(ledgerTransDateFrom) + '..' + queryValue(ledgerTransDateTo));
        transDataSource.addRange(fieldNum(ProjTransPosting, ProjTransDate)).value(queryValue(projTransDateFrom) + '..' + queryValue(projTransDateTo));

        if (!enableProjMultipleContractLinesForProjectFeature)
        {
            if (timeMaterial)
            {
                transDataSource.addRange(fieldNum(ProjTransPosting, ProjType)).value(queryValue(ProjType::TimeMaterial));
            }

            if (fixedPrice)
            {
                transDataSource.addRange(fieldNum(ProjTransPosting, ProjType)).value(queryValue(ProjType::FixedPrice));
            }

            if (investment)
            {
                transDataSource.addRange(fieldNum(ProjTransPosting, ProjType)).value(queryValue(ProjType::Investment));
            }

            if (cost)
            {
                transDataSource.addRange(fieldNum(ProjTransPosting, ProjType)).value(queryValue(ProjType::Cost));
            }

            if (internalProjType)
            {
                transDataSource.addRange(fieldNum(ProjTransPosting, ProjType)).value(queryValue(ProjType::Internal));
            }

            if (time)
            {
                transDataSource.addRange(fieldNum(ProjTransPosting, ProjType)).value(queryValue(ProjType::Time));
            }
        }

        if (custAccount)
        {
            projTableDataSource = transDataSource.addDataSource(tableNum(ProjTable));
            projTableDataSource.addLink(fieldNum(ProjTransPosting, ProjId), fieldNum(ProjTable, ProjId));
            projTableDataSource.addRange(fieldNum(ProjTable, CustAccount)).value(custAccount);
        }

        if (projCategoryGroupId)
        {
            projCategoryGroupDataSource = transDataSource.addDataSource(tableNum(ProjCategory));
            projCategoryGroupDataSource.addLink(fieldNum(ProjTransPosting, CategoryId), fieldNum(ProjCategory, CategoryId));
            projCategoryGroupDataSource.addRange(fieldNum(ProjCategory, CategoryGroupId)).value(projCategoryGroupId);
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryActualEntity</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Builds the query used in running the statement report that shows actual amounts using the <c>ProjTransPosting</c> table as the data source.
    /// </summary>
    /// <returns>
    ///    The query.
    /// </returns>
    Query queryActualEntity()
    {
        query = new Query(querystr(ProjActualsAggregates));

        transDataSource = query.dataSourceTable(tableNum(PSAActualEntity));
        transDataSource.orderMode(OrderMode::GroupBy);

        if (projId)
        {
            transDataSource.addRange(fieldNum(PSAActualEntity, ProjId)).value(queryValue(projId));
        }

        if (projCategoryId)
        {
            transDataSource.addRange(fieldNum(PSAActualEntity, CategoryId)).value(projCategoryId);
        }

        if (projEmplItemId)
        {
            transDataSource.addRange(fieldNum(PSAActualEntity, EmplItemId)).value(projEmplItemId);
        }

        if (projResourceRecId)
        {
            transDataSource.addRange(fieldNum(PSAActualEntity, Resource)).value(queryValue(projResourceRecId));
        }

        if (projResourceCategoryRecId)
        {
            transDataSource.addRange(fieldNum(PSAActualEntity, ResourceCategory)).value(queryValue(projResourceCategoryRecId));
        }

        if (subscriptionId)
        {
            transDataSource.addRange(fieldNum(PSAActualEntity, SubscriptionId)).value(queryValue(subscriptionId));
        }

        if (transId)
        {
            transDataSource.addRange(fieldNum(PSAActualEntity, TransId)).value(transId);
        }

        if (projActivityNumber)
        {
            transDataSource.addRange(fieldNum(PSAActualEntity, ActivityNumber)).value(projActivityNumber);
        }

        if ((fundingSource != 0) || (rangeOnEmptyFundingSource == true))
        {
            transDataSource.addRange(fieldNum(PSAActualEntity, ProjFundingSource)).value(queryValue(fundingSource));
        }

        transDataSource.addRange(fieldNum(PSAActualEntity, LedgerTransDate)).value(queryValue(ledgerTransDateFrom) + '..' + queryValue(ledgerTransDateTo));
        transDataSource.addRange(fieldNum(PSAActualEntity, ProjTransDate)).value(queryValue(projTransDateFrom) + '..' + queryValue(projTransDateTo));

        if (!enableProjMultipleContractLinesForProjectFeature)
        {
            if (timeMaterial)
            {
                transDataSource.addRange(fieldNum(PSAActualEntity, ProjType)).value(queryValue(ProjType::TimeMaterial));
            }

            if (fixedPrice)
            {
                transDataSource.addRange(fieldNum(PSAActualEntity, ProjType)).value(queryValue(ProjType::FixedPrice));
            }

            if (investment)
            {
                transDataSource.addRange(fieldNum(PSAActualEntity, ProjType)).value(queryValue(ProjType::Investment));
            }

            if (cost)
            {
                transDataSource.addRange(fieldNum(PSAActualEntity, ProjType)).value(queryValue(ProjType::Cost));
            }

            if (internalProjType)
            {
                transDataSource.addRange(fieldNum(PSAActualEntity, ProjType)).value(queryValue(ProjType::Internal));
            }

            if (time)
            {
                transDataSource.addRange(fieldNum(PSAActualEntity, ProjType)).value(queryValue(ProjType::Time));
            }
        }

        if (hour)
        {
            transDataSource.addRange(fieldNum(PSAActualEntity, ProjTransType)).value(queryValue(ProjTransType::Hour));
        }

        if (revenue)
        {
            transDataSource.addRange(fieldNum(PSAActualEntity, ProjTransType)).value(queryValue(ProjTransType::Revenue));
        }

        if (expenses)
        {
            transDataSource.addRange(fieldNum(PSAActualEntity, ProjTransType)).value(queryValue(ProjTransType::Cost));
        }

        if (item)
        {
            transDataSource.addRange(fieldNum(PSAActualEntity, ProjTransType)).value(queryValue(ProjTransType::Item));
        }

        if (onAccount)
        {
            transDataSource.addRange(fieldNum(PSAActualEntity, ProjTransType)).value(queryValue(ProjTransType::OnAccount));
        }

        if (custAccount)
        {
            projTableDataSource = transDataSource.addDataSource(tableNum(ProjTable));
            projTableDataSource.addLink(fieldNum(PSAActualEntity, ProjId), fieldNum(ProjTable, ProjId));
            projTableDataSource.addRange(fieldNum(ProjTable, CustAccount)).value(custAccount);
            projTableDataSource.fetchMode(QueryFetchMode::One2One);
        }

        if (projCategoryGroupId)
        {
            projCategoryGroupDataSource = transDataSource.addDataSource(tableNum(ProjCategory));
            projCategoryGroupDataSource.addLink(fieldNum(PSAActualEntity, CategoryId), fieldNum(ProjCategory, CategoryId));
            projCategoryGroupDataSource.addRange(fieldNum(ProjCategory, CategoryGroupId)).value(projCategoryGroupId);
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a zero sales amount. This method can be overridden by sub classes that derive from this class.
    /// </summary>
    /// <returns>
    ///    A zero sales amount.
    /// </returns>
    AmountMST salesAmount()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAmountProjStatisticExcelPivot</Name>
				<Source><![CDATA[
    TmpProjStatisticExcelPivot  setAmountProjStatisticExcelPivot(
    ProjStatisticDimension     _projStatisticDimension,
    AmountMST                  _amountMST,
    Qty                        _qty,
    TmpProjStatisticExcelPivot _tmpProjStatisticExcelPivot)
    {
        boolean     noNeverPosting;

        switch (_projStatisticDimension)
        {
            case ProjStatisticDimension::PLHourQty:
                _tmpProjStatisticExcelPivot.GeneralHoursQty += _qty;
                break;

            case ProjStatisticDimension::PLTotalRevenue:
                _tmpProjStatisticExcelPivot.plTotalRevenue += -_amountMST;
                _tmpProjStatisticExcelPivot.plTotalGrossMargin =
                _tmpProjStatisticExcelPivot.plTotalRevenue -
                _tmpProjStatisticExcelPivot.plCostTotalCost;

                _tmpProjStatisticExcelPivot.plTotalValueAddedAmount =
                _tmpProjStatisticExcelPivot.plTotalRevenue -
                _tmpProjStatisticExcelPivot.plRatioTotalCost +
                _tmpProjStatisticExcelPivot.plCostHour;
                break;

            case ProjStatisticDimension::PLTotalCost:
                _tmpProjStatisticExcelPivot.plCostTotalCost += _amountMST;
                _tmpProjStatisticExcelPivot.plTotalGrossMargin =
                _tmpProjStatisticExcelPivot.plTotalRevenue -
                _tmpProjStatisticExcelPivot.plCostTotalCost;

                if (_tmpProjStatisticExcelPivot.PostingType != LedgerPostingType::ProjAccruedCost)
                {
                    _tmpProjStatisticExcelPivot.plRatioTotalCost += _amountMST;
                }

                if (_tmpProjStatisticExcelPivot.ProjTransType == ProjTransType::Hour &&
               (_tmpProjStatisticExcelPivot.PostingType == LedgerPostingType::ProjCost ||
                _tmpProjStatisticExcelPivot.PostingType == LedgerPostingType::ProjNeverLedger ||
                _tmpProjStatisticExcelPivot.PostingType == LedgerPostingType::ProjNoLedger))
                {
                    _tmpProjStatisticExcelPivot.plCostHour += _amountMST;
                }

                _tmpProjStatisticExcelPivot.plTotalValueAddedAmount =
                _tmpProjStatisticExcelPivot.plTotalRevenue -
                _tmpProjStatisticExcelPivot.plRatioTotalCost +
                _tmpProjStatisticExcelPivot.plCostHour;

                break;

            case ProjStatisticDimension::WIPHourQty:
                _tmpProjStatisticExcelPivot.wipHourQty += _qty;
                break;

            case ProjStatisticDimension::WIPGrossWIP:
                _tmpProjStatisticExcelPivot.wipTotalGrossWIP += _amountMST;
                _tmpProjStatisticExcelPivot.wipTotalNetWIP =
                _tmpProjStatisticExcelPivot.wipTotalGrossWIP -
                _tmpProjStatisticExcelPivot.wipInvoiceOnAcc;
                break;

            case ProjStatisticDimension::WIPInvoiceOnAcc:
                _tmpProjStatisticExcelPivot.wipInvoiceOnAcc += -_amountMST;
                _tmpProjStatisticExcelPivot.wipTotalNetWIP =
                _tmpProjStatisticExcelPivot.wipTotalGrossWIP -
                _tmpProjStatisticExcelPivot.wipInvoiceOnAcc;
                break;

            case ProjStatisticDimension::PayrollAllocation:
            if (this.checkHourQty())
                {
                    _tmpProjStatisticExcelPivot.OtherPayrollQty += -_qty;
                }
                if (this.checkHourAmount())
                {
                    _tmpProjStatisticExcelPivot.OtherPayroll    += -_amountMST;
                }
                break;

            case ProjStatisticDimension::ConsumptionHourQtyAndCost:
            noNeverPosting = _tmpProjStatisticExcelPivot.PostingType == LedgerPostingType::ProjNeverLedger ||
                             _tmpProjStatisticExcelPivot.PostingType == LedgerPostingType::ProjNoLedger;
                if ((noNeverPosting && ProjParameters::find().StatementConsumpHourQty) || !noNeverPosting)
                {
                    _tmpProjStatisticExcelPivot.OtherConsumHoursQty   += _qty;
                }
                if ((noNeverPosting && ProjParameters::find().StatementConsumpHourCost) || !noNeverPosting)
                {
                    _tmpProjStatisticExcelPivot.OtherConsumHourRate   += _amountMST;
                    _tmpProjStatisticExcelPivot.OtherConsumNotCapital += _amountMST;
                }
                break;

            case ProjStatisticDimension::ConsumptionExpenseCost:
                _tmpProjStatisticExcelPivot.OtherConsumExp        += _amountMST;
                _tmpProjStatisticExcelPivot.OtherConsumNotCapital += _amountMST;
                break;

            case ProjStatisticDimension::ConsumptionItemCost:
                _tmpProjStatisticExcelPivot.OtherConsumItem       += _amountMST;
                _tmpProjStatisticExcelPivot.OtherConsumNotCapital += _amountMST;
                break;

            case ProjStatisticDimension::InvoiceOnAccount:
                _tmpProjStatisticExcelPivot.OtherOnAccInvoiceOnAcc += -_amountMST;
                break;
        }

        return tmpProjStatisticExcelPivot;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setClearCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets or gets the variable <paramref name="clearCache" /> that determines whether all the cache used
    ///    for the statement report should be cleared or not.
    /// </summary>
    /// <param name="_clearCache">
    ///    The value to set the variable with; optional.
    /// </param>
    /// <returns>
    ///    The value of <paramref name="clearCache" />.
    /// </returns>
    boolean setClearCache(boolean _clearCache  = clearCache)
    {
        clearCache  = _clearCache;

        return clearCache;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTmpProjStatisticExcelPivot</Name>
				<Source><![CDATA[
    void setTmpProjStatisticExcelPivot(
    ProjStatisticDimension      _projStatisticDimension,
    ProjExportToExcelWorksheet  _projStatementType)
    {
        container                   dataExportRecord;
        container                   dataExportRecordSet;
        int                         containerCount = 0;
        ProjItemTrans               projItemTrans;
        PurchLine                   purchLine;
        VendInvoiceInfoLine_Project vendInvoiceInfoLine_Project;
        VendInvoiceInfoLine         vendInvoiceInfoLine;
        VendInvoiceInfoTable        vendInvoiceInfoTable;

        #DEFINE.ContainerLimit(200)

        queryRun        = new QueryRun(query);

        while (queryRun.next())
        {
            if (this.parmActual())
            {
                projTransPosting = queryRun.get(tableNum(ProjTransPosting));

                tmpProjStatisticExcelPivot.clearAmounts();
                tmpProjStatisticExcelPivot.Vendor = '';
                tmpProjStatisticExcelPivot.OrderNumber = '';
                tmpProjStatisticExcelPivot.initFromProjTransPosting(projTransPosting, _projStatementType, ProjActualBudget::Actual);
                tmpProjStatisticExcelPivot.initFromProjTable(ProjTable::find(tmpProjStatisticExcelPivot.ProjId));
                tmpProjStatisticExcelPivot.initFromProjCategory(ProjCategory::find(tmpProjStatisticExcelPivot.CategoryId));

                // Set Order Number and Vendor
                if (projTransPosting.ProjTransType == ProjTransType::Item)
                {
                    if ((projTransPosting.TransactionOrigin == ProjOrigin::SalesOrder)         ||
                    (projTransPosting.TransactionOrigin == ProjOrigin::ItemRequirement)    ||
                    (projTransPosting.TransactionOrigin == ProjOrigin::PurchaseOrder)      ||
                    (projTransPosting.TransactionOrigin == ProjOrigin::VendorInvoice)      ||
                    (projTransPosting.TransactionOrigin == ProjOrigin::ProductionFinished) ||
                    (projTransPosting.TransactionOrigin == ProjOrigin::ProductionConsumed) ||
                    (projTransPosting.TransactionOrigin == ProjOrigin::BeginningBalance))
                    {
                        projItemTrans = ProjItemTrans::find(projTransPosting.TransId);

                        tmpProjStatisticExcelPivot.OrderNumber = ProjInvoiceItem::findTransId(projItemTrans.ProjTransId).SalesId;
                        if (projTransPosting.TransactionOrigin == ProjOrigin::PurchaseOrder)
                        {
                            select firstonly purchLine
                            where purchLine.ProjTransId     == projTransPosting.TransId;
                            tmpProjStatisticExcelPivot.Vendor = purchLine.purchTable().vendTable_OrderAccount().AccountNum;
                        }
                        else if (projTransPosting.TransactionOrigin == ProjOrigin::VendorInvoice)
                        {
                            select firstonly RecId
                            from vendInvoiceInfoLine_Project
                                where vendInvoiceInfoLine_Project.ProjTransId == projTransPosting.TransId
                            join RecId from vendInvoiceInfoLine
                                where vendInvoiceInfoLine.RecId == vendInvoiceInfoLine_Project.VendInvoiceInfoLineRefRecId
                            join OrderAccount from vendInvoiceInfoTable
                                where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLine.ParmId &&
                                    vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLine.TableRefId;
                            tmpProjStatisticExcelPivot.Vendor = vendInvoiceInfoTable.OrderAccount;
                        }
                    }
                }

                this.setAmountProjStatisticExcelPivot(_projStatisticDimension,
                                                  projTransPosting.AmountMst,
                                                  projTransPosting.Qty,
                                                  tmpProjStatisticExcelPivot);

                dataExportRecord = buf2Con(tmpProjStatisticExcelPivot);
                dataExportRecordSet += [dataExportRecord];
                containerCount++;

                // Calculate Sum and Deviation
                if (this.parmSum() || this.parmDeviation())
                {
                    if (this.parmSum())
                    {
                        tmpProjStatisticExcelPivot.initFromProjTransPosting(projTransPosting, _projStatementType, ProjActualBudget::Sum_);
                    }
                    else
                    {
                        tmpProjStatisticExcelPivot.initFromProjTransPosting(projTransPosting, _projStatementType, ProjActualBudget::Deviation);

                        // Profit and Loss
                        tmpProjStatisticExcelPivot.GeneralHoursQty       = -tmpProjStatisticExcelPivot.GeneralHoursQty;
                        tmpProjStatisticExcelPivot.plCostTotalCost       = -tmpProjStatisticExcelPivot.plCostTotalCost;
                        tmpProjStatisticExcelPivot.plRatioTotalCost      = -tmpProjStatisticExcelPivot.plRatioTotalCost;
                        tmpProjStatisticExcelPivot.plCostHour            = -tmpProjStatisticExcelPivot.plCostHour;

                        // Consumption
                        tmpProjStatisticExcelPivot.OtherConsumHoursQty   = -tmpProjStatisticExcelPivot.OtherConsumHoursQty;
                        tmpProjStatisticExcelPivot.OtherConsumHourRate   = -tmpProjStatisticExcelPivot.OtherConsumHourRate;
                        tmpProjStatisticExcelPivot.OtherConsumExp        = -tmpProjStatisticExcelPivot.OtherConsumExp;
                        tmpProjStatisticExcelPivot.OtherConsumItem       = -tmpProjStatisticExcelPivot.OtherConsumItem;

                        // On Account
                        tmpProjStatisticExcelPivot.OtherOnAccInvoiceOnAcc = -tmpProjStatisticExcelPivot.OtherOnAccInvoiceOnAcc;
                    }

                    dataExportRecord = buf2Con(tmpProjStatisticExcelPivot);
                    dataExportRecordSet += [dataExportRecord];
                    containerCount++;
                }
            }

            else if (this.parmBudget())
            {
                projTransBudget = queryRun.get(tableNum(ProjTransBudget));

                tmpProjStatisticExcelPivot.clearAmounts();
                tmpProjStatisticExcelPivot.initFromProjTransBudget(projTransBudget, _projStatementType, ProjActualBudget::Budget);
                tmpProjStatisticExcelPivot.initFromProjTable(ProjTable::find(tmpProjStatisticExcelPivot.ProjId));
                tmpProjStatisticExcelPivot.initFromProjCategory(ProjCategory::find(tmpProjStatisticExcelPivot.CategoryId));

                this.setAmountProjStatisticExcelPivot(_projStatisticDimension,
                                                  projTransBudget.AmountMst,
                                                  projTransBudget.Qty,
                                                  tmpProjStatisticExcelPivot);

                dataExportRecord = buf2Con(tmpProjStatisticExcelPivot);
                dataExportRecordSet += [dataExportRecord];
                containerCount++;

                // Calculate Sum and Deviation
                if (this.parmSum() || this.parmDeviation())
                {
                    if (this.parmSum())
                    {
                        tmpProjStatisticExcelPivot.initFromProjTransBudget(projTransBudget, _projStatementType, ProjActualBudget::Sum_);
                    }
                    else
                    {
                        tmpProjStatisticExcelPivot.initFromProjTransBudget(projTransBudget, _projStatementType, ProjActualBudget::Deviation);

                        // Profit and Loss
                        tmpProjStatisticExcelPivot.plTotalRevenue                = -tmpProjStatisticExcelPivot.plTotalRevenue;
                        tmpProjStatisticExcelPivot.plTotalGrossMargin            = -tmpProjStatisticExcelPivot.plTotalGrossMargin;
                        tmpProjStatisticExcelPivot.plTotalValueAddedAmount       = -tmpProjStatisticExcelPivot.plTotalValueAddedAmount;

                        // WIp
                        tmpProjStatisticExcelPivot.wipHourQty       = -tmpProjStatisticExcelPivot.wipHourQty;
                        tmpProjStatisticExcelPivot.wipTotalGrossWIP = -tmpProjStatisticExcelPivot.wipTotalGrossWIP;
                        tmpProjStatisticExcelPivot.wipInvoiceOnAcc  = -tmpProjStatisticExcelPivot.wipInvoiceOnAcc;
                        tmpProjStatisticExcelPivot.wipTotalNetWIP   = -tmpProjStatisticExcelPivot.wipTotalNetWIP;

                        // Payroll allocation
                        tmpProjStatisticExcelPivot.OtherPayrollQty  = -tmpProjStatisticExcelPivot.OtherPayrollQty;
                        tmpProjStatisticExcelPivot.OtherPayroll     = -tmpProjStatisticExcelPivot.OtherPayroll;

                        // Consumption
                        tmpProjStatisticExcelPivot.OtherConsumNotCapital = -tmpProjStatisticExcelPivot.OtherConsumNotCapital;
                    }

                    tmpProjStatisticExcelPivot.initFromProjTable(ProjTable::find(tmpProjStatisticExcelPivot.ProjId));
                    tmpProjStatisticExcelPivot.initFromProjCategory(ProjCategory::find(tmpProjStatisticExcelPivot.CategoryId));

                    dataExportRecord = buf2Con(tmpProjStatisticExcelPivot);
                    dataExportRecordSet += [dataExportRecord];
                    containerCount++;
                }
            }

            if (containerCount > #ContainerLimit)
            {
                tmpProjStatisticExcelPivot.data(projStatement::insertToExcelExportFile(dataExportRecordSet, tmpProjStatisticExcelPivot));
                containerCount = 0;
                dataExportRecord = conNull();
                dataExportRecordSet = conNull();
            }
        }

        // Save to table tmpProjStatisticExcelPivot
        if (conLen(dataExportRecordSet) > 0)
        {
            tmpProjStatisticExcelPivot.data(projStatement::insertToExcelExportFile(dataExportRecordSet, tmpProjStatisticExcelPivot));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpProjStatisticExcelPivot</Name>
				<Source><![CDATA[
    public TmpProjStatisticExcelPivot tmpProjStatisticExcelPivot(
    TmpProjStatisticExcelPivot _tmpProjStatisticExcelPivot = tmpProjStatisticExcelPivot)
    {
        tmpProjStatisticExcelPivot = _tmpProjStatisticExcelPivot;

        return tmpProjStatisticExcelPivot;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transListQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns zero quantity. This method can be overidden by sub classes that derive from this class.
    /// </summary>
    /// <returns>
    ///    A zero quantity.
    /// </returns>
    ProjQty transListQty()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transNoEliminationOrigin</Name>
				<Source><![CDATA[
    void transNoEliminationOrigin()
    {
        transDataSource.addRange(fieldNum(ProjTransPosting, LedgerOrigin)).value(strFmt('(%1 != %2) && (%1 != %3)',
        fieldStr(ProjTransPosting, LedgerOrigin),
        enum2int(ProjOrigin::EliminateEstimate),
        enum2int(ProjOrigin::ReverseElimination)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipGrossWIP</Name>
				<Source><![CDATA[
    void wipGrossWIP()
    {
        //
        // Calculate Hour
        //
        if (hour && this.checkHourAmount() && (this.ledgerWIPProduction() || this.ledgerWIPProfit() || this.ledgerSalesvalueOffset() || this.ledgerWIPCostvalue()))
        {
            query   = this.queryBuildExcelPivot();
            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Hour));
                if (this.ledgerWIPProduction())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProduction));
                }
                if (this.ledgerWIPProfit())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProfit));
                }
                if (this.ledgerSalesvalueOffset())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalueOffset));
                }
                if (this.ledgerWIPCostvalue())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPCostvalue));
                }
            }

            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));
                if (this.ledgerWIPProduction())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProduction));
                }
                if (this.ledgerWIPProfit())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProfit));
                }
                if (this.ledgerSalesvalueOffset())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalueOffset));
                }
                if (this.ledgerWIPCostvalue())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPCostvalue));
                }
            }

            this.setTmpProjStatisticExcelPivot(ProjStatisticDimension::WIPGrossWIP, ProjExportToExcelWorksheet::StatWIP);
        }

        //
        // Calculate Item
        //
        if (item && (this.ledgerWIPProduction() || this.ledgerWIPProfit() || this.ledgerSalesvalueOffset() || this.ledgerWIPCostvalue()))
        {
            query   = this.queryBuildExcelPivot();
            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Item));
                if (this.ledgerWIPProduction())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProduction));
                }
                if (this.ledgerWIPProfit())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProfit));
                }
                if (this.ledgerSalesvalueOffset())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalueOffset));
                }
                if (this.ledgerWIPCostvalue())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjStatusAccountItem));
                }
            }

            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Item));
                if (this.ledgerWIPProduction())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProduction));
                }
                if (this.ledgerWIPProfit())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProfit));
                }
                if (this.ledgerSalesvalueOffset())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalueOffset));
                }
                if (this.ledgerWIPCostvalue())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjStatusAccountItem));
                }
            }

            this.setTmpProjStatisticExcelPivot(ProjStatisticDimension::WIPGrossWIP, ProjExportToExcelWorksheet::StatWIP);
        }

        //
        // Calculate Expenses
        //
        if (expenses && (this.ledgerWIPProduction() || this.ledgerWIPProfit() || this.ledgerSalesvalueOffset() || this.ledgerWIPCostvalue()))
        {
            query   = this.queryBuildExcelPivot();
            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Cost));
                if (this.ledgerWIPProduction())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProduction));
                }
                if (this.ledgerWIPProfit())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProfit));
                }
                if (this.ledgerSalesvalueOffset())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalueOffset));
                }
                if (this.ledgerWIPCostvalue())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPCostvalue));
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPCost));
                }
            }

            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Cost));
                if (this.ledgerWIPProduction())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProduction));
                }
                if (this.ledgerWIPProfit())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProfit));
                }
                if (this.ledgerSalesvalueOffset())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalueOffset));
                }
                if (this.ledgerWIPCostvalue())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPCostvalue));
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPCost));
                }
            }

            this.setTmpProjStatisticExcelPivot(ProjStatisticDimension::WIPGrossWIP, ProjExportToExcelWorksheet::StatWIP);
        }

        //
        // Calculate Revenue
        //
        if (revenue && (this.ledgerWIPProduction() || this.ledgerWIPProfit() || this.ledgerSalesvalueOffset()))
        {
            query   = this.queryBuildExcelPivot();
            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Revenue));
                if (this.ledgerWIPProduction())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProduction));
                }
                if (this.ledgerWIPProfit())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProfit));
                }
                if (this.ledgerSalesvalueOffset())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalueOffset));
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPSubscription));
                }
            }

            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Revenue));
                if (this.ledgerWIPProduction())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProduction));
                }
                if (this.ledgerWIPProfit())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPProfit));
                }
                if (this.ledgerSalesvalueOffset())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalueOffset));
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPSubscription));
                }
            }

            this.setTmpProjStatisticExcelPivot(ProjStatisticDimension::WIPGrossWIP, ProjExportToExcelWorksheet::StatWIP);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipHourQty</Name>
				<Source><![CDATA[
    void wipHourQty()
    {
        if ((hour) && this.checkHourAmount() && (this.ledgerSalesvalueOffset() || this.ledgerWIPCostvalue()))
        {
            query   = this.queryBuildExcelPivot();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::Hour));
                if (this.ledgerSalesvalueOffset())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalueOffset));
                }
                if (this.ledgerWIPCostvalue())
                {
                    transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPCostvalue));
                }
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::Hour));
                if (this.ledgerSalesvalueOffset())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjSalesvalueOffset));
                }
                if (this.ledgerWIPCostvalue())
                {
                    transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPCostvalue));
                }
            }

            this.setTmpProjStatisticExcelPivot(ProjStatisticDimension::WIPHourQty, ProjExportToExcelWorksheet::StatWIP);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipInvoiceOnAccount</Name>
				<Source><![CDATA[
    void wipInvoiceOnAccount()
    {
        if (onAccount && this.ledgerWIPInvoicedOnAccount())
        {
            query   = this.queryBuildExcelPivot();

            if (this.parmActual())
            {
                transDataSource.addRange(fieldNum(ProjTransPosting,ProjTransType)).value(queryValue(ProjTransType::OnAccount));
                transDataSource.addRange(fieldNum(ProjTransPosting,PostingType)).value(queryValue(LedgerPostingType::ProjWIPInvoicedOnAccount));
            }
            else if (this.parmBudget())
            {
                transDataSource.addRange(fieldNum(ProjTransBudget,ProjTransType)).value(queryValue(ProjTransType::OnAccount));
                transDataSource.addRange(fieldNum(ProjTransBudget,PostingType)).value(queryValue(LedgerPostingType::ProjWIPInvoicedOnAccount));
            }

            this.setTmpProjStatisticExcelPivot(ProjStatisticDimension::WIPInvoiceOnAcc, ProjExportToExcelWorksheet::StatWIP);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an instance of the appropriate class that inherits from this class based on the type of project statement report passed in as a parameter.
    /// </summary>
    /// <param name="_projListStateType">
    ///    The type project statement report.
    /// </param>
    /// <returns>
    ///    An instance of the appropriate class.
    /// </returns>
    static projStatement construct(ProjListStateType _projListStateType)
    {
        projStatement   projStatement = projStatement::getProjStatement(_projListStateType);

        if (!projStatement)
        {
            // Project posting is not implemented for this type.
            throw error("@SYS50155");
        }

        return projStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjStatement</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes a new instance of <c>ProjStatement</c> based on list state type.
    /// </summary>
    /// <param name = "_projListStateType">
    ///     An enum value of <c>ProjListStateType</c>.
    /// </param>
    /// <returns>
    ///     An instance of <c>ProjStatement</c>.
    /// </returns>
    protected static projStatement getProjStatement(ProjListStateType _projListStateType)
    {
        projStatement projStatement;

        switch (_projListStateType)
        {
            case ProjListStateType::ProfitLoss:
                projStatement = new projStatementProfitLoss();
                break;

            case ProjListStateType::WIP:
            case ProjListStateType::WIPActivity:
                projStatement = new projStatementWIP();
                break;

            case ProjListStateType::Payroll:
                projStatement = new projStatementPayroll();
                break;

            case ProjListStateType::Consumption:
            case ProjListStateType::ConsumptionActivity:
                projStatement = new projStatementConsumption();
                break;

            case ProjListStateType::OnAccount:
                projStatement = new projStatementOnAccount();
                break;

            case ProjListStateType::ProfitLossActivity:
                projStatement = new projStatementProfitLossActivity();
                break;

            case ProjListStateType::Invoice:
                projStatement = new ProjStatementInvoice();
                break;
        }
        return projStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertToExcelExportFile</Name>
				<Source><![CDATA[
    public static TmpProjStatisticExcelPivot insertToExcelExportFile(container   _dataRecords,
                                                                        TmpProjStatisticExcelPivot  _tmpExcelExportFile)
    {
        TmpProjStatisticExcelPivot  tmpExcelExportFile = _tmpExcelExportFile;
        int                         conIndex;
        container                   dataExportRecord;

        ttsbegin;

        for (conIndex=1; conIndex<=conLen(_dataRecords); conIndex+=1)
        {
            dataExportRecord = conPeek(_dataRecords, conIndex);
            tmpExcelExportFile.clear();
            con2Buf(dataExportRecord, tmpExcelExportFile);
            tmpExcelExportFile.insert();
        }

        ttscommit;

        return tmpExcelExportFile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomExportToExcelFilterNode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Construct the Excel entity filter based of the Project statement dialog option selections.
    /// </summary>
    /// <returns>
    /// FilterNode object that will be set for the entity
    /// </returns>
    public static Microsoft.Dynamics.Platform.Integration.Office.FilterNode getCustomExportToExcelFilterNode(str _entityName, ProjStatistic _projStatistic)
    {
        ExportToExcelFilterTreeBuilder filterBuilder = new ExportToExcelFilterTreeBuilder(_entityName);

        var filter = filterBuilder.and(filterBuilder.companyFilter(), filterBuilder.areEqual(fieldStr(ProjStatementEntityMap, ProjId), _projStatistic.parmProjId()));

        if (_projStatistic.parmProjCategoryId())
        {
            filter = filterBuilder.and(filter, filterBuilder.areEqual(fieldStr(ProjStatementEntityMap, CategoryId), _projStatistic.parmProjCategoryId()));
        }

        if (_projStatistic.parmProjFromDate() != dateNull() && _projStatistic.parmProjToDate() != dateNull())
        {
            var transDateFilter = filterBuilder.and(
                filterBuilder.greaterThanOrEqualTo(fieldStr(ProjStatementEntityMap, ProjTransDate), _projStatistic.parmProjFromDate()),
                filterBuilder.lessThanOrEqualTo(fieldStr(ProjStatementEntityMap, ProjTransDate), _projStatistic.parmProjToDate()));

            filter = filterBuilder.and(filter, transDateFilter);
        }

        if (_projStatistic.parmLedgerFromDate() != dateNull() && _projStatistic.parmLedgerToDate() != dateNull())
        {
            var ledgerDateFilter = filterBuilder.and(
                filterBuilder.greaterThanOrEqualTo(fieldStr(ProjStatementEntityMap, LedgerTransDate), _projStatistic.parmLedgerFromDate()),
                filterBuilder.lessThanOrEqualTo(fieldStr(ProjStatementEntityMap, LedgerTransDate), _projStatistic.parmLedgerToDate()));

            filter = filterBuilder.and(filter, ledgerDateFilter);
        }

        //// Filter Transaction Types
        //// Put whatever is checked and add them to the list since we need an OR filter
        List listTrxType = new List(Types::Enum);

        if (_projStatistic.parmHour())
        {
            listTrxType.addEnd(ProjTransType::Hour);
        }

        if (_projStatistic.parmExpenses())
        {
            listTrxType.addEnd(ProjTransType::Cost);
        }

        if (_projStatistic.parmRevenue())
        {
            listTrxType.addEnd(ProjTransType::Revenue);
        }

        if (_projStatistic.parmItem())
        {
            listTrxType.addEnd(ProjTransType::Item);
        }

        if (_projStatistic.parmOnAcc())
        {
            listTrxType.addEnd(ProjTransType::OnAccount);
        }

        Debug::assert(listTrxType.elements() > 0);

        ListEnumerator listEnum = listTrxType.getEnumerator();
        listEnum.moveNext();
        var trxFilter = filterBuilder.areEqual(fieldStr(ProjStatementEntityMap, ProjTransType), listEnum.current());

        if (listTrxType.elements() == 1)
        {
            filter = filterBuilder.and(filter, trxFilter);
        }
        else
        {
            // get the next element to create the OR filter
            listEnum.moveNext();

            var trxOrFilter = filterBuilder.or(trxFilter, filterBuilder.areEqual(fieldStr(ProjStatementEntityMap, ProjTransType), listEnum.current()));

            while (listEnum.moveNext())
            {
                trxOrFilter = filterBuilder.or(trxOrFilter, filterBuilder.areEqual(fieldStr(ProjStatementEntityMap, ProjTransType), listEnum.current()));
            }

            filter = filterBuilder.and(filter, trxOrFilter);
        }

        return filter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newListProjConsumption</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an instance of the <c>projStatementConsumption</c> class and initializes it with values from the input parameters passed in.
    /// </summary>
    /// <param name="_listProjConsumption">
    ///    An instance of the <c>ProjListProjTrans_Consumption</c> class.
    /// </param>
    /// <param name="_actualBudget">
    ///    A <c>ProjActualBudget</c> enumeration that determines whether actuals or budget should be reported; optional.
    /// </param>
    /// <param name="_projAmountQty">
    ///    A <c>ProjAmountQty</c> enumeration that determines whether hours should be reported as an amount or quantity; optional.
    /// </param>
    /// <param name="_forecastModelId">
    ///    The unique identifier of the forcast model used; optional.
    /// </param>
    /// <returns>
    ///    An instance of the <c>projStatementConsumption</c> class.
    /// </returns>
    static projStatement newListProjConsumption(
    ProjListProjTrans_Consumption   _listProjConsumption,
    ProjActualBudget                _actualBudget       = ProjActualBudget::Actual,
    ProjAmountQty                   _projAmountQty      = ProjAmountQty::AmountQty,
    ForecastModelId                 _forecastModelId    = ''
)
    {
        projStatement projStatement = new projStatementConsumption();

        projStatement.parmHour(_listProjConsumption.parmHour());
        projStatement.parmExpenses(_listProjConsumption.parmExpenses());
        projStatement.parmItem(_listProjConsumption.parmItem());

        if (!ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            projStatement.parmTimeMaterial(_listProjConsumption.parmTimeMaterial());
            projStatement.parmFixedPrice(_listProjConsumption.parmFixedPrice());
            projStatement.parmInternal(_listProjConsumption.parmInternalCost());
            projStatement.parmCost(_listProjConsumption.parmInternalCost());
            projStatement.parmInvestment(_listProjConsumption.parmInvestment());
            projStatement.parmTime(_listProjConsumption.parmtime());
        }

        projStatement.parmLedgerTransDateFrom(_listProjConsumption.parmLedgerFromDate());
        projStatement.parmLedgerTransDateTo(_listProjConsumption.parmLedgerToDate());

        if (_listProjConsumption.parmProjBreakDate())
        {
            if (_actualBudget == ProjActualBudget::Actual)
            {
                projStatement.parmProjTransDateFrom(_listProjConsumption.parmProjFromDate());
                projStatement.parmProjTransDateTo(_listProjConsumption.parmProjBreakDate());
            }
            if (_actualBudget == ProjActualBudget::Budget)
            {
                projStatement.parmProjTransDateFrom(_listProjConsumption.parmProjBreakDate());
                projStatement.parmProjTransDateTo(_listProjConsumption.parmProjToDate());
            }
        }
        else
        {
            projStatement.parmProjTransDateFrom(_listProjConsumption.parmProjFromDate());
            projStatement.parmProjTransDateTo(_listProjConsumption.parmProjToDate());
        }
        projStatement.parmListId(_listProjConsumption.listStateId());
        projStatement.parmAmountQty(_projAmountQty);

        if (_actualBudget == ProjActualBudget::Actual)
        {
            projStatement.parmActual(true);
        }

        if (_actualBudget == ProjActualBudget::Budget)
        {
            projStatement.parmBudget(true);
            projStatement.parmforecastModelId(_forecastModelId);
        }

        return projStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newListProjConsumptionActivity</Name>
				<Source><![CDATA[
    static projStatement newListProjConsumptionActivity(
    ProjListProjTransConsumptionActivity   _listProjConsumption,
    ProjActualBudget                _actualBudget       = ProjActualBudget::Actual,
    ProjAmountQty                   _projAmountQty      = ProjAmountQty::AmountQty,
    ForecastModelId                 _forecastModelId    = ''
)
    {
        projStatement projStatement = new projStatementConsumption();

        projStatement.parmHour(_listProjConsumption.parmHour());
        projStatement.parmExpenses(_listProjConsumption.parmExpenses());
        projStatement.parmItem(_listProjConsumption.parmItem());

        projStatement.parmLedgerTransDateFrom(_listProjConsumption.parmLedgerFromDate());
        projStatement.parmLedgerTransDateTo(_listProjConsumption.parmLedgerToDate());

        projStatement.parmProjTransDateFrom(_listProjConsumption.parmProjFromDate());
        projStatement.parmProjTransDateTo(_listProjConsumption.parmProjToDate());
        projStatement.parmListId(_listProjConsumption.listStateId());
        projStatement.parmAmountQty(_projAmountQty);

        if (_actualBudget == ProjActualBudget::Actual)
        {
            projStatement.parmActual(true);
        }

        if (_actualBudget == ProjActualBudget::Budget)
        {
            projStatement.parmBudget(true);
            projStatement.parmforecastModelId(_forecastModelId);
        }

        return projStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newListProjOnAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an instance of the <c>projStatementOnAccount</c> class and initializes it with appropriate values from the input parameters passed in.
    /// </summary>
    /// <param name="_listProjOnAccount">
    ///    An instance of the <c>ProjListProjTrans_OnAccount</c> class.
    /// </param>
    /// <param name="_actualBudget">
    ///    A ProjActualBudget that determines whether actuals or budget should be reported; optional.
    /// </param>
    /// <param name="_forecastModelId">
    ///    A unique identifier of the forcast model used; optional.
    /// </param>
    /// <returns>
    ///    An instance of the <c>projStatementOnAccount</c> class.
    /// </returns>
    static projStatement newListProjOnAccount(
    ProjListProjTrans_OnAccount   _listProjOnAccount,
    ProjActualBudget              _actualBudget = ProjActualBudget::Actual,
    ForecastModelId               _forecastModelId = '' )
    {
        projStatement projStatement = new projStatementOnAccount();

        projStatement.parmOnAccount(true);

        if (!ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            projStatement.parmTimeMaterial(_listProjOnAccount.parmTimeMaterial());
            projStatement.parmFixedPrice(_listProjOnAccount.parmFixedPrice());
        }

        projStatement.parmLedgerTransDateFrom(_listProjOnAccount.parmLedgerFromDate());
        projStatement.parmLedgerTransDateTo(_listProjOnAccount.parmLedgerToDate());

        projStatement.parmProjTransDateFrom(_listProjOnAccount.parmProjFromDate());
        projStatement.parmProjTransDateTo(_listProjOnAccount.parmProjToDate());

        projStatement.parmListId(_listProjOnAccount.listStateId());

        if (_actualBudget == ProjActualBudget::Actual)
        {
            projStatement.parmActual(true);
        }
        if (_actualBudget == ProjActualBudget::Budget)
        {
            projStatement.parmBudget(true);
            projStatement.parmforecastModelId(_forecastModelId);
        }

        return projStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjCostTrans</Name>
				<Source><![CDATA[
    static projStatement newProjCostTrans(
    ProjCostTrans   _projCostTrans,
    TransDate       _ledgerDateFrom = dateNull(),
    TransDate       _ledgerDateTo   = dateMax())
    {
        ProjType      projType  = _projCostTrans.projTable().Type;
        projStatement projStatement = new projStatementStatistic();

        projStatement.parmHour(false);
        projStatement.parmRevenue(false);
        projStatement.parmExpenses(true);
        projStatement.parmOnAccount(false);
        projStatement.parmItem(false);

        if (!ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            projStatement.parmTimeMaterial(projType == ProjType::TimeMaterial ? true : false);
            projStatement.parmFixedPrice(projType   == ProjType::FixedPrice ? true : false);
            projStatement.parmInternal(projType     == ProjType::Internal ? true : false);
            projStatement.parmCost(projType         == ProjType::Cost ? true : false);
            projStatement.parmInvestment(projType   == ProjType::Investment ? true : false);
            projStatement.parmTime(projType         == ProjType::Time ? true : false);
        }

        projStatement.parmProjType(projType);

        projStatement.parmLedgerTransDateFrom(_ledgerDateFrom);
        projStatement.parmLedgerTransDateTo(_ledgerDateTo);

        projStatement.parmProjTransDateFrom(_projCostTrans.TransDate);
        projStatement.parmProjTransDateTo(_projCostTrans.TransDate);

        projStatement.parmTransId(_projCostTrans.TransId);
        projStatement.parmListId(ProjListStateId::TransId);

        projStatement.parmActual(true);

        return projStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjEmplTrans</Name>
				<Source><![CDATA[
    static projStatement newProjEmplTrans(
    ProjEmplTrans   _projEmplTrans,
    TransDate       _ledgerDateFrom = dateNull(),
    TransDate       _ledgerDateTo   = dateMax())
    {
        ProjType      projType  = _projEmplTrans.projTable().Type;
        projStatement projStatement = new projStatementStatistic();

        projStatement.parmHour(true);
        projStatement.parmRevenue(false);
        projStatement.parmExpenses(false);
        projStatement.parmOnAccount(false);
        projStatement.parmItem(false);

        if (!ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            projStatement.parmTimeMaterial(projType == ProjType::TimeMaterial ? true : false);
            projStatement.parmFixedPrice(projType   == ProjType::FixedPrice ? true : false);
            projStatement.parmInternal(projType     == ProjType::Internal ? true : false);
            projStatement.parmCost(projType         == ProjType::Cost ? true : false);
            projStatement.parmInvestment(projType   == ProjType::Investment ? true : false);
            projStatement.parmTime(projType         == ProjType::Time ? true : false);
        }
        projStatement.parmProjType(projType);

        projStatement.parmLedgerTransDateFrom(_ledgerDateFrom);
        projStatement.parmLedgerTransDateTo(_ledgerDateTo);

        projStatement.parmProjTransDateFrom(_projEmplTrans.TransDate);
        projStatement.parmProjTransDateTo(_projEmplTrans.TransDate);

        projStatement.parmTransId(_projEmplTrans.TransId);
        projStatement.parmListId(ProjListStateId::TransId);

        projStatement.parmActual(true);

        return projStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjItemTrans</Name>
				<Source><![CDATA[
    static projStatement newProjItemTrans(
    ProjItemTrans   _projItemTrans,
    TransDate       _ledgerDateFrom = dateNull(),
    TransDate       _ledgerDateTo   = dateMax())
    {
        ProjType      projType  = _projItemTrans.projTable().Type;
        projStatement projStatement = new projStatementStatistic();

        projStatement.parmHour(false);
        projStatement.parmRevenue(false);
        projStatement.parmExpenses(false);
        projStatement.parmOnAccount(false);
        projStatement.parmItem(true);

        if (!ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            projStatement.parmTimeMaterial(projType == ProjType::TimeMaterial ? true : false);
            projStatement.parmFixedPrice(projType == ProjType::FixedPrice ? true : false);
            projStatement.parmInternal(projType == ProjType::Internal ? true : false);
            projStatement.parmCost(projType == ProjType::Cost ? true : false);
            projStatement.parmInvestment(projType == ProjType::Investment ? true : false);
            projStatement.parmTime(projType         == ProjType::Time         ? true : false);
        }
        projStatement.parmProjType(projType);

        projStatement.parmLedgerTransDateFrom(_ledgerDateFrom);
        projStatement.parmLedgerTransDateTo(_ledgerDateTo);

        projStatement.parmProjTransDateFrom(_projItemTrans.TransDate);
        projStatement.parmProjTransDateTo(_projItemTrans.TransDate);

        projStatement.parmTransId(_projItemTrans.ProjTransId);
        projStatement.parmListId(ProjListStateId::TransId);

        projStatement.parmActual(true);

        return projStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjListHourRate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an instance of the <c>projStatementHourRate</c> class and initializes it with appropriate values from the input parameters passed in.
    /// </summary>
    /// <param name="_listProjHourRate">
    ///    An instance of the <c>ProjListProjTrans_HourRate</c> class.
    /// </param>
    /// <param name="_stateProjType">
    ///    The type of project statement report; optional.
    /// </param>
    /// <param name="_actualBudget">
    ///    A <c>ProjActualBudget</c> enumeration that determines whether actuals or budget should be reported; optional.
    /// </param>
    /// <param name="_amountQty">
    ///    A <c>ProjAmountQty</c> enumeration that determines whether hours should be reported as an amount or quantity; optional.
    /// </param>
    /// <param name="_forecastModelId">
    ///    The unique identifier of the forcast model used; optional.
    /// </param>
    /// <returns>
    ///    An instance of the <c>projStatementHourRate</c> class.
    /// </returns>
    static projStatement newProjListHourRate(
    ProjListProjTrans_HourRate  _listProjHourRate,
    ProjListStateProjType       _stateProjType  = ProjListStateProjType::Project,
    ProjActualBudget            _actualBudget   = ProjActualBudget::Actual,
    ProjAmountQty               _amountQty      = ProjAmountQty::AmountQty,
    ForecastModelId             _forecastModelId    = '')
    {
        projStatement projStatement = new projStatementHourRate();

        projStatement.parmHour(_listProjHourRate.parmHour());
        projStatement.parmRevenue(_listProjHourRate.parmRevenue());
        projStatement.parmExpenses(_listProjHourRate.parmExpenses());
        projStatement.parmOnAccount(_listProjHourRate.parmOnAcc());
        projStatement.parmItem(_listProjHourRate.parmItem());

        if (!ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            projStatement.parmTimeMaterial(_listProjHourRate.parmTimeMaterial());
            projStatement.parmFixedPrice(_listProjHourRate.parmFixedPrice());
            projStatement.parmInternal(_listProjHourRate.parmInternalCost());
            projStatement.parmCost(_listProjHourRate.parmInternalCost());
            projStatement.parmInvestment(_listProjHourRate.parmInvestment());
            projStatement.parmTime(_listProjHourRate.parmTime());
        }
        projStatement.parmLedgerTransDateFrom(_listProjHourRate.parmLedgerFromDate());
        projStatement.parmLedgerTransDateTo(_listProjHourRate.parmLedgerToDate());

        projStatement.parmProjTransDateFrom(_listProjHourRate.parmProjFromDate());
        projStatement.parmProjTransDateTo(_listProjHourRate.parmProjToDate());

        projStatement.parmListId(_listProjHourRate.listStateId());
        projStatement.parmStateProjType(_stateProjType);

        projStatement.parmAmountQty(_amountQty);

        if (_actualBudget == ProjActualBudget::Actual)
        {
            projStatement.parmActual(true);
        }

        if (_actualBudget == ProjActualBudget::Budget)
        {
            projStatement.parmBudget(true);
            projStatement.parmforecastModelId(_forecastModelId);
        }

        return projStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjListPayroll</Name>
				<Source><![CDATA[
    static projStatement newProjListPayroll(
    ProjListProjTrans_PayRoll   _listProjPayroll,
    ProjActualBudget            _actualBudget   = ProjActualBudget::Actual,
    ProjAmountQty               _amountQty      = ProjAmountQty::AmountQty,
    ForecastModelId             _forecastModelId = '')
    {
        projStatement projStatement = new projStatementPayroll();

        projStatement.parmHour(true);

        if (!ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            projStatement.parmTimeMaterial(_listProjPayroll.parmTimeMaterial());
            projStatement.parmFixedPrice(_listProjPayroll.parmFixedPrice());
            projStatement.parmInternal(_listProjPayroll.parmInternalCost());
            projStatement.parmCost(_listProjPayroll.parmInternalCost());
            projStatement.parmInvestment(_listProjPayroll.parmInvestment());
        }
        projStatement.parmLedgerTransDateFrom(_listProjPayroll.parmLedgerFromDate());
        projStatement.parmLedgerTransDateTo(_listProjPayroll.parmLedgerToDate());

        projStatement.parmProjTransDateFrom(_listProjPayroll.parmProjFromDate());
        projStatement.parmProjTransDateTo(_listProjPayroll.parmProjToDate());

        projStatement.parmAmountQty(_amountQty);

        projStatement.parmListId(_listProjPayroll.listStateId());

        if (_actualBudget == ProjActualBudget::Actual)
        {
            projStatement.parmActual(true);
        }

        if (_actualBudget == ProjActualBudget::Budget)
        {
            projStatement.parmBudget(true);
            projStatement.parmforecastModelId(_forecastModelId);
        }

        return projStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjListProfitLoss</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an instance of the <c>projStatementProfitLoss</c> class and initializes it with appropriate values from the input parameters passed in.
    /// </summary>
    /// <param name="_listProjProfitLoss">
    ///    An instance of the <c>ProjListProjTrans_ProfitLoss</c> class.
    /// </param>
    /// <param name="_stateProjType">
    ///    The type of project statement report; optional.
    /// </param>
    /// <param name="_actualBudget">
    ///    A <c>ProjActualBudget</c> enumeration that determines whether actuals or budget should be reported; optional.
    /// </param>
    /// <param name="_amountQty">
    ///    A <c>ProjAmountQty</c> enumeration that determines whether hours should be reported as an amount or quantity; optional.
    /// </param>
    /// <param name="_forecastModelId">
    ///    The unique identifier of the forcast model used; optional.
    /// </param>
    /// <returns>
    ///    An instance of the <c>projStatementProfitLoss</c> class.
    /// </returns>
    static projStatement newProjListProfitLoss(
    ProjListProjTrans_ProfitLoss    _listProjProfitLoss,
    ProjListStateProjType           _stateProjType      = ProjListStateProjType::Project,
    ProjActualBudget                _actualBudget       = ProjActualBudget::Actual,
    ProjAmountQty                   _amountQty          = ProjAmountQty::AmountQty,
    ForecastModelId                 _forecastModelId    = '')
    {
        TransDate     pFromDate, pToDate, ledFromDate, ledToDate;
        projStatement projStatement = new projStatementProfitLoss();

        projStatement.parmHour(_listProjProfitLoss.parmHour());
        projStatement.parmRevenue(_listProjProfitLoss.parmRevenue());
        projStatement.parmExpenses(_listProjProfitLoss.parmExpenses());
        projStatement.parmOnAccount(_listProjProfitLoss.parmOnAcc());
        projStatement.parmItem(_listProjProfitLoss.parmItem());

        if (!ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            projStatement.parmTimeMaterial(_listProjProfitLoss.parmTimeMaterial());
            projStatement.parmFixedPrice(_listProjProfitLoss.parmFixedPrice());
            projStatement.parmInternal(_listProjProfitLoss.parmInternalCost());
            projStatement.parmCost(_listProjProfitLoss.parmInternalCost());
            projStatement.parmInvestment(_listProjProfitLoss.parmInvestment());
            projStatement.parmTime(_listProjProfitLoss.parmTime());
        }

        [pFromDate, pToDate, ledFromDate, ledToDate] = _listProjProfitLoss.setLedgerProjDate(_actualBudget);
        projStatement.parmLedgerTransDateFrom(ledFromDate);
        projStatement.parmLedgerTransDateTo(ledToDate);
        projStatement.parmProjTransDateFrom(pFromDate);
        projStatement.parmProjTransDateTo(pToDate);
        projStatement.parmAmountQty(_amountQty);

        projStatement.parmListId(_listProjProfitLoss.listStateId());

        projStatement.parmStateProjType(_stateProjType);

        if (_actualBudget == ProjActualBudget::Actual)
        {
            projStatement.parmActual(true);
        }

        if (_actualBudget == ProjActualBudget::Budget)
        {
            projStatement.parmBudget(true);
            projStatement.parmforecastModelId(_forecastModelId);
        }

        return projStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjListProfitLossActivity</Name>
				<Source><![CDATA[
    static projStatement newProjListProfitLossActivity(
    ProjListProjTrans_ProfitLossActivity    _listProjProfitLoss,
    ProjListStateProjType           _stateProjType      = ProjListStateProjType::Project,
    ProjActualBudget                _actualBudget       = ProjActualBudget::Actual,
    ProjAmountQty                   _amountQty          = ProjAmountQty::AmountQty,
    ForecastModelId                 _forecastModelId    = '')
    {
        TransDate     pFromDate, pToDate, ledFromDate, ledToDate;
        projStatement projStatement = new projStatementProfitLossActivity();

        projStatement.parmHour(_listProjProfitLoss.parmHour());
        projStatement.parmExpenses(_listProjProfitLoss.parmExpenses());
        projStatement.parmItem(_listProjProfitLoss.parmItem());

        [pFromDate, pToDate, ledFromDate, ledToDate] = _listProjProfitLoss.setLedgerProjDate(_actualBudget);
        projStatement.parmLedgerTransDateFrom(ledFromDate);
        projStatement.parmLedgerTransDateTo(ledToDate);
        projStatement.parmProjTransDateFrom(pFromDate);
        projStatement.parmProjTransDateTo(pToDate);
        projStatement.parmAmountQty(_amountQty);

        projStatement.parmListId(_listProjProfitLoss.listStateId());

        projStatement.parmStateProjType(_stateProjType);

        if (_actualBudget == ProjActualBudget::Actual)
        {
            projStatement.parmActual(true);
        }

        if (_actualBudget == ProjActualBudget::Budget)
        {
            projStatement.parmBudget(true);
            projStatement.parmforecastModelId(_forecastModelId);
        }

        return projStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjListWIP</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an instance of the <c>projStatementWIP</c> class and initializes it with appropriate values from the input parameters passed in.
    /// </summary>
    /// <param name="_listProjWIP">
    ///    An instance of the <c>ProjListProjTrans_WIP</c> class.
    /// </param>
    /// <param name="_actualBudget">
    ///    A <c>ProjActualBudget</c> enumeration that determines whether actuals or budget should be reported; optional.
    /// </param>
    /// <param name="_amountQty">
    ///    A <c>ProjAmountQty</c> enumeration that determines whether hours should be reported as an amount or quantity; optional.
    /// </param>
    /// <param name="_forecastModelId">
    ///    The unique identifier of the forcast model used; optional.
    /// </param>
    /// <returns>
    ///    An instance of the <c>projStatementPayroll</c> class.
    /// </returns>
    static projStatement newProjListWIP(
    ProjListProjTrans_WIP       _listProjWIP,
    ProjActualBudget            _actualBudget   = ProjActualBudget::Actual,
    ProjAmountQty               _amountQty      = ProjAmountQty::AmountQty,
    ForecastModelId             _forecastModelId    = '')
    {
        projStatement projStatement = new projStatementWIP();

        projStatement.parmHour(_listProjWIP.parmHour());
        projStatement.parmExpenses(_listProjWIP.parmExpenses());
        projStatement.parmItem(_listProjWIP.parmItem());
        projStatement.parmRevenue(_listProjWIP.parmRevenue());
        projStatement.parmOnAccount(_listProjWIP.parmOnAcc());

        if (!ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            projStatement.parmTimeMaterial(_listProjWIP.parmTimeMaterial());
            projStatement.parmFixedPrice(_listProjWIP.parmFixedPrice());
            projStatement.parmInternal(_listProjWIP.parmInternalCost());
            projStatement.parmCost(_listProjWIP.parmInternalCost());
            projStatement.parmInvestment(_listProjWIP.parmInvestment());
        }
        projStatement.parmLedgerTransDateFrom(_listProjWIP.parmLedgerFromDate());
        projStatement.parmLedgerTransDateTo(_listProjWIP.parmLedgerToDate());

        projStatement.parmProjTransDateFrom(_listProjWIP.parmProjFromDate());
        projStatement.parmProjTransDateTo(_listProjWIP.parmProjToDate());

        projStatement.parmAmountQty(_amountQty);

        projStatement.parmListId(_listProjWIP.listStateId());

        if (_actualBudget == ProjActualBudget::Actual)
        {
            projStatement.parmActual(true);
        }

        if (_actualBudget == ProjActualBudget::Budget)
        {
            projStatement.parmBudget(true);
            projStatement.parmforecastModelId(_forecastModelId);
        }
        return projStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjListWIPActivity</Name>
				<Source><![CDATA[
    static projStatement newProjListWIPActivity(
    ProjListProjTrans_WIPActivity       _listProjWIP,
    ProjActualBudget            _actualBudget   = ProjActualBudget::Actual,
    ProjAmountQty               _amountQty      = ProjAmountQty::AmountQty,
    ForecastModelId             _forecastModelId    = '')
    {
        projStatement projStatement = new projStatementWIP();

        projStatement.parmHour(_listProjWIP.parmHour());
        projStatement.parmExpenses(_listProjWIP.parmExpenses());
        projStatement.parmItem(_listProjWIP.parmItem());

        projStatement.parmLedgerTransDateFrom(_listProjWIP.parmLedgerFromDate());
        projStatement.parmLedgerTransDateTo(_listProjWIP.parmLedgerToDate());

        projStatement.parmProjTransDateFrom(_listProjWIP.parmProjFromDate());
        projStatement.parmProjTransDateTo(_listProjWIP.parmProjToDate());

        projStatement.parmAmountQty(_amountQty);

        projStatement.parmListId(_listProjWIP.listStateId());

        if (_actualBudget == ProjActualBudget::Actual)
        {
            projStatement.parmActual(true);
        }

        if (_actualBudget == ProjActualBudget::Budget)
        {
            projStatement.parmBudget(true);
            projStatement.parmforecastModelId(_forecastModelId);
        }
        return projStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjOnAccTrans</Name>
				<Source><![CDATA[
    static projStatement newProjOnAccTrans(
    ProjOnAccTrans   _projOnAccTrans,
    TransDate       _ledgerDateFrom = dateNull(),
    TransDate       _ledgerDateTo   = dateMax())
    {
        ProjType      projType  = _projOnAccTrans.projTable().Type;
        projStatement projStatement = new projStatementStatistic();

        projStatement.parmHour(false);
        projStatement.parmRevenue(false);
        projStatement.parmExpenses(false);
        projStatement.parmOnAccount(true);
        projStatement.parmItem(false);

        if (!ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            projStatement.parmTimeMaterial(projType == ProjType::TimeMaterial ? true : false);
            projStatement.parmFixedPrice(projType   == ProjType::FixedPrice ? true : false);
            projStatement.parmInternal(projType     == ProjType::Internal ? true : false);
            projStatement.parmCost(projType         == ProjType::Cost ? true : false);
            projStatement.parmInvestment(projType   == ProjType::Investment ? true : false);
            projStatement.parmTime(projType         == ProjType::Time ? true : false);
        }
        projStatement.parmProjType(projType);

        projStatement.parmLedgerTransDateFrom(_ledgerDateFrom);
        projStatement.parmLedgerTransDateTo(_ledgerDateTo);

        projStatement.parmProjTransDateFrom(_projOnAccTrans.TransDate);
        projStatement.parmProjTransDateTo(_projOnAccTrans.TransDate);

        projStatement.parmTransId(_projOnAccTrans.TransId);
        projStatement.parmListId(ProjListStateId::TransId);

        projStatement.parmActual(true);

        return projStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjRevenueTrans</Name>
				<Source><![CDATA[
    static projStatement newProjRevenueTrans(
    ProjRevenueTrans   _projRevenueTrans,
    TransDate       _ledgerDateFrom = dateNull(),
    TransDate       _ledgerDateTo   = dateMax())
    {
        ProjType      projType  = _projRevenueTrans.projTable().Type;
        projStatement projStatement = new projStatementStatistic();

        projStatement.parmHour(false);
        projStatement.parmRevenue(true);
        projStatement.parmExpenses(false);
        projStatement.parmOnAccount(false);
        projStatement.parmItem(false);

        if (!ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            projStatement.parmTimeMaterial(projType == ProjType::TimeMaterial ? true : false);
            projStatement.parmFixedPrice(projType   == ProjType::FixedPrice ? true : false);
            projStatement.parmInternal(projType     == ProjType::Internal ? true : false);
            projStatement.parmCost(projType         == ProjType::Cost ? true : false);
            projStatement.parmInvestment(projType   == ProjType::Investment ? true : false);
            projStatement.parmTime(projType         == ProjType::Time ? true : false);
        }
        projStatement.parmProjType(projType);

        projStatement.parmLedgerTransDateFrom(_ledgerDateFrom);
        projStatement.parmLedgerTransDateTo(_ledgerDateTo);

        projStatement.parmProjTransDateFrom(_projRevenueTrans.TransDate);
        projStatement.parmProjTransDateTo(_projRevenueTrans.TransDate);

        projStatement.parmTransId(_projRevenueTrans.TransId);
        projStatement.parmListId(ProjListStateId::TransId);

        projStatement.parmActual(true);

        return projStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjStatistic</Name>
				<Source><![CDATA[
    static projStatement newProjStatistic(
    ProjStatistic       _statistic,
    ProjActualBudget    _actualBudget   = ProjActualBudget::Actual)
    {
        projStatement projStatement = new projStatementStatistic();

        projStatement.parmHour(_statistic.parmHour());
        projStatement.parmRevenue(_statistic.parmRevenue());
        projStatement.parmExpenses(_statistic.parmExpenses());
        projStatement.parmOnAccount(_statistic.parmOnAcc());
        projStatement.parmItem(_statistic.parmItem());

        if (!ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            projStatement.parmTimeMaterial(_statistic.parmTimeMaterial());
            projStatement.parmFixedPrice(_statistic.parmFixedPrice());
            projStatement.parmInternal(_statistic.parmInternalCost());
            projStatement.parmCost(_statistic.parmInternalCost());
            projStatement.parmInvestment(_statistic.parmInvestment());
            projStatement.parmTime(_statistic.parmTime());
        }
        projStatement.parmLedgerTransDateFrom(_statistic.parmLedgerFromDate());
        projStatement.parmLedgerTransDateTo(_statistic.parmLedgerToDate());

        projStatement.parmProjTransDateFrom(_statistic.parmProjFromDate());
        projStatement.parmProjTransDateTo(_statistic.parmProjToDate());

        if (_actualBudget == ProjActualBudget::Actual)
        {
            projStatement.parmActual(true);
        }
        if (_actualBudget == ProjActualBudget::Budget)
        {
            projStatement.parmBudget(true);
        }

        // Deviation or Sum
        if (_statistic.parmActualBudget() == ProjActualBudget::Deviation)
        {
            projStatement.parmDeviation(true);
        }
        else if (_statistic.parmActualBudget() == ProjActualBudget::Sum_)
        {
            projStatement.parmSum(true);
        }

        return projStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjTable</Name>
				<Source><![CDATA[
    static projStatement newProjTable(ProjTable _projTable, TransDate _ledgerDateFrom = dateNull(),
                                        TransDate _ledgerDateTo = dateMax())
    {
        ProjType      projType      = _projTable.Type;
        projStatement projStatement = new projStatementStatistic();

        projStatement.parmHour(true);
        projStatement.parmRevenue(true);
        projStatement.parmExpenses(true);
        projStatement.parmOnAccount(true);
        projStatement.parmItem(true);

        if (!ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            projStatement.parmTimeMaterial(projType == ProjType::TimeMaterial ? true : false);
            projStatement.parmFixedPrice(projType   == ProjType::FixedPrice ? true : false);
            projStatement.parmInternal(projType     == ProjType::Internal ? true : false);
            projStatement.parmCost(projType         == ProjType::Cost ? true : false);
            projStatement.parmInvestment(projType   == ProjType::Investment ? true : false);
            projStatement.parmTime(projType         == ProjType::Time ? true : false);
        }
        projStatement.parmProjType(projType);
        projStatement.parmLedgerTransDateFrom(_ledgerDateFrom);
        projStatement.parmLedgerTransDateTo(_ledgerDateTo);
        projStatement.parmProjTransDateFrom(dateNull());
        projStatement.parmProjTransDateTo(dateMax());
        projStatement.parmListId(ProjListStateId::Project);
        projStatement.parmActual(true);
        projStatement.parmProjId(_projTable.ProjId);

        return projStatement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>statementType2StateType</Name>
				<Source><![CDATA[
    static ProjListStateType statementType2StateType(
    ProjStatementType   _statementType)
    {
        switch (_statementType)
        {
            case ProjStatementType::ProfitLoss:
                return ProjListStateType::ProfitLoss;

            case ProjStatementType::WIP:
                return ProjListStateType::WIP;

            case ProjStatementType::Payroll:
                return ProjListStateType::Payroll;

            case ProjStatementType::Consumption:
                return ProjListStateType::Consumption;

            case ProjStatementType::Invoice:
                return ProjListStateType::Invoice;
        }
        return ProjListStateType::None;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>