<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVoucher</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;

class CustVoucher extends CustVendVoucher
{
    private static CommerceHQEventSource commerceEventSource = CommerceHQEventSource::Log;

    CustTransRefType transRefType;
    Num transRefId;

    container rboParameters;
    LedgerDimensionAccount summaryledgerDimensionAccount;

    CustDirectDebitMandateRecId directDebitMandateRecId;
    RefRecId cashRegisterTerminalRecId_W;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkTaxInLedgerJournalTrans_RU</Name>
				<Source><![CDATA[
    private boolean checkTaxInLedgerJournalTrans_RU(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean ret = true;
        TmpTaxWorkTrans tmpTaxWorkTrans;
        LedgerJournalTrans localLedgerJournalTrans;
        TaxCalculation taxCalculation;
        CalcUnpostedTaxes_RU calcUnpostedTaxes;

        if (CustParameters::taxation_RU(_ledgerJournalTrans.TransDate) == CustTaxation_RU::OnPayment ||
            _ledgerJournalTrans.vatOnPayment_RU)
        {
            while select localLedgerJournalTrans
                where localLedgerJournalTrans.JournalNum == _ledgerJournalTrans.JournalNum &&
                      localLedgerJournalTrans.Voucher == _ledgerJournalTrans.Voucher &&
                    ((localLedgerJournalTrans.TaxGroup &&
                      localLedgerJournalTrans.TaxItemGroup) ||
                      localLedgerJournalTrans.TaxCode)
            {
                taxCalculation = LedgerJournalTrans::getTaxInstance(localLedgerJournalTrans.JournalNum, localLedgerJournalTrans.Voucher, localLedgerJournalTrans.Invoice, false);
                tmpTaxWorkTrans = taxCalculation.tmpTaxWorkTrans();
                select firstonly tmpTaxWorkTrans;

                calcUnpostedTaxes = new CalcUnpostedTaxes_RU(tmpTaxWorkTrans);
                calcUnpostedTaxes.calc();

                if (calcUnpostedTaxes.taxBaseAmountCur_VAT() ||
                    calcUnpostedTaxes.taxBaseAmountCur_VATReduced() ||
                    calcUnpostedTaxes.taxBaseAmountCur_VATZero())
                {
                    ret = checkFailed("@GLS106747");
                    break;
                }
            }
        }

        if (TaxParameters::find().TaxSpecPosting_RU)
        {
            ret = checkFailed("@GLS103066");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyCashDisc</Name>
				<Source><![CDATA[
    protected void copyCashDisc(TableId _fromTableId,
                                RecId _fromRecId,
                                TableId _toTableId,
                                RecId _toRecId)
    {
        CustTransCashDisc::copyCashDisc(_fromTableId, _fromRecId, _toTableId, _toRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInvoiceJournal</Name>
				<Source><![CDATA[
    protected void createInvoiceJournal(CustVendTrans _custTrans)
    {
        this.populateCustInvoiceJour(_custTrans);
        custInvoiceJour.insert();

        LedgerJournalTrans ledgerJournalTrans;
        if (common.TableId == tableNum(LedgerJournalTrans))
        {
            ledgerJournalTrans = common;
        }
        if (ledgerJournalTrans)
        {
            this.insertCreditInvoicingJour(ledgerJournalTrans, custInvoiceJour);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateCustInvoiceJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populate <c>CustInvoiceJour</c>.
    /// </summary>
    /// <param name = "_custTrans">
    /// The customer transaction used to initialize <c>CustInvoiceJour</c>.
    /// </param>
    protected void populateCustInvoiceJour(CustVendTrans _custTrans)
    {
        LedgerJournalTrans ledgerJournalTrans;
        // <GEERU>
        CustInvoiceJour_RU custInvoiceJour_RU;
        #ISOCountryRegionCodes
        // </GEERU>

        custInvoiceJour.initValue();
        custInvoiceJour.initFromCustTrans(_custTrans);

        custInvoiceJour.FixedDueDate = dueDate;
        custInvoiceJour.DueDate = dueDate;
        custInvoiceJour.CashDiscDate = cashDiscDate;
        custInvoiceJour.CashDisc = cashDiscAmount;
        custInvoiceJour.CashDiscCode = cashDiscCode;
        custInvoiceJour.ExchRate = exchRate;
        custInvoiceJour.ExchRateSecondary = exchRateSecondary;
        custInvoiceJour.ReportingCurrencyExchangeRate = reportingCurrencyExchRate;
        custInvoiceJour.ReportingCurrencyExchangeRateSecondary = reportingCurrencyExchRateSecondary;
        custInvoiceJour.Triangulation = triangulation;
        custInvoiceJour.DefaultDimension = defaultDimension;
        custInvoiceJour.Payment = paymTermId;
        custInvoiceJour.PostingProfile = postingProfile;

        if (common.TableId == tableNum(LedgerJournalTrans))
        {
            ledgerJournalTrans = common;
            custInvoiceJour.vatNum = ledgerJournalTrans.vatNumJournal;
            LedgerJournalTransTaxExtension taxExtension = ledgerJournalTrans.ledgerJournalTransTaxExtension();
            custInvoiceJour.PartyTaxID = taxExtension.VATNumRecId;
            if (TaxIntegrationUtils::isTaxIntegrationEnabledForJournalType(ledgerJournalTrans.ledgerJournalTable().JournalType))
            {
                custInvoiceJour.TaxID = TaxTransactionTaxID::getTaxIDByVoucher(ledgerJournalTrans.Voucher, ledgerJournalTrans.TransDate, ledgerJournalTrans.JournalNum);
            }

            custInvoiceJour.EnterpriseNumber= ledgerJournalTrans.EnterpriseNumber;
            custInvoiceJour.Listcode = ledgerJournalTrans.Listcode;
            custInvoiceJour.SumTax = -Tax::taxTotal(ledgerJournalTrans.Voucher, ledgerJournalTrans.TransDate);
            custInvoiceJour.TaxGroup = ledgerJournalTrans.TaxGroup;

            if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
            {
                TaxEngineLedgerJournalTransHeader taxEngineLedgerJournalTransHeader = TaxEngineLedgerJournalTransHeader::findByJourNumVoucher(ledgerJournalTrans.JournalNum, ledgerJournalTrans.Voucher);
                ITaxDocument taxDocumentObject = TaxBusinessService::getTaxDocumentBySource(taxEngineLedgerJournalTransHeader.TableId, taxEngineLedgerJournalTransHeader.RecId);
                if (taxDocumentObject)
                {
                    custInvoiceJour.ReverseChargeAmount = TaxDocumentUtils::calculateTaxTotalReverseCharge(taxDocumentObject);
                }
            }
            else if (ReverseChargeParameters_W::find().Enabled)
            {
                custInvoiceJour.ReverseChargeAmount = Tax::reverseChargeTotal_W(ledgerJournalTrans.Voucher, ledgerJournalTrans.TransDate);
            }

            // <GEERU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                custInvoiceJour_RU = custInvoiceJour.custInvoiceJour_RU();
                custInvoiceJour_RU.vatOnPayment_RU = ledgerJournalTrans.vatOnPayment_RU;
                custInvoiceJour_RU.Correct_RU = ledgerJournalTrans.Correct_RU;
                custInvoiceJour_RU.CorrectedInvoiceId_RU = ledgerJournalTrans.CorrectedInvoiceId_RU;
                custInvoiceJour_RU.CorrectedInvoiceDate_RU = ledgerJournalTrans.CorrectedInvoiceDate_RU;
                custInvoiceJour.packCustInvoiceJour_RU(custInvoiceJour_RU);

                if (custInvoiceJour.SumTax && !this.checkTaxInLedgerJournalTrans_RU(ledgerJournalTrans))
                {
                    throw error("@SYS18447");
                }
            }
            // </GEERU>

            custInvoiceJour.setInvoiceAddress();

            custInvoiceJour.DeliveryName = custInvoiceJour.InvoicingName;
            custInvoiceJour.DeliveryPostalAddress = custInvoiceJour.InvoicePostalAddress;
        }

        custInvoiceJour.SalesBalance = custInvoiceJour.InvoiceAmount - custInvoiceJour.SumTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInvoiceTrans</Name>
				<Source><![CDATA[
    protected void createInvoiceTrans(CustVendInvoiceJour _custVendInvoiceJour)
    {
        CustInvoiceTrans custInvoiceTrans;
        LedgerJournalTrans ledgerJournalTrans;
        CustInvoiceJour custInvoiceJourLocal = _custVendInvoiceJour;

        // <GEERU><GIN>
        #ISOCountryRegionCodes
        // </GEERU></GIN>
        // <GIN>
        TaxWithholdTrans_IN taxWithholdTransLoc;
        // </GIN>
        ;

        custInvoiceTrans.clear();
        custInvoiceTrans.initFromCustInvoiceJour(custInvoiceJourLocal);

        if (common.TableId == tableNum(LedgerJournalTrans))
        {
            ledgerJournalTrans = common;
            // <GEERU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                CustInvoiceSalesLink::newFromInvoiceJour_RU(custInvoiceJourLocal);

                custInvoiceTrans.LineNum = 1;
                custInvoiceTrans.PriceUnit = 1;
                custInvoiceTrans.Qty = 1;
                custInvoiceTrans.SalesPrice = custInvoiceJourLocal.InvoiceAmount;
                custInvoiceTrans.LineAmount = custInvoiceJourLocal.InvoiceAmount;
                custInvoiceTrans.DefaultDimension = custInvoiceJourLocal.DefaultDimension;
                custInvoiceTrans.QtyPhysical = 1;
                custInvoiceTrans.PartDelivery = NoYes::No;
                custInvoiceTrans.SalesMarkup = 0;
                custInvoiceTrans.TaxAutogenerated = NoYes::Yes;

                custInvoiceTrans.initFromLedgerJournalTrans_RU(ledgerJournalTrans);
            }
            else
            {
                // </GEERU>
                custInvoiceTrans.initFromLedgerJournalTrans(ledgerJournalTrans);
                custInvoiceTrans.SalesPrice = custInvoiceJourLocal.SalesBalance;
                custInvoiceTrans.LineAmount = custInvoiceJourLocal.SalesBalance;
                custInvoiceTrans.TaxAmount = custInvoiceJourLocal.SumTax;

                custInvoiceTrans.LineAmountMST = custInvoiceJour.amountMST(custInvoiceTrans.LineAmount);
                custInvoiceTrans.TaxAmountMST = custInvoiceJour.amountMST(custInvoiceTrans.TaxAmount);
                // <GEERU>
            }
            // </GEERU>
        }

        // <GEERU>
        if (!custInvoiceTrans.LedgerDimension && fixedInvoiceTransLedgerDimension)
        {
            custInvoiceTrans.LedgerDimension = fixedInvoiceTransLedgerDimension;
            custInvoiceTrans.LineAmount = custInvoiceJourLocal.SalesBalance;
            custInvoiceTrans.LineAmountMST = custInvoiceJour.amountMST(custInvoiceTrans.LineAmount);
        }
        // </GEERU>

        custInvoiceTrans.InventDimId = InventDim::inventDimIdBlank();
        custInvoiceTrans.insert();

        // <GEERU>
        AmountAdjustEngineCustInvoice_W::adjustInvoiceJour(custInvoiceJour);
        // </GEERU>
        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])
            && TaxWithholdParameters_IN::find())
        {
            taxWithholdTransLoc = TaxWithholdTrans_IN::find(this.parmTaxWithholdTransRecId_IN(), true);
            if (taxWithholdTransLoc.RecId)
            {
                taxWithholdTransLoc.CustInvoiceTrans = custInvoiceTrans.RecId;
                taxWithholdTransLoc.update();
            }
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPaymScheduleSpecifications</Name>
				<Source><![CDATA[
    void createPaymScheduleSpecifications(CustVendTrans _custVendTrans)
    {
        SpecTransManager specTransManager;
        CustTransOpen custTransOpen;

        while select AmountCur from custTransOpen
            where custTransOpen.RefRecId == _custVendTrans.RecId
        {
            specTransManager = SpecTransManager::newFromSpec(common, false);

            specTransManager.insert(custTransOpen.DataAreaId,
                custTransOpen.TableId,
                custTransOpen.RecId,
                custTransOpen.AmountCur,
                _custVendTrans.CurrencyCode,
                _custVendTrans.Invoice ? NoYes::No : NoYes::Yes);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransOpen</Name>
				<Source><![CDATA[
    protected CustVendTransOpen createTransOpen(CustVendTrans _custVendTrans)
    {
        CustTransOpen custTransOpen;
        CustTrans custTransLocal;

        // <GIN>
        CustInvoiceJour custInvoiceJourloc;
        // </GIN>

        custTransOpen.AmountCur = _custVendTrans.AmountCur;
        custTransOpen.AmountMST = _custVendTrans.AmountMST;
        custTransOpen.ReportingCurrencyAmount = _custVendTrans.ReportingCurrencyAmount;
        custTransOpen.CashDiscDate = cashDiscDate;
        custTransOpen.PossibleCashDisc = cashDiscAmount;
        custTransOpen.DueDate = dueDate;
        custTransOpen.BankDiscNoticeDeadline = bankDiscNoticeDeadline;
        custTransOpen.TransDate = _custVendTrans.TransDate;
        custTransOpen.RefRecId = _custVendTrans.RecId;
        custTransOpen.AccountNum = _custVendTrans.AccountNum;
        custTransOpen.CollectionLetter = NoYes::Yes;

        // <GIN>
        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            custInvoiceJourloc = CustInvoiceJour::findFromCustTrans(_custVendTrans.Invoice, _custVendTrans.TransDate, _custVendTrans.AccountNum);

            if (isTDSApplicable && (taxWithholdAmount || taxWithholdBank || taxWithhold || totalWHTBankAmount || custVendWHTAmount))
            {
                custTransOpen.tdsAmount_IN = taxWithholdAmount + taxWithholdBank + taxWithhold + totalWHTBankAmount + custVendWHTAmount;
                //tdsAmount should be negative for customer transaction.
                if (custTransOpen.tdsAmount_IN > 0 && taxWithholdAmount && custInvoiceJourloc.InvoiceAmount > 0)
                {
                    custTransOpen.tdsAmount_IN = custTransOpen.tdsAmount_IN * -1;
                }
                custTransOpen.TaxWithholdAmountOrigin_IN = taxWithholdAmountOrigin;
            }
            if (isTCSApplicable && (taxWithholdAmount || taxWithholdBank || taxWithhold || totalWHTBankAmount || custVendWHTAmount))
            {
                custTransOpen.tcsAmount_IN = taxWithholdAmount + taxWithholdBank + taxWithhold + totalWHTBankAmount + custVendWHTAmount;
                //tcsAmount should be positive for customer transaction.
                if (custTransOpen.tcsAmount_IN < 0 && taxWithholdAmount && custInvoiceJourloc.InvoiceAmount > 0)
                {
                    custTransOpen.tcsAmount_IN = custTransOpen.tcsAmount_IN * -1;
                }
                custTransOpen.TaxWithholdAmountOrigin_IN = taxWithholdAmountOrigin;
            }
        }
        // </GIN>

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            custTransOpen.InterestCode_BR = interestCode;
            custTransOpen.FineCode_BR = fineCode;
        }
        // </GBR>

        if (BankLCExportFeatureChecker::checkBankLCExportEnabled())
        {
            if (_custVendTrans.TableId == tableNum(CustTrans))
            {
                custTransLocal = _custVendTrans;
                custTransOpen.BankLCExportLine = custTransLocal.BankLCExportLine;
            }
        }
        return custTransOpen;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRboParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get rboParameters by SalesId, or InvoiceId, or LedgerJournalId.
    /// </summary>
    /// <param name="_salesId">
    /// Sales order Id of transaction.
    /// </param>
    /// <param name="_invoiceId">
    /// Invoice Id of transaction.
    /// </param>
    /// <param name="_journalNum">
    /// Journal number of ledger journal trans.
    /// </param>
    /// <returns>
    /// A container contains RetailTransactionId, RetailStoreId, RetailTerminalId and RetailCustTrans.
    /// </returns>
    public container getRboParameters(SalesId _salesId, InvoiceId _invoiceId, LedgerJournalId _journalNum)
    {
        container containerResult;

        // Update rboParameters from RetailTransactionServiceInvoiceContext if it is provided.
        if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
        {
           containerResult = this.getRboParametersFromContextObject(_salesId);
        }

        if (conLen(containerResult) == 0 && _salesId != '')
        {
            containerResult = this.getRboParametersBySalesId(_salesId);

            if (conLen(containerResult) == 0)
            {
                containerResult = this.getRboParametersFromPreviousCustTrans(_salesId);
            }
        }

        if (conLen(containerResult) == 0 && _invoiceId != '')
        {
            containerResult = this.getRboParametersByInvoiceID(_invoiceId);
        }

        if (conLen(containerResult) == 0 && _journalNum != '')
        {
            containerResult = this.getRboParametersByJournalNum(_journalNum);
        }

        // Fallback to default rboParameters
        if (conLen(containerResult) == 0)
        {
            containerResult = rboParameters;
        }

        return containerResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRboParametersByInvoiceID</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get rboParameters by InvoiceId from <c>RetailTransactionTable</c> table.
    /// </summary>
    /// <param name="_invoiceId">
    /// InvoiceId from sales trans.
    /// </param>
    /// <returns>
    /// A container of RboParameters.
    /// </returns>
    /// <remarks>
    /// This method tried to get rboParameters by invoice id for cust trans from POS.
    /// </remarks>
    private container getRboParametersByInvoiceID(InvoiceId _invoiceId)
    {
        boolean                 ret, isCustTrans;
        RetailTransactionId     transactionId;
        RetailStoreId           storeId;
        RetailTerminalId        terminalId;

        [ret, isCustTrans, transactionId, storeId, terminalId] = this.getRetailTransactionDetailsBasedOnSalesOrInvoiceId('', _invoiceId);
        container containerResult = conNull();

        if (ret) // A valid transaction has been found
        {
            this.rboParameters(isCustTrans, transactionId, storeId, terminalId);
            containerResult = rboParameters;
        }

        return containerResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRboParametersByJournalNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get rboParameters by JournalNum through LedgerJournalTable and RetailTransactionTable.
    /// </summary>
    /// <param name="_journalNum">
    /// The journal number.
    /// </param>
    /// <returns>
    /// A container of RboParameters.
    /// </returns>
    /// <remarks>
    /// This method tried to get rboParameters by journal number for cust trans from POS.
    /// </remarks>
    private container getRboParametersByJournalNum(LedgerJournalId _journalNum)
    {
        RetailTransactionTable retailTransactionTable;
        CustTrans preCustTrans;
        LedgerJournalTable ledgerJournalTable;
        RetailChannelTable retailChannelTable;
        
        RetailEodPostLedgerJournalContext context = RetailEodPostLedgerJournalContext::current();

        if (context && context.parmJournalId() == _journalNum)
        {
            select firstonly RecId, CustAccount, TransactionID, Store, Terminal
                from retailTransactionTable
                    where retailTransactionTable.transactionId == context.parmTransactionId()
                        && retailTransactionTable.store == context.parmStore()
                        && retailTransactionTable.terminal == context.parmTerminal()
                        && retailTransactionTable.Channel == context.parmChannel()
                join RecId, DefaultCustAccount from retailChannelTable
                    where retailChannelTable.RecId == context.parmChannel();
        }
        else
        {
            // Get the transaction from RetailTransactionTable by joining the ledger journal table by statement identifier.
            select firstOnly RecId, CustAccount, TransactionID, Store, Terminal from retailTransactionTable
                    where retailTransactionTable.custAccount == accountNum
                       && retailTransactionTable.type == RetailTransactionType::Payment
                join RecId, DefaultCustAccount from retailChannelTable
                    where retailChannelTable.RecId == retailTransactionTable.Channel
                exists join ledgerJournalTable
                    where ledgerJournalTable.RetailStatementId == retailTransactionTable.statementId
                       && LedgerJournalTable.JournalNum == _journalNum
                notexists join preCustTrans
                    where preCustTrans.RetailTransactionId == retailTransactionTable.transactionId;
        }

        container containerResult = conNull();

        if (retailChannelTable.RecId)
        {
            NoYes isCustTrans;

            if (retailTransactionTable.CustAccount != '' &&
                retailTransactionTable.CustAccount != retailChannelTable.DefaultCustAccount)
            {
                isCustTrans = NoYes::Yes;
            }

            this.rboParameters(isCustTrans, retailTransactionTable.TransactionId, retailTransactionTable.Store, retailTransactionTable.Terminal);
            containerResult = rboParameters;
        }

        return containerResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRboParametersBySalesId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get rboParameters by SalesId from <c>RetailTransactionTable</c> table.
    /// </summary>
    /// <param name="_salesId">
    /// Sales order Id of transaction.
    /// </param>
    /// <returns>
    /// A container of RboParameters.
    /// </returns>
    /// <remarks>
    /// This method tried to get rboParameters by sales id for cust trans from POS.
    /// </remarks>
    private container getRboParametersBySalesId(SalesId _salesId)
    {
        boolean                 ret, isCustTrans;
        RetailTransactionId     transactionId;
        RetailStoreId           storeId;
        RetailTerminalId        terminalId;

        [ret, isCustTrans, transactionId, storeId, terminalId] = this.getRetailTransactionDetailsBasedOnSalesOrInvoiceId(_salesId, '');
        container containerResult = conNull();

        if (ret) // A valid transaction has been found
        {
            this.rboParameters(isCustTrans, transactionId, storeId, terminalId);
            containerResult = rboParameters;
        }

        return containerResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRetailTransactionDetailsBasedOnSalesOrInvoiceId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the details of the Retail transactions associated to the sales id or invoice id.
    /// One of these two parameters must be populated. If both are populated, only the sales id is going to be considered.
    /// </summary>
    /// <param name = "_salesId">Sales Id related to the Retail transaction.</param>
    /// <param name = "_invoiceId">Invoice Id related to the Retail transaction.</param>
    /// <returns>The details of the Retail transactions associated to the sales id or invoice id.
    /// The container structure must be like:
    /// 1. Boolean value that indicates that the transaction was found.
    /// 2. Boolean value that indicates if it is a Retail transaction not associated to default customer.
    /// 3. Transaction id.
    /// 4. Store id.
    /// 5. Terminal id.
    /// </returns>
    protected container getRetailTransactionDetailsBasedOnSalesOrInvoiceId(SalesId _salesId, InvoiceId _invoiceId)
    {
        RetailTransactionTable  retailTransactionTable;
        RetailChannelTable      retailChannelTable;
        boolean                 ret, isCustTrans;
        RetailTransactionId     transactionId;
        RetailStoreId           storeId;
        RetailTerminalId        terminalId;

        ret = false;

        if (isConfigurationkeyEnabled(configurationKeyNum(RetailEodBackwardCompatibility)))
        {
            if (_salesId)
            {
                // For sales transaction, find RetailTransactionTable record by matching SalesOrderId.
                select Recid, custAccount, transactionId, store, terminal from retailTransactionTable
                    where retailTransactionTable.salesOrderId == _salesId
                    join RecId, DefaultCustAccount from retailChannelTable
                        where retailChannelTable.RecId == retailTransactionTable.Channel;
            }
            else if (_invoiceId)
            {
                // For payment transaction, find RetailTransactionTable record by matching InvoiceId.
                select RecId, custAccount, transactionId, store, terminal from retailTransactionTable
                    where retailTransactionTable.InvoiceId == _invoiceId
                    join RecId, DefaultCustAccount from retailChannelTable
                        where retailChannelTable.RecId == retailTransactionTable.Channel;
            }

            if (retailChannelTable.RecId)
            {
                ret = true;

                if (retailTransactionTable.custAccount != '' && retailTransactionTable.custAccount != retailChannelTable.DefaultCustAccount)
                {
                    isCustTrans = true;
                }
                else
                {
                    isCustTrans = false;
                }

                transactionId   = retailTransactionTable.transactionId;
                storeId         = retailTransactionTable.store;
                terminalId      = retailTransactionTable.terminal;
            }
        }

        return [ret, isCustTrans, transactionId, storeId, terminalId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRboParametersFromPreviousCustTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get rboParameters by sales order id from CustTrans table.
    /// </summary>
    /// <param name="_salesId">
    /// Sales order Id of transaction.
    /// </param>
    /// <returns>
    /// A container of RboParameters.
    /// </returns>
    /// <remarks>
    /// This method tried to get rboParameters for customer order trans from privious trans.
    /// This method only used when doing pick up operation from POS, since in this case,
    /// more than one record will be inserted into CustTrans table for different transaction type.
    /// </remarks>
    private container getRboParametersFromPreviousCustTrans(SalesId _salesId)
    {
        CustTrans preCustTrans;
        container containerResult = conNull();

        select firstOnly RecId, RetailCustTrans, RetailTransactionId, RetailStoreId, RetailTerminalId from preCustTrans
            where   preCustTrans.MCRPaymOrderID == _salesId
                &&  preCustTrans.Invoice == ''
                &&  preCustTrans.RetailTransactionId != ''
                &&  preCustTrans.TransType == LedgerTransType::Sales;

        if (preCustTrans.RecId)
        {
            this.rboParameters(preCustTrans.RetailCustTrans, preCustTrans.RetailTransactionId, preCustTrans.RetailStoreId, preCustTrans.RetailTerminalId);
            containerResult = rboParameters;
        }

        return containerResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRboParametersFromContextObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get rboParameters by sales order id from RetailTransactionServiceInvoiceContext.
    /// </summary>
    /// <param name="_salesId">
    /// Sales order Id of transaction.
    /// </param>
    /// <returns>
    /// A container of RboParameters.
    /// </returns>
    /// /// <remarks>
    /// This method tried to get rboParameters for customer order trans from context.
    /// </remarks>
    private container getRboParametersFromContextObject(SalesId _salesId)
    {
        container containerResult = conNull();

        RetailTransactionServiceInvoiceContext context = RetailTransactionServiceInvoiceContext::current();        

        if (context != null)
        {
            SalesTable invoicedSalesTable = SalesTable::find(_salesId);
            if (invoicedSalesTable.RecId != 0 && context.parmSalesId() == _salesId)
            {
                RefRecId channelRecId = context.parmChannel();

                commerceEventSource.EventWriteCustVoucherGetRboParametersUsingRetailInvoiceContext(funcName(), invoicedSalesTable.RecId);

                boolean isCustTrans = context.parmCustAccount() != '' && context.parmCustAccount() != RetailChannelTable::findByRecId(channelRecId).DefaultCustAccount;

                this.rboParameters(isCustTrans, context.parmTransactionId(), context.parmStore(), context.parmTerminal());
                containerResult = rboParameters;
            }
            else
            {
                commerceEventSource.EventWriteCustVoucherGetRboParametersSalesIdMismatch(funcName(), invoicedSalesTable.RecId);
            }
        }

        return containerResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendTable</Name>
				<Source><![CDATA[
    public CustVendTable custVendTable()
    {
        return CustTable::find(accountNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendName</Name>
				<Source><![CDATA[
    protected Name getCustVendName()
    {
        return CustTable::find(accountNum).name();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymentLedgerTransactionTxt</Name>
				<Source><![CDATA[
    protected LedgerTransTxt getPaymentLedgerTransactionTxt()
    {
        return LedgerTransTxt::CustPaymentCust;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymentTransactionTxt</Name>
				<Source><![CDATA[
    protected LedgerTransTxt getPaymentTransactionTxt()
    {
        return LedgerTransTxt::CustPaymentCust;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCashRegisterFiscalTrans_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new Cash Register Transaction from Payment Transaction.
    /// </summary>
    /// <param name = "_custVendTransCash">Current transaction.</param>
    protected void initCashRegisterFiscalTrans_W(CustVendTrans _custVendTransCash)
    {
        CashRegisterTerminal_W terminal = CashRegisterTerminal_W::find(cashRegisterTerminalRecId_W);
        ClassId cashRegisterProcessingClassId = CashRegister_W::find(terminal.CashRegister).ProcessingClassId;
        if (CashRegisterProcessingBase::isEnabled(cashRegisterProcessingClassId)
            && CashRegisterPaymMode_W::existsPaymMode(_custVendTransCash.PaymMode))
        {
            CashRegisterProcessingBase cashRegisterProcessing = CashRegisterProcessingBase::construct(cashRegisterTerminalRecId_W);
            cashRegisterProcessing.newFromPaymentTrans(_custVendTransCash)
                .cashRegisterTerminal(terminal)
                .validate()
                .initFiscalTrans();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>CustVendTrans</c> map.
    /// </summary>
    /// <param name="custVendTrans">
    /// The map that contains the value of the vendor transaction or customer transaction.
    /// </param>
    /// <param name="_ledgerPostingJournal">
    /// The ledger posting journal to use for ledger posting.
    /// </param>
    /// <param name="_useSubLedger">
    /// A Boolean value that indicates whether the subledger is being used; optional.
    /// </param>
    protected void initCustVendTrans(
        CustVendTrans custVendTrans,
        LedgerVoucher _ledgerPostingJournal,
        boolean _useSubLedger = false)
    {
        CustInvoiceReferenceNumber_FI custInvRefNum;
        CustTrans custTrans = custVendTrans;
        CustParameters custParameters = CustParameters::find();
        MCRPaymOrderId paymOrderID;
        // <GBR>
        CustTransPayment_BR custTransPayment_BR;
        // </GBR>
        // <GEERU>
        #ISOCountryRegionCodes
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        // <GEERU>
        CustTrans_W custTrans_W;
        // </GEERU>

        LedgerJournalTrans      ledgerJournalTrans;
        InvoiceId               currentInvoiceId;
        boolean                 ok = false;

        // Save the payment order id so when custumer / vendor transactions clear, the record is not lost.
        paymOrderID = custTrans.MCRPaymOrderID;

        if (custVendInvoiceJour.TableId == tableNum(CustInvoiceJour))
        {
            CustInvoiceJour curCustInvoiceJour = custVendInvoiceJour;
            paymOrderID = paymOrderID ? paymOrderID : curCustInvoiceJour.SalesId;
            paymId = paymId ? paymId : curCustInvoiceJour.PaymId;
        }
        else if (custVendInvoiceJour.TableId == tableNum(ProjInvoiceJour))
        {
            ProjInvoiceJour curProjInvoiceJour = custVendInvoiceJour;
            paymId = paymId ? paymId : curProjInvoiceJour.PaymId;
        }

        super(custTrans, _ledgerPostingJournal, _useSubLedger);

        if (common && common.TableId == tableNum(LedgerJournalTrans))
        {
            custTrans.OrderAccount = custTrans.AccountNum;
            // <GEERU>
            if (countryRegion_RU && custTrans.Prepayment)
            {
                custTrans_W = custTrans.custTrans_W();
                custTrans_W.PrepaymentFactureId_W = FactureJourCreate_RU::newPrepaymentFactureLedgerJournalTrans(common, false).FactureId;
                custTrans.packCustTrans_W(custTrans_W);
            }
            // </GEERU>

            ledgerJournalTrans = common;
            currentInvoiceId = ledgerJournalTrans.Invoice ? ledgerJournalTrans.Invoice : ledgerJournalTrans.MarkedInvoice;
            paymOrderID = paymOrderID ? paymOrderID : ledgerJournalTrans.PaymReference;
        }
        else
        {
            custTrans.OrderAccount = orderAccount ? orderAccount : custTrans.AccountNum;
        }

        // If "Retail" is enabled, then update retail fields in CustTrans by rboParameters.
        if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
        {
            [custTrans.RetailCustTrans,custTrans.RetailTransactionId,custTrans.RetailStoreId,custTrans.RetailTerminalId] =
                this.getRboParameters(paymOrderID, currentInvoiceId, ledgerJournalTrans.JournalNum);
        }

        if (custTrans.Invoice
            && !custTrans.PaymReference
            && custParameters.CustInvoiceRefNum_FI)
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceFI00007, funcName());

            // Generate reference number for sales invoices, if changes, must also update CustVoucherProject.initCustVendTrans()
            custInvRefNum = CustInvoiceReferenceNumber_FI::construct(custParameters.InvoiceReferenceNumberFormula_FI, custTrans);
            custTrans.PaymReference = custInvRefNum.generateReferenceNumber();
            paymId = paymId ? paymId : custTrans.PaymReference;
        }

        if (paymId)
        {
            custTrans.PaymId = paymId;
        }
        custTrans.MCRPaymOrderID = paymOrderID;
        custTrans.CancelledPayment = cancelledPayment;

        // <GEERU>
        if (countryRegion_RU)
        {
            custTrans_W = custTrans.custTrans_W();
            custTrans_W.InvoicePostingType_RU = salesInvoicePostingType;
            custTrans.packCustTrans_W(custTrans_W);
        }
        // </GEERU>

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            custTransPayment_BR = custTrans.getPaymentExtension_BR();
            custTransPayment_BR.InterestAmount = finInterestAmount;
            custTransPayment_BR.InterestCode = interestCode;
            custTransPayment_BR.FineAmount = fineAmount;
            custTransPayment_BR.FineCode = fineCode;
            custTrans.packExtensionTable(custTranspayment_br);
        }
        // </GBR>

        if (transRefType != CustTransRefType::Payment
            && this.parmCancelledPayment() == false
            && CustPaymModeTable::find(paymMode).IsSEPA)
        {
            // Set Mandate information only for SEPA invoices since payments do not have mandates. Payments are only associated
            // with mandates during the settlement process.

            if (directDebitMandateRecId == 0)
            {
                if (CustDirectDebitMandateSelectFlight::instance().isEnabled() && transRefType == CustTransRefType::BillOfExchange)
                {
                    CustTrans custTransBeingSettled;
                    SpecTrans specTrans;
                    CustTransOpen custTransOpen;

                    select DirectDebitMandate from custTransBeingSettled
                        exists join custTransOpen
                            where custTransBeingSettled.RecId == custTransOpen.RefRecId
                        exists join specTrans 
                            where specTrans.SpecTableId == ledgerJournalTrans.TableId
                                && specTrans.SpecRecId == ledgerJournalTrans.RecId
                                && specTrans.SpecCompany == ledgerJournalTrans.DataAreaId
                                && specTrans.RefTableId == custTransOpen.TableId
                                && specTrans.RefRecId == custTransOpen.RecId
                                && specTrans.RefCompany == custTransOpen.dataAreaId;

                    if (custTransBeingSettled.DirectDebitMandate)
                    {
                        this.parmDirectDebitMandateRecId(custTransBeingSettled.DirectDebitMandate);
                        custTrans.DirectDebitMandate = directDebitMandateRecId;
                    }
                    else
                    {
                        custTrans.DirectDebitMandate = CustDirectDebitMandate::getDefaultMandate(accountNum);
                    }
                }
                else
                {
                    // Default the mandate if it is empty. This is used for documents such as interest notes, collection letters,
                    // general journal invoices, etc. that don't have the ability to enter a mandate prior to posting.
                    custTrans.DirectDebitMandate = CustDirectDebitMandate::getDefaultMandate(accountNum);
                }
            }
            else
            {
                custTrans.DirectDebitMandate = directDebitMandateRecId;
            }

            if (!custTrans.ThirdPartyBankAccountId)
            {
                custTrans.ThirdPartyBankAccountId = CustDirectDebitMandate::find(custTrans.DirectDebitMandate).BankAccount;
            }
        }
        
        custTrans.ReasonRefRecId = ReasonTableRef::checkCreateInCompany(this.parmReasonRefRecID(), custTrans.DataAreaId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromPostingProfile</Name>
				<Source><![CDATA[
    protected void initFromPostingProfile(CustVendTrans custTrans,
                                          PostingProfile _custPostingProfile)
    {
        custTrans.initFromPostingProfile(_custPostingProfile);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCreditInvoicingJour</Name>
				<Source><![CDATA[
    protected void insertCreditInvoicingJour(LedgerJournalTrans _ledgerJournalTrans, CustInvoiceJour _custInvoiceJour)
    {
        CustVendCreditInvoicingJour custVendCreditInvoicingJour;

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
        {
            if (CustVendCreditInvoicingTable::useCreditInvoicingReporting())
            {
                if (_ledgerJournalTrans)
                {
                    CustVendCreditInvoicingTable custVendCreditInvoicingTable = CustVendCreditInvoicingTable::findRefId(_ledgerJournalTrans.TableId,
                        _ledgerJournalTrans.RecId, true);

                    if (custVendCreditInvoicingTable)
                    {
                        custVendCreditInvoicingJour.insertFromCustVendCreditInvoicingTable(custVendCreditInvoicingTable, _custInvoiceJour);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCustTransIdRef</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts a record into the <c>CustTransIdRef</c> table.
    /// </summary>
    /// <param name="_custTransRecId">
    ///    The record ID of the corresponding record in the <c>CustTrans</c> table.
    /// </param>
    protected void insertCustTransIdRef(RecId _custTransRecId)
    {
        CustTransIdRef ref;

        if (transRefType == CustTransRefType::BillOfExchange && transRefId == '')
        {
            // no-op in the BOE special case where the ID is
            // empty because BOE takes care of it later
            return;
        }

        Debug::assert(appl.ttsLevel() > 0);
        Debug::assert(_custTransRecId != 0);
        Debug::assert(transRefId != '');

        ref.TransRefId = transRefId;
        ref.TransRefType = transRefType;
        ref.TransRecId = _custTransRecId;
        ref.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAmountBelowCreditMax</Name>
				<Source><![CDATA[
    protected boolean isAmountBelowCreditMax(TypeOfCreditmaxCheck _typeOfCreditmaxCheck = TypeOfCreditmaxCheck::Balance)
    {
        // <GEERU>
        #ISOCountryRegionCodes
        FieldId agreementDimFieldId;
        AgreementHeaderExtRecId_RU agreementHeaderExtRecId;
        CustParameters custParameters = CustParameters::find();

        boolean warning = custParameters.CreditLineError == CreditLineErrorType::Warning || custParameters.CreditLineError == CreditLineErrorType::MCRReview;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            if (common)
            {
                agreementDimFieldId = CustVendVoucher::getDefaultDimensionFieldId_RU(common);

                if (agreementDimFieldId)
                {
                    agreementHeaderExtRecId = AgreementHeaderExt_RU::findByDefaultDimension(common.(agreementDimFieldId)).RecId;
                }
            }

            return CustTable::checkCreditLimit(accountNum, _typeOfCreditmaxCheck, CurrencyExchangeHelper::mstAmount(amountCur, currencyCode, this.parmTransDate()),
                                           warning,
                                           agreementHeaderExtRecId,
                                           common.RecId ? common.TableId : 0,
                                           common.TableId ? common.RecId : 0
                                          );
        }
        else
        {
            // </GEERU>

           if (common)
           {
               if (this.checkCreditLimitCheckFreeInvoice(common, custParameters))
               {
                   return CustTable::checkCreditLimit(accountNum, _typeOfCreditmaxCheck, CurrencyExchangeHelper::mstAmount(amountCur, currencyCode, this.parmTransDate()), warning);
               }

            }

            return true;

            // <GEERU>
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCreditLimitCheckFreeInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether or not the specified credit limit check free invoice record exists in the <c>CustParameters</c> table.
    /// </summary>
    /// <param name = "_custParameters">
    ///  The <c>CustParameters</c> table buffer.
    /// </param>
    /// <returns>
    /// true if the specified credit limit check free invoice not selected; otherwise, false.
    /// </returns>
    protected boolean checkCreditLimitCheckFreeInvoice(Common _common, CustParameters _custParameters  = CustParameters::find())
    {
        boolean ret = false;
        if (_common)
        {
            switch(_common.tableId)
            {
                case tableNum(CustInvoiceTable):
                    ret = _custParameters.CreditLimitCheckFreeInvoice ? true : false;
                    break;
                case tableNum(CustInvoiceJour):
                    ret = _custParameters.CreditLimitCheckSales ? true : false;
                    break;
                default:
                    ret = false;
                    break;
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSEPATrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the customer transaction should be processed as part of SEPA functionality.
    /// </summary>
    /// <param name="_custTrans">
    /// The customer transaction buffer.
    /// </param>
    /// <returns>
    /// true if the customer transaction should be processed as part of SEPA functionality; otherwise, false.
    /// </returns>
    protected boolean isSEPATrans(CustTrans _custTrans)
    {
        CustPaymModeTable custPaymModeTable = CustPaymModeTable::find(_custTrans.PaymMode);

        return custPaymModeTable.IsSEPA ||
            (transRefType == CustTransRefType::BillOfExchange &&
                (custPaymModeTable.IsSEPA || (!_custTrans.PaymMode && this.isSettledWithSEPAInvoice(_custTrans))));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSettledWithSEPAInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the customer transaction settled with invoice whose payment mode was marked as a SEPA.
    /// </summary>
    /// <param name="_custTrans">
    /// The customer transaction buffer.
    /// </param>
    /// <returns>
    /// true if the customer transaction settled with invoice whose payment mode was marked as a SEPA; otherwise, false.
    /// </returns>
    protected boolean isSettledWithSEPAInvoice(CustTrans _custTrans)
    {
        CustSettlement custSettlement;
        CustTrans settledCustTrans;
        CustPaymModeTable custPaymModeTable;

        select firstOnly crossCompany RecId
            from custSettlement
            where custSettlement.OffsetRecid == _custTrans.RecId
                && custSettlement.OffsetCompany == _custTrans.company()
                && custSettlement.CanBeReversed == true
        exists join settledCustTrans
            where settledCustTrans.RecId == custSettlement.TransRecId
                && settledCustTrans.dataAreaId == custSettlement.TransCompany
        exists join custPaymModeTable
            where custPaymModeTable.PaymMode == settledCustTrans.PaymMode
                && custPaymModeTable.IsSEPA
                && custPaymModeTable.dataAreaId == custSettlement.TransCompany;

        return custSettlement.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrAdjustPennyDiffCustTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the <c>custtrans</c> record if the record is a penny off due to
    /// tax rounding during partial invoicing.
    /// </summary>
    /// <param name="_custTrans">
    /// A record in the <c>CustTrans</c> table.
    /// </param>
    void mcrAdjustPennyDiffCustTrans(CustTrans _custTrans)
    {
        SalesTable salesTable;
        AmountCur amtBeingSettled;
        AmountCur diffAmt;
        CustTrans prevCustTrans;
        salesTable = common.data();

        select firstonly prevCustTrans
            where prevCustTrans.MCRPaymOrderID == salesTable.SalesId;

        if (prevCustTrans)
        {
            amtBeingSettled = abs(prevCustTrans.SettleAmountCur)+_custTrans.AmountCur;
            // Prepaid settlements cause missing penny settlements.
            if (prevCustTrans.Prepayment)
            {
                diffAmt = abs(amountCur)- amtBeingSettled;
            }
            else
            {
                diffAmt = abs(prevCustTrans.AmountCur)- amtBeingSettled;
            }
            if (abs(diffAmt) <= this.mcrMaxPennyDiff())
            {
                _custTrans.AmountCur = _custTrans.AmountCur+diffAmt;
                _custTrans.AmountMST = CurrencyExchangeHelper::amountCur2MST(_custTrans.AmountCur, _custTrans.CurrencyCode);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrMaxPennyDiff</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Retrieves the penny difference set up from the customer parameters to determine if the penny needs to be adjusted or not.
    /// </summary>
    /// <returns>
    /// penny difference setup on the customer parameters.
    /// </returns>
    AmountMST mcrMaxPennyDiff()
    {
        CustParameters custParameters;

        custParameters = CustParameters::find();

        return custParameters.MaxMSTDiff;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCashRegisterTerminalRecId</Name>
				<Source><![CDATA[
    public RefRecId parmCashRegisterTerminalRecId(RefRecId _cashRegisterTerminalRecId_W = cashRegisterTerminalRecId_W)
    {
        cashRegisterTerminalRecId_W = _cashRegisterTerminalRecId_W;
        return cashRegisterTerminalRecId_W;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDirectDebitMandateRecId</Name>
				<Source><![CDATA[
    public CustDirectDebitMandateRecId parmDirectDebitMandateRecId(CustDirectDebitMandateRecId _directDebitMandateRecId = directDebitMandateRecId)
    {
        directDebitMandateRecId = _directDebitMandateRecId;
        return directDebitMandateRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsTCSApplicable_IN</Name>
				<Source><![CDATA[
    public boolean parmIsTCSApplicable_IN(boolean _isTCSApplicable = isTCSApplicable)
    {
        isTCSApplicable = _isTCSApplicable;

        return isTCSApplicable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsTDSApplicable_IN</Name>
				<Source><![CDATA[
    public boolean parmIsTDSApplicable_IN(boolean _isTDSApplicable = isTDSApplicable)
    {
        isTDSApplicable = _isTDSApplicable;

        return isTDSApplicable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSummaryledgerDimensionAccount</Name>
				<Source><![CDATA[
    public LedgerDimensionAccount parmSummaryledgerDimensionAccount(LedgerDimensionAccount _summaryledgerDimensionAccount = summaryledgerDimensionAccount)
    {
        summaryledgerDimensionAccount = _summaryledgerDimensionAccount;

        return summaryledgerDimensionAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransRefId</Name>
				<Source><![CDATA[
    public Num parmTransRefId(Num _transRefId = transRefId)
    {
        // the ID can be empty for a BOE
        Debug::assert((_transRefId != '') || (transRefType == CustTransRefType::BillOfExchange));

        transRefId = _transRefId;

        return transRefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransRefType</Name>
				<Source><![CDATA[
    public CustTransRefType parmTransRefType(CustTransRefType _transRefType = transRefType)
    {
        transRefType = _transRefType;

        return transRefType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldBypassMandateValidationInPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether mandate validation should be bypassed during posting.
    /// </summary>
    /// <param name = "_directDebitMandate">The RecId of the direct debit mandate.</param>
    /// <param name = "_custTrans">The <c>CustTrans</c> record.</param>
    /// <returns>True if validation should be bypassed; otherwise false.</returns>
    protected boolean shouldBypassMandateValidationInPosting(CustDirectDebitMandateRecId _directDebitMandate, CustTrans _custTrans = null)
    {
        // Never bypass in core solution; this method is intended to provide an extensibility point for other solutions
        // enabling them to participate in this decision
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>post</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates and posts the customer or vendor voucher.
    /// </summary>
    /// <param name="_ledgerPostingJournal">
    ///    The ledger posting journal to use for ledger posting.
    /// </param>
    /// <param name="_custTrans">
    ///    The map object holding the value of vendor transaction or customer transaction.
    /// </param>
    /// <param name="_approval">
    ///    The Boolean value to hold the status for approval; optional.
    /// </param>
    /// <param name="_euroTriangulation">
    ///    The Europe triangulation value in drop-down list; optional.
    /// </param>
    /// <param name="_withHoldTaxType">
    ///    The Boolean value that indicates whether there is withholding tax; optional.
    /// </param>
    /// <param name="_useSubLedger">
    ///    The Boolean value that indicates the <c>SubLedger</c> class is being used; optional.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    The exception occurs when validation fails during validate.
    /// </exception>
    public void post(
        LedgerVoucher _ledgerPostingJournal,
        CustVendTrans _custTrans,
        NoYes _approval = NoYes::No,
        UnknownNoYes _euroTriangulation = Currency::noYes2UnknownNoYes(triangulation),
        boolean _withHoldTaxType = false,
        boolean _useSubLedger = false)
    {
        CustSettlement custSettlement;
        CustTrans invoiceBeingSettled;
        CustDirectDebitMandate custDirectDebitMandate;
        CustDirectDebitMandateRecId lastInvoiceMandateRecId;

        // <GEERU>
        #ISOCountryRegionCodes
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        ttsbegin;

        super(_ledgerPostingJournal, _custTrans, _approval, _euroTriangulation, _withHoldTaxType, _useSubLedger);

        // <GEERU>
        if (! countryRegion_RU ||
            (salesInvoicePostingType != SalesInvoicePostingType_RU::GoodsInRoute &&
            (custVendInvoiceJour.CustVendInvoiceJour::getInventProfileType_RU() != InventProfileType_RU::Bailee &&
                custVendInvoiceJour.CustVendInvoiceJour::getInventProfileType_RU() != InventProfileType_RU::CommissionPrincipalAgent)))
        {
            // </GEERU>
            this.insertCustTransIdRef(_custTrans.RecId);
            // <GEERU>
        }
        // </GEERU>

        if (this.isSEPATrans(_custTrans))
        {
            if (transRefType == CustTransRefType::Payment || transRefType == CustTransRefType::BillOfExchange)
            {
                // Find the settlements associated with the payment to update the usage count and expiration date. At this
                // point all of the settlements have already been posted, so they will exist in the CustSettlement table.
                // The changeCompany statement is necessary since any updates to the mandates need to occur in the company
                // of the invoice.

                while select crossCompany TransRecId, TransCompany from custSettlement
                    where custSettlement.OffsetRecid == _custTrans.RecId
                        && custSettlement.OffsetCompany == _custTrans.company()
                        && custSettlement.CanBeReversed == true
                {
                    changeCompany(custSettlement.TransCompany)
                    {
                        invoiceBeingSettled = CustTrans::find(custSettlement.TransRecId);

                        if (CustPaymModeTable::find(invoiceBeingSettled.PaymMode).IsSEPA)
                        {
                            if (!this.shouldBypassMandateValidationInPosting(invoiceBeingSettled.DirectDebitMandate, _custTrans))
                            {
                                CustDirectDebitMandate::validateMandate(invoiceBeingSettled.DirectDebitMandate, false, true, false, invoiceBeingSettled);

                                custDirectDebitMandate = CustDirectDebitMandate::find(invoiceBeingSettled.DirectDebitMandate);

                                Debug::assert(custDirectDebitMandate.RecId != 0);

                                if (lastInvoiceMandateRecId == 0)
                                {
                                    // This only needs to be set once since all mandates need to be identical
                                    lastInvoiceMandateRecId = custDirectDebitMandate.RecId;
                                    this.parmDirectDebitMandateRecId(lastInvoiceMandateRecId);
                                }

                                if (lastInvoiceMandateRecId != custDirectDebitMandate.RecId)
                                {
                                    throw error(strFmt("@SYS4002549", _custTrans.Voucher));
                                }
                            }
                        }
                        else
                        {
                            throw error(strFmt("@SYS4002548", _custTrans.Voucher));
                        }
                    }
                }

                // At this point, if lastInvoiceMandateRecId is zero it means that no settlement records existed. If not, all
                // of the previous validation succeeded and the custDirectDebitMandate represents the mandate used on all of the
                // invoices. The bank account on the payment must be the same as that used on the mandate of the invoices.

                if (lastInvoiceMandateRecId != 0
                    && custDirectDebitMandate.BankAccount != _custTrans.ThirdPartyBankAccountId)
                {
                    throw error(strFmt(
                        "@SYS4002537",
                        _custTrans.ThirdPartyBankAccountId,
                        _custTrans.Voucher,
                        custDirectDebitMandate.BankAccount));
                }
            }
            else if (_custTrans.AmountCur >= 0
                && this.parmCancelledPayment() == false)
            {
                // Validate the mandate on the invoice
                CustTrans localCustTrans = _custTrans;
                if(!this.shouldBypassMandateValidationInPosting(localCustTrans.DirectDebitMandate, localCustTrans))
                {
                    CustDirectDebitMandate::validateMandate(localCustTrans.DirectDebitMandate, true, true, true, localCustTrans);
                }
            }
        }
        else if (this.parmDirectDebitMandateRecId()) // Validate SEPA prepayments
        {
            CustTrans localCustTrans = _custTrans;
            if(!this.shouldBypassMandateValidationInPosting(this.parmDirectDebitMandateRecId(), localCustTrans))
            {
                CustDirectDebitMandate::validateMandate(this.parmDirectDebitMandateRecId(), true, true, true);
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>rboParameters</Name>
				<Source><![CDATA[
    void rboParameters(RetailCustTrans _rboCustTrans, RetailTransactionId _rboTransactionId, RetailStoreId _rboStoreId, RetailTerminalId _rboTerminalId)
    {
        rboParameters = [_rboCustTrans,_rboTransactionId,_rboStoreId,_rboTerminalId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBuffer</Name>
				<Source><![CDATA[
    protected void setBuffer()
    {
        custVendInvoiceJour = custInvoiceJour;
        custVendPaymSched = custPaymSched;
        custVendPaymSchedLine = custPaymSchedLine;

        if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
        {
            rboParameters = [NoYes::No,'','',''];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInvoiceJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets invoice journal.
    /// </summary>
    /// <param name = "_custVendInvoiceJour">
    ///     A <c>CustVendInvoiceJour</c> table buffer.
    /// </param>
    public void setInvoiceJournal(CustVendInvoiceJour _custVendInvoiceJour)
    {
        CustInvoiceJour custInvoiceJourLocal = _custVendInvoiceJour;
        CustTable custTable = CustTable::find(custInvoiceJourLocal.InvoiceAccount);
        super(custInvoiceJourLocal);

        languageId = custInvoiceJourLocal.LanguageId;
        paymMode = custTable.PaymMode;
        paymSpec = custTable.PaymSpec;

        this.initPaymMoneyTransferSlip_CH(custInvoiceJourLocal);
        this.initPaymMoneyTransferSlip_BE(custInvoiceJourLocal);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPaymMoneyTransferSlip_CH</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the instance of the <c>PaymMoneyTransferSlip_CH</c> object.
    /// </summary>
    /// <param name = "_custInvoiceJour">
    ///     A <c>CustInvoiceJour</c> table buffer.
    /// </param>
    protected void initPaymMoneyTransferSlip_CH(CustInvoiceJour _custInvoiceJour)
    {
        if (_custInvoiceJour.GiroType == PaymentStub::ESR_orange)
        {
            PaymMoneyTransferSlip_CH moneyTransferSlip_CH = PaymMoneyTransferSlip::construct(_custInvoiceJour.GiroType);
            moneyTransferSlip_CH.init(_custInvoiceJour.GiroType);

            PaymMode paymentMode = this.getPaymentMode();

            CustPaymModeTable custPaymModeTable = CustPaymModeTable::find(paymentMode);
            if (custPaymModeTable.AccountType == LedgerJournalACType::Bank)
            {
                CompanyBankAccountId bankAccountId = custPaymModeTable.parmPaymAccount();
                moneyTransferSlip_CH.initOCRLine_CH(_custInvoiceJour, bankAccountId);
            }
            else
            {
                moneyTransferSlip_CH.initOCRLine_CH(_custInvoiceJour);
            }
            paymId = moneyTransferSlip_CH.ocrLinePaymId();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPaymMoneyTransferSlip_BE</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the instance of the <c>PaymMoneyTransferSlip_BE</c> object.
    /// </summary>
    /// <param name = "_custInvoiceJour">
    ///     A <c>CustInvoiceJour</c> table buffer.
    /// </param>
    protected void initPaymMoneyTransferSlip_BE(CustInvoiceJour _custInvoiceJour)
    {
        this.initPaymMoneyTransferSlipDetail_BE(_custInvoiceJour.InvoiceId, _custInvoiceJour.GiroType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPaymMoneyTransferSlipDetail_BE</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the instance of the <c>PaymMoneyTransferSlip_BE</c> object.
    /// </summary>
    /// <param name = "_invoiceId">
    ///     ID of an invoice for which the payment slip is generated.
    /// </param name = _giroType>
    ///     Type of the payment slip.
    /// <param>
    protected void initPaymMoneyTransferSlipDetail_BE(InvoiceId _invoiceId, PaymentStubInvoiceId _giroType)
    {
        if (_giroType == PaymentStub::BelSMS101 ||
            _giroType == PaymentStub::BelSMS102)
        {
            PaymMoneyTransferSlip_BE moneyTransferSlip_BE = new PaymMoneyTransferSlip_BE();
            paymReference = moneyTransferSlip_BE.encodePaymId(_invoiceId,
                                                              _giroType);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransRef</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the type and ID for the corresponding record in the <c>CustTransIdRef</c> table.
    /// </summary>
    /// <param name="_transRefType">
    ///    The type of the transaction reference.
    /// </param>
    /// <param name="_transRefId">
    ///    The ID of the transaction reference.
    /// </param>
    /// <remarks>
    ///    The transaction reference holds the ID value most well-known to the user for a record in the
    ///    <c>CustTrans</c> table. It is created during posting.
    /// </remarks>
    public void setTransRef(CustTransRefType _transRefType, Num _transRefId)
    {
        Debug::assert(_transRefId != '');

        transRefType = _transRefType;
        transRefId = _transRefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>summaryLedgerDimension</Name>
				<Source><![CDATA[
    protected LedgerDimensionDefaultAccount summaryLedgerDimension()
    {
        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            return summaryledgerDimensionAccount ? summaryledgerDimensionAccount:
                CustLedgerAccounts::summaryLedgerDimension(accountNum, postingProfile);
        }
        else
        {
            return CustLedgerAccounts::summaryLedgerDimension(accountNum, postingProfile);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustVoucherCollectionLetter</Name>
				<Source><![CDATA[
    public static CustVoucher newCustVoucherCollectionLetter(CustCollectionLetterJour _custCollectionLetterJour)
    {
        CustVoucherCollectionLetter custVoucher;
        CustTable custTable = CustTable::find(_custCollectionLetterJour.AccountNum);
        boolean usePostingDefinitions = isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
            && LedgerParameters::find().JournalizingDefinitionEnableValue == NoYes::Yes;
        LedgerPostingType postingType = usePostingDefinitions ? LedgerPostingType::CustBalance
                                        : LedgerPostingType::CustCollectionLetterFee;

        custVoucher = new CustVoucherCollectionLetter();

        custVoucher.init(_custCollectionLetterJour.AccountNum,
            _custCollectionLetterJour.Fee + _custCollectionLetterJour.TaxAmount,
            _custCollectionLetterJour.CurrencyCode,
            LedgerTransTxt::CustCollectionLetterCust,
            _custCollectionLetterJour.DefaultDimension,
            _custCollectionLetterJour.PostingProfile,
                postingType);

        if (isConfigurationkeyEnabled(configurationKeyNum(PaymCalendar)))
        {
            custVoucher.parmModule(SysModule::Cust);
        }

        custVoucher.parmApprover(HcmWorker::userId2Worker(curUserId()));
        custVoucher.parmApproved(NoYes::Yes);
        custVoucher.parmFormLetter(_custCollectionLetterJour.CollectionLetterNum);
        custVoucher.parmTypeOfCreditmaxCheck(TypeOfCreditmaxCheck::None);
        custVoucher.parmPaymMode(custTable.PaymMode);
        custVoucher.parmPaymSpec(custTable.PaymSpec);
        custVoucher.parmLanguageId(_custCollectionLetterJour.LanguageId);
        custVoucher.parmPaymTermId(_custCollectionLetterJour.PaymTermId);
        custVoucher.parmDueDate(_custCollectionLetterJour.DueDate);
        custVoucher.parmInvoiceId(_custCollectionLetterJour.CollectionLetterNum);

        return custVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustVoucherFreeInvoice</Name>
				<Source><![CDATA[
    public static CustVoucher newCustVoucherFreeInvoice(
        LedgerTransTxt _ledgerTransTxt,
        CustInvoiceJour _custInvoiceJour,
        CustInvoiceTable _custInvoiceTable)
    {
        #ISOCountryRegionCodes

        CustVoucherFreeInvoice custVoucherFreeInvoice = new CustVoucherFreeInvoice();

        custVoucherFreeInvoice.init(_custInvoiceJour.InvoiceAccount,
            _custInvoiceJour.InvoiceAmount,
            _custInvoiceJour.CurrencyCode,
            _ledgerTransTxt,
            _custInvoiceJour.DefaultDimension,
            _custInvoiceJour.PostingProfile,
            LedgerPostingType::CustBalance,
            _custInvoiceJour.Payment,
            SpecTrans::getSpecTransCount(_custInvoiceTable.DataAreaId, _custInvoiceTable.TableId, _custInvoiceTable.RecId)
                ? SettlementType::SelectedTransact : CustParameters::find().AutoSettle == NoYes::Yes ? SettlementType::OpenTransact : SettlementType::None,
            HcmWorker::userId2Worker(curUserId()),
            NoYes::Yes,
            _custInvoiceJour.InvoiceId,
            _custInvoiceJour.CashDiscDate,
            _custInvoiceJour.CashDisc,
            _custInvoiceJour.DueDate,
            _custInvoiceTable,
            TypeOfCreditmaxCheck::None,
            _custInvoiceJour.CashDiscCode,
            _custInvoiceJour.OrderAccount);

        if (isConfigurationkeyEnabled(configurationKeyNum(PaymCalendar)))
        {
            custVoucherFreeInvoice.parmModule(SysModule::Cust);
        }

        custVoucherFreeInvoice.parmCashDiscBaseDate(_custInvoiceTable.CashDiscBaseDate);
        custVoucherFreeInvoice.parmPaymTermId(_custInvoiceTable.Payment);
        custVoucherFreeInvoice.setInvoiceJournal(_custInvoiceJour);
        custVoucherFreeInvoice.parmFormLetter(_custInvoiceJour.InvoiceId);
        custVoucherFreeInvoice.parmPaymMode(_custInvoiceTable.PaymMode);
        custVoucherFreeInvoice.parmPaymSpec(_custInvoiceTable.PaymSpec);

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            custVoucherFreeInvoice.parmBillingClassification(_custInvoiceTable.CustBillingClassification);
        }

        custVoucherFreeInvoice.parmThirdPartyBankAccountId(_custInvoiceTable.CustBankAccountId);
        custVoucherFreeInvoice.parmDirectDebitMandateRecId(_custInvoiceTable.DirectDebitMandate);

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoNO]))
        {
            custVoucherFreeInvoice.parmBankCentralBankPurposeCode(_custInvoiceTable.BankCentralBankPurposeCode);
            custVoucherFreeInvoice.parmBankCentralBankPurposeText(_custInvoiceTable.BankCentralBankPurposeText);
        }

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            custVoucherFreeInvoice.parmExchRate (_custInvoiceJour.ExchRate);
            custVoucherFreeInvoice.parmExchRateSecondary(_custInvoiceJour.ExchRateSecondary);
            custVoucherFreeInvoice.parmTriangulation (_custInvoiceJour.Triangulation);
        }

        // </GEERU>
        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            custVoucherFreeInvoice.parmFineCode_BR(_custInvoiceTable.FineCode_BR);
            custVoucherFreeInvoice.parmInterestCode_BR(_custInvoiceTable.InterestCode_BR);
        }

        // </GBR>
        return custVoucherFreeInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustVoucherGoodsInRoute_RU</Name>
				<Source><![CDATA[
    public static CustVoucher newCustVoucherGoodsInRoute_RU(LedgerTransTxt _ledgerTransTxt,
                                                            CustInvoiceJour _custInvoiceJour,
                                                            AmountCur _amountCur,
                                                            AmountCur _amountCurFixed)
    {
        CustVoucherSales custVoucherSales = new CustVoucherSales();

        custVoucherSales.init(_custInvoiceJour.InvoiceAccount,
                              _amountCur,
                              _custInvoiceJour.CurrencyCode,
                              _ledgerTransTxt,
                              _custInvoiceJour.DefaultDimension,
                              _custInvoiceJour.PostingProfile,
                              LedgerPostingType::CustBalance,
                              _custInvoiceJour.Payment,
                              _custInvoiceJour.custInvoiceJour_RU().SettleVoucher_RU,
                              HcmWorker::userId2Worker(curUserId()),
                              NoYes::Yes,
                              _custInvoiceJour.InvoiceId,
                              _custInvoiceJour.CashDiscDate,
                              _custInvoiceJour.CashDisc,
                              _custInvoiceJour.DueDate,
                              _custInvoiceJour,
                              TypeOfCreditmaxCheck::None,
                              _custInvoiceJour.CashDiscCode,
                              _custInvoiceJour.OrderAccount);

        if (isConfigurationkeyEnabled(configurationKeyNum(PaymCalendar)))
        {
            custVoucherSales.parmModule(SysModule::Cust);
        }

        custVoucherSales.parmAmountCurFixed_RU(_amountCurFixed);
        custVoucherSales.setInvoiceJournal(_custInvoiceJour);
        custVoucherSales.parmFormLetter(_custInvoiceJour.InvoiceId);
        custVoucherSales.parmThirdPartyBankAccountId(_custInvoiceJour.salesTable().custTable_InvoiceAccount().BankAccount);
        custVoucherSales.parmPaymMode(_custInvoiceJour.salesTable().PaymMode);
        custVoucherSales.parmPaymSpec(_custInvoiceJour.salesTable().PaymSpec);
        custVoucherSales.parmFixedExchRate(_custInvoiceJour.salesTable().FixedExchRate ? NoYes::Yes : NoYes::No);
        custVoucherSales.parmBankCentralBankPurposeCode(_custInvoiceJour.salesTable().BankCentralBankPurposeCode);
        custVoucherSales.parmBankCentralBankPurposeText(_custInvoiceJour.salesTable().BankCentralBankPurposeText);

        return custVoucherSales;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustVoucherInterest</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an instance of the <c>CustVoucherInterest</c> class.
    /// </summary>
    /// <param name="_accountNum">
    ///    The account number of a customers for whom interest has accrued.
    /// </param>
    /// <param name="_interestAmount">
    ///    The amount of interest for a transaction.
    /// </param>
    /// <param name="_currencyCode">
    ///    The currency code of a transaction.
    /// </param>
    /// <param name="_transTxtType">
    ///    The transaction text that has been created for the transaction.
    /// </param>
    /// <param name="_defaultDimension">
    ///    The dimension default sets for the transaction.
    /// </param>
    /// <param name="_postingProfile">
    ///    The posting profile of the transaction when closing.
    /// </param>
    /// <param name="_ledgerPostingType">
    ///    The ledger posting type of a transaction.
    /// </param>
    /// <param name="_custVoucherInterestRecIdSet">
    ///    The <c>Set</c> object that contains the record ID of the <c>CustInterestTrans</c> table.
    /// </param>
    /// <returns>
    ///    An object of the <c>CustVoucher</c> class.
    /// </returns>
    public static CustVoucher newCustVoucherInterest(
        CustVendAC _accountNum,
        AmountCur _interestAmount,
        CurrencyCode _currencyCode,
        LedgerTransTxt _transTxtType,
        DimensionDefault _defaultDimension,
        PostingProfile _postingProfile,
        LedgerPostingType _ledgerPostingType,
        Set _custVoucherInterestRecIdSet)
    {
        CustVoucherInterest custVoucher = new CustVoucherInterest();

        custVoucher.init(_accountNum,
              _interestAmount,
              _currencyCode,
              _transTxtType,
              _defaultDimension,
              _postingProfile,
              _ledgerPostingType,
              '',
              SettlementType::None,
              HcmWorker::userId2Worker(curUserId()),
              NoYes::Yes);

        if (isConfigurationkeyEnabled(configurationKeyNum(PaymCalendar)))
        {
            custVoucher.parmModule(SysModule::Cust);
        }

        custVoucher.parmInterestTrans(_custVoucherInterestRecIdSet);

        return custVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustVoucherJournal</Name>
				<Source><![CDATA[
    public static CustVoucher newCustVoucherJournal(LedgerJournalTrans _ledgerJournalTrans,
                                                    LedgerTransTxt _ledgerTransTxt = LedgerTransTxt::None)
    {
        #ISOCountryRegionCodes
        CustVoucher custVoucher;
        Amount amount;
        LedgerJournalTable ledgerJournalTable = _ledgerJournalTrans.ledgerJournalTable();
        LedgerJournalType ledgerJournalType = ledgerJournalTable.JournalType;
        LedgerJournalType originalJournalType = ledgerJournalTable.findOriginalJournalType();
        // <GBR>
        LedgerJournalTransPayment_BR payment_BR;
        // </GBR>

        if (TaxParameters::canApplyCashDiscOnInvoice_ES())
        {
            amount = _ledgerJournalTrans.amount() - _ledgerJournalTrans.CashDiscAmount;
        }
        else
        {
            amount = _ledgerJournalTrans.amount();
        }

        custVoucher = new CustVoucherJournal();

        custVoucher.init(_ledgerJournalTrans.parmAccount(),
            amount,
            _ledgerJournalTrans.CurrencyCode,
            _ledgerTransTxt,
            _ledgerJournalTrans.DefaultDimension,
            _ledgerJournalTrans.PostingProfile,
            LedgerPostingType::CustBalance,
            _ledgerJournalTrans.Payment,
            _ledgerJournalTrans.SettleVoucher,
            _ledgerJournalTrans.Approver,
            _ledgerJournalTrans.Approved,
            '',
            dateNull(),
            0,
            _ledgerJournalTrans.Due,
            _ledgerJournalTrans);

        if (isConfigurationkeyEnabled(configurationKeyNum(PaymCalendar)))
        {
            custVoucher.parmModule(SysModule::Cust);
        }

        custVoucher.parmExchRate(_ledgerJournalTrans.ExchRate);
        custVoucher.parmExchRateSecondary(_ledgerJournalTrans.ExchRateSecond);
        custVoucher.parmTriangulation(_ledgerJournalTrans.Triangulation);
        custVoucher.parmReportingCurrencyExchRate(_ledgerJournalTrans.ReportingCurrencyExchRate);
        custVoucher.parmReportingCurrencyExchRateSecondary(_ledgerJournalTrans.ReportingCurrencyExchRateSecondary);
        custVoucher.parmCashDiscCode(_ledgerJournalTrans.CashDiscCode);
        custVoucher.parmCashDiscDate(_ledgerJournalTrans.DateCashDisc);
        custVoucher.parmCashDiscAmount(_ledgerJournalTrans.CashDiscAmount);
        custVoucher.parmDueDate(_ledgerJournalTrans.Due);
        custVoucher.parmPaymMode(_ledgerJournalTrans.PaymMode);
        custVoucher.parmPaymSpec(_ledgerJournalTrans.PaymSpec);
        custVoucher.parmTransDate(_ledgerJournalTrans.TransDate);
        custVoucher.parmTransVoucher(_ledgerJournalTrans.Voucher);
        custVoucher.parmTransTxt(_ledgerJournalTrans.Txt);
        custVoucher.parmDocumentDate(_ledgerJournalTrans.DocumentDate);
        custVoucher.parmDocumentNum(_ledgerJournalTrans.DocumentNum);
        custVoucher.parmPaymReference(_ledgerJournalTrans.PaymReference);
        custVoucher.parmInvoiceId(_ledgerJournalTrans.Invoice);
        custVoucher.parmThirdPartyBankAccountId(_ledgerJournalTrans.CustVendBankAccountId);
        custVoucher.parmPrePayment(_ledgerJournalTrans.Prepayment);
        custVoucher.parmLanguageId(CustTable::find(_ledgerJournalTrans.parmAccount()).languageId());
        custVoucher.parmTypeOfCreditmaxCheck(CustParameters::find().CreditMaxCheck);
        custVoucher.parmTransType(_ledgerJournalTrans.TransactionType);
        custVoucher.parmReasonRefRecID(_ledgerJournalTrans.ReasonRefRecID);
        custVoucher.parmCashDiscBaseDate(_ledgerJournalTrans.CashDiscBaseDate);
        custVoucher.parmPaymTermId(_ledgerJournalTrans.Payment);
        custVoucher.parmFinTag(_ledgerJournalTrans.FinTag);

        if (_ledgerJournalTrans.DirectDebitMandate)
        {
            custVoucher.parmDirectDebitMandateRecId(_ledgerJournalTrans.DirectDebitMandate);
        }

        // <GEERU>
        custVoucher.parmCommProfileType_RU(_ledgerJournalTrans.CommProfileType_RU);
        // </GEERU>

        // <GIN>
        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
            custVoucher.parmIsTDSApplicable_IN(ledgerJournalTransTaxExt.TDSGroup != '');
            custVoucher.parmIsTCSApplicable_IN(ledgerJournalTransTaxExt.TCSGroup != '');
        }
        // </GIN>

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            payment_BR = _ledgerJournalTrans.getPaymentExtension_BR();
            custVoucher.parmFineAmount_BR(-payment_BR.FineAmountCur_BR);
            custVoucher.parmFinInterestAmount_BR(-payment_BR.FinInterestAmountCur_BR);
        }
        // </GBR>

        custVoucher.parmBypassCreditCheck(amount < 0 ? true : false); // bypass credit check on payments or transactions with credit amount

        if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank &&
            !_ledgerJournalTrans.isOffsetCompanyIntercompany())
        {
            custVoucher.parmCompanyBankAccountId(_ledgerJournalTrans.parmOffsetAccount());
        }

        switch (ledgerJournalType)
        {
            case LedgerJournalType::Daily:

                custVoucher.parmApproved(_ledgerJournalTrans.Approved);

                if (_ledgerJournalTrans.Approved)
                {
                    custVoucher.parmApprover(_ledgerJournalTrans.Approver ? _ledgerJournalTrans.Approver : HcmWorker::userId2Worker(curUserId()));
                }
                break;

            case LedgerJournalType::BankChequeReversal,
                 LedgerJournalType::BankDepositPaymCancel,
                 LedgerJournalType::Assets:

                custVoucher.parmApproved(NoYes::Yes);
                custVoucher.parmApprover(_ledgerJournalTrans.Approver ? _ledgerJournalTrans.Approver : HcmWorker::userId2Worker(curUserId()));
                break;

            case LedgerJournalType::CustBillOfExchangeAccept,
                 LedgerJournalType::CustBillOfExchangeDraw,
                 LedgerJournalType::CustBillOfExchangeProtest,
                 LedgerJournalType::CustBillOfExchangeRedraw,
                 LedgerJournalType::CustPaymRemittance,
                 LedgerJournalType::CustBillOfExchangeSettle:

                custVoucher.parmCompanyBankAccountId(_ledgerJournalTrans.BankAccountId);
                break;
        }

        if (ledgerJournalType == LedgerJournalType::BankDepositPaymCancel ||
            originalJournalType == LedgerJournalType::BankDepositPaymCancel)
        {
            custVoucher.parmCancelledPayment(NoYes::Yes);
        }

        if (originalJournalType == LedgerJournalType::BankChequeReversal ||
            originalJournalType == LedgerJournalType::BankDepositPaymCancel)
        {
            custVoucher.parmApproved(NoYes::Yes);
            custVoucher.parmApprover(_ledgerJournalTrans.Approver ?
                                     _ledgerJournalTrans.Approver : HcmWorker::userId2Worker(curUserId()));
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoNO]))
        {
            custVoucher.parmBankCentralBankPurposeCode(_ledgerJournalTrans.BankCentralBankPurposeCode);
            custVoucher.parmBankCentralBankPurposeText(_ledgerJournalTrans.BankCentralBankPurposeText);
        }

        return custVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustVoucherSales</Name>
				<Source><![CDATA[
    public static CustVoucher newCustVoucherSales(
        LedgerTransTxt _ledgerTransTxt,
        CustInvoiceJour _custInvoiceJour,
        SalesParmTable _salesParmTable,
        SalesTable _salesTable)
    {
        #ISOCountryRegionCodes
        // <GBR>
        SalesTable_BR salesTable_BR;
        // </GBR>

        // <GEERU>
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        CustVoucherSales custVoucherSales = new CustVoucherSales();

        custVoucherSales.init(_custInvoiceJour.InvoiceAccount,
            _custInvoiceJour.InvoiceAmount,
            _custInvoiceJour.CurrencyCode,
            _ledgerTransTxt,
            _custInvoiceJour.DefaultDimension,
            _custInvoiceJour.PostingProfile,
            LedgerPostingType::CustBalance,
            _custInvoiceJour.Payment,
            // <GEERU>
            countryRegion_RU &&
                _custInvoiceJour.custInvoiceJour_RU().InvoicePostingType_RU == SalesInvoicePostingType_RU::GoodsInRoute ?
                SettlementType::None :
                _salesTable.SettleVoucher,
            // </GEERU>
            HcmWorker::userId2Worker(curUserId()),
            NoYes::Yes,
            _custInvoiceJour.InvoiceId,
            _custInvoiceJour.CashDiscDate,
            _custInvoiceJour.CashDisc,
            _custInvoiceJour.DueDate,
            _salesTable,
            TypeOfCreditmaxCheck::None,
            _custInvoiceJour.CashDiscCode,
            _custInvoiceJour.OrderAccount);

        if (isConfigurationkeyEnabled(configurationKeyNum(PaymCalendar)))
        {
            custVoucherSales.parmModule(SysModule::Cust);
        }

        if (FinTagConfiguration::isFinTagConfigurationSet(curExt()) && SalesOrderFinTagFeature::isEnabled())
        {
            custVoucherSales.parmFinTag(_custInvoiceJour.FinTag);
        }

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            salesTable_BR = _salesTable.salesTable_BR();
            custVoucherSales.parmFineCode_BR(salesTable_BR.FineCode_BR);
            custVoucherSales.parmInterestCode_BR(salesTable_BR.InterestCode_BR);
        }
        // </GBR>

        custVoucherSales.parmCashDiscBaseDate(_salesTable.CashDiscBaseDate);
        custVoucherSales.parmPaymTermId(_salesTable.Payment);
        custVoucherSales.setInvoiceJournal(_custInvoiceJour);
        custVoucherSales.parmFormLetter(_custInvoiceJour.InvoiceId);
        custVoucherSales.parmThirdPartyBankAccountId(_salesParmTable.CustBankAccountId);
        custVoucherSales.parmPaymMode(_salesTable.PaymMode);
        custVoucherSales.parmPaymSpec(_salesTable.PaymSpec);
        custVoucherSales.parmDirectDebitMandateRecId(_salesTable.DirectDebitMandate);

        if (_salesTable.FixedExchRate != 0.0)
        {
            custVoucherSales.parmFixedExchRate(NoYes::Yes);
            custVoucherSales.parmExchRate(_salesTable.FixedExchRate);
        }
        else
        {
            custVoucherSales.parmFixedExchRate(NoYes::No);
        }


        if(_salesTable.ReportingCurrencyFixedExchRate != 0.0)
        {
            custVoucherSales.parmReportingCurrencyExchRate(_salesTable.ReportingCurrencyFixedExchRate);
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoNO]))
        {
            custVoucherSales.parmBankCentralBankPurposeCode(_salesTable.BankCentralBankPurposeCode);
            custVoucherSales.parmBankCentralBankPurposeText(_salesTable.BankCentralBankPurposeText);
        }

        return custVoucherSales;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustVoucherSalesComplInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and initializes an instance of the <c>CustVoucherSalesComplementaryInvoice</c> class.
    /// </summary>
    /// <param name="_ledgerTransTxt">
    /// A text describing the transaction.
    /// </param>
    /// <param name="_salesComplementaryInvoiceHeader">
    /// The <c>SalesComplementaryInvoiceHeader</c> table buffer containing the sales complementary invoice header.
    /// </param>
    /// <param name="_calcTotals">
    /// An instance of the <c>SalesComplInvCalcTotals</c> class used to calculate the totals for the sales
    /// coplementary invoice.
    /// </param>
    /// <returns>
    /// An instance of the <c>CustVoucherSalesComplementaryInvoice</c> class.
    /// </returns>
    public static CustVoucher newCustVoucherSalesComplInvoice (LedgerTransTxt _ledgerTransTxt,
                                                               SalesComplementaryInvoiceHeader _salesComplementaryInvoiceHeader,
                                                               SalesComplInvCalcTotals _calcTotals)
    {
        CustTable custTable;
        AmountMST retainedTaxAmount;
        CustVoucherSalesComplementaryInvoice custVoucherSalesComplementaryInvoice = new CustVoucherSalesComplementaryInvoice();

        if (_calcTotals.tax())
        {
            retainedTaxAmount = _calcTotals.tax().totalTaxAmountRetained_BR();
        }

        custVoucherSalesComplementaryInvoice.init(_salesComplementaryInvoiceHeader.CustTable,
            _salesComplementaryInvoiceHeader.TotalAmount - retainedTaxAmount,
            _salesComplementaryInvoiceHeader.Currency,
            _ledgerTransTxt,
            _salesComplementaryInvoiceHeader.DefaultDimension,
            _salesComplementaryInvoiceHeader.PostingProfile,
            LedgerPostingType::CustBalance,
            _salesComplementaryInvoiceHeader.PaymTerm,
            SpecTrans::getSpecTransCount(_salesComplementaryInvoiceHeader.DataAreaId, _salesComplementaryInvoiceHeader.TableId, _salesComplementaryInvoiceHeader.RecId)
                ? SettlementType::SelectedTransact : CustParameters::find().AutoSettle == NoYes::Yes ? SettlementType::OpenTransact : SettlementType::None,
            HcmWorker::userId2Worker(curUserId()),
            NoYes::Yes,
            _salesComplementaryInvoiceHeader.FiscalDocumentNumber,
            _salesComplementaryInvoiceHeader.CashDiscDate,
            _calcTotals.cashDiscAmount(),
            _salesComplementaryInvoiceHeader.DueDate,
            _salesComplementaryInvoiceHeader,
            TypeOfCreditmaxCheck::None,
            _salesComplementaryInvoiceHeader.CashDisc,
            _salesComplementaryInvoiceHeader.CustTable);

        custVoucherSalesComplementaryInvoice.parmPaymMode(_salesComplementaryInvoiceHeader.CustPaymModeTable);
        custVoucherSalesComplementaryInvoice.parmPaymSpec(_salesComplementaryInvoiceHeader.CustPaymModeSpec);
        custVoucherSalesComplementaryInvoice.parmThirdPartyBankAccountId(_salesComplementaryInvoiceHeader.CustBankAccountID);
        custVoucherSalesComplementaryInvoice.parmCalcTotals(_calcTotals);
        custVoucherSalesComplementaryInvoice.parmFormLetter(_salesComplementaryInvoiceHeader.FiscalDocumentNumber);

        custTable = CustTable::find(_salesComplementaryInvoiceHeader.CustTable);
        custVoucherSalesComplementaryInvoice.parmFineCode_BR(custTable.FineCode_BR);
        custVoucherSalesComplementaryInvoice.parmInterestCode_BR(custTable.InterestCode_BR);

        return custVoucherSalesComplementaryInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustVoucherTaxWithhold</Name>
				<Source><![CDATA[
    public static CustVoucherTaxWithhold newCustVoucherTaxWithhold(TaxWithholdTrans _taxWithholdTrans,
                                                                        DimensionDefault _defaultDimension,
                                                                        PostingProfile _postingProfile,
                                                                        ExchRate _exchRate,
                                                                        ExchrateSecondary _exchRateSecond,
                                                                        EUROTriangulation _triangulation,
                                                                        LedgerTransTxt _ledgerTransTxt = LedgerTransTxt::None)
    {
        CustVoucherTaxWithhold custVoucherTaxWithhold;
        custVoucherTaxWithhold = new CustVoucherTaxWithhold();

        custVoucherTaxWithhold.init(_taxWithholdTrans.CustAccount,
            _taxWithholdTrans.InvoiceTaxWithholdAmount,
            _taxWithholdTrans.InvoiceCurrency,
            _ledgerTransTxt,
            _defaultDimension,
            _postingProfile,
            LedgerPostingType::CustBalance);

        if (isConfigurationkeyEnabled(configurationKeyNum(PaymCalendar)))
        {
            custVoucherTaxWithhold.parmModule(SysModule::Cust);
        }

        custVoucherTaxWithhold.parmExchRate(_exchRate);
        custVoucherTaxWithhold.parmExchRateSecondary(_exchRateSecond);
        custVoucherTaxWithhold.parmTriangulation(_triangulation);
        custVoucherTaxWithhold.parmTransDate(_taxWithholdTrans.TransDate);
        custVoucherTaxWithhold.parmTransVoucher(_taxWithholdTrans.SettlementVoucher);
        custVoucherTaxWithhold.setTaxWithholdTrans(_taxWithholdTrans);
        custVoucherTaxWithhold.setTransRef(CustTransRefType::Payment,_taxWithholdTrans.Voucher);

        return custVoucherTaxWithhold;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustVoucherInterestFee</Name>
				<Source><![CDATA[
    public static CustVoucher newCustVoucherInterestFee(
        CustVendAC _accountNum,
        AmountCur _interestAmount,
        CurrencyCode _currencyCode,
        LedgerTransTxt _transTxtType,
        DimensionDefault _defaultDimension,
        PostingProfile _postingProfile,
        LedgerPostingType _ledgerPostingType)
    {
        CustVoucherInterestFee custVoucher = new CustVoucherInterestFee();

        custVoucher.init(_accountNum,
            _interestAmount,
            _currencyCode,
            _transTxtType,
            _defaultDimension,
            _postingProfile,
            _ledgerPostingType);

        return custVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjTransPostingQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides the base query for select <c>ProjTransPosting</c> with update mode.
    /// </summary>
    /// <param name = "_voucherNo">
    /// The voucher number of the invoice.
    /// </param>
    /// <returns>
    /// Returns the query instance to select all project posted transaction of given voucher and payment status is expected payment.
    /// </returns>
    protected static Query getProjTransPostingQuery(Voucher _voucherNo)
    {
        Query query = new Query();
        QueryBuildDataSource qbds =  query.addDataSource(tableNum(ProjTransPosting));
        qbds.addRange(fieldNum(ProjTransPosting, Voucher)).value(queryValue(_voucherNo));
        qbds.addRange(fieldNum(ProjTransPosting, PaymentStatus)).value(queryValue(ProjPaymentStatus::ExpectedPayment));
        qbds.update(true);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjTransPostingWithAmountQtyAndPaymentStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates record in <c>ProjTransPosting</c> with updated amount, qty and payment status.
    /// </summary>
    /// <param name = "_projTransPostingOrig">
    /// The buffer of <c>ProjTransPosting</c> record.
    /// </param>
    /// <param name = "_partialQty">
    /// The partial quantity.
    /// </param>
    /// <param name = "_partialAmount">
    /// The partial amount.
    /// </param>
    protected static void createProjTransPostingWithAmountQtyAndPaymentStatus(ProjTransPosting _projTransPostingOrig, Qty _partialQty, AmountMST _partialAmount )
    {
        // Copy the row to be inserted
        ProjTransPosting projTransPostingInsert;
        projTransPostingInsert.data(_projTransPostingOrig);

        // insert new record
        projTransPostingInsert.AmountMst = _projTransPostingOrig.AmountMst - _partialAmount;
        projTransPostingInsert.Qty = _projTransPostingOrig.Qty - _partialQty;
        projTransPostingInsert.PaymentStatus = ProjPaymentStatus::ExpectedPayment;
        projTransPostingInsert.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjTransPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method will add rows (partial payment) or update (full payment) the ProjTransPosting
    /// corresponding to the cust transaction
    /// </summary>
    /// <param name = "_paymentDate">
    /// The payment date for the invoice.
    /// </param>
    /// <param name = "_voucherNo">
    /// The voucher number of the invoice
    /// </param>
    /// <param name = "_paymentStatus">
    /// The payment status of the invoice.
    /// </param>
    /// <param name = "_partialPayment">
    /// Whether or not this is a partial payment. Optional value whose default is false.</param>
    /// <param name = "_percentagePayment">
    /// If this is a partial payment, the percentage to be paid.
    /// </param>
    public static void updateProjTransPosting(TransDate _paymentDate,
                                        Voucher _voucherNo,
                                        ProjPaymentStatus _paymentStatus,
                                        boolean _partialPayment = false,
                                        real _percentagePayment = 0)
    {

        ttsbegin;

        QueryRun queryRun = new QueryRun(CustVoucher::getProjTransPostingQuery(_voucherNo));

        ProjCustTransInvoiceTmpTable projCustTransInvoiceTmpTable;
        int conIndex = 0;
        container projTransPostingParams;
        boolean simulatePost = false;

        ProjLedgerJournalPostContext context = ProjLedgerJournalPostContext::current();

        if (context && context.parmSimulatePosting())
        {
            simulatePost = context.parmSimulatePosting();
        }
        
        // Select the projTransPosting for update and change the payment date and status
        while(queryRun.next())
        {
            ProjTransPosting projTransPostingOrig = queryRun.get(tableNum(ProjTransPosting));

            Set tempDBRecords = new Set(Types::Record);
            CustVoucher::updateOriginalProjTransPosting(projTransPostingOrig, _paymentDate, _paymentStatus, _partialPayment, _percentagePayment);

            //Handle Pay when Paid
            if (CustVoucher::isPaymentStatusPaidOrExpectedPayment(_paymentStatus))
            {
                ProjInvoiceJour projInvoiceJour;
                CustTrans custTrans;

                switch (projTransPostingOrig.ProjTransType)
                {
                    case ProjTransType::Item:
                        ProjInvoiceItem projInvoiceItem;
                        while select RecId from projInvoiceItem
                            where projInvoiceItem.ProjTransId == projTransPostingOrig.TransId
                        join InvoiceAmount, ProjInvoiceId, InvoiceDate, InvoiceAccount, LedgerVoucher from projInvoiceJour
                            where projInvoiceJour.ProjInvoiceId == projInvoiceItem.ProjInvoiceId &&
                                  projInvoiceJour.InvoiceDate == projInvoiceItem.InvoiceDate
                        join SettleAmountCur from custTrans
                            where custTrans.AccountNum == projInvoiceJour.InvoiceAccount &&
                                custTrans.Voucher == projInvoiceJour.LedgerVoucher &&
                                custTrans.TransDate == projInvoiceJour.InvoiceDate
                        {
                            projCustTransInvoiceTmpTable.clear();
                            projCustTransInvoiceTmpTable.SettleAmountCur = custTrans.SettleAmountCur;
                            projCustTransInvoiceTmpTable.AccountNum = projInvoiceJour.InvoiceAccount;
                            projCustTransInvoiceTmpTable.Voucher = projInvoiceJour.LedgerVoucher;
                            projCustTransInvoiceTmpTable.TransDate = projInvoiceJour.InvoiceDate;
                            projCustTransInvoiceTmpTable.InvoiceAmount = projInvoiceJour.InvoiceAmount;
                            projCustTransInvoiceTmpTable.ProjInvoiceId = projInvoiceJour.ProjInvoiceId;
                            projCustTransInvoiceTmpTable.ProjTransId = projTransPostingOrig.TransId;
                            projCustTransInvoiceTmpTable.insert();

                            tempDBRecords.add(projCustTransInvoiceTmpTable);
                        }
                        break;

                    case ProjTransType::Hour:
                        ProjInvoiceEmpl projInvoiceEmpl;
                        while select RecId from projInvoiceEmpl
                                where projInvoiceEmpl.TransId == projTransPostingOrig.TransId
                            join InvoiceAmount, ProjInvoiceId, InvoiceDate, InvoiceAccount, LedgerVoucher from projInvoiceJour
                                where projInvoiceJour.ProjInvoiceId == projInvoiceEmpl.ProjInvoiceId &&
                                    projInvoiceJour.InvoiceDate == projInvoiceEmpl.InvoiceDate
                            join SettleAmountCur from custTrans
                                where custTrans.AccountNum == projInvoiceJour.InvoiceAccount &&
                                    custTrans.Voucher == projInvoiceJour.LedgerVoucher &&
                                    custTrans.TransDate == projInvoiceJour.InvoiceDate
                        {
                            projCustTransInvoiceTmpTable.clear();
                            projCustTransInvoiceTmpTable.SettleAmountCur = custTrans.SettleAmountCur;
                            projCustTransInvoiceTmpTable.AccountNum = projInvoiceJour.InvoiceAccount;
                            projCustTransInvoiceTmpTable.Voucher = projInvoiceJour.LedgerVoucher;
                            projCustTransInvoiceTmpTable.TransDate = projInvoiceJour.InvoiceDate;
                            projCustTransInvoiceTmpTable.InvoiceAmount = projInvoiceJour.InvoiceAmount;
                            projCustTransInvoiceTmpTable.ProjInvoiceId = projInvoiceJour.ProjInvoiceId;
                            projCustTransInvoiceTmpTable.ProjTransId = projTransPostingOrig.TransId;
                            projCustTransInvoiceTmpTable.insert();

                            tempDBRecords.add(projCustTransInvoiceTmpTable);
                        }
                        break;

                    case ProjTransType::Cost:
                        ProjInvoiceCost projInvoiceCost;                        
                        while Select RecId from projInvoiceCost
                            where projInvoiceCost.TransId == projTransPostingOrig.TransId
                        join InvoiceAmount, ProjInvoiceId, InvoiceDate, InvoiceAccount, LedgerVoucher from projInvoiceJour
                            where projInvoiceJour.ProjInvoiceId == projInvoiceCost.ProjInvoiceId &&
                                projInvoiceJour.InvoiceDate == projInvoiceCost.InvoiceDate
                        join SettleAmountCur, SettleAmountMST from custTrans
                            where custTrans.AccountNum == projInvoiceJour.InvoiceAccount &&
                                custTrans.Voucher == projInvoiceJour.LedgerVoucher &&
                                custTrans.TransDate == projInvoiceJour.InvoiceDate
                        {
                            projCustTransInvoiceTmpTable.clear();
                            projCustTransInvoiceTmpTable.SettleAmountCur = custTrans.SettleAmountCur;
                            projCustTransInvoiceTmpTable.AccountNum = projInvoiceJour.InvoiceAccount;
                            projCustTransInvoiceTmpTable.Voucher = projInvoiceJour.LedgerVoucher;
                            projCustTransInvoiceTmpTable.TransDate = projInvoiceJour.InvoiceDate;
                            projCustTransInvoiceTmpTable.InvoiceAmount = projInvoiceJour.InvoiceAmount;
                            projCustTransInvoiceTmpTable.ProjInvoiceId = projInvoiceJour.ProjInvoiceId;
                            projCustTransInvoiceTmpTable.ProjTransId = projTransPostingOrig.TransId;
                            projCustTransInvoiceTmpTable.insert();

                            tempDBRecords.add(projCustTransInvoiceTmpTable);
                        }
                        break;
                }
                container con = tempDBRecords.pack();
                conIndex++;
                projTransPostingParams = conIns(projTransPostingParams, conIndex, [projTransPostingOrig.RecId, simulatePost, con]);
            }
        }

        ttscommit;

        if (conIndex > 0)
        {
            CustVoucher::updatePayWhenPaidStatusV2(projTransPostingParams);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOriginalProjTransPosting</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updating Project transaction posting table buffer.
    /// </summary>
    /// <param name = "_projTransPostingOrig">
    ///     Project transaction posting table buffer.
    /// </param>
    /// <param name = "_paymentDate">
    ///     Payment date.
    /// </param>
    /// <param name = "_paymentStatus">
    ///     Project payment status.
    /// </param>
    /// <param name = "_partialPayment">
    ///     Partial payment boolean value.
    /// </param>
    /// <param name = "_percentagePayment">
    ///     Percentage payment.
    /// </param>
    protected static void updateOriginalProjTransPosting(ProjTransPosting _projTransPostingOrig,
        TransDate _paymentDate,
        ProjPaymentStatus _paymentStatus,
        boolean _partialPayment,
        real _percentagePayment)
    {
        // Check to see if the partial payment needs to be done
        if (_partialPayment)
        {
            // get percentage of partial payment
            AmountMST partialAmount = CurrencyExchangeHelper::amount(_projTransPostingOrig.AmountMst * _percentagePayment);
            Qty partialQty = decRound(_projTransPostingOrig.Qty * _percentagePayment, 2);

            CustVoucher::createProjTransPostingWithAmountQtyAndPaymentStatus(_projTransPostingOrig, partialQty, partialAmount);

            // We need to edit the existing record to reflect the partial payment
            _projTransPostingOrig.AmountMst = partialAmount;
            _projTransPostingOrig.Qty = partialQty;
        }

        _projTransPostingOrig.PaymentStatus = _paymentStatus;
        _projTransPostingOrig.PaymentDate = _paymentDate;
        _projTransPostingOrig.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPaymentStatusPaidOrExpectedPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks <c>ProjPaymentStatus</c> is paid or expected payment.
    /// </summary>
    /// <param name = "_paymentStatus">
    /// The payment status of the invoice.
    /// </param>
    /// <returns>
    /// true, if payment status is either paid or expected payment; otherwise, false.
    /// </returns>
    protected static boolean isPaymentStatusPaidOrExpectedPayment(ProjPaymentStatus _paymentStatus)
    {
        return (_paymentStatus == ProjPaymentStatus::Paid || _paymentStatus == ProjPaymentStatus::ExpectedPayment);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePayWhenPaidStatusV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the pay when paid flag on vendor invoice or ledger journal transaction record.
    /// </summary>
    /// <param name="_projTransPostingParams">
    /// A container with the list of parameters used for updating pay when paid status.
    /// </param>
    protected static void updatePayWhenPaidStatusV2(container _projTransPostingParams)
    {
        System.Threading.CancellationToken token = new System.Threading.CancellationToken();

        System.Threading.Tasks.Task task = runAsync(classNum(ProjPayWhenPaidStatusCheck),
                        staticMethodStr(ProjPayWhenPaidStatusCheck, updateVendorPayablePayWhenPaidStatusV2),
                        _projTransPostingParams,
                        token);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPWPReadyForPayment</Name>
				<Source><![CDATA[
    public static boolean isPWPReadyForPayment(ProjTransType _TransType,
                                                ProjTransIdBase _projTransId,
                                                ProjId _projId,
                                                VendAccount _vendAccount)
    {
        return ProjPayWhenPaidStatusCheck::isPWPReadyForPayment(_TransType, _projTransId, _projId, _vendAccount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaymSchedId</Name>
				<Source><![CDATA[
    /// <summary>
    /// sets the payment scheduled id for the respective cust/vend trans record.
    /// </summary>
    /// <param name="_custVendTrans">
    /// cust/vend record.
    /// </param>
    /// <param name="_paymSchedId">
    /// payment schedule Id.
    /// </param>
    protected void setPaymSchedId(CustVendTrans _custVendTrans, PaymSchedId _paymSchedId)
    {
        CustTrans custTrans = _custVendTrans;
        custTrans.PaymSchedId = _paymSchedId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundedOffAmount</Name>
				<Source><![CDATA[
    protected AmountCur roundedOffAmount(AmountCur _amount)
    {
        return CurrencyExchange::roundWithRuleType(
            _amount,
            this.parmCurrencyCode(),
            CurrencyRoundingRuleType::SalesOrder);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymentMode</Name>
				<Source><![CDATA[
    private PaymMode getPaymentMode()
    {
        PaymMode paymentMode = paymMode;

        switch (common.TableId)
        {
            case tableNum(CustInvoiceTable):
                CustInvoiceTable custInvoiceTable = common;

                if (custInvoiceTable.PaymMode)
                {
                    paymentMode = custInvoiceTable.PaymMode;
                }
                break;

            case tableNum(SalesTable):
                SalesTable salesTable = common;

                if (salesTable.PaymMode)
                {
                    paymentMode = salesTable.PaymMode;
                }
                break;
        }

        return paymentMode;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>