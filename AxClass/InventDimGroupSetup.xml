<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventDimGroupSetup</Name>
	<SourceCode>
		<Declaration><![CDATA[
class InventDimGroupSetup extends EcoResDimensionGroupSetup
{
    // <GEERU>
    #isoCountryRegionCodes
    // </GEERU>

    EcoResProductDimensionGroupRecId        productDimensionGroup;
    EcoResProductDimGroupSetup              ecoResProductDimGroupSetup;

    EcoResStorageDimensionGroupRecId        storageDimensionGroup;
    EcoResStorageDimGroupSetup              ecoResStorageDimGroupSetup;

    EcoResTrackingDimensionGroupRecId       trackingDimensionGroup;
    EcoResTrackingDimGroupSetup             ecoResTrackingDimGroupSetup;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>activeConsistentFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are active and are marked as consistent.
    /// </summary>
    /// <returns>
    ///    A list that contains IDs of the <c>InventDim</c> fields that fulfill the condition.
    /// </returns>
    public List activeConsistentFields()
    {
        InventDimParm   inventDimParm;

        this.inventDimParmActiveConsistent(inventDimParm);
        return inventDimParm.selectedDimFields();
    }

]]></Source>
			</Method>
			<Method>
				<Name>activeCoveragePlanFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are active and marked as being part of the coverage
    ///    plan setup.
    /// </summary>
    /// <returns>
    ///    A list that contains IDs of the <c>InventDim</c> fields that fulfill the condition.
    /// </returns>
    public List activeCoveragePlanFields()
    {
        InventDimParm   inventDimParm;

        this.inventDimParmActiveCoveragePlan(inventDimParm);
        return inventDimParm.selectedDimFields();
    }

]]></Source>
			</Method>
			<Method>
				<Name>activeFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are active.
    /// </summary>
    /// <returns>
    ///    A list that contains the IDs of dimensions from the <c>InventDim</c> fields that fulfill the
    ///    condition.
    /// </returns>
    public List activeFields()
    {
        InventDimParm   inventDimParm;

        this.inventDimParmActive(inventDimParm);
        return inventDimParm.selectedDimFields();
    }

]]></Source>
			</Method>
			<Method>
				<Name>activeFinancialInventoryFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are active and are marked as part of the financial
    ///    inventory.
    /// </summary>
    /// <returns>
    ///    A list that contains IDs of <c>InventDim</c> fields that fulfill the condition.
    /// </returns>
    public List activeFinancialInventoryFields()
    {
        InventDimParm   inventDimParm;

        this.inventDimParmActiveFinancialInventory(inventDimParm);
        return inventDimParm.selectedDimFields();
    }

]]></Source>
			</Method>
			<Method>
				<Name>activeMandatoryFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are active and marked as a mandatory field.
    /// </summary>
    /// <returns>
    ///    A list that contains IDs of <c>InventDim</c> fields that fulfill the condition.
    /// </returns>
    public List activeMandatoryFields()
    {
        InventDimParm   inventDimParm;

        this.inventDimParmActiveMandatory(inventDimParm);
        return inventDimParm.selectedDimFields();
    }

]]></Source>
			</Method>
			<Method>
				<Name>activeOrSalesProcessActiveFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are either active or sales process active.
    /// </summary>
    /// <returns>
    ///    A list that contains the IDs of dimensions from the <c>InventDim</c> fields that fulfill the
    ///    condition.
    /// </returns>
    public List activeOrSalesProcessActiveFields()
    {
        InventDimParm   inventDimParm;

        this.inventDimParmActive(inventDimParm);
        inventDimParm = InventDimParm::orParms(inventDimParm, EcoResTrackingDimGroupSetupCache::salesProcessActivated(trackingDimensionGroup));

        return inventDimParm.selectedDimFields();
    }

]]></Source>
			</Method>
			<Method>
				<Name>activePhysicalInventoryFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are active and marked as part of physical inventory.
    /// </summary>
    /// <returns>
    ///    A list that contains IDs of dimensions, from the <c>InventDim</c> table, that fulfill the condition.
    /// </returns>
    public List activePhysicalInventoryFields()
    {
        InventDimParm   inventDimParm;

        this.inventDimParmActivePhysicalInventory(inventDimParm);
        return inventDimParm.selectedDimFields();
    }

]]></Source>
			</Method>
			<Method>
				<Name>activePrimaryStockingFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are active and marked as primary stocking.
    /// </summary>
    /// <returns>
    ///    A list that contains IDs of <c>InventDim</c> fields that fulfill the condition.
    /// </returns>
    public List activePrimaryStockingFields()
    {
        InventDimParm   inventDimParm;

        this.inventDimParmActivePrimaryDimension(inventDimParm);
        return inventDimParm.selectedDimFields();
    }

]]></Source>
			</Method>
			<Method>
				<Name>activePurchPriceFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are active and marked as used by the purchase price
    ///    search.
    /// </summary>
    /// <returns>
    ///    A list that contains IDs of dimensions, from the <c>InventDim</c> table, that fulfills the
    ///    condition.
    /// </returns>
    public List activePurchPriceFields()
    {
        InventDimParm   inventDimParm;

        this.inventDimParmActivePurchPrice(inventDimParm);
        return inventDimParm.selectedDimFields();
    }

]]></Source>
			</Method>
			<Method>
				<Name>activeSalesPriceFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are active and marked as used by the sales price
    ///    search.
    /// </summary>
    /// <returns>
    ///    A list that contains IDs of dimensions, from the <c>InventDim</c> table, that fulfill the condition.
    /// </returns>
    public List activeSalesPriceFields()
    {
        InventDimParm   inventDimParm;

        this.inventDimParmActiveSalesPrice(inventDimParm);
        return inventDimParm.selectedDimFields();
    }

]]></Source>
			</Method>
			<Method>
				<Name>ecoResProductDimGroupSetup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves an instance of the <c>EcoResProductDimGroupSetup</c> class for the product dimensions.
    /// </summary>
    /// <returns>
    ///    An instance of the <c>EcoResProductDimGroupSetup</c> class.
    /// </returns>
    public EcoResProductDimGroupSetup ecoResProductDimGroupSetup()
    {
        if (!ecoResProductDimGroupSetup)
        {
            ecoResProductDimGroupSetup = EcoResProductDimGroupSetup::newDimensionGroup(productDimensionGroup);
        }
        return ecoResProductDimGroupSetup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFieldSetup</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds a dimension setup record in the cache.
    /// </summary>
    /// <param name="_dimensionFieldId">
    ///    Specifies a dimension field ID for which record is to be found.
    /// </param>
    /// <returns>
    ///    An instance of the <c>InventDimGroupFieldSetup</c> class.
    /// </returns>
    /// <remarks>
    ///    When a dimension setup record in the cache is found, a matching <c>InventdimGroupFieldSetup</c>
    ///    instance is initialized and returned with the found buffer.The instance of the
    ///    <c>InventDimGroupFieldSetup</c> class that is returned is never null, but may not have a dimension
    ///    field ID.
    /// </remarks>
    public InventDimGroupFieldSetup getFieldSetup(FieldId _dimensionFieldId)
    {
        if (!_dimensionFieldId)
        {
            return InventDimGroupFieldSetup::newNoValidField();
        }

        if (InventDim::isFieldIdProductDimension(_dimensionFieldId))
        {
            return EcoResProductDimGroupSetupCache::getFieldSetup(productDimensionGroup, _dimensionFieldId);
        }
        else if (InventDim::isFieldIdStorageDimension(_dimensionFieldId))
        {
            return EcoResStorageDimGroupSetupCache::getFieldSetup(storageDimensionGroup, _dimensionFieldId);
        }
        else if (InventDim::isFieldIdTrackingDimension(_dimensionFieldId))
        {
            return EcoResTrackingDimGroupSetupCache::getFieldSetup(trackingDimensionGroup, _dimensionFieldId);
        }
        return InventDimGroupFieldSetup::newNoValidField();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFieldSetupEnumerator</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an enumerator to iterate over all dimension fields.
    /// </summary>
    /// <returns>
    ///    An instance of the <c>InventDimGroupFieldSetupEnumerator</c> class.
    /// </returns>
    public InventDimGroupFieldSetupEnumerator getFieldSetupEnumerator()
    {
        InventDimGroupFieldSetupEnumerator inventDimGroupFieldSetupEnumerator = InventDimGroupFieldSetupEnumerator::newFieldListAndDimGroups(
            InventDim::dimFieldListEnumerator(),
            productDimensionGroup,
            storageDimensionGroup,
            trackingDimensionGroup);

        return inventDimGroupFieldSetupEnumerator;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductDimensionGroup</Name>
				<Source><![CDATA[
    public EcoResProductDimensionGroupRecId  getProductDimensionGroup()
    {
        return productDimensionGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStorageDimensionGroup</Name>
				<Source><![CDATA[
    public EcoResStorageDimensionGroupRecId  getStorageDimensionGroup()
    {
        return storageDimensionGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTrackingDimensionGroup</Name>
				<Source><![CDATA[
    public EcoResTrackingDimensionGroupRecId  getTrackingDimensionGroup()
    {
        return trackingDimensionGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasAllCovDimFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if all the coverage planned dimensions are specified
    /// in an InventDim record.
    /// </summary>
    /// <param name="_inventDim">
    /// InventDim record to check.
    /// </param>
    /// <returns>
    /// True if all the coverage planned dimensions are specified in
    /// the given InventDim record; otherwise, false.
    /// </returns>
    public boolean hasAllCovDimFields(InventDim _inventDim)
    {
        ListEnumerator le = this.activeCoveragePlanFields().getEnumerator();

        while (le.moveNext())
        {
            FieldId fieldId = le.current();
            if (!_inventDim.(fieldId))
            {
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hashString</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a string that identifies the dimension groups that are covered by this instance.
    /// </summary>
    /// <returns>
    ///    A string.
    /// </returns>
    public str hashString()
    {
        return strFmt('%1#%2#%3', productDimensionGroup, storageDimensionGroup, trackingDimensionGroup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmActive</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are active.
    /// </summary>
    /// <param name="_inventDimParm">
    ///    Specifies a <c>InventDimParm</c> table buffer into which requested information is written.
    /// </param>
    public void inventDimParmActive(InventDimParm _inventDimParm)
    {
        InventDimParm   inventDimParmProduct;
        InventDimParm   inventDimParmStorage;
        InventDimParm   inventDimParmTracking;

        container cacheKey = [curext(), funcName(), productDimensionGroup, storageDimensionGroup, trackingDimensionGroup];
        SysGlobalObjectCache sgoc = classFactory.globalObjectCache();
        container result = sgoc.find(InventDimGroupSetup::classScope(), cacheKey);

        if (result == conNull())
        {
            if (productDimensionGroup)
            {
                inventDimParmProduct.data(EcoResProductDimGroupSetupCache::active(productDimensionGroup));
            }

            if (storageDimensionGroup)
            {
                inventDimParmStorage.data(EcoResStorageDimGroupSetupCache::active(storageDimensionGroup));
            }

            if (trackingDimensionGroup)
            {
                inventDimParmTracking.data(EcoResTrackingDimGroupSetupCache::active(trackingDimensionGroup));
            }

            result = buf2Con(InventDimGroupSetup::combineInventDimParms(inventDimParmProduct, inventDimParmStorage, inventDimParmTracking));
            sgoc.insert(InventDimGroupSetup::classScope(), cacheKey, result);
        }

        _inventDimParm.data(con2Buf(result));
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmActiveConsistent</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are active and consistent.
    /// </summary>
    /// <param name="_inventDimParm">
    ///    Specifies a <c>InventDimParm</c> buffer into which requested information is written.
    /// </param>
    public void inventDimParmActiveConsistent(InventDimParm _inventDimParm)
    {
        InventDimParm   inventDimParmProduct;
        InventDimParm   inventDimParmStorage;
        InventDimParm   inventDimParmTracking;

        if (!storageDimensionGroup || !trackingDimensionGroup)
        {
            _inventDimParm.clear();
            return;
        }

        container cacheKey = [curext(), funcName(), productDimensionGroup, storageDimensionGroup, trackingDimensionGroup];
        SysGlobalObjectCache sgoc = classFactory.globalObjectCache();
        container result = sgoc.find(InventDimGroupSetup::classScope(), cacheKey);

        if (result == conNull())
        {
            if (productDimensionGroup)
            {
                inventDimParmProduct.data(EcoResProductDimGroupSetupCache::consistent(productDimensionGroup));
            }

            if (storageDimensionGroup)
            {
                inventDimParmStorage.data(EcoResStorageDimGroupSetupCache::consistent(storageDimensionGroup));
            }

            if (trackingDimensionGroup)
            {
                inventDimParmTracking.data(EcoResTrackingDimGroupSetupCache::consistent(trackingDimensionGroup));
            }

            result = buf2Con(InventDimGroupSetup::combineInventDimParms(inventDimParmProduct, inventDimParmStorage, inventDimParmTracking));
            sgoc.insert(InventDimGroupSetup::classScope(), cacheKey, result);
        }

        _inventDimParm.data(con2Buf(result));
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmActiveCoveragePlan</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are active and are marked as part of coverage planning.
    /// </summary>
    /// <param name="_inventDimParm">
    ///    Specifies a <c>InventDimParm</c> buffer into which requested information is written.
    /// </param>
    public void inventDimParmActiveCoveragePlan(InventDimParm _inventDimParm)
    {
        InventDimParm   inventDimParmProduct;
        InventDimParm   inventDimParmStorage;
        InventDimParm   inventDimParmTracking;

        if (!storageDimensionGroup || !trackingDimensionGroup)
        {
            _inventDimParm.clear();
            return;
        }

        container cacheKey = [curext(), funcName(), productDimensionGroup, storageDimensionGroup, trackingDimensionGroup];
        SysGlobalObjectCache sgoc = classFactory.globalObjectCache();
        container result = sgoc.find(InventDimGroupSetup::classScope(), cacheKey);

        if (result == conNull())
        {
            if (productDimensionGroup)
            {
                inventDimParmProduct.data(EcoResProductDimGroupSetupCache::coveragePlanByDimensionEnabled(productDimensionGroup));
            }

            if (storageDimensionGroup)
            {
                inventDimParmStorage.data(EcoResStorageDimGroupSetupCache::coveragePlanByDimensionEnabled(storageDimensionGroup));
            }

            if (trackingDimensionGroup)
            {
                inventDimParmTracking.data(EcoResTrackingDimGroupSetupCache::coveragePlanByDimensionEnabled(trackingDimensionGroup));
            }

            result = buf2Con(InventDimGroupSetup::combineInventDimParms(inventDimParmProduct, inventDimParmStorage, inventDimParmTracking));
            sgoc.insert(InventDimGroupSetup::classScope(), cacheKey, result);
        }

        _inventDimParm.data(con2Buf(result));
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmActiveFinancialInventory</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are active and are marked as part of the financial
    ///    inventory.
    /// </summary>
    /// <param name="_inventDimParm">
    ///    Specifies a <c>InventDimParm</c> table buffer into which requested information is written.
    /// </param>
    public void inventDimParmActiveFinancialInventory(InventDimParm _inventDimParm)
    {
        InventDimParm   inventDimParmProduct;
        InventDimParm   inventDimParmStorage;
        InventDimParm   inventDimParmTracking;

        if (!storageDimensionGroup || !trackingDimensionGroup)
        {
            _inventDimParm.clear();
            return;
        }

        container cacheKey = [curext(), funcName(), productDimensionGroup, storageDimensionGroup, trackingDimensionGroup];
        sysGlobalObjectCache sgoc = classFactory.globalObjectCache();
        container result = sgoc.find(InventDimGroupSetup::classScope(), cacheKey);

        if (result == conNull())
        {
            if (productDimensionGroup)
            {
                inventDimParmProduct.data(EcoResProductDimGroupSetupCache::financialInventoryEnabled(productDimensionGroup));
            }

            if (storageDimensionGroup)
            {
                inventDimParmStorage.data(EcoResStorageDimGroupSetupCache::financialInventoryEnabled(storageDimensionGroup));
            }

            if (trackingDimensionGroup)
            {
                inventDimParmTracking.data(EcoResTrackingDimGroupSetupCache::financialInventoryEnabled(trackingDimensionGroup));
            }

            result = buf2Con(InventDimGroupSetup::combineInventDimParms(inventDimParmProduct, inventDimParmStorage, inventDimParmTracking));
            sgoc.insert(InventDimGroupSetup::classScope(), cacheKey, result);
        }

        _inventDimParm.data(con2Buf(result));
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmActiveIssueNotBlank</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets information about which dimensions are active and where blank issue values are not allowed.
    /// </summary>
    /// <param name="_inventDimParm">
    /// Specifies an <c>InventDimParm</c> table buffer into which requested information is written.
    /// </param>
    public void inventDimParmActiveIssueNotBlank(InventDimParm _inventDimParm)
    {
        InventDimParm   inventDimParmProduct;
        InventDimParm   inventDimParmStorage;
        InventDimParm   inventDimParmTracking;

        container cacheKey = [curext(), funcName(), storageDimensionGroup, trackingDimensionGroup];
        sysGlobalObjectCache sgoc = classFactory.globalObjectCache();
        container result = sgoc.find(InventDimGroupSetup::classScope(), cacheKey);

        if (result == conNull())
        {
            if (storageDimensionGroup)
            {
                inventDimParmStorage.data(EcoResStorageDimGroupSetupCache::notAllowBlankIssue(storageDimensionGroup));
            }

            if (trackingDimensionGroup)
            {
                inventDimParmTracking.data(EcoResTrackingDimGroupSetupCache::notAllowBlankIssue(trackingDimensionGroup));
            }

            result = buf2Con(InventDimGroupSetup::combineInventDimParms(inventDimParmProduct, inventDimParmStorage, inventDimParmTracking));
            sgoc.insert(InventDimGroupSetup::classScope(), cacheKey, result);
        }

        _inventDimParm.data(con2Buf(result));
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmActiveMandatory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves information about which dimensions are active and mandatory.
    /// </summary>
    /// <param name="_inventDimParm">
    /// Specifies an <c>InventDimParm</c> buffer into which requested information is written.
    /// </param>
    public void inventDimParmActiveMandatory(InventDimParm _inventDimParm)
    {
        InventDimParm   inventDimParmProduct;
        InventDimParm   inventDimParmStorage;
        InventDimParm   inventDimParmTracking;

        if (!storageDimensionGroup || !trackingDimensionGroup)
        {
            _inventDimParm.clear();
            return;
        }

        container cacheKey = [curext(), funcName(), productDimensionGroup, storageDimensionGroup, trackingDimensionGroup];
        sysGlobalObjectCache sgoc = classFactory.globalObjectCache();
        container result = sgoc.find(InventDimGroupSetup::classScope(), cacheKey);

        if (result == conNull())
        {
            if (productDimensionGroup)
            {
                inventDimParmProduct.data(EcoResProductDimGroupSetupCache::mandatory(productDimensionGroup));
            }

            if (storageDimensionGroup)
            {
                inventDimParmStorage.data(EcoResStorageDimGroupSetupCache::mandatory(storageDimensionGroup));
            }

            if (trackingDimensionGroup)
            {
                inventDimParmTracking.data(EcoResTrackingDimGroupSetupCache::mandatory(trackingDimensionGroup));
            }

            result = buf2Con(InventDimGroupSetup::combineInventDimParms(inventDimParmProduct, inventDimParmStorage, inventDimParmTracking));
            sgoc.insert(InventDimGroupSetup::classScope(), cacheKey, result);
        }

        _inventDimParm.data(con2Buf(result));
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmActiveOnlyPhysicalInventory</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves information about which dimensions are active and are only marked as part of the physical
    ///     inventory excluding those marked as both financial and physical.
    /// </summary>
    /// <param name = "_inventDimParm">
    ///     Specifies a <c>InventDimParm</c> table buffer into which requested information is written.
    /// </param>
    public void inventDimParmActiveOnlyPhysicalInventory(InventDimParm _inventDimParm)
    {
        InventDimParm   financiallyActiveDimParm;

        this.inventDimParmActiveFinancialInventory(financiallyActiveDimParm);
        this.inventDimParmActivePhysicalInventory(_inventDimParm);

        ListEnumerator enumerator = financiallyActiveDimParm.selectedDimFields().getEnumerator();
        while (enumerator.moveNext())
        {
            FieldId dimParmFieldId = InventDim::dim2dimParm(enumerator.current());
            if (_inventDimParm.(dimParmFieldId) == NoYes::Yes)
            {
                _inventDimParm.(dimParmFieldId) = NoYes::No;
            }
        }
        _inventDimParm.write();
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmActivePhysicalInventory</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are active and are marked as part of the physical
    ///    inventory.
    /// </summary>
    /// <param name="_inventDimParm">
    ///    Specifies a <c>InventDimParm</c> table buffer into which requested information is written.
    /// </param>
    public void inventDimParmActivePhysicalInventory(InventDimParm _inventDimParm)
    {
        InventDimParm   inventDimParmProduct;
        InventDimParm   inventDimParmStorage;
        InventDimParm   inventDimParmTracking;

        if (!storageDimensionGroup || !trackingDimensionGroup)
        {
            _inventDimParm.clear();
            return;
        }

        container cacheKey = [curext(), funcName(), productDimensionGroup, storageDimensionGroup, trackingDimensionGroup];
        sysGlobalObjectCache sgoc = classFactory.globalObjectCache();
        container result = sgoc.find(InventDimGroupSetup::classScope(), cacheKey);

        if (result == conNull())
        {
            if (productDimensionGroup)
            {
                inventDimParmProduct.data(EcoResProductDimGroupSetupCache::physicalInventoryEnabled(productDimensionGroup));
            }

            if (storageDimensionGroup)
            {
                inventDimParmStorage.data(EcoResStorageDimGroupSetupCache::physicalInventoryEnabled(storageDimensionGroup));
            }

            if (trackingDimensionGroup)
            {
                inventDimParmTracking.data(EcoResTrackingDimGroupSetupCache::physicalInventoryEnabled(trackingDimensionGroup));
            }

            result = buf2Con(InventDimGroupSetup::combineInventDimParms(inventDimParmProduct, inventDimParmStorage, inventDimParmTracking));
            sgoc.insert(InventDimGroupSetup::classScope(), cacheKey, result);
        }

        _inventDimParm.data(con2Buf(result));
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmActivePrimaryDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are active and are marked as primary stocking fields.
    /// </summary>
    /// <param name="_inventDimParm">
    ///    Specifies a <c>InventDimParm</c> table buffer into which requested information is written.
    /// </param>
    public void inventDimParmActivePrimaryDimension(InventDimParm _inventDimParm)
    {
        InventDimParm   inventDimParmProduct;
        InventDimParm   inventDimParmStorage;
        InventDimParm   inventDimParmTracking;

        if (!storageDimensionGroup || !trackingDimensionGroup)
        {
            _inventDimParm.clear();
            return;
        }

        container cacheKey = [curext(), funcName(), productDimensionGroup, storageDimensionGroup, trackingDimensionGroup];
        sysGlobalObjectCache sgoc = classFactory.globalObjectCache();
        container result = sgoc.find(InventDimGroupSetup::classScope(), cacheKey);

        if (result == conNull())
        {
            if (productDimensionGroup)
            {
                inventDimParmProduct.data(EcoResProductDimGroupSetupCache::primaryStockingEnabled(productDimensionGroup));
            }

            if (storageDimensionGroup)
            {
                inventDimParmStorage.data(EcoResStorageDimGroupSetupCache::primaryStockingEnabled(storageDimensionGroup));
            }

            if (trackingDimensionGroup)
            {
                inventDimParmTracking.data(EcoResTrackingDimGroupSetupCache::primaryStockingEnabled(trackingDimensionGroup));
            }

            result = buf2Con(InventDimGroupSetup::combineInventDimParms(inventDimParmProduct, inventDimParmStorage, inventDimParmTracking));
            sgoc.insert(InventDimGroupSetup::classScope(), cacheKey, result);
        }

        _inventDimParm.data(con2Buf(result));
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmActiveProductDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are active product dimensions.
    /// </summary>
    /// <param name="_inventDimParm">
    ///    Specifies a <c>InventDimParm</c> buffer into which requested information is written.
    /// </param>
    public void inventDimParmActiveProductDimension(InventDimParm _inventDimParm)
    {
        if (!productDimensionGroup)
        {
            _inventDimParm.clear();
            return;
        }

        _inventDimParm.data(EcoResProductDimGroupSetupCache::active(productDimensionGroup));
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmActivePurchPrice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are active and marked as part of purchase price search.
    /// </summary>
    /// <param name="_inventDimParm">
    ///    Specifies a <c>InventDimParm</c> buffer into which requested information is written.
    /// </param>
    public void inventDimParmActivePurchPrice(InventDimParm _inventDimParm)
    {
        InventDimParm   inventDimParmProduct;
        InventDimParm   inventDimParmStorage;
        InventDimParm   inventDimParmTracking;

        if (!storageDimensionGroup || !trackingDimensionGroup)
        {
            _inventDimParm.clear();
            return;
        }

        container cacheKey = [curext(), funcName(), productDimensionGroup, storageDimensionGroup, trackingDimensionGroup];
        sysGlobalObjectCache sgoc = classFactory.globalObjectCache();
        container result = sgoc.find(InventDimGroupSetup::classScope(), cacheKey);

        if (result == conNull())
        {
            if (productDimensionGroup)
            {
                inventDimParmProduct.data(EcoResProductDimGroupSetupCache::purchPriceSearchEnabled(productDimensionGroup));
            }

            if (storageDimensionGroup)
            {
                inventDimParmStorage.data(EcoResStorageDimGroupSetupCache::purchPriceSearchEnabled(storageDimensionGroup));
            }

            if (trackingDimensionGroup)
            {
                inventDimParmTracking.data(EcoResTrackingDimGroupSetupCache::purchPriceSearchEnabled(trackingDimensionGroup));
            }

            result = buf2Con(InventDimGroupSetup::combineInventDimParms(inventDimParmProduct, inventDimParmStorage, inventDimParmTracking));
            sgoc.insert(InventDimGroupSetup::classScope(), cacheKey, result);
        }

        _inventDimParm.data(con2Buf(result));
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmActivePurchPriceProductDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which product dimensions are active and marked as part of purchase
    ///    price search.
    /// </summary>
    /// <param name="_inventDimParm">
    ///    Specifies a <c>InventDimParm</c> buffer into which requested information is written.
    /// </param>
    public void inventDimParmActivePurchPriceProductDim(InventDimParm _inventDimParm)
    {
        if (!productDimensionGroup)
        {
            _inventDimParm.clear();
            return;
        }

        _inventDimParm.data(EcoResProductDimGroupSetupCache::purchPriceSearchEnabled(productDimensionGroup));
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmActiveReceiptNotBlank</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets information about which dimensions are active and where blank receipt values are not allowed.
    /// </summary>
    /// <param name="_inventDimParm">
    /// Specifies an <c>InventDimParm</c> table buffer into which requested information is written.
    /// </param>
    public void inventDimParmActiveReceiptNotBlank(InventDimParm _inventDimParm)
    {
        InventDimParm   inventDimParmProduct;
        InventDimParm   inventDimParmStorage;
        InventDimParm   inventDimParmTracking;

        container cacheKey = [curext(), funcName(), storageDimensionGroup, trackingDimensionGroup];
        sysGlobalObjectCache sgoc = classFactory.globalObjectCache();
        container result = sgoc.find(InventDimGroupSetup::classScope(), cacheKey);

        if (result == conNull())
        {
            if (storageDimensionGroup)
            {
                inventDimParmStorage.data(EcoResStorageDimGroupSetupCache::notAllowBlankReceipt(storageDimensionGroup));
            }

            if (trackingDimensionGroup)
            {
                inventDimParmTracking.data(EcoResTrackingDimGroupSetupCache::notAllowBlankReceipt(trackingDimensionGroup));
            }

            result = buf2Con(InventDimGroupSetup::combineInventDimParms(inventDimParmProduct, inventDimParmStorage, inventDimParmTracking));
            sgoc.insert(InventDimGroupSetup::classScope(), cacheKey, result);
        }

        _inventDimParm.data(con2Buf(result));
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmActiveSalesPrice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are active and marked as part of sales price search.
    /// </summary>
    /// <param name="_inventDimParm">
    ///    Specifies a <c>InventDimParm</c> buffer into which requested information is written.
    /// </param>
    public void inventDimParmActiveSalesPrice(InventDimParm _inventDimParm)
    {
        InventDimParm   inventDimParmProduct;
        InventDimParm   inventDimParmStorage;
        InventDimParm   inventDimParmTracking;

        if (!storageDimensionGroup || !trackingDimensionGroup)
        {
            _inventDimParm.clear();
            return;
        }

        container cacheKey = [curext(), funcName(), productDimensionGroup, storageDimensionGroup, trackingDimensionGroup];
        sysGlobalObjectCache sgoc = classFactory.globalObjectCache();
        container result = sgoc.find(InventDimGroupSetup::classScope(), cacheKey);

        if (result == conNull())
        {
            if (productDimensionGroup)
            {
                inventDimParmProduct.data(EcoResProductDimGroupSetupCache::salesPriceSearchEnabled(productDimensionGroup));
            }

            if (storageDimensionGroup)
            {
                inventDimParmStorage.data(EcoResStorageDimGroupSetupCache::salesPriceSearchEnabled(storageDimensionGroup));
            }

            if (trackingDimensionGroup)
            {
                inventDimParmTracking.data(EcoResTrackingDimGroupSetupCache::salesPriceSearchEnabled(trackingDimensionGroup));
            }

            result = buf2Con(InventDimGroupSetup::combineInventDimParms(inventDimParmProduct, inventDimParmStorage, inventDimParmTracking));
            sgoc.insert(InventDimGroupSetup::classScope(), cacheKey, result);
        }

        _inventDimParm.data(con2Buf(result));
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmActiveSalesPriceProductDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which product dimensions are active and marked as part of sales price
    ///    search.
    /// </summary>
    /// <param name="_inventDimParm">
    ///    Specifies a <c>InventDimParm</c> buffer into which requested information is written.
    /// </param>
    public void inventDimParmActiveSalesPriceProductDim(InventDimParm _inventDimParm)
    {
        if (!productDimensionGroup)
        {
            _inventDimParm.clear();
            return;
        }

        _inventDimParm.data(EcoResProductDimGroupSetupCache::salesPriceSearchEnabled(productDimensionGroup));
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmPrimaryNotProductDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which non-product dimensions are active and are marked as primary
    ///    stocking.
    /// </summary>
    /// <param name="_inventDimParm">
    ///    Specifies a <c>InventDimParm</c> buffer into which requested information is written.
    /// </param>
    public void inventDimParmPrimaryNotProductDim(InventDimParm _inventDimParm)
    {
        InventDimParm   inventDimParmProduct;
        InventDimParm   inventDimParmStorage;
        InventDimParm   inventDimParmTracking;

        if (!storageDimensionGroup || !trackingDimensionGroup)
        {
            _inventDimParm.clear();
            return;
        }

        container cacheKey = [curext(), funcName(), storageDimensionGroup, trackingDimensionGroup];
        sysGlobalObjectCache sgoc = classFactory.globalObjectCache();
        container result = sgoc.find(InventDimGroupSetup::classScope(), cacheKey);

        if (result == conNull())
        {
            if (storageDimensionGroup)
            {
                inventDimParmStorage.data(EcoResStorageDimGroupSetupCache::primaryStockingEnabled(storageDimensionGroup));
            }

            if (trackingDimensionGroup)
            {
                inventDimParmTracking.data(EcoResTrackingDimGroupSetupCache::primaryStockingEnabled(trackingDimensionGroup));
            }

            result = buf2Con(InventDimGroupSetup::combineInventDimParms(inventDimParmProduct, inventDimParmStorage, inventDimParmTracking));
            sgoc.insert(InventDimGroupSetup::classScope(), cacheKey, result);
        }

        _inventDimParm.data(con2Buf(result));
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmSalesActiveIssueNotBlank</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets information about which dimensions are sales process active and where blank issue values are not allowed.
    /// </summary>
    /// <param name="_inventDimParm">
    /// Specifies an <c>InventDimParm</c> table buffer into which requested information is written.
    /// </param>
    public void inventDimParmSalesActiveIssueNotBlank(InventDimParm _inventDimParm)
    {
        _inventDimParm.data(EcoResTrackingDimGroupSetupCache::salesProcessActivatedNotAllowBlankIssue(trackingDimensionGroup));
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmSalesProcessActive</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are sales process active.
    /// </summary>
    /// <param name="_inventDimParm">
    ///    Specifies a <c>InventDimParm</c> table buffer into which requested information is written.
    /// </param>
    public void inventDimParmSalesProcessActive(InventDimParm _inventDimParm)
    {
        _inventDimParm.data(EcoResTrackingDimGroupSetupCache::salesProcessActivated(trackingDimensionGroup));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDimensionActive</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the specified dimension setup is valid and active.
    /// </summary>
    /// <param name="_dimensionFieldId">
    ///    Specifies a dimension field ID for the record that is to be found.
    /// </param>
    /// <returns>
    ///    true if the dimension is valid and active; otherwise, false.
    /// </returns>
    public boolean isDimensionActive(FieldId _dimensionFieldId)
    {
        InventDimGroupFieldSetup            inventDimGroupFieldSetup = this.getFieldSetup(_dimensionFieldId);

        return inventDimGroupFieldSetup.isActive();
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProductDimensionGroup</Name>
				<Source><![CDATA[
    protected EcoResProductDimensionGroupRecId  parmProductDimensionGroup(EcoResProductDimensionGroupRecId  _productDimensionGroup = productDimensionGroup)
    {
        productDimensionGroup = _productDimensionGroup;

        return productDimensionGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmStorageDimensionGroup</Name>
				<Source><![CDATA[
    protected EcoResStorageDimensionGroupRecId  parmStorageDimensionGroup(EcoResStorageDimensionGroupRecId  _storageDimensionGroup = storageDimensionGroup)
    {
        storageDimensionGroup = _storageDimensionGroup;

        return storageDimensionGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTrackingDimensionGroup</Name>
				<Source><![CDATA[
    protected EcoResTrackingDimensionGroupRecId  parmTrackingDimensionGroup(EcoResTrackingDimensionGroupRecId  _trackingDimensionGroup = trackingDimensionGroup)
    {
        trackingDimensionGroup = _trackingDimensionGroup;

        return trackingDimensionGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prefixString</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a string that can be used by users to uniquely identify the dimension groups that are
    ///    covered by this instance.
    /// </summary>
    /// <returns>
    ///    A string.
    /// </returns>
    public str prefixString()
    {
        return strFmt("@SYS313145",
            EcoResProductDimensionGroup::find(productDimensionGroup).Name,
            EcoResStorageDimensionGroup::find(storageDimensionGroup).Name,
            EcoResTrackingDimensionGroup::find(trackingDimensionGroup).Name);
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesProcessActiveFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves information about which dimensions are sales process active.
    /// </summary>
    /// <returns>
    ///    A list that contains the IDs of dimensions from the <c>InventDim</c> fields that fulfill the
    ///    condition.
    /// </returns>
    public List salesProcessActiveFields()
    {
        InventDimParm inventDimParm = EcoResTrackingDimGroupSetupCache::salesProcessActivated(trackingDimensionGroup);

        return inventDimParm.selectedDimFields();
    }

]]></Source>
			</Method>
			<Method>
				<Name>classScope</Name>
				<Source><![CDATA[
    private static GlobalObjectCacheScope classScope()
    {
        return classStr(EcoResProductDimGroupSetupCache);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears global object cache for this class's scope.
    /// </summary>
    public static void clearCache()
    {
        classFactory.globalObjectCache().clear(InventDimGroupSetup::classScope());
    }

]]></Source>
			</Method>
			<Method>
				<Name>combineInventDimParms</Name>
				<Source><![CDATA[
    /// <summary>
    /// Combines information from a product dimension group, a storage dimension group and a tracking
    /// dimension group.
    /// </summary>
    /// <param name="_inventDimParmProduct">
    /// The information related to the product dimension group.
    /// </param>
    /// <param name="_inventDimParmStorage">
    /// The information related to the storage dimension group.
    /// </param>
    /// <param name="_inventDimParmTracking">
    /// The information related to the tracking dimension group.
    /// </param>
    /// <returns>
    /// An <c>InventDimParm</c> table buffer that contains the combined information.
    /// </returns>
    [Hookable(false), Wrappable(false)]
    static public InventDimParm combineInventDimParms(
        InventDimParm   _inventDimParmProduct,
        InventDimParm   _inventDimParmStorage,
        InventDimParm   _inventDimParmTracking)
    {
        InventDimParm   inventDimParm;

        InventDimensionEnumerator productDims = InventProductDimension::getEnumeratorForEnabledDimensions();
        while (productDims.moveNext())
        {
            FieldId fieldId = productDims.currentInventDimParmFieldId();
            inventDimParm.(fieldId) = _inventDimParmProduct.(fieldId);
        }

        Enumerator trackingDims = InventDim::dimTrackingDimFieldList().getEnumerator();
        while (trackingDims.moveNext())
        {
            FieldId dimParmFieldId = InventDim::dim2dimParm(trackingDims.current());
            inventDimParm.(dimParmFieldId) = _inventDimParmTracking.(dimParmFieldId);
        }

        Enumerator storageDims = InventDim::dimStorageDimFieldList().getEnumerator();
        while (storageDims.moveNext())
        {
            FieldId dimParmFieldId = InventDim::dim2dimParm(storageDims.current());
            inventDimParm.(dimParmFieldId) = _inventDimParmStorage.(dimParmFieldId);
        }

        inventDimParm.ItemIdFlag = (_inventDimParmProduct.ItemIdFlag || _inventDimParmStorage.ItemIdFlag || _inventDimParmTracking.ItemIdFlag) ? NoYes::Yes : NoYes::No;

        return inventDimParm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static InventDimGroupSetup construct()
    {
        return new InventDimGroupSetup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>flushDataCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Flushes all data caches that are related to the dimension group setup.
    /// </summary>
    static public void flushDataCache()
    {
        EcoResProductDimGroupSetupCache::clearCache();
        EcoResStorageDimGroupSetupCache::clearCache();
        EcoResTrackingDimGroupSetupCache::clearCache();
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmInitAllConsistentDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets information about which dimensions are consistent.
    /// </summary>
    /// <param name="_inventDimParmInitAllConsistentDim">
    ///    The <c>InventDimParm</c> buffer with fields set to the <c>NoYes::Yes</c> enumeration value for the
    ///    return for consistent dimensions.
    /// </param>
    /// <remarks>
    ///    Information is gathered from all dimension groups in the system. It is enough that a dimension is
    ///    active and consistent in just one dimension group to be returned as consistent.
    /// </remarks>
    static public void inventDimParmInitAllConsistentDim(InventDimParm _inventDimParmInitAllConsistentDim)
    {
        InventDimParm   inventDimParmProduct;
        InventDimParm   inventDimParmStorage;
        InventDimParm   inventDimParmTracking;

        EcoResProductDimGroupSetupCache::inventDimParmInitAllActiveDim(inventDimParmProduct);
        EcoResStorageDimGroupSetupCache::inventDimParmInitAllConsistentDim(inventDimParmStorage);
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            EcoResTrackingDimGroupSetupCache::inventDimParmInitAllConsistentDim_RU(inventDimParmTracking);
        }
        // </GEERU>

        _inventDimParmInitAllConsistentDim.data(InventDimGroupSetup::combineInventDimParms(inventDimParmProduct, inventDimParmStorage, inventDimParmTracking));
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmInitAllCoverageDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets information about which dimensions are marked as coverage dimensions.
    /// </summary>
    /// <param name="_inventDimParmInitAllCovDim">
    ///    The <c>InventDimParm</c> buffer with fields set to the <c>NoYes::Yes</c> enumeration value for the
    ///    return for dimensions with the <c>CovPrDimension</c> field enabled.
    /// </param>
    /// <remarks>
    ///    Information is gathered from all dimension groups in the system. It is enough that a dimension is
    ///    active and marked as coverage dimension in just one dimension group to be returned as coverage
    ///    dimension.
    /// </remarks>
    static public void inventDimParmInitAllCoverageDim(InventDimParm _inventDimParmInitAllCovDim)
    {
        InventDimParm   inventDimParmProduct;
        InventDimParm   inventDimParmStorage;
        InventDimParm   inventDimParmTracking;

        EcoResProductDimGroupSetupCache::inventDimParmInitAllActiveDim(inventDimParmProduct);
        EcoResStorageDimGroupSetupCache::inventDimParmInitAllCovDim(inventDimParmStorage);
        EcoResTrackingDimGroupSetupCache::inventDimParmInitAllCovDim(inventDimParmTracking);

        _inventDimParmInitAllCovDim.data(InventDimGroupSetup::combineInventDimParms(inventDimParmProduct, inventDimParmStorage, inventDimParmTracking));
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmInitAllMandatoryDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets information about which dimensions are marked as mandatory.
    /// </summary>
    /// <param name="_inventDimParmInitAllMandatoryDim">
    ///    The <c>InventDimParm</c> buffer with fields set to the <c>NoYes::Yes</c> enumeration value for the
    ///    return for dimensions marked as mandatory.
    /// </param>
    /// <remarks>
    ///    Information is gathered from all dimension groups in the system. It is enough that a dimension is
    ///    active and marked as mandatory in just one dimension group to be returned as mandatory.
    /// </remarks>
    static public void inventDimParmInitAllMandatoryDim(InventDimParm _inventDimParmInitAllMandatoryDim)
    {
        InventDimParm   inventDimParmProduct;
        InventDimParm   inventDimParmStorage;
        InventDimParm   inventDimParmTracking;

        EcoResProductDimGroupSetupCache::inventDimParmInitAllActiveDim(inventDimParmProduct);
        EcoResStorageDimGroupSetupCache::inventDimParmInitAllMandatoryDim(inventDimParmStorage);
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            EcoResTrackingDimGroupSetupCache::inventDimParmInitAllMandatoryDim_RU(inventDimParmTracking);
        }
        // </GEERU>

        _inventDimParmInitAllMandatoryDim.data(InventDimGroupSetup::combineInventDimParms(inventDimParmProduct, inventDimParmStorage, inventDimParmTracking));
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmInitAllNonProductDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets information about which storage and tracking dimensions are active.
    /// </summary>
    /// <param name="_inventDimParmInitAllNonProductDim">
    /// An <c>InventDimParm</c> table buffer with fields set to <c>NoYes::Yes</c> upon return for active
    /// non-product dimensions.
    /// </param>
    static public void inventDimParmInitAllNonProductDim(InventDimParm _inventDimParmInitAllNonProductDim)
    {
        InventDimParm   inventDimParmProduct;
        InventDimParm   inventDimParmStorage;
        InventDimParm   inventDimParmTracking;

        EcoResStorageDimGroupSetupCache::inventDimParmInitAllActiveDim(inventDimParmStorage);
        EcoResTrackingDimGroupSetupCache::inventDimParmInitAllActiveDim(inventDimParmTracking);

        _inventDimParmInitAllNonProductDim.data(InventDimGroupSetup::combineInventDimParms(inventDimParmProduct, inventDimParmStorage, inventDimParmTracking));
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmInitAllPriceDiscDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets information about which dimensions are marked to be used in sales or purchase price search.
    /// </summary>
    /// <param name="_inventDimParmInitAllPriceDiscDim">
    /// The <c>InventDimParm</c> buffer with fields set to the <c>NoYes::Yes</c> enumeration value for the
    /// return for dimensions marked to be used in sales or purchase price search.
    /// </param>
    /// <remarks>
    /// Information is gathered from all dimension groups in the system. It is enough that a dimension is
    /// active and marked to be used in sales or purchase price search in just one dimension group to be
    /// returned as marked to be used in sales or purchase price search.
    /// </remarks>
    static public void inventDimParmInitAllPriceDiscDim(InventDimParm _inventDimParmInitAllPriceDiscDim)
    {
        InventDimParm   inventDimParmProduct;
        InventDimParm   inventDimParmStorage;
        InventDimParm   inventDimParmTracking;

        EcoResProductDimGroupSetupCache::inventDimParmInitAllPriceDiscDim(inventDimParmProduct);
        EcoResStorageDimGroupSetupCache::inventDimParmInitAllPriceDiscDim(inventDimParmStorage);
        EcoResTrackingDimGroupSetupCache::inventDimParmInitAllPriceDiscDim(inventDimParmTracking);

        _inventDimParmInitAllPriceDiscDim.data(InventDimGroupSetup::combineInventDimParms(inventDimParmProduct, inventDimParmStorage, inventDimParmTracking));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAnyTrackingGroupSalesProcessActive</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Queries whether any tracking dimension group has a sales process active dimension.
    /// </summary>
    /// <returns>
    ///    true if any tracking dimension group has a has a sales process active dimension; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Information is gathered from all tracking dimension groups in the system. It is enough that a
    ///    dimension is sales process active in at least one tracking dimension group.
    /// </remarks>
    static public boolean isAnyTrackingGroupSalesProcessActive()
    {
        return EcoResTrackingDimGroupSetupCache::isAnyTrackingGroupSalesProcessActive();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newDimensionGroups</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Creates an instance of the <c>InventDimGroupSetup</c> class which matches the specified dimension groups.
    /// </summary>
    /// <param name="_productDimensionGroup">
    ///  The product dimension group for which the instance is created.
    /// </param>
    /// <param name="_storageDimensionGroup">
    ///  The storage dimension group for which the instance is created.
    /// </param>
    /// <param name="_trackingDimensionGroup">
    ///  The tracking dimension group for which the instance is created.
    /// </param>
    /// <returns>
    ///   An <c>EcoResProductDimGroupSetup</c> instance.
    /// </returns>
    static public InventDimGroupSetup newDimensionGroups(
        EcoResProductDimensionGroupRecId    _productDimensionGroup,
        EcoResStorageDimensionGroupRecId    _storageDimensionGroup,
        EcoResTrackingDimensionGroupRecId   _trackingDimensionGroup)
    {
        InventDimGroupSetup     inventDimGroupSetup = InventDimGroupSetup::construct();

        inventDimGroupSetup.parmProductDimensionGroup(_productDimensionGroup);
        inventDimGroupSetup.parmStorageDimensionGroup(_storageDimensionGroup);
        inventDimGroupSetup.parmTrackingDimensionGroup(_trackingDimensionGroup);
        return inventDimGroupSetup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an instance of the <c>InventDimGroupSetup</c> class that matches the specified item.
    /// </summary>
    /// <param name="_inventTable">
    ///    The <c>InventTable</c> record for the item for which the instance is created.
    /// </param>
    /// <returns>
    ///    An instance of the <c>InventDimGroupSetup</c> class.
    /// </returns>
    static public InventDimGroupSetup newInventTable(InventTable  _inventTable)
    {
        EcoResProductDimensionGroupRecId    productDimensionGroup   = _inventTable.productDimensionGroup();
        EcoResStorageDimensionGroupRecId    storageDimensionGroup   = _inventTable.storageDimensionGroup();
        EcoResTrackingDimensionGroupRecId   trackingDimensionGroup  = _inventTable.trackingDimensionGroup();

        if (!_inventTable.ItemId)
        {
            return InventDimGroupSetup::newDimensionGroups(0, 0, 0);
        }

        if (!storageDimensionGroup || !trackingDimensionGroup)
        {
            throw error(strFmt("@SYS315358", _inventTable.ItemId));
        }

        return InventDimGroupSetup::newDimensionGroups(productDimensionGroup, storageDimensionGroup, trackingDimensionGroup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProduct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an instance of the <c>InventDimGroupSetup</c> class that matches the specified product.
    /// </summary>
    /// <param name="_product">
    ///    The RecId of the Product for which the instance is created.
    /// </param>
    /// <returns>
    ///    An instance of the <c>InventDimGroupSetup</c> class.
    /// </returns>
    static public InventDimGroupSetup newProduct(EcoResProductRecId _product)
    {
        if (!_product)
        {
            return InventDimGroupSetup::newDimensionGroups(0, 0, 0);
        }

        EcoResProductDimensionGroupRecId productDimensionGroup = EcoResProductDimensionGroupProduct::findByProduct(_product).ProductDimensionGroup;
        EcoResStorageDimensionGroupRecId storageDimensionGroup = EcoResStorageDimensionGroupProduct::findByProduct(_product).StorageDimensionGroup;
        EcoResTrackingDimensionGroupRecId trackingDimensionGroup = EcoResTrackingDimensionGroupProduct::findByProduct(_product).TrackingDimensionGroup;

        if (!storageDimensionGroup || !trackingDimensionGroup)
        {
            throw error(strFmt("@SYS315358", _product));
        }

        return InventDimGroupSetup::newDimensionGroups(productDimensionGroup, storageDimensionGroup, trackingDimensionGroup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventTableNoProductDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>InventDimGroupSetup</c> class which matches the specified item, but
    /// does not require a product dimension group to be specified.
    /// </summary>
    /// <param name="_inventTable">
    /// The item for which the instance is created.
    /// </param>
    /// <returns>
    /// An instance of the <c>InventDimGroupSetup</c> class.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The specified item ID does not specify a valid item.
    /// </exception>
    static public InventDimGroupSetup newInventTableNoProductDimensions(InventTable  _inventTable)
    {
        if (!_inventTable.ItemId)
        {
            return InventDimGroupSetup::newDimensionGroups(0, 0, 0);
        }

        EcoResStorageDimensionGroupRecId storageDimensionGroup = _inventTable.storageDimensionGroup();
        EcoResTrackingDimensionGroupRecId trackingDimensionGroup = _inventTable.trackingDimensionGroup();

        if (!storageDimensionGroup || !trackingDimensionGroup)
        {
            throw error(strFmt("@SYS315358", _inventTable.ItemId));
        }

        return InventDimGroupSetup::newDimensionGroups(0, storageDimensionGroup, trackingDimensionGroup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newItemId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an instance of the <c>InventDimGroupSetup</c> class which matches the specified item.
    /// </summary>
    /// <param name="_itemId">
    ///    The item for which the instance is created.
    /// </param>
    /// <returns>
    ///    An instance of the <c>InventDimGroupSetup</c> class.
    /// </returns>
    static public InventDimGroupSetup newItemId(ItemId  _itemId)
    {
        if (!_itemId)
        {
            return InventDimGroupSetup::newDimensionGroups(0, 0, 0);
        }

        InventTable inventTable = InventTable::find(_itemId);

        if (!inventTable)
        {
            throw error(strFmt(InventTable::txtNotExist(), _itemId));
        }

        return InventDimGroupSetup::newInventTable(inventTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newItemIdProductDimensionsOnly</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>InventDimGroupSetup</c> class which matches the specified item, but
    /// only uses and requires a product dimension group to be specified.
    /// </summary>
    /// <param name="_itemId">
    /// The ID of the item for which the instance is created.
    /// </param>
    /// <returns>
    /// An instance of the <c>InventDimGroupSetup</c> class.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The specified item ID does not specify a valid item.
    /// </exception>
    static public InventDimGroupSetup newItemIdProductDimensionsOnly(ItemId  _itemId)
    {
        if (!_itemId)
        {
            return InventDimGroupSetup::newDimensionGroups(0, 0, 0);
        }

        InventTable inventTable = InventTable::find(_itemId);

        if (!inventTable)
        {
            throw error(strFmt(InventTable::txtNotExist(), _itemId));
        }

        return InventDimGroupSetup::newDimensionGroups(inventTable.productDimensionGroup(), 0, 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newItemIdTrackingDimensionsOnly</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>InventDimGroupSetup</c> class which matches the specified item, but
    /// only uses and requires a tracking dimension group to be specified.
    /// </summary>
    /// <param name="_itemId">
    /// The ID of the item for which the instance is created.
    /// </param>
    /// <returns>
    /// An instance of the <c>InventDimGroupSetup</c> class.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The specified item ID does not specify a valid item.
    /// </exception>
    [Hookable(false)]
    static internal InventDimGroupSetup newItemIdTrackingDimensionsOnly(ItemId _itemId)
    {
        if (!_itemId)
        {
            return InventDimGroupSetup::newDimensionGroups(0, 0, 0);
        }

        InventTable inventTable = InventTable::find(_itemId);

        if (!inventTable)
        {
            throw error(strFmt(InventTable::txtNotExist(), _itemId));
        }

        return InventDimGroupSetup::newDimensionGroups(0, 0, inventTable.trackingDimensionGroup());
    }

]]></Source>
			</Method>
			<Method>
				<Name>newItemIdNoStorageDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>InventDimGroupSetup</c> class which matches the specified item id, but
    /// does not require a storage dimension group to be specified.
    /// </summary>
    /// <param name="_itemId">
    /// The item id for which the instance is created.
    /// </param>
    /// <returns>
    /// An instance of the <c>InventDimGroupSetup</c> class.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// The specified item ID does not specify a valid item.
    /// </exception>
    [Hookable(false)]
    static internal InventDimGroupSetup newItemIdNoStorageDimensions(ItemId _itemId)
    {
        if (!_itemId)
        {
            return InventDimGroupSetup::newDimensionGroups(0, 0, 0);
        }

        InventTable inventTable = InventTable::find(_itemId);

        if (!inventTable)
        {
            throw error(strFmt(InventTable::txtNotExist(), _itemId));
        }

        return InventDimGroupSetup::newDimensionGroups(inventTable.productDimensionGroup(), 0, inventTable.trackingDimensionGroup());
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>