<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>rTax25StdDocuments</Name>
	<SourceCode>
		<Declaration><![CDATA[
class rTax25StdDocuments
{
    Map                         docBuffer;
    MapIterator                 mapLoop;
    Set                         linesSet;
    Map                         transMap;
    boolean                     transEnable;

    Qty                         qty;
    Price                       price;
    Amount                      amount;
    Amount                      amountCur;
    AmountMST                   markupAmount;

    TableId                     tableId;
    RecId                       recId;
    TransDate                   docDate;
    NotesLine                   docName;

    NotesLine                   txt;
    PaymMode                    paymMode;
    Description                 paymModeName;
    ItemFreeTxtBase             itemName;
    LedgerTransType             mode;
    RAssetId                    assetId;
    TransDate                   transDate;

    GeneralJournalAccountEntry  accountEntry, offsetAccountEntry;
    GeneralJournalEntry         entry;

    SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
    LedgerVoucherReportDate_RU  ledgerVoucherReportDate;
    ReportingDate_RU            reportingDate;

    TmpRTax25LedgerAccountList  ledgerAccountList;
    DimensionAttribute          dimAttr;
    DimensionAttribute          mainAccountAttr;

    Markup                      markup;
    boolean                     allParm;
    RefRecId                    profitTableRecId;
    CurrencyCode                currencyCode;
    Voucher                     voucher;
    protected const date        AmountDiffCancelDate = 01\01\2015;

    #define.Separator(",")
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>amount</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public AmountMST amount()
    {
        return amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountCur</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public AmountMST amountCur()
    {
        return amountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetId</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public AssetId assetId()
    {
        return assetId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLineFromCustInvoice</Name>
				<Source><![CDATA[
    private void createLineFromCustInvoice(AmountCur        _amount,
                                           Qty              _qty,
                                           ItemFreeTxtBase  _itemName,
                                           RAssetId         _assetId,
                                           CustInvoiceJour  _custInvoiceJour,
                                           CustInvoiceTrans _custInvoiceTrans,
                                           boolean          _lret,
                                           TableId          _tableId = _custInvoiceTrans.TableId,
                                           RecId            _recId   = _custInvoiceTrans.RecId)
    {
        tableId = transEnable || _lret ? _tableId : _custInvoiceJour.TableId;
        recId   = transEnable || _lret ? _recId   : _custInvoiceJour.RecId;
    
        docDate = _custInvoiceJour.InvoiceDate;
        docName = _custInvoiceJour.InvoiceId ?
                  strFmt("@GLS103885",
                         "@SYS12128",
                         _custInvoiceJour.InvoiceId,
                         docDate)            :
                  "";
    
        currencyCode = _custInvoiceTrans.CurrencyCode;
        amountCur    = _amount;
        amount       = currencyCode                                       ?
                       CurrencyExchangeHelper::amountCur2MST(amountCur, currencyCode, _custInvoiceJour.ExchRate) :
                       amountCur;
    
        qty       = _qty;
        itemName  = _itemName;
    
        transDate = reportingDate;
    
        assetId   = _assetId;
    
        paymMode     = SalesTable::find(_custInvoiceTrans.SalesId).PaymMode;
        paymModeName = CustPaymModeTable::find(paymMode).Name;
        paymModeName = paymModeName ?  paymModeName : paymMode;
    
        if(allParm)
        {
            markup       = new Markup(currencyCode);
            markupAmount = markup.calcMarkupAmount_RU(_custInvoiceTrans, _qty, _amount);
            markupAmount = currencyCode                                          ?
                           CurrencyExchangeHelper::amountCur2MST(markupAmount, currencyCode, _custInvoiceTrans.exchRate()) :
                           markupAmount;
        }
    
        this.proposeDocument();
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyCode</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public CurrencyCode currencyCode()
    {
        return  currencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>docDate</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public TransDate docDate()
    {
        return docDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>docName</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public Name docName()
    {
        return docName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>docNameLedgerJournalTrans</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected Name docNameLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans)
    {
        return _ledgerJournalTrans.DocumentNum      ?
               strFmt("@GLS103885",
                      "@SYS11131",
                      _ledgerJournalTrans.DocumentNum,
                      docDate)                      :
               _ledgerJournalTrans.Txt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>docVoucher</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public Voucher docVoucher()
    {
        return voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an item name or a line description for the current document: invoices, GL journals.
    /// </summary>
    /// <returns>
    /// The item name or the line description.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public ItemFreeTxtBase itemName()
    {
        return itemName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadCashTrans</Name>
				<Source><![CDATA[
    private boolean loadCashTrans()
    {
        RCashTrans                          cashTrans;
        LedgerJournalTrans                  ledgerJournalTrans;
        LedgerJournalTrans_RCash            ledgerJournalTrans_RCash;
        MainAccount                         mainAccount, offsetMainAccount;
        Set                                 cashTransSet = new Set(Types::Int64);
        DimensionDefault                    glDefaultDimension;
        DimensionAttributeLevelValueView    dimAttrLevelValueView, offsetDimAttrLevelValueView;
        boolean                             ret;
    
        void processCashTrans()
        {
            if (glDefaultDimension && LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(cashTrans.LedgerDimension) != glDefaultDimension)
                return;
    
            if (linesSet.add([tableNum(RCashTrans),cashTrans.RecId]))
            {
                ret = true;
                ledgerJournalTrans = cashTrans.ledgerJournalTrans();
    
                if (! ledgerJournalTrans)
                {
                    select firstonly ledgerJournalTrans
                        where ledgerJournalTrans.Voucher         == cashTrans.Voucher        &&
                              ledgerJournalTrans.TransDate       == cashTrans.TransDate
                    exists join ledgerJournalTrans_RCash
                        where ledgerJournalTrans_RCash.RefRecId  == ledgerJournalTrans.RecId &&
                              ledgerJournalTrans_RCash.DocType   == cashTrans.DocType        &&
                              ledgerJournalTrans_RCash.CashDocId == cashTrans.DocId;
                }
    
                linesSet.add([tableNum(LedgerJournalTrans), ledgerJournalTrans.RecId]);
    
                tableId = cashTrans.TableId;
                recId   = cashTrans.RecId;
    
                docDate = reportingDate;
                docName = strFmt("@GLS223462",
                                 enum2str(cashTrans.DocType),
                                 cashTrans.DocId,
                                 docDate, cashTrans.PaymentNotes);
    
                currencyCode = cashTrans.CurrencyCode;
                amountCur    = cashTrans.AmountCur;
                amount       = cashTrans.AmountMST;
    
                txt          = cashTrans.Txt;
                transDate    = reportingDate;
    
                this.sign(ledgerJournalTrans.correct());
                this.proposeDocument();
            }
        }
    
        mainAccount           = LedgerDimensionFacade::getMainAccountFromLedgerDimension(accountEntry.LedgerDimension);
        offsetMainAccount     = LedgerDimensionFacade::getMainAccountFromLedgerDimension(offsetAccountEntry.LedgerDimension);
        glDefaultDimension    = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(accountEntry.LedgerDimension);
    
        while select cashTrans
            where cashTrans.Voucher == subledgerVoucherGeneralJournalEntry.Voucher &&
                cashTrans.TransDate == subledgerVoucherGeneralJournalEntry.AccountingDate &&
                cashTrans.OffsetAccountType != LedgerJournalACType::Ledger
            exists join dimAttrLevelValueView
                where dimAttrLevelValueView.ValueCombinationRecId == cashTrans.LedgerDimension &&
                      dimAttrLevelValueView.DimensionAttribute    == mainAccountAttr.RecId &&
                      (dimAttrLevelValueView.DisplayValue == mainAccount.MainAccountId ||
                       dimAttrLevelValueView.DisplayValue == offsetMainAccount.MainAccountId)
        {
            processCashTrans();
        }
    
        while select cashTrans
            where cashTrans.Voucher == subledgerVoucherGeneralJournalEntry.Voucher &&
                cashTrans.TransDate == subledgerVoucherGeneralJournalEntry.AccountingDate &&
                cashTrans.OffsetAccountType == LedgerJournalACType::Ledger
            exists join dimAttrLevelValueView
                where dimAttrLevelValueView.ValueCombinationRecId == cashTrans.LedgerDimension &&
                      dimAttrLevelValueView.DimensionAttribute    == mainAccountAttr.RecId &&
                      (dimAttrLevelValueView.DisplayValue == mainAccount.MainAccountId ||
                       dimAttrLevelValueView.DisplayValue == offsetMainAccount.MainAccountId)
            exists join offsetDimAttrLevelValueView
                where offsetDimAttrLevelValueView.ValueCombinationRecId == cashTrans.OffsetLedgerDimensionNum &&
                      offsetDimAttrLevelValueView.DimensionAttribute    == mainAccountAttr.RecId &&
                      (offsetDimAttrLevelValueView.DisplayValue == mainAccount.MainAccountId ||
                       offsetDimAttrLevelValueView.DisplayValue == offsetMainAccount.MainAccountId)
        {
            processCashTrans();
        }
    
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadCustInvoice</Name>
				<Source><![CDATA[
    private boolean loadCustInvoice()
    {
        #query
        CustInvoiceJour               custInvoiceJour;
        CustInvoiceTrans              custInvoiceTrans;
        CustInvoiceLine               custInvoiceLine;
        RecId                         parentId;
        DimensionDefault              ledgerDim, offsetDim;
        LedgerDimensionDefaultAccount ledgerAccount, offsetAccount;
        boolean                       lret, ret = false;
    
        if ( !(mode == LedgerTransType::None || mode == LedgerTransType::Cust || mode == LedgerTransType::Sales))
            return ret;
    
        ledgerDim     = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(accountEntry.LedgerDimension);
        offsetDim     = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(offsetAccountEntry.LedgerDimension);
        ledgerAccount = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(accountEntry.LedgerDimension);
        offsetAccount = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(offsetAccountEntry.LedgerDimension);
    
        while select TableId,
                    RecId,
                    InvoiceDate,
                    InvoiceId,
                    ExchRate,
                    Payment,
                    FixedDueDate,
                    NumberSequenceGroup
                    from custInvoiceJour
            where custInvoiceJour.LedgerVoucher == subledgerVoucherGeneralJournalEntry.Voucher
            join custInvoiceTrans
                where custInvoiceTrans.InvoiceId            == custInvoiceJour.InvoiceId             &&
                      custInvoiceTrans.InvoiceDate          == custInvoiceJour.InvoiceDate           &&
                      custInvoiceTrans.NumberSequenceGroup  == custInvoiceJour.NumberSequenceGroup   &&
                     (custInvoiceTrans.LedgerDimension      == ledgerAccount                         ||
                      custInvoiceTrans.LedgerDimension      == offsetAccount)                        &&
                    ((custInvoiceTrans.DefaultDimension     == ledgerDim || ! ledgerDim ||
                      ! custInvoiceTrans.DefaultDimension)                                           &&
                     (custInvoiceTrans.DefaultDimension     == offsetDim || ! offsetDim ||
                      ! custInvoiceTrans.DefaultDimension))
        {
    
            if (custInvoiceJour.InvoiceDate != entry.AccountingDate &&
                (select maxof(Transdate) from rAssetTransUnionView
                     where rAssetTransUnionView.Voucher == subledgerVoucherGeneralJournalEntry.Voucher &&
                           rAssetTransUnionView.recVersion).TransDate != entry.AccountingDate)
                continue;
    
    
            if (linesSet.in([tableNum(CustInvoiceTrans),custInvoiceTrans.RecId]))
                continue;
    
            linesSet.add([tableNum(CustInvoiceTrans),custInvoiceTrans.RecId]);
    
            lret     = false;
            parentId = custInvoiceJour.custInvoiceTable().RecId;
            if (parentId)
            {
                while select AmountCur, Quantity, Description, AssetId_RU from custInvoiceLine
                    where custInvoiceLine.ParentRecId      == parentId                         &&
                          custInvoiceLine.LedgerDimension  == custInvoiceTrans.LedgerDimension &&
                          custInvoiceLine.DefaultDimension == custInvoiceTrans.DefaultDimension
                {
                    lret = true;
    
                    if (linesSet.in([tableNum(CustInvoiceLine),custInvoiceLine.RecId]))
                        continue;
    
                    linesSet.add([tableNum(CustInvoiceLine),custInvoiceLine.RecId]);
    
                    this.createLineFromCustInvoice(custInvoiceTrans.LineAmount,
                                                   custInvoiceLine.Quantity,
                                                   custInvoiceLine.Description ?
                                                   custInvoiceLine.Description :
                                                   custInvoiceLine.InvoiceTxt,
                                                   custInvoiceLine.AssetId_RU,
                                                   custInvoiceJour,
                                                   custInvoiceTrans,
                                                   lret,
                                                   custInvoiceLine.TableId,
                                                   custInvoiceLine.RecId);
                }
            }
    
            if (! lret)
            {
                this.createLineFromCustInvoice(custInvoiceTrans.LineAmount,
                                               custInvoiceTrans.Qty,
                                               custInvoiceTrans.ItemId ? custInvoiceTrans.ItemId :
                                                                         (custInvoiceTrans.Name ? custInvoiceTrans.Name :
                                                                                                  EcoResCategory::find(custInvoiceTrans.SalesCategory).Name),
                                               custInvoiceTrans.custInvoiceTrans_RU().AssetId_RU,
                                               custInvoiceJour,
                                               custInvoiceTrans,
                                               lret);
            }
    
            ret  = true;
        }
    
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadCustVendExchRateDiff</Name>
				<Source><![CDATA[
    private boolean loadCustVendExchRateDiff()
    {
        boolean       ret;
        CustVendTrans custVendTrans;
        CustVendTrans custVendTransSource;
        Integer       sign;
    
        Integer determineSign()
        {
    
            if ((tableId == tableNum(CustTrans)                                      &&
                (accountEntry.PostingType       == LedgerPostingType::AmountDiffLoss_RU   ||
                    offsetAccountEntry.PostingType == LedgerPostingType::AmountDiffLoss_RU)) ||
                (tableId == tableNum(VendTrans)                                      &&
                (accountEntry.PostingType       == LedgerPostingType::AmountDiffGain_RU   ||
                    offsetAccountEntry.PostingType == LedgerPostingType::AmountDiffGain_RU)))
            {
                return -1;
            }
            return 1;
        }
    
        AmountMST calcExchAmountPerDimension()
        {
            GeneralJournalAccountEntry          localAccountEntry;
            GeneralJournalAccountEntry          localOffsetAccountEntry;
            GeneralJournalAccountEntry_W        localAccountEntryW;
            GeneralJournalAccountEntry_W        localOffsetAccountEntryW;
            QueryBuildRange        dimRange;
            Map                    dimAttrMap;
            MapIterator            mi;
    
            TaxTrans               taxTrans;
            AmountMST              exchAmount;
            LedgerDimensionAccount taxLedgerDimension;
            Query                  query;
            QueryBuildDataSource   queryBuildDataSource, qbdsTaxOffset, qbdsTax;
            QueryRun               queryRun;
            int                    i;
            LedgerDimensionDefaultAccount sumAccount = custVendTrans.summaryLedgerDimension();
            RTax25ExchAdjDimension        rTax25ExchAdjDimension = new RTax25ExchAdjDimension();
    
            while select AccountingCurrencyAmount, RecId from localAccountEntry
                where localAccountEntry.LedgerDimension     == accountEntry.LedgerDimension &&
                      localAccountEntry.GeneralJournalEntry == accountEntry.GeneralJournalEntry
                join RecId from localAccountEntryW
                    where localAccountEntryW.GeneralJournalAccountEntry == localAccountEntry.RecId
                join RecId from localOffsetAccountEntryW
                    where localOffsetAccountEntryW.BondBatchTrans_RU == localAccountEntryW.BondBatchTrans_RU
                join RecId from localOffsetAccountEntry
                    where localOffsetAccountEntry.RecId == localOffsetAccountEntryW.GeneralJournalAccountEntry
                        && localOffsetAccountEntry.GeneralJournalEntry  == localAccountEntry.GeneralJournalEntry
                        && localOffsetAccountEntry.LedgerDimension      == offsetAccountEntry.LedgerDimension
            {
                linesSet.add([tableNum(GeneralJournalAccountEntry),localAccountEntry.RecId]);
                linesSet.add([tableNum(GeneralJournalAccountEntry),localOffsetAccountEntry.RecId]);
                exchAmount += localAccountEntry.AccountingCurrencyAmount;
            }
    
            query = new Query();
            queryBuildDataSource = query.addDataSource(tableNum(TaxTrans));
            queryBuildDataSource.addSelectionField(fieldNum(TaxTrans,TaxAmount),SelectionField::Sum);
    
            queryBuildDataSource.addRange(fieldNum(TaxTrans,TransDate)).value(queryValue(entry.AccountingDate));
            queryBuildDataSource.addRange(fieldNum(TaxTrans,Voucher)).value(queryValue(subledgerVoucherGeneralJournalEntry.Voucher));
    
            qbdsTaxOffset = queryBuildDataSource.addDataSource(tableNum(TaxTransGeneralJournalAccountEntry));
    
            qbdsTaxOffset.addLink(fieldNum(TaxTrans, RecId),
                                  fieldNum(TaxTransGeneralJournalAccountEntry, TaxTrans));
            qbdsTaxOffset.addRange(fieldNum(TaxTransGeneralJournalAccountEntry, TaxTransRelationship)).value(queryValue(TaxTransRelationshipType::Offset_RU));
            qbdsTaxOffset.joinMode(JoinMode::ExistsJoin);
    
            qbdsTax = queryBuildDataSource.addDataSource(tableNum(TaxTransLedgerDimensionView_RU));
            qbdsTax.addLink(fieldNum(TaxTrans, RecId),
                            fieldNum(TaxTransLedgerDimensionView_RU, TaxTrans));
            qbdsTax.addRange(fieldNum(TaxTransLedgerDimensionView_RU, TaxTransRelationship)).value(queryValue(TaxTransRelationshipType::Tax));
    
            taxLedgerDimension = (sumAccount == LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(accountEntry.LedgerDimension)) ?
                offsetAccountEntry.LedgerDimension : accountEntry.LedgerDimension;
    
            dimAttrMap = LedgerDimensionDefaultingEngine::getLedgerDimensionSpecifiers(taxLedgerDimension);
            mi = new MapIterator(dimAttrMap);
            mi.begin();
            while (mi.more())
            {
                if (mi.key() != dimAttr.RecId           &&
                    mi.key() != mainAccountAttr.RecId)
                {
                    dimRange = SysQuery::addDimensionAttributeRange(query,
                                                                    qbdsTax.name(),
                                                                    fieldStr(TaxTransLedgerDimensionView_RU, LedgerDimension),
                                                                    DimensionComponent::DimensionAttribute,
                                                                    queryValue(conPeek(mi.value(), 1)),
                                                                    DimensionAttribute::find(mi.key()).Name);
                    dimRange.dataSource().joinMode(JoinMode::ExistsJoin);
                }
                mi.next();
            }
    
            queryBuildDataSource.orderMode(OrderMode::GroupBy);
    
            queryRun = new QueryRun(query);
            if (queryRun.next())
            {
                taxTrans = queryRun.get(tableNum(TaxTrans));
            }

            exchAmount += (sumAccount == LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(accountEntry.LedgerDimension)) ?
                taxTrans.TaxAmount : - taxTrans.TaxAmount;
    
            return exchAmount;
        }
    
        if (((accountEntry.PostingType       == LedgerPostingType::ExchRateGain || accountEntry.PostingType       == LedgerPostingType::ExchRateLoss) ||
             (offsetAccountEntry.PostingType == LedgerPostingType::ExchRateGain || offsetAccountEntry.PostingType == LedgerPostingType::ExchRateLoss)) ||
            ((accountEntry.PostingType       == LedgerPostingType::AmountDiffGain_RU || accountEntry.PostingType       == LedgerPostingType::AmountDiffLoss_RU) ||
             (offsetAccountEntry.PostingType == LedgerPostingType::AmountDiffGain_RU || offsetAccountEntry.PostingType == LedgerPostingType::AmountDiffLoss_RU)))
        {
    
            if (linesSet.in([tableNum(GeneralJournalAccountEntry), accountEntry.RecId]) ||
                linesSet.in([tableNum(GeneralJournalAccountEntry), offsetAccountEntry.RecId]))
            {
                return true;
            }
    
            switch (entry.JournalCategory)
            {
                case LedgerTransType::Vend, LedgerTransType::Purch :
                    custVendTrans = VendTrans::findVoucherDate(subledgerVoucherGeneralJournalEntry.Voucher,
                                                               subledgerVoucherGeneralJournalEntry.AccountingDate);
                    break;
                case LedgerTransType::Cust, LedgerTransType::Sales :
                    custVendTrans = CustTrans::findVoucherDate(subledgerVoucherGeneralJournalEntry.Voucher,
                                                               subledgerVoucherGeneralJournalEntry.AccountingDate);
                    break;
                default :
                    custVendTrans = VendTrans::findVoucherDate(subledgerVoucherGeneralJournalEntry.Voucher,
                                                               subledgerVoucherGeneralJournalEntry.AccountingDate);
                    if (! custVendTrans)
                    {
                        custVendTrans = CustTrans::findVoucherDate(subledgerVoucherGeneralJournalEntry.Voucher,
                                                                   subledgerVoucherGeneralJournalEntry.AccountingDate);
                    }
            }
    
            if (custVendTrans.TransType == LedgerTransType::ExchAdjustment)
            {
                custVendTransSource = custVendTrans.data();
                
                select firstonly TransDate from custVendTransSource
                    where custVendTransSource.RecId == custVendTrans.OffsetRecId;
                
                if (custVendTransSource.TransDate < AmountDiffCancelDate)
                {
                    //return true because transaction must be processed in Amount Differences register and should be ignored by RTax25StdDocumentsExt class
                    return true;
                }
                
                tableId      = custVendTrans.TableId;
                recId        = custVendTrans.RecId;
                docDate      = custVendTrans.DocumentDate ? custVendTrans.DocumentDate : custVendTrans.TransDate;
                docName      = strFmt("@GLS106745",accountEntry.PostingType ? accountEntry.PostingType : offsetAccountEntry.PostingType);
                currencyCode = custVendTrans.CurrencyCode;
    
                sign = determineSign();
    
                if (tableId == tableNum(CustTrans))
                {
                    amount  = sign * calcExchAmountPerDimension();
                }
                else
                {
                    amount  = sign * accountEntry.AccountingCurrencyAmount;
                }
    
                txt          = custVendTrans.Txt ? custVendTrans.Txt : docName ;
                paymMode     = custVendTrans.PaymMode;
                transDate    = custVendTrans.TransDate;
    
                this.proposeDocument();
                ret = true;
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadDocument</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public boolean loadDocument(GeneralJournalAccountEntry _accountEntry,
                                GeneralJournalAccountEntry _offsetAccountEntry,
                                RefRecId                   _profitTableRecId = 0,
                                boolean                    _allParameters    = true,
                                LedgerTransType            _mode             = LedgerTransType::None,
                                boolean                    _transSum         = true)
    {
        TransLink_RU                transLink;
        GeneralJournalAccountEntry  accountEntryOrig;
    
        if (_accountEntry.AccountingCurrencyAmount == 0)
            return false;
    
        accountEntry          = _accountEntry;
        offsetAccountEntry    = _offsetAccountEntry;
        entry                 = GeneralJournalEntry::find(_accountEntry.GeneralJournalEntry);
        mode                  = _mode;
        allParm               = _allParameters;
        profitTableRecId      = _profitTableRecId;
        transEnable           = ! _transSum;
    
        ledgerVoucherReportDate = LedgerVoucherReportDate_RU::find(entry.SubledgerVoucher, entry.AccountingDate);
        subledgerVoucherGeneralJournalEntry = SubledgerVoucherGeneralJournalEntry::findByGeneralJournalEntry(entry);
        voucher               = subledgerVoucherGeneralJournalEntry.Voucher;
        reportingDate         = ledgerVoucherReportDate ? ledgerVoucherReportDate.ReportingDate : subledgerVoucherGeneralJournalEntry.AccountingDate;
    
        this.resetValue();
    
        switch (entry.JournalCategory)
        {
            case LedgerTransType::Vend, LedgerTransType::Purch :
                if (this.loadVendInvoice())
                    return true;
                break;
            case LedgerTransType::Cust, LedgerTransType::Sales :
                if (this.loadCustInvoice())
                    return true;
                break;
        }
    
        if (this.loadCashTrans())
            return true;
        if (this.loadEmplAdvTable())
            return true;
    
        if (!(entry.JournalCategory == LedgerTransType::Purch || entry.JournalCategory == LedgerTransType::Vend ||
              entry.JournalCategory == LedgerTransType::Sales || entry.JournalCategory == LedgerTransType::Cust))
        {
            if (this.loadVendInvoice())
                return true;
            if (this.loadCustInvoice())
                return true;
        }
    
        if (this.loadLedgerJournalTrans())
            return true;
    
        if (entry.JournalCategory == LedgerTransType::GeneralJournal)
        {
            transLink = TransLink_RU::findSec(accountEntry.TableId, accountEntry.RecId);
    
            if (transLink &&
               (transLink.TransLinkType == TransLinkType_RU::Storno ||
                transLink.TransLinkType == TransLinkType_RU::Revoke))
            {
                accountEntryOrig = TransLink_RU::getOriginal(accountEntry);
                subledgerVoucherGeneralJournalEntry = SubledgerVoucherGeneralJournalEntry::findByGeneralJournalEntryRecId(accountEntryOrig.GeneralJournalEntry);
    
                //ignoring duplicates for GL storno transactions as they have same base document
                if (this.loadLedgerJournalTrans(true, transLink.TransLinkType == TransLinkType_RU::Storno))
                    return true;
            }
        }
    
        if (this.loadCustVendExchRateDiff())
            return true;
    
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadEmplAdvTable</Name>
				<Source><![CDATA[
    private boolean loadEmplAdvTable()
    {
        DimensionAttributeLevelValueView    dimAttributeLevelValueView;
        MainAccount                         mainAccount,    offsetMainAccount;
        DimensionDefault                    ledgerDim,      offsetLedgerDim;
        LedgerDimensionDefaultAccount       ledgerAcc,      offsetLedgerAcc;
        EmplAdvTable_RU                     advTable;
        EmplAdvLine_RU                      advLine;
        EmplTrans_RU                        emplTrans;
        boolean                             ret = false;
    
        mainAccount         = LedgerDimensionFacade::getMainAccountFromLedgerDimension(accountEntry.LedgerDimension);
        offsetMainAccount   = LedgerDimensionFacade::getMainAccountFromLedgerDimension(offsetAccountEntry.LedgerDimension);
        ledgerAcc           = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(accountEntry.LedgerDimension);
        offsetLedgerAcc     = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(offsetAccountEntry.LedgerDimension);
        ledgerDim           = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(accountEntry.LedgerDimension);
        offsetLedgerDim     = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(offsetAccountEntry.LedgerDimension);
    
        while select TableId, RecId from advTable
            join DocumentDate, DocumentName, CurrencyCode, AmountCurApproved, AmountMst, Qty, Description from advLine
                where advLine.AdvanceId == advTable.AdvanceId           &&
                      (advLine.LineType == EmplAdvLineType_RU::None ||
                       advLine.LineType == EmplAdvLineType_RU::Expend)
            join firstonly RecId from emplTrans
                where emplTrans.RecId       == advLine.EmplTransRecId &&
                      emplTrans.Voucher     == subledgerVoucherGeneralJournalEntry.Voucher &&
                      emplTrans.TransDate   == subledgerVoucherGeneralJournalEntry.AccountingDate
            exists join TableId from dimAttributeLevelValueView
                where dimAttributeLevelValueView.ValueCombinationRecId  == emplTrans.LedgerDimension    &&
                      dimAttributeLevelValueView.DimensionAttribute     == mainAccountAttr.RecId        &&
                       ((dimAttributeLevelValueView.EntityInstance      == mainAccount.RecId            &&
                         advLine.DefaultDimension                       == offsetLedgerDim              &&
                         advLine.LedgerDimension                        == offsetLedgerAcc)             ||
                        (dimAttributeLevelValueView.EntityInstance      == offsetMainAccount.RecId      &&
                         advLine.DefaultDimension                       == ledgerDim                    &&
                         advLine.LedgerDimension                        == ledgerAcc))
        {
            if (linesSet.in([tableNum(EmplAdvLine_RU),advLine.RecId]))
                continue;
    
            ret = true;
            linesSet.add([tableNum(EmplAdvLine_RU),advLine.RecId]);
    
            tableId = advTable.TableId;
            recId   = advTable.RecId;
    
            docDate = advLine.DocumentDate;
            docName = advLine.DocumentName;
    
            currencyCode = advLine.CurrencyCode;
            amountCur    = advLine.AmountCurApproved;
            amount       = advLine.AmountMst;
    
            qty          = advLine.Qty;
    
            txt          = advLine.Description;
            transDate    = reportingDate;
    
            this.sign(false);
            this.proposeDocument();
        }
    
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadLedgerJournalTrans</Name>
				<Source><![CDATA[
    private boolean loadLedgerJournalTrans(boolean _GLCorrection = false, boolean _invertSign = false)
    {
        LedgerJournalTrans        ledgerJournalTrans;
        LedgerJournalTrans_Asset  ledgerJournalTrans_Asset;
        LedgerJournalTrans_RAsset ledgerJournalTrans_RAsset;
        LedgerJournalTable        ledgerJournalTable;
        RAssetPurchTrans          rAssetPurchTrans;
        DimensionDefault          ledgerDim, offsetLedgerDim;
        DimensionDefault          ledgerJournalTransDim, ledgerJournalTransOffsetDim;
        boolean                   ret = false;
    
        ledgerDim           = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(accountEntry.LedgerDimension);
        offsetLedgerDim     = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(offsetAccountEntry.LedgerDimension);
    
        while select ledgerJournalTrans
            where ledgerJournalTrans.Voucher == subledgerVoucherGeneralJournalEntry.Voucher
            exists join ledgerJournalTable
                where ledgerJournalTable.JournalNum  == ledgerJournalTrans.JournalNum
                   && ledgerJournalTable.Posted      == NoYes::Yes
        {
            if (ledgerDim && offsetLedgerDim)
            {
                if (ledgerJournalTrans.AccountType       == LedgerJournalACType::Ledger &&
                    ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
                {
                    ledgerJournalTransDim       = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(ledgerJournalTrans.LedgerDimension);
                    ledgerJournalTransOffsetDim = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(ledgerJournalTrans.OffsetLedgerDimension);
                }
                else
                if (ledgerJournalTrans.AccountType       == LedgerJournalACType::Ledger &&
                    ledgerJournalTrans.OffsetAccountType != LedgerJournalACType::Ledger)
                {
                    ledgerJournalTransDim       = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(ledgerJournalTrans.LedgerDimension);
                    ledgerJournalTransOffsetDim = ledgerJournalTrans.OffsetDefaultDimension;
                }
                else
                if (ledgerJournalTrans.AccountType       != LedgerJournalACType::Ledger &&
                    ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
                {
                    ledgerJournalTransDim       = ledgerJournalTrans.DefaultDimension;
                    ledgerJournalTransOffsetDim = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(ledgerJournalTrans.OffsetLedgerDimension);
                }
                else
                {
                    ledgerJournalTransDim       = ledgerJournalTrans.DefaultDimension;
                    ledgerJournalTransOffsetDim = ledgerJournalTrans.OffsetDefaultDimension;
                }
    
                if (ledgerJournalTransDim          != ledgerDim &&
                    ledgerJournalTransDim          != offsetLedgerDim &&
                    ledgerJournalTransOffsetDim    != ledgerDim &&
                    ledgerJournalTransOffsetDim    != offsetLedgerDim)
                {
                    continue;
                }
            }
    
            ledgerJournalTrans_Asset    = LedgerJournalTrans_Asset::find(ledgerJournalTrans.RecId);
            ledgerJournalTrans_RAsset   = LedgerJournalTrans_RAsset::find(ledgerJournalTrans.RecId);
    
            if (!_GLCorrection &&
                ledgerJournalTrans.TransDate != entry.AccountingDate &&
                RAssetTrans::find(ledgerJournalTrans_RAsset.StornoRecId).getAccountingDate() != entry.AccountingDate)
            {
                continue;
            }
    
            if (!_GLCorrection && linesSet.in([tableNum(LedgerJournalTrans),ledgerJournalTrans.RecId]))
            {
                continue;
            }
    
            if (! this.multiLinesCheck(ledgerJournalTrans))
            {
                continue;
            }
    
            ret = true;
            linesSet.add([tableNum(LedgerJournalTrans),ledgerJournalTrans.RecId]);
    
            tableId = ledgerJournalTrans.TableId;
            recId   = ledgerJournalTrans.RecId;
    
            docDate = ledgerJournalTrans.DocumentDate ? ledgerJournalTrans.DocumentDate : ledgerJournalTrans.TransDate;
            docName = this.docNameLedgerJournalTrans(ledgerJournalTrans);
    
            currencyCode = ledgerJournalTrans.CurrencyCode;
            amountCur    = ledgerJournalTrans.amount();
            if (LedgerJournalTable::find(ledgerJournalTrans.JournalNum).LedgerJournalInclTax &&
                !ledgerJournalTrans.Prepayment  &&
                ledgerJournalTrans.TaxGroup     &&
                ledgerJournalTrans.TaxItemGroup)
            {
                amountCur = amountCur + (amountCur > 0 ? - abs(ledgerJournalTrans.taxAmountJournal()) :  abs(ledgerJournalTrans.taxAmountJournal()));
            }
            amount       = currencyCode ? CurrencyExchangeHelper::amountCur2MST(amountCur, currencyCode, ledgerJournalTrans.ExchRate) :
                                           amountCur;
    
            qty          = ledgerJournalTrans.Qty;
            txt          = ledgerJournalTrans.Txt;
            paymMode     = ledgerJournalTrans.PaymMode;
            paymModeName = ledgerJournalTrans.Payment ? ledgerJournalTrans.Payment : ledgerJournalTrans.PaymMode;
            transDate    = reportingDate;
    
            assetId = ledgerJournalTrans_RAsset.AssetId ? ledgerJournalTrans_RAsset.AssetId : ledgerJournalTrans_Asset.AssetId;
    
            if(allParm)
            {
                if (! assetId)
                {
                    while select AssetId from rAssetPurchTrans
                        where rAssetPurchTrans.TableTableId == ledgerJournalTrans.TableId    &&
                              rAssetPurchTrans.TableRecId   == ledgerJournalTrans.RecId
                    {
                        assetId += (assetId ? #Separator : "") + rAssetPurchTrans.AssetId;
                    }
                }
    
                markup       = new Markup(ledgerJournalTrans.CurrencyCode);
                markup.calc(ledgerJournalTrans.Qty, ledgerJournalTrans.amount(), ledgerJournalTrans);
                markupAmount = currencyCode ? CurrencyExchangeHelper::amountCur2MST(markup.markupCustVend(), currencyCode, ledgerJournalTrans.ExchRate) :
                                              markup.markupCustVend();
            }
            this.sign(ledgerJournalTrans.correct() || _invertSign);
    
            if (_invertSign)
            {
                qty = -qty;
            }
    
            this.proposeDocument();
        }
    
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadVendInvoice</Name>
				<Source><![CDATA[
    private boolean loadVendInvoice()
    {
        VendInvoiceJour                     vendInvoiceJour;
        VendInvoiceTrans                    vendInvoiceTrans;
        RAssetTable                         rAssetTable;
        RAssetPurchTrans                    rAssetPurchTrans;
    //    MainAccount                         mainAccount, offsetMainAccount;
    //    DimensionAttributeLevelValueView    dimAttributeLevelValueView;
        DimensionDefault                    ledgerDim, offsetDim;
        AccountingDistribution              accDistribution;
        SubledgerJournalAccountEntryDistribution sjaeDistr;
        SubledgerJournalAccountEntry             sjaEntry;
        boolean                             ret = false;
    
        if (!(mode == LedgerTransType::None || mode == LedgerTransType::Vend || mode == LedgerTransType::Purch))
            return ret;
    
    //    mainAccount         = DimensionStorage::getMainAccountFromLedgerDimension(accountEntry.LedgerDimension);
    //    offsetMainAccount   = DimensionStorage::getMainAccountFromLedgerDimension(offsetAccountEntry.LedgerDimension);
        ledgerDim           = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(accountEntry.LedgerDimension);
        offsetDim           = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(offsetAccountEntry.LedgerDimension);
    
        while select TableId, RecId, InvoiceDate, InvoiceId, ExchRate, Payment, FixedDueDate, NumberSequenceGroup from vendInvoiceJour
            where vendInvoiceJour.LedgerVoucher == subledgerVoucherGeneralJournalEntry.Voucher &&
                  vendInvoiceJour.InvoiceDate   == subledgerVoucherGeneralJournalEntry.AccountingDate
            join vendInvoiceTrans
                where vendInvoiceTrans.PurchID              == vendInvoiceJour.PurchId              &&
                      vendInvoiceTrans.InvoiceId            == vendInvoiceJour.InvoiceId            &&
                      vendInvoiceTrans.InvoiceDate          == vendInvoiceJour.InvoiceDate          &&
                      vendInvoiceTrans.NumberSequenceGroup  == vendInvoiceJour.NumberSequenceGroup  &&
                      vendInvoiceTrans.InternalInvoiceId    == vendInvoiceJour.InternalInvoiceId    &&
                    ((vendInvoiceTrans.DefaultDimension     == ledgerDim        || !ledgerDim)      &&
                     (vendInvoiceTrans.DefaultDimension     == offsetDim        || !offsetDim  || !vendInvoiceTrans.DefaultDimension))
            exists join accDistribution
                where accDistribution.SourceDocumentLine   == vendInvoiceTrans.SourceDocumentLine  &&
                      accDistribution.SourceDocumentHeader == vendInvoiceJour.SourceDocumentHeader &&
                      accDistribution.AccountingDate       == vendInvoiceJour.InvoiceDate
            exists join sjaeDistr
                where sjaeDistr.AccountingDistribution     == accDistribution.RecId
            exists join sjaEntry
                where sjaEntry.RecId                       == sjaeDistr.SubledgerJournalAccountEntry &&
                      (sjaEntry.GeneralJournalAccountEntry == accountEntry.RecId                     ||
                       sjaEntry.GeneralJournalAccountEntry == offsetAccountEntry.RecId)
    //        exists join TableId from dimAttributeLevelValueView
    //            where dimAttributeLevelValueView.ValueCombinationRecId  == sJAEntry.LedgerDimension   &&
    //                  dimAttributeLevelValueView.DimensionAttribute     == mainAccountAttr.RecId      &&
    //                   (dimAttributeLevelValueView.EntityInstance       == mainAccount.RecId          ||
    //                    dimAttributeLevelValueView.EntityInstance       == offsetMainAccount.RecId)
        {
            if (linesSet.in([tableNum(VendInvoiceTrans), vendInvoiceTrans.RecId]))
                continue;
            ret          = true;
            linesSet.add([tableNum(VendInvoiceTrans), vendInvoiceTrans.RecId]);
    
            tableId      = transEnable ? vendInvoiceTrans.TableId : vendInvoiceJour.TableId;
            recId        = transEnable ? vendInvoiceTrans.RecId   : vendInvoiceJour.RecId;
    
            docDate      = vendInvoiceJour.InvoiceDate;
            docName      = vendInvoiceJour.InvoiceId ?
                                           strFmt("@GLS103885", "@SYS12128", vendInvoiceJour.InvoiceId, docDate) : "";
    
            currencyCode = vendInvoiceTrans.CurrencyCode;
            amountCur    = vendInvoiceTrans.LineAmount;
            amount       = currencyCode ? CurrencyExchangeHelper::amountCur2MST(amountCur, currencyCode, vendInvoiceJour.ExchRate) :
                                           amountCur;
    
            qty          = vendInvoiceTrans.Qty;
            itemName     = vendInvoiceTrans.ItemId ? vendInvoiceTrans.ItemId :
                                                     (vendInvoiceTrans.Name ? vendInvoiceTrans.Name :
                                                                              EcoResCategory::find(vendInvoiceTrans.ProcurementCategory).Name);
            transDate    = reportingDate;
    
            paymMode     = PurchTable::find(vendInvoiceTrans.PurchID).PaymMode;
            paymModeName = VendPaymModeTable::find(paymMode).Name;
            paymModeName =  paymModeName ?  paymModeName : paymMode;
    
            assetId      = "";
            while select AccountNum from rAssetTable
                where rAssetTable.InventTransId       == vendInvoiceTrans.InventTransId &&
                        rAssetTable.PurchId             == vendInvoiceTrans.PurchID
            exists join rAssetPurchTrans
                where rAssetPurchTrans.AssetId        == rAssetTable.AccountNum         &&
                        rAssetPurchTrans.PurchTransType == RAssetPurchTransType::PurchaseLine
            {
                assetId += (assetId ? #Separator : "") + rAssetTable.AccountNum;
            }
    
            if (allParm)
            {
                markup       = new Markup(currencyCode);
                markupAmount = markup.calcMarkupAmount_RU(vendInvoiceTrans,
                                                        vendInvoiceTrans.Qty,
                                                        vendInvoiceTrans.LineAmount);
                markupAmount = currencyCode ? CurrencyExchangeHelper::amountCur2MST(markupAmount, currencyCode, vendInvoiceTrans.exchRate())
                                                        : markupAmount;
            }
            this.proposeDocument();
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapElements</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public int mapElements()
    {
        return transMap.elements();
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupAmount</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public AmountMST markupAmount()
    {
        return markupAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>more</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public boolean more()
    {
        if (! mapLoop)
        {
            mapLoop = new MapIterator(docBuffer);
            mapLoop.begin();
            this.next(true);
        }
        return mapLoop.more();
    }

]]></Source>
			</Method>
			<Method>
				<Name>multiLinesCheck</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public boolean multiLinesCheck(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean     ret     = true;
        boolean     pret    = true;
        MainAccount mainAccount, offsetMainAccount, jourTransMainAccount, jourTransOffsetMainAccount;
    
        mainAccount         = LedgerDimensionFacade::getMainAccountFromLedgerDimension(accountEntry.LedgerDimension);
        offsetMainAccount   = LedgerDimensionFacade::getMainAccountFromLedgerDimension(offsetAccountEntry.LedgerDimension);
    
        if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger &&
            _ledgerJournalTrans.OffsetLedgerDimension)
        {
            jourTransOffsetMainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(_ledgerJournalTrans.OffsetLedgerDimension);
            if ( jourTransOffsetMainAccount.RecId != offsetMainAccount.RecId &&
                 jourTransOffsetMainAccount.RecId != mainAccount.RecId)
            {
                pret = false;
            }
        }
    
        switch (_ledgerJournalTrans.AccountType)
        {
            case LedgerJournalACType::Ledger :
                if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
                {
                    jourTransMainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(_ledgerJournalTrans.LedgerDimension);
                    if ( jourTransMainAccount.RecId != mainAccount.RecId &&
                         jourTransMainAccount.RecId != offsetMainAccount.RecId)
                    {
                        ret = false;
                    }
                }
                break;
            default :
        }
    
        if (! _ledgerJournalTrans.LedgerDimension || ! _ledgerJournalTrans.OffsetLedgerDimension)
        {
            if (! ((ledgerAccountList.MainAccountId       && _ledgerJournalTrans.LedgerDimension       && _ledgerJournalTrans.AmountCurDebit)  ||
                   (ledgerAccountList.MainAccountId       && _ledgerJournalTrans.OffsetLedgerDimension && _ledgerJournalTrans.AmountCurCredit) ||
                   (ledgerAccountList.OffsetMainAccountId && _ledgerJournalTrans.LedgerDimension       && _ledgerJournalTrans.AmountCurCredit) ||
                   (ledgerAccountList.OffsetMainAccountId && _ledgerJournalTrans.OffsetLedgerDimension && _ledgerJournalTrans.AmountCurDebit)))
            {
                ret = false;
            }
    
            if (  ledgerAccountList.MainAccountId             &&
                  ledgerAccountList.OffsetMainAccountId       &&
                ((_ledgerJournalTrans.LedgerDimension         && _ledgerJournalTrans.AmountCurCredit) ||
                 (_ledgerJournalTrans.OffsetLedgerDimension   && _ledgerJournalTrans.AmountCurDebit)))
            {
                ret = false;
            }
        }
    
        return ret && pret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    final protected void new()
    {
        docBuffer       = new Map(Types::Container, Types::Container);
        linesSet        = new Set(Types::Container);
        transMap        = new Map(Types::Container, Types::Container);
        dimAttr         = DimensionAttribute::find(RTax25Parameters::find().DimensionAttribute);
        mainAccountAttr = DimensionAttribute::find(DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount));
    }

]]></Source>
			</Method>
			<Method>
				<Name>next</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void next(boolean _beginLine = false)
    {
        if (! _beginLine)
            mapLoop.next();
    
        if (! mapLoop.more())
            return;
    
        [docDate, recId, tableId, docName]     = mapLoop.key();
        [qty, amount, markupAmount, amountCur] = mapLoop.value();
    
        [profitTableRecId,
         txt,
         itemName,
         assetId,
         transDate,
         paymMode,
         paymModeName,
         currencyCode,
         voucher] = transMap.lookup([tableId,recId]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymMode</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public PaymMode paymMode()
    {
        return paymMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymModeName</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public Description paymModeName()
    {
        return paymModeName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>price</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public Price price()
    {
        return amount / this.qty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>profitTableRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a profit rec id for the current document: invoices, GL journals, advance holder journals.
    /// </summary>
    /// <returns>
    /// The profit rec id of the document.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public RefRecId profitTableRecId()
    {
        return profitTableRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>proposeDocument</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void proposeDocument()
    {
        container c;
    
        if (docBuffer.exists([docDate, recId, tableId, docName]))
        {
            c = docBuffer.lookup([docDate, recId, tableId, docName]);
            docBuffer.insert([docDate, recId, tableId, docName],
                             [qty + conPeek(c, 1), amount + conPeek(c, 2), markupAmount + conPeek(c, 3), amountCur + conPeek(c, 4)]);
        }
        else
        {
            docBuffer.insert([docDate, recId, tableId, docName],  [qty, amount, markupAmount, amountCur]);
        }
    
        transMap.remove([tableId,recId]);
        transMap.insert([tableId,recId], [profitTableRecId, txt, itemName, assetId, transDate, paymMode, paymModeName, currencyCode, voucher]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>qty</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public Qty qty()
    {
        return qty ? qty : 1.0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recId</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public RecId recId()
    {
        return recId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetValue</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void resetValue()
    {
        ;
    
        qty             = 0;
        price           = 0;
        amount          = 0;
        tableId         = 0;
        recId           = 0;
    
        docDate         = dateNull();
        docName         = "";
        txt             = "";
        paymMode        = "";
        paymModeName    = "";
        itemName        = "";
        assetId         = "";
        markupAmount    = 0;
        transDate       = dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLedgerAccountList</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void setLedgerAccountList(TmpRTax25LedgerAccountList _ledgerAccountList)
    {
        ;
        ledgerAccountList = _ledgerAccountList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sign</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void sign(boolean _correct)
    {
        if (_correct == accountEntry.IsCorrection)
        {
            amountCur    = accountEntry.AccountingCurrencyAmount >= 0 ? abs(amountCur)     : - abs(amountCur);
            amount       = accountEntry.AccountingCurrencyAmount >= 0 ? abs(amount)        : - abs(amount);
            markupAmount = accountEntry.AccountingCurrencyAmount >= 0 ? abs(markupAmount)  : - abs(markupAmount);
        }
        else
        {
            amountCur    = accountEntry.AccountingCurrencyAmount < 0 ? abs(amountCur)     : - abs(amountCur);
            amount       = accountEntry.AccountingCurrencyAmount < 0 ? abs(amount)        : - abs(amount);
            markupAmount = accountEntry.AccountingCurrencyAmount < 0 ? abs(markupAmount)  : - abs(markupAmount);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>tableId</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public TableId tableId()
    {
        return tableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transDate</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public TransDate transDate()
    {
        return transDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>txt</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public NotesLine txt()
    {
        return txt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static RTax25StdDocuments construct()
    {
        return new RTax25StdDocuments();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>
