<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxReverse</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>TaxReverse</c> class creates the ledger postings for the tax reversals.
/// </summary>
/// <remarks>
///    This class extends the main tax engine. It derives from the <c>Tax</c> class.
/// </remarks>
public class TaxReverse extends Tax
{
    container       conLedgerDimension;
    container       conSourceBaseAmountCur;
    container       taxTransRecId;
    container       originalTaxTransRecId;
    Map             taxWorkTransTaxTransMap;

    RefTableId      originalSourceTableId;
    RefRecId        originalSourceRecId;

    LedgerJournalId reverseTaxJournalId;
    ExchRate        reportingSettlementCrossRate;
    ExchRate        reportingInvoiceCrossRate;

    // Percentage used to reverse only a portion of the TaxTrans record.
    Percent         percent;

    // If cash discount calculated on amount including sales tax then the
    // percentage (percent) above will exclude cash discount.  This percentage
    // will include the cash discount.
    Percent         percentIncludingCashDiscount;

    boolean         allowGainLossDueToExchangeRates;
    TaxAmount       gainLossAmountDueToExchangeRates;
    TaxAmount       gainLossInReportingCurrency;

    // LedgerVoucher representing the original transaction being settled against.
    LedgerVoucher   relatedLedgerVoucher;
    LedgerPostingType   taxChargePostingType;

    // <GEEPL>
    boolean         copyDistributionToOffsetDimension;
    // </GEEPL>

    //<GTH>
    boolean isLatestSettlement;
    TaxAmount taxAmountToBeReversed;
    TaxBaseCur taxBaseAmountToBeReversed;
    //</GTH>

    Set                 taxChargeIntercompanySet;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>adjustByPercentage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the amounts on the temporary sales tax window by a percentage.
    /// </summary>
    /// <param name="_flipSign">
    /// A Boolean value that indicates whether to flip the sign on the amounts.
    /// </param>
    /// <param name="_originalCurrency">
    /// The original transactional currency from the <c>TaxTrans</c> record that is being reversed;
    /// optional.
    /// </param>
    /// <param name="_percent">
    /// The percentage used to reverse only a portion of the TaxTrans record;
    /// optional.
    /// </param>
    /// <remarks>
    /// This method is typically used in reversal scenarios to reverse a part of a <c>TaxTrans</c> record.
    /// </remarks>
    protected void adjustByPercentage(boolean _flipSign = true, CurrencyCode _originalCurrency = sourceCurrencyCode, Percent _percent = percent)
    {
        TaxAmount taxAmountRaw;
        Sign sign = _flipSign ? -1 : 1;

        // <GTH>
        boolean   isUnrealizedVATEnabled = TaxThaiGovCertificationFeatureChecker::isUnrealizedVATEnabled();
        // </GTH>

        // <GTH>
        if (isUnrealizedVATEnabled && this.parmIsLatestSettlement_TH())
        {
            taxAmountRaw = (taxWorkTrans.TaxAmount - this.parmTaxAmountTobeReversed_TH()) * sign;
            taxWorkTrans.TaxBaseAmount = (taxWorkTrans.TaxBaseAmount - this.parmTaxBaseAmountTobeReversed_TH()) * sign;
            taxWorkTrans.TaxInCostPrice = taxWorkTrans.TaxInCostPrice * sign;
            taxWorkTrans.TaxInCostPriceMST = taxWorkTrans.TaxInCostPriceMST * sign;
        }
        else
        {
        // </GTH>
            taxAmountRaw = taxWorkTrans.TaxAmount * _percent * sign / 100;
            taxWorkTrans.TaxBaseAmount = CurrencyExchangeHelper::amount(taxWorkTrans.TaxBaseAmount * _percent * sign / 100);
            taxWorkTrans.TaxInCostPrice = CurrencyExchangeHelper::amount(taxWorkTrans.TaxInCostPrice * _percent * sign / 100);
            taxWorkTrans.TaxInCostPriceMST = CurrencyExchangeHelper::amount(taxWorkTrans.TaxInCostPriceMST * _percent * sign / 100);
        // <GTH>
        }
        // </GTH>

        taxWorkTrans.TaxAmount              = CurrencyExchangeHelper::amount(taxAmountRaw);
        taxWorkTrans.TaxInCostPrice         = CurrencyExchangeHelper::amount(taxWorkTrans.TaxInCostPrice * _percent * sign / 100);
        taxWorkTrans.TaxInCostPriceMST      = CurrencyExchangeHelper::amount(taxWorkTrans.TaxInCostPriceMST * _percent * sign / 100);

        if (_originalCurrency == sourceCurrencyCode)
        {
            // reversal happens in a different currency than the original invoice.
            // <GTH>
            if (isUnrealizedVATEnabled && this.parmIsLatestSettlement_TH() && _percent == 100)
            {
                taxWorkTrans.SourceTaxAmountCurReal = taxWorkTrans.SourceRegulateAmountCur * sign;
                taxWorkTrans.SourceBaseAmountCur = (taxWorkTrans.SourceBaseAmountCur - this.parmTaxBaseAmountToBeReversed_TH()) * sign;
            }
            else
            {
            // </GTH>
                taxWorkTrans.SourceTaxAmountCurReal = taxWorkTrans.SourceRegulateAmountCur * _percent * sign / 100;
                taxWorkTrans.SourceBaseAmountCur = CurrencyExchangeHelper::amount(taxWorkTrans.SourceBaseAmountCur * _percent * sign / 100, _originalCurrency);
            // <GTH>
            }
            // </GTH>

            taxWorkTrans.SourceTaxAmountCur         = CurrencyExchangeHelper::amount(taxWorkTrans.SourceTaxAmountCurReal, _originalCurrency);
            taxWorkTrans.TaxInCostPrice             = CurrencyExchangeHelper::amount(taxWorkTrans.TaxInCostPriceRegulated * _percent * sign / 100, _originalCurrency);
            taxWorkTrans.SourceRegulateAmountCur    = taxWorkTrans.SourceTaxAmountCur;
            taxWorkTrans.TaxInCostPriceRegulated    = taxWorkTrans.TaxInCostPrice;
            taxWorkTrans.TaxAutogenerated           = NoYes::Yes;
        }
        else
        {
            // original invoice and reversal are using different currencies
            taxWorkTrans.SourceBaseAmountCur  = CurrencyExchangeHelper::curAmount(taxWorkTrans.TaxBaseAmount,
                                                                                  sourceCurrencyCode,
                                                                                  taxDate,
                                                                                  Currency::noYes2UnknownNoYes(triangulation),
                                                                                  exchRate,
                                                                                  exchRateSecond);

            taxWorkTrans.SourceTaxAmountCur = CurrencyExchangeHelper::curAmount(taxWorkTrans.TaxAmount,
                                                                                sourceCurrencyCode,
                                                                                taxDate,
                                                                                Currency::noYes2UnknownNoYes(triangulation),
                                                                                exchRate,
                                                                                exchRateSecond);
            taxWorkTrans.SourceTaxAmountCurReal = CurrencyExchangeHelper::curAmount(taxAmountRaw,
                                                                                    sourceCurrencyCode,
                                                                                    taxDate,
                                                                                    Currency::noYes2UnknownNoYes(triangulation),
                                                                                    exchRate,
                                                                                    exchRateSecond,
                                                                                    false);
            taxWorkTrans.TaxInCostPrice = CurrencyExchangeHelper::curAmount(CurrencyExchangeHelper::mstAmount(taxWorkTrans.TaxInCostPriceRegulated * _percent * -1 / 100,
                                                                                                                _originalCurrency,
                                                                                                                taxWorkTrans.TransDate,
                                                                                                                Currency::noYes2UnknownNoYes(taxWorkTrans.euroTriangulation)),
                                                                            sourceCurrencyCode,
                                                                            taxDate,
                                                                            Currency::noYes2UnknownNoYes(triangulation),
                                                                            exchRate,
                                                                            exchRateSecond);

            taxWorkTrans.SourceRegulateAmountCur  = taxWorkTrans.SourceTaxAmountCur;
            taxWorkTrans.TaxInCostPriceRegulated  = taxWorkTrans.TaxInCostPrice;
            taxWorkTrans.TaxAutogenerated = NoYes::Yes;
        }

        this.convertCurrencies();
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the ledger dimension for adjustment.
    /// </summary>
    /// <param name = "_ledgerDimension">The ledger dimension.</param>
    /// <param name = "_taxTrans">The buffer of <c>TaxTrans</c>.</param>
    /// <returns>Teh ledger dimension for adjustment.</returns>
    protected LedgerDimensionAccount adjustLedgerDimension(LedgerDimensionAccount _ledgerDimension,
                                                           TaxTrans               _taxTrans)
    {
        return _ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustOperationLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the operation ledger dimension for adjustment.
    /// </summary>
    /// <param name = "_operationLedgerDimension">The operation ledger dimension.</param>
    /// <param name = "_taxTrans">The buffer of <c>TaxTrans</c>.</param>
    /// <returns>The operation ledger dimension for adjustment.</returns>
    protected LedgerDimensionAccount adjustOperationLedgerDimension(LedgerDimensionAccount _operationLedgerDimension,
                                                                    TaxTrans               _taxTrans)
    {
        return _operationLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustTaxOffsetUseTaxLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the offset ledger dimension for adjustment.
    /// </summary>
    /// <param name = "_taxOffsetUseTaxLedgerDimension">The offset ledger dimension.</param>
    /// <param name = "_taxTrans">The buffer of <c>TaxTrans</c>.</param>
    /// <returns>The offset ledger dimension for adjustment.</returns>
    protected LedgerDimensionAccount adjustTaxOffsetUseTaxLedgerDimension(LedgerDimensionAccount _taxOffsetUseTaxLedgerDimension,
                                                                          TaxTrans               _taxTrans)
    {
        return _taxOffsetUseTaxLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustTaxTransDueToExchangeRateGainLoss</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts a <c>TaxTrans</c> record to reflect a gain or loss that is caused by different exchange
    /// rates on the payment.
    /// </summary>
    /// <param name="_originalTaxTrans">
    /// The original <c>TaxTrans</c> record that is being reversed.
    /// </param>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller to use for ledger posting.
    /// </param>
    /// <remarks>
    /// This method is typically used in scenarios such as conditional tax when the payment exchange rates
    /// may be different from the invoice exchange rates that result in a gain or loss in accounting and
    /// reporting currency.
    /// </remarks>
    protected void adjustTaxTransDueToExchangeRateGainLoss(TaxTrans _originalTaxTrans, LedgerPostingController _ledgerPostingController)
    {
        TaxAmount       taxAmountGainLoss;
        TaxAmount       taxChargeGainLoss;
        TaxAmount       taxAmountInvoiceReportingRate;
        TaxAmount       taxAmountSettlementReportingRate;
        TaxAmount       taxInCostPriceCurAmountInvoiceRate;
        TaxAmount       accountingInvoiceTaxAmountCurrentRate;
        TaxAmount       accountingInvoiceTaxInCostPriceCurrentRate;        
        Percent         percentToUse;
        RefRecId        originalRecId;
        boolean         usTaxRules;
        CurrencyCode    reportingCurrencyCode;

        CurrencyExchangeHelper currencyHelper;
        currencyHelper = CurrencyExchangeHelper::newLedger(Ledger::current());

        // check if calculating gain/loss due to exchange rates differences from invoice to payment
        // is enabled
        if (this.parmEnableExchangeRatesGainLoss())
        {
            // this method will use the existing record in taxWorkTrans as a template so
            // there should be a valid record selected
            Debug::assert(taxWorkTrans.RecId);

            originalRecId = taxWorkTrans.RecId;

            // percentage is used in case of partial payments
            percentToUse = percent;
            if (this.parmPercentIncludingCashDiscount())
            {
                percentToUse = this.parmPercentIncludingCashDiscount();
            }

            usTaxRules = this.isUSTaxRulesEnabled(_originalTaxTrans);

            // calculate gain/loss due to exchange rates for tax amount and tax charge.
            currencyHelper.parmExchangeRate1(exchRate);
            currencyHelper.parmExchangeRate2(exchRateSecond);
            currencyHelper.parmReportingExchangeRate1(reportingCurrencyExchRate);
            currencyHelper.parmReportingExchangeRate2(reportingCurrencyExchRateSecondary);

            accountingInvoiceTaxAmountCurrentRate = currencyHelper.calculateTransactionToAccounting(_originalTaxTrans.SourceCurrencyCode, _originalTaxTrans.SourceRegulateAmountCur, true);
                        
            accountingInvoiceTaxInCostPriceCurrentRate = currencyHelper.calculateTransactionToAccounting(_originalTaxTrans.SourceCurrencyCode, _originalTaxTrans.TaxInCostPriceRegulated, true);

            taxAmountGainLoss = (accountingInvoiceTaxAmountCurrentRate * percentToUse/100) - (_originalTaxTrans.TaxAmount * percentToUse / 100);
            taxChargeGainLoss = (accountingInvoiceTaxInCostPriceCurrentRate * percentToUse/100) - (_originalTaxTrans.TaxInCostPriceMST * percentToUse / 100);
            if (taxAmountGainLoss)
            {
                // zero out all amounts;
                taxWorkTrans.zeroOutAllAmounts();

                // for the Thailand purchase unrealized VAT remaining report
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoTH ]))
                {
                    taxWorkTrans.IsReversalGainLoss_TH = true;
                }

                taxWorkTrans.TaxAmount = CurrencyExchangeHelper::amount(taxAmountGainLoss);
                taxWorkTrans.TaxInCostPriceMST = taxChargeGainLoss;

                //gain or loss amount due to exchange rate differnce should not include for use tax trans.
                if(_originalTaxTrans.TaxDirection != TaxDirection::UseTax)
                {
                    gainLossAmountDueToExchangeRates += taxWorkTrans.TaxAmount;
                }

                // update tax amount in tax code currency.
                if (taxWorkTrans.SourceCurrencyCode == taxWorkTrans.CurrencyCode)
                {
                    taxWorkTrans.TaxAmountCur      = taxWorkTrans.SourceRegulateAmountCur;
                    taxWorkTrans.TaxInCostPriceCur = taxWorkTrans.TaxInCostPriceRegulated;
                }
                else
                {
                    taxWorkTrans.TaxAmountCur       = CurrencyExchangeHelper::curAmount(taxWorkTrans.TaxAmount, taxWorkTrans.CurrencyCode, taxDate);
                    taxWorkTrans.TaxInCostPriceCur  = CurrencyExchangeHelper::curAmount(taxWorkTrans.TaxInCostPriceMST, taxWorkTrans.CurrencyCode, taxDate);
                }

                //create new tax record to reflect gain/loss in accounting currency.
                taxWorkTrans.insert();

                // reposition the buffer to what it was at prior to entering this method
                select * from taxWorkTrans where taxWorkTrans.RecId == originalRecId;

                // figure out gain/loss in reporting currency -
                // TaxTrans doesn't track tax amounts in reporting currency so we don't need a
                // Tax record.  We just need to fix GL
                reportingCurrencyCode = Ledger::reportingCurrency();
                if (reportingCurrencyCode)
                {
                    // calculate tax amount in invoice reporting exchange rates
                    if (usTaxRules)
                    {
                        taxInCostPriceCurAmountInvoiceRate = 0;
                    }
                    else
                    {                        
                        taxInCostPriceCurAmountInvoiceRate = _originalTaxTrans.TaxInCostPriceCur;
                    }
                                        
                    currencyHelper.parmReportingExchangeRate1(this.parmInvoiceReportingCrossRate());                                                         
                    taxAmountInvoiceReportingRate = currencyHelper.calculateTransactionCurrencyToReportingCurrency(_originalTaxTrans.SourceCurrencyCode,
                                                    (_originalTaxTrans.SourceRegulateAmountCur - taxInCostPriceCurAmountInvoiceRate) * percentToUse / 100, true);

                    // calculate tax amount in settlement reporting currency exchange rates                    
                    currencyHelper.parmReportingExchangeRate1(this.parmSettlementReportingCrossRate());
                    taxAmountSettlementReportingRate = currencyHelper.calculateTransactionCurrencyToReportingCurrency(_originalTaxTrans.SourceCurrencyCode,
                                                    (_originalTaxTrans.SourceRegulateAmountCur - (_originalTaxTrans.TaxInCostPriceRegulated)) * percentToUse / 100, true);

                    //gain or loss amount due to exchange rate differnce should not include for use tax trans.
                    if(_originalTaxTrans.TaxDirection != TaxDirection::UseTax)
                    {
                        gainLossInReportingCurrency += taxAmountSettlementReportingRate - taxAmountInvoiceReportingRate;

                        this.postGainLossInReportingCurrency(_ledgerPostingController, taxWorkTrans.SourceCurrencyCode, taxWorkTrans.LedgerDimension, taxAmountSettlementReportingRate - taxAmountInvoiceReportingRate);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertCurrencies</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts tax amount for currency.
    /// </summary>
    protected void convertCurrencies()
    {
        TaxCurrencyConversionRoutineHandler handler = TaxCurrencyConversionRoutineHandler::instance();

        // update amounts in accounting currency
        if (sourceCurrencyCode == Ledger::accountingCurrency(this.companyInfo().RecId))
        {
            taxWorkTrans.TaxAmount          = taxWorkTrans.SourceRegulateAmountCur;
            taxWorkTrans.TaxBaseAmount      = taxWorkTrans.SourceBaseAmountCur;
            taxWorkTrans.TaxInCostPriceMST  = taxWorkTrans.TaxInCostPriceRegulated;
        }
        else
        {
            taxWorkTrans.TaxAmount          = CurrencyExchangeHelper::mstAmount(taxWorkTrans.SourceRegulateAmountCur, sourceCurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), exchRate, exchRateSecond);

            taxWorkTrans.TaxBaseAmount      = CurrencyExchangeHelper::mstAmount(taxWorkTrans.SourceBaseAmountCur, sourceCurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), exchRate, exchRateSecond);

            taxWorkTrans.TaxInCostPriceMST  = CurrencyExchangeHelper::mstAmount(taxWorkTrans.TaxInCostPriceRegulated, sourceCurrencyCode, taxDate, Currency::noYes2UnknownNoYes(triangulation), exchRate, exchRateSecond);
        }
        //Feature Sales Tax Conversion
        if (this.isTaxCurrencyConversionFeatureEnabled())
        {
            taxWorkTrans.TaxBaseAmountCur   = handler.transCurrencyToTaxCurrency(sourceCurrencyCode, taxWorkTrans.CurrencyCode, taxWorkTrans.SourceBaseAmountCur,
                                                                                    exchRate, taxWorkTrans.ReportingCurrencyExchRate, taxDate);

            taxWorkTrans.TaxBaseAmountRep   = handler.transCurrencyToReportingCurrency(sourceCurrencyCode, taxWorkTrans.SourceBaseAmountCur,
                                                                                        taxWorkTrans.ReportingCurrencyExchRate, taxDate);

            taxWorkTrans.TaxAmountCur       = handler.transCurrencyToTaxCurrency(sourceCurrencyCode, taxWorkTrans.CurrencyCode, taxWorkTrans.SourceRegulateAmountCur,
                                                                                    exchRate, taxWorkTrans.ReportingCurrencyExchRate, taxDate);

            taxWorkTrans.TaxAmountRep       = handler.transCurrencyToReportingCurrency(sourceCurrencyCode, taxWorkTrans.SourceRegulateAmountCur,
                                                                                        taxWorkTrans.ReportingCurrencyExchRate, taxDate);

            taxWorkTrans.TaxInCostPriceCur  = handler.transCurrencyToTaxCurrency(sourceCurrencyCode, taxWorkTrans.CurrencyCode, taxWorkTrans.TaxInCostPriceRegulated,
                                                                                    exchRate, taxWorkTrans.ReportingCurrencyExchRate, taxDate);

            taxWorkTrans.TaxInCostPriceRep  = handler.transCurrencyToReportingCurrency(sourceCurrencyCode, taxWorkTrans.TaxInCostPriceRegulated,
                                                                                        taxWorkTrans.ReportingCurrencyExchRate, taxDate);

        }
        else
        {
            // update amounts in tax code currency
            if (taxWorkTrans.CurrencyCode && taxWorkTrans.CurrencyCode != Ledger::accountingCurrency(this.companyInfo().RecId))
            {
                if (TaxTable::find(taxWorkTrans.TaxCode).TaxCurrencyCode == sourceCurrencyCode)
                {
                    taxWorkTrans.TaxBaseAmountCur   = taxWorkTrans.SourceBaseAmountCur;
                    taxWorkTrans.TaxAmountCur       = taxWorkTrans.SourceRegulateAmountCur;
                    taxWorkTrans.TaxInCostPriceCur  = taxWorkTrans.TaxInCostPriceRegulated;
                }
                else
                {
                    taxWorkTrans.TaxBaseAmountCur   = CurrencyExchangeHelper::curAmount(taxWorkTrans.TaxBaseAmount, taxWorkTrans.CurrencyCode, taxDate);

                    taxWorkTrans.TaxAmountCur       = CurrencyExchangeHelper::curAmount(taxWorkTrans.TaxAmount, taxWorkTrans.CurrencyCode, taxDate);

                    taxWorkTrans.TaxInCostPriceCur  = CurrencyExchangeHelper::curAmount(taxWorkTrans.TaxInCostPrice, taxWorkTrans.CurrencyCode, taxDate);
                }
            }
            else
            {
                taxWorkTrans.TaxBaseAmountCur   = taxWorkTrans.TaxBaseAmount;
                taxWorkTrans.TaxAmountCur       = taxWorkTrans.TaxAmount;
                taxWorkTrans.TaxInCostPriceCur  = taxWorkTrans.TaxInCostPriceMST;
            }
            taxWorkTrans.TaxBaseAmountRep   = handler.transCurrencyToReportingCurrency(sourceCurrencyCode, taxWorkTrans.SourceBaseAmountCur,
                                                                                        taxWorkTrans.ReportingCurrencyExchRate, taxDate);

            taxWorkTrans.TaxAmountRep       = handler.transCurrencyToReportingCurrency(sourceCurrencyCode, taxWorkTrans.SourceRegulateAmountCur,
                                                                                        taxWorkTrans.ReportingCurrencyExchRate, taxDate);

            taxWorkTrans.TaxInCostPriceRep  = handler.transCurrencyToReportingCurrency(sourceCurrencyCode, taxWorkTrans.TaxInCostPriceRegulated,
                                                                                        taxWorkTrans.ReportingCurrencyExchRate, taxDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates <c>TaxUncommitted</c> records for the current set of <c>TmpTaxWorkTrans</c> records.
    /// </summary>
    /// <param name="_skipNotExistsCheck">
    /// true if the calling code has verified already that no tax uncommitted records exist and the query
    /// to find them can be skipped; otherwise, false.
    /// </param>
    public void createTaxUncommitted(boolean _skipNotExistsCheck = false)
    {
        TaxUncommitted::createTaxUncommitted(this, _skipNotExistsCheck);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionForChargeLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     This method is used to get the correct <c>LedgerDimensionAccount</c> for charge posting.
    /// </summary>
    /// <param name="_chargeAmount">
    ///     The charge amount to post.
    /// </param>
    /// <param name="_operationLedgerDimension">
    ///     The <c>LedgerDimensionAccount</c> from the parent of this tax line.
    /// </param>
    /// <returns>
    ///     The correct <c>LedgerDimensionAccount</c>, which should be the same as the expense/offset ledger account on the invoice
    ///     or a due to/from account if the charge company and tax company is different.
    /// </returns>
    protected LedgerDimensionAccount getLedgerDimensionForChargeLine(TaxAmountCur _chargeAmount, LedgerDimensionAccount _operationLedgerDimension)
    {
        TaxTransGeneralJournalAccountEntry  taxLink;
        GeneralJournalAccountEntry          generalJournalAccountEntry;
        GeneralJournalEntry                 generalJournalEntry;
        LedgerDimensionAccount              chargeLineAccount;
        LedgerDimensionDefaultAccount       dueToFromLedgerDimension;
        LedgerDimensionAccount              expenseLedgerDimension;
        LedgerDimensionAccount              ledgerDimensionMerged;
        LedgerInterCompany                  interCompany;
        TaxChargeIntercompany               taxChargeIntercompany;

        taxChargePostingType = LedgerPostingType::Tax;

        if (_chargeAmount != 0 && TaxParameters::find().PurchTaxOnOperations == false)
        {
            // Find the LedgerDimension and charge company corresponding to the original tax record.
            select firstonly GeneralJournalAccountEntry, LedgerDimension from taxLink
                    where taxLink.TaxTrans == taxWorkTrans.OriginalTaxTrans &&
                        taxLink.TaxTransRelationship == TaxTransRelationshipType::TransactionLineAccount
                join LedgerDimension from generalJournalAccountEntry
                    where generalJournalAccountEntry.RecId == taxLink.GeneralJournalAccountEntry
                join SubledgerVoucherDataAreaID from generalJournalEntry
                    where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId;

            expenseLedgerDimension = taxLink.getLedgerDimension(generalJournalAccountEntry);

            if (generalJournalEntry && generalJournalEntry.SubledgerVoucherDataAreaId != curext())
            {
                // Find the due to/from account to return as the charge account since the charge is in a different company and we can't use the expense account.
                dueToFromLedgerDimension = LedgerInterCompany::getOriginatingCompanyLedgerDimensionWithAmount(
                    _chargeAmount,
                    curExt(),
                    generalJournalEntry.SubledgerVoucherDataAreaId);

                ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(dueToFromLedgerDimension);

                chargeLineAccount = ledgerDimensionMerged;
                taxChargePostingType = LedgerPostingType::CrossCompanySettlement;

                // Find due to/from from account to use in the charge company
                dueToFromLedgerDimension = LedgerInterCompany::getDestinationCompanyLedgerDimensionWithAmount(
                    -_chargeAmount,
                    curExt(),
                    generalJournalEntry.SubledgerVoucherDataAreaId);

                changeCompany(generalJournalEntry.SubledgerVoucherDataAreaId)
                {
                    ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(dueToFromLedgerDimension);
                }

                // Add the information for the charge company accounts into the set which will be used by the CustVendSettle class to create transactions in that company.
                taxChargeIntercompany = TaxChargeIntercompany::construct(generalJournalEntry.SubledgerVoucherDataAreaId,
                                                                        expenseLedgerDimension,
                                                                        ledgerDimensionMerged,
                                                                        _chargeAmount,
                                                                        taxWorkTrans.SourceCurrencyCode);
                taxChargeIntercompanySet.add(taxChargeIntercompany);
            }
            else if (!chargeLineAccount && !expenseLedgerDimension && taxWorkTrans.TaxOrigin == TaxOrigin::CashDisc)
            {
                chargeLineAccount = taxWorkTrans.OperationLedgerDimension;
            }
            if (!chargeLineAccount)
            {
                chargeLineAccount = expenseLedgerDimension;
            }
        }
        else
        {
            chargeLineAccount = _operationLedgerDimension;
        }

        return chargeLineAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionForTaxTrans</Name>
				<Source><![CDATA[
    private container getLedgerDimensionForTaxTrans(TaxTrans _taxTrans)
    {
        LedgerJournalTrans ledgerJournalTrans;
        LedgerJournalTaxDocument ledgerJournalTaxDocument;
        TaxableDocument taxableDocument;
        LedgerDimensionDefaultAccount   defaultAccount;
        LedgerDimensionAccount taxAmountAccount;
        LedgerDimensionAccount useTaxPayableAccount;
        LedgerDimensionAccount transactionLineAccount;
        TaxableLine taxableLine;
        TaxTable taxTable;
        TaxLedgerAccountGroup taxLedgerAccountGroup;
        TaxCalculation taxCalculation;

        if (!this.parmOriginalSourceTableId())
        {
            // If not supplied then default the ID's for the source
            // transaction line using the reversed TaxTrans record.
            // If this isn't correct, the caller most override with correct values.
            this.parmOriginalSourceTableId(_taxTrans.SourceTableId);
            this.parmOriginalSourceRecId(_taxTrans.SourceRecId);
        }

        switch (this.parmOriginalSourceTableId())
        {
            // lookup the source transaction line and derive what the accounts should be.
            // this is typically done when settlements is invoked during transaction posting
            // and the tax link records haven't been written yet resulting in empty ledger dimension.
            case tableNum(LedgerJournalTrans):
                ledgerJournalTrans = LedgerJournalTrans::findRecId(this.parmOriginalSourceRecId(), false);
                ledgerJournalTaxDocument = LedgerJournalTaxDocument::construct(ledgerJournalTrans.JournalNum, ledgerJournalTrans.Voucher, ledgerJournalTrans.Invoice);
                taxableDocument = ledgerJournalTaxDocument as TaxableDocument;

                taxCalculation = TaxCalculation::newForSourceType(TaxSourceType::Journals, ledgerJournalTaxDocument);

                taxTable = TaxTable::find(_taxTrans.TaxCode);
                taxLedgerAccountGroup = TaxLedgerAccountGroup::find(taxTable.TaxAccountGroup);

                taxableLine = taxableDocument.getLineByRecId(ledgerJournalTrans.RecId);

                defaultAccount = taxLedgerAccountGroup.taxLedgerDimension(_taxTrans.TaxDirection);
                taxAmountAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultAccount, taxableLine.getDefaultDimension());

                defaultAccount = taxLedgerAccountGroup.TaxOffsetUseTaxLedgerDimension;
                useTaxPayableAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultAccount, taxableLine.getDefaultDimension());

                transactionLineAccount = taxableLine.getOperationLedgerDimension(taxCalculation.getCompany());
        }

        return [taxAmountAccount, useTaxPayableAccount, transactionLineAccount];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxChargeIntercompanySet</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the set containing the due to/from and expense account information.
    ///     This set only contains data if the tax company is different then the expense/charge company,
    ///     which can only happen if the tax destination is set to 'Source' on the Journal header.
    /// </summary>
    /// <returns>
    ///     Set containing instances of <c>TaxChargeIntercompany</c> class.
    /// </returns>
    public Set getTaxChargeIntercompanySet()
    {
        return taxChargeIntercompanySet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxChargePostingType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the LedgerPostingType for the charge posting.
    /// </summary>
    /// <returns>
    ///     By default, it returns Tax, from the base class.
    /// </returns>
    /// <remarks>
    ///     LedgerPostingType can either be Tax or CrossCompanySettlement depending on whether the tax company is the same as the expense/charge company or not.
    /// </remarks>
    protected LedgerPostingType getTaxChargePostingType()
    {
        return taxChargePostingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalGainLossInAccountingAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the gain or loss amount in accounting currency that is caused by exchange rates.
    /// </summary>
    /// <returns>
    /// The gain or loss in accounting currency that is caused by exchange rates.
    /// </returns>
    public TaxAmount getTotalGainLossInAccountingAmount()
    {
        return gainLossAmountDueToExchangeRates;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalGainLossInReportingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the gain or loss amount in reporting currency that is caused by exchange rates.
    /// </summary>
    /// <returns>
    /// The gain or loss amount in reporting currency that is caused by exchange rates.
    /// </returns>
    public TaxAmount getTotalGainLossInReportingCurrency()
    {
        return gainLossInReportingCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Initializes the <c>TaxTrans</c> record.
    /// </summary>
    /// <param name="taxTrans">
    ///   The <c>TaxTrans</c> record to initialize.
    /// </param>
    /// <param name="_voucherSeriesCode">
    ///   The number sequence code.
    /// </param>
    public void initTaxTrans(TaxTrans taxTrans, NumberSequenceCode _voucherSeriesCode)
    {
        TaxTrans_W  taxTrans_W;

        super(taxTrans, _voucherSeriesCode);

        if (TaxReverseTaxPeriodAndTaxBook_ITFlight::instance().isEnabled()
            && MultipleTaxIdReportingHelper::isLegalEntityOrTaxCodeInCountryRegion(taxTrans.TaxCode, [#isoIT], MultipleTaxIdScope::VATDeclaration)
            && taxWorkTransTaxTransMap.exists(taxWorkTrans.RecId))
        {
            TaxTrans origTaxTrans = TaxTrans::findByRecId(taxWorkTransTaxTransMap.lookup(taxWorkTrans.RecId));
            taxTrans.TaxBook = origTaxTrans.TaxBook;
            taxTrans.TaxBookSection = origTaxTrans.TaxBookSection;
            taxTrans.TaxPeriod = origTaxTrans.TaxPeriod;
        }

        if (TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
        {
            taxTrans_W = taxTrans.taxTrans_W();

            this.parmVatRegData_W([taxTrans_W.VatDueDate_W,
                                  taxTrans_W.DocumentDate_PL,
                                  taxTrans_W.CustVendName_PL,
                                  taxTrans_W.VATNum_PL,
                                  taxTrans_W.Addressing_PL,
                                  taxTrans_W.TaxPeriodPaymentCode_PL]);

            this.initVatRegData_W(taxTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxWorkTransLedgerDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the ledger dimensions for the <c>TaxWorkTrans</c> record.
    /// </summary>
    /// <param name="_taxTrans">
    ///    The tax transaction for reversal.
    /// </param>
    public void initTaxWorkTransLedgerDimensions(TaxTrans _taxTrans)
    {
        LedgerVoucherObject                 ledgerVoucherObject;
        LedgerVoucherTransList              list;
        LedgerVoucherTransObject            transaction;
        LedgerPostingOneToManyCollection    taxLinks;
        boolean                             transactionFound;
        Set                                 taxLinkSet;
        SetEnumerator                       enumerator;
        TaxTransRelationshipType            taxTransRelationshipType;

        taxWorkTrans.LedgerDimension                = TaxTransGeneralJournalAccountEntry::getTaxLedgerDimensionForTaxTrans(_taxTrans.RecId);
        taxWorkTrans.TaxOffsetUseTaxLedgerDimension = TaxTransGeneralJournalAccountEntry::getLedgerDimensionForTaxTrans(_taxTrans.RecId, TaxTransRelationshipType::UseTaxPayable);
        taxWorkTrans.OperationLedgerDimension       = TaxTransGeneralJournalAccountEntry::getLedgerDimensionForTaxTrans(_taxTrans.RecId, TaxTransRelationshipType::TransactionLineAccount);

        // if the document being settled has not been posted, the tax links above will not return values.
        // We will discover the accounts using the Ledger posting framework

        // There are some valid scenarios for which the OperationLedgerDimension are empty so
        // we won't check for that in this if condition like we do with LedgerDimension.  If the LedgerDimension is set
        // then the OperationLedgerDimension should have a correct value - If the LedgerDimension is empty then the
        // OperationLedgerDimension will be incorrect.
        if (!taxWorkTrans.LedgerDimension && relatedLedgerVoucher)
        {
            ledgerVoucherObject = relatedLedgerVoucher.findReference(_taxTrans.Voucher, _taxTrans.TransDate, relatedLedgerVoucher.lastPostingLayer());

            if (ledgerVoucherObject)
            {
                list = ledgerVoucherObject.getInternalCollection();
                transactionFound = list.first();

                while (transactionFound)
                {
                    transaction = list.item();
                    taxLinks = transaction.parmTaxLinks();
                    taxLinkSet = taxLinks.find(_taxTrans.RecId);

                    // There are 2 ways transactions can create a relationship for TransactionLineAccount and
                    // the following if condition and the if condition below check for both ways of doing it.
                    // A transaction generally won't use both, or if they did then the value retrieved should be the same.
                    if (transaction.parmTaxParentReferenceTableId() == _taxTrans.SourceTableId &&
                        transaction.parmTaxParentReferenceRecId() == _taxTrans.SourceRecId)
                    {
                        taxWorkTrans.OperationLedgerDimension = transaction.parmLedgerDimensionId();
                    }

                    if (taxLinkSet.elements() > 0)
                    {
                        enumerator = taxLinkSet.getEnumerator();

                        while (enumerator.moveNext())
                        {
                            // The TaxTransRelationshipType is the first object in the container
                            taxTransRelationshipType = conPeek(enumerator.current(), 1);

                            if (taxTransRelationshipType == TaxTransRelationshipType::Tax ||
                                taxTransRelationshipType == TaxTransRelationshipType::TaxInCostPrice)
                            {
                                taxWorkTrans.LedgerDimension = transaction.parmLedgerDimensionId();
                            }

                            if (!taxWorkTrans.TaxOffsetUseTaxLedgerDimension &&
                                 taxTransRelationshipType == TaxTransRelationshipType::UseTaxPayable)
                            {
                                taxWorkTrans.TaxOffsetUseTaxLedgerDimension = transaction.parmLedgerDimensionId();
                            }

                            if (!taxWorkTrans.OperationLedgerDimension &&
                                 taxTransRelationshipType == taxTransRelationshipType::TransactionLineAccount)
                            {
                                taxWorkTrans.OperationLedgerDimension = transaction.parmLedgerDimensionId();
                            }
                        }
                    }

                    transactionFound = list.next();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new(Percent        _percent)
    {
        percent         = _percent;

        super();

        allowGainLossDueToExchangeRates = false;
        taxWorkTransTaxTransMap = new Map(Types::Int64, Types::Int64);
        taxChargeIntercompanySet = new Set(Types::Class);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCopyDistributionToOffsetDimension_W</Name>
				<Source><![CDATA[
    public boolean parmCopyDistributionToOffsetDimension_W(boolean _copyDistributionToOffsetDimension = copyDistributionToOffsetDimension)
    {
        copyDistributionToOffsetDimension = _copyDistributionToOffsetDimension;
        return copyDistributionToOffsetDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEnableExchangeRatesGainLoss</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets whether the reversal should check for gain or loss due to exchange rates.
    /// </summary>
    /// <param name="_enableGainLoss">
    /// true if the reversal should check and update <c>TaxTrans</c> due to gain or loss due to exchange rates.
    /// </param>
    /// <returns>
    /// true if the reversal should check and update <c>TaxTrans</c> due to gain or loss due to exchange rates; otherwise, false.
    /// </returns>
    public boolean parmEnableExchangeRatesGainLoss(boolean _enableGainLoss = allowGainLossDueToExchangeRates)
    {
        allowGainLossDueToExchangeRates = _enableGainLoss;
        return allowGainLossDueToExchangeRates;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHeadingRecId</Name>
				<Source><![CDATA[
    public RefRecId parmHeadingRecId(RefRecId _headingRecId = headingRecId)
    {
        headingRecId = _headingRecId;

        return headingRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHeadingTableId</Name>
				<Source><![CDATA[
    public RefTableId parmHeadingTableId(RefTableId _headingTableId = headingTableId)
    {
        headingTableId = _headingTableId;

        return headingTableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInvoiceReportingCrossRate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This will get/set the reporting currency cross rate from the original invoice.
    /// </summary>
    /// <param name="_reportingInvoiceCrossRate">
    ///    The reporting currency cross rate from the original invoice to use.
    /// </param>
    /// <returns>
    ///    The reporting currency cross rate.
    /// </returns>
    public ExchRate parmInvoiceReportingCrossRate(ExchRate _reportingInvoiceCrossRate = reportingInvoiceCrossRate)
    {
        reportingInvoiceCrossRate = _reportingInvoiceCrossRate;
        return reportingInvoiceCrossRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOriginalSourceRecId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This will get/set the original source record Id for the <c>TaxTrans</c> record being reversed.
    /// </summary>
    /// <param name="_originalSourceRecId">
    ///    The original source record ID.
    /// </param>
    /// <returns>
    ///    The original source record ID.
    /// </returns>
    protected RefRecId parmOriginalSourceRecId(RefRecId _originalSourceRecId = originalSourceRecId)
    {
        originalSourceRecId = _originalSourceRecId;
        return originalSourceRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOriginalSourceTableId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This will get/set the original source table Id for the <c>TaxTrans</c> record being reversed.
    /// </summary>
    /// <param name="_originalSourceTableId">
    ///    The original source Table ID.
    /// </param>
    /// <returns>
    ///    The original source Table ID.
    /// </returns>
    protected RefTableId parmOriginalSourceTableId(RefTableId _originalSourceTableId = originalSourceTableId)
    {
        originalSourceTableId = _originalSourceTableId;
        return originalSourceTableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPercentIncludingCashDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the percentage including cash discount to be used when calculating gain or loss due to exchange rates.
    /// </summary>
    /// <param name="_percentIncludingCashDiscount">
    /// Percentage of partial payment including cash discount amount.
    /// </param>
    /// <returns>
    /// Percentage of partial payment including cash discount amount.
    /// </returns>
    public Percent parmPercentIncludingCashDiscount(Percent _percentIncludingCashDiscount = percentIncludingCashDiscount)
    {
        percentIncludingCashDiscount = _percentIncludingCashDiscount;
        return percentIncludingCashDiscount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRelatedLedgerVoucher</Name>
				<Source><![CDATA[
    public LedgerVoucher parmRelatedLedgerVoucher(LedgerVoucher _relatedLedgerVoucher = relatedLedgerVoucher)
    {
        relatedLedgerVoucher = _relatedLedgerVoucher;
        return relatedLedgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReverseTaxJournalId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This will get/set the ledger journal number for the <c>TaxTrans</c> record being reversed.
    /// </summary>
    /// <param name="_reverseTaxJournalId">
    ///    The ledger journal number.
    /// </param>
    /// <returns>
    ///    The ledger journal number.
    /// </returns>
    public LedgerJournalId parmReverseTaxJournalId(LedgerJournalId _reverseTaxJournalId = reverseTaxJournalId)
    {
        reverseTaxJournalId = _reverseTaxJournalId;
        return reverseTaxJournalId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsLatestSettlement_TH</Name>
				<Source><![CDATA[
    public boolean parmIsLatestSettlement_TH(boolean _isLatestSettlement = isLatestSettlement)
    {
        isLatestSettlement = _isLatestSettlement;

        return isLatestSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxAmountToBeReversed_TH</Name>
				<Source><![CDATA[
    public TaxAmount parmTaxAmountToBeReversed_TH(TaxAmount _taxAmount = taxAmountToBeReversed)
    {
        taxAmountToBeReversed = _taxAmount;

        return taxAmountToBeReversed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxBaseAmountToBeReversed_TH</Name>
				<Source><![CDATA[
    public TaxAmount parmTaxBaseAmountToBeReversed_TH(TaxBaseCur _taxBaseCur = taxBaseAmountToBeReversed)
    {
        taxBaseAmountToBeReversed = _taxBaseCur;

        return taxBaseAmountToBeReversed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSettlementReportingCrossRate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This will get/set the reporting currency cross rate from the settlement.
    /// </summary>
    /// <param name="_reportingSettlementCrossRate">
    ///    The reporting currency cross rate from the settlement to use.
    /// </param>
    /// <returns>
    ///    The reporting currency cross rate from the settlement.
    /// </returns>
    public ExchRate parmSettlementReportingCrossRate(ExchRate _reportingSettlementCrossRate = reportingSettlementCrossRate)
    {
        reportingSettlementCrossRate = _reportingSettlementCrossRate;
        return reportingSettlementCrossRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>post</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates ledger postings for reversed tax transactions.
    /// </summary>
    /// <param name="_ledgerPostingController">
    ///    Posting controller to be used for posting
    /// </param>
    /// <param name="_taxTrans">
    ///    The reversed tax transaction
    /// </param>
    /// <param name="_taxAmount">
    ///    The total tax amount to be reversed
    /// </param>
    /// <param name="_chargeAmount">
    ///    The total tax charge amount to be reversed
    /// </param>
    /// <param name="_exchRateHelper">
    ///    The currency conversion helper
    /// </param>
    /// <param name="_ledgerDimension">
    ///     The ledger dimension
    /// </param>
    /// <param name="_transactionLineLedgerDimension">
    ///     The operation ledger dimension
    /// </param>
    /// <param name="_taxOffsetUseTaxLedgerDimension">
    ///     The offset ledger dimension
    /// </param>
    /// <param name="_ledgerDetailLevel">
    ///     The ledger detail level for posting
    /// </param>
    /// <param name="_projLedger">
    ///     An instance of <c>ProjLedger</c> class. This is instantiated only for Project taxes.
    /// </param>
    /// <param name="_offsetLedgerDimension">
    ///     The offset ledger dimension for amount to be reversed
    /// </param>
    /// <param name="_amountMSTSecondary">
    ///     The total tax amount in reporting currency to be reversed
    /// </param>
    protected void post(LedgerPostingController _ledgerPostingController,
                        TaxTrans                _taxTrans,
                        TaxAmount               _taxAmount,
                        TaxAmount               _chargeAmount,
                        CurrencyExchangeHelper  _exchRateHelper,
                        LedgerDimensionAccount  _ledgerDimension,
                        LedgerDimensionAccount  _transactionLineLedgerDimension,
                        LedgerDimensionAccount  _taxOffsetUseTaxLedgerDimension,
                        LedgerDetailLevel       _ledgerDetailLevel   = LedgerDetailLevel::AsDefault,
                        ProjLedger              _projLedger = null
                        ,LedgerDimensionAccount _offsetLedgerDimension = 0,
                        AmountMSTSecondary      _amountMSTSecondary    = 0
                        )
    {
        LedgerDimensionAccount  ledgerDimension;
        LedgerDimensionAccount  transactionLineLedgerDimension;
        LedgerDimensionAccount  taxOffsetUseTaxLedgerDimension;

        AccountingDistribution  taxTransDistribution;
        AccountingDistribution  parentDistribution;

        boolean                 distributionsFound;

        TaxAmount               totalPostedTaxAmount;
        TaxAmount               totalPostedChargeAmount;
        TaxBaseCur              totalSourceBaseAmountCur;

        TaxAmount               distributedTaxAmount;
        TaxAmount               distributedChargeAmount;
        TaxBaseCur              distributedSourceBaseAmountCur;

        AllocationFactor        totalAllocationFactor;

        // set reporting currency on CurrencyExchangeHelper
        if (!this.parmSettlementReportingCrossRate() && this.parmReportingCurrencyExchRate())
        {
            _exchRateHelper.parmReportingExchangeRate1(this.parmReportingCurrencyExchRate());
        }
        else
        {
            _exchRateHelper.parmReportingExchangeRate1(this.parmSettlementReportingCrossRate());
        }

        while select * from taxTransDistribution
            where taxTransDistribution.SourceDocumentLine == _taxTrans.SourceDocumentLine &&
                taxTransDistribution.ReferenceRole        != AccountingDistributionReferenceRole::Reversing &&
                taxTransDistribution.MonetaryAmount       == MonetaryAmount::Tax
        join LedgerDimension from parentDistribution
            where parentDistribution.RecId == taxTransDistribution.ParentDistribution
        {
            distributionsFound = true;

            distributedTaxAmount            = CurrencyExchangeHelper::amount(_taxAmount * taxTransDistribution.AllocationFactor, _taxTrans.CurrencyCode);
            distributedChargeAmount         = CurrencyExchangeHelper::amount(_chargeAmount * taxTransDistribution.AllocationFactor, _taxTrans.CurrencyCode);
            distributedSourceBaseAmountCur  = CurrencyExchangeHelper::amount(_taxTrans.SourceBaseAmountCur * taxTransDistribution.AllocationFactor, _taxTrans.CurrencyCode);

            totalPostedTaxAmount     += distributedTaxAmount;
            totalPostedChargeAmount  += distributedChargeAmount;
            totalSourceBaseAmountCur += distributedSourceBaseAmountCur;
            totalAllocationFactor             += taxTransDistribution.AllocationFactor;

            if (totalAllocationFactor == 1) //add the difference caused by division and rounding to the last posting
            {
                distributedTaxAmount            += _taxAmount - totalPostedTaxAmount;
                distributedChargeAmount         += _chargeAmount - totalPostedChargeAmount;
                distributedSourceBaseAmountCur  += _taxTrans.SourceBaseAmountCur - totalSourceBaseAmountCur;
            }

            if (_ledgerDimension)
            {
                ledgerDimension = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(
                    LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(_ledgerDimension),
                    taxTransDistribution.LedgerDimension);
            }
            else
            {
                ledgerDimension = this.adjustLedgerDimension(taxTransDistribution.LedgerDimension, _taxTrans);
            }

            // <GEEPL>
            if (_offsetLedgerDimension && copyDistributionToOffsetDimension)
            {
                _offsetLedgerDimension = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(
                    LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(_offsetLedgerDimension),
                    taxTransDistribution.LedgerDimension);
            }
            // </GEEPL>

            taxOffsetUseTaxLedgerDimension = this.adjustTaxOffsetUseTaxLedgerDimension(_taxOffsetUseTaxLedgerDimension, _taxTrans);
            transactionLineLedgerDimension = this.adjustOperationLedgerDimension(parentDistribution.LedgerDimension, _taxTrans);

            if (!_taxAmount && _taxTrans.TaxAmount)
            {
                this.postAccountingCurrency(
                    _ledgerPostingController,
                    _taxTrans,
                    _ledgerDimension ? _ledgerDimension : ledgerDimension,
                    _transactionLineLedgerDimension ? _transactionLineLedgerDimension : transactionLineLedgerDimension,
                    _taxOffsetUseTaxLedgerDimension ? _taxOffsetUseTaxLedgerDimension : taxOffsetUseTaxLedgerDimension,
                    _exchRateHelper,
                    _ledgerDetailLevel);

                // Exchange rate difference amount in accounting currency does not get distributed in accordance with accounting distributions
                // in order to maintain consistency with exchange rate difference in reporting currency posting and their corresponding offsets, which themselves do not get distributed.
                // Hence post the full Exchange rate difference amount in accounting currency, then exit out of the loop to avoid
                // posting this amount multiple times if multiple distributions are found.
                break;
            }
            else
            {
                super(_ledgerPostingController,
                      _taxTrans,
                      distributedTaxAmount,
                      distributedChargeAmount,
                      _exchRateHelper,
                      ledgerDimension,
                      transactionLineLedgerDimension,
                      taxOffsetUseTaxLedgerDimension,
                      _ledgerDetailLevel,
                      _projLedger
                      // <GEERU>
                      ,_offsetLedgerDimension,
                      _amountMSTSecondary
                      // </GEERU>
                      );
            }

            conLedgerDimension      += transactionLineLedgerDimension;
            conSourceBaseAmountCur  += distributedSourceBaseAmountCur;
            taxTransRecId           += _taxTrans.RecId;
            if (taxWorkTransTaxTransMap.exists(taxWorkTrans.RecId))
            {
                originalTaxTransRecId += taxWorkTransTaxTransMap.lookup(taxWorkTrans.RecId);
            }
        }

        if (!distributionsFound)
        {
            if (!_ledgerDimension)
            {
                // settlements is invoked during transaction posting and the tax link records
                // haven't been written yet resulting in empty ledger dimension. Rederive the appropriate
                // LedgerDimensions.

                // _ledgerDimension should always have a value - the others are optional and need not be checked.
                // It can be assume that if _ledgerDimension is empty then the others need to be defaulted also.
                [ledgerDimension, taxOffsetUseTaxLedgerDimension, transactionLineLedgerDimension] = this.getLedgerDimensionForTaxTrans(_taxTrans);
            }
            else
            {
                ledgerDimension = _ledgerDimension;
                taxOffsetUseTaxLedgerDimension = _taxOffsetUseTaxLedgerDimension;
                transactionLineLedgerDimension = _transactionLineLedgerDimension;
            }

            if (!_taxAmount && _taxTrans.TaxAmount)
            {
                this.postAccountingCurrency(_ledgerPostingController,
                                            _taxTrans,
                                            _ledgerDimension,
                                            _transactionLineLedgerDimension,
                                            _taxOffsetUseTaxLedgerDimension,
                                            _exchRateHelper,
                                            _ledgerDetailLevel);
            }
            else
            {
                super(_ledgerPostingController,
                      _taxTrans,
                      _taxAmount,
                      _chargeAmount,
                      _exchRateHelper,
                      ledgerDimension,
                      transactionLineLedgerDimension,
                      taxOffsetUseTaxLedgerDimension,
                      _ledgerDetailLevel,
                      _projLedger
                      // <GEERU>
                      ,_offsetLedgerDimension,
                      _amountMSTSecondary
                      // </GEERU>
                     );
            }

            conLedgerDimension      += _transactionLineLedgerDimension;
            conSourceBaseAmountCur  += _taxTrans.SourceBaseAmountCur;
            taxTransRecId           += _taxTrans.RecId;
            if (taxWorkTransTaxTransMap.exists(taxWorkTrans.RecId))
            {
                originalTaxTransRecId += taxWorkTransTaxTransMap.lookup(taxWorkTrans.RecId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postAccountingCurrency</Name>
				<Source><![CDATA[
    [Hookable(true)]
    private void postAccountingCurrency(LedgerPostingController _ledgerPostingController,
                                         TaxTrans                 _taxTrans,
                                         LedgerDimensionAccount   _ledgerDimension,
                                         LedgerDimensionAccount   _operationLedgerDimension,
                                         LedgerDimensionAccount   _taxOffsetUseTaxLedgerDimension,
                                         CurrencyExchangeHelper   _exchRateHelper,
                                         LedgerDetailLevel        _ledgerDetailLevel = LedgerDetailLevel::AsDefault)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject;

        if (this.isOutGoingTax(_taxTrans))
        {
            ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(_ledgerPostingController.getReference(),
                                                                                    LedgerPostingType::Tax,
                                                                                    _ledgerDimension,
                                                                                    _taxTrans.SourceCurrencyCode,
                                                                                    _taxTrans.TaxAmount - _taxTrans.TaxInCostPriceMST,
                                                                                    0);

            // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
            if (_taxTrans)
            {
                // TaxTrans will not exist in the case where a transaction is only being validated,
                // and in that case the tax trans relationship should not be created
                ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId,
                                                                 TaxTransRelationshipType::Tax,
                                                                 curext(),
                                                                 ledgerVoucherTransObject.parmAccountingCurrencyAmount(),
                                                                 ledgerVoucherTransObject.parmTransactionCurrencyAmount());
            }

            ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);

            if (_taxTrans.TaxOrigin == TaxOrigin::TaxReversed || _taxTrans.TaxOrigin == TaxOrigin::CashDisc)
            {
                 ledgerVoucherTransObject.parmSkipDimensionValidation(true);
            }

            _ledgerPostingController.addTrans(ledgerVoucherTransObject);
        }

        if (this.isIncomingTaxEnabled(_taxTrans))
        {
            ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(_ledgerPostingController.getReference(),
                                                                                LedgerPostingType::Tax,
                                                                                _ledgerDimension,
                                                                                _taxTrans.SourceCurrencyCode,
                                                                                _taxTrans.TaxAmount,
                                                                                0);

            // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
            if (_taxTrans)
            {
                // TaxTrans will not exist in the case where a transaction is only being validated,
                // and in that case the tax trans relationship should not be created
                ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId,
                                                                 TaxTransRelationshipType::Tax,
                                                                 curext(),
                                                                 ledgerVoucherTransObject.parmAccountingCurrencyAmount(),
                                                                 ledgerVoucherTransObject.parmTransactionCurrencyAmount());
            }

            ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);

            if (_taxTrans.TaxOrigin == TaxOrigin::TaxReversed || _taxTrans.TaxOrigin == TaxOrigin::CashDisc)
            {
                ledgerVoucherTransObject.parmSkipDimensionValidation(true);
            }

            _ledgerPostingController.addTrans(ledgerVoucherTransObject);
        }

        if (_taxTrans.TaxDirection == TaxDirection::UseTax)
        {
            ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(_ledgerPostingController.getReference(),
                                                                                LedgerPostingType::Tax,
                                                                                _taxOffsetUseTaxLedgerDimension,
                                                                                _taxTrans.SourceCurrencyCode,
                                                                                _taxTrans.TaxAmount * -1,
                                                                                0);

            // If TaxTrans exists, create the relationship between TaxTrans and LedgerEntry for the tax amount
            if (_taxTrans)
            {
                // TaxTrans will not exist in the case where a transaction is only being validated,
                // and in that case the tax trans relationship should not be created
                ledgerVoucherTransObject.addTaxTransRelationship(_taxTrans.RecId,
                                                                 TaxTransRelationshipType::UseTaxPayable,
                                                                 curext(),
                                                                 ledgerVoucherTransObject.parmAccountingCurrencyAmount(),
                                                                 ledgerVoucherTransObject.parmTransactionCurrencyAmount());
            }

            ledgerVoucherTransObject.parmLedgerDetailLevel(_ledgerDetailLevel);

            if (_taxTrans.TaxOrigin == TaxOrigin::TaxReversed || _taxTrans.TaxOrigin == TaxOrigin::CashDisc)
            {
                ledgerVoucherTransObject.parmSkipDimensionValidation(true);
            }

            _ledgerPostingController.addTrans(ledgerVoucherTransObject);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCharge</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts the sales tax charge.
    /// </summary>
    /// <param name="_ledgerPostingController">
    ///    The ledger posting controller to use for ledger posting.
    /// </param>
    /// <param name="_taxTrans">
    ///    The <c>TaxTrans</c> record that holds the amount to be posted.
    /// </param>
    /// <param name="_chargeAmount">
    ///    The charge amount to post.
    /// </param>
    /// <param name="_exchRateHelper">
    ///    The <c>CurrencyExchHelper</c> instance for the <c>TaxTrans</c> record being posted.
    /// </param>
    /// <param name="_transactionLineAccount">
    ///    The <c>LedgerDimensionAccount</c> from the parent of this tax line.
    /// </param>
    void postCharge(LedgerPostingController _ledgerPostingController,
                    TaxTrans                _taxTrans,
                    TaxAmountCur            _chargeAmount,
                    CurrencyExchangeHelper  _exchRateHelper,
                    LedgerDimensionAccount  _transactionLineAccount)
    {
        AccountingDistribution  taxTransDistribution;
        AccountingDistribution  parentDistribution;

        boolean                 distributionsFound;

        TaxAmount               distributedChargeAmount;
        TaxAmount               totalPostedChargeAmount;
        AllocationFactor        totalAllocationFactor;

        // set reporting currency on CurrencyExchangeHelper
        if (!this.parmSettlementReportingCrossRate() && this.parmReportingCurrencyExchRate())
        {
            _exchRateHelper.parmReportingExchangeRate1(this.parmReportingCurrencyExchRate());
        }
        else
        {
            _exchRateHelper.parmReportingExchangeRate1(this.parmSettlementReportingCrossRate());
        }

        while select * from taxTransDistribution
            where taxTransDistribution.SourceDocumentLine == _taxTrans.SourceDocumentLine &&
                taxTransDistribution.ReferenceRole        != AccountingDistributionReferenceRole::Reversing &&
                (taxTransDistribution.MonetaryAmount       == MonetaryAmount::TaxNonRecoverable ||
                taxTransDistribution.MonetaryAmount           == MonetaryAmount::TaxMeasureNonRecoverable)
        join LedgerDimension from parentDistribution
            where parentDistribution.RecId == taxTransDistribution.ParentDistribution
        {
            distributedChargeAmount   = CurrencyExchangeHelper::amount(_chargeAmount * taxTransDistribution.AllocationFactor, _taxTrans.CurrencyCode);

            totalPostedChargeAmount  += distributedChargeAmount;
            totalAllocationFactor             += taxTransDistribution.AllocationFactor;

            if (totalAllocationFactor == 1) //add the difference caused by division and rounding to the last posting
            {
                distributedChargeAmount         += _chargeAmount - totalPostedChargeAmount;
            }

            if (this.isChargeAmountPosting(_taxTrans, _chargeAmount))
            {
                this.postChargeAccountingCurrency(_ledgerPostingController,
                  _taxTrans,
                  distributedChargeAmount,
                  _exchRateHelper,
                  _transactionLineAccount);
            }
            else
            {
                super(_ledgerPostingController,
                      _taxTrans,
                      distributedChargeAmount,
                      _exchRateHelper,
                      _transactionLineAccount);
            }
            distributionsFound      = true;
        }

        if (!distributionsFound)
        {
            if (!_chargeAmount && _taxTrans.TaxInCostPriceMST && !this.taxParameters().PurchTaxOnOperations)
            {
                this.postChargeAccountingCurrency(_ledgerPostingController,
                  _taxTrans,
                  _chargeAmount,
                  _exchRateHelper,
                  _transactionLineAccount);
            }
            else
            {
                super(_ledgerPostingController,
                        _taxTrans,
                        _chargeAmount,
                        _exchRateHelper,
                        _transactionLineAccount);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postChargeAccountingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the sales tax charge for accounting currency.
    /// </summary>
    /// <param name = "_ledgerPostingController">The ledger posting controller to use for ledger posting.</param>
    /// <param name = "_taxTrans">The <c>TaxTrans</c> record that holds the amount to be posted.</param>
    /// <param name = "_chargeAmount">The charge amount to post.</param>
    /// <param name = "_exchRateHelper">The <c>CurrencyExchHelper</c> instance for the <c>TaxTrans</c> record being posted.</param>
    /// <param name = "_transactionLineAccount">The <c>LedgerDimensionAccount</c> from the parent of this tax line.</param>
    protected void postChargeAccountingCurrency(LedgerPostingController _ledgerPostingController,
                    TaxTrans                _taxTrans,
                    TaxAmountCur            _chargeAmount,
                    CurrencyExchangeHelper  _exchRateHelper,
                    LedgerDimensionAccount  _transactionLineAccount)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject;
        boolean isFound;

        // this code previously existed in
        ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(_ledgerPostingController.getReference(),
                                                                            LedgerPostingType::Tax,
                                                                            _transactionLineAccount,
                                                                            _taxTrans.SourceCurrencyCode,
                                                                            _taxTrans.TaxInCostPriceMST,
                                                                            0);
        ledgerVoucherTransObject.parmLedgerDetailLevel(LedgerDetailLevel::Detail);

        isFound = _ledgerPostingController.findReference(_taxTrans.Voucher, _taxTrans.TransDate);
        if (!isFound)
        {
            // when tax is using document date, the date tax has will differ from the date
            // the Journals use.
            isFound = _ledgerPostingController.findReference(_taxTrans.Voucher, _ledgerPostingController.getJournal().lastTransDate());
            Debug::assert(isFound);
        }

        _ledgerPostingController.addTrans(ledgerVoucherTransObject);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postGainLossInReportingCurrency</Name>
				<Source><![CDATA[
    [Hookable(true)]
    private void postGainLossInReportingCurrency(LedgerPostingController _ledgerPostingController, CurrencyCode transactionCurrencyCode, LedgerDimensionAccount _ledgerDimension, TaxAmount reportingGainLossAmount)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject;

        ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(_ledgerPostingController.getReference(),
                                                                                  LedgerPostingType::Tax,
                                                                                  _ledgerDimension,
                                                                                  transactionCurrencyCode,
                                                                                  0,
                                                                                  reportingGainLossAmount);

        ledgerVoucherTransObject.parmSkipDimensionValidation(true);
        _ledgerPostingController.addTrans(ledgerVoucherTransObject);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reverses all <c>TaxUncommitted</c> records for a source transaction line.
    /// </summary>
    /// <param name="_originalSourceTableId">
    /// The table ID of the source transaction line.
    /// </param>
    /// <param name="_originalSourceRecId">
    /// The record ID of the source transaction line.
    /// </param>
    /// <param name="_reversalSourceTableId">
    /// The table ID of the transaction line to attach the reversing <c>TaxUncommitted</c> records.
    /// </param>
    /// <param name="_reversalSourceRecId">
    /// The record ID of the transaction line to attach the reversing <c>TaxUncommitted</c> records.
    /// </param>
    /// <param name="_voucher">
    /// The voucher number of the transaction line to set on the reversing <c>TaxUncommitted</c> records.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date of the transaction line to set on the reversing <c>TaxUncommitted</c> records.
    /// </param>
    public static void reverseTaxUncommitted(RefTableId _originalSourceTableId,
                                    RefRecId _originalSourceRecId,
                                    RefTableId _reversalSourceTableId,
                                    RefRecId _reversalSourceRecId,
                                    Voucher _voucher,
                                    date    _transDate)
    {
        TaxUncommitted sourceTaxUncommitted;

        while select * from sourceTaxUncommitted
            where sourceTaxUncommitted.SourceTableId == _originalSourceTableId &&
                  sourceTaxUncommitted.SourceRecId == _originalSourceRecId
        {
            sourceTaxUncommitted.reverseSignOnAmounts();
            sourceTaxUncommitted.SourceTableId = _reversalSourceTableId;
            sourceTaxUncommitted.SourceRecId = _reversalSourceRecId;
            sourceTaxUncommitted.Voucher = _voucher;
            sourceTaxUncommitted.TransDate = _transDate;
            sourceTaxUncommitted.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUSTaxRulesEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether enable US taxation rule.
    /// </summary>
    /// <param name="_originalTaxTrans">
    /// The original <c>TaxTrans</c> record that is being reversed.
    /// </param>
    /// <returns>
    /// True if enable US taxation rule, otherwise, false.
    /// </returns>
    [Hookable(true)]
    protected boolean isUSTaxRulesEnabled(TaxTrans _originalTaxTrans)
    {
        return this.taxParameters().PurchTaxOnOperations; 
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOutGoingTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether post for out going tax.
    /// </summary>
    /// <param name = "_taxTrans">
    /// The <c>TaxTrans</c> record.
    /// </param>
    /// <returns>
    /// True if post for out going tax, otherwise, false.
    /// </returns>
    [Hookable(true)]
    protected boolean isOutGoingTax(TaxTrans _taxTrans)
    {
        return ! this.taxParameters().PurchTaxOnOperations || _taxTrans.TaxDirection == TaxDirection::OutgoingTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isIncomingTaxEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether post for in coming tax.
    /// </summary>
    /// <param name = "_taxTrans">
    /// The <c>TaxTrans</c> record.
    /// </param>
    /// <returns>
    /// True if post for in coming tax, otherwise, false.
    /// </returns>
    [Hookable(true)]
    protected boolean isIncomingTaxEnabled(TaxTrans _taxTrans)
    {
        return this.taxParameters().PurchTaxOnOperations
            && (_taxTrans.TaxDirection == TaxDirection::IncomingTax
                || _taxTrans.TaxDirection == TaxDirection::UseTax)
            && this.postSalesTaxReceivableAmounts();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isChargeAmountPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether post charge amount.
    /// </summary>
    /// <param name="_taxTrans">
    /// The <c>TaxTrans</c> record that holds the amount to be posted.
    /// </param>
    /// <param name="_chargeAmount">
    /// The charge amount to post.
    /// </param>
    /// <returns>
    /// True if post charge amount, otherwise, false.
    /// </returns>
    protected boolean isChargeAmountPosting(TaxTrans _taxTrans, TaxAmountCur _chargeAmount)
    {
        return !_chargeAmount && _taxTrans.TaxInCostPriceMST && !this.taxParameters().PurchTaxOnOperations;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>