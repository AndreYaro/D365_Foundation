<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxVatRegisterDP</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>TaxVatRegisterDP</c> class generates data for the <c>TaxVatRegister</c> report.
/// </summary>
[
    SRSReportQueryAttribute(queryStr(TaxVatRegister)),
    SRSReportParameterAttribute(classStr(TaxVatRegisterContract))
]
public class TaxVatRegisterDP extends SrsReportDataProviderPreProcessTempDB
{
    boolean printEmptyPaymentCode;
    boolean showDetails;
    boolean discrepancyFound;
    TaxVatRegisterTmp taxVatRegisterTmp;
    Set reportedSet;
    RecordSortedList rsl;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calcDiscrepancyVatAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the correct amounts for discrepancy report.
    /// </summary>
    /// <param name="_taxTrans">
    /// The <c>TaxTrans</c> table buffer with modified <c>TransDate</c> or <c>VatDueDate_W</c> values.
    /// </param>
    /// <param name="_isDiscrepancyReport">
    /// The <c>DiscrepancyReport</c> parameter.
    /// </param>
    /// <param name="_toDate">
    /// The end date parameter.
    /// </param>
    /// <param name="_fromDate">
    /// The start date parameter.
    /// </param>
    /// <param name="_taxTrans_W">
    /// The <c>TaxTrans_W</c> table buffer.
    /// </param>
    /// <returns>
    /// The <c>TaxTrans</c> table buffer with calculated amounts.
    /// </returns>
    private TaxTrans calcDiscrepancyVatAmount(
        TaxTrans _taxTrans,
        boolean _isDiscrepancyReport,
        TransDate _toDate,
        TransDate _fromDate,
        TaxTrans_W _taxTrans_W)
    {
        _taxTrans.TaxOrigin = TaxOrigin::Payment;

        if (_isDiscrepancyReport && _taxTrans_W.VatDueDate_W)
        {
            if (_taxTrans_W.VatDueDate_W >= _fromDate && _taxTrans_W.VatDueDate_W <= _toDate)
            {
                TaxTrans taxTransOrig = _taxTrans.orig();
                _taxTrans.TaxAmount = taxTransOrig.TaxAmount - _taxTrans.TaxAmount;
                _taxTrans.TaxBaseAmount = taxTransOrig.TaxBaseAmount - _taxTrans.TaxBaseAmount;
                discrepancyFound = true;
            }
            else
            {
                _taxTrans.TaxOrigin = TaxOrigin::Transfer;
            }
        }

        return _taxTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTmpTaxTransOtherPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes transactions falling in other periods for discrepancy report.
    /// </summary>
    /// <param name="_discrepancyReport">
    /// The discrepancy report.
    /// </param>
    /// <param name="_fromDate">
    /// The start date.
    /// </param>
    /// <param name="_toDate">
    /// The end date.
    /// </param>
    /// <param name="_fromTaxCode">
    /// The start tax code.
    /// </param>
    /// <param name="_toTaxCode">
    /// The end tax code.
    /// </param>
    /// <param name="_taxDirection">
    /// The <c>TaxDirection</c> parameter.
    /// </param>
    /// <param name="_showServiceInVatRegister">
    /// The <c>ShowServiceInVatRegister</c> parameter which controls visibility of service tariff text in
    /// the <c>TaxVatRegister</c> report.
    /// </param>
    private void createTmpTaxTransOtherPeriod(
        boolean _discrepancyReport,
        TransDate _fromDate,
        TransDate _toDate,
        TaxCode _fromTaxCode,
        TaxCode _toTaxCode,
        TaxDirection _taxDirection,
        ShowServiceInVatRegister _showServiceInVatRegister)
    {
        QueryRun taxDueTableQueryRun = this.taxDueTableQuery();

        QueryRun taxTransQueryRun;
        PlTaxDueTable taxDueTable;
        TaxTrans taxTrans;
        CustTrans custTrans;
        VendTrans vendTrans;
        TaxTrans_W taxTrans_W;
        TaxTrans originalTaxTrans;
        InvoiceId invoice;
        LedgerJournalTrans ledgerJournalTrans;
        // The block below should execute once when the taxDueTable buffer for transactions with empty value for TaxPeriodPaymentCode_PL so that they are captured in the report.
        do
        {
            taxDueTable = taxDueTableQueryRun.get(tablenum(PlTaxDueTable)) as PlTaxDueTable;

            if (!taxDueTable.RecId && !printEmptyPaymentCode)
            {
                continue;
            }

            taxTransQueryRun = this.taxTransQuery(taxDueTable, true, _taxDirection, _fromTaxCode, _toTaxCode, _fromDate, _toDate);

            while (taxTransQueryRun.next())
            {
                taxTrans = taxTransQueryRun.get(tablenum(TaxTrans));

                if (!reportedSet.in(taxTrans.RecId))
                {
                    custTrans = taxTransQueryRun.get(tableNum(CustTrans));
                    vendTrans = taxTransQueryRun.get(tableNum(VendTrans));
                    ledgerJournalTrans = taxTransQueryRun.get(tableNum(LedgerJournalTrans));
                    taxTrans_W = taxTransQueryRun.get(tableNum(TaxTrans_W));

                    if (taxTrans_W.ReversedTaxTransRecId_W)
                    {
                        originalTaxTrans = taxTrans::findRecId_IN(taxTrans_W.ReversedTaxTransRecId_W);

                        if (originalTaxTrans)
                        {
                            switch (originalTaxTrans.TaxDirection)
                            {
                                case TaxDirection::OutgoingTax:
                                    custTrans = CustTrans::findVoucherDate(originalTaxTrans.Voucher, originalTaxTrans.TransDate);
                                    break;
                                case TaxDirection::IncomingTax:
                                    vendTrans = VendTrans::findVoucherDate(originalTaxTrans.Voucher, originalTaxTrans.TransDate);
                                    break;
                            }
                        }
                    }

                    if (custTrans.Invoice)
                    {
                        invoice = custTrans.Invoice;
                    }
                    else if (vendTrans.Invoice)
                    {
                        invoice = vendTrans.Invoice;
                    }
                    else if (ledgerJournalTrans.Invoice)
                    {
                        invoice = ledgerJournalTrans.Invoice;
                    }
                    else if (taxTrans.Source == TaxModuleType::Voucher)
                    {
                        invoice = this.getSettlementInvoiceId(taxTrans.SourceTableId, taxTrans.SourceRecId);
                    }

                    this.insertTaxVatRegisterTmp(taxTrans, taxTrans_W, invoice, _discrepancyReport, _fromDate, _toDate, taxTrans.TaxDirection, _showServiceInVatRegister);
                }
            }
        }
        while (taxDueTableQueryRun.next());

    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxVatRegisterTmp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the actual data for the report from the <c>TaxVatRegisterTmp</c> table.
    /// </summary>
    /// <returns>
    /// The <c>TaxVatRegisterTmp</c> table.
    /// </returns>
    [
        SRSReportDataSetAttribute(tableStr(TaxVatRegisterTmp))
    ]
    public TaxVatRegisterTmp getTaxVatRegisterTmp()
    {
        select taxVatRegisterTmp;
        return taxVatRegisterTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTaxVatRegisterTmp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts records into the table.
    /// </summary>
    /// <param name="_taxTrans">
    /// The <c>TaxTrans</c> table buffer with modified <c>TransDate</c> or <c>VatDueDate_W</c> values.
    /// </param>
    /// <param name="_taxTrans_W">
    /// The <c>TaxTrans_W</c> table buffer.
    /// </param>
    /// <param name="_invoiceId">
    /// The <c>InvoiceId</c> of the transaction.
    /// </param>
    /// <param name="_discrepancyReport">
    /// The <c>DiscrepancyReport</c> parameter.
    /// </param>
    /// <param name="_fromDate">
    /// The from <c>TransDate</c> parameter.
    /// </param>
    /// <param name="_toDate">
    /// The to <c>TransDate</c> parameter.
    /// </param>
    /// <param name="_taxDirection">
    /// The <c>TaxDirection</c> parameter.
    /// </param>
    /// <param name="_showServiceInVatRegister">
    /// The <c>ShowServiceInVatRegister</c> parameter which controlls visibility of service tariff text in
    /// <c>TaxVatRegister</c> report.
    /// </param>
    /// <param name="_custTrans">
    /// The <c>CustTrans</c> buffer.
    /// </param>
    private void insertTaxVatRegisterTmp(
        TaxTrans _taxTrans,
        TaxTrans_W _taxTrans_W,
        InvoiceId _invoiceId,
        boolean _discrepancyReport,
        TransDate _fromDate,
        TransDate _toDate,
        TaxDirection _taxDirection,
        ShowServiceInVatRegister _showServiceInVatRegister,
        CustTrans _custTrans = null)
    {
        VendTable vendTable;
        TaxTrans taxTrans;

        discrepancyFound = false;

        TaxTrans taxTransLocal;
        taxTransLocal.data(this.calcDiscrepancyVatAmount(_taxTrans, _discrepancyReport, _toDate, _fromDate, _taxTrans_W));

        if (taxTransLocal.TaxAmount || taxTransLocal.TaxBaseAmount || _discrepancyReport)
        {
            taxVatRegisterTmp.clear();
            taxVatRegisterTmp.Voucher = taxTransLocal.Voucher;
            taxVatRegisterTmp.TransDate = taxTransLocal.TransDate;
            taxVatRegisterTmp.InvoiceId = _invoiceId;
            taxVatRegisterTmp.TaxCode = taxTransLocal.TaxCode;
            if (showDetails)
            {
                taxVatRegisterTmp.TaxDirection = taxTransLocal.TaxDirection;
            }
            boolean isAny = rsl.find(taxVatRegisterTmp);

            if (_taxDirection == TaxDirection::OutgoingTax || _taxDirection == TaxDirection::TaxExemptSales || _taxDirection == TaxDirection::OutgoingTax_W)
            {
                if (!isAny)
                {
                    CzCustAdvanceInvoiceTable czCustAdvanceInvoiceTable;

                    select firstOnly RecId from czCustAdvanceInvoiceTable
                        where czCustAdvanceInvoiceTable.Voucher == _custTrans.Voucher
                           && czCustAdvanceInvoiceTable.InvoiceDate == _custTrans.TransDate
                           && czCustAdvanceInvoiceTable.InvoiceId == _invoiceId
                           && czCustAdvanceInvoiceTable.InvoiceAmount == _custTrans.AmountCur;

                    if (!czCustAdvanceInvoiceTable.RecId && !discrepancyFound)
                    {
                        //If the transaction comes from a Customer Invoice, we should consider the related advance invoices
                        CustInvoiceJour custInvoiceJour;
                        TaxTrans custInvoiceJourTaxes;
                        select firstonly RecId from custInvoiceJour
                            group by custInvoiceJour.RecId
                            where custInvoiceJour.LedgerVoucher == taxTransLocal.Voucher
                                && custInvoiceJour.InvoiceDate == taxTransLocal.TransDate
                        outer join sum(TaxBaseAmount) from custInvoiceJourTaxes
                            where custInvoiceJourTaxes.Voucher == custInvoiceJour.LedgerVoucher
                                && custInvoiceJourTaxes.TransDate == custInvoiceJour.InvoiceDate
                                && custInvoiceJourTaxes.TaxCode == taxTransLocal.TaxCode
                                && (custInvoiceJourTaxes.TaxDirection == taxTransLocal.TaxDirection || !showDetails);
                        if (custInvoiceJour.RecId)
                        {
                            CustAdvanceInvoiceSettlement_W custAdvanceInvoiceSettlement;

                            while select InvoiceJourRecId, AdvanceInvoiceRecId, ReversalAdvanceInvoiceRecId, CreditNoteRecId, ReversalCancellationRecId from custAdvanceInvoiceSettlement
                                where custAdvanceInvoiceSettlement.InvoiceJourRecId == custInvoiceJour.RecId
                                    || custAdvanceInvoiceSettlement.CreditNoteRecId == custInvoiceJour.RecId
                            {
                                while select TaxAmount, TaxBaseAmount, RecId from taxTrans
                                    where taxTrans.TaxCode == taxTransLocal.TaxCode
                                        && taxTrans.TaxBaseAmount * custInvoiceJourTaxes.TaxBaseAmount < 0
                                exists join czCustAdvanceInvoiceTable
                                    where czCustAdvanceInvoiceTable.Voucher == taxTrans.Voucher
                                        && czCustAdvanceInvoiceTable.InvoiceDate == taxTrans.TransDate
                                        && ((custAdvanceInvoiceSettlement.InvoiceJourRecId == custInvoiceJour.RecId
                                        && (czCustAdvanceInvoiceTable.RecId == custAdvanceInvoiceSettlement.AdvanceInvoiceRecId
                                        || czCustAdvanceInvoiceTable.RecId == custAdvanceInvoiceSettlement.ReversalAdvanceInvoiceRecId))
                                        || (custAdvanceInvoiceSettlement.CreditNoteRecId == custInvoiceJour.RecId
                                        && czCustAdvanceInvoiceTable.RecId == custAdvanceInvoiceSettlement.ReversalCancellationRecId))
                                {
                                    if (reportedSet.add(taxTrans.RecId))
                                    {
                                        taxTransLocal.TaxAmount += taxTrans.TaxAmount;
                                        taxTransLocal.TaxBaseAmount += taxTrans.TaxBaseAmount;
                                    }
                                }
                            }
                        }
                    }
                }

                taxTransLocal.TaxAmount = -taxTransLocal.TaxAmount;
                taxTransLocal.TaxBaseAmount = -taxTransLocal.TaxBaseAmount;
            }

            reportedSet.add(_taxTrans.RecId);

            if (isAny)
            {
                if (taxTransLocal.TaxValue <= 0
                    && _taxTrans.ReverseCharge_W == NoYes::Yes
                    && TaxTable::find(_taxTrans.TaxCode).NegativeTax == NoYes::Yes)
                {
                    taxTransLocal.TaxBaseAmount = -taxTransLocal.TaxBaseAmount;
                }

                taxVatRegisterTmp.TaxAmount += taxTransLocal.TaxAmount;
                taxVatRegisterTmp.TaxBaseAmount += taxTransLocal.TaxBaseAmount;
                taxVatRegisterTmp.TaxInCostPrice += taxTransLocal.TaxInCostPriceMST;
                taxVatRegisterTmp.TaxBaseAmountDeducted = this.getTaxBaseAmountDeducted(
                    taxVatRegisterTmp.TaxAmount,
                    taxVatRegisterTmp.TaxBaseAmount,
                    taxVatRegisterTmp.TaxInCostPrice,
                    _taxTrans.CurrencyCode);
                rsl.ins(taxVatRegisterTmp, true);
            }
            else
            {
                taxVatRegisterTmp.clear();
                taxVatRegisterTmp.Addressing = _taxTrans_W.Addressing_PL;
                taxVatRegisterTmp.CustVendName = _taxTrans_W.CustVendName_PL;
                taxVatRegisterTmp.DocumentDate = _taxTrans_W.DocumentDate_PL;
                taxVatRegisterTmp.TaxAmount = taxTransLocal.TaxAmount;
                taxVatRegisterTmp.TaxBaseAmount = taxTransLocal.TaxBaseAmount;
                taxVatRegisterTmp.TaxCode = taxTransLocal.TaxCode;
                taxVatRegisterTmp.TaxGroup = taxTransLocal.TaxGroup;
                taxVatRegisterTmp.TaxValue = taxTransLocal.TaxValue;
                taxVatRegisterTmp.TransDate = taxTransLocal.TransDate;
                taxVatRegisterTmp.VatDueDate = _taxTrans_W.VatDueDate_W;
                taxVatRegisterTmp.VATNum = _taxTrans_W.VATNum_PL;
                taxVatRegisterTmp.Voucher = taxTransLocal.Voucher;
                taxVatRegisterTmp.TaxPeriod = taxTransLocal.TaxPeriod;
                taxVatRegisterTmp.TaxOrigin = taxTransLocal.TaxOrigin;
                taxVatRegisterTmp.TaxRepCounter = taxTransLocal.TaxRepCounter;
                taxVatRegisterTmp.TaxPeriodPaymentCode = _taxTrans_W.TaxPeriodPaymentCode_PL;
                taxVatRegisterTmp.TaxInCostPrice = taxTransLocal.TaxInCostPriceMST;
                taxVatRegisterTmp.TaxDirection = taxTransLocal.TaxDirection;
                taxVatRegisterTmp.InvoiceId = _invoiceId;

                VendTrans vendTransNonSAD;
                select firstonly AccountNum from vendTransNonSAD
                    where vendTransNonSAD.Voucher     == taxTransLocal.Voucher
                        && vendTransNonSAD.TransDate  == taxTransLocal.TransDate
                        && vendTransNonSAD.TransType  == LedgerTransType::Purch
                        && vendTransNonSAD.AccountNum != _taxTrans_W.CustVendName_PL
                        && vendTransNonSAD.Invoice    != _invoiceId;

                if (vendTransNonSAD.AccountNum)
                {
                    vendTable                          = VendTable::find(vendTransNonSAD.AccountNum);
                    taxVatRegisterTmp.Addressing       = vendTable.postalAddress().Address;
                    taxVatRegisterTmp.CustVendName     = vendTable.name();
                    taxVatRegisterTmp.VATNum           = vendTable.VATNum;
                }

                if (_showServiceInVatRegister == ShowServiceInVatRegister::Yes
                   || (_showServiceInVatRegister == ShowServiceInVatRegister::MandatoryOnly
                   && TaxGroupHeading::find(taxTransLocal.TaxGroup).IsMandatoryServiceTariff_PL))
                {
                    TaxServiceTariff taxServiceTariff = TaxServiceTariff::findByParent(taxTransLocal.TableId, taxTransLocal.RecId);
                    ServiceTariffNumber_PL serviceTariffNumber_PL = ServiceTariffNumber_PL::find(taxServiceTariff.ServiceTariffNumber);
                    taxVatRegisterTmp.ServiceTariffId = serviceTariffNumber_PL.ServiceTariffId_PL;
                    taxVatRegisterTmp.ServiceTariffTxt = serviceTariffNumber_PL.ServiceTariffTxt_PL;
                }

                if (!taxVatRegisterTmp.TaxPeriod)
                {
                    taxVatRegisterTmp.TaxPeriod = TaxTable::taxPeriod(taxVatRegisterTmp.TaxCode);
                }

                if (taxVatRegisterTmp.TaxValue <= 0
                    && _taxTrans.ReverseCharge_W == NoYes::Yes
                    && TaxTable::find(_taxTrans.TaxCode).NegativeTax == NoYes::Yes)
                {
                    taxVatRegisterTmp.TaxValue = -taxVatRegisterTmp.TaxValue;
                    taxVatRegisterTmp.TaxBaseAmount = -taxVatRegisterTmp.TaxBaseAmount;
                }

                taxVatRegisterTmp.TaxBaseAmountDeducted = this.getTaxBaseAmountDeducted(
                    taxVatRegisterTmp.TaxAmount,
                    taxVatRegisterTmp.TaxBaseAmount,
                    taxVatRegisterTmp.TaxInCostPrice,
                    _taxTrans.CurrencyCode);

                rsl.ins(taxVatRegisterTmp);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxBaseAmountDeducted</Name>
				<Source><![CDATA[
    private TaxBase getTaxBaseAmountDeducted(TaxAmount _taxAmount, TaxBase _taxBaseAmount, TaxAmountCur _taxInCostPrice, CurrencyCode _currencyCode)
    {
        TaxBase ret;
        if (_taxBaseAmount)
        {
            ret = (_taxAmount && _taxInCostPrice) ?
                CurrencyExchangeHelper::amount(decRound((_taxAmount - _taxInCostPrice) / _taxAmount, 2) * _taxBaseAmount, _currencyCode) :
                _taxBaseAmount;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceIdFromTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets InvoiceId from VendTrans by Voucher and TransDate
    /// </summary>
    private InvoiceId getInvoiceIdFromTrans(Voucher _voucher, TransDate _transDate)
    {
        VendTrans vendTransInvoice;
        LedgerJournalVoucherChanged ledgerJournalVoucherChanged;

        select firstonly Invoice from vendTransInvoice
            exists join ledgerJournalVoucherChanged
                where ledgerJournalVoucherChanged.FromVoucher == vendTransInvoice.Voucher
                   && ledgerJournalVoucherChanged.FromDate == vendTransInvoice.TransDate
                   && ledgerJournalVoucherChanged.ToVoucher == _voucher
                   && ledgerJournalVoucherChanged.ToDate == _transDate;

        return vendTransInvoice.Invoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processReport</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the records based on the parameters entered.
    /// </summary>
    public void processReport()
    {
        TaxVatRegisterContract contract = this.parmDataContract() as TaxVatRegisterContract;
        QueryRun taxDueTableQueryRun;
        QueryRun taxTransQueryRun;
        PlTaxDueTable taxDueTable;
        TaxTrans taxTrans;
        TaxTrans taxTransSettle;
        TaxTrans_W taxTrans_W;
        TaxSettleTransSummary taxSettleSumary;
        TransDate fromDate;
        TransDate toDate;
        TaxCode fromTaxCode;
        TaxCode toTaxCode;
        boolean discrepancyReport;
        CustTrans custTrans;
        VendTrans vendTrans;
        LedgerJournalTrans ledgerJournalTrans;
        InvoiceId invoice;
        TaxDirection taxDirection;
        ShowServiceInVatRegister showServiceInVatRegister;
        TaxTrans originalTaxTrans;
        TransDate transClosedDate;
        TransDate updatedVatDueDate;
        TransDate transCountFromDate;
        Voucher prevGJEVoucher;
        TransDate prevGJETransDate;

        fromDate = contract.parmFromDate();
        toDate = contract.parmToDate();
        fromTaxCode = contract.parmFromTaxCode();
        toTaxCode = contract.parmToTaxCode();
        discrepancyReport = contract.parmDiscrepancyReport();
        printEmptyPaymentCode = contract.parmPrintEmptyPaymentCode();
        taxDirection = contract.parmTaxDirection();
        showServiceInVatRegister = contract.parmShowServiceInVatRegister();
        showDetails = contract.parmShowDetails();
        taxDueTableQueryRun = this.taxDueTableQuery();

        reportedSet = new Set(Types::Int64);
        rsl = new RecordSortedList(tableNum(TaxVatRegisterTmp), taxVatRegisterTmp);
        if (showDetails)
        {
            rsl.sortOrder(fieldnum(TaxVatRegisterTmp, Voucher), fieldnum(TaxVatRegisterTmp, TransDate), fieldnum(TaxVatRegisterTmp, InvoiceId), fieldnum(TaxVatRegisterTmp, TaxCode), fieldnum(TaxVatRegisterTmp, TaxDirection));
        }
        else
        {
            rsl.sortOrder(fieldnum(TaxVatRegisterTmp, Voucher), fieldnum(TaxVatRegisterTmp, TransDate), fieldnum(TaxVatRegisterTmp, InvoiceId), fieldnum(TaxVatRegisterTmp, TaxCode));
        }

        // The block below should execute once when the taxDueTable buffer for transactions with blank TaxPeriodPaymentCode_PL so that they are captured in the report.
        do
        {
            taxDueTable = taxDueTableQueryRun.get(tablenum(PlTaxDueTable));

            if (!taxDueTable.RecId && !printEmptyPaymentCode)
            {
                continue;
            }

            taxTransQueryRun = this.taxTransQuery(taxDueTable, false, taxDirection, fromTaxCode, toTaxCode, fromDate, toDate);

            while (taxTransQueryRun.next())
            {
                taxTrans = taxTransQueryRun.get(tablenum(TaxTrans));
                if (reportedSet.in(taxTrans.RecId))
                {
                    continue;
                }
                taxTrans_W = taxTransQueryRun.get(tableNum(TaxTrans_W));

                if (taxTrans.TaxDirection == TaxDirection::OutgoingTax || taxTrans.TaxDirection == TaxDirection::TaxExemptSales || taxTrans.TaxDirection == TaxDirection::OutgoingTax_W)
                {
                    if (taxTrans_W.ReversedTaxTransRecId_W)
                    {
                        originalTaxTrans = TaxTrans::findRecId_IN(taxTrans_W.ReversedTaxTransRecId_W);
                        custTrans = CustTrans::findVoucherDate(originalTaxTrans.Voucher, originalTaxTrans.TransDate);
                        invoice = custTrans.Invoice;
                    }
                    else
                    {
                        if (taxTrans.ReverseCharge_W)
                        {
                            vendTrans = taxTransQueryRun.get(tableNum(VendTrans));
                            invoice = vendTrans.Invoice;
                            custTrans.clear();
                        }
                        else
                        {
                            custTrans = taxTransQueryRun.get(tableNum(CustTrans));
                            invoice = custTrans.Invoice;
                            vendTrans.clear();
                        }
                    }

                    if (invoice == '')
                    {
                        invoice = this.getInvoiceIdFromTrans(taxTrans.Voucher, taxTrans.TransDate);
                    }
                }
                else if (taxTrans.TaxDirection == TaxDirection::IncomingTax || taxTrans.TaxDirection == TaxDirection::TaxExemptPurchase || taxTrans.TaxDirection == TaxDirection::IncomingTax_W)
                {
                    if (taxTrans_W.ReversedTaxTransRecId_W)
                    {
                        originalTaxTrans = TaxTrans::findRecId_IN(taxTrans_W.ReversedTaxTransRecId_W);
                        vendTrans = VendTrans::findVoucherDate(originalTaxTrans.Voucher, originalTaxTrans.TransDate);
                    }
                    else
                    {
                        vendTrans = taxTransQueryRun.get(tableNum(VendTrans));
                    }

                    invoice = vendTrans.Invoice;

                    if (invoice == '')
                    {
                        invoice = this.getInvoiceIdFromTrans(taxTrans.Voucher, taxTrans.TransDate);
                    }
                }
                else if (taxTrans.TaxDirection == TaxDirection::UseTax)
                {
                    vendTrans = taxTransQueryRun.get(tableNum(VendTrans));
                    invoice = vendTrans.Invoice;

                    if (!vendTrans && invoice == '')
                    {
                        custTrans = taxTransQueryRun.get(tableNum(CustTrans));
                        invoice = custTrans.Invoice;
                    }
                }

                if (invoice == '')
                {
                    //In journals, if invoiceId field is blank, the DocumentNum should be displayed as invoice id.
                    ledgerJournalTrans = taxTransQueryRun.get(tableNum(LedgerJournalTrans)) as LedgerJournalTrans;
                    if (ledgerJournalTrans.Invoice == '' && ledgerJournalTrans.DocumentNum)
                    {
                        invoice = ledgerJournalTrans.DocumentNum;
                    }
                    else if (ledgerJournalTrans.Invoice)
                    {
                        invoice = ledgerJournalTrans.Invoice;
                    }
                    else if (taxTrans.Source == TaxModuleType::Voucher)
                    {
                        invoice = this.getSettlementInvoiceId(taxTrans.SourceTableId, taxTrans.SourceRecId);
                    }

                    if (invoice == '')
                    {
                        if (prevGJEVoucher != taxTrans.Voucher || prevGJETransDate != taxTrans.TransDate)
                        {
                            invoice = GeneralLedgerExtension::findBySubledgerVoucherAccountingDateCurrentLedger(taxTrans.Voucher, taxTrans.TransDate, taxTrans.DataAreaId).DocumentNumber;
                            prevGJEVoucher = taxTrans.Voucher;
                            prevGJETransDate = taxTrans.TransDate;
                        }
                    }
                }

                switch (taxDueTable.TaxDueDate)
                {
                    case PlTaxDueDate::VatDate :
                        break;

                    case PlTaxDueDate::OnPayment, PlTaxDueDate::OnPaymentNotLaterThan :
                        taxSettleSumary = new TaxSettleTransSummary(fromDate, toDate);

                        taxSettleSumary.parmTaxDueTable(taxDueTable);
                        taxSettleSumary.parmUseInvoiceTrans(true);

                        taxTransSettle.clear();

                        if (custTrans)
                        {
                            if (!taxDueTable.Partial || taxTransQueryRun.get(tableNum(CustSettlement)))
                            {
                                taxTransSettle = taxSettleSumary.getTaxSettleTransLine(taxTrans, custTrans, invoice);
                            }
                        }
                        else if (vendTrans)
                        {
                            if (!taxDueTable.Partial || taxTransQueryRun.get(tableNum(VendSettlement)))
                            {
                                taxTransSettle = taxSettleSumary.getTaxSettleTransLine(taxTrans, vendTrans, invoice);
                            }
                        }

                        if (taxDueTable.TaxDueDate == PlTaxDueDate::OnPayment)
                        {
                            taxTrans.TaxAmount = taxTransSettle.TaxAmount;
                            taxTrans.TaxBaseAmount = taxTransSettle.TaxBaseAmount;
                            if (taxDueTable.VatDateIsPaymentDate)
                            {
                                taxTrans_W.VatDueDate_W = taxTransSettle ? taxTransSettle.taxTrans_W().VatDueDate_W : dateNull();
                                taxTrans.packTaxTrans_W(taxTrans_W);
                            }
                        }
                        else
                        {

                            switch (taxDueTable.TaxDueCalcFrom)
                            {
                                case PlTaxDueCalcFrom::TransDate :
                                    transCountFromDate = taxTrans.TransDate;
                                    transClosedDate = vendTrans.Closed ? vendTrans.Closed: custTrans.Closed;
                                    updatedVatDueDate = transCountFromDate + taxDueTable.TaxPaymentDaysQty;

                                    break;

                                case PlTaxDueCalcFrom::VatDate :
                                    transCountFromDate = taxTrans_W.VatDueDate_W;
                                    transClosedDate = vendTrans.Closed ? vendTrans.Closed: custTrans.Closed;
                                    updatedVatDueDate = taxTrans_W.VatDueDate_W + taxDueTable.TaxPaymentDaysQty;

                                    break;
                            }
                            if (taxDueTable.Partial)
                            {
                                taxTrans_W.VatDueDate_W = taxTransSettle.taxTrans_W().VatDueDate_W
                                                ? min(transCountFromDate, updatedVatDueDate)
                                                : updatedVatDueDate;
                                taxTrans.packTaxTrans_W(taxTrans_W);
                            }
                            else
                            {
                                taxTrans_W.VatDueDate_W = transClosedDate
                                            ? min(transClosedDate, updatedVatDueDate)
                                            : updatedVatDueDate;
                                taxTrans.packTaxTrans_W(taxTrans_W);
                            }

                            if (taxTrans_W.VatDueDate_W >= fromDate &&  taxTrans_W.VatDueDate_W <= toDate)
                            {
                                if (taxTransSettle.TaxAmount != 0 || taxTransSettle.TaxBaseAmount != 0)
                                {
                                    taxTrans.TaxAmount = taxTransSettle.TaxAmount;
                                    taxTrans.TaxBaseAmount = taxTransSettle.TaxBaseAmount;
                                }
                            }
                            else
                            {
                                taxTrans.TaxAmount = 0;
                                taxTrans.TaxBaseAmount = 0;
                            }
                            if (vendTrans || custTrans)
                            {
                                transClosedDate = vendTrans.Closed ? vendTrans.Closed: custTrans.Closed;
                                if (transClosedDate && transClosedDate <= fromDate && !taxTransSettle)
                                {
                                    taxTrans.TaxAmount = 0;
                                    taxTrans.TaxBaseAmount = 0;
                                }
                            }
                        }

                        break;

                    case PlTaxDueDate::VatDateNotLaterThan :
                        switch (taxDueTable.TaxDueCalcFrom)
                        {
                            case PlTaxDueCalcFrom::TransDate :
                                taxTrans_W.VatDueDate_W = min(taxTrans_W.VatDueDate_W, taxTrans.TransDate + taxDueTable.TaxPaymentDaysQty);
                                taxTrans.packTaxTrans_W(taxTrans_W);
                                break;
                            case PlTaxDueCalcFrom::VatDate :
                                taxTrans_W.VatDueDate_W = taxTrans_W.VatDueDate_W + taxDueTable.TaxPaymentDaysQty;
                                taxTrans.packTaxTrans_W(taxTrans_W);
                                break;
                        }

                        break;
                }

                this.insertTaxVatRegisterTmp(taxTrans, taxTrans_W, invoice, discrepancyReport, fromDate, toDate, taxTrans.TaxDirection, showServiceInVatRegister, custTrans);
            }
        }
        while (taxDueTableQueryRun.next());

        if (discrepancyReport)
        {
            this.createTmpTaxTransOtherPeriod(discrepancyReport, fromDate, toDate, fromTaxCode, toTaxCode, taxDirection, showServiceInVatRegister);
        }
        this.insertIntoTaxVatRegisterTmp(discrepancyReport);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertIntoTaxVatRegisterTmp</Name>
				<Source><![CDATA[
    private void insertIntoTaxVatRegisterTmp(boolean _discrepancyReport)
    {
        try
        {
            RecordInsertList recordInsertList = new RecordInsertList(tableNum(TaxVatRegisterTmp), true, true, true, false, true, taxVatRegisterTmp);
            rsl.first(taxVatRegisterTmp);
            ttsbegin;
            do
            {
                if (!_discrepancyReport || taxVatRegisterTmp.TaxAmount != 0 || taxVatRegisterTmp.TaxBaseAmount != 0)
                {
                    recordInsertList.add(taxVatRegisterTmp);
                }
            }
            while (rsl.next(taxVatRegisterTmp));
            recordInsertList.insertDatabase();
            ttscommit;
        }
        catch (Exception::TransientSqlConnectionError)
        {
            #OCCRetryCount
            if (appl.ttsLevel() != 0)
            {
                throw Exception::TransientSqlConnectionError;
            }

            if (SysTransientSqlConnectionErrorHandler::retryTransientSqlConnectionError(#RetryNum))
            {
                retry;
            }
            else
            {
                throw;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxDueTableQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a query for the <c>PlTaxDueTable</c> table.
    /// </summary>
    /// <returns>
    /// The <c>QueryRun</c> object.
    /// </returns>
    private QueryRun taxDueTableQuery()
    {
        Query taxDueTableQuery = new Query();
        QueryBuildDataSource qbdsDueTable = taxDueTableQuery.addDataSource(tableNum(PlTaxDueTable));
        QueryBuildDataSource qbdsTaxTrans_W = this.parmQuery().dataSourceTable(tableNum(TaxTrans_W));
        QueryBuildRange qbr;

        Counter i;
        if (qbdsTaxTrans_W.findRange(fieldNum(TaxTrans_W, TaxPeriodPaymentCode_PL)))
        {
            for (i = 1; i <= qbdsTaxTrans_W.rangeCount(); i++)
            {
                qbr = qbdsTaxTrans_W.range(i);

                if (fieldExt2Id(qbr.field()) == fieldNum(TaxTrans_W, TaxPeriodPaymentCode_PL))
                {
                    qbdsDueTable.addRange(fieldNum(PlTaxDueTable, TaxPeriodPaymentCode)).value(qbr.value());

                    if (!qbr.value() || qbr.value() == SysQuery::valueEmptyString())
                    {
                        printEmptyPaymentCode = true;
                    }
                }
            }
        }
        else
        {
            printEmptyPaymentCode = true;
        }

        // Copy the filters for TaxPeriodPaymentCode_PL from this.parmQuery() to TaxDueTableQuery.
        i=1;

        Counter queryFilterCount = this.parmQuery().queryFilterCount();

        QueryBuildDataSource queryFilterDataSource;
        QueryFilter queryFilter;
        QueryFilter dueTableQueryFilter;

        while (i <= queryFilterCount)
        {
            queryFilter = this.parmQuery().queryFilter(i);
            queryFilterDataSource = queryFilter.dataSource();

            if (queryFilter != null && queryFilter.value() != '' && queryFilterDataSource.table() == tableNum(TaxTrans_W))
            {
                if (fieldName2id(tableNum(TaxTrans_W), queryFilter.field()) == fieldnum(TaxTrans_W, TaxPeriodPaymentCode_PL))
                {
                    dueTableQueryFilter = taxDueTableQuery.addQueryFilter(qbdsDueTable, fieldStr(PlTaxDueTable, TaxPeriodPaymentCode));
                    dueTableQueryFilter.value(queryFilter.value());
                }
            }

            i++;
        }

        QueryRun taxDueTableQueryRun = new QueryRun(taxDueTableQuery);

        return taxDueTableQueryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSettlementDatasource</Name>
				<Source><![CDATA[
    private void addSettlementDatasource(
        TransDate _fromDate,
        TransDate _toDate,
        Query _query,
        TableId _transTableId,
        TableId _settlementTableId,
        FieldId _transDateFieldId,
        FieldId _canBeReversedFieldId,
        FieldId _reversedRecIdFieldId)
    {
        QueryBuildDataSource qbdsSettlement = _query.dataSourceTable(_transTableId).addDataSource(_settlementTableId);
        qbdsSettlement.relations(true);
        qbdsSettlement.joinMode(JoinMode::OuterJoin);
        findOrCreateRange_W(qbdsSettlement, _transDateFieldId, queryRange(_fromDate, _toDate));
        findOrCreateRange_W(
            qbdsSettlement,
            _canBeReversedFieldId,
            '((' + fieldId2name(_settlementTableId, _canBeReversedFieldId) + ')||(' + fieldId2name(_settlementTableId, _reversedRecIdFieldId) + '))');
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxTransQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a query for the <c>TaxTrans</c> table buffer.
    /// </summary>
    /// <param name="_taxDueTable">
    /// The <c>PlTaxDueTable</c> buffer.
    /// </param>
    /// <param name="_isDiscrepancyReport">
    /// The <c>DiscrepancyReport</c> parameter.
    /// </param>
    /// <param name="_taxDirection">
    /// The <c>TaxDirection</c> parameter.
    /// </param>
    /// <param name="_fromTaxCode">
    /// The <c>TaxCode</c> start parameter.
    /// </param>
    /// <param name="_toTaxCode">
    /// The <c>TaxCode</c> end parameter.
    /// </param>
    /// <param name="_fromDate">
    /// The start date.
    /// </param>
    /// <param name="_toDate">
    /// The end date.
    /// </param>
    /// <returns>
    /// The <c>TaxTrans</c> query.
    /// </returns>
    private QueryRun taxTransQuery(
        PlTaxDueTable _taxDueTable,
        boolean _isDiscrepancyReport,
        TaxDirection _taxDirection,
        TaxCode _fromTaxCode,
        TaxCode _toTaxCode,
        TransDate _fromDate,
        TransDate _toDate)
    {
        Query query = new query(this.parmQuery());
        QueryBuildDataSource qbdsTaxTrans_W = query.dataSourceTable(tablenum(TaxTrans_W));

        while (qbdsTaxTrans_W.findRange(fieldnum(TaxTrans_W, TaxPeriodPaymentCode_PL)))
        {
            qbdsTaxTrans_W.clearRange(fieldnum(TaxTrans_W, TaxPeriodPaymentCode_PL));
        }

        QueryBuildRange qbrTaxTrans_W = SysQuery::findOrCreateRange(qbdsTaxTrans_W, fieldNum(TaxTrans_W, TaxPeriodPaymentCode_PL));

        if (_taxDueTable.RecId)
        {
            qbrTaxTrans_W.value(SysQuery::value(_taxDueTable.TaxPeriodPaymentCode));
        }
        else
        {
            qbrTaxTrans_W.value(SysQuery::valueEmptyString());
        }

        QueryBuildDataSource qbds = query.dataSourceTable(tablenum(TaxTrans));
        qbds.addOrderByField(fieldNum(TaxTrans, RecId));
        QueryBuildRange qbr = SysQuery::findOrCreateRange(qbds, fieldNum(TaxTrans, TaxDirection));
        qbr.status(RangeStatus::Hidden);

        if(!qbr.value())
        {
            qbr.value(queryValue(_taxDirection));
        }

        container taxDirections = str2con(qbr.value(), ',');
        container taxDirectionSecondary;

        for (int i = 1; i <= conLen(taxDirections); i++)
        {
            str strTaxDirection = strLRTrim(conPeek(taxDirections, i));
            TaxDirection taxDirection = str2Enum(TaxDirection::UseTax, strTaxDirection);

            switch (taxDirection)
            {
                case TaxDirection::IncomingTax  :
                    taxDirectionSecondary += [TaxDirection::IncomingTax_W, TaxDirection::TaxExemptPurchase];
                    break;

                case TaxDirection::OutgoingTax  :
                    taxDirectionSecondary += [TaxDirection::OutgoingTax_W, TaxDirection::TaxExemptSales];
                    break;

                default :
                    taxDirectionSecondary += [taxDirection];
                    break;
            }
        }

        if (taxDirectionSecondary != [_taxDirection])
        {
            qbr = qbds.addRange(fieldNum(TaxTrans, TaxDirection));
            qbr.value(con2Str(taxDirectionSecondary));
        }
        
        if (_toTaxCode)
        {
            qbr = SysQuery::findOrCreateRange(qbds, fieldNum(TaxTrans, TaxCode));
            qbr.value(SysQuery::range(_fromTaxCode, _toTaxCode));
        }

        if (_isDiscrepancyReport)
        {
            qbr = SysQuery::findOrCreateRange(qbds, fieldNum(TaxTrans, TransDate));
            qbr.value(SysQuery::range(_fromDate, _toDate));
        }
        else
        {
            switch (_taxDueTable.TaxDueDate)
            {
                case PlTaxDueDate::VatDate :
                    qbrTaxTrans_W = SysQuery::findOrCreateRange(qbdsTaxTrans_W, fieldNum(TaxTrans_W, VatDueDate_W));
                    qbrTaxTrans_W.value(SysQuery::range(_fromDate, _toDate));
                    break;

                case PlTaxDueDate::OnPayment :
                    if (_taxDueTable.Partial)
                    {
                        this.addDataSourcesToQuery (
                            _fromDate,
                            _toDate,
                            query);
                    }
                    break;

                case PlTaxDueDate::VatDateNotLaterThan, PlTaxDueDate::OnPaymentNotLaterThan :

                    switch (_taxDueTable.TaxDueCalcFrom)
                    {
                        case PlTaxDueCalcFrom::TransDate :
                            qbr = SysQuery::findOrCreateRange(qbds, fieldNum(TaxTrans, TransDate));
                            qbr.value(SysQuery::range(_fromDate - _taxDueTable.TaxPaymentDaysQty, _toDate));
                            break;

                        case PlTaxDueCalcFrom::VatDate :
                            qbrTaxTrans_W = SysQuery::findOrCreateRange(qbdsTaxTrans_W, fieldNum(TaxTrans_W, VatDueDate_W));
                            qbrTaxTrans_W.value(SysQuery::range(_fromDate - _taxDueTable.TaxPaymentDaysQty, maxdate()));
                            break;
                    }

                    if (_taxDueTable.Partial && _taxDueTable.TaxDueDate == PlTaxDueDate::OnPaymentNotLaterThan)
                    {
                        this.addDataSourcesToQuery (
                            _fromDate,
                            _toDate,
                            query);
                    }
                    break;
            }
        }

        qbds = qbds.addDataSource(tablenum(TaxTable));
        qbds.joinMode(JoinMode::ExistsJoin);
        qbds.relations(true);

        qbds.addRange(fieldnum(TaxTable, TaxType_W)).value(SysQuery::value(TaxType_W::VAT));
        qbds.addRange(fieldnum(TaxTable, TaxType_W)).value(SysQuery::value(TaxType_W::VATReduced));
        qbds.addRange(fieldnum(TaxTable, TaxType_W)).value(SysQuery::value(TaxType_W::VATZero));

        // Create ranges for all filters.
        Counter i=1;
        QueryFilter queryFilter;

        Counter queryFilterCount = this.parmQuery().queryFilterCount();
        while (i <= queryFilterCount)
        {
            queryFilter = this.parmQuery().queryFilter(i);

            if (queryFilter != null && queryFilter.value() != '')
            {
                qbr = SysQuery::findOrCreateRange(queryFilter.dataSource(), fieldName2id(queryFilter.dataSource().table(),queryFilter.field()));
                qbr.value(queryFilter.value());
            }

            i++;
        }

        return new QueryRun(query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDataSourcesToQuery</Name>
				<Source><![CDATA[
    private void addDataSourcesToQuery(
        TransDate _fromDate,
        TransDate _toDate,
        Query _query)
    {
        this.addSettlementDatasource(
                            _fromDate,
                            _toDate,
                            _query,
                            tablenum(CustTrans),
                            tableNum(CustSettlement),
                            fieldNum(CustSettlement, TransDate),
                            fieldNum(CustSettlement, CanBeReversed),
                            fieldNum(CustSettlement, ReversedRecId_RU));
        this.addSettlementDatasource(
                            _fromDate,
                            _toDate,
                            _query,
                            tablenum(VendTrans),
                            tableNum(VendSettlement),
                            fieldNum(VendSettlement, TransDate),
                            fieldNum(VendSettlement, CanBeReversed),
                            fieldNum(VendSettlement, ReversedRecId_RU));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSettlementInvoiceId</Name>
				<Source><![CDATA[
    private InvoiceId getSettlementInvoiceId(RefTableId _sourceTableId, RefRecId _sourceRecId)
    {
        InvoiceId invoiceId;

        switch (_sourceTableId)
        {
            case tableNum(VendTrans):
                VendTrans vendTrans;
                select firstonly Invoice from vendTrans
                    where vendTrans.OffsetRecid == _sourceRecId;
                invoiceId = vendTrans.Invoice;
                break;

            case tableNum(CustTrans):
                CustTrans custTrans;
                select firstonly Invoice from custTrans
                    where custTrans.OffsetRecid == _sourceRecId;
                invoiceId = custTrans.Invoice;
                break;
        }

        return invoiceId;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>