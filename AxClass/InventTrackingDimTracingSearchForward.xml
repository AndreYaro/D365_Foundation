<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventTrackingDimTracingSearchForward</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    Class for handling forward tracing for tracking dimension tracing.
/// </summary>
public class InventTrackingDimTracingSearchForward extends InventTrackingDimTracingSearch
{
    Set inventTransKeysHandled;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkDateOrder</Name>
				<Source><![CDATA[
    protected boolean checkDateOrder(
        InventDimTrackingInventTransNode    _currentNode,
        InventTrans                         _inventTrans,
        InventTransOrigin                   _inventTransOrigin)
    {      
        if (includeWarehouseSpecificInventoryTransactions)
        {
            InventTransTrackingTransaction inventTransTrackingTransaction =
                InventTransTrackingTransaction::newFromInventTransAndInventTransOrigin(_inventTrans, _inventTransOrigin);

            return this.dateAllowsTrackingTransactionToBeUsedAsSubNodeOfCurrentNode(_currentNode, inventTransTrackingTransaction);
        }
        else
        {
            boolean ret = super(_currentNode, _inventTrans, _inventTransOrigin);

            if (ret)
            {
                InventDimTrackingInventTransNode childNode = InventDimTrackingInventTransNode::newFromInventTrans(_inventTrans, _inventTransOrigin);
                if (_currentNode.hasFullDateTime() && childNode.hasFullDateTime())
                {
                    // Both have full date and time information so we can compare
                    if (childNode.fullTrackingDateTime() < _currentNode.fullTrackingDateTime())
                    {
                        ret = false;
                    }
                }
                else
                {
                    if (childNode.trackingDate() < _currentNode.trackingDate())
                    {
                        ret = false;
                    }
                }
            }
            return ret;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dateAllowsTrackingTransactionToBeUsedAsSubNodeOfCurrentNode</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean dateAllowsTrackingTransactionToBeUsedAsSubNodeOfCurrentNode(InventDimTrackingInventTransNode _currentNode, InventTrackingTransaction _trackingTransaction)
    {
        boolean ret = super(_currentNode, _trackingTransaction);

        if (ret)
        {
            InventDimTrackingInventTransNode childNode = _trackingTransaction.createTrackingNode();
                
            if (_currentNode.hasFullDateTime() && childNode.hasFullDateTime())
            {
                // Both have full date and time information so we can compare
                if (childNode.fullTrackingDateTime() < _currentNode.fullTrackingDateTime())
                {
                    ret = false;
                }
            }
            else
            {
                if (childNode.trackingDate() < _currentNode.trackingDate())
                {
                    ret = false;
                }
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkQuarantineOrder</Name>
				<Source><![CDATA[
    protected boolean checkQuarantineOrder(
        InventDimTrackingInventTransNode    _currentNode,
        InventTrans                         _inventTrans,
        InventTransOrigin                   _inventTransOrigin)
    {
        InventTrackingDimTracingInventTransDTO  inventTransParentDTO = _currentNode.parmInventTransDTO();
        InventTrackingDimTracingInventTransOriginDTO inventTransOriginDTOParent = _currentNode.parmInventTransOriginDTO();

        if (inventTransOriginDTOParent.referenceCategory() != InventTransType::QuarantineOrder)
        {
            return true;
        }

        if (inventTransParentDTO.inventDim().inventLocation().InventLocationType == InventLocationType::Quarantine)
        {
            if (inventTransParentDTO.inventQty() < 0)
            {
                // item going from quarantine warehouse to standard warehouse
                if (_inventTransOrigin.ReferenceId != inventTransOriginDTOParent.referenceId())
                {
                    return false;
                }
                if (_inventTrans.inventDim().inventLocation().InventLocationType != InventLocationType::Standard)
                {
                    return false;
                }
            }
            else
            {
                // item going from quarantine receipt to quarantine issue
                if (_inventTransOrigin.ReferenceId != inventTransOriginDTOParent.referenceId())
                {
                    return false;
                }
                if (_inventTrans.inventDim().inventLocation().InventLocationType != InventLocationType::Quarantine)
                {
                    return false;
                }
            }
        }
        else
        {
            // Parent is at standard warehouse
            if (inventTransParentDTO.inventQty() < 0)
            {
                // going from standard warehouse to quarantine warehouse
                if (_inventTransOrigin.ReferenceId != inventTransOriginDTOParent.referenceId())
                {
                    return false;
                }
                if (_inventTrans.inventDim().inventLocation().InventLocationType != InventLocationType::Quarantine)
                {
                    return false;
                }
            }
            else
            {
                // else it is the receipt back at standard warehouse
                if (_inventTransOrigin.ReferenceId == inventTransOriginDTOParent.referenceId()
                 && _inventTransOrigin.ReferenceCategory == inventTransOriginDTOParent.referenceCategory())
                {
                    // Cannot link to the same quarantine order issues from standard warehouse.
                    return false;
                }
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTransOriginIds</Name>
				<Source><![CDATA[
    protected boolean checkTransOriginIds(
        InventDimTrackingInventTransNode    _currentNode,
        InventTrans                         _inventTrans,
        InventTransOrigin                   _inventTransOrigin)
    {
        InventTrackingDimTracingInventTransOriginDTO inventTransOriginParentDTO = _currentNode.parmInventTransOriginDTO();
        if (_inventTransOrigin.ReferenceId == '' && inventTransOriginParentDTO.referenceId() == '') // Both are virtual movements where inventTransOrigin is assigned at posting time.
        {
            InventTrackingDimTracingInventTransDTO inventTransParentDTO = _currentNode.parmInventTransDTO();
            if (this.isInventTransWithParametersFirst(
                    _inventTrans.DateFinancial, inventTransParentDTO.dateFinancial(),
                    _inventTrans.Voucher, inventTransParentDTO.voucher(),
                    _inventTrans.InventTransOrigin, inventTransOriginParentDTO.recId()))
            {
                return false;
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSubNode</Name>
				<Source><![CDATA[
    protected void createSubNode(
        InventDimTrackingInventTransNode    _currentNode,
        InventTrans                         _inventTrans,
        InventTransOrigin                   _inventTransOrigin = null)
    {
        if (includeWarehouseSpecificInventoryTransactions)
        {
            InventDimTrackingInventTransNode childNode = inventTrackingDimTracingRelations.inventTransNode(_inventTrans, _inventTransOrigin);

            this.linkSubNode(_currentNode, childNode);
        }
        else
        {
            var relatedTransactionNode = inventTrackingDimTracingRelations.addForwardRelation(_currentNode, _inventTransOrigin, _inventTrans);
            if (!relatedTransactionNode.parmIsForwardExpanded())
            {
                transactionsToExpand.add(relatedTransactionNode.tracingNodeKey());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandIssueTransactionDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate handling the expansion of an issue transaction.
    /// </summary>
    /// <param name = "_inventTrackingDimTracingSearch">The class receiving the expanded <c>InventTrans</c> records.</param>
    /// <param name = "_inventTransList">The list of expanded <c>InventTrans</c> records.</param>
    /// <param name = "_currentNode">The node to expand.</param>
    /// <param name = "_inventDimParmAll">The InventDimParm to filter the expansion.</param>
    /// <param name = "_result">The event result to indicate if the delegate handler handled the expansion.</param>
    delegate void expandIssueTransactionDelegate(
        InventTrackingDimTracingSearchForward   _inventTrackingDimTracingSearch,
        SysRecordSortedList                     _inventTransList,
        InventDimTrackingInventTransNode        _currentNode,
        InventDimParm                           _inventDimParmAll,
        EventHandlerResult                      _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandIssueTransaction</Name>
				<Source><![CDATA[
    protected void expandIssueTransaction(
        SysRecordSortedList                 _inventTransList,
        InventDimTrackingInventTransNode    _currentNode)
    {
        var eventResult = new EventHandlerResult();
        this.expandIssueTransactionDelegate(this, _inventTransList, _currentNode, inventDimParmAll, eventResult);

        if (eventResult.result())
        {
            // When delegate returns a result, we are not going to perform the logic to find and expand child nodes.
            // Presumably, the delagate did all the job necessary, so we do not need to proceed.
            return;
        }

        this.expandReturnIssueTransaction(_inventTransList, _currentNode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandReturnIssueTransaction</Name>
				<Source><![CDATA[
    private void expandReturnIssueTransaction(
        SysRecordSortedList                 _inventTransList,
        InventDimTrackingInventTransNode    _currentNode)
    {
        InventTrackingDimTracingInventTransDTO inventTransParentDTO = _currentNode.parmInventTransDTO();
        if (inventTransParentDTO.returnInventTransOriginRecId() && inventTransParentDTO.isIssue())
        {
            this.findTransReceipts(_inventTransList, _currentNode, inventTransParentDTO.returnInventTransOriginRecId(), '');
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandIssueTransactionDelegateHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate handler for the expansion of an issue transaction.
    /// </summary>
    /// <param name = "_inventTrackingDimTracingSearch">The class receiving the expanded <c>InventTrans</c> records.</param>
    /// <param name = "_inventTransList">The list of expanded <c>InventTrans</c> records.</param>
    /// <param name = "_currentNode">The node to expand.</param>
    /// <param name = "_inventDimParmAll">The InventDimParm to filter the expansion.</param>
    /// <param name = "_result">The event result to indicate if the delegate handler handled the expansion.</param>
    [SubscribesTo(classStr(InventTrackingDimTracingSearchForward), delegateStr(InventTrackingDimTracingSearchForward, expandIssueTransactionDelegate))]
    public static void expandIssueTransactionDelegateHandler(InventTrackingDimTracingSearchForward _inventTrackingDimTracingSearch, SysRecordSortedList _inventTransList, InventDimTrackingInventTransNode _currentNode, InventDimParm _inventDimParmAll, EventHandlerResult _result)
    {
        InventTrackingDimTracingInventTransDTO          inventTransParentDTO = _currentNode.parmInventTransDTO();
        InventTrackingDimTracingInventTransOriginDTO    inventTransOriginDTOParent = _currentNode.parmInventTransOriginDTO();

        switch (inventTransOriginDTOParent.referenceCategory())
        {
            case InventTransType::ProdLine:
                if (#PmfEnabled && inventTransParentDTO.isIssue())
                {
                    _inventTrackingDimTracingSearch.findBatchReceipts(_inventTransList, _currentNode);
                }
            // fall through
            case InventTransType::BOMLine:
                _inventTrackingDimTracingSearch.findTransReceipts(_inventTransList, _currentNode, inventTransOriginDTOParent.assemblyInventTransOrigin().RecId, inventTransParentDTO.voucher());
                break;
            case InventTransType::InventTransfer:
            case InventTransType::WMSTransport:
            case InventTransType::QuarantineOrder:
            case InventTransType::TransferOrderReceive:
            case InventTransType::TransferOrderShip:
            case InventTransType::KanbanJobTransferIssue:
            case InventTransType::KanbanJobTransferReceipt:
            case InventTransType::WHSContainer:
                _inventTrackingDimTracingSearch.findTransTransferReceiptsDTO(_inventTransList, _currentNode, inventTransParentDTO, inventTransOriginDTOParent);
                break;
            case InventTransType::WHSQuarantine:
                _inventTrackingDimTracingSearch.findTransWHSQuarantineReceipts(_inventTransList, _currentNode);
                break;
            case InventTransType::WHSWork:
                _inventTrackingDimTracingSearch.findTransWHSWorkReceipts(_inventTransList, _currentNode);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandReceiptTransactionDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate handling the expansion of a receipt transaction.
    /// </summary>
    /// <param name = "_inventTrackingDimTracingSearch">The class receiving the expanded <c>InventTrans</c> records.</param>
    /// <param name = "_inventTransList">The list of expanded <c>InventTrans</c> records.</param>
    /// <param name = "_currentNode">The node to expand.</param>
    /// <param name = "_inventDimParmAll">The InventDimParm to filter the expansion.</param>
    /// <param name = "_result">The event result to indicate if the delegate handler handled the expansion.</param>
    delegate void expandReceiptTransactionDelegate(
        InventTrackingDimTracingSearchForward   _inventTrackingDimTracingSearch,
        SysRecordSortedList                     _inventTransList,
        InventDimTrackingInventTransNode        _currentNode,
        InventDimParm                           _inventDimParmAll,
        EventHandlerResult                      _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandReceiptTransaction</Name>
				<Source><![CDATA[
    protected void expandReceiptTransaction(SysRecordSortedList _inventTransList, InventDimTrackingInventTransNode _currentNode)
    {
        boolean isNodeExpanded = this.tryExpandReceiptNode(_inventTransList, _currentNode);
        if (isNodeExpanded)
        {
            return;
        }

        InventTransOrigin   inventTransOrigin;
        InventTrans         inventTrans;

        // find ISSUE transactions for the same item and iventDim as the current node
        while select inventTransOrigin
            where inventTransOrigin.ItemId == _currentNode.getItemId()
            join inventTrans
                where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                    &&  inventTrans.Qty < 0
                    &&  inventTrans.InventDimId == _currentNode.getInventDimId()
        {
            if (this.isNotReturnTransaction(_currentNode, inventTrans))
            {
                this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>tryExpandReceiptNode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Tries to expand a node by calling a delegate.
    /// When delegate returns a result (true), we are going to assume nodes are expanded.
    /// Presumably, the delagate did all the job necessary, so we do not need to proceed.
    /// </summary>
    /// <param name = "_inventTransList">The list of expanded <c>InventTrans</c> records.</param>
    /// <param name = "_currentNode">Currently processed node.</param>
    /// <returns>true if node expand logic is done; otherwise, false.</returns>
    private boolean tryExpandReceiptNode(SysRecordSortedList _inventTransList, InventDimTrackingInventTransNode _currentNode)
    {
        if (this.isEventResultEvaluated())
        {
            return globalEventResult.result();
        }

        EventHandlerResult eventResult = new EventHandlerResult();
        this.expandReceiptTransactionDelegate(this, _inventTransList, _currentNode, inventDimParmAll, eventResult);

        return eventResult.result();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNotReturnTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks that the provided node is not a node for a return transaction (transaction created for a return process).
    /// If it is a node for a return transaction, then it checks that the found inventTrans is not an originator for this node.
    /// We want to exclude the inventTrans ISSUE that are originators to the current node for a RECEIPT transaction,
    /// (We are looking for the successors not predecessors).
    /// </summary>
    /// <param name = "_currentNode">Currently processed node.</param>
    /// <param name = "_inventTrans">InventTrans related to the current node.</param>
    /// <returns>false if _inventTrans is a return originator for the _currentNode; otherwise, true.</returns>
    private boolean isNotReturnTransaction(InventDimTrackingInventTransNode _currentNode, InventTrans _inventTrans)
    {
        InventTrackingDimTracingInventTransDTO inventTransParentDTO = _currentNode.parmInventTransDTO();

        return !inventTransParentDTO.returnInventTransOriginRecId()                                     // parent is not a return trans OR
            || inventTransParentDTO.returnInventTransOriginRecId() != _inventTrans.InventTransOrigin;   // parent is return trans and found inventTrans is the return originator
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandReceiptTransactionDelegateHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate handler for the expansion of a receipt transaction.
    /// </summary>
    /// <param name = "_inventTrackingDimTracingSearch">The class receiving the expanded <c>InventTrans</c> records.</param>
    /// <param name = "_inventTransList">The list of expanded <c>InventTrans</c> records.</param>
    /// <param name = "_currentNode">The node to expand.</param>
    /// <param name = "_inventDimParmAll">The InventDimParm to filter the expansion.</param>
    /// <param name = "_result">The event result to indicate if the delegate handler handled the expansion.</param>
    [SubscribesTo(classStr(InventTrackingDimTracingSearchForward), delegateStr(InventTrackingDimTracingSearchForward, expandReceiptTransactionDelegate))]
    public static void expandReceiptTransactionDelegateHandler(InventTrackingDimTracingSearchForward _inventTrackingDimTracingSearch, SysRecordSortedList _inventTransList, InventDimTrackingInventTransNode _currentNode, InventDimParm _inventDimParmAll, EventHandlerResult _result)
    {
        InventTrackingDimTracingInventTransDTO          inventTransParentDTO = _currentNode.parmInventTransDTO();
        InventTrackingDimTracingInventTransOriginDTO    inventTransOriginDTOParent = _currentNode.parmInventTransOriginDTO();

        InventTransOrigin       inventTransOrigin;
        InventTrans             inventTrans;

        switch (inventTransOriginDTOParent.referenceCategory())
        {
            case InventTransType::TransferOrderShip:
                while select inventTransOrigin
                    where inventTransOrigin.ItemId == inventTransOriginDTOParent.itemId()
                      &&  inventTransOrigin.ReferenceCategory == InventTransType::TransferOrderReceive
                      &&  inventTransOrigin.ReferenceId == inventTransOriginDTOParent.referenceId()
                    join inventTrans
                    where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                      &&  inventTrans.Qty <  0
                      &&  inventTrans.InventDimId == inventTransParentDTO.inventDimId()
                {
                    if (!inventTransParentDTO.returnInventTransOriginRecId() || inventTransParentDTO.returnInventTransOriginRecId() != inventTrans.InventTransOrigin)
                    {
                        _inventTrackingDimTracingSearch.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
                    }
                }
                break;
            case InventTransType::QuarantineOrder:
                if (inventTransParentDTO.inventDim().inventLocation().InventLocationType == InventLocationType::Quarantine)
                {
                    while select inventTransOrigin
                        where inventTransOrigin.ItemId == inventTransOriginDTOParent.itemId()
                            && inventTransOrigin.ReferenceCategory == InventTransType::QuarantineOrder
                            && inventTransOrigin.ReferenceId == inventTransOriginDTOParent.referenceId()
                        join inventTrans
                        where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                            && inventTrans.Qty < 0
                            && inventTrans.InventDimId == inventTransParentDTO.inventDimId()
                    {
                        if (!inventTransParentDTO.returnInventTransOriginRecId() || inventTransParentDTO.returnInventTransOriginRecId() != inventTrans.InventTransOrigin)
                        {
                            _inventTrackingDimTracingSearch.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
                        }
                    }
                }
                else
                {
                    while select inventTransOrigin
                        where inventTransOrigin.ItemId == inventTransOriginDTOParent.itemId()
                        join inventTrans
                        where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                          &&  inventTrans.Qty <  0
                          &&  inventTrans.InventDimId == inventTransParentDTO.inventDimId()
                    {
                        if (!inventTransParentDTO.returnInventTransOriginRecId() || inventTransParentDTO.returnInventTransOriginRecId() != inventTrans.InventTransOrigin)
                        {
                            _inventTrackingDimTracingSearch.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
                        }
                    }
                }
                break;
            case InventTransType::KanbanJobTransferIssue:
                while select inventTransOrigin
                    where inventTransOrigin.ItemId == inventTransOriginDTOParent.itemId()
                      &&  inventTransOrigin.ReferenceCategory == InventTransType::KanbanJobTransferReceipt
                      &&  inventTransOrigin.ReferenceId == inventTransOriginDTOParent.referenceId()
                    join inventTrans
                    where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                      &&  inventTrans.Qty <  0
                      &&  inventTrans.InventDimId == inventTransParentDTO.inventDimId()
                {
                    if (!inventTransParentDTO.returnInventTransOriginRecId() || inventTransParentDTO.returnInventTransOriginRecId() != inventTrans.InventTransOrigin)
                    {
                        _inventTrackingDimTracingSearch.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
                    }
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBatchReceipts</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the batch order receipts.
    /// </summary>
    /// <param name="_inventTransList">
    ///    A <c>SysRecordSortList</c> list of transactions.
    /// </param>
    /// <param name="_currentNode">
    ///    The transaction node being expanded.
    /// </param>
    protected void findBatchReceipts(
        SysRecordSortedList                 _inventTransList,
        InventDimTrackingInventTransNode    _currentNode)
    {
        InventTrackingDimTracingInventTransOriginDTO inventTransOriginDTOParent = _currentNode.parmInventTransOriginDTO();
        InventTransOrigin   inventTransOrigin;
        InventTrans         inventTrans;
        ProdBOM             prodBOM;
        PmfProdCoBy         prodCoBy;

        if (!InventTrackingDimSkipCrossProdLineTracingFlight::instance().isEnabled())
        {
            while select TableId from prodBOM
                where prodBOM.ProdId == inventTransOriginDTOParent.referenceId()
                join inventTransOrigin
                    where inventTransOrigin.InventTransId == prodBOM.InventTransId
                join inventTrans
                    where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                        && inventTrans.StatusIssue == StatusIssue::None
                        && inventTrans.Qty > 0
            {
                this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
            }
        }

        while select TableId from prodCoBy
            where prodCoBy.ProdId == inventTransOriginDTOParent.referenceId()
                && prodCoBy.ProductType != PmfProductType::By_Product
            join inventTransOrigin
                where inventTransOrigin.InventTransId   == prodCoBy.InventTransId
            join inventTrans
                where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                    && inventTrans.StatusIssue == StatusIssue::None
                    && inventTrans.Qty > 0
        {
            this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTransReceipts</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds and adds receipt transactions related to the parent transaction to the transaction list.
    /// </summary>
    /// <param name="_inventTransList">
    ///    The <c>SysRecordSortedList</c> object to insert into.
    /// </param>
    /// <param name="_currentNode">
    ///    The transaction node being expanded.
    /// </param>
    /// <param name="_inventTransOriginId">
    ///    The transaction ID for the related receipt transaction.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher used when posting related receipts. If empty all transactions will be considered.
    /// </param>
    protected void findTransReceipts(
        SysRecordSortedList                 _inventTransList,
        InventDimTrackingInventTransNode    _currentNode,
        InventTransOriginId                 _inventTransOriginId,
        Voucher                             _voucher)
    {
        InventTransOrigin       inventTransOrigin;
        InventTrans             inventTrans;
        InventDimParm           dimParmTrackingDim;
        InventDim               inventDim;
        
        InventDim inventDimParent = _currentNode.parmInventTransDTO().inventDim();
        List trackingDimList = InventDim::dimTrackingDimFieldList();
        dimParmTrackingDim.initFromInventDim(inventDimParent, trackingDimList);

        InventTrackingDimTracingProductComponentLot inventTrackingDimTracingProductComponentLot;
        if (isProdAsBuiltBOMFeatureEnabled)
        {
            // component node
            inventTrackingDimTracingProductComponentLot = InventTrackingDimTracingProductComponentLot::createBuilder(_currentNode.parmInventTransDTO(),
                                                                                                                     _currentNode.parmInventTransOriginDTO(),
                                                                                                                     inventDimParent, 
                                                                                                                     productComponentLotSettleMap);
        }

        if (_currentNode.parmInventTransOriginDTO().referenceCategory() == InventTransType::Sales 
             && inventDimParent.anyTrackingDimensionSpecified())
        {
            while select inventTransOrigin
            where inventTransOrigin.RecId       == _inventTransOriginId
            join inventTrans
            where inventTrans.InventTransOrigin == inventTransOrigin.RecId
              &&  inventTrans.StatusIssue       == StatusIssue::None
              &&  inventTrans.Qty                >  0
              && (inventTrans.Voucher           == _voucher  || !_voucher)
            #InventDimExistsJoin(inventTrans.inventDimId, inventDim, inventDimParent, dimParmTrackingDim)
            {
                this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
            }
        }
        else
        {
            while select inventTransOrigin
            where inventTransOrigin.RecId       == _inventTransOriginId
            join inventTrans
            where inventTrans.InventTransOrigin == inventTransOrigin.RecId
              &&  inventTrans.StatusIssue       == StatusIssue::None
              &&  inventTrans.Qty                >  0
              && (!isProdAsBuiltBOMFeatureEnabled || !inventTrans.PackingSlipReturned)
              && (inventTrans.Voucher           == _voucher  || !_voucher)
            {
                if (inventTrackingDimTracingProductComponentLot && !inventTrackingDimTracingProductComponentLot.checkProductLotAssociation(inventTrans, inventTransOrigin))
                {
                    continue;
                }

                this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);

                if (inventTrackingDimTracingProductComponentLot && !inventTrackingDimTracingProductComponentLot.getSettleQty())
                {
                    break;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTransTransferReceiptsDTO</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds and adds transfer receipt transactions related to the parent issue transaction to the transaction list.
    /// </summary>
    /// <param name="_inventTransList">
    ///    The <c>SysRecordSortedList</c> object to insert into.
    /// </param>
    /// <param name="_currentNode">
    ///    The transaction node being expanded.
    /// </param>
    /// <param name="_inventTransParentDTO">
    ///    The inventory transaction information for the related issue transaction.
    /// </param>
    /// <param name="_inventTransOriginDTOParent">
    ///    The inventory transaction originator information for the related issue transaction.
    /// </param>
    protected void findTransTransferReceiptsDTO(
        SysRecordSortedList                             _inventTransList,
        InventDimTrackingInventTransNode                _currentNode,
        InventTrackingDimTracingInventTransDTO          _inventTransParentDTO,
        InventTrackingDimTracingInventTransOriginDTO    _inventTransOriginDTOParent)
    {
        InventDim               inventDimParent = _inventTransParentDTO.inventDim();
        InventTransOrigin       transferInventTransOrigin = _inventTransParentDTO.transferInventTransOrigin(_inventTransOriginDTOParent.recId());
        InventTrans             inventTrans;
        InventDim               inventDim;
        InventDimParm           inventDimParmNonLocation;
        Voucher                 voucher = _inventTransParentDTO.voucher();

        //  transfer journal can be transferred between different dimensions
        if (_inventTransOriginDTOParent.referenceCategory() != InventTransType::InventTransfer)
        {
            inventDimParmNonLocation.initFromInventDim(inventDimParent);
            inventDimParmNonLocation.InventSiteIdFlag       = NoYes::No;
            inventDimParmNonLocation.InventLocationIdFlag   = NoYes::No;
            inventDimParmNonLocation.wmsLocationIdFlag      = NoYes::No;
            inventDimParmNonLocation.LicensePlateFlag       = NoYes::No;
        }

        if (_inventTransOriginDTOParent.referenceCategory() == InventTransType::TransferOrderShip)
        {
            // Skip the transit warehouse transactions
            InventTransferLine inventTransferLine = InventTransferLine::findTransIdShip(_inventTransOriginDTOParent.inventTransId());
            if (inventTransferLine.RecId)
            {
                transferInventTransOrigin = InventTransOrigin::findByInventTransId(inventTransferLine.InventTransIdReceive);
                voucher = '';
            }
        }

        select sum(Qty) from inventTrans
            where inventTrans.InventTransOrigin     == transferInventTransOrigin.RecId
              && (inventTrans.Voucher               == voucher   || !voucher)
            #InventDimJoin(inventTrans.inventDimId, inventDim, inventDimParent, inventDimParmNonLocation);

        if (inventTrans.Qty == 0)
        {
            while select inventTrans
                where inventTrans.InventTransOrigin == transferInventTransOrigin.RecId
                  &&  inventTrans.StatusIssue       == StatusIssue::None
                  &&  inventTrans.Qty               >  0
                  && (inventTrans.Voucher           == voucher  || !voucher)
                #InventDimJoin(inventTrans.inventDimId, inventDim, inventDimParent, inventDimParmNonLocation)
            {
                this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, transferInventTransOrigin);
            }
        }
        else
        {
            boolean hasRelatedTrackingDimTransferReceiptTrans = false;
            // Find by tracking dimension firstly
            List trackingDimList = InventDim::dimTrackingDimFieldList();
            InventDimParm dimParmTrackingDim;
            dimParmTrackingDim.initFromInventDim(inventDimParent, trackingDimList);
                          
            while select inventTrans
                where inventTrans.InventTransOrigin == transferInventTransOrigin.RecId
                &&  inventTrans.StatusIssue       == StatusIssue::None
                &&  inventTrans.Qty               >  0
                && (inventTrans.Voucher           == voucher  || !voucher)
                #InventDimJoin(inventTrans.inventDimId, inventDim, inventDimParent, dimParmTrackingDim)
            {
                hasRelatedTrackingDimTransferReceiptTrans = true;
                this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, transferInventTransOrigin);
            }

            // Doesn't find anything from query above, find again by ignoring tracking dimension
            if (!hasRelatedTrackingDimTransferReceiptTrans &&
                this.needQueryTransWithoutSpecifiedTrackingDim(inventDimParent, _inventTransOriginDTOParent.referenceCategory()))
            {
                while select inventTrans
                    where inventTrans.InventTransOrigin == transferInventTransOrigin.RecId
                      &&  inventTrans.StatusIssue       == StatusIssue::None
                      &&  inventTrans.Qty               >  0
                      && (inventTrans.Voucher           == voucher  || !voucher)
                {
                    this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, transferInventTransOrigin);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTransWHSQuarantineReceipts</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds and adds WHS Quarantine receipt transactions related to the parent issue transaction to the transaction list.
    /// </summary>
    /// <param name="_inventTransList">
    ///    The <c>SysRecordSortedList</c> object to insert into.
    /// </param>
    /// <param name="_currentNode">
    ///    The transaction node being expanded.
    /// </param>
    /// <param name="_inventTransOriginParent">
    ///    The transaction origin for the related issue transaction; optional, the parameter value is not used.
    /// </param>
    protected void findTransWHSQuarantineReceipts(
        SysRecordSortedList                 _inventTransList,
        InventDimTrackingInventTransNode    _currentNode,
        InventTransOrigin                   _inventTransOriginParent = null)
    {
        InventTrans             inventTrans;
        InventTransOrigin       inventTransOrigin;
        WHSWorkQuarantine       whsWorkQuarantine;

        while select inventTrans
            join inventTransOrigin
                where inventTransOrigin.RecId == inventTrans.InventTransOrigin
            exists join whsWorkQuarantine
                where whsWorkQuarantine.InventTransIdTo == inventTransOrigin.InventTransId
                    && whsWorkQuarantine.InventTransIdFrom == _currentNode.parmInventTransOriginDTO().inventTransId()
        {
            this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTransWHSWorkReceipts</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds and adds WHS Work receipt transactions related to the parent issue transaction to the transaction list.
    /// </summary>
    /// <param name="_inventTransList">
    ///    The <c>SysRecordSortedList</c> object to insert into.
    /// </param>
    /// <param name="_currentNode">
    ///    The transaction node being expanded.
    /// </param>
    /// <param name="_inventTransOriginParent">
    ///    The transaction origin for the related issue transaction; optional, the parameter value is not used.
    /// </param>
    protected void findTransWHSWorkReceipts(
        SysRecordSortedList                 _inventTransList,
        InventDimTrackingInventTransNode    _currentNode,
        InventTransOrigin                   _inventTransOriginParent = null)
    {
        InventTrans             inventTrans;
        InventTransOrigin       inventTransOrigin;
        WHSWorkInventTrans      whsWorkInventTrans;
        InventDim               inventDim;
        InventDim               parentInventDim = _currentNode.parmInventTransDTO().inventDim();
        InventDimParm           inventDimParmNonStorage = parentInventDim.toDimParm();

        inventDimParmNonStorage.clearStorageDimensions();

        if (isInventTrackingDimTracingCorrectJoinOrderEnabled)
        {
            while select inventTrans
            join inventTransOrigin
                where inventTransOrigin.RecId == inventTrans.InventTransOrigin
            #InventDimJoin(inventTrans.inventDimId, inventDim, parentInventDim, inventDimParmNonStorage)
            exists join whsWorkInventTrans
                where whsWorkInventTrans.InventTransIdTo   == inventTransOrigin.InventTransId
                   && whsWorkInventTrans.InventTransIdFrom == _currentNode.parmInventTransOriginDTO().inventTransId()
            {
                this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
            }
        }
        else
        {
            while select inventTrans
            join inventTransOrigin
                where inventTransOrigin.RecId == inventTrans.InventTransOrigin
            exists join whsWorkInventTrans
                where whsWorkInventTrans.InventTransIdTo   == inventTransOrigin.InventTransId
                   && whsWorkInventTrans.InventTransIdFrom == _currentNode.parmInventTransOriginDTO().inventTransId()
            #InventDimJoin(inventTrans.inventDimId, inventDim, parentInventDim, inventDimParmNonStorage)
            {
                this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isChildInProdBOM</Name>
				<Source><![CDATA[
    protected boolean isChildInProdBOM(InventDimTrackingInventTransNode _currentNode, InventTransOrigin _inventTransOrigin)
    {
        return this.isTransReferenceProdBOMForProduction(
            _inventTransOrigin.ReferenceCategory, _currentNode.parmInventTransOriginDTO().referenceCategory(),
            _inventTransOrigin.ReferenceId, _currentNode.parmInventTransOriginDTO().referenceId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransactionExpanded</Name>
				<Source><![CDATA[
    protected boolean isTransactionExpanded(InventDimTrackingInventTransNode _transactionNode)
    {
        return _transactionNode.parmIsForwardExpanded();
    }

]]></Source>
			</Method>
			<Method>
				<Name>markNodeAsExpanded</Name>
				<Source><![CDATA[
    protected void markNodeAsExpanded(
        InventDimTrackingInventTransNode    _currentNode)
    {
        _currentNode.parmIsForwardExpanded(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>markNodeWithNoSubnodes</Name>
				<Source><![CDATA[
    protected void markNodeWithNoSubnodes(
        InventDimTrackingInventTransNode    _currentNode)
    {
        if (inventTrackingDimTracingCriteria.parmTraceDirection() == ForwardBackward::Backward)
        {
            inventTrackingDimTracingRelations.markAsRootNode(_currentNode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new instance of the <c>InventTrackingDimTracingSearchForward</c> class.
    /// </summary>
    /// <returns>
    ///    An instance of the <c>InventTrackingDimTracingSearchForward</c> class.
    /// </returns>
    protected static InventTrackingDimTracingSearchForward construct()
    {
        InventTrackingDimTracingSearchForward   inventTrackingDimTracingSearchForward = new InventTrackingDimTracingSearchForward();
        return inventTrackingDimTracingSearchForward;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newParameters</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Create an instance to do a full forward search.
    /// </summary>
    /// <param name="_inventTrackingDimTracingCriteria">
    ///    The search criteria to use.
    /// </param>
    /// <returns>
    ///    A new instance of the search class.
    /// </returns>
    static public InventTrackingDimTracingSearchForward newParameters(
        InventTrackingDimTracingCriteria    _inventTrackingDimTracingCriteria)
    {
        InventTrackingDimTracingSearchForward   inventTrackingDimTracingSearchForward = InventTrackingDimTracingSearchForward::construct();

        inventTrackingDimTracingSearchForward.parmInventTrackingDimTracingCriteria(_inventTrackingDimTracingCriteria);

        return inventTrackingDimTracingSearchForward;
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandReceiptTransactionIncludingWHSInventoryTransaction</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void expandReceiptTransactionIncludingWHSInventoryTransaction(
        SysRecordSortedList                 _inventTransAndWHSInventoryTransactionList,
        InventDimTrackingInventTransNode    _currentNode,
        Map _allTransactionMap)
    {
        var eventResult = new EventHandlerResult();
        SysRecordSortedList tmpInventTransList = this.initInventTransList();
        this.expandReceiptTransactionDelegate(this, tmpInventTransList, _currentNode, inventDimParmAll, eventResult);

        if (!eventResult.result())
        {
            globalEventResult = eventResult;

            this.expandReceiptTransaction(tmpInventTransList, _currentNode);

            InventTrackingDimTracingSearch::addInventTransListToInventTrackingTransactionList(_inventTransAndWHSInventoryTransactionList, tmpInventTransList, _allTransactionMap);
            
            this.expandReceiptTransactionsWHSTransactions(_inventTransAndWHSInventoryTransactionList, _currentNode, _allTransactionMap);

            globalEventResult = null;
        }
        else
        {
            InventTrackingDimTracingSearch::addInventTransListToInventTrackingTransactionList(_inventTransAndWHSInventoryTransactionList, tmpInventTransList, _allTransactionMap);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandReceiptTransactionsWHSTransactions</Name>
				<Source><![CDATA[
    private void expandReceiptTransactionsWHSTransactions(
        SysRecordSortedList                 _inventTransAndWHSInventoryTransactionList,
        InventDimTrackingInventTransNode    _currentNode,
        Map                                 _allTransactionMap)
    {
        InventDim inventDim = _currentNode.getInventDim();

        WHSInventoryTransactionView transactionView = new WHSWarehouseTransactionItemTracingQuery().findIssueTransaction(_currentNode.getItemId(), _currentNode.getInventDim());

        this.addTransactionViewRecordsToListAndMap(_currentNode, transactionView, _inventTransAndWHSInventoryTransactionList, _allTransactionMap);
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandIssueTransactionIncludingWHSInventoryTransaction</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void expandIssueTransactionIncludingWHSInventoryTransaction(
        SysRecordSortedList                 _inventTransAndWHSInventoryTransactionList,
        InventDimTrackingInventTransNode    _currentNode,
        Map _allTransactionMap)
    {
        if (_currentNode.getTransactionType() == InventTrackingTransactionType::InventTrans)
        {
            SysRecordSortedList tmpList = this.initInventTransList();

            this.expandIssueTransaction(tmpList, _currentNode);

            InventTrackingDimTracingSearch::addInventTransListToInventTrackingTransactionList(_inventTransAndWHSInventoryTransactionList, tmpList, _allTransactionMap);
        }
        else if (_currentNode.getTransactionType() == InventTrackingTransactionType::WHSInventoryTransaction)
        {
            this.expandIssueWHSInventoryTransaction(_inventTransAndWHSInventoryTransactionList, _currentNode, _allTransactionMap);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandIssueWHSInventoryTransaction</Name>
				<Source><![CDATA[
    private void expandIssueWHSInventoryTransaction(
        SysRecordSortedList                 _list,
        InventDimTrackingInventTransNode    _currentNode,
        Map _allTransactionMap)
    {
        WHSInventoryTransactionView transactionView  = this.findWHSInventoryTransactions(WHSInventoryTransactionTypeEnum::RegisteredReceipt, _currentNode);
        
        this.addTransactionViewRecordsToListAndMap(_currentNode, transactionView, _list, _allTransactionMap);
    }

]]></Source>
			</Method>
			<Method>
				<Name>linkSubNode</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void linkSubNode(
        InventDimTrackingInventTransNode  _currentNode,
        InventDimTrackingInventTransNode _relatedTransactionNode)
    {
        inventTrackingDimTracingRelations.addForwardRelationBetweenNodes(_currentNode, _relatedTransactionNode);
        
        if (!_relatedTransactionNode.parmIsForwardExpanded())
        {
            transactionsToExpand.add(_relatedTransactionNode.tracingNodeKey());
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>