<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>GanttData_WrkCtrV2</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>GanttData_WrkCtrV2</c> class handles Gantt data loading.
/// </summary>
public class GanttData_WrkCtrV2 extends GanttData_WrkCtr
{
    private ProdTableTmpFilter      productionOrdersTmpFilter;         // contains a subset of production/planned production orders for bulk processing instead of one by one.
    private WrkCtrCapResTmpFilter   capacityReservationsTmpFilter;     // contains a subset of modified capacity reservations for bulk processing instead of one by one.
    private RecordInsertList        rilMaterials;
    private RecordInsertList        rilCapacityReservations;
    private Map                     mapOprMaterialAvailabilityDateTime;
    private ReqPlanVersionRefRecId  reqPlanVersionRefRecId;
    private boolean                 isFirstLoad; 
    private GanttClient_WrkCtr      localGanttClient;
    private GanttSetup_WrkCtr       localGanttSetup;
    private List                    wrkCtrCapResInsertList;            // cannot use RecordInsertList because of auto-push to the table
    private boolean                 isGanttDataWrkCtrOpenSaveMoveFlightEnabled;
    private boolean                 isGanttDataWrkCtrMaterialAvailabilityFlightEnabled;
    private boolean                 isGanttDataUpdateRawMaterialsWhenDateTimeChangeFlightEnabled;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();
        this.initData();
        isGanttDataWrkCtrOpenSaveMoveFlightEnabled = GanttDataWrkCtrOpenSaveMoveFlight::instance().isEnabled();
        isGanttDataWrkCtrMaterialAvailabilityFlightEnabled = GanttDataWrkCtrMaterialAvailabilityFlight::instance().isEnabled();
        isGanttDataUpdateRawMaterialsWhenDateTimeChangeFlightEnabled = GanttDataUpdateRawMaterialsWhenDateTimeChangeFlight::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initData</Name>
				<Source><![CDATA[
    protected void initData()
    {
        super();
        reqPlanVersionRefRecId = ReqPlanVersion::findActiveReqPlanIdDynamic().RecId;
        rilMaterials = new RecordInsertList(tableNum(GanttTmpMaterials), true, true, true, true, true, ganttTmpMaterials);
        rilCapacityReservations = new RecordInsertList(tableNum(WrkCtrCapResTmpFilter), true, true, true, true, true, capacityReservationsTmpFilter);
        mapOprMaterialAvailabilityDateTime = new Map(Types::String, Types::UtcDateTime);
        wrkCtrCapResInsertList = new List(Types::Record);

        if (this.parmGanttClient())
        {
            localGanttClient = this.parmGanttClient() as GanttClient_WrkCtr;
            localGanttSetup = localGanttClient.parmGanttSetup() as GanttSetup_WrkCtr;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadData</Name>
				<Source><![CDATA[
    protected void loadData()
    {
        this.loadDataExtended(setLoadWrkCtrIds);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadDataExtended</Name>
				<Source><![CDATA[
    /// <summary>Loads related Gantt data.</summary>
    /// <param name = "_wrkCtrIds">The set of new resource Ids to load data for.</param>
    /// <param name = "_alwaysInitEmpty">A flag that initializes the internal data regarding empty work centers.</param>
    protected void loadDataExtended(Set _wrkCtrIds, boolean _alwaysInitEmpty = false)
    {
        // load production data
        this.loadDataProdWrkCtrIdSetExtended(_wrkCtrIds);

        // load planned production data
        this.loadDataPlannedProdWrkCtrIdSetExtended(_wrkCtrIds);

        // load project data
        this.loadDataProjWrkCtrIdSetExtended(_wrkCtrIds);

        // load links between jobs
        this.loadDataLinks();

        // adjust the links after loading
        this.adjustLinks();

        // create a map of work centers without jobs
        if (_alwaysInitEmpty || localGanttClient.isCalledFromWrkCtr())
        {
            this.initEmptyWrkCtrIds();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadAdditionalResources</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads data for additional resources.
    /// </summary>
    /// <param name = "_wrkCtrIds">The set of new resource Ids to load data for.</param>
    public void loadAdditionalResources(Set _wrkCtrIds)
    {
        // Merge the set of already loaded data with the new set
        setLoadWrkCtrIds = Set::union(setLoadWrkCtrIds, _wrkCtrIds);
        tmpWrkCtrIdLoaded = null;

        // Load new data
        this.loadDataExtended(_wrkCtrIds, true);

        // Load calendars
        this.createCalendars();
        this.loadCalendarData();
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadDataProdWrkCtrIdSetExtended</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads the production orders that are to be used in the Gantt chart for a set of resources.
    /// </summary>
    /// <param name="_wrkCtrIds">
    ///    The set of resource Ids to load.
    /// </param>
    private void loadDataProdWrkCtrIdSetExtended(Set _wrkCtrIds)
    {
        hasProdJobs = false;

        if (!this.canLoadProdData())
        {
            return;
        }

        Set setDataProd = Set::create(this.loadProductionOrders(_wrkCtrIds.pack(),
                                      this.parmLoadingFromDate(),
                                      this.parmLoadingToDate(),
                                      (loadOnlySpecific ? this.conSetLoadIds() : conNull())));
     
        if (!isGanttDataWrkCtrMaterialAvailabilityFlightEnabled || localGanttSetup.parmShowProdJobMaterialDate())
        {
            this.loadMaterialAvailbilityProd(null);
            rilMaterials.insertDatabase();
        }

        SetEnumerator       setEnumerator = setDataProd.getEnumerator();
        ProdRouteJob        prodRouteJob;
        ProdRoute           prodRoute;
        ProdTable           prodTable;
        WrkCtrTable         wrkCtrTable;
        WrkCtrResourceGroup wrkCtrResourceGroup;
        boolean             allowEdit = GanttTable_WrkCtrJob::allowEditProd(false);
                
        while (setEnumerator && setEnumerator.moveNext())
        {
            [prodRouteJob, prodRoute, prodTable, wrkCtrTable, wrkCtrResourceGroup] = setEnumerator.current();

            this.insertDataProd(prodRouteJob,
                                prodRoute,
                                prodTable,
                                wrkCtrTable,
                                setLoadWrkCtrIds.in(prodRouteJob.WrkCtrId)  &&
                                this.canLoadProdRouteJob(prodRouteJob, prodRoute, null, prodTable, this.parmLoadingFromDate(), this.parmLoadingToDate()),
                                wrkCtrResourceGroup,
                                allowEdit);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadDataPlannedProdWrkCtrIdSetExtended</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads all the planned production orders that are to be used in the Gantt chart.
    /// </summary>
    /// <param name="_wrkCtrIds">
    ///    The set of resource Ids to load.
    /// </param>
    /// <remarks>
    ///    All jobs that satisfy the given time interval and workcenter are loaded, regardless that they are
    ///    displayed or not in the control.
    /// </remarks>
    private void loadDataPlannedProdWrkCtrIdSetExtended(Set _wrkCtrIds)
    {
        hasPlannedProdJobs = false;

        if (!this.canLoadPlannedProdData())
        {
            return;
        }

        Set setDataPlannedProd = Set::create(this.loadPlannedProductionOrders(_wrkCtrIds.pack(),
                                             this.parmLoadingFromDate(),
                                             this.parmLoadingToDate(),
                                             localGanttSetup.parmReqPlanIdPlannedProd(),
                                             (loadOnlySpecific ? this.conSetLoadIds() : conNull())));

        if (!isGanttDataWrkCtrMaterialAvailabilityFlightEnabled || localGanttSetup.parmShowPlannedProdJobMaterialDate())
        {
            this.loadMaterialAvailbilityPlannedProd(null);
            rilMaterials.insertDatabase();
        }

        SetEnumerator       setEnumerator = setDataPlannedProd.getEnumerator();
        ReqRouteJob         reqRouteJob;
        ReqRoute            reqRoute;
        ReqPO               reqPO;
        WrkCtrTable         wrkCtrTable;
        WrkCtrResourceGroup wrkCtrResourceGroup;
        boolean             allowEdit = GanttTable_WrkCtrJob::allowEditPlannedProd(false);

        // iterate through the planned production order jobs received from the server
        while (setEnumerator && setEnumerator.moveNext())
        {
            [reqRouteJob, reqRoute, reqPO, wrkCtrTable, wrkCtrResourceGroup] = setEnumerator.current();
            
            this.insertDataPlannedProd(reqRouteJob,
                                       reqRoute,
                                       reqPO,
                                       wrkCtrTable,
                                       setLoadWrkCtrIds.in(reqRouteJob.WrkCtrId)  &&
                                       this.canLoadReqRouteJob(reqRouteJob, reqRoute, null, null, reqPO, this.parmLoadingFromDate(), this.parmLoadingToDate()),
                                       wrkCtrResourceGroup,
                                       allowEdit);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadMaterialAvailbilityPlannedProd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads material availability information for a planned production order.
    /// </summary>
    /// <param name = "_reqPO">The planned production order record to load for.</param>
    /// <returns>A <c>Map</c> with the maximum material availability date per operation number.</returns>
    protected Map loadMaterialAvailbilityPlannedProd(ReqPo _reqPO)
    {
        ReqTrans            reqTrans;
        ReqRoute            firstReqRoute;
                
        while select PlanVersion, RefType, RefId, OprNum, ItemId, CovInventDimId, Qty, FuturesDate, FuturesTime
            from reqTrans
            where reqTrans.PlanVersion  == reqPlanVersionRefRecId
                && (reqTrans.RefType == ReqRefType::BOMLine || reqTrans.RefType == ReqRefType::PmfFormulaLine)
            exists join productionOrdersTmpFilter
                where productionOrdersTmpFilter.ProdId  == reqTrans.RefId
        {
            OprNum oprNum = reqTrans.OprNum;
            if (!oprNum)
            {
                // In case the OprNum is not explicitly set on the ReqTrans it must be defaulted.
                if (!firstReqRoute)
                {
                    firstReqRoute = ReqRoute::findFirst(reqTrans.PlanVersion, reqTrans.RefId);
                }
                oprNum = firstReqRoute.OprNum;
            }

            this.initGanttTmpMaterialsPlannedProductionOrder(reqTrans, oprNum);
            
            rilMaterials.add(ganttTmpMaterials);

            // Determine the maximum futures date/time per operation
            utcdatetime futuresDateTime = DateTimeUtil::newDateTime(reqTrans.FuturesDate, reqTrans.FuturesTime, DateTimeUtil::getUserPreferredTimeZone());
            utcDateTime maxFuturesDateTime;
            str hashKey = this.hashKeyMaterialAvailability(ganttTmpMaterials.RefId, ganttTmpMaterials.OprNum, ganttTmpMaterials.RefType);
            
            if (mapOprMaterialAvailabilityDateTime.exists(hashKey))
            {
                maxFuturesDateTime = mapOprMaterialAvailabilityDateTime.lookup(hashKey);
            }
            mapOprMaterialAvailabilityDateTime.insert(hashKey, max(futuresDateTime, maxFuturesDateTime));
        }

        return mapOprMaterialAvailabilityDateTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initGanttTmpMaterialsPlannedProductionOrder</Name>
				<Source><![CDATA[
    /// <summary>Initializes a material availability information for a planned production order.</summary>
    /// <param name = "reqTrans">The material's requirement.</param>
    /// <param name = "oprNum">The operation number.</param>
    public void initGanttTmpMaterialsPlannedProductionOrder(ReqTrans reqTrans, OprNum oprNum)
    {
        ganttTmpMaterials.clear();
        ganttTmpMaterials.RefId = reqTrans.RefId;
        ganttTmpMaterials.RefType = WrkCtrCapRefType::PlannedOrder;
        ganttTmpMaterials.OprNum = oprNum;
        ganttTmpMaterials.ItemId = reqTrans.ItemId;
        ganttTmpMaterials.InventDimId = reqTrans.CovInventDimId;
        ganttTmpMaterials.ReqQty = -1 * reqTrans.Qty;
        ganttTmpMaterials.DisplayProductNumber = InventTable::getProductNumberForItemDim(reqTrans.ItemId, reqTrans.inventDim());
        ganttTmpMaterials.AvailabilityDate = reqTrans.FuturesDate;
        ganttTmpMaterials.AvailabilityTime = reqTrans.FuturesTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadDataProjWrkCtrIdSetExtended</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads the project hour forecast data that is to be used in the Gantt chart.
    /// </summary>
    /// <param name="_wrkCtrIds">The set of resource Ids to load.</param>
    /// <remarks>
    ///    All jobs that satisfy the given time interval and workcenter are loaded, regardless that they are
    ///    displayed or not in the control.
    /// </remarks>
    private void loadDataProjWrkCtrIdSetExtended(Set _wrkCtrIds)
    {
        hasProjJobs = false;

        if (!this.canLoadProjData())
        {
            return;
        }

        Set setDataProj = Set::create(GanttData_WrkCtr::loadDataProjOnServer(_wrkCtrIds.pack(),
                                                                         this.parmLoadingFromDate(),
                                                                         this.parmLoadingToDate(),
                                                                         (loadOnlySpecific ? this.conSetLoadIds() : conNull())));
        ProjForecastEmpl    projForecastEmpl;
        ProjTable           projTable;
        WrkCtrTable         wrkCtrTable;
        WrkCtrResourceGroup wrkCtrResourceGroup;
        smmActivities       smmActivities;
        boolean             allowEdit = GanttTable_WrkCtrJob::allowEditProj(false);

        // iterate through the project jobs received from the server
        SetEnumerator setEnumerator = setDataProj.getEnumerator();
        while (setEnumerator && setEnumerator.moveNext())
        {
            [projForecastEmpl, projTable, smmActivities, wrkCtrTable, wrkCtrResourceGroup] = setEnumerator.current();
            this.insertDataProj(projForecastEmpl,
                                projTable,
                                smmActivities,
                                wrkCtrTable,
                                setLoadWrkCtrIds.in(projForecastEmpl.SchedWrkCtrId)  &&
                                this.canLoadProjForecastEmpl(projForecastEmpl, false, this.parmLoadingFromDate(), this.parmLoadingToDate()),
                                wrkCtrResourceGroup,
                                allowEdit);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertDataProd</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts data into the <see cref="GanttTmpWrkCtrJob Table" /> based on a production order data.
    /// </summary>
    /// <param name="_prodRouteJob">
    ///    The <see cref="ProdRouteJob Table" /> buffer containing the job details.
    /// </param>
    /// <param name="_prodRoute">
    ///    The <see cref="ProdRoute Table" /> buffer containing details about the operation to which the job
    ///    belongs.
    /// </param>
    /// <param name="_prodTable">
    ///    The <see cref="ProdTable Table" /> buffer containing details about the production order to which
    ///    the job belongs.
    /// </param>
    /// <param name="_wrkCtrTable">
    ///    The <see cref="WrkCtrTable Table" /> buffer containing information about the associated work center.
    /// </param>
    /// <param name="_isDisplayed">
    ///    Set to true if the job should be displayed in the Gantt chart; otherwise set to false.
    /// </param>
    /// <param name="_wrkCtrResourceGroup">
    ///    The <see cref="WrkCtrResourceGroup Table" /> buffer containing information about the associated resource group.
    /// </param>
    /// <param name="_allowEdit">
    ///    Determines if the job is allowed to be edited (moved); optional.
    /// </param>
    /// <param name="_materialAvailabilityDateTime">
    ///    The material availability date/time of the operation; optional. The parameter is not used.
    /// </param>
    protected void insertDataProd(ProdRouteJob          _prodRouteJob,
                                  ProdRoute             _prodRoute,
                                  ProdTable             _prodTable,
                                  WrkCtrTable           _wrkCtrTable,
                                  boolean               _isDisplayed,
                                  WrkCtrResourceGroup   _wrkCtrResourceGroup = null,
                                  boolean               _allowEdit = true,
                                  utcdatetime           _materialAvailabilityDateTime = DateTimeUtil::minValue())
    {
        if (_isDisplayed)
        {
            hasProdJobs = true;
        }
                
        // insert production job data
        ganttTableWrkCtrJob.cleanTableBuffer();

        // avoid recomputing each prodRouteJob on form's opening as nothing is changed yet.
        if (localGanttClient.isFirstLoad())
        {
            ganttTableWrkCtrJob.initFromProdRouteJob(_prodRouteJob, _prodRoute);
            ganttTableWrkCtrJob.setAllowEdit(_allowEdit);
        }
        else
        {
            ganttTableWrkCtrJob.setAllowEdit(_allowEdit);
            ganttTableWrkCtrJob.initFromProdRouteJob(_prodRouteJob, _prodRoute);
        }

        ganttTableWrkCtrJob.initFromProdRoute(_prodRoute);
        ganttTableWrkCtrJob.initFromProdTable(_prodTable);

        if (prmisDefault(_wrkCtrResourceGroup))
        {
            ganttTableWrkCtrJob.initFromWrkCtrTable(_wrkCtrTable, _prodRouteJob.FromDate, _prodRouteJob.ToDate);
        }
        else
        {
            ganttTableWrkCtrJob.initFromWrkCtrResourceGroup(_wrkCtrResourceGroup);
        }

        ganttTableWrkCtrJob.setReqPlanId(reqPlanIdDefaultDynamic);

        ganttTableWrkCtrJob.initFromGanttSetup(localGanttSetup);
        ganttTableWrkCtrJob.initFromGanttColor(localGanttClient.parmGanttColor());

        ganttTableWrkCtrJob.initEmptyGroupNames();
        ganttTableWrkCtrJob.setIsDisplayed(_isDisplayed);

        if (!isGanttDataWrkCtrMaterialAvailabilityFlightEnabled || localGanttSetup.parmShowProdJobMaterialDate())
        {
            str hashKeyMaterialAvailability = this.hashKeyMaterialAvailability(_prodRoute.ProdId, _prodRoute.OprNum, WrkCtrCapRefType::Production);
            if (_prodRoute.OprNum && mapOprMaterialAvailabilityDateTime.exists(hashKeyMaterialAvailability))
            {
                utcdatetime materialAvailabilityDateTime = mapOprMaterialAvailabilityDateTime.lookup(hashKeyMaterialAvailability);
        
                ganttTableWrkCtrJob.setMaterialAvailabilityDateTime(materialAvailabilityDateTime);
                ganttTableWrkCtrJob.setRequiresMaterials(true);
            }
        }

        GanttTmpWrkCtrJob duplicateRecord = ganttTableWrkCtrJob.findDuplicate();
        if (!duplicateRecord)
        {
            ganttTableWrkCtrJob.insert(_prodRouteJob.RecId, _prodRouteJob.RecVersion);

            // insert calendar name
            this.insertCalendarName(ganttTableWrkCtrJob);
        }
        else
        {
            if (_isDisplayed && duplicateRecord.IsDisplayed == NoYes::No)
            {
                ganttTableWrkCtrJob.updateField(duplicateRecord.RecId, fieldstr(GanttTmpWrkCtrJob, IsDisplayed), NoYes::Yes);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertDataPlannedProd</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts data into the <see cref="GanttTmpWrkCtrJob Table" /> based on a planned production order data.
    /// </summary>
    /// <param name="_reqRouteJob">
    ///    The <see cref="ReqRouteJob Table" /> buffer containing the job details.
    /// </param>
    /// <param name="_reqRoute">
    ///    The <see cref="ReqRoute Table" /> buffer containing details about the operation to which the job
    ///    belongs.
    /// </param>
    /// <param name="_reqPO">
    ///    The <see cref="ReqPO Table" /> buffer containing details about the planned order to which the job
    ///    belongs.
    /// </param>
    /// <param name="_wrkCtrTable">
    ///    The <see cref="WrkCtrTable Table" /> buffer containing information about the associated work center.
    /// </param>
    /// <param name="_isDisplayed">
    ///    Set to true if the job should be displayed in the Gantt chart; otherwise set to false.
    /// </param>
    /// <param name="_wrkCtrResourceGroup">
    ///    The <see cref="WrkCtrResourceGroup Table" /> buffer containing information about the associated resource group.
    /// </param>
    /// <param name="_allowEdit">
    ///    Determines if the job is allowed to be edited (moved); optional.
    /// </param>
    /// <param name="_materialAvailabilityDateTime">
    ///    The material availability date/time of the operation; optional. The parameter is not used.
    /// </param>
    protected void insertDataPlannedProd(ReqRouteJob            _reqRouteJob,
                                         ReqRoute               _reqRoute,
                                         ReqPO                  _reqPO,
                                         WrkCtrTable            _wrkCtrTable,
                                         boolean                _isDisplayed,
                                         WrkCtrResourceGroup    _wrkCtrResourceGroup = null,
                                         boolean                _allowEdit = true,
                                         utcdatetime            _materialAvailabilityDateTime = DateTimeUtil::minValue())
    {
        if (_isDisplayed)
        {
            hasPlannedProdJobs = true;
        }

        // insert production job data
        ganttTableWrkCtrJob.cleanTableBuffer();

        // avoid recomputing each reqRouteJob on form's opening as nothing is changed yet.
        if (localGanttClient.isFirstLoad())
        {
            if (isGanttDataWrkCtrOpenSaveMoveFlightEnabled)
            {
                this.initFromReqRouteJob(_reqRouteJob, _reqRoute);
            }
            else
            {
                ganttTableWrkCtrJob.initFromReqRouteJob(_reqRouteJob, _reqRoute);
            }
            ganttTableWrkCtrJob.setAllowEdit(_allowEdit);
        }
        else
        {
            ganttTableWrkCtrJob.setAllowEdit(_allowEdit);

            if (isGanttDataWrkCtrOpenSaveMoveFlightEnabled)
            {
                this.initFromReqRouteJob(_reqRouteJob, _reqRoute);
            }
            else
            {
                ganttTableWrkCtrJob.initFromReqRouteJob(_reqRouteJob, _reqRoute);
            }
        }
        ganttTableWrkCtrJob.initFromReqRoute(_reqRoute);
        ganttTableWrkCtrJob.initFromReqPO(_reqPO);

        if (prmisDefault(_wrkCtrResourceGroup))
        {
            ganttTableWrkCtrJob.initFromWrkCtrTable(_wrkCtrTable, _reqRouteJob.FromDate, _reqRouteJob.ToDate);
        }
        else
        {
            ganttTableWrkCtrJob.initFromWrkCtrResourceGroup(_wrkCtrResourceGroup);
        }

        ganttTableWrkCtrJob.initFromGanttSetup(localGanttSetup);
        ganttTableWrkCtrJob.initFromGanttColor(localGanttClient.parmGanttColor());

        ganttTableWrkCtrJob.initEmptyGroupNames();
        ganttTableWrkCtrJob.setIsDisplayed(_isDisplayed);
        
        GanttTmpWrkCtrJob duplicateRecord = ganttTableWrkCtrJob.findDuplicate();
        if (!duplicateRecord)
        {
            if (!isGanttDataWrkCtrMaterialAvailabilityFlightEnabled || localGanttSetup.parmShowPlannedProdJobMaterialDate())
            {
                str hashKeyMaterialAvailability = this.hashKeyMaterialAvailability(_reqRoute.RefId, _reqRoute.OprNum, WrkCtrCapRefType::PlannedOrder);
                if (_reqRoute.OprNum && mapOprMaterialAvailabilityDateTime.exists(hashKeyMaterialAvailability))
                {
                    utcdatetime materialAvailabilityDateTime = mapOprMaterialAvailabilityDateTime.lookup(hashKeyMaterialAvailability);
        
                    ganttTableWrkCtrJob.setMaterialAvailabilityDateTime(materialAvailabilityDateTime);
                    ganttTableWrkCtrJob.setRequiresMaterials(true);
                }
            }
            ganttTableWrkCtrJob.insert(_reqRouteJob.RecId, _reqRouteJob.RecVersion);

            // insert calendar name
            this.insertCalendarName(ganttTableWrkCtrJob);
        }
        else
        {
            if (_isDisplayed && duplicateRecord.IsDisplayed == NoYes::No)
            {
                ganttTableWrkCtrJob.updateField(duplicateRecord.RecId, fieldstr(GanttTmpWrkCtrJob, IsDisplayed), NoYes::Yes);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromReqRouteJob</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the <c>GanttTmpWrkCtrJob</c> data fields that have data from a planned production order
    ///    job
    /// </summary>
    /// <param name="_reqRouteJob">
    ///    A table buffer that contains the source planned production order job data.
    /// </param>
    /// <param name="_reqRoute">
    ///    A table buffer that contains the planned production order route data.
    /// </param>
    public void initFromReqRouteJob(ReqRouteJob _reqRouteJob,
                                    ReqRoute    _reqRoute = null)  // set for better performance
    {
        #timeConstants
        GanttTmpWrkCtrJob ganttTmpWrkCtrJob = ganttTableWrkCtrJob.parmTableBuffer();

        ganttTmpWrkCtrJob.JobId                     = strfmt('%1', _reqRouteJob.RecId);
        ganttTmpWrkCtrJob.JobType                   = _reqRouteJob.JobType;
        ganttTmpWrkCtrJob.JobTypeActivityPurpose    = enum2str(_reqRouteJob.JobType);
        ganttTmpWrkCtrJob.JobDuration               = ganttTmpWrkCtrJob.AllowEdit ? ganttTableWrkCtrJob.recalcWrkCtrHoursFromReqRoute(_reqRouteJob, _reqRoute) * #SecondsPerHour
                                                                                  : _reqRouteJob.SchedTimeHours * #SecondsPerHour;
        ganttTmpWrkCtrJob.ReqPlanId                 = localGanttSetup.parmReqPlanIdPlannedProd();
        ganttTmpWrkCtrJob.RefId                     = _reqRouteJob.ReqPOId;
        ganttTmpWrkCtrJob.RefType                   = WrkCtrCapRefType::PlannedOrder;
        ganttTmpWrkCtrJob.WrkCtrId                  = _reqRouteJob.WrkCtrId;
        ganttTmpWrkCtrJob.CalendarId                = ganttTableWrkCtrJob.getCalendarNameFromReqRouteJob(_reqRouteJob, _reqRoute);
        ganttTmpWrkCtrJob.OprNum                    = _reqRouteJob.OprNum;
        ganttTmpWrkCtrJob.OprNumActivityNumber      = strfmt('%1', _reqRouteJob.OprNum);
        ganttTmpWrkCtrJob.OprPriority               = _reqRouteJob.OprPriority;
        ganttTmpWrkCtrJob.SchedFromDate             = _reqRouteJob.FromDate;
        ganttTmpWrkCtrJob.SchedFromTime             = _reqRouteJob.FromTime;
        ganttTmpWrkCtrJob.SchedToDate               = _reqRouteJob.ToDate;
        ganttTmpWrkCtrJob.SchedToTime               = _reqRouteJob.ToTime;
        ganttTmpWrkCtrJob.SchedFromDateTime         = DateTimeUtil::newDateTime(_reqRouteJob.FromDate, _reqRouteJob.FromTime, DateTimeUtil::getUserPreferredTimeZone());
        ganttTmpWrkCtrJob.SchedToDateTime           = DateTimeUtil::newDateTime(_reqRouteJob.ToDate, _reqRouteJob.ToTime, DateTimeUtil::getUserPreferredTimeZone());
        ganttTmpWrkCtrJob.NumType                   = _reqRouteJob.NumType;
        ganttTmpWrkCtrJob.NumPrimary                = _reqRouteJob.NumPrimary;
        ganttTmpWrkCtrJob.NumSecondary              = _reqRouteJob.NumSecondary;
        ganttTmpWrkCtrJob.Link                      = _reqRouteJob.Link;
        ganttTmpWrkCtrJob.ProjLineNum               = 0;

        ganttTableWrkCtrJob.initReserveCapacityFromReqRouteJob(_reqRouteJob, _reqRoute);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCalendarName</Name>
				<Source><![CDATA[
    public void addCalendarName(Name _name)
    {
        if (!isGanttDataWrkCtrOpenSaveMoveFlightEnabled)
        {
            super(_name);
            return;
        }

        if (!localGanttSetup.parmLoadCalendar())
        {
            return;
        }

        setCalendarNames.add(_name);
    }

]]></Source>
			</Method>
			<Method>
				<Name>jobRequiresMaterials</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a job requires any materials.
    /// </summary>
    /// <param name = "_ganttTmpWrkCtrJob">The job to find materials for.</param>
    /// <returns>true if the job requires materials; otherwise, false.</returns>
    public boolean jobRequiresMaterials(GanttTmpWrkCtrJob _ganttTmpWrkCtrJob)
    {
        return _ganttTmpWrkCtrJob.RequiresMaterials;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadProductionOrders</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Queries production orders related data for Gantt
    /// </summary>
    /// <param name="_conLoadWrkCtrIds">
    ///    A container which is the packed set of work center IDs to be loaded.
    /// </param>
    /// <param name="_loadingFromDate">
    ///    A <c>Date</c> value indicating the start date for the data fetch interval.
    /// </param>
    /// <param name="_loadingToDate">
    ///    A <c>Date</c> value indicating the end date for the data fetch interval.
    /// </param>
    /// <param name="_conRefIdsToLoad">
    ///    A <c>container</c> with a packed set of the Ids of specific production orders to load instead of all orders on the work centers; optional.
    /// </param>
    /// <returns>
    ///    A packed set of containers holding <see cref="T:ProdRouteJob" />, <see cref="T:ProdRoute" />, <see
    ///    cref="T:ProdTable" />, <see cref="T:WrkCtrTable" /> and <see cref="T:WrkCtrResourceGroup" /> record pairs that were fetched.
    /// </returns>
    protected container loadProductionOrders(container    _conLoadWrkCtrIds,
                                             date         _loadingFromDate,
                                             date         _loadingToDate,
                                             container    _conRefIdsToLoad = conNull())
    {
        SetEnumerator       setEnumerator;
        WrkCtrId            wrkCtrId;

        ProdRouteJob        prodRouteJob;
        ProdRoute           prodRoute;
        ProdTable           prodTable;
        WrkCtrTable         wrkCtrTable;
        WrkCtrResourceGroup wrkCtrResourceGroup;

        Set             setRefIdsToLoad = new Set(Types::String);
        Set             setDataProd = new Set(Types::Container);
        Set             setLoadWrkCtrIdsLocal;

        if (_conRefIdsToLoad != conNull())
        {
            // Load only specific orders
            setRefIdsToLoad = Set::create(_conRefIdsToLoad);
        }
        else
        {
            if (_conLoadWrkCtrIds)
            {
                setLoadWrkCtrIdsLocal = Set::create(_conLoadWrkCtrIds);
            }
            else
            {
                setLoadWrkCtrIdsLocal = new Set(Types::String);
            }

            // gather all production orders to load in a set
            setEnumerator = setLoadWrkCtrIdsLocal.getEnumerator();
            while (setEnumerator && setEnumerator.moveNext())
            {
                wrkCtrId = setEnumerator.current();

                while select ProdId from prodRouteJob
                    group by ProdId
                    where prodRouteJob.WrkCtrId     == wrkCtrId         &&
                          prodRouteJob.ToDate       >= _loadingFromDate &&
                          prodRouteJob.FromDate     <= _loadingToDate
                {
                    setRefIdsToLoad.add(prodRouteJob.ProdId);
                }
            }
        }

        if (!setRefIdsToLoad.elements())
        {
            return setDataProd.pack();
        }

        this.createFilterTempDb(setRefIdsToLoad);

        while select prodRouteJob
            join prodRoute
                where prodRoute.ProdId          == prodRouteJob.ProdId      &&
                      prodRoute.OprNum          == prodRouteJob.OprNum      &&
                      prodRoute.OprPriority     == prodRouteJob.OprPriority
            join prodTable
                where prodTable.ProdId          == prodRouteJob.ProdId
            join wrkCtrTable
                where wrkCtrTable.WrkCtrId      == prodRouteJob.WrkCtrId
            exists join productionOrdersTmpFilter
                where productionOrdersTmpFilter.ProdId == prodRouteJob.ProdId
        {
            wrkCtrResourceGroup = WrkCtrTable::getResourceGroupFromCache(wrkCtrTable, prodRouteJob.FromDate, prodRouteJob.ToDate);
            setDataProd.add([prodRouteJob, prodRoute, prodTable, wrkCtrTable, wrkCtrResourceGroup]);
        }

        return setDataProd.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFilterTempDb</Name>
				<Source><![CDATA[
    private void createFilterTempDb(Set _setRefIdsToLoad)
    {
        RecordInsertList filterInsertList = new RecordInsertList(tablenum(ProdTableTmpFilter), true, true, true, true, true, productionOrdersTmpFilter);
        SetEnumerator setEnumerator = _setRefIdsToLoad.getEnumerator();
        while (setEnumerator && setEnumerator.moveNext())
        {
            select RecId from productionOrdersTmpFilter
                where productionOrdersTmpFilter.ProdId == setEnumerator.current();

            if (!productionOrdersTmpFilter.RecId)
            {
                productionOrdersTmpFilter.clear();
                productionOrdersTmpFilter.ProdId = setEnumerator.current();
                filterInsertList.add(productionOrdersTmpFilter);
            }
        }
        filterInsertList.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadPlannedProductionOrders</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Queries planned production orders related data for Gantt
    /// </summary>
    /// <param name="_conLoadWrkCtrIds">
    ///    A container which is the packed set of work center IDs to be loaded.
    /// </param>
    /// <param name="_loadingFromDate">
    ///    A <c>Date</c> value indicating the start date for the data fetch interval.
    /// </param>
    /// <param name="_loadingToDate">
    ///    A <c>Date</c> value indicating the end date for the data fetch interval.
    /// </param>
    /// <param name="_reqPlanId">
    ///    A <c>ReqPlanId</c> indicating which master plan to use for loading planned production orders.
    /// </param>
    /// <param name="_conRefIdsToLoad">
    ///    A <c>container</c> with a packed set of the Ids of specific planned production orders to load instead of all orders on the work centers; optional.
    /// </param>
    /// <returns>
    ///    A packed set of containers holding <see cref="T:ReqRouteJob" />, <see cref="T:ReqRoute" />, <see
    ///    cref="T:ReqPO" />, <see cref="T:WrkCtrTable" /> and <see cref="T:WrkCtrResourceGroup" /> record pairs that were fetched.
    /// </returns>
    protected container loadPlannedProductionOrders(container _conLoadWrkCtrIds,
                                                    date      _loadingFromDate,
                                                    date      _loadingToDate,
                                                    ReqPlanId _reqPlanId,
                                                    container _conRefIdsToLoad = conNull())
    {
        ReqRouteJob         reqRouteJob;
        Set                 setRefIdsToLoad     = new Set(Types::String);
        Set                 setDataPlannedProd  = new Set(Types::Container);
        reqPlanVersionRefRecId = ReqPlan::findReqPlanId(_reqPlanId).findActiveVersion().RecId;

        if (_conRefIdsToLoad != conNull())
        {
            // Load only specific orders
            setRefIdsToLoad = Set::create(_conRefIdsToLoad);
        }
        else
        {
            Set setLoadWrkCtrIdsLocal;

            if (_conLoadWrkCtrIds)
            {
                setLoadWrkCtrIdsLocal = Set::create(_conLoadWrkCtrIds);
            }
            else
            {
                setLoadWrkCtrIdsLocal = new Set(Types::String);
            }

            // gather all planned production orders to load in a set
            WrkCtrId wrkCtrId;
            SetEnumerator setEnumerator = setLoadWrkCtrIdsLocal.getEnumerator();
            while (setEnumerator && setEnumerator.moveNext())
            {
                wrkCtrId = setEnumerator.current();
                while select ReqPOId from reqRouteJob
                    group by ReqPOId
                    where reqRouteJob.WrkCtrId                  == wrkCtrId                 &&
                          reqRouteJob.PlanVersion               == reqPlanVersionRefRecId   &&
                          reqRouteJob.ToDate                    >= _loadingFromDate         &&
                          reqRouteJob.FromDate                  <= _loadingToDate
                {
                    setRefIdsToLoad.add(reqRouteJob.ReqPOId);
                }
            }
        }

        if (!setRefIdsToLoad.elements())
        {
            return setDataPlannedProd.pack();
        }
        
        // reuse productionOrdersTmpFilter tempDB for planned production orders as well
        delete_from productionOrdersTmpFilter;
        this.createFilterTempDb(setRefIdsToLoad);

        ReqRoute            reqRoute;
        ReqPO               reqPO;
        WrkCtrTable         wrkCtrTable;
        WrkCtrResourceGroup wrkCtrResourceGroup;

        while select reqRouteJob
            where reqRouteJob.PlanVersion    == reqPlanVersionRefRecId
            join reqRoute
                where reqRoute.RefId         == reqRouteJob.ReqPOId     &&
                      reqRoute.PlanVersion   == reqPlanVersionRefRecId  &&
                      reqRoute.OprNum        == reqRouteJob.OprNum      &&
                      reqRoute.OprPriority   == reqRouteJob.OprPriority
            join reqPO
                where reqPO.PlanVersion      == reqPlanVersionRefRecId  &&
                      reqPO.RefId            == reqRouteJob.ReqPOId
            join wrkCtrTable
                where wrkCtrTable.WrkCtrId   == reqRouteJob.WrkCtrId
            exists join productionOrdersTmpFilter
                where productionOrdersTmpFilter.ProdId == reqRouteJob.ReqPOId
        {
            wrkCtrResourceGroup = WrkCtrTable::getResourceGroupFromCache(wrkCtrTable, reqRouteJob.FromDate, reqRouteJob.ToDate);
            setDataPlannedProd.add([reqRouteJob, reqRoute, reqPO, wrkCtrTable, wrkCtrResourceGroup]);
        }

        return setDataPlannedProd.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadMaterialAvailbilityProd</Name>
				<Source><![CDATA[
    /// <summary>Loads material availability information for production orders.</summary>
    /// <param name = "_prodTable">The production order record to load for.</param>
    /// <returns>A <c>Map</c> with the maximum material availability date per operation number.</returns>
    protected Map loadMaterialAvailbilityProd(ProdTable _prodTable)
    {
        ProdBOM                     prodBOM;
        ReqTrans                    reqTrans;
        InventTransOriginProdBOM    inventTransOriginProdBOM;
        ProdRoute                   firstProdRoute;

        ganttTmpMaterials.clear();

        while select InventTransId, ProdId, ItemId, OprNum, InventDimId, QtyBOMCalc, RecId
            from prodBOM
            order by prodBOM.ProdId
            join InventTransOrigin from inventTransOriginProdBOM
                where inventTransOriginProdBOM.ProdBOMDataAreaId    == prodBOM.DataAreaId
                   && inventTransOriginProdBOM.ProdBOMInventTransId == prodBOM.InventTransId
            outer join FuturesDate, FuturesTime from reqTrans
                where reqTrans.PlanVersion       == reqPlanVersionRefRecId
                   && reqTrans.RefType           == ReqRefType::ProdLine
                   && reqTrans.RefId             == prodBOM.ProdId
                   && reqTrans.InventTransOrigin == inventTransOriginProdBOM.InventTransOrigin
            exists join productionOrdersTmpFilter
                where productionOrdersTmpFilter.ProdId  == prodBOM.ProdId
        {
            OprNum oprNum = prodBOM.OprNum;
            if (!oprNum)
            {
                // In case the OprNum is not explicitly set on the ProdBOM it must be defaulted.
                if (!firstProdRoute)
                {
                    firstProdRoute = ProdRoute::findFirst(prodBOM.ProdId);
                }
                oprNum = firstProdRoute.OprNum;
            }
            this.initGanttTmpMaterialsProductionOrder(prodBOM, oprNum, reqTrans);
            
            // Determine the maximum futures date/time per operation
            utcdatetime futuresDateTime = DateTimeUtil::newDateTime(reqTrans.FuturesDate, reqTrans.FuturesTime, DateTimeUtil::getUserPreferredTimeZone());
            utcDateTime maxFuturesDateTime;
            str hashKey = this.hashKeyMaterialAvailability(ganttTmpMaterials.RefId, ganttTmpMaterials.OprNum, ganttTmpMaterials.RefType);

            if (mapOprMaterialAvailabilityDateTime.exists(hashKey))
            {
                maxFuturesDateTime = mapOprMaterialAvailabilityDateTime.lookup(hashKey);
            }
            mapOprMaterialAvailabilityDateTime.insert(hashKey, max(futuresDateTime, maxFuturesDateTime));
        }

        if (ganttTmpMaterials.RefRecId)
        {
            rilMaterials.add(ganttTmpMaterials);
        }

        return mapOprMaterialAvailabilityDateTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initGanttTmpMaterialsProductionOrder</Name>
				<Source><![CDATA[
    /// <summary>Initializes a material availability information for a production order.</summary>
    /// <param name = "prodBOM">The production order's material.</param>
    /// <param name = "oprNum">The operation number.</param>
    /// <param name = "reqTrans">The material's requirement.</param>
    public void initGanttTmpMaterialsProductionOrder(ProdBOM prodBOM, OprNum oprNum, ReqTrans reqTrans)
    {
        if (prodBOM.RecId != ganttTmpMaterials.RefRecId)
        {
            if (ganttTmpMaterials.RefRecId)
            {
                rilMaterials.add(ganttTmpMaterials);
                ganttTmpMaterials.clear();
            }

            ganttTmpMaterials.RefRecId = prodBOM.RecId;
            ganttTmpMaterials.RefId = prodBOM.ProdId;
            ganttTmpMaterials.RefType = WrkCtrCapRefType::Production;
            ganttTmpMaterials.OprNum = oprNum;
            ganttTmpMaterials.ItemId = prodBOM.ItemId;
            ganttTmpMaterials.InventDimId = prodBOM.InventDimId;
            ganttTmpMaterials.ReqQty = prodBOM.QtyBOMCalc;
            ganttTmpMaterials.DisplayProductNumber = InventTable::getProductNumberForItemDim(prodBOM.ItemId, prodBOM.inventDim());
            ganttTmpMaterials.AvailabilityDate = reqTrans.FuturesDate;
            ganttTmpMaterials.AvailabilityTime = reqTrans.FuturesTime;
        }
        else
        {
            // There can be multiple demand records per BOM line (in case that some part is reserved against onhand etc) so need to find the maximum
            // futuresDate/time per BOM line
            if (reqTrans.FuturesDate > ganttTmpMaterials.AvailabilityDate ||
                    (reqTrans.FuturesDate == ganttTmpMaterials.AvailabilityDate && reqTrans.FuturesTime == ganttTmpMaterials.AvailabilityTime))
            {
                ganttTmpMaterials.AvailabilityDate = reqTrans.FuturesDate;
                ganttTmpMaterials.AvailabilityTime = reqTrans.FuturesTime;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>hashKeyMaterialAvailability</Name>
				<Source><![CDATA[
    private str hashKeyMaterialAvailability(str _refId, OprNum _oprNum, WrkCtrCapRefType _refType)
    {
        return _refId + '~' + int2Str(_oprNum) + '~' + enum2Str(_refType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCalendarsBase</Name>
				<Source><![CDATA[
    private boolean createCalendarsBase()
    {
        if (this.parmGanttClient().parmGanttSetup()                      &&
           !this.parmGanttClient().parmGanttSetup().parmLoadCalendar())
        {
            return false;
        }

        if (!setCalendarNames.elements())
        {
            return false;
        }

        GanttCalendar ganttCalendar;
        SetEnumerator setEnumerator = setCalendarNames.getEnumerator();

        while (setEnumerator && setEnumerator.moveNext())
        {
            if (ganttCalendarCollection.findCalendarName(setEnumerator.current()))
            {
                continue;
            }

            ganttCalendar = GanttCalendar::newGanttCalendarType(this.ganttCalendarType());
            ganttCalendar.parmCalendarName(setEnumerator.current());

            ganttCalendarCollection.insert(ganttCalendar);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLinkGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the link group if it has already been set for any of the records in the set _setRecIds
    /// </summary>
    /// <param name = "_setRecords">The set of jobs</param>
    /// <returns>The number of links in the link group</returns>
    private int64 getLinkGroup(Set _setRecords)
    {
        int64               resultLinkGroup = 0;
        GanttTmpWrkCtrJob   jobTmp;

        SetEnumerator setEnumeratorGroup = _setRecords.getEnumerator();
        while (setEnumeratorGroup && setEnumeratorGroup.moveNext())
        {
            jobTmp = setEnumeratorGroup.current();
            resultLinkGroup = this.getLinkGroupByRecId(jobTmp.RecId);

            if (resultLinkGroup)
            {
                break;
            }
        }

        return resultLinkGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadLinksByRecIds</Name>
				<Source><![CDATA[
    /// <summary>Inserts links between the current job and all next jobs.</summary>
    /// <param name = "_currentJob">The current job in the route</param>
    /// <param name = "allJobs">The set of all jobs</param>
    /// <param name = "nextJob">The next job in the route</param>
    /// <param name = "mapNextJobs">The map of subsequent jobs</param>
    /// <param name = "_primaryJob">The primary job</param>
    private void loadLinksByRecIds(GanttTmpWrkCtrJob _currentJob,
                                   GanttTmpWrkCtrJob allJobs,
                                   GanttTmpWrkCtrJob nextJob,
                                   Map               mapNextJobs,
                                   GanttTmpWrkCtrJob _primaryJob = null)
    {
        container           conRecords;
        GanttTmpWrkCtrJob   jobTmp;

        // the _primaryJob is passed so this is treated as the master job to which the links should be attached
        if (_primaryJob)
        {
            jobTmp = _primaryJob;
        }
        else
        {
            jobTmp = _currentJob;
        }

        if (!mapNextJobs.exists(jobTmp.RecId))
        {
            // get the next nodes for the job
            conRecords = GanttTmpWrkCtrJob::getNextJobsRecords(jobTmp, allJobs, _primaryJob ? true : false);
            mapNextJobs.add(jobTmp.RecId, conRecords);
        }
        else
        {
            conRecords = mapNextJobs.lookup(jobTmp.RecId);
        }

        // if no link group is already set on the link predecessor then set it to a new number
        if (!mapRecId2LinkGroup.exists(jobTmp.RecId))
        {
            if (_currentJob.IsDisplayed)
            {
                this.addRecId2LinkGroup(_currentJob.RecId, linkGroupNo);
            }
            linkGroupNo ++;
        }
        else
        {
            // if we don't exist in the link group map and we have a primary job which exists in the link group map
            if (_primaryJob                                 &&
                    mapRecId2LinkGroup.exists(_primaryJob.RecId))
            {
                this.addRecId2LinkGroup(_currentJob.RecId, mapRecId2LinkGroup.lookup(_primaryJob.RecId));
            }
        }

        if (conRecords != connull())
        {
            Set setRecords = Set::create(conRecords);
            int64 nextJobsLinkGroup;

            // if the link type is not enforcing start or end then make sure that the next jobs get the same group id
            if (jobTmp.Link != SchedJobLink::SS &&
                    jobTmp.Link != SchedJobLink::FF)
            {
                nextJobsLinkGroup = this.getLinkGroup(setRecords);
                if (!nextJobsLinkGroup)
                {
                    // if none of the jobs already has a link group id, take a new one
                    nextJobsLinkGroup = linkGroupNo;
                    linkGroupNo ++;
                }
            }

            // create all links to the next jobs
            GanttLinkType ganttLinkType;
            SetEnumerator setEnumerator = setRecords.getEnumerator();
            while (setEnumerator && setEnumerator.moveNext())
            {
                nextJob = setEnumerator.current();
                if (nextJob.RecId)
                {
                    ganttTableLink.cleanTableBuffer();

                    // Update the link group number on the nextJob
                    if (nextJob.IsDisplayed)
                    {
                        //
                        // Check if the link is a SS or and FF link.
                        // Also check that the previous job does exist in the Rec to link group id map
                        // (it could be that it is not in the map because it is not displayed)
                        //
                        if ((jobTmp.Link == SchedJobLink::SS ||
                                jobTmp.Link == SchedJobLink::FF) &&
                                mapRecId2LinkGroup.exists(_currentJob.RecId))
                        {
                            this.addRecId2LinkGroup(nextJob.RecId, mapRecId2LinkGroup.lookup(_currentJob.RecId));
                        }
                        else
                        {
                            this.addRecId2LinkGroup(nextJob.RecId, nextJobsLinkGroup);
                        }
                    }

                    // take the link type from the primary job always
                    ganttLinkType = GanttTmpLink::schedJobLink2GanttLinkType(jobTmp.Link);

                    boolean isDisplayed = _currentJob.IsDisplayed && nextJob.IsDisplayed;
                    ganttTableLink.setLinkData(_currentJob.RecId,
                                                    nextJob.RecId,
                                                    isDisplayed,
                                                    NoYes::No,
                                                    ganttLinkType);

                    GanttTmpLink duplicateLink = ganttTableLink.findDuplicate();
                    if (!duplicateLink)
                    {
                        ganttTableLink.insert();
                    }
                    else
                    {
                        if (isDisplayed && duplicateLink.Visible == NoYes::No)
                        {
                            ganttTableLink.updateField(duplicateLink.RecId, fieldstr(GanttTmpLink, Visible), NoYes::Yes);
                        }
                    }

                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadDataLinks</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads the links information for work center data.
    /// </summary>
    protected void loadDataLinks()
    {
        GanttTmpWrkCtrJob   currentJob    = null;
        GanttTmpWrkCtrJob   allJobs       = null;
        GanttTmpWrkCtrJob   nextJob       = null;
        GanttTmpWrkCtrJob   primaryJob;
        Map                 mapNextJobs = new Map(Types::Int64, Types::Container);

        // fetch all data and stuff it into allJobs so that we can use it for looking up jobs
        currentJob = ganttTableWrkCtrJob.findFirst();

        while (currentJob.RecId)
        {
            allJobs.clear();
            allJobs.data(currentJob);
            allJobs.doInsert();

            currentJob = ganttTableWrkCtrJob.findNext();
        }

        currentJob.setTmpData(allJobs);
        nextJob.setTmpData(allJobs);

        // iterate through every job (node)
        while select currentJob
        {
            // Get the primary last workcenter job for the current job
            // For the multiple workcenters case it will get the last workcenter node,
            // since the last workcenter node actually contains the link to the next job/operation
            primaryJob = GanttTmpWrkCtrJob::find(allJobs, currentJob.RefId, currentJob.ReqPlanId, currentJob.ProjLineNum, currentJob.OprNum, currentJob.NumType, RouteOprPriority::Primary, true);

            // add links cloned from the primary job so that the secondary jobs
            // have the same successors like the primary
            this.loadLinksByRecIds(currentJob, allJobs, nextJob, mapNextJobs, primaryJob);

            // calling loadLinksByRecIds again without the primaryJob parameter is done to create StartStart links between the
            // currentJob and parallel jobs when having multiple workcenters
            if (currentJob.OprPriority == RouteOprPriority::Primary)
            {
                this.loadLinksByRecIds(currentJob, allJobs, nextJob, mapNextJobs);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCombinedCalendar</Name>
				<Source><![CDATA[
    private void createCombinedCalendar(Set               _setCombinedCalendarsNames, 
                                        Set               _setGroupRecIds, 
                                        GanttTmpWrkCtrJob _ganttTmpWrkCtrJobUpdate)
    {
        SetEnumerator           setEnumerator;
        GanttCalendarId         combinedCalendarName;
        GanttCalendarCombined   ganttCombinedCalendar;
        GanttCalendar           ganttCalendar;

        // check that we have at least one calendar to combine
        if (_setCombinedCalendarsNames.elements() > 1)
        {
            setEnumerator = _setCombinedCalendarsNames.getEnumerator();

            //create new calendar instance
            ganttCombinedCalendar = GanttCalendar::newGanttCalendarType(GanttCalendarType::Combined);

            // create the combined calendar name
            combinedCalendarName = '';
            while (setEnumerator && setEnumerator.moveNext())
            {
                if (combinedCalendarName)
                {
                    combinedCalendarName += ',';
                }
                combinedCalendarName += setEnumerator.current();

                ganttCalendar = ganttCalendarCollection.findCalendarName(setEnumerator.current());

                if (!ganttCalendar)
                {
                    throw error(strfmt("@SYS119187", setEnumerator.current()));
                }

                ganttCombinedCalendar.parmSetCombinedCalendars().add(ganttCalendar);
            }

            if (!ganttCalendarCollection.findCalendarName(combinedCalendarName))
            {
                ganttCombinedCalendar.parmCalendarName(combinedCalendarName);
                ganttCalendarCollection.insert(ganttCombinedCalendar);
            }

            ttsbegin;

            // update the calendar id on all records that get a combined calendar
            setEnumerator = _setGroupRecIds.getEnumerator();
            while (setEnumerator && setEnumerator.moveNext())
            {
                // update the loaded data
                select firstonly forupdate _ganttTmpWrkCtrJobUpdate
                    where _ganttTmpWrkCtrJobUpdate.RecId == setEnumerator.current();

                _ganttTmpWrkCtrJobUpdate.CalendarId = combinedCalendarName;
                _ganttTmpWrkCtrJobUpdate.doUpdate();

                // update the data in the recordsorted list
                this.parmGanttTableWrkCtrJob().updateField(
                        setEnumerator.current(),
                        fieldstr(GanttTmpWrkCtrJob, CalendarId),
                        combinedCalendarName);
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCalendars</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the combined calendars that are needed for parallel operations.
    /// </summary>
    /// <returns>
    ///    true if calendars were successfully created; otherwise, false.
    /// </returns>
    protected boolean createCalendars()
    {        
        if (!this.createCalendarsBase())
        {
            return false;
        }
        
        // make this expensive combined calendar update logic UI selection dependend.
        if (ganttClient.parmGanttSetup().parmThrottleCalendarPerf())
        {
            // skip unless required.
            return true;
        }

        GanttTmpWrkCtrJob ganttTmpWrkCtrJobUpdate;
        Set               setCombinedCalendarsNames = new Set(Types::String);
        Set               setGroupRecIds = null;
        SetEnumerator     setEnumeratorGroup;
        GanttTmpWrkCtrJob localGanttTableWrkCtrJob;

        ganttTmpWrkCtrJobUpdate.setTmpData(this.parmGanttTableWrkCtrJob().parmTableBuffer());

        MapEnumerator mapEnumerator = mapLinkGroups2RecIds.getEnumerator();
        while (mapEnumerator && mapEnumerator.moveNext())
        {
            setGroupRecIds = mapEnumerator.currentValue();

            setCombinedCalendarsNames = new Set(Types::String);

            // iterate through all jobs belonging to a link group and get the calendar Ids
            setEnumeratorGroup = setGroupRecIds.getEnumerator();
            while (setEnumeratorGroup && setEnumeratorGroup.moveNext())
            {
                this.parmGanttTableWrkCtrJob().findRecId(setEnumeratorGroup.current());
                localGanttTableWrkCtrJob = this.parmGanttTableWrkCtrJob().parmTableBuffer() as GanttTmpWrkCtrJob;
                setCombinedCalendarsNames.add(localGanttTableWrkCtrJob.CalendarId);
            }

            this.createCombinedCalendar(setCombinedCalendarsNames, setGroupRecIds, ganttTmpWrkCtrJobUpdate);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanAll</Name>
				<Source><![CDATA[
    public void cleanAll()
    {
        super();

        delete_from productionOrdersTmpFilter;
        this.initData();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newGanttClient</Name>
				<Source><![CDATA[
    /// <summary>Creates an instance of <c>GanttData_WrkCtrV2</c>.</summary>
    /// <param name = "_ganttClient">A gantt client.</param>
    /// <returns>An instance of <c>GanttData_WrkCtrV2</c></returns>
    public static GanttData_WrkCtrV2 newGanttClient(GanttClient_WrkCtr _ganttClient)
    {
        GanttData_WrkCtrV2 ganttData = GanttData_WrkCtrV2::construct();
        ganttData.parmGanttClient(_ganttClient);

        return ganttData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static GanttData_WrkCtrV2 construct()
    {
        return new GanttData_WrkCtrV2();
    }

]]></Source>
			</Method>
			<Method>
				<Name>save</Name>
				<Source><![CDATA[
    // If you need to do any feature related changes to this method then copy/paste it to the derived class without calling super()
    public void save()
    {
        #OCCRetryCount

        if (!isGanttDataWrkCtrOpenSaveMoveFlightEnabled)
        {
            super();
            return;
        }
        
        try
        {
            ttsbegin;
            // validate AND save in one-go.
            this.saveData(false, false);

            this.postSaveData();

            this.cleanAfterSaving();

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            this.progressFinish();

            retry;
        }
        catch (Exception::TransientSqlConnectionError)
        {
            this.progressFinish();

            if (ReqTransientSqlConnectionErrorHandlingHelper::retryTransientSqlConnectionError())
            {
                retry;
            }
            else
            {
                throw;
            }
        }
        catch (Exception::UpdateConflict)
        {
            this.progressFinish();

            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::Error)
        {
            this.progressFinish();

            throw error("@SYS18447");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Saves or validates the data modified by the user in the Gantt chart.
    /// </summary>
    /// <param name="_onlyValidate">
    ///    A Boolean indicating whether to perform only a validation, true, or to also save the data, false;
    ///    optional.
    /// </param>
    /// <param name="_skipValidation">
    ///    A Boolean value set to true to skip the validation, or false if validation is to be performed;
    ///    optional.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    An exception is thrown if one of the records in the database was modified by another user.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    ///    An exception is thrown if invalid data is detected in the gantt chart data to be saved.
    /// </exception>    
    protected void saveData(boolean _onlyValidate   = false,
                            boolean _skipValidation = true)
    {
        if (!isGanttDataWrkCtrOpenSaveMoveFlightEnabled)
        {
            super(_onlyValidate, _skipValidation);
            return;
        }

        if (_onlyValidate)
        {
            this.progressInitValidating();
        }
        else
        {
            this.progressInitSaving();
        }

        Set                     setRecIdsToBeSaved = new Set(Types::Int64);
        Set                     setModifiedRefRecIds = new Set(Types::Int64);
        GanttTmpWrkCtrJob       gantTmpWrkCtrJob;

        setRecIdsToBeSaved  = Set::union(setRecIdsToBeSaved, ganttTableWrkCtrJob.parmSetUserModifiedRecIds());

        if (!_skipValidation)
        {
            setModifiedRefRecIds = this.createModifiedRefIdSet(setRecIdsToBeSaved);
        }

        SetEnumerator setEnumerator       = setRecIdsToBeSaved.getEnumerator();

        this.progressTotal(setRecIdsToBeSaved.elements());

        // load in one server call all the data needed by the validation procedure later
        this.parmGanttTableWrkCtrJob().loadAllValidationRecords();

        while (setEnumerator && setEnumerator.moveNext())
        {
            ganttTableWrkCtrJob.findRecId(setEnumerator.current(), true);
            gantTmpWrkCtrJob = ganttTableWrkCtrJob.parmTableBuffer();

            // update modified data
            if (ganttTableWrkCtrJob.parmSetUserModifiedRecIds().in(gantTmpWrkCtrJob.RecId))
            {
                if (!_skipValidation)
                {
                    // check if we should validate the sequence
                    if (setModifiedRefRecIds.in(gantTmpWrkCtrJob.RecId))
                    {
                        if (!this.validateRefId(gantTmpWrkCtrJob.RefType, gantTmpWrkCtrJob.RefId))
                        {
                            throw Exception::Error;
                        }
                    }

                    if (!ganttTableWrkCtrJob.validateWrite())
                    {
                        throw Exception::Error;
                    }
                }

                switch (gantTmpWrkCtrJob.RefType)
                {
                    case WrkCtrCapRefType::Production   :
                        GanttData_WrkCtr::updateOrigDataProd(gantTmpWrkCtrJob, _onlyValidate);
                        break;

                    case WrkCtrCapRefType::PlannedOrder :
                        this.updateOrigDataPlannedProductionOrder(gantTmpWrkCtrJob, _onlyValidate);
                        break;

                    case WrkCtrCapRefType::Project      :
                        GanttData_WrkCtr::updateOrigDataProj(gantTmpWrkCtrJob, _onlyValidate);
                        break;
                }
            }

            this.progressUpdate();
        }

        this.handleCapacityReservations();

        // clear the data that was used for validation (data that was loaded in one server call)
        this.parmGanttTableWrkCtrJob().clearAllValidationRecords();
        this.progressFinish();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOrigDataPlannedProductionOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Propagates a planned production order route's job changes.
    /// </summary>
    /// <param name="_ganttTmpWrkCtrJob">
    ///    A planned order route's job.
    /// </param>
    /// <param name="_onlyValidate">
    ///    A boolean that indicates whether to validate only the propagated capacity reservations. False by default
    /// </param>
    protected void updateOrigDataPlannedProductionOrder(GanttTmpWrkCtrJob _ganttTmpWrkCtrJob,  boolean _onlyValidate = false)
    {
        boolean         needToUpdateReqPO       = false;
        boolean         needToUpdateReqRoute    = false;

        setprefix(strfmt("@SYS108495"   + ' %1', _ganttTmpWrkCtrJob.RefId));
        setprefix(strfmt("@SYS75245", _ganttTmpWrkCtrJob.WrkCtrId, _ganttTmpWrkCtrJob.OprNum, _ganttTmpWrkCtrJob.OprPriority, _ganttTmpWrkCtrJob.OprId));
        setprefix(strfmt("@SYS9942"     + ' %1', _ganttTmpWrkCtrJob.JobType));

        if (_ganttTmpWrkCtrJob.RefType != WrkCtrCapRefType::PlannedOrder)
        {
            throw error(strfmt("@SYS23264", funcname()));
        }

        // find planned production order
        ReqPO reqPO = ReqPO::find(reqPlanVersionRefRecId, _ganttTmpWrkCtrJob.RefId, true);

        if (!reqPO.RecId)
        {
            throw error(strfmt("@SYS113076", _ganttTmpWrkCtrJob.RefId));
        }

        // find the current planned production operation
        ReqRoute reqRoute = ReqRoute::find(reqPlanVersionRefRecId, _ganttTmpWrkCtrJob.RefId, _ganttTmpWrkCtrJob.OprNum, _ganttTmpWrkCtrJob.OprPriority, true);

        if (!reqRoute.RecId)
        {
            throw error(strfmt("@SYS113077", _ganttTmpWrkCtrJob.OprNum, _ganttTmpWrkCtrJob.RefId));
        }

        // update planned production job
        ReqRouteJob reqRouteJob = ReqRouteJob::findRecId(str2recId(_ganttTmpWrkCtrJob.JobId), true);

        if (!reqRouteJob.RecId)
        {
            throw error(strfmt("@SYS113078", _ganttTmpWrkCtrJob.JobId, _ganttTmpWrkCtrJob.RefId));
        }

        reqRouteJob.FromDate   = _ganttTmpWrkCtrJob.SchedFromDate;
        reqRouteJob.FromTime   = _ganttTmpWrkCtrJob.SchedFromTime;
        reqRouteJob.ToDate     = _ganttTmpWrkCtrJob.SchedToDate;
        reqRouteJob.ToTime     = _ganttTmpWrkCtrJob.SchedToTime;
        reqRouteJob.WrkCtrId   = _ganttTmpWrkCtrJob.WrkCtrId;

        if (!_onlyValidate)
        {
            reqRouteJob.update();
        }

        // check the route group setup
        ProdJobType prodJobType = reqRouteJob.prodJobType();

        NoYes scheduleCapacity    = prodJobType.scheduleCapacity(reqRoute.routeGroup());
        NoYes scheduleWorkTime    = prodJobType.scheduleWorkTime(reqRoute.routeGroup());

        // if Capacity parameter is specified in the route group, then Work time parameter must also be specified
        if (scheduleCapacity && !scheduleWorkTime)
        {
            throw error("@SYS68284" + "@SYS68285" + '.');
        }

        // reserve work center's capacity
        if (scheduleCapacity)
        {
            this.handleCapacityReqRouteJob(reqRouteJob, _onlyValidate);
        }
        else
        {
            // delete any existing capacity reservations
            if (!_onlyValidate)
            {
                this.markDeleteCapacityReqRouteJob(reqRouteJob);
            }
        }

        // if it is the first job in the operation
        if (reqRouteJob.RecId == ReqRouteJob::findFirstWithPriority(reqRouteJob.PlanVersion, reqRouteJob.ReqPOId, reqRouteJob.OprNum, reqRouteJob.OprPriority).RecId)
        {
            // change the start date on the operation
            reqRoute.FromDate   = _ganttTmpWrkCtrJob.SchedFromDate;
            reqRoute.FromTime   = _ganttTmpWrkCtrJob.SchedFromTime;

            needToUpdateReqRoute    = true;
        }

        // if it is the last job in the operation
        if (reqRouteJob.RecId == ReqRouteJob::findLastWithPriority(reqRouteJob.PlanVersion, reqRouteJob.ReqPOId, reqRouteJob.OprNum, reqRouteJob.OprPriority).RecId)
        {
            // change the finish date on the operation
            reqRoute.ToDate = _ganttTmpWrkCtrJob.SchedToDate;
            reqRoute.ToTime = _ganttTmpWrkCtrJob.SchedToTime;

            needToUpdateReqRoute    = true;
        }

        // if it is the first operation in the planned production order
        if (reqRoute.OprNum == ReqRoute::findFirst(reqRoute.PlanVersion, reqRoute.RefId).OprNum)
        {
            if (reqPO.SchedFromDate != reqRoute.FromDate ||
                !isGanttDataUpdateRawMaterialsWhenDateTimeChangeFlightEnabled)
            {
                // change the start date on the planned production order only when scheduling start datetime is changed.
                reqPO.SchedFromDate = reqRoute.FromDate;

                needToUpdateReqPO   = true;
            }
        }

        // if it is the last operation in the planned production order
        if (reqRoute.OprNum == ReqRoute::findLast(reqRoute.PlanVersion, reqRoute.RefId).OprNum)
        {
            if (reqPO.SchedToDate != reqRoute.ToDate ||
                !isGanttDataUpdateRawMaterialsWhenDateTimeChangeFlightEnabled)
            {
                // change the finish date on the planned production order only when scheduling end datetime is changed.
                reqPO.SchedToDate   = reqRoute.ToDate;

                needToUpdateReqPO   = true;
            }
        }

        if (!_onlyValidate)
        {
            if (needToUpdateReqRoute)
            {
                reqRoute.update();
            }

            if (needToUpdateReqPO)
            {
                reqPO.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleCapacityReqRouteJob</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates and inserts capacity reservations for planned production orders.
    /// </summary>
    /// <param name="_reqRouteJob">
    ///    A planned order route's job.
    /// </param>
    /// <param name="_onlyValidate">
    ///    A boolean that indicates whether to validate only the propagated capacity reservations. False by default
    /// </param>
    protected void handleCapacityReqRouteJob(ReqRouteJob _reqRouteJob, boolean _onlyValidate = false)
    {
        WrkCtrSlotData  reserveSlotData;
        RouteOpr        routeOpr    = _reqRouteJob.reqRoute().refRouteOpr();
        // delete capacity reservations
        if (!_onlyValidate)
        {
            this.markDeleteCapacityReqRouteJob(_reqRouteJob);
        }

        // create capacity slots to be reserved
        reserveSlotData = GanttData_WrkCtr::createJobCapacityReservations(_reqRouteJob.FromDate,
                                                                          _reqRouteJob.FromTime,
                                                                          _reqRouteJob.ToDate,
                                                                          _reqRouteJob.ToTime,
                                                                          _reqRouteJob.WrkCtrId);

        // reserve capacity
        if (reserveSlotData && !_onlyValidate)
        {
            this.insertReqRouteJobCapacityReservations(reserveSlotData,
                                                            int642str(_reqRouteJob.RecId),
                                                            _reqRouteJob.JobType,
                                                            _reqRouteJob.ReqPOId,
                                                            WrkCtrCapRefType::PlannedOrder,
                                                            _reqRouteJob.OprNum,
                                                            _reqRouteJob.OprPriority,
                                                            _reqRouteJob.WrkCtrId,
                                                            routeOpr.activityRequirementSet().LoadPercent,
                                                            localGanttSetup.parmReqPlanIdPlannedProd());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>markDeleteCapacityReqRouteJob</Name>
				<Source><![CDATA[
    private void markDeleteCapacityReqRouteJob(ReqRouteJob  _reqRouteJob)
    {
        // delete capacity reservations
        this.markDeleteJobCapacityReservations(int642str(_reqRouteJob.RecId), _reqRouteJob.JobType, _reqRouteJob.ReqPOId, WrkCtrCapRefType::PlannedOrder, localGanttSetup.parmReqPlanIdPlannedProd());
    }

]]></Source>
			</Method>
			<Method>
				<Name>markDeleteJobCapacityReservations</Name>
				<Source><![CDATA[
    private void markDeleteJobCapacityReservations(ProdJobId _jobId, RouteJobType _jobType,  WrkCtrRefId _refId, WrkCtrCapRefType _refType, ReqPlanId _reqPlanId, WrkCtrCapacityType _loadType = WrkCtrCapacityType::JobSched)
    {
        capacityReservationsTmpFilter.clear();
        capacityReservationsTmpFilter.JobId         = _jobId;                           
        capacityReservationsTmpFilter.JobType       = _jobType;
        capacityReservationsTmpFilter.RefId         = _refId;                          
        capacityReservationsTmpFilter.RefType       =  _refType;                        
        capacityReservationsTmpFilter.PlanVersion   = this.determineReqPlanVersion(_reqPlanId, _refType);
        capacityReservationsTmpFilter.LoadType      = _loadType;
        
        rilCapacityReservations.add(capacityReservationsTmpFilter);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertReqRouteJobCapacityReservations</Name>
				<Source><![CDATA[
    private void insertReqRouteJobCapacityReservations(WrkCtrSlotData           _reserveSlotData,
                                                       ProdJobId                _jobId,
                                                       RouteJobType             _jobType,
                                                       WrkCtrRefId              _refId,
                                                       WrkCtrCapRefType         _refType,
                                                       OprNum                   _oprNum,
                                                       RouteOprPriority         _oprPriority,
                                                       WrkCtrId                 _wrkCtrId,
                                                       WrkCtrLoadPct            _wrkCtrLoadPct,
                                                       ReqPlanId                _reqPlanId,
                                                       ProdJobLocked            _locked     = NoYes::No,
                                                       WrkCtrCapacityType       _loadType   = WrkCtrCapacityType::JobSched)
    {
        WrkCtrCapRes        wrkCtrCapRes;
        WrkCtrTable         wrkCtrTable = WrkCtrTable::find(_wrkCtrId);
        WrkCtrLoadPct       wrkCtrLoadPct;

        if (_reserveSlotData == null)
        {
            throw error(strfmt("@SYS54195", funcname()));
        }

        if (_reserveSlotData.first())
        {
            do
            {
                wrkCtrCapRes.JobId          = _jobId;
                wrkCtrCapRes.JobType        = _jobType;
                wrkCtrCapRes.RefId          = _refId;
                wrkCtrCapRes.RefType        = _refType;
                wrkCtrCapRes.OprNum         = _oprNum;
                wrkCtrCapRes.OprPriority    = _oprPriority;
                wrkCtrCapRes.WrkCtrId       = _wrkCtrId;
                wrkCtrCapRes.WrkCtrLoadPct  = _wrkCtrLoadPct;
                wrkCtrCapRes.PlanVersion    = reqPlanVersionRefRecId;
                wrkCtrCapRes.Locked         = _locked;
                wrkCtrCapRes.LoadType       = _loadType;
                wrkCtrCapRes.TransDate      = _reserveSlotData.rec_TransDate();
                wrkCtrCapRes.StartTime      = _reserveSlotData.rec_FromTime();
                wrkCtrCapRes.EndTime        = _reserveSlotData.rec_ToTime();
                wrkCtrLoadPct               = wrkCtrTable.Exclusive ? 100 : _wrkCtrLoadPct;
                wrkCtrLoadPct               = wrkCtrLoadPct ? wrkCtrLoadPct : 100;
                wrkCtrCapRes.WrkCtrSec      = _reserveSlotData.rec_Capacity() * wrkCtrLoadPct / 100;

                wrkCtrCapRes.initIntvFields();
                wrkCtrCapResInsertList.addEnd(wrkCtrCapRes);
            }
            while (_reserveSlotData.next());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleCapacityReservations</Name>
				<Source><![CDATA[
    private void handleCapacityReservations()
    {
        WrkCtrCapRes wrkCtrCapRes;
        rilCapacityReservations.insertDatabase();

        select count(RecId) from capacityReservationsTmpFilter; 
        if (capacityReservationsTmpFilter.RecId != 0)
        {
            wrkCtrCapRes.skipDataMethods(true);

            delete_from wrkCtrCapRes
            where wrkCtrCapRes.PlanVersion    == reqPlanVersionRefRecId
            exists join capacityReservationsTmpFilter
            where wrkCtrCapRes.JobId        == capacityReservationsTmpFilter.JobId          &&
                  wrkCtrCapRes.JobType      == capacityReservationsTmpFilter.JobType        &&
                  wrkCtrCapRes.RefId        == capacityReservationsTmpFilter.RefId          &&
                  wrkCtrCapRes.RefType      == capacityReservationsTmpFilter.RefType        &&
                  wrkCtrCapRes.PlanVersion  == capacityReservationsTmpFilter.PlanVersion    &&
                  wrkCtrCapRes.LoadType     == capacityReservationsTmpFilter.LoadType;

            delete_from capacityReservationsTmpFilter;
            rilCapacityReservations = new RecordInsertList(tableNum(WrkCtrCapResTmpFilter), true, true, true, true, true, capacityReservationsTmpFilter);
        }

        if (wrkCtrCapResInsertList.elements() > 0)
        {
            ListEnumerator listIterator = wrkCtrCapResInsertList.getEnumerator();
            while (listIterator && listIterator.moveNext())
            {
                wrkCtrCapRes = listIterator.current();
                wrkCtrCapRes.doInsert();
            }
            wrkCtrCapResInsertList = new List(Types::Record);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineReqPlanVersion</Name>
				<Source><![CDATA[
    private ReqPlanVersionRefRecId determineReqPlanVersion(ReqPlanId _reqPlanId, WrkCtrCapRefType _refType)
    {
        return _refType == WrkCtrCapRefType::PlannedOrder ? reqPlanVersionRefRecId : 0;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>