<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>MCRSalesOrderTotals</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///     The <c>MCRSalesOrderTotals</c> class uses a combination of values that come from the sales totals class
///     along with the totals stored in customer invoice journal to come up with the product
///     total, misc charge totals, tax totals, total discount totals, and order total for a sales
///     order at the time of calling this class.
/// </summary>
/// <remarks>
///     Accessors provide three types of figures
///     -Remaining - what is left to be invoiced.
///     -Invoiced  - what has been invoiced.
///     -Total     - total amount (typically remaining + invoiced).
/// </remarks>
class MCRSalesOrderTotals
{
    // Information about sales order
    boolean anySalesLinesNegative;
    private SalesTotals salesTotals;

    // Continuity
    AmountCur continuity;
    AmountCur continuityBillUpFront;
    AmountCur continuityExclTax;
    AmountCur continuityTax;
    AmountCur continuityPayNow;
    AmountCur continuityPayNowTax;
    AmountCur continuityPayLater;
    AmountCur continuityPayLaterTax;

    // Invoiced
    AmountCur invoicedDisc;
    AmountCur invoicedMarkup;
    AmountCur invoicedOrder;
    AmountCur invoicedProduct;
    AmountCur invoicedTax;
    AmountCur invoicedMarkupCoupon;
    AmountCur invoicedInstallMarkup;
    AmountCur invoicedInstallTax;
    AmountCur invoicedInstallProduct;
    AmountCur invoicedInstallDisc;

    // Remaining
    AmountCur remainingCashDisc;
    AmountCur remainingDisc;
    AmountCur remainingMarkup;
    AmountCur remainingOrder;
    AmountCur remainingProduct;
    AmountCur remainingProductAbsoluteBalance;
    AmountCur remainingReturnDisc;
    AmountCur remainingReturnMarkup;
    AmountCur remainingReturnOrder;
    AmountCur remainingReturnProduct;
    AmountCur remainingReturnTax;
    AmountCur remainingTax;
    AmountCur remainingMarkupCoupon;
    AmountCur remainingInstallmentOrder;
    AmountCur remainingInstallmentMarkUpLine;
    AmountCur remainingInstallmentTax;
    AmountCur remainingInstallMarkUpCoupon;
    AmountCur remainingInstallmentMarkUpTotal;
    AmountCur remainingInstallmentDisc;
    // Note that if container gets larger than 48 will need to split into subcontainers
    // Note that if any changes made to macro then need to change version number
    // Please keep variables in alphabetical order (easier to check)
    #define.CurrentVersion(2)
    #localmacro.CurrentList0
        anySalesLinesNegative,
        continuity,
        continuityBillUpFront,
        continuityExclTax,
        continuityPayNow,
        continuityPayNowTax,
        continuityPayLater,
        continuityPayLaterTax,
        continuityTax,
        invoicedDisc,
        invoicedMarkup,
        invoicedOrder,
        invoicedProduct,
        invoicedTax,
        remainingCashDisc,
        remainingDisc,
        remainingMarkup,
        remainingOrder,
        remainingProduct,
        remainingProductAbsoluteBalance,
        remainingReturnDisc,
        remainingReturnMarkup,
        remainingReturnOrder,
        remainingReturnProduct,
        remainingReturnTax,
        remainingTax,
        remainingMarkupCoupon,
        invoicedMarkupCoupon
    #endmacro

    #localmacro.CurrentList1
        remainingInstallmentOrder,
        remainingInstallmentMarkUpLine,
        remainingInstallmentTax,
        remainingInstallMarkUpCoupon,
        remainingInstallmentMarkUpTotal,
        remainingInstallmentDisc,
        invoicedInstallMarkup,
        invoicedInstallTax,
        invoicedInstallProduct,
        invoicedInstallDisc
    #endmacro
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>allocateInvoicedMarkupTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Adds certain types of charges to the appropriate type total.
    /// </summary>
    /// <param name="_markupTrans">
    ///     The markup transaction to be allocated.
    /// </param>
    /// <param name="_currencyCode">
    ///     The currency in which to allocated the markup transaction.
    /// </param>
    /// <param name="_isReturn">
    ///     The flag marking if the markup transaction belongs to a return order; optional.
    /// </param>
    /// <remarks>
    ///     Current types include coupons.
    /// </remarks>
    private void allocateInvoicedMarkupTrans(
        MarkupTrans     _markupTrans,
        CurrencyCode    _currencyCode,
        NoYes           _isReturn = NoYes::No)
    {
        AmountCur       convertedAmount;
        MarkupAmount    markupAmt;
        MarkupTable     markupTable;

        convertedAmount = CurrencyExchangeHelper::curAmount2CurAmount(_markupTrans.CalculatedAmount, _markupTrans.CurrencyCode, _currencyCode);

        markupTable = _markupTrans.markupTable();

        // Only markups of type custVend are included in trade totals calculation.
        if (markupTable.CustType == MarkupType::CustVend)
        {
            markupAmt += convertedAmount;
        }
        if (markupTable.VendType == MarkupType::CustVend)
        {
            markupAmt -= convertedAmount;
        }

        if (_markupTrans.MCRCouponMarkup)
        {
            // reverse the sign to deduct from Misc charge display on sales order total form
            invoicedMarkupCoupon += markupAmt * -1;
        }
        if (_markupTrans.MCRInstallmentEligible &&
           _isReturn == NoYes::No)
        {
            invoicedInstallMarkup += markupAmt;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcContinuity</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates continuity values.
    /// </summary>
    /// <param name="_salesTable">
    ///     The sales table whose continuity records are to be calculated.
    /// </param>
    /// <param name="_recordSortedListLine">
    ///     A record sorted list containing all of the continuity lines for the sales order.
    /// </param>
    private void calcContinuity(
        SalesTable          _salesTable,
        RecordSortedList    _recordSortedListLine)
    {
        MCRInventTable  mcrInventTable;
        SalesLine       salesLine;
        boolean         loop;
        AmountCur       localTax;
        MCRSalesTable   mcrSalesTable = _salesTable.mcrSalesTable();

        if (mcrSalesTable.ContinuityOrder || mcrSalesTable.Continuitychild)
        {
            loop = _recordSortedListLine.first(salesLine);
            while (loop)
            {
                continuity        += salesLine.LineAmount;
                continuityExclTax += salesLine.lineAmountExclTax(DateTimeUtil::date(_salesTable.CreatedDateTime));
                // Retrieve the item record as the schedule id is required
                mcrInventTable = MCRInventTable::findByItemId(salesLine.ItemId);
                if (InventTable::MCRIsItemContinuity(salesLine.ItemId))
                {
                    localTax = SalesLine::MCRCalcContinuityLineTax(salesLine);
                    continuityTax += localTax;
                    // If bill up front, then this amount needs to be paid now, add this to the
                    // continuityPayNow bucket
                    if (MCRContinuityScheduleHeader::IsBillUPFrontWithNoPaymSched(mcrInventTable.ContinuityScheduleID))
                    {
                        continuityPayNow    += salesLine.LineAmount;
                        continuityPayNowTax += localTax;
                    }
                    else
                    {
                        continuityPayLater      += salesLine.LineAmount;
                        continuityPayLaterTax   += localTax;
                    }
                    if (MCRContinuityScheduleHeader::IsBillUPFrontWithPaymSched(mcrInventTable.ContinuityScheduleID))
                    {
                        continuityBillUpFront += salesLine.LineAmount;
                    }
                }
                loop = _recordSortedListLine.next(salesLine);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcInvoiced</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates all invoiced totals.
    /// </summary>
    /// <param name="_salesTable">
    ///     The sales table whose invoice is to be calculated.
    /// </param>
    /// <remarks>
    ///     For handling summary invoices, suppose CustInvoiceSalesLink has 3 records
    ///     - Invoice A    sales ID     1      original sales ID     1
    ///     - Invoice A    sales ID     1      original sales ID     2
    ///     - Invoice B    sales ID     3      original sales ID     3
    ///     If sales ID is 1 or 2 then this object is totals for an order
    ///     that was part of a summary invoice (invoice A).  If sales ID is 3 then
    ///     not part of a summary invoice.
    /// </remarks>
    private void calcInvoiced(SalesTable _salesTable)
    {
        CustInvoiceSalesLink custInvoiceSalesLink;

        select firstonly RecId from custInvoiceSalesLink
            where (custInvoiceSalesLink.OrigSalesId == _salesTable.SalesId
                   && custInvoiceSalesLink.SalesId  != _salesTable.SalesId);

        if (!custInvoiceSalesLink.RecId)
        {
            select firstonly RecId from custInvoiceSalesLink
                where (custInvoiceSalesLink.OrigSalesId != _salesTable.SalesId
                       && custInvoiceSalesLink.SalesId  == _salesTable.SalesId);
        }

        if (custInvoiceSalesLink.RecId)
        {
            this.calcInvoicedExistMultiple(_salesTable);
        }
        else
        {
            this.calcInvoicedNoMultiple(_salesTable);
        }

        if (MCRInstallmentPlanSalesTable::existSalesId(_salesTable.SalesId))
        {
            this.calcInvoicedInstallment(_salesTable);
        }

        // <GEERU>
        if (RetailParameters::find().ProcessGiftCardsAsPrepayments_RU)
        {
            this.addInvoicedGiftCardAmount_RU(_salesTable.SalesId);
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcInvoicedExistMultiple</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates all invoiced totals knowing this order has been part of at least one
    ///     summary invoice.
    /// </summary>
    /// <param name="_salesTable">
    ///     The sales table whose invoice is to be calculated.
    /// </param>
    public void calcInvoicedExistMultiple(SalesTable _salesTable)
    {
        this.calcInvoicedExistMultipleOptimized(_salesTable);
        return;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcInvoicedExistMultipleOptimized</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates all invoiced totals knowing this order has been part of at least one
    ///     summary invoice.
    /// </summary>
    /// <param name="_salesTable">
    ///     The sales table whose invoice is to be calculated.
    /// </param>
    private void calcInvoicedExistMultipleOptimized(SalesTable _salesTable)
    {
        CustInvoiceJour                 custInvoiceJour;
        CustInvoiceTrans                custInvoiceTrans;
        CustInvoiceSalesLink            custInvoiceSalesLink;
        CustInvoiceSalesLink            custInvoiceSalesLink2;
        MarkupTrans                     markupTrans;
        MCRSalesMultipleInvoiceTotals   mcrSalesMultipleInvoiceTotals;
        RecordSortedList                orsListMarkup;
        boolean                         loop;
        RecId                           currentCustInvoiceJourRecId;

        // There is at least one summary invoice so need to process each invoice separately.
        // Select all non-summmary invoices.  If no other record exists in CustInvoiceSalesLink
        // with a different origSalesId then there is only one sales order on the invoice and
        // therefore it is a non-summary invoice.
        select sum(EndDisc), sum(InvoiceAmount), sum(SalesBalance), sum(SumMarkup), sum(SumTax) from custInvoiceJour
            where custInvoiceJour.RefNum == RefNum::SalesOrder
                && custInvoiceJour.SalesId == _salesTable.SalesId
            notexists join custInvoiceSalesLink
                where custInvoiceJour.SalesId          == custInvoiceSalesLink.SalesId
                   && custInvoiceJour.InvoiceDate      == custInvoiceSalesLink.InvoiceDate
                   && custInvoiceJour.InvoiceId        == custInvoiceSalesLink.InvoiceId
                   && custInvoiceSalesLink.OrigSalesId != _salesTable.SalesId;

        // Add invoice totals
        invoicedDisc    += custInvoiceJour.EndDisc;
        invoicedOrder   += custInvoiceJour.InvoiceAmount;
        invoicedProduct += custInvoiceJour.SalesBalance;
        invoicedMarkup  += custInvoiceJour.SumMarkup;
        invoicedTax     += custInvoiceJour.SumTax;

        // Allocate misc charges attached to invoice header
        while select markupTrans
            exists join custInvoiceJour
                where custInvoiceJour.RefNum == RefNum::SalesOrder
                    && custInvoiceJour.SalesId == _salesTable.SalesId
                    && markupTrans.TransRecId   == custInvoiceJour.RecId
                    && markupTrans.TransTableId == custInvoiceJour.TableId
            notexists join custInvoiceSalesLink
                where custInvoiceJour.SalesId          == custInvoiceSalesLink.SalesId
                    && custInvoiceJour.InvoiceDate      == custInvoiceSalesLink.InvoiceDate
                    && custInvoiceJour.InvoiceId        == custInvoiceSalesLink.InvoiceId
                    && custInvoiceSalesLink.OrigSalesId != _salesTable.SalesId
        {
            this.allocateInvoicedMarkupTrans(markupTrans, _salesTable.CurrencyCode);
        }

        // Allocate misc charges attached to invoice lines
        while select markupTrans
            exists join custInvoiceTrans
                where markupTrans.TransRecId       == custInvoiceTrans.RecId
                    && markupTrans.TransTableId     == custInvoiceTrans.TableId
                exists join custInvoiceJour
                    where custInvoiceJour.RefNum == RefNum::SalesOrder
                        && custInvoiceJour.SalesId == _salesTable.SalesId
                        && custInvoiceTrans.SalesId     == custInvoiceJour.SalesId
                        && custInvoiceTrans.InvoiceId   == custInvoiceJour.InvoiceId
                        && custInvoiceTrans.InvoiceDate == custInvoiceJour.InvoiceDate
                notexists join custInvoiceSalesLink
                    where custInvoiceJour.SalesId          == custInvoiceSalesLink.SalesId
                        && custInvoiceJour.InvoiceDate      == custInvoiceSalesLink.InvoiceDate
                        && custInvoiceJour.InvoiceId        == custInvoiceSalesLink.InvoiceId
                        && custInvoiceSalesLink.OrigSalesId != _salesTable.SalesId
        {
            this.allocateInvoicedMarkupTrans(markupTrans, _salesTable.CurrencyCode);
        }

        // Select summary invoices and extract this order's contribution to summary invoices
        while select custInvoiceSalesLink
            where custInvoiceSalesLink.OrigSalesId == _salesTable.SalesId
            join custInvoiceJour
                where custInvoiceJour.SalesId          == custInvoiceSalesLink.SalesId
                   && custInvoiceJour.InvoiceDate      == custInvoiceSalesLink.InvoiceDate
                   && custInvoiceJour.InvoiceId        == custInvoiceSalesLink.InvoiceId
                   && custInvoiceJour.RefNum           == RefNum::SalesOrder
              exists join custInvoiceSalesLink2
                             where custInvoiceSalesLink2.InvoiceId   == custInvoiceJour.InvoiceId
                                && custInvoiceSalesLink2.SalesId     == custInvoiceJour.SalesId
                                && custInvoiceSalesLink2.InvoiceDate == custInvoiceJour.InvoiceDate
                                && custInvoiceSalesLink2.OrigSalesId != _salesTable.SalesId

        {
            // Make sure the object mcrSalesMultipleInvoiceTotals will just be constructed one time when the custInvoiceJour.Recid is equal.
            if (currentCustInvoiceJourRecId != custInvoiceJour.RecId)
            {
                currentCustInvoiceJourRecId = custInvoiceJour.RecId;

                mcrSalesMultipleInvoiceTotals = MCRSalesMultipleInvoiceTotals::construct(custInvoiceJour);
            }

            invoicedDisc    += mcrSalesMultipleInvoiceTotals.getEndDisc(_salesTable.SalesId);
            invoicedOrder   += mcrSalesMultipleInvoiceTotals.getTotal(_salesTable.SalesId);
            invoicedProduct += mcrSalesMultipleInvoiceTotals.getBalance(_salesTable.SalesId);
            invoicedMarkup  += mcrSalesMultipleInvoiceTotals.getMarkup(_salesTable.SalesId);
            invoicedTax     += mcrSalesMultipleInvoiceTotals.getTax(_salesTable.SalesId);

            orsListMarkup = mcrSalesMultipleInvoiceTotals.getMarkupList(custInvoiceSalesLink.OrigSalesId);
            loop = orsListMarkup.first(markupTrans);

            while (loop)
            {
                this.allocateInvoicedMarkupTrans(markupTrans, _salesTable.CurrencyCode);
                loop = orsListMarkup.next(markupTrans);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcInvoicedInstallment</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the totals for invoiced installment eligible line.
    /// </summary>
    /// <param name="_salesTable">
    ///     The sales table from which to retrieve invoiced installment eligible line.
    /// </param>
    private void calcInvoicedInstallment(SalesTable _salesTable)
    {
        CustInvoiceJour         custInvoiceJour;
        CustInvoiceSalesLink    custInvoiceSalesLink;
        CustInvoiceTrans        custInvoiceTrans;
        SalesLine               salesLine;
        MCRSalesLine            mcrSalesLine;
        select sum(SumLineDiscMST), sum(LineAmountMST), sum(TaxAmountMST) from custInvoiceTrans
            exists join salesLine
            where custInvoiceTrans.InventTransId == salesLine.InventTransId
                && salesLine.SalesId == _salesTable.SalesId
            exists join mcrSalesLine
            where mcrSalesLine.SalesLine == salesLine.RecId
                  && mcrSalesLine.InstallmentEligible;

        // Sum invoice totals
        invoicedInstallDisc     = custInvoiceTrans.SumLineDiscMST;
        invoicedInstallProduct  = custInvoiceTrans.LineAmountMST;
        invoicedInstallTax      = custInvoiceTrans.TaxAmountMST;

        select sum(SalesBalanceMST), sum(EndDiscMST), sum(SumTaxMST) from custInvoiceJour
            where custInvoiceJour.RefNum == RefNum::SalesOrder
            exists join custInvoiceSalesLink
            where custInvoiceJour.SalesId          == custInvoiceSalesLink.SalesId
                && custInvoiceJour.InvoiceDate      == custInvoiceSalesLink.InvoiceDate
                && custInvoiceJour.InvoiceId        == custInvoiceSalesLink.InvoiceId
                && custInvoiceSalesLink.OrigSalesId == _salesTable.SalesId
            exists join salesLine
            where salesLine.SalesId == custInvoiceJour.SalesId
                && salesLine.SalesId == _salesTable.SalesId
            exists join mcrSalesLine
            where mcrSalesLine.SalesLine == salesLine.RecId
                && mcrSalesLine.InstallmentEligible;

        if (custInvoiceJour.SumTaxMST)
        {
            invoicedInstallTax = custInvoiceJour.SumTaxMST;
        }

        if (custInvoiceJour.SalesBalanceMST)
        {
            invoicedInstallDisc += invoicedInstallProduct * (custInvoiceJour.EndDiscMST/custInvoiceJour.SalesBalanceMST);
        }

        invoicedInstallDisc = CurrencyExchangeHelper::amount(invoicedInstallDisc, _salesTable.CurrencyCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcInvoicedNoMultiple</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates all invoiced totals knowing this order has not been part of andy summary invoices.
    /// </summary>
    /// <param name="_salesTable">
    ///     The sales table whose invoice is to be calculated.
    /// </param>
    /// <remarks>
    ///     Sum fields for performance.  Selections of MarkupTrans records do not
    ///     need to include CustInvoiceSalesLink since no summary invoices.  Matching
    ///     against SalesId will not find any other CustInvoiceJour or CustInvoiceTrans
    ///     records.
    /// </remarks>
    public void calcInvoicedNoMultiple(SalesTable _salesTable)
    {
        CustInvoiceJour     custInvoiceJour;
        CustInvoiceTrans    custInvoiceTrans;
        MarkupTrans         markupTrans;
        // There are no multiple/summary invoices so sum fields for performance
        select sum(EndDisc),
               sum(InvoiceAmount),
               sum(SalesBalance),
               sum(SumMarkup),
               sum(SumTax) from custInvoiceJour
            where custInvoiceJour.RefNum  == RefNum::SalesOrder
               && custInvoiceJour.SalesId == _salesTable.SalesId;
        invoicedDisc    = custInvoiceJour.EndDisc;
        invoicedOrder   = custInvoiceJour.InvoiceAmount;
        invoicedProduct = custInvoiceJour.SalesBalance;
        invoicedMarkup  = custInvoiceJour.SumMarkup;
        invoicedTax     = custInvoiceJour.SumTax;

        // Allocate misc charges attached to invoice header
        while select markupTrans
            join TableId from custInvoiceJour
                where markupTrans.TransRecId   == custInvoiceJour.RecId
                   && markupTrans.TransTableId == custInvoiceJour.TableId
                   && custInvoiceJour.RefNum   == RefNum::SalesOrder
                   && custInvoiceJour.SalesId  == _salesTable.SalesId
        {
            this.allocateInvoicedMarkupTrans(markupTrans, _salesTable.CurrencyCode);
        }

        // Allocate misc charges attached to invoice lines
        while select markupTrans
            join TableId from custInvoiceTrans
                where markupTrans.TransRecId    == custInvoiceTrans.RecId
                   && markupTrans.TransTableId  == custInvoiceTrans.TableId
                   && custInvoiceTrans.SalesId  == _salesTable.SalesId
        {
            this.allocateInvoicedMarkupTrans(markupTrans, _salesTable.CurrencyCode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcRemaining</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the remaining totals for the current sales order.
    /// </summary>
    /// <param name="_salesTotals">
    ///     The sales totals record for which to calculate the remaining totals.
    /// </param>
    /// <param name="_salesId">
    ///     Current sales order identifier.
    /// </param>
    private void calcRemaining(SalesTotals _salesTotals, SalesId _salesId)
    {
        container displayFields;

        displayFields       = _salesTotals.displayFields();
        remainingDisc       = conPeek(displayFields, TradeTotals::posEndDisc());
        remainingDisc       = abs(remainingDisc);
        remainingOrder      = conPeek(displayFields, TradeTotals::posTotalAmount());
        remainingProduct    = conPeek(displayFields, TradeTotals::posBalance());
        remainingMarkup     = conPeek(displayFields, TradeTotals::posMarkup());
        remainingTax        = conPeek(displayFields, TradeTotals::posTaxTotal());
        remainingCashDisc   = conPeek(displayFields, TradeTotals::posCashDisc());

        if (CustParameters::find().TaxAdjustmentInReturn)
        {
            SalesTable salesTable = SalesTable::find(_salesId);
            if (salesTable.SalesType == SalesType::ReturnItem)
            {
                remainingTax = MCRSalesOrderTaxTotals::getEstimatedTaxAmountForReturnOrder(salesTable);
            }
        }

        // <GEERU>
        if (RetailParameters::find().ProcessGiftCardsAsPrepayments_RU)
        {
            this.addRemainingGiftCardAmount_RU(_salesId);
        }
        // </GEERU>

        // Get markup type subtotals
        remainingMarkupCoupon = conPeek(displayFields, TradeTotals::MCRPostotalCoupon());

        // Get absolute balance (needed for pro-rating misc charges)
        remainingProductAbsoluteBalance = _salesTotals.mcrTotalBalanceAbsoluteValue();

        // Get return totals
        remainingReturnDisc         = conPeek(displayFields, TradeTotals::MCRPosReturnDiscountTotal());
        remainingReturnMarkup       = conPeek(displayFields, TradeTotals::MCRPosReturnMarkup());
        remainingReturnOrder        = conPeek(displayFields, TradeTotals::MCRPosReturnTotalAmount());
        remainingReturnProduct      = conPeek(displayFields, TradeTotals::MCRPosReturnBalanceAmount());
        remainingReturnTax          = conPeek(displayFields, TradeTotals::MCRPosReturnTaxTotal());

        // Get installment eligible totals
        remainingInstallmentOrder = conPeek(displayFields, TradeTotals::MCRPosReturnInstallmentTotal());
        remainingInstallmentMarkUpLine =conPeek(displayFields, TradeTotals::MCRPosReturnInstallmentMarkUpLine());
        remainingInstallmentTax = conPeek(displayFields, TradeTotals::MCRPosReturnInstallmentTax());
        remainingInstallmentMarkUpTotal = conPeek(displayFields, TradeTotals::MCRPosReturnInstallmentMarkUpTotal());
        remainingInstallmentDisc = conPeek(displayFields, TradeTotals::MCRPosEndInstallmentDisc());
        remainingInstallmentDisc = abs(remainingInstallmentDisc);
        // set coupon amount
        remainingInstallMarkUpCoupon = conPeek(displayFields, TradeTotals::MCRPosReturnInstallmentMarkUpCoupon());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContinuity</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the continuity total that
    ///     have a continuity item attached.
    /// </summary>
    /// <returns>
    ///     The total net amount of all sales lines.
    /// </returns>
    public AmountCur getContinuity()
    {
        return continuity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContinuityBillUpFront</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the totals of the lines that have a continuity item, that is a
    ///     bill up front with no payment schedule.
    /// </summary>
    /// <returns>
    ///     The totals of the lines that have a continuity item.
    /// </returns>
    public AmountCur getContinuityBillUpFront()
    {
        return continuityBillUpFront;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContinuityExclTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the amount of the continuity order before tax.
    /// </summary>
    /// <returns>
    /// The amount of the continuity order before tax.
    /// </returns>
    public AmountCur getContinuityExclTax()
    {
        return continuityExclTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContinuityPayLater</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the totals of continuity lines that will be paid later due
    ///     to either being a bill up front with payment schedule or a non bill up
    ///     front.
    /// </summary>
    /// <returns>
    ///     The totals of continuity lines that will be paid later.
    /// </returns>
    public AmountCur getContinuityPayLater()
    {
        return continuityPayLater;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContinuityPayLaterTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns accumulated taxes for lines, containing continuity item that may have to be paid later.
    /// </summary>
    /// <returns>
    ///     A total of taxes for lines, containing continuity item that may have to be paid later.
    /// </returns>
    public AmountCur getContinuityPayLaterTax()
    {
        return continuityPayLaterTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContinuityPayNow</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the total of all continuity lines that are to be paid at
    ///     the time of sales order payment.
    /// </summary>
    /// <returns>
    ///     The total of all continuity lines that are to be paid at
    ///     the time of sales order payment.
    /// </returns>
    public AmountCur getContinuityPayNow()
    {
        return continuityPayNow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContinuityPayNowTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns an accumulated total of taxes for bill up front continuity lines.
    /// </summary>
    /// <returns>
    ///     An accumulated total of taxes for bill up front continuity lines.
    /// </returns>
    public AmountCur getContinuityPayNowTax()
    {
        return continuityPayNowTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContinuityTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates taxes for lines that are continuity parents or children.
    /// </summary>
    /// <returns>
    ///     The taxes for lines that are continuity parents or children.
    /// </returns>
    public AmountCur getContinuityTax()
    {
        return continuityTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInstallmentEligibleRemaining</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the total remaining amount that can be paid on installment.
    /// </summary>
    /// <returns>
    ///     The total remaining amount that can be paid on installment.
    /// </returns>
    public AmountCur getInstallmentEligibleRemaining()
    {
        AmountCur retAmount = 0;
        AmountCur remainingInstallOrder;
        AmountCur remainingInstallTax;
        AmountCur remainingMarkUpLine;
        AmountCur remainingInstallMarkUp;
        AmountCur remainingInstallDisc;
        AmountCur remainingInstalMarkupCoupon;

        remainingInstallOrder = this.getRemainingInstallmentOrder(); // Product amount (MCRInstallmentPlanSalesTable.TotalProductAmount)
        remainingInstallTax = this.getRemainingInstallmentTax(); // Tax amount
        remainingMarkUpLine = this.getRemainingInstallmentMarkUpLine();
        remainingInstallMarkUp = this.getRemainingInstallmentMarkUpTotal();
        remainingInstallDisc = this.getRemainingInstallmentEndDisc(); // End discount amount
        remainingInstalMarkupCoupon = this.getRemainingInstallMarkUpCoupon();

        // don't back out coupon amt cause its already taken
        // into account in the remainingInstallMarkUp variable.
        // If there are no eligible lines then don't return any other
        // amounts that would otherwise normally be eligible
        if (remainingInstallOrder)
        {
            retAmount = remainingInstallOrder
                        + remainingInstallTax
                        + remainingInstallMarkUp
                        + remainingMarkUpLine
                        - remainingInstallDisc;
        }

        return retAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInstallmentEligibleTotal</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the total amount that can be paid on installment.
    /// </summary>
    /// <returns>
    ///     The total amount that can be paid on installment.
    /// </returns>
    public AmountCur getInstallmentEligibleTotal()
    {
        AmountCur retAmount = 0;
        AmountCur totalInstallOrder;
        AmountCur totalInstallTax;
        AmountCur totalInstallMarkUp;
        AmountCur totalInstallDisc;
        AmountCur totalCashDisc;

        // Use the total (remaining + invoice) so the value is accurate.
        totalInstallOrder   = this.getTotalInstallProduct(); // Product amount (MCRInstallmentPlanSalesTable.TotalProductAmount)
        totalInstallTax     = this.getTotalInstallTax(); // Tax amount
        totalInstallMarkUp  = this.getTotalInstallMarkup();
        totalInstallDisc    = this.getTotalInstallDisc(); // End discount amount
        totalCashDisc       = this.getRemainingCashDiscount(); // Cash discount amount

        // don't back out coupon amt cause its already taken
        // into account in the remainingInstallMarkUp variable.
        // If there are no eligible lines then don't return any other
        // amounts that would otherwise normally be eligible
        if (totalInstallOrder)
        {
            retAmount = totalInstallOrder
                        + totalInstallTax
                        + totalInstallMarkUp
                        - totalInstallDisc
                        - totalCashDisc;
        }

        return retAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInstallmentInvoiceTotal</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the total installment invoiced.
    /// </summary>
    /// <returns>
    ///     The total installment invoiced.
    /// </returns>
    public AmountCur getInstallmentInvoiceTotal()
    {
        return(invoicedInstallProduct
               + invoicedInstallTax
               + invoicedInstallMarkup
               - invoicedInstallDisc);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoicedDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the discount amount after invoicing.
    /// </summary>
    /// <returns>
    /// The discount amount after invoicing.
    /// </returns>
    public AmountCur getInvoicedDisc()
    {
        return invoicedDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoicedInstallDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the discount amount on an installment payment after invoicing.
    /// </summary>
    /// <returns>
    /// The discount amount on an installment payment after invoicing.
    /// </returns>
    public AmountCur  getInvoicedInstallDisc()
    {
        return invoicedInstallDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoicedInstallMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the markup amount on an installment payment after invcoicing.
    /// </summary>
    /// <returns>
    /// The markup amount on an installment payment after invoicing.
    /// </returns>
    public AmountCur getInvoicedInstallMarkup()
    {
        return invoicedInstallMarkup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoicedInstallProduct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the amount invoiced for an installment payment for a product.
    /// </summary>
    /// <returns>
    /// The amount invoiced for an installment payment for a product.
    /// </returns>
    public AmountCur  getInvoicedInstallProduct()
    {
        return invoicedInstallProduct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoicedInstallTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the tax amount of an installment payment after invoicing.
    /// </summary>
    /// <returns>
    /// The tax amount of an installment paymetent after invoicing.
    /// </returns>
    public AmountCur  getInvoicedInstallTax()
    {
        return invoicedInstallTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoicedMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns all of the invoiced misc charges.
    /// </summary>
    /// <returns>
    ///     The sum of the invoiced misc charges.
    /// </returns>
    public AmountCur getInvoicedMarkup()
    {
        return invoicedMarkup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoicedMarkupCoupon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the markup after a coupon is applied and the order is invoiced.
    /// </summary>
    /// <returns>
    /// The markup after a coupon is applied and the order is invoiced.
    /// </returns>
    public AmountCur getInvoicedMarkupCoupon()
    {
        return invoicedMarkupCoupon;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoicedOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the invoiced order amount, including
    ///     all markup, discounts and tax.
    /// </summary>
    /// <returns>
    ///     The invoiced order amount.
    /// </returns>
    public AmountCur getInvoicedOrder()
    {
        return invoicedOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoicedProduct</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the invoiced product value.
    /// </summary>
    /// <returns>
    ///     The invoiced product value.
    /// </returns>
    public AmountCur getInvoicedProduct()
    {
        return invoicedProduct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoicedTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the amount of tax on an invoiced order.
    /// </summary>
    /// <returns>
    /// The amount of tax on an invoiced order.
    /// </returns>
    public AmountCur getInvoicedTax()
    {
        return invoicedTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainingCashDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the remaining cash discount amount.
    /// </summary>
    /// <returns>
    ///     The amount to be taken as cash discount.
    /// </returns>
    public AmountCur getRemainingCashDiscount()
    {
        return remainingCashDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainingDisc</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns remaining discount amount (still to be invoiced).
    /// </summary>
    /// <returns>
    ///     The amount still to be invoiced.
    /// </returns>
    public AmountCur getRemainingDisc()
    {
        return remainingDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainingInstallMarkUpCoupon</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the coupon amounts at a line level that are installment eligible.
    /// </summary>
    /// <returns>
    ///     The coupon amounts at a line level that are installment eligible.
    /// </returns>
    public AmountCur getRemainingInstallMarkUpCoupon()
    {
        return remainingInstallMarkUpCoupon;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainingInstallmentEndDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the remaining amount on an installment order after discounts.
    /// </summary>
    /// <returns>
    /// The remaining amount on an installment order after discounts.
    /// </returns>
    public AmountCur getRemainingInstallmentEndDisc()
    {
        return remainingInstallmentDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainingInstallmentMarkUpLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the line level markups for the installment eligible lines.
    /// </summary>
    /// <returns>
    ///     The line level markups for the installment eligible lines.
    /// </returns>
    public AmountCur getRemainingInstallmentMarkUpLine()
    {
        return remainingInstallmentMarkUpLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainingInstallmentMarkUpTotal</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the total markups for the installment eligible lines.
    /// </summary>
    /// <returns>
    ///     The total markups for the installment eligible lines.
    /// </returns>
    public AmountCur getRemainingInstallmentMarkUpTotal()
    {
        return remainingInstallmentMarkUpTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainingInstallmentOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the installment portion of the order.
    /// </summary>
    /// <returns>
    ///     The installment portion of the order.
    /// </returns>
    /// <remarks>
    ///     If on a sales order there are lines that are installment eligible and non installment eligible
    ///     then the break down of the portion that is non installment and the portion of the sales order
    ///     that is installment eligible needs to be split.
    ///     Example: If the sales order is for a total of $320 (lines total), the Portion that is installment eligible
    ///     is $270, and the amount that is not is $50 , then this method should return $270.
    /// </remarks>
    public AmountCur getRemainingInstallmentOrder()
    {
        return remainingInstallmentOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainingInstallmentTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the taxes on the lines that are installment eligible.
    /// </summary>
    /// <returns>
    ///     The taxes on the lines that are installment eligible.
    /// </returns>
    public AmountCur getRemainingInstallmentTax()
    {
        return remainingInstallmentTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainingMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the remaining markup amount.
    /// </summary>
    /// <returns>
    /// The remianing markup amount.
    /// </returns>
    public AmountCur getRemainingMarkup()
    {
        return remainingMarkup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainingMarkupCoupon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the remaining markup amount after coupons have been applied.
    /// </summary>
    /// <returns>
    /// The remaining markup amount after coupons have been applied.
    /// </returns>
    public AmountCur getRemainingMarkupCoupon()
    {
        return remainingMarkupCoupon;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainingOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the remaining order amount, including all markup, discounts and tax.
    /// </summary>
    /// <returns>
    ///     The amount still to be invoiced.
    /// </returns>
    public AmountCur getRemainingOrder()
    {
        return remainingOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainingProduct</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns remaining product value, without markup, discounts or tax.
    /// </summary>
    /// <returns>
    ///     The remaining product value.
    /// </returns>
    public AmountCur getRemainingProduct()
    {
        return remainingProduct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainingProductAbsoluteBalance</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the absolute balance of remaining product.
    /// </summary>
    /// <returns>
    ///     The absolute balance of remaining product.
    /// </returns>
    public AmountCur getRemainingProductAbsoluteBalance()
    {
        return remainingProductAbsoluteBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainingReturnDisc</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the total discount amount relating to the return half of the order.
    /// </summary>
    /// <returns>
    ///     The total discount amount relating to the return half of the order.
    /// </returns>
    public real getRemainingReturnDisc()
    {
        return remainingReturnDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainingReturnMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the remaining misc charges associated with the return half of the order.
    /// </summary>
    /// <returns>
    ///     The remaining misc charges associated with the return half of the order.
    /// </returns>
    public AmountCur getRemainingReturnMarkup()
    {
        return remainingReturnMarkup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainingReturnOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the order total of the return half of the sales order.
    /// </summary>
    /// <returns>
    ///     the order total of the return half of the sales order.
    /// </returns>
    public real getRemainingReturnOrder()
    {
        return remainingReturnOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainingReturnProduct</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Get the return product total without markup, discounts or tax.
    /// </summary>
    /// <returns>
    ///     The return product total without markup, discounts or tax.
    /// </returns>
    public real getRemainingReturnProduct()
    {
        return remainingReturnProduct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainingReturnTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the remaining tax total associated with the return half of the order.
    /// </summary>
    /// <returns>
    ///     The remaining tax total associated with the return half of the order.
    /// </returns>
    public real getRemainingReturnTax()
    {
        return remainingReturnTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRemainingTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the remaining tax amount.
    /// </summary>
    /// <returns>
    ///     The tax amount still to be invoiced.
    /// </returns>
    public AmountCur getRemainingTax()
    {
        return remainingTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalContinuityOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total of a continuity order.
    /// </summary>
    /// <returns>
    /// The total of a continuity order.
    /// </returns>
    public AmountCur getTotalContinuityOrder()
    {
        return this.getInvoicedOrder()
            + (this.getRemainingOrder()
               - (this.getContinuity() + this.getContinuityTax()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalContinuityProduct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the remaining product total, less continuity totals.
    /// </summary>
    /// <returns>
    /// The remaining product total, less continuity totals.
    /// </returns>
    public AmountCur getTotalContinuityProduct()
    {
        // If Continuity sales line exists subtract the totals of those lines
        // from the remaining product total.
        return this.getContinuityPayNow() + this.getContinuityPayLater();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalContinuityTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total tax amount before continuity orders process.
    /// </summary>
    /// <returns>
    /// The total tax amount before continuity orders process.
    /// </returns>
    public AmountCur getTotalContinuityTax()
    {
        // Subtract the continuity taxes from the main tax bucket
        return this.getInvoicedTax()
            + (this.getRemainingTax() - this.getContinuityTax());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total amount of discount.
    /// </summary>
    /// <returns>
    /// The total amount of discount.
    /// </returns>
    public AmountCur getTotalDisc()
    {
        return this.getInvoicedDisc()
            + this.getRemainingDisc()
            + this.getRemainingReturnDisc()
            + this.getRemainingCashDiscount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalInstallDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total amount of discount on an installment payment.
    /// </summary>
    /// <returns>
    /// The total amount of discount on an installment payment.
    /// </returns>
    public AmountCur getTotalInstallDisc()
    {
        return invoicedInstallDisc + remainingInstallmentDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalInstallMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total markup amount on an installment payment.
    /// </summary>
    /// <returns>
    /// The total makrup amount on an installment payment.
    /// </returns>
    public AmountCur getTotalInstallMarkup()
    {
        return invoicedInstallMarkup + remainingInstallmentMarkUpLine + remainingInstallmentMarkUpTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalInstallProduct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the installment amount.
    /// </summary>
    /// <returns>
    /// The total installment amount.
    /// </returns>
    public AmountCur getTotalInstallProduct()
    {
        return invoicedInstallProduct + remainingInstallmentOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalInstallTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total amount of tax on an installment.
    /// </summary>
    /// <returns>
    /// The total amount of tax on an installment.
    /// </returns>
    public AmountCur getTotalInstallTax()
    {
        return invoicedInstallTax + remainingInstallmentTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the total miscellaneous charges for the sales order.
    /// </summary>
    /// <returns>
    ///     The total miscellaneous charges for the sales order.
    /// </returns>
    public AmountCur getTotalMarkup()
    {
        return this.getInvoicedMarkup() + this.getRemainingMarkup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalMarkupCoupon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total makrup after a coupon has been applied.
    /// </summary>
    /// <returns>
    /// The total markup after a coupon has been applied.
    /// </returns>
    public AmountCur getTotalMarkupCoupon()
    {
        return this.getInvoicedMarkupCoupon() + this.getRemainingMarkupCoupon();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the order total for the sales order, including the remaining order total
    ///     plus the invoiced total.
    /// </summary>
    /// <returns>
    ///     The sales order total.
    /// </returns>
    /// <remarks>
    ///     It is possible that the line is negative but there is no corresponding invoice - in such
    ///     a case compute the current order total without taking into consideration the invoiced total.
    /// </remarks>
    public AmountCur getTotalOrder()
    {
        AmountCur currentOrderTotal;
        AmountCur installmentMarkUp;
        installmentMarkUp = this.getRemainingInstallmentMarkUpTotal();
        if (this.getInvoicedOrder() > 0)
        {
           currentOrderTotal = this.getInvoicedOrder() + this.getRemainingOrder();
        }
        else
        {
            if (!this.parmAnySalesLinesNegative())
            {
                currentOrderTotal = this.getRemainingOrder();
            }
            else
            {
                if (this.getInvoicedOrder() < 0)
                {
                    currentOrderTotal = this.getInvoicedOrder()
                                        + this.getRemainingOrder()
                                        - this.getInvoicedDisc();
                }
                else if (this.getInvoicedOrder() == 0)
                {
                    currentOrderTotal = this.getRemainingOrder();
                }
            }
        }
        currentOrderTotal -= this.getRemainingCashDiscount();
        return currentOrderTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalProduct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total amount paid and unpaid of the product.
    /// </summary>
    /// <returns>
    /// The total amount paid and unpaid of the product.
    /// </returns>
    public AmountCur getTotalProduct()
    {
        return this.getInvoicedProduct() + this.getRemainingProduct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returs the total amount of tax paid and unpaid.
    /// </summary>
    /// <returns>
    /// The total amount of tax paid and unpaid.
    /// </returns>
    public AmountCur getTotalTax()
    {
        return this.getInvoicedTax() + this.getRemainingTax();
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes a new instance of the <c>MCRSalesOrderTotals</c> class and,
    ///     based on a passed in sales order record, calculate remaining totals, invoiced totals, and
    ///     continuity totals for order.
    /// </summary>
    /// <param name="_salesTable">
    ///     The sales order record for which totals will be calculated.
    /// </param>
    /// <param name="_calcDetails">
    ///     Indicates whether do detail calcuation when constructing the object.
    /// </param>
    /// <remarks>
    ///     If totals have already been calculated and are stored in database, create object from stored
    ///     container in database.
    /// </remarks>
    public void new(SalesTable _salesTable, boolean _calcDetails = true)
    {
        // Either totals not found or unpack failed so recalculate.
        this.parmAnySalesLinesNegative(_salesTable.mcrAnySalesLinesNegative());

        if (_calcDetails)
        {
            salesTotals = SalesTotals::construct(_salesTable, SalesUpdate::All);
            salesTotals.calc();

            this.calculateDetails(_salesTable, salesTotals);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    static MCRSalesOrderTotals construct(SalesTable _salesTable, SalesTotals _salesTotals)
    {
        MCRSalesOrderTotals mcrSalesOrderTotals = new MCRSalesOrderTotals(_salesTable, false);
        mcrSalesOrderTotals.parmAnySalesLinesNegative(_salesTable.mcrAnySalesLinesNegative());
        mcrSalesOrderTotals.calculateDetails(_salesTable, _salesTotals);

        return mcrSalesOrderTotals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateDetails</Name>
				<Source><![CDATA[
    private void calculateDetails(SalesTable _salesTable, SalesTotals _salesTotals)
    {
        this.salesTotals = _salesTotals;

        RecordSortedList recordSortedListLine = _salesTotals.recordSortedListLine();
        this.calcRemaining(_salesTotals, _salesTable.SalesId);
        this.calcInvoiced(_salesTable);
        this.calcContinuity(_salesTable, recordSortedListLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    private container pack()
    {
        return [#CurrentVersion, [#CurrentList0], [#CurrentList1]];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAnySalesLinesNegative</Name>
				<Source><![CDATA[
    private boolean parmAnySalesLinesNegative(
        boolean _anySalesLinesNegative = anySalesLinesNegative
        )
    {
        anySalesLinesNegative = _anySalesLinesNegative;
        return anySalesLinesNegative;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesTotals</Name>
				<Source><![CDATA[
    internal SalesTotals getSalesTotals()
    {
        return salesTotals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retZeroBillUpFrontWithSched</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns zero for bill up front payments that have an associated payment schedule.
    /// </summary>
    /// <returns>
    /// A real value of zero.
    /// </returns>
    public real retZeroBillUpFrontWithSched()
    {
        return 0.0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    private boolean unpack(container _packedClass)
    {
        int version;
        container con0;
        container con1;
        version = conPeek(_packedClass, 1);
        // Only unpack if versions match
        if (version == #CurrentVersion)
        {
            [version, con0, con1] = _packedClass;
            [#CurrentList0] = con0;
            [#CurrentList1] = con1;

            return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addInvoicedGiftCardAmount_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds total invoiced gift card issue amount to the invoice order amount.
    /// </summary>
    /// <param name="_salesId">
    /// Sales order identifier.
    /// </param>
    private void addInvoicedGiftCardAmount_RU(SalesId _salesId)
    {
        CustInvoiceTrans_RU        custInvoiceTrans_RU;
        CustInvoiceTrans           custInvoiceTrans;
        CustInvoiceSalesLink       custInvoiceSalesLink;

        select sum(MCRGiftCardAmount) from custInvoiceTrans_RU
            exists join custInvoiceTrans
                where custInvoiceTrans.RecId       == custInvoiceTrans_RU.CustInvoiceTrans &&
                      custInvoiceTrans.OrigSalesId == _salesId
                exists join custInvoiceSalesLink
                    where custInvoiceSalesLink.OrigSalesId == _salesId                     &&
                          custInvoiceSalesLink.SalesId     == custInvoiceTrans.SalesId     &&
                          custInvoiceSalesLink.InvoiceId   == custInvoiceTrans.InvoiceId   &&
                          custInvoiceSalesLink.InvoiceDate == custInvoiceTrans.InvoiceDate;

        invoicedOrder += custInvoiceTrans_RU.MCRGiftCardAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRemainingGiftCardAmount_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds not posted gift card issue amount to the remaining order amount.
    /// </summary>
    /// <param name="_salesId">
    /// Sales order identifier.
    /// </param>
    private void addRemainingGiftCardAmount_RU(SalesId _salesId)
    {
        MCRSalesLine     mcrSalesLine;
        SalesLine        salesLine;
        ItemId           giftCardItemId = RetailParameters::find().GiftcardItem;
        CustInvoiceTrans custInvoiceTrans;

        select sum (GiftCardAmount_RU) from mcrSalesLine
            join TableId from salesLine
                where salesLine.SalesId == _salesId       &&
                      salesLine.ItemId  == giftCardItemId &&
                      salesLine.RecId   == mcrSalesLine.SalesLine
                notexists join custInvoiceTrans
                    where custInvoiceTrans.InventTransId == salesLine.InventTransId;

        remainingOrder += mcrSalesLine.GiftCardAmount_RU;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>