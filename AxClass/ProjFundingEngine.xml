<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjFundingEngine</Name>
	<SourceCode>
		<Declaration><![CDATA[
class ProjFundingEngine
{
    ProjTrans               projTrans;

    ProjFundingSourceRefId singleFundingSourceRefId;

    AmountCur               totalCost;
    AmountCur               totalRevenue;

    boolean                 allocateSuccessful;
    boolean                 useFundingLimits;
    boolean                 singleFundingSourceRequired;
    boolean                 posting;
    boolean                 invoiceable;
    boolean                 allocateCalled;

    List                    fundingSourceAllocation;
    List                    costDistributionsList;
    List                    saleDistributionsList;
    List                    costList;
    List                    inputCostList;
    List                    inputRevenueList;
    List                    revenueList;
    List                    revenueInTrxCurrencyList;

    Map                     costDistributions;
    Map                     saleDistributions;
    Map                     limitRulesUpdated;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addCostDistribution</Name>
				<Source><![CDATA[
    private void addCostDistribution(ProjFundingSourceRefId _fundingSourceRefId, AmountCur  _amount)
    {
        AmountCur   amountToMap;

        amountToMap = _amount;
        if (costDistributions.exists(_fundingSourceRefId))
        {
            //Update value to map
            amountToMap = costDistributions.lookup(_fundingSourceRefId) + amountToMap;
            costDistributions.remove(_fundingSourceRefId);
        }

        costDistributions.insert(_fundingSourceRefId, amountToMap);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSalesDistribution</Name>
				<Source><![CDATA[
    private void addSalesDistribution(ProjFundingSourceRefId _fundingSourceRefId, AmountCur  _amount)
    {
        AmountCur  amountToMap;

        amountToMap = _amount;
        if (saleDistributions.exists(_fundingSourceRefId))
        {
            //Update value to map
            amountToMap = saleDistributions.lookup(_fundingSourceRefId) + amountToMap;
            saleDistributions.remove(_fundingSourceRefId);
        }

        saleDistributions.insert(_fundingSourceRefId, amountToMap);
    }

]]></Source>
			</Method>
			<Method>
				<Name>allocate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Process the funding rules to allocated the amount to one or more funding sources.
    /// </summary>
    /// <returns>
    ///     Returns true if the amount was distributed to funding sources, otherwise false
    /// </returns>
    public boolean allocate()
    {
        AmountCur               amountToSplit;
        AmountCur               lastLoopValue;
        AmountCur               limitingAmount;
        boolean                 splitByCost                         = false;
        boolean                 negativeSplitAmount                 = false;
        boolean                 usedOnHold                          = false;
        boolean                 trxCurrencyIsContractCurrency       = true;
        CurrencyCode            contractCurrency;
        int64                   rulesProcessed                      = 0;
        List                    splitList;
        List                    emptyAmountList;
        ListEnumerator          enumerateList;
        ProjFundingSourceRefId  fundingSourceRefId                  = 0;
        ProjFundingSourceRefId  limitingfundingSource               = 0;
        ProjFundingSourceRefId  roundingFundingSource               = 0;
        ProjInvoiceTable        projInvoiceTable;
        ProjSplitAllocation     allocation;
        ProjSplitBill           projSplitBill;
        real                    adjPercentage;

        emptyAmountList         = new List(Types::Class);
        fundingSourceAllocation = new List(Types::Class);

        if (allocateCalled)
        {
            // Allocate was previously called. Reset the distributions
            this.resetDistributions();

            // clear the map use to track limit updates
            limitRulesUpdated = new Map(Types::Int64, Types::Real);
        }

        allocateCalled = true;

        // No contract associated to project
        if (ProjFundingEngine::findProjInvoiceProjId(projTrans) == '')
        {
            this.updateDistribution(inputCostList,    ProjDistributionListType::Cost);
            this.updateDistribution(inputRevenueList, ProjDistributionListType::Sale);

            fundingSourceAllocation.addEnd(ProjSplitAllocation::construct( 0, 100, 0, NoYes::Yes));
        }
        else
        {
            //
            // Revenue and Cost list should have same set of distributions.
            // Create a empty list base on the costList
            //
            emptyAmountList = this.createListWithZeroAmounts(inputCostList);

            projInvoiceTable = ProjInvoiceTable::find(ProjFundingEngine::findProjInvoiceProjId(projTrans));
            contractCurrency = projInvoiceTable.CurrencyId;
            if (projTrans.currencyIdSales() != projInvoiceTable.CurrencyId)
            {
                // Use this variable so speed processing and avoid currency rounding issue
                trxCurrencyIsContractCurrency = false;
            }

            costList = inputCostList;

            //Convert totalRevenue to contract currency to update limits correctly
            revenueInTrxCurrencyList = inputRevenueList;

            // Only need to convert if Contract currency does not match transaction currency
            if (trxCurrencyIsContractCurrency)
            {
                revenueList = inputRevenueList;
            }
            else
            {
                revenueList = this.createListInContractCurrency(inputRevenueList);
            }

            // Use contract amounts for splits as that is what limits are based on
            amountToSplit = this.getTotalAmountFromList(revenueList);

            if ((totalCost == 0.00) && (totalRevenue == 0.00 || amountToSplit == 0.00))
            {
                // create zero sales based on first funding rule found
                projSplitBill = ProjSplitBill::construct(projTrans, singleFundingSourceRequired);
                splitList = projSplitBill.split(totalRevenue);
                if (splitList.empty())
                {
                    allocateSuccessful = false;

                    //Create On-Hold funding distributions if used.
                    usedOnHold = true;

                    //
                    // If the contract is setup to use On-Hold funding distribution the
                    // variable allocateSucessfull will be set to true
                    //
                    this.onHoldFundingDistributions(inputCostList, inputRevenueList);
                }
                else
                {
                    enumerateList = splitList.getEnumerator();
                    while (enumerateList.moveNext())
                    {
                        allocation = enumerateList.current();
                        fundingSourceRefId = allocation.parmFundingSourceRefRecId();

                        // Create a list with values 0 containing funding sources
                        emptyAmountList = this.createListWithZeroAmounts(inputRevenueList);
                        emptyAmountList = this.createListWithFundingSource(emptyAmountList, fundingSourceRefId);

                        this.updateDistribution(emptyAmountList, ProjDistributionListType::Cost);
                        this.updateDistribution(emptyAmountList, ProjDistributionListType::Sale);
                        allocateSuccessful = true;
                    }
                }
            }
            else
            {
                if (totalRevenue == 0.00)
                {
                    splitByCost         = true;
                    useFundingLimits    = false;
                }

                if (splitByCost)
                {
                    amountToSplit = totalCost;
                }

                if (amountToSplit < 0.00)
                {
                    negativeSplitAmount = true;
                    amountToSplit       = amountToSplit * -1;
                    costList            = this.changeSignOfListAmounts(costList);
                    revenueList         = this.changeSignOfListAmounts(revenueList);
                }

                //
                // We can simplify the allocation process when single useSingleFundingSource = true
                // and the funding source is specified.
                //
                // Validate the funding source, transaction does not exceed fundin limits.
                //
                if (singleFundingSourceRequired && (singleFundingSourceRefId != 0))
                {
                    // Validate specified funding source is part of the contract for this transaction
                    ProjTable projTable = projTrans.projTable();
                    ProjFundingSource projFundingSource = ProjFundingSource::find(singleFundingSourceRefId);
                    if (projTable.ProjInvoiceProjId != projFundingSource.ContractId)
                    {
                        allocateSuccessful = false;
                    }
                    else
                    {
                        // Validate amount is within funding limits for the funding source on the contract and allocate
                        if (ProjFundingEngine::isAmountWithinFundingLimits(ProjTrans, singleFundingSourceRefId, totalRevenue))
                        {
                            List distributionList;

                            distributionList = this.createListWithFundingSource(inputCostList, singleFundingSourceRefId);
                            this.updateDistribution(distributionList, ProjDistributionListType::Cost);

                            distributionList = this.createListWithFundingSource(inputRevenueList, singleFundingSourceRefId);
                            this.updateDistribution(distributionList, ProjDistributionListType::Sale);

                            fundingSourceAllocation.addEnd(ProjSplitAllocation::construct(singleFundingSourceRefId, 100, totalRevenue, NoYes::Yes));

                            // Update the appropriate funding limits and track thos which are changed.
                            if (useFundingLimits)
                            {
                                projSplitBill = ProjSplitBill::construct(projTrans, singleFundingSourceRequired, negativeSplitAmount);
                                this.updateFundingLimitsAllocated(projSplitBill, singleFundingSourceRefId, totalRevenue);
                            }

                            allocateSuccessful = true;
                        }
                        else
                        {
                            allocateSuccessful = false;
                        }
                        amountToSplit = 0;
                        roundingFundingSource = singleFundingSourceRefId;
                    }
                }
                else
                {
                    while ( (amountToSplit > 0.00) && (lastLoopValue != amountToSplit))
                    {
                        lastLoopValue           = amountToSplit;

                        // Setup to process amount
                        projSplitBill = ProjSplitBill::construct(projTrans, singleFundingSourceRequired, negativeSplitAmount);
                        if (useFundingLimits == false || (!invoiceable && projTrans is ProjTransRevenueJournal))
                        {
                            projSplitBill.parmIgnoreLimits(true);
                        }

                        splitList = projSplitBill.split(amountToSplit);
                        if (splitList.empty())
                        {
                            //
                            // No valid processing rules found
                            //

                            allocateSuccessful  = false;
                            amountToSplit       = 0;

                            //
                            // If using OnHold, create On-Hold funding distributions.
                            //
                            usedOnHold = true;
                            if ( splitByCost )
                            {
                                if (singleFundingSourceRequired)
                                {
                                    this.revertFundingLimitsUpdated();
                                    this.resetDistributions();

                                    this.onHoldFundingDistributions(inputCostList, emptyAmountList);
                                }
                                else
                                {
                                    this.onHoldFundingDistributions(costList, emptyAmountList);
                                }
                            }
                            else
                            {
                                if (singleFundingSourceRequired)
                                {
                                    this.revertFundingLimitsUpdated();
                                    this.resetDistributions();

                                    this.onHoldFundingDistributions(inputCostList, inputRevenueList);
                                }
                                else
                                {
                                    this.onHoldFundingDistributions(costList, revenueInTrxCurrencyList);
                                }
                            }
                        }
                        else
                        {
                            //
                            // Valid rule found for processing
                            //
                            rulesProcessed += 1;

                            // Set variables for limit  processing
                            [adjPercentage, limitingAmount, limitingfundingSource, roundingFundingSource] = this.getAllocationVariables(splitList, amountToSplit);

                            if ((splitList.elements() == 1) &&
                                (adjPercentage == 1.0))
                            {
                                //
                                // This results in 100% allocation to one funding source rule processed without limits reached.
                                // This simple rule processsing with no limit reached or multiple funding source.
                                //

                                this.processSimpleRule(costList,
                                                        revenueList,
                                                        emptyAmountList,
                                                        projSplitBill,
                                                        roundingFundingSource,
                                                        rulesProcessed,
                                                        splitByCost,
                                                        negativeSplitAmount,
                                                        trxCurrencyIsContractCurrency);

                                amountToSplit       = 0;
                                costList            = emptyAmountList;
                                revenueList         = emptyAmountList;
                            }
                            else
                            {
                                //
                                // This allocation to multiple funding sources required or limit contraint.
                                //
                                this.processComplexRule(projSplitBill,
                                                        costList,
                                                        revenueList,
                                                        revenueInTrxCurrencyList,
                                                        splitList,
                                                        projTrans,
                                                        contractCurrency,
                                                        adjPercentage,
                                                        negativeSplitAmount);
                                if  (splitByCost)
                                {
                                    amountToSplit       = this.getTotalAmountFromList(costList);
                                }
                                else
                                {
                                    amountToSplit       = this.getTotalAmountFromList(revenueList);
                                }
                            }
                        }
                    }

                    if (allocateSuccessful == NoYes::Yes)
                    {
                        this.validateDistributionsForRoundingErrors(splitList, usedOnHold, projSplitBill);
                    }
                }
            }
            if (allocateSuccessful)
            {
                this.createFundingSourceAllocationMappings(splitByCost, roundingFundingSource);
            }

            if ( ( posting == false ) || ( invoiceable == false ) || (allocateSuccessful == false))
            {
                //Revert soft updates to funding limits
                this.revertFundingLimitsUpdated();
            }
         }
        
        return allocateSuccessful;
    }

]]></Source>
			</Method>
			<Method>
				<Name>billingRuleInvoiceable</Name>
				<Source><![CDATA[
    private void billingRuleInvoiceable()
    {
        if (invoiceable)
        {
            invoiceable = ProjInvoiceTable::isBillingRuleInvoiceable(projTrans.projId(),
                                                                     projTrans.categoryId(),
                                                                     projTrans.psaContractLineNum(),
                                                                     projTrans.transType());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>changeSignOfListAmounts</Name>
				<Source><![CDATA[
    private List changeSignOfListAmounts(List _distributions)
    {
        List                    newList;
        ListEnumerator          enumerateList;
        projAccDistribution     padSource;
        projAccDistribution     padDestingation;

        newList = new List(Types::Class);

        enumerateList = _distributions.getEnumerator();
        while (enumerateList.moveNext())
        {
            padSource = enumerateList.current();
            padDestingation = projAccDistribution::construct(padSource.parmSourceDocumentLine(),
                                                             padSource.parmMonetaryAmount(),
                                                             padSource.parmAmount() * -1,
                                                             padSource.parmFundingSource());
            newList.addEnd(padDestingation);
        }

        return newList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDistributionForRule</Name>
				<Source><![CDATA[
    private List createDistributionForRule(List                     _distributionList,
                                           real                     _allocationPercentage,
                                           real                     _adjustmentPercentage,
                                           ProjFundingSourceRefId   _fundingSource,
                                           CurrencyCode             _contractCurrency,
                                           AmountCur                _checkAmount)
    {
        AmountCur               amount;
        AmountCur               adjustmentAmount;
        boolean                 amountCorrected         = false;
        List                    newDistributionList;
        List                    tempList;
        ListEnumerator          enumerateList;
        projAccDistribution     padSource;
        projAccDistribution     padDestination;

        newDistributionList = new List(Types::Class);

        enumerateList = _distributionList.getEnumerator();
        while (enumerateList.moveNext())
        {
            padSource = enumerateList.current();
            amount    = CurrencyExchangeHelper::amount(_allocationPercentage * padSource.parmAmount() * _adjustmentPercentage, _contractCurrency);

            padDestination = projAccDistribution::construct(padSource.parmSourceDocumentLine(),
                                                            padSource.parmMonetaryAmount(),
                                                            amount,
                                                            _fundingSource);
            newDistributionList.addEnd(padDestination);
        }

        //Validate distribution list amounts
        amount = this.getTotalAmountFromList(newDistributionList);
        if (amount != _checkAmount)
        {
            tempList            = newDistributionList;
            newDistributionList = new List(Types::Class);

            adjustmentAmount    = amount - _checkAmount;

            // Adjustment will be applied to ExtendedPrice
            enumerateList = tempList.getEnumerator();
            while (enumerateList.moveNext())
            {
                padSource = enumerateList.current();
                if ((padSource.parmMonetaryAmount() == MonetaryAmount::ExtendedPrice) && !amountCorrected)
                {
                    amount = padSource.parmAmount() - adjustmentAmount;

                    padDestination = projAccDistribution::construct(padSource.parmSourceDocumentLine(),
                                                                    padSource.parmMonetaryAmount(),
                                                                    amount,
                                                                    _fundingSource);

                    // Only adjust once if there are multiple extended price entries.
                    amountCorrected = true;
                    newDistributionList.addEnd(padDestination);
                }
                else
                {
                    newDistributionList.addEnd(padSource);
                }
            }
        }

        return newDistributionList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFundingSourceAllocationMappings</Name>
				<Source><![CDATA[
    private void createFundingSourceAllocationMappings(boolean _splitByCost, ProjFundingSourceRefId allocateRoundingFundingSource)
    {
        MapEnumerator           mapEnumerator;
        ProjSplitAllocation     allocation;
        ProjFundingRuleAllocation projFundingRuleAllocation;

        // Check for split by cost as there may be sale distributions of 0.00 for invoicing
        if ( saleDistributions.elements() > 0 && !_splitByCost)
        {
            mapEnumerator = saleDistributions.getEnumerator();

            while ( mapEnumerator.moveNext() )
            {
                if (totalRevenue != 0.00)
                {
                    allocation = ProjSplitAllocation::construct( mapEnumerator.currentKey(),
                                                                 mapEnumerator.currentValue()/totalRevenue * 100,
                                                                 0,
                                                                 mapEnumerator.currentKey() == allocateRoundingFundingSource? NoYes::Yes : NoYes::No );
                }
                else
                {
                    select firstonly AllocationPercentage from projFundingRuleAllocation
                        where projFundingRuleAllocation.FundingSource == mapEnumerator.currentKey();

                     allocation = ProjSplitAllocation::construct( mapEnumerator.currentKey(),
                                                                  projFundingRuleAllocation.AllocationPercentage,
                                                                  0,
                                                                  mapEnumerator.currentKey() == allocateRoundingFundingSource? NoYes::Yes : NoYes::No );
                }

                fundingSourceAllocation.addEnd( allocation );
            }
        }
        else if ( costDistributions.elements() > 0 )
        {
            mapEnumerator = costDistributions.getEnumerator();

            while ( mapEnumerator.moveNext() )
            {
                if (totalCost != 0.00)
                {
                    allocation = ProjSplitAllocation::construct( mapEnumerator.currentKey(),
                                                                 mapEnumerator.currentValue()/totalCost * 100,
                                                                 0,
                                                                 mapEnumerator.currentKey() == allocateRoundingFundingSource? NoYes::Yes : NoYes::No );
                }
                else
                {
                    select firstonly AllocationPercentage from projFundingRuleAllocation
                        where projFundingRuleAllocation.FundingSource == mapEnumerator.currentKey();

                     allocation = ProjSplitAllocation::construct( mapEnumerator.currentKey(),
                                                                  projFundingRuleAllocation.AllocationPercentage,
                                                                  0,
                                                                  mapEnumerator.currentKey() == allocateRoundingFundingSource? NoYes::Yes : NoYes::No );
                }

                fundingSourceAllocation.addEnd( allocation );
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createListInContractCurrency</Name>
				<Source><![CDATA[
    private List createListInContractCurrency(List _distributions)
    {
        List                    listInContractCurrency;
        ListEnumerator          enumerateList;
        projAccDistribution     padSource;
        projAccDistribution     padDestination;
        AmountCur               amountInContractCurrency;

        listInContractCurrency = new List(Types::Class);

        enumerateList = _distributions.getEnumerator();
        while (enumerateList.moveNext())
        {
            padSource = enumerateList.current();
            amountInContractCurrency = ProjFundingEngine::curAmount2AmountOfContract(projTrans.projId(),
                                                                      padSource.parmAmount(),
                                                                      projTrans.currencyIdSales(),
                                                                      projTrans.transDate());

            padDestination = projAccDistribution::construct(padSource.parmSourceDocumentLine(),
                                                            padSource.parmMonetaryAmount(),
                                                            amountInContractCurrency,
                                                            padSource.parmFundingSource());
            listInContractCurrency.addEnd(padDestination);
        }

        return listInContractCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createListTrxCurrency</Name>
				<Source><![CDATA[
    private List createListTrxCurrency(List _distributions)
    {
        AmountCur               amountInTrxCurrency;
        List                    listTrxCurrency;
        ListEnumerator          enumerateList;
        projAccDistribution     padSource;
        projAccDistribution     padDestination;

        listTrxCurrency = new List(Types::Class);

        enumerateList = _distributions.getEnumerator();
        while (enumerateList.moveNext())
        {
            padSource = enumerateList.current();
            amountInTrxCurrency = ProjFundingEngine::contractAmount2curAmount( projTrans.projId(),
                                                                      padSource.parmAmount(),
                                                                      projTrans.currencyIdSales(),
                                                                      projTrans.transDate());

            padDestination = projAccDistribution::construct(padSource.parmSourceDocumentLine(),
                                                            padSource.parmMonetaryAmount(),
                                                            amountInTrxCurrency,
                                                            padSource.parmFundingSource());
            listTrxCurrency.addEnd(padDestination);
        }

        return listTrxCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createListWithFundingSource</Name>
				<Source><![CDATA[
    private List createListWithFundingSource(List _list, ProjFundingSourceRefId _fundingSource)
    {
        List                    newList;
        ListEnumerator          enumerateList;
        projAccDistribution     padSource;
        projAccDistribution     padDestination;

        newList = new List(Types::Class);

        enumerateList = _list.getEnumerator();
        while (enumerateList.moveNext())
        {
            padSource = enumerateList.current();

            padDestination = projAccDistribution::construct( padSource.parmSourceDocumentLine(),
                                                            padSource.parmMonetaryAmount(),
                                                            padSource.parmAmount(),
                                                            _fundingSource);
            newList.addEnd(padDestination);
        }

        return newList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createListWithoutFundingSource</Name>
				<Source><![CDATA[
    private List createListWithoutFundingSource(List _list)
    {
        AmountCur               amount;
        List                    newList;
        ListEnumerator          enumerateList;
        projAccDistribution     padSource;
        projAccDistribution     padDestination;

        boolean existsInList(List _listLocal, projAccDistribution _padSource)
        {
            ListEnumerator          enumList;
            projAccDistribution     pad;

            enumList = _listLocal.getEnumerator();
            while (enumList.moveNext())
            {
                pad = enumList.current();
                if (_padSource.parmSourceDocumentLine() == pad.parmSourceDocumentLine() &&
                    _padSource.parmMonetaryAmount() == pad.parmMonetaryAmount())
                {
                    return true;
                }
            }

            return false;
        }

        newList = new List(Types::Class);

        enumerateList = _list.getEnumerator();
        while (enumerateList.moveNext())
        {
            padSource = enumerateList.current();

            // Removing funding source may created duplicate records - sum amounts before insert
            if (!existsInList(newList, padSource))
            {
                amount = this.getAmountBasedOnDistribionProperties(_list,
                                                               padSource.parmSourceDocumentLine(),
                                                               padSource.parmMonetaryAmount());

                padDestination = projAccDistribution::construct( padSource.parmSourceDocumentLine(),
                                                                padSource.parmMonetaryAmount(),
                                                                amount,
                                                                0);
                newList.addEnd(padDestination);
            }
        }

        return newList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createListWithZeroAmounts</Name>
				<Source><![CDATA[
    private List createListWithZeroAmounts(List _distributionList)
    {
        List                    newDistibutionList;
        ListEnumerator          enumerateList;
        projAccDistribution     padSource;
        projAccDistribution     padDestination;

        newDistibutionList = new List(Types::Class);

        enumerateList = _distributionList.getEnumerator();
        while (enumerateList.moveNext())
        {
            padSource = enumerateList.current();
            padDestination = projAccDistribution::construct(padSource.parmSourceDocumentLine(),
                                                            padSource.parmMonetaryAmount(),
                                                            0,
                                                            padSource.parmFundingSource());
            newDistibutionList.addEnd(padDestination);
        }

        return newDistibutionList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAllocationVariables</Name>
				<Source><![CDATA[
    private container getAllocationVariables(List _splitList, AmountCur  _amountToSplit)
    {
        AmountCur               limitingAmount;
        ListEnumerator          enumerateList;
        ProjFundingSourceRefId  limitingFundingSource = 0;
        ProjFundingSourceRefId  roundingFundingSource = 0;
        ProjSplitAllocation     projSplitAllocation;
        real                    allocPercentage;
        real                    adjPercentage = 1.00;

        limitingAmount = _amountToSplit;

        enumerateList = _splitList.getEnumerator();

        // Check for limit being reached
        // If a limit is reached an adjustment percentage is needed in the calculations
        while (enumerateList.moveNext())
        {
            projSplitAllocation = enumerateList.current();
            allocPercentage = projSplitAllocation.parmPercent()/100;
            if (projSplitAllocation.parmIsAllocateRounding())
            {
                roundingFundingSource = projSplitAllocation.parmFundingSourceRefRecId();
            }

            if (_amountToSplit > (projSplitAllocation.parmLimit() / allocPercentage))
            {
                // Compute percentage adjustment
                if (((projSplitAllocation.parmLimit()/allocPercentage) / _amountToSplit) < adjPercentage)
                {
                    limitingAmount          = projSplitAllocation.parmLimit();
                    limitingFundingSource   = projSplitAllocation.parmFundingSourceRefRecId();
                    adjPercentage           = ((projSplitAllocation.parmLimit()/allocPercentage) / _amountToSplit);
                }
            }
        }

        return [adjPercentage, limitingAmount, limitingFundingSource, roundingFundingSource];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAmountBasedOnDistribionProperties</Name>
				<Source><![CDATA[
    private AmountCur getAmountBasedOnDistribionProperties(List                     _distributionList,
                                                           SourceDocumentLineRecId  _sourceDocumentLine,
                                                           MonetaryAmount           _monentaryAmountType)
    {
        AmountCur               amount;
        ListEnumerator          enumerateList;
        projAccDistribution     projAccDistribution;

        // Compute total amount from list;
        enumerateList = _distributionList.getEnumerator();
        while (enumerateList.moveNext())
        {
            projAccDistribution = enumerateList.current();
            if ((projAccDistribution.parmSourceDocumentLine() == _sourceDocumentLine) &&
                (projAccDistribution.parmMonetaryAmount() == _monentaryAmountType))
            {
                amount += projAccDistribution.parmAmount();
            }
        }

        return amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns a list of funding source and amount as allocated by the funding engine
    /// </summary>
    /// <param name="_distributionList">
    ///     Whether to retrieve cost or sales distributions
    /// </param>
    /// <returns>
    ///     The list of funding sources and amount allocated
    /// </returns>
    public List getDistributions(ProjDistributionListType _distributionList)
    {
        List    retValue;

        retValue = new List(Types::Class);
        switch (_distributionList)
        {
            case ProjDistributionListType::Cost :
                retValue = costDistributionsList;
                break;

            case ProjDistributionListType::Sale :
                retValue = saleDistributionsList;
                break;
        }

        return retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOnHoldFundingSource</Name>
				<Source><![CDATA[
    private ProjFundingSourceRefId getOnHoldFundingSource()
    {
        ProjFundingSourceRefId      fundingsource       = 0;
        ProjTable                   projTableLocal;

        projTableLocal = ProjTable::find(projTrans.projId());
        if (projTableLocal.ProjInvoiceProjId)
        {
            // Find the OnHold funding source for the contract
            ProjFundingSource projFundingSource;
            select firstonly RecId from projFundingSource where
                projFundingSource.ContractId == projTableLocal.ProjInvoiceProjId &&
                projFundingSource.FundingType == ProjFundingType::OnHoldFundingSource;

            fundingsource = projFundingSource.RecId;
        }

        return fundingsource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalAmountFromList</Name>
				<Source><![CDATA[
    private AmountCur getTotalAmountFromList(List _distributionList)
    {
        AmountCur               amount;
        ListEnumerator          enumerateList;
        projAccDistribution     projAccDistribution;

        // Compute total amount from list;
        enumerateList = _distributionList.getEnumerator();
        while (enumerateList.moveNext())
        {
            projAccDistribution = enumerateList.current();
            amount              += projAccDistribution.parmAmount();
        }

        return amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    private void init(ProjTrans _projTrans,
                    List _costList,
                    List _revenueList,
                    boolean _posting,
                    boolean _useFundingLimits)
    {
        AmountCur               costAmount;
        AmountCur               revenueAmount;

        this.initMaps();
        this.initLists();

        inputCostList       = _costList;
        inputRevenueList    = _revenueList;

        costAmount      = this.getTotalAmountFromList(_costList);
        revenueAmount   = this.getTotalAmountFromList(_revenueList);

        this.initVariables(_projTrans, costAmount, revenueAmount, _posting, _useFundingLimits);

        // These calls are dependent on setting of ProjTrans variable
        this.initLinePropertyBasedSettings();
        this.billingRuleInvoiceable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLinePropertyBasedSettings</Name>
				<Source><![CDATA[
    private void initLinePropertyBasedSettings()
    {
        ProjLineProperty projLineProperty = ProjLineProperty::find(projTrans.linePropertyId());
        if (projLineProperty)
        {
            // Invoiceable transaction
            if ( !projLineProperty.ToBeInvoiced )
            {
                invoiceable = false;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLists</Name>
				<Source><![CDATA[
    private void initLists()
    {
        inputCostList                   = new List(Types::Class);
        inputRevenueList                = new List(Types::Class);

        costDistributionsList           = new List(Types::Class);
        saleDistributionsList           = new List(Types::Class);

        costList                        = new List(Types::Class);
        revenueList                     = new List(Types::Class);
        revenueInTrxCurrencyList        = new List(Types::Class);

        fundingSourceAllocation         = new List(Types::Class);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMaps</Name>
				<Source><![CDATA[
    private void initMaps()
    {
        costDistributions = new Map(Types::Int64, Types::Real);
        saleDistributions = new Map(Types::Int64, Types::Real);
        limitRulesUpdated = new Map(Types::Int64, Types::Real);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initVariables</Name>
				<Source><![CDATA[
    private void initVariables(ProjTrans _projTrans,
                                AmountCur _totalCost,
                                AmountCur _totalRevenue,
                                boolean _posting,
                                boolean _useFundingLimits)
    {
        totalCost           = _totalCost;
        totalRevenue        = _totalRevenue;
        projTrans           = _projTrans;
        posting             = _posting;
        useFundingLimits    = _useFundingLimits;

        allocateCalled = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOnHoldFundingAllowed</Name>
				<Source><![CDATA[
    private boolean isOnHoldFundingAllowed()
    {
        boolean ret = true;

        if (projTrans.transType() == ProjTransType::OnAccount)
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeLists</Name>
				<Source><![CDATA[
    private List mergeLists(List _list1, List _list2)
    {
        AmountCur               newAmount;
        boolean                 found;
        List                    mergedList;
        ListEnumerator          enumeratorList1;
        ListEnumerator          enumeratorList2;
        projAccDistribution     padList1;
        projAccDistribution     padList2;
        projAccDistribution     padDestination;

        boolean keysMatchForProjAccDist(projAccDistribution _pad1, projAccDistribution _pad2)
        {
            boolean retValue = false;

            if (padList1.parmSourceDocumentLine() == padList2.parmSourceDocumentLine() &&
                    padList1.parmMonetaryAmount() == padList2.parmMonetaryAmount() &&
                    padList1.parmFundingSource() == padList2.parmFundingSource())
            {
                retValue = true;
            }

            return retValue;
        }

        mergedList = new List(Types::Class);

        enumeratorList1 = _list1.getEnumerator();
        enumeratorList2 = _list2.getEnumerator();

        while (enumeratorList1.moveNext())
        {
            padList1 = enumeratorList1.current();

            found = false;
            enumeratorList2.reset();
            while (enumeratorList2.moveNext() && !found)
            {
                padList2 = enumeratorList2.current();
                if (keysMatchForProjAccDist(padList1, padList2))
                {
                    // Values found in both lists, combine and add to MergeList
                    newAmount = padList1.parmAmount() + padList2.parmAmount();
                    padDestination = projAccDistribution::construct(padList1.parmSourceDocumentLine(),
                                                                    padList1.parmMonetaryAmount(),
                                                                    newAmount,
                                                                    padList1.parmFundingSource());
                    mergedList.addEnd(padDestination);
                    found = true;
                }
            }
            if (!found)
            {
                // Not part of List2, add to MergeList
                mergedList.addEnd(padList1);
            }
        }

        // Check for List2 values not in List1 to include in MergedList
        enumeratorList2.reset();
        while (enumeratorList2.moveNext())
        {
            padList2 = enumeratorList2.current();

            found = false;
            enumeratorList1.reset();
            while (enumeratorList1.moveNext() && !found)
            {
                padList1 = enumeratorList1.current();
                if (keysMatchForProjAccDist(padList1, padList2))
                {
                    found = true;
                }
            }
            if (!found)
            {
                mergedList.addEnd(padList2);
            }
        }

        return mergedList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        singleFundingSourceRequired     = false;
        posting                         = true;
        allocateSuccessful              = true;
        invoiceable                     = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onHoldFundingDistributions</Name>
				<Source><![CDATA[
    private void onHoldFundingDistributions(List _costAmountList, List _revenueAmountList)
    {
        List                    newList;
        ProjFundingSourceRefId  fundingSourceRefId;

        if (this.isOnHoldFundingAllowed() == true)
        {
            // Find the OnHold funding source for the contract
            fundingSourceRefId = this.getOnHoldFundingSource();

            if (fundingSourceRefId != 0)
            {
                allocateSuccessful = true;

                // Costs
                newList = this.createListWithFundingSource(_costAmountList, fundingSourceRefId);
                this.updateDistribution(newList, ProjDistributionListType::Cost);

                // Revenue
                newList = this.createListWithFundingSource(_revenueAmountList, fundingSourceRefId);
                this.updateDistribution(newList, ProjDistributionListType::Sale);
            }
        }

        if (allocateSuccessful != true)
        {
            // clear distribution, so the user doesn't try and use them.
            this.resetDistributions();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCostDistributions</Name>
				<Source><![CDATA[
    public Map parmCostDistributions(Map _costDistributions = costDistributions)
    {
        costDistributions = _costDistributions;

        return costDistributions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmfundingSourceAllocation</Name>
				<Source><![CDATA[
    public List parmfundingSourceAllocation(List _fundingSourceAllocation = fundingSourceAllocation)
    {
        fundingSourceAllocation = _fundingSourceAllocation;

        return fundingSourceAllocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSaleDistributions</Name>
				<Source><![CDATA[
    public Map parmSaleDistributions(Map _saleDistributions = saleDistributions)
    {
        saleDistributions = _saleDistributions;

        return saleDistributions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFundingLimitList</Name>
				<Source><![CDATA[
	public Map getFundingLimitList()
	{
        return limitRulesUpdated;
	}

]]></Source>
			</Method>
			<Method>
				<Name>parmSingleFundingSourceRequired</Name>
				<Source><![CDATA[
    public boolean parmSingleFundingSourceRequired(boolean _singleFundingSourceRequired = singleFundingSourceRequired)
    {
        singleFundingSourceRequired = _singleFundingSourceRequired;

        return singleFundingSourceRequired;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processComplexRule</Name>
				<Source><![CDATA[
    private void processComplexRule(ProjSplitBill           _projSplitBill,
                                         List               _costList,
                                         List               _revenueList,
                                         List               _revenueTrxLIst,
                                         List               _allocationList,
                                         ProjTrans          _projTrans,
                                         CurrencyCode       _contractCurrency,
                                         real               _adjPercentage,
                                         boolean            _negativeSplitAmount)
    {
        AmountCur               amountToDistribute;
        AmountCur               listAmount;
        List                    costDistributionForAllocation;
        List                    costDistributionsForRule;
        List                    revenueDistributionsForAllocation;
        List                    revenueTrxDistributionsForAllocation;
        List                    revenueDistributionsForRule;
        List                    revenueTrxDistributionsForRule;
        ListEnumerator          enumerateList;
        ProjFundingSourceRefId  fundingSourceRefId = 0;
        ProjSplitAllocation     projSplitAllocation;
        real                    allocationPercentage;

        costDistributionsForRule        = new List(Types::Class);
        revenueDistributionsForRule     = new List(Types::Class);
        revenueTrxDistributionsForRule  = new List(Types::Class);

        enumerateList   = _allocationList.getEnumerator();
        while (enumerateList.moveNext())
        {
            // Process each funding source in rule.
            projSplitAllocation     = enumerateList.current();
            allocationPercentage    = projSplitAllocation.parmPercent()/100;
            fundingSourceRefId      = projSplitAllocation.parmFundingSourceRefRecId();

            costDistributionForAllocation         = new List(Types::Class);
            revenueDistributionsForAllocation     = new List(Types::Class);
            revenueTrxDistributionsForAllocation  = new List(Types::Class);

            // Create the cost distributions
            listAmount          = this.getTotalAmountFromList(_costList);

            amountToDistribute  = CurrencyExchangeHelper::amount(allocationPercentage * listAmount * _adjPercentage, _contractCurrency);

            costDistributionForAllocation   = this.createDistributionForRule(_costList,
                                                                 allocationPercentage,
                                                                 _adjPercentage,
                                                                 fundingSourceRefId,
                                                                 _contractCurrency,
                                                                 amountToDistribute);

            if (_negativeSplitAmount)
            {
                costDistributionForAllocation = this.changeSignOfListAmounts(costDistributionForAllocation);
            }

            costDistributionsForRule = this.mergeLists(costDistributionsForRule, costDistributionForAllocation);

            // Create the revenue distributionsif (!splitByCost)
            listAmount                          = this.getTotalAmountFromList(_revenueList);
            amountToDistribute                  = CurrencyExchangeHelper::amount(allocationPercentage * listAmount * _adjPercentage, _contractCurrency);

            revenueDistributionsForAllocation   = this.createDistributionForRule(_revenueList,
                                                                    allocationPercentage,
                                                                    _adjPercentage,
                                                                    fundingSourceRefId,
                                                                    _contractCurrency,
                                                                    amountToDistribute);

            listAmount                          = this.getTotalAmountFromList(_revenueTrxLIst);
            amountToDistribute                  = CurrencyExchangeHelper::amount(allocationPercentage * listAmount * _adjPercentage, _contractCurrency);

            revenueTrxDistributionsForAllocation = this.createDistributionForRule(_revenueTrxLIst,
                                                                    allocationPercentage,
                                                                    _adjPercentage,
                                                                    fundingSourceRefId,
                                                                    _projTrans.currencyIdSales(),
                                                                    amountToDistribute);
            if (_negativeSplitAmount)
            {
               revenueDistributionsForAllocation = this.changeSignOfListAmounts(revenueDistributionsForAllocation);
            }

            // Update limits
            if (useFundingLimits == true)
            {
                listAmount = this.getTotalAmountFromList(revenueDistributionsForAllocation);
                this.updateFundingLimitsAllocated(_projSplitBill, fundingSourceRefId, listAmount);
            }

            // Use trx list to avoid calculation rounding
            revenueDistributionsForRule     = this.mergeLists(revenueDistributionsForRule, revenueDistributionsForAllocation);
            revenueTrxDistributionsForRule  = this.mergeLists(revenueTrxDistributionsForRule, revenueTrxDistributionsForAllocation);
        }

        // Update distribution lists.
        this.updateDistribution(costDistributionsForRule, ProjDistributionListType::Cost);
        this.updateDistribution(revenueTrxDistributionsForRule, ProjDistributionListType::Sale);

        // Update processing lists
        costDistributionsForRule        = this.createListWithoutFundingSource(costDistributionsForRule);
        if (!_negativeSplitAmount)
        {
            costDistributionsForRule    = this.changeSignOfListAmounts(costDistributionsForRule);
        }
        costList                        = this.mergeLists(_costList, costDistributionsForRule);

        revenueDistributionsForRule     = this.createListWithoutFundingSource(revenueDistributionsForRule);
        if (!_negativeSplitAmount)
        {
            revenueDistributionsForRule = this.changeSignOfListAmounts(revenueDistributionsForRule);
        }
        revenueList                     = this.mergeLists(_revenueList, revenueDistributionsForRule);

        revenueTrxDistributionsForRule  = this.createListWithoutFundingSource(revenueTrxDistributionsForRule);
        revenueTrxDistributionsForRule  = this.changeSignOfListAmounts(revenueTrxDistributionsForRule);
        revenueInTrxCurrencyList        = this.mergeLists(_revenueTrxLIst, revenueTrxDistributionsForRule);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSimpleRule</Name>
				<Source><![CDATA[
    private void processSimpleRule(List                    _costList,
                                   List                    _revenueList,
                                   List                    _emptyAmountList,
                                   ProjSplitBill           _projSplitBill,
                                   ProjFundingSourceRefId  _roundingFundingSource,
                                   int64                   _rulesProcessed,
                                   boolean                 _splitByCost,
                                   boolean                 _negativeSplitAmount,
                                   boolean                 _trxCurrencyIsContractCurrency)
    {
        AmountCur               limitAmount;
        List                    distributionList;

        // Handle cost amounts
        distributionList = this.createListWithFundingSource(_costList, _roundingFundingSource);
        if (_negativeSplitAmount)
        {
            distributionList = this.changeSignOfListAmounts(distributionList);
            this.updateDistribution(distributionList, ProjDistributionListType::Cost);
        }
        else
        {
            this.updateDistribution(distributionList, ProjDistributionListType::Cost);
        }

        // Handle revenue amounts
        // Need to convert back to TrxCurrency
        if (_rulesProcessed == 1)
        {
            // In this case we can use the inputRevenueList without needing to convert again
            distributionList = this.createListWithFundingSource(inputRevenueList, _roundingFundingSource);
            this.updateDistribution(distributionList, ProjDistributionListType::Sale);
            limitAmount = this.getTotalAmountFromList(_revenueList);

            //Changing negative split amount as all values processed as positive transactions
            if (_negativeSplitAmount)
            {
                limitAmount = limitAmount * -1;
            }
        }
        else
        {
            if (_splitByCost)
            {
                // No revenue -- use emptyDistList
                distributionList = this.createListWithFundingSource(_emptyAmountList, _roundingFundingSource);
                this.updateDistribution(_emptyAmountList, ProjDistributionListType::Sale);
            }
            else
            {
                distributionList = _revenueList;
                limitAmount = this.getTotalAmountFromList(_revenueList);

                if (!_trxCurrencyIsContractCurrency)
                {
                    // Convert back to Trx Currency
                    distributionList = this.createListTrxCurrency(_revenueList);
                }

                if (_negativeSplitAmount)
                {
                    // Change as all values processed as positive transactions
                    distributionList = this.changeSignOfListAmounts(distributionList);
                    limitAmount = limitAmount * -1;
                }
                distributionList = this.createListWithFundingSource(distributionList, _roundingFundingSource);
                this.updateDistribution(distributionList, ProjDistributionListType::Sale);
            }
        }

        // Update limits
        if (useFundingLimits == true)
        {
            this.updateFundingLimitsAllocated(_projSplitBill, _roundingFundingSource, limitAmount);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetDistributions</Name>
				<Source><![CDATA[
    private void resetDistributions()
    {
        //
        // Reset the distribution objects.
        //
        // Normally this would be the result of an allocation failure so that the
        // user doesn't attempt to use invalid data.
        //
        costDistributions       = new Map(Types::Int64, Types::Real);
        saleDistributions       = new Map(Types::Int64, Types::Real);

        costDistributionsList   = new List(Types::Class );
        saleDistributionsList   = new List(Types::Class );

        fundingSourceAllocation = new List(Types::Class);
    }

]]></Source>
			</Method>
			<Method>
				<Name>revertFundingLimitsUpdated</Name>
				<Source><![CDATA[
    private void revertFundingLimitsUpdated()
    {
        MapEnumerator           enumerateMap;
        ProjFundingLimit        projFundingLimit;
        RefRecId                fundingLimitRefRecId;

        if (!limitRulesUpdated.empty())
        {
            enumerateMap = limitRulesUpdated.getEnumerator();

            ttsbegin;
            while (enumerateMap.moveNext())
            {
                fundingLimitRefRecId = enumerateMap.currentKey();
                projFundingLimit = ProjFundingLimit::find(fundingLimitRefRecId, true);
                projFundingLimit.LimitSpent = projFundingLimit.LimitSpent - enumerateMap.currentValue();
                projFundingLimit.update();
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDistribution</Name>
				<Source><![CDATA[
    private void updateDistribution(List _distributions, ProjDistributionListType _distributionType)
    {
        ListEnumerator          enumerateList;
        projAccDistribution     projAccDistribution;

        if (_distributions.elements() != 0)
        {
            // Update distribution lists
            switch (_distributionType)
            {
                case ProjDistributionListType::Cost :
                    costDistributionsList = this.mergeLists(costDistributionsList, _distributions);
                    break;

                case ProjDistributionListType::Sale :
                    saleDistributionsList = this.mergeLists(saleDistributionsList, _distributions);
                    break;
            }

            // Update distribution maps
            enumerateList = _distributions.getEnumerator();
            while (enumerateList.moveNext())
            {
                projAccDistribution = enumerateList.current();

                switch (_distributionType)
                {
                    case ProjDistributionListType::Cost :
                        this.addCostDistribution(projAccDistribution.parmFundingSource(), projAccDistribution.parmAmount());
                        break;

                    case ProjDistributionListType::Sale :
                        this.addSalesDistribution(projAccDistribution.parmFundingSource(), projAccDistribution.parmAmount());
                        break;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFundingLimitsAllocated</Name>
				<Source><![CDATA[
    private void updateFundingLimitsAllocated(ProjSplitBill _projSplitBill, ProjFundingSourceRefId _fundingSource, AmountCur _amount)
    {
        ProjFundingLimit        projFundingLimit;
        RecId                   projFundingLimitRecId;
        AmountCur               limitSpent;
        QueryRun                listOfLimits;

        if (!invoiceable)
        {
            return;
        }

        if (_amount != 0.00)
        {
            listOfLimits = _projSplitBill.getTransLimits();
            listOfLimits.reset();

            while (listOfLimits.next())
            {
                projFundingLimit = listOfLimits.get(tableNum(ProjFundingLimit));
                if (projFundingLimit.FundingSource == _fundingSource || projFundingLimit.FundingSource == 0)
                {
                    ttsbegin;
                    projFundingLimitRecId = projFundingLimit.RecId;
                    projFundingLimit = ProjFundingLimit::find(projFundingLimitRecId, true);
                    projFundingLimit.LimitSpent += _amount;
                    projFundingLimit.update();

                    limitSpent = _amount;
                    if (limitRulesUpdated.exists(projFundingLimit.RecId))
                    {
                        //Update values
                        limitSpent = limitRulesUpdated.lookup(projFundingLimit.RecId) + _amount;
                        limitRulesUpdated.remove(projFundingLimit.RecId);
                    }
                    limitRulesUpdated.insert(projFundingLimit.RecId, limitSpent);

                    ttscommit;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDistributionsForRoundingErrors</Name>
				<Source><![CDATA[
    private void validateDistributionsForRoundingErrors(List _lastDistributionAllocations, boolean _usedOnHold, ProjSplitBill   _projSplitBill)
    {
        AmountCur               adjustmentAmount;
        AmountCur               checkAmount;
        List                    correctionDistributions;
        ListEnumerator          enumerateList;
        projAccDistribution     projAccDistribution;
        projAccDistribution     correctionDistribution;
        ProjFundingSourceRefId  correctionFundingSource;
        ProjSplitAllocation     splitAllocation;

        //
        // Get the rounding account from rule last processed for corrections
        //
        enumerateList = _lastDistributionAllocations.getEnumerator();
        while (enumerateList.moveNext())
        {
            splitAllocation = enumerateList.current();
            if (splitAllocation.parmIsAllocateRounding())
            {
                correctionFundingSource = splitAllocation.parmFundingSourceRefRecId();
            }
        }

        //
        // If OnHold used, this is the correct account
        //
        if (_usedOnHold)
        {
            correctionFundingSource = this.getOnHoldFundingSource();
        }

        //
        //  Validate that the correction funding source
        //  If limits were hit on this funding source, may not be able to do corrections
        //

        // Check the Cost Distributions
        correctionDistributions = new List(Types::Class);

        enumerateList = inputCostList.getEnumerator();
        while (enumerateList.moveNext())
        {
            projAccDistribution = enumerateList.current();
            checkAmount = this.getAmountBasedOnDistribionProperties(costDistributionsList, projAccDistribution.parmSourceDocumentLine(), projAccDistribution.parmMonetaryAmount());
            if (projAccDistribution.parmAmount() !=checkAmount)
            {
                adjustmentAmount    = projAccDistribution.parmAmount() - checkAmount;

                correctionDistribution = projAccDistribution::construct(projAccDistribution.parmSourceDocumentLine(),projAccDistribution.parmMonetaryAmount(), adjustmentAmount,correctionFundingSource);
                correctionDistributions.addEnd(correctionDistribution);
                this.addCostDistribution(correctionDistribution.parmFundingSource(), adjustmentAmount);
            }
        }
        if (correctionDistributions.elements() != 0)
        {
            costDistributionsList = this.mergeLists(costDistributionsList, correctionDistributions);
        }

        // Check the Sales Distibutions
        correctionDistributions = new List(Types::Class);

        enumerateList = inputRevenueList.getEnumerator();
        while (enumerateList.moveNext())
        {
            projAccDistribution = enumerateList.current();
            checkAmount = this.getAmountBasedOnDistribionProperties(saleDistributionsList, projAccDistribution.parmSourceDocumentLine(), projAccDistribution.parmMonetaryAmount());
            if (projAccDistribution.parmAmount() !=checkAmount)
            {
                adjustmentAmount    = projAccDistribution.parmAmount() - checkAmount;

                correctionDistribution = projAccDistribution::construct(projAccDistribution.parmSourceDocumentLine(),projAccDistribution.parmMonetaryAmount(), adjustmentAmount,correctionFundingSource);
                correctionDistributions.addEnd(correctionDistribution);
                if (useFundingLimits == true)
                {
                    this.updateFundingLimitsAllocated(_projSplitBill, correctionDistribution.parmFundingSource(), adjustmentAmount);
                }
                this.addSalesDistribution(correctionDistribution.parmFundingSource(), adjustmentAmount);
            }
        }
        if (correctionDistributions.elements() != 0)
        {
            saleDistributionsList = this.mergeLists(saleDistributionsList, correctionDistributions);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes a new instance of the <c>ProjFundingEngine</c> class.
    /// </summary>
    /// <param name="_projTrans">
    ///     An instance of <c>ProjTrans</c> class that represents the transaction to process.
    /// </param>
    /// <param name="_totalCost">
    ///     The total cost of the transaction for processing.
    /// </param>
    /// <param name="_totalRevenue">
    ///     The total revenue of the transaction for processing.
    /// </param>
    /// <param name="_posting">
    ///     The transaction is journalizing the amounts.
    /// </param>
    /// <param name="_useFundingLimits">
    ///     Apply funding limits when processing the transation.
    /// </param>
    /// <returns>
    ///     A new instance of the <c>ProjFundingEngine</c> class.
    /// </returns>
    public static ProjFundingEngine construct(
        ProjTrans   _projTrans,
        AmountCur   _totalCost,
        AmountCur   _totalRevenue,
        boolean     _posting = true,
        boolean     _useFundingLimits = true)
    {
        List                    inputCostList;
        List                    inputRevenueList;
        projAccDistribution     projAccDistribution;

        inputCostList       = new List(Types::Class);
        inputRevenueList    = new List(Types::Class);

        //create  costList, RevenueList to be passed to construct_ex
        projAccDistribution = projAccDistribution::construct(0, MonetaryAmount::ExtendedPrice, _totalCost, 0);
        inputCostList.addEnd(projAccDistribution);

        projAccDistribution = projAccDistribution::construct(0, MonetaryAmount::ExtendedPrice, _totalRevenue, 0);
        inputRevenueList.addEnd(projAccDistribution);

        return ProjFundingEngine::construct_ex(_projTrans, inputCostList, inputRevenueList, _posting, _useFundingLimits);
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct_ex</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes a new instance of the <c>ProjFundingEngine</c> class.
    /// </summary>
    /// <param name="_projTrans">
    ///     An instance of <c>ProjTrans</c> class that represents the transaction to process.
    /// </param>
    /// <param name="_totalCostList">
    ///     A list of costs for the transaction based on source document line, monetary type and amount
    /// </param>
    /// <param name="_totalRevenueList">
    ///     A list of revenue for the transaction based on source document line, monetary type and amount
    /// </param>
    /// <param name="_posting">
    ///     The transaction is journalizing the amounts.
    /// </param>
    /// <param name="_useFundingLimits">
    ///     Apply funding limits when processing the transation.
    /// </param>
    /// <returns>
    ///     A new instance of the <c>ProjFundingEngine</c> class.
    /// </returns>
    public static ProjFundingEngine construct_ex(
        ProjTrans   _projTrans,
        List        _totalCostList,
        List        _totalRevenueList,
        boolean     _posting = true,
        boolean     _useFundingLimits = true)
    {
        ProjFundingEngine    retProjFundingEngine;

        retProjFundingEngine = new ProjFundingEngine();
        retProjFundingEngine.init(_projTrans, _totalCostList, _totalRevenueList, _posting, _useFundingLimits);

        return retProjFundingEngine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>contractAmount2curAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Converts an amount in contract currency to the transaction currency
    /// </summary>
    /// <param name="_projId">
    ///     The project Id
    /// </param>
    /// <param name="_amount">
    ///     The amount in the contract's currency
    /// </param>
    /// <param name="_trxCurrencyCode">
    ///     The transaction's currency code
    /// </param>
    /// <param name="_exchRateDate">
    ///     Optional, The exchange rate. Default is current system date.
    /// </param>
    /// <param name="_rounding">
    ///     Optional, round results to tranaction currency settings. Defualt is true
    /// </param>
    /// <returns>
    ///     The amount in transaction currency
    /// </returns>
    public static AmountCur contractAmount2curAmount(
        ProjId          _projId,
        Amount          _amount,
        CurrencyCode    _trxCurrencyCode,
        TransDate       _exchRateDate   = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
        boolean         _rounding       = true)
    {
        AmountCur           amountCur = _amount;
        CurrencyCode        companyCurrencyCode;
        CurrencyCode        contractCurrencyCode;
        ExchRate            exchRate;
        ProjInvoiceProjId   projInvoiceProjId;

        companyCurrencyCode = Ledger::accountingCurrency();
        projInvoiceProjId = ProjTable::find(_projId).ProjInvoiceProjId;
        contractCurrencyCode = ProjInvoiceTable::find(projInvoiceProjId).CurrencyId;

        if (projInvoiceProjId != '')
        {
            if (_trxCurrencyCode != contractCurrencyCode)
            {
                if (_trxCurrencyCode && contractCurrencyCode)
                {
                    if (contractCurrencyCode != companyCurrencyCode)
                    {
                        //Convert from Contract Currency to MST
                        // Return Fixed Exchange Rate for Contract, if it exists
                        exchRate = ProjInvoiceCurrency::find(projInvoiceProjId, contractCurrencyCode).ExchRate;
                        amountCur = CurrencyExchangeHelper::mstAmount(_amount, contractCurrencyCode, _exchRateDate, UnknownNoYes::Unknown, exchRate, 0, false);
                    }

                    if (_trxCurrencyCode != companyCurrencyCode)
                    {
                        // Convert from MST to transaction currency
                        // Return Fixed Exchange Rate for Contract, if it exists
                        exchRate = ProjInvoiceCurrency::find(projInvoiceProjId, _trxCurrencyCode).ExchRate;
                        amountCur = CurrencyExchangeHelper::curAmount(amountCur, _trxCurrencyCode, _exchRateDate, UnknownNoYes::Unknown, exchRate, 0, false);
                    }
                }

                if (_rounding)
                {
                    amountCur = CurrencyExchangeHelper::amount(amountCur, _trxCurrencyCode);
                }
            }
        }

        return amountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>curAmount2AmountOfContract</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Converts an amount in transaction currency to the contract currency
    /// </summary>
    /// <param name="_projId">
    ///     The project Id
    /// </param>
    /// <param name="_amount">
    ///     The amount in the transaction's currency
    /// </param>
    /// <param name="_currencyCode">
    ///     The contracts's currency code
    /// </param>
    /// <param name="_exchRateDate">
    ///     Optional, The exchange rate. Default is current system date.
    /// </param>
    /// <param name="_rounding">
    ///     Optional, round results to tranaction currency settings. Defualt is true
    /// </param>
    /// <returns>
    ///     The amount in the contract currency
    /// </returns>
    public static AmountCur curAmount2AmountOfContract(
        ProjId          _projId,
        Amount          _amount,
        CurrencyCode    _currencyCode,
        TransDate       _exchRateDate   = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
        boolean         _rounding       = true)
    {
        AmountCur           amountCur = _amount;
        CurrencyCode        companyCurrencyCode;
        CurrencyCode        contractCurrencyCode;
        ExchRate            exchRate;
        ProjInvoiceProjId   projInvoiceProjId;

        companyCurrencyCode = Ledger::accountingCurrency();
        projInvoiceProjId = ProjTable::find(_projId).ProjInvoiceProjId;
        contractCurrencyCode = ProjInvoiceTable::find(projInvoiceProjId).CurrencyId;

        if (projInvoiceProjId != '')
        {
            if (_currencyCode != contractCurrencyCode)
            {
                if (_currencyCode && contractCurrencyCode)
                {
                    if (_currencyCode != companyCurrencyCode)
                    {
                        //Convert from Transaction Currency to MST
                        // Return Fixed Exchange Rate for Contract, if it exists
                        exchRate = ProjInvoiceCurrency::find(projInvoiceProjId, _currencyCode).ExchRate;
                        amountCur = CurrencyExchangeHelper::mstAmount(_amount, _currencyCode, _exchRateDate, UnknownNoYes::Unknown, exchRate, 0, false);
                    }

                    if (contractCurrencyCode != companyCurrencyCode)
                    {
                        // Convert from MST to Contract Currency
                        // Return Fixed Exchange Rate for Contract, if it exists
                        exchRate = ProjInvoiceCurrency::find(projInvoiceProjId, contractCurrencyCode).ExchRate;
                        amountCur = CurrencyExchangeHelper::curAmount(amountCur, contractCurrencyCode, _exchRateDate, UnknownNoYes::Unknown, exchRate, 0, false);
                    }
                }

                if (_rounding)
                {
                    amountCur = CurrencyExchangeHelper::amount(amountCur, contractCurrencyCode);
                }
            }
        }

        return amountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>distributeQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Distributes the quantity among funding sources based on allocated percentages.
    /// </summary>
    /// <param name="_splitList">
    /// A list of <c>ProjSplitAllocation</c> objects.
    /// </param>
    /// <param name="_qty">
    /// The quantity to be distributed among funding sources.
    /// </param>
    /// <returns>
    /// A map that contains the funding sources.
    /// </returns>
    public static Map distributeQty( List _splitList, Qty _qty)
    {
        ListEnumerator      enumerator;
        int64               allocateRoundingFundingSource;
        int64               lastFundingSource;
        Map                 qtyDistributionMap;
        ProjSplitAllocation allocation;
        real                allocPercentage;
        Qty                 qtyToMap;
        Qty                 qtyToSplit;
        int64               allocateFundingSourceLoc;
        Qty                 qtyToAddLoc;

        qtyDistributionMap = new Map(Types::Int64, Types::Real);
        qtyToSplit  = _qty;

        if (_splitList.empty())
        {
            // No Contract, Item Reversal
            qtyDistributionMap.insert( 0, qtyToSplit );
        }
        else
        {
            enumerator = _splitList.getEnumerator();
            while ( enumerator.moveNext() )
            {
                allocation = enumerator.current();
                allocPercentage = percent( allocation.parmPercent(), 10000) ;
                qtyToMap = allocPercentage * _qty;

                allocateFundingSourceLoc = allocation.parmFundingSourceRefRecId();

                if (qtyDistributionMap.exists(allocateFundingSourceLoc))
                {
                    qtyToAddLoc = qtyDistributionMap.lookup(allocateFundingSourceLoc) + qtyToMap;
                    qtyDistributionMap.remove(allocateFundingSourceLoc);
                    qtyDistributionMap.insert(allocateFundingSourceLoc, qtyToAddLoc);
                }
                else
                {
                    qtyDistributionMap.insert(allocateFundingSourceLoc, qtyToMap);
                }
                qtyToSplit -= qtyToMap;

                lastFundingSource = allocation.parmFundingSourceRefRecId()    ;

                if (allocation.parmIsAllocateRounding())
                {
                    allocateRoundingFundingSource = allocation.parmFundingSourceRefRecId() ;
                }
            }

            // Handle qty for Rounding Funding Source
            if (qtyToSplit != 0.0)
            {
                if (allocateRoundingFundingSource == 0)
                {
                    // Rounding account not specified.
                    throw error("@SYS136009");
                }
                else
                {
                    if (qtyDistributionMap.exists(allocateRoundingFundingSource))
                    {
                        qtyToMap = qtyDistributionMap.lookup(allocateRoundingFundingSource) + qtyToSplit;
                        qtyDistributionMap.remove(allocateRoundingFundingSource);
                        qtyDistributionMap.insert(allocateRoundingFundingSource, qtyToMap);
                    }
                    else
                    {
                        qtyToMap = qtyDistributionMap.lookup(lastFundingSource) + qtyToSplit;
                        qtyDistributionMap.remove(lastFundingSource);
                        qtyDistributionMap.insert(lastFundingSource, qtyToMap);
                    }
                }
            }
        }

        return qtyDistributionMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAmountWithinFundingLimits</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns whether the amount is within the funding limits of the contract
    /// </summary>
    /// <param name="projTrans">
    ///     A project transaction
    /// </param>
    /// <param name="_fundingSourceRefId">
    ///     The funding source
    /// </param>
    /// <param name="_amountInTrxCurrency">
    ///     Amount in transaction currency
    /// </param>
    /// <returns>
    ///     Returns true if the amount is within all funding limits, otherwise false
    /// </returns>
    public static boolean isAmountWithinFundingLimits(
        ProjTrans               projTrans,
        ProjFundingSourceRefId  _fundingSourceRefId,
        AmountCur               _amountInTrxCurrency)
    {
        ProjSplitBill           projSplitBill;
        QueryRun                listOfLimits;
        ProjFundingLimit        projFundingLimit;
        ProjLineProperty        projLineProperty;
        AmountCur               amountInContractCurrency;

        // For the case of retention, the calculation  of the amount in the tracking funding limit tracking table is
        // calculated by multiplication of accounting distribution allocation factor and retention percentage.
        // As for the case of tax, it is calculated by division of the total line amount times the receive amount to be invoiced.
        // Hence it is unavoidable to have rounding error and hence the rounding adjustment is required.
        // If this rounding adjustment is not used, then it may report false positive that the funding limit is exceeded.
        const real roundingAdjustment = 0.03;

        if (!ProjFundingLimit::existForContract(ProjFundingEngine::findProjInvoiceProjId(projTrans)))
        {
            return true;
        }

        projLineProperty = ProjLineProperty::find(projTrans.linePropertyId());
        if (projLineProperty)
        {
            // Only update limits for transaction To be Invoiced
            if (!projLineProperty.ToBeInvoiced)
            {
                return true;
            }
        }

        if (!ProjInvoiceTable::isBillingRuleInvoiceable(projTrans.projId(), projTrans.categoryId(), projTrans.psaContractLineNum(), projTrans.transType()))
        {
            return true;
        }

        projSplitBill = ProjSplitBill::construct(projTrans);
        listOfLimits = projSplitBill.getTransLimits();
        listOfLimits.reset();

        while (listOfLimits.next())
        {
            projFundingLimit = listOfLimits.get(tableNum(ProjFundingLimit));
            if (projFundingLimit.FundingSource == _fundingSourceRefId || projFundingLimit.FundingSource == 0)
            {
                amountInContractCurrency = ProjFundingEngine::curAmount2AmountOfContract(projTrans.projId(), _amountInTrxCurrency, projTrans.currencyIdSales(), projTrans.transDate());
                if (amountInContractCurrency > 0)
                {
                    // Don't include pending credit amounts in computing how much can be spent.
                    AmountCur trackedAmount = ProjFundingLimitTrackingManager::getTrackedAmount(projFundingLimit.RecId, ProjSDLineTrackingType::All);
                    AmountCur spentPlusCommitAmount = projFundingLimit.LimitSpent + trackedAmount + amountInContractCurrency;
                    if ( spentPlusCommitAmount - projFundingLimit.AmountMst > roundingAdjustment)
                    {
                        return false;
                    }
                }
                else
                {
                    // Credit - Don't credit more than has been spent + pending credit amounts
                    if ( projFundingLimit.LimitSpent + ProjFundingLimitTrackingManager::getTrackedAmount(projFundingLimit.RecId, ProjSDLineTrackingType::Credit) + amountInContractCurrency < 0.00)
                    {
                        return false;
                    }
                }
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Distributes the amount among funding sources on the basis allocated percentages.
    /// </summary>
    /// <param name="_splitList">
    /// A list of instances of the <c>ProjSplitAllocation</c> class.
    /// </param>
    /// <param name="_amount">
    /// The amount to distribute among funding sources.
    /// </param>
    /// <param name="_currenyCode">
    /// The currency code that is used for the rounding of currency.
    /// </param>
    /// <returns>
    /// A map that contains the funding sources.
    /// </returns>
    public static Map ledgerDistributions(List _splitList, AmountCur _amount, CurrencyCode _currenyCode)
    {
        Map amountDistributionMap = new Map(Types::Int64, Types::Real);
        AmountCur amountToSplit  = CurrencyExchangeHelper::amount(_amount, _currenyCode);

        if (_splitList.empty())
        {
            // No Contract, Item Reversal
            amountDistributionMap.insert(0, amountToSplit);
        }
        else
        {
            int64 allocateRoundingFundingSource;
            ProjSplitAllocation allocation;
            real allocPercentage;
            AmountCur amountToMap;
            AmountCur amountToAddLoc;
            int64 allocateFundingSourceLoc;
            AmountCur amountToSplit_Ori = amountToSplit;
            
            ListEnumerator enumerator = _splitList.getEnumerator();
            while (enumerator.moveNext())
            {
                allocation = enumerator.current();
                allocPercentage = percent( allocation.parmPercent(),10000) ;
                amountToMap = CurrencyExchangeHelper::amount(allocPercentage * _amount, _currenyCode);

                allocateFundingSourceLoc = allocation.parmFundingSourceRefRecId();

                if (amountDistributionMap.exists(allocateFundingSourceLoc))
                {
                    amountToAddLoc = amountDistributionMap.lookup(allocateFundingSourceLoc) + amountToMap;
                    amountDistributionMap.remove(allocateFundingSourceLoc);
                    amountDistributionMap.insert(allocateFundingSourceLoc, amountToAddLoc);
                }
                else
                {
                    amountDistributionMap.insert(allocateFundingSourceLoc, amountToMap);
                }
                amountToSplit -= amountToMap;

                if (allocation.parmIsAllocateRounding())
                {
                    allocateRoundingFundingSource = allocation.parmFundingSourceRefRecId() ;
                }
            }

            // Handle amount for Rounding Funding Source
            if (amountToSplit != 0.0)
            {
                if (allocateRoundingFundingSource == 0)
                {
                    if (amountDistributionMap.elements() == 1
                        && allocateFundingSourceLoc == 0
                        && ProjNoFundingSourceLedgerDistributeFixFlight::instance().isEnabled())
                    {
                        // No funding source scenario - directly add total of amountToSplit to avoid rounding issue
                        amountDistributionMap.remove(allocateFundingSourceLoc);
                        amountDistributionMap.insert(allocateFundingSourceLoc, amountToSplit_Ori);
                    }
                    else
                    {
                        // Rounding account not specified.
                        throw error("@SYS136009");
                    }
                }
                else
                {
                    if (amountDistributionMap.exists(allocateRoundingFundingSource))
                    {
                        amountToMap = amountDistributionMap.lookup(allocateRoundingFundingSource) + amountToSplit;
                        amountDistributionMap.remove(allocateRoundingFundingSource);
                        amountDistributionMap.insert(allocateRoundingFundingSource, amountToMap);
                    }
                    else
                    {
                        amountDistributionMap.insert(allocateRoundingFundingSource, amountToSplit);
                    }
                }
            }
        }
        return amountDistributionMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFundingLimits</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Update the funding limit based on the information provided.
    /// </summary>
    /// <param name="projTrans">
    ///     A project transaction
    /// </param>
    /// <param name="_fundingSourceRefId">
    ///     The funding source
    /// </param>
    /// <param name="_amountInTrxCurrency">
    ///     The amount in transaction's currency
    /// </param>
    /// <param name="_allowNegSpent">
    ///     Optional, allow spent amount to become negative. Default is true
    /// </param>
    /// <param name="_throwError">
    ///     Optional, throw an error message. Default is false
    /// </param>
    /// <param name="_errorMessage">
    ///     Optional, message to be returned on error.
    /// </param>
    public static void updateFundingLimits(ProjTrans                projTrans,
                                           ProjFundingSourceRefId   _fundingSourceRefId,
                                           AmountCur                _amountInTrxCurrency,
                                           boolean                  _allowNegSpent = true,
                                           boolean                  _throwError = false,
                                           str                      _errorMessage = "@SYS136009"
    )
    {
        ProjSplitBill           projSplitBill;
        QueryRun                listOfLimits;
        ProjFundingLimit        projFundingLimit;
        RecId                   projFundingLimitRecId;
        ProjLineProperty        projLineProperty;
        ProjTable               projTable;

        AmountCur               amountInContractCurrency;

        // For the case of retention, the calculation  of the amount in the tracking funding limit tracking table is
        // calculated by multiplication of accounting distribution allocation factor and retention percentage.
        // As for the case of tax, it is calculated by division of the total line amount times the receive amount to be invoiced.
        // Hence it is unavoidable to have rounding error and hence the rounding adjustment is required.
        // If this rounding adjustment is not used, then it may report false positive that the funding limit is exceeded.
        const real roundingAdjustment = 0.03;

        projTable = ProjTable::find(projTrans.projId());

        // No funding limits exist for contract
        if (!ProjFundingLimit::existForContract(ProjFundingEngine::findProjInvoiceProjId(projTrans)))
        {
            return;
        }

        projLineProperty = ProjLineProperty::find(projTrans.linePropertyId());
        if (projLineProperty)
        {
            // Only update limits for transaction To be Invoiced
            if (!projLineProperty.ToBeInvoiced)
            {
                return;
            }
        }

        if (!ProjInvoiceTable::isBillingRuleInvoiceable(projTable.ProjId, projTrans.categoryId(), projTrans.psaContractLineNum(), projTrans.transType()))
        {
            return;
        }

        // Convert Amount to Contract Currency
        amountInContractCurrency = ProjFundingEngine::curAmount2AmountOfContract(projTrans.projId(), _amountInTrxCurrency, projTrans.currencyIdSales(), projTrans.transDate());

        projSplitBill = ProjSplitBill::construct(projTrans);
        listOfLimits = projSplitBill.getTransLimits();
        listOfLimits.reset();

        while (listOfLimits.next())
        {
            projFundingLimit = listOfLimits.get(tableNum(ProjFundingLimit));
            if (projFundingLimit.FundingSource == _fundingSourceRefId || projFundingLimit.FundingSource == 0)
            {
                ttsbegin;
                projFundingLimitRecId = projFundingLimit.RecId;
                projFundingLimit = ProjFundingLimit::find(projFundingLimitRecId, true);
                projFundingLimit.LimitSpent += amountInContractCurrency;
                if ( (projFundingLimit.LimitSpent < 0.0) && (_allowNegSpent == false))
                {
                    projFundingLimit.LimitSpent = 0.0;
                }
                if ( _throwError )
                {
                    if (projFundingLimit.AmountMst - projFundingLimit.LimitSpent < -roundingAdjustment)
                    {
                        throw error(_errorMessage);
                    }
                }
                projFundingLimit.update();

                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFundTrackingForDistribution</Name>
				<Source><![CDATA[
    public static List setFundTrackingForDistribution(
        AccountingDistribution          _accountingDistribution,
        ProjectAccountingDistribution   _projectAccountingDistribution,
        AmountCur               _amountInTrxCurrency)
    {
        ProjTrans                       projTrans;
        ProjSplitBill                   projSplitBill;
        QueryRun                        listOfLimits, listOfRules;
        ProjLineProperty                projLineProperty;

        ProjFundingLimit                projFundingLimit;
        AmountCur                       contractCurrencyAmount;
        AmountCur                       trackedAmount;
        AmountCur                       currentFundingSourceAmount;

        container                       retval = [true, false, 0, 0];
        List                            copyListFundingLimit = new List(Types::Record);
        List                            listOfFundingLimits = new List(Types::Record);
        ListEnumerator                  listEnumerator;
        RefRecId                        lastFundingLimit;

        ProjFundingRuleAllocation       projFundingRuleAllocation;
        ProjTable                       projTable;
        ProjFundingSource               projFundingSource;
        boolean                         displayError = true;
        ProjectAccountingDistribution   localProjectAccountingDistribution;

        void insertNewFundingLimitTracking(RefRecId _projFundingLimitRecId, AmountCur _amountTracked, NoYes _hasLimitError)
        {
            ProjFundingLimitTracking        projFundingLimitTracking;

            projFundingLimitTracking.clear();
            projFundingLimitTracking.ProjFundingLimit               = _projFundingLimitRecId;
            projFundingLimitTracking.SourceDocumentHeader           = _accountingDistribution.SourceDocumentHeader;
            projFundingLimitTracking.SourceDocumentLine             = _accountingDistribution.SourceDocumentLine;
            projFundingLimitTracking.AccountingDistribution         = _accountingDistribution.RecId;
            projFundingLimitTracking.ProjectAccountingDistribution  = _projectAccountingDistribution.RecId;
            projFundingLimitTracking.sdCreditLine                   = NoYes::No;
            projFundingLimitTracking.Reversing                      = NoYes::No;
            projFundingLimitTracking.Amount                         = _amountTracked;
            projFundingLimitTracking.LimitError                     = _hasLimitError;
            projFundingLimitTracking.insert();

            copyListFundingLimit.addEnd(projFundingLimitTracking);
        }

        projTrans = ProjFundingLimitTrackingManager::createProjTransFromProjDist(_projectAccountingDistribution, _accountingDistribution);

        projTable = ProjTable::find(projTrans.projId());

        projLineProperty = ProjLineProperty::find(projTrans.linePropertyId());
        if (projLineProperty)
        {
            // Only update limits for transaction To be Invoiced
            if (!projLineProperty.ToBeInvoiced)
            {
                return copyListFundingLimit;
            }
        }

        if (!ProjInvoiceTable::isBillingRuleInvoiceable(projTrans.projId(), projTrans.categoryId(), projTrans.psaContractLineNum(), projTrans.transType()))
        {
            return copyListFundingLimit;
        }

        projSplitBill = ProjSplitBill::construct(projTrans);
        listOfRules = projSplitBill.buildRuleQR();  //This is the query to get the list of Funding Rules with PRIORITY and ALLOCATION

        listOfLimits = projSplitBill.getTransLimits();  // This is the query to get all the Funding Limits

        listOfLimits.reset();

        //Cache the Funding Limits query result
        while (listOfLimits.next())
        {
            listOfFundingLimits.addEnd(listOfLimits.get(tableNum(ProjFundingLimit)));
        }

        listEnumerator = listOfFundingLimits.getEnumerator();

        if (listOfFundingLimits.empty())
        {
            return copyListFundingLimit;
        }

        contractCurrencyAmount = ProjFundingEngine::curAmount2AmountOfContract(projTrans.projId(), _amountInTrxCurrency, projTrans.currencyIdSales(), projTrans.transDate());

        // For each rule, we need to get the funding limit's funding source and allocate
        while (listOfRules.next())
        {
            projFundingRuleAllocation = listOfRules.get(tableNum(ProjFundingRuleAllocation));

            while (listEnumerator.moveNext() && contractCurrencyAmount > 0)
            {
                projFundingLimit = listEnumerator.current();

                if (projFundingRuleAllocation.FundingSource == projFundingLimit.FundingSource && _projectAccountingDistribution.ProjFundingSource == projFundingLimit.FundingSource)
                {
                    trackedAmount = ProjFundingLimitTrackingManager::getTrackedAmount(projFundingLimit.RecId, ProjSDLineTrackingType::Standard);

                    currentFundingSourceAmount = projFundingLimit.AmountMst - (projFundingLimit.LimitSpent + trackedAmount);

                    if (contractCurrencyAmount > 0)
                    {
                        insertNewFundingLimitTracking(projFundingLimit.RecId, contractCurrencyAmount, NoYes::No);
                        contractCurrencyAmount -= currentFundingSourceAmount;
                    }

                    lastFundingLimit = projFundingLimit.RecId;
                }
            }

            if (contractCurrencyAmount <= 0)
            {
                break;
            }
            else
            {
                listEnumerator.reset();
            }
        }

        if (contractCurrencyAmount > 0)
        {
            if (projTable.ProjInvoiceProjId)
            {
                // Find the OnHold funding source for the contract
                select firstonly RecId from projFundingSource
                    where projFundingSource.ContractId == projTable.ProjInvoiceProjId &&
                          projFundingSource.FundingType == ProjFundingType::OnHoldFundingSource;

                if (projFundingSource.RecId != 0)
                {
                    localProjectAccountingDistribution = ProjectAccountingDistribution::find(_projectAccountingDistribution.RecId, true);
                    localProjectAccountingDistribution.TransactionCurrencyAmount = contractCurrencyAmount;
                    localProjectAccountingDistribution.ProjFundingSource = projFundingSource.RecId;
                    localProjectAccountingDistribution.doUpdate();

                    displayError = false;
                }
            }

            if (displayError)
            {
                insertNewFundingLimitTracking(lastFundingLimit, contractCurrencyAmount, NoYes::Yes);
                checkFailed("@SYS4110062");
            }
        }

        return copyListFundingLimit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findProjInvoiceProjId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>ProjInvoiceProjId</c> value based on the specified <c>ProjTrans</c> instance.
    /// </summary>
    /// <param name = "_projTrans">
    /// A <c>ProjTrans</c> instance.
    /// </param>
    /// <returns>
    /// A <c>ProjInvoiceProjId</c> value.
    /// </returns>
    protected static ProjInvoiceProjId findProjInvoiceProjId(ProjTrans _projTrans)
    {
        return ProjTable::find(_projTrans.projId()).ProjInvoiceProjId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSingleFundingSourceRefId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the funding source reference Id to be use when processing for a specific funding source.
    /// </summary>
    /// <param name="_singleFundingSourceRefId">
    /// A funding source reference Id.
    /// </param>
    public void setSingleFundingSourceRefId(ProjFundingSourceRefId _singleFundingSourceRefId)
    {
        singleFundingSourceRefId = _singleFundingSourceRefId;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>