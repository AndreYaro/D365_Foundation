<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SalesUpdateConfirmDatesCommand</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>SalesUpdateConfirmDatesCommand</c> class implements logic to set confirmed dates for a <c>SalesTable</c> record and the related <c>SalesLines</c> records.
/// </summary>
class SalesUpdateConfirmDatesCommand extends RunBaseBatch implements BatchRetryable
{
    #define.optionButtonChecked(1)

    TransDate                           shipDateSalesTable;
    TransDate                           receiptDateSalesTable;
    boolean                             rereadDataSources;

    SalesTable                          salesTable;
    SalesShippingDateLatestAllowed      shippingDateLatestAllowed;
    SalesDeliveryDateControlType        deliveryDateControlType;
    SalesAllowMultipleShipDates         allowMultipleShipDates;
    SalesTableUpdateConfirmedDates      salesTableUpdateConfirmedDates;
    SalesLineUpdateConfirmedDates       salesLineUpdateConfirmedDates;
    SalesLineAllowNewConfirmedDates     salesLineAllowNewConfirmedDates;
    SalesLineUpdateDeliverDateControl   salesLineUpdateDeliverDateControl;
    boolean                             isSalesLineDeliveryControlOverRuled;

    Dialog                              dialog;
    DialogField                         dfSalesId;
    DialogField                         dfShippingDateLatestAllowed;
    DialogField                         dfDeliveryDateControlType;
    DialogField                         dfAllowMultipleShipDates;
    DialogField                         dfSalesTableUpdateConfirmedDates;
    DialogField                         dfSalesLineUpdateConfirmedDates;
    DialogField                         dfSalesLineAllowNewConfirmedDates;
    DialogField                         dfSalesLineUpdateDeliverDateControl;
    DialogGroup                         dgSalesLineOverRuled;

    private boolean areConfirmedDatesClearedOnAnySalesLinesWithFullRunCTP = false;

    #LOCALMACRO.Version2List
        salesTable,
        shippingDateLatestAllowed,
        deliveryDateControlType,
        allowMultipleShipDates,
        salesTableUpdateConfirmedDates,
        salesLineUpdateConfirmedDates,
        salesLineAllowNewConfirmedDates,
        salesLineUpdateDeliverDateControl,
        isSalesLineDeliveryControlOverRuled,
        rereadDataSources
    #ENDMACRO

    #DEFINE.CurrentVersion(3)
    #LOCALMACRO.CurrentList
        salesTable,
        shippingDateLatestAllowed,
        deliveryDateControlType,
        allowMultipleShipDates,
        salesTableUpdateConfirmedDates,
        salesLineUpdateConfirmedDates,
        salesLineAllowNewConfirmedDates,
        salesLineUpdateDeliverDateControl,
        isSalesLineDeliveryControlOverRuled,
        rereadDataSources,
        shipDateSalesTable,
        receiptDateSalesTable
    #ENDMACRO
    
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>caption</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a caption of the <c>RunBaseBatch</c> dialog box.
    /// </summary>
    /// <returns>
    /// A String value that holds the caption of the <c>RunBaseBatch</c> dialog box.
    /// </returns>
    public ClassDescription caption()
    {
        return "@SYS324456";
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCloseDialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the settings that are provided in the dialog box are valid, which lets the user
    /// continue and close the dialog box.
    /// </summary>
    /// <param name="calledFrom">
    /// An object that represents the calling object.
    /// </param>
    /// <returns>
    /// true if settings in the dialog box are valid; otherwise, false.
    /// </returns>
    public boolean checkCloseDialog(Object calledFrom = null)
    {
        boolean ret = super(calledFrom);

        if (   isSalesLineDeliveryControlOverRuled
            && deliveryDateControlType == SalesDeliveryDateControlType::None)
        {
            ret = checkFailed(strFmt("@SYS324461",deliveryDateControlType));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deliveryDateControlTypeForced</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a force delivery date control type applies.
    /// </summary>
    /// <returns>
    /// An enumeration value of type <c>SalesDeliveryDateControlType</c> that represents a forced delivery
    /// date control type.
    /// </returns>
    protected SalesDeliveryDateControlType  deliveryDateControlTypeForced()
    {
        if (   isSalesLineDeliveryControlOverRuled
            && deliveryDateControlType != SalesDeliveryDateControlType::None)
        {
            return deliveryDateControlType;
        }

        return  SalesDeliveryDateControlType::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the user dialog box by adding groups and fields.
    /// </summary>
    /// <returns>
    /// A <c>Dialog</c> object.
    /// </returns>
    public Object dialog()
    {
        dialog = super(); 

        dfSalesId                           = dialog.addField(extendedTypeStr(SalesId));
        dfSalesId.allowEdit(false);

        dfShippingDateLatestAllowed         = dialog.addField(extendedTypeStr(SalesShippingDateLatestAllowed));

        dgSalesLineOverRuled = dialog.addGroup("@SYS323575");
        dgSalesLineOverRuled.frameOptionButton(FormFrameOptionButton::Check);
        dfDeliveryDateControlType           = dialog.addField(enumStr(SalesDeliveryDateControlType));
        dfSalesLineUpdateDeliverDateControl = dialog.addField(extendedTypeStr(SalesLineUpdateDeliverDateControl));

        DialogGroup dlgSalesTable = dialog.addGroup("@SYS9694");
        dfAllowMultipleShipDates            = dialog.addField(extendedTypeStr(SalesAllowMultipleShipDates));
        dfSalesTableUpdateConfirmedDates    = dialog.addField(extendedTypeStr(SalesTableUpdateConfirmedDates));

        DialogGroup dlgSalesLine = dialog.addGroup("@SYS324462");

        dfSalesLineUpdateConfirmedDates     = dialog.addField(extendedTypeStr(SalesLineUpdateConfirmedDates));
        dfSalesLineAllowNewConfirmedDates   = dialog.addField(extendedTypeStr(SalesLineAllowNewConfirmedDates));

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogPostRun</Name>
				<Source><![CDATA[
    public void dialogPostRun(DialogRunbase _dialog)
    {
        this.initParm();

        super(_dialog);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFixedShipDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the latest ship date for all sales lines that are related to the specified sales order.
    /// </summary>
    /// <returns>
    /// A date value that represents the latest ship date.
    /// </returns>
    protected TransDate  findFixedShipDate()
    {
        TransDate                           maxShipDate;

        if (allowMultipleShipDates)
        {
            return dateNull();
        }

        // set confirmed dates according a specific strategy (no warnings etc) in order to find latest ship date
        SalesConfirmDatesCommandStrategy strategy = SalesConfirmDatesCommandStrategy::newParameters(this.deliveryDateControlTypeForced(),dateNull(),dateNull(),true);
        strategy.parmForceReqCalcExplodeCoverageDeletion(true);
        strategy.parmAllowMultipleShipDates(allowMultipleShipDates);

        SalesLine salesLine = this.selectSalesLine();
        while (salesLine.RecId)
        {
            this.setConfirmedDates(salesLine,strategy);

            if (salesLine.ShippingDateConfirmed)
            {
                maxShipDate = max(maxShipDate,salesLine.ShippingDateConfirmed);
            }
            next salesLine;
        }

        return maxShipDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Implements logic to retrieves values from the dialog.
    /// </summary>
    /// <returns>
    /// true if the dialog values were retrieved; otherwise, false.
    /// </returns>
    public boolean getFromDialog()
    {
        boolean ret = super();

        shippingDateLatestAllowed           = dfShippingDateLatestAllowed.value();
        deliveryDateControlType             = dfDeliveryDateControlType.value();
        allowMultipleShipDates              = dfAllowMultipleShipDates.value();
        salesTableUpdateConfirmedDates      = dfSalesTableUpdateConfirmedDates.value();
        salesLineUpdateConfirmedDates       = dfSalesLineUpdateConfirmedDates.value();
        salesLineAllowNewConfirmedDates     = dfSalesLineAllowNewConfirmedDates.value();
        salesLineUpdateDeliverDateControl   = dfSalesLineUpdateDeliverDateControl.value();
        isSalesLineDeliveryControlOverRuled = dgSalesLineOverRuled.optionValue();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDfAllowMultipleShipDates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>dfAllowMultipleShipDates</c> dialog box field.
    /// </summary>
    protected  void initDfAllowMultipleShipDates()
    {
        SalesLine       salesLine;

        select firstonly RecId from salesLine
            where  salesLine.SalesId                == salesTable.SalesId
                && salesLine.LineDeliveryType       != LineDeliveryType::OrderLine
                && salesLine.SalesStatus            == SalesStatus::Backorder;

        if (salesLine.RecId == 0)
        {
            dfAllowMultipleShipDates.value(NoYes::No);
        }
        else
        {
            // delivery schedule exists
            dfAllowMultipleShipDates.value(NoYes::Yes);
            dfAllowMultipleShipDates.allowEdit(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the dialog box values.
    /// </summary>
    protected void initParm()
    {
        if (dialog)
        {
            dfSalesId.value(salesTable.SalesId);
            dgSalesLineOverRuled.optionValue(#optionButtonChecked);
            dfDeliveryDateControlType.value(salesTable.DeliveryDateControlType);
            dfShippingDateLatestAllowed.value(salesTable.ShippingDateConfirmed);
            dfSalesLineUpdateConfirmedDates.value(NoYes::Yes);
            this.initDfAllowMultipleShipDates();
            dfSalesLineAllowNewConfirmedDates.value(NoYes::No);

            // dialog fields initialized from last values
            dfSalesTableUpdateConfirmedDates.value(salesTableUpdateConfirmedDates);
            dfSalesLineUpdateDeliverDateControl.value(salesLineUpdateDeliverDateControl);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the dialog box values for the first time or when the default button is clicked.
    /// </summary>
    public void initParmDefault()
    {
        super();

        if (dialog)
        {
            dgSalesLineOverRuled.optionValue(#optionButtonChecked);
            dfSalesLineUpdateConfirmedDates.value(NoYes::Yes);
            dfSalesLineAllowNewConfirmedDates.value(NoYes::No);
            this.initDfAllowMultipleShipDates();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initVariables</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the internal class variables.
    /// </summary>
    protected void initVariables()
    {
        shipDateSalesTable          = dateNull();
        receiptDateSalesTable       = dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRequestedDatesExceeded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the requested dates have been exceeded.
    /// </summary>
    /// <param name="_salesLine">
    /// A <c>SalesLine</c> record that represents a sales line.
    /// </param>
    /// <returns>
    /// true if the requested dates are exceeded; otherwise, false.
    /// </returns>
    protected boolean isRequestedDatesExceeded(SalesLine    _salesLine)
    {
        return _salesLine.ShippingDateConfirmed > _salesLine.ShippingDateRequested
            || _salesLine.ReceiptDateConfirmed  > _salesLine.ReceiptDateRequested;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#currentVersion,#currentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesTable</Name>
				<Source><![CDATA[
    public SalesTable parmSalesTable(SalesTable _salesTable = salesTable)
    {
        salesTable = _salesTable;

        return salesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prefixTextSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the information message text for the specified <c>SalesLine</c> record.
    /// </summary>
    /// <param name="_salesLine">
    /// A <c>SalesLine</c> record that represents a sales line.
    /// </param>
    /// <returns>
    /// A String value that describes the sales line.
    /// </returns>
    protected str prefixTextSalesLine(SalesLine  _salesLine)
    {
        InventDim inventDim = _salesLine.inventDim();

        return strFmt("@SYS324460",
                     #PreFixField(_salesLine,LineNum,_salesLine.LineNum),
                     #PreFixField(_salesLine,ItemId,_salesLine.ItemId),
                     inventDim.preFix(),
                     #PreFixField(_salesLine,RemainSalesPhysical,
                     _salesLine.RemainSalesPhysical),
                     _salesLine.SalesUnit);
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshCallerDatasource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refreshes the caller data sources.
    /// </summary>
    /// <param name="_caller">
    /// An instance of the <c>FormRun</c> class.
    /// </param>
    private void refreshCallerDatasource(FormRun _caller)
    {
        if (_caller && _caller is FormRun)
        {
            FormRun callerForm = _caller;

            if (this.rereadDataSources()
                && callerForm.name() == formStr(SalesTable))
            {
                FormDataSource formDataSource = callerForm.dataSource(tableStr(SalesTable));
                formDataSource.reread();
                formDataSource.refresh();

                formDataSource = callerForm.dataSource(tableStr(SalesLine));
                SalesLine salesLine;
                salesLine.data(formDataSource.cursor());
                formDataSource.research();
                formDataSource.positionToRecord(salesLine);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>rereadDataSources</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the records have been updated, which requires a reread of the data sources.
    /// </summary>
    /// <returns>
    /// true if the data sources must be reread; otherwise, false.
    /// </returns>
    protected boolean rereadDataSources()
    {
        return rereadDataSources;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Implements main logic to confirm the dates for the specified sales order.
    /// </summary>
    /// <exception cref="M:Exception::UpdateConflictNotRecovered">
    /// An unrecovered update conflict occurred.
    /// </exception>
    /// <exception cref="M:Exception::UpdateConflict">
    /// If an update conflict occurred.
    /// </exception>
    public void run()
    {
        #OCCRetryCount

        SalesConfirmDatesCommandStrategy    strategy;
        SalesLine                           salesLine;
        Counter                             numOfConfirmedSalesLines;
        Counter                             numOfSalesLines;

        try
        {
            setPrefix(strFmt("@SYS323569",salesTable.SalesId, salesTable.CustAccount));

            // For online CTP we need to have this update before the calculations
            if (SalesUpdateConfirmDatesOnlineCTPFlight::instance().isEnabled())
            {
                this.updateSalesLinesDeliveryDateControl();
            }

            this.initVariables();

            // Clear the latest allowed shipping date when allowing overwriting of confirmed dates
            if (salesLineAllowNewConfirmedDates)
            {
                shippingDateLatestAllowed = dateNull();
            }

            strategy = this.strategyToConfirmSalesLines();

            ttsbegin;

            if (!allowMultipleShipDates)
            {
                strategy.parmSkipConflictHandling(true);
                strategy.parmNotCalculateConfirmDates(false);

                salesLine = this.selectSalesLine(false);
                while (salesLine.RecId)
                {
                    setPrefix(this.prefixTextSalesLine(salesLine));
                    this.setConfirmedDates(salesLine,strategy);
                    next salesLine;
                }

                strategy.parmSkipConflictHandling(false);
                strategy.parmNotCalculateConfirmDates(true);
                [numOfSalesLines, numOfConfirmedSalesLines] = this.updateSalesLineConfirmDates(strategy);
            }
            else
            {
                [numOfSalesLines, numOfConfirmedSalesLines] = this.updateSalesLineConfirmDates(strategy);
            }

            this.updateSalesTable();

            ttscommit;

            this.runReqTransUpdate();

            info(strFmt("@SYS323574",numOfConfirmedSalesLines,numOfSalesLines));
        }
        catch (Exception::Deadlock)
        {
            retry;
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (ReqTransientSqlConnectionErrorHandlingHelper::retryTransientSqlConnectionError())
            {
                retry;
            }
            else
            {
                throw;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesLineConfirmDates</Name>
				<Source><![CDATA[
    private container updateSalesLineConfirmDates(SalesConfirmDatesCommandStrategy _strategy)
    {
        Counter numOfConfirmedSalesLines;
        Counter numOfSalesLines;
        SalesLine salesLine = this.selectSalesLine(true);
        Set updatedSalesLines = new Set(Types::Int64);
        boolean isExcludeNotUpdatedSalesLinesFlightEnabled = SalesUpdateConfirmDatesExcludeNotUpdatedSalesLinesOfSameItemFlight::instance().isEnabled();

        while (salesLine.RecId)
        {
            setPrefix(this.prefixTextSalesLine(salesLine));

            // If it allows the new confirmed dates, clear the old values and recalculate them.
            if (salesLineAllowNewConfirmedDates)
            {
                salesLine.ShippingDateConfirmed = dateNull();
                salesLine.ReceiptDateConfirmed  = dateNull();
            }

            boolean areConfirmedDatesSet = false;

            if (isExcludeNotUpdatedSalesLinesFlightEnabled)
            {
                using (SalesUpdateConfirmDatesExcludeNotUpdatedSalesLinesContext context = this.createExcludeNotUpdatedSalesLinesContext(salesLine, updatedSalesLines))
                {
                    areConfirmedDatesSet = this.setConfirmedDates(salesLine, _strategy);
                }
            }
            else
            {
                areConfirmedDatesSet = this.setConfirmedDates(salesLine, _strategy);
            }

            if (areConfirmedDatesSet)
            {
                this.updateSalesLine(salesLine);

                if (!this.isRequestedDatesExceeded(salesLine) 
                    && !this.skipLockedSalesLine(salesLine)
                    && !this.areConfirmedDatesCleared(salesLine))
                {
                    numOfConfirmedSalesLines++;
                }
            }
            else
            {
                if (!this.areConfirmedDatesCleared(salesLine) && !this.isRequestedDatesExceeded(salesLine))
                {
                    numOfConfirmedSalesLines++;
                }
            }

            if (isExcludeNotUpdatedSalesLinesFlightEnabled)
            {
                updatedSalesLines.add(salesLine.RecId);
            }

            next salesLine;
            numOfSalesLines++;
        }

        return [numOfSalesLines, numOfConfirmedSalesLines];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createExcludeNotUpdatedSalesLinesContext</Name>
				<Source><![CDATA[
    private SalesUpdateConfirmDatesExcludeNotUpdatedSalesLinesContext createExcludeNotUpdatedSalesLinesContext(SalesLine _currentSalesLine, Set _updatedSalesLineSet)
    {
        SalesUpdateConfirmDatesExcludeNotUpdatedSalesLinesContext context = SalesUpdateConfirmDatesExcludeNotUpdatedSalesLinesContext::construct();

        SalesLine salesLine = this.selectSalesLine(true);

        // Add not-updated lines to context
        while (salesLine)
        {
            if (salesLine.ItemId != _currentSalesLine.ItemId ||
                (salesLine.RecId == _currentSalesLine.RecId || _updatedSalesLineSet.in(salesLine.RecId)))
            {
                next salesLine;
                continue;
            }

            context.addLine(salesLine);

            next salesLine;
        }

        return context;
    }

]]></Source>
			</Method>
			<Method>
				<Name>areConfirmedDatesCleared</Name>
				<Source><![CDATA[
    protected boolean areConfirmedDatesCleared(SalesLine _salesLine)
    {
        boolean ret = !_salesLine.ShippingDateConfirmed || !_salesLine.ReceiptDateConfirmed;

        if (this.isDeliveryDateControlTypeFullRunCTP(_salesLine))
        {
            ret = !_salesLine.ShippingDateConfirmed && !_salesLine.ReceiptDateConfirmed;
            areConfirmedDatesClearedOnAnySalesLinesWithFullRunCTP = areConfirmedDatesClearedOnAnySalesLinesWithFullRunCTP || ret;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDeliveryDateControlTypeFullRunCTP</Name>
				<Source><![CDATA[
    private boolean isDeliveryDateControlTypeFullRunCTP(SalesLine _salesLine)
    {
        if (SalesUpdateConfirmDatesOnlineCTPFlight::instance().isEnabled())
        {
            return _salesLine.DeliveryDateControlType == SalesDeliveryDateControlType ::FullRunCTP;
        }

        return MpsDeliveryDateControlTypeCTPHelper::isDeliveryDateControlTypeMpsCTP(_salesLine.DeliveryDateControlType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>runReqTransUpdate</Name>
				<Source><![CDATA[
    private void runReqTransUpdate()
    {
        if (MpsDeliveryDateControlTypeCTPHelper::isDeliveryDateControlTypeClassicCTP(deliveryDateControlType))
        {
            salesLineAllowNewConfirmedDates = NoYes::Yes;
            SalesLine salesLine = this.selectSalesLine(false);
            Set inventTransOriginRefSet = new Set(Types::Int64);
            Set itemsSet = new Set(Types::String);

            while (salesLine.RecId)
            {
                InventTransOrigin inventTransOrigin = InventTransOrigin::findByInventTransId(salesLine.InventTransId);
                
                // The ship dates were just calculated using CTP. It is safe to perform simple inventsumlogtts rollup for the sales lines which were just recalculated
                inventTransOriginRefSet.add(InventTransOrigin::findByInventTransId(salesLine.InventTransId).RecId);
                itemsSet.add(salesLine.itemId);

                next salesLine;
            }
            SetEnumerator itemsSetEnumerator = itemsSet.getEnumerator();

            while (itemsSetEnumerator.moveNext())
            {
                ReqTransUpdate reqTransUpdate = ReqTransUpdate::newItemId(itemsSetEnumerator.current());
                reqTransUpdate.filterByRefIdAndExcludeType(salesTable.SalesId, InventTransType::Sales);
                reqTransUpdate.parmInventTransOriginsWithSafeDateStatusChange(inventTransOriginRefSet);
                reqTransUpdate.run();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Selects the <c>SalesLine</c> records that must be confirmed.
    /// </summary>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether the records must be selected for update; optional.
    /// </param>
    /// <returns>
    /// A <c>SalesLine</c> record buffer that can be iterated.
    /// </returns>
    protected SalesLine selectSalesLine(boolean     _forUpdate = false)
    {
        SalesLine       salesLine;

        salesLine.selectForUpdate(_forUpdate);

        select salesLine
            where salesLine.SalesId == salesTable.SalesId
            && salesLine.RemainInventPhysical > 0
            && (salesLineAllowNewConfirmedDates
              || (! salesLine.ShippingDateConfirmed
               && ! salesLine.ReceiptDateConfirmed));

        return salesLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setConfirmedDates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the confirmed dates for the specified <c>SalesLine</c> record.
    /// </summary>
    /// <param name="_salesLine">
    /// A <c>SalesLine</c> record that represents a sales line.
    /// </param>
    /// <param name="_strategy">
    /// A <c>SalesConfirmDatesCommandStrategy</c> object that contains the confirm strategy.
    /// </param>
    /// <returns>
    /// true if the confirmed dates were set on the specified sales line; otherwise, false.
    /// </returns>
    protected boolean setConfirmedDates(
        SalesLine                           _salesLine,
        SalesConfirmDatesCommandStrategy    _strategy)
    {
        return _salesLine.type().setConfirmedDates(_strategy);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkConfirmedDatesInSalesCalendar</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check the confirmed dates for the specified <c>SalesLine</c> record in the customer calendar.
    /// </summary>
    /// <param name="_calendarId">
    /// A customer calendar.
    /// </param>
    /// <param name="_receiptDate">
    /// A confirmed receipt date.
    /// </param>
    /// <returns>
    /// true if the dates in the open calendar date; otherwise, false.
    /// </returns>
    protected boolean checkConfirmedDatesInSalesCalendar(SalesCalendarId _calendarId, TransDate _receiptDate)
    {
        boolean ret = true;
        
        if (!WorkCalendarDate::isDateOpen(_calendarId, _receiptDate))
        {
            ret = checkFailed(strFmt("@SYS88283", _receiptDate));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showDefaultButton</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the default button is shown.
    /// </summary>
    /// <returns>
    /// true if the default button must be shown; otherwise, false.
    /// </returns>
    public boolean showDefaultButton()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>strategyToConfirmSalesLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a <c>SalesConfirmDatesCommandStrategy</c> object.
    /// </summary>
    /// <returns>
    /// A <c>SalesConfirmDatesCommandStrategy</c> object that contains the logic to confirm the dates.
    /// </returns>
    protected SalesConfirmDatesCommandStrategy strategyToConfirmSalesLines()
    {
        TransDate fixedShipDate = this.findFixedShipDate();

        SalesConfirmDatesCommandStrategy strategy = SalesConfirmDatesCommandStrategy::newParameters(this.deliveryDateControlTypeForced(),
                                                               shippingDateLatestAllowed,
                                                               fixedShipDate,
                                                               false);

        // If multiple ship dates are not allowed then the pegging will be dropped as part of the calculations in the findFixedShipDate method
        // However if multiple ship dates are allowed then the findFixedShipDate method will not cause explosion and will not drop pegging so we need to do it here.
        strategy.parmForceReqCalcExplodeCoverageDeletion(allowMultipleShipDates);
        strategy.parmAllowMultipleShipDates(allowMultipleShipDates);

        return strategy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container  _packedClass)
    {
        Integer     version = conPeek(_packedClass,1);

        switch (version)
        {
            case 2:
               [version, #Version2List] = _packedClass;
               break;

            case #CurrentVersion:
               [version, #CurrentList] = _packedClass;
               break;

            default :
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDeliveryDateControl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the delivery date control of the specified sales line to the specified delivery date control value.
    /// </summary>
    /// <param name="_salesLine">
    /// A <c>SalesLine</c> record that represents a sales line.
    /// </param>
    protected void updateDeliveryDateControl(SalesLine     _salesLine)
    {
        if (   salesLineUpdateDeliverDateControl
            && isSalesLineDeliveryControlOverRuled
            && deliveryDateControlType != SalesDeliveryDateControlType::None)
        {
            _salesLine.DeliveryDateControlType = deliveryDateControlType;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipLockedSalesLine</Name>
				<Source><![CDATA[
    private boolean skipLockedSalesLine(SalesLine _salesLine)
    {
        return _salesLine.Blocked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the specified <c>SalesLine</c> record.
    /// </summary>
    /// <param name="_salesLine">
    /// A <c>SalesLine</c> record that represents a sales line.
    /// </param>
    protected void updateSalesLine(SalesLine     _salesLine)
    {
        if (salesLineUpdateConfirmedDates)
        {
            if (this.skipLockedSalesLine(_salesLine))
            {
                warning("@SCM:SalesUpdateConfirmDatesSkipBlockedLine");
            }
            else
            {
                // For online CTP we need to have this update before the calculations
                if (!SalesUpdateConfirmDatesOnlineCTPFlight::instance().isEnabled())
                {
                    this.updateDeliveryDateControl(_salesLine);
                }

                SalesCalendarId salesCalendarId = CustTable::find(salesTable.CustAccount).SalesCalendarId;
                if (salesCalendarId && !this.checkConfirmedDatesInSalesCalendar(salesCalendarId, _salesLine.ReceiptDateConfirmed))
                {
                    // Clear the confirmed dates if the date in the closed day.
                    _salesLine.ShippingDateConfirmed = dateNull();
                    _salesLine.ReceiptDateConfirmed  = dateNull();
                }

                _salesLine.update(); 
  
                shipDateSalesTable      = max(shipDateSalesTable,_salesLine.ShippingDateConfirmed);
                receiptDateSalesTable   = max(receiptDateSalesTable,_salesLine.ReceiptDateConfirmed);

                if (!this.isRequestedDatesExceeded(_salesLine) && _salesLine.ShippingDateConfirmed)
                {
                    info(strFmt("@SYS323570",_salesLine.ShippingDateConfirmed));
                }

                rereadDataSources = true;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesLinesDeliveryDateControl</Name>
				<Source><![CDATA[
    private void updateSalesLinesDeliveryDateControl()
    {
        if (   salesLineUpdateConfirmedDates
            && salesLineUpdateDeliverDateControl
            && isSalesLineDeliveryControlOverRuled
            && deliveryDateControlType != SalesDeliveryDateControlType::None)
        {
            ttsbegin;

            SalesLine salesLine = this.selectSalesLine(true);

            while (salesLine.RecId)
            {
                setPrefix(this.prefixTextSalesLine(salesLine));

                if (!this.skipLockedSalesLine(salesLine))
                {
                    this.updateDeliveryDateControl(salesLine);

                    if (salesLine.DeliveryDateControlType != salesLine.orig().DeliveryDateControlType)
                    {
                        salesLine.update();
  
                        rereadDataSources = true;
                    }
                }

                next salesLine;
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the confirmed ship and receipt dates for the sales order.
    /// </summary>
    protected void updateSalesTable()
    {
        if (salesTableUpdateConfirmedDates
            && (shipDateSalesTable
            ||  receiptDateSalesTable))
        {
            SalesTable salesTableForupdate = SalesTable::find(salesTable.SalesId,true);

            salesTableForupdate.ShippingDateConfirmed = shipDateSalesTable;
            salesTableForupdate.ReceiptDateConfirmed  = receiptDateSalesTable;

            salesTableForupdate.update();
        }

        if (areConfirmedDatesClearedOnAnySalesLinesWithFullRunCTP)
        {
            warning("@SCM:MPSSalesOrderConfirmedDatesNotUpToDate");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    private static SalesUpdateConfirmDatesCommand construct()
    {
        return new SalesUpdateConfirmDatesCommand();
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args   _args)
    {
        SalesTable                          callerSalesTable;

        if (   _args
            && _args.record().TableId == tableNum(SalesTable))
        {
            callerSalesTable = _args.record() as SalesTable;
        }

        if (   callerSalesTable
            || callerSalesTable.SalesId)
        {
            SalesUpdateConfirmDatesCommand salesUpdateConfirmDatesCommand = SalesUpdateConfirmDatesCommand::newSalesTable(callerSalesTable);

            if (! salesUpdateConfirmDatesCommand.prompt())
            {
                return;
            }

            using (SysErrorMessageHelpScope scope = SysErrorMessageHelpScope::newErrorContext(_args))
            {
                salesUpdateConfirmDatesCommand.runOperation();
            }

            salesUpdateConfirmDatesCommand.refreshCallerDatasource(_args.caller());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newSalesTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>SalesUpdateConfirmDatesCommand</c> class.
    /// </summary>
    /// <param name="_salesTable">
    /// A <c>SalesTable</c> record that represent the sales order header.
    /// </param>
    /// <returns>
    /// A <c>SalesUpdateConfirmDatesCommand</c> object.
    /// </returns>
    public static SalesUpdateConfirmDatesCommand newSalesTable(
        SalesTable     _salesTable)
    {
        SalesUpdateConfirmDatesCommand salesUpdateConfirmDatesCommand = SalesUpdateConfirmDatesCommand::construct();
        salesUpdateConfirmDatesCommand.getLast();
        salesUpdateConfirmDatesCommand.parmSalesTable(_salesTable);

        return salesUpdateConfirmDatesCommand;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllowMultipleShipDates</Name>
				<Source><![CDATA[
    public boolean parmAllowMultipleShipDates(boolean _allowMultipleShipDates = allowMultipleShipDates)
    {
        allowMultipleShipDates = _allowMultipleShipDates;
        return allowMultipleShipDates;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDeliveryDateControlType</Name>
				<Source><![CDATA[
    public SalesDeliveryDateControlType parmDeliveryDateControlType(SalesDeliveryDateControlType _deliveryDateControlType = deliveryDateControlType)
    {
        deliveryDateControlType = _deliveryDateControlType;
        return deliveryDateControlType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesLineUpdateConfirmedDates</Name>
				<Source><![CDATA[
    public boolean parmSalesLineUpdateConfirmedDates(boolean _salesLineUpdateConfirmedDates = salesLineUpdateConfirmedDates)
    {
        salesLineUpdateConfirmedDates = _salesLineUpdateConfirmedDates;
        return salesLineUpdateConfirmedDates;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsSalesLineDeliveryControlOverRuled</Name>
				<Source><![CDATA[
    public boolean parmIsSalesLineDeliveryControlOverRuled(boolean _isSalesLineDeliveryControlOverRuled = isSalesLineDeliveryControlOverRuled)
    {
        isSalesLineDeliveryControlOverRuled = _isSalesLineDeliveryControlOverRuled;
        return isSalesLineDeliveryControlOverRuled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    final boolean isRetryable() 
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesShippingDateLatestAllowed</Name>
				<Source><![CDATA[
    [Hookable(false)]
    final public SalesShippingDateLatestAllowed parmSalesShippingDateLatestAllowed(SalesShippingDateLatestAllowed _shippingDateLatestAllowed = shippingDateLatestAllowed)
    {
        shippingDateLatestAllowed = _shippingDateLatestAllowed;

        return shippingDateLatestAllowed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesTableUpdateConfirmedDates</Name>
				<Source><![CDATA[
    [Hookable(false)]
    final public SalesTableUpdateConfirmedDates parmSalesTableUpdateConfirmedDates(SalesTableUpdateConfirmedDates _salesTableUpdateConfirmedDates = salesTableUpdateConfirmedDates)
    {
        salesTableUpdateConfirmedDates = _salesTableUpdateConfirmedDates;

        return salesTableUpdateConfirmedDates;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesLineAllowNewConfirmedDates</Name>
				<Source><![CDATA[
    [Hookable(false)]
    final public SalesLineAllowNewConfirmedDates parmSalesLineAllowNewConfirmedDates(SalesLineAllowNewConfirmedDates _salesLineAllowNewConfirmedDates = salesLineAllowNewConfirmedDates)
    {
        salesLineAllowNewConfirmedDates = _salesLineAllowNewConfirmedDates;

        return salesLineAllowNewConfirmedDates;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesLineUpdateDeliverDateControl</Name>
				<Source><![CDATA[
    [Hookable(false)]
    final public SalesLineUpdateDeliverDateControl parmSalesLineUpdateDeliverDateControl(SalesLineUpdateDeliverDateControl _salesLineUpdateDeliverDateControl = salesLineUpdateDeliverDateControl)
    {
        salesLineUpdateDeliverDateControl = _salesLineUpdateDeliverDateControl;

        return salesLineUpdateDeliverDateControl;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShipDateSalesTable</Name>
				<Source><![CDATA[
    [Hookable(false)]
    final public TransDate parmShipDateSalesTable()
    {
        return shipDateSalesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReceiptDateSalesTable</Name>
				<Source><![CDATA[
    [Hookable(false)]
    final public TransDate parmReceiptDateSalesTable()
    {
        return receiptDateSalesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRereadDataSources</Name>
				<Source><![CDATA[
    [Hookable(false)]
    final public boolean parmRereadDataSources()
    {
        return this.rereadDataSources();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromSalesUpdateConfirmDatesCommad</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the current object based on an another <c>SalesUpdateConfirmDatesCommand</c> object.
    /// </summary>
    /// <param name = "_salesUpdateConfirmDatesCommand">
    /// A <c>SalesUpdateConfirmDatesCommand</c> object.
    /// </param>
    public void initFromSalesUpdateConfirmDatesCommad(SalesUpdateConfirmDatesCommand _salesUpdateConfirmDatesCommand)
    {
        this.parmSalesTable(_salesUpdateConfirmDatesCommand.parmSalesTable());
        this.parmSalesShippingDateLatestAllowed(_salesUpdateConfirmDatesCommand.parmSalesShippingDateLatestAllowed());
        this.parmDeliveryDateControlType(_salesUpdateConfirmDatesCommand.parmDeliveryDateControlType());
        this.parmAllowMultipleShipDates(_salesUpdateConfirmDatesCommand.parmAllowMultipleShipDates());
        this.parmSalesTableUpdateConfirmedDates(_salesUpdateConfirmDatesCommand.parmSalesTableUpdateConfirmedDates());
        this.parmSalesLineUpdateConfirmedDates(_salesUpdateConfirmDatesCommand.parmSalesLineUpdateConfirmedDates());
        this.parmSalesLineAllowNewConfirmedDates(_salesUpdateConfirmDatesCommand.parmSalesLineAllowNewConfirmedDates());
        this.parmSalesLineUpdateDeliverDateControl(_salesUpdateConfirmDatesCommand.parmSalesLineUpdateDeliverDateControl());
        this.parmIsSalesLineDeliveryControlOverRuled(_salesUpdateConfirmDatesCommand.parmIsSalesLineDeliveryControlOverRuled());
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>