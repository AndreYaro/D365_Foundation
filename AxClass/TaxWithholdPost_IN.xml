<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxWithholdPost_IN</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>TaxWithholdPost_IN</c> class is used to post tax withhold data.
/// </summary>
abstract class TaxWithholdPost_IN
{
    TaxableDocument         taxableDocument;
    PurchCalcTax            purchCalcTax;
    RefTableId              headingTableId;
    RefRecId                headingRecId;
    NoYes                   post;
    EUROTriangulation       triangulation;
    TaxModuleType           taxModuleType;
    RefTableId              origHeadingTableId;
    RefRecId                origHeadingRecId;
    TransDate               taxDate;
    CurrencyCode            sourceCurrencyCode;
    ExchRate                exchRate;
    ExchrateSecondary       exchRateSecond;
    Voucher                 voucher;
    Voucher                 voucherInterCompany;
    voucher                 voucherSettle;
    Common                  sourceRecord;
    boolean                 taxRegulationExist;
    CompanyId               companyId;
    CompanyId               paymcompanyId;
    CompanyId               journalLineCompany;
    Counter                 sourceDocumentTaxLine;
    RecId                   specRefRecId;
    CustVendAC              paymentAccount;
    CustVendAC              invoiceAccount;
    Voucher                 invoiceVoucher;
    AmountCur               transAmountOrigin;
    TmpTaxWithholdWorkTrans_IN  taxWithholdWorkTrans;
    boolean                     overlookThreshold, thresholdExceeded;
    boolean                     exceptionalThreshold, amountOrginCalculated;

    boolean                 checkBankStatus;
    AccountNum              offsetAccountNum;
    RefRecId                taxWithholdTransRecId;
    RefRecId                cpOrigRefRecId;
    SpecTrans               specTransForCP;

    #COSNumbers
    #define.7(7)
    #define.8(8)
    #define.15(15)
    #define.19(19)
    #define.POS_SoftwareDeclReceived(24)
    #define.TDSExchRate(25)
    #define.TDSExchRateSecond(26)
    #define.TDSTriangulation(27)
    #define.TDSExchRateRep(28)

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>newForSourceTypeDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Delegate for retrieving a newly derived <c>TaxWithholdPost_IN</c> record based on the transaction.
    /// </summary>
    /// <param name="_sourceType">
    ///    The type of the transaction posting taxes.
    /// </param>
    /// <param name="_initializationClass">
    ///    The initialization class for the specified transaction.
    /// </param>
    /// <param name="_post">
    ///    True if the <c>TaxTrans</c> and <c>Ledger</c> records will be created; false if it will not post.
    /// </param>
    /// <param name = "_result">An <c>EventHandlerResult</c> instance, where subscribers can provide the creation result.</param>
    public static void newForSourceTypeDelegate(TaxSourceType _sourceType, Object _initializationClass, NoYes _post, EventHandlerResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>newForSourceTypeWithTaxCalculationDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Delegate for retrieving a newly derived <c>TaxWithholdPost_IN</c> record based on the transaction.
    /// </summary>
    /// <param name="_sourceType">
    ///    The type of the transaction posting taxes.
    /// </param>
    /// <param name="_initializationClass">
    ///    The initialization class for the given transaction.
    /// </param>
    /// <param name="_post">
    ///    A Boolean value that specifies whether the <c>TaxTrans</c> and <c>Ledger</c> entries will be made.
    /// </param>
    /// <param name="_taxCalculation">
    ///    The tax will post using the tax lines in the table that are specified by the <paramref
    ///    name="_taxCalculation" /> parameter.
    /// </param>
    /// <param name = "_result">An <c>EventHandlerResult</c> instance, where subscribers can provide the creation result.</param>
    public static void newForSourceTypeWithTaxCalculationDelegate(TaxSourceType _sourceType, Object _initializationClass, NoYes _post, TaxWithholdCalculation_IN _taxWTHCalculation, EventHandlerResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>addPostingReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add a reference to LedgerPostingController object.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller to use for ledger posting.
    /// </param>
    /// <param name="_voucher">
    /// The voucher to use when adding the reference.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date to use when adding the reference.
    /// </param>
    /// <param name="_sourceTableId">
    /// The source table ID to use when adding the reference.
    /// </param>
    /// <param name="_sourceRecId">
    /// The source record ID to use when adding the reference.
    /// </param>
    protected void addPostingReference(
        LedgerPostingController _ledgerPostingController,
        Voucher _voucher,
        TransDate _transDate,
        TableId _sourceTableId = 0,
        RecId _sourceRecId = 0)
    {
        LedgerVoucherObject ledgerVoucherObject;

        ledgerVoucherObject = LedgerVoucherObject::newVoucher(
            _voucher,
            _transDate,
            SysModule::Ledger);

        _ledgerPostingController.addReference(ledgerVoucherObject);
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowTaxWithholdAdjustmentDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if tax withhold posting should delete tax withhold adjustments.
    /// </summary>
    /// <returns>
    /// true if taxwithhold posting should delete <c>TaxWithholdWorkRegulation_IN</c> records; otherwise, false.
    /// </returns>
    protected boolean allowTaxWithholdAdjustmentDelete()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowTaxWithholdUncommittedDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if tax withhold posting should delete the <c>TaxWithholdUncommitted_IN</c> records.
    /// </summary>
    /// <returns>
    /// true if tax withhold posting should delete <c>TaxWithholdUncommitted_IN</c> records; otherwise, false.
    /// </returns>
    protected boolean allowTaxWithholdUncommittedDelete()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTaxWithholdRegulation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Removes the tax withhold adjustments for the current document.
    /// </summary>
    protected void deleteTaxWithholdRegulation()
    {
        TaxWithholdWorkRegulation_IN taxWithholdWorkRegulation;

        delete_from taxWithholdWorkRegulation
        where taxWithholdWorkRegulation.SourceTableId  == this.sourceTableId()
           && taxWithholdWorkRegulation.SourceRecId    == this.sourceRecId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>existsTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the tax data exists.
    /// </summary>
    /// <returns>
    /// Returns true if the tax exists.
    /// </returns>
    protected boolean existsTax()
    {
        TaxWithholdUncommitted_IN TaxWithholdUncommittedLoc;

        select firstOnly crossCompany RecId from TaxWithholdUncommittedLoc
            where TaxWithholdUncommittedLoc.HeadingTableId  == origHeadingTableId
                && TaxWithholdUncommittedLoc.HeadingRecId   == origHeadingRecId
                && TaxWithholdUncommittedLoc.CPOrigInvoiceRefRecId == cpOrigRefRecId
                && ((TaxWithholdUncommittedLoc.Voucher       == voucherInterCompany
                        || TaxWithholdUncommittedLoc.Voucher    == voucherSettle)
                    || !voucherInterCompany);
        return TaxWithholdUncommittedLoc.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPostingReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find the correct posting reference.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller to use for ledger posting.
    /// </param>
    /// <param name="_voucher">
    /// The voucher to use when finding the reference.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date to use when finding the reference.
    /// </param>
    /// <param name="_sourceTableId">
    /// The source table ID to use when finding the reference.
    /// </param>
    /// <param name="_sourceRecId">
    /// The source record ID to use when finding the reference.
    /// </param>
    protected void findPostingReference(
        LedgerPostingController _ledgerPostingController,
        Voucher _voucher,
        TransDate _transDate,
        TableId _sourceTableId = 0,
        RecId _sourceRecId = 0
    )
    {
        boolean isFound;

        if (this.postFindPostingReference())
        {
            isFound = _ledgerPostingController.findReference(_voucher, _transDate);

            if (!isFound)
            {
                if (_ledgerPostingController.getJournal().lastTransDate())
                {
                    // when tax is using document date, the date tax has will differ from the date
                    // the Journals use.
                    isFound = _ledgerPostingController.findReference(_voucher, _ledgerPostingController.getJournal().lastTransDate());
                }

                if (!isFound)
                {
                    this.addPostingReference(_ledgerPostingController, _voucher, _transDate, _sourceTableId, _sourceRecId);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCompanyToPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the company for which to be posted.
    /// </summary>
    /// <returns>
    ///    The company ID withhold tax to post.
    /// </returns>
    protected CompanyId getCompanyToPost()
    {
        return curext();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the project related ledger dimension.
    /// </summary>
    /// <param name="_taxWithholdWorkTrans">
    /// The TmpTaxWithholdWorkTrans_I> buffer.
    /// </param>
    /// <param name="_salesPurchJournalLineLoc">
    /// The SalesPurchJournalLine buffer.
    /// </param>
    /// <returns>
    /// returns the project related ledger dimension.
    /// </returns>
    public LedgerDimensionAccount getProjLedgerDimension(TmpTaxWithholdWorkTrans_IN _taxWithholdWorkTrans,
                                                         SalesPurchJournalLine      _salesPurchJournalLineLoc)
    {
        LedgerDimensionAccount ledgerDimension;

        void ledgerDimensionAcct(DimensionDefault _defaultDimension)
        {
            ledgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(taxWithholdWorkTrans.LedgerDimensionDefaultAccount, _defaultDimension);
        }

        switch (_salesPurchJournalLineLoc.SourceTableId)
        {
            case tableNum(ProjRevenueTrans) :
                ledgerDimensionAcct(ProjRevenueTrans::find(_salesPurchJournalLineLoc.SourceId).DefaultDimension);
                break;

            case tableNum(ProjItemTrans) :
                ledgerDimensionAcct(ProjItemTrans::find(_salesPurchJournalLineLoc.SourceId).DefaultDimension);
                break;

            case tableNum(ProjOnAccTrans) :
                ledgerDimensionAcct(ProjOnAccTrans::find(_salesPurchJournalLineLoc.SourceId).DefaultDimension);
                break;

            case tableNum(SalesLine) :
                ledgerDimensionAcct(SalesLine::findRecId(_salesPurchJournalLineLoc.SourceRecId).DefaultDimension);
                break;
        }
        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesPurchJournalLineFromTmpTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets sales purch journal line from temporary tax.
    /// </summary>
    /// <param name="_taxWithholdWorkTrans">
    /// The tax withhold work transaciton.
    /// </param>
    /// <returns>
    /// The instance of the <c>SalesPurchJournalLine</c> class.
    /// </returns>
    SalesPurchJournalLine  getSalesPurchJournalLineFromTmpTax(TmpTaxWithholdWorkTrans_IN  _taxWithholdWorkTrans)
    {
        SalesPurchJournalLine    salesPurchJournalLine;
        ProjInvoiceItem             projInvoiceItem;
        ProjInvoiceRevenue          projInvoiceRevenue;
        ProjInvoiceOnAcc            projInvoiceOnAcc;

        switch (_taxWithholdWorkTrans.SourceTableId)
        {
            case tableNum(PurchLine):
               salesPurchJournalLine = PurchLine::findRecId(_taxWithholdWorkTrans.SourceRecId);
                break;

            case tableNum(SalesLine):
                salesPurchJournalLine = SalesLine::findRecId(_taxWithholdWorkTrans.SourceRecId);
                break;

            case tableNum(CustInvoiceTrans):
                salesPurchJournalLine = CustInvoiceTrans::findRecId(_taxWithholdWorkTrans.SourceRecId);
                break;

            case tableNum(LedgerJournalTrans):
                salesPurchJournalLine = LedgerJournalTrans::findRecId(_taxWithholdWorkTrans.SourceRecId, false);
                break;

            case tableNum(VendInvoiceInfoLine):
                salesPurchJournalLine = VendInvoiceInfoLine::findRecId(_taxWithholdWorkTrans.SourceRecId, false);
                break;

            case tablenum(ProjInvoiceRevenue) :
                select firstonly TransId from ProjInvoiceRevenue
                    where ProjInvoiceRevenue.RecId == _taxWithholdWorkTrans.SourceRecId;

                salesPurchJournalLine = projRevenueTrans::find(ProjInvoiceRevenue.TransId).projRevenueTransView_IN() as Common;
                break;

            case tablenum(ProjInvoiceItem) :
                select firstonly InventTransId, SalesId, ProjTransId from projInvoiceItem
                    where projInvoiceItem.RecId == _taxWithholdWorkTrans.SourceRecId;

                if (projInvoiceItem.SalesId)
                {
                    salesPurchJournalLine = SalesLine::findInventTransId(projInvoiceItem.InventTransId);
                }
                else
                {
                    salesPurchJournalLine = ProjItemTrans::find(projInvoiceItem.ProjTransId).projItemTransView_IN() as Common;
                }

                break;

            case tablenum(ProjInvoiceOnAcc) :
                select firstonly TransId from projInvoiceOnAcc
                    where projInvoiceOnAcc.RecId == _taxWithholdWorkTrans.SourceRecId;

                salesPurchJournalLine = ProjOnAccTrans::find(projInvoiceOnAcc.TransId).projOnAccTransView_IN() as Common;
                break;
        }
        return  salesPurchJournalLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesPurchJournalLineFrTaxUnCommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to get sales purch journal line based on the invent Id.
    /// </summary>
    /// <param name="_taxWithHoldUncommitted">
    /// The <c>TaxWithholdUncommitted_IN</c> Buffer passed to get the SalesPurchJournalLine map value.
    /// </param>
    /// <returns>
    /// Returns the <c>SalesPurchJournalLine</c> map.
    /// </returns>
    SalesPurchJournalLine  getSalesPurchJournalLineFrTaxUnCommitted(TaxWithholdUncommitted_IN _taxWithHoldUncommitted)
    {
        SalesPurchJournalLine       salesPurchJournalLine;
        SalesPurchJournalLineExtension_IN salesPurchJournalLineExtension_IN;
        LedgerJournalTrans          ledgerJournalTransLoc;
        CustInvoiceTable            custInvoiceTable;
        CustInvoiceLine             custInvoiceLine;
        VendInvoiceInfoLine                 vendInvoiceInfoLineLoc;
        VendInvoiceInfoLine_W               vendInvoiceInfoLine_WLoc;

        switch (_taxWithHoldUncommitted.SourceTableId)
        {
            case tableNum(PurchLine),
                tableNum(VendInvoiceInfoLine),
                tableNum(VendInvoiceTrans) :
                if (_taxWithHoldUncommitted.SourceTableId == tableNum(VendInvoiceTrans))
                {
                    vendInvoiceInfoLineLoc = VendInvoiceInfoLine::findSourceDocumentLine(_taxWithHoldUncommitted.parmParentSourceDocumentLine().RecId);
                    if (vendInvoiceInfoLineLoc.RecId && vendInvoiceInfoLineLoc.isNonPO())
                    {
                        vendInvoiceInfoLine_WLoc = vendInvoiceInfoLineLoc.vendInvoiceInfoLine_W();

                        salesPurchJournalLine = vendInvoiceInfoLineLoc;
                        salesPurchJournalLine.SourceTableId                 = vendInvoiceInfoLineLoc.TableId;
                        salesPurchJournalLine.SourceRecId                   = vendInvoiceInfoLineLoc.RecId;
                        salesPurchJournalLine.TaxItemGroup                  = vendInvoiceInfoLineLoc.TaxItemGroup;
                        salesPurchJournalLine.CurrencyCode                  = vendInvoiceInfoLineLoc.CurrencyCode;
                        salesPurchJournalLine.TaxGroup                      = vendInvoiceInfoLineLoc.TaxGroup;
                        salesPurchJournalLine.LineNum                       = vendInvoiceInfoLineLoc.LineNum;

                        salesPurchJournalLine.SalesPurchJournalLine::parmMaximumRetailPrice(vendInvoiceInfoLine_WLoc.MaximumRetailPrice_IN);
                        salesPurchJournalLine.SalesPurchJournalLine::parmAssessableValue(vendInvoiceInfoLine_WLoc.AssessableValue_IN);

                        salesPurchJournalLineExtension_IN = salesPurchJournalLine.SalesPurchJournalLine::getSalesPurchJournalLineExtension_IN();
                        salesPurchJournalLineExtension_IN.SalesPurchJournalLine::packSalesPurchJournalLineExtension_IN(salesPurchJournalLineExtension_IN);
                    }
                    else if (vendInvoiceInfoLineLoc.RecId && !vendInvoiceInfoLineLoc.isNonPO())
                    {
                        salesPurchJournalLine = VendInvoiceInfoLine::findSourceDocumentLine(_taxWithHoldUncommitted.parmParentSourceDocumentLine().RecId).purchLine();
                    }
                }
                else if (_taxWithHoldUncommitted.SourceTableId == tableNum(VendInvoiceInfoLine))
                {
                    salesPurchJournalLine = VendInvoiceInfoLine::findRecId(_taxWithHoldUncommitted.SourceRecId);
                }
                else
                {
                    salesPurchJournalLine = PurchLine::findRecId(_taxWithHoldUncommitted.SourceRecId);
                }
                break;

            case tableNum(SalesLine):
                salesPurchJournalLine = SalesLine::findRecId(_taxWithHoldUncommitted.SourceRecId);
                break;

            case tableNum(CustInvoiceLine):
                select firstonly RecId, InvoiceId, CurrencyCode from custInvoiceTable
                    where custInvoiceTable.InvoiceId == CustInvoiceJour::findRecId(_taxWithHoldUncommitted.HeadingRecId).InvoiceId;

                select firstonly TableId, RecId, TaxItemGroup, TaxGroup,LineNum
                    from custInvoiceLine
                        where custInvoiceLine.RecId == _taxWithHoldUncommitted.SourceRecId;

                // This non-persisted field in the CustInvoiceLine table exists to support the
                // SalesPurchJournalLine map so it has to be set to the actual value here.
                custInvoiceLine.CurrencyCode = custInvoiceTable.CurrencyCode;

                salesPurchJournalLine = custInvoiceLine;

                // These values have to be set because they are not stored in the table
                salesPurchJournalLine.SourceTableId = custInvoiceLine.TableId;
                salesPurchJournalLine.SourceRecId = custInvoiceLine.RecId;

                salesPurchJournalLineExtension_IN = salesPurchJournalLine.SalesPurchJournalLine::getSalesPurchJournalLineExtension_IN();
                salesPurchJournalLineExtension_IN.AssessableValue   = custInvoiceLine.custInvoiceLineTaxExtensionIN().AssessableValueTransactionCurrency;
                salesPurchJournalLine.SalesPurchJournalLine::packSalesPurchJournalLineExtension_IN(salesPurchJournalLineExtension_IN);
                break;

            case tableNum(CustInvoiceTrans):
                salesPurchJournalLine = CustInvoiceTrans::findRecId(_taxWithHoldUncommitted.SourceRecId);
                break;

            case tableNum(VendInvoiceTrans):
                salesPurchJournalLine = VendInvoiceTrans::findRecId(_taxWithHoldUncommitted.SourceRecId);
                break;

            case tableNum(LedgerJournalTrans):
                select firstOnly crossCompany ledgerJournalTransLoc
                    where ledgerJournalTransLoc.recid == _taxWithHoldUncommitted.SourceRecId;
                salesPurchJournalLine = ledgerJournalTransLoc;
                break;

            case tableNum(ProjAdvancedJournalLine) :
                salesPurchJournalLine = ProjAdvancedJournalLine::find(_taxWithHoldUncommitted.SourceRecId);
                break;
        }
        return  salesPurchJournalLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxWithholdTransactionReason</Name>
				<Source><![CDATA[
    private TaxWithholdReasonCode getTaxWithholdTransactionReason(TaxWithholdTrans_IN _taxWithholdTrans)
    {
        TaxWithholdComponentGroupTable_IN   taxWithholdComponentGroupTableLoc;
        #TaxWithhold_IN

        taxWithholdComponentGroupTableLoc = TaxWithholdComponentGroupTable_IN::find(_taxWithholdTrans.TaxWithholdComponentGroup);
        if (taxWithholdComponentGroupTableLoc.Status == TaxWithholdComponentStatus_IN::Resident
            && (taxWithholdComponentGroupTableLoc.SectionCode    == #Section193
                || taxWithholdComponentGroupTableLoc.SectionCode == #Section194
                || taxWithholdComponentGroupTableLoc.SectionCode == #Section194A
                || taxWithholdComponentGroupTableLoc.SectionCode == #Section194B
                || taxWithholdComponentGroupTableLoc.SectionCode == #Section194BB
                || taxWithholdComponentGroupTableLoc.SectionCode == #Section194C
                || taxWithholdComponentGroupTableLoc.SectionCode == #Section194D
                || taxWithholdComponentGroupTableLoc.SectionCode == #Section194EE
                || taxWithholdComponentGroupTableLoc.SectionCode == #Section194G
                || taxWithholdComponentGroupTableLoc.SectionCode == #Section194H
                || taxWithholdComponentGroupTableLoc.SectionCode == #Section194I
                || taxWithholdComponentGroupTableLoc.SectionCode == #Section194J
                || taxWithholdComponentGroupTableLoc.SectionCode == #Section194LA))
        {
            return #ZeroDeductDueToThreshholdMark;
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>headingRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the heading rec id.
    /// </summary>
    /// <returns>
    /// The heading rec id.
    /// </returns>
    RefRecId headingRecId()
    {
        return headingRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>headingTableId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the heading table id.
    /// </summary>
    /// <returns>
    /// The heading table id.
    /// </returns>
    RefTableId headingTableId()
    {
        return headingTableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>origHeadingRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the original heading record id.
    /// </summary>
    /// <returns>
    /// The heading rec id.
    /// </returns>
    public RefRecId origHeadingRecId()
    {
        return origHeadingRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>origHeadingTableId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the original heading table id.
    /// </summary>
    /// <returns>
    /// The heading table id.
    /// </returns>
    public RefTableId origHeadingTableId()
    {
        return origHeadingTableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the ledger posting.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller.
    /// </param>
    protected void initLedgerPosting(LedgerPostingController _ledgerPostingController)
    {
        LedgerVoucher ledgerPostingJournal = _ledgerPostingController.getJournal();

        if (post && (ledgerPostingJournal == null))
        {
            // two messages is the legacy behavior
            warning(strFmt("@SYS19386", funcName()));
            throw error("@SYS18447");
        }

        if (ledgerPostingJournal != null)
        {
            voucher = ledgerPostingJournal.lastVoucher();
            taxDate = ledgerPostingJournal.lastTransDate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the ledger journal id.
    /// </summary>
    /// <returns>
    /// The ledger journal id.
    /// </returns>
    LedgerJournalId journalNum()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveSourceDocLineOwnerToTaxWithHoldTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Changes the owner of the source document line records from <c>TaxWithHoldUncommitted_IN</c> to <c>TaxWithHoldTrans_IN</c>.
    /// </summary>
    private void moveSourceDocLineOwnerToTaxWithHoldTrans()
    {
        SourceDocumentLine          sourceDocumentLine;
        TaxWithholdUncommitted_IN   taxWithHoldUncommitted;
        int                         taxTransTableNum;

        if (!this.useSubLedgerJournalLines())
        {
            // if the calling transaction isn't using SubLedger then we don't
            // need to do this.
            return;
        }

        // the new owner of the source document line records will be TaxWithHoldTrans_IN.
        taxTransTableNum = tableNum(TaxWithholdTrans_IN);

        // update the owner for all records as a set.
        while select sourceDocumentLine
            join taxWithHoldUncommitted
        where
            taxWithHoldUncommitted.HeadingRecId       == this.headingRecId() &&
            taxWithHoldUncommitted.HeadingTableId     == this.headingTableId() &&
            taxWithHoldUncommitted.SourceDocumentLine == sourceDocumentLine.RecId
        {
            sourceDocumentLine.selectForUpdate(true);
            sourceDocumentLine.SourceRelationType = taxTransTableNum;
            sourceDocumentLine.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveTaxLineToNewOwner</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Moves all of the tax lines for the given document to a new document.
    /// </summary>
    /// <param name="_oldParentTableId">
    ///    Original table ID for the transaction line.
    /// </param>
    /// <param name="_oldParentRecId">
    ///    Original <c>RecId</c> for the transaction header.
    /// </param>
    protected void moveTaxLineToNewOwner(
        RefTableId   _oldParentTableId,
        RefRecId     _oldParentRecId)
    {
        TaxWithholdUncommitted_IN   taxUnCommittedWHT;
        TaxWithholdWorkRegulation_IN    taxWithholdWorkRegulation;

        update_recordset taxWithholdWorkTrans
        setting
            HeadingRecId    = headingRecId,
            SourceTableId   = this.sourceTableId(),
            SourceRecId     = this.sourceRecId(),
            HeadingTableId  = headingTableId
        where
            taxWithholdWorkTrans.SourceTableId == _oldParentTableId &&
            taxWithholdWorkTrans.SourceRecId   == _oldParentRecId;

        update_recordSet taxWithholdWorkRegulation
        setting
            sourceTableId = this.sourceTableId(),
            sourceRecId   = this.sourceRecId()
        where
            taxWithholdWorkRegulation.SourceTableId == _oldParentTableId &&
            taxWithholdWorkRegulation.SourceRecId   == _oldParentRecId;

        if (this.useTaxUncommitted())
        {
            update_recordset taxUnCommittedWHT
            setting
                HeadingRecId    = headingRecId,
                SourceTableId   = this.sourceTableId(),
                SourceRecId     = this.sourceRecId(),
                HeadingTableId  = headingTableId
            where
                taxUnCommittedWHT.SourceRecId   == _oldParentRecId &&
                taxUnCommittedWHT.SourceTableId == _oldParentTableId &&
                taxUnCommittedWHT.HeadingTableId == origHeadingTableId &&
                taxUnCommittedWHT.HeadingRecId == origHeadingRecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>overrideVoucherOnPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether posting should override the voucher when it posts to the <c>TaxWithholdTrans_IN</c> table.
    /// </summary>
    /// <returns>
    ///    true if posting should override the voucher; otherwise, false.
    /// </returns>
    protected boolean overrideVoucherOnPost()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>post</Name>
				<Source><![CDATA[
    /// <summary>
    /// The post method of the <c>TaxWithholdPost_IN</c> class.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller.
    /// </param>
    /// <param name="_taxWithholdTrans">
    /// The tax withhold trans.
    /// </param>
    /// <param name="_taxAmount">
    /// The tax amount.
    /// </param>
    /// <param name="_exchRateHelper">
    /// The exchange rate helper.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The ledger dimension.
    /// </param>
    protected void post(
        LedgerPostingController _ledgerPostingController,
        TaxWithholdTrans_IN     _taxWithholdTrans,
        TaxAmount               _taxAmount,
        CurrencyExchangeHelper  _exchRateHelper,
        LedgerDimensionAccount  _ledgerDimension)

    {
        LedgerVoucherTransObject ledgerVoucherTransObject;
        TaxWithholdCodeType_IN   taxWithholdType;
        LedgerPostingType        ledgerPostingTypeLoc;

        taxWithholdType = TaxWithholdTable::find(_taxWithholdTrans.TaxWithholdCode).TaxType_IN;

        if (taxWithholdType == TaxWithholdCodeType_IN::TDS)
        {
            ledgerPostingTypeLoc = LedgerPostingType::TDS_IN;
        }
        else
        {
            ledgerPostingTypeLoc = LedgerPostingType::TCS_IN;
        }
        if (_taxAmount)
        {
            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerPostingController.getReference(),
                                                                                ledgerPostingTypeLoc,
                                                                                _ledgerDimension,
                                                                                _taxWithholdTrans.CurrencyCode,
                                                                                _taxAmount,
                                                                                _exchRateHelper);

            _ledgerPostingController.addTrans(ledgerVoucherTransObject);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postAsPerCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts tax withhold as per company.
    /// </summary>
    /// <param name="_amount">
    /// The amount information.
    /// </param>
    /// <param name="_ledgerDimensionId">
    /// The ledger dimension id.
    /// </param>
    /// <param name="_exchRate">
    /// The exchange rate.
    /// </param>
    /// <param name="_exchRateSecondary">
    /// The secondary exchange rate.
    /// </param>
    /// <param name="_exchRatesTriangulation">
    /// The triangulation exchange rates.
    /// </param>
    /// <param name="_currencyCode">
    /// The currency code.
    /// </param>
    /// <param name="_dimension">
    /// The dimension information.
    /// </param>
    /// <param name="_tableId">
    /// The table id.
    /// </param>
    /// <param name="_recId">
    /// The rec id.
    /// </param>
    /// <param name="_ledgerPostingType">
    /// The ledger posting type.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The ledger voucher information.
    /// </param>
    public void  postAsPerCompany(
        real                          _amount,
        LedgerDimensionDefaultAccount _ledgerDimensionId,
        ExchRate                      _exchRate,
        ExchRate                      _exchRateSecondary,
        ExchRatesTriangulation        _exchRatesTriangulation,
        CurrencyCode                  _currencyCode,
        DimensionDefault              _dimension,
        RefTableId                    _tableId,
        RefRecId                      _recId,
        LedgerPostingType             _ledgerPostingType,
        LedgerVoucher                 _ledgerVoucher)

    {
        CurrencyExchangeHelper      currencyExchangeHelper;
        LedgerVoucherTransObject    ledgerVoucherTransObject;

        currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), _ledgerVoucher.findLedgerVoucherObject().parmAccountingDate());
        currencyExchangeHelper.parmExchangeRate1(_exchRate);
        currencyExchangeHelper.parmExchangeRate2(_exchRateSecondary);

        // Posting of the withholding tax on the withholding tax account
        ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerVoucher.findLedgerVoucherObject(),
                                                                                         _ledgerPostingType,
                                                                                         LedgerDimensionFacade::serviceCreateLedgerDimension(_ledgerDimensionId, _dimension),
                                                                                         _currencyCode,
                                                                                         _amount,
                                                                                         currencyExchangeHelper);
        ledgerVoucherTransObject.parmSourceTableId(_tableId);
        ledgerVoucherTransObject.parmSourceRecId(_recId);
        _ledgerVoucher.addTrans(ledgerVoucherTransObject);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postFindPostingReference</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines if withhold tax posting should attempt to find the correct posting reference
    ///   using the voucher and transdate on the withhold tax line.
    /// </summary>
    /// <returns>
    ///   true if withhold tax should find the posting reference; otherwise, false.
    /// </returns>
    protected boolean postFindPostingReference()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postToLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts to the ledger using either the subledger or the legacy method of posting.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller to use for ledger posting.
    /// </param>
    /// <param name="_taxWithholdTrans">
    /// The transaction line being posted.
    /// </param>
    /// <param name="_exchangeRateHelper">
    /// The <c>CurrencyExchHelper</c> instance for the <c>TaxTrans</c> record being posted.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The <c>LedgerDimensionAccount</c> data type that represents the tax amount.
    /// </param>
    private void postToLedger(
        LedgerPostingController _ledgerPostingController,
        TaxWithholdTrans_IN     _taxWithholdTrans,
        CurrencyExchangeHelper  _exchangeRateHelper,
        LedgerDimensionAccount  _ledgerDimension)
    {
        TaxAmountCur        taxAmountCur;

        taxAmountCur = _taxWithholdTrans.TaxAutoGenerated ? _taxWithholdTrans.TaxWithholdAmountCur : _taxWithholdTrans.AdjustedTaxWithholdAmount;

        // use the legacy posting.
        if (_taxWithholdTrans.Exempt == NoYes::No
            && taxAmountCur
            && (_taxWithholdTrans.TransactionStatus != TaxWithholdTransactionstatus_IN::Adjusted
                || _taxWithholdTrans.Source         != TaxModuleType::Voucher))
        {
            this.post(_ledgerPostingController, _taxWithholdTrans, taxAmountCur, _exchangeRateHelper, _ledgerDimension);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postToTaxWithHoldTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts a TaxWithholdTrans_IN record.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller to use for ledger posting.
    /// </param>
    /// <param name="_taxWithholdTrans">
    /// Transaction line being posted.
    /// </param>
    /// <param name="_exchangeRateHelper">
    /// An instance of <c>CurrencyExchHalper</c> with the currency, exchange rates, and triangulation values set.
    /// </param>
    /// <param name="_taxWithholdData">
    /// The container with the required source data.
    /// </param>
    protected void postToTaxWithHoldTrans(
        LedgerPostingController _ledgerPostingController,
        TaxWithholdTrans_IN     _taxWithholdTrans,
        CurrencyExchangeHelper  _exchangeRateHelper,
        container               _taxWithholdData)
    {
        SpecTrans                       specTransLoc;
        container                       custVendInfo;
        LedgerJournalTrans              ledgerJournalTransLoc;
        TaxWithholdThresholdLimit_IN    taxWithholdThresholdLimit;
        TaxwithholdTrans_IN             taxWithholdTransLoc;
        TaxWithholdWorkRegulation_IN    taxWithholdWorkRegulation;
        VendTable                       vendTableLoc = VendTable::find(_taxWithholdTrans.VendAccount);
        CustTable                       custTableLoc = CustTable::find(_taxWithholdTrans.CustAccount);
        TaxInformationVendTable_IN      taxInformationVendTable = TaxInformationVendTable_IN::findByVendTable(vendTableLoc.AccountNum);
        TaxInformationCustTable_IN      taxInformationCustTable = TaxInformationCustTable_IN::findByCustTable(custTableLoc.AccountNum);
        AmountCurCredit                 amountCurCredit;
        AmountCurDebit                  amountCurDebit;
        RecId                           ledgerJournalTransRecid;
        AmountCur                       balance01;

        #TaxWithhold_IN
        #COSNumbers

        if (this.overrideVoucherOnPost())
        {
            _taxWithholdTrans.Voucher = voucherInterCompany ? voucherInterCompany: voucher;
        }

        // Payment Company Information
        if (_taxWithholdTrans.SourceTableId == tableNum(LedgerJournalTrans))
        {
            select firstonly crossCompany ledgerJournalTransLoc
                where ledgerJournalTransLoc.RecId == _taxWithholdTrans.SourceRecId;

            amountCurCredit = ledgerJournalTransLoc.AmountCurCredit;
            amountCurDebit = ledgerJournalTransLoc.AmountCurDebit;
            ledgerJournalTransRecid = ledgerJournalTransLoc.RecId;

            select firstonly specTransLoc
                where specTransLoc.SpecRecId     == _taxWithholdTrans.SourceRecId
                    && specTransLoc.SpecTableId  == _taxWithholdTrans.SourceTableId
                    && specTransLoc.RefCompany   == companyId;

            balance01 = specTransLoc.Balance01;

            this.setInvoiceAndPaymentData(specTransLoc, ledgerJournalTransLoc);
            this.setSpecTransBuffer(specTransLoc);

            if ((conPeek(_taxWithholdData, #14) == SettlementType::SelectedTransact) && (companyId != paymcompanyId || paymcompanyId == curext()))
            {
                if (_taxWithholdTrans.SourceTableId == tableNum(LedgerJournalTrans))
                {
                    custVendInfo = TaxWithholdCalculation_IN::getVendorInformation(specTransLoc);

                    _taxWithholdTrans.SettlementVoucher      = conPeek(_taxWithholdData, #10);
                    _taxWithholdTrans.CustVendTransInvoiceId = conPeek(custVendInfo, 8);
                }
            }

            if ((conPeek(_taxWithholdData, #14) != SettlementType::SelectedTransact) && (companyId != paymcompanyId))
            {
                select  ForeignVoucher from ledgerJournalTransLoc
                    where ledgerJournalTransLoc.Voucher == _taxWithholdTrans.Voucher;

                _taxWithholdTrans.SettlementVoucher      = ledgerJournalTransLoc.ForeignVoucher;
            }
        }

        if ((conPeek(_taxWithholdData, #14) != SettlementType::SelectedTransact))
        {
            _taxWithholdTrans.Posted          = NoYes::Yes;
        }
        else
        {
            LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExtension = LedgerJournalTransTaxExtensionIN::findByLedgerJournalTrans(ledgerJournalTransRecid);

            if((ledgerJournalTransTaxExtension.TDSGroup || ledgerJournalTransTaxExtension.TCSGroup)
                && TaxParameters::checkTaxParameters_IN()
                && (amountCurDebit + amountCurCredit - balance01))
            {
                _taxWithholdTrans.Posted = NoYes::Yes;
            }
        }
        // Genaral
        _taxWithholdTrans.InvoiceVoucher         = invoiceVoucher;
        _taxWithholdTrans.PaymAccount            = paymentAccount;
        _taxWithholdTrans.PaymCompany            = paymcompanyId;

        if (_taxWithholdTrans.RecoverableAccount)
        {
            _taxWithholdTrans.LedgerDimensionReceivableAccount = _taxWithholdTrans.LedgerDimension;
        }
        _taxWithholdTrans.NatureOfAssessee                   = conPeek(_taxWithholdData, #16);
        _taxWithholdTrans.InventRefId                        = conPeek(_taxWithholdData, #18);
        _taxWithholdTrans.ReturnVoucher                      = conPeek(_taxWithholdData, #19);
        _taxWithholdTrans.ReturnLineNum                      = conPeek(_taxWithholdData, #20);
        _taxWithholdTrans.VendInvoiceInternalDefaultGroup    = conPeek(_taxWithholdData, #22);

        if (taxInformationVendTable)
        {
            _taxWithholdTrans.Nameofdeductee     = DirPartyTable::findRec(vendTableLoc.Party).Name;
            _taxWithholdTrans.pan                = taxInformationVendTable.PANNumber;
            _taxWithholdTrans.panReferenceNumber = taxInformationVendTable.panReferenceNumber;
            _taxWithholdTrans.panStatus          = taxInformationVendTable.panStatus;
        }
        else
        {
            _taxWithholdTrans.Nameofdeductee     = DirPartyTable::findRec(custTableLoc.Party).Name;
            _taxWithholdTrans.pan                = taxInformationCustTable.panNumber;
            _taxWithholdTrans.panReferenceNumber = taxInformationCustTable.panReferenceNumber;
            _taxWithholdTrans.panStatus          = taxInformationCustTable.panStatus;
        }

        if (!TaxWithholdTable::find(_taxWithholdTrans.TaxWithholdCode).ApplyThreshold_IN)
        {
            select firstonly AdjustedTaxWithholdAmount from taxWithholdWorkRegulation
                where taxWithholdWorkRegulation.TaxWithholdCode      == _taxWithholdTrans.TaxWithholdCode
                    &&taxWithholdWorkRegulation.SourceTableId        == _taxWithholdTrans.SourceTableId
                    && taxWithholdWorkRegulation.SourceRecId         == _taxWithholdTrans.SourceRecId
                    && taxWithholdWorkRegulation.AdjustedTaxWithholdAmount;

            overlookThreshold = TaxWithholdGroupData::find(_taxWithholdTrans.TaxWithholdGroup, _taxWithholdTrans.TaxWithholdCode).OverlookTax_IN;

            select firstonly ExceptionThreshold, FromDate, ToDate from taxWithholdThresholdLimit
                where taxWithholdThresholdLimit.TaxWithholdComponent      == _taxWithholdTrans.TaxWithholdComponent
                    && (!taxWithholdThresholdLimit.FromDate
                    || (taxWithholdThresholdLimit.FromDate                 <= _taxWithholdTrans.TransDate
                    && taxWithholdThresholdLimit.ToDate                    >= _taxWithholdTrans.TransDate));

            if (overlookThreshold
                || (taxWithholdThresholdLimit.ExceptionThreshold && taxWithholdThresholdLimit.ExceptionThreshold < _taxWithholdTrans.WithholdBaseAmount)
                || taxWithholdWorkRegulation.AdjustedTaxWithholdAmount != 0)
            {
                _taxWithholdTrans.OverlookThreshold = true;
            }

            // if _taxWithholdTrans.TaxWithholdCalculated here, means threshhold has exceed.
            if (taxWithholdThresholdLimit.RecId && _taxWithholdTrans.TaxWithholdCalculated)
            {
                update_recordset taxWithholdTransLoc
                    setting TaxWithholdCalculated = true
                    where taxWithholdTransLoc.TaxWithholdCode           == _taxWithholdTrans.TaxWithholdCode
                            && taxWithholdTransLoc.VendAccount           == _taxWithholdTrans.VendAccount
                            && taxWithholdTransLoc.CustAccount           == _taxWithholdTrans.CustAccount
                            && taxWithholdTransLoc.TaxWithholdGroup      == _taxWithholdTrans.taxWithholdGroup
                            && taxWithholdTransLoc.TaxWithholdCalculated == false
                            && taxWithholdTransLoc.TransDate             >= taxWithholdThresholdLimit.FromDate
                            && taxWithholdTransLoc.TransDate             <= taxWithholdThresholdLimit.ToDate;
            }
            // if adjustment happens, even threshhold not cross, taxWithholdTrans.TaxWithholdCalculated should be yes
            if (_taxWithholdTrans.AdjustedTaxWithholdAmount != 0 || _taxWithholdTrans.TaxWithholdAmountCur != 0)
            {
                _taxWithholdTrans.TaxWithholdCalculated = NoYes::Yes;
            }

            if (taxInformationVendTable)
            {
                if (_taxWithholdTrans.PANStatus  == PANStatus_IN::Received
                    && _taxWithholdTrans.TaxType == TaxWithholdCodeType_IN::TDS
                    && TaxWithholdGroupHeading::find(_taxWithholdTrans.TaxWithholdGroup).IsTransporter_IN
                    && TaxWithholdComponentGroupTable_IN::find(TaxWithholdComponentTable_IN::find(_taxWithholdTrans.TaxWithholdComponent).TaxWithholdComponentGroup).Status == TaxWithholdComponentStatus_IN::Resident)
                {
                    _taxWithholdTrans.Reason = #TransporterMark;
                }
            }

            // priority of different marks:
            // C > T > B > Y > A
            // mark Y for transactions from 2010.4.1 and onwards
            if (_taxWithholdTrans.TaxType        == TaxWithholdCodeType_IN::TDS
                && _taxWithholdTrans.AdjustedTaxWithholdAmount == 0
                && !_taxWithholdTrans.TaxWithholdCalculated
                && _taxWithholdTrans.Reason      == ''
                && _taxWithholdTrans.PANStatus   == PANStatus_IN::Received
                && _taxWithholdTrans.Exempt      == NoYes::No
                && !TaxWithholdGroupHeading::find(_taxWithholdTrans.TaxWithholdGroup).IsTransporter_IN
                && _taxWithholdTrans.TransDate   >= str2date(#MarkWHTTransDueToThresholdFromDate, 321)
                && (NoYes::No == conpeek(_taxWithholdData, #POS_SoftwareDeclReceived)))
            {
                _taxWithholdTrans.Reason = this.getTaxWithholdTransactionReason(_taxWithholdTrans);
            }

            if (_taxWithholdTrans.TaxType == TaxWithholdCodeType_IN::TDS
                && !_taxWithholdTrans.Reason)
            {
                if (_taxWithholdTrans.PANStatus != PANStatus_IN::Received)
                {
                    _taxWithholdTrans.Reason = #PANNonAvailableMark;
                }
                else if (NoYes::Yes == conpeek(_taxWithholdData, #POS_SoftwareDeclReceived))
                {
                    _taxWithholdTrans.Reason = #IsSoftwareDeclReceived;
                    //software transfer already has TDS deducted at rate of 0%, which means it has tds tax deducted
                    _taxWithholdTrans.TaxWithholdCalculated = NoYes::Yes;
                }
            }
        }
        else
        {
            if (_taxWithholdTrans.TaxWithholdCalculated && _taxWithholdTrans.CalcUncalcPostedTrans)
            {
                //update uncalcPosted trans, which should been calculated in this trans
                update_recordset taxWithholdTransLoc
                    setting TaxWithholdCalculated = true
                    where taxWithholdTransLoc.TaxWithholdCode            == _taxWithholdTrans.TaxWithholdCode
                            && taxWithholdTransLoc.VendAccount           == _taxWithholdTrans.VendAccount
                            && taxWithholdTransLoc.CustAccount           == _taxWithholdTrans.CustAccount
                            && taxWithholdTransLoc.TaxWithholdGroup      == _taxWithholdTrans.taxWithholdGroup
                            && taxWithholdTransLoc.TaxWithholdCalculated == false
                            && (!_taxWithholdTrans.ThresholdValidFrom   || taxWithholdTransLoc.TransDate >= _taxWithholdTrans.ThresholdValidFrom)
                            && (!_taxWithholdTrans.ThresholdValidTo     || taxWithholdTransLoc.TransDate <= _taxWithholdTrans.ThresholdValidTo);
            }
        }

        _taxWithholdTrans.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveAndPostFromSubLedgerJournalLinesWHT</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts withhold tax amounts to <c>TaxWithholdTrans_IN</c> and the ledger using <c>TaxWithholdUncommitted_IN</c> and
    ///    <c>SubLedgerJournalLines</c>.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller to use for ledger posting.
    /// </param>
    protected void saveAndPostFromSubLedgerJournalLinesWHT(LedgerPostingController _ledgerPostingController)
    {
        TaxWithholdUncommitted_IN   taxWithholdUncommitted;
        TaxWithholdTrans_IN         taxWithholdTrans;
        CurrencyExchangeHelper      exchangeRateHelper;
        container                   taxWithholdData;
        SalesPurchJournalLine       salesPurchJournalLineLoc;
        LedgerJournalACType         accountTypeLoc;
        boolean                     isTaxTransCreated;
        SourceDocumentHeader        sourceDocumentHeader;
        SourceDocumentLine          sourceDocumentLine;
        SourceDocumentLineRecId     taxTransSourceDocumentLineId;

        SelectableDataArea  currentCompany = curext();
        #ISOCountryRegionCodes

        exchangeRateHelper = CurrencyExchangeHelper::newLedger(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));

        if (!paymcompanyId)
        {
            paymcompanyId = curext();
        }
        if (!companyId)
        {
            companyId = curext();
        }

        ttsbegin;

        while select *
           from taxWithholdUncommitted
           where taxWithholdUncommitted.HeadingRecId   == this.headingRecId()
              && taxWithholdUncommitted.HeadingTableId == this.headingTableId()
              && taxWithholdUncommitted.Company        == this.getCompanyToPost()
        {
            changecompany (taxWithholdUncommitted.Company)
            {
                salesPurchJournalLineLoc = this.getSalesPurchJournalLineFrTaxUnCommitted(taxWithholdUncommitted);

                taxWithholdData = this.setWHTContainerData(salesPurchJournalLineLoc, taxWithholdUncommitted.TaxBaseAmount);

                exchangeRateHelper.parmExchangeRate1(taxWithholdUncommitted.ExchangeRate);
                exchangeRateHelper.parmExchangeRate2(taxWithholdUncommitted.ExchRateSecond);
                exchangeRateHelper.parmExchangeDate(taxWithholdUncommitted.CalculationDate);

                if (salesPurchJournalLineLoc.SourceTableId == tableNum(LedgerJournalTrans))
                {
                    accountTypeLoc = LedgerJournalTrans::findRecId(salesPurchJournalLineLoc.SourceRecId, false).AccountType;
                }

                if (taxWithholdUncommitted.TaxWithholdCode)
                {
                    taxDate = taxWithholdUncommitted.CalculationDate;
                    if (currentCompany == taxWithholdUncommitted.Company)
                    {
                        this.findPostingReference(_ledgerPostingController, taxWithholdUncommitted.Voucher, taxWithholdUncommitted.CalculationDate, taxWithholdUncommitted.SourceTableId, taxWithholdUncommitted.SourceRecId);
                    }

                    taxWithholdTrans.clear();
                    taxWithholdTrans.initFromTaxWithholdUncommitted(taxWithholdUncommitted);

                    this.postToTaxWithHoldTrans(_ledgerPostingController, taxWithholdTrans, exchangeRateHelper, taxWithholdData);

                    if (!isTaxTransCreated)
                    {
                        taxTransSourceDocumentLineId = taxWithholdTrans.SourceDocumentLine;
                        isTaxTransCreated = true;
                    }
                }
            }
        }
        // the SourceRelationshipType on the source document line records needs to change from
        // TaxWithHoldUncommitted_IN to TaxWithholdTrans_IN.
        this.moveSourceDocLineOwnerToTaxWithHoldTrans();

        if (this.allowTaxWithholdAdjustmentDelete())
        {
            // delete any taxWithholding adjustments
            this.deleteTaxWithholdRegulation();
        }

        if (this.allowTaxWithholdUncommittedDelete())
        {
            // after posting, TaxWithholdUncommitted_IN records get removed.
            TaxWithholdUncommitted_IN::deleteForDocumentHeader(this.headingTableId(), headingRecId, false);
        }

        if (isTaxTransCreated)
        {
            // Attempts to create relationship between TaxWithholdTrans_IN and GeneralJournalAccountEntry after TaxWithholdTrans_IN is created
            // because the subledger journal account entries might have been transferred to the ledger prior to the
            // taxTrans records for the source document are created.

            select firstonly RecId from sourceDocumentHeader
                join RecId from sourceDocumentLine
                    where sourceDocumentLine.SourceDocumentHeader == sourceDocumentHeader.RecId
                        && sourceDocumentLine.RecId == taxTransSourceDocumentLineId;

            TaxWHTTransGeneralJournalAccountEntry_IN::generateTaxWHTTransGeneralJourAccEntry(sourceDocumentHeader.RecId);
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveAndPostFromTaxWHTUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method is the main entry point to post to TaxWithholdTrans_IN and to post
    ///    withhold tax amounts to the Ledger using TaxWithholdUncommitted_IN.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller to use for ledger posting.
    /// </param>
    protected void saveAndPostFromTaxWHTUncommitted(LedgerPostingController _ledgerPostingController)
    {
        TaxWithholdUncommitted_IN   taxWithholdUncommitted;
        TaxWithholdTrans_IN         taxWithholdTrans;
        CurrencyExchangeHelper      exchangeRateHelper;
        container                   taxWithholdData;
        SalesPurchJournalLine       salesPurchJournalLineLoc;
        LedgerJournalTrans          ledgerJournalTrans;
        AmountMST                   exchRateDiffTDSForAccounting = 0;
        AmountMSTSecondary          exchRateDiffTDSForReporting = 0;
        Map                         exchRateDiffTDS = new Map(Types::Int64, Types::Container);
        MapEnumerator               exchRateDiffTDSMapEnumerator;
        AmountMST                   exchRateDiffTDSForAccountingFirst, exchRateDiffTDSForAccountingFinal;
        AmountMSTSecondary          exchRateDiffTDSForReportingFirst, exchRateDiffTDSForReportingFinal;
        RefRecId                    ledgerJournalTransRecId;

        SelectableDataArea  currentCompany = curext();
        #ISOCountryRegionCodes

        exchangeRateHelper = CurrencyExchangeHelper::newLedger(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));

        if (!paymcompanyId)
        {
            paymcompanyId = curext();
        }
        if (!companyId)
        {
            companyId = curext();
        }

        ttsbegin;

        while select crossCompany * from taxWithholdUncommitted
            where taxWithholdUncommitted.HeadingTableId  == headingTableId
                && taxWithholdUncommitted.HeadingRecId   == headingRecId
                && taxWithholdUncommitted.Company        == companyId
                && ((taxWithholdUncommitted.Voucher       == voucherInterCompany
                        || taxWithholdUncommitted.Voucher    == voucherSettle)
                    || !voucherInterCompany)
                && taxWithholdUncommitted.CPOrigInvoiceRefRecId == cpOrigRefRecId
        {
            exchRateDiffTDSForAccounting = 0;
            exchRateDiffTDSForReporting  = 0;

            changecompany (taxWithholdUncommitted.Company)
            {
                salesPurchJournalLineLoc = this.getSalesPurchJournalLineFrTaxUnCommitted(taxWithholdUncommitted);

                taxWithholdData = this.setWHTContainerData(salesPurchJournalLineLoc, taxWithholdUncommitted.TaxBaseAmount);

                exchangeRateHelper.parmExchangeRate1(taxWithholdUncommitted.ExchangeRate);
                exchangeRateHelper.parmExchangeRate2(taxWithholdUncommitted.ExchRateSecond);
                exchangeRateHelper.parmExchangeDate(taxWithholdUncommitted.CalculationDate);

                if (taxWithholdUncommitted.TaxWithholdCode)
                {
                    taxDate = taxWithholdUncommitted.CalculationDate;

                    select * from ledgerJournalTrans
                        where ledgerJournalTrans.TableId == taxWithholdUncommitted.SourceTableId &&
                                ledgerJournalTrans.RecId == taxWithholdUncommitted.SourceRecId;

                    exchangeRateHelper.parmReportingExchangeRate1(ledgerJournalTrans.ReportingCurrencyExchRate);
                    exchangeRateHelper.parmReportingExchangeRate2(ledgerJournalTrans.ReportingCurrencyExchRateSecondary);

                    if (currentCompany == taxWithholdUncommitted.Company)
                    {
                        if (companyId != paymcompanyId
                            && voucherInterCompany)
                        {
                            this.findPostingReference(_ledgerPostingController, voucherInterCompany, taxWithholdUncommitted.CalculationDate, taxWithholdUncommitted.SourceTableId, taxWithholdUncommitted.SourceRecId);
                        }
                        else
                        {
                            this.findPostingReference(_ledgerPostingController, taxWithholdUncommitted.Voucher, taxWithholdUncommitted.CalculationDate, taxWithholdUncommitted.SourceTableId, taxWithholdUncommitted.SourceRecId);
                        }
                        
                        _ledgerPostingController.getReference().lastTransTxt(ledgerJournalTrans.Txt);
                    }

                    taxWithholdTrans.clear();
                    taxWithholdTrans.initFromTaxWithholdUncommitted(taxWithholdUncommitted);

                    this.postToTaxWithHoldTrans(_ledgerPostingController, taxWithholdTrans, exchangeRateHelper, taxWithholdData);

                    if (ledgerJournalTrans.SettleVoucher == SettlementType::SelectedTransact && taxWithholdUncommitted.sourceTaxAmountCur)
                    {
                        this.updateTaxWithholdTrans(ledgerJournalTrans.TableId, ledgerJournalTrans.RecId, taxWithholdUncommitted.TaxWithholdGroup, taxWithholdUncommitted.TaxWithholdCode);
                    }

                    if (taxWithholdTrans.TaxType == TaxWithholdCodeType_IN::TDS
                        && (VendTable::find(taxWithholdTrans.VendAccount).isForeign() || taxWithholdTrans.CurrencyCode != Ledger::accountingCurrency()))
                    {
                        if (LedgerJournalTrans_Tax_Extension::isVendorPayment(ledgerJournalTrans))
                        {
                            exchRateDiffTDSForAccounting = exchangeRateHelper.calculateTransactionToAccounting(taxWithholdTrans.CurrencyCode, taxWithholdTrans.TaxWithholdAmountCur, true);
                            exchRateDiffTDSForReporting  = exchangeRateHelper.calculateTransactionCurrencyToReportingCurrency(taxWithholdTrans.CurrencyCode, taxWithholdTrans.TaxWithholdAmountCur);
                            //For a foreign vendor applied TDS, then TT buying rate(TDS exchange rate) is used for the conversion from transaction currency to accounting currency and reporting currency.
                            exchangeRateHelper.parmExchangeRate1(conPeek(taxWithholdData, #TDSExchRate));
                            exchangeRateHelper.parmExchangeRate2(conPeek(taxWithholdData, #TDSExchRateSecond));
                            exchangeRateHelper.parmReportingExchangeRate1(conPeek(taxWithholdData, #TDSExchRateRep));

                            exchRateDiffTDSForAccounting -= exchangeRateHelper.calculateTransactionToAccounting(taxWithholdTrans.CurrencyCode, taxWithholdTrans.TaxWithholdAmountCur, true);
                            exchRateDiffTDSForReporting  -= exchangeRateHelper.calculateTransactionCurrencyToReportingCurrency(taxWithholdTrans.CurrencyCode, taxWithholdTrans.TaxWithholdAmountCur);
                        }
                        else
                        {
                            //For a foreign vendor applied TDS, then TT buying rate(TDS exchange rate) is used for the conversion from transaction currency to accounting currency and reporting currency.
                            exchangeRateHelper.parmExchangeRate1(conPeek(taxWithholdData, #TDSExchRate));
                            exchangeRateHelper.parmExchangeRate2(conPeek(taxWithholdData, #TDSExchRateSecond));
                            exchangeRateHelper.parmReportingExchangeRate1(conPeek(taxWithholdData, #TDSExchRateRep));
                        }
                    }

                    this.postToLedger(_ledgerPostingController, taxWithholdTrans, exchangeRateHelper, LedgerDimensionFacade::serviceCreateLedgerDimension(taxWithholdUncommitted.LedgerDimensionDefaultAccount, ledgerJournalTrans.DefaultDimension ? ledgerJournalTrans.DefaultDimension : ledgerJournalTrans.OffsetDefaultDimension));

                    // For customer payment, when parameter Tax liability is enabled, post interim account to tax withhold trans;
                    // Meanwhile, post interim account to ledger. 
                    if (LedgerJournalTrans::isCustomerPaymentByAccounts(ledgerJournalTrans)
                        && TaxWithholdGroupHeading::find(taxWithholdTrans.TaxWithholdGroup).TaxLiabilityOnPayment_IN)
                    {
                        taxWithholdTrans.initFromTaxWithholdTrans(taxWithholdTrans, -1);
                        taxWithholdTrans.IsTaxInterim = NoYes::Yes;
                        taxWithholdTrans.IsPartOfTurnOver = NoYes::No;
                        taxWithholdTrans.LedgerDimension = TaxWithholdTable::find(taxWithholdTrans.TaxWithholdCode).InterimAccount_IN;

                        this.postToTaxWithHoldTrans(_ledgerPostingController, taxWithholdTrans, exchangeRateHelper, taxWithholdData);

                        this.postToLedger(_ledgerPostingController, taxWithholdTrans, exchangeRateHelper, LedgerDimensionFacade::serviceCreateLedgerDimension(taxWithholdTrans.LedgerDimension, ledgerJournalTrans.DefaultDimension ? ledgerJournalTrans.DefaultDimension : ledgerJournalTrans.OffsetDefaultDimension));
                    }

                    if (exchRateDiffTDS.exists(ledgerJournalTrans.RecId))
                    {
                        [exchRateDiffTDSForAccountingFirst,exchRateDiffTDSForReportingFirst] = exchRateDiffTDS.lookup(ledgerJournalTrans.RecId);
                        exchRateDiffTDS.remove(ledgerJournalTrans.RecId);
                        exchRateDiffTDS.insert(ledgerJournalTrans.RecId, [(exchRateDiffTDSForAccounting + exchRateDiffTDSForAccountingFirst) , (exchRateDiffTDSForReporting + exchRateDiffTDSForReportingFirst)]);
                    }
                    else
                    {
                        exchRateDiffTDS.insert(ledgerJournalTrans.RecId, [exchRateDiffTDSForAccounting, exchRateDiffTDSForReporting]);
                    }
                }
            }
        }
        exchRateDiffTDSMapEnumerator = exchRateDiffTDS.getEnumerator();

        while (exchRateDiffTDSMapEnumerator.moveNext())
        {
            ledgerJournalTransRecId = exchRateDiffTDSMapEnumerator.currentKey();
            [exchRateDiffTDSForAccountingFinal, exchRateDiffTDSForReportingFinal] = exchRateDiffTDSMapEnumerator.currentValue();
            if (exchRateDiffTDSForAccountingFinal != 0 || exchRateDiffTDSForReportingFinal != 0)
            {
                this.postExchRateDiff(exchRateDiffTDSForAccountingFinal,
                exchRateDiffTDSForReportingFinal,
                conPeek(taxWithholdData, #4),
                _ledgerPostingController,
                LedgerJournalTrans::findRecId(ledgerJournalTransRecId, false));
            }
        }

        if (this.allowTaxWithholdAdjustmentDelete())
        {
            // delete any taxWithholding adjustments
            this.deleteTaxWithholdRegulation();
        }

        if (this.allowTaxWithholdUncommittedDelete())
        {
            // after posting, TaxWithholdUncommitted_IN records get removed.
            TaxWithholdUncommitted_IN::deleteForDocumentHeader(headingTableId, headingRecId, false);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postExchRateDiff</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post the TT buying rate and GAAP rate difference to Currency gain/loss account.
    /// </summary>
    /// <param name="_exchRateDiff">
    /// The amount in accounting currency.
    /// </param>
    /// <param name="_exchRateReportingDiff">
    /// The amount in reporting currency.
    /// </param>
    /// <param name="_currencyCode">
    /// The currency code.
    /// </param>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal transaction related to exchange rate difference.
    /// </param>
    protected void postExchRateDiff(
        AmountMST               _exchRateDiff,
        AmountMSTSecondary      _exchRateReportingDiff,
        CurrencyCode            _currencyCode,
        LedgerPostingController _ledgerPostingController,
        LedgerJournalTrans      _ledgerJournalTrans = null)
    {
        LedgerDimensionDefaultAccount   exchGainLossLedgerDimension;

        // find the ledger account for the gain or loss this will be the account for the invoice company MST currency
        exchGainLossLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountLossProfit(-_exchRateDiff, _currencyCode), _ledgerJournalTrans.DefaultDimension);

        this.postExchRateLedgerTrans(_ledgerPostingController, exchGainLossLedgerDimension, _currencyCode, _exchRateDiff, _exchRateReportingDiff, _ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountLossProfit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the ledger dimension.
    /// </summary>
    /// <param name="_exchRateDiff">
    /// The amount caused by exchange rate.
    /// </param>
    /// <param name="_currencyCode">
    /// The currency code.
    /// </param>
    /// <returns>
    /// The ledger dimension.
    /// </returns>
    public LedgerDimensionDefaultAccount accountLossProfit(Amount _exchRateDiff, CurrencyCode _currencyCode)
    {
        LedgerDimensionDefaultAccount defaultAccount;
        CurrencyGainLossAccountType   accountType;

        if (_exchRateDiff > 0)
        {
            accountType = CurrencyGainLossAccountType::RealizedGain;
        }
        else
        {
            accountType = CurrencyGainLossAccountType::RealizedLoss;
        }

        defaultAccount = CurrencyLedgerGainLossAccount::ledgerDimension(
            Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
            _currencyCode,
            accountType);

        return defaultAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postExchRateLedgerTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post the TT buying rate and GAAP rate difference to Currency gain/loss account.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller.
    /// </param>
    /// <param name="_exchGainLossLedgerDimension">
    /// Ledger dimension of exchGain/Loss transaction.
    /// </param>
    /// <param name="_currencyCode">
    /// The currency code.
    /// </param>
    /// <param name="_exchRateDiff">
    /// The amount in accounting currency.
    /// </param>
    /// <param name="_exchRateReportingDiff">
    /// The amount in reporting currency.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal transaction related to exchange rate difference.
    /// </param>
    protected void postExchRateLedgerTrans(LedgerPostingController         _ledgerPostingController,
        LedgerDimensionDefaultAccount   _exchGainLossLedgerDimension,
        CurrencyCode                    _currencyCode,
        AmountMST                       _exchRateDiff,
        AmountMSTSecondary              _exchRateReportingDiff,
        LedgerJournalTrans              _ledgerJournalTrans = null)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject;
        LedgerPostingType        ledgerPostingTypeLoc;
        LedgerDimensionAccount   ledgerDimension;

        ledgerPostingTypeLoc = this.getLedgerPostingType_ExchRate(-_exchRateDiff);
        ledgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(_exchGainLossLedgerDimension);

        if (_exchRateDiff)
        {
            ledgerVoucherTransObject = LedgerVoucherTransObject::newAdjustmentDefault(_ledgerPostingController.getJournal().findLedgerVoucherObject(_ledgerJournalTrans.Voucher, _ledgerJournalTrans.Transdate),
                                                                        ledgerPostingTypeLoc,
                                                                        ledgerDimension,
                                                                        _currencyCode,
                                                                        _exchRateDiff,
                                                                        _exchRateReportingDiff);

            _ledgerPostingController.getJournal().addTrans(ledgerVoucherTransObject);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerPostingType_ExchRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the ledger posting type by the amount caused by exchange rate difference.
    /// </summary>
    /// <param name="_exchRateDiff">
    /// The amount caused by exchange rate difference.
    /// </param>
    /// <returns>
    /// Returns the posting type.
    /// </returns>
    public LedgerPostingType getLedgerPostingType_ExchRate(Amount _exchRateDiff)
    {
        return (_exchRateDiff > 0 ? LedgerPostingType::ExchRateGain : LedgerPostingType::ExchRateLoss);
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveAndPostFromTmpTaxWHTWorkTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method is the main entry point to post to TaxWithholdTrans_IN
    ///    and to post withhold tax amounts to the Ledger using TmpTaxWithholdWorkTrans_IN.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller to use for ledger posting.
    /// </param>
    protected void saveAndPostFromTmpTaxWHTWorkTrans(LedgerPostingController _ledgerPostingController)
    {
        TaxWithholdTrans_IN         taxWithholdTrans;
        CurrencyExchangeHelper      exchangeRateHelper;
        container                   taxWithholdData;
        ExchRate                    reportingExchangeRate;
        SalesPurchJournalLine       salesPurchJournalLineLoc;
        CustInvoiceTrans            custInvoiceTransloc;
        LedgerJournalTrans          ledgerJournalTransloc;
        LedgerJournalACType         accountTypeLoc;
        LedgerDimensionAccount      ledgerDimension;
        AmountMST                   exchRateDiffTDSForAccounting = 0;
        AmountMSTSecondary          exchRateDiffTDSForReporting = 0;
        Map                         exchRateDiffTDS = new Map(Types::Int64, Types::Container);
        MapEnumerator               exchRateDiffTDSMapEnumerator;
        AmountMST                   exchRateDiffTDSForAccountingFirst, exchRateDiffTDSForAccountingFinal;
        AmountMSTSecondary          exchRateDiffTDSForReportingFirst, exchRateDiffTDSForReportingFinal;
        RefRecId                    ledgerJournalTransRecId;

        SelectableDataArea  currentCompany = curext();
        #ISOCountryRegionCodes

        exchangeRateHelper = CurrencyExchangeHelper::newLedger(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));
        if(origHeadingTableId == tableNum(SalesTable))
        {
            reportingExchangeRate = SalesTable::findRecId(origHeadingRecId).ReportingCurrencyFixedExchRate;
        }

        if (!paymcompanyId)
        {
            paymcompanyId = curext();
        }
        if (!companyId)
        {
            companyId = curext();
        }

        ttsbegin;

        while select *
           from taxWithholdWorkTrans
           where taxWithholdWorkTrans.HeadingRecId   == this.headingRecId()
              && taxWithholdWorkTrans.HeadingTableId == this.headingTableId()
              && taxWithholdWorkTrans.CompanyAccount == this.getCompanyToPost()
        {
            exchRateDiffTDSForAccounting = 0;
            exchRateDiffTDSForReporting  = 0;

            changecompany (taxWithholdWorkTrans.CompanyAccount)
            {
                salesPurchJournalLineLoc = this.getSalesPurchJournalLineFromTmpTax(taxWithholdWorkTrans);

                taxWithholdData = this.setWHTContainerData(salesPurchJournalLineLoc, taxWithholdWorkTrans.TaxBaseAmount);

                exchangeRateHelper.parmExchangeRate1(taxWithholdWorkTrans.ExchangeRate);
                exchangeRateHelper.parmExchangeRate2(taxWithholdWorkTrans.ExchRateSecond);
                if(reportingExchangeRate != 0)
                {
                    exchangeRateHelper.parmReportingExchangeRate1(reportingExchangeRate);
                }
                exchangeRateHelper.parmExchangeDate(taxWithholdWorkTrans.CalculationDate);

                if (taxWithholdWorkTrans.SourceTableId == tableNum(CustInvoiceTrans))
                {
                    custInvoiceTransloc = CustInvoiceTrans::findRecId(taxWithholdWorkTrans.SourceRecId);
                    ledgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(taxWithholdWorkTrans.LedgerDimensionDefaultAccount, custInvoiceTransloc.DefaultDimension);
                }

                if (salesPurchJournalLineLoc.SourceTableId == tableNum(LedgerJournalTrans))
                {
                    ledgerJournalTransloc = LedgerJournalTrans::findRecId(salesPurchJournalLineLoc.SourceRecId, false);
                    accountTypeLoc  = ledgerJournalTransloc.AccountType;
                    ledgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(taxWithholdWorkTrans.LedgerDimensionDefaultAccount, ledgerJournalTransloc.DefaultDimension);
                }

                if (taxWithholdWorkTrans.SourceTableId == tableNum(ProjInvoiceRevenue)
                    || taxWithholdWorkTrans.SourceTableId == tableNum(ProjInvoiceItem)
                    || taxWithholdWorkTrans.SourceTableId == tableNum(ProjInvoiceOnAcc))
                {
                    ledgerDimension = this.getProjLedgerDimension(taxWithholdWorkTrans, salesPurchJournalLineLoc);
                }

                if (taxWithholdWorkTrans.TaxWithholdCode)
                {
                    taxDate = taxWithholdWorkTrans.CalculationDate;
                    if (currentCompany == taxWithholdWorkTrans.CompanyAccount)
                    {
                        this.findPostingReference(_ledgerPostingController, taxWithholdWorkTrans.Voucher, taxWithholdWorkTrans.CalculationDate, taxWithholdWorkTrans.SourceTableId, taxWithholdWorkTrans.SourceRecId);
                    }

                    taxWithholdTrans.clear();
                    taxWithholdTrans.initFromTaxWithholdWorkTrans(taxWithholdWorkTrans);

                    this.postToTaxWithHoldTrans(_ledgerPostingController, taxWithholdTrans, exchangeRateHelper, taxWithholdData);
                    if (taxWithholdWorkTrans.SourceTableId == tableNum(ProjInvoiceRevenue)
                        || taxWithholdWorkTrans.SourceTableId == tableNum(ProjInvoiceItem)
                        || taxWithholdWorkTrans.SourceTableId == tableNum(ProjInvoiceOnAcc))
                    {
                        ledgerDimension = this.getProjLedgerDimension(taxWithholdWorkTrans, salesPurchJournalLineLoc);
                    }

                    if (ledgerJournalTransloc.SettleVoucher == SettlementType::SelectedTransact && taxWithholdWorkTrans.sourceTaxAmountCur)
                    {
                        this.updateTaxWithholdTrans(ledgerJournalTransloc.TableId, ledgerJournalTransloc.RecId, taxWithholdWorkTrans.TaxWithholdGroup, taxWithholdWorkTrans.TaxWithholdCode);
                    }

                    if (taxWithholdTrans.TaxType == TaxWithholdCodeType_IN::TDS
                        && VendTable::find(taxWithholdTrans.VendAccount).isForeign())
                    {
                        exchRateDiffTDSForAccounting += exchangeRateHelper.calculateTransactionToAccounting(taxWithholdTrans.CurrencyCode, taxWithholdTrans.TaxWithholdAmountCur, true);
                        exchRateDiffTDSForReporting  += exchangeRateHelper.calculateTransactionCurrencyToReportingCurrency(taxWithholdTrans.CurrencyCode, taxWithholdTrans.TaxWithholdAmountCur);

                        //For a foreign vendor applied TDS, then TT buying rate(TDS exchange rate) is used for the conversion from transaction currency to accounting currency and reporting currency.
                        exchangeRateHelper.parmExchangeRate1(conPeek(taxWithholdData, #TDSExchRate));
                        exchangeRateHelper.parmExchangeRate2(conPeek(taxWithholdData, #TDSExchRateSecond));

                        exchRateDiffTDSForAccounting -= exchangeRateHelper.calculateTransactionToAccounting(taxWithholdTrans.CurrencyCode, taxWithholdTrans.TaxWithholdAmountCur, true);
                        exchRateDiffTDSForReporting  -= exchangeRateHelper.calculateTransactionCurrencyToReportingCurrency(taxWithholdTrans.CurrencyCode, taxWithholdTrans.TaxWithholdAmountCur);
                    }

                    this.postToLedger(_ledgerPostingController, taxWithholdTrans, exchangeRateHelper, ledgerDimension);
                    
                    if (exchRateDiffTDS.exists(ledgerJournalTransloc.RecId))
                    {
                        [exchRateDiffTDSForAccountingFirst,exchRateDiffTDSForReportingFirst] = exchRateDiffTDS.lookup(ledgerJournalTransloc.RecId);
                        exchRateDiffTDS.remove(ledgerJournalTransloc.RecId);
                        exchRateDiffTDS.insert(ledgerJournalTransloc.RecId, [(exchRateDiffTDSForAccounting + exchRateDiffTDSForAccountingFirst) , (exchRateDiffTDSForReporting + exchRateDiffTDSForReportingFirst)]);
                    }
                    else
                    {
                        exchRateDiffTDS.insert(ledgerJournalTransloc.RecId, [exchRateDiffTDSForAccounting, exchRateDiffTDSForReporting]);
                    }
                }
            }
        }

        exchRateDiffTDSMapEnumerator = exchRateDiffTDS.getEnumerator();

        while (exchRateDiffTDSMapEnumerator.moveNext())
        {
            ledgerJournalTransRecId = exchRateDiffTDSMapEnumerator.currentKey();
            [exchRateDiffTDSForAccountingFinal, exchRateDiffTDSForReportingFinal] = exchRateDiffTDSMapEnumerator.currentValue();
            if (exchRateDiffTDSForAccountingFinal != 0 || exchRateDiffTDSForReportingFinal != 0)
            {
                this.postExchRateDiff(exchRateDiffTDSForAccountingFinal,
                exchRateDiffTDSForReportingFinal,
                conPeek(taxWithholdData, #4),
                _ledgerPostingController,
                LedgerJournalTrans::findRecId(ledgerJournalTransRecId, false));
            }
        }

        if (this.allowTaxWithholdAdjustmentDelete())
        {
            // delete any taxWithholding adjustments
            this.deleteTaxWithholdRegulation();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveAndPostWHT</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method is the main entry point to post to TaxWithholdTrans_IN and to post
    ///    withhold tax amounts to the Ledger.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller to use for ledger posting.
    /// </param>
    public void saveAndPostWHT(LedgerPostingController _ledgerPostingController)
    {
        this.validate();

        this.initLedgerPosting(_ledgerPostingController);

        select count(RecId) from taxWithholdWorkTrans;

        if (taxWithholdWorkTrans.RecId > 0 && !this.useSubLedgerJournalLines())
        {
            this.saveAndPostFromTmpTaxWHTWorkTrans(_ledgerPostingController);
        }
        else
        {
            if (this.useSubLedgerJournalLines())
            {
                this.saveAndPostFromSubLedgerJournalLinesWHT(_ledgerPostingController);
            }
            else
            {
                this.saveAndPostFromTaxWHTUncommitted(_ledgerPostingController);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCPOrigRefRecid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the value of original refenrence record Id.
    /// </summary>
    /// <param name="_recId">
    /// Given record Id.
    /// </param>
    public void setCPOrigRefRecid(RecId   _recId)
    {
        cpOrigRefRecId = _recId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCreditNoteAmount</Name>
				<Source><![CDATA[
    private container setCreditNoteAmount(TaxWithholdTrans_IN  _taxwithholdTrans,
                                          Qty                   _qty)
    {
        container   creditNoteAmount;
        container   returnAmount;
        int         numOfPennies;
        Counter     counterI = 1;

        creditNoteAmount = conPoke(creditNoteAmount, 1, _taxwithholdTrans.TaxWithholdBaseAmountCur);
        creditNoteAmount = conPoke(creditNoteAmount, 2, _taxwithholdTrans.TaxWithholdAmountCur);
        creditNoteAmount = conPoke(creditNoteAmount, 3, _taxwithholdTrans.AdjustedBaseAmount);
        creditNoteAmount = conPoke(creditNoteAmount, 4, _taxwithholdTrans.AdjustedTaxWithholdAmount);
        creditNoteAmount = conPoke(creditNoteAmount, 5, _taxwithholdTrans.WithholdBaseAmount);
        creditNoteAmount = conPoke(creditNoteAmount, 6, _taxwithholdTrans.TaxWithholdAmount);
        creditNoteAmount = conPoke(creditNoteAmount, 7, _taxwithholdTrans.TaxWithholdAmountOrigin);
        creditNoteAmount = conPoke(creditNoteAmount, 8, _taxwithholdTrans.TaxTaxWithholdAmount);
        creditNoteAmount = conPoke(creditNoteAmount, 9, _taxwithholdTrans.AmountOriginMST);

        for (counterI = 1; counterI <= conLen(creditNoteAmount); counterI++)
        {
            if (conPeek(creditNoteAmount, counterI))
            {
                numOfPennies = real2int(conPeek(creditNoteAmount, counterI) * _qty * 100 mod 100);
                if (numOfPennies &&
                    (counterI == 2 || counterI == 4 || counterI == 6 || counterI == 8))
                {
                    returnAmount = conPoke(returnAmount, counterI, CurrencyExchangeHelper::amount(round(conPeek(creditNoteAmount, counterI) * _qty - 1 / 2, 1)));
                }
                else
                {
                    returnAmount = conPoke(returnAmount, counterI, CurrencyExchangeHelper::amount(conPeek(creditNoteAmount, counterI) * _qty));
                }
            }
            else
            {
                returnAmount = conPoke(returnAmount, counterI, conPeek(creditNoteAmount, counterI));
            }
        }
        return returnAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setExchRates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets and sets the currency and exchange rate information about withhold tax.
    /// </summary>
    /// <param name="_sourceCurrencyCode">
    /// The currency code of the transaction; optional.
    /// </param>
    /// <param name="_exchRate">
    ///    The primary exchange rate that will be used for currency conversions between transactional and
    ///    master currency; optional.
    /// </param>
    /// <param name="_exchRateSecond">
    ///    The secondary exchange rate that will be used for currency conversions between transactional and
    ///    master currency; optional.
    /// </param>
    /// <param name="_exchRatesTriangulation">
    /// A Boolean value that specifies whether triangulation is required; optional.
    /// </param>
    /// <param name="_exchRateDate">
    /// The date for the given exchange rate; optional.
    /// </param>
    void setExchRates(  CurrencyCode            _sourceCurrencyCode     = sourceCurrencyCode,
                        ExchRate                _exchRate               = exchRate,
                        ExchRate                _exchRateSecond         = exchRateSecond,
                        ExchRatesTriangulation  _exchRatesTriangulation = UnknownNoYes::Unknown,
                        TransDate               _exchRateDate                = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        sourceCurrencyCode  = _sourceCurrencyCode;
        triangulation = Currency::unknownNoYes2Noyes(_exchRatesTriangulation, _sourceCurrencyCode, _exchRateDate);
        exchRate = _exchRate;
        exchRateSecond = _exchRateSecond;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInvoiceAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets invoice account information.
    /// </summary>
    /// <param name="_accountNumber">
    /// The account number.
    /// </param>
    public void setInvoiceAccount(CustVendAC   _accountNumber)
    {
        invoiceAccount = _accountNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInvoiceAndPaymentData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets invoice and payment data.
    /// </summary>
    /// <param name="_specTrans">
    /// The spec transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal transaction.
    /// </param>
    /// <param name="_paymentCompany">
    /// The payment company id.
    /// </param>
    public void setInvoiceAndPaymentData(
        SpecTrans           _specTrans,
        LedgerJournalTrans  _ledgerJournalTrans = null,
        CompanyId           _paymentCompany = curext())
    {
        container   vendorInformation;

        vendorInformation = TaxWithholdCalculation_IN::getVendorInformation(_specTrans, _ledgerJournalTrans, _paymentCompany);
        this.setInvoiceCompany(conPeek(vendorInformation, 5));
        this.setPaymentCompany(conPeek(vendorInformation, 6));
        this.setPaymentAccount('');
        this.setInvoiceAccount(conPeek(vendorInformation, 1));
        this.setInvoiceVoucher(conPeek(vendorInformation, 7));
        this.setJournalLineCompany(_ledgerJournalTrans.Company);
        this.setSpecRefRecid(_specTrans.RefRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInvoiceCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets invoice company.
    /// </summary>
    /// <param name="_companyId">
    /// The company id.
    /// </param>
    public void setInvoiceCompany(CompanyId   _companyId = curext())
    {
         companyId = _companyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInvoiceVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets invoice voucher information.
    /// </summary>
    /// <param name="_invoiceVoucher">
    /// The invoice voucher information.
    /// </param>
    public void setInvoiceVoucher(Voucher   _invoiceVoucher)
    {
        invoiceVoucher = _invoiceVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setJournalLineCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets journal line company.
    /// </summary>
    /// <param name="_companyId">
    /// The company id.
    /// </param>
    public void setJournalLineCompany(CompanyId   _companyId = curext())
    {
         journalLineCompany = _companyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLedgerData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the ledger data information.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal transaction.
    /// </param>
    /// <param name="_grossAmount">
    /// The gross amount.
    /// </param>
    /// <returns>
    /// The ledger data.
    /// </returns>
    public container setLedgerData(LedgerJournalTrans _ledgerJournalTrans,
                                   real               _grossAmount)
    {
        container               taxWithholdData;
        TransTaxInformation     transTaxInformation;

        transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(_ledgerJournalTrans);

        #define.13(13)

        taxWithholdData = conNull();
        taxWithholdData = conPoke(taxWithholdData, #1, _ledgerJournalTrans.ExchRate);
        taxWithholdData = conPoke(taxWithholdData, #2, _ledgerJournalTrans.ExchRateSecond);
        taxWithholdData = conPoke(taxWithholdData, #3, Currency::noYes2UnknownNoYes(_ledgerJournalTrans.Triangulation));
        taxWithholdData = conPoke(taxWithholdData, #4, _ledgerJournalTrans.CurrencyCode);
        taxWithholdData = conPoke(taxWithholdData, #5, _grossAmount);
        taxWithholdData = conPoke(taxWithholdData, #6, TaxModuleType::Voucher);
        taxWithholdData = conPoke(taxWithholdData, #7, _ledgerJournalTrans.DefaultDimension);
        taxWithholdData = conPoke(taxWithholdData, #8, _ledgerJournalTrans.TableId);
        taxWithholdData = conPoke(taxWithholdData, #9, _ledgerJournalTrans.RecId);
        taxWithholdData = conPoke(taxWithholdData, #10, _ledgerJournalTrans.Voucher);
        taxWithholdData = conPoke(taxWithholdData, #11, _ledgerJournalTrans.Invoice);
        taxWithholdData = conPoke(taxWithholdData, #12, _ledgerJournalTrans.LineNum);
        taxWithholdData = conPoke(taxWithholdData, #13, _ledgerJournalTrans.ledgerJournalTable().JournalType);
        taxWithholdData = conPoke(taxWithholdData, #14, _ledgerJournalTrans.SettleVoucher);
        taxWithholdData = conPoke(taxWithholdData, #15, transTaxInformation.CompanyLocation);
        taxWithholdData = conPoke(taxWithholdData, #16, transTaxInformation.TaxWithholdNatureOfAssessee);
        taxWithholdData = conPoke(taxWithholdData, #17, dateNull());
        taxWithholdData = conPoke(taxWithholdData, #18, '');

        return taxWithholdData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaymentAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets payment account information.
    /// </summary>
    /// <param name="_paymentAccount">
    /// The payment account.
    /// </param>
    public void setPaymentAccount(CustVendAC    _paymentAccount)
    {
        paymentAccount = _paymentAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaymentCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets payment company information.
    /// </summary>
    /// <param name="_companyId">
    /// The company id.
    /// </param>
    public void setPaymentCompany(CompanyId   _companyId = curext())
    {
        paymcompanyId = _companyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSpecRefRecid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets spec reference rec id.
    /// </summary>
    /// <param name="_recId">
    /// The rec id.
    /// </param>
    public void setSpecRefRecid(RecId   _recId)
    {
        specRefRecId = _recId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSpecTransBuffer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the spec trans buffer.
    /// </summary>
    /// <param name="_specTrans">
    /// The spec trans information.
    /// </param>
    public void setSpecTransBuffer(SpecTrans   _specTrans)
    {
        specTransForCP.data(_specTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxWithholdAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets tax withhold amount.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal trans.
    /// </param>
    /// <param name="_account">
    /// The account number.
    /// </param>
    /// <param name="_invoiceCompany">
    /// The invoice company id.
    /// </param>
    /// <returns>
    /// The tax withhold amount.
    /// </returns>
    public real setTaxWithholdAmount(LedgerJournalTrans   _ledgerJournalTrans,
                                     AccountNum           _account = '',
                                     CompanyId            _invoiceCompany = curext())
    {
        TaxWithholdTrans_IN    taxWithHoldTrans;
        TaxWithholdTrans_IN    taxWithholdTransLoc;
        real                   chargeAmount;
        int                    sign = -1;

        if (!paymcompanyId)
        {
            paymcompanyId = curext();
        }

        if (_invoiceCompany != paymcompanyId)
        {
            changecompany(_invoiceCompany)
            {
                select CustAccount, VendAccount, TaxType from taxWithholdTransLoc
                    where taxWithholdTransLoc.SettlementVoucher == _ledgerJournalTrans.Voucher
                       && taxWithholdTransLoc.TransDate         == _ledgerJournalTrans.TransDate;

                if (taxWithholdTransLoc.VendAccount && taxWithholdTransLoc.TaxType == TaxWithholdCodeType_IN::TCS)
                {
                    sign = -1;
                }
                if (taxWithholdTransLoc.CustAccount)
                {
                    sign = -1;
                }

                while select TaxWithholdAmountCur, AdjustedTaxWithholdAmount from taxWithHoldTrans
                    where taxWithHoldTrans.SettlementVoucher == _ledgerJournalTrans.Voucher
                       && taxWithHoldTrans.TransDate         == _ledgerJournalTrans.TransDate
                {
                    if (taxWithHoldTrans.AdjustedTaxWithholdAmount)
                    {
                        chargeAmount += taxWithHoldTrans.AdjustedTaxWithholdAmount * sign ;
                    }
                    else
                    {
                        chargeAmount += taxWithHoldTrans.TaxWithholdAmountCur * sign;
                    }
                }
            }
        }
        else
        {
            while select TaxWithholdAmountCur, AdjustedTaxWithholdAmount from taxWithHoldTrans
                    where taxWithHoldTrans.Voucher       == _ledgerJournalTrans.Voucher
                       && taxWithHoldTrans.TransDate     == _ledgerJournalTrans.TransDate
                       && (taxWithHoldTrans.CustAccount  == _account
                       ||  taxWithHoldTrans.VendAccount  == _account)
            {
                if (taxWithHoldTrans.AdjustedTaxWithholdAmount)
                {
                    chargeAmount += taxWithHoldTrans.AdjustedTaxWithholdAmount * -1;
                }
                else
                {
                    chargeAmount += taxWithHoldTrans.TaxWithholdAmountCur * -1;
                }
            }
        }
        return chargeAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setVoucherInterCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets interCompany voucher
    /// </summary>
    /// <param name="_voucher">
    /// Intercompany voucher
    /// </param>
    public void setVoucherInterCompany(voucher _voucher)
    {
        voucherInterCompany = _voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setVoucherSettle</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets settle voucher for CP direct settlement
    /// </summary>
    /// <param name="_voucher">
    /// Intercompany voucher
    /// </param>
    public void setVoucherSettle(voucher _voucher)
    {
        voucherSettle = _voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWHTContainerData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets WHT container data.
    /// </summary>
    /// <param name="_line">
    /// The line information.
    /// </param>
    /// <param name="_grossAmount">
    /// The gross amount.
    /// </param>
    /// <returns>
    /// The WHT container data.
    /// </returns>
    public container setWHTContainerData(
        Common  _line,
        real    _grossAmount)
    {
        container               taxWithholdData;
        LedgerJournalTrans      ledgerJournalTransLoc;
        PurchLine               purchLineLoc;
        PurchLine_IN            purchLineLoc_IN;
        PurchTable              purchTableLoc;
        VendInvoiceInfoLine     vendInvoiceInfoLineLoc;
        VendInvoiceInfoTable    vendInvoiceInfoTableLoc;
        CurrencyCode            currencyCodeLoc;
        TaxModuleType           taxModuleTypeLoc;
        DimensionDefault        dimensionDefaultLoc;
        RefTableId              sourceTableIdLoc;
        RefRecId                sourceRecIdLoc;
        Voucher                 voucherLoc;
        InvoiceId               invoiceLoc;
        LineNum                 lineNumLoc;
        SettlementType          settlementTypeLoc;
        LedgerJournalType       ledgerJournalTypeLoc;
        LogisticsLocationRecId  companyLocationLoc;
        NatureOfAssessee_IN     natureOfAssesseeLoc;
        TransDate               creditNoteDate;
        PurchOrderedQty         quantityLoc;
        Voucher                 taxWithholdVoucher;
        LineNum                 taxWithholdLineNum;
        ExchRate                exchangeRate;
        ExchrateSecondary       exchangeRateSecond;
        VendInvoiceInfoTableTaxExtension_IN  vendInvoiceInfoTableTaxLoc;
        NoYes                   softwareDeclReceived;
        TransTaxInformation     transTaxInformation;
        ExchRate                tdsExchangeRate; // TT buying rate used only by TDS
        ExchrateSecondary       tdsExchangeRateSecond; // TT buying rate used only by TDS
        EUROTriangulation       tdsTriangulation; // TT buying rate used only by TDS
        ExchRate                tdsExchangeRateRep; // TT buying rate used only by TDS

        #define.13(13)

        void setValues(CurrencyCode _currencyCode, TaxModuleType _taxModuleType, DimensionDefault _dimensionDefault,
                       RefTableId _sourceTableId, RefRecId _sourceRecId, Voucher _voucher, InvoiceId _invoiceNum, LineNum _lineNum,
                       LedgerJournalType _ledgerJournalType, SettlementType _journalType, RefRecId _companyLocation, NatureOfAssessee_IN _natureOfAssessee,
                       Voucher _taxWithholdVoucher, LineNum _taxWithholdLineNum, TransDate _creditNoteDate, Qty _quantity,
                       ExchRate _exchangeRate, ExchrateSecondary _exchRateSecond, NoYes _softwareDeclReceived, 
                       TransDate _transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
        {
            currencyCodeLoc         = _currencyCode;
            taxModuleTypeLoc        = _taxModuleType;
            dimensionDefaultLoc     = _dimensionDefault;
            sourceTableIdLoc        = _sourceTableId;
            sourceRecIdLoc          = _sourceRecId;
            voucherLoc              = _voucher;
            invoiceLoc              = _invoiceNum;
            lineNumLoc              = _lineNum;
            ledgerJournalTypeLoc    = _ledgerJournalType;
            settlementTypeLoc       = _journalType;
            companyLocationLoc      = _companyLocation;
            natureOfAssesseeLoc     = _natureOfAssessee;
            taxWithholdVoucher      = _taxWithholdVoucher;
            taxWithholdLineNum      = _taxWithholdLineNum;
            creditNoteDate          = _creditNoteDate;
            quantityLoc             = _quantity;
            exchangeRate            = _exchangeRate;
            exchangeRateSecond      = _exchRateSecond;
            softwareDeclReceived    = _softwareDeclReceived;
            tdsExchangeRate         = TaxExchangeRateHelper::getTDSExchangeRate_IN(_currencyCode, _creditNoteDate ? _creditNoteDate : _transDate);
            tdsExchangeRateSecond   = TaxExchangeRateHelper::getTDSExchangeRateSecond_IN(_currencyCode, _creditNoteDate ? _creditNoteDate : _transDate);
            tdsTriangulation        = Currency::unknownNoYes2Noyes(UnknownNoYes::Unknown, _currencyCode, _creditNoteDate ? _creditNoteDate : _transDate);
            tdsExchangeRateRep      = TaxExchangeRateHelper::getTDSExchangeRateRep_IN(_currencyCode, Ledger::reportingCurrency(), _creditNoteDate ? _creditNoteDate : _transDate);
        }

        transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(_line);

        switch (_line.TableId)
        {
            case tableNum(LedgerJournalTrans) :
                ledgerJournalTransLoc   = _line as LedgerJournalTrans;

                setValues(ledgerJournalTransLoc.CurrencyCode,
                          TaxModuleType::Voucher,
                          ledgerJournalTransLoc.DefaultDimension,
                          ledgerJournalTransLoc.TableId,
                          ledgerJournalTransLoc.RecId,
                          ledgerJournalTransLoc.Voucher,
                          ledgerJournalTransLoc.Invoice,
                          ledgerJournalTransLoc.LineNum,
                          ledgerJournalTransLoc.ledgerJournalTable().JournalType,
                          ledgerJournalTransLoc.SettleVoucher,
                          transTaxInformation.CompanyLocation,
                          transTaxInformation.TaxWithholdNatureOfAssessee,
                          '',
                          0,
                          dateNull(),
                          0,
                          ledgerJournalTransLoc.ExchRate,
                          ledgerJournalTransLoc.ExchRateSecond,
                          transTaxInformation.TaxWithholdSoftwareDeclReceived,
                          ledgerJournalTransLoc.TransDate);

                break;

            case tableNum(PurchLine) :
                purchLineLoc        = _line as PurchLine;
                purchLineLoc_IN     = purchLineLoc.purchLine_IN();
                purchTableLoc       = purchLineLoc.purchTable();
                setValues(purchLineLoc.CurrencyCode,
                            TaxModuleType::PurchInvoice,
                            0,
                            purchLineLoc.TableId,
                            purchLineLoc.RecId,
                            '',
                            '',
                            any2real(purchLineLoc.LineNumber),
                            0,
                            0,
                            transTaxInformation.CompanyLocation,
                            purchTableLoc.purchTable_W().NatureOfAssessee_IN,
                            purchLineLoc_IN.TaxWithholdVoucher,
                            purchLineLoc_IN.TaxWithholdLineNum,
                            purchLineLoc_IN.CreditNoteDate,
                            purchLineLoc.PurchQty,
                            exchRate,
                            exchRateSecond,
                            transTaxInformation.TaxWithholdSoftwareDeclReceived);
                break;

            case tableNum(VendInvoiceInfoLine) :
                vendInvoiceInfoLineLoc      = _line as VendInvoiceInfoLine;
                vendInvoiceInfoTableLoc     = vendInvoiceInfoLineLoc.vendInvoiceInfoTable();
                vendInvoiceInfoTableTaxLoc  = VendInvoiceInfoTableTaxExtension_IN::findByVendInvoiceInfoTableRecId(vendInvoiceInfoTableLoc.RecId);

                setValues(vendInvoiceInfoLineLoc.CurrencyCode,
                          TaxModuleType::PurchInvoice,
                          0,
                          vendInvoiceInfoLineLoc.TableId,
                          vendInvoiceInfoLineLoc.RecId,
                          '',
                          '',
                          vendInvoiceInfoLineLoc.LineNum,
                          0,
                          0,
                          transTaxInformation.CompanyLocation,
                          vendInvoiceInfoTableTaxLoc.NatureOfAssessee,
                          '',
                          0,
                          dateNull(),
                          vendInvoiceInfoLineLoc.ReceiveNow,
                          exchRate,
                          exchRateSecond,
                          transTaxInformation.TaxWithholdSoftwareDeclReceived);
                break;

            default :
                break;
        }

        taxWithholdData = conNull();
        taxWithholdData = conPoke(taxWithholdData, #1, exchangeRate);
        taxWithholdData = conPoke(taxWithholdData, #2, exchangeRateSecond);
        taxWithholdData = conPoke(taxWithholdData, #3, triangulation);
        taxWithholdData = conPoke(taxWithholdData, #4, currencyCodeLoc);
        taxWithholdData = conPoke(taxWithholdData, #5, _grossAmount);
        taxWithholdData = conPoke(taxWithholdData, #6, taxModuleTypeLoc);
        taxWithholdData = conPoke(taxWithholdData, #7, dimensionDefaultLoc);
        taxWithholdData = conPoke(taxWithholdData, #8, sourceTableIdLoc);
        taxWithholdData = conPoke(taxWithholdData, #9, sourceRecIdLoc);
        taxWithholdData = conPoke(taxWithholdData, #10, voucherLoc);
        taxWithholdData = conPoke(taxWithholdData, #11, invoiceLoc);
        taxWithholdData = conPoke(taxWithholdData, #12, lineNumLoc);
        taxWithholdData = conPoke(taxWithholdData, #13, ledgerJournalTypeLoc);
        taxWithholdData = conPoke(taxWithholdData, #14, settlementTypeLoc);
        taxWithholdData = conPoke(taxWithholdData, #15, companyLocationLoc);
        taxWithholdData = conPoke(taxWithholdData, #16, natureOfAssesseeLoc);
        taxWithholdData = conPoke(taxWithholdData, #17, creditNoteDate);
        taxWithholdData = conPoke(taxWithholdData, #18, '');
        taxWithholdData = conPoke(taxWithholdData, 19,  taxWithholdVoucher);
        taxWithholdData = conPoke(taxWithholdData, #20, taxWithholdLineNum);
        taxWithholdData = conPoke(taxWithholdData, 21, quantityLoc);
        taxWithholdData = conPoke(taxWithholdData, 22, headingTableId);
        taxWithholdData = conPoke(taxWithholdData, 23, headingRecId);
        taxWithholdData = conpoke(taxWithholdData, #POS_SoftwareDeclReceived, softwareDeclReceived); //#24
        taxWithholdData = conPoke(taxWithholdData, #TDSExchRate, tdsExchangeRate); //#25
        taxWithholdData = conPoke(taxWithholdData, #TDSExchRateSecond, tdsExchangeRateSecond); //#26
        taxWithholdData = conPoke(taxWithholdData, #TDSTriangulation,  tdsTriangulation); //#27
        taxWithholdData = conPoke(taxWithholdData, #TDSExchRateRep, tdsExchangeRateRep); //#28

        return taxWithholdData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceRecId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the <c>RecId</c> of the transaction line that is currently being posted.
    /// </summary>
    /// <returns>
    ///    The <c>RecId</c> of the transaction line being posted.
    /// </returns>
    public RecId sourceRecId()
    {
        return sourceRecord.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceTableId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the <c>TableId</c> of the transaction that is to be taxed.
    /// </summary>
    /// <returns>
    ///    The ID of the transaction to be taxed.
    /// </returns>
    public TableId sourceTableId()
    {
        return sourceRecord.TableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxWithholdAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///   This method returns the actual withhold tax amount.
    /// </summary>
    /// <returns>
    ///   The actual withhold tax amount in transactional currency.
    /// </returns>
    public TaxAmountCur totalTaxWithholdAmount()
    {
        select sum(SourceRegulateAmountCur)
            from taxWithholdWorkTrans;

        return taxWithholdWorkTrans.SourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAndPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method is the main entry point to execute transaction specific logic and to
    ///    post to TaxWithholdTrans_IN and to post withhold tax amounts to the Ledger.
    /// </summary>
    /// <param name="_ledgerPostingController">
    /// The ledger posting controller to use for ledger posting.
    /// </param>
    /// <returns>
    ///    The total withhold tax amount.
    /// </returns>
    public TaxAmount updateAndPost(LedgerPostingController _ledgerPostingController)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxWithholdTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates tax withhold transaction.
    /// </summary>
    /// <param name="_tableId">
    /// The table id.
    /// </param>
    /// <param name="_recId">
    /// The rec id.
    /// </param>
    /// <param name="_taxWithholdGroup">
    /// The tax withhold group.
    /// </param>
    /// <param name="_taxWithholdCode">
    /// The tax withhold code.
    /// </param>
    public void  updateTaxWithholdTrans(RefTableId         _tableId,
                                        RefRecId           _recId,
                                        TaxWithholdGroup   _taxWithholdGroup,
                                        TaxWithholdCode    _taxWithholdCode)
    {
        SpecTrans               specTrans;
        VendTransOpen           vendTransOpen;
        VendTrans               vendTrans;
        TaxWithholdTrans_IN     taxWithholdTransLoc;
        CustTransOpen           custTransOpen;
        CustTrans               custTrans;

        while select SpecRecId, SpecTableId, RefRecId, RefTableId from specTrans
            where specTrans.SpecRecId   == _recId
               && specTrans.SpecTableId == _tableId
        {
            select  firstonly RecId, TableId, RefRecId, AccountNum, TransDate from vendTransOpen
                where vendTransOpen.RecId         == specTrans.RefRecId
                   && vendTransOpen.TableId       == specTrans.RefTableId;

            select firstonly RecId, AccountNum, TransDate, Voucher from vendTrans
                where vendTrans.RecId             == vendTransOpen.RefRecId
                   && vendTrans.AccountNum        == vendTransOpen.AccountNum
                   && vendTrans.TransDate         == vendTransOpen.TransDate;

            select  firstonly RecId, TableId, RefRecId, AccountNum, TransDate from custTransOpen
                where custTransOpen.RecId         == specTrans.RefRecId
                   && custTransOpen.TableId       == specTrans.RefTableId;

            select firstonly RecId, AccountNum, TransDate, Voucher from custTrans
                where custTrans.RecId             == custTransOpen.RefRecId
                   && custTrans.AccountNum        == custTransOpen.AccountNum
                   && custTrans.TransDate         == custTransOpen.TransDate;

            voucher    = custTrans.Voucher      ?  custTrans.Voucher   : vendTrans.Voucher;

            update_recordset taxWithholdTransLoc
                setting OverlookThreshold       = true,
                        TaxWithholdCalculated   = true
                where taxWithholdTransLoc.Voucher           == voucher
                   && taxWithholdTransLoc.TaxWithholdGroup  == _taxWithholdGroup
                   && taxWithholdTransLoc.TaxWithholdCode   == _taxWithholdCode;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>useSubLedgerJournalLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a Boolean value that indicates whether the current transaction being posted supports the
    ///    <c>SubLedgerDistributions</c> or <c>SubLedgerJournalLines</c>. By default, the base implementation
    ///    is that the transactions do not support sub-ledgers. If the individual transactions support
    ///    sub-ledgers, they will have to override this and return true.
    /// </summary>
    /// <returns>
    ///    true if the current transaction supports sub-ledgers; otherwise, false.
    /// </returns>
    public boolean useSubLedgerJournalLines()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the <c>TaxWithholdPost_IN</c> class should use the <c>TaxWithholdUncommitted_IN</c> table.
    /// </summary>
    /// <returns>
    ///    true if the <c>TaxWithholdPost_IN</c> class should use the <c>TaxWithholdUncommitted_IN</c> table; otherwise, false.
    /// </returns>
    public boolean useTaxUncommitted()
    {
        if (taxableDocument)
        {
            return taxableDocument.useTaxUncommitted();
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the instance of the <c>TaxWithholdPost_IN</c> class.
    /// </summary>
    /// <returns>
    /// true if no validation errors.
    /// </returns>
    protected boolean validate()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWithholdTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if multiple taxtypes attached to transaction lines.
    /// </summary>
    protected void validateWithholdTax()
    {
        CustInvoiceTable                    custInvoiceTable;
        CustInvoiceLine                     custInvoiceLine;
        SalesTable                          salesTable;
        SalesLine                           salesLine;
        SalesLine_IN                        salesLine_IN;
        VendInvoiceInfoTable                vendInvoiceInfoTable;
        VendInvoiceInfoLine                 vendInvoiceInfoLine;
        VendInvoiceInfoLineTaxExtension_IN  vendInvoiceInfoLineTaxExtension;
        int                                 tcsLineCount;
        int                                 tdsLineCount;
        TaxInformation_IN                   taxinformation;
        CustInvoiceLineTaxExtensionIN       custInvoiceLineTaxExtensionIN;

        switch (origHeadingTableId)
        {
            case tableNum(CustInvoiceTable) :

                custInvoiceTable =  CustInvoiceTable::findRecId(origHeadingRecId);

                while select custInvoiceLine
                    where custInvoiceLine.ParentRecId  == custInvoiceTable.RecId
                {
                    custInvoiceLineTaxExtensionIN = custInvoiceLine.custInvoiceLineTaxExtensionIN();

                    if (custInvoiceLineTaxExtensionIN.tcsGroup)
                    {
                        tcsLineCount += 1;
                    }
                    if (custInvoiceLineTaxExtensionIN.tdsGroup)
                    {
                        tdsLineCount += 1;
                    }
                    if (tcsLineCount && tdsLineCount)
                    {
                        throw error(strfmt("@GLS5856", "@SYS23028"));
                    }

                    if (custInvoiceLineTaxExtensionIN.tcsGroup || custInvoiceLineTaxExtensionIN.tdsGroup)
                    {
                        taxinformation = TaxInformation_IN::find(TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(custInvoiceLine).TaxInformation);
                        if (!taxinformation || !taxinformation.TAN)
                        {
                            throw error(strFmt("@SYS26332", "@GLS5353"));
                        }
                    }
                }
                break;

            case tableNum(SalesTable) :

                salesTable = SalesTable::findRecId(origHeadingRecId);

                while select RecId from salesLine
                    where salesLine.SalesId  == salesTable.SalesId
                    outer join tdsGroup, tcsGroup from salesLine_IN
                        where salesLine.RecId == salesLine_IN.SalesLine
                {
                    if (salesLine_IN.tcsGroup)
                    {
                        tcsLineCount += 1;
                    }
                    if (salesLine_IN.tdsGroup)
                    {
                        tdsLineCount += 1;
                    }
                    if (tcsLineCount && tdsLineCount)
                    {
                        throw error(strfmt("@GLS5856", "@SYS9694"));
                    }

                    if (salesLine_IN.tcsGroup || salesLine_IN.tdsGroup)
                    {
                        taxinformation = TaxInformation_IN::find(TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(salesLine).TaxInformation);
                        if (!taxinformation || !taxinformation.TAN)
                        {
                            throw error(strFmt("@SYS26332", "@GLS5353"));
                        }
                    }
                }
                break;

            case tableNum(VendInvoiceInfoTable) :

                vendInvoiceInfoTable = VendInvoiceInfoTable::findRecId(origHeadingRecId);

                while select RecId from vendInvoiceInfoLine
                    where vendInvoiceInfoLine.ParmId        == vendInvoiceInfoTable.ParmId
                    &&    vendInvoiceInfoLine.TableRefId    == vendInvoiceInfoTable.TableRefId
                {
                    vendInvoiceInfoLineTaxExtension = vendInvoiceInfoLineTaxExtension_IN::findByVendInvoiceInfoLineRecId(vendInvoiceInfoLine.RecId);

                    if (vendInvoiceInfoLineTaxExtension.TCSGroup)
                    {
                        tcsLineCount += 1;
                    }
                    if (vendInvoiceInfoLineTaxExtension.TDSGroup)
                    {
                        tdsLineCount += 1;
                    }

                    if (tcsLineCount && tdsLineCount)
                    {
                        throw error(strfmt("@GLS5856", "@SYS15812"));
                    }

                    if (vendInvoiceInfoLineTaxExtension.TCSGroup|| vendInvoiceInfoLineTaxExtension.TDSGroup)
                    {
                        taxinformation = TaxInformation_IN::find(TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(vendInvoiceInfoLine).TaxInformation);
                        if (!taxinformation || !taxinformation.TAN)
                        {
                            throw error(strFmt("@SYS26332", "@GLS5353"));
                        }
                    }
                }
                break;

            default :
            break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTaxWithholdUncommitted_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if there is an uncomitted WHT record after posting WHT tax.
    /// </summary>
    /// <param name = "_taxWithholdPost">The <c>TaxWithholdPost_IN</c> object instance.</param>
    /// <param name = "_headingTableSourceDocumentRecId">The <c>SourceDocumentLine</c> RecId for heading table.</param>
    /// <param name = "_taxWithholdCalculation">The <c>TaxWithholdCalculation_IN</c> object instance.</param>
    /// <returns>True if the uncomitted WHT record doesn't exist, else false.</returns>
    public boolean validateTaxWithholdUncommitted_IN(
        TaxWithholdPost_IN _taxWithholdPost,
        RefRecId _headingTableSourceDocumentRecId,
        TaxWithholdCalculation_IN _taxWithholdCalculation)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newForSourceType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a newly derived <c>TaxWithholdPost_IN</c> record based on the transaction.
    /// </summary>
    /// <param name="_sourceType">
    /// The type of the transaction posting withhold taxes.
    /// </param>
    /// <param name="_initializationClass">
    /// The initialization class for the specified transaction.
    /// </param>
    /// <param name="_post">
    /// True if the <c>TaxWithholdTrans_IN</c> and <c>Ledger</c> records will be created; false if it will not post.
    /// </param>
    /// <returns>
    /// The appropriate <c>TaxWithholdPost_IN</c> instance based on the calling transaction.
    /// </returns>
    public static TaxWithholdPost_IN newForSourceType(TaxSourceType _sourceType, Object _initializationClass, NoYes _post)
    {
        TaxWithholdPostPurch_IN         taxWithholdPostPurch;
        TaxWithholdPostJournal_IN       taxWithholdPostJournal;
        TaxWithholdPostFreeInvoice_IN   taxWithholdPostFreeInvoice;
        TaxWithholdPostProjAdvancedJournal_IN taxWithholdPostProjAdvancedJournal;

        switch (_sourceType)
        {
            case TaxSourceType::FreeTextInvoice :
                taxWithholdPostFreeInvoice = new TaxWithholdPostFreeInvoice_IN(_post, _initializationClass);
                return taxWithholdPostFreeInvoice;

            case TaxSourceType::PurchaseOrder :
                taxWithholdPostPurch = new TaxWithholdPostPurch_IN(_post, _initializationClass);
                return taxWithholdPostPurch;

            case TaxSourceType::Journals :
                taxWithholdPostJournal = new TaxWithholdPostJournal_IN(_post, _initializationClass);
                return taxWithholdPostJournal;

            case TaxSourceType::ProjAdvancedJournal :
                taxWithholdPostProjAdvancedJournal = new TaxWithholdPostProjAdvancedJournal_IN(_post, _initializationClass);
                return taxWithholdPostProjAdvancedJournal;

            default:
                var eventHandlerResult = new EventHandlerResult();
                TaxWithholdPost_IN::newForSourceTypeDelegate(_sourceType, _initializationClass, _post, eventHandlerResult);

                if (eventHandlerResult.hasResult())
                {
                    return eventHandlerResult.result();
                }

                throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newForSourceTypeWithTaxCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a new derived <c>TaxWithholdPost_IN</c> record that is based on the transaction.
    /// </summary>
    /// <param name="_sourceType">
    /// The type of the transaction posting taxes.
    /// </param>
    /// <param name="_initializationClass">
    /// The initialization class for the given transaction.
    /// </param>
    /// <param name="_post">
    /// A Boolean value that specifies whether the <c>TaxWithholdTrans_IN</c> and <c>Ledger</c> entries will be made.
    /// </param>
    /// <param name="_taxWHTCalculation">
    ///    The tax will post using the withhold tax lines in the table that are specified by the <paramref
    ///    name="_taxWHTCalculation" /> parameter.
    /// </param>
    /// <returns>
    /// The appropriate <c>TaxWithholdPost_IN</c> record that is based on the calling transaction.
    /// </returns>
    /// <remarks>
    /// The instance uses the <c>TaxWithholdUncommitted_IN</c> records to post.
    /// </remarks>
    public static TaxWithholdPost_IN newForSourceTypeWithTaxCalculation(TaxSourceType _sourceType, Object _initializationClass, NoYes _post, TaxWithholdCalculation_IN _taxWHTCalculation)
    {
        TaxWithholdPostPurch_IN         taxWithholdPostPurch;
        TaxWithholdPostJournal_IN       taxWithholdPostJournal;
        TaxWithholdPostFreeInvoice_IN   taxWithholdPostFreeInvoice;
        TmpTaxWithholdWorkTrans_IN      tmpTaxWithholdWorkTrans;

        if (_taxWHTCalculation != null)
        {
            tmpTaxWithholdWorkTrans = _taxWHTCalculation.tmpTaxWithholdWorkTrans();
        }

        switch (_sourceType)
        {
            case TaxSourceType::FreeTextInvoice :
                taxWithholdPostFreeInvoice = new TaxWithholdPostFreeInvoice_IN(_post, _initializationClass, tmpTaxWithholdWorkTrans);
                return taxWithholdPostFreeInvoice;

            case TaxSourceType::PurchaseOrder :
                taxWithholdPostPurch = new TaxWithholdPostPurch_IN(_post, _initializationClass, tmpTaxWithholdWorkTrans);
                return taxWithholdPostPurch;

            case TaxSourceType::Journals :
                taxWithholdPostJournal = new TaxWithholdPostJournal_IN(_post, _initializationClass, tmpTaxWithholdWorkTrans);
                return taxWithholdPostJournal;

            default:
                var eventHandlerResult = new EventHandlerResult();
                TaxWithholdPost_IN::newForSourceTypeWithTaxCalculationDelegate(_sourceType, _initializationClass, _post, _taxWHTCalculation, eventHandlerResult);

                if (eventHandlerResult.hasResult())
                {
                    return eventHandlerResult.result();
                }

                throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxTotalVoucherDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax total voucher date.
    /// </summary>
    /// <param name="_voucher">
    /// The voucher information.
    /// </param>
    /// <param name="_date">
    /// The transaction date.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxAmountCur</c> class.
    /// </returns>
    static TaxAmountCur taxTotalVoucherDate(
        Voucher     _voucher,
        TransDate   _date)
    {
        TaxWithholdTrans_IN taxWithholdTrans;
        TaxAmountCur        taxWithholdAmountCur;

        while select
            sum(TaxWithholdAmountCur), sum(AdjustedTaxWithholdAmount)
        from taxWithholdTrans
        where taxWithholdTrans.Voucher == _voucher
           && taxWithholdTrans.TransDate == _date
        {
            if (taxWithholdTrans.AdjustedTaxWithholdAmount)
            {
                taxWithholdAmountCur += taxWithholdTrans.AdjustedTaxWithholdAmount;
            }
            else
            {
                taxWithholdAmountCur += taxWithholdTrans.TaxWithholdAmountCur;
            }
        }

        return taxWithholdAmountCur;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>