<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjTransItemTrans</Name>
	<SourceCode>
		<Declaration><![CDATA[
class ProjTransItemTrans extends ProjTransItem
{
    ProjItemTrans   projItemTrans;

    boolean         calcTransCost;
    Amount          transCost;
    boolean         calcLedgerCostAmountMST;
    AmountMST       ledgerCostAmountMST;
    boolean         getCanBeInvoiced;
    boolean         canBeInvoiced;
    boolean         calcTransTurnover;
    AmountCur       transTurnover;
    boolean         calcLedgerSalesAmountMST;
    AmountMST       ledgerSalesAmountMST;
    boolean         calcTransCostMST;
    AmountMST       transCostMST;
    boolean         getVoucherInvoice;
    Voucher         voucherInvoice;
    // <GEERU>
    boolean         countryRegion_RU;
    #ISOCountryRegionCodes
    // </GEERU>
    // <GCN>
    boolean         countryRegion_CN;
    #ISOCountryRegionCodes
    // </GCN>

    ProjItemTransTaxExtensionIN projItemTransTaxExtensionIN;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>accountBalanceSheetLedgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountBalanceSheetLedgerDimension()
    {
        if (InventPostingExtendParm_CN::checkExtendParmEnabled())
        {
            switch (projItemTrans.TransactionOrigin)
            {
                case ProjOrigin::ItemRequirement:
                    return InventPosting::accountItemLedgerDimensionExtendParmFromParameter_CN(
                        this.buildAccountItemLedgerDimensionParameter(
                            null,
                            InventPostingExtendParm_CN::constructInventDim(projItemTrans.inventDim()).parmInventSiteId()));

                default:
                    return InventPosting::itemLedgerDimensionExtendParmFromParameter_CN(
                        this.buildItemLedgerDimensionParameter(InventAccountType::InventIssue),
                        InventPostingExtendParm_CN::constructInventDim(projItemTrans.inventDim()));
            }
        }

        switch (projItemTrans.TransactionOrigin)
        {
            case ProjOrigin::ItemRequirement:
                if (countryRegion_RU)
                {
                    return InventPosting::accountItemLedgerDimensionFromParameters(this.buildAccountItemLedgerDimensionParameter(projItemTrans.inventDim()));
                }
                else
                {
                    return InventPosting::accountItemLedgerDimensionFromParameters(this.buildAccountItemLedgerDimensionParameter());
                }

            default:
                return InventPosting::itemLedgerDimensionFromParameter(this.buildItemLedgerDimensionParameter(InventAccountType::InventIssue));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildItemLedgerDimensionParameter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a parameter for searching an inventory posting ledger dimension for an item.
    /// </summary>
    /// <param name = "_inventAccountType">A inventory account type.</param>
    /// <returns>The built parameter instance.</returns>
    protected InventPostingItemLedgerDimensionParameters buildItemLedgerDimensionParameter(
        InventAccountType   _inventAccountType)
    {
        InventPostingItemLedgerDimensionParameters searchParameters = InventPostingItemLedgerDimensionParameters::newFromParameters(
            _inventAccountType,
            projItemTrans.ItemId,
            projItemTrans.inventTable().itemGroupId());

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            searchParameters.InventDim_RU = projItemTrans.inventDim();
        }

        return searchParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildAccountItemLedgerDimensionParameter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a parameter for searching an inventory posting account ledger dimension for an item.
    /// </summary>
    /// <param name = "_inventDim">An inventory dimension.</param>
    /// <param name = "_siteRelation">An inventory site relation.</param>
    /// <returns>The built parameter instance.</returns>
    protected InventPostingAccountItemLedgerDimensionParameters buildAccountItemLedgerDimensionParameter(InventDim _inventDim = null, InventSiteRelation_CN _siteRelation = '')
    {
        InventCategoryRelation itemCategory;

        if (projItemTrans.TransactionOrigin == ProjOrigin::ItemRequirement && projItemTrans.AdjRefTransId)
        {
            itemCategory = SalesLine::findInventTransId(ProjItemTrans::find(projItemTrans.AdjRefTransId).InventTransId).SalesCategory;
        }

        return InventPostingAccountItemLedgerDimensionParameters::newFromParameters(
            InventAccountType::SalesIssue,
            projItemTrans.ItemId,
            projItemTrans.inventTable().itemGroupId(),
            itemCategory,
            // If a category relation is added to the table it can be supplied here
            projItemTrans.projTable().CustAccount,
            // fra ProjTable.custAccount
            CustTable::find(projItemTrans.projTable().CustAccount).CustGroup,
            // fra custTable
            projItemTrans.TaxGroupId,
            _inventDim,
            _siteRelation);
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountOperationsLedgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountOperationsLedgerDimension(ProjFundingSourceRefId _fundingSourceId )
    {
        return ProjPosting::getLedgerDimension(
            ProjAccountType::CostAccount,
            this.projId(),
            this.categoryId(),
            _fundingSourceId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>activityNumber</Name>
				<Source><![CDATA[
    public ProjActivityNumber activityNumber()
    {
        return projItemTrans.ActivityNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies whether a transaction can be adjusted.
    /// </summary>
    /// <returns>
    /// true if the transaction can be adjusted; otherwise, false.
    /// </returns>
    /// <remarks>
    /// A transaction can only be adjusted if it has been posted.
    /// </remarks>
    public boolean adjustable()
    {
        ProjItemTrans               childProjItemTrans;
        ProjItemTransCost           projItemTransCost;
        ProjItemTransSale           projItemTransSale;
        InventTransOrigin           inventTransOrigin;
        InventTransOriginProdTable  inventTransOriginProdTable;
        ProdTable                   prodTable;
        InventTrans                 inventTrans;
        boolean                     adjustableCost = true;
        boolean                     adjustableSale = true;

        if (projItemTrans.TransactionOrigin == ProjOrigin::BeginningBalance)
        {
            return false;
        }

        // Disable adjustment for stocked item transaction for multiple funding sources scenario.
        if (projItemTrans.TransactionOrigin == ProjOrigin::ItemRequirement
            && ProjBlockAdjustmentForItemReqTransWithMFSFlight::instance().isEnabled()
            && ProjFeatureStateHelper::isProjCancelItemReqPackingslipFeatureEnabled()
            && projItemTrans.inventTable().isStocked()
            && ProjInvoiceTable::hasMultipleFundingSources(projItemTrans.projTable().ProjInvoiceProjId))
        {
            return false;
        }

        if (projItemTrans.TransactionOrigin == ProjOrigin::ProductionConsumed)
        {
            if (!projItemTrans.Qty && !projItemTrans.costPrice())
            {
                return false;
            }

            select firstonly inventTransOrigin
                where inventTransOrigin.InventTransId == projItemTrans.InventTransId
                join inventTrans
                    where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                       && inventTrans.ProjAdjustRefId   == projItemTrans.ProjAdjustRefId;

            if (inventTrans)
            {
                if (!inventTrans.isUpdatedFinancial())
                {
                    return false;
                }

                select TableId from inventTransOrigin
                    where inventTransOrigin.RecId == inventTrans.InventTransOrigin
                    outer join TableId from inventTransOriginProdTable
                        where inventTransOriginProdTable.InventTransOrigin == inventTransOrigin.RecId
                        join ProdId from prodTable
                            where prodTable.ProdId     == inventTransOriginProdTable.ProdOrderId
                               && prodTable.DataAreaId == inventTransOriginProdTable.ProdOrderDataAreaId;

                if (projItemTrans.Qty < 0 &&
                    prodTable.ProdId &&
                    projItemTrans.ProjTransId == ProdTableProj::find(prodTable.ProdId, ProjItemTypeProdTable::ErrorQuantity).ProjTransId)
                {
                    return false;
                }
            }
        }

        select firstonly RecId from childProjItemTrans
            where childProjItemTrans.AdjRefTransId == projItemTrans.ProjTransId;

        if (!childProjItemTrans.RecId)
        {
            if (projItemTrans.AdjRefTransId)
            {
                ProjItemTrans parentTrans;

                select firstonly RecId, Qty from parentTrans
                        where parentTrans.ProjTransId == projItemTrans.AdjRefTransId;

                if (parentTrans.RecId)
                {
                    if ((parentTrans.Qty > 0 && projItemTrans.Qty < 0) ||
                        (parentTrans.Qty < 0 && projItemTrans.Qty > 0))
                    {
                        return false;
                    }
                }
            }
        }
        else
        {
            return false;
        }

        while select TransStatus from projItemTransCost
            where projItemTransCost.InventTransId   == projItemTrans.InventTransId
               && projItemTransCost.ProjAdjustRefId == projItemTrans.ProjAdjustRefId
        {
            adjustableCost = adjustableCost && ProjParameters::adjustable(projItemTransCost.TransStatus);
            if (!adjustableCost)
            {
                break;
            }
        }

        while select TransStatus from projItemTransSale
            where projItemTransSale.ProjTransId == projItemTrans.ProjTransId
        {
            adjustableSale = adjustableSale && ProjParameters::adjustable(projItemTransSale.TransStatus);
            if (!adjustableSale)
            {
                break;
            }
        }

        return !childProjItemTrans.RecId && adjustableCost && adjustableSale;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assessableValue_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves Assessable value for this transaction.
    /// </summary>
    /// <returns>
    /// Assessable value for this transaction.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public AmountCur assessableValue_IN()
    {
        return projItemTransTaxExtensionIN.AssessableValueTransactionCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeInvoiced</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether this transaction can be invoiced.
    /// </summary>
    /// <param name="_chargeable">
    /// A Boolean value that determines whether invoice proposal transactions can be invoiced; optional.
    /// </param>
    /// <returns>
    /// true if this transaction can be invoiced; otherwise, false.
    /// </returns>
    /// <remarks>
    /// If the project line property of the project that is associated with this transaction indicates that
    /// the project is not chargeable, it cannot be invoiced. Otherwise, the funding type is validated and
    /// the <c>ProjTrans.canTransStatusBeInvoiced</c> method is called to determine whether the transaction
    /// can be invoiced based on its status.
    /// </remarks>
    public boolean canBeInvoiced(
        boolean _chargeable = false)
    {
        ProjItemTransSale   projItemTransSale;
        boolean             ret;

        if (!SysDictClass::isSuperclass(classIdGet(this), classNum(ProjTransItemTrans)))
        {
            if (!getCanBeInvoiced)
            {
                getCanBeInvoiced = true;
                while select projItemTransSale
                    where projItemTransSale.ProjTransId == this.transId()
                {
                    canBeInvoiced = ProjTrans::newProjItemTransSale(projItemTrans, projItemTransSale).canBeInvoiced();
                    if (canBeInvoiced)
                    {
                        break;
                    }
                }
            }

            ret = canBeInvoiced;
        }
        else
        {
            ret = super(_chargeable);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>categoryId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the category ID for a transaction.
    /// </summary>
    /// <returns>
    /// The category ID for the transaction.
    /// </returns>
    /// <remarks>
    /// This abstract method must be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public ProjCategoryId categoryId()
    {
        return projItemTrans.CategoryId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustHandleBudget</Name>
				<Source><![CDATA[
    public boolean mustHandleBudget()
    {
        boolean ret = false;
        if (projItemTrans.TransIdPackSlip)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the cost price for a transaction.
    /// </summary>
    /// <returns>
    /// The cost price for this transaction.
    /// </returns>
    /// <remarks>
    /// This abstract method must be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public CostPrice costPrice()
    {
        CostPrice ret;

        if (!SysDictClass::isSuperclass(classIdGet(this), classNum(ProjTransItemTrans)))
        {
            ret = this.qty() ? CurrencyExchangeHelper::price(this.transCost() / this.qty(), this.currencyIdCost()) : 0;
        }
        else
        {
            ret = super();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyIdSales</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the currency code for the sales amounts that are reported by a transaction.
    /// </summary>
    /// <returns>
    /// The currency code for the sales amounts that are reported by the transaction.
    /// </returns>
    /// <remarks>
    /// This abstract method must be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public ProjSalesCurrencyCode currencyIdSales()
    {
        return projItemTrans.CurrencyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultDimension</Name>
				<Source><![CDATA[
    public DimensionDefault defaultDimension()
    {
        return projItemTrans.DefaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>intrastatFulfillmentDate_HU</Name>
				<Source><![CDATA[
    IntrastatFulfillmentDate_HU intrastatFulfillmentDate_HU()
    {
        return projItemTrans.IntrastatFulfillmentDate_HU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ID of the inventory dimension for this transaction.
    /// </summary>
    /// <returns>
    /// An empty string.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    InventDimId inventDimId()
    {
        return projItemTrans.InventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransId</Name>
				<Source><![CDATA[
    public InventTransId inventTransId()
    {
        return projItemTrans.InventTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiced</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether this transaction has been invoiced.
    /// </summary>
    /// <returns>
    /// Always returns false.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public  boolean invoiced()
    {
        ProjItemTransSale   projItemTransSale;
        boolean             ret;

        if (!SysDictClass::isSuperclass(classIdGet(this), classNum(ProjTransItemTrans)))
        {
            while select projItemTransSale
                where projItemTransSale.ProjTransId == this.transId()
            {
                ret = ProjTrans::newProjItemTransSale(projItemTrans, projItemTransSale).invoiced();
                if (ret)
                {
                    break;
                }
            }
        }
        else
        {
            ret = super();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the invoice ID of the invoice for this transaction.
    /// </summary>
    /// <returns>
    /// An empty string.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public ProjInvoiceId invoiceId()
    {
        ProjItemTransSale   projItemTransSale;
        ProjInvoiceId       ret;

        if (!SysDictClass::isSuperclass(classIdGet(this), classNum(ProjTransItemTrans)))
        {
            while select projItemTransSale
                where projItemTransSale.ProjTransId == this.transId()
            {
                ret = ProjTrans::newProjItemTransSale(projItemTrans, projItemTransSale).invoiceId();
                if (ret)
                {
                    break;
                }
            }
        }
        else
        {
            ret = super();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCorrection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the value of the correction field that is associated with a transaction.
    /// </summary>
    /// <returns>
    /// The value of the correction field that is associated with the transaction.
    /// </returns>
    /// <remarks>
    /// This method must be overridden by classes to support storno.
    /// </remarks>
    public LedgerCorrection isCorrection()
    {
        LedgerCorrection ret;

        ret = projItemTrans.IsCorrection;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemAdjustVersion</Name>
				<Source><![CDATA[
    public ProjItemAdjustVersion itemAdjustVersion()
    {
        return projItemTrans.adjustVersion();
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ID of the inventory item that is associated with this transaction.
    /// </summary>
    /// <returns>
    /// An empty string.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend the class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public ItemId itemId()
    {
        return projItemTrans.ItemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemLedgerAccountLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension for the inventory item that is associated with this transaction.
    /// </summary>
    /// <returns>
    /// An empty string.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public LedgerDimensionDefaultAccount itemLedgerAccountLedgerDimension()
    {
        return projItemTrans.LedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the transaction origin for this transaction.
    /// </summary>
    /// <returns>
    /// The <c>ProjItemType::Project</c> enumeration value.
    /// </returns>
    /// <remarks>
    /// This method can be overridden by classes that extend this class to return a different transaction
    /// origin for the specific transaction.
    /// </remarks>
    ProjTransactionOrigin itemType()
    {
        return projItemTrans.TransactionOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerCostAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the cost amount to be posted to the general ledger.
    /// </summary>
    /// <returns>
    /// Always returns 0.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public AmountMST ledgerCostAmountMST()
    {
        Amount              ret;
        ProjItemTransCost   projItemTransCost;
        ProjTrans           projTransCost;

        if (!SysDictClass::isSuperclass(classIdGet(this), classNum(ProjTransItemTrans)))
        {
            if (!calcLedgerCostAmountMST)
            {
                calcLedgerCostAmountMST = true;
                while select projItemTransCost
                    where projItemTransCost.InventTransId == projItemTrans.InventTransId &&
                        projItemTransCost.ProjAdjustRefId == projItemTrans.ProjAdjustRefId
                {
                    projTransCost = ProjTrans::newProjItemTransCost(projItemTransCost);
                    ledgerCostAmountMST += projTransCost.ledgerCostAmountMST();
                }
            }

            ret = ledgerCostAmountMST;
        }
        else
        {
            ret = super();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerSalesAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the sales amount to be posted to the general ledger.
    /// </summary>
    /// <returns>
    /// Always returns 0.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public AmountMST ledgerSalesAmountMST()
    {
        AmountMST           ret;
        ProjItemTransSale   projItemTransSale;
        ProjTrans           projTransSale;

        if (!SysDictClass::isSuperclass(classIdGet(this), classNum(ProjTransItemTrans)))
        {
            if (!calcLedgerSalesAmountMST)
            {
                calcLedgerSalesAmountMST = true;
                while select projItemTransSale
                    where projItemTransSale.ProjTransId == projItemTrans.ProjTransId
                {
                    projTransSale = ProjTrans::newProjItemTransSale(projItemTrans, projItemTransSale);
                    ledgerSalesAmountMST += projTransSale.ledgerSalesAmountMST();
                }
            }

            ret = ledgerSalesAmountMST;
        }
        else
        {
            ret = super();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>linePropertyId</Name>
				<Source><![CDATA[
    public ProjLinePropertyId linePropertyId()
    {
        return projItemTrans.LinePropertyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>maximumRetailPrice_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves Maximum retail price value for this transaction.
    /// </summary>
    /// <returns>
    /// Maximum retail price value for this transaction.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public MaximumRetailPrice_IN maximumRetailPrice_IN()
    {
        return projItemTransTaxExtensionIN.MaximumRetailPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new(ProjItemTrans _projItemTrans)
    {
        projItemTrans   = _projItemTrans;
        // <GEERU>
        countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            projItemTransTaxExtensionIN = ProjItemTransTaxExtensionIN::findByProjItemTrans(_projItemTrans.RecId);
        }
        // <GIN>

        super(_projItemTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>packingSlipId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ID of the packing slip that is associated with this transaction.
    /// </summary>
    /// <returns>
    /// An empty string.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public PackingSlipId packingSlipId()
    {
        return projItemTrans.PackingSlipId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingBalanceSheet</Name>
				<Source><![CDATA[
    LedgerPostingType postingBalanceSheet()
    {
        switch (projItemTrans.TransactionOrigin)
        {
            case ProjOrigin::ItemRequirement:
                return LedgerPostingType::SalesIssue;
        }

        return LedgerPostingType::InventIssue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projAdjustRefId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ID of the project adjustment reference that is associated with this transaction.
    /// </summary>
    /// <returns>
    /// An empty string.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public ProjAdjustRefId projAdjustRefId()
    {
        return projItemTrans.ProjAdjustRefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ID of the project that is associated with this transaction.
    /// </summary>
    /// <returns>
    /// The ID of the project that is associated with this transaction.
    /// </returns>
    /// <remarks>
    /// This abstract method must be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public ProjId projId()
    {
        return projItemTrans.ProjId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>proposal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether this transaction is from a project proposal.
    /// </summary>
    /// <returns>
    /// true if this transaction is from a project proposal; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction. This base class implementation returns false.
    /// </remarks>
    public  boolean proposal()
    {
        ProjItemTransSale   projItemTransSale;
        boolean             ret;

        if (!SysDictClass::isSuperclass(classIdGet(this), classNum(ProjTransItemTrans)))
        {
            while select projItemTransSale
                where projItemTransSale.ProjTransId == this.transId()
            {
                ret = ProjTrans::newProjItemTransSale(projItemTrans, projItemTransSale).proposal();
                if (ret)
                {
                    break;
                }
            }
        }
        else
        {
            ret = super();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>proposalId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ID of the project proposal that is associated with this transaction.
    /// </summary>
    /// <returns>
    /// An empty string.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public  ProjProposalId proposalId()
    {
        ProjItemTransSale   projItemTransSale;
        ProjProposalId      ret;

        if (!SysDictClass::isSuperclass(classIdGet(this), classNum(ProjTransItemTrans)))
        {
            while select projItemTransSale
                where projItemTransSale.ProjTransId == this.transId()
            {
                ret = ProjTrans::newProjItemTransSale(projItemTrans, projItemTransSale).proposalId();
                if (ret)
                {
                    break;
                }
            }
        }
        else
        {
            ret = super();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaContractLineNum</Name>
				<Source><![CDATA[
    public PSAContractLineNum psaContractLineNum()
    {
        return projItemTrans.psaContractLineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the quantity for this transaction.
    /// </summary>
    /// <returns>
    /// The quantity for this transaction.
    /// </returns>
    /// <remarks>
    /// This abstract method must be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public Qty qty()
    {
        ProjItemTransSale   projItemTransSale;
        Qty                 itemTransQty = projItemTrans.Qty;

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            select TransStatus from projItemTransSale
                    where projItemTransSale.ProjTransId == this.transId();

            if (projItemTransSale.TransStatus == ProjTransStatus::CreditnoteProposal)
            {
                itemTransQty = -projItemTrans.Qty;
            }
        }

        return itemTransQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the record ID for this transaction.
    /// </summary>
    /// <returns>
    /// Always returns zero.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public RecId recId()
    {
        return projItemTrans.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the sales price for this transaction.
    /// </summary>
    /// <returns>
    /// The sales price for this transaction.
    /// </returns>
    /// <remarks>
    /// This abstract method must be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    SalesPrice salesPrice()
    {
        SalesPrice  ret;

        if (!SysDictClass::isSuperclass(classIdGet(this), classNum(ProjTransItemTrans)))
        {
            ret = this.qty() ? CurrencyExchangeHelper::price(this.transTurnover() / this.qty(), this.currencyIdSales()) : 0;
        }
        else
        {
            ret = super();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesUnit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the sales unit for this transaction.
    /// </summary>
    /// <returns>
    /// An empty string.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public UnitOfMeasureSymbol salesUnit()
    {
        return projItemTrans.SalesUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tableId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the table ID for this transaction.
    /// </summary>
    /// <returns>
    /// Always returns zero.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public TableId tableId()
    {
        return tableName2id(tableStr(ProjItemTrans));
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the tax group for this transaction.
    /// </summary>
    /// <returns>
    /// An empty string.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public TaxGroup taxGroup()
    {
        return projItemTrans.TaxGroupId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxItemGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the item tax group for this transaction.
    /// </summary>
    /// <returns>
    /// An empty string.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public TaxItemGroup taxItemGroup()
    {
        return projItemTrans.TaxItemGroupId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tcsGroup_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves TCS value for this transaction.
    /// </summary>
    /// <returns>
    /// TCS value for this transaction.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public TaxWithholdGroup tcsGroup_IN()
    {
        return projItemTransTaxExtensionIN.tcsGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tdsGroup_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves TDS value for this transaction.
    /// </summary>
    /// <returns>
    /// TDS value for this transaction.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public TaxWithholdGroup tdsGroup_IN()
    {
        return projItemTransTaxExtensionIN.tdsGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the total cost of this transaction in the transaction currency.
    /// </summary>
    /// <returns>
    /// The total cost of this transaction.
    /// </returns>
    public  Amount transCost()
    {
        Amount              ret;

        if (!SysDictClass::isSuperclass(classIdGet(this), classNum(ProjTransItemTrans)))
        {
        ret = projItemTrans.TotalCostAmountCur;
        }
        else
        {
            ret = super();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transCostMST</Name>
				<Source><![CDATA[
    public AmountMST transCostMST(boolean _calledFromPSARecCost = false)
    {
        AmountMST           ret;
        ProjItemTransCost   projItemTransCost;
        ProjTrans           projTransSale;

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            ret = projItemTrans.costAmountTotal();
        }
        else
        {
            if (!SysDictClass::isSuperclass(classIdGet(this), classNum(ProjTransItemTrans)))
            {
                if (!calcTransCostMST)
                {
                    calcTransCostMST = true;
                    while select projItemTransCost
                        where projItemTransCost.InventTransId == projItemTrans.InventTransId &&
                            projItemTransCost.ProjAdjustRefId == projItemTrans.ProjAdjustRefId
                    {
                        projTransSale = ProjTrans::newProjItemTransCost(projItemTransCost);
                        transCostMST += projTransSale.transCostMST();
                    }
                }

                ret = transCostMST;
            }
            else
            {
                ret = super();
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the transaction date.
    /// </summary>
    /// <returns>
    /// The transaction date.
    /// </returns>
    /// <remarks>
    /// This abstract method must be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public TransDate transDate()
    {
        return projItemTrans.TransDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the transaction ID.
    /// </summary>
    /// <returns>
    /// An empty string.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public TransactionID transId()
    {
        return projItemTrans.ProjTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transTurnover</Name>
				<Source><![CDATA[
    public AmountCur transTurnover()
    {
        AmountCur           ret;

        if (!SysDictClass::isSuperclass(classIdGet(this), classNum(ProjTransItemTrans)))
        {
            ret = projItemTrans.TotalSalesAmountCur;
        }
        else
        {
            ret = super();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>txt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the transaction text.
    /// </summary>
    /// <returns>
    /// The transaction text.
    /// </returns>
    /// <remarks>
    /// This abstract method must be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public TransTxt txt()
    {
        return projItemTrans.Txt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>voucherInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the voucher number that is associated with this transaction.
    /// </summary>
    /// <returns>
    /// The voucher number that is associated with this transaction.
    /// </returns>
    /// <remarks>
    /// This abstract method must be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public Voucher voucherInvoice()
    {
        Voucher             ret;
        ProjItemTransSale   projItemTransSale;
        ProjTrans           projTransSale;

        if (!SysDictClass::isSuperclass(classIdGet(this), classNum(ProjTransItemTrans)))
        {
            if (!getVoucherInvoice)
            {
                getVoucherInvoice = true;
                while select projItemTransSale
                    where projItemTransSale.ProjTransId == projItemTrans.ProjTransId
                {
                    projTransSale = ProjTrans::newProjItemTransSale(projItemTrans, projItemTransSale);
                    voucherInvoice = projTransSale.voucherInvoice();
                    if (voucherInvoice)
                    {
                        break;
                    }
                }
            }

            ret = voucherInvoice;
        }
        else
        {
            ret = super();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>voucherOriginal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the original voucher number that is associated with this transaction.
    /// </summary>
    /// <returns>
    /// An empty string.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by classes that extend this class to provide the necessary
    /// functionality for the specific transaction.
    /// </remarks>
    public Voucher voucherOriginal()
    {
        return projItemTrans.VoucherPackingSlip;
    }

]]></Source>
			</Method>
			<Method>
				<Name>priceUnit</Name>
				<Source><![CDATA[
    public PriceUnit priceUnit()
    {
        PriceUnit ret = super();
        
        switch(this.parmProjItemType())
        {
            case ProjItemType::PurchOrder :
                PurchLine purchLine = PurchLine::findInventTransId(this.inventTransId());
                if(purchLine)
                {
                    ret = purchLine.PriceUnit;
                }
                break;
            case ProjItemType::Project :
            case ProjItemType::SalesOrder :
                SalesLine salesLine = SalesLine::findInventTransId(this.inventTransId());
                if(salesLine)
                {
                    ret = salesLine.PriceUnit;
                }
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>