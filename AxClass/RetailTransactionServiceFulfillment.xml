<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailTransactionServiceFulfillment</Name>
	<SourceCode>
		<Declaration><![CDATA[
using System.Collections.Specialized;
using System.Reflection;
using Microsoft.Dynamics.Commerce.Runtime.Services.CustomerOrder;
using Microsoft.Dynamics.Commerce.Runtime.TransactionService;
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;

/// <summary>
/// The <c>RetailTransactionServiceFulfillment</c> implements the store fulfillment methods of the service interface exposed by the <c>RetailTransactionService</c> class to the retail channels.
/// </summary>
public class RetailTransactionServiceFulfillment
{
    private static CommerceHQEventSource eventSource = CommerceHQEventSource::Log;

    private const str TransactionServiceAssemblyName = 'Microsoft.Dynamics.Commerce.Runtime.TransactionService';
    private const str entityAssemblyFileName = 'Microsoft.Dynamics.Commerce.Runtime.Entities';
    private const str entityNamespaceName = 'Microsoft.Dynamics.Commerce.Runtime.DataModel';
    private const str notificationDetailCollectionName = 'NotificationDetailCollection';
    private const str notificationDetailName = 'NotificationDetail';
    private const str ShipFulfillmentInfoName = 'Microsoft.Dynamics.Commerce.Runtime.TransactionService.ShipFulfillmentInfo';
    private const str ShipFulfillmentLineInfoName = 'Microsoft.Dynamics.Commerce.Runtime.TransactionService.ShipFulfillmentLineInfo';
    private const str SalesLineQuantityInfoName = 'Microsoft.Dynamics.Commerce.Runtime.TransactionService.SalesLineQuantityInfo';
    private const str PaymentInfoName = 'Microsoft.Dynamics.Commerce.Runtime.Services.CustomerOrder.PaymentInfo';
    private const str AmountProperty = 'Amount';
    private const str PrepaymentProperty = 'Prepayment';
    private const str CurrencyProperty = 'Currency';
    private const str CurrentChannelRecordIdProperty = 'CurrentChannelRecordId';

    private const str FulfillmentInfoName = 'Microsoft.Dynamics.Commerce.Runtime.TransactionService.FulfillmentInfo';
    private const str FulfillmentLineInfoName = 'Microsoft.Dynamics.Commerce.Runtime.TransactionService.FulfillmentLineInfo';
    private const str FulfillmentLineInfoCollectionName = 'Microsoft.Dynamics.Commerce.Runtime.TransactionService.FulfillmentLineInfoCollection';
    private const str FromXmlMethodName = 'FromXml';
    private const str FulfillmentLinesProperty = 'FulfillmentLines';
    private const str SalesLineNumberProperty = 'SalesLineNumber';
    private const str QuantityProperty = 'Quantity';
    private const str SalesIdProperty = 'SalesId';
    private const str InvoiceDateStringProperty = 'InvoiceDateString';
    private const str PackingDateProperty = 'PackingDate';
    private const str SerialNumberProperty = 'SerialNumber';
    private const str SalesPersonIdElementName = 'SalesPersonId';
    private const str SalesPersonStoreIdElementName = 'SalesPersonStoreId';
    private const str SalesPersonFirstNameElementName = 'SalesPersonFirstName';
    private const str SalesPersonLastNameElementName = 'SalesPersonLastName';
    private const str SerialNumberElementName = 'SerialNumber';
    private const str ReasonCodeIdProperty = 'ReasonCodeId';
    private const str ReasonSubCodeIdProperty = 'ReasonSubCodeId';
    private const str SalesLineQuantityInfoCollectionProperty = 'SalesLineQuantityInfoCollection';

    private const int DefaultStartingPosition = 1;
    private const int DefaultMaxResultCount = 20;
    private const str And = '&& ';
    
    private const str ArrayOfFulfillmentLinesElementName = 'ArrayOfFulfillmentLine';
    private const str ArrayOfFulfillmentLineParameterElementName = 'ArrayOfFulfillmentLineParameter';
    private const str FulfillmentLineElementName = 'FulfillmentLine';
    private const str FulfillmentLineCustomFieldsElementName = 'FulfillmentLineCustomFields';
    private const str CustomerIdElementName = 'CustomerId';
    private const str FulfillmentLineParameterElementName = 'FulfillmentLineParameter';
    private const str CustomerNameElementName = 'CustomerName';
    private const str LoyaltyCardNumberElementName = 'LoyaltyCardNumber';
    private const str CustomerPhoneNumberElementName = 'CustomerPhoneNumber';
    private const str DeliveryTypeElementName = 'DeliveryTypeValue';
    private const str EmailAddressElementName = 'EmailAddress';
    private const str SalesIdElementName = 'SalesId';
    private const str SalesLineNumberElementName = 'SalesLineNumber';
    private const str ChannelReferenceIdElementName = 'ChannelReferenceId';
    private const str ReceiptIdElementName = 'ReceiptId';
    private const str ItemIdElementName = 'ItemId';
    private const str ProductIdElementName = 'ProductId';
    private const str ProductVariantElementName = 'ProductVariant';
    private const str ItemNameElementName = 'ItemName';
    private const str RetailVariantIdElementName = 'RetailVariantId';
    private const str UnitOfMeasureSymbolElementName = 'UnitOfMeasureSymbol';
    private const str DeliveryModeCodeElementName = 'DeliveryModeCode';
    private const str WarehouseIdElementName = 'WarehouseId';
    private const str StoreNumberElementName = 'StoreId';
    private const str DocumentStatusElementName = 'DocumentStatusValue';
    private const str FulfillmentStatusElementName = 'FulfillmentStatusValue';
    private const str FulfillmentStatusesElementName = 'FulfillmentStatusValues';
    private const str FulfillmentDeliveryType = 'FulfillmentDeliveryTypeValue';
    private const str QuantityOrderedElementName = 'QuantityOrdered';
    private const str QuantityNotProcessedElementName = 'QuantityNotProcessed';
    private const str QuantityReservedElementName = 'QuantityReserved';
    private const str QuantityPickedElementName = 'QuantityPicked';
    private const str QuantityPackedElementName = 'QuantityPacked';
    private const str QuantityNotInvoicedElementName = 'QuantityNotInvoiced';
    private const str QuantityNotPickedElementName = 'QuantityNotPicked';
    private const str QuantityNotPackedElementName = 'QuantityNotPacked';
    private const str QuantityInvoicedElementName = 'QuantityInvoiced';
    private const str StoreInventoryTotalQuantityElementName = 'StoreInventoryTotalQuantity';
    private const str StoreInventoryReservedQuantityElementName = 'StoreInventoryReservedQuantity';
    private const str StoreInventoryOrderedQuantityElementName = 'StoreInventoryOrderedQuantity';
    private const str RequestedDeliveryDateElementName = 'RequestedDeliveryDate';
    private const str RequestedDeliveryStartDateElementName = 'RequestedDeliveryStartDate';
    private const str RequestedDeliveryEndDateElementName = 'RequestedDeliveryEndDate';
    private const str RequestedReceiptDateElementName = 'RequestedReceiptDate';
    private const str RequestedReceiptStartDateElementName = 'RequestedReceiptStartDate';
    private const str RequestedReceiptEndDateElementName = 'RequestedReceiptEndDate';
    private const str CreatedDateElementName = 'CreatedDate';
    private const str TotalAmountElementName = 'TotalAmount';
    private const str BalanceElementName = 'Balance';
    private const str OrderCreatedStartElementName = 'OrderCreatedStartDate';
    private const str OrderCreatedEndDateElementName = 'OrderCreatedEndDate';
    private const str ShippingAddressElementName = 'ShippingAddress';
    private const str StreetNumberElementName = 'StreetNumber';
    private const str StreetElementName = 'Street';
    private const str BuildingComplimentElementName = 'BuildingCompliment';
    private const str CityElementName = 'City';
    private const str DistrictNameElementName = 'DistrictName';
    private const str CountyElementName = 'County';
    private const str CountyNameElementName = 'CountyName';
    private const str PostboxElementName = 'Postbox';
    private const str ZipCodeElementName = 'ZipCode';
    private const str StateElementName = 'State';
    private const str StateNameElementName = 'StateName';
    private const str CountryRegionElementName = 'ThreeLetterISORegionName';
    private const str FullAddressElementName = 'FullAddress';
    private const str ArrayOfPackingSlipDataName = 'ArrayOfPackingSlipData';
    private const str PackingSlipDataElementName = 'PackingSlipData';
    private const str PackingSlipIdElementName = 'PackingSlipId';
    private const str CreatedDateTimeElementName = 'CreatedDateTime';
    private const str AddMethodName = 'Add';
    private const str ActionPropertyElementName = 'ActionProperty';
    private const str ItemCountElementName = 'ItemCount';
    private const str IsSuccessElementName = 'IsSuccess';
    private const str IsLiveContentOnlyElementName = 'IsLiveContentOnly';
    private const str DisplayTextElementName = 'DisplayText';
    private const str LastUpdatedDateTimeStrElementName = 'LastUpdatedDateTimeStr';
    private const str AllOrderActionProperty = '1';
    private const str PickOrderActionProperty = '2';
    private const str ShipOrderActionProperty = '3';
    private const str OrderNumberSortColumnName = 'orderNumber';
    private const str CustomerNameSortColumnName = 'customerName';
    private const str DeliveryDateSortColumnName = 'deliveryDate';
    private const str FulfillmentStatusSortColumnName = 'fulfillmentStatus';
    private const str IsOrderTotalIncludedElementName = 'IsOrderTotalIncluded';
    private const str DetailedLineStatusElementName = 'DetailedLineStatusValue';
    private const str DetailedOrderStatusElementName = 'DetailedOrderStatusValue';
    private const str PickupTimeslotStartDateTimeElementName = 'PickupTimeslotStartDateTime';
    private const str PickupTimeslotEndDateTimeElementName = 'PickupTimeslotEndDateTime';
    private const str ChannelTypeElementName = 'ChannelTypeValue';
    
    private const str ArrayOfCustomFieldsElementName = 'ArrayOfFulfillmentLineCustomFields';
    private const str CustomFieldsElementName = 'CustomFields';
    private const str NameValuePairElementName = 'NameValuePair';
    private const str NameElementName = 'Name';
    private const str ValueElementName = 'Value';

    private const int DateSequence = 321;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>PackFulfillmentLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the status of the fulfillment lines to Packed.
    /// </summary>
    /// <param name="_fulfillmentXmlString">
    /// XML string containing the fulfillment lines.
    /// </param>
    /// <returns>
    /// A <c>Container</c> containing result info.
    /// </returns>
    /// <remarks>
    /// Container structure by positions:
    /// 1 - operation status (true means operation succeeded; false - an application error occured),
    /// 2 - error message (optional)
    /// </remarks>
    public static container PackFulfillmentLines(str _fulfillmentXmlString)
    {
        boolean success = true;
        str error = '';
        SalesLine salesLine;
        RetailSalesLine retailSalesLine;
        str orderNumber;
        SalesTable salesTable;
        SalesFormLetter salesFormLetter;

        try
        {
            eventSource.EventWriteFulFillmentProcessStart(funcName());

            // Load the assembly and CRT-defined types using reflection
            System.Reflection.Assembly transactionServiceAssembly = System.Reflection.Assembly::Load(TransactionServiceAssemblyName);
            System.Type fulfillmentInfoType = transactionServiceAssembly == null ? null : transactionServiceAssembly.GetType(FulfillmentInfoName);
            System.Type FulfillmentLineInfoCollectionType = transactionServiceAssembly == null ? null : transactionServiceAssembly.GetType(FulfillmentLineInfoCollectionName);
            System.Type fulfillmentLineInfoType = transactionServiceAssembly == null ? null : transactionServiceAssembly.GetType(FulfillmentLineInfoName);
            System.Reflection.MethodInfo fromXmlMethod = fulfillmentInfoType == null ? null : fulfillmentInfoType.GetMethod(FromXmlMethodName);

            if (fromXmlMethod != null)
            {
                // Deserialize the xml string input
                System.Object[] parameters = new System.Object[1]();
                parameters.SetValue(_fulfillmentXmlString, 0);
                var fulfillmentInfo = fromXmlMethod.Invoke(System.Activator::CreateInstance(fulfillmentInfoType), parameters);

                // Iterate through the collection of sales lines
                System.Collections.ICollection fulfillmentLines = fulfillmentInfoType.GetProperty(FulfillmentLinesProperty).GetValue(fulfillmentInfo) as System.Collections.ICollection;
                System.Collections.IEnumerator fulfillmentLineEnumerator = fulfillmentLines.GetEnumerator();
                ttsbegin;
                while (fulfillmentLineEnumerator.MoveNext())
                {
                    var fulfillmentLine = fulfillmentLineEnumerator.Current;
                    real salesLineNumber = fulfillmentLineInfoType.GetProperty(SalesLineNumberProperty).GetValue(fulfillmentLine);
                    real quantity = fulfillmentLineInfoType.GetProperty(QuantityProperty).GetValue(fulfillmentLine);
                    str salesId = fulfillmentLineInfoType.GetProperty(SalesIdProperty).GetValue(fulfillmentLine);

                    // Verify that the fulfillment lines are from the same order.
                    if (!orderNumber)
                    {
                        orderNumber = salesId;
                    }
                    else if (orderNumber != salesId)
                    {
                        success = false;
                        error = "@Retail:FulfillmentLinesMustBeFromSameOrder"; // The selected fulfillment lines must be from the same order.
                        break;
                    }

                    select firstonly forupdate salesLine where salesLine.SalesId == salesId && salesLine.LineNum == salesLineNumber;

                    if (salesLine)
                    {
                        // Verify that the quantity can be packed
                        select QuantityPacked, QuantityInvoiced, FulfillmentStatus from retailSalesLine where retailSalesLine.SalesLine == salesLine.RecId;

                        if (retailSalesLine)
                        {
                            // Verify that the quantity can be packed.
                            if (retailSalesLine.QuantityPacked + quantity > salesLine.QtyOrdered - retailSalesLine.QuantityInvoiced)
                            {
                                success = false;
                                error = "@Retail:QuantityGreaterThanRemaining"; // The quantity entered is greater than the remaining quantity.
                                break;
                            }
                            else if (quantity < 0)
                            {
                                success = false;
                                error = "@Retail:QuantityLessThanZero"; // The quantity entered must be greater than zero.
                                break;
                                // Verify that the line can be marked as packed.
                            }
                            else if (retailSalesLine.FulfillmentStatus != RetailFulfillmentLineStatus::Accepted &&
                                    retailSalesLine.FulfillmentStatus != RetailFulfillmentLineStatus::Picking &&
                                    retailSalesLine.FulfillmentStatus != RetailFulfillmentLineStatus::PartiallyPicked &&
                                    retailSalesLine.FulfillmentStatus != RetailFulfillmentLineStatus::Picked &&
                                    retailSalesLine.FulfillmentStatus != RetailFulfillmentLineStatus::PartiallyPacked &&
                                    retailSalesLine.FulfillmentStatus != RetailFulfillmentLineStatus::PartiallyInvoiced)
                            {
                                success = false;
                                // One or more fulfillment lines can't be marked as packed. Only accepted, picking, partially picked, picked, and partially packed lines can be marked as packed.
                                error = "@Retail:FulfillmentLineCannotBeMarkedAsPacked";
                                break;
                            }
                            else
                            {
                                RetailTransactionServiceFulfillment::setWHSLocationToDefaultIfEmpty(salesLine);
                                // Update the quantity of the sales line to pack.
                                salesLine.SalesDeliverNow = salesLine.unitConvertInvent2Sales(quantity);
                                salesLine.InventDeliverNow = quantity;
                                salesLine.doUpdate();
                            }
                        }
                        else
                        {
                            success = false;
                            error = "@Retail:FulfillmentLineCannotBeFound"; // Updating the fulfillment status failed because the fulfillment line can't be found.
                            break;
                        }
                    }
                    else
                    {
                        success = false;
                        error = "@Retail:FulfillmentLineCannotBeFound"; // Updating the fulfillment status failed because the fulfillment line can't be found.
                        break;
                    }
                }

                eventSource.EventWriteFulfillmentProcessForSalesOrder(funcName(), SalesTable::find(orderNumber).RecId);

                // Pack the sales line.
                if (success)
                {
                    salesTable = SalesTable::find(orderNumber);
                    salesFormLetter = SalesFormLetter::construct(DocumentStatus::PackingSlip);
                    salesFormLetter.reArrangeNow(false);
                    salesFormLetter.update(salesTable, DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), SalesUpdate::DeliverNow, AccountOrder::None, false, false, false);
                }

                ttscommit;
            }
            else
            {
                error = "@Retail:CrtVersionMismatch"; // The server doesn't support this operation.
            }
        }
        catch (Exception::CLRError)
        {
            success = false;
            System.Exception ex;
            ex = CLRInterop::getLastException();
            if (ex && ex.InnerException)
            {
                if (ex.InnerException.InnerException)
                {
                    // Use inner exception if it is available as it is often more descriptive.
                    error = ex.InnerException.InnerException.Message;
                }
                else
                {
                    error = ex.InnerException.Message;
                }
            }
        }
        catch(Exception::Error)
        {
            error = "@Retail:PackFulfillmentLinesFailed"; // An error occurred when marking fulfillment lines as packed.
            success = false;
        }
        eventSource.EventWriteFulFillmentProcessEnd(funcName(), success);

        return [success, error];
    }

]]></Source>
			</Method>
			<Method>
				<Name>MarkFulfillmentLinesAsPacked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the status of the fulfillment lines to Packed.
    /// </summary>
    /// <param name="_fulfillmentXmlString">
    /// XML string containing the fulfillment lines.
    /// </param>
    /// <returns>
    /// A <c>Container</c> containing result info.
    /// </returns>
    /// <remarks>
    /// Container structure by positions:
    /// 1 - operation status (true means operation succeeded; false - an application error occured),
    /// 2 - error message (optional)
    /// 3 - Packing Slip Id of the new packing slip created for the fulfillment lines.
    /// 4 - result returned by extension implemented by partner.
    /// </remarks>
    public static container MarkFulfillmentLinesAsPacked(str _fulfillmentXmlString)
    {
        boolean success = true;
        str error = '';
        RetailSalesLine retailSalesLine;
        SalesId orderNumber;
        PackingSlipId packingSlipId;
        boolean extensionResult = true;
        int infologLine = Global::infologLine();
        TransDate packingDate;

        try
        {
            eventSource.EventWriteFulFillmentProcessStart(funcName());

            // Load the assembly and CRT-defined types using reflection
            System.Reflection.Assembly transactionServiceAssembly = System.Reflection.Assembly::Load(TransactionServiceAssemblyName);
            System.Type fulfillmentInfoType = transactionServiceAssembly == null ? null : transactionServiceAssembly.GetType(FulfillmentInfoName);
            System.Type FulfillmentLineInfoCollectionType = transactionServiceAssembly == null ? null : transactionServiceAssembly.GetType(FulfillmentLineInfoCollectionName);
            System.Type fulfillmentLineInfoType = transactionServiceAssembly == null ? null : transactionServiceAssembly.GetType(FulfillmentLineInfoName);
            System.Reflection.MethodInfo fromXmlMethod = fulfillmentInfoType == null ? null : fulfillmentInfoType.GetMethod(FromXmlMethodName);

            if (fromXmlMethod != null)
            {
                // Deserialize the xml string input
                System.Object[] parameters = new System.Object[1]();
                parameters.SetValue(_fulfillmentXmlString, 0);
                var fulfillmentInfo = fromXmlMethod.Invoke(System.Activator::CreateInstance(fulfillmentInfoType), parameters);

                // Iterate through the collection of sales lines
                System.Collections.ICollection fulfillmentLines = fulfillmentInfoType.GetProperty(FulfillmentLinesProperty).GetValue(fulfillmentInfo) as System.Collections.ICollection;
                System.Collections.IEnumerator fulfillmentLineEnumerator = fulfillmentLines.GetEnumerator();
                ttsbegin;
                while (fulfillmentLineEnumerator.MoveNext())
                {
                    var fulfillmentLine = fulfillmentLineEnumerator.Current;
                    real salesLineNumber = fulfillmentLineInfoType.GetProperty(SalesLineNumberProperty).GetValue(fulfillmentLine);
                    real quantity = fulfillmentLineInfoType.GetProperty(QuantityProperty).GetValue(fulfillmentLine);
                    SalesId salesId = fulfillmentLineInfoType.GetProperty(SalesIdProperty).GetValue(fulfillmentLine);
                    str packingDateString = fulfillmentLineInfoType.GetProperty(PackingDateProperty).GetValue(fulfillmentLine);

                    if (strLen(packingDateString) > 0)
                    {
                        packingDate = str2Date(packingDateString, DateSequence);
                    }

                    // Verify that the fulfillment lines are from the same order.
                    if (!orderNumber)
                    {
                        orderNumber = salesId;
                    }
                    else if (orderNumber != salesId)
                    {
                        success = false;
                        error = "@Retail:FulfillmentLinesMustBeFromSameOrder"; // The selected fulfillment lines must be from the same order.
                        break;
                    }

                    SalesLine salesLine = SalesLine::find(salesId, salesLineNumber, true);

                    if (salesLine)
                    {
                        real qtyOrderedInSalesUOM;
                        real qtyOrderedInInventoryUOM;
                        
                        if (RetailOrdersFeatureControl::useQtyInInventoryUOMForFulfillment())
                        {
                            qtyOrderedInSalesUOM = quantity;
                            qtyOrderedInInventoryUOM = salesLine.unitConvertSales2Invent(qtyOrderedInSalesUOM);
                        }
                        else
                        {
                            // Legacy behavior.
                            qtyOrderedInSalesUOM = salesLine.unitConvertInvent2Sales(quantity);
                            qtyOrderedInInventoryUOM = quantity;
                        }

                        // Verify that the quantity can be packed
                        select QuantityPacked, QuantityInvoiced, FulfillmentStatus from retailSalesLine where retailSalesLine.SalesLine == salesLine.RecId;

                        if (retailSalesLine)
                        {
                            // Verify that the quantity can be packed.
                            SalesQty qtyOrdered = salesLine.QtyOrdered;
                            if (!salesLine.isStocked() && RetailMarkServiceFulfillmentLinesAsPackedFlight::instance().isEnabled())
                            {
                                qtyOrdered = salesLine.SalesQty;
                            }

                            if (qtyOrderedInInventoryUOM > qtyOrdered - retailSalesLine.QuantityInvoiced - retailSalesLine.QuantityPacked)
                            {
                                success = false;
                                error = "@Retail:QuantityGreaterThanRemaining"; // The quantity entered is greater than the remaining quantity.
                                break;
                            }
                            else if (qtyOrderedInInventoryUOM < 0)
                            {
                                success = false;
                                error = "@Retail:QuantityLessThanZero"; // The quantity entered must be greater than zero.
                                break;
                                // Verify that the line can be marked as packed.
                            }
                            else if (retailSalesLine.FulfillmentStatus != RetailFulfillmentLineStatus::Accepted &&
                                    retailSalesLine.FulfillmentStatus != RetailFulfillmentLineStatus::Picking &&
                                    retailSalesLine.FulfillmentStatus != RetailFulfillmentLineStatus::PartiallyPicked &&
                                    retailSalesLine.FulfillmentStatus != RetailFulfillmentLineStatus::Picked &&
                                    retailSalesLine.FulfillmentStatus != RetailFulfillmentLineStatus::PartiallyPacked &&
                                    retailSalesLine.FulfillmentStatus != RetailFulfillmentLineStatus::PartiallyInvoiced)
                            {
                                success = false;
                                // One or more fulfillment lines can't be marked as packed. Only accepted, picking, partially picked, picked, and partially packed lines can be marked as packed.
                                error = "@Retail:FulfillmentLineCannotBeMarkedAsPacked";
                                break;
                            }
                            else
                            {
                                if (RetailOrderSerialNumberValidationFeatureExposure::isEnabled())
                                {
                                    str serialId = fulfillmentLineInfoType.GetProperty(SerialNumberProperty).GetValue(fulfillmentLine);
                                    str updateSerialIdError = RetailTransactionServiceFulfillment::updateSerialId(salesLine, retailSalesLine, serialId);
                                    if (updateSerialIdError != '')
                                    {
                                        success = false;
                                        error = updateSerialIdError;
                                        break;
                                    }
                                }

                                RetailTransactionServiceFulfillment::setWHSLocationToDefaultIfEmpty(salesLine);

                                // Update the quantity of the sales line to pack.
                                salesLine.SalesDeliverNow = qtyOrderedInSalesUOM;
                                salesLine.InventDeliverNow = qtyOrderedInInventoryUOM;
                                salesLine.doUpdate();
                            }
                        }
                        else
                        {
                            success = false;
                            error = "@Retail:FulfillmentLineCannotBeFound"; // Updating the fulfillment status failed because the fulfillment line can't be found.
                            break;
                        }
                    }
                    else
                    {
                        success = false;
                        error = "@Retail:FulfillmentLineCannotBeFound"; // Updating the fulfillment status failed because the fulfillment line can't be found.
                        break;
                    }

                    if (success)
                    {
                        // Call extension point to execute custom validations
                        var request = RetailTransactionServiceFulfillmentMarkAsPackedCustomValidationRequest::construct();
                        request.salesId = salesId;
                        request.salesLineNumber = salesLineNumber;
                        request.quantity = quantity;
                        var response = RetailTransactionServiceFulfillment::executeMarkFulfillmentLineAsPackedCustomValidation(request);
                        if (!response.isSuccessful)
                        {
                            success = response.isSuccessful;
                            error = response.errorMessage;
                            break;
                        }
                    }
                }

                eventSource.EventWriteFulfillmentProcessForSalesOrder(funcName(), SalesTable::find(orderNumber).RecId);

                // Pack the sales line.
                if (success)
                {
                    // Create Packing Slip
                    packingSlipId = RetailTransactionServiceFulfillment::createPackingSlip(orderNumber, packingDate);
                }

                ttscommit;
            }
            else
            {
                error = "@Retail:CrtVersionMismatch"; // The server doesn't support this operation.
            }
        }
        catch (Exception::CLRError)
        {
            success = false;
            System.Exception ex;
            ex = CLRInterop::getLastException();
            if (ex && ex.InnerException)
            {
                if (ex.InnerException.InnerException)
                {
                    // Use inner exception if it is available as it is often more descriptive.
                    error = ex.InnerException.InnerException.Message;
                }
                else
                {
                    error = ex.InnerException.Message;
                }
            }
        }
        catch(Exception::Error)
        {
            error = strFmt('@Retail:PackError',RetailTransactionServiceUtilities::getInfologMessages(infologLine));
            success = false;
        }

        // Call extension point with Packing Slip Id
        if (success)
        {
            extensionResult = RetailTransactionServiceFulfillment::packingSlipExtensionPoint(packingSlipId);
        }
        eventSource.EventWriteFulFillmentProcessEnd(funcName(), success);

        return [success, error, packingSlipId, extensionResult];
    }

]]></Source>
			</Method>
			<Method>
				<Name>AcceptFulfillmentLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the status of the fulfillment lines to Accepted.
    /// </summary>
    /// <param name="_fulfillmentXmlString">
    /// XML string containing the fulfillment lines.
    /// </param>
    /// <returns>
    /// A <c>Container</c> containing result info.
    /// </returns>
    /// <remarks>
    /// Container structure by positions:
    /// 1 - operation status (true means operation succeeded; false - an application error occured),
    /// 2 - error message (optional)
    /// </remarks>
    public static container AcceptFulfillmentLines(str _fulfillmentXmlString)
    {
        return RetailTransactionServiceFulfillment::UpdateFulfillmentLineStatus(_fulfillmentXmlString, RetailFulfillmentLineStatus::Accepted);
    }

]]></Source>
			</Method>
			<Method>
				<Name>PickFulfillmentLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the status of the fulfillment lines to Picking.
    /// </summary>
    /// <param name="_fulfillmentXmlString">
    /// XML string containing the fulfillment lines.
    /// </param>
    /// <returns>
    /// A <c>Container</c> containing result info.
    /// </returns>
    /// <remarks>
    /// Container structure by positions:
    /// 1 - operation status (true means operation succeeded; false - an application error occured),
    /// 2 - error message (optional)
    /// </remarks>
    public static container PickFulfillmentLines(str _fulfillmentXmlString)
    {
        return RetailTransactionServiceFulfillment::UpdateFulfillmentLineStatus(_fulfillmentXmlString, RetailFulfillmentLineStatus::Picking);
    }

]]></Source>
			</Method>
			<Method>
				<Name>rejectFulfillmentLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the status of the fulfillment lines to Rejected.
    /// </summary>
    /// <param name="_fulfillmentXmlString">
    /// XML string containing the fulfillment lines.
    /// </param>
    /// <returns>
    /// A <c>Container</c> containing result info.
    /// </returns>
    /// <remarks>
    /// Container structure by positions:
    /// 1 - operation status (true means operation succeeded; false - an application error occured),
    /// 2 - error message (optional)
    /// </remarks>
    public static container rejectFulfillmentLines(str _fulfillmentXmlString)
    {
        boolean success = true;
        str error = '';
        container result;

        try
        {
            eventSource.EventWriteFulFillmentProcessStart(funcName());

            // Load the assembly and CRT-defined types using reflection
            System.Reflection.Assembly transactionServiceAssembly = System.Reflection.Assembly::Load(TransactionServiceAssemblyName);
            System.Type fulfillmentInfoType = transactionServiceAssembly == null ? null : transactionServiceAssembly.GetType(FulfillmentInfoName);
            System.Type FulfillmentLineInfoCollectionType = transactionServiceAssembly == null ? null : transactionServiceAssembly.GetType(FulfillmentLineInfoCollectionName);
            System.Type fulfillmentLineInfoType = transactionServiceAssembly == null ? null : transactionServiceAssembly.GetType(FulfillmentLineInfoName);
            System.Reflection.MethodInfo fromXmlMethod = fulfillmentInfoType == null ? null : fulfillmentInfoType.GetMethod(FromXmlMethodName);

            if (fromXmlMethod != null)
            {
                // Deserialize the xml string input
                System.Object[] parameters = new System.Object[1]();
                parameters.SetValue(_fulfillmentXmlString, 0);
                var fulfillmentInfo = fromXmlMethod.Invoke(System.Activator::CreateInstance(fulfillmentInfoType), parameters);

                // Iterate through the collection of sales lines
                System.Collections.ICollection fulfillmentLines = fulfillmentInfoType.GetProperty(FulfillmentLinesProperty).GetValue(fulfillmentInfo) as System.Collections.ICollection;
                System.Collections.IEnumerator fulfillmentLineEnumerator = fulfillmentLines.GetEnumerator();
                ttsbegin;
                while (fulfillmentLineEnumerator.MoveNext())
                {
                    var fulfillmentLine = fulfillmentLineEnumerator.Current;
                    real salesLineNumber = fulfillmentLineInfoType.GetProperty(SalesLineNumberProperty).GetValue(fulfillmentLine);
                    real quantity = fulfillmentLineInfoType.GetProperty(QuantityProperty).GetValue(fulfillmentLine);
                    str salesId = fulfillmentLineInfoType.GetProperty(SalesIdProperty).GetValue(fulfillmentLine);
                    str reasonCodeId = fulfillmentLineInfoType.GetProperty(ReasonCodeIdProperty).GetValue(fulfillmentLine);
                    str reasonSubCodeId = fulfillmentLineInfoType.GetProperty(ReasonSubCodeIdProperty).GetValue(fulfillmentLine);

                    eventSource.EventWriteFulfillmentProcessForSalesOrder(funcName(), SalesTable::find(salesId).RecId);

                    result = RetailTransactionServiceFulfillment::rejectFulfillmentLine(salesId, salesLineNumber, quantity, reasonCodeId, reasonSubCodeId);

                    // Only update success and error for the first failure.
                    // Continue with reject for other sales lines even after the failure to reject
                    // one of them.
                    if (success)
                    {
                        int length = conLen(result);
                        if (length == 3)
                        {
                            success = conPeek(result, 1);
                            error = conPeek(result, 2);
                        }
                    }
                }

                ttscommit;
            }
            else
            {
                error = "@Retail:CrtVersionMismatch"; // The server doesn't support this operation.
            }
        }
        catch (Exception::CLRError)
        {
            success = false;
            System.Exception ex;
            ex = CLRInterop::getLastException();
            if (ex && ex.InnerException)
            {
                if (ex.InnerException.InnerException)
                {
                    // Use inner exception if it is available as it is often more descriptive.
                    error = ex.InnerException.InnerException.Message;
                }
                else
                {
                    error = ex.InnerException.Message;
                }
            }
        }
        eventSource.EventWriteFulFillmentProcessEnd(funcName(), success);

        return [success, error];
    }

]]></Source>
			</Method>
			<Method>
				<Name>rejectFulfillmentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the status of the fulfillment line to Rejected.
    /// </summary>
    /// <param name = "salesId">The Sales Id.</param>
    /// <param name = "salesLineNumber">The Sales line number.</param>
    /// <param name = "rejectedQuantity">Rejected quantity.</param>
    /// <param name = "reasonCodeId">Reason code Id.</param>
    /// <param name = "reasonSubCodeId">Reason Sub Code Id.</param>
    /// <returns>
    /// Container structure by positions:
    /// 1 - operation status (true means operation succeeded; false - an application error occured),
    /// 2 - error message (optional)
    /// 3 - RecId of the SalesLine with Rejected fulfillment status.
    /// </returns>
    /// <remarks>
    /// Currently the caller is responsible to specify a SQL transaction before calling this API.
    /// </remarks>
    public static container rejectFulfillmentLine(str salesId, real salesLineNumber, real rejectedQuantity, str reasonCodeId, str reasonSubCodeId)
    {
        boolean success = true;
        str error = '';
        SalesLine salesLine;
        RetailSalesLine retailSalesLine;
        real _salesQty;
        RetailFulfillmentRejectData originalSalesLineData;
        RetailFulfillmentRejectData splitSalesLineData;
        int fulfillmentLines;
        SalesLine splitSalesLine;
        RecId rejectedSalesLineRecId;

        // Get sales line data
        salesLine = SalesLine::find(salesId, salesLineNumber, false);

        if (!salesLine)
        {
            // Sales line does not exist
            success = false;
            error = "@Retail:FulfillmentLineCannotBeFound"; // Updating the fulfillment status failed because the fulfillment line can't be found.
            return [success, error, rejectedSalesLineRecId];
        }

        if (rejectedQuantity <= 0 || rejectedQuantity > salesLine.SalesQty)
        {
            // Validate quantity is not zero or negative
            success = false;
            error = "@Retail:FulfillmentLineRejectedInvalidQuantity"; // Fulfillment line reject has invalid quantity.
            return [success, error, rejectedSalesLineRecId];
        }

        _salesQty = salesLine.SalesQty;

        // Preserve original SalesLine's RecId in case reject is a Full Reject.
        rejectedSalesLineRecId = salesLine.RecId;

        // Get reject reason description
        RetailInformationSubcodeTranslationDescr information;
        information = RetailTransactionServiceFulfillment::getReasonCodeInformation(salesLine.DataAreaId, reasonCodeId, reasonSubCodeId);

        try
        {
            RetailFulfillmentRejectStatusCalculationResult result;
            
            // Get rejected line properties
            retailSalesLine = RetailSalesLine::findBySalesLine(salesLine.RecId, false);
                
            // Calculate reject result
            result = RetailFulfillmentRejectCalculator::prepareFulfillmentValuesForReject(
                rejectedQuantity,
                _salesQty,
                retailSalesLine.QuantityPicked,
                retailSalesLine.QuantityPacked,
                retailSalesLine.QuantityInvoiced,
                retailSalesLine.FulfillmentStatus);

            // Check if call to CalculateRejectStatus succeeded
            if (!result.parmSuccess())
            {
                return [result.parmSuccess(), result.parmErrorMessage(), rejectedSalesLineRecId];
            }

            // Parse result
            ListEnumerator enumerator;

            fulfillmentLines = 0;
            enumerator = result.parmFulfillmentRejectData().getEnumerator();
            enumerator.reset();

            while (enumerator.moveNext())
            {
                if (fulfillmentLines == 0)
                {
                    originalSalesLineData = enumerator.current();
                }
                else if (fulfillmentLines == 1)
                {
                    splitSalesLineData = enumerator.current();
                }

                fulfillmentLines++;
            }

            // Split the line if needed
            if (fulfillmentLines > 1)
            {
                SalesTable salesTableRecord = SalesTable::find(salesId);

                // Update original sales line with new QuantityOrdered value.
                // Last parameter is saying that original line is updated.
                OrderFulfillmentHelper::createOrUpdateSplitQuantitySalesLine(salesTableRecord, salesLine, originalSalesLineData.parmQuantityOrdered(), true);

                // Create new sales line using provided sales line as a template and
                // set QuantityOrdered for new sales line to provided value.
                // Last parameter is saying that new copy of original sales line need to be
                // created and added to the sale.
                splitSalesLine = OrderFulfillmentHelper::createOrUpdateSplitQuantitySalesLine(salesTableRecord, salesLine, splitSalesLineData.parmQuantityOrdered(), false);
            }
            else if (fulfillmentLines == 0)
            {
                // No lines match criteria (expect 1 or more) - line(s) already rejected.
                success = false;
                error = "@Retail:FulfillmentLineNotQualified"; // Updating the fulfillment status failed because the fulfillment line can't be found.
                return [success, error, rejectedSalesLineRecId];
            }
                
            // Update sales line 1
            select forupdate retailSalesLine
                where retailSalesLine.SalesLine == salesLine.RecId;

            if (!retailSalesLine)
            {
                success = false;
                error = "@Retail:FulfillmentLineCannotBeFound"; // Updating the fulfillment status failed because the fulfillment line can't be found.
                return [success, error, rejectedSalesLineRecId];
            }

            if (originalSalesLineData.parmFulfillmentLineStatus() == RetailFulfillmentLineStatus::Rejected)
            {
                retailSalesLine.InfocodeId = reasonCodeId;
                retailSalesLine.SubInfocodeId = reasonSubCodeId;
                retailSalesLine.Information = information;
            }
            else
            {
                retailSalesLine.InfocodeId = '';
                retailSalesLine.SubInfocodeId = '';
                retailSalesLine.Information = '';
            }

            retailSalesLine.FulfillmentStatus = originalSalesLineData.parmFulfillmentLineStatus();
            retailSalesLine.QuantityPicked = originalSalesLineData.parmQuantityPicked();
            retailSalesLine.QuantityPacked = originalSalesLineData.parmQuantityPacked();
            retailSalesLine.QuantityInvoiced = originalSalesLineData.parmQuantityInvoiced();
            retailSalesLine.update();
                
            // Update sales line 2
            if (fulfillmentLines > 1)
            {
                select forupdate retailSalesLine
                    where retailSalesLine.SalesLine == splitSalesLine.RecId;

                if (!retailSalesLine)
                {
                    success = false;
                    error = "@Retail:FulfillmentLineCannotBeFound"; // Updating the fulfillment status failed because the fulfillment line can't be found.
                    return [success, error, rejectedSalesLineRecId];
                }

                // This is a partial reject.
                rejectedSalesLineRecId = splitSalesLine.RecId;

                retailSalesLine.InfocodeId = reasonCodeId;
                retailSalesLine.SubInfocodeId = reasonSubCodeId;
                retailSalesLine.Information = information;
                retailSalesLine.FulfillmentStatus = splitSalesLineData.parmFulfillmentLineStatus();
                retailSalesLine.QuantityPicked = splitSalesLineData.parmQuantityPicked();
                retailSalesLine.QuantityPacked = splitSalesLineData.parmQuantityPacked();
                retailSalesLine.QuantityInvoiced = splitSalesLineData.parmQuantityInvoiced();
                retailSalesLine.update();
            }
        }
        catch (Exception::Error)
        {
            success = false;
            error = "@Retail:FulfillmentLineCannotBeFound"; // Updating the fulfillment status failed because the fulfillment line can't be found.
        }

        return [success, error, rejectedSalesLineRecId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFulfillmentStatusFromCreatedSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update fulfillment status from the created sales line.
    /// </summary>
    /// <param name = "_salesLine">The created sales line.</param>
    /// <param name = "_retailSalesLine">The retail sales line associated with sales line.</param>
    public static void updateFulfillmentStatusFromCreatedSalesLine(SalesLine _salesLine, RetailSalesLine _retailSalesLine)
    {
        RefRecId salesLineRecId = _salesLine.RecId;

        RetailParameters retailParams = RetailParameters::find();
        DlvModeId carryOutDlvMode = retailParams.CarryOutDeliveryModeCode;
        DlvModeId electronicDlvMode = retailParams.ElectronicDeliveryModeCode;
        SalesTable salesTable = _salesLine.salesTable();

        // Do not process SalesTable that has order type outside Retail.
        // Do not process Carry Out or Electronic Dlv Mode.
        if (!RetailTransactionServiceFulfillment::hasValidOrderType(_salesLine.salesTable())
            || (carryOutDlvMode == _salesLine.DlvMode && carryOutDlvMode != '')
            || (electronicDlvMode == _salesLine.DlvMode && electronicDlvMode != ''))
        {
            return;
        }

        eventSource.EventWriteFulfillmentProcessForSalesLine(funcName(), salesLineRecId);
        _retailSalesLine.FulfillmentStatus = RetailTransactionServiceFulfillment::getUpdatedOpenOrderFulfillmentStatus(_retailSalesLine);
        RetailTransactionServiceFulfillment::updateOnOrderAndReservedQuantities(_salesLine, _retailSalesLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFulfillmentStatusFromEditSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update fulfillment status from edited SalesLine.
    /// </summary>
    /// <param name = "_salesLine">The edited SalesLine.</param>
    /// <param name = "_updateRejectedLines">A flag indicating whether or not to update lines that have been rejected.</param>
    public static void updateFulfillmentStatusFromEditSalesLine(SalesLine _salesLine, boolean _updateRejectedLines = false)
    {
        RefRecId salesLineRecId = _salesLine.RecId;

        RetailParameters retailParams = RetailParameters::find();
        DlvModeId carryOutDlvMode = retailParams.CarryOutDeliveryModeCode;
        DlvModeId electronicDlvMode = retailParams.ElectronicDeliveryModeCode;
        RetailSalesLine retSalesLine = RetailSalesLine::findBySalesLine(_salesLine.RecId);
        RetailFulfillmentLineStatus currentStatus = retSalesLine.FulfillmentStatus;
        RetailFulfillmentLineStatus updatedStatus = retSalesLine.FulfillmentStatus;
        RetailStoreId currentFulfillmentStoreId = retSalesLine.FulfillmentStoreId;
        RetailStoreId updatedFulfillmentStoreId = _salesLine.mcrGetFulfillmentStore();
        // Only update fulfillment store id when the flight is enabled and the fulfillment store id is updated.
        boolean shouldUpdateFulfillmentStoreId = false;
        if (RetailUpdateSalesLineFulfillmentStoreIdFlight::instance().isEnabled())
        {
            shouldUpdateFulfillmentStoreId = currentFulfillmentStoreId != updatedFulfillmentStoreId;
            // Set the new fulfillment store id so the fulfillment status can be calculated correctly.
            retSalesLine.FulfillmentStoreId = updatedFulfillmentStoreId;
        }
        int infologLine;
        str errorMessage;

        // Do not process SalesTable that has order type outside Retail.
        // Do not process fulfillment status: Rejected.
        // Do not process fulfillment status Unknown when the retail sales lines is not created yet.
        // Do not process delivery mode: Carry Out, Electronic Dlv Mode.
        if (!RetailTransactionServiceFulfillment::hasValidOrderType(_salesLine.salesTable())
            || (retSalesLine.FulfillmentStatus == RetailFulfillmentLineStatus::Unknown && !retSalesLine)
            || (retSalesLine.FulfillmentStatus == RetailFulfillmentLineStatus::Rejected && !_updateRejectedLines)
            || (carryOutDlvMode == _salesLine.DlvMode && carryOutDlvMode != '')
            || (electronicDlvMode == _salesLine.DlvMode && electronicDlvMode != ''))
        {
            return;
        }

        eventSource.EventWriteFulfillmentProcessForSalesLine(funcName(), salesLineRecId);

        if (RetailUpdateFulfillmentStatusFlightV2::instance().isEnabled())
        {
            updatedStatus = RetailTransactionServiceFulfillment::getFulfillmentStatusV2(_salesLine, retSalesLine, true);
        }
        else
        {
            if (retSalesLine.QuantityInvoiced > 0)
            {
                if (_salesLine.SalesQty == retSalesLine.QuantityInvoiced)
                {
                    // Status is Invoiced when QuantityOrdered is QuantityInvoiced.
                    updatedStatus = RetailFulfillmentLineStatus::Invoiced;
                }
                else if (_salesLine.SalesQty > retSalesLine.QuantityInvoiced)
                {
                    // Status is Partially Invoiced when QuantityOrdered is more than QuantityInvoiced.
                    updatedStatus = RetailFulfillmentLineStatus::PartiallyInvoiced;
                }
            }
            else if (retSalesLine.QuantityPacked > 0)
            {
                if (_salesLine.SalesQty == retSalesLine.QuantityPacked)
                {
                    // Status is Packed when QuantityOrdered is QuantityPacked.
                    updatedStatus = RetailFulfillmentLineStatus::Packed;
                }
                else if (_salesLine.SalesQty > retSalesLine.QuantityPacked)
                {
                    // Status is Partially Packed when QuantityOrdered is more than QuantityPacked.
                    updatedStatus = RetailFulfillmentLineStatus::PartiallyPacked;
                }
            }
            else if (retSalesLine.QuantityPicked > 0)
            {
                if (_salesLine.SalesQty == retSalesLine.QuantityPicked)
                {
                    // Status is Picked when QuantityOrdered is QuantityPicked.
                    updatedStatus = RetailFulfillmentLineStatus::Picked;
                }
                else if (_salesLine.SalesQty > retSalesLine.QuantityPicked)
                {
                    // Status is Partially Picked when QuantityOrdered is more than QuantityPicked.
                    updatedStatus = RetailFulfillmentLineStatus::PartiallyPicked;
                }
            }
            else if (_salesLine.SalesQty > 0 && retSalesLine.QuantityPicked == 0 && retSalesLine.QuantityPacked == 0 && retSalesLine.QuantityInvoiced == 0)
            {
                updatedStatus = RetailTransactionServiceFulfillment::getUpdatedOpenOrderFulfillmentStatus(retSalesLine);
            }
        }
       
        // Update only if status is changed.
        if (currentStatus != updatedStatus || shouldUpdateFulfillmentStoreId)
        {
            try
            {
                infologLine = Global::infologLine();
                ttsbegin;
                retSalesLine.selectForUpdate(true);

                // Reset the reject reasons for rejected lines
                if (currentStatus == RetailFulfillmentLineStatus::Rejected && currentStatus != updatedStatus)
                {
                    retSalesLine.InfocodeId = '';
                    retSalesLine.Information = '';
                    retSalesLine.SubInfocodeId ='';
                }

                retSalesLine.FulfillmentStatus = updatedStatus;
                retSalesLine.update();
                ttscommit;

                // Reread SalesLine to prevent SalesLine.update() failing due to UpdateConflict on RetailSalesLine
                _salesLine.reread();
            }
            catch (Exception::Error)
            {
                errorMessage = RetailTransactionServiceUtilities::getInfologMessages(infologLine);
                RetailTracer::Error('RetailTransactionServiceFulfilment', funcName(), errorMessage);
                throw error(errorMessage); // throw error will do auto ttsabort.
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetFulfillmentStatusFromEditSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reset the fulfillment status to the initial state if it is possible
    /// </summary>
    /// <param name = "_salesLine">The edited SalesLine.</param>
    public static void resetFulfillmentStatusFromEditSalesLine(SalesLine _salesLine)
    {
        RetailTransactionServiceFulfillment::updateFulfillmentStatusFromEditSalesLine(_salesLine, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>packingSlipExtensionPoint</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides chain of command extensibility point for partners to associate any
    /// additional information they may need with the packing slip Id.
    /// </summary>
    /// <param name= "_packingSlipId">Packing slip Id.</param>
    /// <returns>Returns <c>true</c> if completed successfully; otherwise, <c>false</c>.</returns>
    protected static boolean packingSlipExtensionPoint(PackingSlipId _packingSlipId)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPackingSlip</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates packing slip.
    /// </summary>
    /// <param name = "salesId">Sales Id.</param>
    /// <param name = "packingDate">Packing date.</param>
    /// <returns>Returns the latest packing slip Id for provided Sales Id.</returns>
    private static PackingSlipId createPackingSlip(SalesId salesId, TransDate packingDate)
    {
        SalesTable salesTable = SalesTable::find(salesId);
        SalesFormLetter salesFormLetter;
        SalesFormLetterConstructContext context = null;

        try
        {
            if (RetailFulfillmentResetPackingSlipLastValueFlight::instance().isEnabled())
            {
                context = SalesFormLetterConstructContext::construct();
                context.parmLoadFromSysLastValue(UnknownNoYes::No);
            }

            salesFormLetter = SalesFormLetter::construct(DocumentStatus::PackingSlip);
            salesFormLetter.reArrangeNow(false);

            // set the packing date with RetailServiceAccount time if we don't receive the local time from CSU
            if (!packingDate)
            {
                packingDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
            }

            salesFormLetter.update(salesTable, packingDate, SalesUpdate::DeliverNow, AccountOrder::None, false, false, false);
        }
        finally
        {
            if (context != null)
            {
                context.Dispose();
            }
        }

        FormletterOutputContract outputContract;
        CustPackingSlipJour journal;
        boolean updateError;
        Counter numberOfOrdersPosted;

        outputContract = salesFormLetter.getOutputContract();
        updateError = outputContract.parmUpdateError();
        numberOfOrdersPosted = outputContract.parmNumberOfOrdersPosted();

        if (updateError || numberOfOrdersPosted == 0)
        {
            // Failed to create packing slip.
            // Calling code will set the returned error message.
            throw error('');
        }

        journal = outputContract.parmJournal();

        return journal.PackingSlipId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUpdatedOpenOrderFulfillmentStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update fulfillment status in an open order.
    /// </summary>
    /// <param name= "_retailSalesLine">The retail sales line.</param>
    /// <returns>The updated fulfillment status.</returns>
    internal static RetailFulfillmentLineStatus getUpdatedOpenOrderFulfillmentStatus(RetailSalesLine _retailSalesLine)
    {
        RetailFulfillmentLineStatus updatedStatus;
        RetailStoreTable retailStoreTable = RetailStoreTable::find(_retailSalesLine.FulfillmentStoreId);

        boolean isManualAccept = retailStoreTable && retailStoreTable.ManualAccept;

        if (isManualAccept)
        {
            // When manual accept is true, sales line has fulfillment status Pending.
            updatedStatus = RetailFulfillmentLineStatus::Pending;
        }
        else
        {
            // When manual accept is false, sales line has fulfillment status Accepted.
            updatedStatus = RetailFulfillmentLineStatus::Accepted;
        }

        return updatedStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasValidOrderType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate whether the sales table has valid order type for fulfillment status update.
    /// </summary>
    /// <param name = "_salesTable">The instance of SalesTable.</param>
    /// <returns>True if order type is valid, false otherwise.</returns>
    private static boolean hasValidOrderType(SalesTable _salesTable)
    {
        boolean hasValidSalesStatus = _salesTable.SalesStatus == SalesStatus::Backorder
            || _salesTable.SalesStatus == SalesStatus::Delivered
            || _salesTable.SalesStatus == SalesStatus::Invoiced;
        boolean hasValidSalesType = _salesTable.SalesType == SalesType::Sales;
        boolean isRetailOrder = _salesTable.isRetailSale();
        boolean isCallCenterOrder = _salesTable.mcrIsCallCenter();

        return hasValidSalesStatus && hasValidSalesType && (isRetailOrder || isCallCenterOrder);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shipFulFillmentLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ships the fulfillment lines.
    /// </summary>
    /// <param name="_fulfillmentXmlString">
    /// XML string containing the fulfillment lines.
    /// </param>
    /// <returns>
    /// A <c>Container</c> containing result info.
    /// </returns>
    /// <remarks>
    /// Container structure by positions:
    /// 1 - operation status (true means operation succeeded; false - an application error occured),
    /// 2 - error message (optional)
    /// </remarks>
    public static container shipFulFillmentLines(str fulfillmentXmlString)
    {
        boolean success = true;
        str error = '';
        int fromLine;

        // Validate argument passed.
        if (fulfillmentXmlString == null || fulfillmentXmlString == '')
        {
            error = "@Retail:InvalidFunctionParameter";
            success = false;
            return [success, error];
        }

        try
        {
            fromLine = Global::infologLine();

            // Load the assembly and CRT-defined types using reflection
            System.Reflection.Assembly transactionServiceAssembly = System.Reflection.Assembly::Load(TransactionServiceAssemblyName);
            System.Type shipFulfillmentInfoType = transactionServiceAssembly == null ? null : transactionServiceAssembly.GetType(ShipFulfillmentInfoName);
            System.Type shipFulfillmentLineInfoType = transactionServiceAssembly == null ? null : transactionServiceAssembly.GetType(ShipFulfillmentLineInfoName);
            System.Type salesLineQuantityInfoType = transactionServiceAssembly == null ? null : transactionServiceAssembly.GetType(SalesLineQuantityInfoName);
            System.Reflection.MethodInfo fromXmlMethod = shipFulfillmentInfoType == null ? null : shipFulfillmentInfoType.GetMethod(FromXmlMethodName);

            if (fromXmlMethod != null)
            {
                // Deserialize the xml string input
                System.Object[] parameters = new System.Object[1]();
                parameters.SetValue(fulfillmentXmlString, 0);
                var fulfillmentInfo = fromXmlMethod.Invoke(System.Activator::CreateInstance(shipFulfillmentInfoType), parameters);

                // Iterate through the collection of fulfillment lines
                str currentChannelRecId = shipFulfillmentInfoType.GetProperty(CurrentChannelRecordIdProperty).GetValue(fulfillmentInfo);
                System.Collections.ICollection fulfillmentLines = shipFulfillmentInfoType.GetProperty(FulfillmentLinesProperty).GetValue(fulfillmentInfo) as System.Collections.ICollection;
                System.Collections.IEnumerator fulfillmentLineEnumerator = fulfillmentLines.GetEnumerator();
                while (fulfillmentLineEnumerator.MoveNext())
                {
                    var fulfillmentLine = fulfillmentLineEnumerator.Current;
                    str salesId = shipFulfillmentLineInfoType.GetProperty(SalesIdProperty).GetValue(fulfillmentLine);
                    str invoiceDateString = shipFulfillmentLineInfoType.GetProperty(InvoiceDateStringProperty).GetValue(fulfillmentLine);
                    System.Collections.ICollection salesLineQuantityInfoCollection = shipFulfillmentLineInfoType.GetProperty(SalesLineQuantityInfoCollectionProperty).GetValue(fulfillmentLine);

                    // step 1: Get customer order info object from the fulfillment line info.
                    Map salesLineQuantityInfo = new Map(Types::Real, Types::Real);
                    Map salesLineSerialIdMap = new Map(Types::Real, Types::String);

                    System.Collections.IEnumerator salesLineQuantityEnumerator = salesLineQuantityInfoCollection.GetEnumerator();
                    while (salesLineQuantityEnumerator.MoveNext())
                    {
                        var salesLineQuantity = salesLineQuantityEnumerator.Current;
                        LineNumber salesLineNumber = salesLineQuantityInfoType.GetProperty(SalesLineNumberProperty).GetValue(salesLineQuantity);
                        SalesQty quantity = salesLineQuantityInfoType.GetProperty(QuantityProperty).GetValue(salesLineQuantity);
                        
                        salesLineQuantityInfo.insert(salesLineNumber, quantity);

                        if (RetailOrderSerialNumberValidationFeatureExposure::isEnabled())
                        {
                            str serialId = salesLineQuantityInfoType.GetProperty(SerialNumberProperty).GetValue(salesLineQuantity);
                            if (!System.String::IsNullOrEmpty(serialId))
                            {
                                salesLineSerialIdMap.insert(salesLineNumber, serialId);
                            }
                        }
                    }

                    container result = RetailTransactionServiceOrders::getCustomerOrderInfoForShipFulfillmentLine(salesId, salesLineQuantityInfo);
                    
                    if (conPeek(result, 1) == false)
                    {
                        success = false;
                        error = conPeek(result, 2);
                        break;
                    }

                    str customerOrderInfoXml = conPeek(result, 3);
                    CustomerOrderInfo customerOrderInfo = CustomerOrderInfo::FromXml(customerOrderInfoXml);

                    // Add business date properties to customerOrderInfo based on fulfillment line's invoice date.
                    if (!System.String::IsNullOrEmpty(invoiceDateString))
                    {
                        customerOrderInfo.BusinessDateString = invoiceDateString;
                    }

                    if (RetailOrderSerialNumberValidationFeatureExposure::isEnabled())
                    {
                        ItemInfoCollection items = customerOrderInfo.Items as ItemInfoCollection;
                        for (int i = 0; i < items.get_Count(); i++)
                        {
                            ItemInfo itemInfo = items.get_Item(i) as ItemInfo;
                            if (salesLineSerialIdMap.exists(itemInfo.LineNumber))
                            {
                                itemInfo.SerialId = salesLineSerialIdMap.lookup(itemInfo.LineNumber);
                            }
                        }
                    }

                    // Step 2: Calculate deposit to be applied.
                    CustomerOrderInfo custInfo = new CustomerOrderInfo();
                    custInfo = customerOrderInfo;
                    custInfo.PrepaymentAmountApplied = RetailTransactionServiceFulfillment::calculateDeposit(custInfo, currentChannelRecId);

                    // Step 3: Settle the Customer order
                    result = RetailTransactionServiceOrders::settleCustomerOrder(customerOrderInfo);

                    if (conPeek(result, 1) == false)
                    {
                        success = false;
                        error = conPeek(result, 2);
                        break;
                    }
                }
            }
            else
            {
                error = "@Retail:CrtVersionMismatch"; // The server doesn't support this operation.
            }
        }
        catch(Exception::UpdateConflict)
        {
            error = "@Retail:SalesOrderUpdateConflict";
            success = false;
        }
        catch(Exception::Deadlock)
        {
            error = "@Retail:SalesOrderUpdateConflict";
            success = false;
        }
        catch(Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            success = false;
        }

        return [success, error];
    }

]]></Source>
			</Method>
			<Method>
				<Name>UpdateFulfillmentLineStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the status of the fulfillment lines.
    /// </summary>
    /// <param name="_fulfillmentXmlString">
    /// XML string containing the fulfillment lines.
    /// </param>
    /// <param name="_status">
    /// The status to change the fulfillment lines to.
    /// </param>
    /// <returns>
    /// A <c>Container</c> containing result info.
    /// </returns>
    /// <remarks>
    /// Container structure by positions:
    /// 1 - operation status (true means operation succeeded; false - an application error occured),
    /// 2 - error message (optional)
    /// </remarks>
    private static container UpdateFulfillmentLineStatus(str _fulfillmentXmlString, RetailFulfillmentLineStatus _status)
    {
        boolean success = true;
        str error = '';
        SalesLine salesLine;
        RetailSalesLine retailSalesLine;
        RetailInformationSubcodeTable retailInformationSubcodeTable;
        RetailInformationSubcodeTranslation retailInformationSubcodeTranslation;

        try
        {
            eventSource.EventWriteFulFillmentProcessStart(funcName());

            // Load the assembly and CRT-defined types using reflection
            System.Reflection.Assembly transactionServiceAssembly = System.Reflection.Assembly::Load(TransactionServiceAssemblyName);
            System.Type fulfillmentInfoType = transactionServiceAssembly == null ? null : transactionServiceAssembly.GetType(FulfillmentInfoName);
            System.Type FulfillmentLineInfoCollectionType = transactionServiceAssembly == null ? null : transactionServiceAssembly.GetType(FulfillmentLineInfoCollectionName);
            System.Type fulfillmentLineInfoType = transactionServiceAssembly == null ? null : transactionServiceAssembly.GetType(FulfillmentLineInfoName);
            System.Reflection.MethodInfo fromXmlMethod = fulfillmentInfoType == null ? null : fulfillmentInfoType.GetMethod(FromXmlMethodName);

            if (fromXmlMethod != null)
            {
                // Deserialize the xml string input
                System.Object[] parameters = new System.Object[1]();
                parameters.SetValue(_fulfillmentXmlString, 0);
                var fulfillmentInfo = fromXmlMethod.Invoke(System.Activator::CreateInstance(fulfillmentInfoType), parameters);

                // Call extension point to execute custom validations
                var request = RetailTransactionServiceFulfillmentUpdateLineStatusCustomValidationRequest::construct();
                request.fulfillmentInfo = fulfillmentInfo;
                request.status = _status;
                var response = RetailTransactionServiceFulfillment::executeUpdateFulfillmentLineStatusCustomValidation(request);
                if (!response.isSuccessful)
                {
                    return [false, response.errorMessage];
                }

                // Iterate through the collection of sales lines
                System.Collections.ICollection fulfillmentLines = fulfillmentInfoType.GetProperty(FulfillmentLinesProperty).GetValue(fulfillmentInfo) as System.Collections.ICollection;
                System.Collections.IEnumerator fulfillmentLineEnumerator = fulfillmentLines.GetEnumerator();
                ttsbegin;
                while (fulfillmentLineEnumerator.MoveNext())
                {
                    var fulfillmentLine = fulfillmentLineEnumerator.Current;
                    real salesLineNumber = fulfillmentLineInfoType.GetProperty(SalesLineNumberProperty).GetValue(fulfillmentLine);
                    real quantity = fulfillmentLineInfoType.GetProperty(QuantityProperty).GetValue(fulfillmentLine);
                    str salesId = fulfillmentLineInfoType.GetProperty(SalesIdProperty).GetValue(fulfillmentLine);
                    str reasonCodeId = fulfillmentLineInfoType.GetProperty(ReasonCodeIdProperty).GetValue(fulfillmentLine);
                    str reasonSubCodeId = fulfillmentLineInfoType.GetProperty(ReasonSubCodeIdProperty).GetValue(fulfillmentLine);

                    eventSource.EventWriteFulfillmentProcessForSalesOrder(funcName(), SalesTable::find(salesId).RecId);

                    // Update the fulfillment status of each line
                    select firstonly LineNum, SalesId, RecId, SalesQty, DataAreaId from salesLine where SalesLine.SalesId == salesId && salesLine.LineNum == salesLineNumber;

                    if (salesLine)
                    {
                        select forupdate retailSalesLine where retailSalesLine.SalesLine == salesLine.RecId;
                        if (retailSalesLine)
                        {
                            switch (_status)
                            {
                                case RetailFulfillmentLineStatus::Accepted:

                                if (retailSalesLine.FulfillmentStatus == RetailFulfillmentLineStatus::Pending)
                                    {
                                        retailSalesLine.FulfillmentStatus = RetailFulfillmentLineStatus::Accepted;
                                        retailSalesLine.update();
                                    }
                                    else
                                    {
                                        success = false;
                                        error = "@Retail:FulfillmentLineAlreadyAccepted"; // One or more fulfillment lines can't be accepted. Only pending fulfillment lines can be accepted.
                                    }

                                    break;

                                case RetailFulfillmentLineStatus::Picking:
                                    if (retailSalesLine.FulfillmentStatus == RetailFulfillmentLineStatus::Accepted
                                        || RetailSalesLine.FulfillmentStatus == RetailFulfillmentLineStatus::Picking)
                                    {
                                        retailSalesLine.FulfillmentStatus = RetailFulfillmentLineStatus::Picking;
                                        retailSalesLine.update();
                                    }
                                    else
                                    {
                                        success = false;
                                        error = "@Retail:FulfillmentLineCannotBeMarkedAsPicking"; // One or more fulfillment lines can't be marked as picking. Only accepted lines can be marked as picking.
                                    }

                                    break;

                                default:
                                    break;
                            }
                        }
                        else
                        {
                            success = false;
                            error = "@Retail:FulfillmentLineCannotBeFound"; // Updating the fulfillment status failed because the fulfillment line can't be found.
                        }
                    }
                    else
                    {
                        success = false;
                        error = "@Retail:FulfillmentLineCannotBeFound"; // Updating the fulfillment status failed because the fulfillment line can't be found.
                    }
                }

                ttscommit;
            }
            else
            {
                error = "@Retail:CrtVersionMismatch"; // The server doesn't support this operation.
            }
        }
        catch (Exception::CLRError)
        {
            success = false;
            System.Exception ex;
            ex = CLRInterop::getLastException();
            if (ex && ex.InnerException)
            {
                if (ex.InnerException.InnerException)
                {
                    // Use inner exception if it is available as it is often more descriptive.
                    error = ex.InnerException.InnerException.Message;
                }
                else
                {
                    error = ex.InnerException.Message;
                }
            }
        }
        eventSource.EventWriteFulFillmentProcessEnd(funcName(), success);

        return [success, error];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFulfillmentLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get list of fulfillment lines.
    /// </summary>
    /// <param name = "_fulfillmentSearchCriteriaXml">The fulfillment search criteria xml.</param>
    /// <returns>A container that has list of fulfillment lines that matches the fulfillment criteria.</returns>
    /// <remarks>
    /// Xml argument example:
    /// <TransactionServiceFulfillmentLineSearchCriteria>
    ///  <DeliveryTypeValue>1</DeliveryTypeValue/>
    ///  <SalesId/>
    ///  <CustomerId/>
    ///  <CustomerName/>
    ///  <EmailAddress/>
    ///  <ChannelReferenceId />
    ///  <ReceiptId/>
    ///  <FulfillmentStatusValue>5,6,7</FulfillmentStatusValue>
    ///  <OrderCreatedStartDate/>
    ///  <OrderCreatedEndDate/>
    ///  <RequestedDeliveryStartDate/>
    ///  <RequestedDeliveryEndDate/>
    ///  <RequestedReceiptStartDate/>
    ///  <RequestedReceiptEndDate/>
    ///  <DeliveryModeCode/>
    ///  <StartDateTime/>
    ///  <EndDateTime/>
    ///  <WarehouseId />
    ///  <StoreId/>
    ///
    ///  <PagingInfo>
    ///    <Skip/>
    ///    <Top/>
    ///  </PagingInfo>
    ///  <SortColumn>
    ///    <ColumnName/>
    ///    <IsDescending/>
    ///  </SortColumn>
    /// </TransactionServiceFulfillmentLineSearchCriteria>
    /// </remarks>
    public static container getFulfillmentLines(str _fulfillmentSearchCriteriaXml)
    {
        int infologLine = Global::infologLine();

        try
        {
            if (RetailUseCompressedDataSourceForGetFulfillmentLinesToggle::instance().isEnabled())
            {
                return RetailTransactionServiceFulfillment::getFulfillmentLinesInternalV2(_fulfillmentSearchCriteriaXml);
            }
            else
            {
                return RetailTransactionServiceFulfillment::getFulfillmentLinesInternalLegacy(_fulfillmentSearchCriteriaXml);
            }
        }
        catch(Exception::Error)
        {
            eventSource.WriteFulfillmentMethodFailure(funcName());
            str errorMessage = RetailTransactionServiceUtilities::getInfologMessages(infologLine);
            return [false, errorMessage, ''];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPackingSlipsData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the packing slip data given a sales order identifier.
    /// </summary>
    /// <param name = "salesId">The sales order identifier.</param>
    /// <returns>A list of packing slip data.</returns>
    public static container getPackingSlipsData(SalesId salesId)
    {
        CustPackingSlipJour journal;
        XmlDocument xmlDoc;
        XmlElement xmlRoot, packingSlipDataElement;

        eventSource.EventWriteFulFillmentProcessStart(funcName());

        // Initialize xml return result
        xmlDoc = RetailTransactionServiceUtilities::getXmlDocumentForSerializedEntities();
        xmlRoot = xmlDoc.createElement(ArrayOfPackingSlipDataName);
        xmlRoot.setAttribute('xmlns', RetailTransactionServiceUtilities::getCrtDataModelXmlNamespace());

        eventSource.EventWriteFulfillmentProcessForSalesOrder(funcName(), SalesTable::find(salesId).RecId);

        while select PackingSlipId, CreatedDateTime
            from journal
            where journal.SalesId == salesId
        {
            CustPackingSlipJour custPackingSlipJour = CustPackingSlipJour::findRecId(journal.RecId);
            if (!custPackingSlipJour.isCanceled())
            {
                packingSlipDataElement = xmlDoc.createElement(PackingSlipDataElementName);
                RetailTransactionServiceFulfillment::addDateElementResult(xmlDoc, packingSlipDataElement, CreatedDateTimeElementName, journal.CreatedDateTime);
                RetailTransactionServiceFulfillment::addElementStrResult(xmlDoc, packingSlipDataElement, PackingSlipIdElementName, journal.PackingSlipId);
                xmlRoot.appendChild(packingSlipDataElement);
            }
        }
        
        xmlDoc.appendChild(xmlRoot);

        eventSource.EventWriteFulFillmentProcessEnd(funcName(), true);

        return [true, '', xmlDoc.toString()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFulfillmentNotificationLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets notification counts based on fulfillment lines.
    /// </summary>
    /// <param name = "_channelId">The channel id.</param>
    /// <returns>A container that has list of notification lines for given channel.</returns>
    public static System.Object getFulfillmentNotificationLines(RetailChannelRecId _channelId)
    {
        System.Object result = ReflectionHelper::createInstance(entityAssemblyFileName, entityNamespaceName, notificationDetailCollectionName);
        if (result != null)
        {
            System.Type notificationDetailInfoCollectionType = result.GetType();

            // Get notification lines for Order fulfillment group
            System.Object storePickup = RetailTransactionServiceFulfillment::getStorePickupNotificationDetailInfo(_channelId);
            System.Object shipping = RetailTransactionServiceFulfillment::getShipFromStoreNotificationDetailInfo(_channelId);

            notificationDetailInfoCollectionType.GetMethod(AddMethodName).Invoke(result, storePickup);
            notificationDetailInfoCollectionType.GetMethod(AddMethodName).Invoke(result, shipping);
            
            // Get the notification for all order fulfillment.
            System.Object allOrderFulfilment = ReflectionHelper::createInstance(entityAssemblyFileName, entityNamespaceName, notificationDetailName);
            System.Type notificationDetailType = allOrderFulfilment.GetType();
            notificationDetailType.GetProperty(ActionPropertyElementName).SetValue(allOrderFulfilment, AllOrderActionProperty);
            int totalCount = notificationDetailType.GetProperty(ItemCountElementName).GetValue(storePickup);
            totalCount += notificationDetailType.GetProperty(ItemCountElementName).GetValue(shipping);
            notificationDetailType.GetProperty(ItemCountElementName).SetValue(allOrderFulfilment, totalCount);
            notificationDetailType.GetProperty(IsSuccessElementName).SetValue(allOrderFulfilment, true);
            notificationDetailType.GetProperty(IsLiveContentOnlyElementName).SetValue(allOrderFulfilment, true);
            notificationDetailInfoCollectionType.GetMethod(AddMethodName).Invoke(result, allOrderFulfilment);
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFulfillmentLinesByPackingSlipId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets fulfillment lines associated with the packing slip.
    /// </summary>
    /// <param name = "salesId">Sales Id of the packing slip.</param>
    /// <param name = "packingSlipId">Packing slip Id.</param>
    /// <returns>
    /// A container that has list of fulfillment lines of requested packing slip.
    /// </returns>
    public static container getFulfillmentLinesByPackingSlipId(SalesId salesId, PackingSlipId packingSlipId)
    {
        boolean success = false;
        str errorMessage = '';
        int infologLine;
        XmlDocument resultDoc;

        try
        {
            eventSource.EventWriteFulFillmentProcessStart(funcName());

            infologLine = Global::infologLine();

            // Initialize xml return result
            resultDoc = RetailTransactionServiceUtilities::getXmlDocumentForSerializedEntities();
            XmlElement resultRootElement = resultDoc.createElement(ArrayOfFulfillmentLineParameterElementName);
            resultRootElement.setAttribute('xmlns', RetailTransactionServiceUtilities::getCrtDataModelXmlNamespace());

            eventSource.EventWriteFulfillmentProcessForSalesOrder(funcName(), SalesTable::find(salesId).RecId);

            // Get active fulfillment lines
            CustPackingSlipTrans custPackingSlipTrans;

            while select SalesId, LineNum, Qty from custPackingSlipTrans
                where custPackingSlipTrans.SalesId == salesId
                    && custPackingSlipTrans.PackingSlipId == packingSlipId
                    && custPackingSlipTrans.Qty > 0
            {
                XmlElement fulfillmentElement = resultDoc.createElement(FulfillmentLineParameterElementName);

                RetailTransactionServiceFulfillment::addDecimalElementResult(resultDoc, fulfillmentElement, QuantityProperty, custPackingSlipTrans.Qty);
                RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, SalesIdProperty, custPackingSlipTrans.SalesId);
                RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, SalesLineNumberProperty, RetailTransactionServiceUtilities::lineNumToString(custPackingSlipTrans.LineNum));

                resultRootElement.appendChild(fulfillmentElement);
            }

            resultDoc.appendChild(resultRootElement);
            success = true;

        }
        catch(Exception::Error)
        {
            errorMessage = RetailTransactionServiceUtilities::getInfologMessages(infologLine);
            RetailTracer::Error('RetailTransactionService', funcName(), errorMessage);
        }
        eventSource.EventWriteFulFillmentProcessEnd(funcName(), success);

        return [success, errorMessage, resultDoc.toString()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStorePickupNotificationDetailInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets notification counts based on store pickup fulfillment lines.
    /// </summary>
    /// <param name = "_channelId">The channel id.</param>
    /// <returns>A notification line for store pickup counts.</returns>
    private static System.Object getStorePickupNotificationDetailInfo(RetailChannelRecId _channelId)
    {
        System.Object result = ReflectionHelper::createInstance(entityAssemblyFileName, entityNamespaceName, notificationDetailName);
        System.Type notificationDetailType = result.GetType();
        notificationDetailType.GetProperty(DisplayTextElementName).SetValue(result, 'FULFILLMENT_STOREPICKUP_RESOURCE_ID');
        notificationDetailType.GetProperty(ActionPropertyElementName).SetValue(result, PickOrderActionProperty);

        RetailFulfillmentNotificationView retailFulfillmentNotification;
        RetailDlvModeTmp pickupDeliveryModes = RetailDlvMode::getPickupDeliveryModes();

        // for pickup use store's warehouse
        InventLocation warehouse = RetailStoreTable::findInventLocation(_channelId);

        // Get "Store Pickup" lines statistics
        // count all order lines with the order line status not equal pending,
        // rejected, invoiced, delivery type equal 'Store pickup'and salesline status not equal cancelled
        // include only orders that are not On Hold.

        select count(RecId) from retailFulfillmentNotification
            where retailFulfillmentNotification.FulfillmentStatus != RetailFulfillmentLineStatus::Invoiced
                && retailFulfillmentNotification.FulfillmentStatus != RetailFulfillmentLineStatus::Rejected
                && retailFulfillmentNotification.FulfillmentStatus != RetailFulfillmentLineStatus::Unknown
                && retailFulfillmentNotification.SalesStatus != SalesStatus::Canceled
                && retailFulfillmentNotification.SalesStatus != SalesStatus::Invoiced
                && retailFulfillmentNotification.IsOnHold == NoYes::No
                && retailFulfillmentNotification.WarehouseId == warehouse.InventLocationId
                && retailFulfillmentNotification.SalesLineStatus != SalesStatus::Canceled
            exists join pickupDeliveryModes
                where retailFulfillmentNotification.DlvMode == pickupDeliveryModes.Code;

        if (retailFulfillmentNotification.RecId > 0)
        {
            notificationDetailType.GetProperty(ItemCountElementName).SetValue(result, retailFulfillmentNotification.RecId);

            // Get latest record for notification purposes.
            select firstonly retailFulfillmentNotification
                order by LastModifiedDateTime desc
            where retailFulfillmentNotification.FulfillmentStatus != RetailFulfillmentLineStatus::Invoiced
                && retailFulfillmentNotification.FulfillmentStatus != RetailFulfillmentLineStatus::Rejected
                && retailFulfillmentNotification.FulfillmentStatus != RetailFulfillmentLineStatus::Unknown
                && retailFulfillmentNotification.SalesStatus != SalesStatus::Canceled
                && retailFulfillmentNotification.SalesStatus != SalesStatus::Invoiced
                && retailFulfillmentNotification.IsOnHold == NoYes::No
                && retailFulfillmentNotification.WarehouseId == warehouse.InventLocationId
                && retailFulfillmentNotification.SalesLineStatus != SalesStatus::Canceled
            exists join pickupDeliveryModes
                where retailFulfillmentNotification.DlvMode == pickupDeliveryModes.Code;

            if (retailFulfillmentNotification)
            {
                notificationDetailType.GetProperty(LastUpdatedDateTimeStrElementName).SetValue(result, DateTimeUtil::toStr(retailFulfillmentNotification.CreatedDate));
            }
        }

        notificationDetailType.GetProperty(IsSuccessElementName).SetValue(result, true);

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getShipFromStoreNotificationDetailInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets notification counts based on ship from store fulfillment lines.
    /// </summary>
    /// <param name = "_channelId">The channel id.</param>
    /// <returns>A notification line for ship from store counts.</returns>
    private static System.Object getShipFromStoreNotificationDetailInfo(RetailChannelRecId _channelId)
    {
        System.Object result = ReflectionHelper::createInstance(entityAssemblyFileName, entityNamespaceName, notificationDetailName);
        System.Type notificationDetailType = result.GetType();
        notificationDetailType.GetProperty(DisplayTextElementName).SetValue(result, 'FULFILLMENT_SHIPFROMSTORE_RESOURCE_ID');
        notificationDetailType.GetProperty(ActionPropertyElementName).SetValue(result, ShipOrderActionProperty);

        RetailFulfillmentNotificationView retailFulfillmentNotification;
        RetailDlvModeTmp pickupDeliveryModes = RetailDlvMode::getPickupDeliveryModes();

        RetailParameters retailParamsTable;
        DlvModeId carryOutDlvModeCode, electronicDlvModeCode;
        select CarryOutDeliveryModeCode, ElectronicDeliveryModeCode from retailParamsTable;

        if (retailParamsTable)
        {
            carryOutDlvModeCode = retailParamsTable.CarryOutDeliveryModeCode;
            electronicDlvModeCode = retailParamsTable.ElectronicDeliveryModeCode;
        }

        InventLocation warehouse = RetailStoreTable::findInventLocation(_channelId);

        // count all order lines with the order line status not equal pending,
        // rejected, invoiced, delivery type equal to 'Ship from store' and salesline status not equal cancelled
        select count(RecId) from retailFulfillmentNotification
            where retailFulfillmentNotification.DlvMode != carryOutDlvModeCode
                && retailFulfillmentNotification.DlvMode != electronicDlvModeCode
                && retailFulfillmentNotification.FulfillmentStatus != RetailFulfillmentLineStatus::Invoiced
                && retailFulfillmentNotification.FulfillmentStatus != RetailFulfillmentLineStatus::Pending
                && retailFulfillmentNotification.FulfillmentStatus != RetailFulfillmentLineStatus::Rejected
                && retailFulfillmentNotification.FulfillmentStatus != RetailFulfillmentLineStatus::Unknown
                && retailFulfillmentNotification.SalesStatus != SalesStatus::Canceled
                && retailFulfillmentNotification.SalesStatus != SalesStatus::Invoiced
                && retailFulfillmentNotification.IsOnHold == NoYes::No
                && retailFulfillmentNotification.WarehouseId == warehouse.InventLocationId
                && retailFulfillmentNotification.SalesLineStatus != SalesStatus::Canceled
             notexists join pickupDeliveryModes
                where retailFulfillmentNotification.DlvMode == pickupDeliveryModes.Code;


        if (retailFulfillmentNotification.RecId > 0)
        {
            notificationDetailType.GetProperty(ItemCountElementName).SetValue(result, retailFulfillmentNotification.RecId);

            select firstonly retailFulfillmentNotification
                order by LastModifiedDateTime desc
                where retailFulfillmentNotification.DlvMode != carryOutDlvModeCode
                    && retailFulfillmentNotification.DlvMode != electronicDlvModeCode
                    && retailFulfillmentNotification.FulfillmentStatus != RetailFulfillmentLineStatus::Invoiced
                    && retailFulfillmentNotification.FulfillmentStatus != RetailFulfillmentLineStatus::Pending
                    && retailFulfillmentNotification.FulfillmentStatus != RetailFulfillmentLineStatus::Rejected
                    && retailFulfillmentNotification.FulfillmentStatus != RetailFulfillmentLineStatus::Unknown
                    && retailFulfillmentNotification.SalesStatus != SalesStatus::Canceled
                    && retailFulfillmentNotification.SalesStatus != SalesStatus::Invoiced
                    && retailFulfillmentNotification.IsOnHold == NoYes::No
                    && retailFulfillmentNotification.WarehouseId == warehouse.InventLocationId
                    && retailFulfillmentNotification.SalesLineStatus != SalesStatus::Canceled
                notexists join pickupDeliveryModes
                    where retailFulfillmentNotification.DlvMode == pickupDeliveryModes.Code;

            if (retailFulfillmentNotification)
            {
                notificationDetailType.GetProperty(LastUpdatedDateTimeStrElementName).SetValue(result, DateTimeUtil::toStr(retailFulfillmentNotification.CreatedDate));
            }
        }

        notificationDetailType.GetProperty(IsSuccessElementName).SetValue(result, true);

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>MarkAsPicked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the status of the fulfillment lines to Picked.
    /// </summary>
    /// <param name="_fulfillmentXmlString">
    /// XML string containing the fulfillment lines.
    /// </param>
    /// <returns>
    /// A <c>Container</c> containing result info.
    /// </returns>
    /// <remarks>
    /// Container structure by positions:
    /// 1 - operation status (true means operation succeeded; false - an application error occured),
    /// 2 - error message (optional)
    /// </remarks>
    public static container MarkAsPicked(str _fulfillmentXmlString)
    {
        boolean success = true;
        str error = '';

        SalesLine salesLine;
        RetailSalesLine retailSalesLine;
        int infologLine = Global::infologLine();

        try
        {
            eventSource.EventWriteFulFillmentProcessStart(funcName());

            // Load the assembly and CRT-defined types using reflection
            System.Reflection.Assembly transactionServiceAssembly = System.Reflection.Assembly::Load(TransactionServiceAssemblyName);
            System.Type fulfillmentInfoType = transactionServiceAssembly == null ? null : transactionServiceAssembly.GetType(FulfillmentInfoName);
            System.Type FulfillmentLineInfoCollectionType = transactionServiceAssembly == null ? null : transactionServiceAssembly.GetType(FulfillmentLineInfoCollectionName);
            System.Type fulfillmentLineInfoType = transactionServiceAssembly == null ? null : transactionServiceAssembly.GetType(FulfillmentLineInfoName);
            System.Reflection.MethodInfo fromXmlMethod = fulfillmentInfoType == null ? null : fulfillmentInfoType.GetMethod(FromXmlMethodName);

            if (fromXmlMethod != null)
            {
                // Deserialize the xml string input
                System.Object[] parameters = new System.Object[1]();
                parameters.SetValue(_fulfillmentXmlString, 0);
                var fulfillmentInfo = fromXmlMethod.Invoke(System.Activator::CreateInstance(fulfillmentInfoType), parameters);

                // Iterate through the collection of sales lines
                System.Collections.ICollection fulfillmentLines = fulfillmentInfoType.GetProperty(FulfillmentLinesProperty).GetValue(fulfillmentInfo) as System.Collections.ICollection;
                System.Collections.IEnumerator fulfillmentLineEnumerator = fulfillmentLines.GetEnumerator();
                while (fulfillmentLineEnumerator.MoveNext())
                {
                    var fulfillmentLine = fulfillmentLineEnumerator.Current;
                    real salesLineNumber = fulfillmentLineInfoType.GetProperty(SalesLineNumberProperty).GetValue(fulfillmentLine);
                    real quantity = fulfillmentLineInfoType.GetProperty(QuantityProperty).GetValue(fulfillmentLine);
                    str salesId = fulfillmentLineInfoType.GetProperty(SalesIdProperty).GetValue(fulfillmentLine);

                    eventSource.EventWriteFulfillmentProcessForSalesOrder(funcName(), SalesTable::find(salesId).RecId);

                    select salesLine
                        join FulfillmentStatus, QuantityInvoiced, QuantityPacked, QuantityPicked from retailSalesLine
                        where retailSalesLine.SalesLine == salesLine.RecId && salesLine.SalesId == salesId && salesLine.LineNum == salesLineNumber;

                    if (salesLine && retailSalesLine)
                    {
                        if (retailSalesLine.FulfillmentStatus == RetailFulfillmentLineStatus::Unknown ||
                            retailSalesLine.FulfillmentStatus == RetailFulfillmentLineStatus::Pending)
                        {
                            success = false;
                            error = "@Retail:CannotProcessLinesOfPendingOrUnknown"; // Cannot process a line which is in Pending or Unknown status.
                        }
                        else if (retailSalesLine.FulfillmentStatus == RetailFulfillmentLineStatus::Invoiced
                            || retailSalesLine.FulfillmentStatus == RetailFulfillmentLineStatus::Packed
                            || retailSalesLine.FulfillmentStatus == RetailFulfillmentLineStatus::Picked)
                        {
                            success = false;
                            error = "@Retail:CannotMarkProcessedLineAsPicked"; // The sales line has already been processed (Picked, Packed, or invoiced).
                        }
                        else
                        {
                            if (RetailOrdersFeatureControl::useQtyInInventoryUOMForFulfillment())
                            {
                                quantity = salesLine.unitConvertSales2Invent(quantity);
                            }
                            

                            if (quantity > salesLine.QtyOrdered - retailSalesLine.QuantityInvoiced - retailSalesLine.QuantityPacked - retailSalesLine.QuantityPicked)
                            {
                                success = false;
                                error = "@Retail:CannotPickMoreThanRemainingQuantityToInvoice"; // Cannot mark more items as picked than remaining quantity to invoice.
                            }
                            else
                            {
                                str updateSerialIdError = '';
                                if (RetailOrderSerialNumberValidationFeatureExposure::isEnabled())
                                {
                                    str serialId = fulfillmentLineInfoType.GetProperty(SerialNumberProperty).GetValue(fulfillmentLine);
                                    updateSerialIdError = RetailTransactionServiceFulfillment::updateSerialId(salesLine, retailSalesLine, serialId);
                                }

                                if (updateSerialIdError != '')
                                {
                                    error = updateSerialIdError;
                                }
                                else
                                {
                                    // Update WHS location in case it hasn't been set.
                                    RetailTransactionServiceFulfillment::setWHSLocationToDefaultIfEmpty(salesLine);

                                    error = RetailTransactionServiceFulfillment::MarkAsPickedInternal(salesId, salesLineNumber, quantity);
                                }

                                if (error != '')
                                {
                                    success = false;
                                }
                            }
                        }
                    }
                    else
                    {
                        success = false;
                        error = "@Retail:FulfillmentLineCannotBeFound"; // Updating the fulfillment status failed because the fulfillment line can't be found.
                    }
                }
            }
            else
            {
                error = "@Retail:CrtVersionMismatch"; // The server doesn't support this operation.
                success = false;
            }
        }
        catch (Exception::CLRError)
        {
            success = false;
            System.Exception ex;
            ex = CLRInterop::getLastException();
            if (ex && ex.InnerException)
            {
                if (ex.InnerException.InnerException)
                {
                    // Use inner exception if it is available as it is often more descriptive.
                    error = ex.InnerException.InnerException.Message;
                }
                else
                {
                    error = ex.InnerException.Message;
                }
            }
        }
        catch
        {
            error = strFmt('@Retail:MarkFulfillmentLinesAsPickedErrorDetail', RetailTransactionServiceUtilities::getInfologMessages(infologLine));
            success = false;
        }

        eventSource.EventWriteFulFillmentProcessEnd(funcName(), success);

        return [success, error, ''];
    }

]]></Source>
			</Method>
			<Method>
				<Name>InventUpd_Picked_Post_updateNow</Name>
				<Source><![CDATA[
    /// <summary>
    /// The event handler to update retail fulfillment status and quantities for picking.
    /// </summary>
    /// <param name="args">The arguments for this event handler.</param>
    [PostHandlerFor(classStr(InventUpd_Picked), methodStr(InventUpd_Picked, updateNow))]
    public static void InventUpd_Picked_Post_updateNow(XppPrePostArgs args)
    {
        InventUpd_Picked inventPicked = args.getThis();
        InventMovement inventMovement = inventPicked.movement().parentMovement();
        if (inventMovement.isRetailSalesOrder())
        {
            Common buffer = inventMovement.buffer();
            RetailTransactionServiceFulfillment::updateFulfillmentStatus(buffer.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>InventUpd_Reservation_Post_updateNow</Name>
				<Source><![CDATA[
    /// <summary>
    /// The event handler to update retail fulfillment status and quantities for reserving.
    /// </summary>
    /// <param name="args">The arguments for this event handler.</param>
    [PostHandlerFor(classStr(InventUpd_Reservation), methodStr(InventUpd_Reservation, updateNow))]
    internal static void InventUpd_Reservation_Post_updateNow(XppPrePostArgs args)
    {
        InventUpd_Reservation inventUpdReservation = args.getThis();
        InventMovement inventMovement = inventUpdReservation.movement();

        if (!(inventMovement is InventMov_Sales))
        {
            return;
        }

        SalesLine salesLine = inventMovement.buffer() as SalesLine;

        if (salesLine && inventMovement.isRetailSalesOrder())
        {
            RetailTransactionServiceFulfillment::updateOnOrderAndReservedQuantities(salesLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>InventUpd_Estimate_Post_updateNow</Name>
				<Source><![CDATA[
    /// <summary>
    /// The event handler to update retail fulfillment status and quantities for on order.
    /// </summary>
    /// <param name="args">The arguments for this event handler.</param>
    [PostHandlerFor(classStr(InventUpd_Estimated), methodStr(InventUpd_Estimated, updateNow))]
    internal static void InventUpd_Estimate_Post_updateNow(XppPrePostArgs args)
    {
        InventUpd_Estimated inventUpdReservation = args.getThis();
        InventMovement inventMovement = inventUpdReservation.movement();

        if (!(inventMovement is InventMov_Sales))
        {
            return;
        }

        SalesLine salesLine = inventMovement.buffer() as SalesLine;

        if (salesLine && inventMovement.isRetailSalesOrder())
        {
            RetailTransactionServiceFulfillment::updateOnOrderAndReservedQuantities(salesLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFulfillmentStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the picked, packed and invoiced quantity of this retail sales line,
    /// and then update the fulfillment status according to these quantities.
    /// </summary>
    /// <param name = "limitStatusTypes">The string to limit the status when querying inventory transaction records.</param>
    /// <returns>True if update the records successfully; Otherwise false.</returns>
    /// <remarks>
    /// When calling from Invoice operations, the status could be changed to Invoiced/PartiallyInvoiced,
    /// and all QuantityInvoiced, QuantityPacked, QuantityPicked could be potentially changed.
    /// When calling from Packing operations, the status could be changed to Packed/PartiallyPacked/Accepted,
    /// and both QuantityPacked, QuantityPicked could be potentially changed.
    /// When calling from Picking operations, the status could be changed to Picked/PartiallyPicked/Accepted,
    /// and only QuantityPicked could be potentially changed.
    /// </remarks>
    public static boolean updateFulfillmentStatus(SalesLineRefRecId salesLineRecId)
    {
        if (salesLineRecId == 0)
        {
            return false;
        }

        SalesLine salesLine = SalesLine::findRecId(salesLineRecId);

        if (!salesLine.isStocked())
        {
            return RetailTransactionServiceFulfillment::updateFulfillmentStatusForNonStockedItems(salesLineRecId);
        }
        else
        {
            return RetailTransactionServiceFulfillment::updateFulfillmentStatusForStockedItems(salesLineRecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFulfillmentStatusForStockedItems</Name>
				<Source><![CDATA[
    private static boolean updateFulfillmentStatusForStockedItems(SalesLineRefRecId _salesLineRecId)
    {
        int retryCount = 1;
        eventSource.EventWriteFulfillmentProcessForSalesLine(funcName(), _salesLineRecId);

        try
        {
            SalesLine salesLine;
            RetailSalesLine retailSalesLine;
            InventTransOrigin inventTransOrigin;
                        
            select firstonly forupdate retailSalesLine
            join salesLine
                where salesLine.RecId == retailSalesLine.SalesLine && salesLine.RecId == _salesLineRecId
            join RecId from inventTransOrigin
                where inventTransOrigin.InventTransId == salesLine.InventTransId;
            
            if (retailSalesLine.RecId == 0 || inventTransOrigin.RecId == 0 || 
                (!SalesTable::find(salesLine.SalesId).isRetailSale() 
                && RetailFulfillmentUpdateFulfillmentStatusOnlyForRetailOrdersFlight::instance().isEnabled()))
            {
                return false;
            }
            else if (salesLine.QtyOrdered < 0)
            {
                // This is sales line for return. In retail scenario, this line is either Invoiced or Partially Invoiced, based on the quantity.
                retailSalesLine.QuantityInvoiced = -1 * salesLine.QtyOrdered;
                retailSalesLine.QuantityPicked = 0;
                retailSalesLine.QuantityPacked = 0;
            
                if (salesLine.SalesQty == salesLine.invoicedInTotal())
                {
                    retailSalesLine.FulfillmentStatus = RetailFulfillmentLineStatus::Invoiced;
                }
                else
                {
                    retailSalesLine.FulfillmentStatus = RetailFulfillmentLineStatus::PartiallyInvoiced;
                }
            }
            else
            {
                InventTrans inventTrans;
                Qty newQtyPicked = 0;
                Qty newQtyPacked = 0;
                Qty newQtyInvoiced = 0;
                Qty newQtyOnOrder = 0;
                Qty newQtyReservPhysical = 0;
                while select StatusIssue, StatusReceipt, Qty from inventTrans
                where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                && (inventTrans.StatusIssue == StatusIssue::None
                || inventTrans.StatusIssue == StatusIssue::Deducted
                || inventTrans.StatusIssue == StatusIssue::Sold
                || inventTrans.StatusIssue == StatusIssue::OnOrder
                || inventTrans.StatusIssue == StatusIssue::ReservPhysical
                || inventTrans.StatusIssue == StatusIssue::Picked)
                {
                    if (inventTrans.StatusIssue == StatusIssue::Picked)
                    {
                        newQtyPicked -= inventTrans.Qty;
                    }
                    else if (inventTrans.StatusIssue == StatusIssue::Deducted)
                    {
                        newQtyPacked -= inventTrans.Qty;
                    }
                    else if (inventTrans.StatusIssue == StatusIssue::OnOrder)
                    {
                        newQtyOnOrder -= inventTrans.Qty;
                    }
                    else if (inventTrans.StatusIssue == StatusIssue::ReservPhysical)
                    {
                        newQtyReservPhysical -= inventTrans.Qty;
                    }
                    else if ((inventTrans.StatusIssue == StatusIssue::Sold && inventTrans.StatusReceipt == StatusReceipt::None)
                        || (inventTrans.StatusIssue == StatusIssue::None && inventTrans.StatusReceipt == StatusReceipt::Purchased)) // Need to account for correction and/or cancellation of packing slips.
                    {
                        newQtyInvoiced -= inventTrans.Qty;
                    }
                }
            
                retailSalesLine.QuantityPicked = newQtyPicked;
                retailSalesLine.QuantityPacked = newQtyPacked;
                retailSalesLine.QuantityInvoiced = newQtyInvoiced;
                retailSalesLine.QuantityNotProcessed = newQtyOnOrder;
                retailSalesLine.QuantityPhysicallyReserved = newQtyReservPhysical;
                retailSalesLine.QuantityColumnsVersion = RetailSalesLineQuantityColumnsVersion::V1;

                if (RetailUpdateFulfillmentStatusFlightV2::instance().isEnabled())
                {
                    retailSalesLine.FulfillmentStatus = RetailTransactionServiceFulfillment::getFulfillmentStatusV2(salesLine, retailSalesLine, false);
                }
                else
                {
                    retailSalesLine.FulfillmentStatus = RetailTransactionServiceFulfillment::getFulfillmentStatus(
                        retailSalesLine.QuantityPicked,
                        retailSalesLine.QuantityPacked,
                        retailSalesLine.QuantityInvoiced,
                        salesLine.QtyOrdered);
                }
            }
            
            ttsbegin;
            retailSalesLine.update();
            ttscommit;
            
            return true;
        }
        catch (Exception::UpdateConflict)
        {
            if (retryCount <= 5)
            {
                eventSource.EventWriteUpdateFulfillmentStatusForStockedItemsRetry(_salesLineRecId, retryCount);
                retryCount++;
                retry;
            }
            else
            {
                eventSource.EventWriteUpdateFulfillmentStatusForStockedItemsMaxRetries(_salesLineRecId);
                throw Exception::UpdateConflictNotRecovered;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFulfillmentStatusForNonStockedItems</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the fulfillment status of retail sales line.
    /// </summary>
    /// <param name = "_salesLineRecId">The created sales line.</param>
    /// <returns>True if update the records successfully; Otherwise false.</returns>
    private static boolean updateFulfillmentStatusForNonStockedItems(SalesLineRefRecId _salesLineRecId)
    {
        boolean ret;

        eventSource.EventWriteFulfillmentProcessForSalesLine(funcName(), _salesLineRecId);

        SalesLine salesline = SalesLine::findRecId(_salesLineRecId);
        RetailSalesLine retailSalesLine = salesLine.RetailSalesLine();

        if (retailSalesLine.RecId)
        {
            ttsbegin;
            retailSalesLine.selectForUpdate(true);

            SalesQty invoicedQty = salesLine.invoicedInTotal();
            if (salesline.SalesQty && (salesline.SalesQty == invoicedQty))
            {
                retailSalesLine.FulfillmentStatus = RetailFulfillmentLineStatus::Invoiced;
                retailSalesLine.update();
            }
            else if (invoicedQty)
            {
                retailSalesLine.FulfillmentStatus = RetailFulfillmentLineStatus::PartiallyInvoiced;
                retailSalesLine.update();
            }
            ttscommit;

            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOnOrderAndReservedQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Given a sales line (and optionally its corresponding retail sales line),
    /// update the fields storing QuantityNotProcessed and QuantityPhysicallyReserved on the retail sales line.
    /// Note: the retail sales line parameter is optional, but if provided it must be the retail sales line corresponding to the sales line.
    /// </summary>
    /// <param name = "_salesLine">The sales line to use as a basis for the update.</param>
    /// <param name = "_retailSalesLine">The (optional) retail sales line associated with the sales line.</param>
    private static void updateOnOrderAndReservedQuantities(SalesLine _salesLine, RetailSalesLine _retailSalesLine = null)
    {
        InventTransOriginId inventTransOriginId = InventTransOriginSalesLine::findInventTransOriginId(_salesLine.DataAreaId, _salesLine.InventTransId);
        InventTransIdSum inventTransIdSum = InventTransIdSum::newTransIdNoChildType(inventTransOriginId);

        if (_retailSalesLine.SalesLine && _salesLine && _retailSalesLine.SalesLine != _salesLine.RecId)
        {
            // This indicates a bug in the calling code -- there are no steps a user can take to correct this.
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (!_retailSalesLine.SalesLine)
        {
            _retailSalesLine = RetailSalesLine::findBySalesLine(_salesLine.RecId, true);

            if (!_retailSalesLine.SalesLine)
            {
                // It's possible the sales line is being created and has no RetailSalesLine yet.
                return;
            }
        }

        _retailSalesLine.QuantityNotProcessed = abs(inventTransIdSum.onOrder());
        _retailSalesLine.QuantityPhysicallyReserved = abs(inventTransIdSum.reservPhysical());
        _retailSalesLine.QuantityColumnsVersion = RetailSalesLineQuantityColumnsVersion::V1;

        if (_retailSalesLine)
        {
            ttsbegin;
            _retailSalesLine.selectForUpdate(true);
            _retailSalesLine.update();
            _salesLine.retailPackRetailSalesLine(_retailSalesLine);
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOrderTotalAmountsCalculationDisabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides chain of command extensibility point for partners to associate any
    /// additional information they may need with the sales order Id.
    /// </summary>
    /// <param name= "_salesId">Sales order Id.</param>
    /// <returns>Returns <c>fasle</c> if completed successfully; otherwise, <c>true</c>.</returns>
    [Replaceable]
    protected static boolean isOrderTotalAmountsCalculationDisabled(SalesId _salesId)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFulfillmentStatus</Name>
				<Source><![CDATA[
    private static RetailFulfillmentLineStatus getFulfillmentStatus(InventQty pickedQty, InventQty packedQty, InventQty invoicedQty, InventQty orderedQty)
    {
        if (invoicedQty == orderedQty)
        {
            return RetailFulfillmentLineStatus::Invoiced;
        }
        else if (invoicedQty > 0)
        {
            return RetailFulfillmentLineStatus::PartiallyInvoiced;
        }
        else if (packedQty == orderedQty)
        {
            return RetailFulfillmentLineStatus::Packed;
        }
        else if (packedQty > 0)
        {
            return RetailFulfillmentLineStatus::PartiallyPacked;
        }
        else if (pickedQty == orderedQty)
        {
            return RetailFulfillmentLineStatus::Picked;
        }
        else if (pickedQty > 0)
        {
            return RetailFulfillmentLineStatus::PartiallyPicked;
        }
        else
        {
            // There are three situations where we could get zeor records marked as Picked, Deducted or Sold from InventTrans table:
            // 1. Create a new sales line.
            // 2. Unpick a line.
            // 3. Unpack a line.
            // Only the first situation will potentially requires us to mark the status as pending,
            // the other two situations will always ask us to mark the status as Accepted. This is
            // because if you are able to unpick/unpack a line, then the line must have already been
            // accepted before. But the first situation will not hit this logic, so we always mark the
            // status as Accepted here.
            return RetailFulfillmentLineStatus::Accepted;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFulfillmentStatusV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is invoked by updateFulfillmentStatus() and updateFulfillmentStatusFromEditSalesLine().
    /// updateFulfillmentStatus() is called during pick/unpick/pack/unpack/invoice operations.
    /// During these operations, the line must have already been accepted, so there is no need to checkManualAccept.
    /// updateFulfillmentStatusFromEditSalesLine() is called when a sales line is edited.
    /// It is possible that the sales line is still pending, so the checkManualAccept should be performed.
    /// </summary>
    /// <param name = "_salesLine">SalesLine.</param>
    /// <param name = "_retailSalesLine">RetailSalesLine.</param>
    /// <param name="_checkManualAccept">A flag indicating whether to check the ManualAccept flag.</param>
    /// <returns>Fulfillment status.</returns>
    private static RetailFulfillmentLineStatus getFulfillmentStatusV2(SalesLine _salesLine, RetailSalesLine _retailSalesLine, boolean _checkManualAccept)
    {
        boolean hasQtyInvoiced = _retailSalesLine.QuantityInvoiced > 0;
        boolean hasQtyPacked = _retailSalesLine.QuantityPacked > 0;
        boolean hasQtyPicked = _retailSalesLine.QuantityPicked > 0;
        boolean hasQtyReservedOrNotProcessed = (_retailSalesLine.QuantityNotProcessed + _retailSalesLine.QuantityPhysicallyReserved + _salesLine.reservedOnOrder()) > 0;

        if (hasQtyInvoiced)
        {
            if (hasQtyPacked || hasQtyPicked || hasQtyReservedOrNotProcessed)
           {
               return RetailFulfillmentLineStatus::PartiallyInvoiced;
           }
           else
           {
               return RetailFulfillmentLineStatus::Invoiced;
           }
        }
        else if (hasQtyPacked)
        {
            if (hasQtyPicked || hasQtyReservedOrNotProcessed)
            {
                return RetailFulfillmentLineStatus::PartiallyPacked;
            }
            else
            {
                return RetailFulfillmentLineStatus::Packed;
            }
        }
        else if (hasQtyPicked)
        {
            if (hasQtyReservedOrNotProcessed)
            {
                return RetailFulfillmentLineStatus::PartiallyPicked;
            }
            else
            {
                return RetailFulfillmentLineStatus::Picked;
            }
        }

        if (_checkManualAccept)
        {
            return RetailTransactionServiceFulfillment::getUpdatedOpenOrderFulfillmentStatus(_retailSalesLine);
        }

        return RetailFulfillmentLineStatus::Accepted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>MarkAsPickedInternal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Mark a sales line as picked.
    /// </summary>
    /// <param name = "_salesId">The sales identifier of this sales line.</param>
    /// <param name = "_salesLineNumber">The sales line number of this sales line.</param>
    /// <param name = "_qtyPicked">The quantity of the items picked.</param>
    private static str MarkAsPickedInternal(SalesId _salesId, LineNum _salesLineNumber, InventQty _qtyPicked)
    {
        InventTransWMS_Pick inventTransWMS_Pick;
        SalesLine salesLine;
        RetailSalesLine retailSalesLine;
        InventTrans inventTrans;
        InventTransOrigin inventTransOrigin;
        TmpInventTransWMS tmpInventTransWMS;
        Query query;
        
        str error = '';

        // Update the InventTrans first.
        RetailTransactionServiceFulfillment::locateSalesLineAndInventTrans(_salesId, _salesLineNumber, salesLine, inventTrans);
        
        if (inventTrans)
        {
            query = RetailTransactionServiceFulFillment::initInventTransQuery(salesLine);
            inventTransWMS_Pick = InventTransWMS_Pick::newStandard(tmpInventTransWMS, query);

            // Quantity needs to be negative in AX.
            inventTrans.Qty = 0 - _qtyPicked;
            inventTransWMS_Pick.createFromInventTrans(inventTrans);
            boolean updateSuccessful = inventTransWMS_Pick.updateInvent();

            if (!updateSuccessful)
            {
                error = "@Retail:PickFulfillmentLinesFailed"; // An error occurred when marking fulfillment lines as picked.
            }
        }
        else
        {
            error = "@Retail:InventTransRecordNotFound"; // Failed to find a record in InventTrans table to update.
            return error;
        }

        return error;
    }

]]></Source>
			</Method>
			<Method>
				<Name>locateSalesLineAndInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Locates the record to update in InventTrans table.
    /// </summary>
    /// <param name = "salesId">The sales identifier of the sales line.</param>
    /// <param name = "salesLineNumber">The sales line number.</param>
    /// <param name = "salesLine">The SalesLine table.</param>
    /// <param name = "inventTrans">The InventTrans table.</param>
    private static void locateSalesLineAndInventTrans(SalesId salesId, LineNum salesLineNumber, SalesLine salesLine, InventTrans inventTrans)
    {
        InventTransOrigin inventTransOrigin;

        select *
            from inventTrans
            join RecId from inventTransOrigin where inventTransOrigin.RecId == inventTrans.InventTransOrigin && InventTrans.StatusIssue == StatusIssue::ReservPhysical
            join * from salesLine where salesLine.InventTransId == inventTransOrigin.InventTransId && salesLine.SalesId == salesId && salesLine.LineNum == salesLineNumber;

        if (!inventTrans)
        {
            select *
            from inventTrans
            join RecId from inventTransOrigin where inventTransOrigin.RecId == inventTrans.InventTransOrigin && InventTrans.StatusIssue == StatusIssue::ReservOrdered
            join * from salesLine where salesLine.InventTransId == inventTransOrigin.InventTransId && salesLine.SalesId == salesId && salesLine.LineNum == salesLineNumber;
        }
        
        if (!inventTrans)
        {
            select *
            from inventTrans
            join RecId from inventTransOrigin where inventTransOrigin.RecId == inventTrans.InventTransOrigin && InventTrans.StatusIssue == StatusIssue::OnOrder
            join * from salesLine where salesLine.InventTransId == inventTransOrigin.InventTransId && salesLine.SalesId == salesId && salesLine.LineNum == salesLineNumber;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventTransQuery</Name>
				<Source><![CDATA[
    private static Query initInventTransQuery(SalesLine salesLine)
    {
        Query                   query;
        InventDimParm           inventDimParmActive;
        InventMovement          inventMovement;
        QueryBuildDataSource    qbdsInventTrans;
        InventTransOriginId     inventTransOriginId;

        query = new Query();
        qbdsInventTrans = query.addDataSource(tableNum(InventTrans));
        qbdsInventTrans.clearDynalinks();
        qbdsInventTrans.clearRanges();

        qbdsInventTrans.addRange(fieldNum(InventTrans,StatusReceipt)).value(SysQuery::value(StatusReceipt::None));
        qbdsInventTrans.addRange(fieldNum(InventTrans,StatusIssue)).value(SysQuery::range(StatusIssue::Picked,StatusIssue::OnOrder));

        inventMovement      = InventTransWMS_Pick::inventMovement(salesLine);
        inventTransOriginId = inventMovement.inventTransOriginId();

        RetailTransactionServiceFulfillment::setInventTransOriginQueryRange(qbdsInventTrans, salesLine, inventMovement, inventTransOriginId);

        //superset of all active dimensions on all loaded movements
        inventMovement.inventDimGroupSetup().inventDimParmActive(inventDimParmActive);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventTransOriginQueryRange</Name>
				<Source><![CDATA[
    private static void setInventTransOriginQueryRange(
            QueryBuildDataSource _qbdsInventTrans,
            Common               _callerTable,
            InventMovement       _inventMovement,
            InventTransOriginId  _inventTransOriginId = _inventMovement ? _inventMovement.inventTransOriginId() : 0)
    {
        QueryBuildRange         qbRange;
        InventTransChildType    inventTransChildType;
        InventTransChildRefId   inventTransChildRefId;
        str                     rangeStr;
        int                     inventTransChildTypeInt;

        if (_qbdsInventTrans)
        {
            if (_inventMovement)
            {
                if (_inventMovement.transChildType())
                {
                    inventTransChildType  = _inventMovement.transChildType();
                    inventTransChildRefId = _inventMovement.transChildRefId();
                }
                else
                {
                    inventTransChildType  = InventTransChildType::None;
                    inventTransChildRefId = '';
                }
            }

            inventTransChildTypeInt = enum2int(inventTransChildType); // Avoid query problems with special characters in enum label.
            //range over all loaded movements
            qbRange = _qbdsInventTrans.addRange(fieldNum(InventTrans,InventTransOrigin));
            rangeStr = strFmt('((%1.%2 == %3) && (%4.%5 == %6)',
                                     _qbdsInventTrans.name(),
                                     fieldStr(InventTrans,InventTransOrigin),
                                     queryValue(_inventTransOriginId),
                                     _qbdsInventTrans.name(),
                                     fieldStr(InventTrans,TransChildType),
                                     inventTransChildTypeInt);

            if (inventTransChildRefId)
            {
                rangeStr = rangeStr + strFmt(' && (%1.%2 == \"%3\"))',
                                     _qbdsInventTrans.name(),
                                     fieldStr(InventTrans,TransChildRefId),
                                     queryValue(inventTransChildRefId));
            }
            else
            {
                // To avoid 2 times double quotes for the childRefId.
                rangeStr = rangeStr + strFmt(' && (%1.%2 == \"\"))',
                                     _qbdsInventTrans.name(),
                                     fieldStr(InventTrans,TransChildRefId));
            }
            qbRange.value(rangeStr);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getArg</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the string value of an xml element argument.
    /// </summary>
    /// <param name = "_searchCriteriaXmlRoot">The root element of the search criteria</param>
    /// <param name = "_elementName">The element name.</param>
    /// <returns>The inner text of the xml element.</returns>
    private static str getArg(XmlElement _searchCriteriaXmlRoot, str _elementName)
    {
        str result = '';
        XmlElement xmlRoot = _searchCriteriaXmlRoot.getNamedElement(_elementName);

        // Get the text when element exists.
        if (xmlRoot != null)
        {
            result = xmlRoot.text();
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addQueryRangeStr</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add a parameter value string on the query range.
    /// </summary>
    /// <param name = "_qbds">The query build data source.</param>
    /// <param name = "_parameterValue">The parameter value.</param>
    /// <param name = "_fieldId">The field identifier.</param>
    private static void addQueryRangeStr(QueryBuildDataSource _qbds, str _parameterValue, FieldId _fieldId)
    {
        // Add range when parameter value is not empty.
        _parameterValue = strRTrim(strLTrim(_parameterValue));

        if (_parameterValue)
        {
            _qbds.addRange(_fieldId).value(_parameterValue);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addQueryRangeDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add a parameter value type date on the query range.
    /// </summary>
    /// <param name = "_qbds">The query build data source.</param>
    /// <param name = "_startDateStr">The starting date filter value.</param>
    /// <param name= "_endDateStr">The ending date filter value.</param>
    /// <param name = "_fieldId">The field identifier.</param>
    private static void addQueryRangeDate(QueryBuildDataSource _qbds, str _startDateStr, str _endDateStr, FieldId _fieldId)
    {
        if (!_startDateStr && !_endDateStr)
        {
            return;
        }

        utcDateTime startDateTime = DateTimeUtil::minValue();
        utcdatetime endDateTime = DateTimeUtil::maxValue();

        if (_startDateStr)
        {
            startDateTime = DateTimeUtil::parse(_startDateStr);
        }

        if (_endDateStr)
        {
            endDateTime = DateTimeUtil::parse(_endDateStr);
        }

        _qbds.addRange(_fieldId).value(SysQuery::range(startDateTime, endDateTime));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addQuerySortColumn</Name>
				<Source><![CDATA[
    private static void addQuerySortColumn(QueryBuildDataSource _qbds, XMLDocument _searchCriteriaXML, RetailGetFulfillmentLinesVersion _methodVersion)
    {
        FieldId salesIdFieldNum = _methodVersion == RetailGetFulfillmentLinesVersion::V1 ? fieldNum(RetailFulfillmentLineView, SalesId)
            : fieldNum(RetailFulfillmentLineViewV2, SalesId);
        FieldId customerNameFieldNum = _methodVersion == RetailGetFulfillmentLinesVersion::V1 ? fieldNum(RetailFulfillmentLineView, CustomerName)
            : fieldNum(RetailFulfillmentLineViewV2, CustomerName);
        FieldId deliveryDateFieldNum = _methodVersion == RetailGetFulfillmentLinesVersion::V1 ? fieldNum(RetailFulfillmentLineView, RequestedDeliveryDate)
            : fieldNum(RetailFulfillmentLineViewV2, RequestedDeliveryDate);
        FieldId pickupStartTimeFieldNum = _methodVersion == RetailGetFulfillmentLinesVersion::V1 ? fieldNum(RetailFulfillmentLineView, PickupStartTime)
            : fieldNum(RetailFulfillmentLineViewV2, PickupStartTime);
        FieldId fulfillmentStatusFieldNum = _methodVersion == RetailGetFulfillmentLinesVersion::V1 ? fieldNum(RetailFulfillmentLineView, FulfillmentStatus)
            : fieldNum(RetailFulfillmentLineViewV2, FulfillmentStatus);

        str columnName;
        SortOrder sortOrder;
        XmlElement sortColumnsNode = _searchCriteriaXML.documentElement().getNamedElement('SortColumn');
        [columnName, sortOrder] = RetailTransactionServiceUtilities::parseSortColumn(sortColumnsNode);
            
        if (columnName != '')
        {
            // Sort the results by column name with proper sort order.
            switch (columnName)
            {
                case OrderNumberSortColumnName:
                    _qbds.addSortField(salesIdFieldNum, sortOrder);
                    break;
                case CustomerNameSortColumnName:
                    _qbds.addSortField(customerNameFieldNum, sortOrder);
                    break;
                case DeliveryDateSortColumnName:
                    _qbds.addSortField(deliveryDateFieldNum, sortOrder);
                    _qbds.addSortField(pickupStartTimeFieldNum, sortOrder);
                    break;
                case FulfillmentStatusSortColumnName:
                    _qbds.addSortField(fulfillmentStatusFieldNum, sortOrder);
                    break;
                default:
                    break;
            }
        }
        else
        {
            _qbds.addSortField(deliveryDateFieldNum, SortOrder::Ascending);
            _qbds.addSortField(salesIdFieldNum, SortOrder::Ascending);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addQueryDeliveryType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add parameter fulfillment delivery type.
    /// </summary>
    /// <param name = "_qbds">The query build data source.</param>
    /// <param name = "_deliveryTypeInt">The delivery type in integer value.</param>
    /// <param name = "_pickupDlvModeCode">The delivery mode for pickup.</param>
    /// <param name = "_carryOutDlvModeCode">The delivery mode for carry out.</param>
    /// <param name = "_electronicDlvModeCode">The delivery mode for electronic.</param>
    /// <param name="_includeDlvModeCode">Delivery mode code to be included.</param>
    /// <param name="_methodVersion">Version of get fullfillment lines that is being called.</param>
    private static void addQueryDeliveryType(QueryBuildDataSource _qbds, int _deliveryTypeInt, DlvModeId _pickupDlvModeCode, DlvModeId _carryOutDlvModeCode, DlvModeId _electronicDlvModeCode, DlvModeId _includeDlvModeCode, RetailGetFulfillmentLinesVersion _methodVersion)
    {
        str dlvModeCodeColumnName = _methodVersion == RetailGetFulfillmentLinesVersion::V1 ? fieldStr(RetailFulfillmentLineView, DeliveryModeCode)
            : fieldStr(RetailFulfillmentLineViewV2, DeliveryMode);
        FieldId dlvModeFieldId = _methodVersion == RetailGetFulfillmentLinesVersion::V1 ? fieldNum(RetailFulfillmentLineView, DeliveryModeCode)
            : fieldNum(RetailFulfillmentLineViewV2, DeliveryMode);

        System.Text.StringBuilder stringBuilder = new System.Text.StringBuilder();
        QueryBuildDataSource pickupQbds;

        // Exclude carry out delivery mode.
        if (_carryOutDlvModeCode)
        {
            stringBuilder.Append(strFmt('%1( %2 != "%3" ) ', And, dlvModeCodeColumnName, _carryOutDlvModeCode));
        }

        // Exclude electronic delivery mode.
        if (_electronicDlvModeCode)
        {
            stringBuilder.Append(strFmt('%1( %2 != "%3" ) ', And, dlvModeCodeColumnName, _electronicDlvModeCode));
        }

        if (_includeDlvModeCode)
        {
            stringBuilder.Append(strFmt('%1( %2 == "%3" ) ', And, dlvModeCodeColumnName, _includeDlvModeCode));
        }

        switch (_deliveryTypeInt)
        {
            case enum2int(RetailFulfillmentLineDeliveryType::All):
                break; // Do nothing, no filtering on delivery type All
            case enum2int(RetailFulfillmentLineDeliveryType::StorePickup):
                if (RetailMultiplePickupDeliveryModeFeatureExposure::isEnabled())
                {
                    pickupQbds = _qbds.addDataSource(tableNum(RetailDlvMode));
                    pickupQbds.joinMode(JoinMode::ExistsJoin);
                    pickupQbds.addLink(dlvModeFieldId, fieldNum(RetailDlvMode, Code));
                    pickupQbds.addRange(fieldNum(RetailDlvMode, Type)).value(SysQuery::value(RetailDlvModeType::Pickup));
                }
                else
                {
                    stringBuilder.Append(strFmt('%1( %2 == "%3" ) ', and, dlvModeCodeColumnName, _pickupDlvModeCode));
                }
                break;
            case enum2int(RetailFulfillmentLineDeliveryType::StoreShipping):
                // Do not include pickup delivery mode.
                if (RetailMultiplePickupDeliveryModeFeatureExposure::isEnabled())
                {
                    pickupQbds = _qbds.addDataSource(tableNum(RetailDlvMode));
                    pickupQbds.joinMode(JoinMode::NoExistsJoin);
                    pickupQbds.addLink(dlvModeFieldId, fieldNum(RetailDlvMode, Code));
                    pickupQbds.addRange(fieldNum(RetailDlvMode, Type)).value(SysQuery::value(RetailDlvModeType::Pickup));
                }
                else
                {
                    stringBuilder.Append(strFmt('%1( %2 != "%3" ) ', and, dlvModeCodeColumnName, _pickupDlvModeCode));
                }
                break;
            default:
                // Extension codes on partners if they add more enum values on FulfillmentDeliveryType.
                RetailTransactionServiceFulfillment::addRangeFulfillmentDeliveryTypeDelegate(_deliveryTypeInt, _qbds);
                break;
        }

        if (stringBuilder.Length > 0)
        {
            QueryBuildRange qbrParam = _qbds.addRange(dlvModeFieldId);
            stringBuilder = stringBuilder.Remove(0, strLen(and)); // Remove prefix at the beginning of the query range.
            qbrParam.value(strFmt('( %1 )', stringBuilder.ToString()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addQueryFulfillmentStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add query fulfillment status.
    /// </summary>
    /// <param name = "_qbds">The query build data source.</param>
    /// <param name = "_searchCriteriaXmlRoot">The root element of the criteria.</param>
    /// <param name = "_methodVersion">The version of getFulfillmentLines method.</param>
    private static void addQueryFulfillmentStatus(QueryBuildDataSource _qbds, XmlElement _searchCriteriaXmlRoot, RetailGetFulfillmentLinesVersion _methodVersion)
    {
        FieldId fulfillmentStatusFieldNum = _methodVersion == RetailGetFulfillmentLinesVersion::V1 ? fieldNum(RetailFulfillmentLineView, FulfillmentStatus)
            : fieldNum(RetailFulfillmentLineViewV2, FulfillmentStatus);
        boolean hasValidValues = false;

        // Get fulfillment status parameter
        str fulfillmentStatusStr = RetailTransactionServiceFulfillment::getArg(_searchCriteriaXmlRoot, FulfillmentStatusesElementName);

        if (strLen(fulfillmentStatusStr) > 0)
        {
            container fulfillmentStatusTypes = str2con(fulfillmentStatusStr, ',');
            int containerLength = conLen(fulfillmentStatusTypes);

            if (containerLength > 0)
            {
                int cnt = 1;
                int fulfillmentStatusValue;
            

                while (cnt <= containerLength)
                {
                    fulfillmentStatusValue = str2Int(conPeek(fulfillmentStatusTypes, cnt));
                    cnt++;

                    if (fulfillmentStatusValue != enum2int(RetailFulfillmentLineStatus::Unknown) &&
                        fulfillmentStatusValue != enum2int(RetailFulfillmentLineStatus::Invoiced) &&
                        fulfillmentStatusValue != enum2int(RetailFulfillmentLineStatus::Rejected))
                    {
                        _qbds.addRange(fulfillmentStatusFieldNum).value(queryValue(fulfillmentStatusValue));
                        hasValidValues = true;
                    }
                }
            }
        }

        // User does not put any filter on fulfillment status. Set default (exclude status Unknown, Invoiced and Rejected)
        if (!hasValidValues)
        {
            if (strLen(fulfillmentStatusStr) > 0)
            {
                _qbds.addRange(fulfillmentStatusFieldNum).value(fulfillmentStatusStr);
            }

            // Status Unknown, Invoiced and Rejected should not be part of FulfillmentLine result.
            _qbds.addRange(fulfillmentStatusFieldNum).value(
                RetailTransactionServiceFulfillment::getQueryNotValueForExcludedFulfillmentLineStatus());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQueryNotValueForExcludedFulfillmentLineStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the list of fulfillment line statuses ignored by fulfillment lines view.
    /// </summary>
    /// <returns>
    /// A query range string containing all fulfillment line statuses that should be ignored by fulfillment lines view.
    /// </returns>
    [QueryRangeFunction]
    private static str getQueryNotValueForExcludedFulfillmentLineStatus()
    {
        container excludedValues;

        excludedValues += RetailFulfillmentLineStatus::Unknown;
        excludedValues += RetailFulfillmentLineStatus::Invoiced;
        excludedValues += RetailFulfillmentLineStatus::Rejected;

        return queryNotValueCon_W(excludedValues);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addElementStrResult</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Add string result value to xml element.
    /// </summary>
    /// <param name = "_resultDoc">The xml document.</param>
    /// <param name = "_parentElement">The parent element.</param>
    /// <param name = "_elementName">The element name.</param>
    /// <param name = "_value">The value to be added to xml result.</param>
    private static void addElementStrResult(XmlDocument _resultDoc, XmlElement _parentElement, str _elementName, str _value)
    {
        if (_value != '')
        {
            XmlElement propertyElement = _resultDoc.createElement(_elementName);
            propertyElement.innerText(_value);
            _parentElement.appendChild(propertyElement);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDecimalElementResult</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add decimal result value to xml element.
    /// </summary>
    /// <param name = "_resultDoc">The xml document.</param>
    /// <param name = "_parentElement">The parent element.</param>
    /// <param name = "_elementName">The element name.</param>
    /// <param name = "_decimalValue">The decimal value to be added to xml result.</param>
    private static void addDecimalElementResult(XmlDocument _resultDoc, XmlElement _parentElement, str _elementName, real _decimalValue)
    {
        str strValue = num2Str(_decimalValue, 0, /* no minimum chars */ 2 /* two digits decimal */,
            1 /* point separator */, 0 /* no thousand separator */);
        XmlElement propertyElement = _resultDoc.createElement(_elementName);
        propertyElement.innerText(strValue);
        _parentElement.appendChild(propertyElement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDateElementResult</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add date result value to xml element.
    /// </summary>
    /// <param name = "_resultDoc">The xml document.</param>
    /// <param name = "_parentElement">The parent element.</param>
    /// <param name = "_elementName">The element name.</param>
    /// <param name = "_dateTimeValue">The datetime value to be added to xml result.</param>
    private static void addDateElementResult(XmlDocument _resultDoc, XmlElement _parentElement, str _elementName, utcdatetime _dateTimeValue)
    {
        XmlElement propertyElement = _resultDoc.createElement(_elementName);
        propertyElement.setAttribute('xmlns:a', 'http://schemas.datacontract.org/2004/07/System');
        propertyElement.innerXml(RetailTransactionServiceUtilities::utcDateTimeToDateTimeStringWithOffset(_dateTimeValue));
        _parentElement.appendChild(propertyElement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRangeFulfillmentDeliveryTypeDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for adding range on fulfillment delivery type.
    /// </summary>
    /// <param name="_deliveryTypeInt">
    /// The fulfillment delivery type in int value.
    /// </param>
    /// <param name="_qbds">
    /// The query build data source for adding more range on delivery type.
    /// </param>
    static delegate void addRangeFulfillmentDeliveryTypeDelegate(int _deliveryTypeInt, QueryBuildDataSource _qbds)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerGetFulfillmentLinesCustomFilterRanges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to get the extension field ranges for custom filters of fulfillment line search criteria.
    /// </summary>
    /// <param name = "customFiltersXmlElement">The XML element of custom filters.</param>
    /// <param name = "extensionRanges">List of the containers (extensionFieldName, extensionFieldValue) used to build query ranges for custom filters from extensions.</param>
    static delegate void registerGetFulfillmentLinesCustomFilterRanges(XmlElement customFiltersXmlElement, List extensionRanges)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateDeposit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates deposit to be applied while settling a shipping order.
    /// </summary>
    /// <param name = "orderInfo">Customer order information.</param>
    /// <param name = "currentChannelRecId">Current channel record id.</param>
    /// <returns>The available deposit amount.</returns>
    private static Amount calculateDeposit(CustomerOrderInfo orderInfo, str currentChannelRecId)
    {
        Amount nonPrepayments = 0;
        Amount prepaymentAmountPaid = 0;
        Amount prepaymentAmountInvoiced = 0;
        Amount availableDeposit = 0;
        SalesLine salesLine;
        System.Reflection.Assembly transactionServiceAssembly = System.Reflection.Assembly::Load(TransactionServiceAssemblyName);
        System.Type paymentInfoType = transactionServiceAssembly == null ? null : transactionServiceAssembly.GetType(PaymentInfoName);

        System.Collections.IEnumerator paymentsEnumerator = orderInfo.Payments.GetEnumerator();
        while (paymentsEnumerator.MoveNext())
        {
            var payment = paymentsEnumerator.Current;
            Amount amount = paymentInfoType.GetProperty(AmountProperty).GetValue(payment);
            boolean prepayment = paymentInfoType.GetProperty(PrepaymentProperty).GetValue(payment);
            str currency = strUpr(paymentInfoType.GetProperty(CurrencyProperty).GetValue(payment));
            str currentChannelCurrency = strUpr(RetailChannelTable::findByRecId(str2recId(currentChannelRecId)).Currency);

            if (currency != currentChannelCurrency)
            {
                CurrencyExchangeHelper currencyExchHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()));
                amount = currencyExchHelper.calculateCurrencyToCurrency(currency, currentChannelCurrency, amount, true);
            }

            if (prepayment)
            {
                // Sum prepayments to track total deposits paid
                prepaymentAmountPaid += amount;
            }
            else
            {
                // Sum non-prepayments as base for calculating deposits applied to pickups
                nonPrepayments += amount;
            }
        }

        // Portion of the prepayment that has been applied to invoices
        // (total amount invoiced less payments, difference is the deposit applied)
        prepaymentAmountInvoiced = orderInfo.PreviouslyInvoicedAmount - nonPrepayments;

        // if the prepayment invoiced is greater than the total paid as deposit, there is no credit left
        availableDeposit = prepaymentAmountPaid - prepaymentAmountInvoiced > 0 ? prepaymentAmountPaid - prepaymentAmountInvoiced : 0;
        
        return availableDeposit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReasonCodeInformation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the localized description for info code.
    /// </summary>
    /// <param name = "_dataAreaId">Data area Id.</param>
    /// <param name = "reasonCodeId">Reason code Id.</param>
    /// <param name = "reasonSubCodeId">Reason Sub Code Id.</param>
    /// <returns>
    /// Returns localized description of reason info code.
    /// </returns>
    private static RetailInformationSubcodeTranslationDescr getReasonCodeInformation(str _dataAreaId, str reasonCodeId, str reasonSubCodeId)
    {
        RetailInformationSubcodeTable retailInformationSubcodeTable;
        RetailInformationSubcodeTranslation retailInformationSubcodeTranslation;
        RetailInformationSubcodeTranslationDescr information = '';

        if (strLen(reasonCodeId) > 0 && strLen(reasonSubCodeId) > 0)
        {
            select firstonly RecId
                from retailInformationSubcodeTable
                where retailInformationSubcodeTable.DataAreaId == _dataAreaId
                    && retailInformationSubcodeTable.infocodeId == reasonCodeId
                    && retailInformationSubcodeTable.subcodeId == reasonSubCodeId;

            if (retailInformationSubcodeTable)
            {
                retailInformationSubcodeTranslation = RetailInformationSubcodeTranslation::find(retailInformationSubcodeTable.RecId);
                if (retailInformationSubcodeTranslation)
                {
                    information = retailInformationSubcodeTranslation.description;
                }
            }
        }

        return information;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductNameForFulfillmentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the product name of the fulfillment line in the specified language.
    /// </summary>
    /// <param name= "_fulfillmentLine">The fulfillment line.</param>
    /// <param name-"_languageId">The specified language id.</param>
    /// <returns>The product name in the language provided if available, otherwise the product name in the system language.</returns>
    private static EcoResProductName getProductNameForFulfillmentLine(ItemId _itemId, InventDimId _inventDimId, str _itemDescription, LanguageId _languageId)
    {
        InventTable inventTable = InventTable::find(_itemId);
        EcoResProductName productName = inventTable.productName(_languageId, _inventDimId);
        
        return productName? productName: _itemDescription;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWHSLocationToDefaultIfEmpty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Given a sales line with a WHS enabled item and store, sets the location to the store's default location.
    /// </summary>
    /// <param name = "_salesLine">The sales line.</param>
    private static void setWHSLocationToDefaultIfEmpty(SalesLine _salesLine)
    {
        InventDim inventDim;

        select firstonly forupdate inventDim
            where inventDim.inventDimId == _salesLine.InventDimId;

        if (inventDim && !inventDim.wmsLocationId)
        {
            ItemId item = _salesLine.ItemId;
            boolean isItemAndWarehouseWHSEnabled = WHSInventEnabled::exist(item) && InventLocation::find(inventDim.InventLocationId).whsEnabled;

            if (isItemAndWarehouseWHSEnabled)
            {
                // Default to the default wms location and update the sales line with new InventDimId reference.
                WMSLocationId wmsLocation = InventLocation::find(inventDim.InventLocationId).RBODefaultWMSLocationId;
                if (wmsLocation)
                {
                    _salesLine.selectForUpdate(true);

                    ttsbegin;
                    inventDim.wMSLocationId = wmsLocation;
                    inventDim = InventDim::findOrCreate(inventDim);
                    _salesLine.InventDimId = inventDim.InventDimId;
                    _salesLine.update();
                    ttscommit;
                }

            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDecimalAmountElementResult</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add decimal result value to xml element.
    /// </summary>
    /// <param name = "_resultDoc">The xml document.</param>
    /// <param name = "_parentElement">The parent element.</param>
    /// <param name = "_elementName">The element name.</param>
    /// <param name = "_decimalValue">The decimal value to be added to xml result.</param>
    private static void addDecimalAmountElementResult(XmlDocument _resultDoc, XmlElement _parentElement, str _elementName, real _decimalValue)
    {
        str strValue = num2Str(_decimalValue, 0, /* no minimum chars */ 3 /* three digits decimal */,
            1 /* point separator */, 0 /* no thousand separator */);
        XmlElement propertyElement = _resultDoc.createElement(_elementName);
        propertyElement.innerText(strValue);
        _parentElement.appendChild(propertyElement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBooleanElementResult</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add boolean result value to xml element.
    /// </summary>
    /// <param name = "_resultDoc">The xml document.</param>
    /// <param name = "_parentElement">The parent element.</param>
    /// <param name = "_elementName">The element name.</param>
    /// <param name = "_booleanValue">The boolean value to be added to xml result.</param>
    private static void addBooleanElementResult(XmlDocument _resultDoc, XmlElement _parentElement, str _elementName, boolean _booleanValue)
    {
        str strValue;

        if (_booleanValue)
        {
            strValue = '1';
        }
        else
        {
            strValue = '0';
        }

        XmlElement propertyElement = _resultDoc.createElement(_elementName);
        propertyElement.innerText(strValue);
        _parentElement.appendChild(propertyElement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLoyaltyCardNumberToQuery</Name>
				<Source><![CDATA[
    private static void addLoyaltyCardNumberToQuery(QueryBuildDataSource _qbds, str _loyaltyCardNumberParam, RetailGetFulfillmentLinesVersion _methodVersion)
    {
        FieldId partyFieldNum = _methodVersion == RetailGetFulfillmentLinesVersion::V1 ? fieldNum(RetailFulfillmentLineView, Party) :
            fieldNum(RetailFulfillmentLineViewV2, Party);

        QueryBuildDataSource retailLoyaltyCard_ds = _qbds.addDatasource(tableNum(RetailLoyaltyCard));
        retailLoyaltyCard_ds.joinMode(JoinMode::ExistsJoin);
        retailLoyaltyCard_ds.relations(false);
        retailLoyaltyCard_ds.addLink(partyFieldNum, fieldNum(RetailLoyaltyCard, Party));
        retailLoyaltyCard_ds.addRange(fieldNum(RetailLoyaltyCard, CardNumber)).value(_loyaltyCardNumberParam);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCustomerPhoneNumberToQuery</Name>
				<Source><![CDATA[
    private static void addCustomerPhoneNumberToQuery(QueryBuildDataSource _qbds, str _customerPhoneNumberParam, RetailGetFulfillmentLinesVersion _methodVersion)
    {
        FieldId partyFieldNum = _methodVersion == RetailGetFulfillmentLinesVersion::V1 ? fieldNum(RetailFulfillmentLineView, Party) :
            fieldNum(RetailFulfillmentLineViewV2, Party);

        QueryBuildDataSource dirPartyLocation_ds = _qbds.addDataSource(tableNum(DirPartyLocation));
        dirPartyLocation_ds.joinMode(JoinMode::ExistsJoin);
        dirPartyLocation_ds.relations(false);
        dirPartyLocation_ds.addLink(partyFieldNum, fieldNum(DirPartyLocation, Party));

        QueryBuildDataSource logisticsElectronicAddress_ds = dirPartyLocation_ds.addDataSource(tableNum(LogisticsElectronicAddress));
        logisticsElectronicAddress_ds.joinMode(JoinMode::InnerJoin);
        logisticsElectronicAddress_ds.relations(false);
        logisticsElectronicAddress_ds.addLink(fieldNum(DirPartyLocation, Location), fieldNum(LogisticsElectronicAddress, Location));
        logisticsElectronicAddress_ds.addRange(fieldNum(LogisticsElectronicAddress, Locator)).value(_customerPhoneNumberParam);
        logisticsElectronicAddress_ds.addRange(fieldNum(LogisticsElectronicAddress, Type)).value(enum2Str(LogisticsElectronicAddressMethodType::Phone));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFulfillmentLinesInternalLegacy</Name>
				<Source><![CDATA[
    private static container getFulfillmentLinesInternalLegacy(str _fulfillmentSearchCriteriaXml)
    {
        RetailGetFulfillmentLinesVersion methodVersion = RetailGetFulfillmentLinesVersion::V1;
        eventSource.WriteGetFulfillmentLinesMethodVersion(enum2int(methodVersion));

        RetailParameters retailParamsTable;
        DlvModeId pickupDlvModeCode, carryOutDlvModeCode, electronicDlvModeCode;
        select PickupDeliveryModeCode, CarryOutDeliveryModeCode, ElectronicDeliveryModeCode, DataAreaId from retailParamsTable;

        if (retailParamsTable)
        {
            pickupDlvModeCode = retailParamsTable.PickupDeliveryModeCode;
            carryOutDlvModeCode = retailParamsTable.CarryOutDeliveryModeCode;
            electronicDlvModeCode = retailParamsTable.ElectronicDeliveryModeCode;
        }

        XmlDocument searchCriteriaXmlDoc = new XmlDocument();
        searchCriteriaXmlDoc.loadXml(_fulfillmentSearchCriteriaXml);
        XmlElement searchCriteriaXmlRoot = searchCriteriaXmlDoc.documentElement();

        Query query = new Query();
        QueryBuildDataSource qbds = query.addDataSource(tableNum(RetailFulfillmentLineView));

        RetailTransactionServiceFulfillment::addQuerySortColumn(qbds, searchCriteriaXmlDoc, methodVersion);

        // Fulfillment type and warehouse identifier must be part of the parameter.
        str dlvTypeStr = RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, DeliveryTypeElementName);
        InventLocationId warehouseId = RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, WarehouseIdElementName);

        // Include only orders that are not On Hold.
        qbds.addRange(fieldNum(RetailFulfillmentLineView, IsOnHold)).value(queryValue(NoYes::No));

        // Include only orders that has sales type sales.
        qbds.addRange(fieldNum(RetailFulfillmentLineView, SalesType)).value(queryValue(SalesType::Sales));

        // Include only orders that has sales status backordered or delivered.
        qbds.addRange(fieldNum(RetailFulfillmentLineView, SalesStatus)).value(queryValue(SalesStatus::Backorder));
        qbds.addRange(fieldNum(RetailFulfillmentLineView, SalesStatus)).value(queryValue(SalesStatus::Delivered));
            
        // Exclude records which have Statement id populated (these are cash and carry transactions).
        qbds.addRange(fieldNum(RetailFulfillmentLineView, StatementId)).value(SysQuery::valueEmptyString());

        // Exclude records which have sales line status cancelled.
        qbds.addRange(fieldNum(RetailFulfillmentLineView, SalesLineStatus)).value(SysQuery::valueNot(enum2str(SalesStatus::Canceled)));

        if (!dlvTypeStr || !warehouseId)
        {
            return [false, "@Retail:GetFulfillmentError", ''];
        }
        else
        {
            int deliveryTypeInt = str2Int(dlvTypeStr);
            RetailTransactionServiceFulfillment::addQueryDeliveryType(qbds, deliveryTypeInt, pickupDlvModeCode, carryOutDlvModeCode, electronicDlvModeCode,
                    RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, DeliveryModeCodeElementName), methodVersion);
        }

        RetailTransactionServiceFulfillment::addQueryRangeStr(qbds, RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, CustomerIdElementName), fieldNum(RetailFulfillmentLineView, CustomerId));
        RetailTransactionServiceFulfillment::addQueryRangeStr(qbds, RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, EmailAddressElementName), fieldNum(RetailFulfillmentLineView, EmailAddress));
        RetailTransactionServiceFulfillment::addQueryRangeStr(qbds, RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, SalesIdElementName), fieldNum(RetailFulfillmentLineView, SalesId));
        RetailTransactionServiceFulfillment::addQueryRangeStr(qbds, RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, ChannelReferenceIdElementName), fieldNum(RetailFulfillmentLineView, ChannelReferenceId));
        RetailTransactionServiceFulfillment::addQueryRangeStr(qbds, warehouseId, fieldNum(RetailFulfillmentLineView, WarehouseId));
        RetailTransactionServiceFulfillment::addQueryRangeStr(qbds, RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, StoreNumberElementName), fieldNum(RetailFulfillmentLineView, StoreNumber));
        RetailTransactionServiceFulfillment::addQueryRangeDate(qbds, RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, OrderCreatedStartElementName),
                RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, OrderCreatedEndDateElementName), fieldNum(RetailFulfillmentLineView, CreatedDate));
        RetailTransactionServiceFulfillment::addQueryRangeDate(qbds, RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, RequestedDeliveryStartDateElementName),
                RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, RequestedDeliveryEndDateElementName), fieldNum(RetailFulfillmentLineView, RequestedDeliveryDate));
        RetailTransactionServiceFulfillment::addQueryRangeDate(qbds, RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, RequestedReceiptStartDateElementName),
                RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, RequestedReceiptEndDateElementName), fieldNum(RetailFulfillmentLineView, RequestedReceiptDate));

        RetailTransactionServiceFulfillment::addQueryFulfillmentStatus(qbds, searchCriteriaXmlRoot, methodVersion);

        // Get customer name parameter
        str custNameParam = RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, CustomerNameElementName);

        if (custNameParam)
        {
            qbds.addRange(fieldNum(RetailFulfillmentLineView, CustomerName)).value(strFmt('*%1*', queryValue(custNameParam)));
        }

        str receiptIdParam = RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, ReceiptIdElementName);

        if (receiptIdParam)
        {
            QueryBuildRange qbr = qbds.addRange(fieldNum(RetailFulfillmentLineView, DataAreaId));
            str channelReferenceIdFieldName = fieldStr(RetailFulfillmentLineView, ChannelReferenceId);
            str receiptIdFieldName = fieldStr(RetailFulfillmentLineView, ReceiptId);

            // Receipt Id can be located on either table RetailSalesTable.ChannelReferenceId (Customer Order, Call Center)
            // or RetailTransactionTable.ReceiptId (Async Customer Order, eCommerce orders).
            qbr.value(strFmt(
                '( (%1 == "%2") || (%3 == "%2") )', // ( (ChannelReferenceId == param) || (ReceiptId == param) )
                channelReferenceIdFieldName,
                receiptIdParam,
                receiptIdFieldName));
        }

        str loyaltyCardNumberParam = RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, LoyaltyCardNumberElementName);
        if (loyaltyCardNumberParam)
        {
            RetailTransactionServiceFulfillment::addLoyaltyCardNumberToQuery(qbds, loyaltyCardNumberParam, methodVersion);
        }

        str customerPhoneNumberParam = RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, customerPhoneNumberElementName);
        if (customerPhoneNumberParam)
        {
            RetailTransactionServiceFulfillment::addCustomerPhoneNumberToQuery(qbds, customerPhoneNumberParam, methodVersion);
        }

        // Get the store language so we retrieve the product name in the store language if possible, otherwise system language.
        RetailStoreTable retailStore;
        select firstonly CultureName from retailStore
                where retailStore.InventLocation == warehouseId
                && retailStore.inventLocationDataAreaId == retailParamsTable.DataAreaId;

        LanguageId storeLanguage = retailStore.cultureName;

        // Initialize xml return result
        XmlDocument resultDoc = RetailTransactionServiceUtilities::getXmlDocumentForSerializedEntities();
        XmlElement resultRootElement = resultDoc.createElement(ArrayOfFulfillmentLinesElementName);
        resultRootElement.setAttribute('xmlns', RetailTransactionServiceUtilities::getCrtDataModelXmlNamespace());

        // Get paging details
        int startingPosition = DefaultStartingPosition;
        int maxResultCount = DefaultMaxResultCount;
        int resultCounter = 0;
        [startingPosition, maxResultCount] = RetailTransactionServiceTransactions::parsePagingInfo(searchCriteriaXmlDoc);

        // maxResultCount is 0 if PagingInfo.AllRecords is set.
        boolean queryAllRecords = maxResultCount == 0;

        QueryRun qr = new QueryRun(query);

        if (!queryAllRecords)
        {
            qr.enablePositionPaging(true);
            qr.addPageRange(startingPosition, maxResultCount);
        }

        RetailFulfillmentLineDeliveryType deliveryType;
        Map amountMap = new Map(Types::String, Types::Container);
        real totalAmount, balance;
        SalesTotals salesTotals;
        SalesTable salesTable;
        Map detailedOrderStatusMap = new Map(Types::String, Types::Enum);
        Map channelTypeMap = new Map(Types::Int64, Types::Enum);

        Set uniqueSalesLines = new Set(Types::Container);
        while (qr.next())
        {
            // Counter reaches max result. Stop fetching data.
            if (!queryAllRecords && resultCounter >= maxResultCount)
            {
                break;
            }

            RetailFulfillmentLineView fulfillmentResult = qr.get(tableNum(RetailFulfillmentLineView));
            if (uniqueSalesLines.In([fulfillmentResult.SalesId, fulfillmentResult.SalesLineNumber]))
            {
                continue;
            }

            uniqueSalesLines.add([fulfillmentResult.SalesId, fulfillmentResult.SalesLineNumber]);
            XmlElement fulfillmentElement = resultDoc.createElement(FulfillmentLineElementName);

            // Get the delivery type.
            if (RetailDlvMode::isPickupDeliveryMode(fulfillmentResult.DeliveryModeCode))
            {
                deliveryType = RetailFulfillmentLineDeliveryType::StorePickup;
            }
            else
            {
                deliveryType = RetailFulfillmentLineDeliveryType::StoreShipping;
            }

            salesTable = SalesTable::find(fulfillmentResult.SalesId);
            boolean isOrderTotalAmountCalculationDisabled = RetailTransactionServiceFulfillment::isOrderTotalAmountsCalculationDisabled(fulfillmentResult.SalesId);
            if (!isOrderTotalAmountCalculationDisabled)
            {
                // Get the total amount and balance.
                if (!amountMap.exists(fulfillmentResult.SalesId))
                {
                    salesTotals = SalesTotals::construct(salesTable);
                    salesTotals.calc();
                    totalAmount = salesTotals.totalAmount() + salesTable.amountInvoiced();

                    // If sales order is a call center order, calculate balance by fetching prepayment details from MCRCustPaymTable. Otherwise, get prepayment details from RetailPrePaymentTrans.
                    if (salesTable.mcrIsCallCenter())
                    {
                        mcrCustPaymTotals custPaym = mcrCustPaymTotals::construct(salesTable.TableId, salesTable.RecId);
                        balance = totalAmount - custPaym.getTotalPaymAmount();
                    }
                    else
                    {
                        balance = totalAmount - RetailTransactionPaymentsHelper::paymentsMade(fulfillmentResult.SalesId);
                    }

                    amountMap.insert(fulfillmentResult.SalesId, [ balance, totalAmount ]);
                }
            }
            else
            {
                amountMap.insert(fulfillmentResult.SalesId, [ 0, 0 ]);
            }

            // Add element result - Sort by element name alphabetically.
            RetailTransactionServiceFulfillment::addDecimalAmountElementResult(resultDoc, fulfillmentElement, BalanceElementName, conPeek(amountMap.lookup(fulfillmentResult.SalesId), 1));
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, ChannelTypeElementName, int2Str(enum2int(RetailTransactionServiceFulfillment::getChannelType(channelTypeMap, fulfillmentResult.RetailChannelId))));
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, ChannelReferenceIdElementName, fulfillmentResult.ChannelReferenceId);
            RetailTransactionServiceFulfillment::addDateElementResult(resultDoc, fulfillmentElement, CreatedDateElementName, fulfillmentResult.CreatedDate);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, CustomerIdElementName, fulfillmentResult.CustomerId);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, CustomerNameElementName, fulfillmentResult.CustomerName);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, DeliveryModeCodeElementName, fulfillmentResult.DeliveryModeCode);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, DeliveryTypeElementName, int2Str(enum2int(deliveryType)));

            if (RetailAllowPartialOrderEditingFeatureExposure::isEnabledInFeatureManagement())
            {
                RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, DetailedLineStatusElementName, int2Str(enum2int(RetailDetailedOrderInfoHelper::getDetailedLineStatus(SalesLine::find(fulfillmentResult.SalesId, fulfillmentResult.SalesLineNumber, false)))));
                RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, DetailedOrderStatusElementName, int2Str(enum2int(RetailTransactionServiceFulfillment::getDetailedOrderStatus(detailedOrderStatusMap, salesTable))));
            }

            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, DocumentStatusElementName, int2Str(any2Int(fulfillmentResult.DocumentStatus)));
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, EmailAddressElementName, fulfillmentResult.EmailAddress);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, FulfillmentStatusElementName, int2Str(any2Int(fulfillmentResult.FulfillmentStatus)));
            RetailTransactionServiceFulfillment::addBooleanElementResult(resultDoc, fulfillmentElement, IsOrderTotalIncludedElementName, !isOrderTotalAmountCalculationDisabled);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, ItemIdElementName, fulfillmentResult.ItemId);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, ItemNameElementName, RetailTransactionServiceFulfillment::getProductNameForFulfillmentLine(fulfillmentResult.ItemId, fulfillmentResult.InventDimId, fulfillmentResult.ItemName, storeLanguage));

            if (fulfillmentResult.PickupEndTime > 0)
            {
                RetailTransactionServiceFulfillment::addDateElementResult(resultDoc, fulfillmentElement, PickupTimeslotEndDateTimeElementName, DateTimeUtil::newDateTime(fulfillmentResult.RequestedDeliveryDate, fulfillmentResult.PickupEndTime));
                RetailTransactionServiceFulfillment::addDateElementResult(resultDoc, fulfillmentElement, PickupTimeslotStartDateTimeElementName, DateTimeUtil::newDateTime(fulfillmentResult.RequestedDeliveryDate, fulfillmentResult.PickupStartTime));
            }

            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, ProductIdElementName, int642Str(fulfillmentResult.DistinctProductVariant == 0 ? fulfillmentResult.Product : fulfillmentResult.DistinctProductVariant));
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, ProductVariantElementName, fulfillmentResult.DisplayProductNumber);
            RetailTransactionServiceFulfillment::addDecimalElementResult(resultDoc, fulfillmentElement, QuantityInvoicedElementName, fulfillmentResult.QuantityInvoiced);
            RetailTransactionServiceFulfillment::addDecimalElementResult(resultDoc, fulfillmentElement, QuantityOrderedElementName, fulfillmentResult.QuantityOrdered);
            RetailTransactionServiceFulfillment::addDecimalElementResult(resultDoc, fulfillmentElement, QuantityPackedElementName, fulfillmentResult.QuantityPacked);
            RetailTransactionServiceFulfillment::addDecimalElementResult(resultDoc, fulfillmentElement, QuantityPickedElementName, fulfillmentResult.QuantityPicked);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, RetailVariantIdElementName, fulfillmentResult.RetailVariantId);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, ReceiptIdElementName, fulfillmentResult.ReceiptId);
            RetailTransactionServiceFulfillment::addDateElementResult(resultDoc, fulfillmentElement, RequestedDeliveryDateElementName, DateTimeUtil::newDateTime(fulfillmentResult.RequestedDeliveryDate, 0));
            RetailTransactionServiceFulfillment::addDateElementResult(resultDoc, fulfillmentElement, RequestedReceiptDateElementName, DateTimeUtil::newDateTime(fulfillmentResult.RequestedReceiptDate, 0));
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, SalesIdElementName, fulfillmentResult.SalesId);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, SalesLineNumberElementName, RetailTransactionServiceUtilities::lineNumToString(fulfillmentResult.SalesLineNumber));
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, SalesPersonFirstNameElementName, fulfillmentResult.SalesPersonFirstName);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, SalesPersonIdElementName, fulfillmentResult.SalesPersonId);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, SalesPersonLastNameElementName, fulfillmentResult.SalesPersonLastName);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, SalesPersonStoreIdElementName, fulfillmentResult.StoreNumber);

            if (RetailOrderSerialNumberValidationFeatureExposure::isEnabled())
            {
                RetailTransactionServiceFulfillment::fillXmlWithSerialId(resultDoc, fulfillmentElement, fulfillmentResult.ItemId, fulfillmentResult.InventTransId, fulfillmentResult.InventDimId);
            }
            
            // Add address result.
            XmlElement addressElement = resultDoc.createElement(ShippingAddressElementName);
            addressElement.setAttribute('xmlns', RetailTransactionServiceUtilities::getCrtDataModelXmlNamespace());

            // Elements added has to be sorted alphabetically.
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, addressElement, BuildingComplimentElementName, fulfillmentResult.ShippingAddress_BuildingCompliment);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, addressElement, CityElementName, fulfillmentResult.ShippingAddress_City);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, addressElement, CountyElementName, fulfillmentResult.ShippingAddress_County);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, addressElement, CountyNameElementName, fulfillmentResult.ShippingAddress_CountyName);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, addressElement, DistrictNameElementName, fulfillmentResult.ShippingAddress_DistrictName);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, addressElement, FullAddressElementName, fulfillmentResult.ShippingAddress_FullAddress);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, addressElement, PostboxElementName, fulfillmentResult.ShippingAddress_Postbox);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, addressElement, StateElementName, fulfillmentResult.ShippingAddress_State);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, addressElement, StateNameElementName, fulfillmentResult.ShippingAddress_StateName);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, addressElement, StreetElementName, fulfillmentResult.ShippingAddress_Street);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, addressElement, StreetNumberElementName, fulfillmentResult.ShippingAddress_StreetNumber);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, addressElement, CountryRegionElementName, fulfillmentResult.ShippingAddress_CountryRegion);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, addressElement, ZipCodeElementName, fulfillmentResult.ShippingAddress_ZipCode);
            fulfillmentElement.appendChild(addressElement);

            // Get inventory info.
            InventDim inventDim;
            InventOnHandByWarehouse inventOnHandByWarehouse;
            real localOrderedSum = 0.0;
            real localReservPhysical = 0.0;
            real localAvailPhysical = 0.0;
            select firstonly InventSizeId, InventColorId, InventStyleId from inventDim
                    where inventDim.inventDimId == fulfillmentResult.InventDimId;
            if (inventDim)
            {
                select firstonly ReservPhysical, AvailPhysical, OrderedSum from inventOnHandByWarehouse
                    where inventOnHandByWarehouse.ItemId == fulfillmentResult.ItemId
                        && inventOnHandByWarehouse.InventLocationId == fulfillmentResult.WarehouseId
                        && inventOnHandByWarehouse.InventSizeId == inventDim.InventSizeId
                        && inventOnHandByWarehouse.InventColorId == inventDim.InventColorId
                        && inventOnHandByWarehouse.InventStyleId == inventDim.InventStyleId;
            }
            if (inventOnHandByWarehouse)
            {
                localOrderedSum = inventOnHandByWarehouse.OrderedSum;
                localReservPhysical = inventOnHandByWarehouse.ReservPhysical;
                localAvailPhysical = inventOnHandByWarehouse.AvailPhysical;
            }

            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, StoreNumberElementName, fulfillmentResult.StoreNumber);
            RetailTransactionServiceFulfillment::addDecimalElementResult(resultDoc, fulfillmentElement, StoreInventoryOrderedQuantityElementName, localOrderedSum);
            RetailTransactionServiceFulfillment::addDecimalElementResult(resultDoc, fulfillmentElement, StoreInventoryReservedQuantityElementName, localReservPhysical);
            RetailTransactionServiceFulfillment::addDecimalElementResult(resultDoc, fulfillmentElement, StoreInventoryTotalQuantityElementName, localAvailPhysical);
            RetailTransactionServiceFulfillment::addDecimalAmountElementResult(resultDoc, fulfillmentElement, TotalAmountElementName, conPeek(amountMap.lookup(fulfillmentResult.SalesId), 2));
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, UnitOfMeasureSymbolElementName, fulfillmentResult.UnitOfMeasureSymbol);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, WarehouseIdElementName, fulfillmentResult.WarehouseId);

            resultRootElement.appendChild(fulfillmentElement);
            resultCounter++;
        }

        resultDoc.appendChild(resultRootElement);

        return [true, '', resultDoc.toString()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFulfillmentLinesInternalV2</Name>
				<Source><![CDATA[
    private static container getFulfillmentLinesInternalV2(str _fulfillmentSearchCriteriaXml)
    {
        RetailGetFulfillmentLinesVersion methodVersion = RetailGetFulfillmentLinesVersion::V2;
        eventSource.WriteGetFulfillmentLinesMethodVersion(enum2int(methodVersion));

        RetailParameters retailParamsTable = RetailParameters::find();

        DlvModeId pickupDlvModeCode = retailParamsTable.PickupDeliveryModeCode;
        DlvModeId carryOutDlvModeCode = retailParamsTable.CarryOutDeliveryModeCode;
        DlvModeId electronicDlvModeCode = retailParamsTable.ElectronicDeliveryModeCode;

        XmlDocument searchCriteriaXmlDoc = new XmlDocument();
        searchCriteriaXmlDoc.loadXml(_fulfillmentSearchCriteriaXml);
        XmlElement searchCriteriaXmlRoot = searchCriteriaXmlDoc.documentElement();

        Query query = new Query();
        QueryBuildDataSource qbds = query.addDataSource(tableNum(RetailFulfillmentLineViewV2));

        RetailTransactionServiceFulfillment::addQuerySortColumn(qbds, searchCriteriaXmlDoc, methodVersion);

        // Fulfillment type and warehouse identifier must be part of the parameter.
        str dlvTypeStr = RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, DeliveryTypeElementName);
        InventLocationId warehouseId = RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, WarehouseIdElementName);

        if (!dlvTypeStr || !warehouseId)
        {
            throw Exception::Error;
        }

        int deliveryTypeInt = str2Int(dlvTypeStr);
        RetailTransactionServiceFulfillment::addQueryDeliveryType(qbds, deliveryTypeInt, pickupDlvModeCode, carryOutDlvModeCode, electronicDlvModeCode,
            RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, DeliveryModeCodeElementName), methodVersion);

        RetailTransactionServiceFulfillment::addQueryRangeStr(qbds, RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, CustomerIdElementName), fieldNum(RetailFulfillmentLineViewV2, CustomerId));
        RetailTransactionServiceFulfillment::addQueryRangeStr(qbds, RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, EmailAddressElementName), fieldNum(RetailFulfillmentLineViewV2, EmailAddress));
        RetailTransactionServiceFulfillment::addQueryRangeStr(qbds, RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, SalesIdElementName), fieldNum(RetailFulfillmentLineViewV2, SalesId));
        RetailTransactionServiceFulfillment::addQueryRangeStr(qbds, RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, ChannelReferenceIdElementName), fieldNum(RetailFulfillmentLineViewV2, ChannelReferenceId));
        RetailTransactionServiceFulfillment::addQueryRangeStr(qbds, warehouseId, fieldNum(RetailFulfillmentLineViewV2, InventLocationId));
        RetailTransactionServiceFulfillment::addQueryRangeStr(qbds, RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, StoreNumberElementName), fieldNum(RetailFulfillmentLineViewV2, StoreNumber));
        RetailTransactionServiceFulfillment::addQueryRangeDate(qbds, RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, OrderCreatedStartElementName),
                RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, OrderCreatedEndDateElementName), fieldNum(RetailFulfillmentLineViewV2, CreatedDate));
        RetailTransactionServiceFulfillment::addQueryRangeDate(qbds, RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, RequestedDeliveryStartDateElementName),
                RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, RequestedDeliveryEndDateElementName), fieldNum(RetailFulfillmentLineViewV2, RequestedDeliveryDate));
        RetailTransactionServiceFulfillment::addQueryRangeDate(qbds, RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, RequestedReceiptStartDateElementName),
                RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, RequestedReceiptEndDateElementName), fieldNum(RetailFulfillmentLineViewV2, RequestedReceiptDate));

        RetailTransactionServiceFulfillment::addQueryFulfillmentStatus(qbds, searchCriteriaXmlRoot, methodVersion);

        str receiptIdStr = RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, ReceiptIdElementName);
        if (receiptIdStr)
        {
            if (FeatureStateProvider::isFeatureEnabled(RetailOmniChannelGenerateOrderConfirmationIdFeature::instance())) {
                // Filter against RetailSalesTable.ChannelReferenceId or RetailSalesTable.ReceiptId.
                // In the past for retail orders created from POS, there is no InitialReceiptId column in the RetailSalesTable.
                // Instead ChannelReferenceId column contains the value of ReceiptId.
                qbds.addRange(fieldNum(RetailFulfillmentLineViewV2, ReceiptId)).value(strFmt(
                    '( (%1 == "%3") || (%2 == "%3") )', // ( (ReceiptId == param) || (ChannelReferenceId == param) )
                    fieldStr(RetailFulfillmentLineViewV2, ReceiptId),
                    fieldStr(RetailFulfillmentLineViewV2, ChannelReferenceId),
                    receiptIdStr));
            }
            else
            {
                // Before the feature is enabled, POS ReceiptId is actually stored in ChannelReferenceId field.
                // Logic above is compatible to the current code block. We left previous logic here to prevent performance regression.
                RetailTransactionServiceFulfillment::addQueryRangeStr(qbds, receiptIdStr, fieldNum(RetailFulfillmentLineViewV2, ChannelReferenceId));
            }
        }

        // Custom filters from extensions
        List extensionRanges = new List(Types::Container);
        XmlElement customFiltersXmlElement = searchCriteriaXmlRoot.getNamedElement('CustomFilters');
        if (customFiltersXmlElement)
        {
            // Gather custom filters from extensions
            RetailTransactionServiceFulfillment::registerGetFulfillmentLinesCustomFilterRanges(customFiltersXmlElement, extensionRanges);
          
            // Apply custom filters as query ranges
            RetailTransactionServiceFulfillment::addExtensionFieldRangeValue(qbds, extensionRanges);

            // Call extension point to add custom data sources and filters
            RetailTransactionServiceFulfillment::registerGetFulfillmentLinesCustomDataSources(customFiltersXmlElement, qbds);
        }

        // Get customer name parameter
        str custNameParam = RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, CustomerNameElementName);

        if (custNameParam)
        {
            qbds.addRange(fieldNum(RetailFulfillmentLineViewV2, CustomerName)).value(strFmt('*%1*', queryValue(custNameParam)));
        }

        str loyaltyCardNumberParam = RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, LoyaltyCardNumberElementName);
        if (loyaltyCardNumberParam)
        {
            RetailTransactionServiceFulfillment::addLoyaltyCardNumberToQuery(qbds, loyaltyCardNumberParam, methodVersion);
        }

        str customerPhoneNumberParam = RetailTransactionServiceFulfillment::getArg(searchCriteriaXmlRoot, customerPhoneNumberElementName);
        if (customerPhoneNumberParam)
        {
            RetailTransactionServiceFulfillment::addCustomerPhoneNumberToQuery(qbds, customerPhoneNumberParam, methodVersion);
        }

        // Get the store language so we retrieve the product name in the store language if possible, otherwise system language.
        RetailStoreTable retailStore;
        select firstonly CultureName from retailStore
                where retailStore.InventLocation == warehouseId
                && retailStore.inventLocationDataAreaId == retailParamsTable.DataAreaId;

        LanguageId storeLanguage = retailStore.cultureName;

        // Initialize xml return result
        XmlDocument resultDoc = RetailTransactionServiceUtilities::getXmlDocumentForSerializedEntities();
        XmlElement resultRootElement = resultDoc.createElement(ArrayOfFulfillmentLinesElementName);
        resultRootElement.setAttribute('xmlns', RetailTransactionServiceUtilities::getCrtDataModelXmlNamespace());

        XmlDocument resultDocCustomFields = RetailTransactionServiceUtilities::getXmlDocumentForSerializedEntities();
        XmlElement resultRootElementCustomFields = resultDocCustomFields.createElement(ArrayOfCustomFieldsElementName);
        resultRootElementCustomFields.setAttribute('xmlns', RetailTransactionServiceUtilities::getCrtTransactionServiceXmlNamespace());

        // Get paging details
        int startingPosition = DefaultStartingPosition;
        int maxResultCount = DefaultMaxResultCount;
        int resultCounter = 0;
        [startingPosition, maxResultCount] = RetailTransactionServiceTransactions::parsePagingInfo(searchCriteriaXmlDoc);

        QueryRun qr = new QueryRun(query);

        boolean queryAllRecords = maxResultCount == 0;
        if (!queryAllRecords)
        {
            qr.enablePositionPaging(true);
            qr.addPageRange(startingPosition, maxResultCount);
        }

        Map salesOrderMap = new Map(Types::String, Types::Record);
        Map amountMap = new Map(Types::String, Types::Container);
        Map productMap = new Map(Types::String, Types::Int64);
        Map hcmWorkerMap = new Map(Types::Int64, Types::Container);
        Map addressMap = new Map(Types::Int64, Types::Container);
        Map detailedOrderStatusMap = new Map(Types::String, Types::Enum);
        Map channelTypeMap = new Map(Types::Int64, Types::Enum);

        Set uniqueSalesLines = new Set(Types::Container);
        while (qr.next())
        {
            // Counter reaches max result. Stop fetching data.
            if (!queryAllRecords && resultCounter >= maxResultCount)
            {
                break;
            }

            RetailFulfillmentLineViewV2 fulfillmentResult = qr.get(tableNum(RetailFulfillmentLineViewV2));
            if (uniqueSalesLines.In([fulfillmentResult.SalesId, fulfillmentResult.LineNumber]))
            {
                continue;
            }

            uniqueSalesLines.add([fulfillmentResult.SalesId, fulfillmentResult.LineNumber]);
            XmlElement fulfillmentElement = resultDoc.createElement(FulfillmentLineElementName);
            XmlElement fulfillmentCustomFieldsElement = resultDocCustomFields.createElement(FulfillmentLineCustomFieldsElementName);

            RetailFulfillmentLineDeliveryType deliveryType;
            // Get the delivery type.
            if (RetailDlvMode::isPickupDeliveryMode(fulfillmentResult.DeliveryMode))
            {
                deliveryType = RetailFulfillmentLineDeliveryType::StorePickup;
            }
            else
            {
                deliveryType = RetailFulfillmentLineDeliveryType::StoreShipping;
            }

            SalesTable salesTable = RetailTransactionServiceFulfillment::getSalesTable(salesOrderMap, fulfillmentResult.SalesId);

            boolean isOrderTotalAmountCalculationDisabled = RetailTransactionServiceFulfillment::isOrderTotalAmountsCalculationDisabled(fulfillmentResult.SalesId);
            if (!isOrderTotalAmountCalculationDisabled)
            {
                // Get the total amount and balance.
                if (!amountMap.exists(fulfillmentResult.SalesId))
                {
                    SalesTotals salesTotals = SalesTotals::construct(salesTable);
                    salesTotals.calc();

                    real balance;
                    real totalAmount = salesTotals.totalAmount() + salesTable.amountInvoiced();

                    // If sales order is a call center order, calculate balance by fetching prepayment details from MCRCustPaymTable. Otherwise, get prepayment details from RetailPrePaymentTrans.
                    if (salesTable.mcrIsCallCenter())
                    {
                        mcrCustPaymTotals custPaym = mcrCustPaymTotals::construct(salesTable.TableId, salesTable.RecId);
                        balance = totalAmount - custPaym.getTotalPaymAmount();
                    }
                    else
                    {
                        balance = totalAmount - RetailTransactionPaymentsHelper::paymentsMade(fulfillmentResult.SalesId);
                    }

                    amountMap.insert(fulfillmentResult.SalesId, [ balance, totalAmount ]);
                }
            }
            else
            {
                amountMap.insert(fulfillmentResult.SalesId, [ 0, 0 ]);
            }

            // When the feature was enabled in feature management, it triggers a batch job to update the fulfillment status/quantity values
            // for all existing retail sales lines.
            // But just in case someone calls RTS while the job is still running, or the job has failed, we update here as a final effort.
            boolean isPartialEditingFeatureEnabled = RetailAllowPartialOrderEditingFeatureExposure::isEnabledInFeatureManagement();
            SalesLine salesLine = SalesLine::findRecId(fulfillmentResult.SalesLineRefRecId);
            RetailSalesLine retailSalesLine;
            SalesQty qtyNotInvoiced, qtyNotPacked, qtyNotPicked;

            if (isPartialEditingFeatureEnabled && fulfillmentResult.QuantityColumnsVersion == RetailSalesLineQuantityColumnsVersion::V0)
            {
                if (salesLine.isStocked())
                {
                    RetailTransactionServiceFulfillment::updateFulfillmentStatusForStockedItems(salesLine.RecId);

                    // Instead of .reread() we can just grab the values that were updated.
                    select RecId, QuantityNotProcessed, QuantityPhysicallyReserved, QuantityPicked, QuantityPacked, QuantityInvoiced
                        from retailSalesLine
                        where retailSalesLine.SalesLine == salesLine.RecId;

                    fulfillmentResult.QuantityNotProcessed = retailSalesLine.QuantityNotProcessed;
                    fulfillmentResult.QuantityPhysicallyReserved = retailSalesLine.QuantityPhysicallyReserved;
                    fulfillmentResult.QuantityPicked = retailSalesLine.QuantityPicked;
                    fulfillmentResult.QuantityPacked = retailSalesLine.QuantityPacked;
                    fulfillmentResult.QuantityInvoiced = retailSalesLine.QuantityInvoiced;
                    qtyNotInvoiced = fulfillmentResult.QuantityOrdered - fulfillmentResult.QuantityInvoiced;
                    qtyNotPacked = qtyNotInvoiced - fulfillmentResult.QuantityPacked;
                    qtyNotPicked = qtyNotInvoiced - fulfillmentResult.QuantityPacked - fulfillmentResult.QuantityPicked;

                    eventSource.EventWriteRetailSalesLineUpdateQuantitiesOnDemand(retailSalesLine.RecId);
                }
            }

            if (RetailFulfillmentQuantitiesInSalesUomFlight::instance().isEnabled())
            {
                if (!retailSalesLine.RecId)
                {
                    // Instead of .reread() we can just grab the values that were updated.
                    select RecId, QuantityNotProcessed, QuantityPhysicallyReserved, QuantityPicked, QuantityPacked, QuantityInvoiced
                        from retailSalesLine
                        where retailSalesLine.SalesLine == salesLine.RecId;
                }

                fulfillmentResult.QuantityNotProcessed = retailSalesLine.getQuantityNotProcessedInSalesUnit(salesLine);
                fulfillmentResult.QuantityPhysicallyReserved = retailSalesLine.getQuantityPhysicallyReservedInSalesUnit(salesLine);
                fulfillmentResult.QuantityPicked = retailSalesLine.getQuantityPickedInSalesUnit(salesLine);
                fulfillmentResult.QuantityPacked = retailSalesLine.getQuantityPackedInSalesUnit (salesLine);
                fulfillmentResult.QuantityInvoiced = retailSalesLine.getQuantityInvoicedInSalesUnit(salesLine);
                qtyNotInvoiced = fulfillmentResult.QuantityOrdered - fulfillmentResult.QuantityInvoiced;
                qtyNotPacked = qtyNotInvoiced - fulfillmentResult.QuantityPacked;
                qtyNotPicked = qtyNotInvoiced - fulfillmentResult.QuantityPacked - fulfillmentResult.QuantityPicked;
            }

            InventDim inventDim = InventDim::find(fulfillmentResult.InventDimId);

            // Add element result - Element name must be sorted alphabetically.
            // DataContractSerializer requires fields to be ordered. 
            // See https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/data-member-order
            RetailTransactionServiceFulfillment::addDecimalAmountElementResult(resultDoc, fulfillmentElement, BalanceElementName, conPeek(amountMap.lookup(fulfillmentResult.SalesId), 1));
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, ChannelReferenceIdElementName, fulfillmentResult.ChannelReferenceId);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, ChannelTypeElementName, int2Str(enum2int(RetailTransactionServiceFulfillment::getChannelType(channelTypeMap, salesTable.RetailChannelTable))));
            RetailTransactionServiceFulfillment::addDateElementResult(resultDoc, fulfillmentElement, CreatedDateElementName, fulfillmentResult.CreatedDate);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, CustomerIdElementName, fulfillmentResult.CustomerId);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, CustomerNameElementName, fulfillmentResult.CustomerName);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, DeliveryModeCodeElementName, fulfillmentResult.DeliveryMode);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, DeliveryTypeElementName, int2Str(enum2int(deliveryType)));

            if (RetailAllowPartialOrderEditingFeatureExposure::isEnabledInFeatureManagement())
            {
                RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, DetailedLineStatusElementName, int2Str(enum2int(RetailDetailedOrderInfoHelper::getDetailedLineStatus(SalesLine::find(fulfillmentResult.SalesId, fulfillmentResult.LineNumber, false)))));
                RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, DetailedOrderStatusElementName, int2Str(enum2int(RetailTransactionServiceFulfillment::getDetailedOrderStatus(detailedOrderStatusMap, salesTable))));
            }

            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, DocumentStatusElementName, int2Str(any2Int(salesTable.DocumentStatus)));
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, EmailAddressElementName, fulfillmentResult.EmailAddress);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, FulfillmentStatusElementName, int2Str(any2Int(fulfillmentResult.FulfillmentStatus)));
            RetailTransactionServiceFulfillment::addBooleanElementResult(resultDoc, fulfillmentElement, IsOrderTotalIncludedElementName, !isOrderTotalAmountCalculationDisabled);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, ItemIdElementName, fulfillmentResult.ItemId);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, ItemNameElementName, RetailTransactionServiceFulfillment::getProductNameForFulfillmentLine(fulfillmentResult.ItemId, fulfillmentResult.InventDimId, fulfillmentResult.ItemDescription, storeLanguage));

            if (fulfillmentResult.PickupEndTime > 0)
            {
                RetailTransactionServiceFulfillment::addDateElementResult(resultDoc, fulfillmentElement, PickupTimeslotEndDateTimeElementName, DateTimeUtil::newDateTime(fulfillmentResult.RequestedDeliveryDate, fulfillmentResult.PickupEndTime));
                RetailTransactionServiceFulfillment::addDateElementResult(resultDoc, fulfillmentElement, PickupTimeslotStartDateTimeElementName, DateTimeUtil::newDateTime(fulfillmentResult.RequestedDeliveryDate, fulfillmentResult.PickupStartTime));
            }

            EcoResProductRecId productId = RetailTransactionServiceInventory::getProductRecordIdByDimensions(productMap, fulfillmentResult.ItemId, curExt(), inventDim.InventColorId, inventDim.configId, inventDim.InventSizeId, inventDim.InventStyleId, inventDim.InventVersionId);
            str productVariant = EcoResProduct::find(productId).DisplayProductNumber;

            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, ProductIdElementName, int642Str(productId));
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, ProductVariantElementName, productVariant);
            RetailTransactionServiceFulfillment::addDecimalElementResult(resultDoc, fulfillmentElement, QuantityInvoicedElementName, fulfillmentResult.QuantityInvoiced);
            RetailTransactionServiceFulfillment::addDecimalElementResult(resultDoc, fulfillmentElement, QuantityNotInvoicedElementName, qtyNotInvoiced);
            RetailTransactionServiceFulfillment::addDecimalElementResult(resultDoc, fulfillmentElement, QuantityNotPackedElementName, QtyNotPacked);
            RetailTransactionServiceFulfillment::addDecimalElementResult(resultDoc, fulfillmentElement, QuantityNotPickedElementName, QtyNotPicked);

            if (isPartialEditingFeatureEnabled)
            {
                RetailTransactionServiceFulfillment::addDecimalElementResult(resultDoc, fulfillmentElement, QuantityNotProcessedElementName, fulfillmentResult.QuantityNotProcessed);
            }
            
            RetailTransactionServiceFulfillment::addDecimalElementResult(resultDoc, fulfillmentElement, QuantityOrderedElementName, fulfillmentResult.QuantityOrdered);
            RetailTransactionServiceFulfillment::addDecimalElementResult(resultDoc, fulfillmentElement, QuantityPackedElementName, fulfillmentResult.QuantityPacked);
            RetailTransactionServiceFulfillment::addDecimalElementResult(resultDoc, fulfillmentElement, QuantityPickedElementName, fulfillmentResult.QuantityPicked);

            if (isPartialEditingFeatureEnabled)
            {
                RetailTransactionServiceFulfillment::addDecimalElementResult(resultDoc, fulfillmentElement, QuantityReservedElementName, fulfillmentResult.QuantityPhysicallyReserved);
            }

            str receiptIdResult = fulfillmentResult.ReceiptId ? fulfillmentResult.ReceiptId : fulfillmentResult.ChannelReferenceId;
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, ReceiptIdElementName, receiptIdResult);
            RetailTransactionServiceFulfillment::addDateElementResult(resultDoc, fulfillmentElement, RequestedDeliveryDateElementName, DateTimeUtil::newDateTime(fulfillmentResult.RequestedDeliveryDate, 0));
            RetailTransactionServiceFulfillment::addDateElementResult(resultDoc, fulfillmentElement, RequestedReceiptDateElementName, DateTimeUtil::newDateTime(fulfillmentResult.RequestedReceiptDate, 0));
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, RetailVariantIdElementName, fulfillmentResult.RetailVariantId);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, SalesIdElementName, fulfillmentResult.SalesId);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, SalesLineNumberElementName, RetailTransactionServiceUtilities::lineNumToString(fulfillmentResult.LineNumber));

            HcmWorker hcmWorker;
            DirPersonName dirPersonName;
            [hcmWorker, dirPersonName] = RetailTransactionServiceFulfillment::getHCMWorkerDetails(hcmWorkerMap, salesTable.WorkerSalesTaker);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, SalesPersonFirstNameElementName, dirPersonName.FirstName);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, SalesPersonIdElementName, hcmWorker.PersonnelNumber);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, SalesPersonLastNameElementName, dirPersonName.LastName);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, SalesPersonStoreIdElementName, fulfillmentResult.StoreNumber);

            if (RetailOrderSerialNumberValidationFeatureExposure::isEnabled())
            {
                RetailTransactionServiceFulfillment::fillXmlWithSerialId(resultDoc, fulfillmentElement, fulfillmentResult.ItemId, fulfillmentResult.InventTransId, fulfillmentResult.InventDimId);
            }

            XmlElement addressElement = resultDoc.createElement(ShippingAddressElementName);
            addressElement.setAttribute('xmlns', RetailTransactionServiceUtilities::getCrtDataModelXmlNamespace());

            LogisticsPostalAddress logisticsPostalAddress;
            LogisticsAddressState logisticsAddressState;
            LogisticsAddressCounty logisticsAddressCounty;

            [logisticsPostalAddress, LogisticsAddressState, logisticsAddressCounty] = RetailTransactionServiceFulfillment::getLogisticsPostalAddressDetails(addressMap, fulfillmentResult.DeliveryPostalAddress);

            // Elements must be added in alphabetical order.
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, addressElement, BuildingComplimentElementName, logisticsPostalAddress.BuildingCompliment);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, addressElement, CityElementName, logisticsPostalAddress.City);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, addressElement, CountyElementName, logisticsPostalAddress.County);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, addressElement, CountyNameElementName, logisticsAddressCounty.Name);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, addressElement, DistrictNameElementName, logisticsPostalAddress.DistrictName);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, addressElement, FullAddressElementName, logisticsPostalAddress.Address);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, addressElement, PostboxElementName, logisticsPostalAddress.Postbox);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, addressElement, StateElementName, logisticsPostalAddress.State);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, addressElement, StateNameElementName, logisticsAddressState.Name);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, addressElement, StreetElementName, logisticsPostalAddress.Street);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, addressElement, StreetNumberElementName, logisticsPostalAddress.StreetNumber);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, addressElement, CountryRegionElementName, logisticsPostalAddress.CountryRegionId);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, addressElement, ZipCodeElementName, logisticsPostalAddress.ZipCode);
            fulfillmentElement.appendChild(addressElement);

            InventOnHandByWarehouse inventOnHand;
            real localOrderedSum = 0;
            real localReservPhysical = 0;
            real localAvailPhysical = 0;
            select firstonly ReservPhysical, AvailPhysical, OrderedSum from inventOnHand
                    where inventOnHand.ItemId == fulfillmentResult.ItemId
                        && inventOnHand.InventSiteId == inventDim.InventSiteId
                        && inventOnHand.InventLocationId == fulfillmentResult.InventLocationId
                        && inventOnHand.InventSizeId == inventDim.InventSizeId
                        && inventOnHand.InventColorId == inventDim.InventColorId
                        && inventOnHand.InventStyleId == inventDim.InventStyleId
                        && inventOnHand.configId == inventDim.configId;

            if (inventOnHand)
            {
                localOrderedSum = inventOnHand.OrderedSum;
                localReservPhysical = inventOnHand.ReservPhysical;
                localAvailPhysical = inventOnHand.AvailPhysical;
            }

            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, StoreNumberElementName, fulfillmentResult.StoreNumber);
            RetailTransactionServiceFulfillment::addDecimalElementResult(resultDoc, fulfillmentElement, StoreInventoryOrderedQuantityElementName, localOrderedSum);
            RetailTransactionServiceFulfillment::addDecimalElementResult(resultDoc, fulfillmentElement, StoreInventoryReservedQuantityElementName, localReservPhysical);
            RetailTransactionServiceFulfillment::addDecimalElementResult(resultDoc, fulfillmentElement, StoreInventoryTotalQuantityElementName, localAvailPhysical);
            RetailTransactionServiceFulfillment::addDecimalAmountElementResult(resultDoc, fulfillmentElement, TotalAmountElementName, conPeek(amountMap.lookup(fulfillmentResult.SalesId), 2));
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, UnitOfMeasureSymbolElementName, fulfillmentResult.SalesUnitOfMeasure);
            RetailTransactionServiceFulfillment::addElementStrResult(resultDoc, fulfillmentElement, WarehouseIdElementName, fulfillmentResult.InventLocationId);

            RetailTransactionServiceFulfillment::addFulfillmentLineCustomFields(resultDocCustomFields, fulfillmentCustomFieldsElement, fulfillmentResult);

            resultRootElement.appendChild(fulfillmentElement);
            resultRootElementCustomFields.appendChild(fulfillmentCustomFieldsElement);
            resultCounter++;
        }

        resultDoc.appendChild(resultRootElement);
        resultDocCustomFields.appendChild(resultRootElementCustomFields);

        return [true, '', resultDoc.toString(), resultDocCustomFields.toString()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillXmlWithSerialId</Name>
				<Source><![CDATA[
    private static void fillXmlWithSerialId(XmlDocument _resultDoc, XmlElement _fulfillmentElement, str _itemId, str _inventTransId, str _inventDimId)
    {
        InventTable inventTable = InventTable::find(_itemId);
        InventDim inventDim;
        if (inventTable.isActiveInSalesProcess())
        {
            InventTransOrigin inventTransOrigin;
            InventTrackingRegisterTrans inventTrackingRegisterTrans;
            select firstonly InventSerialId from inventDim
            join inventTrackingRegisterTrans
            where inventTrackingRegisterTrans.InventDimId == inventDim.inventDimId
            join inventTransOrigin
            where inventTransOrigin.RecId == inventTrackingRegisterTrans.InventTransOrigin
                && inventTransOrigin.InventTransId == _inventTransId;
        }
        else
        {
            inventDim = InventDim::find(_inventDimId);
        }
        
        if (inventDim)
        {
            RetailTransactionServiceFulfillment::addElementStrResult(_resultDoc, _fulfillmentElement, SerialNumberElementName, inventDim.inventSerialId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSerialId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the serial identifier of the item in the given sales line.
    /// </summary>
    /// <param name = "_salesLine">The given sales line.</param>
    /// <param name = "_retailSalesLine">The given retail sales line.</param>
    /// <param name = "_serialId">The serial identifier.</param>
    private static str updateSerialId(SalesLine _salesLine, RetailSalesLine _retailSalesLine, str _serialId)
    {
        if (!_serialId)
        {
            return '';
        }

        InventDim inventDim;
        InventTransOrigin inventTransOrigin;

        InventTable inventTable = InventTable::find(_salesLine.ItemId);
        if (inventTable.RecId == 0)
        {
            return '';
        }

        if (inventTable.isSalesProcessSerialActive())
        {
            inventTransOrigin = InventTransOrigin::findByInventTransId(_salesLine.InventTransId);

            InventTrackingRegisterTrans inventTrackingRegisterTrans, inventTrackingRegisterTransToUpdate;
            select firstonly inventTrackingRegisterTrans
                where inventTrackingRegisterTrans.InventTransOrigin == inventTransOrigin.RecId;

            if (inventTrackingRegisterTrans)
            {
                inventDim = InventDim::find(inventTrackingRegisterTrans.InventDimId);
                inventDim.inventSerialId = _serialId;
                inventDim = InventDim::findOrCreate(inventDim);

                update_recordset inventTrackingRegisterTransToUpdate
                    setting InventDimId = inventDim.inventDimId
                    where inventTrackingRegisterTransToUpdate.RecId == inventTrackingRegisterTrans.RecId;
            }
            else
            {
                InventMovement inventMovement = InventMovement::construct(_salesLine, InventMovSubType::None, null);
                if (inventMovement.mustRegisterTrackingDimension())
                {
                    inventDim = InventDim::find(_salesLine.InventDimId);
                    inventDim.inventSerialId = _serialId;
                    InventTrackingRegisterUpdate::newFromMovement(inventMovement).registerTrackingDimension(inventDim, inventMovement.transQty());
                }
            }
        }
        else if (inventTable.isItemSerialNumberActivated())
        {
            inventDim = InventDim::find(_salesLine.InventDimId);

            if (_retailSalesLine.FulfillmentStatus == RetailFulfillmentLineStatus::Picked
                && inventDim.inventSerialId != _serialId)
            {
                return '@Retail:CannotUpdateSerialNumberOfLineOfPicked';
            }

            inventDim.inventSerialId = _serialId;
            inventDim = InventDim::findOrCreate(inventDim);

            _salesLine.selectForUpdate(true);
            ttsbegin;
            _salesLine.InventDimId = inventDim.InventDimId;
            _salesLine.update();
            ttscommit;
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesTable</Name>
				<Source><![CDATA[
    private static SalesTable getSalesTable(Map _cache, SalesId _salesId)
    {
        if (_cache.exists(_salesId))
        {
            return _cache.lookup(_salesId);
        }

        SalesTable salesTable = SalesTable::find(_salesId);
        _cache.insert(_salesId, salesTable);

        return salesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getHCMWorkerDetails</Name>
				<Source><![CDATA[
    private static container getHCMWorkerDetails(Map _cache, RecId _hcmWorkerRecId)
    {
        if (_cache.exists(_hcmWorkerRecId))
        {
            return _cache.lookup(_hcmWorkerRecId);
        }

        HcmWorker hcmWorker = HcmWorker::find(_hcmWorkerRecId);
        DirPersonName dirPersonName;
        if (hcmWorker)
        {
            dirPersonName = DirPersonName::find(hcmWorker.Person);
        }

        container ret = [hcmWorker, dirPersonName];
        _cache.insert(_hcmWorkerRecId, ret);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLogisticsPostalAddressDetails</Name>
				<Source><![CDATA[
    private static container getLogisticsPostalAddressDetails(Map _cache, RecId _logisticsPostalAddressRecId)
    {
        if (_cache.exists(_logisticsPostalAddressRecId))
        {
            return _cache.lookup(_logisticsPostalAddressRecId);
        }

        LogisticsPostalAddress postalAddress = LogisticsPostalAddress::findRecId(_logisticsPostalAddressRecId);

        LogisticsAddressState state;
        select firstonly state
            where state.CountryRegionId == postalAddress.CountryRegionId
            && state.StateId == postalAddress.State;

        LogisticsAddressCounty county;
        select firstonly county
            where county.CountryRegionId == postalAddress.CountryRegionId
            && county.StateId == postalAddress.State
            && county.CountyId == postalAddress.County;

        container ret = [postalAddress, state, county];
        _cache.insert(_logisticsPostalAddressRecId, ret);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDetailedOrderStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the detailed status for a sales order.
    /// </summary>
    /// <param name = "_cache">The detailed order status cache.</param>
    /// <param name = "_salesId">The SalesId on the order.</param>
    /// <returns>Detailed order status.</returns>
    private static MCRSalesOrderDetailedStatus getDetailedOrderStatus(Map _cache, SalesTable _salesTable)
    {
        SalesId salesId = _salesTable.SalesId;

        if (_cache.exists(salesId))
        {
            return _cache.lookup(salesId);
        }

        MCRSalesOrderDetailedStatus detailedOrderStatus = MCRSalesDetailedStatus::salesOrderDetailedStatus(_salesTable);
        _cache.insert(salesId, detailedOrderStatus);

        return detailedOrderStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChannelType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the channel type for a fulfillment line.
    /// </summary>
    /// <param name = "_cache">The channel type cache.</param>
    /// <param name = "_retailChannelId">RecId of RetailChannelTable.</param>
    /// <returns>Channel type.</returns>
    private static RetailChannelType getChannelType(Map _cache, RecId _retailChannelId)
    {
        if (_cache.exists(_retailChannelId))
        {
            return _cache.lookup(_retailChannelId);
        }

        RetailChannelTable retailChannelTable = RetailChannelTable::findByRecId(_retailChannelId);
        _cache.insert(_retailChannelId, retailChannelTable.ChannelType);

        return retailChannelTable.ChannelType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFulfillmentLinesCustomFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Gets fulfillment line custom fields.
    /// </summary>
    /// <param name = "_line">The fulfillment line view.</param>
    public static Map getFulfillmentLinesCustomFields(RetailFulfillmentLineViewV2 _line)
    {
        return new Map(Types::String,Types::String);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFulfillmentLineCustomFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Add custom fields to xml element.
    /// </summary>
    /// <param name = "_resultDoc">The xml document.</param>
    /// <param name = "_parentElement">The parent element.</param>
    /// <param name = "_line">The fulfillment line view.</param>
    private static void addFulfillmentLineCustomFields(XmlDocument _resultDoc, XmlElement _parentElement, RetailFulfillmentLineViewV2 _line)
    {
        eventSource.EventWriteFulFillmentProcessStart(funcName());

        XmlElement customFieldsElement = _resultDoc.createElement(CustomFieldsElementName);

        var fields = RetailTransactionServiceFulfillment::getFulfillmentLinesCustomFields(_line);
        var iterator = new MapIterator (fields);

        int fieldsCount = 0;
        while (iterator.more())
        {
            RetailTransactionServiceFulfillment::addFulfillmentLineCustomField(_resultDoc, customFieldsElement, iterator.key(), iterator.value());
            iterator.next();
            fieldsCount++;
        }

        eventSource.EventWriteFulfillmentLineTotalCountOfCustomFields(_line.RecId, fieldsCount);

        _parentElement.appendChild(customFieldsElement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFulfillmentLineCustomField</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Add custom field.
    /// </summary>
    /// <param name = "_resultDoc">The xml document.</param>
    /// <param name = "_customFieldsElement">The additional properties element.</param>
    /// <param name = "_name">The name of property.</param>
    /// <param name = "_stringValue">The string value of property.</param>
    private static void addFulfillmentLineCustomField(XmlDocument _resultDoc, XmlElement _customFieldsElement, str _name, str _stringValue)
    {
        XmlElement nameValuePairElement = _resultDoc.createElement(NameValuePairElementName);
        nameValuePairElement.setAttribute('xmlns', RetailTransactionServiceUtilities::getCrtDataModelXmlNamespace());
        XmlElement nameElement = _resultDoc.createElement(NameElementName);
        XmlElement valueElement = _resultDoc.createElement(ValueElementName);

        // add name element.
        nameElement.innerText(_name);
        nameValuePairElement.appendChild(nameElement);

        // add value element.
        valueElement.innerText(_stringValue);
        nameValuePairElement.appendChild(valueElement);

        _customFieldsElement.appendChild(nameValuePairElement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addExtensionFieldRangeValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the extension fields range values.
    /// </summary>
    private static void addExtensionFieldRangeValue(QueryBuildDataSource _qbds, List _extensionRanges)
    {
        ListEnumerator extensionRangeEnumerator = _extensionRanges.getEnumerator();
        while (extensionRangeEnumerator.moveNext())
        {
            str extensionFieldName;
            str extensionFieldValue;

            [extensionFieldName, extensionFieldValue] = extensionRangeEnumerator.current();
            int extensionFieldId = fieldName2Id(_qbds.table(), extensionFieldName);
            if (extensionFieldId)
            {
                _qbds.addRange(extensionFieldId).value(extensionFieldValue);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerGetFulfillmentLinesCustomDataSources</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to add custom data sources and filters to the search journal query.
    /// </summary>
    /// <param name = "customFiltersXmlElement">The XML element of custom filters and datasources.</param>
    /// <param name = "qbds">The search journal query QueryBuildDataSource object that can be used for adding custom datasources and filters</param>
    static delegate void registerGetFulfillmentLinesCustomDataSources(XmlElement customFiltersXmlElement, QueryBuildDataSource qbds)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeMarkFulfillmentLineAsPackedCustomValidation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides chain of command extensibility point for partners to execute custom validations.
    /// </summary>
    /// <param name = "request">The request.</param>
    /// <returns>The response.</returns>
    protected static RetailTransactionServiceFulfillmentMarkAsPackedCustomValidationResponse executeMarkFulfillmentLineAsPackedCustomValidation(RetailTransactionServiceFulfillmentMarkAsPackedCustomValidationRequest request)
    {
        var response = RetailTransactionServiceFulfillmentMarkAsPackedCustomValidationResponse::construct();
        response.isSuccessful = true;
        response.errorMessage = '';
        return response;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeUpdateFulfillmentLineStatusCustomValidation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides chain of command extensibility point for partners to execute custom validations.
    /// </summary>
    /// <param name = "request">The request.</param>
    /// <returns>The response.</returns>
    protected static RetailTransactionServiceFulfillmentUpdateLineStatusCustomValidationResponse executeUpdateFulfillmentLineStatusCustomValidation(RetailTransactionServiceFulfillmentUpdateLineStatusCustomValidationRequest request)
    {
        var response = RetailTransactionServiceFulfillmentUpdateLineStatusCustomValidationResponse::construct();
        response.isSuccessful = true;
        response.errorMessage = '';
        return response;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>