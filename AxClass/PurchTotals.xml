<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PurchTotals</Name>
	<SourceCode>
		<Declaration><![CDATA[
abstract class PurchTotals extends TradeTotalsBase implements PaymCalendarIDerivationSource, PaymCalendarIBankAddress
{
    RecordSortedList    recordListPurchLine;
    RecordSortedList    recordListParmLine;

    PurchTable          purchTable;
    PurchLine           purchLine;

    PurchUpdate         specQty;
    CurrencyCode        currency;
    CurrencyCode        salesTaxCurrency_BR;

    container           cachedCalculationParameters;
    boolean             calculationCached;
    boolean             enableCaching;

    // InventTable is used for item weight/volume retrieval.
    InventTable         inventTable;
    InventDimId         inventDimId;
    PurchQty            qty;
    PdsCWInventQty      pdsCWQty;
    Weight              weight;
    Volume              volume;

    CostAmount          costValue;
    VendCreditFreeValueMST  freeValue;

    DiscAmount          lineDisc;
    DiscAmount          endDisc;
    DiscAmount          calculatedEndDisc;
    DiscAmount          cashDisc;
    DiscDate            cashDiscDate;

    AmountCur           balance;
    Map                 orderBalances;
    Map                 endDiscBalances;
    AmountCur           roundOff;
    MarkupAmount        markupAmount;
    TaxAmountCur        taxTotal;
    AmountCur           totalAmount;
    AmountCur           useTax;
    MarkupAmount        otherMiscCharges;

    TaxPurch            tax;

    AmountCur           totalCashDisc;
    boolean             onlyOneCashDiscOnInvoice;
    boolean             keepEndDisc;
    boolean             isCreditNote;
    boolean             isCreditNoteCalculated;
    internal protected boolean isCalculationComplete;

    // A Boolean value indicating whether pending invoices should be excluded.
    boolean             excludePendingInvoices;

    // <GEERU>
    boolean             checkAgreementLimit;
    MarkupAmount        markupLineAmount;
    Map                 markupLineDetails;
    MarkupAmount        markupAmountItem;
    // </GEERU>
    // <GIN>
    TaxAmountCur        vatAmount;
    TaxWithhold_IN      taxWithhold;
    AmountCur           withholdingTaxAmount;
    AmountCur           taxWithholdAmount;
    str                 formName;
    TaxAmountCur        totalInclTaxAmount;
    TaxWithholdCalculation_IN   taxWithholdCalculation;
    // </GIN>
    // <GBR>
    Weight                              grossWeight;
    AmountCur                           totalServicesAmountCur;
    AmountMST                           totalServicesAmountMST;
    AmountCur                           totalProductsAmountCur;
    AmountMST                           totalProductsAmountMST;
    AmountCur                           vendTransAmountCur;
    MarkupAmount                        markupFreightAmountMST;
    MarkupAmount                        markupInsuranceAmountMST;
    MarkupAmount                        markupSiscomexAmountMST;
    MarkupAmount                        markupOthersAmountMST;
    MarkupAmount                        markupTotalAmountMST;
    MarkupAmount                        markupTotalAmountCur;
    PurchImportDeclarationTotals_BR     importDeclarationTotals;

    // Instrumentation
    protected int64   runTimeCalcTotals;
    protected int64   runTimeCalcTaxTotals;
    protected int64   runTimeCalcMarkupTotals;
    protected int64   runTimeCalcDiscountTotals;
    protected int     numberOfPurchLines;
    protected int     numberOfPurchTaxLines;
    protected int     numberOfMarkupTrans;

    const int posICMSTotal_BR         = 24;
    const int posIPITotal_BR          = 25;
    const int posCOFINSTotal_BR       = 26;
    const int posPISTotal_BR          = 27;
    const int posImportTaxTotal_BR    = 28;
    const int posIRRFTotal_BR         = 29;
    const int posINSSTotal_BR         = 30;
    const int posISSTotal_BR          = 31;
    const int posMarkupFreight_BR     = 32;
    const int posMarkupInsurance_BR   = 33;
    const int posMarkupSiscomex_BR    = 34;
    const int posMarkupOther_BR       = 35;
    const int posCSLLTotal_BR         = 36;
    const int posRetainedINSSTotal_BR = 37;
    const int posTotalMarkup_BR       = 38;
    const int posICMSDiffTotal_BR     = 39;
    const int posSalesTaxCurrency_BR  = 40;
    const int posICMSSTTotal_BR       = 41;
    // </GBR>

    TaxWithholdAmountCur    taxWithholdTotal;

    boolean             canApplyCashDiscOnInvoice_ES;

    Map                 displayFieldsMethodMap; // key = Integer; value = methodStr(PurchTotals, <methodName>)
    DictClass           dictClassPurchTotals;
    PurchQuantity       purchQuantityStatusNoneCached;
    Map                 inventTableModuleCached;
    boolean             skipPurchLineSortedList;
    boolean             excludePurchLineMarkup;
    boolean             updateTotalsSummary;
    AmountCur           preAppliedAmount;
    AmountCur           newTotalAmount;

    // <GTE>
    TaxAmountCur        taxTotalGTE;
    TaxAmountCur        taxTotalReverseCharge;
    // </GTE>

    boolean loadFromTaxUncommitted;
    boolean loadFromTaxTrans;
    RecId   sourceDocumentHeaderRecId;
    boolean isSalesTaxDetailNotNeeded;

    internal TaxWithholdCalculation taxWithholdCalc;
    internal protected boolean doCalculateGWHTChargesCode;
    internal protected boolean isWHTCalcNeeded;

    private PurchInstrumentationLogger instrumentationLogger;
    private LedgerParameters ledgerParameters;
    private MarkupAmount markupGWHTaxAmount;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addMarkupLineDetails_RU</Name>
				<Source><![CDATA[
    protected void addMarkupLineDetails_RU(PurchLine _purchLine, MarkupAmount _markupAmount)
    {
        VendPostingProfile  postingProfile;
        MarkupAmount        markupAmountTmp;
        PurchLine_W         purchLine_W = _purchLine.purchLine_W();

        postingProfile = purchLine_W.PostingProfile_RU ? purchLine_W.PostingProfile_RU : purchTable.PostingProfile;

        markupAmountTmp = 0;
        if (markupLineDetails.exists([postingProfile, _purchLine.inventProfileType_RU()]))
        {
            markupAmountTmp = markupLineDetails.lookup([postingProfile, _purchLine.inventProfileType_RU()]);
        }
        markupLineDetails.insert([postingProfile, _purchLine.inventProfileType_RU()], _markupAmount + markupAmountTmp);
        markupLineAmount += _markupAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEdit</Name>
				<Source><![CDATA[
    boolean allowEdit()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Method calculating totals values.
    /// </summary>
    /// <param name="_excludePendingInvoices">
    ///     true if pending invoice amounts should be excluded, otherwise false; optional.
    /// </param>
    /// <param name="_delayTaxCalc">
    ///     true if tax calculation should be delayed, otherwise false; optional.
    /// </param>
    /// <param name="_taxesOnly">
    ///     true if calculation should include tax only, otherwise false; optional.
    /// </param>
    void calc(boolean _excludePendingInvoices = false, boolean _delayTaxCalc = false, boolean _taxesOnly = false)
    {
        #ISOCountryRegionCodes
        QueryRun            queryTransact;
        QueryRun            queryPurchTableMarkup;
        Markup              markup;
        PurchCalcTax        purchCalcTax;

        VendTable           vendTable;
        PurchTable          purchTableMarkup;

        PurchQty            purchQty;

        PdsCWInventQty      pdsCWPurchQty;

        InventQty           inventQty;
        AmountCur           lineAmount;
        AmountCur           roundedOffTotalAmount;

        // <GEERU>
        #ISOCountryRegionCodes
        boolean             countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        InventTableModule   inventTableModule;
        TransDate           purchCalcTaxInvoiceDate;

        // GWHT telemetry
        int64 runTimeCalcTaxWithholdTotal;
        int64 numberOfPurchLinesInWhichTaxWithholdTotal;
        TradeInstrumentationStopWatch stopWatchTaxWithholdTotal;
        boolean isGWHTaxEnabled = TaxWithholdingGlobalFeature::isExtendedWHTSupportedInCountryRegionOrParamEnabled();
        boolean isCalcWHTInInvoiceEnabled = TaxWithholdingGlobalFeature::isCalcWHTInInvoiceEnabled() && isWHTCalcNeeded;

        // See if calculation has already been completed and cached
        if (this.checkForCache([_excludePendingInvoices, _delayTaxCalc]))
        {
            return;
        }

        TradeInstrumentationStopWatch stopWatch = TradeInstrumentationStopwatch::newStopwatch();

        this.clear();

        excludePendingInvoices  = _excludePendingInvoices;
        excludePurchLineMarkup  = !this.lineMarkupTransExist();

        currency    = purchTable.CurrencyCode;
        markup      = new Markup(currency);
        markup.parmExchRate(this.exchRate(), this.exchRateSecondary(), Currency::noYes2UnknownNoYes(this.triangulation()));
        markup.transDate(this.invoiceDate());
        markup.parmMarkupEnumerable(this.parmEnumerableFactory().createMarkupEnumerableProvider());

        if (BrazilParameters::isEnabled())
        {
            salesTaxCurrency_BR = Ledger::accountingCurrency(CompanyInfo::current());
        }

        purchCalcTax = this.constructPurchCalcTax();
        purchCalcTax.transferEnumerableFactory(this.parmEnumerableFactory());
        purchCalcTax.parmSkipLineMarkup(excludePurchLineMarkup);

        if (!_delayTaxCalc)
        {
            this.calcTax(purchCalcTax);

            if (_taxesOnly)
            {
                // Quick exit if the caller only wanted to calculate/generate taxes
                return;
            }
        }

        vendTable = purchTable.vendTable_InvoiceAccount();

        if (isGWHTaxEnabled && !_delayTaxCalc)
        {
            if (isCalcWHTInInvoiceEnabled)
            {
                taxWithholdCalc = TaxWithholdCalcPurch::construct(purchCalcTax);
            }

            doCalculateGWHTChargesCode = this.doCalculateGWHTChargesCode(vendTable);

            if (doCalculateGWHTChargesCode)
            {
                if (isCalcWHTInInvoiceEnabled)
                {
                    markup.parmTaxWithholdCalculation(taxWithholdCalc);
                }

                markup.setTax(purchCalcTax.tax());
                markup.parmDoCalculateGWHTChargeCodes(true);
                markup.parmOrderTaxWithholdGroup(vendTable.TaxWithholdGroup);
            }
        }

        // <GIN>
        if (TaxWithholdParameters_IN::checkTaxParameters() && vendTable.TaxWithholdCalculate
            && !_delayTaxCalc)
        {
            this.calcWithholdTax_IN(purchCalcTax);
        }
        // </GIN>

        queryTransact = this.queryBuild();
        purchCalcTaxInvoiceDate = purchCalcTax.invoiceDate();

        while (queryTransact.next())
        {
            purchLine = this.queryGet(queryTransact);
            if (!purchLine)
            {
                continue;
            }
            using (var activityContext = instrumentationLogger.purchTotalsActivities().calc())
            {
                numberOfPurchLines++;

                if (!skipPurchLineSortedList)
                {
                    recordListPurchLine.ins(purchLine);
                }

                purchQty        = this.qtyPurch();

                // Initialize inventtable for item based lines.
                if (this.isCategoryBased())
                {
                    inventTable = null;
                }
                else
                {
                    inventTable = InventTable::find(purchLine.ItemId);
                }
                // calculate the qty in inventory units (can use inventTable for conversion)
                inventQty       = this.qtyInventoryUnits(purchQty);

                pdsCWPurchQty = 0;

                if (PdsGlobal::pdsIsCWItem(purchLine.ItemId))
                {
                    pdsCWPurchQty   = this.pdsCWQtyPurch (purchLine);
                }

                this.updateQuantities(purchQty, inventQty, pdsCWPurchQty);

                lineAmount       = this.lineAmount(purchQty, purchCalcTaxInvoiceDate);

                this.updateOrderBalances(lineAmount);
                costValue       += CurrencyExchangeHelper::amount(purchQty * purchLine.getEffectiveLinePrice(), '');

                TradeInstrumentationStopWatch stopWatchLineDiscount = TradeInstrumentationStopwatch::newStopwatch();
                if (this.discPercent() && this.lineEndDisc())
                {
                    this.updateEndDiscBalances(lineAmount);
                }

                if (purchLine.PurchPrice && this.purchLineHasDiscount())
                {
                    lineDisc += purchLine.calcLineDiscExclTax(purchQty, purchCalcTaxInvoiceDate, tax);
                }
                runTimeCalcDiscountTotals += stopWatchLineDiscount.elapsedMilliseconds();

                if (!excludePurchLineMarkup)
                {
                    this.markupCalc(markup,
                        purchQty,
                        lineAmount,
                        purchLine,
                        DocumentStatus::Invoice,
                        this.interCompanyLineAmount(purchLine, purchQty, purchCalcTaxInvoiceDate));
                }

                // <GEERU>
                if (countryRegion_RU)
                {
                    this.addMarkupLineDetails_RU(purchLine, -markup.markupCustVend());
                }
                // </GEERU>

                numberOfPurchLinesInWhichTaxWithholdTotal = 0;
                runTimeCalcTaxWithholdTotal = 0;

                if (isGWHTaxEnabled && !isCalcWHTInInvoiceEnabled)
                {
                    inventTableModule = InventTableModule::find(purchLine.ItemId, ModuleInventPurchSales::Purch);

                    if ((inventTableModule.TaxWithholdCalculate_TH
                       && inventTableModule.TaxWithholdItemGroupHeading_TH)
                       || ((SysCountryRegionCode::isLegalEntityInCountryRegion([#isoGB])
                            || (ledgerParameters.EnableWHTOnCharges == NoYes::Yes
                                && TaxWithholdingGlobalFeature::isFeatureAndParamEnabled()))
                         && purchLine.ProcurementCategory))
                    {
                        stopWatchTaxWithholdTotal = TradeInstrumentationStopwatch::newStopwatch();

                        numberOfPurchLinesInWhichTaxWithholdTotal++;

                        if (purchLine.TaxWithholdBaseCur_TH > 0)
                        {
                            taxWithholdTotal += TaxWithhold::calcWithholdingTax(purchLine.TaxWithholdGroup_TH,
                                                                    purchLine.TaxWithholdItemGroupHeading_TH,
                                                                    purchLine.TaxWithholdBaseCur_TH,
                                                                    purchCalcTaxInvoiceDate);
                        }
                        else
                        {
                            taxWithholdTotal += TaxWithhold::calcWithholdingTax(purchLine.TaxWithholdGroup_TH,
                                                                    purchLine.TaxWithholdItemGroupHeading_TH,
                                                                    lineAmount,
                                                                    purchCalcTaxInvoiceDate,
                                                                    Tax::calcTaxAmount(purchLine.TaxGroup,
                                                                        purchLine.TaxItemGroup,
                                                                        purchCalcTaxInvoiceDate,
                                                                        purchLine.CurrencyCode,
                                                                        lineAmount,
                                                                        TaxModuleType::Purch));
                        }

                        runTimeCalcTaxWithholdTotal += stopWatchTaxWithholdTotal.elapsedMilliseconds();
                    }
                }
            }
        }

        queryPurchTableMarkup = this.queryBuildPurchTable();

        while (queryPurchTableMarkup.next())
        {
            purchTableMarkup = this.queryGetPurchTable(queryPurchTableMarkup);
            if (!purchTableMarkup)
            {
                continue;
            }

            vendTable = purchTableMarkup.vendTable_InvoiceAccount();

            this.markupCalc(markup,
                1,
                this.purchOrderBalance(purchTableMarkup.TableId, purchTableMarkup.RecId),
                purchTableMarkup,
                DocumentStatus::Invoice,
                this.interCompanyLineAmount(purchLine, 1, purchCalcTaxInvoiceDate));
        }

        if (isCalcWHTInInvoiceEnabled && !_delayTaxCalc)
        {
            taxWithholdTotal = purchCalcTax.calcWithholdTax(this);
        }

        if (!isCalcWHTInInvoiceEnabled && ledgerParameters.EnableWHTOnCharges == NoYes::Yes)
        {
            // Global withhholding markupTrans amount for lines and headers
            taxWithholdTotal += markupGWHTaxAmount;
        }

        endDisc             = this.endDisc();
        calculatedEndDisc   = this.calculatedEndDisc();
        roundOff        = this.invoiceRoundOff();

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            if (purchCalcTax.directImport_BR() == true)
            {
                markupAmount = markup.totalMarkupAmountCur_BR();
            }
        }
        // </GBR>

        totalAmount     = balance
                        - endDisc
                        + markupAmount
                        + this.taxTotal()
                        + this.purchTaxRoundOff()
                        + roundOff;

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            this.updateMarkupValues_BR(markup);
        }
        // </GBR>

        if (totalAmount != 0)
        {
            if (isGWHTaxEnabled && taxWithholdTotal != 0 && !isCalcWHTInInvoiceEnabled)
            {
                AmountCur purchTotalAmount = this.purchTotalAmount();
                if (abs(purchTotalAmount) < abs(ledgerParameters.TaxWithholdMinInvoice_TH))
                {
                    taxWithholdTotal = 0;
                }
            }

            if (TaxWithholdEnableIncludeTCSInTotalFeatureToggle::includeTCSInInvoiceAmount(taxWithhold))
            {
                AmountCur amountToRound = this.purchTotalAmount() + taxWithholdAmount;
                roundedOffTotalAmount = this.roundedOffAmount(amountToRound) - this.roundedOffAmount(taxWithholdAmount);
                roundOff += this.roundedOffAmount(amountToRound) - amountToRound;
            }
            else
            {
                roundedOffTotalAmount = this.roundedOffTotalAmount();
                roundOff += roundedOffTotalAmount - totalAmount;
            }

            totalAmount             = roundedOffTotalAmount;
        }

        if (vendTable.CreditMax)
        {
            // <GEERU>
            if (countryRegion_RU
                && checkAgreementLimit)
            {
                freeValue   = this.calculateFreeValue_RU();
            }
            else
            {
                // </GEERU>
                freeValue   = vendTable.freeValueMST(CurrencyExchangeHelper::mstAmount(totalAmount, currency, DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), Currency::noYes2UnknownNoYes(this.triangulation()), this.exchRate(), this.exchRateSecondary()));

                // <GEERU>
            }
            // </GEERU>
        }

        if (canApplyCashDiscOnInvoice_ES)
        {
            onlyOneCashDiscOnInvoice = true;
        }

        cashDisc        = this.cashDisc();

        this.purchTotalAmount();

        if (canApplyCashDiscOnInvoice_ES)
        {
            cashDiscDate    = this.cashDiscDate();
        }

        if (updateTotalsSummary)
        {
            PurchTotalsSummaryController::calculateAndUpdateTotalsSummary(purchTable, null, this);
        }

        isCalculationComplete = true;

        runTimeCalcTotals = stopWatch.elapsedMilliseconds();

        this.logInstrumentationMeasures();

        if (isGWHTaxEnabled && !isCalcWHTInInvoiceEnabled)
        {
            TaxWithHoldInstrumentationTelemetry::logGWHTTelemetry(
                GlobalizationConstants::FeatureReferenceTAX00036,
                funcName(),
                TaxWithHoldInstrumentationTelemetry::PurchTotals,
                enum2Str(SalesPurch::Purch),
                true,
                numberofPurchLinesInWhichTaxWithholdTotal,
                runTimeCalcTaxWithholdTotal);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>doCalculateGWHTChargesCode</Name>
				<Source><![CDATA[
    protected boolean doCalculateGWHTChargesCode(VendTable _vendTable)
    {
        return ledgerParameters.EnableWHTOnCharges == NoYes::Yes && _vendTable.TaxWithholdCalculate == NoYes::Yes && _vendTable.TaxWithholdGroup != '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>logInstrumentationMeasures</Name>
				<Source><![CDATA[
    /// <summary>
    /// Logs instrumentation measures.
    /// </summary>
    protected void logInstrumentationMeasures()
    {
        const TradeInstrumentationMeasureName NumberOfPurchaseOrderLines = 'NumberOfPurchaseOrderLines';
        const TradeInstrumentationMeasureName NumberOfTaxLines = 'NumberOfTaxLines';
        const TradeInstrumentationMeasureName NumberOfMarkupTransactions = 'NumberOfMarkupTransactions';
        const TradeInstrumentationMeasureName RuntimeDiscountTotalsCalculation = 'RuntimeDiscountTotalsCalculation';

        PurchInstrumentation::newInstrumentation(tableStr(PurchTable), int642Str(purchTable.RecId))
            .addMeasureElapsedMilliseconds(TradeInstrumentation::getMeasureNameByMethodName(classstr(PurchTotals), methodStr(PurchTotals, calc)), runTimeCalcTotals)
            .addMeasureElapsedMilliseconds(TradeInstrumentation::getMeasureNameByMethodName(classstr(PurchTotals), methodStr(PurchTotals, calcTax)), runTimeCalcTaxTotals)
            .addMeasureElapsedMilliseconds(TradeInstrumentation::getMeasureNameByMethodName(classstr(PurchTotals), methodStr(PurchTotals, markupCalc)), runTimeCalcMarkupTotals)
            .addMeasureElapsedMilliseconds(RuntimeDiscountTotalsCalculation, runTimeCalcDiscountTotals)
            .addMeasureCount(NumberOfPurchaseOrderLines, numberOfPurchLines)
            .addMeasureCount(NumberOfTaxLines, numberOfPurchTaxLines)
            .addMeasureCount(NumberOfMarkupTransactions, numberOfMarkupTrans)
            .logMeasures();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNumberOfTaxLines</Name>
				<Source><![CDATA[
    protected void updateNumberOfTaxLines(PurchCalcTax _purchCalcTax)
    {
        if (_purchCalcTax is PurchCalcTax_Purch)
        {
            PurchCalcTax_Purch purchCalcTaxPurch = _purchCalcTax as PurchCalcTax_Purch;
            numberOfPurchTaxLines += purchCalcTaxPurch.getNumberOfTaxLines();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTax</Name>
				<Source><![CDATA[
    void calcTax(PurchCalcTax _purchCalcTax)
    {
        using (var activityContext = instrumentationLogger.purchTotalsActivities().calcTax())
        {
            TradeInstrumentationStopwatch stopWatch = TradeInstrumentationStopwatch::newStopwatch();
            _purchCalcTax.setSpecQty(specQty);
            _purchCalcTax.setSalesTaxDetailIsNotNeeded(isSalesTaxDetailNotNeeded);

            // <GTE>
            if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
            {
                ITaxableDocument taxableDocument = TaxableDocumentObject::construct(this.parmTaxableDocumentDescriptor());
                ITaxDocument taxDocumentObject = TaxBusinessService::calculateTax(taxableDocument);

                if (taxDocumentObject)
                {
                    ITaxDocumentMeasureValue totalTaxMeasureValue = taxDocumentObject.getTotalTax();
                    taxTotalGTE = taxTotal + totalTaxMeasureValue.amountTransactionCurrency();

                    ITaxDocumentMeasureValue partyTaxMeasureValue = taxDocumentObject.sumByTaxAccountingProvider(TaxAccountingProvider::Party, TaxAccountingPostingProfileDistributionSide::Credit);
                    taxTotal += partyTaxMeasureValue.amountTransactionCurrency();

                    partyTaxMeasureValue = taxDocumentObject.sumByTaxAccountingProvider(TaxAccountingProvider::Party, TaxAccountingPostingProfileDistributionSide::Debit);
                    taxTotal -= partyTaxMeasureValue.amountTransactionCurrency();

                    taxTotalReverseCharge = TaxDocumentUtils::calculateTaxTotalReverseCharge(taxDocumentObject);
                }
                else
                {
                    taxTotalGTE = taxTotal;
                }

                _purchCalcTax.tax(new TaxPurchEmpty(_purchCalcTax, false, false, false, true, false));
                this.tax(_purchCalcTax.tax());
            }
            else
            {
                // </GTE>
                taxTotal        = _purchCalcTax.calcTax(this);
                this.tax(_purchCalcTax.tax());
                // <GTE>
            }
            // </GTE>
            isSalesTaxDetailNotNeeded = _purchCalcTax.setSalesTaxDetailIsNotNeeded();
            this.updateNumberOfTaxLines(_purchCalcTax);
            if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
            {
                loadFromTaxUncommitted = _purchCalcTax.loadFromTaxUncommitted();
                loadFromTaxTrans = _purchCalcTax.loadFromTaxTrans();
                sourceDocumentHeaderRecId = _purchCalcTax.headingTableSourceDocumentRecId();

                if (loadFromTaxUncommitted && isSalesTaxDetailNotNeeded)
                {
                    useTax = TaxUncommitted::useTaxForTaxUncommitted(_purchCalcTax.headingTableID(), _purchCalcTax.headingRecID());
                }
                else if (loadFromTaxTrans && isSalesTaxDetailNotNeeded)
                {
                    useTax = TaxTrans::useTaxForTaxTrans(sourceDocumentHeaderRecId);
                }
                else
                {
                    useTax = this.tax().useTaxTotal();
                }
            }

            runTimeCalcTaxTotals += stopWatch.elapsedMilliseconds();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculatedEndDisc</Name>
				<Source><![CDATA[
    public DiscAmount calculatedEndDisc(boolean _roundResult = true)
    {
        TradeInstrumentationStopwatch stopWatch = TradeInstrumentationStopwatch::newStopwatch();

        MapEnumerator   endDiscBalancesEnumerator;
        AmountCur       localCalcEndDisc;

        endDiscBalancesEnumerator = endDiscBalances.getEnumerator();

        while (endDiscBalancesEnumerator.moveNext())
        {
            localCalcEndDisc += endDiscBalancesEnumerator.current() * endDiscBalancesEnumerator.currentValue() / 100;
        }

        if (_roundResult)
        {
            localCalcEndDisc = CurrencyExchangeHelper::amount(localCalcEndDisc, this.purchCurrency());
        }

        runTimeCalcDiscountTotals += stopWatch.elapsedMilliseconds();

        return localCalcEndDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculatedEndDiscBalance</Name>
				<Source><![CDATA[
    public DiscAmount  calculatedEndDiscBalance()
    {
        MapEnumerator   endDiscBalancesEnumerator;
        AmountCur       calculatedEndDiscBalance;

        endDiscBalancesEnumerator = endDiscBalances.getEnumerator();

        while (endDiscBalancesEnumerator.moveNext())
        {
            calculatedEndDiscBalance += endDiscBalancesEnumerator.currentValue();
        }

        return CurrencyExchangeHelper::amount(calculatedEndDiscBalance, this.purchCurrency());
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateFreeValue_RU</Name>
				<Source><![CDATA[
    protected VendCreditFreeValueMST calculateFreeValue_RU()
    {
        PurchAgreementHeaderExt_RU purchAgreementHeaderExt;
        VendTable               vendTable;
        VendCreditFreeValueMST  calcFreeValue;
        PurchTable_RU           purchTable_RU = purchTable.purchTable_RU();

        vendTable = VendTable::find(purchTable.InvoiceAccount);

        if (purchTable_RU.AgreementHeaderExt_RU)
        {
            purchAgreementHeaderExt = PurchAgreementHeaderExt_RU::find(purchTable_RU.AgreementHeaderExt_RU);

            if (purchAgreementHeaderExt.CreditMax)
            {
                calcFreeValue = purchAgreementHeaderExt.CreditMax -(-vendTable.openBalanceMSTPerAgreement_RU(purchAgreementHeaderExt.AgreementId))
                                                    - CurrencyExchangeHelper::mstAmount(totalAmount, currency, DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), Currency::noYes2UnknownNoYes(this.triangulation()), this.exchRate(), this.exchRateSecondary());
            }
            else
            {
                calcFreeValue = 0;
            }
        }
        else
        {
            calcFreeValue = vendTable.CreditMax - PurchAgreementHeaderExt_RU::creditLimitPerVendAccount(vendTable.InvoiceAccount)
                                                - (-vendTable.openBalanceMSTPerAgreement_RU(''))
                                                - CurrencyExchangeHelper::mstAmount(totalAmount, currency, DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), Currency::noYes2UnknownNoYes(this.triangulation()), this.exchRate(), this.exchRateSecondary());
        }
        return calcFreeValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateIsCreditNote</Name>
				<Source><![CDATA[
    protected void calculateIsCreditNote()
    {
        QueryRun            queryTransact;
        AmountCur           total;
        InventQty           totalUnitQty;

        queryTransact = this.queryBuild();

        while (queryTransact.next())
        {
            purchLine = this.queryGet(queryTransact);
            if (!purchLine)
            {
                continue;
            }

            total += purchLine.LineAmount;
            totalUnitQty += purchLine.PurchQty;
        }

        isCreditNote = this.determineIsCreditNote(total, totalUnitQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcWithholdTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates withhold tax.
    /// </summary>
    /// <param name="_purchCalcTax">
    /// The purch calculate tax.
    /// </param>
    public void calcWithholdTax_IN(PurchCalcTax _purchCalcTax)
    {
        _purchCalcTax.setSpecQty(specQty);
        _purchCalcTax.endDiscPercentWht_IN();
        taxWithholdAmount   = _purchCalcTax.calcWithholdTax_IN(this);
        this.taxWithholdCalculation_IN(_purchCalcTax.taxWithholdCalculation_IN());

        taxWithhold      = new TaxWithhold_IN();

        if (taxWithholdCalculation != null)
        {
            taxWithhold.tmpTaxWithholdWorkTrans(taxWithholdCalculation.tmpTaxWithholdWorkTrans());
            taxWithhold.loadTaxWithholdRegulation(taxWithhold.tmpTaxWithholdWorkTrans());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDisc</Name>
				<Source><![CDATA[
    DiscAmount cashDisc()
    {
        // <GIN>
        TmpTaxWorkTrans     taxWorkTrans;
        TaxAmount           tmpAmount;

        if (TaxParameters::checkTaxParameters_IN() && VendParameters::find().CashDiscVAT)
        {
            if (tax)
            {
                taxWorkTrans    = this.tax().tmpTaxWorkTrans();
                while select TaxCode, SourceTaxAmountCur from taxWorkTrans
                {
                    if (TaxTable::find(taxWorkTrans.TaxCode).TaxType_IN != TaxType_IN::None)
                    {
                        tmpAmount += taxWorkTrans.SourceTaxAmountCur;
                    }
                }
            }
            totalCashDisc = VendParameters::cashDiscAmount_IN(purchTable.CashDisc, this.purchCurrency(), totalAmount,
                                                            totalAmount - this.purchTaxTotal(),
                                                            purchTable.CashDiscPercent,
                                                            tmpAmount);
        }
        else
        {
            // </GIN>
            using (TaxIntegrationTaxJurisdictionParametersContext taxIntegrationTaxJurisdictionParametersContext = TaxIntegrationTaxJurisdictionParametersContext::construct(purchTable.TableId, purchTable.RecId))
            {
                totalCashDisc = VendParameters::cashDiscAmount(
                    purchTable.CashDisc,
                    this.purchCurrency(),
                    totalAmount,
                    totalAmount - this.purchTaxTotal(),
                    purchTable.CashDiscPercent);
            }

            //<GIN>
        }
        //</GIN>
        return totalCashDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscAmount</Name>
				<Source><![CDATA[
    public DiscAmount cashDiscAmount()
    {
        return totalCashDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscDate</Name>
				<Source><![CDATA[
    DiscDate   cashDiscDate()
    {
        return VendParameters::cashDiscDate(purchTable.CashDisc, this.documentDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>categoryWeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the weight of a category based order line.
    /// </summary>
    /// <returns>
    /// The weight of the category based order line.
    /// </returns>
    protected Weight categoryWeight()
    {
        return PurchLineForeignTradeCategory::findpurchLine(purchLine).UnitWeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fullCalculationParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the calculation parameters representing full totals calculation.
    /// </summary>
    /// <param name = "_parameters">The original calculation parameters.</param>
    /// <returns>The calculation parameters representing full totals calculation, as opposed to taxes-only calculation.</returns>
    protected container fullCalculationParameters(container _parameters)
    {
        return _parameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether or not the specified parameter combination has already been cached.
    /// </summary>
    /// <param name="_parameters">The parameter set to check for.</param>
    /// <returns>true if the cached</returns>
    protected boolean checkForCache(container _parameters)
    {
        // Make sure the parameters are the same (or equivalent) and execution is still in the transaction block
        if (calculationCached
            && (cachedCalculationParameters == _parameters
                || cachedCalculationParameters == this.fullCalculationParameters(_parameters))
            && appl.ttsLevel() > 0)
        {
            return true;
        }

        // Not cached so set the next result to cached
        if (this.parmEnableCaching())
        {
            calculationCached = true;
            cachedCalculationParameters = _parameters;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clear</Name>
				<Source><![CDATA[
    void  clear()
    {
        // <GEERU>
        #ISOCountryRegionCodes
        // </GEERU>
        qty                 = 0;
        weight              = 0;
        volume              = 0;

        costValue           = 0;
        freeValue           = 0;

        lineDisc            = 0;
        endDisc             = 0;
        cashDisc            = 0;

        balance             = 0;
        orderBalances       = new Map(Types::String, Types::Real);
        endDiscBalances     = new Map(Types::Real, Types::Real);
        roundOff            = 0;
        markupAmount        = 0;
        taxTotal            = 0;
        totalAmount         = 0;

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            useTax = 0;
            otherMiscCharges = 0;
        }

        inventTable         = null;

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            markupLineDetails   = new Map(Types::Container, Types::Real);
        }
        // </GEERU>
        taxWithholdTotal    = 0;

        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            taxTotalGTE = 0;
        }
        // </GTE>
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructPurchCalcTax</Name>
				<Source><![CDATA[
    PurchCalcTax constructPurchCalcTax()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>deliveryDate_ES</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the purchase delivery date.
    /// </summary>
    /// <returns>
    ///    The purchase delivery date.
    /// </returns>
    public TransDate deliveryDate_ES()
    {
        TransDate firstPackingSlipDate = purchTable.firstPackingSlipDate();

        if (firstPackingSlipDate)
        {
            return firstPackingSlipDate;
        }

        return purchTable.DeliveryDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineIsCreditNote</Name>
				<Source><![CDATA[
    protected boolean determineIsCreditNote(AmountCur _amount, InventQty _qty)
    {
        return _amount < 0 || (!_amount && _qty < 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>discPercent</Name>
				<Source><![CDATA[
    public DiscPct discPercent()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayFields</Name>
				<Source><![CDATA[
    container  displayFields(container  _fields = conNull())
    {
        int         maxPos = this.displayFieldsMaxPos();

        int         pos;
        int         displayFieldPos;
        container   displayFields;
        container   fields;
        MethodName  methodName;
        ExecutePermission perm;

        pos = 1;

        while (pos <= maxPos)
        {
            if (conLen(_fields) == 0)
            {
                fields += [pos];
            }

            displayFields += [''];

            pos++;
        }

        if (conLen(_fields) != 0)
        {
            fields += _fields;
        }

        // Grants permission to execute the DictClass.callObject method.
        // DictClass.callObject runs under code access security.
        perm = new ExecutePermission();
        perm.assert();

        pos = 1;

        while (pos <= conLen(fields))
        {
            displayFieldPos = conPeek(fields, pos);
            if (displayFieldsMethodMap.exists(displayFieldPos))
            {
                methodName = displayFieldsMethodMap.lookup(displayFieldPos);
                displayFields = conPoke(displayFields, displayFieldPos, dictClassPurchTotals.callObject(methodName, this));
            }
            pos++;
        }

        // Closes the code access permission scope.
        CodeAccessPermission::revertAssert();

        return displayFields;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayFieldsMaxPos</Name>
				<Source><![CDATA[
    /// <summary>
    /// Computes an integer value that is the maximum position currently in use by display fields.
    /// </summary>
    /// <returns>An integer value that is the maximum position currently in use by display fields.</returns>
    protected int displayFieldsMaxPos()
    {
        int currentPos;
        int maxPos = 0;

        MapEnumerator me = displayFieldsMethodMap.getEnumerator();

        while (me.moveNext())
        {
            currentPos = me.currentKey();
            if (currentPos > maxPos)
            {
                maxPos = currentPos;
            }
        }

        return maxPos;
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentDate</Name>
				<Source><![CDATA[
    DocumentDate documentDate()
    {
        return this.invoiceDate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>endDisc</Name>
				<Source><![CDATA[
    public DiscAmount  endDisc(boolean _roundResult = true)
    {
        endDisc = this.calculatedEndDisc(_roundResult);

        return endDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRate</Name>
				<Source><![CDATA[
    ExchRate  exchRate()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRateSecondary</Name>
				<Source><![CDATA[
    ExchrateSecondary  exchRateSecondary()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBankPostalAddress</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds the current postal address of the vendors bank.
    /// </summary>
    /// <returns>
    ///     A record of the <c>LogisticsPostalAddress</c> table.
    /// </returns>
    public LogisticsPostalAddress getBankPostalAddress()
    {
        VendTable           vendTable;
        VendBankAccount     vendBankAccount;

        vendTable = VendTable::findByCompany(purchTable.company(), purchTable.InvoiceAccount);
        vendBankAccount = VendBankAccount::findByCompany(vendTable.company(), vendTable.AccountNum, vendTable.BankAccount);

        return LogisticsLocationEntity::location2PostalAddress(vendBankAccount.Location);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInclTaxAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates inclusive tax amount.
    /// </summary>
    /// <returns>
    /// Returns calculated inclusive tax amount.
    /// </returns>
    public TaxAmountCur getInclTaxAmount_IN()
    {
        TaxAmountCur        inclTaxAmount;
        TmpTaxWorkTrans     tmpTaxWorkTrans;
        PurchLine           purchlineLoc;
        FormulaDesigner_IN  formulaDesigner;
        TaxableBasis_IN     taxBasis;
        TmpTaxCalc_IN       tmpTaxCalc;

        while select TaxItemGroup, RecId, TableId  from purchlineLoc
            where purchlineLoc.PurchId == purchTable.PurchId
        {
            if (FormulaDesigner_IN::isPriceInclTaxLine(purchlineLoc.TaxItemGroup))
            {
                tmpTaxWorkTrans = this.tax().tmpTaxWorkTrans();
                tmpTaxCalc      = this.tax().tmpTaxCalc_IN();
                while select tmpTaxWorkTrans
                        where tmpTaxWorkTrans.SourceRecId      == purchlineLoc.RecId
                           && tmpTaxWorkTrans.SourceTableId    == purchlineLoc.TableId
                           && tmpTaxWorkTrans.TaxDirection     != TaxDirection::UseTax
                           && tmpTaxWorkTrans.TaxOrigin        != TaxOrigin::TaxReversed
                {
                    formulaDesigner = FormulaDesigner_IN::findByTaxCode(tmpTaxWorkTrans.TaxItemGroup, tmpTaxWorkTrans.TaxCode);
                    if (formulaDesigner.PriceInclTax)
                    {
                        select firstonly tmpTaxCalc where
                            tmpTaxCalc.TaxCode       == tmpTaxWorkTrans.TaxCode
                         && tmpTaxCalc.SourceTableID == purchlineLoc.TableId
                         && tmpTaxCalc.SourceRecID   == purchlineLoc.RecId;

                        taxBasis = formulaDesigner.TaxableBasis;
                        if (taxBasis == TaxableBasis_IN::ExclAmount)
                        {
                            taxBasis = Tax::getTaxableBasis_IN(formulaDesigner);
                        }
                        if (TaxTable::find(tmpTaxWorkTrans.TaxCode).TaxType_IN != TaxType_IN::None
                            && (taxBasis == TaxableBasis_IN::LineAmount
                                || taxBasis == TaxableBasis_IN::Assessable))
                        {
                            if (!tmpTaxWorkTrans.SourceRegulateAmountCur)
                            {
                                inclTaxAmount += tmpTaxWorkTrans.SourceTaxAmountCur;
                            }
                            else
                            {
                                inclTaxAmount += tmpTaxWorkTrans.SourceRegulateAmountCur;
                            }
                            if (inclTaxAmount < 0)
                            {
                                inclTaxAmount += tmpTaxCalc.TaxOnCharges;
                            }
                            else
                            {
                                inclTaxAmount -= tmpTaxCalc.TaxOnCharges;
                            }
                        }
                    }
                }
            }
        }
        return CurrencyExchangeHelper::amount(inclTaxAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrderBalanceKey</Name>
				<Source><![CDATA[
    protected str getOrderBalanceKey(TableId _tableId, RecId _recId)
    {
        return strFmt('%1,%2', _tableId, _recId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPrimaryPostalAddress</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds the current postal address of the vendor.
    /// </summary>
    /// <returns>
    ///     A record of the <c>LogisticsPostalAddress</c> table.
    /// </returns>
    public LogisticsPostalAddress getPrimaryPostalAddress()
    {
        VendTable       vendTable;

        vendTable = VendTable::findByCompany(purchTable.DataAreaId, purchTable.InvoiceAccount);

        return vendTable.postalAddress();
    }

]]></Source>
			</Method>
			<Method>
				<Name>importDeclarationTotals_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a temporary table with the calculated values.
    /// </summary>
    /// <returns>
    /// A <c>TmpImportDeclarationTotals_BR</c> table buffer.
    /// </returns>
    ///
    public TmpImportDeclarationTotals_BR importDeclarationTotals_BR()
    {
        TmpImportDeclarationTotals_BR tmpImportDeclarationTotals;

        if (importDeclarationTotals)
        {
            tmpImportDeclarationTotals = importDeclarationTotals.tmpImportDeclarationTotals();
        }

        return tmpImportDeclarationTotals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDisplayFields</Name>
				<Source><![CDATA[
    [HookableAttribute(true),
    SuppressBpWarning('BPParameterNotUsed', 'Parameter can be used in pre/post event handlers')]
    protected void initDisplayFields(PurchTotals _purchTotals)
    {
        dictClassPurchTotals = new DictClass(classNum(PurchTotals));

        displayFieldsMethodMap = new Map(Types::Integer, Types::String);

        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchQty),              PurchTotals::posQty());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchWeight),           PurchTotals::posWeight());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchVolume),           PurchTotals::posVolume());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchCurrency),         PurchTotals::posCurrency());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchExchRate),         PurchTotals::posExchRate());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchaseCreditMax),     PurchTotals::posCreditMax());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchCashDisc),         PurchTotals::posCashDisc());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchFreeValue),        PurchTotals::posFreeValue());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchLineDisc),         PurchTotals::posLineDisc());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchBalance),          PurchTotals::posBalance());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchEndDisc),          PurchTotals::posEndDisc());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchMarkup),           PurchTotals::posMarkup());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchTaxTotal),         PurchTotals::posTaxTotal());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchRoundOff),         PurchTotals::posRoundOff());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, displayPurchTotal),     PurchTotals::posTotalAmount());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchTaxRoundOff),      PurchTotals::posTaxRoundOff());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchCashDiscDate),     PurchTotals::posCashDiscDate());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchPrepayLimit),      PurchTotals::posPrepayLimit());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchPrepayAvailable),  PurchTotals::posPrepayAvailable());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchTaxWithholdTotal), PurchTotals::posTaxWithholdTotal());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchPreAppliedAmount), PurchTotals::posPreAppliedAmount());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, pdsCWPurchQty),         PurchTotals::pdsCWPosQty());

        if (TaxWithholdEnableIncludeTCSInTotalFeatureToggle::isFeatureEnabled())
        {
            this.setupDisplayFieldMethod(methodStr(PurchTotals, purchTaxWithholdTCSTotal_IN),  PurchTotals::posWithholdTCSAmount_IN());
        }

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            this.initDisplayFieldsPost_BR();
        }
        // </GBR>

        if (VendParameters::find().TaxUnderTotals_IN && TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            this.initDisplayFieldsPostGTE();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isConfirmation</Name>
				<Source><![CDATA[
    public boolean isConfirmation()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchNewTotalAmount</Name>
				<Source><![CDATA[
    AmountCur purchNewTotalAmount()
    {
        if (canApplyCashDiscOnInvoice_ES && onlyOneCashDiscOnInvoice)
        {
            onlyOneCashDiscOnInvoice = false;
            totalAmount = totalAmount - totalCashDisc;
        }
        newTotalAmount = totalAmount - preAppliedAmount;

        return newTotalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayPurchTotal</Name>
				<Source><![CDATA[
    internal AmountCur displayPurchTotal()
    {
        AmountCur displayTotalAmount = this.purchNewTotalAmount();
        if (TaxWithholdEnableIncludeTCSInTotalFeatureToggle::includeTCSInInvoiceAmount(taxWithhold))
        {
            displayTotalAmount += this.roundedOffAmount(taxWithholdAmount);
        }
        return displayTotalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchPreAppliedAmount</Name>
				<Source><![CDATA[
    AmountCur purchPreAppliedAmount()
    {
        return preAppliedAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posPreAppliedAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>Prepayment amount</c>
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>Prepayment amount</c>
    /// </returns>
    static Integer  posPreAppliedAmount()
    {
        return 24;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posWithholdTCSAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>Withholding TCS amount</c>
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>Withholding TCS amount</c>.
    /// </returns>
    static Integer posWithholdTCSAmount_IN()
    {
        return 25;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDisplayFieldsPost_BR</Name>
				<Source><![CDATA[
    private void initDisplayFieldsPost_BR()
    {
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchSalesTaxCurrency_BR),     PurchTotals::posSalesTaxCurrency_BR());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchTaxTotalICMS_BR),         PurchTotals::posICMSTotal_BR());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchTaxTotalICMSST_BR),       PurchTotals::posICMSSTTotal_BR());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchTaxTotalIPI_BR),          PurchTotals::posIPITotal_BR());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchTaxTotalPIS_BR),          PurchTotals::posPISTotal_BR());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchTaxTotalCOFINS_BR),       PurchTotals::posCOFINSTotal_BR());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchTaxTotalICMSDiff_BR),     PurchTotals::posICMSDiffTotal_BR());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchTaxTotalII_BR),           PurchTotals::posImportTaxTotal_BR());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchTaxTotalISS_BR),          PurchTotals::posISSTotal_BR());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchTaxTotalINSS_BR),         PurchTotals::posINSSTotal_BR());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchTaxTotalIRRF_BR),         PurchTotals::posIRRFTotal_BR());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchTaxTotalCSLL_BR),         PurchTotals::posCSLLTotal_BR());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchTaxTotalINSSRetained_BR), PurchTotals::posRetainedINSSTotal_BR());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, markupTotalAmount_BR),         PurchTotals::posTotalMarkup_BR());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, markupFreightAmountMST_BR),    PurchTotals::posMarkupFreight_BR());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, markupInsuranceAmountMST_BR),  PurchTotals::posMarkupInsurance_BR());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, markupOthersAmountMST_BR),     PurchTotals::posMarkupOther_BR());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, markupSiscomexAmountMST_BR),   PurchTotals::posMarkupSiscomex_BR());
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyLineAmount</Name>
				<Source><![CDATA[
    [SuppressBPWarning('BPParameterNotUsed', 'Child class implementation of method uses the parameters')]
    LineAmount interCompanyLineAmount(PurchLine _purchLine, PurchQty _purchQty, InvoiceDate _invoiceDate)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTableModulePurchCached</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Selects and caches record buffers of the <c>InventTableModule</c> table.
    /// </summary>
    /// <param name="_itemId">
    ///     An <c>ItemId</c> type.
    /// </param>
    /// <returns>
    ///     A buffer of the <c>InventTableModule</c> table.
    /// </returns>
    /// <remarks>
    ///     The selected <c>InventTableModule</c> table buffer is of module type purchase and matches the item ID of the purchase line.
    /// </remarks>
    protected InventTableModule inventTableModulePurchCached(ItemId _itemId)
    {
        InventTableModule inventTableModule;

        if (!inventTableModuleCached)
        {
            inventTableModuleCached = new Map(Types::String, Types::Record);
        }

        if (inventTableModuleCached.exists(_itemId))
        {
            inventTableModule = inventTableModuleCached.lookup(_itemId);
        }
        else
        {
            inventTableModule = InventTableModule::find(_itemId, ModuleInventPurchSales::Purch);
            inventTableModuleCached.insert(_itemId, inventTableModule);
        }

        return inventTableModule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceDate</Name>
				<Source><![CDATA[
    TransDate invoiceDate()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceRoundOff</Name>
				<Source><![CDATA[
    AmountCur invoiceRoundOff()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCategoryBased</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the order line is category based.
    /// </summary>
    /// <returns>
    ///    true if the order line is category based; otherwise, false.
    /// </returns>
    protected boolean isCategoryBased()
    {
        return purchLine.isCategoryBased();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCreditNote</Name>
				<Source><![CDATA[
    public boolean isCreditNote()
    {
        if (!isCreditNoteCalculated)
        {
            this.calculateIsCreditNote();
            isCreditNoteCalculated = true;
        }

        return isCreditNote;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isStocked</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the order line is tracked in inventory.
    /// </summary>
    /// <returns>
    ///    true if the order line is tracked in inventory; otherwise, false.
    /// </returns>
    protected boolean isStocked()
    {
        return purchLine.isStocked();
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemVolume</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the volume of the current item on an item based order line.
    /// </summary>
    /// <returns>
    /// The volume of the current item on an item based order line.
    /// </returns>
    protected Volume itemVolume()
    {
        return inventTable.UnitVolume;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemWeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the weight of the current item on an item based order line.
    /// </summary>
    /// <returns>
    /// The weight of the current item on an item based order line.
    /// </returns>
    protected Weight itemWeight()
    {
        return inventTable.NetWeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineAmount</Name>
				<Source><![CDATA[
    AmountCur lineAmount(PurchQty _purchQty, TransDate _transDate)
    {
        return purchLine.calculateLineAmountExcludingTax(_purchQty, _transDate, tax, false, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineEndDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the line is eligible for total discount.
    /// </summary>
    /// <returns>
    /// true if the order line is eligible for total discount; otherwise, false.
    /// </returns>
    public boolean lineEndDisc()
    {
        return this.isCategoryBased() || this.inventTableModulePurchCached(purchLine.ItemId).EndDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineMarkupTransExist</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if a <c>MarkupTrans</c> table record related to a line of the purchase order exist.
    /// </summary>
    /// <returns>
    ///     true if a <c>MarkupTrans</c> table record exits; otherwise, false.
    /// </returns>
    public boolean lineMarkupTransExist()
    {
        PurchLine           localPurchLine;
        MarkupTrans         localMarkUpTrans;

        // Check if any markup at all exists.
        select firstonly RecId from localMarkUpTrans
            where localMarkUpTrans.TransTableId == tableNum(PurchLine)
               && localMarkUpTrans.IsDeleted    == NoYes::No
        exists join localPurchLine
            where localPurchLine.PurchId == purchTable.PurchId
               && localPurchLine.RecId   == localMarkUpTrans.TransRecId;

        return localMarkUpTrans.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>linePurchUnit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the <c>PurchUnit</c> object of the current line.
    /// </summary>
    /// <returns>
    ///    The <c>PurchUnit</c> object of the current line.
    /// </returns>
    protected PurchUnit linePurchUnit()
    {
        return purchLine.PurchUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupCalc</Name>
				<Source><![CDATA[
    [HookableAttribute(true)]
    private void markupCalc(Markup            _markup,
                            Qty               _qty,
                            AmountCur         _value,
                            Common            _source,
                            DocumentStatus    _documentStatus    = DocumentStatus::None,
                            AmountCur         _interCompanyValue = 0,
                            InvoiceId         _invoiceId         = '')
    {
        using (var activityContext = instrumentationLogger.purchTotalsActivities().markupCalc())
        {
            TradeInstrumentationStopwatch stopWatch = TradeInstrumentationStopwatch::newStopwatch();

            _markup.calc(_qty,
                     _value,
                     _source,
                     _documentStatus,
                     _interCompanyValue,
                     _invoiceId,
                     0,
                     '',
                     '',
                     purchTable.isInterCompanyOrder());

            markupAmount -= _markup.markupCustVend();

            if (_markup.parmTaxWithholdCalculation())
            {
                if (doCalculateGWHTChargesCode)
                {
                    taxWithholdCalc = _markup.parmTaxWithholdCalculation();
                }
            }
            else
            {
                markupGWHTaxAmount += _markup.markupGWHTaxAmount();
            }

            numberOfMarkupTrans += _markup.getNumberOfMarkupTransactionsInCalculation();
            runTimeCalcMarkupTotals += stopWatch.elapsedMilliseconds();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupFreightAmountMST_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the value of the <c>Freight</c> markup type in accounting currency.
    /// </summary>
    /// <returns>
    ///    The value of the <c>Freight</c> markup type.
    /// </returns>
    public MarkupAmount markupFreightAmountMST_BR()
    {
        return markupFreightAmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupInsuranceAmountMST_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the value of the <c>Insurance</c> markup type in accounting currency.
    /// </summary>
    /// <returns>
    ///    The value of the <c>Insurance</c> markup type.
    /// </returns>
    public MarkupAmount markupInsuranceAmountMST_BR()
    {
        return markupInsuranceAmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupOthersAmountMST_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the value of the <c>Other</c> markup type in accounting currency.
    /// </summary>
    /// <returns>
    ///    The value of the <c>Other</c> markup type.
    /// </returns>
    public MarkupAmount markupOthersAmountMST_BR()
    {
        return markupOthersAmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupSiscomexAmountMST_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the value of the <c>Siscomex</c> markup type in accounting currency.
    /// </summary>
    /// <returns>
    ///    The value of the <c>Siscomex</c> markup type.
    /// </returns>
    public MarkupAmount markupSiscomexAmountMST_BR()
    {
        return markupSiscomexAmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupTotalAmount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the total markup value in the legal entity currency.
    /// </summary>
    /// <returns>
    ///    Total markup value.
    /// </returns>
    protected MarkupAmount markupTotalAmount_BR()
    {
        return markupTotalAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new(PurchTable     _purchTable,
                       PurchUpdate    _specQty)
    {
        // <GEERU>
        #ISOCountryRegionCodes
        // </GEERU>
        purchTable      = _purchTable;
        specQty         = _specQty;

        recordListPurchLine = new RecordSortedList(tableNum(PurchLine));
        recordListParmLine  = new RecordSortedList(this.parmLineTableId());

        recordListPurchLine.sortOrder(fieldNum(PurchLine, RecId));
        recordListParmLine.sortOrderFromContainer(this.recordListParmLineSortOrder());

        onlyOneCashDiscOnInvoice = false;

        canApplyCashDiscOnInvoice_ES = TaxParameters::canApplyCashDiscOnInvoice_ES();
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            markupLineDetails = new Map(Types::Container, Types::Real);
        }
        // </GEERU>

        // passing this instance so that it can be used in static pre/post event handlers
        this.initDisplayFields(this);

        instrumentationLogger = PurchInstrumentationLogger::createLogger(classStr(PurchTotals));

        ledgerParameters = LedgerParameters::find();
    }

]]></Source>
			</Method>
			<Method>
				<Name>orderLine_orderTable</Name>
				<Source><![CDATA[
    protected Common orderLine_orderTable()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheckAgreementLimit_RU</Name>
				<Source><![CDATA[
    public boolean parmCheckAgreementLimit_RU(boolean _checkAgreementLimit = checkAgreementLimit)
    {
        checkAgreementLimit = _checkAgreementLimit;
        return checkAgreementLimit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEnableCaching</Name>
				<Source><![CDATA[
    public boolean parmEnableCaching(boolean _enableCaching = enableCaching)
    {
        if (!prmisDefault(_enableCaching))
        {
            enableCaching = _enableCaching;

            if (!enableCaching)
            {
                calculationCached = false;
                cachedCalculationParameters = conNull();
            }
        }
        return enableCaching;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmKeepEndDisc</Name>
				<Source><![CDATA[
    public boolean parmKeepEndDisc(boolean _keepEndDisc = keepEndDisc)
    {
        keepEndDisc = _keepEndDisc;
        return keepEndDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineTableId</Name>
				<Source><![CDATA[
    protected TableId parmLineTableId()
    {
        return tableNum(PurchParmLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPurchQuantity</Name>
				<Source><![CDATA[
    public PurchQuantity parmPurchQuantity(PurchQuantity _purchQuantity = purchQuantityStatusNoneCached)
    {
        purchQuantityStatusNoneCached = _purchQuantity;
        return purchQuantityStatusNoneCached;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmModuleType</Name>
				<Source><![CDATA[
    public PaymCalendarModuleType parmModuleType()
    {
        return PaymCalendarModuleType::Vendor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOtherMiscCharges</Name>
				<Source><![CDATA[
    public MarkupAmount parmOtherMiscCharges(MarkupAmount _otherMiscCharges = otherMiscCharges)
    {
        otherMiscCharges = _otherMiscCharges;
        return otherMiscCharges;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymMode</Name>
				<Source><![CDATA[
    public PaymMode parmPaymMode()
    {
        return purchTable.PaymMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymTermDataAreaId</Name>
				<Source><![CDATA[
    public DataAreaId parmPaymTermDataAreaId()
    {
        return purchTable.DataAreaId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymTermId</Name>
				<Source><![CDATA[
    public PaymTermId parmPaymTermId()
    {
        return purchTable.Payment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipPurchLineSortedList</Name>
				<Source><![CDATA[
    public boolean parmSkipPurchLineSortedList(boolean _skipPurchLineSortedList = skipPurchLineSortedList)
    {
        skipPurchLineSortedList = _skipPurchLineSortedList;
        return skipPurchLineSortedList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxWithholdAmount_IN</Name>
				<Source><![CDATA[
    public AmountCur parmTaxWithholdAmount_IN(AmountCur _taxWithholdAmount = taxWithholdAmount)
    {
        taxWithholdAmount = _taxWithholdAmount;

        return taxWithholdAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateTotalsSummary</Name>
				<Source><![CDATA[
    public boolean parmUpdateTotalsSummary(boolean _updateTotalsSummary = updateTotalsSummary)
    {
        updateTotalsSummary = _updateTotalsSummary;
        return updateTotalsSummary;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymCode</Name>
				<Source><![CDATA[
    PaymTermId paymCode()
    {
        return purchTable.Payment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymDayId</Name>
				<Source><![CDATA[
    PaymDayId paymDayId()
    {
        return purchTable.paymDayId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxableDocumentDescriptor</Name>
				<Source><![CDATA[
    public TaxableDocumentDescriptor parmTaxableDocumentDescriptor()
    {
        return TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(purchTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWPurchQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets CW quantity.
    /// </summary>
    /// <returns>CW quantity.</returns>
    public PdsCWInventQty pdsCWPurchQty()
    {
        return pdsCWQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWQtyPurch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets CW quantity.
    /// </summary>
    /// <param name="_purchLine">Purch line source record.</param>
    /// <returns>CW quantity.</returns>
    public PdsCWInventQty pdsCWQtyPurch(PurchLine _purchLine)
    {
        return PurchQuantity::construct(
                    DocumentStatus::Invoice).pdsCWCalcInventQty(
                        _purchLine, specQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postUpdateOrderBalances_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Update the products and services amount.
    /// </summary>
    /// <param name="_amountCur">
    ///     Amount of the current line.
    /// </param>
    protected void postUpdateOrderBalances_BR(AmountCur _amountCur)
    {
        AmountMST amountMST = CurrencyExchangeHelper::amountCur2MST(_amountCur, currency, this.exchRate());

        if (inventTable)
        {
            switch (inventTable.ItemType)
            {
                case ItemType::Item :
                    totalProductsAmountCur += _amountCur;
                    totalProductsAmountMST += amountMST;
                    break;

                case ItemType::Service :
                    totalServicesAmountCur += _amountCur;
                    totalServicesAmountMST += amountMST;
                    break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchaseCreditMax</Name>
				<Source><![CDATA[
    AmountMST purchaseCreditMax()
    {
        return purchTable.vendTable_InvoiceAccount().CreditMax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchBalance</Name>
				<Source><![CDATA[
    AmountCur purchBalance()
    {
        return balance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchBalanceMST_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the balance in company currency
    /// </summary>
    /// <returns>
    /// purchase balance amount (MST)
    /// </returns>
    public AmountMST purchBalanceMST_BR()
    {
        if (!BrazilParameters::isEnabled())
        {
            return 0;
        }

        return abs(CurrencyExchangeHelper::amountCur2MST(balance, currency, this.exchRate(), this.invoiceDate()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchBaseTotalICMS_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the base total ICMS amount
    /// </summary>
    /// <returns>
    /// ICMS base amount.
    /// </returns>
    public TaxAmount purchBaseTotalICMS_BR()
    {
        return this.purchBaseTotalMST_BR(TaxType_BR::ICMS);
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchBaseTotalICMSST_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the base total ICMS-ST amount
    /// </summary>
    /// <returns>
    /// ICMS-ST base amount.
    /// </returns>
    public TaxAmount purchBaseTotalICMSST_BR()
    {
        return this.purchBaseTotalMST_BR(TaxType_BR::ICMSST);
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchBaseTotalMST_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Return the total base amount by tax type.
    /// </summary>
    /// <param name="_taxType">Tax type to get total amount</param>
    /// <returns>
    ///     Return the total base amount.
    /// </returns>
    public TaxAmount purchBaseTotalMST_BR(TaxType_BR _taxType)
    {
        if (!BrazilParameters::isEnabled())
        {
            return 0;
        }

        if (isSalesTaxDetailNotNeeded)
        {
            TmpTaxWorkTrans taxworkTrans = this.tax().tmpTaxWorkTrans();
            select firstonly RecId from taxWorkTrans;
            if (!taxWorkTrans)
            {
                TaxLoadToTmpTaxWorkTransWhileSalesTaxDetailIsNotNeededParameters parameters = TaxLoadToTmpTaxWorkTransWhileSalesTaxDetailIsNotNeededParameters::construct();
                parameters.loadFromTaxUncommitted = loadFromTaxUncommitted;
                parameters.loadFromTaxTrans = loadFromTaxTrans;
                parameters.headingTableId = this.tax().headingTableId();
                parameters.headingRecId = this.tax().headingRecId();
                parameters.headingTableSourceDocumentRecId = sourceDocumentHeaderRecId;

                taxworkTrans = taxworkTrans.loadToTmpTaxWorkTransWhileSalesTaxDetailIsNotNeeded(parameters);
                this.tax().tmpTaxWorkTrans(taxWorkTrans);
            }
        }
        return abs(CurrencyExchangeHelper::amountCur2MST(this.tax().totalBaseAmountByType_BR(_taxType), currency, this.exchRate(), this.invoiceDate()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchCashDisc</Name>
				<Source><![CDATA[
    DiscAmount  purchCashDisc()
    {
        return cashDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchCashDiscAmount</Name>
				<Source><![CDATA[
    DiscAmount  purchCashDiscAmount()
    {
        return cashDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchCashDiscCode</Name>
				<Source><![CDATA[
    CashDiscCode  purchCashDiscCode()
    {
        return purchTable.CashDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchCashDiscDate</Name>
				<Source><![CDATA[
    DiscDate   purchCashDiscDate()
    {
        return cashDiscDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchCurrency</Name>
				<Source><![CDATA[
    CurrencyCode purchCurrency()
    {
        return currency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchSalesTaxCurrency_BR</Name>
				<Source><![CDATA[
    CurrencyCode purchSalesTaxCurrency_BR()
    {
        return salesTaxCurrency_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchEndDisc</Name>
				<Source><![CDATA[
    DiscAmount  purchEndDisc()
    {
        return endDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchExchRate</Name>
				<Source><![CDATA[
    ExchRate    purchExchRate()
    {
        return this.exchRate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchFreeValue</Name>
				<Source><![CDATA[
    VendCreditFreeValueMST purchFreeValue()
    {
        return freeValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchLineDisc</Name>
				<Source><![CDATA[
    DiscAmount  purchLineDisc()
    {
        return lineDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchLineHasDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether a discount is applied to the purchase line.
    /// </summary>
    /// <returns>
    ///     true if a discount amount, a discount percentage, a multi line discount amount or a multi line discount percentage is applied; otherwise, false.
    /// </returns>
    protected boolean purchLineHasDiscount()
    {
        return (purchLine.LineDisc
                || purchLine.DiscPercent
                || purchLine.MultiLnDisc
                || purchLine.MultiLnPercent);
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchMarkup</Name>
				<Source><![CDATA[
    MarkupAmount  purchMarkup()
    {
        return markupAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchMarkupItem_RU</Name>
				<Source><![CDATA[
    MarkupAmount purchMarkupItem_RU()
    {
        return markupAmountItem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchOrderBalance</Name>
				<Source><![CDATA[
    public AmountCur purchOrderBalance(TableId _tableId, RecId _recId)
    {
        AmountCur   orderBalance;
        str         key = this.getOrderBalanceKey(_tableId, _recId);

        if (orderBalances.exists(key))
        {
            orderBalance = orderBalances.lookup(key);
        }

        return orderBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchOtherMiscCharges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>otherMiscCharges</c> value of the current instance.
    /// </summary>
    /// <returns>
    /// The <c>otherMiscCharges</c> value as the <c>AmountCur</c> data type.
    /// </returns>
    AmountCur  purchOtherMiscCharges()
    {
        return otherMiscCharges;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchPrepayAvailable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the value of the <c>PrepayAvailable</c> field of the <c>PurchPrepayTable</c> table by
    ///    using the value of the <c>PurchId</c> field of the <c>PurchTable</c> table.
    /// </summary>
    /// <returns>
    ///    The value of the <c>PrepayAvailable</c> field of the <c>PurchPrepayTable</c> table.
    /// </returns>
    PurchPrepayAvailable purchPrepayAvailable()
    {
        return PurchPrepayTable::findPurchId(purchTable.PurchId).PrepayAvailable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchPrepayLimit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the value of the <c>PrepayLimit</c> field of the <c>PurchPrepayTable</c> table by using
    ///    the value of the <c>PurchId</c> field of the <c>PurchTable</c> table.
    /// </summary>
    /// <returns>
    ///    The value of the <c>PrepayLimit</c> field of the <c>PurchPrepayTable</c> table.
    /// </returns>
    PurchPrepayLimit purchPrepayLimit()
    {
        return PurchPrepayTable::findPurchId(purchTable.PurchId).PrepayLimit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchQty</Name>
				<Source><![CDATA[
    PurchQty    purchQty()
    {
        return qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchQuantityStatusNoneCached</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Instantiates an object of the <c>PurchQuantity</c> class if it does not exist.
    /// </summary>
    /// <returns>
    ///     A <c>PurchQuantity</c> class object.
    /// </returns>
    protected PurchQuantity purchQuantityStatusNoneCached()
    {
        if (!purchQuantityStatusNoneCached)
        {
            purchQuantityStatusNoneCached = PurchQuantity::construct(DocumentStatus::None, excludePendingInvoices);
        }
        return purchQuantityStatusNoneCached;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchRoundOff</Name>
				<Source><![CDATA[
    RoundOff   purchRoundOff()
    {
        return roundOff;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTaxRoundOff</Name>
				<Source><![CDATA[
    TaxAmountCur  purchTaxRoundOff()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTaxTotal</Name>
				<Source><![CDATA[
    TaxAmountCur  purchTaxTotal()
    {
        return taxTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTaxTotalGTE</Name>
				<Source><![CDATA[
    TaxAmountCur purchTaxTotalGTE()
    {
        return taxTotalGTE;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTaxTotalCOFINS_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total COFINS amount
    /// </summary>
    /// <returns>
    /// COFINS amount.
    /// </returns>
    TaxAmount purchTaxTotalCOFINS_BR()
    {
        return this.purchTaxTotalMST_BR(TaxType_BR::COFINS);
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTaxTotalCSLL_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total CSLL amount
    /// </summary>
    /// <returns>
    /// CSLL amount.
    /// </returns>
    TaxAmount purchTaxTotalCSLL_BR()
    {
        return this.purchTaxTotalMST_BR(TaxType_BR::CSLL);
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTaxTotalICMS_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total ICMS amount
    /// </summary>
    /// <returns>
    /// ICMS amount.
    /// </returns>
    TaxAmount purchTaxTotalICMS_BR()
    {
        return this.purchTaxTotalMST_BR(TaxType_BR::ICMS);
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTaxTotalICMSST_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total ICMS-ST amount
    /// </summary>
    /// <returns>
    /// ICMS-ST amount.
    /// </returns>
    TaxAmount purchTaxTotalICMSST_BR()
    {
        return this.purchTaxTotalMST_BR(TaxType_BR::ICMSST);
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTaxTotalICMSDiff_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total ICMS-Dif amount
    /// </summary>
    /// <returns>
    /// ICMS amount.
    /// </returns>
    TaxAmount purchTaxTotalICMSDiff_BR()
    {
        return this.purchTaxTotalMST_BR(TaxType_BR::ICMSDiff);
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTaxTotalII_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total import tax amount
    /// </summary>
    /// <returns>
    /// II amount.
    /// </returns>
    TaxAmount purchTaxTotalII_BR()
    {
        return this.purchTaxTotalMST_BR(TaxType_BR::ImportTax);
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTaxTotalINSS_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total INSS tax amount
    /// </summary>
    /// <returns>
    /// INSS amount.
    /// </returns>
    TaxAmount purchTaxTotalINSS_BR()
    {
        return this.purchTaxTotalMST_BR(TaxType_BR::INSS);
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTaxTotalINSSRetained_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total INSS retained tax amount
    /// </summary>
    /// <returns>
    /// INSS retained amount.
    /// </returns>
    TaxAmount purchTaxTotalINSSRetained_BR()
    {
        return this.purchTaxTotalMST_BR(TaxType_BR::INSSRetained);
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTaxTotalIPI_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total IPI amount
    /// </summary>
    /// <returns>
    /// IPI amount.
    /// </returns>
    TaxAmount purchTaxTotalIPI_BR()
    {
        return this.purchTaxTotalMST_BR(TaxType_BR::IPI);
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTaxTotalIRRF_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total IRRF tax amount
    /// </summary>
    /// <returns>
    /// IRRF amount.
    /// </returns>
    TaxAmount purchTaxTotalIRRF_BR()
    {
        return this.purchTaxTotalMST_BR(TaxType_BR::IRRF);
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTaxTotalISS_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total ISS tax amount
    /// </summary>
    /// <returns>
    /// ISS amount.
    /// </returns>
    TaxAmount purchTaxTotalISS_BR()
    {
        return this.purchTaxTotalMST_BR(TaxType_BR::ISS);
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTaxTotalMST_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Return the total tax amount by tax type.
    /// </summary>
    /// <param name="_taxType">Tax type to get total amount</param>
    /// <returns>
    ///     Return the total tax amount.
    /// </returns>
    public TaxAmount purchTaxTotalMST_BR(TaxType_BR _taxType)
    {
        if (!BrazilParameters::isEnabled())
        {
            return 0;
        }

        if (loadFromTaxUncommitted && isSalesTaxDetailNotNeeded)
        {
            return abs(CurrencyExchangeHelper::amountCur2MST(this.tax().totalTaxAmountByTypeFromTaxUncommitted_BR(_taxType), currency, this.exchRate(), this.invoiceDate()));

        }
        else if (loadFromTaxTrans && isSalesTaxDetailNotNeeded)
        {
            return abs(CurrencyExchangeHelper::amountCur2MST(this.tax().totalTaxAmountByTypeFromTaxTrans_BR(_taxType, sourceDocumentHeaderRecId), currency, this.exchRate(), this.invoiceDate()));
        }
        else
        {
            return abs(CurrencyExchangeHelper::amountCur2MST(this.tax().totalTaxAmountByType_BR(_taxType), currency, this.exchRate(), this.invoiceDate()));
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTaxTotalPIS_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total PIS amount
    /// </summary>
    /// <returns>
    /// PIS amount.
    /// </returns>
    TaxAmount purchTaxTotalPIS_BR()
    {
        return this.purchTaxTotalMST_BR(TaxType_BR::PIS);
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTaxWithholdTotal</Name>
				<Source><![CDATA[
    TaxWithholdAmountCur  purchTaxWithholdTotal()
    {
        return taxWithholdTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTaxWithholdTCSTotal_IN</Name>
				<Source><![CDATA[
    private AmountCur purchTaxWithholdTCSTotal_IN()
    {
        if (taxWithhold
            && taxWithhold.taxTCSType())
        {
            return taxWithholdAmount;
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTotalAmount</Name>
				<Source><![CDATA[
    AmountCur purchTotalAmount()
    {
        if (canApplyCashDiscOnInvoice_ES && onlyOneCashDiscOnInvoice)
        {
            onlyOneCashDiscOnInvoice = false;
            totalAmount = totalAmount - totalCashDisc;
        }
        return totalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTotalAmountGTE</Name>
				<Source><![CDATA[
    AmountCur purchTotalAmountGTE()
    {
        return totalAmount - taxTotal + taxTotalGTE;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTotalAmountMST_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the purchase total amount in company currency
    /// </summary>
    /// <returns>
    ///  purchase total amount (MST)
    /// </returns>
    public AmountMST purchTotalAmountMST_BR()
    {
        if (!BrazilParameters::isEnabled())
        {
            return 0;
        }

        return abs(CurrencyExchangeHelper::amountCur2MST(totalAmount, currency, this.exchRate(), this.invoiceDate()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchUseTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>useTax</c> value of the current instance.
    /// </summary>
    /// <returns>
    /// The <c>useTax</c> value as the <c>AmountCur</c> data type.
    /// </returns>
    AmountCur  purchUseTax()
    {
        return useTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchVolume</Name>
				<Source><![CDATA[
    Volume   purchVolume()
    {
        return volume;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchWeight</Name>
				<Source><![CDATA[
    Weight purchWeight()
    {
        return weight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyInvent</Name>
				<Source><![CDATA[
    InventQty qtyInvent()
    {
        return this.purchQuantityStatusNoneCached().calcInventQty(purchLine, specQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyInventoryUnits</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the order line quantity in inventory units.
    /// </summary>
    /// <param name="_unitQty">
    /// The order line quantity in order line units.
    /// </param>
    /// <returns>
    /// The order line quantity in inventory units.
    /// </returns>
    /// <remarks>
    /// For non-inventoried lines the <paramref name="_unitQty" /> parameter is converted to inventory
    /// units through the <see cref="M:TradeTotals.qtyInventoryUnits" /> method.
    /// </remarks>
    protected InventQty qtyInventoryUnits(UnitQty _unitQty)
    {
        if (this.isStocked())
        {
            return this.qtyInvent();
        }
        else
        {
            if (this.isCategoryBased())
            {
                return _unitQty;
            }
            else
            {
                return this.unitQtyInInventoryUnits(_unitQty);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyPurch</Name>
				<Source><![CDATA[
    PurchQty qtyPurch()
    {
        return this.purchQuantityStatusNoneCached().calcPurchQty(purchLine, specQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryBuild</Name>
				<Source><![CDATA[
    abstract Object  queryBuild()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryBuildPurchTable</Name>
				<Source><![CDATA[
    QueryRun  queryBuildPurchTable()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryGet</Name>
				<Source><![CDATA[
    abstract Common  queryGet(QueryRun  transact)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryGetPurchTable</Name>
				<Source><![CDATA[
    [SuppressBPWarning('BPParameterNotUsed', 'Parameter used in overloads')]
    PurchTable queryGetPurchTable(QueryRun _queryRun)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordListParmLine</Name>
				<Source><![CDATA[
    RecordSortedList  recordListParmLine(RecordSortedList  _recordListParmLine = recordListParmLine)
    {
        return _recordListParmLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordListParmLineSortOrder</Name>
				<Source><![CDATA[
    protected container recordListParmLineSortOrder()
    {
        TableId lineTableId = this.parmLineTableId();

        return  [VendDocumentUtil::fieldNum(fieldNum(VendDocumentLineMap, TableRefId), lineTableId),
                VendDocumentUtil::fieldNum(fieldNum(VendDocumentLineMap, OrigPurchId), lineTableId),
                VendDocumentUtil::fieldNum(fieldNum(VendDocumentLineMap, LineNum), lineTableId),
                VendDocumentUtil::fieldNum(fieldNum(VendDocumentLineMap, PurchLineRecId), lineTableId),
                fieldNum(VendDocumentLineMap, RecId)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordListPurchLine</Name>
				<Source><![CDATA[
    RecordSortedList  recordListPurchLine(RecordSortedList  _recordListPurchLine = recordListPurchLine)
    {
        return _recordListPurchLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordListPurchParmLine</Name>
				<Source><![CDATA[
    RecordSortedList  recordListPurchParmLine(RecordSortedList  _recordListPurchParmLine = recordListParmLine)
    {
        return _recordListPurchParmLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordSortedListLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a record sorted list of lines for which the totals object was created.
    /// </summary>
    /// <returns>
    /// A record sorted list of lines.
    /// </returns>
    public RecordSortedList recordSortedListLine()
    {
        return this.recordListPurchParmLine();
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundedOffTotalAmount</Name>
				<Source><![CDATA[
    public AmountCur roundedOffTotalAmount()
    {
            return CurrencyExchange::roundWithRuleType(
                this.purchTotalAmount(),
                this.purchCurrency(),
                CurrencyRoundingRuleType::PurchaseOrder);
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundedOffAmount</Name>
				<Source><![CDATA[
    internal AmountCur roundedOffAmount(AmountCur _amount)
    {
        return CurrencyExchange::roundWithRuleType(
                _amount,
                this.purchCurrency(),
                CurrencyRoundingRuleType::PurchaseOrder);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupDisplayFieldMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Helper method to set up display field methods.
    /// </summary>
    /// <param name="_methodName">The method belonging to PurchTotals class that will provide the field value.</param>
    /// <param name="_position">The position of the field.</param>
    protected void setupDisplayFieldMethod(MethodName _methodName, Integer _position = this.displayFieldsMaxPos() + 1)
    {
        displayFieldsMethodMap.insert(_position, _methodName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>tax</Name>
				<Source><![CDATA[
    TaxPurch tax(TaxPurch _tax = tax)
    {
        tax = _tax;
        return tax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxCashDiscPercent</Name>
				<Source><![CDATA[
    DiscPct taxCashDiscPercent()
    {
        if (canApplyCashDiscOnInvoice_ES)
        {
            return purchTable.CashDiscPercent;
        }
        else
        {
            return CashDisc::find(purchTable.CashDisc).Percent;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxTotal</Name>
				<Source><![CDATA[
    TaxAmount  taxTotal()
    {
        return taxTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxReverseCharge</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total tax reverse charge amount.
    /// </summary>
    /// <returns>The total tax reverse charge amount.</returns>
    public TaxAmountCur totalTaxReverseCharge()
    {
        if (!TaxSolutionScopeIntegrationUtil::isCompanyEnabled() && this.tax())
        {
            taxTotalReverseCharge = this.tax().reverseChargeAmount_W();
        }
        return taxTotalReverseCharge;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithhold_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// The tax withhold information.
    /// </summary>
    /// <param name="_taxWithhold">
    /// The tax withhold information.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxWithhold_IN</c> class.
    /// </returns>
    public TaxWithhold_IN taxWithhold_IN(TaxWithhold_IN  _taxWithhold = taxWithhold)
    {
        taxWithhold = _taxWithhold;

        return taxWithhold;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithholdCalculation_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets tax withhold calculation.
    /// </summary>
    /// <param name="_taxWithholdCalculation">
    /// The instance of the <c>TaxWithholdCalculation_IN</c> class.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxWithholdCalculation_IN</c> class.
    /// </returns>
    public TaxWithholdCalculation_IN taxWithholdCalculation_IN(TaxWithholdCalculation_IN _taxWithholdCalculation = taxWithholdCalculation)
    {
        taxWithholdCalculation = _taxWithholdCalculation;
        return taxWithholdCalculation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithholdCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets tax withhold calculation.
    /// </summary>
    /// <param name="_taxWithholdCalc">
    /// The instance of the <c>TaxWithholdCalculation</c> class.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxWithholdCalculation</c> class.
    /// </returns>
    internal TaxWithholdCalculation taxWithholdCalculation(TaxWithholdCalculation _taxWithholdCalc = taxWithholdCalc)
    {
        taxWithholdCalc = _taxWithholdCalc;
        return taxWithholdCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalLinesGrossAmountMST_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Return the total gross amount of products and services in accounting currency.
    /// </summary>
    /// <returns>
    ///     Total gross amount of products and services in accounting currency.
    /// </returns>
    public AmountMST totalLinesGrossAmountMST_BR()
    {
        AmountMST discountAmountMST = CurrencyExchangeHelper::amountCur2MST(this.purchLineDisc(), currency, this.exchRate());

        return this.purchBalanceMST_BR() + discountAmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalMarkupLine_RU</Name>
				<Source><![CDATA[
    public MarkupAmount totalMarkupLine_RU()
    {
        return markupLineAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalMarkupLineDetails_RU</Name>
				<Source><![CDATA[
    public Map totalMarkupLineDetails_RU()
    {
        return markupLineDetails;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalProductsAmountCur_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Return the total amount of products in transaction currency.
    /// </summary>
    /// <returns>
    ///     Total amount of products in transaction currency.
    /// </returns>
    public AmountCur totalProductsAmountCur_BR()
    {
        return totalProductsAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalProductsAmountMST_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Return the total amount of products in accounting currency.
    /// </summary>
    /// <returns>
    ///     Total amount of products in accounting currency.
    /// </returns>
    public AmountMST totalProductsAmountMST_BR()
    {
        return totalProductsAmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalServicesAmountCur_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Return the total amount of services in transaction currency.
    /// </summary>
    /// <returns>
    ///     Total amount of services in transaction currency.
    /// </returns>
    public AmountCur totalServicesAmountCur_BR()
    {
        return totalServicesAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalServicesAmountMST_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Return the total amount of services in accounting currency.
    /// </summary>
    /// <returns>
    ///     Total amount of services in accounting currency.
    /// </returns>
    public AmountMST totalServicesAmountMST_BR()
    {
        return totalServicesAmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxAmountRetained_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Return the total amount of retained taxes in accounting currency.
    /// </summary>
    /// <returns>
    ///     Total amount retained taxes in accounting currency.
    /// </returns>
    public TaxAmount totalTaxAmountRetained_BR()
    {
        return this.tax().totalTaxAmountRetained_BR();
    }

]]></Source>
			</Method>
			<Method>
				<Name>triangulation</Name>
				<Source><![CDATA[
    EUROTriangulation triangulation()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>unitQtyInInventoryUnits</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts a quantity from order line units to inventory units.
    /// </summary>
    /// <param name="_unitQty">
    /// The order line quantity to convert.
    /// </param>
    /// <returns>
    /// The order line quantity in inventory units.
    /// </returns>
    protected InventQty unitQtyInInventoryUnits(UnitQty _unitQty)
    {
        Debug::assert(inventTable != null);

        if (inventTable.RecId)
        {
            return EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(inventTable.ItemId,
                                                                                         inventDimId,
                                                                                         _unitQty,
                                                                                         this.linePurchUnit(),
                                                                                         inventTable.inventUnitId(),
                                                                                         NoYes::Yes);
        }
        else
        {
            return _unitQty;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateEndDiscBalances</Name>
				<Source><![CDATA[
    protected void updateEndDiscBalances(AmountCur _amountCur)
    {
        DiscPct     discPercent = this.discPercent();
        AmountCur   endDiscBalance;

        if (discPercent)
        {
            if (endDiscBalances.exists(discPercent))
            {
                endDiscBalance = endDiscBalances.lookup(discPercent);
            }

            endDiscBalance += _amountCur;
            endDiscBalances.insert(discPercent, endDiscBalance);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMarkupValues_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates markup amounts by type.
    /// </summary>
    /// <param name="_markup">
    /// Current markup class.
    /// </param>
    protected void updateMarkupValues_BR(Markup _markup)
    {
        markupFreightAmountMST      = CurrencyExchangeHelper::amountCur2MST(_markup.markupFreight_BR(), currency, this.exchRate());
        markupInsuranceAmountMST    = CurrencyExchangeHelper::amountCur2MST(_markup.markupInsurance_BR(), currency, this.exchRate());
        markupOthersAmountMST       = CurrencyExchangeHelper::amountCur2MST(_markup.markupOther_BR(), currency, this.exchRate());
        markupSiscomexAmountMST     = CurrencyExchangeHelper::amountCur2MST(_markup.markupSiscomex_BR(), currency, this.exchRate());

        markupTotalAmountCur        = _markup.totalMarkupAmountCur_BR();
        markupTotalAmountMST        = _markup.totalMarkupAmountMST_BR();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOrderBalances</Name>
				<Source><![CDATA[
    public void updateOrderBalances(AmountCur _amountCur)
    {
        Common      common = this.orderLine_orderTable();
        AmountCur   orderBalance;

        orderBalance = this.purchOrderBalance(common.TableId, common.RecId);

        balance         += _amountCur;
        orderBalance    += _amountCur;

        orderBalances.insert(this.getOrderBalanceKey(common.TableId, common.RecId), orderBalance);

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            this.postUpdateOrderBalances_BR(_amountCur);
        }
        // </GBR>
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the total order quantities, inventory quantities, and measurements.
    /// </summary>
    /// <param name="_unitQty">
    ///    The order line quantity in order line units.
    /// </param>
    /// <param name="_inventQty">
    ///    The order line quantity in inventory units.
    /// </param>
    /// <param name="_cwQty">
    ///    The order line quantity in catch weight units.
    /// </param>
    /// <remarks>
    ///    There is only a unit of measure difference between the parameters. Therefore the <paramref
    ///    name="_inventQty" /> parameter can be non-zero for non-inventoried lines.
    /// </remarks>
    protected void updateQuantities(UnitQty _unitQty, InventQty _inventQty
        , PdsCWInventQty _cwQty = 0
        )
    {
        Weight      netWeight;
        Volume      unitVolume;

        if (this.isCategoryBased())
        {
            netWeight   = this.categoryWeight();
            // The other measurements are 0 for category based lines.
        }
        else
        {
            netWeight   = this.itemWeight();
            unitVolume  = this.itemVolume();
        }

        pdsCWQty += _cwQty;
        qty     += _unitQty;

        weight  += abs(_inventQty) * netWeight;
        volume  += abs(_inventQty) * unitVolume;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vatAmountTotal_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the amount and return.
    /// </summary>
    /// <returns>
    /// Returns the amount.
    /// </returns>
    public TaxAmountCur  vatAmountTotal_IN()
    {
        return vatAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vendTransAmount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the custTrans amount.
    /// </summary>
    /// <returns>
    ///     The invoiceAmount subtracted of retained tax amount in transactional currency.
    /// </returns>
    public AmountCur vendTransAmount_BR()
    {
        if (isSalesTaxDetailNotNeeded)
        {
            TmpTaxWorkTrans taxworkTrans = tax.tmpTaxWorkTrans();
            select firstonly RecId from taxWorkTrans;

            if (!taxWorkTrans)
            {
                TaxLoadToTmpTaxWorkTransWhileSalesTaxDetailIsNotNeededParameters parameters = TaxLoadToTmpTaxWorkTransWhileSalesTaxDetailIsNotNeededParameters::construct();
                parameters.loadFromTaxUncommitted = loadFromTaxUncommitted;
                parameters.loadFromTaxTrans = loadFromTaxTrans;
                parameters.headingTableId = tax.headingTableId();
                parameters.headingRecId = tax.headingRecId();
                parameters.headingTableSourceDocumentRecId = sourceDocumentHeaderRecId;

                taxworkTrans = taxworkTrans.loadToTmpTaxWorkTransWhileSalesTaxDetailIsNotNeeded(parameters);

                tax.tmpTaxWorkTrans(taxWorkTrans);
            }
        }
        if (purchTable.isDirectImport_BR())
        {
            return this.purchTotalAmount() - this.taxTotal() - this.markupTotalAmount_BR();
        }
        else
        {
            return this.purchTotalAmount() - tax.totalTaxAmountRetained_BR();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>withholdingTaxAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the withholding tax amount.
    /// </summary>
    /// <returns>
    /// The withholding tax amount.
    /// </returns>
    public AmountCur withholdingTaxAmount_IN()
    {
        return withholdingTaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineEndDiscBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the line end discount balance.
    /// </summary>
    /// <param name="_lineRecId">
    /// The record ID of the line for which the end discount balance should be retrieved.
    /// </param>
    /// <returns>
    /// The end discount balance for the line.
    /// </returns>
    public AmountCur lineEndDiscBalance(RecId _lineRecId)
    {
        AmountCur lineEndDiscBalance;

        if (endDiscBalances.exists(_lineRecId))
        {
            lineEndDiscBalance = endDiscBalances.lookup(_lineRecId);
        }

        return lineEndDiscBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the <c>Tax</c> object from the total calculation.
    /// </summary>
    /// <param name="_purchTable">
    ///    A <c>PurchTable</c> record.
    /// </param>
    /// <returns>
    ///    The <c>Tax</c> object.
    /// </returns>
    static public Tax getTax(PurchTable _purchTable)
    {
        PurchTotals purchTotals = PurchTotals::newPurchTable(_purchTable);
        purchTotals.calc();
        return purchTotals.tax();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDisplayFieldsPostEventHandler</Name>
				<Source><![CDATA[
    // [PostHandlerFor(classStr(PurchTotals), methodStr(PurchTotals, initDisplayFields))]
    private static void initDisplayFieldsPostEventHandler(PurchTotals _purchTotals)
    {
        _purchTotals.setupDisplayFieldMethod(methodStr(PurchTotals, purchUseTax),           PurchTotals::posUseTax());
        _purchTotals.setupDisplayFieldMethod(methodStr(PurchTotals, purchOtherMiscCharges), PurchTotals::posOtherMiscCharges());
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDisplayFieldsPostGTE</Name>
				<Source><![CDATA[
    private void initDisplayFieldsPostGTE()
    {
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchTaxTotalGTE), PurchTotals::posTaxTotal());
        this.setupDisplayFieldMethod(methodStr(PurchTotals, purchTotalAmountGTE), PurchTotals::posTotalAmount());
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupCalcPostEventHandler</Name>
				<Source><![CDATA[
    [PostHandlerFor(classStr(PurchTotals), methodStr(PurchTotals, markupCalc))]
    public static void markupCalcPostEventHandler(XppPrePostArgs _args)
    {
        Markup          markup;
        MarkupAmount    otherMiscCharges;

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            markup = _args.getArg('_markup');

            otherMiscCharges -= markup.markupOtherCharges();

            _args.getThis().parmOtherMiscCharges(otherMiscCharges);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newParmTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new object of the <c>PurchTotals</c> class that calculates the totals from a
    ///    <c>VendInvoiceInfoTable</c> or <c>PurchParmTable</c> record.
    /// </summary>
    /// <param name="_parmTable">
    ///    A <c>VendInvoiceInfoTable</c> or <c>PurchParmTable</c> record.
    /// </param>
    /// <param name="_specQty">
    ///    Indicates which quantity to use.
    /// </param>
    /// <param name="_parmId">
    ///    A session identifier.
    /// </param>
    /// <param name="_sumPurchId">
    ///    The purchase order identifier of the summary <c>VendInvoiceInfoTable</c> or <c>PurchParmTable</c>
    ///    record.
    /// </param>
    /// <param name="_documentStatus">
    ///    The document type; optional.
    /// </param>
    /// <param name="_cachingMethod">
    /// An Enum value that specifies whether to use new or existing cached instances of the <c>PurchTotals</c> class within a transactional scope.
    /// </param>
    /// <returns>
    ///    An object of the <c>PurchTotals_ParmTransEdit</c> class.
    /// </returns>
    /// <remarks>
    ///    The <paramref name="_parmId" /> parameter is used to calculate the tax for the totals in the
    ///    <c>PurchCalcTax</c> class.
    ///    In older versions boolean parameter <c>_shareInstances</c> was used. It has been replaced with <c>_cachingMethod</c> enum parameter.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    ///    The <paramref name="_parmId" /> parameter was blank.
    /// </exception>
    static PurchTotals newParmTable(
                VendDocumentTableMap    _parmTable,
                PurchUpdate             _specQty,
                ParmId                  _parmId,
                PurchId                 _sumPurchId,
                DocumentStatus          _documentStatus = DocumentStatus::None,
                PurchTotalsCachingMethod _cachingMethod = PurchTotalsCachingMethod::NoCaching)
    {
        // If allowed to share instances and in a transactional scope
        if (_cachingMethod != PurchTotalsCachingMethod::NoCaching && appl.ttsLevel() > 0)
        {
            PurchTotals_ParmTransEdit   parmEdit;
            VendDocumentTableMap        cachedTable;
            container                   cacheKey;

            cacheKey = [_specQty, _parmId, _sumPurchId, _documentStatus];

            if (_cachingMethod == PurchTotalsCachingMethod::Reuse)
            {
                parmEdit = SysTransactionScopeCache::get(funcName(), cacheKey, null);
                if (parmEdit)
                {
                    // See if the instance is the same
                    cachedTable = parmEdit.parmTable();
                    if (cachedTable.TableId == _parmTable.TableId &&
                        cachedTable.RecId == _parmTable.RecId &&
                        cachedTable.RecVersion == _parmTable.RecVersion)
                    {
                        return parmEdit;
                    }
                }
            }

            // Different instance or not set, so start over

            if (_documentStatus == DocumentStatus::Invoice)
            {
                parmEdit = PurchTotals_ParmTransEditInvoice::construct(_parmTable, _specQty, _parmId, _sumPurchId, _documentStatus);
            }
            else
            {
                parmEdit = PurchTotals_ParmTransEdit::construct(_parmTable, _specQty, _parmId, _sumPurchId, _documentStatus);
            }
            parmEdit.parmEnableCaching(true);

            SysTransactionScopeCache::set(funcName(), cacheKey, parmEdit);
            return parmEdit;
        }
        else
        {
            // Not sharing instances, always return a new instance
            if (_documentStatus == DocumentStatus::Invoice)
            {
                return PurchTotals_ParmTransEditInvoice::construct(_parmTable, _specQty, _parmId, _sumPurchId, _documentStatus);
            }
            else
            {
                return PurchTotals_ParmTransEdit::construct(_parmTable, _specQty, _parmId, _sumPurchId, _documentStatus);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPurchTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a new instance of the <c>PurchTotals</c> class to calculate the totals from a
    ///    <c>PurchTable</c> record.
    /// </summary>
    /// <param name="_purchTable">
    ///    A <c>PurchTable</c> record.
    /// </param>
    /// <param name="_specQty">
    ///    The quantity to use; optional.
    /// </param>
    /// <returns>
    ///    An instance of the <c>PurchTotals_Trans</c> class.
    /// </returns>
    static PurchTotals  newPurchTable(PurchTable    _purchTable,
                                      PurchUpdate   _specQty = PurchUpdate::All)
    {
        return PurchTotals_Trans::construct(_purchTable, _specQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPurchTableConfirmation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new instance of the <c>PurchTotals</c> class to calculate totals during purchase order
    ///    confirmation.
    /// </summary>
    /// <param name="_purchTable">
    ///    A <c>PurchTable</c> record.
    /// </param>
    /// <param name="_purchParmTable">
    ///    A <c>PurchParmTable</c> record.
    /// </param>
    /// <returns>
    ///    An instance of the <c>PurchTotals_Trans</c> class.
    /// </returns>
    static PurchTotals  newPurchTableConfirmation(PurchTable _purchTable, PurchParmTable _purchParmTable)
    {
        PurchTotals_PurchOrder purchTotals = PurchTotals_PurchOrder::construct(_purchTable, _purchParmTable);
        purchTotals.setConfirmation(true);

        return purchTotals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWPosQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets CW quantity index.
    /// </summary>
    /// <returns>
    ///     The position index.
    /// </returns>
    public static Integer pdsCWPosQty()
    {
        return 23;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsInitDisplayFields</Name>
				<Source><![CDATA[
    [PostHandlerFor(classStr(PurchTotals), methodStr(PurchTotals, initDisplayFields))]
    public static void pdsInitDisplayFields(XppPrePostArgs _args)
    {
        PurchTotals purchTotals = _args.getArg(identifierstr(_purchTotals));
        purchTotals.setupDisplayFieldMethod(methodStr(PurchTotals, pdsCWPurchQty));
    }

]]></Source>
			</Method>
			<Method>
				<Name>posBalance</Name>
				<Source><![CDATA[
    static Integer posBalance()
    {
        return 10;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posCashDisc</Name>
				<Source><![CDATA[
    static Integer posCashDisc()
    {
        return 7;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posCashDiscDate</Name>
				<Source><![CDATA[
    static Integer posCashDiscDate()
    {
        return 17;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posCOFINSTotal_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>COFINS</c> tax type
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>COFINS</c> tax type.
    /// </returns>
    static Integer posCOFINSTotal_BR()
    {
        return posCOFINSTotal_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posCreditMax</Name>
				<Source><![CDATA[
    static Integer posCreditMax()
    {
        return 6;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posCSLLTotal_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>CSLL</c> tax type
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>CSLL</c> tax type.
    /// </returns>
    static Integer posCSLLTotal_BR()
    {
        return posCSLLTotal_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posCurrency</Name>
				<Source><![CDATA[
    static Integer posCurrency()
    {
        return 4;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posSalesTaxCurrency_BR</Name>
				<Source><![CDATA[
    static Integer posSalesTaxCurrency_BR()
    {
        return posSalesTaxCurrency_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posEndDisc</Name>
				<Source><![CDATA[
    static Integer posEndDisc()
    {
        return 11;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posExchRate</Name>
				<Source><![CDATA[
    static Integer posExchRate()
    {
        return 5;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posFreeValue</Name>
				<Source><![CDATA[
    static Integer posFreeValue()
    {
        return 8;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posICMSTotal_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>ICMS</c> tax type
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>ICMS</c> tax type.
    /// </returns>
    static Integer posICMSTotal_BR()
    {
        return posICMSTotal_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posICMSSTTotal_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>ICMS-ST</c> tax type
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>ICMS-ST</c> tax type.
    /// </returns>
    static Integer posICMSSTTotal_BR()
    {
        return posICMSSTTotal_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posICMSDiffTotal_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>ICMS-Dif</c> tax type
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>ICMS-Dif</c> tax type.
    /// </returns>
    static Integer posICMSDiffTotal_BR()
    {
        return posICMSDiffTotal_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posImportTaxTotal_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>ImportTax</c> tax type
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>ImportTax</c> tax type.
    /// </returns>
    static Integer posImportTaxTotal_BR()
    {
        return posImportTaxTotal_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posINSSTotal_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>INSS</c> tax type
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>INSS</c> tax type.
    /// </returns>
    static Integer posINSSTotal_BR()
    {
        return posINSSTotal_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posIPITotal_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>IPI</c> tax type
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>IPI</c> tax type.
    /// </returns>
    static Integer posIPITotal_BR()
    {
        return posIPITotal_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posIRRFTotal_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>IRRF</c> tax type
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>IRRF</c> tax type.
    /// </returns>
    static Integer posIRRFTotal_BR()
    {
        return posIRRFTotal_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posISSTotal_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>ISS</c> tax type
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>ISS</c> tax type.
    /// </returns>
    static Integer posISSTotal_BR()
    {
        return posISSTotal_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posLineDisc</Name>
				<Source><![CDATA[
    static Integer posLineDisc()
    {
        return 9;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posMarkup</Name>
				<Source><![CDATA[
    static Integer posMarkup()
    {
        return 12;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posMarkupFreight_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>Freight</c> amount
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>Freight</c> amount.
    /// </returns>
    static Integer posMarkupFreight_BR()
    {
        return posMarkupFreight_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posMarkupInsurance_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>Insurance</c> misc charges amount
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>Insurance</c> amount.
    /// </returns>
    static Integer posMarkupInsurance_BR()
    {
        return posMarkupInsurance_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posMarkupOther_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>Other</c> misc charges amount
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>Other</c> amount.
    /// </returns>
    static Integer posMarkupOther_BR()
    {
        return posMarkupOther_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posMarkupSiscomex_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>Siscomex</c> misc charges amount
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>Siscomex</c> amount.
    /// </returns>
    static Integer posMarkupSiscomex_BR()
    {
        return posMarkupSiscomex_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posOtherMiscCharges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the position of the value of the <c>OtherMiscCharges</c> field of the <c>PurchPrepayTable</c>
    /// table in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    /// The position of the value of the <c>OtherMiscCharges</c> field of the <c>PurchPrepayTable</c> table.
    /// </returns>
    static Integer posOtherMiscCharges()
    {
        return 22;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posPISTotal_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>PIS</c> tax type
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>PIS</c> tax type.
    /// </returns>
    static Integer posPISTotal_BR()
    {
        return posPISTotal_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posPrepayAvailable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>PrepayAvailable</c> field of the
    ///    <c>PurchPrepayTable</c> table in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>PrepayAvailable</c> field of the <c>PurchPrepayTable</c> table.
    /// </returns>
    static Integer posPrepayAvailable()
    {
        return 19;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posPrepayLimit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>PrepayLimit</c> field of the <c>PurchPrepayTable</c>
    ///    table in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>PrepayLimit</c> field of the <c>PurchPrepayTable</c> table.
    /// </returns>
    static Integer posPrepayLimit()
    {
        return 18;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posQty</Name>
				<Source><![CDATA[
    static Integer posQty()
    {
        return 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posRetainedINSSTotal_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the value of the <c>RetainedINSS</c> tax type
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    The position of the value of the <c>RetainedINSS</c> tax type.
    /// </returns>
    static Integer posRetainedINSSTotal_BR()
    {
        return posRetainedINSSTotal_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posRoundOff</Name>
				<Source><![CDATA[
    static Integer posRoundOff()
    {
        return 16;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posTaxRoundOff</Name>
				<Source><![CDATA[
    static Integer posTaxRoundOff()
    {
        return 14;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posTaxTotal</Name>
				<Source><![CDATA[
    static Integer posTaxTotal()
    {
        return 13;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posTaxWithholdTotal</Name>
				<Source><![CDATA[
    static Integer posTaxWithholdTotal()
    {
        return 20;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posTotalAmount</Name>
				<Source><![CDATA[
    static Integer posTotalAmount()
    {
        return 15;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posTotalMarkup_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the position of the total markup value
    ///    in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    ///    Retrieves the position of the total markup value.
    /// </returns>
    static Integer posTotalMarkup_BR()
    {
        return posTotalMarkup_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posUseTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the position of the value of the <c>UseTax</c> field of the <c>PurchPrepayTable</c>
    /// table in the <c>displayFields</c> container.
    /// </summary>
    /// <returns>
    /// The position of the value of the <c>UseTax</c> field of the <c>PurchPrepayTable</c> table.
    /// </returns>
    static Integer posUseTax()
    {
        return 21;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posVolume</Name>
				<Source><![CDATA[
    static Integer posVolume()
    {
        return 3;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posWeight</Name>
				<Source><![CDATA[
    static Integer posWeight()
    {
        return 2;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showTax</Name>
				<Source><![CDATA[
    static FormRun showTax(str _menuItemDisplayStr, PurchTable _purchTable, FormRun _formRun = null)
    {
        PurchTotals purchTotals = PurchTotals::newPurchTable(_purchTable);
        purchTotals.calc(false, false, true);

        purchTotals.tax().sourceSingleLine(true, false);

        return Tax::showTaxes(_menuItemDisplayStr, purchTotals.tax(), null, _formRun);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsSalesTaxDetailNotNeeded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets and gets the value of whether sales tax detail is not needed.
    /// </summary>
    /// <param name = "_salesTaxDetailNotNeeded">The boolean buffer of whether sales tax detail is not needed.</param>
    [Hookable(false)]
    public void parmIsSalesTaxDetailNotNeeded(boolean _salesTaxDetailNotNeeded)
    {
        isSalesTaxDetailNotNeeded = _salesTaxDetailNotNeeded;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsWHTCalcNeeded</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean parmIsWHTCalcNeeded(boolean _isWHTCalcNeeded = isWHTCalcNeeded)
    {
        isWHTCalcNeeded = _isWHTCalcNeeded;
        return isWHTCalcNeeded;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showTaxLine</Name>
				<Source><![CDATA[
    static void showTaxLine(str _menuItemDisplayStr, PurchTable _purchTable, PurchLine _purchLine)
    {
        PurchTotals    purchTotals;

        purchTotals = PurchTotals::newPurchTable(_purchTable);
        purchTotals.calc();
        purchTotals.tax().sourceSingleLine(true, true);

        Tax::showTaxes(_menuItemDisplayStr, purchTotals.tax(),_purchLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>showWithholdTaxLine_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize a formRun object of <c>TaxWithholdTmpWorkTrans_IN</c> form.
    /// </summary>
    /// <param name="_purchTable">
    /// A <c>PurchTable</c> buffer.
    /// </param>
    /// <param name="_purchLine">
    ///  A <c>PurchLine</c> buffer.
    /// </param>
    /// <returns>
    /// A formRun object of <c>TaxWithholdTmpWorkTrans_IN</c> form.
    /// </returns>
    public static FormRun showWithholdTaxLine_IN(PurchTable _purchTable, PurchLine _purchLine)
    {
        PurchTotals purchTotals;

        purchTotals = PurchTotals::newPurchTable(_purchTable);
        purchTotals.calc();

        return TaxWithhold_IN::showWithholdTaxes(purchTotals.taxWithhold_IN(), _purchLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>showWithholdTax</Name>
				<Source><![CDATA[
    public static FormRun showWithholdTax(str _menuItemDisplayStr, PurchTable _purchTable, FormRun _formRun = null)
    {
        PurchTotals purchTotals = PurchTotals::newPurchTable(_purchTable);

        purchTotals.parmIsWHTCalcNeeded(true);
        purchTotals.calc();

        return TaxWithholdCalculation::showWithholdTaxes(_menuItemDisplayStr, purchTotals.taxWithholdCalculation(), _purchTable, _formRun);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCalculationComplete</Name>
				<Source><![CDATA[
    internal boolean isCalculationComplete()
    {
        return isCalculationComplete;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>