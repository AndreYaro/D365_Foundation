<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustAgingSnapshot</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.AccountsReceivable.Instrumentation;
/// <summary>
///    The <c>CustAgingSnapshot</c> class calculates and stores the customer aging and collections
///    information.
/// </summary>
/// <remarks>
///    The customer aging information is calculated and stored as a specific date so that it may not be
///    current. If it does not have to store customer aging information or real-time aging balances are
///    required, use the <c>CustVendBalanceList</c> class.
/// </remarks>
class CustAgingSnapshot extends RunBaseBatch implements BatchRetryable
{
    // Class fields
    CustVendReportName agingPeriodDef;
    CustCollectionsPoolId customerPool;
    DateTransactionDuedate agedBy;
    CustAgingDateType agingDateType;
    CustAgingDate agingDate;
    container sourceCompanies;
    List agingLineNumList;
    boolean showResults;
    boolean updateCollectionsStatus = true;
    boolean hasJobBeenSplit;
    boolean ageCustomersWithNoOpenTransactions = true;
    boolean bypassCreditLimitCalcDuringAging;
    CustAccount fromCustomer, toCustomer;
    private CustAgingLineCalculation custAgingLineCalculation;
    private NoYes isCustAgingPerfFeatureEnabled;
    private NoYes manualUpdate;
    private NoYes isFinalTask = NoYes::No;

    const int MinimumCustomerBundleSize = 120;

    private CustInstrumentationLogger custInstrumentationLogger;
    private int openTransTotalCount;
    private CustParameters custParameters;

    // This list defines which fields will be persisted and
    // restored by way of the system's SysLastValue functionality.
    #DEFINE.SysLastValuesCurrentVersion(100)
    #LOCALMACRO.SysLastValuesList
        agingPeriodDef,
        customerPool,
        agedBy,
        agingDateType,
        agingDate
    #ENDMACRO

    // This list defines how the object is serialized and unserialized
    // as it is sent across the wire. This list should also contain all
    // nonobject types that are defined on this class declaration.
    #DEFINE.CurrentVersion(2)
    #LOCALMACRO.CurrentList
        agingPeriodDef,
        customerPool,
        agedBy,
        agingDateType,
        agingDate,
        sourceCompanies,
        showResults,
        hasJobBeenSplit,
        fromCustomer,
        toCustomer,
        updateCollectionsStatus
    #ENDMACRO

    #DEFINE.CurrentListV1(1)
    #LOCALMACRO.CurrentList_v1
        agingPeriodDef,
        customerPool,
        agedBy,
        agingDateType,
        agingDate,
        sourceCompanies,
        showResults,
        hasJobBeenSplit,
        fromCustomer,
        toCustomer
    #ENDMACRO

    #DEFINE.CurrentListV3(3)
    #LOCALMACRO.CurrentList_v3
        agingPeriodDef,
        customerPool,
        agedBy,
        agingDateType,
        agingDate,
        sourceCompanies,
        showResults,
        hasJobBeenSplit,
        fromCustomer,
        toCustomer,
        updateCollectionsStatus,
        ageCustomersWithNoOpenTransactions
    #ENDMACRO

    #DEFINE.CurrentVersion(4) 
    #LOCALMACRO.CurrentList
        agingPeriodDef,
        customerPool,
        agedBy,
        agingDateType,
        agingDate,
        sourceCompanies,
        showResults,
        hasJobBeenSplit,
        fromCustomer,
        toCustomer,
        updateCollectionsStatus,
        ageCustomersWithNoOpenTransactions,
        bypassCreditLimitCalcDuringAging,
        isFinalTask
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addSourceCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Includes a company in the calculation of snapshots.
    /// </summary>
    /// <param name="_companyId">
    /// A company identifier.
    /// </param>
    public void addSourceCompany(CompanyId _companyId)
    {
        if (confind(sourceCompanies, _companyId) == 0)
        {
            sourceCompanies += _companyId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSnapshot</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the customer aging and collections information about the aging period definition and the
    /// provided customer.
    /// </summary>
    /// <param name="_primaryCustTable">
    /// The <c>CustTable</c> table record of the primary customer to process.
    /// </param>
    /// <remarks>
    /// The primary customer will never be a cross-company customer.
    /// </remarks>
    protected void calculateSnapshot(CustTable _primaryCustTable)
    {
        #OCCRetryCount

        try
        {
            // The scope of the transaction must include all customers processed as part
            // of the primary customer. This ensures an all or nothing approach.

            if (!isCustAgingPerfFeatureEnabled || (FeatureStateProvider::isFeatureEnabled(CustAgingSnapshotPerformanceEnhancementV2::instance()) && this.parmManualUpdate()))
            {
                this.deleteSnapshot(_primaryCustTable.AccountNum);
            }

            // Store generic information about this snapshot run that does not need
            // any cross-company handling.
            CustAging custAging;
            custAging.CustTable = _primaryCustTable.AccountNum;
            custAging.StatRepInterval = agingPeriodDef;
            custAging.AgedBy = agedBy;
            custAging.AgingDate = this.getActualAgingDate();
            custAging.insert();

            // Snapshots are calculated for all cross-company customers related to the primary customer
            // via _primaryCustTable.Party. The primary customer is retrieved from the company where
            // the aging snapshot originated based on the customer pool query. Note that the pool
            // query will not be executed cross-company. Any cross-company queries are only applied
            // here now that the customers that are part of this pool have been retrieved.

            // We could perform a cross company select to find all customers with a single 'while select'
            // statement; however, that does not handle cases where a customer is being shared across a virtual
            // company. As a result, it is necessary to loop over all companies selected to determine if
            // transactions do exist for that shared customer in each company. It is the only way to consider
            // them all, and it works for any case since the party is the same across companies or in the case
            // of shared customers in a virtual company.

            int sourceCompanyCount = conLen(sourceCompanies);
            for (int i = 1; i <= sourceCompanyCount; i++)
            {
                CompanyId customerCompany = conPeek(sourceCompanies, i);
                var customerCompanyContext = [customerCompany];

                CustTable crossCompanyCustTable;
                select crossCompany:customerCompanyContext crossCompanyCustTable
                    where crossCompanyCustTable.Party == _primaryCustTable.Party;

                // Customers may not exist for the given party in every company selected, so ensure they
                // exist before calculating any aging information.
                if (crossCompanyCustTable)
                {
                    var custAgingLegalEntity = this.calculateSnapshotHeader(customerCompany, custAging.RecId, crossCompanyCustTable);
                    CustVendBalanceList balanceList;
                    
                    if (CustAgingSnapshotReduceTempDbUsageFlight::instance().isEnabled())
                    {
                        changecompany(customerCompany)
                        {
                            custAgingLineCalculation.calculateDetails(crossCompanyCustTable);
                        }
                    } 
                    else
                    {
                        balanceList = this.calculateSnapshotLines(customerCompany, crossCompanyCustTable);
                    }

                    ttsbegin;
                    this.saveSnapshot(custAging, custAgingLegalEntity, balanceList, customerCompany, crossCompanyCustTable);
                    ttscommit;
                    
                    if (!CustAgingSnapshotReduceTempDbUsageFlight::instance().isEnabled())
                    {
                        balanceList.releaseTempTables();
                    }
                }
            }
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                this.deleteSnapshot(_primaryCustTable.AccountNum);
                throw Exception::Deadlock;
            }
            else
            {
                retry;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    this.deleteSnapshot(_primaryCustTable.AccountNum);
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                this.deleteSnapshot(_primaryCustTable.AccountNum);
                throw Exception::UpdateConflict;
            }
        }
        catch
        {
            this.deleteSnapshot(_primaryCustTable.AccountNum);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSnapshotHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the aging snapshot header information.
    /// </summary>
    /// <param name="_company">
    /// The company of the <c>CustTable</c> record.
    /// </param>
    /// <param name="_custAgingRecId">
    /// The foreign key reference to the <c>CustAging</c> table record.
    /// </param>
    /// <param name="_crossCompanyCustTable">
    /// The customer used to calculate the snapshot, which could be a cross-company customer.
    /// </param>
    /// <returns>
    /// A <c>CustAgingLegalEntity</c> table record populated with the appropriate aging information.
    /// </returns>
    protected CustAgingLegalEntity calculateSnapshotHeader(selectableDataArea _company, RefRecId _custAgingRecId, CustTable _crossCompanyCustTable)
    {
        // Convert all amounts to the accounting currency of the Ledger that is initiating the snapshot. As a result,
        // do not include this call within the changecompany scope.
        var currencyExchHelper = CurrencyExchangeHelper::newLedger(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));

        AmountMST calculateMstAmount(AmountMST _amount)
        {
            return currencyExchHelper.calculateTransactionToAccounting(Ledger::accountingCurrency(), _amount, true);
        }
        // Convert all amounts to the reporting currency of the Ledger that is initiating the snapshot.
        AmountMSTSecondary calculateMstSecondaryAmount(AmountMSTSecondary _amount)
        {
            return currencyExchHelper.calculateTransactionCurrencyToReportingCurrency(Ledger::reportingCurrency(), _amount, true);
        }

        CustAging custAgingLocal;
        select firstonly AgingDate from custAgingLocal
            where custAgingLocal.RecId == _custAgingRecId;

        CustAgingDate localAgingDate = custAgingLocal.AgingDate;

        CustAgingLegalEntity custAgingLegalEntity;
        custAgingLegalEntity.CustAging = _custAgingRecId;
        custAgingLegalEntity.SourceLegalEntity = CompanyInfo::current(_company);

        changecompany(_company)
        {
            var creditLimit = CustCreditLimit::construct(_crossCompanyCustTable);

            custAgingLegalEntity.AmountDueMst = calculateMstAmount(creditLimit.balanceInvoiced());
            custAgingLegalEntity.AmountDueMstSecondary = calculateMstSecondaryAmount(creditLimit.balanceInvoicedReporting());

            if (!this.parmBypassCreditLimitCalcDuringAging())
            {
                custAgingLegalEntity.PackingSlipBalanceMst = calculateMstAmount(creditLimit.balanceDelivered());

                // Since balanceNotInvoiced() returns the total ordered + total delivered it is necessary to subtract the
                // total delivered in order to get just the amount ordered
                custAgingLegalEntity.OpenOrderBalanceMst = calculateMstAmount(creditLimit.balanceNotInvoiced()) - custAgingLegalEntity.PackingSlipBalanceMst;

                // The credit limit functionality requries an amount (new sales total / invoice) to be included
                // before any remaining credit will be calculated. This is immediately added back to the credit
                // available which results in a net zero effect.
                if (creditLimit.shouldCheckCreditAvailable())
                {
                    AmountMST dummyInvoiceAmt = 1;
                    creditLimit.addAmountMST(dummyInvoiceAmt);
                    custAgingLegalEntity.CreditRemainingMst = creditLimit.calcCreditAvailable() + dummyInvoiceAmt;
                    custAgingLegalEntity.CreditRemainingMst = calculateMstAmount(custAgingLegalEntity.CreditRemainingMst);
                }
            }
            custAgingLegalEntity.CreditLimitMst = calculateMstAmount(_crossCompanyCustTable.CreditMax);

            var disputeResults = CustDispute::getDisputeStatisticsForCustomer(_crossCompanyCustTable.AccountNum);
            custAgingLegalEntity.DisputedTransactionCount = conpeek(disputeResults, 1);
            custAgingLegalEntity.DisputedTransactionBalanceMst = calculateMstAmount(conpeek(disputeResults, 2));

            custAgingLegalEntity.NumOpenInvoices = this.getNumberOfOpenInvoices(_crossCompanyCustTable.AccountNum, localAgingDate);

            this.setLastPaymentData(_crossCompanyCustTable, custAgingLegalEntity, localAgingDate);

            custAgingLegalEntity.MSTCurrency = Ledger::accountingCurrency();
            custAgingLegalEntity.MSTSecondaryCurrency = Ledger::reportingCurrency();
        }

        return custAgingLegalEntity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLastPaymentData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates and sets the last payment date and last payment value for the given customer account.
    /// </summary>
    /// <param name = "_crossCompanyCustTable">The <c>CustTable</c> record to base the selection of payment data.</param>
    /// <param name = "_custAgingLegalEntity">The current <c>CustAgingLegalEntity</c> record to populate payment data.</param>
    /// <param name = "_agingDate">The date for which the aging snapshot is being executed.</param>
    protected void setLastPaymentData(CustTable _crossCompanyCustTable, CustAgingLegalEntity _custAgingLegalEntity, CustAgingDate _agingDate)
    {
        CustTrans custTrans;

        select firstonly custTrans
            order by TransDate desc, Voucher desc
            where custTrans.AccountNum  == _crossCompanyCustTable.AccountNum
                && custTrans.Invoice == ''
                && custTrans.AmountCur < 0
                && custTrans.TransDate <= _agingDate;

        _custAgingLegalEntity.LastPaymentDate = custTrans.TransDate;
        _custAgingLegalEntity.LastPaymentAmount = -custTrans.AmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumberOfOpenInvoices</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the number of open invoices for a given customer at the time of the execution of the aging snapshot.
    /// </summary>
    /// <param name = "_custAccount">The customer account that is being processed.</param>
    /// <param name = "_agingDate">The date for which the aging snapshot is being executed.</param>
    /// <returns>The number of open invoices for the given customer.</returns>
    protected int getNumberOfOpenInvoices(CustAccount _custAccount, CustAgingDate _agingDate)
    {
        CustInvoiceJour custInvoiceJour;
        CustTrans custTrans;
        CustTransOpen custTransOpen;

        select count(RecId)
            from custInvoiceJour
                where custInvoiceJour.InvoiceAccount == _custAccount
                    && CustInvoiceJour.InvoiceDate <= _agingDate
            exists join custTrans
                where custTrans.Invoice == custInvoiceJour.InvoiceId
                    && custTrans.AccountNum == custInvoiceJour.InvoiceAccount
                    && custTrans.TransDate == custInvoiceJour.InvoiceDate
                    && custTrans.Voucher == custInvoiceJour.LedgerVoucher
            join custTransOpen
                where custTransOpen.AccountNum == custTrans.AccountNum
                    && custTransOpen.RefRecId == custTrans.RecId;

        return int642int(custInvoiceJour.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSnapshotLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the aging snapshot line information.
    /// </summary>
    /// <param name="_company">
    /// The company of the <c>CustTable</c> record.
    /// </param>
    /// <param name="_crossCompanyCustTable">
    /// The customer used to calculate the snapshot, which could be a cross-company customer.
    /// </param>
    /// <returns>
    /// An instance of the <c>CustVendBalanceList</c> class that contains the
    /// aging snapshot line information.
    /// </returns>
    protected CustVendBalanceList calculateSnapshotLines(selectableDataArea _company, CustTable _crossCompanyCustTable)
    {
        // Keep this call out of the changeCompany statement block since the aging
        // period definition from the current company should be used to determine
        // aging periods.
        var balanceList = CustVendBalanceList::construct(
            SysModule::Cust,
            agedBy,
            0,
            dateMax(),
            this.getActualAgingDate(),
            NoYes::No,
            DayMonth::Day,
            ForwardBackwardPrinting::Backward,
            agingPeriodDef,
            NoYes::Yes,
            NoYes::No,
            null,
            NoYes::No,
            NoYes::No,
            NoYes::No,
            updateCollectionsStatus);

        changecompany(_company)
        {
            balanceList.calculateDetails(_crossCompanyCustTable);
        }
        return balanceList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>caption</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the caption of the dialog box.
    /// </summary>
    /// <returns>
    ///    The caption of the dialog box.
    /// </returns>
    public ClassDescription caption()
    {
        return "@SYS132576";
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCloseDialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether processing can continue after the user-defined information has been provided.
    /// </summary>
    /// <param name="_calledFrom">
    ///    The object that called this method.
    /// </param>
    /// <returns>
    ///    true if the dialog box can continue with processing; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The dialog box requires an aging period defintion. It also requires an aging date when the
    ///    <c>AgingDateType</c> enumeration value is set to <c>SelectedDate</c>.
    /// </remarks>
    public boolean checkCloseDialog(Object _calledFrom = null)
    {
        super(_calledFrom);

        return this.validateParms(false, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearSourceCompanies</Name>
				<Source><![CDATA[
    public void clearSourceCompanies()
    {
        sourceCompanies = connull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSubJobs</Name>
				<Source><![CDATA[
    private void createSubJobs(BatchHeader _batchHeader, CustAgingSnapshot _agingSnapshotFinalTask = null)
    {
        var custAgingSnapshot = CustAgingSnapshot::construct();

        custAgingSnapshot.unpack(this.pack());
        custAgingSnapshot.parmHasJobBeenSplit(true);

        batchInfo = custAgingSnapshot.batchInfo();

        str batchCaption = FeatureStateProvider::isFeatureEnabled(CustAgingSnapshotPerformanceEnhancementV2::instance()) ?
            strFmt("@CreditCollections:AgingSnapshotPerfV2TaskDescription") : 
            strFmt("@CreditCollections:AgingSnapshotTaskDescription", fromCustomer, toCustomer);

        batchInfo.parmCaption(batchCaption);
        _batchHeader.addRuntimeTask(custAgingSnapshot, this.parmCurrentBatch().RecId);
        
        if (_agingSnapshotFinalTask)
        {
            _batchHeader.addDependency(_agingSnapshotFinalTask, custAgingSnapshot, BatchDependencyStatus::FinishedOrError);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFinalTask</Name>
				<Source><![CDATA[
    private CustAgingSnapshot createFinalTask(BatchHeader _batchHeader)
    {
        CustAgingSnapshot agingSnapshotFinalTask = CustAgingSnapshot::construct();

        agingSnapshotFinalTask.unpack(this.pack());
        agingSnapshotFinalTask.parmIsFinalTask(NoYes::Yes);
        agingSnapshotFinalTask.parmHasJobBeenSplit(NoYes::Yes);

        batchInfo = agingSnapshotFinalTask.batchInfo();
        batchInfo.parmCaption("@CreditCollections:AgingSnapshotFinalTask");

        _batchHeader.addRuntimeTask(agingSnapshotFinalTask, this.parmCurrentBatch().RecId);

        return agingSnapshotFinalTask;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteSnapshot</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the aging snapshot that exists for the aging period definition and provided customer.
    /// </summary>
    /// <param name="_custAccount">
    ///    The customer used to determine which aging snapshot to delete.
    /// </param>
    protected void deleteSnapshot(CustAccount _custAccount)
    {
        CustAging custAging;

        delete_from custAging
            where custAging.CustTable == _custAccount &&
                custAging.StatRepInterval == agingPeriodDef;

        // The cascading delete from the CustAging table to CustAgingLine table will
        // automatically remove the appropriate detail records.
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteSnapshotForAgingPeriodDefinition</Name>
				<Source><![CDATA[
    private void deleteSnapshotForAgingPeriodDefinition()
    {
        this.deleteCustAgingLineForAgingPeriodDefinition();
        this.deleteCustAgingLegalEntityForAgingPeriodDefinition();
        this.deleteCustAgingForAgingPeriodDefinition();
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteCustAgingLineForAgingPeriodDefinition</Name>
				<Source><![CDATA[
    private void deleteCustAgingLineForAgingPeriodDefinition()
    {
        CustAging custAging;
        CustAgingLegalEntity custAgingLegalEntity;
        CustAgingLine custAgingLine;

        this.skipValidationsForCustAging(custAging);
        this.skipValidationsForCustAgingLegalEntity(custAgingLegalEntity);

        delete_from custAgingLine
            exists join custAgingLegalEntity
                where custAgingLegalEntity.RecId == custAgingLine.CustAgingLegalEntity
            exists join custAging
                where custAging.RecId == custAgingLegalEntity.CustAging
                    && custAging.StatRepInterval == agingPeriodDef;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteCustAgingLegalEntityForAgingPeriodDefinition</Name>
				<Source><![CDATA[
    private void deleteCustAgingLegalEntityForAgingPeriodDefinition()
    {
        CustAging custAging;
        CustAgingLegalEntity custAgingLegalEntity;

        this.skipValidationsForCustAging(custAging);
        this.skipValidationsForCustAgingLegalEntity(custAgingLegalEntity);

        delete_from custAgingLegalEntity
            exists join custAging
                where custAging.RecId == custAgingLegalEntity.CustAging
                    && custAging.StatRepInterval == agingPeriodDef;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteCustAgingForAgingPeriodDefinition</Name>
				<Source><![CDATA[
    private void deleteCustAgingForAgingPeriodDefinition()
    {
        CustAging custAging;
        this.skipValidationsForCustAging(custAging);

        delete_from custAging
            where custAging.StatRepInterval == agingPeriodDef;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipValidationsForCustAging</Name>
				<Source><![CDATA[
    private void skipValidationsForCustAging(CustAging _custAging)
    {
        _custAging.skipDeleteActions(NoYes::Yes);
        _custAging.skipBusinessEvents(NoYes::Yes);
        _custAging.skipDataMethods(NoYes::Yes);
        _custAging.skipEvents(NoYes::Yes);
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipValidationsForCustAgingLegalEntity</Name>
				<Source><![CDATA[
    private void skipValidationsForCustAgingLegalEntity(CustAgingLegalEntity _custAgingLegalEntity)
    {
        _custAgingLegalEntity.skipDeleteActions(NoYes::Yes);
        _custAgingLegalEntity.skipBusinessEvents(NoYes::Yes);
        _custAgingLegalEntity.skipDataMethods(NoYes::Yes);
        _custAgingLegalEntity.skipEvents(NoYes::Yes);
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Provides the dialog box to display for this instance of the <c>RunBaseBatch</c> class.
    /// </summary>
    /// <param name="_dialog">
    ///    A reference to the instance of the dialog box to display.
    /// </param>
    /// <returns>
    ///    An instance of the dialog box to display.
    /// </returns>
    /// <remarks>
    ///    This was overridden because the standard dialog box does not support specialized logic for enabling
    ///    and disabling fields. The <c>CustAgingSnapshot</c> form serves as the dialog box for this
    ///    <c>RunBaseBatch</c> class.
    /// </remarks>
    public Object dialog(DialogRunbase _dialog = null)
    {
        return Dialog::newFormnameRunbase(formstr(CustAgingSnapshot), this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActualAgingDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the aging date used to calculate aging snapshots.
    /// </summary>
    /// <returns>
    ///    The aging date used to calculate aging snapshots.
    /// </returns>
    /// <remarks>
    ///    If the <c>AgingDateType</c> value is set to <c>CustAgingDateType::CurrentDate</c>, the
    ///    <c>AgingDate</c> value will be overridden with the current date. If the <c>AgingDateType</c> value
    ///    is set to a <c>CustAgingDateType::SelectedDate</c>, the value of the <c>AgingDate</c> value will be
    ///    returned.
    /// </remarks>
    protected date getActualAgingDate()
    {
        return agingDateType == CustAgingDateType::CurrentDate ? DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()) : agingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerPoolQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the customer query that determines which customers should be included in the aging
    ///    snapshot.
    /// </summary>
    /// <returns>
    ///    An instance of a user-defined <c>Query</c> class retrieved from the <c>CustCollectionsPool</c>
    ///    table.
    /// </returns>
    /// <remarks>
    ///    The customer pool is used instead of storing the query directly because the pool can be changed at
    ///    any time. This allows the aging snapshot to always use the most recent pool in order to get the
    ///    correct list of customers for processing.
    /// </remarks>
    protected Query getCustomerPoolQuery()
    {
        Query query;
        QueryBuildDataSource currentDs;

        if (fromCustomer != '')
        {
            if (customerPool && toCustomer && (fromCustomer != toCustomer))
            {
                // Validation has already been performed on the pool at this point, so assume it is valid.
                CustCollectionsPool collectionPool;

                select QueryPacked from collectionPool where collectionPool.Name == customerPool;
                query = new Query(collectionPool.QueryPacked);

                currentDs = SysQuery::findOrCreateDataSource(Query, tableNum(CustTable), 0);

                str newQueryRange = SysQuery::range(fromCustomer, toCustomer);

                if (currentDS.findRange(fieldnum(CustTable, AccountNum)))
                {
                    QueryBuildDataSource newCustTableDataSource = currentDs.addDataSource(tablenum(CustTable), 'CustTable2');
                    newCustTableDataSource.relations(false);
                    newCustTableDataSource.joinMode(JoinMode::ExistsJoin);
                    newCustTableDataSource.addLink(fieldNum(CustTable, RecId), fieldNum(CustTable, RecId), currentDs.name());
                    newCustTableDataSource.addRange(fieldnum(CustTable, AccountNum)).value(newQueryRange);
                }
                else
                {
                    currentDs.addRange(fieldnum(CustTable, AccountNum)).value(newQueryRange);
                }
            }
            else
            {
                // Run it for a bundle of customers
                query = new Query();
                currentDs = query.addDataSource(tablenum(CustTable), tablestr(CustTable));
                currentDs.addRange(fieldnum(CustTable, AccountNum)).value(SysQuery::range(fromCustomer, toCustomer));
            }
        }
        else if (customerPool)
        {
            CustCollectionsPool collectionPool;

            // Validation has already been performed on the pool at this point, so assume it is valid.
            select firstonly QueryPacked from collectionPool where collectionPool.Name == customerPool;
            query = new Query(collectionPool.QueryPacked);
        }
        else
        {
            // No pool defined so include all customers
            query = new Query();
            query.addDataSource(tablenum(CustTable), tablestr(CustTable));
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads the last used value.
    /// </summary>
    public void getLast()
    {
        // Do not make the call to super because the #CurrentList and #SysLastValues
        // lists are different, requiring that we have specialized logic for the
        // SysLastValues implementation.
        // super();

        // The following fields must be maintained to mimic the functionality of the overriden
        // method.
        getLastCalled = true;
        inGetSaveLast = true;

        // Restore the pertinent values from the SysLastValue table.
        var packedValues = xSysLastValue::getValue(
            this.lastValueDataAreaId(),
            this.lastValueUserId(),
            this.lastValueType(),
            this.lastValueElementName(),
            this.lastValueDesignName());

        this.unpackSysLastValues(packedValues);

        // This is a RunBaseBatch derivative class. Manually restore the user's
        // settings on the batch tab because super() is not being called.
        xSysLastValue::getLast(this.batchInfo());

        // The following fields must be maintained to mimic the functionality of the overriden
        // method.
        inGetSaveLast = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();

        showResults = false;
        hasJobBeenSplit = false;
        fromCustomer = '';
        toCustomer = '';
        agingDateType = CustAgingDateType::CurrentDate;
        agingDate = dateNull();
        agedBy = DateTransactionDuedate::DueDate;
        openTransTotalCount = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>packSysLastValues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Packs the object for the <c>SysLastValue</c> framework to support persisting user input.
    /// </summary>
    /// <returns>
    ///    A container that stores the list of values that are specified by the <c>SysLastValuesList</c> macro.
    /// </returns>
    /// <remarks>
    ///    This method brings support for inheritance to the <c>SysLastValue</c> implementation on this class.
    ///    Derivative classes should override this method and provide their own implementation with a pack
    ///    list.
    /// </remarks>
    public container packSysLastValues()
    {
        return [#SysLastValuesCurrentVersion, #SysLastValuesList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAgedBy</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>AgedBy</c> value.
    /// </summary>
    /// <param name="_agedBy">
    ///    The value to set.
    /// </param>
    /// <returns>
    ///    The <c>AgedBy</c> value.
    /// </returns>
    /// <remarks>
    ///    Transactions are aged based on the number of days overdue from the transaction date, due date, or
    ///    document date. The <c>AgedBy</c> value specifies which transaction date should be considered when
    ///    aging the open transaction amounts.
    /// </remarks>
    public DateTransactionDuedate parmAgedBy(DateTransactionDuedate _agedBy = agedBy)
    {
        agedBy = _agedBy;
        return agedBy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAgingDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>AgingDate</c> value.
    /// </summary>
    /// <param name="_agingDate">
    ///    The value to set.
    /// </param>
    /// <returns>
    ///    The <c>AgingDate</c> value.
    /// </returns>
    /// <remarks>
    ///    The <c>AgingDate</c> value is combined with the aging period definition to determine where the
    ///    aging periods begin and end. It represents the starting date of the aging period definition and
    ///    also the cutoff date because no open transactions after this date will be considered. The
    ///    <c>AgingDate</c> value will be overridden with the current date at calculation time if the
    ///    <c>AgingDateType</c> value is set to <c>CustAgingDateType::CurrentDate</c>.The default value upon
    ///    construction is the current date.
    /// </remarks>
    public CustAgingDate parmAgingDate(CustAgingDate _agingDate = agingDate)
    {
        agingDate = _agingDate;
        return agingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAgingDateType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>AgingDateType</c> value.
    /// </summary>
    /// <param name="_agingDateType">
    ///    The value to set.
    /// </param>
    /// <returns>
    ///    The <c>AgingDateType</c> value.
    /// </returns>
    /// <remarks>
    ///    If the <c>AgingDateType</c> value is set to <c>CustAgingDateType::CurrentDate</c>, the
    ///    <c>AgingDate</c> value will be overridden with the current date at calculation time.
    /// </remarks>
    public CustAgingDateType parmAgingDateType(CustAgingDateType _agingDateType = agingDateType)
    {
        agingDateType = _agingDateType;
        return agingDateType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAgingPeriodDef</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>AgingPeriodDef</c> value.
    /// </summary>
    /// <param name="_agingPeriodDef">
    ///    The value to set.
    /// </param>
    /// <returns>
    ///    The <c>AgingPeriodDef</c> value.
    /// </returns>
    /// <remarks>
    ///    The <c>AgingPeriodDef</c> value specifies the aging period definition to use when calculating the
    ///    aging snapshot.
    /// </remarks>
    public CustVendReportName parmAgingPeriodDef(CustVendReportName _agingPeriodDef = agingPeriodDef)
    {
        agingPeriodDef = _agingPeriodDef;
        return agingPeriodDef;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>CustAccount</c> value.
    /// </summary>
    /// <param name="_custAccount">
    ///    The value to set.
    /// </param>
    /// <returns>
    ///    The <c>CustAccount</c> value.
    /// </returns>
    /// <remarks>
    ///    When the <c>CustAccount</c> value is set, the <c>CustomerPool</c> value is ignored when calculating
    ///    aging snapshots and is run for the single customer specified by this property.
    /// </remarks>
    public CustAccount parmCustAccount(CustAccount _custAccount = fromCustomer)
    {
        fromCustomer = _custAccount;
        toCustomer = _custAccount;
        return fromCustomer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustomerPool</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>CustomerPool</c> value.
    /// </summary>
    /// <param name="_customerPool">
    ///    The value to set.
    /// </param>
    /// <returns>
    ///    The <c>CustomerPool</c> value.
    /// </returns>
    /// <remarks>
    ///    The <c>CustomerPool</c> value specifies the customer pool query to use when calculating the aging
    ///    snapshot. The query defined by the customer pool determines which customers should be aged as part
    ///    of this process.
    /// </remarks>
    public CustCollectionsPoolId parmCustomerPool(CustCollectionsPoolId _customerPool = customerPool)
    {
        customerPool = _customerPool;
        return customerPool;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHasJobBeenSplit</Name>
				<Source><![CDATA[
    private boolean parmHasJobBeenSplit(boolean _hasJobBeenSplit = hasJobBeenSplit)
    {
        hasJobBeenSplit = _hasJobBeenSplit;
        return hasJobBeenSplit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsFinalTask</Name>
				<Source><![CDATA[
    private NoYes parmIsFinalTask(NoYes _isFinalTask = isFinalTask)
    {
        isFinalTask = _isFinalTask;
        return isFinalTask;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowResults</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>ShowResults</c> value.
    /// </summary>
    /// <param name="_showResults">
    ///    The value to set.
    /// </param>
    /// <returns>
    ///    The <c>ShowResults</c> value.
    /// </returns>
    /// <remarks>
    ///    If the <c>ShowResults</c> value is true, the results of the aging snapshot process will be
    ///    displayed on an Infolog that indicates which customers were processed.The default value upon
    ///    construction is false.
    /// </remarks>
    public boolean parmShowResults(boolean _showResults = showResults)
    {
        showResults = _showResults;
        return showResults;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateCollectionsStatus</Name>
				<Source><![CDATA[
    public boolean parmUpdateCollectionsStatus(boolean _updateCollectionsStatus = updateCollectionsStatus)
    {
        updateCollectionsStatus = _updateCollectionsStatus;
        return updateCollectionsStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAgeCustomersWithNoOpenTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the <c>includeZeroBalanceCustomers</c> value.
    /// </summary>
    /// <param name = "_ageCustomersWithNoOpenTransactions">Whether aging should be calculated on zero balance customers.</param>
    /// <returns>The <c>includeZeroBalanceCustomers</c> value.</returns>
    public boolean parmAgeCustomersWithNoOpenTransactions(boolean _ageCustomersWithNoOpenTransactions = ageCustomersWithNoOpenTransactions)
    {
        ageCustomersWithNoOpenTransactions = _ageCustomersWithNoOpenTransactions;
        return ageCustomersWithNoOpenTransactions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBypassCreditLimitCalcDuringAging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the <c>bypassCreditLimitCalcDuringAging</c> value.
    /// </summary>
    /// <param name = "_bypassCreditLimitCalcDuringAging">Whether aging should bypass calculating credit limit on customer</param>
    /// <returns>The <c>bypassCreditLimitCalcDuringAging</c> value.</returns>
    public boolean parmBypassCreditLimitCalcDuringAging(boolean _bypassCreditLimitCalcDuringAging = bypassCreditLimitCalcDuringAging)
    {
        bypassCreditLimitCalcDuringAging = _bypassCreditLimitCalcDuringAging;
        return bypassCreditLimitCalcDuringAging;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmManualUpdate</Name>
				<Source><![CDATA[
    internal protected NoYes parmManualUpdate(NoYes _manualUpdate = manualUpdate)
    {
        manualUpdate = _manualUpdate;
        return manualUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCustAgingPerfFeatureEnabled</Name>
				<Source><![CDATA[
    private NoYes isCustAgingPerfFeatureEnabled()
    {
        return !this.parmCustomerPool() && !this.parmManualUpdate() && FeatureStateProvider::isFeatureEnabled(CustAgingPerformanceEnhancementFeature::instance());
    }

]]></Source>
			</Method>
			<Method>
				<Name>process</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Drives the aging snapshot process that includes deleting, calculating, and storing aging snapshots
    ///    for the specified aging period definition and customers.
    /// </summary>
    /// <returns>
    ///    A string that contains the aging snapshot process.
    /// </returns>
    protected str process()
    {
        str summaryMessage;

        this.validateParms(true);
        AccountsReceivableEventSource eventSource = AccountsReceivableEventSource::Log;
        isCustAgingPerfFeatureEnabled = this.isCustAgingPerfFeatureEnabled();

        if (isCustAgingPerfFeatureEnabled && !hasJobBeenSplit)
        {
            this.deleteSnapshotForAgingPeriodDefinition();
        }

        // This indicates that the batch is running the first time. In that case we need to break up the job to
        // smaller jobs to allow for parallel processing across multiple threads.
        if (!hasJobBeenSplit && this.isInBatch())
        {
            if (customerPool)
            {
                eventSource.EventWriteAgingSnapshotDetails('CollectionPool', 1, 'Boolean - Is collection pool set');
            }
            
            if (ageCustomersWithNoOpenTransactions)
            {
                eventSource.EventWriteAgingSnapshotDetails('ZeroBalances', ageCustomersWithNoOpenTransactions, 'Boolean - are customers with zero balances included');
            }

            if (bypassCreditLimitCalcDuringAging)
            {
                eventSource.EventWriteAgingSnapshotDetails('BypassCreditLimitCalc', bypassCreditLimitCalcDuringAging, 'Boolean - are credit limit calculations bypassed');
            }

            var batchHeader = BatchHeader::getCurrentBatchHeader();

            if (batchHeader == null)
            {
                batchHeader = BatchHeader::construct();
            }
            
            str lastCustomer;
            var i = 0;
            QueryRun queryRun = new QueryRun(this.getCustomerPoolQuery());

            //remove all fields, since we only need the AccountNum field for splitting into multiple tasks 
            queryRun.query().clearAllFields();
            
            QueryBuildDataSource custDs = SysQuery::findOrCreateDataSource(queryRun.query(), tableNum(CustTable), 0);
            custDs.addSortField(fieldNum(CustTable, AccountNum));
            custDs.addSelectionField(fieldNum(CustTable, AccountNum));
            
            int numberOfBatches = this.calculateNumberOfBatchTasks();
            int totalCount = queryRun.query().dataSourceCount() > 1 ? SysQuery::countLoops(queryRun) : SysQuery::countTotal(queryRun);
            int bundleSize = real2int(roundUp((totalCount / numberOfBatches), 1.0));
            bundleSize = bundleSize < MinimumCustomerBundleSize ? MinimumCustomerBundleSize : bundleSize;

            while (queryRun.next())
            {
                CustTable custTable = queryRun.get(tablenum(CustTable), 1);

                if (custTable)
                {
                    i++;

                    if (i == 1)
                    {
                        fromCustomer = custTable.AccountNum;
                    }
                    else if (i >= bundleSize)
                    {
                        toCustomer = custTable.AccountNum;

                        this.createSubJobs(batchHeader);
                        i = 0;
                    }

                    lastCustomer = custTable.AccountNum;
                }
            }

            // The last bundle is smaller than bundleSize
            if (i > 0)
            {
                toCustomer = lastCustomer;

                this.createSubJobs(batchHeader);
            }

            batchHeader.save();
            Batch childTasks, parentTask;

            while select RecId from childTasks
                exists join parentTask
                where parentTask.RecId == this.parmCurrentBatch().RecId
                    && childTasks.BatchJobId == parentTask.BatchJobId
                    && childTasks.RecId != this.parmCurrentBatch().RecId
            {
                eventSource.EventWriteAgingSnapshotBundleCreated(this.parmCurrentBatch().RecId, childTasks.RecId);
            }
        }
        else
        {
            // Since this information never changes per customer, read it once for later use.
            // This is eventually used by the saveSnapshot method and only needs to be done when
            // we are actually processing the snapshot.

            agingLineNumList = new List(Types::real);
            StatRepIntervalLine agingPeriod;

            while select LineNum from agingPeriod
                where agingPeriod.Name == agingPeriodDef
            {
                agingLineNumList.addEnd(agingPeriod.LineNum);
            }

            boolean shouldUpdateResult = true;
            // Update aging information for all customers in the selected pool
            QueryRun queryRun = new QueryRun(this.getCustomerPoolQuery());

            while (queryRun.next())
            {
                if (queryRun.changed(tablenum(CustTable), 1))
                {
                    CustTable custTable = queryRun.get(tablenum(CustTable), 1);
                    if (custTable)
                    {
                        int customerOpenTransCount = this.getOpenTransactionsCountForCustomer(custTable.Party);
                        int customerOpenOrderBalance = 0;

                        // If aging performance enhancement feature is enabled, we've already deleted the snapshot,
                        // and will insert all zero balance customers after the loop.
                        if (CustAgingSnapshotZeroBalancePackingSlipFlight::instance().isEnabled())
                        {
                            if (customerOpenTransCount == 0 && !this.shouldCalculateStatsForZeroBalCustomers(custTable) && isCustAgingPerfFeatureEnabled)
                            {
                                continue;
                            }
                        } 
                        else
                        {
                            if (custParameters.CalculateStatisticsForZeroBalanceCustomers && customerOpenTransCount == 0)
                            {
                                customerOpenOrderBalance = this.getOpenOrderBalanceForCustomer(custTable);
                            }

                            if (customerOpenTransCount == 0 && customerOpenOrderBalance == 0 && isCustAgingPerfFeatureEnabled)
                            {
                                continue;
                            }
                        }
                        

                        if (!ageCustomersWithNoOpenTransactions && customerOpenTransCount == 0)
                        {
                            this.deleteSnapshot(custTable.AccountNum);
                        }
                        else
                        {
                            this.calculateSnapshot(custTable);
                            openTransTotalCount += customerOpenTransCount;
                        }

                        if (shouldUpdateResult)
                        {
                            if (strlen(summaryMessage) == 0)
                            {
                                // The aging snapshot has been created for customer %1 %2.
                                summaryMessage = strfmt("@SYS132603", custTable.AccountNum, custTable.name());
                            }
                            else
                            {
                                // The aging snapshot has been created for the selected customers.
                                summaryMessage = "@SYS138728";
                                shouldUpdateResult = false;
                            }
                        }
                    }
                }
            }

            if (isCustAgingPerfFeatureEnabled && ageCustomersWithNoOpenTransactions)
            {
                this.insertCustomersWithNoOpenTransactions();
            }

            if (updateCollectionsStatus 
                && CustDisputeHistoryAutomationAvoidTempDbLeakFlight::instance().isEnabled())
            {
                this.updateCollectionStatusForCustomers();
            }

            if (strlen(summaryMessage) == 0)
            {
                // No customers meet the criteria for the aging snapshot.
                summaryMessage = "@SYS132602";
            }
        }

        return summaryMessage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processV2</Name>
				<Source><![CDATA[
    private str processV2()
    {
        str summaryMessage;
        boolean excludeZeroBalanceInQueue = false;

        this.validateParms(true);

        if (!hasJobBeenSplit && !this.parmManualUpdate())
        {
            CustAgingSnapshotDelete::deleteAgingSnapshot(agingPeriodDef, CustCollectionsPool::findByPoolId(customerPool));
        }

        // This indicates that the batch is running the first time. In that case we need to break up the job to
        // smaller jobs to allow for parallel processing across multiple threads.
        if (!hasJobBeenSplit && this.isInBatch())
        {

            CustAgingSnapshotQueueBuilder::buildQueueForSnapshot(agingPeriodDef, customerPool, this.shouldExcludeZeroBalanceCustomers());

            this.writeEventsForAgingSnapshot();

            this.createBatchHeaderAndSubjobs();
        }
        else
        {
            this.initAgingLineNumList();

            if (CustAgingSnapshotReduceTransactionScopeFlight::instance().isEnabled())
            {
                summaryMessage = this.isInBatch() ? this.executeTask() : this.executeSnapshotSynchronous();
            }
            else
            {
                summaryMessage = this.isInBatch() ? this.executeQueue() : this.executeSnapshotSynchronous();
            }
        }

        if (isFinalTask || !this.isInBatch())
        {
            this.executeFinalTask();
        }

        return summaryMessage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeSnapshotSynchronous</Name>
				<Source><![CDATA[
    private str executeSnapshotSynchronous()
    {
        str summaryMessage;
        boolean shouldUpdateResult = true;

        // Update aging information for all customers in the selected pool
        Query poolQuery = this.getCustomerPoolQuery();

        if (this.shouldExcludeZeroBalanceCustomers())
        {
            this.excludeCustomersWithNoOpenTransactions(poolQuery);
        }

        QueryRun queryRun = new QueryRun(poolQuery);

        while (queryRun.next())
        {
            if (queryRun.changed(tablenum(CustTable), 1))
            {
                CustTable custTable = queryRun.get(tablenum(CustTable), 1);
                if (custTable)
                {
                    this.ageBalancesForCustomer(custTable);

                    [shouldUpdateResult, summaryMessage] = this.setSummaryMessageAndUpdateResult(summaryMessage, shouldUpdateResult, custTable);
                }
            }
        }

        return summaryMessage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>excludeCustomersWithNoOpenTransactions</Name>
				<Source><![CDATA[
    private void excludeCustomersWithNoOpenTransactions(Query _q)
    {
        QueryBuildDataSource qbdsCustTransOpen = _q.dataSourceTable(tableNum(CustTable)).addDataSource(tableNum(CustTransOpen));
        qbdsCustTransOpen.addLink(fieldNum(CustTable, AccountNum), fieldNum(CustTransOpen, AccountNum));
        qbdsCustTransOpen.joinMode(JoinMode::ExistsJoin);
        qbdsCustTransOpen.fields().dynamic(NoYes::No);
        qbdsCustTransOpen.fields().clearFieldList();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldExcludeZeroBalanceCustomers</Name>
				<Source><![CDATA[
    private boolean shouldExcludeZeroBalanceCustomers()
    {
        return (CustAgingSnapshotExcludeZeroBalanceTransFlight::instance().isEnabled() 
            && !custParameters.CalculateStatisticsForZeroBalanceCustomers && conLen(sourceCompanies) == 1 && !this.parmManualUpdate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSummaryMessageAndUpdateResult</Name>
				<Source><![CDATA[
    private container setSummaryMessageAndUpdateResult(str _summaryMessage, boolean _shouldUpdateResult, CustTable _custTable)
    {
        boolean ret = _shouldUpdateResult;

        if (_shouldUpdateResult)
        {
            if (strlen(_summaryMessage) == 0)
            {
                // The aging snapshot has been created for customer %1 %2.
                _summaryMessage = strfmt("@SYS132603", _custTable.AccountNum, _custTable.name());
            }
            else
            {
                // The aging snapshot has been created for the selected customers.
                _summaryMessage = "@SYS138728";
                ret = false;
            }
        }

        return [ret, _summaryMessage];
    }

]]></Source>
			</Method>
			<Method>
				<Name>initAgingLineNumList</Name>
				<Source><![CDATA[
    internal void initAgingLineNumList()
    {
        agingLineNumList = new List(Types::real);
        StatRepIntervalLine agingPeriod;

        while select LineNum from agingPeriod
                where agingPeriod.Name == agingPeriodDef
        {
            agingLineNumList.addEnd(agingPeriod.LineNum);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustAgingLineCalculation</Name>
				<Source><![CDATA[
    internal void initCustAgingLineCalculation()
    {
        custAgingLineCalculation = new CustAgingLineCalculation(
            agedBy,
            0,
            dateMax(),
            this.getActualAgingDate(),
            NoYes::No,
            DayMonth::Day,
            ForwardBackwardPrinting::Backward,
            agingPeriodDef,
            NoYes::Yes,
            NoYes::No,
            null,
            NoYes::No,
            NoYes::No,
            NoYes::No,
            updateCollectionsStatus);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBatchHeaderAndSubjobs</Name>
				<Source><![CDATA[
    private void createBatchHeaderAndSubjobs()
    {
        var batchHeader = BatchHeader::getCurrentBatchHeader();

        if (batchHeader == null)
        {
            batchHeader = BatchHeader::construct();
        }

        int numberOfBatches = this.calculateNumberOfBatchTasks();

        CustAgingSnapshot agingSnapshotFinalTask = this.createFinalTask(batchHeader);

        for (int i = 1; i <= numberOfBatches; i++)
        {
            this.createSubJobs(batchHeader, agingSnapshotFinalTask);
        }

        batchHeader.save();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateNumberOfBatchTasks</Name>
				<Source><![CDATA[
    private int calculateNumberOfBatchTasks()
    {
        const int MaxPercentage = 100;
        const int DefaultTasks = 10;
        const int Zero = 0;

        CustParameters parameters = CustParameters::find();

        if (FeatureStateProvider::isFeatureEnabled(CustAgingPercentCustomerPerBatchTaskFeature::instance()))
        {
            if(parameters.PercentCustomersPerBatchTask == Zero)
            {
                return DefaultTasks;
            }

            parameters.PercentCustomersPerBatchTask = parameters.PercentCustomersPerBatchTask > MaxPercentage ? MaxPercentage : parameters.PercentCustomersPerBatchTask;
            return any2int(MaxPercentage / parameters.PercentCustomersPerBatchTask);
        } 
        else
        {
            return parameters.CustAgingSnapshotBatchLimit == Zero ? DefaultTasks : parameters.CustAgingSnapshotBatchLimit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeEventsForAgingSnapshot</Name>
				<Source><![CDATA[
    private void writeEventsForAgingSnapshot()
    {
        AccountsReceivableEventSource eventSource = AccountsReceivableEventSource::Log;

        if (customerPool)
        {
            eventSource.EventWriteAgingSnapshotDetails('CollectionPool', 1, 'Boolean - Is collection pool set');
        }
            
        if (ageCustomersWithNoOpenTransactions)
        {
            eventSource.EventWriteAgingSnapshotDetails('ZeroBalances', ageCustomersWithNoOpenTransactions, 'Boolean - are customers with zero balances included');
        }

        if (bypassCreditLimitCalcDuringAging)
        {
            eventSource.EventWriteAgingSnapshotDetails('BypassCreditLimitCalc', bypassCreditLimitCalcDuringAging, 'Boolean - are credit limit calculations bypassed');
        }

        if (FeatureStateProvider::isFeatureEnabled(CustAgingSnapshotPerformanceEnhancementV2::instance()))
        {
            eventSource.EventWriteAgingSnapshotDetails('CustAgingSnapshotPerformanceEnhancementV2', 1, 'Boolean - Is CustAgingSnapshotPerformanceEnhancementV2 enabled');
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeFinalTask</Name>
				<Source><![CDATA[
    private void executeFinalTask()
    {
        if (ageCustomersWithNoOpenTransactions && !this.parmManualUpdate())
        {
            CustAgingSnapshotInsertZeroBalance::ageZeroBalanceCustomers(agingPeriodDef, agedBy, this.getActualAgingDate(), agingLineNumList, customerPool);
        }

        if (updateCollectionsStatus && CustDisputeHistoryAutomationAvoidTempDbLeakFlight::instance().isEnabled())
        {
            this.updateCollectionStatusForCustomers();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCollectionStatusForCustomers</Name>
				<Source><![CDATA[
    private void updateCollectionStatusForCustomers()
    {
        CustVendTransAging customersAging;
        Query customerPoolQuery = this.getCustomerPoolQuery();
        this.convertToQueryObjectForInsertRecordset(customerPoolQuery);

        QueryBuildDataSource qbdsCustTable = customerPoolQuery.dataSourceTable(tableNum(CustTable));
        qbdsCustTable.addSelectionField(fieldNum(CustTable, AccountNum));

        Map fieldMap = new Map(Types::String, Types::Container);
        fieldMap.insert(fieldStr(CustVendTransAging, AccountNum), [qbdsCustTable.uniqueId(), fieldStr(CustTable, AccountNum)]);

        Query::insert_recordset(customersAging, fieldMap, customerPoolQuery);

        CustDisputeHistoryAutomationAging::updateCollectionsStatus(customersAging, this.getActualAgingDate());

        customersAging.dispose();
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertToQueryObjectForInsertRecordset</Name>
				<Source><![CDATA[
    internal void convertToQueryObjectForInsertRecordset(Query _q)
    {
        for (int i = 1; i <= _q.dataSourceCount(); i ++)
        {
            QueryBuildDataSource qbds = _q.dataSourceNo(i);
            qbds.fields().dynamic(NoYes::No);
            qbds.fields().clearFieldList();
                    
            if (qbds.joinMode() == JoinMode::InnerJoin && qbds.embedded())
            {
                qbds.joinMode(JoinMode::ExistsJoin);
            }
            else if (qbds.joinMode() == JoinMode::OuterJoin)
            {
                qbds.enabled(false);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeTask</Name>
				<Source><![CDATA[
    internal str executeTask()
    {
        #OCCRetryCount

        const int RetryInterval = 500;
        CustAgingSnapshotQueue snapshotQueue;
        snapshotQueue.readPast(true);
        boolean shouldUpdateResult = true;
        str summaryMessage;
        System.Exception exception;
        boolean exceptionThrown;
        RefRecId snapshotQueueRecId;

        UserConnection snapshotQueueConnection = new UserConnection();

        try
        {
            snapshotQueue.setConnection(snapshotQueueConnection);
            
            do
            {
                try
                {
                    snapshotQueueConnection.ttsbegin();

                    snapshotQueue.clear();
                    exceptionThrown = false;

                    select firstonly pessimisticlock * from snapshotQueue
                        where snapshotQueue.StatRepInterval == agingPeriodDef;

                    if (snapshotQueue.RecId)
                    {
                        snapshotQueueRecId = snapshotQueue.RecId;

                        CustTable custTable = CustTable::find(snapshotQueue.AccountNum);
                    
                        if (custTable)
                        {
                            this.ageBalancesForCustomer(custTable);

                            [shouldUpdateResult, summaryMessage] = this.setSummaryMessageAndUpdateResult(summaryMessage, shouldUpdateResult, custTable);

                            snapshotQueue.delete();
                        }
                    }

                    snapshotQueueConnection.ttscommit();
                }
                catch (Exception::Deadlock)
                {
                    if (xSession::currentRetryCount() >= #RetryNum)
                    {
                        exceptionThrown = true;
                        continue;
                    }
                    else
                    {
                        sleep(RetryInterval);
                        retry;
                    }
                }
                catch (exception)
                {
                    exceptionThrown = true;
                }
                finally
                {
                    if (exceptionThrown)
                    {
                        // Previous transaction was closed due to error
                        ttsbegin;

                        delete_from snapshotQueue
                            where snapshotQueue.RecId == snapshotQueueRecId;

                        ttscommit;
                    }
                }
            }
            while (snapshotQueue);
        }
        finally
        {
            snapshotQueueConnection.finalize();
        }

        return summaryMessage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ageBalancesForCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the aging snapshot for the provided customer.
    /// </summary>
    /// <param name = "_custTable"><T>CustTable</T> buffer provided for aging</param>
    private void ageBalancesForCustomer(CustTable _custTable)
    {
        int customerOpenTransCount = this.getOpenTransactionsCountForCustomer(_custTable.Party);
        int customerOpenOrderBalance = 0;

        if (CustAgingSnapshotZeroBalancePackingSlipFlight::instance().isEnabled())
        {
            if (this.parmManualUpdate() || customerOpenTransCount || this.shouldCalculateStatsForZeroBalCustomers(_custTable))
            {
                this.calculateSnapshot(_custTable);
                openTransTotalCount += customerOpenTransCount;
            }
        }
        else
        {
            if (custParameters.CalculateStatisticsForZeroBalanceCustomers && customerOpenTransCount == 0)
            {
                customerOpenOrderBalance = this.getOpenOrderBalanceForCustomer(_custTable);
            }

            if (this.parmManualUpdate() || customerOpenTransCount || customerOpenOrderBalance)
            {
                this.calculateSnapshot(_custTable);
                openTransTotalCount += customerOpenTransCount;
            } 
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeQueue</Name>
				<Source><![CDATA[
    internal str executeQueue()
    {
        #OCCRetryCount

        const int RetryInterval = 500;
        CustAgingSnapshotQueue snapshotQueue;
        snapshotQueue.readPast(true);
        boolean shouldUpdateResult = true;
        str summaryMessage;
        System.Exception exception;
        boolean exceptionThrown;
        RefRecId snapshotQueueRecId;

        do
        {
            try
            {
                ttsbegin;

                snapshotQueue.clear();
                exceptionThrown = false;

                select firstonly pessimisticlock * from snapshotQueue
                    where snapshotQueue.StatRepInterval == agingPeriodDef;

                if (snapshotQueue.RecId)
                {
                    snapshotQueueRecId = snapshotQueue.RecId;

                    CustTable custTable = CustTable::find(snapshotQueue.AccountNum);
                    
                    if (custTable)
                    {
                        this.ageBalancesForCustomer(custTable);

                        [shouldUpdateResult, summaryMessage] = this.setSummaryMessageAndUpdateResult(summaryMessage, shouldUpdateResult, custTable);

                        snapshotQueue.delete();
                    }
                }

                ttscommit;
            }
            catch (Exception::Deadlock)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    exceptionThrown = true;
                    continue;
                }
                else
                {
                    sleep(RetryInterval);
                    retry;
                }
            }
            catch (exception)
            {
                exceptionThrown = true;
            }
            finally
            {
                if (exceptionThrown)
                {
                    // Previous transaction was closed due to error
                    ttsbegin;

                    delete_from snapshotQueue
                        where snapshotQueue.RecId == snapshotQueueRecId;

                    ttscommit;
                }
            }
        }
        while (snapshotQueue);

        return summaryMessage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Drives the aging snapshot process for the provided aging period definition and customers.
    /// </summary>
    public void run()
    {
        str snapshotResult;

        using (SysInstrumentationActivityContext activityContext = this.getActivityContextForRun())
        {
            custParameters = CustParameters::find();
     
            if (CustAgingSnapshotReduceTempDbUsageFlight::instance().isEnabled())
            {
                this.initCustAgingLineCalculation();
            }

            if (FeatureStateProvider::isFeatureEnabled(CustAgingSnapshotPerformanceEnhancementV2::instance()))
            {
                snapshotResult = this.processV2();
            }
            else
            {
                snapshotResult = this.process();
            }

            if (CustAgingSnapshotReduceTempDbUsageFlight::instance().isEnabled())
            {
                custAgingLineCalculation.releaseTempTables();
            }

            activityContext.addCustomProperty(CustAgingInstrumentationConstants::OpenTransTotalCountOrderOfMagnitudeNumber, ApplicationCommonInstrumentationMagnitude::log10Magnitude(openTransTotalCount));

            activityContext.addCustomProperty(CustAgingInstrumentationConstants::IsInBatch, any2Str(this.isInBatch()));
            activityContext.addCustomProperty(CustAgingInstrumentationConstants::IsCreditLimitCalcSkipped,
                any2Str(this.parmBypassCreditLimitCalcDuringAging()));  
            activityContext.addCustomProperty(CustAgingInstrumentationConstants::UpdateCollectionsStatus, any2Str(updateCollectionsStatus));
            activityContext.addCustomProperty(CustAgingInstrumentationConstants::HasJobBeenSplit, any2Str(hasJobBeenSplit));
            activityContext.addCustomProperty(CustAgingInstrumentationConstants::AgeCustomersWithNoOpenTrans, any2Str(ageCustomersWithNoOpenTransactions));
        }

        if (this.parmShowResults())
        {
            info(snapshotResult);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCustomersWithNoOpenTransactions</Name>
				<Source><![CDATA[
    private void insertCustomersWithNoOpenTransactions()
    {
        if (!this.isInBatch())
        {
            this.setFromCustomerAgingPerformanceAsync();
            this.setToCustomerAgingPerformanceAsync();
        }

        this.insertCustAgingWithNoOpenTransactions();
        this.insertCustAgingLegalEntityWithNoOpenTransactions();
        this.insertCustAgingLineWithNoOpenTransactions();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFromCustomerAgingPerformanceAsync</Name>
				<Source><![CDATA[
    private void setFromCustomerAgingPerformanceAsync()
    {
        CustTable custTable;

        select firstonly AccountNum from custTable
            order by AccountNum;

        fromCustomer = custTable.AccountNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setToCustomerAgingPerformanceAsync</Name>
				<Source><![CDATA[
    private void setToCustomerAgingPerformanceAsync()
    {
        CustTable custTable;

        select firstonly AccountNum from custTable
            order by AccountNum desc;

        toCustomer = custTable.AccountNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCustAgingWithNoOpenTransactions</Name>
				<Source><![CDATA[
    private void insertCustAgingWithNoOpenTransactions()
    {
        CustAging custAging;
        CustTable custTable;
        CustAging custAgingLocal;

        var agingDateLocal = this.getActualAgingDate();

        insert_recordset custAging ( AgedBy, AgingDate, CustTable, StatRepInterval )
        select agedBy, agingDateLocal, AccountNum, agingPeriodDef from custTable
            where custTable.AccountNum >= fromCustomer
                && custTable.AccountNum <= toCustomer
            notexists join custAgingLocal
                where custAgingLocal.CustTable == custTable.AccountNum
                    && custAgingLocal.StatRepInterval == agingPeriodDef;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCustAgingLegalEntityWithNoOpenTransactions</Name>
				<Source><![CDATA[
    private void insertCustAgingLegalEntityWithNoOpenTransactions()
    {
        CustAging custAging;
        CustAgingLegalEntity custAgingLegalEntity;
        CustTable custTable;
        CustAgingLegalEntity custAgingLegalEntityLocal;

        var currentCompany = CompanyInfo::current(curExt());
        var accountingCurrency = Ledger::accountingCurrency();
        var reportingCurrency = Ledger::reportingCurrency();

        insert_recordset custAgingLegalEntity ( CustAging, SourceLegalEntity, MSTCurrency, MSTSecondaryCurrency )
        select RecId, currentCompany, accountingCurrency, reportingCurrency from custAging
            where custAging.StatRepInterval == agingPeriodDef
            exists join custTable
                where custTable.AccountNum == custAging.CustTable
                    && custTable.AccountNum >= fromCustomer
                    && custTable.AccountNum <= toCustomer
            notexists join custAgingLegalEntityLocal
                where custAgingLegalEntityLocal.CustAging == custAging.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCustAgingLineWithNoOpenTransactions</Name>
				<Source><![CDATA[
    private void insertCustAgingLineWithNoOpenTransactions()
    {
        CustAging custAging;
        CustAgingLegalEntity custAgingLegalEntity;
        CustAgingLine custAgingLine;
        custAgingLine custAgingLineLocal;
        CustTable custTable;
        var position = agingLineNumList.elements();
        var enumerator = agingLineNumList.getEnumerator();
        
        while (enumerator.moveNext())
        {
            var statRepLineNum = enumerator.current();

            insert_recordset custAgingLine ( CustAgingLegalEntity, Position, StatRepIntervalLineName, StatRepIntervalLineNum )
            select RecId, position, agingPeriodDef, statRepLineNum from custAgingLegalEntity
                exists join custAging
                    where custAging.RecId == custAgingLegalEntity.CustAging
                        && custAging.StatRepInterval == agingPeriodDef
                exists join custTable
                    where custTable.AccountNum == custAging.CustTable
                        && custTable.AccountNum >= fromCustomer
                        && custTable.AccountNum <= toCustomer
                notexists join custAgingLineLocal
                    where custAgingLineLocal.CustAgingLegalEntity == custAgingLegalEntity.RecId
                        && custAgingLineLocal.StatRepIntervalLineName == custAging.StatRepInterval
                        && custAgingLineLocal.StatRepIntervalLineNum == statRepLineNum;
            position--;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveLast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Saves the last value.
    /// </summary>
    public void saveLast()
    {
        // Do not make the call to super because the #CurrentList and #SysLastValues
        // lists are different, requiring that we have specialized logic for the
        // SysLastValues implementation.
        //super();

        // The following fields must be maintained to mimic the functionality of the overriden
        // method.
        inGetSaveLast = true;

        // Persist the pertinent values to the SysLastValue table.
        xSysLastValue::putValue(
            this.packSysLastValues(),
            this.lastValueDataAreaId(),
            this.lastValueUserId(),
            this.lastValueType(),
            this.lastValueElementName(),
            this.lastValueDesignName());

        // This is a RunBaseBatch derivative class. Manually save the user's
        // settings on the batch tab because super() is not being called.
        xSysLastValue::saveLast(this.batchInfo());

        // The following fields must be maintained to mimic the functionality of the overriden
        // method.
        inGetSaveLast = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveSnapshot</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Saves the aging snapshot.
    /// </summary>
    /// <param name="_custAging">
    ///    The <c>CustAging</c> record to save.
    /// </param>
    /// <param name="_custAgingLegalEntity">
    ///    The <c>CustAgingLegalEntity</c> record to save.
    /// </param>
    /// <param name="_balanceList">
    ///    An instance of the <c>CustVendBalanceList</c> class that contains the necessary information to save
    ///    the records in the <c>CustAgingLine</c> table.
    /// </param>
    /// <param name="_sourceCompany">
    ///    The source company of the aging information.
    /// </param>
    /// <param name="_crossCompanyCustTable">
    ///  A <c>CustTable</c> table buffer of the customer the aging the aging will be saved for.
    /// </param>
    protected void saveSnapshot(CustAging _custAging, CustAgingLegalEntity _custAgingLegalEntity, CustVendBalanceList _balanceList, CompanyId _sourceCompany, CustTable _crossCompanyCustTable)
    {
        Array columnToAgingPeriodArray = new Array(Types::Real);
        Array columnToAgingPeriodReportingArray = new Array(Types::Real);

        for (var agingPeriod = 1; agingPeriod <= CustVendBalanceList::numOfBalanceAge() - 1; agingPeriod++)
        {
            columnToAgingPeriodArray.value(agingPeriod, 0.0);
            columnToAgingPeriodReportingArray.value(agingPeriod, 0.0);
        }

        _custAgingLegalEntity.insert();

        // Convert all amounts to the accounting currency of the Ledger that is initiating the snapshot.
        var currencyExchHelper = CurrencyExchangeHelper::newLedger(Ledger::current());
        var originalCompanyCurrency = Ledger::accountingCurrency(CompanyInfo::current(_custAging.DataAreaId));
        var sourceCompanyCurrency = Ledger::accountingCurrency(CompanyInfo::current(_sourceCompany));
        var originalCompanyReportingCurrency = Ledger::reportingCurrency(CompanyInfo::current(_custAging.DataAreaId));
        var sourceCompanyReportingCurrency = Ledger::reportingCurrency(CompanyInfo::current(_sourceCompany));
        
        var agedBalancesMST = conNull();
        var agedSourceBalances = conNull();
        
        var agedBalancesMSTSecondary = conNull();
        var agedSourceBalancesReporting = conNull();


        if (CustAgingSnapshotReduceTempDbUsageFlight::instance().isEnabled())
        {
            agedBalancesMST = custAgingLineCalculation.getSpecificSourceCurrency(_crossCompanyCustTable.AccountNum, originalCompanyCurrency, false);
            agedSourceBalances = custAgingLineCalculation.getSpecificSourceCurrency(_crossCompanyCustTable.AccountNum, originalCompanyCurrency, true);
        
            agedBalancesMSTSecondary = custAgingLineCalculation.getBalancesReportingCurrency(_crossCompanyCustTable.AccountNum, originalCompanyReportingCurrency, true);
            agedSourceBalancesReporting = custAgingLineCalculation.getBalancesReportingCurrency(_crossCompanyCustTable.AccountNum, originalCompanyReportingCurrency, false);       
        }
        else 
        {
            agedBalancesMST = _balanceList.getSpecificSourceCurrency(_crossCompanyCustTable.AccountNum, originalCompanyCurrency, false);
            agedSourceBalances = _balanceList.getSpecificSourceCurrency(_crossCompanyCustTable.AccountNum, originalCompanyCurrency, true);
        
            agedBalancesMSTSecondary = _balanceList.getBalancesReportingCurrency(_crossCompanyCustTable.AccountNum, originalCompanyReportingCurrency, true);
            agedSourceBalancesReporting = _balanceList.getBalancesReportingCurrency(_crossCompanyCustTable.AccountNum, originalCompanyReportingCurrency, false);
        }

        var recordInsertList = new RecordInsertList(tablenum(CustAgingLine));

        var enumerator = agingLineNumList.getEnumerator();
        while (enumerator.moveNext())
        {
            CustAgingLine custAgingLine;
            custAgingLine.CustAgingLegalEntity = _custAgingLegalEntity.RecId;
            custAgingLine.StatRepIntervalLineName = agingPeriodDef;
            custAgingLine.StatRepIntervalLineNum = enumerator.current();

            if (CustAgingSnapshotReduceTempDbUsageFlight::instance().isEnabled())
            {
                custAgingLine.Position = custAgingLineCalculation.getPositionByLineNum(custAgingLine.StatRepIntervalLineNum);
            }
            else
            {
                custAgingLine.Position = _balanceList.getPositionByLineNum(custAgingLine.StatRepIntervalLineNum);
            }

            custAgingLine.OpenBalanceMst = 
                currencyExchHelper.calculateTransactionToAccounting(sourceCompanyCurrency, conpeek(agedBalancesMST, custAgingLine.Position), true)
                + conpeek(agedSourceBalances, custAgingLine.Position);

            if (custAgingLine.OpenBalanceMst != 0 && _custAging.FirstNonzeroBalancePeriod < custAgingLine.Position)
            {
                _custAging.FirstNonzeroBalancePeriod = custAgingLine.Position;
            }
            custAgingLine.OpenBalanceMstSecondary = 
                currencyExchHelper.calculateTransactionCurrencyToReportingCurrency(sourceCompanyReportingCurrency, conpeek(agedBalancesMSTSecondary, custAgingLine.Position), true)
                + conpeek(agedSourceBalancesReporting, custAgingLine.Position);

            columnToAgingPeriodArray.value(custAgingLine.Position, custAgingLine.OpenBalanceMst);
            columnToAgingPeriodReportingArray.value(custAgingLine.Position, custAgingLine.OpenBalanceMstSecondary);
            recordInsertList.add(custAgingLine);
        }

        recordInsertList.insertDatabase();

        this.populateAgingPeriodFieldsForSnapShot(_custAging, columnToAgingPeriodArray, columnToAgingPeriodReportingArray);
        
        _custAging.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateAgingPeriodFieldsForSnapShot</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the aging period fields on the <c>CustAging</c> table buffer.
    /// </summary>
    /// <param name = "_custAging">The <c>CustAging</c> table buffer to populate.</param>
    /// <param name = "_columnToAgingPeriodArray">The array storing values for aging period values.</param>
    /// <param name = "_columnToAgingPeriodReportingArray">The array storing values for the reporting currency period values.</param>
    [Wrappable(true)]
    protected final void populateAgingPeriodFieldsForSnapShot(CustAging _custAging,
        Array _columnToAgingPeriodArray,
        Array _columnToAgingPeriodReportingArray)
    {
        // To improve the performance of rendering collection list page, CustAging table is denormalized by adding
        // the maximum number of aging periods.
        _custAging.AgingPeriod1 += _columnToAgingPeriodArray.value(1);
        _custAging.AgingPeriod2 += _columnToAgingPeriodArray.value(2);
        _custAging.AgingPeriod3 += _columnToAgingPeriodArray.value(3);
        _custAging.AgingPeriod4 += _columnToAgingPeriodArray.value(4);
        _custAging.AgingPeriod5 += _columnToAgingPeriodArray.value(5);
        _custAging.AgingPeriod6 += _columnToAgingPeriodArray.value(6);

        _custAging.AgingPeriod1ReportingCurrency += _columnToAgingPeriodReportingArray.value(1);
        _custAging.AgingPeriod2ReportingCurrency += _columnToAgingPeriodReportingArray.value(2);
        _custAging.AgingPeriod3ReportingCurrency += _columnToAgingPeriodReportingArray.value(3);
        _custAging.AgingPeriod4ReportingCurrency += _columnToAgingPeriodReportingArray.value(4);
        _custAging.AgingPeriod5ReportingCurrency += _columnToAgingPeriodReportingArray.value(5);
        _custAging.AgingPeriod6ReportingCurrency += _columnToAgingPeriodReportingArray.value(6);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Version version = RunBase::getVersion(packedClass);

        switch (version)
        {
            case #CurrentVersion:
                [version,#CurrentList] = packedClass;
                break;

            case #CurrentListV1:
                [version, #CurrentList_v1] = packedClass;
                break;

            case #CurrentListV3:
                [version, #CurrentList_v3] = packedClass;
                break;

            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpackSysLastValues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Unpacks the object for the <c>SysLastValue</c> framework to support user input.
    /// </summary>
    /// <param name="_packedValues">
    ///    A packed instance of the <c>LedgerJournalSave</c> object.
    /// </param>
    /// <remarks>
    ///    This method brings support for inheritance to the <c>SysLastValue</c> implementation on this class.
    ///    Derivative classes should override this method and provide their own implementation with an unpack
    ///    list.
    /// </remarks>
    public void unpackSysLastValues(container _packedValues)
    {
        Version version = RunBase::getVersion(_packedValues);

        switch (version)
        {
            case #SysLastValuesCurrentVersion:
                [version, #SysLastValuesList] = _packedValues;
                break;

            default:
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateParms</Name>
				<Source><![CDATA[
    protected boolean validateParms(boolean _throwError, boolean _showMessages = true)
    {
        boolean isValid = true;

        void handleError(str _errorMessage)
        {
            if (_throwError)
            {
                throw error(_errorMessage);
            }
            else if (_showMessages)
            {
                isValid = checkFailed(_errorMessage);
            }
            else
            {
                isValid = false;
            }
        }

        if (!agingPeriodDef)
        {
            // The aging period definition must be selected before processing an aging snapshot.
            handleError("@SYS132608");
        }

        isValid = isValid && CustVendBalanceList::validateAgingPeriodDefinition(agingPeriodDef, _throwError, _showMessages);

        isValid = isValid && CustCollectionsPool::validatePoolForAgingSnapshot(customerPool, _throwError, _showMessages);

        if (agingDateType == CustAgingDateType::SelectedDate && agingDate == dateNull())
        {
            // The aging date must be selected before processing an aging snapshot.
            handleError("@SYS132601");
        }

        if (conlen(sourceCompanies) == 0)
        {
            // At least one company account range must be selected
            handleError("@SYS310300");
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Constructs an instance of the <c>CustAgingSnapshot</c> class.
    /// </summary>
    /// <returns>
    ///    An instance of the <c>CustAgingSnapshot</c> class.
    /// </returns>
    public static CustAgingSnapshot construct()
    {
        CustAgingSnapshot agingSnapshot = new CustAgingSnapshot();

        return agingSnapshot;
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args args)
    {
        CustAgingSnapshot agingSnapshot = CustAgingSnapshot::construct();

        agingSnapshot.parmShowResults(true);

        if (agingSnapshot.prompt())
        {
            using (SysErrorMessageHelpScope scope = SysErrorMessageHelpScope::newErrorContext(args))
            {
                agingSnapshot.runOperation();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOpenTransactionsCountForCustomer</Name>
				<Source><![CDATA[
    private int getOpenTransactionsCountForCustomer(DirPartyRecId _party)
    {
        CustTransOpen custTransOpen;
        CustTable custTable;

        select crosscompany:sourceCompanies count(RecId) from custTable
            where custTable.Party == _party
            join custTransOpen
                where custTransOpen.AccountNum == custTable.AccountNum;

        return any2int(custTable.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOpenOrderBalanceForCustomer</Name>
				<Source><![CDATA[
    private int getOpenOrderBalanceForCustomer(CustTable _custTable)
    {
        CustCreditLimit custCreditLimit = CustCreditLimit::construct(_custTable);
        return (custCreditLimit.balanceNotInvoiced() - custCreditLimit.balanceDelivered());
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCalculateStatsForZeroBalCustomers</Name>
				<Source><![CDATA[
    /// <summary>
    /// When 'calculate statistics for zero balance customers' is enabled, aging snapshot should be calculated for customers with no posted transactions
    /// However calculating statistics for all the customers will impact performance, to avoid this, we should calculate stats for zero balance customers only if they have open orders or delivered not invoiced transactions
    private boolean shouldCalculateStatsForZeroBalCustomers(CustTable _custTable)
    {
         CustCreditLimit custCreditLimit = CustCreditLimit::construct(_custTable);
         
         //balanceDelivered() is called first to avoid balanceNotInvoiced() call, as balanceNotInvoiced() is calculated by going through all the sales orders.
         return (custParameters.CalculateStatisticsForZeroBalanceCustomers && (custCreditLimit.balanceDelivered() > 0 || custCreditLimit.balanceNotInvoiced() > 0));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    public boolean isRetryable() 
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivityContextForRun</Name>
				<Source><![CDATA[
    private SysInstrumentationActivityContext getActivityContextForRun()
    {
        custInstrumentationLogger = CustInstrumentationLogger::newFromInstrumentationNameSpace(CustAgingInstrumentationConstants::InstrumentationNamespace);
        return custInstrumentationLogger.activityContext(custInstrumentationLogger.activity(
            CustAgingInstrumentationConstants::CustAgingSnapshotProcess,
            CustAgingInstrumentationConstants::InstrumentationNamespace));
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>