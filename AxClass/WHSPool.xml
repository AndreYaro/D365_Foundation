<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSPool</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>WHSPool</c> class is the abstract base class for common business logic for the
///    <c>WHSProdBOMPool</c> and <c>WHSKanbanJobPickingListPool</c> tables.
/// </summary>
public abstract class WHSPool
{
    InventDimParm   inventDimParmPhysicalInvent;
    InventDimParm   inventDimParmPhysicalInventNoLP;
    boolean         inventDimParmsCached;
    List            activePhysicalInventoryDimList;
    JournalId		prodJournalId;    
    
    private UnknownNoYes isCWItem;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addWavedQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Add quantity as waved quantity.
    /// </summary>
    /// <param name="_qtyToAdd">
    ///    The quantity to add.
    /// </param>
    [SysObsolete('Method is obsoleted to support catch weight items. Method is replaced by the addWavedHandlingQty method. Please file an extensibility request if access is required.', false, 30\9\2019)]
    protected abstract void addWavedQty(InventQty _qtyToAdd)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>addWavedHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Add handling quantity as waved quantity.
    /// </summary>
    /// <param name="_qtyToAdd">
    ///    The handling quantity to add.
    /// </param>
    final protected void addWavedHandlingQty(InventHandlingQty _qtyToAdd)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), this.itemId()))
        {
            this.addWavedHandlingQuantities(_qtyToAdd);
        }
        else
        {
            this.addWavedQty(_qtyToAdd);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addWavedHandlingQuantities</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal protected void addWavedHandlingQuantities(InventHandlingQty _qtyToAdd)
    {
        throw error(Error::missingOverride(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineLastBatchConsumed</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the last consumed batch ID.
    /// </summary>
    /// <param name="_inventDim">
    ///    The inventory dimension that holds the warehouse location where the batch was consumed.
    /// </param>
    /// <returns>
    ///    The batch ID.
    /// </returns>
    public abstract InventBatchId determineLastBatchConsumed(InventDim  _inventDim)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineLastSerialConsumed</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the last consumed serial ID.
    /// </summary>
    /// <param name="_inventDim">
    ///    The inventory dimension that holds the warehouse location where the batch was consumed.
    /// </param>
    /// <returns>
    ///    The serial ID.
    /// </returns>
    protected InventSerialId determineLastSerialConsumed(InventDim _inventDim)
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayOrderIdAndItemId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Displays the order ID and item ID in a concatenated string.
    /// </summary>
    /// <returns>
    ///    A string with the order ID and item ID.
    /// </returns>
    public str displayOrderIdAndItemId()
    {
        return strFmt('%1 %2',this.id(),this.itemId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBatchItems</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds batch item inventory.
    /// </summary>
    /// <param name="_inventDim">
    ///    The inventory dimension.
    /// </param>
    /// <param name="_batchActive">
    ///    A Boolean value that indicates if the batch inventory dimension is active.
    /// </param>
    /// <param name="_isWorkCenter">
    ///    A Boolean value that indicates if the transaction takes place at a work center.
    /// </param>
    /// <param name="_allowNegative">
    ///    A Boolean that indicates if a negative quantity is allowed.
    /// </param>
    /// <param name="_ttsId">
    ///    The transaction ID.
    /// </param>
    /// <param name="_pickingQty">
    ///    The picking quantity.
    /// </param>
    /// <param name="_runningQty">
    ///    The running quantity.
    /// </param>
    /// <returns>
    ///    A container of values that includes the <c>InventDim</c> table record with the batch ID.
    /// </returns>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the findBatchItemsHandlingQty method. Extenders should move their logic to wrap or override the findBatchItemsHandlingQuantities method.', false, 30\9\2019)]
    protected container findBatchItems(
        InventDim            _inventDim,
        boolean              _batchActive,
        boolean              _isWorkCenter,
        boolean              _allowNegative,
        CreatedTransactionId _ttsId,
        Qty                  _pickingQty,
        Qty                  _runningQty)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), this.itemId());
        
        return this.findBatchItemsHandlingQuantities(_inventDim,
                                                    _batchActive,
                                                    _isWorkCenter,
                                                    _allowNegative,
                                                    _ttsId,
                                                    _pickingQty,
                                                    _runningQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBatchItemsHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds batch item inventory.
    /// </summary>
    /// <param name="_inventDim">
    ///    The inventory dimension.
    /// </param>
    /// <param name="_batchActive">
    ///    A Boolean value that indicates if the batch inventory dimension is active.
    /// </param>
    /// <param name="_isWorkCenter">
    ///    A Boolean value that indicates if the transaction takes place at a work center.
    /// </param>
    /// <param name="_allowNegative">
    ///    A Boolean that indicates if a negative quantity is allowed.
    /// </param>
    /// <param name="_ttsId">
    ///    The transaction ID.
    /// </param>
    /// <param name="_pickingQty">
    ///    The picking handling quantity.
    /// </param>
    /// <param name="_runningQty">
    ///    The running handling quantity.
    /// </param>
    /// <returns>
    ///    A container of values that includes the <c>InventDim</c> table record with the batch ID.
    /// </returns>
    final protected container findBatchItemsHandlingQty(
        InventDim            _inventDim,
        boolean              _batchActive,
        boolean              _isWorkCenter,
        boolean              _allowNegative,
        CreatedTransactionId _ttsId,
        InventHandlingQty    _pickingQty,
        InventHandlingQty    _runningQty)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), this.itemId()))
        {
            return this.findBatchItemsHandlingQuantities(_inventDim,
                                                        _batchActive,
                                                        _isWorkCenter,
                                                        _allowNegative,
                                                        _ttsId,
                                                        _pickingQty,
                                                        _runningQty);
        }
        
        return this.findBatchItems(_inventDim,
                                _batchActive,
                                _isWorkCenter,
                                _allowNegative,
                                _ttsId,
                                _pickingQty,
                                _runningQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findSerialItemsHandlingQuantities</Name>
				<Source><![CDATA[
    private container findSerialItemsHandlingQuantities(
        InventDim            _inventDim,
        boolean              _isWorkCenter,
        boolean              _allowNegative,
        CreatedTransactionId _ttsId,
        InventHandlingQty    _pickingQty,
        InventHandlingQty    _runningQty)
    {
        // iterate over dims for serial controlled items
        InventTable item = InventTable::find(this.itemId());

        ProdWhsInventSerialOnHandCollectionManagement onHandCollectionManagement = ProdWhsInventSerialOnHandCollectionManagement::newFromParameters(item, _inventDim, _ttsId);
        WHSInventOnHandCollectionEnumerator whsInventOnHandCollectionEnumerator = onHandCollectionManagement.getEnumeratorForDeepestHierarchyLevel();

        InventHandlingQty   useQty;
        InventDim           inventDimFound;
        InventSerialId      lastPhysicalSerialId;

        while (whsInventOnHandCollectionEnumerator.moveNext())
        {
            WHSInventOnHandData whsInventOnHandData = whsInventOnHandCollectionEnumerator.current();
            InventDim inventDim = inventDim::findOrCreate(whsInventOnHandData.parmInventDim()); // if dim found it must include serial

            // Check if inventory is available.
            // If work center we need to check for availability up to the location level.
            if (_isWorkCenter && !_allowNegative)
            {
                useQty = whsInventOnHand::getWorkPhysicalAvailHandlingQty(item.ItemId, inventDim.inventDimId, false);
                inventDimFound.data(inventDim);
            }
            // If loc was specified but serial was not, we need to check serial availability within the location
            // If the item allows negative and is in the work center then we need to check serial availablity within the location
            else if (!_inventDim.inventSerialId
                        || (_allowNegative
                            && _isWorkCenter))
            {
                InventDim inventDimSerialLocation = this.inventDim();
                inventDimSerialLocation.wmsLocationId   = inventDim.wmsLocationId;
                inventDimSerialLocation.inventSerialId  = inventDim.inventSerialId;
                inventDimSerialLocation = InventDim::findOrCreate(inventDimSerialLocation);

                WHSInventReserve whsInventReserve = WHSInventReserve::find(this.ItemId(), inventDimSerialLocation.InventDimId);

                // Must include delta records
                WHSInventReserveDeltaView deltaView = WHSInventReserveDeltaView::findByItemDimId(this.ItemId(), inventDimSerialLocation.inventDimId, _ttsId);
                
                if (this.parmIsCWItem())
                {
                    useQty = whsInventReserve.CWAvailPhysical + deltaView.SumOfCWAvailPhysical;
                }
                else
                {
                    useQty = whsInventReserve.AvailPhysical + deltaView.SumOfAvailPhysical;
                }

                inventDimFound.data(inventDim);
            }

            if (useQty)
            {
                useQty  = min(useQty, (_pickingQty - _runningQty));
                lastPhysicalSerialId = inventDim.inventSerialId;
                break;
            }
        }

        return [lastPhysicalSerialId, useQty, inventDimFound];
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBatchItemsHandlingQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds batch item inventory.
    /// </summary>
    /// <param name="_inventDim">
    /// The inventory dimension.
    /// </param>
    /// <param name="_batchActive">
    /// A Boolean value that indicates if the batch inventory dimension is active.
    /// </param>
    /// <param name="_isWorkCenter">
    /// A Boolean value that indicates if the transaction takes place at a work center.
    /// </param>
    /// <param name="_allowNegative">
    /// A Boolean that indicates if a negative quantity is allowed.
    /// </param>
    /// <param name="_ttsId">
    /// The transaction ID.
    /// </param>
    /// <param name="_pickingQty">
    /// The picking handling quantity.
    /// </param>
    /// <param name="_runningQty">
    /// The running handling quantity.
    /// </param>
    /// <returns>
    /// A container of values that includes the <c>InventDim</c> table record with the batch ID.
    /// </returns>
    /// <remarks>
    /// The method is an extension point and is not meant to be called directly. Callers should call the findBatchItemsHandlingQty method.
    /// </remarks>
    [Wrappable(true)]
    protected container findBatchItemsHandlingQuantities(
        InventDim            _inventDim,
        boolean              _batchActive,
        boolean              _isWorkCenter,
        boolean              _allowNegative,
        CreatedTransactionId _ttsId,
        InventHandlingQty    _pickingQty,
        InventHandlingQty    _runningQty)
    {
        inventDim                 inventDimFound;
        InventBatchId             lastPhysicalBatchId;
        InventHandlingQty         useQty;
        InventHandlingQty         pickingQty    = _pickingQty;
        InventHandlingQty         runningQty    = _runningQty;
        boolean                   batchActive   = _batchActive;
        boolean                   allowNegative = _allowNegative;
        boolean                   doBreak       = false;

        // Loop over dims for batch controlled items
        // Order by production date for batch
        // Only look for physical inventory
        InventTable item = InventTable::find(this.itemId());
        
        var onHandCollectionMgt = ProdWhsInventBatchOnHandCollectionManagement::newFromParameters(item, _inventDim, _ttsId);
        WHSInventOnHandCollectionEnumerator whsInventOnHandCollectionEnumerator = onHandCollectionMgt.getEnumeratorForDeepestHierarchyLevel();

        while (whsInventOnHandCollectionEnumerator.moveNext())
        {
            WHSInventOnHandData whsInventOnHandData = whsInventOnHandCollectionEnumerator.current();
            InventDim inventDim = inventDim::findOrCreate(whsInventOnHandData.parmInventDim());

            // Check if inventory is available.
            // If work center we need to check for availability up to the loc level.
            if (_isWorkCenter && !allowNegative)
            {
                useQty = WHSInventOnHand::getWorkPhysicalAvailHandlingQty(this.ItemId(), inventDim.inventDimId, false);
                inventDimFound.data(inventDim);
            }
            // If loc was specified but batch was not, we need to check batch availability within the location
            // If the item allows negative and is in the work center then we need to check batch availablity within the location
            else if (   batchActive
                     && (!_inventDim.inventBatchId
                     ||  (allowNegative
                     &&   _isWorkCenter)))
            {
                InventDim inventDimBatchLocation = this.inventDim();
                inventDimBatchLocation.wMSLocationId = inventDim.wMSLocationId;
                inventDimBatchLocation.inventBatchId = inventDim.inventBatchId;
                inventDimBatchLocation = InventDim::findOrCreate(inventDimBatchLocation);

                WHSInventReserve whsInventReserve = WHSInventReserve::find(this.ItemId(), inventDimBatchLocation.InventDimId);

                // Must include delta records
                WHSInventReserveDeltaView deltaView = WHSInventReserveDeltaView::findByItemDimId(this.ItemId(), inventDimBatchLocation.inventDimId, _ttsId);
                
                if (!this.parmIsCWItem())
                {
                    useQty = whsInventReserve.AvailPhysical + deltaView.SumOfAvailPhysical;
                }
                else
                {
                    useQty = whsInventReserve.CWAvailPhysical + deltaView.SumOfCWAvailPhysical;
                }
                inventDimFound.data(inventDimBatchLocation);
            }

            if (useQty)
            {
                if (useQty > (pickingQty - runningQty))
                {
                    useQty = (pickingQty - runningQty);
                }
                lastPhysicalBatchId = inventDim.inventBatchId;
                doBreak = true;
                break;
            }
        }

        return [lastPhysicalBatchId,useQty,inventDimFound,doBreak];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimForNegativeSerialConsumption</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Finds the missing serial dimensions when consuming inventory to drive physical inventory negative.
    /// </summary>
    /// <param name = "_inventDim">The <c>InventDim</c> record on which to look for negative on hand where the serial was consumed.</param>
    /// <param name = "_lastPhysicalSerialId">The Serial ID of the last physical serial consumed during this process.</param>
    /// <param name = "_isWorkCenter">A Boolean value that indicates if the transaction takes place at a work center.</param>
    /// <returns>An inventDim with the dimensions to be used for consuming inventory and driving physical inventory negative.</returns>
    /// <exception cref="Exception::Error">The serial could not be determined.</exception>
    protected InventDim getDimForNegativeSerialConsumption(
        InventDim       _inventDim,
        InventSerialId  _lastPhysicalSerialId,
        boolean         _isWorkCenter)
    {
        InventDim inventDim;

        // Find last serial consumed from WorkCenter/location and use that serial
        inventDim.data(_inventDim);
        inventDim.InventSerialId = _lastPhysicalSerialId ? _lastPhysicalSerialId : this.determineLastSerialConsumed(_inventDim);

        if (inventDim.InventSerialId)
        {
            inventDim = InventDim::findOrCreate(inventDim);
        }
        else
        {
            inventDim.clear();

            if (!_isWorkCenter)
            {
                throw error(strFmt("@WAX:SerialNegativeProduction_UnableToPickFromSpecifiedLocation", this.id(), this.itemId(), _inventDim.wmsLocationId));
            }
        }

        return inventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimForNegativeConsumption</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the missing batch dimensions when consuming inventory to drive physical inventory negative.
    /// </summary>
    /// <param name="_inventDim">
    ///    A <c>InventDIm</c> table buffer.
    /// </param>
    /// <param name="_lastPhysicalBatchId">
    ///    The batch ID of the last physical batch consumed during this process.
    /// </param>
    /// <param name="_isWorkCenter">
    ///    A Boolean value that indicates if the transaction takes place at a work center.
    /// </param>
    /// <returns>
    /// An inventDim with the dimensions to be used for consuming inventory and driving physical inventory negative.
    /// </returns>
    /// <exception cref="Exception::Error">
    ///    The batch could not be determined.
    /// </exception>
    protected InventDim getDimForNegativeConsumption(
        InventDim     _inventDim,
        InventBatchId _lastPhysicalBatchId,
        boolean       _isWorkCenter)
    {
        InventDim   inventDim;

        // Find last batch consumed from WorkCenter/location and use that batch
        inventDim.data(_inventDim);
        inventDim.InventBatchId = _lastPhysicalBatchId ? _lastPhysicalBatchId : this.determineLastBatchConsumed(_inventDim);
        if (inventDim.InventBatchId)
        {
            inventDim = InventDim::findOrCreate(inventDim);
        }
        else
        {
            inventDim.clear();
            // Throw error if location was specified on the prodLine.
            if (!_isWorkCenter)
            {
                throw error(strFmt("@WAX3937", this.id(), this.itemId(), _inventDim.wmsLocationId));
            }
        }

        return inventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>id</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ID of the pool.
    /// </summary>
    /// <returns>
    ///    The ID.
    /// </returns>
    public abstract Num id()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromBuffer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the pool record from a table buffer.
    /// </summary>
    /// <param name="_common">
    ///    The table buffer to initialize from.
    /// </param>
    public abstract void initFromBuffer(Common _common)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeValuesFromDimGroupSetup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialized global values based on dim group setup for the item.
    /// </summary>
    private void initializeValuesFromDimGroupSetup()
    {
        InventDimGroupSetup inventDimGroupSetup;

        if (!inventDimParmsCached)
        {
            inventDimGroupSetup = InventMovement::construct(this.movementBuffer()).inventDimGroupSetup();
            inventDimGroupSetup.inventDimParmActivePhysicalInventory(inventDimParmPhysicalInvent);
            inventDimParmPhysicalInventNoLP.data(inventDimParmPhysicalInvent);
            inventDimParmPhysicalInventNoLP.LicensePlateFlag = NoYes::No;
            inventDimParmsCached = true;
        }

        if (activePhysicalInventoryDimList == null)
        {
            activePhysicalInventoryDimList = inventDimGroupSetup.activePhysicalInventoryFields();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the inventory dimension of the pool.
    /// </summary>
    /// <returns>
    ///    The inventory dimension.
    /// </returns>
    public abstract InventDim inventDim()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the inventory transaction ID of the pool.
    /// </summary>
    /// <returns>
    ///    The inventory transaction ID.
    /// </returns>
    public abstract InventTransId inventTransId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransOriginId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the inventory transaction origin of the pool.
    /// </summary>
    /// <returns>
    ///    The inventory transaction origin.
    /// </returns>
    public abstract InventTransOriginId inventTransOriginId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOnOpenWave</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if the pool is on an open wave.
    /// </summary>
    /// <returns>
    ///    true if the current pool is on an open wave; otherwise, false.
    /// </returns>
    public abstract boolean isOnOpenWave()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the item ID of the pool.
    /// </summary>
    /// <returns>
    ///    The item ID.
    /// </returns>
    public abstract ItemId itemId()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsCWItem</Name>
				<Source><![CDATA[
    final internal boolean parmIsCWItem()
    {
        if (isCWItem == UnknownNoYes::Unknown && this.itemId())
        {
            isCWItem = PdsGlobal::pdsIsCWItem(this.itemId()) ? UnknownNoYes::Yes : UnknownNoYes::No;
        }

        return isCWItem == UnknownNoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>movementBuffer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the inventory movement buffer of the pool.
    /// </summary>
    /// <param name="_forUpdate">
    ///    A Boolean value indicating if the buffer should be selected for update; optional.
    /// </param>
    /// <returns>
    ///    The inventory movement buffer.
    /// </returns>
    protected abstract Common movementBuffer(boolean _forUpdate = false)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickFromWorkCenter</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Picks inventory from a work center location.
    /// </summary>
    /// <param name="_inventDim">
    ///    The inventory dimension to pick from.
    /// </param>
    /// <param name="_workCenterQty">
    ///    The quantity available in the work center.
    /// </param>
    /// <param name="_reservedQty">
    ///    The quantity currently reserved by the source line transaction.
    /// </param>
    /// <param name="_isWorkCenter">
    ///    A Boolean value that indicates if the location is a work center.
    /// </param>
    /// <returns>
    ///    true if work should be created; otherwise, false.
    /// </returns>
    [SysObsolete('Method is obsoleted to support catch weight items. Method is replaced by the pickFromWorkCenterHandlingQty method. Please file an extensibility request if access is required.', false, 30\9\2019)]
    public boolean pickFromWorkCenter(
        InventDim   _inventDim,
        InventQty   _workCenterQty,
        InventQty   _reservedQty,
        boolean     _isWorkCenter)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), this.itemId());

        return this.pickFromWorkCenterHandlingQuantities(_inventDim, _workCenterQty, _reservedQty, _isWorkCenter);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickFromWorkCenterHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Picks inventory from a work center location.
    /// </summary>
    /// <param name="_inventDim">
    ///    The inventory dimension to pick from.
    /// </param>
    /// <param name="_workCenterQty">
    ///    The handling quantity available in the work center.
    /// </param>
    /// <param name="_reservedQty">
    ///    The handling quantity currently reserved by the source line transaction.
    /// </param>
    /// <param name="_isWorkCenter">
    ///    A Boolean value that indicates if the location is a work center.
    /// </param>
    /// <returns>
    ///    true if work should be created; otherwise, false.
    /// </returns>
    [Hookable(false)]
    final public boolean pickFromWorkCenterHandlingQty(
        InventDim           _inventDim,
        InventHandlingQty   _workCenterQty,
        InventHandlingQty   _reservedQty,
        boolean             _isWorkCenter)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), this.itemId()))
        {
            return this.pickFromWorkCenterHandlingQuantities(_inventDim, _workCenterQty, _reservedQty, _isWorkCenter);
        }

        return this.pickFromWorkCenter(_inventDim, _workCenterQty, _reservedQty, _isWorkCenter);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickFromWorkCenterHandlingQuantities</Name>
				<Source><![CDATA[
    private boolean pickFromWorkCenterHandlingQuantities(
        InventDim           _inventDim,
        InventHandlingQty   _workCenterQty,
        InventHandlingQty   _reservedQty,
        boolean             _isWorkCenter)
    {
        boolean allowNegative;

        InventHandlingQty qtyLeftToWave = _reservedQty - WHSPool::calcOpenAndFrozenWorkHandlingQty(this.inventTransId(), _inventDim);
        InventHandlingQty pickingQty = min(_workCenterQty, qtyLeftToWave);

        // Determine if item allow picking the location Negative
        if (InventTable::find(this.ItemId()).whsAllowPhysNeg() && _inventDim.wmsLocation().whsLocationProfile().AllowNegative &&
            (!_isWorkCenter || WHSInventTable::find(this.ItemId()).PickWCNeg))
        {
            allowNegative = true;
        }

        createdTransactionId ttsId = InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().ttsId();

        return this.pickInventoryHandlingQty(_inventDim, _workCenterQty, _reservedQty, _isWorkCenter, pickingQty, qtyLeftToWave, ttsId, allowNegative);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickInventoryHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Picks the total inventory quantity form a work center location.
    /// </summary>
    /// <param name="_inventDim">
    ///    The inventory dimension to pick from.
    /// </param>
    /// <param name="_workCenterQty">
    ///    The handling quantity available in the work center.
    /// </param>
    /// <param name="_reservedQty">
    ///    The handling quantity currently reserved by the source line transaction.
    /// </param>
    /// <param name="_isWorkCenter">
    ///    A Boolean value that indicates if the location is a work center.
    /// </param>
    /// <param name="_pickingQty">
    ///    The total inventory handling quantity to be picked form a work center location.
    /// </param>
    /// <param name="_qtyLeftToWave">
    ///    The handling quantity that is remaining to be waved.
    /// </param>
    /// <param name="_createdTransactionId">
    ///    The transaction ID.
    /// </param>
    /// <param name="_allowNegative">
    ///    A Boolean that indicates if a negative quantity is allowed.
    /// </param>
    /// <returns>
    ///    true if work should be created; otherwise, false.
    /// </returns>
    final internal protected boolean pickInventoryHandlingQty(
        InventDim               _inventDim,
        InventHandlingQty       _workCenterQty,
        InventHandlingQty       _reservedQty,
        boolean                 _isWorkCenter,
        InventHandlingQty       _pickingQty,
        InventHandlingQty       _qtyLeftToWave,
        createdTransactionId    _createdTransactionId,
        boolean                 _allowNegative)
    {
        return this.pickInventoryHandlingQuantities(_inventDim,
                                                    _workCenterQty,
                                                    _reservedQty,
                                                    _isWorkCenter,
                                                    _pickingQty,
                                                    _qtyLeftToWave,
                                                    _createdTransactionId,
                                                    _allowNegative);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSerialBelowActive</Name>
				<Source><![CDATA[
    private boolean isSerialBelowActive(InventTable _inventTable)
    {
        return (_inventTable.isItemSerialNumberActivated()
             && WhsReservationHierarchyInventDimUtil::isSerialBelowLocation(_inventTable));
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDetermineAdditionalDimensionForNegativePicking</Name>
				<Source><![CDATA[
    private boolean mustDetermineAdditionalDimensionForNegativePicking(
        InventDim           _inventDim,
        boolean             _allowNegative,
        boolean             _batchActive,
        boolean             _foundSerial,
        InventHandlingQty   _useQty)
    {
        boolean batchActiveNoBatchSpecified  = (_batchActive && !_inventDim.inventBatchId);
        boolean serialFoundNoSerialSpecified = (_foundSerial && !_inventDim.inventSerialId);
        
        return !_useQty && _allowNegative && (batchActiveNoBatchSpecified || serialFoundNoSerialSpecified);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickInventoryHandlingQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Picks the total inventory handling quantity form a work center location.
    /// </summary>
    /// <param name="_inventDim">
    ///    The inventory dimension to pick from.
    /// </param>
    /// <param name="_workCenterQty">
    ///    The handling quantity available in the work center.
    /// </param>
    /// <param name="_reservedQty">
    ///    The handling quantity currently reserved by the source line transaction.
    /// </param>
    /// <param name="_isWorkCenter">
    ///    A Boolean value that indicates if the location is a work center.
    /// </param>
    /// <param name="_pickingQty">
    ///    The total inventory handling quantity to be picked form a work center location.
    /// </param>
    /// <param name="_qtyLeftToWave">
    ///    The handling quantity that is remaining to be waved.
    /// </param>
    /// <param name="_createdTransactionId">
    ///    The transaction ID.
    /// </param>
    /// <param name="_allowNegative">
    ///    A Boolean that indicates if a negative quantity is allowed.
    /// </param>
    /// <returns>
    ///    true if work should be created; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The method is an extension point and is not meant to be called directly. Callers should call the pickInventoryHandlingQty method.
    /// </remarks>
    [Wrappable(true)]
    protected boolean pickInventoryHandlingQuantities(
        InventDim               _inventDim,
        InventHandlingQty       _workCenterQty,
        InventHandlingQty       _reservedQty,
        boolean                 _isWorkCenter,
        InventHandlingQty       _pickingQty,
        InventHandlingQty       _qtyLeftToWave,
        createdTransactionId    _createdTransactionId,
        boolean                 _allowNegative)

    {
        InventDim inventDim;
        InventSum inventSum;
        InventHandlingQty runningQty;
        InventHandlingQty useQty;
        InventHandlingQty qtyToPick;
        InventTable inventTable = InventTable::find(this.ItemId());
        boolean batchActive = inventTable.whsBatchActive();
        InventBatchId lastPhysicalBatchId;
        boolean unableToDetermineDimensions;
        boolean createWork = true;

        if (_workCenterQty >= _qtyLeftToWave)
        {
            createWork = false;
        }

        inventDim.clear();
        inventSum.clear();

        InventSerialId lastPhysicalSerialId;
        boolean foundSerialItemHandlingQuantities;
        boolean mustDetermineAdditionalDimensionsForNonBatchSerialItem = false;
        boolean isMustDetermineAdditionalDimensionsForNonBatchSerialItemInitialized = false;

        while (runningQty < _pickingQty)
        {
            [lastPhysicalBatchId, useQty, inventDim] = this.findBatchItemsHandlingQty(_inventDim, batchActive, _isWorkCenter,
                                                                           _allowNegative, _createdTransactionId, _pickingQty, runningQty);

            /* 
                Attempt to find the quantity used and the dimension set of any serial below items that are not batch tracked.
                These should be consumed based on first serial found, and are included in the above method if batch is tracked so that should be ignored here.
            */ 
            boolean isSerialBelowActive = this.isSerialBelowActive(inventTable);

            if (!batchActive && isSerialBelowActive)
            {
                [lastPhysicalSerialId, useQty, inventDim] = this.findSerialItemsHandlingQuantities(_inventDim, 
                    _isWorkCenter,
                    _allowNegative, 
                    _createdTransactionId, 
                    _pickingQty, 
                    runningQty);

                foundSerialItemHandlingQuantities = true;
            }

            if (!inventDim)
            {
                if (!isMustDetermineAdditionalDimensionsForNonBatchSerialItemInitialized)
                {
                    mustDetermineAdditionalDimensionsForNonBatchSerialItem = this.mustDetermineAdditionalDimensionsForNonBatchSerialItem(_inventDim, batchActive, isSerialBelowActive);
                    isMustDetermineAdditionalDimensionsForNonBatchSerialItemInitialized = true;
                }

                if (mustDetermineAdditionalDimensionsForNonBatchSerialItem)
                {
                    [useQty, inventDim] = this.determineAdditionalDimensionsForNonBatchSerialItem(inventTable, _inventDim, _pickingQty - runningQty, _createdTransactionId);
                }
            }

            // If we didn't find qty to pick, the item allows negative, no batch was specified, and the item is batch active...
            // Then we must determine what batch to pick.
            if (this.mustDetermineAdditionalDimensionForNegativePicking(inventDim, _allowNegative, batchActive, foundSerialItemHandlingQuantities, useQty))
            {
                if (batchActive)
                {
                    inventDim = this.getDimForNegativeConsumption(_inventDim, lastPhysicalBatchId, _isWorkCenter);
                }
                else // must be serial as it is found in the mustDetermine check above
                {
                    inventDim = this.getDimForNegativeSerialConsumption(_inventDim, lastPhysicalSerialId, _isWorkCenter);
                }

                if (inventDim.InventDimId)
                {
                    useQty = _pickingQty;
                }
                else
                {
                    createWork = true;
                    unableToDetermineDimensions = true;
                }
            }

            if (useQty)
            {
                qtyToPick = useQty;
            }
            else if (!unableToDetermineDimensions)
            {
                qtyToPick = _workCenterQty;

                if (qtyToPick > _qtyLeftToWave)
                {
                    qtyToPick = _qtyLeftToWave - runningQty;
                }
                if (!inventDim)
                {
                    inventDim = _inventDim;
                }
            }

            if (qtyToPick <= 0)
            {
                createWork = true;
                break;
            }

            ttsbegin;

            if (this.validateInventDimForPick(inventDim))
            {
                this.pickHandlingQtyFromWorkCenter(inventDim, qtyToPick);
            }

            ttscommit;

            ProdBOM prodBOM = ProdBOM::findTransId(this.inventTransId());

            if (prodBOM.prodTable().ProdStatus == ProdStatus::StartedUp
                && prodBOM.flushingPrinciple() == ProdFlushingPrincipBOM::Picked)
            {
                prodJournalId = WHSPostProdJournal::createJournalLineFromTransaction(this.inventTransId(), inventDim.inventDimId, qtyToPick, prodJournalId);
            }
            runningQty += qtyToPick;
        }

        return createWork;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDetermineAdditionalDimensionsForNonBatchSerialItem</Name>
				<Source><![CDATA[
    private boolean mustDetermineAdditionalDimensionsForNonBatchSerialItem(InventDim _inventDim, boolean _isBatchActive, boolean _isSerialBelowActive)
    {
        if (_isBatchActive || _isSerialBelowActive)
        {
            return false;
        }

        return !this.validateInventDimForPick(_inventDim);
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineAdditionalDimensionsForNonBatchSerialItem</Name>
				<Source><![CDATA[
    private container determineAdditionalDimensionsForNonBatchSerialItem(InventTable _inventTable, InventDim _inventDim, InventHandlingQty _qtyLeftToPick, createdTransactionId _ttsId)
    {
        InventDimParm inventDimParmCriteria;
        inventDimParmCriteria.initFromInventDim(_inventDim);

        const boolean includeOrdered = false;
        const boolean includePhysical = true;
        const boolean mustIncludeDelta = true;
        const boolean onlyReserveOnWHSEnabledWarehouses = true;

        WHSReservationOnHandCollectionEnumeratorBuilderParameters parameters = WHSReservationOnHandCollectionEnumeratorBuilderParameters::newFromParameters(
                InventMovement::construct(this.movementBuffer()),
                _inventDim,
                inventDimParmCriteria,
                this.retrieveBottomHierarchyLevel(_inventTable),
                _ttsId,
                includeOrdered,
                includePhysical,
                mustIncludeDelta,
                onlyReserveOnWHSEnabledWarehouses);

        WHSInventOnHandCollectionEnumerator whsInventOnHandCollectionEnumerator = WHSReservationOnHandCollectionEnumeratorBuilder::newFromParameters(parameters).buildOnHandEnumerator();

        if (whsInventOnHandCollectionEnumerator.moveNext())
        {
            WHSInventOnHandData whsInventOnHandData = whsInventOnHandCollectionEnumerator.current();
            InventDim inventDimWithAllDimensions = whsInventOnHandData.parmInventDim();

            InventHandlingQty useQty = whsInventOnHand::getWorkPhysicalAvailHandlingQty(this.ItemId(), inventDimWithAllDimensions.inventDimId, false);

            if (useQty > _qtyLeftToPick)
            {
                useQty = _qtyLeftToPick;
            }

            if (useQty)
            {
                return [useQty, inventDimWithAllDimensions];
            }
        }

        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveBottomHierarchyLevel</Name>
				<Source><![CDATA[
    private WHSReservationHierarchyLevel retrieveBottomHierarchyLevel(InventTable _inventTable)
    {
        return WHSReservationHierarchyProvider::construct().getBottomHierarchyLevel(_inventTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickHandlingQtyFromWorkCenter</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Picks the specified inventory handling quantity form a work center location.
    /// </summary>
    /// <param name="_inventDim">
    ///    The inventory dimension to pick from.
    /// </param>
    /// <param name="_handlingQtyToPick">
    ///    The handling quantity to be picked.
    /// </param>
    [Wrappable(false)]
    protected void pickHandlingQtyFromWorkCenter(InventDim _inventDim, InventHandlingQty _handlingQtyToPick)
    {
        if (PdsGlobal::pdsIsCWItem(this.itemId()))
        {
            this.pickQuantitiesFromWorkCenter(_inventDim, 0, _handlingQtyToPick);
        }
        else
        {
            this.pickQuantitiesFromWorkCenter(_inventDim, _handlingQtyToPick, 0);            
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pickQuantitiesFromWorkCenter</Name>
				<Source><![CDATA[
    private void pickQuantitiesFromWorkCenter(InventDim _inventDim, InventQty _qtyToPick, PDSCWInventQty _cwQtyToPick)
    {
        using (var context = WhsInventPickingContext::newSkipPickIdAllocation())
        {
            if (PdsGlobal::pdsIsCWItem(this.itemId()))
            {
                // For catch weight items we must take the average weight based on inventory and use that average weight when picking against the prodBOM.
                InventQty weightToPick = WHSCatchWeightHelper::calculateDefaultWeightForPick(this.itemId(), _inventDim, _cwQtyToPick, InventTable::inventDecimals(this.itemId()));
                WHSInvent::pickQuantities(this.movementBuffer(true), _inventDim.InventDimId, weightToPick, _cwQtyToPick, WHSReservationHierarchyInventDimUtil::initInventDimParmAboveLocation(InventTable::find(this.itemId())));
            }
            else
            {
                WHSInvent::pickQuantities(this.movementBuffer(), _inventDim.InventDimId, _qtyToPick, 0,
                                        WHSReservationHierarchyInventDimUtil::initInventDimParmAboveLocation(InventTable::find(this.itemId())));
            }
        }

        this.addWavedHandlingQty(_qtyToPick);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpickHandlingQtyFromWorkCenter</Name>
				<Source><![CDATA[
    private void unpickHandlingQtyFromWorkCenter(InventDimId _inventDimId, InventQty _qtyToUnpick, PDSCWInventQty _cwQtyToUnpick)
    {
        this.addWavedHandlingQty(-_qtyToUnpick);

        if (PdsGlobal::pdsIsCWItem(this.itemId()))
        {
            WHSInvent::pickQuantities(this.movementBuffer(true), _inventDimId, -_qtyToUnpick, -_cwQtyToUnpick, WHSReservationHierarchyInventDimUtil::initInventDimParmAboveLocation(InventTable::find(this.itemId())));
        }
        else
        {
            WHSInvent::pickQuantities(this.movementBuffer(), _inventDimId, -_qtyToUnpick, 0,
                                        WHSReservationHierarchyInventDimUtil::initInventDimParmAboveLocation(InventTable::find(this.itemId())));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unPickHandlingQuantities</Name>
				<Source><![CDATA[
    internal void unPickHandlingQuantities(InventTransId _inventTransId, InventQty _qtyToUnpick, PDSCWInventQty _cwQtyToUnpick)
    {
        InventTrans inventTrans;
        InventTransOrigin inventTransOrigin;
        InventQty inventTransQty;
        PdsCWInventQty cwTransQty;

        InventQty runningQty;
        PdsCWInventQty runningCWQty;

        boolean catchWeightItem = this.parmIsCWItem();

        while select inventDimId, Qty, PdsCWQty from inventTrans
            where inventTrans.StatusIssue == StatusIssue::Picked
            exists join inventTransOrigin
                where inventTransOrigin.RecId == inventTrans.InventTransOrigin
                   && inventTransOrigin.InventTransId == _inventTransId
        {
            if ((!catchWeightItem && runningQty == _qtyToUnpick) 
                || (catchWeightItem && runningCWQty == _cwQtyToUnpick))
            {
                break;
            }

            inventTransQty = min(-inventTrans.Qty, _qtyToUnpick - runningQty);
            if (catchWeightItem)
            {
                cwTransQty = min(-inventTrans.PdsCWQty, _cwQtyToUnpick - runningCWQty);
            }

            this.unpickHandlingQtyFromWorkCenter(inventTrans.inventDimId, inventTransQty, cwTransQty);
            runningQty += inventTransQty;
            runningcwQty += cwTransQty;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pool</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the current pool record.
    /// </summary>
    /// <returns>
    ///    The pool record.
    /// </returns>
    public abstract Common pool()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyLeftToWave</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the quantity that is left to wave.
    /// </summary>
    /// <returns>
    ///    The quantity left to wave.
    /// </returns>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the handlingQtyLeftToWave method. Extenders should move their logic to wrap or override the handlingQuantityLeftToWave method.', false, 30\9\2019)]
    public abstract InventQty qtyLeftToWave()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>handlingQtyLeftToWave</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the handling quantity that is left to wave.
    /// </summary>
    /// <returns>
    ///    The handling quantity left to wave.
    /// </returns>
    [Hookable(false)]
    final public InventHandlingQty handlingQtyLeftToWave()
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), this.itemId()))
        {
            return this.handlingQuantityLeftToWave();
        }

        return this.qtyLeftToWave();
    }

]]></Source>
			</Method>
			<Method>
				<Name>handlingQuantityLeftToWave</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the handling quantity that is left to wave.
    /// </summary>
    /// <returns>
    /// The handling quantity left to wave.
    /// </returns>
    /// <remarks>
    /// The method is an extension point and is not meant to be called directly. Callers should call the handlingQtyLeftToWave method.
    /// </remarks>
    [Wrappable(true)]
    protected internal InventHandlingQty handlingQuantityLeftToWave()
    {
        throw error(Error::missingOverride(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>reservedInventQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the pool quantity that is physically reserved.
    /// </summary>
    /// <returns>
    ///    The physically reserved pool quantity.
    /// </returns>
    public InventQty reservedInventQty()
    {
        return -InventTransIdSum::newTransOriginId(this.inventTransOriginId()).reservPhysical();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reservedCWInventQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the pool catch weight quantity that is physically reserved.
    /// </summary>
    /// <returns>
    ///    The physically reserved pool catch weight quantity.
    /// </returns>
    public PdsCWInventQty reservedCWInventQty()
    {
        return -InventTransIdSum::newTransOriginId(this.inventTransOriginId()).pdsCWReservPhysical();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInventDimForPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the inventDim has all required physical inventory dimensions set and is valid for pick.
    /// </summary>
    /// <param name="_inventDim">
    /// The inventDim being validated.
    /// </param>
    /// <returns>
    /// true if the inventDim is valid for pick; otherwise; false.
    /// </returns>
    private boolean validateInventDimForPick(
        InventDim   _inventDim)
    {
        InventDimParm       inventDimParm;

        this.initializeValuesFromDimGroupSetup();

        if (_inventDim.wmsLocationId
        &&  _inventDim.InventLocationId
        &&  !_inventDim.wmsLocation().whsLocationIsLPControlled())
        {
            inventDimParm = inventDimParmPhysicalInventNoLP;
        }
        else
        {
            inventDimParm = inventDimParmPhysicalInvent;
        }

        return _inventDim.allInventDimParmFieldsHaveValues(inventDimParm, activePhysicalInventoryDimList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>waveTemplateType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the wave template type for the pool.
    /// </summary>
    /// <returns>
    ///    The wave template type.
    /// </returns>
    public abstract WHSWaveTemplateType waveTemplateType()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcOpenAndFrozenWorkQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total quantity that is being  processed and the quantity that is frozen by work.
    /// </summary>
    /// <param name="_inventTransId">
    /// The inventtransId to find work for.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// An the inventory dimensions to find work for.
    /// </param>
    /// <returns>
    /// The total quantity that is being  processed and the quantity that is frozen by work.
    /// </returns>
    [SysObsolete('Method is obsoleted to support catch weight items. Method is replaced by the calcOpenAndFrozenWorkHandlingQty method. Please file an extensibility request if access is required.', true, 30\9\2019)]
    public static InventQty calcOpenAndFrozenWorkQty(
        InventTransId   _inventTransId,
        InventDim       _inventDimCriteria
        )
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), InventTransOrigin::findByInventTransId(_inventTransId).ItemId);
        
        return WHSPool::calcOpenAndFrozenWorkHandlingQuantities(_inventTransId, _inventDimCriteria);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcOpenAndFrozenWorkHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total handling quantity that is being processed and the handling quantity that is frozen by work.
    /// </summary>
    /// <param name="_inventTransId">
    /// The inventtransId to find work for.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// An the inventory dimensions to find work for.
    /// </param>
    /// <returns>
    /// The total handling quantity that is being processed and the handling quantity that is frozen by work.
    /// </returns>
    public static InventHandlingQty calcOpenAndFrozenWorkHandlingQty(
        InventTransId   _inventTransId,
        InventDim       _inventDimCriteria)
    {
        ItemId itemId = InventTransOrigin::findByInventTransId(_inventTransId).ItemId;

        if (WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), itemId))
        {
            WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), itemId);
        }

        return WHSPool::calcOpenAndFrozenWorkHandlingQuantities(_inventTransId, _inventDimCriteria);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcOpenAndFrozenWorkHandlingQuantities</Name>
				<Source><![CDATA[
    private static InventHandlingQty calcOpenAndFrozenWorkHandlingQuantities(
        InventTransId   _inventTransId,
        InventDim       _inventDimCriteria)
    {
        InventTable inventTable = InventTransOrigin::findByInventTransId(_inventTransId).inventTable();

        InventDimParm inventDimParm = WHSReservationHierarchyInventDimUtil::initInventDimParmAboveLocation(inventTable);

        // Find the total handling qty of open and in process work.
        WHSInventQty openWorkQty = WHSPool::calculateOpenWorkHandlingQty(_inventTransId,_inventDimCriteria,inventDimParm);

        // Find total handling qty of work that has been frozen and is being overpicked by other work
        // WHSWorkFrozen records are deleted as the overpicking work is completed.
        WHSInventQty frozenWorkQty = WHSPool::calculateWorkFrozenHandlingQty(_inventTransId,_inventDimCriteria,inventDimParm);

        return openWorkQty + frozenWorkQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateOpenWorkHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the handling quantity that is being processed by work.
    /// </summary>
    /// <param name="_inventTransId">
    /// The inventtransId to find work for.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// An the inventory dimensions to find work for.
    /// </param>
    /// <param name="_inventDimParmCriteria">
    /// An <c>InventDimParm</c> buffer used for finding work.
    /// </param>
    /// <returns>
    /// The handling quantity that is being processed by work.
    /// </returns>
    public static InventHandlingQty calculateOpenWorkHandlingQty(
        InventTransId   _inventTransId,
        InventDim       _inventDimCriteria,
        InventDimParm   _inventDimParmCriteria)
    {
        return WHSPool::calculateOpenWorkHandlingQuantities(_inventTransId, _inventDimCriteria, _inventDimParmCriteria);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateOpenWorkHandlingQuantities</Name>
				<Source><![CDATA[
    private static InventHandlingQty calculateOpenWorkHandlingQuantities(
        InventTransId   _inventTransId,
        InventDim       _inventDimCriteria,
        InventDimParm   _inventDimParmCriteria)
    {
        WHSWorkTable        workTable;
        WHSWorkLine         workLine;
        InventDim           inventDim;
        WHSWorkLine         workLinePut;

        select sum(InventQtyWork) from workLine
            where workLine.WorkType == WHSWorkType::Pick
                && workLine.WorkStatus != WHSWorkStatus::Cancelled
                && workLine.InventTransId == _inventTransId
            exists join workTable
                where (workTable.WorkStatus == WHSWorkStatus::Open
                        || workTable.WorkStatus == WHSWorkStatus::InProcess)
                    && workTable.WorkId == workLine.WorkId
            #InventDimExistsJoin(workLine.InventDimId, inventDim, _inventDimCriteria, _inventDimParmCriteria)
            notexists join workLinePut
                where workLinePut.WorkId == workLine.WorkId 
                    && workLinePut.LineNum < workLine.LineNum
                    && workLinePut.WorkType == WHSWorkType::Put
                    && workLinePut.WorkStatus != WHSWorkStatus::Cancelled;

        return workLine.InventQtyWork;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateWorkFrozenQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the quantity that is being  frozen by work.
    /// </summary>
    /// <param name="_inventTransId">
    /// The inventtransId to find work for.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// An the inventory dimensions to find work for.
    /// </param>
    /// <param name="_inventDimParmCriteria">
    /// An <c>InventDimParm</c> buffer used for finding work.
    /// </param>
    /// <returns>
    /// The quantity that is being frozen by work.
    /// </returns>
    [SysObsolete('Method is obsoleted to support catch weight items. Please file an extensibility request if access is required.', false, 30\9\2019)]
    public static WHSInventQty calculateWorkFrozenQty(
        InventTransId   _inventTransId,
        InventDim       _inventDimCriteria,
        InventDimParm   _inventDimParmCriteria)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), InventTransOrigin::findByInventTransId(_inventTransId).ItemId);
        
        return WHSPool::calculateWorkFrozenHandlingQuantities(_inventTransId, _inventDimCriteria, _inventDimParmCriteria);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateWorkFrozenHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the quantity that is being  frozen by work.
    /// </summary>
    /// <param name="_inventTransId">
    /// The inventtransId to find work for.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// An the inventory dimensions to find work for.
    /// </param>
    /// <param name="_inventDimParmCriteria">
    /// An <c>InventDimParm</c> buffer used for finding work.
    /// </param>
    /// <returns>
    /// The handling quantity that is being frozen by work.
    /// </returns>
    [Hookable(false)]
    internal static InventHandlingQty calculateWorkFrozenHandlingQty(
        InventTransId   _inventTransId,
        InventDim       _inventDimCriteria,
        InventDimParm   _inventDimParmCriteria)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), InventTransOrigin::findByInventTransId(_inventTransId).ItemId))
        {
            return WHSPool::calculateWorkFrozenHandlingQuantities(_inventTransId, _inventDimCriteria, _inventDimParmCriteria);
        }

        return WHSPool::calculateWorkFrozenQty(_inventTransId, _inventDimCriteria, _inventDimParmCriteria);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateWorkFrozenHandlingQuantities</Name>
				<Source><![CDATA[
    private static InventHandlingQty calculateWorkFrozenHandlingQuantities(
        InventTransId   _inventTransId,
        InventDim       _inventDimCriteria,
        InventDimParm   _inventDimParmCriteria)
    {
        WHSWorkFrozen   workFrozen;
        InventDim       inventDimJoin;

        select sum(Qty) from workFrozen
            where workFrozen.InventTransId == _inventTransId
        #InventDImExistsJoin(workFrozen.FrozenWorkInventDimId, inventDimJoin, _inventDimCriteria, _inventDimParmCriteria);

        return  workFrozen.Qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProdJournalId</Name>
				<Source><![CDATA[
    public JournalId parmProdJournalId(JournalId _prodJournalId = prodJournalId)
    {
        prodJournalId = _prodJournalId;
        return prodJournalId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeWarehousePolicy</Name>
				<Source><![CDATA[
	/// <summary>
	///  Method will reserve or pick raw materials based upon <c>WHSRawMaterialPolicy</c>.
	/// </summary>
	/// <param name="_inventTrans">
	///  <c>InventTrans</c> buffer.
	/// </param>
	/// <param name="_waveId">
	///  The wave currently being released.
	/// </param>
	/// <param name="_waveExecutionId">
	///  The execution id for the wave currently being released.
	/// </param>
	/// <param name="_wrkCtrInventDim">
	///  The inventory dimensions for work center where raw materials will be reserved or picked.
	/// </param>
	/// <param name="_isWorkCenter">
	///  A Boolean value that indicates if the location is a work center.
	/// </param>
	/// <param name="_skipReservation">
	///  A Boolean value that indicates if the reservation should be skipped because the inventory is already reserved at the picking location.
	/// </param>
	/// <param name="_workCenterQty">
	///  The quantity available in the work center, defaulted to the quantity on the <c>InventTrans</c> buffer.
	/// </param>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the executeWarehousePolicyHandlingQty method. Extenders should move their logic to wrap or override the executeWarehousePolicyHandlingQuantity method.', false, 30\9\2019)]
	public void executeWarehousePolicy(
        InventTrans          _inventTrans,
		WHSWaveId            _waveId,
		WHSWaveExecutionID   _waveExecutionId,
		InventDim            _wrkCtrInventDim,
		boolean              _isWorkCenter,
		boolean              _skipReservation    = false,
		InventQty            _workCenterQty      = -_inventTrans.Qty)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), this.itemId());

        this.executeWarehousePolicyHandlingQuantity(_inventTrans,
                                    _waveId,
                                    _waveExecutionId,
                                    _wrkCtrInventDim,
                                    _isWorkCenter,
                                    _skipReservation,
                                    _workCenterQty,
                                    -_inventTrans.Qty);
	}

]]></Source>
			</Method>
			<Method>
				<Name>executeWarehousePolicyHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Method will reserve or pick raw materials based upon <c>WHSRawMaterialPolicy</c>.
    /// </summary>
    /// <param name="_inventTrans">
    ///  <c>InventTrans</c> buffer.
    /// </param>
    /// <param name="_waveId">
    ///  The wave currently being released.
    /// </param>
    /// <param name="_waveExecutionId">
    ///  The execution id for the wave currently being released.
    /// </param>
    /// <param name="_wrkCtrInventDim">
    ///  The inventory dimensions for work center where raw materials will be reserved or picked.
    /// </param>
    /// <param name="_isWorkCenter">
    ///  A Boolean value that indicates if the location is a work center.
    /// </param>
    /// <param name="_skipReservation">
    ///  A Boolean value that indicates if the reservation should be skipped because the inventory is already reserved at the picking location.
    /// </param>
    /// <param name="_workCenterQty">
    ///  The handling quantity available in the work center, defaulted to the quantity on the <c>InventTrans</c> buffer.
    /// </param>
    [Hookable(false)]
    final public void executeWarehousePolicyHandlingQty(
        InventTrans          _inventTrans,
        WHSWaveId            _waveId,
        WHSWaveExecutionID   _waveExecutionId,
        InventDim            _wrkCtrInventDim,
        boolean              _isWorkCenter,
        boolean              _skipReservation,
        InventHandlingQty    _workCenterQty)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), this.itemId()))
        {
            this.executeWarehousePolicyHandlingQuantity(_inventTrans,
                                        _waveId,
                                        _waveExecutionId,
                                        _wrkCtrInventDim,
                                        _isWorkCenter,
                                        _skipReservation,
                                        _workCenterQty,
                                        -_inventTrans.PdsCWQty);
        }
        else
        {
            this.executeWarehousePolicy(_inventTrans,
                                        _waveId,
                                        _waveExecutionId,
                                        _wrkCtrInventDim,
                                        _isWorkCenter,
                                        _skipReservation,
                                        _workCenterQty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeWarehousePolicyHandlingQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reserves or picks raw materials based upon <c>WHSRawMaterialPolicy</c>.
    /// </summary>
    /// <param name="_inventTrans">
    ///  <c>InventTrans</c> buffer.
    /// </param>
    /// <param name="_waveId">
    ///  The wave currently being released.
    /// </param>
    /// <param name="_waveExecutionId">
    ///  The execution id for the wave currently being released.
    /// </param>
    /// <param name="_wrkCtrInventDim">
    ///  The inventory dimensions for work center where raw materials will be reserved or picked.
    /// </param>
    /// <param name="_isWorkCenter">
    ///  A Boolean value that indicates if the location is a work center.
    /// </param>
    /// <param name="_skipReservation">
    ///  A Boolean value that indicates if the reservation should be skipped because the inventory is already reserved at the picking location.
    /// </param>
    /// <param name="_workCenterQty">
    ///  The handling quantity available in the work center, defaulted to the quantity on the <c>InventTrans</c> buffer.
    /// </param>    
    /// <param name="_positiveTransQty">
    /// The inventory transaction handling quantity as a positive value.
    /// </param>
    /// <remarks>
    /// The method is an extension point and is not meant to be called directly. Callers should call the executeWarehousePolicyHandlingQty method.
    /// </remarks>
    [Wrappable(true)]
    protected void executeWarehousePolicyHandlingQuantity(
        InventTrans          _inventTrans,
        WHSWaveId            _waveId,
        WHSWaveExecutionID   _waveExecutionId,
        InventDim            _wrkCtrInventDim,
        boolean              _isWorkCenter,
        boolean              _skipReservation,
        InventHandlingQty    _workCenterQty,
        InventHandlingQty    _positiveTransQty)
    {
        WHSRawMaterialPolicy    rawMaterialPolicy = InventLocation::find(_wrkCtrInventDim.InventLocationId).WHSRawMaterialPolicy;

        // If serials are being captured and registered prior to consumption, then the warehouse policy of picking raw materials must be overridden since they will not have serials at picking.
        if (WHSInventTable::isPotentialProdPickOverride(_inventTrans.ItemId, rawMaterialPolicy))
        {
            warning(strFmt("@WAX:AutomatickPickOverrideMessage", _inventTrans.ItemId));

            rawMaterialPolicy = WHSRawMaterialPolicy::Reserve;
        }
        
        switch (rawMaterialPolicy)
        {
            case WHSRawMaterialPolicy::Reserve :
                // If location was specified on the BOM line and materials were not reserved above location, this reservation can be skipped since material is
                //  already reserved where it will be consumed
                if (!_skipReservation)
                {
                    using (var context = WHSPoolReserveOnWorkCenterReserveOnFullDimensionsFlight::instance().isEnabled() ? WHSProdInputLocationReserveFullDimsContext::construct() : null)
                    {
                        this.reserveOnWorkCenter(_inventTrans.ItemId,
                                                 _wrkCtrInventDim,
                                                 _inventTrans.inventDimId,
                                                 _inventTrans.InventTransOrigin,
                                                 _workCenterQty,
                                                 _positiveTransQty,
                                                 _isWorkCenter);
                    }
                }

                WHSPostEngine::createWaveExecutionHistoryLine(_waveId, _waveExecutionId, strFmt("@WAX:ProdBOMReservedMessage", this.displayOrderIdAndItemId(), _wrkCtrInventDim.wmsLocationId), false);
                break;

            case WHSRawMaterialPolicy::Pick :
                this.pickFromWorkCenterHandlingQty(_wrkCtrInventDim, _workCenterQty, _positiveTransQty, _isWorkCenter);
                WHSPostEngine::createWaveExecutionHistoryLine(_waveId, _waveExecutionId, strFmt("@WAX3335", this.displayOrderIdAndItemId(), _wrkCtrInventDim.wmsLocationId), false);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserveOnWorkCenter</Name>
				<Source><![CDATA[
	/// <summary>
	///    Reserves inventory on a work center location.
	/// </summary>
	/// <param name="_itemId">
	///     The id for the item being reserved.
	/// </param>
	/// <param name="_inventDim">
	///    The inventory dimension to reserve on.
	/// </param>
	/// <param name="_inventDimId">
    ///    The inventory dimension id for the existing transactions on the production BOM.
	/// </param>
	/// <param name="_inventTransOriginId">
	///     The inventory transaction line origin id.
	/// </param>
	/// <param name="_workCenterQty">
	///    The quantity available in the work center.
	/// </param>
	/// <param name="_reservedHandlingQty">
	///    The quantity currently reserved by the source line transaction.
	/// </param>
	/// <param name="_isWorkCenter">
	///    A Boolean value that indicates if the location is a work center.
	/// </param>
	/// <returns>
	///    true if work should be created; otherwise, false.
	/// </returns>
	private boolean reserveOnWorkCenter(
		ItemId              _itemId,
		InventDim           _inventDim,
		InventDimId         _inventDimId,
		InventTransOriginId _inventTransOriginId,
		InventHandlingQty   _workCenterQty,
        InventHandlingQty   _reservedHandlingQty,
        boolean             _isWorkCenter)
	{
		InventDim                   inventDim;
		InventDimParm               inventDimParm;
		InventTable                 inventTable = InventTable::find(_itemId);
		boolean                     createWork = true;
        InventHandlingQty           reservingQty;
        InventHandlingQty           runningQty;
        InventHandlingQty           useQty;
		InventHandlingQty           qtyToReserve;
		boolean                     allowNegative;
		boolean                     batchActive = inventTable.whsBatchActive();
		InventBatchId               lastPhysicalBatchId;
		boolean                     unableToDetermineDimensions;
		InventDim                   inventDimFrom   = InventDim::find(_inventDimId);

        InventHandlingQty qtyLeftToWave = _reservedHandlingQty - WHSPool::calcOpenAndFrozenWorkHandlingQty(this.inventTransId(), _inventDim);

        // Determine if item allow picking the location Negative
		if (inventTable.whsAllowPhysNeg()
		    &&  _inventDim.wmsLocation().whsLocationProfile().AllowNegative
		    &&  (!_isWorkCenter || WHSInventTable::find(_itemId).PickWCNeg))
		{
			allowNegative = true;
		}

		if (_workCenterQty >= qtyLeftToWave)
		{
			createWork = false;
			reservingQty = qtyLeftToWave;
		}
		else
		{
			reservingQty = _workCenterQty;
		}

        createdTransactionId ttsId = InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().ttsId();

        WHSInstrumentationLogger logger = WHSInstrumentationLogger::createLogger(classStr(WHSPool));
        WHSPoolReserveOnWorkCenterInstrumentationActivities activities = logger.reserveOnWorkCenter();

        using (var reserveOnWorkCenterActivityContext = activities.reserveOnWorkCenter(_inventTransOriginId))
        {
            int loopsCounter = 0;

            while (runningQty < reservingQty)
            {
                loopsCounter++;

                [lastPhysicalBatchId, useQty, inventDim] = this.findBatchItemsHandlingQty(_inventDim, batchActive, _isWorkCenter,
                                                                           allowNegative, ttsId, reservingQty, runningQty);
                                
                activities.parmFoundInventDim(reserveOnWorkCenterActivityContext, inventDim.RecId);

                if (WHSReserveOnWorkCenterOnLPControlledLocationFlight::instance().isEnabled()
                    && !inventDim
                    && !_inventDim.LicensePlateId
                    && _inventDim.wmsLocationId
                    && _inventDim.wmsLocation().whsLocationIsLPControlled())
                {
                    boolean isSerialBelowActive = (inventTable.isItemSerialNumberActivated() && WhsReservationHierarchyInventDimUtil::isSerialBelowLocation(inventTable));

                    if (this.mustDetermineAdditionalDimensionsForNonBatchSerialItem(_inventDim, batchActive, isSerialBelowActive))
                    {
                        [useQty, inventDim] = this.determineAdditionalDimensionsForNonBatchSerialItem(inventTable, _inventDim, reservingQty - runningQty, ttsId);
                    }
                }

                // If we didn't get a hit in the loop, the item allows negative, no batch was specified, and the item is batch active...
                // Then we must determine what batch to reserve.
                if (!useQty &&  allowNegative && !inventDim.InventBatchId && batchActive)
                {
                    inventDim = this.getDimForNegativeConsumption(_inventDim, lastPhysicalBatchId, _isWorkCenter);

                    if (inventDim.InventDimId)
                    {
                        useQty = reservingQty;
                    }
                    else
                    {
                        createWork = true;
                        unableToDetermineDimensions = true;
                    }
                }

                if (useQty)
                {
                    qtyToReserve = useQty;
                }
                else if (!unableToDetermineDimensions)
                {
                    qtyToReserve = _workCenterQty;

                    if (qtyToReserve > qtyLeftToWave)
                    {
                        qtyToReserve = qtyLeftToWave - runningQty;
                    }
                    if (!inventDim)
                    {
                        inventDim = _inventDim;
                    }
                }

                if (qtyToReserve <= 0)
                {
                    createWork = true;
                    break;
                }

                ttsbegin;

                // Reserve on location currently only works for prodBOMs, so it is safe to assume the buffer is a prodBOM.
                ProdBOM prodBOMLocal = this.movementBuffer(true) as ProdBOM;

                if (ProdJournalBOM::hasOpenReservedRecord(prodBOMLocal.InventTransId, inventDimFrom.inventDimId))
                {
                    WHSPoolProdBOM::updateWithPickListTransactionsHandlingQty(prodBOMLocal.InventTransId, prodBOMLocal.ItemId, inventDim, qtyToReserve, 0, WHSRawMaterialPolicy::Reserve);
                }
                else
                {
                    InventMovement movement = InventMovement::construct(prodBOMLocal);
                    movement.inventTransOriginId(_inventTransOriginId);

                    this.reserveProdBOMByInventMovement(movement, inventDimFrom, inventDim, inventDimParm, qtyToReserve);
                }

                this.addWavedHandlingQty(qtyToReserve);

                ttscommit;

                ProdBOM prodBOM = ProdBOM::findTransId(this.inventTransId());

                if (prodBOM.prodTable().ProdStatus == ProdStatus::StartedUp
                &&	prodBOM.flushingPrinciple()	   == ProdFlushingPrincipBOM::Picked)
                {
                    prodJournalId = WHSPostProdJournal::createJournalLineFromTransaction(this.inventTransId(), inventDim.inventDimId, qtyToReserve, prodJournalId);
                }
                runningQty += qtyToReserve;
            }

            activities.parmBatchSearchLoopsCount(reserveOnWorkCenterActivityContext, loopsCounter);
        }

		return createWork;
	}

]]></Source>
			</Method>
			<Method>
				<Name>reserveProdBOMByInventMovement</Name>
				<Source><![CDATA[
    protected void reserveProdBOMByInventMovement(
        InventMovement    _movement, 
        InventDim         _inventDimFrom, 
        InventDim         _inventDimTo, 
        InventDimParm     _inventDimParm, 
        InventHandlingQty _qtyToReserve)
    {
        if (appl.ttsLevel() == 0)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        // In case on-hand raw material only exists at production input location and a reservation was made prior to releasing the production order, undo reservation
        //  above location and then reserve again to include all previously undefined physical dimensions.
        // Match on all fields
        _inventDimParm.setAllInventDim();

        // Create reservation class
        
        InventUpd_Reservation reserve = InventUpd_Reservation::newParameters(
                                                                    _movement,
                                                                    _inventDimFrom,
                                                                    _inventDimParm,
                                                                    InventDimFixedClass::inventDimParm2InventDimFixed(_inventDimParm),
                                                                    _movement.pdsCWItem() ? WhsInvent::defaultCatchWeightReserveQuantity(_movement.itemId(), _qtyToReserve) : _qtyToReserve, 
                                                                    false, 
                                                                    false, 
                                                                    _movement.pdsCWItem() ? _qtyToReserve : 0);
        // Make sure parms are setup to only unreserve physical reserved transactions and also prevent reserved ordered transactions from taking newly availabale inventory.
        reserve.parmOnlyUnReservePhysicalReserved(true);
        reserve.parmAllowAutoReserveDim(false);
        // Call unreserve
        reserve.updateNow();

        // Transactions involving items with reservation hierarchies of batch or serial above location will not have this tracking dimension set when unreserved, therefore the
        //  inventory dimension parameters will be based off of the transaction instead of the item
        _inventDimParm.initFromInventDim(_movement.inventdim());

        InventHandlingQty reserveQty;

        
        reserveQty = _movement.pdsCWItem() ? WhsInvent::defaultCatchWeightReserveQuantity(_movement.itemId(), -_qtyToReserve) : -_qtyToReserve;
   

        // Create reservation class for reserving more
        reserve = InventUpd_Reservation::newParameters(
                                                    _movement,
                                                    _inventDimTo,
                                                    _inventDimParm,
                                                    InventDimFixedClass::inventDimParm2InventDimFixed(_inventDimParm),
                                                    reserveQty,
                                                    true,
                                                    false,
                                                    _movement.pdsCWItem() ? -_qtyToReserve : 0);
        // Don't allow it to reserve order or reserve less than requested.
        reserve.parmAllowReserveReduction(false);
        reserve.parmAllowReserveOrdered(false);
        reserve.updateNow();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>