<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RTax25RegCalc_TemporaryDifferencesByBalance</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>RTax25RegCalc_TemporaryDifferencesByBalance</c> class is used for the calculation of "Temporary tax differences by balance method" register.
/// </summary>
internal final class RTax25RegCalc_TemporaryDifferencesByBalance extends RTax25RegCalc
{
    private RAssetStandardId rAssetStandardId, rAssetStandardTaxId;
    private RDeferralsBookId rDeferralsBookId, rDeferralsBookTaxId;
    private Range parmTypeId;
    private Counter transCount;
    private TaxCode assetTaxCode, lastTaxCode;
    private TaxCode debtReserveTaxCode;
    private Map registerLineMap;
    private RefRecId lastProfitTableRecId;
    private RecId assetProfitTableRecId;
    private RecId assetClothProfitTableRecId;
    private RecId assetRiggProfitTableRecId;
    private RecId debtReserveProfitTableRecId;
    private AmountMST totalInitialDTADTL, totalDTADTL,
        totalNetBookValue, totalTaxNetBookValue,
        totalCreatingDTA, totalDecreasingDTA,
        totalCreatingDTL, totalDecreasingDTL;
    private AmountMST taxCodeInitialDTADTL, taxCodeDTADTL,
        taxCodeNetBookValue, taxCodeTaxNetBookValue,
        taxCodeCreatingDTA, taxCodeDecreasingDTA,
        taxCodeCreatingDTL, taxCodeDecreasingDTL;
    private AmountMST profitInitialDTADTL, profitDTADTL,
        profitNetBookValue, profitTaxNetBookValue,
        profitCreatingDTA, profitDecreasingDTA,
        profitCreatingDTL, profitDecreasingDTL;

    private const RTax25ProfitId DebtReserveProfitID = 'DebtReserve';
    private const str EmptyStr = '';
    private const int FieldNumOne = 1;
    private const int FieldNumTwo = 2;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates register data and saves it to buffer.
    /// </summary>
    public void calc()
    {
        const int RetryNum = 5;

        try
        {
            ttsbegin;

            super();

            this.createBodyAssetGroupTypes(RAssetGroupTypes::FixedAssets);
            this.createBodyAssetGroupTypes(RAssetGroupTypes::Cloths);
            this.createBodyAssetGroupTypes(RAssetGroupTypes::Rigging);

            SysQueryRun deferralsQueryRun = this.queryRunDeferrals();
            while (deferralsQueryRun.next())
            {
                RDeferralsTable rDeferralsTable = deferralsQueryRun.get(tablenum(RDeferralsTable));
                this.createBodyDeferrals(rDeferralsTable);
            }

            if (this.isDebtReserves())
            {
                this.createBodyDebtReserve();
            }

            this.sortRegisterTrans();
            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            if ((appl.ttsLevel() == 0)
                && (xSession::currentRetryCount() < RetryNum))
            {
                retry;
            }
            else
            {
                throw Exception::Deadlock;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBodyAssetGroupTypes</Name>
				<Source><![CDATA[
    private void createBodyAssetGroupTypes(RAssetGroupTypes _assetGroupTypes)
    {
        SysQueryRun queryRun = this.queryRunAsset(_assetGroupTypes);

        RAssetTable rAssetTable;
        while (queryRun.next())
        {
            rAssetTable = queryRun.get(tablenum(RAssetTable));
            this.createBodyAsset(rAssetTable, _assetGroupTypes);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcDiffForReserve</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates tax differences for bad debt reserves.
    /// </summary>
    /// <param name="_profitTableRecId">
    /// A record ID of the profit table.
    /// </param>
    /// <param name="_key">
    /// A container holding accounting object ID information.
    /// </param>
    /// <param name="_balanceRAP">
    /// A container holding amounts calculated for business accounting model.
    /// </param>
    /// <param name="_balanceTAX">
    /// A container holding amounts calculated for tax accounting model.
    /// </param>
    private void calcDiffForReserve(
        RefRecId _profitTableRecId,
        container _key,
        container _balanceRAP,
        container _balanceTAX)
    {
        AmountMST taxNetBookValuePrevPeriod = conPeek(_balanceTAX, 1);
        AmountMST netBookValuePrevPeriod = conPeek(_balanceRAP, 1);

        AmountMST taxNetBookValueCurPeriod = conPeek(_balanceTAX, 2);
        AmountMST netBookValueCurPeriod = conPeek(_balanceRAP, 2);

        AmountMST diffBalancePrevPeriod  = taxNetBookValuePrevPeriod - netBookValuePrevPeriod;
        AmountMST diffBalanceCurPeriod = taxNetBookValueCurPeriod - netBookValueCurPeriod;

        if (diffBalancePrevPeriod || diffBalanceCurPeriod)
        {
            transCount++;

            AmountMST initialDeferredTaxValue, curDeferredTaxValue, creatingDTA, decreasingDTA, creatingDTL, decreasingDTL;
            [initialDeferredTaxValue, curDeferredTaxValue, creatingDTA, decreasingDTA, creatingDTL, decreasingDTL] = this.calcLineAmounts(
                diffBalancePrevPeriod,
                diffBalanceCurPeriod,
                debtReserveTaxCode);

            Amount changeTaxDiffCurPeriod = CurrencyExchangeHelper::amount(diffBalancePrevPeriod - diffBalanceCurPeriod);

            RefTableId refTableId = conPeek(_key, 1);
            RefRecId refRecId = conPeek(_key, 2);
            DocumentNum invoiceNumberStr = conPeek(_key, 3);
            DocumentDate postingDate = conPeek(_key, 4);

            str lineDescription = refTableId != 0 ?
                strfmt("@RTax25BadDebtReserve:TempDiffForInv", invoiceNumberStr) :
                "@RTax25BadDebtReserve:TempDiffTotal";

            str accountingObject = refTableId != 0 ?
                strFmt("@RTax25BadDebtReserve:ReserveFor", invoiceNumberStr) :
                "@RTax25Registers:ReserveTotal";

            this.insertRegisterMap(
                debtReserveTaxCode,
                regQuery.addBodyRecord(
                    _profitTableRecId,
                    [
                        postingDate,
                        accountingObject,
                        dateTo,
                        initialDeferredTaxValue,
                        netBookValueCurPeriod,
                        taxNetBookValueCurPeriod,
                        curDeferredTaxValue,
                        creatingDTA,
                        decreasingDTA,
                        creatingDTL,
                        decreasingDTL],
                    refTableId,
                    refRecId,
                    lineDescription,
                    -transCount,
                    changeTaxDiffCurPeriod));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcLineAmounts</Name>
				<Source><![CDATA[
    private container calcLineAmounts(
        AmountMST _diffBalancePrevPeriod,
        AmountMST _diffBalanceCurPeriod,
        TaxCode _taxCode)
    {
        AmountMST initialDeferredTaxValue = new Tax().taxCalcWithoutSource_RU(
            _taxCode,
            dateTo,
            CompanyInfoHelper::standardCurrency(),
            _diffBalancePrevPeriod,
            TaxModuleType::Voucher);

        AmountMST curDeferredTaxValue = new Tax().taxCalcWithoutSource_RU(
            _taxCode,
            dateTo,
            CompanyInfoHelper::standardCurrency(),
            _diffBalanceCurPeriod,
            TaxModuleType::Voucher);

        AmountMST currentDifference = curDeferredTaxValue - initialDeferredTaxValue;

        AmountMST creatingDTA, creatingDTL, decreasingDTA, decreasingDTL;
        if (initialDeferredTaxValue >= 0)
        {
            if (currentDifference >= 0)
            {
                creatingDTA = currentDifference;
            }
            else
            {
                if (initialDeferredTaxValue >= -currentDifference)
                {
                    decreasingDTA = -currentDifference;
                }
                else
                {
                    decreasingDTA = initialDeferredTaxValue;
                    creatingDTL = -currentDifference - initialDeferredTaxValue;
                }
            }
        }
        else
        {
            if (currentDifference <= 0)
            {
                creatingDTL = -currentDifference;
            }
            else
            {
                if (-initialDeferredTaxValue >= currentDifference)
                {
                    decreasingDTL = currentDifference;
                }
                else
                {
                    decreasingDTL = -initialDeferredTaxValue;
                    creatingDTA = currentDifference + initialDeferredTaxValue;
                }
            }
        }

        return [initialDeferredTaxValue, curDeferredTaxValue, creatingDTA, decreasingDTA, creatingDTL, decreasingDTL];
    }

]]></Source>
			</Method>
			<Method>
				<Name>check</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the specified settings and parameters are present.
    /// </summary>
    /// <returns>
    /// true if the validation succeeded; otherwise, false.
    /// </returns>
    public boolean check()
    {
        boolean ret;

        ret = super();

        if (ret)
        {
            if (!rAssetStandardId)
            {
                ret = checkFailed(strfmt("@GLS107145", "@SYS12578"));
            }

            if (!rAssetStandardTaxId)
            {
                ret = checkFailed(strfmt("@GLS107146", "@SYS12578"));
            }

            if (!rDeferralsBookId)
            {
                ret = checkFailed(strfmt("@GLS107145", "@GLS103666"));
            }

            if (!rDeferralsBookTaxId)
            {
                ret = checkFailed(strfmt("@GLS107146", "@GLS103666"));
            }

            if (rAssetStandardId == rAssetStandardTaxId)
            {
                ret = checkFailed(strfmt("@GLS107147", "@SYS12578"));
            }

            if (rDeferralsBookId == rDeferralsBookTaxId)
            {
                ret = checkFailed(strfmt("@GLS107147", "@GLS103666"));
            }

            if (!assetTaxCode)
            {
                ret = checkFailed("@GLS107150");
            }

            if (!debtReserveTaxCode)
            {
                ret = checkFailed("@RTax25BadDebtReserve:BadDebtTaxCodeNotSet");
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBodyDebtReserve</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates tax difference register lines for doubtful debt reserves.
    /// </summary>
    private void createBodyDebtReserve()
    {
        RefRecId debtModelRAPRecId = CustParameters::rTax25DebtModel(false);
        RefRecId debtModelTAXRecId = CustParameters::rTax25DebtModelTax();

        RTax25DebtModel rTax25DebtModel = RTax25DebtModel::findRecId(debtModelTAXRecId);

        TransDate modelStartDate, modelEndDate;
        [modelStartDate, modelEndDate] = RTax25DebtModel::periodDates(rTax25DebtModel.PeriodType, dateTo);

        if (modelEndDate != dateTo)
        {
            return;
        }

        RTax25DebtReserveTaxBalanceCalc balanceCalc = RTax25DebtReserveTaxBalanceCalc::newParameters(
            modelStartDate,
            modelEndDate,
            RTax25DebtModelType::RAP);

        Map mapBalanceRAP = balanceCalc.getBalanceMap();
        Map mapDoubfulDebtsRAP = balanceCalc.getDoubtfulDebtsMap();

        balanceCalc = RTax25DebtReserveTaxBalanceCalc::newParameters(
            modelStartDate,
            modelEndDate,
            RTax25DebtModelType::TAX);

        Map mapBalanceTAX = balanceCalc.getBalanceMap();
        Map mapDoubfulDebtsTAX = balanceCalc.getDoubtfulDebtsMap();

        if (debtModelRAPRecId && debtModelTAXRecId)
        {
            if (RTax25DebtModel::findRecId(debtModelRAPRecId).AccountingPolicy == RTax25DebtPolicy::Total)
            {
                mapBalanceTAX = this.summarizeMap(mapBalanceTAX);
                mapDoubfulDebtsTAX = this.summarizeMap(mapDoubfulDebtsTAX);
            }

            if (RTax25DebtModel::findRecId(debtModelTAXRecId).AccountingPolicy == RTax25DebtPolicy::Total)
            {
                mapBalanceRAP = this.summarizeMap(mapBalanceRAP);
                mapDoubfulDebtsRAP = this.summarizeMap(mapDoubfulDebtsRAP);
            }
        }

        Set setProcessedKeys = new Set(Types::Container);
        RefRecId profitTableRecId = RTax25ProfitTable::findByProfitId(DebtReserveProfitID).RecId;
        MapEnumerator enumerator;
        container key, balanceRAP, balanceTAX;

        if (mapBalanceRAP)
        {
            enumerator = mapBalanceRAP.getEnumerator();
            while (enumerator.moveNext())
            {
                key = enumerator.currentKey();
                balanceRAP = enumerator.currentValue();

                if (mapBalanceTAX.exists(key))
                {
                    balanceTAX = mapBalanceTAX.lookup(key);
                    setProcessedKeys.add(key);
                }
                else
                {
                    balanceTAX = mapDoubfulDebtsRAP.lookup(key);
                }

                this.calcDiffForReserve(
                    profitTableRecId,
                    key,
                    balanceRAP,
                    balanceTAX);
            }
        }

        if (mapBalanceTAX)
        {
            enumerator = mapBalanceTAX.getEnumerator();
            while (enumerator.moveNext())
            {
                key = enumerator.currentKey();
                balanceTAX = enumerator.currentValue();

                if (setProcessedKeys.in(key))
                {
                    continue;
                }

                this.calcDiffForReserve(
                    profitTableRecId,
                    key,
                    mapDoubfulDebtsTAX.lookup(key),
                    balanceTAX);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>summarizeMap</Name>
				<Source><![CDATA[
    private Map summarizeMap(Map _map)
    {
        Map mapResult = new Map(Types::Container, Types::Container);

        MapEnumerator mapEnumerator = _map.getEnumerator();
        container value;
        container total = [0, 0];

        while (mapEnumerator.moveNext())
        {
            value = mapEnumerator.currentValue();
            total = [conPeek(total, 1) + conPeek(value, 1), conPeek(total, 2) + conPeek(value, 2)];
        }

        mapResult.insert([0, 0, '', dateNull()], total);

        return mapResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBodyAsset</Name>
				<Source><![CDATA[
    private void createBodyAsset(RAssetTable _rAssetTable, RAssetGroupTypes _assetGroupTypes = RAssetGroupTypes::FixedAssets)
    {
        TransDate endPrevDate = endmth(prevmth(dateFrom));

        RAssetSumCalc_TransCorr rAssetSumCalc_Trans = RAssetSumCalc_TransCorr::newAssetPeriod(_rAssetTable.AccountNum, rAssetStandardId);

        rAssetSumCalc_Trans.parmDateTo(endPrevDate);
        AmountMST netBookValuePrevPeriod = rAssetSumCalc_Trans.netBookValueMST();
        rAssetSumCalc_Trans.parmRangeAssetStandard(rAssetStandardTaxId);
        AmountMST taxNetBookValuePrevPeriod = rAssetSumCalc_Trans.netBookValueMST();
        AmountMST diffBalancePrevPeriod = taxNetBookValuePrevPeriod - netBookValuePrevPeriod;

        TransDate transDate = endmth(dateTo);
        rAssetSumCalc_Trans.parmRangeAssetStandard(rAssetStandardId);
        rAssetSumCalc_Trans.parmDateTo(transDate);
        AmountMST netBookValueCurPeriod = rAssetSumCalc_Trans.netBookValueMST();
        rAssetSumCalc_Trans.parmRangeAssetStandard(rAssetStandardTaxId);
        AmountMST taxNetBookValueCurPeriod = rAssetSumCalc_Trans.netBookValueMST();
        AmountMST diffBalanceCurPeriod = taxNetBookValueCurPeriod - netBookValueCurPeriod;

        if (diffBalancePrevPeriod || diffBalanceCurPeriod)
        {
            transCount++;
            AmountMST initialDeferredTaxValue, curDeferredTaxValue, creatingDTA, decreasingDTA, creatingDTL, decreasingDTL;
            [initialDeferredTaxValue, curDeferredTaxValue, creatingDTA, decreasingDTA, creatingDTL, decreasingDTL] = this.calcLineAmounts(
                diffBalancePrevPeriod,
                diffBalanceCurPeriod,
                assetTaxCode);

            RAssetStandards rAssetStandards = RAssetStandards::find(_rAssetTable.AccountNum, rAssetStandardId);
            if (rAssetStandards.DisposalDate >= endPrevDate
                && rAssetStandards.DisposalDate <= transDate)
            {
                transDate = rAssetStandards.DisposalDate;
            }

            RefRecId profitTableRecId;
            switch (_assetGroupTypes)
            {
                case RAssetGroupTypes::FixedAssets:
                    profitTableRecId = assetProfitTableRecId;
                    break;

                case RAssetGroupTypes::Cloths:
                    profitTableRecId = assetClothProfitTableRecId;
                    break;

                case RAssetGroupTypes::Rigging:
                    profitTableRecId = assetRiggProfitTableRecId;
                    break;

                default:
                    profitTableRecId = assetProfitTableRecId;
                    break;
            }

            Amount changeTaxDiffCurPeriod = CurrencyExchangeHelper::amount(diffBalanceCurPeriod - diffBalancePrevPeriod);
            this.insertRegisterMap(
                assetTaxCode,
                regQuery.addBodyRecord(
                    profitTableRecId,
                    [
                        _rAssetTable.AcquisitionDate,
                        strfmt("@GLS116360", _rAssetTable.AccountNum, _rAssetTable.Name),
                        transDate,
                        initialDeferredTaxValue,
                        netBookValueCurPeriod,
                        taxNetBookValueCurPeriod,
                        curDeferredTaxValue,
                        creatingDTA,
                        decreasingDTA,
                        creatingDTL,
                        decreasingDTL],
                    _rAssetTable.TableId,
                    _rAssetTable.RecId,
                    strfmt("@GLS116360", _rAssetTable.AccountNum, _rAssetTable.Name),
                    -transCount,
                    changeTaxDiffCurPeriod));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBodyDeferrals</Name>
				<Source><![CDATA[
    private void createBodyDeferrals(RDeferralsTable _rDeferralsTable)
    {
        TransDate endPrevDate = endmth(prevmth(dateFrom));

        RDeferralsSumCalc_TransCorr rDeferralsSumCalc_Trans = RDeferralsSumCalc_TransCorr::newDeferralsPeriod(_rDeferralsTable.DeferralsId, rDeferralsBookId);

        rDeferralsSumCalc_Trans.parmDateTo(endPrevDate);
        AmountMST netBookValuePrevPeriod = rDeferralsSumCalc_Trans.netBookValue();
        rDeferralsSumCalc_Trans.parmRangeDeferralsBookId(rDeferralsBookTaxId);
        AmountMST taxNetBookValuePrevPeriod = rDeferralsSumCalc_Trans.netBookValue();
        AmountMST diffBalancePrevPeriod = taxNetBookValuePrevPeriod - netBookValuePrevPeriod;

        TransDate transDate = endmth(dateTo);
        rDeferralsSumCalc_Trans.parmRangeDeferralsBookId(rDeferralsBookId);
        rDeferralsSumCalc_Trans.parmDateTo(transDate);
        AmountMST netBookValueCurPeriod = rDeferralsSumCalc_Trans.netBookValue();
        rDeferralsSumCalc_Trans.parmRangeDeferralsBookId(rDeferralsBookTaxId);
        AmountMST taxNetBookValueCurPeriod = rDeferralsSumCalc_Trans.netBookValue();
        AmountMST diffBalanceCurPeriod = taxNetBookValueCurPeriod - netBookValueCurPeriod;

        TaxCode taxCode = RTax25ProfitTable::find(_rDeferralsTable.rTax25ProfitTable).taxCode();
        if (taxCode && (diffBalancePrevPeriod || diffBalanceCurPeriod))
        {
            transCount++;
            AmountMST initialDeferredTaxValue, curDeferredTaxValue, creatingDTA, decreasingDTA, creatingDTL, decreasingDTL;
            [initialDeferredTaxValue, curDeferredTaxValue, creatingDTA, decreasingDTA, creatingDTL, decreasingDTL] = this.calcLineAmounts(
                diffBalancePrevPeriod,
                diffBalanceCurPeriod,
                taxCode);

        RDeferralsBook rDeferralsBook = RDeferralsBook::find(_rDeferralsTable.DeferralsId, rDeferralsBookId);
        if (!rDeferralsBook.RecId)
        {
            rDeferralsBook = RDeferralsBook::find(_rDeferralsTable.DeferralsId, rDeferralsBookTaxId);
        }

        if (rDeferralsBook.RetirementDate >= endPrevDate
            && rDeferralsBook.RetirementDate <= transDate
            && rDeferralsBook.Status == RDeferralsStatus::Retired)
        {
            transDate = rDeferralsBook.RetirementDate;;
        }

        RTax25Description transText = strfmt("@GLS107170", _rDeferralsTable.DeferralsId, _rDeferralsTable.Name);
        Amount changeTaxDiffCurPeriod = CurrencyExchangeHelper::amount(diffBalanceCurPeriod - diffBalancePrevPeriod);
        this.insertRegisterMap(
            taxCode,
            regQuery.addBodyRecord(
                _rDeferralsTable.rTax25ProfitTable,
                [
                    _rDeferralsTable.AcquisitionDate,
                    transText,
                    transDate,
                    initialDeferredTaxValue,
                    netBookValueCurPeriod,
                    taxNetBookValueCurPeriod,
                    curDeferredTaxValue,
                    creatingDTA,
                    decreasingDTA,
                    creatingDTL,
                    decreasingDTL],
                _rDeferralsTable.TableId,
                _rDeferralsTable.RecId,
                transText,
                -transCount,
                changeTaxDiffCurPeriod));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFooter</Name>
				<Source><![CDATA[
    private void createFooter(Counter _i, RTax25FieldId _blockFieldNum = 0)
    {
        TaxValue taxValue = TaxData::percent(lastTaxCode, dateTo, 0);

        switch (_blockFieldNum)
        {
            case FieldNumOne:
                regQuery.addFooterRecord(
                    0,
                    [
                        dateNull(),
                        EmptyStr,
                        dateNull(),
                        taxCodeInitialDTADTL,
                        taxCodeNetBookValue,
                        taxCodeTaxNetBookValue,
                        taxCodeDTADTL,
                        taxCodeCreatingDTA,
                        taxCodeDecreasingDTA,
                        taxCodeCreatingDTL,
                        taxCodeDecreasingDTL],
                    0,
                    strfmt("@GLS107102", lastTaxCode,taxValue),
                    _i);

                taxCodeInitialDTADTL = 0;
                taxCodeNetBookValue = 0;
                taxCodeTaxNetBookValue = 0;
                taxCodeDTADTL = 0;
                taxCodeCreatingDTA = 0;
                taxCodeDecreasingDTA = 0;
                taxCodeCreatingDTL = 0;
                taxCodeDecreasingDTL = 0;
                break;

            case FieldNumTwo:
                RefRecId profitTableRecId;
                RTax25Description description;
                switch (lastProfitTableRecId)
                {
                    case assetProfitTableRecId:
                        profitTableRecId = 0;
                        description = strfmt("@SYS90673", "@SYS12578");
                        break;

                    case assetClothProfitTableRecId:
                        profitTableRecId = 0;
                        description = strfmt("@SYS90673", "@GLS113945");
                        break;

                    case assetRiggProfitTableRecId:
                        profitTableRecId = 0;
                        description = strfmt("@SYS90673", "@GLS113946");
                        break;

                    case debtReserveProfitTableRecId:
                        profitTableRecId = 0;
                        description = strfmt("@SYS90673", "@RTax25BadDebtReserve:ReserveBadDebts");
                        break;

                    default:
                        profitTableRecId = lastProfitTableRecId;
                        description = strfmt("@GLS103999", RTax25ProfitTable::find(lastProfitTableRecId).ProfitId);
                        break;
                }

                regQuery.addFooterRecord(
                    profitTableRecId,
                    [
                        dateNull(),
                        EmptyStr,
                        dateNull(),
                        profitInitialDTADTL,
                        profitNetBookValue,
                        profitTaxNetBookValue,
                        profitDTADTL,
                        profitCreatingDTA,
                        profitDecreasingDTA,
                        profitCreatingDTL,
                        profitDecreasingDTL],
                    0,
                    description,
                    _i);

                profitInitialDTADTL = 0;
                profitNetBookValue = 0;
                profitTaxNetBookValue = 0;
                profitDTADTL = 0;
                profitCreatingDTA = 0;
                profitDecreasingDTA = 0;
                profitCreatingDTL = 0;
                profitDecreasingDTL = 0;
                break;

            default:
                regQuery.addFooterRecord(
                    0,
                    [
                        dateNull(),
                        EmptyStr,
                        dateNull(),
                        totalInitialDTADTL,
                        totalNetBookValue,
                        totalTaxNetBookValue,
                        totalDTADTL,
                        totalCreatingDTA,
                        totalDecreasingDTA,
                        totalCreatingDTL,
                        totalDecreasingDTL],
                    0,
                    "@SYS37297",
                    _i);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createHeader</Name>
				<Source><![CDATA[
    private void createHeader(Counter _i, RTax25FieldId _blockFieldNum = 0)
    {
        switch (_blockFieldNum)
        {
            case FieldNumOne:
                regQuery.addHeaderRecord(
                    0,
                    conNull(),
                    0,
                    strfmt("@GLS107103", lastTaxCode, TaxData::percent(lastTaxCode, dateTo, 0)),
                    _i);
                break;

            case FieldNumTwo:
                RefRecId profitTableRecId;
                RTax25Description description;
                switch (lastProfitTableRecId)
                {
                    case assetProfitTableRecId:
                        profitTableRecId = 0;
                        description = "@SYS19633";
                        break;

                    case assetClothProfitTableRecId:
                        profitTableRecId = 0;
                        description = "@GLS113945";
                        break;

                    case assetRiggProfitTableRecId:
                        profitTableRecId = 0;
                        description = "@GLS113946";
                        break;

                    case debtReserveProfitTableRecId:
                        profitTableRecId = 0;
                        description = "@RTax25BadDebtReserve:ReserveBadDebts";
                        break;

                    default:
                        profitTableRecId = lastProfitTableRecId;
                        description = strfmt("@GLS104111", lastProfitTableRecId);
                        break;
                }

                regQuery.addHeaderRecord(
                    profitTableRecId,
                    conNull(),
                    0,
                    description,
                    _i);
                break;

            default:
                regQuery.addHeaderRecord(
                    0,
                    conNull(),
                    0,
                    "@SYS28004",
                    _i);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes register data.
    /// </summary>
    /// <param name="_registerJournalTrans">
    /// <c>RegisterJournalTrans</c> record being calculated.
    /// </param>
    /// <param name="_batch">
    /// <c>Batch</c> record.
    /// </param>
    /// <returns>
    /// true if initialization succeed; Otherwise false.
    /// </returns>
    public boolean init(RTax25RegisterJournalTrans _registerJournalTrans = null, Batch _batch = null)
    {
        boolean ret = super(_registerJournalTrans, _batch);

        const int RegisterCode2 = 2;
        const int RegisterCode3 = 3;
        const int RegisterCode5 = 5;
        const RTax25ProfitId AssetProfitID = 'Asset';
        const RTax25ProfitId AssetClothsProfitID = 'AssetCloth';
        const RTax25ProfitId AssetRiggingProfitID = 'AssetRigg';

        rAssetStandardId = RAssetParameters::standardIdDefault();
        rAssetStandardTaxId = RAssetParameters::standardTaxIdDefault();
        rDeferralsBookId = RDeferralsParameters::find().DeferralsBookIdDefault;
        rDeferralsBookTaxId = RTax25Parameters::find().DeferralsBookId;

        parmTypeId = RTax25RegisterParameters::find(registerId, RegisterCode2).Parameter;
        assetTaxCode = strltrim(strrtrim(RTax25RegisterParameters::find(registerId, RegisterCode3).Parameter));
        debtReserveTaxCode = strltrim(strrtrim(RTax25RegisterParameters::find(registerId, RegisterCode5).Parameter));

        if (!parmTypeId)
        {
            parmTypeId = queryValue(RAssetType::Tangible);
            parmTypeId = queryRangeConcat(parmTypeId, RAssetType::LandBuilding);
        }

        registerLineMap = new Map(Types::String, Types::Class);

        assetProfitTableRecId = this.findOrCreateRTax25ProfitTableByProfidId(AssetProfitID);
        assetClothProfitTableRecId = this.findOrCreateRTax25ProfitTableByProfidId(AssetClothsProfitID);
        assetRiggProfitTableRecId = this.findOrCreateRTax25ProfitTableByProfidId(AssetRiggingProfitID);
        debtReserveProfitTableRecId = this.findOrCreateRTax25ProfitTableByProfidId(DebtReserveProfitID, debtReserveTaxCode);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrCreateRTax25ProfitTableByProfidId</Name>
				<Source><![CDATA[
    private RecId findOrCreateRTax25ProfitTableByProfidId(RTax25ProfitId _profitId, TaxCode _taxCode = '')
    {
        RecId profitTableRecId = RTax25ProfitTable::findByProfitId(_profitId).RecId;

        if (!profitTableRecId)
        {
            RTax25ProfitTable registerTable;
            registerTable.ProfitId = _profitId;
            registerTable.TaxCode = _taxCode;
            registerTable.doInsert();
            profitTableRecId = registerTable.RecId;
        }

        return profitTableRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDebtReserves</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if tax differences for doubtful debt reserves should be calculated.
    /// </summary>
    /// <returns>
    /// A boolean value indicating if tax differences for doubtful debt reserves should be calculated.
    /// </returns>
    private boolean isDebtReserves()
    {
        RTax25RegisterTable rTax25RegisterTable;
        container rTax25RegisterTypes = this.rTax25RegisterTypesForCheckDebtReserves();

        select firstOnly RecId from rTax25RegisterTable
            where rTax25RegisterTable.RegisterType in rTax25RegisterTypes;

        return rTax25RegisterTable.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>rTax25RegisterTypesForCheckDebtReserves</Name>
				<Source><![CDATA[
    private container rTax25RegisterTypesForCheckDebtReserves()
    {
        return [
            RTax25RegisterType::DebtDebitReservation,
            RTax25RegisterType::DebtDebitReservationDetail,
            RTax25RegisterType::DebtDebitReservationRAP,
            RTax25RegisterType::DebtDebitReservationDetailRAP];
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertRegisterMap</Name>
				<Source><![CDATA[
    private void insertRegisterMap(TaxCode _taxCode, RTax25RegisterTrans_TemporaryDifferencesByBalance _regTrans)
    {
        RecordSortedList registerTransList;

        if (registerLineMap.exists(_taxCode))
        {
            registerTransList = registerLineMap.lookup(_taxCode);
        }
        else
        {
            registerTransList = new RecordSortedList(tablenum(RTax25RegisterTrans_TemporaryDifferencesByBalance));
            registerTransList.sortOrder(
                fieldnum(RTax25RegisterTrans_TemporaryDifferencesByBalance, RTax25ProfitTable),
                fieldnum(RTax25RegisterTrans_TemporaryDifferencesByBalance, LineNumber));
        }

        _regTrans.LineNumber = -_regTrans.LineNumber;
        registerTransList.ins(_regTrans);
        registerLineMap.insert(_taxCode, registerTransList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRunAsset</Name>
				<Source><![CDATA[
    private SysQueryRun queryRunAsset(RAssetGroupTypes _assetGroupTypes = RAssetGroupTypes::FixedAssets)
    {
        const RTax25ParameterCode ParameterCodeOne = 1;
        SysQuery query = new SysQuery();
        QueryBuildDataSource qbdsRAssetTable = query.addDataSource(tablenum(RAssetTable));

        if (_assetGroupTypes == RAssetGroupTypes::FixedAssets)
        {
            qbdsRAssetTable.addRange(fieldnum(RAssetTable, AssetType)).value(parmTypeId);
        }

        str rangeStatusStrFmt = strFmt(
            '((%1 != %2) && (%1 != %3))',
            fieldStr(RAssetTable, Status),
            any2Int(RAssetStatus::NoAcquisition),
            any2Int(RAssetStatus::PurchInvoice));
        qbdsRAssetTable.addRange(fieldnum(RAssetTable, Status)).value(rangeStatusStrFmt);

        QueryBuildDataSource qbds = qbdsRAssetTable.addDataSource(tablenum(RAssetMainGroup));
        qbds.fetchMode(QueryFetchMode::One2One);
        qbds.addSelectionField(fieldNum(RAssetMainGroup, TableId));
        qbds.addRange(fieldnum(RAssetMainGroup, GroupType)).value(queryValue(_assetGroupTypes));
        qbds.addLink(fieldnum(RAssetTable, AssetGroup), fieldnum(RAssetMainGroup, AssetMainGroupId));

        qbds = qbdsRAssetTable.addDataSource(tablenum(RAssetStandards));
        qbds.fetchMode(QueryFetchMode::One2One);
        qbds.relations(true);
        qbds.joinMode(JoinMode::ExistsJoin);

        str queryRangeForRAssetStandardId = queryRangeConcat(queryValue(rAssetStandardTaxId), rAssetStandardId);
        qbds.addRange(fieldnum(RAssetStandards, AssetStandardId)).value(queryRangeForRAssetStandardId);

        str rangeDisposalDateStrFmt = strFmt(
            '((%1 == %2) || (%1 >= %3))',
            fieldStr(RAssetStandards, DisposalDate),
            date2StrXpp(dateNull()),
            date2StrXpp(rTax25PeriodIterator.parmFromDate()));
        qbds.addRange(fieldnum(RAssetStandards, DisposalDate)).value(rangeDisposalDateStrFmt);
        qbds.addRange(fieldnum(RAssetStandards, AssetGroup)).value(RTax25RegisterParameters::find(registerId, ParameterCodeOne).Parameter);

        qbds = qbds.addDataSource(tablenum(RAssetTransReportingView));
        qbds.joinMode(JoinMode::ExistsJoin);

        qbds.addLink(fieldnum(RAssetStandards, AssetId), fieldnum(RAssetTransReportingView, AccountNum));
        qbds.addRange(fieldnum(RAssetTransReportingView, AssetStandardId)).value(queryRangeForRAssetStandardId);
        qbds.addRange(fieldnum(RAssetTransReportingView, StornoRecId)).value(queryValue(0));

        rTax25PeriodIterator.applyExtendedRange(qbds, true);

        SysQueryRun queryRun = new SysQueryRun(query.pack());

        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRunDeferrals</Name>
				<Source><![CDATA[
    private SysQueryRun queryRunDeferrals()
    {
        const RTax25ParameterCode ParameterCodeFour = 4;
        SysQuery query = new SysQuery();

        QueryBuildDataSource qbds = query.addDataSource(tablenum(RDeferralsTable));
        qbds.addRange(fieldnum(RDeferralsTable, rTax25ProfitTable)).value(SysQuery::valueNot(0));

        qbds = qbds.addDataSource(tablenum(RDeferralsBook));
        qbds.relations(true);

        Range queryRangeForRDeferralsBook = queryRangeConcat(queryValue(rDeferralsBookTaxId), rDeferralsBookId);
        qbds.addRange(fieldnum(RDeferralsBook, DeferralsBookId)).value(queryRangeForRDeferralsBook);

        str rangeEndDeferralsDateStrFmt = strFmt(
            '(%1 >= %2)',
            fieldStr(RDeferralsBook, EndDeferralsDate),
            date2StrXpp(rTax25PeriodIterator.parmFromDate()));
        qbds.addRange(fieldnum(RDeferralsBook, EndDeferralsDate)).value(rangeEndDeferralsDateStrFmt);

        str rangeDisposalDateStrFmt = strFmt(
            '((%1 == %2) || (%1 >= %3))',
            fieldStr(RDeferralsBook, RetirementDate),
            date2StrXpp(dateNull()),
            date2StrXpp(rTax25PeriodIterator.parmFromDate()));
        qbds.addRange(fieldnum(RDeferralsBook, RetirementDate)).value(rangeDisposalDateStrFmt);

        str rangeStatusStrFmt = strFmt(
            '(%1 != %2)',
            fieldStr(RDeferralsBook, Status),
            any2Int(RDeferralsStatus::Scheduled));
        qbds.addRange(fieldnum(RDeferralsBook, Status)).value(rangeStatusStrFmt);
        qbds.addRange(fieldnum(RDeferralsBook, DeferralsGroupId)).value(RTax25RegisterParameters::find(registerId, ParameterCodeFour).Parameter);
        qbds.joinMode(JoinMode::ExistsJoin);

        qbds = qbds.addDataSource(tablenum(RDeferralsTransReportingView));
        qbds.addLink(fieldnum(RDeferralsBook, DeferralsId), fieldnum(RDeferralsTransReportingView, DeferralsId));
        qbds.addRange(fieldnum(RDeferralsTransReportingView, DeferralsBookId)).value(queryRangeForRDeferralsBook);
        qbds.addRange(fieldnum(RDeferralsTransReportingView, StornoRecId)).value(queryValue(0));

        rTax25PeriodIterator.applyExtendedRange(qbds, true);

        SysQueryRun queryRun = new SysQueryRun(query.pack());
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sortRegisterTrans</Name>
				<Source><![CDATA[
    private void sortRegisterTrans()
    {
        RTax25RegisterTrans_TemporaryDifferencesByBalance regTrans;
        int i = 1;
        MapEnumerator mapEnumerator = registerLineMap.getEnumerator();
        RecordSortedList registerTransList;

        while (mapEnumerator.moveNext())
        {
            registerTransList = mapEnumerator.currentValue();
            if (i == 1)
            {
                this.createHeader(i);
            }

            i++;
            lastTaxCode = mapEnumerator.currentKey();
            this.createHeader(i, FieldNumOne);
            lastProfitTableRecId = 0;
            while (registerTransList.next(regTrans))
            {
                if (regTrans.rTax25ProfitTable != lastProfitTableRecId)
                {
                    if (lastProfitTableRecId)
                    {
                        i++;
                        this.createFooter(i, FieldNumTwo);
                    }

                    i++;
                    lastProfitTableRecId = regTrans.rTax25ProfitTable;
                    this.createHeader(i, FieldNumTwo);
                }

                i++;
                this.totals(regTrans);
                regTrans.LineNumber = -regTrans.LineNumber;
                if (regQuery.getSortedList().find(regTrans))
                {
                    regQuery.getSortedList().del(regTrans);
                    regTrans.LineNumber = i;

                    if (regTrans.rTax25ProfitTable == assetProfitTableRecId
                        || regTrans.rTax25ProfitTable == assetClothProfitTableRecId
                        || regTrans.rTax25ProfitTable == assetRiggProfitTableRecId
                        || regTrans.RTax25ProfitTable == debtReserveProfitTableRecId)
                    {
                        regTrans.rTax25ProfitTable = 0;
                    }

                    regQuery.getSortedList().ins(regTrans);
                }
            }

            i++;
            this.createFooter(i,FieldNumTwo);

            i++;
            this.createFooter(i,FieldNumOne);
        }

        if (i > 1)
        {
            i++;
            this.createFooter(i);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>totals</Name>
				<Source><![CDATA[
    private void totals(RTax25RegisterTrans_TemporaryDifferencesByBalance _regTrans)
    {
        TransDate transDate = _regTrans.TransactionDate;
        boolean isEqualMthTransDateToMthDateFrom = (endmth(transDate) == endmth(dateFrom));

        totalInitialDTADTL += isEqualMthTransDateToMthDateFrom ? _regTrans.InitialDTADTL : 0;
        totalNetBookValue += _regTrans.NetBookValue;
        totalTaxNetBookValue += _regTrans.TaxNetBookValue;
        totalDTADTL += _regTrans.DTADTL;
        totalCreatingDTA += _regTrans.CreatingDTA;
        totalDecreasingDTA += _regTrans.DecreasingDTA;
        totalCreatingDTL += _regTrans.CreatingDTL;
        totalDecreasingDTL += _regTrans.DecreasingDTL;

        taxCodeInitialDTADTL += isEqualMthTransDateToMthDateFrom ? _regTrans.InitialDTADTL : 0;
        taxCodeNetBookValue += _regTrans.NetBookValue;
        taxCodeTaxNetBookValue += _regTrans.TaxNetBookValue;
        taxCodeDTADTL += _regTrans.DTADTL;
        taxCodeCreatingDTA += _regTrans.CreatingDTA;
        taxCodeDecreasingDTA += _regTrans.DecreasingDTA;
        taxCodeCreatingDTL += _regTrans.CreatingDTL;
        taxCodeDecreasingDTL += _regTrans.DecreasingDTL;

        profitInitialDTADTL += isEqualMthTransDateToMthDateFrom ? _regTrans.InitialDTADTL : 0;
        profitNetBookValue += _regTrans.NetBookValue;
        profitTaxNetBookValue += _regTrans.TaxNetBookValue;
        profitDTADTL += _regTrans.DTADTL;
        profitCreatingDTA   += _regTrans.CreatingDTA;
        profitDecreasingDTA += _regTrans.DecreasingDTA;
        profitCreatingDTL   += _regTrans.CreatingDTL;
        profitDecreasingDTL += _regTrans.DecreasingDTL;
    }

]]></Source>
			</Method>
			<Method>
				<Name>correctedPeriodDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the minimum date from the dates which correspond to the end of the quarter in which the reporting date of the corrective transaction is included.
    /// </summary>
    /// <param name="_fromDateCalculation">
    /// Start date of the period in which the accounting date should be included.
    /// </param>
    /// <param name="_toDateCalculation">
    /// End date of the period in which the accounting date should be included.
    /// </param>
    /// <param name="_toDateCorrection">
    /// End date of the period in which the reporting date should be included.
    /// </param>
    /// <returns>
    /// Minimum date from the dates which correspond to the end of the quarter in which the corrective transaction is included.
    /// </returns>
    public ReportingDate_RU correctedPeriodDate(FromDate _fromDateCalculation, ToDate _toDateCalculation, ToDate _toDateCorrection)
    {
        ReportingDate_RU correctedPeriodDate;

        correctedPeriodDate = this.correctedPeriodDateGroupTypes(
            RAssetGroupTypes::FixedAssets,
            correctedPeriodDate,
            _fromDateCalculation,
            _toDateCalculation,
            _toDateCorrection);

        correctedPeriodDate = this.correctedPeriodDateGroupTypes(
            RAssetGroupTypes::Cloths,
            correctedPeriodDate,
            _fromDateCalculation,
            _toDateCalculation,
            _toDateCorrection);

        correctedPeriodDate = this.correctedPeriodDateGroupTypes(
            RAssetGroupTypes::Rigging,
            correctedPeriodDate,
            _fromDateCalculation,
            _toDateCalculation,
            _toDateCorrection);

        QueryRun qrCheck = this.queryRunDeferralsCheck(_fromDateCalculation, _toDateCalculation, _toDateCorrection);
        if (qrCheck.next())
        {
            RDeferralsTransCorrectiveView deferralsTrans = qrCheck.get(tableNum(RDeferralsTransCorrectiveView));
            if (!correctedPeriodDate || correctedPeriodDate > deferralsTrans.ReportingDate)
            {
                correctedPeriodDate = dateEndQtr(deferralsTrans.ReportingDate);
            }
        }

        return correctedPeriodDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>correctedPeriodDateGroupTypes</Name>
				<Source><![CDATA[
    private ReportingDate_RU correctedPeriodDateGroupTypes(
        RAssetGroupTypes _assetGroupTypes,
        ReportingDate_RU _currentMinDate,
        FromDate _fromDateCalculation,
        ToDate _toDateCalculation,
        ToDate _toDateCorrection)
    {
        ReportingDate_RU correctedPeriodDate = _currentMinDate;

        QueryRun qrCheck = this.queryRunAssetCheck(_fromDateCalculation, _toDateCalculation, _toDateCorrection, _assetGroupTypes);
        if (qrCheck.next())
        {
            RAssetTransCorrectiveView assetTrans = qrCheck.get(tableNum(RAssetTransCorrectiveView));

            if (!correctedPeriodDate || correctedPeriodDate > assetTrans.ReportingDate)
            {
                correctedPeriodDate = dateEndQtr(assetTrans.ReportingDate);
            }
        }

        return correctedPeriodDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRunAssetCheck</Name>
				<Source><![CDATA[
    private QueryRun queryRunAssetCheck(
        FromDate _fromDateCalculation,
        ToDate _toDateCalculation,
        ToDate _toDateCorrection,
        RAssetGroupTypes _assetGroupTypes = RAssetGroupTypes::FixedAssets)
    {
        const RTax25ParameterCode ParameterCodeOne = 1;
        Query query = new Query();

        QueryBuildDataSource qbdsAssetTrans = query.addDataSource(tableNum(RAssetTransCorrectiveView));
        qbdsAssetTrans.addSortField(fieldNum(RAssetTransCorrectiveView, ReportingDate), SortOrder::Ascending);
        qbdsAssetTrans.firstOnly(true);

        str queryRangeForRAssetStandardId = queryRangeConcat(queryValue(rAssetStandardTaxId), rAssetStandardId);
        qbdsAssetTrans.addRange(fieldnum(RAssetTransCorrectiveView, AssetStandardId)).value(queryRangeForRAssetStandardId);
        Range queryRange = queryValue(RAssetTransType::Depreciation);
        queryRange = queryRangeConcat(queryRange, RAssetTransType::DepreciationAdj);
        queryRange = queryRangeConcat(queryRange, RAssetTransType::WriteDownAdj);
        queryRange = queryRangeConcat(queryRange, RAssetTransType::WriteUpAdj);
        queryRange = queryRangeConcat(queryRange, RAssetTransType::Disposal);
        queryRange = queryRangeConcat(queryRange, RAssetTransType::DisposalScrap);
        queryRange = queryRangeConcat(queryRange, RAssetTransType::DisposalSale);
        queryRange = queryRangeConcat(queryRange, RAssetTransType::Acquisition);
        queryRange = queryRangeConcat(queryRange, RAssetTransType::AcquisitionAdj);
        queryRange = queryRangeConcat(queryRange, RAssetTransType::Revaluation);
        qbdsAssetTrans.addRange(fieldnum(RAssetTransCorrectiveView, AssetTransType)).value(queryRange);
        qbdsAssetTrans.addRange(fieldnum(RAssetTransCorrectiveView, AccountingDate)).value(queryRange(_fromDateCalculation, _toDateCalculation));
        qbdsAssetTrans.addRange(fieldnum(RAssetTransCorrectiveView, ReportingDate)).value(queryRange(dateNull(), _toDateCorrection));

        QueryBuildDataSource qbds = qbdsAssetTrans.addDataSource(tableNum(RAssetStandards));
        qbds.fetchMode(QueryFetchMode::One2One);
        qbds.joinMode(JoinMode::ExistsJoin);

        qbds.addLink(fieldnum(RAssetTransCorrectiveView, AccountNum), fieldnum(RAssetStandards, AssetId));

        qbds.addRange(fieldnum(RAssetStandards, AssetStandardId)).value(queryValue(rAssetStandardTaxId));
        qbds.addRange(fieldnum(RAssetStandards, AssetGroup)).value(RTax25RegisterParameters::find(registerId, ParameterCodeOne).Parameter);

        qbds = qbdsAssetTrans.addDataSource(tablenum(RAssetTable));
        qbds.addLink(fieldNum(RAssetTransCorrectiveView, AccountNum), fieldNum(RAssetTable, AccountNum));
        qbds.fetchMode(QueryFetchMode::One2One);
        qbds.joinMode(JoinMode::ExistsJoin);

        if (_assetGroupTypes == RAssetGroupTypes::FixedAssets)
        {
            qbds.addRange(fieldnum(RAssetTable, AssetType)).value(parmTypeId);
        }

        qbds = qbds.addDataSource(tablenum(RAssetMainGroup));
        qbds.addLink(fieldnum(RAssetTable, AssetGroup), fieldnum(RAssetMainGroup, AssetMainGroupId));
        qbds.joinMode(JoinMode::ExistsJoin);
        qbds.fetchMode(QueryFetchMode::One2One);
        qbds.addRange(fieldnum(RAssetMainGroup, GroupType)).value(queryValue(_assetGroupTypes));

        QueryRun queryRun = new QueryRun(query);

        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRunDeferralsCheck</Name>
				<Source><![CDATA[
    private QueryRun queryRunDeferralsCheck(
        FromDate _fromDateCalc,
        ToDate _toDateCalc,
        ToDate _toDateCorr)
    {
        const RTax25ParameterCode ParameterCodeFour = 4;
        Query query = new Query();

        QueryBuildDataSource qbdsTrans = query.addDataSource(tablenum(RDeferralsTransCorrectiveView));
        qbdsTrans.addSortField(fieldNum(RDeferralsTransCorrectiveView, ReportingDate), SortOrder::Ascending);
        qbdsTrans.firstOnly(true);

        qbdsTrans.addRange(fieldNum(RDeferralsTransCorrectiveView, DeferralsBookId)).value(queryRangeConcat(queryValue(rDeferralsBookTaxId), rDeferralsBookId));
        qbdsTrans.addRange(fieldNum(RDeferralsTransCorrectiveView, AccountingDate)).value(queryRange(_fromDateCalc, _toDateCalc));
        qbdsTrans.addRange(fieldNum(RDeferralsTransCorrectiveView, ReportingDate)).value(queryRange(dateNull(), _toDateCorr));

        QueryBuildDataSource qbds = qbdsTrans.addDataSource(tablenum(RDeferralsBook));
        qbds.addLink(fieldNum(RDeferralsTransCorrectiveView, DeferralsId), fieldNum(RDeferralsBook, DeferralsId));
        qbds.joinMode(JoinMode::ExistsJoin);
        qbds.fetchMode(QueryFetchMode::One2One);

        qbds.addRange(fieldNum(RDeferralsBook, DeferralsBookId)).value(queryValue(rDeferralsBookTaxId));
        qbds.addRange(fieldNum(RDeferralsBook, DeferralsGroupId)).value(RTax25RegisterParameters::find(registerId, ParameterCodeFour).Parameter);

        qbds = qbdsTrans.addDataSource(tableNum(RDeferralsTable));
        qbds.addRange(fieldnum(RDeferralsTable, rTax25ProfitTable)).value(SysQuery::valueNot(0));
        qbds.addLink(fieldNum(RDeferralsTransCorrectiveView, DeferralsId), fieldNum(RDeferralsTable, DeferralsId));
        qbds.fetchMode(QueryFetchMode::One2One);

        QueryRun queryRun = new QueryRun(query);

        return queryRun;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>