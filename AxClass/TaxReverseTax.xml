<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxReverseTax</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>TaxReverseTax</c> class is used for calculating the tax reversal of reversed tax upon a
///    settled cash discount.
/// </summary>
/// <remarks>
///    If an invoice has a cash discount and a payment is settled, and the settlement is reversed. Then,
///    this method calculates the reversed tax for the cash discount. This class derives from the
///    <c>Tax</c> class and works as an extension of the main tax engine.
/// </remarks>
class TaxReverseTax extends TaxReverse
{
    TmpTaxWorkTrans         tmpTaxWorkTransLocal;
    LedgerJournalId         ledgerJournalId;
    RefTableId              reverseTaxTableId;
    RefRecId                reverseTaxRecId;
    boolean                 exchRatesSet;
    LedgerJournalTransTxt   transTxt;

    TaxModuleType           source;
    boolean                 sourceSet;

    boolean                 sourceAmountCurSet;
    AmountCur               sourceAmountCur;

    RefTableId              restrictionSourceTableId;
    RefRecId                restrictionSourceRecId;
    boolean                 preserveSourceRecId;
    boolean                 useSubLedgerJournalLines;

    // <GEERU>
    TransDate               originalTransDate;
    CustVendTransPostingLogRecId_RU custVendTransPostingLog_RU;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>adjustTaxes</Name>
				<Source><![CDATA[
    public void adjustTaxes(
        LedgerPostingController _ledgerPostingController,
        Voucher _originalVoucher,
        TransDate _originalTransDate,
        LedgerJournalId _ledgerJournalId,
        RefTableId _newTaxTransParentTableId,
        RefRecId _newTaxTransParentRecId)
    {
        AmountCur           taxTotalAmountCur;
        AmountCur           totalOffsetAmountCur;
        AmountCur           allocatedTaxAmount;
        Factor              factor;
        TmpTaxWorkTrans     tmpTaxWorkTransLocalRounding;
        LedgerJournalTrans  ledgerJournalTransFieldList;
        LedgerJournalTrans  ledgerJournalTransOffsetFieldList;
        TaxTrans            taxTrans;
        CurrencyExchangeHelper  exchangeRateHelper;
        LedgerDimensionAccount  ledgerDimension;
        // <GIN>
        TaxTrans_IN             taxTransIN;
        LedgerJournalTrans      ledgerJournalTransLocal;
        TaxAmount               vatDeferredAmount;
        TaxTable                taxTable;
        TransTaxInformation     transTaxInformation;
        // </GIN>

        // <GEEU>
        #EECountryRegionCodes
        // </GEEU>

        //  Accumulate all the offset transaction amounts.
        select sum (AmountCurDebit), sum(AmountCurCredit) from ledgerJournalTransOffsetFieldList
            where ledgerJournalTransOffsetFieldList.JournalNum          == _ledgerJournalId
               && ledgerJournalTransOffsetFieldList.Voucher             == voucher
               && ledgerJournalTransOffsetFieldList.TransDate           == taxDate
               && ledgerJournalTransOffsetFieldList.PurchLedgerPosting  == ArrivalPostingType::Offset;

        totalOffsetAmountCur += ledgerJournalTransOffsetFieldList.AmountCurDebit -
                                ledgerJournalTransOffsetFieldList.AmountCurCredit;

        if (totalOffsetAmountCur)
        {
            temporaryLedgerPostingJournal = _ledgerPostingController.getJournal();

            taxTotalAmountCur = this.calcAndInsertTaxes(_originalVoucher, _originalTransDate);

            while select AmountCurDebit, AmountCurCredit, LedgerDimension, DefaultDimension, CurrencyCode, Triangulation, TableId, RecId, Company, ReasonRefRecID from ledgerJournalTransFieldList
                where ledgerJournalTransFieldList.JournalNum == _ledgerJournalId
                   && ledgerJournalTransFieldList.Voucher    == voucher
                   && ledgerJournalTransFieldList.TransDate  == taxDate
                   && ledgerJournalTransFieldList.NoEdit     == NoYes::No
            {
                factor = ledgerJournalTransFieldList.amount() / totalOffsetAmountCur;
                ledgerDimension = ledgerJournalTransFieldList.parmLedgerDimension();

                using (TaxReverseTaxNewTransContext newTransContext = TaxReverseTaxNewTransContext::instance())
                {
                    newTransContext.parmReasonRefRecID(ledgerJournalTransFieldList.ReasonRefRecID);
                    allocatedTaxAmount += this.newTrans(ledgerDimension, factor, ledgerJournalTransFieldList.TableId, ledgerJournalTransFieldList.RecId, ledgerJournalTransFieldList.DefaultDimension);
                }
            }

            // Adjust the maximum TaxAmountCur for each tax code, tax direction and currency to make it balance
            boolean isAdjustNeeded = -allocatedTaxAmount != taxTotalAmountCur;

            if (!TaxSolutionScopeIntegrationUtil::isCompanyEnabled()
                && !isIndiaCountryRegionEnabled)
            {
                isAdjustNeeded = TmpTaxWorkTrans::isAdjustNeededAfterAllocationToLine(taxWorkTrans, tmpTaxWorkTransLocal);
            }

            if (isAdjustNeeded)
            {
                while select sum (TaxAmount),
                           sum (TaxAmountCur),
                           sum (TaxAmountRep),
                           sum (SourceTaxAmountCur),
                           sum (TaxBaseAmount),
                           sum (TaxBaseAmountCur),
                           sum (TaxBaseAmountRep),
                           sum (SourceBaseAmountCur),
                           sum (SourceRegulateAmountCur),
                           sum (TaxBaseQty),
                           sum (TaxInCostPrice),
                           sum (TaxInCostPriceMST),
                           sum (TaxInCostPriceCur),
                           sum (TaxInCostPriceRep),
                           sum (TaxInCostPriceRegulated)
                from taxWorkTrans
                group by TaxCode, TaxDirection, CurrencyCode, TaxAutogenerated, SourceCurrencyCode
                {
                    select sum (TaxAmount),
                           sum (TaxAmountCur),
                           sum (TaxAmountRep),
                           sum (SourceTaxAmountCur),
                           sum (TaxBaseAmount),
                           sum (TaxBaseAmountCur),
                           sum (TaxBaseAmountRep),
                           sum (SourceBaseAmountCur),
                           sum (SourceRegulateAmountCur),
                           sum (TaxBaseQty),
                           sum (TaxInCostPrice),
                           sum (TaxInCostPriceMST),
                           sum (TaxInCostPriceCur),
                           sum (TaxInCostPriceRep),
                           sum (TaxInCostPriceRegulated)
                    from tmpTaxWorkTransLocal
                    where tmpTaxWorkTransLocal.TaxCode          == taxWorkTrans.TaxCode &&
                          tmpTaxWorkTransLocal.TaxDirection     == taxWorkTrans.TaxDirection &&
                          tmpTaxWorkTransLocal.CurrencyCode     == taxWorkTrans.CurrencyCode &&
                          tmpTaxWorkTransLocal.TaxAutogenerated == taxWorkTrans.TaxAutogenerated;

                    //Get the maximum TaxAmountCur row for the tmpTaxWorkTransLocal buffer
                    tmpTaxWorkTransLocalRounding.setTmpData(tmpTaxWorkTransLocal);

                    select firstonly forupdate tmpTaxWorkTransLocalRounding
                    order by TaxAmountCur desc
                    where tmpTaxWorkTransLocalRounding.TaxCode          == taxWorkTrans.TaxCode &&
                          tmpTaxWorkTransLocalRounding.TaxDirection     == taxWorkTrans.TaxDirection &&
                          tmpTaxWorkTransLocalRounding.CurrencyCode     == taxWorkTrans.CurrencyCode &&
                          tmpTaxWorkTransLocalRounding.TaxAutogenerated == taxWorkTrans.TaxAutogenerated;

                    //Adjust the maximum TaxAmountCur row by logically taking out the rounding difference.
                    if (tmpTaxWorkTransLocalRounding.RecId)
                    {
                        tmpTaxWorkTransLocalRounding.TaxAmount                          -= (taxWorkTrans.TaxAmount + tmpTaxWorkTransLocal.TaxAmount);
                        tmpTaxWorkTransLocalRounding.TaxAmountCur                       -= (taxWorkTrans.TaxAmountCur + tmpTaxWorkTransLocal.TaxAmountCur);
                        tmpTaxWorkTransLocalRounding.TaxAmountRep                       -= (taxWorkTrans.TaxAmountRep + tmpTaxWorkTransLocal.TaxAmountRep);
                        tmpTaxWorkTransLocalRounding.SourceTaxAmountCur                 -= (taxWorkTrans.SourceTaxAmountCur + tmpTaxWorkTransLocal.SourceTaxAmountCur);
                        tmpTaxWorkTransLocalRounding.TaxBaseAmount                      -= (taxWorkTrans.TaxBaseAmount + tmpTaxWorkTransLocal.TaxBaseAmount);
                        tmpTaxWorkTransLocalRounding.TaxBaseAmountCur                   -= (taxWorkTrans.TaxBaseAmountCur + tmpTaxWorkTransLocal.TaxBaseAmountCur);
                        tmpTaxWorkTransLocalRounding.TaxBaseAmountRep                   -= (taxWorkTrans.TaxBaseAmountRep + tmpTaxWorkTransLocal.TaxBaseAmountRep);
                        tmpTaxWorkTransLocalRounding.SourceBaseAmountCur                -= (taxWorkTrans.SourceBaseAmountCur + tmpTaxWorkTransLocal.SourceBaseAmountCur);
                        tmpTaxWorkTransLocalRounding.SourceRegulateAmountCur            -= (taxWorkTrans.SourceRegulateAmountCur + tmpTaxWorkTransLocal.SourceRegulateAmountCur);
                        tmpTaxWorkTransLocalRounding.TaxBaseQty                         -= (taxWorkTrans.TaxBaseQty + tmpTaxWorkTransLocal.TaxBaseQty);
                        tmpTaxWorkTransLocalRounding.TaxInCostPrice                     -= (taxWorkTrans.TaxInCostPrice + tmpTaxWorkTransLocal.TaxInCostPrice);
                        tmpTaxWorkTransLocalRounding.TaxInCostPriceMST                  -= (taxWorkTrans.TaxInCostPriceMST + tmpTaxWorkTransLocal.TaxInCostPriceMST);
                        tmpTaxWorkTransLocalRounding.TaxInCostPriceCur                  -= (taxWorkTrans.TaxInCostPriceCur + tmpTaxWorkTransLocal.TaxInCostPriceCur);
                        tmpTaxWorkTransLocalRounding.TaxInCostPriceRep                  -= (taxWorkTrans.TaxInCostPriceRep + tmpTaxWorkTransLocal.TaxInCostPriceRep);
                        tmpTaxWorkTransLocalRounding.TaxInCostPriceRegulated            -= (taxWorkTrans.TaxInCostPriceRegulated + tmpTaxWorkTransLocal.TaxInCostPriceRegulated);
                        //This update is also updating the tmpTaxWorkTransLocal buffer
                        tmpTaxWorkTransLocalRounding.update(this.ignoreCalculatedSalesTax());
                    }
                }
            }

            exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), taxDate);

            while select taxWorkTrans
            {
                taxTrans.clear();
                this.initFromTaxWorkTrans(taxTrans, taxWorkTrans, this.taxOrigin(taxWorkTrans.TaxOrigin));
                taxTrans.TaxOrigin = TaxOrigin::TaxReversed;
                taxTrans.JournalNum = ledgerJournalId;
                // <GEEU>
                if (TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
                {
                    this.initVatRegData_W(taxTrans);
                }
                // </GEEU>
                TaxTransGlobalInitializer initializerBySourceTable = TaxTransGlobalInitializer::construct(taxTrans);
                initializerBySourceTable.parmTaxTransSource(taxWorkTrans);
                initializerBySourceTable.initTaxTransFromSourceTaxTrans();

                // <GMY>
                TaxGSTTaxInformation_MY::createGAFInformation(taxTrans);
                // </GMY>

                taxTrans.insert();
                // <GIN>
                if (isTaxParametersEnabled)
                {
                    taxTransIN.clear();
                    taxTransIN.initFromTaxWorkTrans(taxWorkTrans, taxTrans, factor);
                    taxTransIN.insert();
                }
                // </GIN>

                this.postAdjust(_ledgerPostingController, taxTrans, exchangeRateHelper, taxWorkTrans.LedgerDimension, taxWorkTrans.OperationLedgerDimension, taxWorkTrans.TaxOffsetUseTaxLedgerDimension);
            }

            while select tmpTaxWorkTransLocal
            {
                taxTrans.clear();
                // <GIN>
                if (isTaxParametersEnabled)
                {
                    taxTransIN.clear();
                }
                // </GIN>
                this.initFromTaxWorkTrans(taxTrans, tmpTaxWorkTransLocal, this.taxOrigin(taxWorkTrans.TaxOrigin));
                taxTrans.TaxOrigin = TaxOrigin::Tax;
                taxTrans.JournalNum = ledgerJournalId;

                if (!taxTrans.SourceRecId || !taxTrans.SourceTableId)
                {
                    taxTrans.SourceTableId = _newTaxTransParentTableId;
                    taxTrans.SourceRecId = _newTaxTransParentRecId;
                }

                // <GEEU>
                if (TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
                {
                    this.initVatRegData_W(taxTrans);
                }
                // </GEEU>
                TaxTransGlobalInitializer initializerBySourceTable = TaxTransGlobalInitializer::construct(taxTrans);
                initializerBySourceTable.parmTaxTransSource(tmpTaxWorkTransLocal);
                initializerBySourceTable.initTaxTransFromSourceTaxTrans();

                // <GMY>
                TaxGSTTaxInformation_MY::createGAFInformation(taxTrans);
                // </GMY>

                taxTrans.insert();
                // <GIN>
                if (isTaxParametersEnabled)
                {
                   taxTransIN.initFromTaxWorkTrans(tmpTaxWorkTransLocal, taxTrans);
                   taxTransIN.insert();
                }
                // </GIN>

                select firstOnly ledgerJournalTransLocal
                    where ledgerJournalTransLocal.JournalNum == ledgerJournalId
                        && ledgerJournalTransLocal.Voucher   == voucher
                        && ledgerJournalTransLocal.TransDate == taxDate
                        && ledgerJournalTransLocal.NoEdit    == NoYes::No
                        && ledgerJournalTransLocal.RecId     == tmpTaxWorkTransLocal.SourceRecId;

                if (ledgerJournalTransLocal &&
                    ledgerJournalTransLocal.AccountType != LedgerJournalACType::Ledger &&
                    TaxParameters::find().PurchTaxOnOperations)
                {
                    tmpTaxWorkTransLocal.OperationLedgerDimension = tmpTaxWorkTransLocal.LedgerDimension;
                }

                this.postAdjust(_ledgerPostingController, taxTrans, exchangeRateHelper, tmpTaxWorkTransLocal.LedgerDimension, tmpTaxWorkTransLocal.OperationLedgerDimension, tmpTaxWorkTransLocal.TaxOffsetUseTaxLedgerDimension);
            }
            // <GIN>
            if (isVATEnabled)
            {
                if (LedgerJournalTable::find(ledgerJournalId).JournalType   == LedgerJournalType::Approval &&
                    TaxTable::find(taxTrans.TaxCode).TaxType_IN             == TaxType_IN::VAT)
                {
                    select ledgerJournalTransLocal
                        where ledgerJournalTransLocal.JournalNum            == ledgerJournalId
                           && ledgerJournalTransLocal.PurchLedgerPosting    == ArrivalPostingType::None
                           && ledgerJournalTransLocal.Voucher               == taxTrans.Voucher;

                    transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(ledgerJournalTransLocal);

                    if (transTaxInformation.VATGoodsType == VATGoodsType_IN::CapitalGoods)
                    {
                        select sum(TaxAmountCur), sum(TaxInCostPriceCur) from tmpTaxWorkTransLocal
                        where tmpTaxWorkTransLocal.SourceTableId    == tableNum(LedgerJournalTrans)
                            && tmpTaxWorkTransLocal.SourceRecId      == ledgerJournalTransLocal.RecId
                        exists join taxTable
                            where taxTable.TaxCode    == tmpTaxWorkTransLocal.TaxCode
                                && taxTable.TaxType_IN == TaxType_IN::VAT;

                        vatDeferredAmount = tmpTaxWorkTransLocal.TaxAmountCur - tmpTaxWorkTransLocal.TaxInCostPriceCur;

                        if (vatDeferredAmount > 0 && ledgerJournalTransLocal.amount() > 0)
                        {
                            DefermentScheduleTrans_IN::createDefermentScheduleTrans(ledgerJournalTransLocal, vatDeferredAmount);
                        }
                    }
                    if (ledgerJournalTransLocal  &&
                        !taxTrans.SourceRecId    &&
                        !taxTrans.SourceTableId)
                    {
                        taxTrans.SourceRecId = ledgerJournalTransLocal.RecId;
                        taxTrans.SourceTableId = ledgerJournalTransLocal.TableId;
                    }
                }
            }
            // </GIN>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowExemptTax_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether exempt tax should be allowed
    /// </summary>
    /// <returns>
    /// False, but can be overridden in descendands
    /// </returns>
    protected boolean allowExemptTax_RU()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAndInsertTaxes</Name>
				<Source><![CDATA[
    public TaxAmount calcAndInsertTaxes(Voucher   _originalvoucher,
                                           TransDate _originalTransDate)
    {
        TaxTrans            taxTrans;
        TaxAmount           taxAmount;
        // <GIN>
        LedgerJournalTrans  ledgerJournalTrans;
        // </GIN>

        // <GEERU>
        TaxTrans_RU taxTrans_RU;
        // <GIN>
        #isoCountryRegionCodes
        // </GIN>
        // </GEERU>

        // <GTE>
        ITaxableDocument            taxableDocument;
        ITaxDocument                taxDocumentObject;
        LedgerJournalTrans          ledgerJournalTransGTE;
        // </GTE>

        ttsbegin;
        TaxReverseTaxParameters parameters = TaxReverseTaxParameters::construct();
        parameters.originalVoucher = _originalvoucher;
        parameters.originalTransDate = _originalTransDate;
        parameters.sourceAmountCurSet = sourceAmountCurSet;
        parameters.sourceAmountCur = sourceAmountCur;
        parameters.reverseTaxOrigin = this.reverseTaxOrigin();
        parameters.restrictionSourceTableId = restrictionSourceTableId;
        parameters.restrictionSourceRecId = restrictionSourceRecId;
        parameters.reverseTaxJournalId = reverseTaxJournalId;
        parameters.allowExemptTax_RU = this.allowExemptTax_RU();
        parameters.custVendTransPostingLogRecId_RU = this.parmCustVendTransPostingLog_RU();

        Query query = this.buildTaxInsertAndCalcQuery(parameters);
        QueryRun queryRun = new QueryRun(query);
        //Sum taxamount from taxtrans.
        while (queryRun.next())
        {
            taxTrans = queryRun.get(tableNum(TaxTrans));
            if (parameters.CustVendTransPostingLogRecId_RU)
            {
                taxTrans_RU = queryRun.get(tableNum(TaxTrans_RU));
            }
            taxAmount += this.insertTaxWorkTrans(taxTrans, taxTrans_RU);
        }

        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            ledgerJournalTransGTE = LedgerJournalTrans::findJournalForVoucher(_originalvoucher, _originalTransDate);

            taxableDocument = TaxableDocumentObject::construct(
                TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(ledgerJournalTransGTE));

            taxDocumentObject = TaxBusinessService::calculateTax(taxableDocument);
            if (taxDocumentObject)
            {
                taxAmount = taxDocumentObject.sumByTaxAccountingProvider(TaxAccountingProvider::Party, TaxAccountingPostingProfileDistributionSide::Debit).amountTransactionCurrency();
                taxAmount -= taxDocumentObject.sumByTaxAccountingProvider(TaxAccountingProvider::Party, TaxAccountingPostingProfileDistributionSide::Credit).amountTransactionCurrency();
            }
        }
        // </GTE>

        // <GIN>
        if (isIndiaCountryRegionEnabled)
        {
            ledgerJournalTrans = LedgerJournalTrans::findJournalForVoucher(_originalvoucher, _originalTransDate);
            LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
            if (ledgerJournalTrans.RecId
                && ledgerJournalTransTaxExt.TaxSetoffVoucher)
            {
                taxAmount += this.reverseTaxSetoffVoucher_IN(ledgerJournalTransTaxExt.TaxSetoffVoucher);
            }
        }
        // </GIN>
        ttscommit;

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAndPost</Name>
				<Source><![CDATA[
    public AmountCur calcAndPost(
        LedgerPostingController _ledgerPostingController,
        Voucher _originalVoucher,
        TransDate _originalTransDate,
        boolean _postTaxes = true)
    {
        AmountCur amountCur;

        if (_ledgerPostingController.getJournal() == null)
        {
            throw error(Error::missingParameter(this));
        }

        _ledgerPostingController.getReference().lastTransTxt(transTxt);
        temporaryLedgerPostingJournal = _ledgerPostingController.getJournal();

        amountCur = this.calcAndInsertTaxes(_originalVoucher, _originalTransDate);

        if (_postTaxes)
        {
            this.saveAndPost(_ledgerPostingController);
        }

        return amountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRate</Name>
				<Source><![CDATA[
    ExchRate exchRate(date _date = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        ;
        return exchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContainers</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets a container that consists of the two variables <c>ConLedgerAccount</c> and
    ///    <c>ConSourceBaseAmountCur</c>.
    /// </summary>
    /// <returns>
    ///    A container that consists of the two variables <c>ConLedgerAccount</c> and
    ///    <c>ConSourceBaseAmountCur</c>.
    /// </returns>
    container getContainers()
    {
        return [conLedgerDimension, conSourceBaseAmountCur];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultAmountMSTSecondaryToPost_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns default amount in secondary currency to post
    /// </summary>
    /// <param name="_taxTrans">
    /// Tax transaction
    /// </param>
    /// <returns>
    /// Amount for post method
    /// </returns>
    protected AmountMSTSecondary getDefaultAmountMSTSecondaryToPost_RU(TaxTrans _taxTrans)
    {
        if (this.parmOriginalTransDate_RU())
        {
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                return -(select firstonly AmountMSTSecond from custVendTransPostingLog_RU
                    where custVendTransPostingLog_RU.Voucher        == _taxTrans.Voucher                &&
                          custVendTransPostingLog_RU.TransDate      == this.parmOriginalTransDate_RU() &&
                          custVendTransPostingLog_RU.PostingLogType == CustVendTransPostingLogType_RU::PrepaymentStornoVAT
                ).AmountMSTSecond;
            }
            // <GEECZ>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ]))
            {
                return -(select firstonly AmountMSTSecond from custVendTransPostingLog_RU
                    where custVendTransPostingLog_RU.Voucher        == _taxTrans.Voucher
                       && custVendTransPostingLog_RU.TransDate      == this.parmOriginalTransDate_RU()
                       && custVendTransPostingLog_RU.PostingLogType == CustVendTransPostingLogType_RU::PrepaymentStornoVAT
                       && custVendTransPostingLog_RU.Reversed       == NoYes::No
                ).AmountMSTSecond;
            }
            // </GEECZ>
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTaxWorkTrans</Name>
				<Source><![CDATA[
    private TaxAmount insertTaxWorkTrans(TaxTrans _taxTrans, TaxTrans_RU _taxTransRU = null)
    {
        if (!_taxTransRU)
        {
            _taxTransRU = _taxTrans.taxTrans_RU();
        }
        sourceCurrencyCode = _taxTrans.SourceCurrencyCode;
        triangulation = _taxTrans.euroTriangulation;

        this.initTaxWorkTransFromTaxTrans(_taxTrans, _taxTransRU);

        taxWorkTrans.insert();

        if (TaxReverseTaxPeriodAndTaxBook_ITFlight::instance().isEnabled())
        {
            taxWorkTransTaxTransMap.insert(taxWorkTrans.RecId, _taxTrans.RecId);
        }

        return this.taxAmount(taxWorkTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalNum</Name>
				<Source><![CDATA[
    LedgerJournalId journalNum()
    {
        return ledgerJournalId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new(Voucher                _voucher,
             TransDate              _transDate,
             LedgerJournalTransTxt  _txt,
             Percent                _percent = 100)
    {
        // reversals are by default 100% reversals
        super(_percent);

        voucher         = _voucher;
        taxDate         = _transDate;
        transTxt        = _txt;
        sourceSet       = false;

        preserveSourceRecId = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTrans</Name>
				<Source><![CDATA[
    protected AmountCur newTrans(LedgerDimensionAccount _operationLedgerDimension,
                                 Factor             _factor,
                                 RefTableId           _newTaxTransParentTableId,
                                 RefRecId             _newTaxTransParentRecId,
                                 DimensionDefault   _defaultDimension = 0)
    {
        AmountCur               taxAmount;

        while select taxWorkTrans
        {
            this.initNewTrans(_operationLedgerDimension, _factor, _newTaxTransParentTableId, _newTaxTransParentRecId, _defaultDimension);

            tmpTaxWorkTransLocal.insert();
            taxAmount += this.taxAmount(tmpTaxWorkTransLocal);
        }
        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustVendTransPostingLog_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Filter reversed tax transaction to be linked with the given posting log RecID
    /// </summary>
    /// <param name="_value">CustVendTransPostingLog_RU RecID</param>
    /// <returns>Current value of the filter</returns>
    public CustVendTransPostingLogRecId_RU parmCustVendTransPostingLog_RU(CustVendTransPostingLogRecId_RU _value = custVendTransPostingLog_RU)
    {
        custVendTransPostingLog_RU = _value;
        return custVendTransPostingLog_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOriginalTransDate_RU</Name>
				<Source><![CDATA[
    public TransDate parmOriginalTransDate_RU(TransDate _originalTransDate = originalTransDate)
    {
        originalTransDate = _originalTransDate;

        return originalTransDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseSubLedgerJournalLines</Name>
				<Source><![CDATA[
    public boolean parmUseSubLedgerJournalLines(boolean _useSubLedgerJournalLines = useSubLedgerJournalLines)
    {
        useSubLedgerJournalLines = _useSubLedgerJournalLines;

        return useSubLedgerJournalLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postAdjust</Name>
				<Source><![CDATA[
    public void postAdjust(LedgerPostingController _ledgerPostingController,
                           TaxTrans _taxTrans,
                           CurrencyExchangeHelper  _exchangeRateHelper,
                           LedgerDimensionAccount  _ledgerDimension,
                           LedgerDimensionAccount  _operationLedgerDimension,
                           LedgerDimensionAccount  _taxOffsetUseTaxLedgerDimension)
    {
        AmountCur           taxAmountCur;
        AmountCur           taxInCostPrice;
        ExchRate            exchRateOnTax;
        // <GIN>
        TaxType_IN          taxType;
        // </GIN>
        if (!_taxTrans.TaxAutogenerated)
        {
            taxAmountCur = _taxTrans.SourceRegulateAmountCur;
            taxInCostPrice = _taxTrans.TaxInCostPriceRegulated;
        }
        else
        {
            taxAmountCur   = _taxTrans.SourceTaxAmountCur;
            taxInCostPrice = _taxTrans.TaxInCostPrice;
        }
        // <GIN>
        if (isTaxParametersEnabled)
        {
            taxType = TaxTable::find(_taxTrans.TaxCode).TaxType_IN;
            if (taxType != TaxType_IN::None
                && ((taxType == TaxType_IN::Customs          && isCustomsEnabled)
                    || (taxType == TaxType_IN::Excise        && isExciseEnabled)
                    || (taxType == TaxType_IN::SalesTax      && isSalesTaxEnabled)
                    || (taxType == TaxType_IN::ServiceTax    && isServiceTaxEnabled)
                    || (taxType == TaxType_IN::VAT           && isVATEnabled)))
            {
                totLOIAmount = _taxTrans.TaxInCostPrice;
            }

            this.getPostingType_IN(taxType);
        }
        // </GIN>

        if (_taxTrans.ExemptTax == NoYes::No && taxAmountCur)
        {
            temporaryLedgerPostingJournal = _ledgerPostingController.getJournal();

            sourceCurrencyCode = _taxTrans.SourceCurrencyCode;

            if (taxAmountCur != 0 && !triangulation && this.exchRate() != _taxTrans.TaxAmount / taxAmountCur * 100)
            {
                exchRateOnTax = _taxTrans.TaxAmount / taxAmountCur * 100;
            }
            else
            {
                exchRateOnTax = this.exchRate();
            }

            _ledgerPostingController.getReference().lastTransTxt(transTxt);

            _exchangeRateHelper.parmExchangeRate1(exchRateOnTax);
            _exchangeRateHelper.parmExchangeDate(_taxTrans.TransDate);

            this.post(_ledgerPostingController, _taxTrans, taxAmountCur, taxInCostPrice, _exchangeRateHelper, _ledgerDimension, _operationLedgerDimension, _taxOffsetUseTaxLedgerDimension);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>preserveOriginalParent</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the parent record ID from the <c>TaxTrans</c> record should be used for the
    ///    reversal record.
    /// </summary>
    public void preserveOriginalParent()
    {
        preserveSourceRecId = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recalcWithFactor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Recalculates the tax amount with factor.
    /// </summary>
    /// <param name = "_tmpTaxWorkTrans">The buffer of <c>TmpTaxWorkTrans</c>.</param>
    /// <param name = "_factor">The factor.</param>
    protected void recalcWithFactor(TmpTaxWorkTrans _tmpTaxWorkTrans,
                                    Factor          _factor)
    {
        CurrencyCode    reportingCurrency = Ledger::reportingCurrency(this.companyInfo().RecId);

            _tmpTaxWorkTrans.TaxAmount                          = CurrencyExchangeHelper::amount(_tmpTaxWorkTrans.TaxAmount * _factor);
            _tmpTaxWorkTrans.TaxAmountCur                       = CurrencyExchangeHelper::amount(_tmpTaxWorkTrans.TaxAmountCur * _factor, _tmpTaxWorkTrans.CurrencyCode);
            _tmpTaxWorkTrans.TaxAmountRep                       = CurrencyExchangeHelper::amount(_tmpTaxWorkTrans.TaxAmountRep * _factor, reportingCurrency);
            _tmpTaxWorkTrans.TaxBaseAmount                      = CurrencyExchangeHelper::amount(_tmpTaxWorkTrans.TaxBaseAmount * _factor);
            _tmpTaxWorkTrans.TaxBaseAmountCur                   = CurrencyExchangeHelper::amount(_tmpTaxWorkTrans.TaxBaseAmountCur * _factor, _tmpTaxWorkTrans.CurrencyCode);
            _tmpTaxWorkTrans.TaxBaseAmountRep                   = CurrencyExchangeHelper::amount(_tmpTaxWorkTrans.TaxBaseAmountRep * _factor, reportingCurrency);
            _tmpTaxWorkTrans.TaxInCostPrice                     = CurrencyExchangeHelper::amount(_tmpTaxWorkTrans.TaxInCostPrice * _factor, _tmpTaxWorkTrans.SourceCurrencyCode);
            _tmpTaxWorkTrans.TaxInCostPriceMST                  = CurrencyExchangeHelper::amount(_tmpTaxWorkTrans.TaxInCostPriceMST * _factor);
            _tmpTaxWorkTrans.TaxInCostPriceCur                  = CurrencyExchangeHelper::amount(_tmpTaxWorkTrans.TaxInCostPriceCur * _factor, _tmpTaxWorkTrans.CurrencyCode);
            _tmpTaxWorkTrans.TaxInCostPriceRep                  = CurrencyExchangeHelper::amount(_tmpTaxWorkTrans.TaxInCostPriceRep * _factor, reportingCurrency);
            _tmpTaxWorkTrans.TaxInCostPriceRegulated            = CurrencyExchangeHelper::amount(_tmpTaxWorkTrans.TaxInCostPriceRegulated * _factor, _tmpTaxWorkTrans.SourceCurrencyCode);
            _tmpTaxWorkTrans.SourceTaxAmountCur                 = CurrencyExchangeHelper::amount(_tmpTaxWorkTrans.SourceTaxAmountCur * _factor, _tmpTaxWorkTrans.SourceCurrencyCode);
            _tmpTaxWorkTrans.SourceBaseAmountCur                = CurrencyExchangeHelper::amount(_tmpTaxWorkTrans.SourceBaseAmountCur * _factor, _tmpTaxWorkTrans.SourceCurrencyCode);
            _tmpTaxWorkTrans.SourceRegulateAmountCur            = CurrencyExchangeHelper::amount(_tmpTaxWorkTrans.SourceRegulateAmountCur * _factor, _tmpTaxWorkTrans.SourceCurrencyCode);
            _tmpTaxWorkTrans.TaxBaseQty                         = _tmpTaxWorkTrans.TaxBaseQty * _factor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>replaceTaxWorkTransWithLocal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Removes all records in the taxWorkTrans buffer and replaces it with all records in the tmpTaxWorkTransLocal buffer.
    /// </summary>
    private void replaceTaxWorkTransWithLocal()
    {
        delete_from taxWorkTrans;

        while select tmpTaxWorkTransLocal
        {
            taxWorkTrans.clear();

            taxWorkTrans.data(tmpTaxWorkTransLocal.data());

            taxWorkTrans.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseByFactor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Applies the percentage factor to the tax records that were reversed.
    /// </summary>
    /// <param name="_operationLedgerDimension">
    /// Default operation ledger dimension to use on the reversing tax records.
    /// </param>
    /// <param name="_factor">
    /// The percentage to use on the reversing records.
    /// </param>
    /// <param name="_newTaxTransParentTableId">
    /// Identifies the source table to use on the reversing tax records.
    /// </param>
    /// <param name="_newTaxTransParentRecId">
    /// Identifies the source record to use on the reversing tax records.
    /// </param>
    /// <returns>
    /// Total tax amount of the reversing tax records.
    /// </returns>
    public AmountCur reverseByFactor(LedgerDimensionAccount _operationLedgerDimension,
                                     Factor             _factor,
                                     RefTableId           _newTaxTransParentTableId,
                                     RefRecId             _newTaxTransParentRecId)
    {
        AmountCur   taxAmount;

        // Generate tax records based on the percentage being applied
        taxAmount = this.newTrans(_operationLedgerDimension, _factor, _newTaxTransParentTableId, _newTaxTransParentRecId);

        // Use the prorated tax records
        this.replaceTaxWorkTransWithLocal();

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseTaxOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the enumeration value <c>Tax</c>, from the enumerated type <c>TaxOrigin</c>.
    /// </summary>
    /// <returns>
    ///    The value <c>TaxOrigin::Tax</c>.
    /// </returns>
    TaxOrigin reverseTaxOrigin()
    {
        return TaxOrigin::Tax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseTaxSetoffVoucher_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the TaxAmount if Voucher is TaxSetOffVoucher.
    /// </summary>
    /// <param name="_taxSetoffVoucher_IN">
    /// TaxSetOffVoucher_IN
    /// </param>
    /// <returns>
    /// Returns TaxAmount if Voucher is TaxSetOffVoucher.
    /// </returns>

    protected TaxAmount reverseTaxSetoffVoucher_IN(Voucher   _taxSetoffVoucher_IN)
    {
        TaxTrans            taxTrans;
        TaxAmount           taxAmount;

        ttsbegin;

        while select * from taxTrans
            where (taxTrans.Voucher     == _taxSetoffVoucher_IN)
        {
            sourceCurrencyCode = taxTrans.SourceCurrencyCode;
            triangulation = taxTrans.euroTriangulation;

            taxWorkTrans.clear();
            taxWorkTrans.HeadingRecId               = headingRecId;
            taxWorkTrans.SourceTableId              = this.sourceTableId();
            if (preserveSourceRecId)
            {
                taxWorkTrans.SourceRecId            = taxTrans.SourceRecId;
            }
            else
            {
                taxWorkTrans.SourceRecId            = this.sourceRecId();
            }

            taxWorkTrans.TaxCode                    = taxTrans.TaxCode;
            taxWorkTrans.TaxGroup                   = taxTrans.TaxGroup;
            taxWorkTrans.TaxItemGroup               = taxTrans.TaxItemGroup;

            if (sourceSet)
            {
                taxWorkTrans.Source                 = source;
            }
            else
            {
                taxWorkTrans.Source                 = taxTrans.Source;
            }

            taxWorkTrans.Voucher                    = voucher;
            taxWorkTrans.TransDate                  = taxDate;
            taxWorkTrans.CalculationDate            = taxDate;
            taxWorkTrans.TaxDirection               = taxTrans.TaxDirection;
            taxWorkTrans.CurrencyCode               = taxTrans.CurrencyCode;
            taxWorkTrans.SourceCurrencyCode         = sourceCurrencyCode;
            taxWorkTrans.TaxAutogenerated           = taxTrans.TaxAutogenerated;
            taxWorkTrans.euroTriangulation          = taxTrans.euroTriangulation;
            taxWorkTrans.TaxAmount                  = -taxTrans.TaxAmount;
            taxWorkTrans.TaxAmountCur               = -taxTrans.TaxAmountCur;
            taxWorkTrans.TaxBaseAmount              = -taxTrans.TaxBaseAmount;
            taxWorkTrans.TaxBaseAmountCur           = -taxTrans.TaxBaseAmountCur;
            taxWorkTrans.TaxInCostPrice             = -taxTrans.TaxInCostPrice;
            taxWorkTrans.TaxInCostPriceMST          = -taxTrans.TaxInCostPriceMST;
            taxWorkTrans.TaxInCostPriceCur          = -taxTrans.TaxInCostPriceCur;
            taxWorkTrans.TaxInCostPriceRegulated    = -taxTrans.TaxInCostPriceRegulated;
            taxWorkTrans.SourceTaxAmountCur         = -taxTrans.SourceTaxAmountCur;
            taxWorkTrans.SourceBaseAmountCur        = -taxTrans.SourceBaseAmountCur;
            taxWorkTrans.SourceRegulateAmountCur    = -taxTrans.SourceRegulateAmountCur;
            taxWorkTrans.TaxBaseQty                 = -taxTrans.TaxBaseQty;

            taxWorkTrans.TaxReports                 = NoYes::Yes;
            taxWorkTrans.ExemptTax                  = taxTrans.ExemptTax;
            taxWorkTrans.TaxAutogenerated           = taxTrans.TaxAutogenerated;
            taxWorkTrans.TaxOrigin                  = TaxOrigin::Tax;
            taxWorkTrans.HeadingTableId             = taxTrans.HeadingTableId;
            taxWorkTrans.SourceDocumentLine         = taxTrans.SourceDocumentLine;

            this.initTaxWorkTransLedgerDimensions(taxTrans);

            taxWorkTrans.insert();

            taxAmount += this.taxAmount(taxWorkTrans);
        }

        ttscommit;

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setExchRates</Name>
				<Source><![CDATA[
    void setExchRates(CurrencyCode      _sourceCurrencyCode = '',
                      ExchRate          _exchRate = 0,
                      ExchRate          _exchRateSecond = 0,
                      ExchRatesTriangulation    _triangulation = UnknownNoYes::Unknown,
                      TransDate         _exchRateDate = dateNull())
    {
        // <GEERU>
        #isoCountryRegionCodes
        // </GEERU>

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            super(_sourceCurrencyCode,
                _exchRate,
                _exchRateSecond,
                _triangulation);
        }
        else
        {
        // </GEERU>
            super(_sourceCurrencyCode, _exchRate, _exchRateSecond, _triangulation, _exchRateDate);
        // <GEERU>
        }
        // </GEERU>

        exchRatesSet = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setJournalNum</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the variable <c>ledgerJournalId</c> equal to the specified parameter.
    /// </summary>
    /// <param name="_ledgerJournalId">
    ///    The <c>LedgerJournalId</c> to set.
    /// </param>
    void setJournalNum(LedgerJournalId _ledgerJournalId)
    {
        ;
        ledgerJournalId = _ledgerJournalId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRestrictionRecId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets what the restriction should be when querying the <c>SourceTableId</c> field of the
    ///    <c>TaxTrans</c> record to discover what <c>TaxTrans</c> records should be reversed.
    /// </summary>
    /// <param name="_recId">
    ///    The <c>RefRecId</c> to set.
    /// </param>
    public void setRestrictionRecId(RefRecId _recId)
    {
        restrictionSourceRecId = _recId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRestrictionTableId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets what the restriction should be when querying the <c>SourceTableId</c> field of the
    ///    <c>TaxTrans</c> record to discover what <c>TaxTrans</c> records should be reversed.
    /// </summary>
    /// <param name="_tableId">
    ///    The <c>RefTableId</c> to set.
    /// </param>
    public void setRestrictionTableId(RefTableId _tableId)
    {
        restrictionSourceTableId = _tableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setReverseRecId</Name>
				<Source><![CDATA[
    public void setReverseRecId(RecId _reverseTaxRecId)
    {
        reverseTaxRecId = _reverseTaxRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setReverseTableId</Name>
				<Source><![CDATA[
    public void setReverseTableId(RefTableId    _reverseTaxTableId)
    {
        reverseTaxTableId = _reverseTaxTableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSource</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates the value of the source field on the <c>TaxTrans</c> record when the reversal is posted.
    /// </summary>
    /// <param name="_source">
    ///    The value of the <c>TaxModuleType</c> field.
    /// </param>
    /// <remarks>
    ///    By default, if this method is not used then the default value will be the same value as the
    ///    <c>TaxTrans</c> record that is reversed.
    /// </remarks>
    public void setSource(TaxModuleType _source)
    {
        source = _source;
        sourceSet = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSourceAmountCur</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the variables sourceAmountCurSet and sourceAmountCur.
    /// </summary>
    /// <param name="_amountCur">
    ///    The value to which to set the variable sourceAmountCur.
    /// </param>
    /// <remarks>
    ///    The variable sourceAmountCurSet is set to true by this method.
    /// </remarks>
    void setSourceAmountCur(AmountCur _amountCur)
    {;
        sourceAmountCurSet  = true;
        sourceAmountCur     = _amountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the record ID of the transaction line to calculate.
    /// </summary>
    /// <returns>
    /// The record ID of the transaction line to calculate.
    /// </returns>
    public recId sourceRecId()
    {
        return reverseTaxRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceTableId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the table ID of the transaction to tax.
    /// </summary>
    /// <returns>
    /// The ID of the transaction to tax.
    /// </returns>
    public RefTableId sourceTableId()
    {
        return reverseTaxTableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceTableId_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns source table id for tax, can be overridden
    /// </summary>
    /// <param name="_taxTrans">
    /// Tax transaction
    /// </param>
    /// <returns>
    /// Source table id for tax
    /// </returns>
    /// <remarks>
    /// Overridden in <c>TaxReverseTaxCustVendSettle_RU</c>
    /// </remarks>
    public RefTableId sourceTableId_RU(TaxTrans _taxTrans)
    {
        return this.sourceTableId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax amount for different direction.
    /// </summary>
    /// <param name = "_tmpTaxWorkTrans">The buffer of <c>TmpTaxWorkTrans</c>.</param>
    /// <returns>The tax amount.</returns>
    protected TaxAmount taxAmount(TmpTaxWorkTrans _tmpTaxWorkTrans)
    {
        TaxAmountCur   taxAmount;
        if (_tmpTaxWorkTrans.TaxDirection == TaxDirection::UseTax)
        {
            if (_tmpTaxWorkTrans.TaxAutogenerated)
            {
                taxAmount = -_tmpTaxWorkTrans.TaxInCostPrice;
            }
            else
            {
                taxAmount = -_tmpTaxWorkTrans.TaxInCostPriceRegulated;
            }
        }
        else
        {
            if (!_tmpTaxWorkTrans.TaxAutogenerated)
            {
                taxAmount = _tmpTaxWorkTrans.SourceRegulateAmountCur - _tmpTaxWorkTrans.TaxInCostPriceRegulated;
            }
            else
            {
                taxAmount = _tmpTaxWorkTrans.SourceTaxAmountCur - _tmpTaxWorkTrans.TaxInCostPrice;
            }
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountRegulation</Name>
				<Source><![CDATA[
    void taxAmountRegulation(TaxTrans           _taxTrans,
                             TaxAmountCur       _taxAmountCur,
                             ExchRate           _exchRate = 0,
                             ExchrateSecondary  _exchRateSecond = 0)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxBaseAmountRegulation</Name>
				<Source><![CDATA[
    void taxBaseAmountRegulation(TaxTrans          _taxTrans,
                                 AmountCur         _amountCur,
                                 ExchRate           _exchRate = 0,
                                 ExchrateSecondary _exchRateSecond = 0)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxInCostPriceReporting</Name>
				<Source><![CDATA[
    void taxInCostPriceReporting(TaxTrans           _taxTrans,
                                 TaxAmountCur       _taxAmountCur,
                                 ExchRate           _exchRate = 0,
                                 ExchrateSecondary  _exchRateSecond = 0)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the default tax origin.
    /// </summary>
    /// <param name="_defaultTaxOrigin">
    /// The default tax origin.
    /// </param>
    /// <returns>
    /// The default tax origin.
    /// </returns>
    protected TaxOrigin taxOrigin(TaxOrigin _defaultTaxOrigin)
    {
        return TaxOrigin::TaxReversed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useSubLedgerJournalLines</Name>
				<Source><![CDATA[
    public boolean useSubLedgerJournalLines()
    {
        return useSubLedgerJournalLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxWorkTransFromTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the fields of <c>TmpTaxWorkTrans</c>.
    /// </summary>
    /// <param name = "_taxTrans">
    /// The buffer of <c>TaxTrans</c>.
    /// </param>
    /// <param name = "_taxTransRU">
    /// The buffer of <c>TaxTrans_RU</c>.
    /// </param>
    [Hookable(true)]
    protected void initTaxWorkTransFromTaxTrans(TaxTrans _taxTrans, TaxTrans_RU _taxTransRU)
    {
        // <GEERU>
        #isoCountryRegionCodes
        boolean     isRussiaEnabled = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        // <GIN>
        TaxTrans_W taxTrans_W;
        // </GIN>

        taxWorkTrans.clear();
        taxWorkTrans.HeadingRecId = headingRecId;

        // <GEERU>
        if (isRussiaEnabled)
        {
            taxWorkTrans.SourceTableId = this.sourceTableId_RU(_taxTrans);
        }
        else
        {
            // </GEERU>
            taxWorkTrans.SourceTableId = this.sourceTableId();
            // <GEERU>
        }
        // </GEERU>

        if (preserveSourceRecId)
        {
            taxWorkTrans.SourceRecId = _taxTrans.SourceRecId;
        }
        else
        {
            taxWorkTrans.SourceRecId = this.sourceRecId();
        }

        taxWorkTrans.TaxCode        = _taxTrans.TaxCode;
        taxWorkTrans.TaxGroup       = _taxTrans.TaxGroup;
        taxWorkTrans.TaxItemGroup   = _taxTrans.TaxItemGroup;

        if (sourceSet)
        {
            taxWorkTrans.Source = source;
        }
        else
        {
            taxWorkTrans.Source = _taxTrans.Source;
        }

        taxWorkTrans.Voucher                    = voucher;
        taxWorkTrans.TransDate                  = taxDate;
        taxWorkTrans.CalculationDate            = taxDate;
        taxWorkTrans.TaxDirection               = _taxTrans.TaxDirection;
        taxWorkTrans.CurrencyCode               = _taxTrans.CurrencyCode;
        taxWorkTrans.SourceCurrencyCode         = sourceCurrencyCode;
        taxWorkTrans.TaxAutogenerated           = _taxTrans.TaxAutogenerated;
        taxWorkTrans.euroTriangulation          = _taxTrans.euroTriangulation;
        taxWorkTrans.TaxAmount                  = -_taxTrans.TaxAmount;
        taxWorkTrans.TaxAmountCur               = -_taxTrans.TaxAmountCur;
        taxWorkTrans.TaxAmountRep               = -_taxTrans.TaxAmountRep;
        taxWorkTrans.TaxBaseAmount              = -_taxTrans.TaxBaseAmount;
        taxWorkTrans.TaxBaseAmountCur           = -_taxTrans.TaxBaseAmountCur;
        taxWorkTrans.TaxBaseAmountRep           = -_taxTrans.TaxBaseAmountRep;
        taxWorkTrans.TaxInCostPrice             = -_taxTrans.TaxInCostPrice;
        taxWorkTrans.TaxInCostPriceMST          = -_taxTrans.TaxInCostPriceMST;
        taxWorkTrans.TaxInCostPriceCur          = -_taxTrans.TaxInCostPriceCur;
        taxWorkTrans.TaxInCostPriceRep          = -_taxTrans.TaxInCostPriceRep;
        taxWorkTrans.TaxInCostPriceRegulated    = -_taxTrans.TaxInCostPriceRegulated;
        taxWorkTrans.SourceTaxAmountCur         = -_taxTrans.SourceTaxAmountCur;
        taxWorkTrans.SourceBaseAmountCur        = -_taxTrans.SourceBaseAmountCur;
        taxWorkTrans.SourceRegulateAmountCur    = -_taxTrans.SourceRegulateAmountCur;
        taxWorkTrans.TaxBaseQty                 = -_taxTrans.TaxBaseQty;

        taxWorkTrans.TaxReports                 = NoYes::Yes;
        taxWorkTrans.ExemptTax                  = _taxTrans.ExemptTax;
        taxWorkTrans.TaxAutogenerated           = _taxTrans.TaxAutogenerated;
        taxWorkTrans.TaxOrigin                  = TaxOrigin::Tax;
        taxWorkTrans.TaxId                      = _taxTrans.TaxID;
        taxWorkTrans.PartyTaxId                 = _taxTrans.PartyTaxId;
        taxWorkTrans.ISVFeatureSetupGuid        = _taxTrans.ISVFeatureSetupGuid;
        taxWorkTrans.ISVFeatureSetupName        = _taxTrans.ISVFeatureSetupName;
        taxWorkTrans.EmptyTaxBaseForOutgoingTax_W = _taxTrans.EmptyTaxBaseForOutgoingTax_W;

        if (TaxIntegrationUtils::isTaxInformationEnabled())
        {
            taxWorkTrans.OriginalTaxTrans = _taxTrans.RecId;
        }

        if (this.headingTableId())
        {
            taxWorkTrans.HeadingTableId             = this.headingTableId();
        }
        else
        {
            taxWorkTrans.HeadingTableId             = _taxTrans.HeadingTableId;
        }

        taxWorkTrans.SourceDocumentLine         = _taxTrans.SourceDocumentLine;
        taxWorkTrans.ReverseCharge_W            = _taxTrans.ReverseCharge_W;
        taxWorkTrans.Reason                     = _taxTrans.Reason;
        taxWorkTrans.ReasonComment              = _taxTrans.ReasonComment;
        //<GEEPL>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            taxTrans_W = _taxTrans.taxTrans_W();
            taxWorkTrans.TaxPeriodPaymentCode_PL    = taxTrans_W.TaxPeriodPaymentCode_PL;
            taxWorkTrans.CustVendName_PL            = taxTrans_W.CustVendName_PL;
            taxWorkTrans.VatDueDate_W               = taxTrans_W.VatDueDate_W;
            taxWorkTrans.DocumentDate_PL            = taxTrans_W.DocumentDate_PL;
            taxWorkTrans.vatNum_PL                  = taxTrans_W.vatNum_PL;
            taxWorkTrans.Addressing_PL              = taxTrans_W.Addressing_PL;
            taxWorkTrans.TaxPeriodPaymentCode_PL    = taxTrans_W.TaxPeriodPaymentCode_PL;
        }
        //</GEEPL>

        if (TaxParameters::reportUseVatDueDate_W())
        {
            taxTrans_W = _taxTrans.taxTrans_W();
            taxWorkTrans.VatDueDate_W = taxTrans_W.VatDueDate_W;
        }

        // <GEERU>
        if(isRussiaEnabled)
        {
            taxWorkTrans.OffsetLedgerDimension_RU   = _taxTransRU.OffsetLedgerDimension_RU;
        }
        // </GEERU>
        this.initTaxWorkTransLedgerDimensions(_taxTrans);

        // <GIN>
        if (isIndiaCountryRegionEnabled)
        {
            taxTrans_W = _taxTrans.taxTrans_W();
            taxWorkTrans.TaxRegistrationNumberTable_IN  = taxTrans_W.TaxRegistrationNumberTable_IN;
            taxWorkTrans.CustomsDuty_IN                 = taxTrans_W.CustomsDuty_IN;
            if (!taxWorkTrans.LedgerDimension_IN && taxTrans_W.TaxType_IN == TaxType_IN::Customs)
            {
                taxWorkTrans.LedgerDimension_IN =
                    TaxTransGeneralJournalAccountEntry::getLedgerDimensionForTaxTrans_IN(TaxTrans_IN::findRefRecId(_taxTrans.RecId).RecId,
                        TaxTransRelationshipType::Tax,
                        fieldStr(TaxTrans_IN, ImportDutyExpenseLedgerDimension)).LedgerDimension;
            }
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>initNewTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes local <c>TmpTaxWorkTrans</c> from taxWorkTrans.
    /// </summary>
    /// <param name = "_operationLedgerDimension">
    /// The buffer of <c>LedgerDimensionAccount</c>.
    /// </param>
    /// <param name="_factor">
    /// The factor.
    /// </param>
    /// <param name="_newTaxTransParentTableId">
    /// Identifies the source table.
    /// </param>
    /// <param name="_newTaxTransParentRecId">
    /// Identifies the source record.
    /// </param>
    /// <param name= "_defaultDimension">
    /// The default dimension.
    /// </param>
    protected void initNewTrans(LedgerDimensionAccount _operationLedgerDimension,
                                Factor                 _factor,
                                RefTableId             _newTaxTransParentTableId,
                                RefRecId               _newTaxTransParentRecId,
                                DimensionDefault       _defaultDimension)
    {
        tmpTaxWorkTransLocal.clear();
        tmpTaxWorkTransLocal.HeadingRecId                       = taxWorkTrans.HeadingRecId;
        tmpTaxWorkTransLocal.SourceTableId                      = _newTaxTransParentTableId;
        tmpTaxWorkTransLocal.SourceRecId                        = _newTaxTransParentRecId;
        tmpTaxWorkTransLocal.HeadingTableId                     = taxWorkTrans.HeadingTableId;
        tmpTaxWorkTransLocal.TaxCode                            = taxWorkTrans.TaxCode;
        tmpTaxWorkTransLocal.TaxGroup                           = taxWorkTrans.TaxGroup;
        tmpTaxWorkTransLocal.TaxItemGroup                       = taxWorkTrans.TaxItemGroup;
        tmpTaxWorkTransLocal.Source                             = taxWorkTrans.Source;
        tmpTaxWorkTransLocal.Voucher                            = taxWorkTrans.Voucher;
        tmpTaxWorkTransLocal.TransDate                          = taxWorkTrans.TransDate;
        tmpTaxWorkTransLocal.TaxDirection                       = taxWorkTrans.TaxDirection;
        tmpTaxWorkTransLocal.CurrencyCode                       = taxWorkTrans.CurrencyCode;
        tmpTaxWorkTransLocal.SourceCurrencyCode                 = taxWorkTrans.SourceCurrencyCode;
        tmpTaxWorkTransLocal.TaxAutogenerated                   = taxWorkTrans.TaxAutogenerated;
        tmpTaxWorkTransLocal.euroTriangulation                  = taxWorkTrans.euroTriangulation;
        tmpTaxWorkTransLocal.TaxAmount                          = taxWorkTrans.TaxAmount;
        tmpTaxWorkTransLocal.TaxAmountCur                       = taxWorkTrans.TaxAmountCur;
        tmpTaxWorkTransLocal.TaxAmountRep                       = taxWorkTrans.TaxAmountRep;
        tmpTaxWorkTransLocal.TaxBaseAmount                      = taxWorkTrans.TaxBaseAmount;
        tmpTaxWorkTransLocal.TaxBaseAmountCur                   = taxWorkTrans.TaxBaseAmountCur;
        tmpTaxWorkTransLocal.TaxBaseAmountRep                   = taxWorkTrans.TaxBaseAmountRep;
        tmpTaxWorkTransLocal.TaxInCostPrice                     = taxWorkTrans.TaxInCostPrice;
        tmpTaxWorkTransLocal.TaxInCostPriceMST                  = taxWorkTrans.TaxInCostPriceMST;
        tmpTaxWorkTransLocal.TaxInCostPriceCur                  = taxWorkTrans.TaxInCostPriceCur;
        tmpTaxWorkTransLocal.TaxInCostPriceRep                  = taxWorkTrans.TaxInCostPriceRep;
        tmpTaxWorkTransLocal.TaxInCostPriceRegulated            = taxWorkTrans.TaxInCostPriceRegulated;
        tmpTaxWorkTransLocal.SourceTaxAmountCur                 = taxWorkTrans.SourceTaxAmountCur;
        tmpTaxWorkTransLocal.SourceBaseAmountCur                = taxWorkTrans.SourceBaseAmountCur;
        tmpTaxWorkTransLocal.SourceRegulateAmountCur            = taxWorkTrans.SourceRegulateAmountCur;
        tmpTaxWorkTransLocal.TaxBaseQty                         = taxWorkTrans.TaxBaseQty;
        tmpTaxWorkTransLocal.TaxReports                         = taxWorkTrans.TaxReports;
        tmpTaxWorkTransLocal.ExemptTax                          = taxWorkTrans.ExemptTax;
        tmpTaxWorkTransLocal.TaxAutogenerated                   = taxWorkTrans.TaxAutogenerated;
        tmpTaxWorkTransLocal.TaxOrigin                          = taxWorkTrans.TaxOrigin;
        tmpTaxWorkTransLocal.OperationLedgerDimension           = _operationLedgerDimension;
        tmpTaxWorkTransLocal.SourceDocumentLine                 = taxWorkTrans.SourceDocumentLine;
        tmpTaxWorkTransLocal.ReverseCharge_W                    = taxWorkTrans.ReverseCharge_W;

        TaxReverseTaxNewTransContext callingContext = TaxReverseTaxNewTransContext::current();
        if (callingContext && callingContext.parmReasonRefRecID())
        {
            [tmpTaxWorkTransLocal.Reason, tmpTaxWorkTransLocal.ReasonComment] = callingContext.getReasonData();
        }
        else
        {
            tmpTaxWorkTransLocal.Reason = taxWorkTrans.Reason;
            tmpTaxWorkTransLocal.ReasonComment = taxWorkTrans.ReasonComment;
        }

        tmpTaxWorkTransLocal.LedgerDimension = Tax::getNewLedgerDimensionDueToAccountStructureChange(taxWorkTrans.LedgerDimension);
        tmpTaxWorkTransLocal.TaxOffsetUseTaxLedgerDimension = Tax::getNewLedgerDimensionDueToAccountStructureChange(taxWorkTrans.TaxOffsetUseTaxLedgerDimension);

        //<GEEPL>
        tmpTaxWorkTransLocal.TaxPeriodPaymentCode_PL            = taxWorkTrans.TaxPeriodPaymentCode_PL;
        tmpTaxWorkTransLocal.CustVendName_PL                    = taxWorkTrans.CustVendName_PL;
        tmpTaxWorkTransLocal.VatDueDate_W                       = taxWorkTrans.VatDueDate_W;
        tmpTaxWorkTransLocal.DocumentDate_PL                    = taxWorkTrans.DocumentDate_PL;
        tmpTaxWorkTransLocal.vatNum_PL                          = taxWorkTrans.vatNum_PL;
        tmpTaxWorkTransLocal.Addressing_PL                      = taxWorkTrans.Addressing_PL;
        tmpTaxWorkTransLocal.TaxPeriodPaymentCode_PL            = taxWorkTrans.TaxPeriodPaymentCode_PL;
        //</GEEPL>
        this.recalcWithFactor(tmpTaxWorkTransLocal, _factor);
        // <GIN>
        if (isIndiaCountryRegionEnabled )
        {
            tmpTaxWorkTransLocal.TaxRegistrationNumberTable_IN  = taxWorkTrans.TaxRegistratioNnumberTable_IN;
            tmpTaxWorkTransLocal.CustomsDuty_IN                 = taxWorkTrans.CustomsDuty_IN * _factor;
        }
        // </GIN>

        tmpTaxWorkTransLocal.OriginalTaxTrans                   = taxWorkTrans.OriginalTaxTrans;
        tmpTaxWorkTransLocal.TaxId                              = taxWorkTrans.TaxId;
        tmpTaxWorkTransLocal.PartyTaxId                         = taxWorkTrans.PartyTaxId;
        tmpTaxWorkTransLocal.ISVFeatureSetupGuid                = taxWorkTrans.ISVFeatureSetupGuid;
        tmpTaxWorkTransLocal.ISVFeatureSetupName                = taxWorkTrans.ISVFeatureSetupName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildTaxInsertAndCalcQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds query object for <c>TaxTrans</c> record.
    /// </summary>
    /// <param name = "_parameters">The buffer of <c>TaxReverseTaxParameters</c>.</param>
    /// <returns>Query object for <c>TaxTrans</c> record.</returns>
    [Replaceable]
    public Query buildTaxInsertAndCalcQuery(TaxReverseTaxParameters _parameters)
    {
        Query query = new Query();
        QueryBuildDataSource qbds = query.addDataSource(tableNum(TaxTrans));

        if (_parameters.originalVoucher != '')
        {
            qbds.addRange(fieldNum(TaxTrans, Voucher)).value(strfmt(
                '(%1.%2 == "%3")',
                qbds.name(),
                fieldstr(TaxTrans, Voucher),
                queryValue(_parameters.originalVoucher)));
        }
        else
        {
            qbds.addRange(fieldNum(TaxTrans, Voucher)).value(strfmt(
                '(%1.%2 == %3)',
                qbds.name(),
                fieldstr(TaxTrans, Voucher),
                queryValue(_parameters.originalVoucher)));
        }
        
        qbds.addRange(fieldNum(TaxTrans, TransDate)).value(strfmt(
            '(%1.%2 == %3)',
            qbds.name(),
            fieldstr(TaxTrans, TransDate),
            date2StrXpp(_parameters.originalTransDate)));

        if (_parameters.custVendTransPostingLogRecId_RU)
        {
            qbds.addRange(fieldNum(TaxTrans, ExemptTax)).value(strfmt(
            '((%1.%2 == %3) ||((%1.%2 == %4) && (%8) && ((%1.%5 == %6)||(%1.%5 == %7))))',
            qbds.name(),
            fieldstr(TaxTrans, ExemptTax),
            any2Int(NoYes::No),
            any2Int(NoYes::Yes),
            fieldstr(TaxTrans, TaxDirection),
            any2Int(TaxDirection::TaxExemptPurchase),
            any2Int(TaxDirection::TaxExemptSales),
            any2Int(_parameters.allowExemptTax_RU)));
        }
        else
        {
            qbds.addRange(fieldNum(TaxTrans, ExemptTax)).value(strfmt(
            '((%1.%2 == %3) ||((%1.%2 == %4) && ((%1.%5 == %6)||(%1.%5 == %7))))',
            qbds.name(),
            fieldstr(TaxTrans, ExemptTax),
            any2Int(NoYes::No),
            any2Int(NoYes::Yes),
            fieldstr(TaxTrans, TaxDirection),
            any2Int(TaxDirection::TaxExemptPurchase),
            any2Int(TaxDirection::TaxExemptSales)));
        }

        qbds.addRange(fieldNum(TaxTrans, TaxDirection)).value(strfmt(
            '(%2 || ((%3 - %1.%4) == %1.%5) || (%1.%6 == %7))',
            qbds.name(),
            any2Int(!_parameters.sourceAmountCurSet),
            queryValue(_parameters.sourceAmountCur),
            fieldstr(TaxTrans, SourceTaxAmountCur),
            fieldstr(TaxTrans, SourceBaseAmountCur),
            fieldstr(TaxTrans, TaxDirection),
            any2Int(TaxDirection::UseTax)));

        qbds.addRange(fieldNum(TaxTrans, TaxOrigin)).value(strfmt(
            '((%1.%2 == %3) || (%1.%2 == %4))',
            qbds.name(),
            fieldstr(TaxTrans, TaxOrigin),
            any2int(TaxOrigin::CashDisc),
            any2int(_parameters.reverseTaxOrigin)));

        qbds.addRange(fieldNum(TaxTrans, SourceTableId)).value(strfmt(
            '((%2 == %3) || ((%1.%4 == %5) && (%1.%6 == %7)))',
            qbds.name(),
            queryValue(_parameters.restrictionSourceRecId),
            queryValue(0),
            fieldstr(TaxTrans, SourceTableId),
            queryValue(_parameters.restrictionSourceTableId),
            fieldstr(TaxTrans, SourceRecId),
            queryValue(_parameters.restrictionSourceRecId)));

        if(_parameters.reverseTaxJournalId != '')
        {
            qbds.addRange(fieldNum(TaxTrans, JournalNum)).value(strfmt(
                '(("%2" == "")||(%1.%3 == "%2"))',
                qbds.name(),
                queryValue(_parameters.reverseTaxJournalId),
                fieldstr(TaxTrans, JournalNum)));
        }
        else
        {
            qbds.addRange(fieldNum(TaxTrans, JournalNum)).value(strfmt(
                '((%2 == "")||(%1.%3 == %2))',
                qbds.name(),
                queryValue(_parameters.reverseTaxJournalId),
                fieldstr(TaxTrans, JournalNum)));
        }

        if (_parameters.custVendTransPostingLogRecId_RU)
        {
            QueryBuildDataSource taxTrans_RU_Qbds = qbds.addDataSource(tableNum(TaxTrans_RU));
            taxTrans_RU_Qbds.joinMode(JoinMode::InnerJoin);
            taxTrans_RU_Qbds.addLink(fieldNum(TaxTrans, RecId), fieldNum(TaxTrans_RU, TaxTrans), qbds.name());
            taxTrans_RU_Qbds.addRange(fieldNum(TaxTrans_RU, CustVendTransPostingLog_RU)).value(strFmt(
                '(%1.%2 == %3)',
                taxTrans_RU_Qbds.name(),
                fieldstr(TaxTrans_RU, CustVendTransPostingLog_RU),
                queryValue(_parameters.custVendTransPostingLogRecId_RU)));
        }

        return query;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>