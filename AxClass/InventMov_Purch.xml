<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventMov_Purch</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>InventMov_Purch</c> class is used as a data carrier together with the <c>InventUpdate</c>
///    class when the inventory is updated with purchase line transactions.
/// </summary>
/// <remarks>
///    This class is used when creating or making changes to a purchase order line.
/// </remarks>
public class InventMov_Purch extends InventMovement
{
    PurchLine       purchLine;

    boolean         physicalTaxCalculated;
    AmountMST       physicalSumTaxMst;

    RecId           purchParmSubLineRecId;
    Map             mapCanInventTransBeFinancialUpdated;
    AssetParameters assetParameters;
    InventDimId     intercompanyInventDimId;
    boolean         searchedForintercompanyInventDimId;
    
    [SysObsolete('Deprecated field. Please use InventMovement.parminventBlockingStatusSyncInventDim method instead.', false, 03\11\2023)]
    InventDim       inventBlockingInventStatusSyncInventDim;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>accountBalanceSheet</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountBalanceSheet()
    {
        if (! cacheAccountBalanceSheet)
        {
            cacheAccountBalanceSheet = purchLine.ledgerDimensionReceipt();
        }

        return cacheAccountBalanceSheet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountCharge</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountCharge()
    {
        return this.accountItem(InventAccountType::PurchCharge);
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a posting account for the current purchase order line.
    /// </summary>
    /// <param name="_inventAccountType">
    ///    The posting account type.
    /// </param>
    /// <returns>
    ///    The posting account number for the account type for the current purchase order line.
    /// </returns>
    protected LedgerDimensionDefaultAccount accountItem(InventAccountType _inventAccountType)
    {
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            return InventPosting::accountItemLedgerDimensionFromParameters(this.buildAccountItemLedgerDimensionParameter(_inventAccountType, this.inventdim()));
        }
        // </GEERU>
        return InventPosting::accountItemLedgerDimensionFromParameters(this.buildAccountItemLedgerDimensionParameter(_inventAccountType));
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildAccountItemLedgerDimensionParameter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a parameter for searching an inventory posting account ledger dimension for an item.
    /// </summary>
    /// <param name = "_inventAccountType">An inventory account type.</param>
    /// <param name = "_inventDim">An inventory dimension.</param>
    /// <returns>The built parameter instance.</returns>
    protected InventPostingAccountItemLedgerDimensionParameters buildAccountItemLedgerDimensionParameter(InventAccountType _inventAccountType, InventDim _inventDim = null)
    {
        return InventPostingAccountItemLedgerDimensionParameters::newFromParameters(
            _inventAccountType,
            purchLine.ItemId,
            this.itemGroupId(),
            purchLine.ProcurementCategory,
            purchLine.VendAccount,
            purchLine.VendGroup,
            purchLine.TaxGroup,
            _inventDim);
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountItemExtendParm_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a posting account for the current purchase order line with site.
    /// </summary>
    /// <param name="_inventAccountType">
    /// The posting account type.
    /// </param>
    /// <returns>
    /// The posting account number for the account type for the current purchase order line.
    /// </returns>
    protected LedgerDimensionDefaultAccount accountItemExtendParm_CN(InventAccountType _inventAccountType)
    {
        return InventPosting::accountItemExtendParmFromParameter_CN(
            InventPostingAccountItemLedgerDimensionParameters::newFromPurchLine(
                purchLine,
                _inventAccountType,
                this.inventTable().itemGroupId(),
                null,
                InventPostingExtendParm_CN::constructInventDim(purchLine.inventDim()).parmInventSiteId()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountOperations</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountOperations()
    {
        if (! cacheAccountOperations)
        {
            cacheAccountOperations = purchLine.ledgerDimensionConsumption();
        }

        return cacheAccountOperations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountOperationsAutoLossProfit</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountOperationsAutoLossProfit(InventQty _qty)
    {
        if (this.projId() && !purchLine.existsItemReqForPO())
        {
            return ProjPosting::getInventLedgerDimension(ProjAccountType::CostAccount,
                this.projId(),
                this.projCategoryId());
        }

        return super(_qty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountPhysical</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountPhysical()
    {
        if (! cacheAccountPhysical)
        {
            // <GCN>
            if (InventPostingExtendParm_CN::checkExtendParmEnabled())
            {
                cacheAccountPhysical = this.accountItemExtendParm_CN(InventAccountType::PurchPackingSlip);
            }
            else
            {
            // </GCN>
                cacheAccountPhysical = this.accountItem(InventAccountType::PurchPackingSlip);
            // <GCN>
            }
            // </GCN>
        }

        return cacheAccountPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountPhysicalTax</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountPhysicalTax()
    {
        return this.accountItem(InventAccountType::PurchPackingSlipTax);
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountStdLoss</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountStdLoss()
    {
        // <GCN>
        if (InventPostingExtendParm_CN::checkExtendParmEnabled())
        {
            return this.accountItemExtendParm_CN(InventAccountType::PurchStdLoss);
        }
        else
        {
        // </GCN>
            return this.accountItem(InventAccountType::PurchStdLoss);
        // <GCN>
        }
        // </GCN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountStdOffset</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountStdOffset()
    {
        // <GCN>
        if (InventPostingExtendParm_CN::checkExtendParmEnabled())
        {
            return this.accountItemExtendParm_CN(InventAccountType::PurchStdOffsetAccount);
        }
        else
        {
        // </GCN>
            return this.accountItem(InventAccountType::PurchStdOffsetAccount);
        // <GCN>
        }
        // </GCN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountStdProfit</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountStdProfit()
    {
        // <GCN>
        if (InventPostingExtendParm_CN::checkExtendParmEnabled())
        {
            return this.accountItemExtendParm_CN(InventAccountType::PurchStdProfit);
        }
        else
        {
        // </GCN>
            return this.accountItem(InventAccountType::PurchStdProfit);
        // <GCN>
        }
        // </GCN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountStockVariation</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount accountStockVariation()
    {
        return this.accountItem(InventAccountType::PurchStockVariation);
    }

]]></Source>
			</Method>
			<Method>
				<Name>activityNumber</Name>
				<Source><![CDATA[
    public ProjActivityNumber activityNumber()
    {
        return purchLine.ActivityNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRemainFinancialUnit</Name>
				<Source><![CDATA[
    public void addRemainFinancialUnit(
        UnitQty         _qtyUnit,
        InventQty       _qty)
    {
        purchLine.RemainInventFinancial += _qty;
        if (purchLine.RemainInventFinancial)
        {
            purchLine.RemainPurchFinancial+= _qtyUnit;
        }
        else
        {
            purchLine.RemainPurchFinancial = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRemainPhysical</Name>
				<Source><![CDATA[
    public void addRemainPhysical(InventQty  _inventQty)
    {
        // RemainInventPhysical should only be updated for inventoried items
        if (purchLine.isStocked())
        {
            purchLine.RemainInventPhysical += _inventQty;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRemainPhysicalUnit</Name>
				<Source><![CDATA[
    public void addRemainPhysicalUnit(UnitQty _qtyUnit)
    {
        purchLine.RemainPurchPhysical += _qtyUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetBookId</Name>
				<Source><![CDATA[
    public AssetBookId assetBookId()
    {
        return purchLine.AssetBookId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetId</Name>
				<Source><![CDATA[
    public AssetId assetId()
    {
        return purchLine.AssetId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>autoLossProfitInventMovVirtuel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates an <c>InventMov_Virtuel</c> object for an inventory transaction that is to be financially updated.
    /// </summary>
    /// <param name="_financial">
    /// The source <c>InventUpd_Financial</c> object
    /// </param>
    /// <param name="_inventTrans">
    /// The source inventory transaction buffer.
    /// </param>
    /// <param name="_inventTransId">
    /// The inventory transaction that is to be financially updated.
    /// </param>
    /// <returns>
    /// A <c>InventMov_Virtuel</c> object.
    /// </returns>
    protected InventMov_Virtuel autoLossProfitInventMovVirtuel(InventUpd_Financial _financial, InventTrans _inventTrans, InventTransId _inventTransId)
    {
        InventMov_Virtuel ret = super(_financial, _inventTrans, _inventTransId);

        if (this.projId() &&
            this.transQtyUnit() > 0 &&
            this.mustBeQuarantineControlled() &&
            !this.inventModelGroup().NegativePhysical)
        {
            ret.parmMustBeDeducted(true);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateIndirectCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the indirect cost related to the movement.
    /// </summary>
    /// <param name="_ledgerVoucher">
    ///    The ledger voucher object where the ledger transactions are added.
    /// </param>
    /// <param name="_physical">
    ///    The quantity that is physically updated.
    /// </param>
    /// <param name="_inputAmount">
    ///    The input amount.
    /// </param>
    /// <remarks>
    ///    The indirect cost must be calculated when the movement is physically updated.
    /// </remarks>
    public void calculateIndirectCost(LedgerVoucher _ledgerVoucher, Qty _physical, InventCostInputAmount _inputAmount)
    {
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) &&
            InventProfile_RU::find(this.inventdim().InventProfileId_RU).LockCostAdjustment)
        {
            inventCostIndirectPhysical = InventCostIndirectPhysical::newNoIndirectCost();
        }
        else
        {
        // </GEERU>
            inventCostIndirectPhysical = InventCostIndirectPhysical::newCalculation(_ledgerVoucher, this, _physical, _inputAmount);
        // <GEERU>
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeAutoRepAsFinished</Name>
				<Source><![CDATA[
    public boolean canBeAutoRepAsFinished()
    {
        boolean     ret = !purchLine.Scrap && super();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInventTransBeFinancialUpdated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the current <c>InventTrans</c> record can be updated.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The <c>InventTrans</c> record that is to be updated.
    /// </param>
    /// <returns>
    ///    true if the current <c>InventTrans</c> record can be updated; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    <c>InventTrans</c> records that have <c>TransType</c> set to <c>Purch</c>, <c>StatusReceipt</c> set
    ///    to <c>Received</c>, or <c>StatusIssue</c> set to <c>Deducted</c> will be skipped if they are
    ///    associated with a packing slip line that is matched to another unposted invoice line.
    /// </remarks>
    public boolean canInventTransBeFinancialUpdated(InventTrans _inventTrans)
    {
        boolean canUpdate = true;

        if (this.parmPurchParmSubLineRecId() == 0 &&
            (_inventTrans.StatusReceipt == StatusReceipt::Received || _inventTrans.StatusIssue == StatusIssue::Deducted))
        {
            if (mapCanInventTransBeFinancialUpdated.exists(_inventTrans.VoucherPhysical))
            {
                // If the result has been cached, use it
                canUpdate = mapCanInventTransBeFinancialUpdated.lookup(_inventTrans.VoucherPhysical);
            }
            else
            {
                // Skip InventTrans records that are associated with a packing slip line that is matched to another unposted invoice line.
                canUpdate = ! VendPackingSlipJour::unpostedInvoicesExist(_inventTrans);

                // Cache result for future use
                mapCanInventTransBeFinancialUpdated.insert(_inventTrans.VoucherPhysical, canUpdate);
            }
        }

        return canUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInventTransBeUpdatedRegistered</Name>
				<Source><![CDATA[
    internal boolean canInventTransBeUpdatedRegistered(InventTrans _inventTrans)
    {
        if (!WHSInventTransRegistrationUpdateCheckFlight::instance().isEnabled()
            || !WHSParameters::isReceivingCompletedEnabledForPOLoads()
            || !_inventTrans.LoadId)
        {
            return super(_inventTrans);
        }

        WHSLoadTable load = WHSLoadTable::find(_inventTrans.LoadId);

        if (load.LoadReceivingCompletedUTCDateTime)
        {
            return checkFailed(strFmt("@WAX:CannotUpdateRegisteredInventTransOnReceivedLoad",
                this.transId(),
                _inventTrans.LoadId,
                _inventTrans.ItemId,
                this.transRefId()));
        }

        return super(_inventTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUserCreateAssetAcquisition</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the user can create an asset acquisition transaction.
    /// </summary>
    /// <returns>
    ///    true if the user can create an asset acquisition transaction; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    A user can create an asset acquisition if the following criteria are met:
    ///    <list type="bullet">
    ///       <item>
    ///          <description>
    ///             The <c>AssetAllowAcqPostingPO</c> value of the <c>AssetParamters</c> table is set to true.
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>The user is a member of a group that can post asset transactions.</description>
    ///       </item>
    ///    </list>
    /// </remarks>
    protected boolean canUserCreateAssetAcquisition()
    {
        if (! assetParameters)
        {
            assetParameters = AssetParameters::find();
        }

        boolean ret = assetParameters.AssetAllowAcqPostingPO;
        if (ret)
        {
            SysGroup assetGroupPostPO = assetParameters.AssetUserGroupIdPostPO;
            if (assetGroupPostPO)
            {
                ret = UserInfoHelp::userInUserGroup(curUserId(), assetGroupPostPO);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDimInventOwnerId_RU</Name>
				<Source><![CDATA[
    public boolean checkDimInventOwnerId_RU(InventDim _inventDim, boolean _showError = true)
    {
        boolean        ret = super(_inventDim, _showError);

        if (this.inventDimGroupSetup().isDimensionActive(fieldNum(InventDim, InventOwnerId_RU)) &&
            _inventDim.InventOwnerId_RU &&
            _inventDim.inventProfile_RU().InventOwnerIdCheckPurchOrder)
        {
            PurchTable purchTable = purchLine.purchTable();
            InventOwner_RU inventOwner = InventOwner_RU::findAccountNum(InventOwnerAccountType_RU::Vend,
                                                                        purchTable.OrderAccount,
                                                                        purchTable.purchTable_RU().AgreementHeaderExt_RU);

            if (inventOwner && inventOwner.InventOwnerId != _inventDim.InventOwnerId_RU)
            {
                ret = _showError ? checkFailed(strFmt("@GLS115707", fieldId2pname(tableNum(InventDim), fieldNum(InventDim, InventOwnerId_RU)))) : false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDimPhysical</Name>
				<Source><![CDATA[
    boolean checkDimPhysical(
        InventQty   _qty,
        InventDim   _inventDim,
        boolean     _finalCheck,
        boolean     _showError = true
        )
    {
        boolean ok = super(_qty, _inventDim, _finalCheck, _showError);

        if (ok && _finalCheck && this.inventDimGroupSetup().isDimensionActive(fieldNum(InventDim, InventOwnerId_RU)))
        {
            PurchTable purchTableLoc = purchLine.purchTable();

            if (_inventDim.inventProfile_RU().InventOwnerIdCheckPurchOrder &&
                ! InventOwner_RU::checkPurchOrder(_inventDim.InventOwnerId_RU, purchTableLoc))
            {
                ok = checkFailed(strFmt("@GLS115658",
                                        _inventDim.InventOwnerId_RU,
                                        purchTableLoc.OrderAccount,
                                        AgreementHeaderExt_RU::find(purchTableLoc.purchTable_RU().AgreementHeaderExt_RU).AgreementId,
                                        fieldId2pname(tableNum(InventDim), fieldNum(InventDim, InventOwnerId_RU))));
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateEstimated</Name>
				<Source><![CDATA[
    public boolean checkUpdateEstimated(
        InventUpd_Estimated     _updateNow,
        InventMovement          _this_Orig)
    {
        boolean ret = true;

        if (_this_Orig && abs(this.transQty())  <  abs(_this_Orig.transQty()) && this.transQty() * _this_Orig.transQty() >= 0 )
        {
            if (_this_Orig.remainPhysicalUnit() == 0 && _this_Orig.remainFinancialUnit() == 0)
            {
                ret = checkFailed("@SYS25508");
            }
        }

        if (ret)
        {
            // For inventoried lines the physical and financial quantities should match.
            if (purchLine.isStocked())
            {
                ret = super(_updateNow, _this_Orig);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateFinancial</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates whether the inventory movement can be financially updated.
    /// </summary>
    /// <param name="_updateNow">
    ///    An instance of the <c>InventUpd_Financial</c> class that contains the current financial inventory update.
    /// </param>
    /// <returns>
    ///    true if the inventory movement is valid; otherwise, false.
    /// </returns>
    public boolean checkUpdateFinancial(InventUpd_Financial _updateNow)
    {
        boolean             ret = true;
        VendInvoiceInfoLine vendInvoiceInfoLine;

        if (isConfigurationkeyEnabled(configurationKeyNum(Project))
            && _updateNow.parmFinancialUnit()   == 0)
        {
            select firstonly RecId from vendInvoiceInfoLine
                where   vendInvoiceInfoLine.PurchLineRecId == purchLine.RecId
                &&      vendInvoiceInfoLine.psaReleaseAmount
                &&      !vendInvoiceInfoLine.ReceiveNow;

            if (!vendInvoiceInfoLine)
            {
                ret = false;
            }
        }
        else
        {
            ret = super(_updateNow);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdatePhysical</Name>
				<Source><![CDATA[
    public boolean checkUpdatePhysical(InventUpd_Physical _updateNow)
    {
        boolean ok = true;

        if (this.transQtyUnit() == 0)
        {
            ok = checkFailed("@SYS12170");
        }

        if (purchLine.Complete && abs(this.transQtyUnit()) != abs(_updateNow.parmPhysicalUnit()))
        {
            ok = checkFailed("@SYS25384");
        }

        if (!purchLine.checkUpdatePhysical())
        {
            ok = false;
        }

        if (! super(_updateNow))
        {
            ok = false;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOriginOwnerRelationship</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the relationship between the inventory transactions originator and the owner.
    /// </summary>
    public void createOriginOwnerRelationship()
    {
        InventTransOriginId originId = this.inventTransOriginId();

        if (originId && purchLine.RecId)
        {
            InventTransOriginPurchLine::writeOriginOwnerRelationship(purchLine.DataAreaId, purchLine.InventTransId, originId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendAc</Name>
				<Source><![CDATA[
    public CustVendAC custVendAc()
    {
        return purchLine.VendAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteOriginOwnerRelationship</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the relationship between the inventory transactions originator and the owner that
    ///    corresponds.
    /// </summary>
    public void deleteOriginOwnerRelationship()
    {
        if (purchLine.RecId)
        {
            InventTransOriginPurchLine::deleteOwnerRelationship(purchLine.DataAreaId, purchLine.InventTransId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deliveryPostalAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Identifies the postal delivery address of the purchase order line.
    /// </summary>
    /// <returns>
    /// An ID of a <c>LogisticsPostalAddress</c> record; otherwise, 0.
    /// </returns>
    /// <remarks>
    /// This method is only used for shipping deliveries when returning items.
    /// </remarks>
    protected LogisticsPostalAddressRecId deliveryPostalAddress()
    {
        return purchLine.DeliveryPostalAddress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dirParty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the party ID of the vendor that is related to the movement.
    /// </summary>
    /// <returns>
    ///    The party ID of the vendor related to the movement.
    /// </returns>
    /// <remarks>
    ///    This method returns zero if there is no vendor related to the movement.
    /// </remarks>
    public DirPartyRecId dirParty()
    {
        CustVendAC     account = this.custVendAc();

        if (!account)
        {
            return 0;
        }

        return VendTable::find(account).Party;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsAdjustIntercompanyRemainInventoryQty</Name>
				<Source><![CDATA[
    public void pdsAdjustIntercompanyRemainInventoryQty()
    {
        if (purchLine.InterCompanyInventTransId)
        {
            SalesLine salesLine;

            changecompany(purchLine.purchTable().InterCompanyCompanyId)
            {
                salesLine = SalesLine::findInventTransId(purchLine.InterCompanyInventTransId,true);
            }
                
            if (salesLine.RecId && salesLine.RemainInventPhysical == 0 && salesLine.RemainInventFinancial == purchLine.RemainInventFinancial
                    && this.interCompanyMovement() && this.pdsCWItem() && purchLine.PdsCWRemainInventPhysical == 0 && purchLine.RemainInventPhysical != 0)
            {
                this.pdsAdjustInventoryQuantity(-purchLine.RemainInventPhysical);
                this.updateBuffer(this.parmAutoReserveWhenAdjustingCatchWeight());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>enteredPcsPrice</Name>
				<Source><![CDATA[
    protected PriceCur enteredPcsPrice()
    {
        return purchLine.PurchPrice / (purchLine.PriceUnit ? purchLine.PriceUnit : 1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimatedPhysicalTax</Name>
				<Source><![CDATA[
    public AmountMST estimatedPhysicalTax(InventTrans _inventTrans)
    {
        AmountCur   amountCur = 0;
        AmountMST   amountMST = 0;

        PurchTable  purchTable = purchLine.purchTable();

        if (!this.mustBeBookedPhysicalTax())
        {
            return 0;
        }

        if (!purchLine.QtyOrdered)
        {
            return 0;
        }

        if (!physicalTaxCalculated)
        {
            if (purchTable.InclTax)
            {
                amountCur = purchLine.LineAmount - purchLine.lineAmountExclTax(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
            }
            else
            {
                amountCur = Tax::calcTaxAmount(purchLine.TaxGroup,
                                               purchLine.TaxItemGroup,
                                               DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
                                               purchLine.CurrencyCode,
                                               purchLine.LineAmount,
                                               purchTable.taxModuleType(),
                                               purchLine.PurchQty,
                                               purchLine.PurchUnit,
                                               purchLine.ItemId,
                                               TaxDirection::IncomingTax,
                                               purchLine.gsthstTaxType_CA);
            }

            if (amountCur)
            {
                amountMST = CurrencyExchangeHelper::mstAmount(amountCur, purchLine.CurrencyCode);
            }

            physicalSumTaxMst       = amountMST;
            physicalTaxCalculated   = true;
        }

        return CurrencyExchangeHelper::amount(physicalSumTaxMst * _inventTrans.Qty / purchLine.QtyOrdered);
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimatedPhysicalValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the estimated physical value for an inventory transaction.
    /// </summary>
    /// <param name="_inventTrans">
    /// The <c>inventTrans</c> record for which to get the estimated physical value.
    /// </param>
    /// <param name="_inventOnhand">
    /// The <c>InventOnHand</c> object.
    /// </param>
    /// <param name="_updateNow">
    /// The <c>InventUpdate</c> object.
    /// </param>
    /// <returns>
    /// The estimated physical value for the inventory transaction.
    /// </returns>
    public CostAmount estimatedPhysicalValue(
        InventTrans         _inventTrans,
        InventOnhand        _inventOnhand,
        InventUpdate        _updateNow)
    {
        CostAmount  costAmount;
        InventUpd_Physical update = _updateNow;

        if (((_inventTrans.Qty >= 0 && purchLine.QtyOrdered > 0 )
             && ! this.inventModelGroup().StandardCost)
            || this.inventModelType().stdCostBased())
        {
            costAmount = update.parmCostInputAmount().getAmount(_inventTrans.Qty);
            costAmount += this.inventCostIndirectPhysical().update(_inventTrans);
        }
        else
        {
            costAmount = super(_inventTrans,_inventOnhand, _updateNow);
        }

        return costAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimatedPhysicalValueSecCur_RU</Name>
				<Source><![CDATA[
    public CostAmountSecCur_RU estimatedPhysicalValueSecCur_RU(
        InventTrans     _inventTrans,
        InventOnhand    _inventOnhand,
        InventUpdate    _updateNow)
    {
        CostAmount  costAmount;
        InventUpd_Physical update = _updateNow as InventUpd_Physical;

        if (((_inventTrans.Qty >= 0 && purchLine.QtyOrdered > 0 && !this.inventModelGroup().StandardCost) || this.inventModelType().stdCostBased()) && update && update.parmCostInputAmountSecCur_RU())
        {
            costAmount = update.parmCostInputAmountSecCur_RU().getAmount(_inventTrans.Qty);
        }
        else
        {
            costAmount = super(_inventTrans, _inventOnhand, _updateNow);
        }

        costAmount += CurrencyExchangeHelper::amountMST2MSTSecond_RU(this.inventCostIndirectPhysical().costAmount_RU(), _inventTrans.DatePhysical);

        return costAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFixedAssetIssueDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the inventDim for the fixed asset issue transaction based on WHS PO put-away work.
    /// </summary>
    /// <param name="_inventTransReceipt">
    /// The receipt <c>InventTrans</c> receipt record.
    /// </param>
    /// <returns>
    /// The inventDim to be used for the fixed asset issue transaction.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Wrong use of function.
    /// </exception>
    protected InventDim findFixedAssetIssueDimensions(InventTrans _inventTransReceipt)
    {
        WHSWorkLine         firstPickLine;
        WHSWorkTable        workTable;
        WHSDimTracking      dimTracking;
        WHSWorkInventTrans  workInventTrans;

        WHSWorkLine         putWorkLine;
        InventDim           joinInventDim;
        WHSWorkTrans        workTrans;

        if (_inventTransReceipt.RecId           == 0
        ||  _inventTransReceipt.StatusReceipt   != StatusReceipt::Purchased)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        ttsbegin;

        InventTransId inventTransId  = InventTransOrigin::find(_inventTransReceipt.InventTransOrigin).InventTransId;
        InventDim     transInventDim = _inventTransReceipt.inventDim();
        InventDimParm inventDimParm  = WHSReservationHierarchyInventDimUtil::initInventDimParmAboveLocation(this.inventTable());

        select firstonly RecId, WorkId from firstPickLine
            where firstPickLine.InventTransId       == inventTransId
                && firstPickLine.WorkType           == WHSWorkType::Pick
                && firstPickLine.wmsLocationId      == transInventDim.wmsLocationId
            exists join dimTracking
                where dimTracking.WorkId                == firstPickLine.WorkId
                    && dimTracking.InventTransIdParent  == firstPickLine.InventTransId
                    && dimTracking.InventDimId          == _inventTransReceipt.InventDimId
            exists join WorkTable
                where workTable.workId == firstPickLine.WorkId
                    && workTable.InventLocationId == transInventDim.InventLocationId;

        if (firstPickLine.RecId == 0)
        {
            select firstonly WorkId from firstPickLine
                where firstPickLine.InventTransId           == inventTransId
                    && firstPickLine.WorkType               == WHSWorkType::Pick
                    && firstPickLine.wmsLocationId          == transInventDim.wmsLocationId
                exists join workInventTrans
                    where workInventTrans.WorkId                == firstPickLine.WorkId
                        && workInventTrans.InventTransIdParent  == firstPickLine.InventTransId
                        && workInventTrans.InventDimIdFrom      == _inventTransReceipt.InventDimId
                exists join WorkTable
                    where workTable.workId == firstPickLine.WorkId
                        && workTable.InventLocationId == transInventDim.InventLocationId;
        }

        select firstonly wmsLocationId, WorkId, LineNum from putWorkLine
            order by LineNum desc
            where putWorkLine.WorkId    == firstPickLine.WorkId
            &&    putWorkLine.WorkType  == WHSWorkType::Put
            exists join workInventTrans
            where workInventTrans.WorkId    == putWorkLine.WorkId
            &&    workInventTrans.LineNum   == putWorkLine.LineNum
            #InventDimExistsJoin(workInventTrans.InventDimIdFrom, joinInventDim, transInventDim, inventDimParm);

        if (putWorkLine.wmsLocationId)
        {
            transInventDim.wmsLocationId = putWorkLine.wmsLocationId;
            if (transInventDim.wmsLocation().whsLocationIsLPControlled())
            {
                select firstonly InventDimId, TargetLicensePlateId from workTrans
                    where workTrans.WorkId  == putWorkLine.WorkId
                    &&    workTrans.LineNum == putWorkLine.LineNum;

                if (WHSPopulateSourceAndTargetLPOnWHSWorkTransFeature::instance().isEnabled()
                    || WHSConsumeTargetLPFromWHSWorkTransFlight::instance().isEnabled())
                {
                    transInventDim.LicensePlateId = workTrans.TargetLicensePlateId;
                }
                else
                {
                    transInventDim.LicensePlateId = workTrans.inventDim().LicensePlateId;
                }
            }
            else
            {
                transInventDim.LicensePlateId = '';
            }

            transInventDim = InventDim::findOrCreate(transInventDim);
        }

        ttscommit;

        return transInventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyMarkingAllowed</Name>
				<Source><![CDATA[
    public boolean interCompanyMarkingAllowed()
    {
        return TradeInterCompany::markingAllowed(purchLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyMovement</Name>
				<Source><![CDATA[
    public boolean interCompanyMovement()
    {
        if (purchLine.ItemRefType == InventRefType::Sales
        &&  purchLine.InventRefTransId
        &&  purchLine.InterCompanyInventTransId)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyTransaction</Name>
				<Source><![CDATA[
    public boolean interCompanyTransaction()
    {
        if (purchLine.purchTable().InterCompanyOrder
        &&  purchLine.InterCompanyInventTransId
        &&  purchLine.RecId)
        {
            return true;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventCostIndirectFinancial</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves an <c>InventCostIndirectFinancial</c> object.
    /// </summary>
    /// <returns>
    /// An <c>InventCostIndirectFinancial</c> object.
    /// </returns>
    /// <remarks>
    /// The <c>InventCostIndirectFinancial</c> object is used to update the indirect cost that is related
    /// to an inventory transaction.
    /// </remarks>
    public InventCostIndirectFinancial inventCostIndirectFinancial()
    {
        LedgerPostingType               postingTypeIndirectCostFinancial;
        LedgerDimensionDefaultAccount   ledgerDimensionIndirectCostFinancial;

        if (!inventCostIndirectFinancial)
        {
            // <GEERU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) &&
                InventProfile_RU::find(this.inventdim().InventProfileId_RU).LockCostAdjustment)
            {
                inventCostIndirectFinancial = InventCostIndirectFinancial::construct(false);
            }
            else
            {
            // </GEERU>
                if (this.mustBeBookedCharge())
                {
                    postingTypeIndirectCostFinancial = this.postingStockVariation();
                    ledgerDimensionIndirectCostFinancial = this.accountStockVariation();
                }
                else
                {
                    postingTypeIndirectCostFinancial = this.postingOperations();
                    ledgerDimensionIndirectCostFinancial = this.accountOperations();
                }

                inventCostIndirectFinancial = InventCostIndirectFinancial::construct(true,
                        postingTypeIndirectCostFinancial,
                        LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimensionIndirectCostFinancial, this.defaultDimension())
                        // <GEERU>
                        , this.parmStornoPhysical_RU()
                        // </GEERU>
                        );
            // <GEERU>
            }
            // </GEERU>
        }
        return inventCostIndirectFinancial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimId</Name>
				<Source><![CDATA[
    public InventDimId inventDimId()
    {
        if (this.searchForIntercompanyInventDimId())
        {
            if (inventTransRecId)
            {
                intercompanyInventDimId = InterCompanyTransferInventDim::findInterCompanyDimTransferred(inventTransRecId);
            }
            else
            {
                intercompanyInventDimId = InterCompanyTransferInventDim::findRelatedIntercompanyDimTransferred(purchLine.InventTransId);
            }
            searchedForintercompanyInventDimId = true;
        }
        return intercompanyInventDimId ? intercompanyInventDimId : purchLine.InventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransOriginId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the ID of the inventory transaction originator that corresponds to the movement.
    /// </summary>
    /// <param name="_inventTransOriginId">
    ///    The new value of the ID of the inventory transaction originator.
    /// </param>
    /// <returns>
    ///    The ID of the inventory transaction originator that corresponds to the movement.
    /// </returns>
    public InventTransOriginId inventTransOriginId(InventTransOriginId _inventTransOriginId = inventTransOriginId)
    {
        if (_inventTransOriginId != inventTransOriginId)
        {
            inventTransOriginId = _inventTransOriginId;
        }
        else
        {
            if (!inventTransOriginId)
            {
                inventTransOriginId = InventTransOriginPurchLine::findInventTransOriginId(purchLine.DataAreaId, purchLine.InventTransId);
            }
        }

        return inventTransOriginId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReturned</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether this movement represents a return.
    /// </summary>
    /// <param name="_qty">
    ///    The movement quantity.
    /// </param>
    /// <returns>
    ///    true if the movement represents a return; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Adds special handling for the case when the quantity is zero; otherwise, the super method gives the
    ///    result.
    /// </remarks>
    public boolean isReturned(InventQty _qty)
    {
        if (_qty == 0 && purchLine.PurchaseType == PurchaseType::ReturnItem)
        { // with zero quantity it isn't clear to the super method whether it is a return or not.
            return true;
        }

        boolean ret = super(_qty);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemId</Name>
				<Source><![CDATA[
    public ItemId  itemId()
    {
        return purchLine.ItemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markingRefInventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the ID of the marked transaction origin.
    /// </summary>
    /// <returns>
    ///    zero if the whole movement is not marked; otherwise, the ID of the transaction origin.
    /// </returns>
    public InventTransOriginId markingRefInventTransOrigin()
    {
        InventTransOriginId markedInventTransOriginId;

        if (this.projId() && !purchLine.existsItemReqForPO())
        {
            if (this.parmPackingSlipId() && this.parmReturnMode())
            {
                ProjProductReceiptCancellationMarkingUpdateContext context = ProjProductReceiptCancellationMarkingUpdateContext::current();
                if (context && context.parmRefInventTransOrigin())
                {
                    markedInventTransOriginId = context.parmRefInventTransOrigin();
                    context.parmRefInventTransOrigin(0);

                    return markedInventTransOriginId;
                }

                InventTrans inventTrans;
                select firstonly MarkingRefInventTransOrigin from inventTrans
                    where inventTrans.InventTransOrigin == this.inventTransOriginId()
                    && inventTrans.PackingSlipId == this.parmPackingSlipId()
                    && inventTrans.ItemId == purchLine.ItemId
                    && inventTrans.MarkingRefInventTransOrigin
                    && inventTrans.ValueOpen == InventTransOpen::Yes;

                markedInventTransOriginId = inventTrans.MarkingRefInventTransOrigin;
            }
            else
            {
                markedInventTransOriginId = InventTransOrigin::findMarkingRefInventTransOrigin(this.inventTransOriginId(), purchLine.ItemId, true, true);
            }
        }
        else
        {
            markedInventTransOriginId = InventTransOrigin::findByInventTransId(purchLine.InventRefTransId).RecId;
        }

        return markedInventTransOriginId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>moduleType</Name>
				<Source><![CDATA[
    protected ModuleInventPurchSales moduleType()
    {
        return ModuleInventPurchSales::Purch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeBookedCharge</Name>
				<Source><![CDATA[
    public boolean mustBeBookedCharge()
    {
        return purchLine.isStocked()
            && this.inventModelGroup().PostOnhandFinancial
            && VendParameters::find().PostChargeAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeBookedOperations</Name>
				<Source><![CDATA[
    public boolean mustBeBookedOperations()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeBookedPhysically</Name>
				<Source><![CDATA[
    public boolean  mustBeBookedPhysically()
    {
        if (this.inventModelType().mustAlwaysBeBookedPhysically() || VendParameters::find().PostPackingSlip)
        {
            return super();
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeCostControlled</Name>
				<Source><![CDATA[
    public boolean mustBeCostControlled()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeDeducted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the model group that is associated with the current <c>InventMovement</c> object
    ///    requires a mandatory deduct.
    /// </summary>
    /// <returns>
    ///    A Boolean value that indicates whether the model group that is associated with the current
    ///    <c>InventMovement</c> object requires a mandatory deduct.
    /// </returns>
    public boolean mustBeDeducted()
    {
        return this.inventModelGroup().MandatoryDeduct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeReceived</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the model group that is associated with the current <c>InventMovement</c> object
    ///    requires a mandatory receive.
    /// </summary>
    /// <returns>
    ///    A Boolean value that indicates whether the model group that is associated with the current
    ///    <c>InventMovement</c> object requires a mandatory receive.
    /// </returns>
    public boolean mustBeReceived()
    {
        if (this.projId() &&
            this.transQtyUnit() > 0 &&
            this.mustDoAutoLossProfitFinancial() &&
            this.mustBeQuarantineControlled() &&
            !this.inventModelGroup().NegativePhysical)
        {
            return true;
        }

        return this.inventModelGroup().MandatoryReceive;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeRegistered</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the transactions that are related to this movement must be registered.
    /// </summary>
    /// <returns>
    ///    true if transactions must be registered; otherwise, false.
    /// </returns>
    public boolean mustBeRegistered()
    {
        if (purchLine.isDropShipment())
        {
            return false;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeRemainControlled</Name>
				<Source><![CDATA[
    public boolean  mustBeRemainControlled()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeUnitControlled</Name>
				<Source><![CDATA[
    public boolean  mustBeUnitControlled()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeQuarantineControlled</Name>
				<Source><![CDATA[
    public boolean mustBeQuarantineControlled()
    {
        boolean ret = super();

        return ret && this.mustCreateQuarantineOrder();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckOverDelivery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the current <c>InventMovement</c> object requires checking for over delivery.
    /// </summary>
    /// <param name="_direction">
    /// The <c>InventDirection</c> value of the update that is being made.
    /// </param>
    /// <returns>
    /// true if over delivery must be checked; otherwise, false.
    /// </returns>
    public NoYes mustCheckOverDelivery(InventDirection _direction)
    {
        InventQty   qty;
        switch (_direction)
        {
            case InventDirection::Issue:
                qty = -1;
                break;
            case InventDirection::Receipt:
                qty = 1;
                break;
            case InventDirection::None:
                qty = 0;
                break;
        }

        if (this.transQty() * qty <= 0)
        {
            return NoYes::No;
        }

        return NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreateQuarantineOrder</Name>
				<Source><![CDATA[
    public boolean mustCreateQuarantineOrder()
    {
        boolean     ret         = super();

        if (ret)
        {
            switch (purchLine.ItemRefType)
            {
                case InventRefType::Sales:
                    // When PurchLine has reference to SalesLine with Direct delivery, quarantine order must not be created
                    SalesLine salesLine = SalesLine::findInventTransId(purchLine.InventRefTransId);
                    if (salesLine.isDropShipment())
                    {
                        ret = false;
                    }
                    break;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDoAutoLossProfitEstimate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the <c>updateAutoLossProfit</c> method must be called to update the inventory
    ///    marking and reservations.
    /// </summary>
    /// <returns>
    ///    true if the <c>updateAutoLossProfit</c> method must be called; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method is called to update inventory reservations.
    /// </remarks>
    public boolean mustDoAutoLossProfitEstimate()
    {
        // If it is a project purchase order and not linked with solid movement yet or
        // If it is a project purchase order and linked with solid movement and if the current operation
        // is cancelling the quantity then the related marked invent trans must be estimated.
        if (this.projId()
            && !purchLine.existsItemReqForPO()
            && (purchLine.isCanceled()
                || !(select firstonly inventTransOrigin where inventTransOrigin.RecId == this.markingRefInventTransOrigin()
                                                    && inventTransOrigin.ReferenceId !='').RecId))
        {
            return true;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDoAutoLossProfitFinancial</Name>
				<Source><![CDATA[
    public boolean mustDoAutoLossProfitFinancial()
    {
        if (this.assetId())
        {
            return true;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDoAutoLossProfitPhysical</Name>
				<Source><![CDATA[
    public boolean mustDoAutoLossProfitPhysical()
    {
        boolean mustDoAutoLossProfitPhysical = super();

        if (mustDoAutoLossProfitPhysical &&
            this.projId() &&
            this.transQtyUnit() > 0 &&
            this.mustBeQuarantineControlled() &&
            !this.inventModelGroup().NegativePhysical &&
            !((InventQuarantineOrder::findInventTransIdRef(purchLine.InventTransId).Status == InventQuarantineStatus::Ended) &&
            this.parmReturnMode()))
        {
            mustDoAutoLossProfitPhysical = false;
        }

        return mustDoAutoLossProfitPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDoProjPosting</Name>
				<Source><![CDATA[
    public boolean mustDoProjPosting()
    {
        return ((this.projId() && !purchLine.existsItemReqForPO()) ? true : false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSetProjAdjRefInventTrans</Name>
				<Source><![CDATA[
    public boolean mustSetProjAdjRefInventTrans()
    {
        return ((this.projId() && !purchLine.existsItemReqForPO()) ? true : super());
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateBatchAttribValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the movement should update the batch attributes on the related quality orders.
    /// </summary>
    /// <returns>
    /// true if attributes should be updated; otherwise, false .
    /// </returns>
    public boolean mustUpdateBatchAttribValues()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateVoucherMatched</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether we can update the voucher matched parameter.
    /// </summary>
    /// <returns>
    /// True when we are cancelling or correcting the posted quantity for a project purchase order
    /// that is linked with a quarantine order with End status.
    /// </returns>
    public boolean mustUpdateVoucherMatched()
    {
        boolean     ret;

        if (this.projId() &&
            this.mustBeQuarantineControlled() &&
            InventQuarantineOrder::findInventTransIdRef(purchLine.InventTransId).Status == InventQuarantineStatus::Ended &&
            this.parmReturnMode())
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new(
        PurchLine   _purchLine,
        InventType  _inventType = PurchLineType::construct(_purchLine))
    {
        purchLine = _purchLine;

        mapCanInventTransBeFinancialUpdated = new Map(Types::String, Types::Enum);

        super(purchLine, _inventType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newMovement_Orig</Name>
				<Source><![CDATA[
    public InventMovement newMovement_Orig()
    {
        PurchLine purchLineApproved = purchLine.findApproved();

        if (!purchLineApproved)
        {
            return null;
        }
        return InventMov_Purch::newFromPurchLine(purchLineApproved);
    }

]]></Source>
			</Method>
			<Method>
				<Name>offsetAccountPhysical</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount offsetAccountPhysical()
    {
        if (! cacheOffsetAccountPhysical)
        {
            cacheOffsetAccountPhysical = this.accountItem(InventAccountType::PurchPackingSlipOffsetAccount);
        }

        return cacheOffsetAccountPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>overDeliveryPct</Name>
				<Source><![CDATA[
    public Percent overDeliveryPct()
    {
        if (!PurchParameters::find().OverDelivery)
        {
            return 0;
        }

        return purchLine.OverDeliveryPct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPurchParmSubLineRecId</Name>
				<Source><![CDATA[
    public RecId parmPurchParmSubLineRecId(RecId _purchParmSubLineRecId = purchParmSubLineRecId)
    {
        purchParmSubLineRecId = _purchParmSubLineRecId;
        return purchParmSubLineRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCountryOfOrigin1</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>PdsVendBatchInfo</c> record first country/region of origin.
    /// </summary>
    /// <returns>
    /// The country/region identifier for the country/region of origin.
    /// </returns>
    public PdsCountryOfOrigin pdsCountryOfOrigin1()
    {
        return purchLine.pdsVendBatchInfo().CountryOfOrigin1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCountryOfOrigin2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>PdsVendBatchInfo</c> record second country/region of origin.
    /// </summary>
    /// <returns>
    /// The country/region identifier for the country/region of origin.
    /// </returns>
    public PdsCountryOfOrigin pdsCountryOfOrigin2()
    {
        return purchLine.pdsVendBatchInfo().CountryOfOrigin2;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWAddRemainFinancial</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method adds CW remain financial
    /// </summary>
    /// <param name="_qty">
    /// CW quantity to add to remain financial
    /// </param>
    public void pdsCWAddRemainFinancial(PdsCWInventQty _qty)
    {
        if (this.mustBeUnitControlled()
            && this.mustBeRemainControlled())
        {
            purchLine.PdsCWRemainInventFinancial += _qty;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWAddRemainPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method adds CW remain physical
    /// </summary>
    /// <param name="_qty">
    /// CW quantity to add to remain physical
    /// </param>
    public void pdsCWAddRemainPhysical(PdsCWInventQty _qty)
    {
        // PdsCWRemainInventPhysical should only be updated for inventoried items
        if (purchLine.isStocked())
        {
            purchLine.PdsCWRemainInventPhysical += _qty;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWRemainPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method returns CW remain physical
    /// </summary>
    /// <returns>
    /// returns CW quantity
    /// </returns>
    public PdsCWInventQty  pdsCWRemainPhysical()
    {
        return purchLine.PdsCWRemainInventPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWSetRemainPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method set CW remain physical
    /// </summary>
    /// <param name="_qty">
    /// CW quantity to set remain physical
    /// </param>
    public void pdsCWSetRemainPhysical(PdsCWInventQty _qty)
    {
        // PdsCWRemainInventPhysical should only be updated for inventoried items
        if (purchLine.isStocked())
        {
            purchLine.PdsCWRemainInventPhysical = _qty;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWSetTransQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method sets CW transaction quantity
    /// </summary>
    /// <param name="_qty">
    /// CW quantity
    /// </param>
    public void pdsCWSetTransQty(PdsCWInventQty _qty)
    {
        // PdsCWQty should only be updated for inventoried items
        if (purchLine.isStocked())
        {
            purchLine.PdsCWQty = _qty;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWTransQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method returns CW transaction quantity.
    /// </summary>
    /// <returns>
    /// returns CW quantity
    /// </returns>
    public PdsCWInventQty  pdsCWTransQty()
    {
        return purchLine.PdsCWQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsUseVendBatchDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the <c>PdsVendBatchInfo</c> record related uses the vendor's batch date.
    /// </summary>
    /// <returns>
    /// True, if vendor batch date is to be used; otherwise false.e
    /// </returns>
    public PdsUseVendBatchDate pdsUseVendBatchDate()
    {
        return purchLine.pdsVendBatchInfo().UseVendBatchDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsUseVendBatchExp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the <c>PdsVendBatchInfo</c> record related uses the vendor's expiration date.
    /// </summary>
    /// <returns>
    /// True, if vendor expiration date is to be used; otherwise false.
    /// </returns>
    public PdsUseVendBatchExp pdsUseVendBatchExp()
    {
        return purchLine.pdsVendBatchInfo().UseVendBatchExp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsVendBatchDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>PdsVendBatchInfo</c> record vendor's batch date.
    /// </summary>
    /// <returns>
    /// The vendor's batch date, if specified.
    /// </returns>
    public PdsVendBatchDate pdsVendBatchDate()
    {
        return purchLine.pdsVendBatchInfo().VendBatchDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsVendBatchId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>PdsVendBatchInfo</c> record vendor's batch number.
    /// </summary>
    /// <returns>
    /// The vendor's batch number, if specified.
    /// </returns>
    public PdsVendBatchId pdsVendBatchId()
    {
        return purchLine.pdsVendBatchInfo().VendBatchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsVendBatchInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the vendor batch details associated with this transaction;
    /// </summary>
    /// <returns>
    /// The buffer of the <c>PdsVendBatchInfo</c> table.
    /// </returns>
    public PdsVendBatchInfo pdsVendBatchInfo()
    {
        return purchLine.pdsVendBatchInfo();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsVendExpiryDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>PdsVendBatchInfo</c> record vendor's batch expiration date.
    /// </summary>
    /// <returns>
    /// The vendor's expiration date, if specified.
    /// </returns>
    public PdsVendExpiryDate pdsVendExpiryDate()
    {
        return purchLine.pdsVendBatchInfo().VendExpiryDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingBalanceSheet</Name>
				<Source><![CDATA[
    public LedgerPostingType postingBalanceSheet()
    {
        return LedgerPostingType::PurchReceipt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingBalanceSheetSecCur_RU</Name>
				<Source><![CDATA[
    private LedgerPostingType postingBalanceSheetSecCur_RU()
    {
        return LedgerPostingType::PurchReceipt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingCharge</Name>
				<Source><![CDATA[
    public LedgerPostingType postingCharge()
    {
        return LedgerPostingType::PurchCharge;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingOffsetPhysical</Name>
				<Source><![CDATA[
    public LedgerPostingType postingOffsetPhysical()
    {
        return LedgerPostingType::PurchOffsetAccountPckSlp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingOperations</Name>
				<Source><![CDATA[
    public LedgerPostingType postingOperations()
    {
        if (purchLine.isStocked())
        {
            return LedgerPostingType::PurchConsump;
        }
        else if (purchLine.hasAssetAssociated())
        {
            return LedgerPostingType::FixedAssetsDebit;
        }
        return LedgerPostingType::PurchExpense;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingPhysical</Name>
				<Source><![CDATA[
    public LedgerPostingType postingPhysical()
    {
        return LedgerPostingType::PurchPckSlp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingPhysicalTax</Name>
				<Source><![CDATA[
    public LedgerPostingType postingPhysicalTax()
    {
        return LedgerPostingType::PurchPckSlpTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingStdLoss</Name>
				<Source><![CDATA[
    public LedgerPostingType postingStdLoss()
    {
        return LedgerPostingType::PurchStdLoss;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingStdOffset</Name>
				<Source><![CDATA[
    public LedgerPostingType postingStdOffset()
    {
        return LedgerPostingType::PurchStdOffsetAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingStdProfit</Name>
				<Source><![CDATA[
    public LedgerPostingType postingStdProfit()
    {
        return LedgerPostingType::PurchStdProfit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingStockVariation</Name>
				<Source><![CDATA[
    public LedgerPostingType postingStockVariation()
    {
        return LedgerPostingType::PurchStockVariation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projCategoryId</Name>
				<Source><![CDATA[
    public ProjCategoryId projCategoryId()
    {
        return purchLine.ProjCategoryId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projId</Name>
				<Source><![CDATA[
    public ProjId projId()
    {
        return purchLine.ProjId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projLedgerOrigin</Name>
				<Source><![CDATA[
    public ProjLedgerOrigin projLedgerOrigin()
    {
        if (this.projId() && !purchLine.existsItemReqForPO())
        {
            return ProjOrigin::PurchaseOrder;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>projLinePropertyId</Name>
				<Source><![CDATA[
    public ProjLinePropertyId projLinePropertyId()
    {
        return purchLine.ProjLinePropertyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projSalesCurrencyId</Name>
				<Source><![CDATA[
    public ProjSalesCurrencyCode projSalesCurrencyId()
    {
        return purchLine.ProjSalesCurrencyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projSalesQty</Name>
				<Source><![CDATA[
    internal Qty projSalesQty(Qty _qty = 0)
    {
       
        if (purchLine.PurchUnit != purchLine.ProjSalesUnitId)
        {
            EcoResProductUnitConverter unitConverter = EcoResProductUnitConverter::newGivenUnitSymbolsForReleasedProduct(purchLine.ItemId,
                                                                                                                        purchLine.InventDimId,
                                                                                                                        purchLine.PurchUnit,
                                                                                                                        purchLine.ProjSalesUnitId,
                                                                                                                        NoYes::Yes);
            if (unitConverter.canValueBeConverted())
            {
                _qty = unitConverter.convertValue(_qty);
            }
        }
        return _qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projSalesPrice</Name>
				<Source><![CDATA[
    public ProjSalesPriceCost projSalesPrice()
    {
        SalesLine salesLine;

        ProjTable projTable = ProjTable::find(this.projId());
        if (!projTable)
        {
            return 0;
        }

        // Initialize salesLine from project data
        salesLine.initFromProjTable(projTable);
        salesLine.CustAccount = projTable.CustAccount;
        salesLine.CustGroup = CustTable::find(projTable.CustAccount).CustGroup;

        // Initialize salesLine for line amount calculation including discounts, trade agreements, etc.
        salesLine.ItemId = this.itemId();
        salesLine.SalesQty = purchLine.PurchQty;
        salesLine.initFromInventTable(this.inventTable());

        // Initialize salesLine's values that can be changed on project tab of transaction line
        salesLine.SalesUnit = purchLine.ProjSalesUnitId;
        salesLine.CurrencyCode = purchLine.ProjSalesCurrencyId;
        salesLine.SalesPrice = purchLine.ProjSalesPrice;
        salesLine.PriceUnit = purchLine.PriceUnit;

        // Recalculate the line amount using new values from the project
        // Divide by the salesLine.SalesQty, because this method should return price per item
        return salesLine.calcLineAmountForced()/(salesLine.SalesQty ? salesLine.SalesQty : 1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTaxGroupId</Name>
				<Source><![CDATA[
    public ProjTaxGroup projTaxGroupId()
    {
        return purchLine.ProjTaxGroupId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTaxItemGroupId</Name>
				<Source><![CDATA[
    public ProjTaxItemGroup projTaxItemGroupId()
    {
        return purchLine.ProjTaxItemGroupId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTransactionOrigin</Name>
				<Source><![CDATA[
    public ProjTransactionOrigin projTransactionOrigin()
    {
        if (this.projId() && !purchLine.existsItemReqForPO())
        {
            return ProjOrigin::PurchaseOrder;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTransId</Name>
				<Source><![CDATA[
    public ProjTransIdBase projTransId()
    {
        return purchLine.ProjTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainFinancialUnit</Name>
				<Source><![CDATA[
    public UnitQty     remainFinancialUnit()
    {
        return purchLine.RemainPurchFinancial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainPhysical</Name>
				<Source><![CDATA[
    public InventQty   remainPhysical()
    {
        return purchLine.RemainInventPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainPhysicalUnit</Name>
				<Source><![CDATA[
    public UnitQty      remainPhysicalUnit()
    {
        return purchLine.RemainPurchPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchForIntercompanyInventDimId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether to search for transferred <c>InventDimId</c> for intercompany purchase lines.
    /// </summary>
    /// <returns>
    /// true if search for transferred <c>InventDimId</c> for intercompany purchase lines should be performed; otherwise, false.
    /// </returns>
    protected boolean searchForIntercompanyInventDimId()
    {
        return (this.interCompanyMovement()
            && !searchedForintercompanyInventDimId
            && purchLine.PurchQty        > 0
            && purchLine.OverDeliveryPct > 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventDimId</Name>
				<Source><![CDATA[
    public void setInventDimId(InventDimId _dimId)
    {
        purchLine.setInventDimId(_dimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventRefFields</Name>
				<Source><![CDATA[
    public boolean setInventRefFields(
        InventRefType           _inventRefType,
        InventRefId             _inventRefId,
        InventTransOriginId     _markingRefInventTransOrigin)
    {
        purchLine.ItemRefType         = _inventRefType;
        purchLine.InventRefId         = _inventRefId;
        purchLine.InventRefTransId    = InventTransOrigin::find(_markingRefInventTransOrigin).InventTransId;
        if (purchLine.ProjId && purchLine.InventRefTransId)
        {
            this.setProjRefFields(SalesLine::findInventTransId(purchLine.InventRefTransId));
        }

        if (_inventRefType == InventRefType::None && purchLine.isDropShipment())
        {
            // when deleting related drop shipment, then line is no longer a direct delivery
            purchLine.DeliveryType = TradeLineDlvType::None;
            purchLine.MCRDropShipment = NoYes::No;
            purchLine.MCRDropShipStatus = MCRDropShipStatus::None;
            purchLine.MCRDropShipComment = '';
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setProjRefFields</Name>
				<Source><![CDATA[
    public void setProjRefFields(SalesLine _salesLine)
    {
        if (_salesLine)
        {
            purchLine.ProjId                = _salesLine.ProjId;
            purchLine.ProjCategoryId        = _salesLine.ProjCategoryId;
            purchLine.ProjLinePropertyId    = _salesLine.ProjLinePropertyId;
            purchLine.ProjTransId           = _salesLine.ProjTransId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRemainPhysical</Name>
				<Source><![CDATA[
    public void setRemainPhysical(InventQty  _inventQty)
    {
        // RemainInventPhysical should only be updated for inventoried items
        if (purchLine.isStocked())
        {
            purchLine.RemainInventPhysical = _inventQty;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRemainPhysicalUnit</Name>
				<Source><![CDATA[
    public void setRemainPhysicalUnit(UnitQty     _qtyUnit)
    {
        purchLine.RemainPurchPhysical = _qtyUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransQty</Name>
				<Source><![CDATA[
    public void setTransQty(InventQty  _qtyInvent)
    {
        // QtyOrdered should only be updated for inventoried items
        if (purchLine.isStocked())
        {
            purchLine.QtyOrdered = _qtyInvent;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransQtyUnit</Name>
				<Source><![CDATA[
    public void setTransQtyUnit(UnitQty  _qtyUnit)
    {
        purchLine.PurchQty = _qtyUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>subDeliveryPct</Name>
				<Source><![CDATA[
    protected Percent subDeliveryPct()
    {
        if (!PurchParameters::find().SubDelivery)
        {
            return 0;
        }

        return purchLine.UnderDeliveryPct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSyncInventoryBlockingStatusTransType</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean shouldSyncInventoryBlockingStatusTransType()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transDate</Name>
				<Source><![CDATA[
    public TransDate transDate()
    {
        return purchLine.ConfirmedDlv? purchLine.ConfirmedDlv : purchLine.DeliveryDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transId</Name>
				<Source><![CDATA[
    public InventTransId transId()
    {
        return purchLine.InventTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transInventRefType</Name>
				<Source><![CDATA[
    public InventRefType transInventRefType()
    {
        return InventRefType::Purch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transQty</Name>
				<Source><![CDATA[
    public InventQty  transQty()
    {
        // QtyOrdered should only be used for inventoried items.
        if (purchLine.isStocked())
        {
            return purchLine.QtyOrdered;
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transQtyUnit</Name>
				<Source><![CDATA[
    public UnitQty      transQtyUnit()
    {
        return purchLine.PurchQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transRefId</Name>
				<Source><![CDATA[
    public InventTransRefId transRefId()
    {
        return purchLine.PurchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transSign</Name>
				<Source><![CDATA[
    public Integer transSign()
    {
        return 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transType</Name>
				<Source><![CDATA[
    public InventTransType transType()
    {
        return InventTransType::Purch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transUnitId</Name>
				<Source><![CDATA[
    public UnitOfMeasureSymbol transUnitId()
    {
        return purchLine.PurchUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAutoDimOwnerId_RU</Name>
				<Source><![CDATA[
    public boolean updateAutoDimOwnerId_RU()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAutoLossProfit</Name>
				<Source><![CDATA[
    public void updateAutoLossProfit(InventUpd_Financial _financial)
    {
        InventMov_Virtuel       movement_Virtuel;
        InventTrans             inventTrans;
        InventTransOriginId     newInventTransOriginId;
        // <GBR>
        boolean                 postFixedAsset = !BrazilParameters::isEnabled() || purchLine.purchTable().createVendTrans_BR();
        // </GBR>
        InventDimParm           virtuelMarkingInventDimParmFixed;

        if ((!purchLine.AssetId) || (!this.canUserCreateAssetAcquisition()))

        {
            super(_financial);
            return;
        }
        
        // Do asset posting
        this.postFixedAsset(postFixedAsset, _financial);

        while select forupdate inventTrans
            where inventTrans.InventTransOrigin == this.inventTransOriginId()
              &&  inventTrans.DateFinancial     == _financial.parmLedgerVoucher().lastTransDate()
              &&  inventTrans.Voucher           == _financial.parmLedgerVoucher().lastVoucher()
              &&  inventTrans.InvoiceId         == _financial.parmInvoiceId()
              && (!_financial.parmPackingSlipId()   || inventTrans.PackingSlipId    == _financial.parmPackingSlipId())
              && (!_financial.parmVoucherPhysical() || inventTrans.VoucherPhysical  == _financial.parmVoucherPhysical())
              &&  inventTrans.Qty               != 0
        {
            // create virtuel movement (first time ->  without any newInventTransOriginId
            if (this.isItemWHSEnabled()
                && this.workLineExistsForInventTransId(inventTrans.inventTransOrigin().InventTransId))
            {
                // Since the inventory is moved by work during the receipt process, assets should attempt to remove inventory from the final put location of the work.
                movement_Virtuel = InventMov_Virtuel::newAutoLossAsset(_financial, inventTrans, newInventTransOriginId, this.findFixedAssetIssueDimensions(inventTrans).InventDimId);
                movement_Virtuel.inventDimGroupSetup().inventDimParmActiveFinancialInventory(virtuelMarkingInventDimParmFixed);
                virtuelMarkingInventDimParmFixed.setAllTrackingDimensions();
                movement_Virtuel.setMarkingInventDimParmFixed(virtuelMarkingInventDimParmFixed);
                movement_Virtuel.parmSkipReservationForMarkingCreation(true);
            }
            else
            {
                movement_Virtuel = InventMov_Virtuel::newAutoLossAsset(_financial, inventTrans, newInventTransOriginId);
            }

            InventUpd_Financial financial_Virtuel = this.constructInventUpdForUpdateAutoLossProfit(movement_Virtuel, _financial);
            financial_Virtuel.updateNow();

            // set newInventTransOriginId value  - re-use the existing inventTransOriginId for the current source document
            newInventTransOriginId = movement_Virtuel.inventTransOriginId();
        }

        this.createTransIdForAsset(postFixedAsset, newInventTransOriginId);

        super(_financial);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateCostAmountPosted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the amount for posting in company currency.
    /// </summary>
    /// <param name = "_financial">
    /// An <c>InventUpd_Financial</c> instance.
    /// </param>
    /// <returns>
    /// The posted amount.
    /// </returns>
    [Replaceable]
    protected AmountMST calculateCostAmountPosted(InventUpd_Financial _financial)
    {
        InventTrans inventTrans;

        return (select sum(CostAmountPosted) from inventTrans
                                   where inventTrans.InventTransOrigin == this.inventTransOriginId()
                                     &&  inventTrans.DateFinancial     == _financial.parmLedgerVoucher().lastTransDate()
                                     &&  inventTrans.Voucher           == _financial.parmLedgerVoucher().lastVoucher()
                                     &&  inventTrans.InvoiceId         == _financial.parmInvoiceId()
                                     && (!_financial.parmPackingSlipId()      || inventTrans.PackingSlipId    == _financial.parmPackingSlipId())
                                     && (!_financial.parmVoucherPhysical()    || inventTrans.VoucherPhysical  == _financial.parmVoucherPhysical())
                                     &&  inventTrans.Qty               != 0
                    ).CostAmountPosted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postFixedAsset</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes asset posting.
    /// </summary>
    /// <param name = "_postFixedAsset">
    /// Determines whether the asset should be posted.
    /// </param>
    /// <param name = "_financial">
    /// An <c>InventUpd_Financial</c> instance.
    /// </param>
    /// <param name = "_amountMST">
    /// Amount for posting in company currency.
    /// </param>
    protected void postFixedAsset(boolean _postFixedAsset, InventUpd_Financial _financial)
    {
        // <GBR>
        if (_postFixedAsset)
        {
            // </GBR>
            AmountMST amountMST = this.calculateCostAmountPosted(_financial);

            AssetPost assetPost = AssetPost::newInventMovement(_financial.parmLedgerVoucher(), this, _financial, amountMST);

            if (!this.validateAssetPost(assetPost))
            {
                throw error("@SYS21628");
            }

            assetPost.post(false);
            // <GBR>
        }
        // </GBR>
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAssetPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for valid conditions to post the asset.
    /// </summary>
    /// <param name = "_assetPost">
    /// An <c>AssetPost</c> instance.
    /// </param>
    /// <param name="budget">
    /// A Boolean value that specifies whether there is a budget; optional.
    /// </param>
    /// <param name="_checkNetBookValue">
    /// A Boolean value that specifies whether you want to check the net book value; optional.
    /// </param>
    /// <returns></returns>
    protected boolean validateAssetPost(AssetPost _assetPost, boolean _budget = false, boolean _checkNetBookValue = true)
    {
        return _assetPost.check(_budget, _checkNetBookValue);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransIdForAsset</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates inventory transaction for asset posting.
    /// </summary>
    /// <param name = "_postFixedAsset">
    /// Determines whether the asset should be posted.
    /// </param>
    /// <param name = "_newInventTransOriginId">
    /// The existing <c>InventTransOriginId</c> for the current source document.
    /// </param>
    protected void createTransIdForAsset(boolean _postFixedAsset, InventTransOriginId _newInventTransOriginId)
    {
        // <GBR>
        if (_postFixedAsset)
        {
            // </GBR>
            AssetInventTrans::createTransId(purchLine.AssetId, purchLine.AssetBookId, _newInventTransOriginId);
            // <GBR>
        }
        // </GBR>
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructInventUpdForUpdateAutoLossProfit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs and initializes an <c>InventUpd_Financial</c> instance.
    /// </summary>
    /// <param name = "_movement_Virtuel">An <c>InventMov_Virtuel</c> instance.</param>
    /// <param name = "_financial">An <c>InventUpd_Financial</c> instance.</param>
    /// <returns>An <c>InventUpd_Financial</c> instance.</returns>
    protected InventUpd_Financial constructInventUpdForUpdateAutoLossProfit(InventMov_Virtuel _movement_Virtuel, InventUpd_Financial _financial)
    {
        InventUpd_Financial financial_Virtuel = InventUpd_Financial::newAutoLossProfit(_movement_Virtuel, _financial);
        financial_Virtuel.parmExchangeRateDate(_financial.parmExchangeRateDate());

        return financial_Virtuel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBuffer</Name>
				<Source><![CDATA[
    public void updateBuffer(boolean _updateReservation = true)
    {
        Purchline purchLinOrig = purchLine.orig();
        InventUpd_Estimated estimated = this.updateInventoryOnUpdate();

        purchLine.doUpdate();
        
        boolean isCatchWeight = this.inventTable().pdsCWItem();

        if (purchLine.DeliveryType == TradeLineDlvType::DropShip
            && !this.parmReturnMode()
            && !purchLine.isInterCompanyOrder()
            && ((!isCatchWeight && purchLine.RemainInventPhysical > purchLinOrig.RemainInventPhysical)
                || (isCatchWeight && purchLine.PdsCWRemainInventPhysical > purchLinOrig.PdsCWRemainInventPhysical)
                || (!isCatchWeight && purchLine.RemainPurchPhysical > purchLinOrig.RemainPurchPhysical)))
        {
            SalesLine salesLine = purchLine.salesLine(true);

            if (salesLine.isStocked())
            {
                salesLine.RemainInventPhysical += purchLine.RemainInventPhysical - purchLinOrig.RemainInventPhysical;
                salesLine.PdsCWRemainInventPhysical += purchLine.PdsCWRemainInventPhysical - purchLinOrig.PdsCWRemainInventPhysical;
            }

            salesLine.RemainSalesPhysical += EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(purchLine.ItemId,
                                                                                                                   purchLine.InventDimId,
                                                                                                                   purchLine.RemainPurchPhysical - purchLinOrig.RemainPurchPhysical,
                                                                                                                   purchLine.PurchUnit,
                                                                                                                   salesLine.SalesUnit,
                                                                                                                   NoYes::Yes);
            salesLine.update();
            purchLine.reread();
        }

        if (estimated && _updateReservation)
        {
            estimated.updateReservation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventoryOnUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the inventory when a purchase line is updated.
    /// </summary>
    /// <returns>A new instance of the <c>InventUpd_Estimated</c> class.</returns>
    protected InventUpd_Estimated updateInventoryOnUpdate()
    {
        InventUpd_Estimated estimated = this.instantiateInventUpd_Estimated(InventMovSubType::None);
        if (estimated)
        {
            if (!estimated.movement().parmProjectReturnIssue())
            {
                estimated.movement().parmMustDoAutoLossProfitForbid(NoYes::Yes);
            }

            estimated.updateNow();
        } 

        return estimated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiateInventUpd_Estimated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates an instance of the <c>InventUpd_Estimated</c> class.
    /// </summary>
    /// <param name = "_inventMovSubType">An <c>InventMovSubType</c> value.</param>
    /// <returns>An <c>InventUpd_Estimated</c> instance.</returns>
    protected InventUpd_Estimated instantiateInventUpd_Estimated(InventMovSubType _inventMovSubType)
    {
        return InventUpd_Estimated::newInventMovement(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDoBuffer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the underlying buffer with the <c>doUpdate</c> method.
    /// </summary>
    /// <remarks>
    ///    When the <c>newMovement_Orig</c> method is expected to return the values that are being saved, it
    ///    uses values from the <c>PurchLineHistory</c> table. This table is updated with the current buffer
    ///    values.
    /// </remarks>
    public void updateDoBuffer()
    {
        Purchline purchLinOrig = purchLine.orig();
        PurchLineHistory    purchLineHistory;
        PurchLineType       purchLineType = inventType;

        super();

        if (purchLine.isInterCompanyOrder()
            && !this.parmReturnMode()
            && (purchLine.RemainInventPhysical > purchLinOrig.RemainInventPhysical
                || purchLine.PdsCWRemainInventPhysical > purchLinOrig.PdsCWRemainInventPhysical
                || purchLine.RemainPurchPhysical > purchLinOrig.RemainPurchPhysical))
        {
            SalesLine salesLine = purchLine.interCompanySalesLine(true);

            if (salesLine.QtyOrdered > 0)
            {
                if (salesLine.isStocked())
                {
                    changecompany(salesLine.DataAreaId)
                    {
                        if (salesLine.RemainInventPhysical || salesLine.PdsCWRemainInventPhysical)
                        {
                            salesLine.RemainInventPhysical += purchLine.RemainInventPhysical - purchLinOrig.RemainInventPhysical;
                            salesLine.PdsCWRemainInventPhysical += purchLine.PdsCWRemainInventPhysical - purchLinOrig.PdsCWRemainInventPhysical;
                        }
                        else
                        {
                            InventTrans         inventTrans;
                            InventTransOrigin   inventTransOrigin;
                    
                            select sum(Qty), sum(PdsCWQty) from inventTrans
                                where ((inventTrans.StatusReceipt    == StatusReceipt::Purchased
                                   && inventTrans.StatusIssue         == StatusIssue::None)
                                   || ((inventTrans.StatusIssue       == StatusIssue::Deducted
                                   || inventTrans.StatusIssue         == StatusIssue::Sold)
                                   && inventTrans.StatusReceipt       == StatusReceipt::None))
                                 exists join inventTransOrigin
                                     where inventTrans.InventTransOrigin    == inventTransOrigin.RecId
                                        && inventTransOrigin.InventTransId  == salesLine.InventTransId;
                            
                            InventQty purchRemainInventPhysicalInSalesUnit = purchLine.RemainInventPhysical;

                            UnitOfMeasureSymbol fromInventTransUnit;
                            changecompany(purchLine.DataAreaId)
                            {
                                fromInventTransUnit = InventTableModule::find(purchLine.ItemId, ModuleInventPurchSales::Invent).UnitId;
                            }

                            UnitOfMeasureSymbol toInventTransUnit = InventTableModule::find(salesLine.ItemId, ModuleInventPurchSales::Invent).UnitId;
                           
                            if (fromInventTransUnit != toInventTransUnit)
                            {
                                EcoResProductUnitConverter unitConverter = EcoResProductUnitConverter::newGivenUnitSymbolsForReleasedProduct(purchLine.ItemId,
                                                                                                                        purchLine.InventDimId,
                                                                                                                        fromInventTransUnit,
                                                                                                                        toInventTransUnit,
                                                                                                                        NoYes::Yes);
                                if (unitConverter.canValueBeConverted())
                                {
                                    purchRemainInventPhysicalInSalesUnit = unitConverter.convertValue(purchLine.RemainInventPhysical);
                                }
                            }

                            salesLine.RemainInventPhysical = purchRemainInventPhysicalInSalesUnit + inventTrans.Qty;
                            salesLine.PdsCWRemainInventPhysical = purchLine.PdsCWRemainInventPhysical + inventTrans.PdsCWQty;
                                                     
                            if (salesLine.RemainInventPhysical < 0 || salesLine.PdsCWRemainInventPhysical < 0)
                            {
                                salesLine.RemainInventPhysical = 0;
                                salesLine.PdsCWRemainInventPhysical = 0;
                            }
                        }
      
                        salesLine.RemainSalesPhysical = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(purchLine.ItemId,
                                                                                                                       purchLine.InventDimId,
                                                                                                                       salesLine.RemainInventPhysical,
                                                                                                                       InventTableModule::find(salesLine.ItemId, ModuleInventPurchSales::Invent).UnitId,
                                                                                                                       salesLine.SalesUnit,
                                                                                                                       NoYes::Yes);
                        salesLine.update();
                    }
                }

                purchLine.reread();
            }
        }

        if (purchLineType.isChangeRequestRequired()
            && purchLine.purchTable().DocumentState != VersioningDocumentState::Draft
            && PurchTableVersion::findLatest(purchLine.PurchId, purchLine.DataAreaId).IsArchived == NoYes::Yes)
        {
            purchLineHistory.validTimeStateUpdateMode(ValidTimeStateUpdate::Correction);

            // updating the Remain* fields on PurchLineHistory records to calculate the correct new estimated inventory movements
            update_recordset purchLineHistory
                setting RemainPurchPhysical         = purchLine.RemainPurchPhysical,
                        RemainPurchFinancial        = purchLine.RemainPurchFinancial,
                        RemainInventPhysical        = purchLine.RemainInventPhysical,
                        RemainInventFinancial       = purchLine.RemainInventFinancial,
                        PdsCWRemainInventPhysical   = purchline.PdsCWRemainInventPhysical,
                        PdsCWRemainInventFinancial  = purchline.PdsCWRemainInventFinancial
                where purchLineHistory.PurchId          == purchLine.PurchId
                   && purchLineHistory.InventTransId    == purchLine.InventTransId
                   && purchLineHistory.ValidTo          == DateTimeUtil::maxValue();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerAdjust</Name>
				<Source><![CDATA[
    public void updateLedgerAdjust(
        LedgerVoucher           _ledgerVoucher,
        InventUpd_Financial     _updateNow,
        CostAmount              _costAmount,
        ProjAdjustRefId         _projAdjustRefId = '',
        ProjTransDate           _projTransDate  = dateNull())
    {
        LedgerVoucherTransObject    ledgerVoucherTransObject;
        // <GEERU>
        LedgerBondClient_RU         ledgerBondClient;
        boolean                     correct;
        CostAmount                  costAmount;
        boolean                     countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        if (this.mustBeBookedFinancially())
        {
            if (!this.checkInventSiteDimension(this.inventdim()))
            {
                throw error("@SYS18447");
            }

            if (!_costAmount)
            {
                return;
            }

            LedgerVoucherObject ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();
            CurrencyExchangeHelper currencyExchHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());
            // <GEERU>
            if (countryRegion_RU)
            {
                ledgerBondClient = ledgerVoucherObject.ledgerBondClient_RU();
                correct          = ledgerVoucherObject.parmCorrection();
                costAmount       = _costAmount - this.parmIndirectCostAmount_RU();

                if (InventParameters::find().StornoAdjPosting && this.correctionSwapOnItem_RU(costAmount))
                {
                    correct = !correct;
                }

                if (ledgerBondClient)
                {
                    ledgerBondClient.addNewLogObject();
                }
            }
            // </GEERU>

            if (this.mustBeBookedBalanceSheet())
            {
                // <GEERU>
                if (countryRegion_RU &&
                    correct != ledgerVoucherObject.parmCorrection())
                {
                    if (this.parmIndirectCostAmount_RU())
                    {
                        _ledgerVoucher.addTrans(
                            LedgerVoucherTransObject::newTransactionAmountDefault(
                                ledgerVoucherObject,
                                this.postingBalanceSheet(),
                                LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountBalanceSheet(), this.defaultDimension()),
                                CompanyInfoHelper::standardCurrency(),
                                this.parmIndirectCostAmount_RU(),
                                currencyExchHelper));

                        _ledgerVoucher.addTrans(
                            LedgerVoucherTransObject::newTransactionAmountDefault(
                                ledgerVoucherObject,
                                this.postingOperations(),
                                LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountOperations(), this.defaultDimension()),
                                CompanyInfoHelper::standardCurrency(),
                                -this.parmIndirectCostAmount_RU(),
                                currencyExchHelper));
                    }

                    if (costAmount)
                    {
                        ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                ledgerVoucherObject,
                                this.postingBalanceSheet(),
                                LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountBalanceSheet(), this.defaultDimension()),
                                CompanyInfoHelper::standardCurrency(),
                                costAmount,
                                currencyExchHelper);
                        ledgerVoucherTransObject.parmCorrect(correct);
                        _ledgerVoucher.addTrans(ledgerVoucherTransObject);

                        ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                ledgerVoucherObject,
                                this.postingOperations(),
                                LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountOperations(), this.defaultDimension()),
                                CompanyInfoHelper::standardCurrency(),
                                -costAmount,
                                currencyExchHelper);
                        ledgerVoucherTransObject.parmCorrect(correct);
                        _ledgerVoucher.addTrans(ledgerVoucherTransObject);
                    }
                }
                else
                {
                // </GEERU>

                    ledgerVoucherTransObject = InventoryReportingCurrencyTriangulationHelper::createLedgerVoucherTransObject(
                                ledgerVoucherObject,
                                this.postingBalanceSheet(),
                                LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountBalanceSheet(), this.defaultDimension()),
                                CompanyInfoHelper::standardCurrency(),
                                _costAmount,
                                currencyExchHelper);

                    _ledgerVoucher.addTrans(ledgerVoucherTransObject);

                    ledgerVoucherTransObject = InventoryReportingCurrencyTriangulationHelper::createLedgerVoucherTransObject(
                                ledgerVoucherObject,
                                this.postingOperations(),
                                LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountOperations(), this.defaultDimension()),
                                CompanyInfoHelper::standardCurrency(),
                                -_costAmount,
                                currencyExchHelper);

                    _ledgerVoucher.addTrans(ledgerVoucherTransObject);

                // <GEERU>
                }
                // </GEERU>

                if (this.mustBeBookedCharge())
                {
                    _ledgerVoucher.addTrans(
                        LedgerVoucherTransObject::newTransactionAmountDefault(
                            ledgerVoucherObject,
                            this.postingOperations(),
                            LedgerDimensionFacade::serviceCreateLedgerDimension(
                                this.accountOperations(),
                                this.defaultDimension()),
                            CompanyInfoHelper::standardCurrency(),
                            _costAmount,
                            currencyExchHelper));

                    _ledgerVoucher.addTrans(
                        LedgerVoucherTransObject::newTransactionAmountDefault(
                            ledgerVoucherObject,
                            this.postingStockVariation(),
                            LedgerDimensionFacade::serviceCreateLedgerDimension(
                                this.accountStockVariation(),
                                this.defaultDimension()),
                            CompanyInfoHelper::standardCurrency(),
                            -_costAmount,
                            currencyExchHelper));
                }

                _updateNow.updCostAmountLedger(_updateNow.updCostAmountLedger() + _costAmount);
            }
            else if (this.mustBeBookedOperations())
            {
                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                ledgerVoucherObject,
                                                this.postingOperations(),
                                                LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountOperations(), this.defaultDimension()),
                                                CompanyInfoHelper::standardCurrency(),
                                                -_costAmount,
                                                currencyExchHelper);
                ledgerVoucherTransObject.parmProjLedger(ProjLedger::newInventCost(
                                                            this.projId(),
                                                            this.activityNumber(),
                                                            this.projCategoryId(),
                                                            this.transId(),
                                                            _projAdjustRefId,
                                                            this.projTransactionOrigin(),
                                                            this.projLedgerOrigin(),
                                                            this.itemId(),
                                                            false,
                                                            _projTransDate,
                                                            ProjItemTransCostType::Cost));
                _ledgerVoucher.addTrans(ledgerVoucherTransObject);

                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                ledgerVoucherObject,
                                                this.postingOperations(),
                                                LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountOperations(), this.defaultDimension()),
                                                CompanyInfoHelper::standardCurrency(),
                                                _costAmount,
                                                currencyExchHelper);

                _ledgerVoucher.addTrans(ledgerVoucherTransObject);
                _updateNow.updOperationsAmountLedger(_updateNow.updOperationsAmountLedger() - _costAmount);
            }
            else
            {
                // Never expect to be executed.
                // Must be update financial is checking if mustBeBookedOperations OR mustBeBookedBalanceSheet is true
                throw error(Error::wrongUseOfFunction(funcName()));
            }

            // <GEERU>
            if (countryRegion_RU
                && ledgerBondClient)
            {
                if (ledgerBondClient.currentLogLength() == 2)
                {
                    ledgerBondClient.bondLastVRef2CurrentLog();
                }
                ledgerBondClient.removeCurrentLogObject();
            }
            // </GEERU>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerAdjustSecCur_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates ledger adjustment for reporting currency.
    /// </summary>
    /// <param name="_ledgerVoucher">
    /// The <c>LedgerVoucher</c> object.
    /// </param>
    /// <param name="_updateNow">
    /// The <c>InventUpd_Finanfial</c> object.
    /// </param>
    /// <param name="_costAmount">
    /// The cost amount value.
    /// </param>
    /// <param name="_projAdjustRefId">
    /// The project adjustment reference; optional.
    /// </param>
    /// <param name="_projTransDate">
    /// The project transaction date.
    /// </param>
    public void updateLedgerAdjustSecCur_RU(
        LedgerVoucher           _ledgerVoucher,
        InventUpd_Financial     _updateNow,
        CostAmountSecCur_RU     _costAmount,
        ProjAdjustRefId         _projAdjustRefId = '',
        ProjTransDate           _projTransDate   = dateNull())
    {
        LedgerVoucherTransObject    trans;

        if (!this.mustBeBookedFinancially() || !this.mustBeBookedOnhandSecCur_RU())
        {
            return;
        }

        if (!_costAmount)
        {
            return;
        }

        if (!isTelemetryForSecCurSent)
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceRU00111, funcName());
            isTelemetryForSecCurSent = true;
        }

        LedgerVoucherObject ledgerVoucherObject = _ledgerVoucher.findOrCreateReferenceSecCur_RU();
        LedgerBondClient_RU ledgerBondClient    = ledgerVoucherObject.ledgerBondClient_RU();
        boolean             correct             = ledgerVoucherObject.parmCorrection();
        CostAmountSecCur_RU costAmount          = _costAmount - this.parmIndirectCostAmountSecCur_RU();

        if (InventParameters::find().StornoAdjPosting && this.correctionSwapOnItem_RU(costAmount))
        {
            correct = !correct;
        }

        if (ledgerBondClient)
        {
            ledgerBondClient.addNewLogObject();
        }

        if (this.mustBeBookedBalanceSheet())
        {
            if (correct != ledgerVoucherObject.parmCorrection())
            {
                if (this.parmIndirectCostAmountSecCur_RU())
                {
                    ledgerVoucherObject.addTrans(LedgerVoucherTransObject::newBasicSecondary_RU(
                        ledgerVoucherObject,
                        this.postingBalanceSheet(),
                        LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountBalanceSheet(), this.defaultDimension()),
                        CompanyInfoHelper::standardCurrency(),
                        this.parmIndirectCostAmount_RU()));

                    ledgerVoucherObject.addTrans(LedgerVoucherTransObject::newBasicSecondary_RU(
                        ledgerVoucherObject,
                        this.postingOperations(),
                        LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountOperations(), this.defaultDimension()),
                        CompanyInfoHelper::standardCurrency(),
                        -this.parmIndirectCostAmount_RU()));
                }

                if (costAmount)
                {
                    trans = LedgerVoucherTransObject::newBasicSecondary_RU(
                            ledgerVoucherObject,
                            this.postingBalanceSheet(),
                            LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountBalanceSheet(), this.defaultDimension()),
                            CompanyInfoHelper::standardCurrency(),
                            costAmount);

                    trans.parmCorrect(correct);
                    ledgerVoucherObject.addTrans(trans);

                    trans = LedgerVoucherTransObject::newBasicSecondary_RU(
                            ledgerVoucherObject,
                            this.postingOperations(),
                            LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountOperations(), this.defaultDimension()),
                            CompanyInfoHelper::standardCurrency(),
                            -costAmount);

                    trans.parmCorrect(correct);
                    ledgerVoucherObject.addTrans(trans);
                }
            }
            else
            {
                trans = LedgerVoucherTransObject::newBasicSecondary_RU(
                        ledgerVoucherObject,
                        this.postingBalanceSheet(),
                        LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountBalanceSheet(), this.defaultDimension()),
                        CompanyInfoHelper::standardCurrency(),
                        _costAmount);

                trans.parmCorrect(correct);
                ledgerVoucherObject.addTrans(trans);

                trans = LedgerVoucherTransObject::newBasicSecondary_RU(
                        ledgerVoucherObject,
                        this.postingOperations(),
                        LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountOperations(), this.defaultDimension()),
                        CompanyInfoHelper::standardCurrency(),
                        -_costAmount);

                trans.parmCorrect(correct);
                ledgerVoucherObject.addTrans(trans);
            }
        }
        else if (this.mustBeBookedOperations())
        {
            trans = LedgerVoucherTransObject::newBasicSecondary_RU(
                        ledgerVoucherObject,
                        this.postingOperations(),
                        LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountOperations(), this.defaultDimension()),
                        CompanyInfoHelper::standardCurrency(),
                        -_costAmount);

            trans.parmProjLedger(ProjLedger::newInventCost(
                this.projId(),
                this.activityNumber(),
                this.projCategoryId(),
                this.transId(),
                _projAdjustRefId,
                this.projTransactionOrigin(),
                this.projLedgerOrigin(),
                this.itemId(),
                false,
                _projTransDate,
                ProjItemTransCostType::Cost));

            ledgerVoucherObject.addTrans(trans);
        }

        if (ledgerBondClient)
        {
            if (ledgerBondClient.currentLogLength() == 2)
            {
                ledgerBondClient.bondLastVRef2CurrentLog();
            }

            ledgerBondClient.removeCurrentLogObject();
        }

        _ledgerVoucher.restoreReferenceSecCur_RU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerFinancial</Name>
				<Source><![CDATA[
    public CostAmount updateLedgerFinancial(
        LedgerVoucher           _ledgerVoucher,
        InventUpd_Financial     _updateNow,
        boolean                 _allowNegative = false)
    {
        CostAmount                  costAmountMST;
        LedgerDimensionAccount      mergedLedgerDimension;
        LedgerVoucherTransObject    ledgerVoucherTransObject;
        // <GIN>
        boolean                     isCustomsEnabled = TaxParameters::isCustomsEnable_IN();
        // </GIN>
        // <GEERU>
        boolean                     countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        LedgerBondClient_RU         ledgerBondClient;
        // </GEERU>

        if (! _updateNow.parmCostAmountCur() 
            && !FeatureStateProvider::isFeatureEnabled(PostingZeroInvoicesInGeneralLedgerFeature::instance()))
        {
            costAmountMST = 0;
        }
        else if (this.mustBeBookedFinancially())
        {
            if (!this.checkInventSiteDimension(this.inventdim()))
            {
                throw error("@SYS18447");
            }

            CurrencyExchangeHelper exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(
                Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
                _ledgerVoucher.findLedgerVoucherObject().parmAccountingDate());

            exchangeRateHelper.parmExchangeRate1(_updateNow.parmExchRate());
            exchangeRateHelper.parmExchangeRate2(_updateNow.parmExchRateSecondary());

            if (this.mustBeBookedBalanceSheet())
            {
                // <GEERU>
                if (!countryRegion_RU || VendParameters::find().UsePurchConsumpAccount_RU)
                {
                    if (countryRegion_RU)
                    {
                        ledgerBondClient = _ledgerVoucher.findLedgerVoucherObject().ledgerBondClient_RU();
                    }
                // </GEERU>
                    ledgerVoucherTransObject = this.initializeLedgerVoucherTransObject(_ledgerVoucher,
                                    _updateNow,
                                    this.accountBalanceSheet(),
                                    this.postingBalanceSheet(),
                                    _updateNow.parmCostAmountCur()
                                    // <GTE>
                                    - this.taxEngineInventMovement().taxInCostPriceCur() - this.taxEngineInventMovement().postedTaxInCostPriceCur(),
                                    // </GTE>
                                    exchangeRateHelper);
                    ledgerVoucherTransObject.parmSourceTableId(purchLine.TableId);
                    ledgerVoucherTransObject.parmSourceRecId(purchLine.RecId);
                    _ledgerVoucher.addTrans(ledgerVoucherTransObject);

                    ledgerVoucherTransObject = this.initializeLedgerVoucherTransObject(_ledgerVoucher,
                                    _updateNow,
                                    this.accountOperations(),
                                    this.postingOperations(),
                                    -_updateNow.parmCostAmountCur()
                                    // <GTE>
                                    + this.taxEngineInventMovement().taxInCostPriceCur() + this.taxEngineInventMovement().postedTaxInCostPriceCur(),
                                    // </GTE>
                                    exchangeRateHelper);
                    ledgerVoucherTransObject.parmSourceTableId(purchLine.TableId);
                    ledgerVoucherTransObject.parmSourceRecId(purchLine.RecId);
                    _ledgerVoucher.addTrans(ledgerVoucherTransObject);
                // <GEERU>
                    if (ledgerBondClient)
                    {
                        ledgerBondClient.bondLast2();
                    }
                }
                // </GEERU>

                // <GIN>
                if (isCustomsEnabled)
                {
                    costAmountMST =  customsLoadOnInventoryMST + exchangeRateHelper.calculateTransactionToAccounting(_updateNow.parmCurrencyCode(), _updateNow.parmCostAmountCur() - customsLoadOnInventory, true);
                    ledgerVoucherTransObject.parmAccountingCurrencyAmount(costAmountMST);
                    _updateNow.updCostAmountLedger(costAmountMST);
                }
                else
                {
                // </GIN>
                    costAmountMST = exchangeRateHelper.calculateTransactionToAccounting(_updateNow.parmCurrencyCode(), _updateNow.parmCostAmountCur(), true);

                    _updateNow.updCostAmountLedger(costAmountMST);
                // <GIN>
                }
                // </GIN>

                // <GTE>
                if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
                {
                    this.taxEngineInventMovement().updateTaxFinancial(_ledgerVoucher, _updateNow,this.postingBalanceSheet(), this.accountBalanceSheet(), this.defaultDimension(), purchLine);
                    this.taxEngineInventMovement().updateTaxFinancial(_ledgerVoucher, _updateNow, this.postingOperations(), this.accountOperations(), this.defaultDimension(), purchLine);
                }
                // </GTE>

                if (this.mustBeBookedCharge())
                {
                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        ledgerBondClient = _ledgerVoucher.findLedgerVoucherObject().ledgerBondClient_RU();
                    }
                    // </GEERU>
                    ledgerVoucherTransObject = this.initializeLedgerVoucherTransObject(_ledgerVoucher,
                                    _updateNow,
                                    this.accountOperations(),
                                    this.postingOperations(),
                                    _updateNow.parmCostAmountCur(),
                                    exchangeRateHelper);
                    
                    _ledgerVoucher.addTrans(ledgerVoucherTransObject);

                    ledgerVoucherTransObject = this.initializeLedgerVoucherTransObject(_ledgerVoucher,
                                    _updateNow,
                                    this.accountStockVariation(),
                                    this.postingStockVariation(),
                                    -_updateNow.parmCostAmountCur(),
                                    exchangeRateHelper);

                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        ledgerVoucherTransObject.parmIsCorrection(NoYes::Yes);
                    }
                    // </GEERU>
                    _ledgerVoucher.addTrans(ledgerVoucherTransObject);
                    // <GEERU>
                    if (ledgerBondClient)
                    {
                        ledgerBondClient.bondLast2();
                    }
                    // </GEERU>
                }
            }
            else if (this.mustBeBookedOperations())
            {
                // <GEERU>
                if (countryRegion_RU)
                {
                    ledgerBondClient = _ledgerVoucher.findLedgerVoucherObject().ledgerBondClient_RU();
                }
                // </GEERU>
                costAmountMST = exchangeRateHelper.calculateTransactionToAccounting(_updateNow.parmCurrencyCode(), _updateNow.parmCostAmountCur(), true);

                _updateNow.updOperationsAmountLedger(costAmountMST);
                // <GEERU>
                if (ledgerBondClient)
                {
                    ledgerBondClient.bondLast2();
                }
                // </GEERU>
            }
            else
            {
                // Never expect to be executed.
                // Must be update financial is checking if mustBeBookedOperations OR mustBeBookedBalanceSheet is true
                throw error(Error::wrongUseOfFunction(funcName()));
            }

            if (this.projId() && !purchLine.existsItemReqForPO() && !this.mustBeBookedBalanceSheet())
            {
                _updateNow.updCostAmountLedger(costAmountMST);
            }
        }
        else
        {
            throw error("@SYS2009");
        }

        return costAmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeLedgerVoucherTransObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes an instance of <c>LedgerVoucherTransObject</c> based on input parameters.
    /// </summary>
    /// <param name="_ledgerVoucher">
    /// A <c>LedgerVoucher</c> object.
    /// </param>
    /// <param name="_updateNow">
    /// An <c>InventUpd_Financial</c> object.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The <c>LedgerDimensionDefaultAccount</c> record that specifies the initial dimension values.
    /// </param>
    /// <param name="_postingType">
    /// The posting type of the general journal entry.
    /// </param>
    /// <param name="_transactionCurrencyAmount">
    /// The amount in the transaction currency.
    /// </param>
    /// <param name="_exchangeRateHelper">
    /// The accounting currency amount and secondary currency amount exchange rates.
    /// </param>
    /// <returns>
    /// An instance of <c>LedgerVoucherTransObject</c>.
    /// </returns>
    protected LedgerVoucherTransObject initializeLedgerVoucherTransObject(
        LedgerVoucher                   _ledgerVoucher,
        InventUpd_Financial             _updateNow,
        LedgerDimensionDefaultAccount   _ledgerDimension,
        LedgerPostingType               _postingType,
        Money                           _transactionCurrencyAmount,
        CurrencyExchangeHelper          _exchangeRateHelper
        )
    {
        LedgerDimensionAccount      mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(_ledgerDimension,
                                                                                                                this.defaultDimension());
        LedgerVoucherObject ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();

        LedgerVoucherTransObject ledgerVoucherTransObject = InventoryReportingCurrencyTriangulationHelper::createLedgerVoucherTransObject(
                                        _ledgerVoucher.findLedgerVoucherObject(),
                                        _postingType,
                                        mergedLedgerDimension,
                                        _updateNow.parmCurrencyCode(),
                                        _transactionCurrencyAmount,
                                        _exchangeRateHelper);

        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerFinancialSecCur_RU</Name>
				<Source><![CDATA[
    public CostAmountSecCur_RU updateLedgerFinancialSecCur_RU(
        LedgerVoucher       _ledgerVoucher,
        InventUpd_Financial _updateNow,
        boolean             _allowNegative = false)
    {
        CostAmountSecCur_RU     costAmountSecCur;

        if (this.mustBeBookedFinancially() && this.mustBeBookedOnhandSecCur_RU())
        {
            if (!isTelemetryForSecCurSent)
            {
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceRU00111, funcName());
                isTelemetryForSecCurSent = true;
            }

            LedgerVoucherObject voucherObjectSecCur = _ledgerVoucher.findOrCreateReferenceSecCur_RU();
            if (this.mustBeBookedBalanceSheet())
            {
                voucherObjectSecCur.addTrans(
                    LedgerVoucherTransObject::newBasicSecondary_RU(
                        voucherObjectSecCur,
                        this.postingBalanceSheetSecCur_RU(),
                        LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountBalanceSheet(), this.defaultDimension()),
                        _updateNow.parmCurrencyCode(),
                        _updateNow.parmCostAmountCurSecCur_RU()));

                if (VendParameters::find().UsePurchConsumpAccount_RU)
                {
                    voucherObjectSecCur.addTrans(
                        LedgerVoucherTransObject::newBasicSecondary_RU(
                            voucherObjectSecCur,
                            this.postingOperations(),
                            LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountOperations(), this.defaultDimension()),
                            _updateNow.parmCurrencyCode(),
                            -_updateNow.parmCostAmountCurSecCur_RU()));
                }

                costAmountSecCur = _updateNow.parmCostAmountCurSecCur_RU();
                _updateNow.updCostAmountSecCurLedger_RU(costAmountSecCur);
            }
            else
            {
                if (this.mustBeBookedOperations())
                {
                    voucherObjectSecCur.addTrans(
                        LedgerVoucherTransObject::newBasicSecondary_RU(
                            voucherObjectSecCur,
                            this.postingOperations(),
                            LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountOperations(), this.defaultDimension()),
                            _updateNow.parmCurrencyCode(),
                            -_updateNow.parmCostAmountCurSecCur_RU()));

                    costAmountSecCur = _updateNow.parmCostAmountCurSecCur_RU();
                    _updateNow.updCostAmountSecCurLedger_RU(costAmountSecCur);
                }
            }

            _ledgerVoucher.restoreReferenceSecCur_RU();
        }

        return costAmountSecCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Adds ledger transactions for the physical update to the ledger voucher object.
    /// </summary>
    /// <param name="_ledgerVoucher">
    ///   A <c>LedgerVoucher</c> object.
    /// </param>
    /// <param name="_inventTrans">
    ///   An <c>InventTrans</c> record.
    /// </param>
    /// <param name="_updateNow">
    ///   An <c>InventUpdate</c> object.
    /// </param>
    /// <param name="_inventOnhand">
    ///   An <c>InventOnHand</c> object.
    /// </param>
    /// <param name="_inventTransUpd_RU">
    ///   An <c>InventTrans</c> record; optional.
    /// </param>
    public void updateLedgerPhysical(
        LedgerVoucher   _ledgerVoucher,
        InventTrans     _inventTrans,
        InventUpdate    _updateNow,
        InventOnhand    _inventOnhand
        , InventTrans     _inventTransUpd_RU = _inventTrans)
    {
        LedgerVoucherTransObject    ledgerVoucherTransObject;
        CurrencyCode                standardCurrencyCode = CompanyInfoHelper::standardCurrency();
        // <GEERU>
        boolean                     countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        LedgerBondClient_RU         ledgerBondClient;
        // </GEERU>

        super(_ledgerVoucher, _inventTrans, _updateNow, _inventOnhand
              // <GEERU>
              , _inventTransUpd_RU
              // </GEERU>
              );

        if (this.mustBeBookedCharge())
        {
            LedgerVoucherObject ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();
            CurrencyExchangeHelper currencyExchHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());
            // <GEERU>
            if (countryRegion_RU)
            {
                ledgerBondClient = ledgerVoucherObject.ledgerBondClient_RU();
            }
            // </GEERU>

            if (_inventTrans.isUpdatedPhysical())
            {
                _updateNow.postingPhysicalCharge(true);

                if (this.mustBeBookedPhysically())
                {
                    LedgerDimensionAccount mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(this.offsetAccountPhysical(), this.defaultDimension());
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                    _ledgerVoucher.findLedgerVoucherObject(),
                                                    this.postingOffsetPhysical(),
                                                    mergedLedgerDimension,
                                                    standardCurrencyCode,
                                                    _inventTrans.CostAmountPhysical,
                                                    currencyExchHelper);
                    _ledgerVoucher.addTrans(ledgerVoucherTransObject);

                    mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(this.accountStockVariation(), this.defaultDimension());
                    ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                    _ledgerVoucher.findLedgerVoucherObject(),
                                                    this.postingStockVariation(),
                                                    mergedLedgerDimension,
                                                    standardCurrencyCode,
                                                    -_inventTrans.CostAmountPhysical,
                                                    currencyExchHelper);
                    // <GEERU>
                    if (countryRegion_RU)
                    {
                        ledgerVoucherTransObject.parmIsCorrection(NoYes::Yes);
                    }
                    // </GEERU>
                    _ledgerVoucher.addTrans(ledgerVoucherTransObject);
                    // <GEERU>
                    if (ledgerBondClient)
                    {
                        ledgerBondClient.bondLast2();
                    }
                    // </GEERU>
                }
            }
            else if (_inventTrans.isUpdatedFinancial())
            {
                _updateNow.postingFinancialCharge(true);

                if (bookedPhysically != UnknownNoYes::No)
                {
                    InventTransPosting inventTransPosting = _inventTrans.inventTransPostingPhysicalCharge();

                    if (inventTransPosting.IsPosted)
                    {
                        CostAmountPhysical originalCostAmountPhysical = this.inventModelType().originalCostAmountPhysical(_inventTrans);

                        ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                        ledgerVoucherObject,
                                                        inventTransPosting.PostingType,
                                                        inventTransPosting.LedgerDimension,
                                                        standardCurrencyCode,
                                                        -originalCostAmountPhysical,
                                                        currencyExchHelper);

                        // When relieving physical inventory the accounts are not validated because
                        // the amounts need to be relieved from the original accounts
                        ledgerVoucherTransObject.parmSkipDimensionValidation(true);
                        _ledgerVoucher.addTrans(ledgerVoucherTransObject);

                        ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                        ledgerVoucherObject,
                                                        inventTransPosting.PostingTypeOffset,
                                                        inventTransPosting.OffsetLedgerDimension,
                                                        standardCurrencyCode,
                                                        originalCostAmountPhysical,
                                                        currencyExchHelper);
                        // <GEERU>
                        if (countryRegion_RU)
                        {
                            ledgerVoucherTransObject.parmIsCorrection(NoYes::Yes);
                        }
                        // </GEERU>

                        // When relieving physical inventory the accounts are not validated because
                        // the amounts need to be relieved from the original accounts
                        ledgerVoucherTransObject.parmSkipDimensionValidation(true);
                        _ledgerVoucher.addTrans(ledgerVoucherTransObject);
                        // <GEERU>
                        if (ledgerBondClient)
                        {
                            ledgerBondClient.bondLast2();
                        }
                        // </GEERU>
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>useEnteredPriceAsCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if returning the Project Purchase Order.
    ///    Which is not created from Item Requirement.
    ///    Or if returning Fixed Asset Purchase Order.
    /// </summary>
    /// <returns>
    ///    Return true if return Project Purchase Order is not created from Item Requirement
    ///   Otherwise call base class method.
    ///   Also return true if return Purchase Order with Fixed Asset.
    /// </returns>
    /// <remarks>
    ///    This method overrides a base class method.
    /// </remarks>
    public boolean useEnteredPriceAsCost()
    {
        if (this.isProjectWithNegativeQuantityAndScrap() || this.isAssetWithNegativeQuantity())
        {
            return true;
        }
        else
        {
            return super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProjectWithNegativeQuantityAndScrap</Name>
				<Source><![CDATA[
    private boolean isProjectWithNegativeQuantityAndScrap()
    {
        return purchLine.ProjId
            && !purchLine.existsItemReqForPO()
            && purchLine.Scrap == NoYes::Yes
            && purchLine.QtyOrdered < 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAssetWithNegativeQuantity</Name>
				<Source><![CDATA[
    private boolean isAssetWithNegativeQuantity()
    {
        return purchLine.AssetId
            && purchLine.QtyOrdered < 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFixedAssetReturn</Name>
				<Source><![CDATA[
    internal boolean isFixedAssetReturn()
    {
        return this.isAssetWithNegativeQuantity();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromPurchLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>InventMov_Purch</c> class based on the specified record.
    /// </summary>
    /// <param name="_purchLine">
    ///    The <c>PurchLine</c> record for which the class is instantiated.
    /// </param>
    /// <returns>
    ///    An instance of the <c>InventMov_Purch</c> or the <c>InventMov_PurchCreditNote</c> class.
    /// </returns>
    public static InventMov_Purch newFromPurchLine(PurchLine _purchLine)
    {
        if (_purchLine.PurchQty < 0) // Detect it is a credit note line
        {
            return InventMov_PurchCreditNote::construct(_purchLine);
        }
        else
        {
            return new InventMov_Purch(_purchLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowAutoLossProfit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allow auto loss profit.
    /// </summary>
    /// <returns>
    /// Return true if allow.
    ///</returns>
    public boolean allowAutoLossProfit()
    {
        if (this.projId()
            && purchLine.existsItemReqForPO())
        {
            return false;
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>workLineExistsForInventTransId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether a work line exists for the given inventory transaction ID.
    /// </summary>
    /// <param name="_inventTransId">
    /// Inventory transaction ID to check for.
    /// </param>
    /// <returns>
    /// true if work line exists; otherwise, false.
    /// </returns>
    private boolean workLineExistsForInventTransId(InventTransId _inventTransId)
    {
        WHSWorkLine workLine;

        select firstonly RecId from workLine
            where workLine.InventTransId == _inventTransId;

        return workLine.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>batchProdDate</Name>
				<Source><![CDATA[
    public InventBatchProdDate batchProdDate(InventTrans _inventTrans = null)
    {
        if (_inventTrans)
        {
            if (_inventTrans.DatePhysical)
            {
                return _inventTrans.DatePhysical;
            }
            else if (_inventTrans.DateInvent)
            {
                return _inventTrans.DateInvent;
            }
            else if (this.parmDateRegistration())
            {
                return this.parmDateRegistration();
            }
            else
            {
                return _inventTrans.DateStatus;
            }
        }

        return this.transDate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsMustConsiderBatchAttrib</Name>
				<Source><![CDATA[
    public PdsBatchAttribAutoRes pdsMustConsiderBatchAttrib()
    {
        if (purchLine.PurchaseType == PurchaseType::ReturnItem)
        {
            return false;
        }
        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventBlockingStatusSyncInventDim</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal InventDim parmInventBlockingStatusSyncInventDim(InventDim _inventBlockingStatusSyncInventDim = inventBlockingInventStatusSyncInventDim)
    {
        inventBlockingInventStatusSyncInventDim = super(_inventBlockingStatusSyncInventDim);

        return inventBlockingInventStatusSyncInventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCanDepreciateMarkedTransactionUpdate</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void validateCanDepreciateMarkedTransactionUpdate(InventTrans _inventTrans)
    {
        this.whsCheckCrossDockLoadInventTransUpdated(_inventTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCanDeleteMarkedTransaction</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void validateCanDeleteMarkedTransaction()
    {
        this.whsCheckCrossDockLoadInventTransDeleted();
    }

]]></Source>
			</Method>
			<Method>
				<Name>logUnexpectedLotIdNotSpecified</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void logUnexpectedLotIdNotSpecified(MethodName _fromMethod)
    {
        error(strFmt("@SCM:LotIdNotSpecifiedForPurchLineError", purchLine.PurchId, purchLine.InventTransId, int642Str(purchLine.RecId)));
        super(_fromMethod);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFinTag</Name>
				<Source><![CDATA[
    protected void updateFinTag(LedgerVoucherTransObject _ledgerVoucherTransObject)
    {
        if (FinTagConfiguration::isFinTagConfigurationSet(purchLine.DataAreaId)
            && PurchaseOrderFinTagFeature::isEnabled() && purchLine.FinTag)
        {
            _ledgerVoucherTransObject.parmFinTag(purchLine.FinTag);
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>