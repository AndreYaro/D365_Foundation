<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxVoucherService</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>TaxVoucherService</c> class contains the journal-specific logic, which determines the
///    account that the offset of the total tax amount is allocated.
/// </summary>
/// <remarks>
///    This class calculates the sales tax to post on individual lines and determines the amount to add to
///    the customer or vendor ledger account.It determines the account to which to add the sales tax. This
///    account can be a customer, a vendor, or a bank account; and if one of those exists, this account
///    will be chosen.
/// </remarks>
class TaxVoucherService
{
    #ISOCountryRegionCodes
    boolean             taxUncommittedCheckedForTaxAmounts;
    boolean             taxAmountsExistForDocument;
    boolean             offsetForTotalTaxAmountAllocated;
    boolean             postTaxOnErrorAccount;
    boolean             vendCustExistsForPrimaryVoucher;
    boolean             vendCustExistsForPrimaryVoucherChecked;
    boolean             vendCustExistsForVoucher;
    boolean             vendCustExistsForVoucherChecked;
    boolean             paymentFeeExists;
    boolean             paymentFeeExistsChecked;
    boolean             paymentFeeTaxAllocated;
    boolean             intercompanyCustVendBank;
    boolean             nonRecoverableVATExists;
    boolean             nonRecoverableVATExistsChecked;

    LedgerJournalTable  ledgerJournalTable;
    DataAreaId dataAreaIdPost = '';

    // Holds a map of recid's which tie a LedgerJournalTrans record in other companies to a
    // LedgerJournalTrans record in the originating company.  Taxes are now calculated once, in the
    // currently logged in company.  Tax amounts are then shared to "other companies" on the transaction
    // as needed using this map to tie them together.
    Map                 interCompanyMap;
    Map                 asset2CustVendTransMap;

    TaxObligationCompany taxObligation;
    SelectableDataArea   taxObligationSourceCompany;

    // Voucher and Invoice currently being processed
    Voucher             voucherBeingProcessed;
    TransDate           transDateBeingProcessed;
    InvoiceId           invoiceBeingProcessed;
    CompanyId           loggedInCompany;
    TaxPost             taxPost;

    // This is the Cust/Vend/Bank account type which is the tax source.
    RefRecId            originalTaxObligationSourceRecord;

    TaxUncommittedTaxTransTmp taxUncommittedTaxTransTmp;

    // <GIN>
    boolean             isIndiaTaxEnabled;
    Map                 priceInclTaxAmountMap;
    Map                 serviceTaxAmountMap;
    boolean             isInclusiveTax;
    boolean             isformulaDefined;
    boolean             isInterCompanyTrans;
    AmountCur           interCompanyTaxBase;
    boolean             taxIncluded;
    boolean             isLedgerLedger;

    TaxWithholdAmountCur    withholdTaxAmountCur;
    Map offsetForTotalTaxAmountAllocatedByVoucherMap;
    boolean taxInterruptOfErrorAccountForMultiVoucherFlightEnabled = True;
    private boolean isTaxDifferencePostingOnJapanConsInvoiceEnabled = TaxConsInvoice_JP::isTaxDifferencePostingOnConsInvoiceEnabled(true);
    private boolean isTaxInterCompanyDestinationIncludeTaxFlightEnabled = TaxInterCompanyDestinationIncludeTaxFlight::instance().isEnabled();

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkForDocumentChange</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the tax document that is being posted has changed.
    /// </summary>
    /// <param name="_voucher">
    ///    The current <c>Voucher</c> enumeration value.
    /// </param>
    /// <param name="_invoiceId">
    ///    The current invoice.
    /// </param>
    /// <param name="_isInterCompany">
    ///    true if this is an intercompany journal; otherwise, false.
    /// </param>
    /// <param name="_transDate">
    ///    The current transaction date.
    /// </param>
    /// <remarks>
    ///    A journal may contain multiple tax documents. Each tax document is represented by a <c>Voucher</c>
    ///    and <c>InvoiceId</c> enumeration value. However, the offset for the total tax amount is allocated
    ///    one time for each voucher.
    /// </remarks>
    private void checkForDocumentChange(Voucher _voucher, InvoiceId _invoiceId, boolean _isInterCompany, TransDate _transDate = dateNull())
    {
        LedgerJournalTaxDocument ledgerJournalTaxDocument;
        if (_voucher != voucherBeingProcessed || _transDate != transDateBeingProcessed)
        {
            voucherBeingProcessed = _voucher;
            transDateBeingProcessed = _transDate;
            invoiceBeingProcessed = _invoiceId;
            taxUncommittedCheckedForTaxAmounts = false;
            taxAmountsExistForDocument = false;
            paymentFeeExists = false;
            paymentFeeExistsChecked = false;
            paymentFeeTaxAllocated = false;
            this.setOffsetForTotalTaxAmountAllocatedByVoucher(_voucher, false);
            vendCustExistsForVoucher = false;
            vendCustExistsForVoucherChecked = false;
            vendCustExistsForPrimaryVoucher = false;
            vendCustExistsForPrimaryVoucherChecked = false;

            if (taxObligation == TaxObligationCompany::Source && !_isInterCompany)
            {
                ledgerJournalTaxDocument = ledgerJournalTaxDocument::construct(ledgerJournalTable.JournalNum, _voucher, _invoiceId);
                taxObligationSourceCompany = ledgerJournalTaxDocument.getSourceCompany();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIfVendCustExistsForDocument</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the voucher that is being posted contains a vendor or customer type.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The current <c>LedgerJournalTrans</c> record that is being processed.
    /// </param>
    /// <returns>
    ///    true if a vendor or customer type is used in this voucher; otherwise, false.
    /// </returns>
    private boolean checkIfVendCustExistsForDocument(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTrans ledgerJournalTrans;

        if (!vendCustExistsForVoucherChecked)
        {
            select RecId from ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == _ledgerJournalTrans.JournalNum &&
                  ledgerJournalTrans.Voucher == _ledgerJournalTrans.Voucher &&
                  (ledgerJournalTrans.AccountType == LedgerJournalACType::Cust ||
                   ledgerJournalTrans.AccountType == LedgerJournalACType::Vend ||
                   ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust ||
                   ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend);

            vendCustExistsForVoucherChecked = true;
            vendCustExistsForVoucher = ledgerJournalTrans.RecId;
        }

        return vendCustExistsForVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIfVendCustExistsInOrigJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets a value which indiates whether the voucher from the originating journal contains a customer or vendor type.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The current <c>LedgerJournalTrans</c> record that is being processed.
    /// </param>
    /// <returns>
    ///    true if a vendor or customer type is used in the originating journal; otherwise, false.
    /// </returns>
    private boolean checkIfVendCustExistsInOrigJournal(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTrans ledgerJournalTrans;

        if (!vendCustExistsForPrimaryVoucherChecked)
        {
            changeCompany (_ledgerJournalTrans.ForeignCompany)
            {
                select RecId from ledgerJournalTrans
                where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum &&
                      ledgerJournalTrans.Voucher == _ledgerJournalTrans.ForeignVoucher &&
                      (ledgerJournalTrans.AccountType == LedgerJournalACType::Cust ||
                       ledgerJournalTrans.AccountType == LedgerJournalACType::Vend ||
                       ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust ||
                       ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend);
            }

            vendCustExistsForPrimaryVoucherChecked = true;
            vendCustExistsForPrimaryVoucher = (ledgerJournalTrans.RecId != 0);
        }

        return vendCustExistsForPrimaryVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesTaxAmountExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a tax amount exists in the <c>TaxUncommitted</c> table for the given primary
    /// account or offset account of a <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// true if a tax amount exists for the given <c>LedgerJournalTrans</c> record; otherwise, false.
    /// </returns>
    private boolean doesTaxAmountExist(LedgerJournalTrans _ledgerJournalTrans)
    {
        Voucher voucherOriginatingCompany;

        changecompany(loggedInCompany)
        {
            if (!ledgerJournaltable.isTaxSupported())
            {
                taxUncommittedCheckedForTaxAmounts = true;
                return false;
            }

            this.checkForDocumentChange(_ledgerJournalTrans.Voucher, _ledgerJournalTrans.Invoice, _ledgerJournalTrans.ForeignVoucher != '', _ledgerJournalTrans.TransDate);

            if (!taxUncommittedCheckedForTaxAmounts)
            {
                // TaxUncommitted records only exist for the voucher in the originating company.
                // For intercompany scenarios, the voucher in the originating company is needed,
                // since the LedgerJournalTrans can be for the foreign company when posting intercompany journal.
                if (this.isInterCompanyLedgerJournalTrans(_ledgerJournalTrans))
                {
                    voucherOriginatingCompany = _ledgerJournalTrans.ForeignVoucher;
                }
                else
                {
                    voucherOriginatingCompany = _ledgerJournalTrans.Voucher;
                }
                // if this is a prepayment and the tax parameter enabling tax on prepayments
                // was on, we calculated tax, then turned off, then we need to ensure that
                // taxes gets cleared out.
                if (_ledgerJournalTrans.Prepayment)
                {
                    if ((ledgerJournalTable.JournalType == LedgerJournalType::CustPayment && !CustParameters::find().TaxOnPrepayment) ||
                            (ledgerJournalTable.JournalType == LedgerJournalType::Payment && !VendParameters::find().TaxOnPrepayment))
                    {
                        if (TaxUncommitted::existByDocumentAndInvoice(ledgerJournalTable.TableId, ledgerJournalTable.RecId, voucherOriginatingCompany, _ledgerJournalTrans.Invoice))
                        {
                            TaxUncommitted::deleteForInvoice(ledgerJournalTable.TableId, ledgerJournalTable.RecId, voucherOriginatingCompany, _ledgerJournalTrans.Invoice);
                        }
                    }
                }

                taxAmountsExistForDocument = TaxUncommitted::existByDocumentAndVoucher(ledgerJournalTable.TableId, ledgerJournalTable.RecId, voucherOriginatingCompany);
                if (!taxAmountsExistForDocument)
                {
                    TaxVoucherService::calculateTaxForVoucher(ledgerJournalTable.JournalNum, voucherOriginatingCompany);
                    taxAmountsExistForDocument = TaxUncommitted::existByDocumentAndVoucher(ledgerJournalTable.TableId, ledgerJournalTable.RecId, voucherOriginatingCompany);
                }
                taxUncommittedCheckedForTaxAmounts = true;
            }
        }

        return taxAmountsExistForDocument;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesTaxExistForIntercompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a tax amount exists in the <c>TaxUncommitted</c> table for the given primary
    /// account or offset account of an intercompany <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <param name="_interCompanyledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record to use to find a tax amount.
    /// </param>
    /// <returns>
    /// true if a tax amount exists for the given intercompany <c>LedgerJournalTrans</c> record; otherwise,
    /// false.
    /// </returns>
    public boolean doesTaxExistForIntercompany(LedgerJournalTrans _interCompanyledgerJournalTrans)
    {
        RefRecId            originatingCompanyRecId;
        LedgerJournalTrans  ledgerJournalTransOriginatingCompany;
        LedgerJournalTable  originatingledgerJournalTable;
        CompanyId           currentCompany;

        // Get the RecId for the LedgerJournalTrans line for the originating company.
        if (interCompanyMap.exists(_interCompanyledgerJournalTrans.RecId))
        {
            originatingCompanyRecId = interCompanyMap.lookup(_interCompanyledgerJournalTrans.RecId);
        }
        else
        {
            return 0;
        }

        currentCompany = curext();

        // the current company is the foreign company so switch back to the originating company.
        changecompany(_interCompanyledgerJournalTrans.ForeignCompany)
        {
            // get the LedgerJournalTrans line for the originating company.
            ledgerJournalTransOriginatingCompany = LedgerJournalTrans::findRecId(originatingCompanyRecId, false);

            originatingledgerJournalTable = ledgerJournalTransOriginatingCompany.ledgerJournalTable();

            return TaxUncommitted::existByDocumentVoucherAndCompany(originatingledgerJournalTable.TableId, originatingledgerJournalTable.RecId, ledgerJournalTransOriginatingCompany.Voucher, currentCompany);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesTaxOnPaymentFeeExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the tax on payment fees exist for the specified voucher.
    /// </summary>
    /// <param name="_voucher">
    /// The voucher.
    /// </param>
    /// <param name="_journalNumber">
    /// The journal number.
    /// </param>
    /// <returns>
    /// true if a tax amount exists for payment fees; otherwise, false.
    /// </returns>
    private boolean doesTaxOnPaymentFeeExist(Voucher _voucher, JournalId _journalNumber)
    {
        LedgerJournalTrans ledgerJournalTrans;
        TaxUncommitted taxUncommitted;

        if (!paymentFeeExistsChecked)
        {
            select firstonly RecId from ledgerJournalTrans
                where ledgerJournalTrans.Voucher  ==_voucher &&
                      ledgerJournalTrans.JournalNum == _journalNumber &&
                      ledgerJournalTrans.TransactionType == LedgerTransType::Fee;

            if (ledgerJournalTrans.RecId != 0)
            {
                select firstonly RecId from ledgerJournalTrans
                    where ledgerJournalTrans.Voucher  ==_voucher &&
                          ledgerJournalTrans.JournalNum == _journalNumber &&
                          ledgerJournalTrans.TransactionType == LedgerTransType::Fee
                exists join taxUncommitted
                    where taxUncommitted.SourceTableId == ledgerJournalTrans.TableId &&
                          taxUncommitted.SourceRecId == ledgerJournalTrans.RecId;
                paymentFeeExists = (ledgerJournalTrans.RecId != 0);
            }
            paymentFeeExistsChecked = true;
        }
        return paymentFeeExists;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNonRecoverableTaxAmountCurList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the ledgerposting type and non-recoverable tax amount list for ledger line.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> to post.
    /// </param>
    /// <param name="_interCompany">
    /// true if this is an intercompany journal; otherwise, false.
    /// </param>
    /// <param name="_dueToDueFromAccount">
    /// true if this is a due to or due from account; otherwise, false.
    /// </param>
    /// <returns>
    /// The tax amount list for the ledger account.
    /// </returns>
    /// <remarks>
    /// When the normal account that is found on the original <c>LedgerJournalTrans</c> record is not used,
    /// a special account such as the due to or due from accounts is used.
    /// </remarks>
    public List getNonRecoverableTaxAmountCurList(LedgerJournalTrans _ledgerJournalTrans, boolean _interCompany, boolean _dueToDueFromAccount)
    {
        LedgerJournalTrans  originatingLedgerJournalTrans;
        SelectableDataArea  originatingCompany;
        List                nonRecoverableTaxAmountCurList;

        if (!nonRecoverableVATExistsChecked)
        {
            changeCompany (loggedInCompany)
            {
                nonRecoverableVATExists = TaxUncommitted::existsNonRecoverableTaxForDocument(ledgerJournalTable.TableId, LedgerJournalTable.RecId);
                nonRecoverableVATExistsChecked = true;
            }
        }

        if (!nonRecoverableVATExists)
        {
            return null;
        }

        if (_interCompany)
        {
            changeCompany (_ledgerJournalTrans.ForeignCompany)
            {
                originatingLedgerJournalTrans = LedgerJournalTrans::findRecId(this.getOriginatingLJTFromIntercompanyLJT(_ledgerJournalTrans.RecId), false);
            }
        }
        else
        {
            originatingLedgerJournalTrans = _ledgerJournalTrans;
        }

        if (!_dueToDueFromAccount)
        {
            boolean shouldGetNonRecvTaxAmount = false;

            if (originatingLedgerJournalTrans.Company == curext())
            {
                if (originatingLedgerJournalTrans.isPrimaryTaxable()
                    || this.isTaxDifferencePostingOnJapanConsInvoiceEnabled)
                {
                    shouldGetNonRecvTaxAmount = true;
                }
            }
            if (!shouldGetNonRecvTaxAmount && originatingLedgerJournalTrans.OffsetCompany == curext()
                && originatingLedgerJournalTrans.OffsetLedgerDimension)
            {
                if (originatingLedgerJournalTrans.isOffsetTaxable()
                    || this.isTaxDifferencePostingOnJapanConsInvoiceEnabled)
                {
                    shouldGetNonRecvTaxAmount = true;
                }
            }

            if (shouldGetNonRecvTaxAmount)
            {
                if (_interCompany)
                {
                    nonRecoverableTaxAmountCurList = this.getNonRecTaxAmtCurIntecoLineList(_ledgerJournalTrans);
                }
                else
                {
                    nonRecoverableTaxAmountCurList = this.getNonRecTaxAmtCurForLineList(_ledgerJournalTrans);
                }
            }
        }
        else
        {
            if (taxObligationSourceCompany == curext()
                && taxObligation == TaxObligationCompany::Source
                && intercompanyCustVendBank
                && originatingLedgerJournalTrans.RecId == originalTaxObligationSourceRecord)
            {
                // all nonrecoverable VAT is owed to this company so update the due to/due from account
                if (_interCompany)
                {
                    nonRecoverableTaxAmountCurList = this.getNonRecTaxAmtCurIntercoDocList(_ledgerJournalTrans);
                }
                else
                {
                    nonRecoverableTaxAmountCurList = this.getNonRecTaxAmtCurForDocAndVoList(ledgerJournalTable, _ledgerJournalTrans.Voucher);
                }
            }
            else
            {
                // We only need the non-recoverable VAT which is associated with
                // the current line being processed.

                // Special code for single line scenarios
                if (originatingLedgerJournalTrans.OffsetLedgerDimension)
                {
                    if (_interCompany)
                    {
                        if ((!intercompanyCustVendBank
                            || taxObligation == TaxObligationCompany::Source)
                            && taxObligation != TaxObligationCompany::Destination)
                        {
                            nonRecoverableTaxAmountCurList = this.getNonRecTaxAmtCurIntecoLineList(_ledgerJournalTrans, -1);
                        }
                    }
                    else
                    {
                        if (intercompanyCustVendBank
                            || taxObligation == TaxObligationCompany::Source)
                        {
                            nonRecoverableTaxAmountCurList = this.getNonRecTaxAmtCurForLineList(_ledgerJournalTrans);
                        }
                    }
                }
                else
                {
                    // multi line scenarios

                    if (_interCompany)
                    {
                        originatingCompany = _ledgerJournalTrans.ForeignCompany;
                    }
                    else
                    {
                        originatingCompany = curext();
                    }

                    changeCompany (originatingCompany)
                    {
                        if (_interCompany)
                        {
                            if ((!intercompanyCustVendBank
                                || taxObligation == TaxObligationCompany::Source)
                                && taxObligation != TaxObligationCompany::Destination)
                            {
                                nonRecoverableTaxAmountCurList = this.getNonRecTaxAmtCurIntecoLineList(_ledgerJournalTrans, -1);
                            }
                        }
                        else
                        {
                            if ((intercompanyCustVendBank
                                || taxObligation == TaxObligationCompany::Source)
                                && taxObligation != TaxObligationCompany::Destination)
                            {
                                nonRecoverableTaxAmountCurList = this.getNonRecTaxAmtCurForLineList(_ledgerJournalTrans);
                            }
                        }
                    }
                }
            }
        }

        return nonRecoverableTaxAmountCurList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNonRecoverableVATForDestinationCo</Name>
				<Source><![CDATA[
    private TaxAmountCur getNonRecoverableVATForDestinationCo(LedgerJournalTrans _ledgerJournalTrans, SelectableDataArea _destinationCompany)
    {
        TaxUncommitted     taxUncommitted;
        LedgerJournalTrans ledgerJournalTranslocal;

        select sum(TaxInCostPrice) from taxUncommitted
            group by ledgerJournalTranslocal.JournalNum, ledgerJournalTranslocal.Voucher, ledgerJournalTranslocal.Company
            join RecId from ledgerJournalTranslocal
                where ledgerJournalTranslocal.JournalNum == _ledgerJournalTrans.JournalNum
                    && ledgerJournalTranslocal.Voucher == _ledgerJournalTrans.Voucher
                    && ledgerJournalTranslocal.Company == _destinationCompany
                    && ledgerJournalTranslocal.TableId == taxUncommitted.SourceTableId
                    && ledgerJournalTranslocal.RecId == taxUncommitted.SourceRecId;

        return taxUncommitted.TaxInCostPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNonRecTaxAmtCurForDocAndVoList</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the list whose items contain posting type and non recoverable tax amount for the transaction line.
    /// </summary>
    /// <param name="_ledgerJournalTable">
    ///    The <c>LedgerJournalTable</c> record.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher number.
    /// </param>
    /// <param name="_company">
    ///    The company ID to restrict the total tax to; optional.
    /// </param>
    /// <param name="_signFactor">
    ///    The factor used to determine the sign of the amount.
    /// </param>
    /// <returns>
    ///    The list whose items contain posting type and non recoverable tax amount in transactional currency.
    /// </returns>
    private List getNonRecTaxAmtCurForDocAndVoList(
        ledgerJournalTable  _ledgerJournalTable,
        Voucher             _voucher,
        SelectableDataArea  _company = '',
        sign                _signFactor = 1)
    {
        // <GIN>
        #ISOCountryRegionCodes
        // </GIN>
        List actualNonRecoverableTaxSourceDocList;

        // <GIN>
        if (isIndiaTaxEnabled)
        {
            return this.getNonRecTaxAmtCurForDocAndVoList_IN(_ledgerJournalTable.TableId, _ledgerJournalTable.RecId, _voucher, _signFactor, _company);
        }
        else
        {
        // </GIN>
            actualNonRecoverableTaxSourceDocList = new List(Types::Container);
            actualNonRecoverableTaxSourceDocList.addEnd(
                [LedgerPostingType::Tax,
                _signFactor * TaxUncommitted::getActualNonRecoverableVATAmtForDocAndVo(_ledgerJournalTable.TableId, _ledgerJournalTable.RecId, _voucher, _company)]);
            return actualNonRecoverableTaxSourceDocList;
        // <GIN>
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNonRecTaxAmtCurForDocAndVoList_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the list whose items contain posting type and nont recoverable tax amount for the invoice.
    /// </summary>
    /// <param name="_documentTableId">
    /// The table ID for the transaction header.
    /// </param>
    /// <param name="_documentId">
    /// The record ID of the transaction header.
    /// </param>
    /// <param name="_voucher">
    /// The voucher.
    /// </param>
    /// <param name="_signFactor">
    ///    The factor used to determine the sign of the amount.
    /// </param>
    /// <param name="_companyId">
    /// If supplied, then the tax amount returned will be for the given company.
    /// If not supplied, the tax amount will include tax for all companies; optional.
    /// </param>
    /// <returns>
    /// The list whose items contain posting type and non recoverable tax amount in transaction currency.
    /// </returns>
    private List getNonRecTaxAmtCurForDocAndVoList_IN(
        RefTableId          _documentTableId,
        RefRecId            _documentId,
        Voucher             _voucher,
        Sign                _signFactor = 1,
        SelectableDataArea  _companyId  = '')
    {
        TaxUncommitted taxUncommitted;
        TaxTable       taxTable;
        List           actualTaxInCostPriceForSourceDocList = new List(Types::Container);

        while select TaxInCostPriceRegulated from taxUncommitted
            where taxUncommitted.HeadingRecId   == _documentId
                && taxUncommitted.HeadingTableId   == _documentTableId
                && taxUncommitted.Voucher          == _voucher
                && (_companyId == '' || taxUncommitted.Company == _companyId)
        join TaxType_IN from taxTable
            where taxTable.TaxCode == taxUncommitted.TaxCode
        {
            actualTaxInCostPriceForSourceDocList.addEnd([TaxVoucherService::getTaxPostingType_IN(taxTable.TaxType_IN), taxUncommitted.TaxInCostPriceRegulated * _signFactor]);
        }

        return actualTaxInCostPriceForSourceDocList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNonRecTaxAmtCurForLineList</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the list whose items contain posting type and non recoverable tax amount for the transaction line.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_signFactor">
    ///    The factor used to determine the sign of the amount.
    /// </param>
    /// <returns>
    ///    The the list whose items contain posting type and non recoverable tax amount in transactional currency.
    /// </returns>
    private List getNonRecTaxAmtCurForLineList(LedgerJournalTrans _ledgerJournalTrans, Sign _signFactor = 1)
    {
        // <GIN>
        #ISOCountryRegionCodes
        // </GIN>
        List actualNonRecoverableTaxForSourceLineList;

        // <GIN>
        if (isIndiaTaxEnabled)
        {
            if (_ledgerJournalTrans.isLedgerBankJournal_IN())
            {
                return null;
            }
            return this.getNonRecTaxAmtCurForLineList_IN(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId, _signFactor);
        }
        else
        {
        // </GIN>
            actualNonRecoverableTaxForSourceLineList = new List(Types::Container);
            actualNonRecoverableTaxForSourceLineList.addEnd(
                [LedgerPostingType::Tax, _signFactor * TaxUncommitted::getActualTaxInCostPriceForSourceLine(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId)]);
            return actualNonRecoverableTaxForSourceLineList;
        // <GIN>
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNonRecTaxAmtCurForLineList_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the list whose items contain posting type and non recoverable tax amount for the transaction line.
    /// </summary>
    /// <param name="_sourceTableId">
    ///    The transaction line table ID.
    /// </param>
    /// <param name="_sourceRecId">
    ///    The transaction line record ID.
    /// </param>
    /// <param name="_signFactor">
    ///    The factor used to determine the sign of the amount.
    /// </param>
    /// <returns>
    ///    The list whose items contain posting type and non recoverable tax amount in transaction currency.
    /// </returns>
    private List getNonRecTaxAmtCurForLineList_IN(RefTableId _sourceTableId, RefRecId _sourceRecId, Sign _signFactor = 1)
    {
        TaxUncommitted  taxUncommitted;
        TaxTable        taxTable;
        List            actualTaxInCostPriceForSourceLineList = new List(Types::Container);

        while select TaxInCostPriceRegulated from taxUncommitted
            where taxUncommitted.SourceRecId == _sourceRecId
                && taxUncommitted.SourceTableId == _sourceTableId
        join TaxType_IN from taxTable
            where taxTable.TaxCode == taxUncommitted.TaxCode
        {
            actualTaxInCostPriceForSourceLineList.addEnd([TaxVoucherService::getTaxPostingType_IN(taxTable.TaxType_IN), taxUncommitted.TaxInCostPriceRegulated * _signFactor]);
        }

        return actualTaxInCostPriceForSourceLineList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNonRecTaxAmtCurIntecoLineList</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the list whose items contain posting type and non recoverable tax amount for an intercompany line.
    /// </summary>
    /// <param name="_interCompanyledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_signFactor">
    ///    The factor used to determine the sign of the amount.
    /// </param>
    /// <returns>
    ///    The list whose items contain posting type and non recoverable tax amount in transaction currency.
    /// </returns>
    private List getNonRecTaxAmtCurIntecoLineList(LedgerJournalTrans _interCompanyledgerJournalTrans, Sign _signFactor = 1)
    {
        RefRecId            originatingCompanyRecId;
        LedgerJournalTrans  ledgerJournalTransOriginatingCompany;

        // Get the RecId for the LedgerJournalTrans line for the originating company.
        if (interCompanyMap.exists(_interCompanyledgerJournalTrans.RecId))
        {
            originatingCompanyRecId = interCompanyMap.lookup(_interCompanyledgerJournalTrans.RecId);
        }
        else
        {
            return null;
        }

        // the current company is the foreign company so switch back to the originating company.
        changecompany(_interCompanyledgerJournalTrans.ForeignCompany)
        {
            // get the LedgerJournalTrans line for the originating company.
            ledgerJournalTransOriginatingCompany = LedgerJournalTrans::findRecId(originatingCompanyRecId, false);

            // Get the tax amount from the originating company.  All taxes are calculated in the originating company
            return this.getNonRecTaxAmtCurForLineList(ledgerJournalTransOriginatingCompany, _signFactor);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNonRecTaxAmtCurIntercoDocList</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the list whose items contain posting type and non recoverable tax amount for the original company for an intercompany document.
    /// </summary>
    /// <param name="_interCompanyledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_company">
    ///    The company ID to restrict the total tax to; optional.
    /// </param>
    /// <param name="_signFactor">
    ///    The factor used to determine the sign of the amount.
    /// </param>
    /// <returns>
    ///   The list whose items contain posting type and non recoverable tax amount in transaction currency.
    /// </returns>
    private List getNonRecTaxAmtCurIntercoDocList(
        LedgerJournalTrans  _interCompanyledgerJournalTrans,
        SelectableDataArea  _company = '',
        Sign                _signFactor = 1)
    {
        RefRecId            originatingCompanyRecId;
        LedgerJournalTrans  ledgerJournalTransOriginatingCompany;
        ledgerJournalTable  ledgerJournalTableOriginatingCompany;

        // Get the RecId for the LedgerJournalTrans line for the originating company.
        if (interCompanyMap.exists(_interCompanyledgerJournalTrans.RecId))
        {
            originatingCompanyRecId = interCompanyMap.lookup(_interCompanyledgerJournalTrans.RecId);
        }
        else
        {
            // return empty list
            return null;
        }

        // the current company is the foreign company so switch back to the originating company.
        changecompany(_interCompanyledgerJournalTrans.ForeignCompany)
        {
            // get the LedgerJournalTrans line for the originating company.
            ledgerJournalTransOriginatingCompany = LedgerJournalTrans::findRecId(originatingCompanyRecId, false);

            ledgerJournalTableOriginatingCompany = ledgerJournalTransOriginatingCompany.ledgerJournalTable();

            // Get the tax amount from the originating company.  All taxes are calculated in the originating company
            return this.getNonRecTaxAmtCurForDocAndVoList(ledgerJournalTableOriginatingCompany, ledgerJournalTransOriginatingCompany.Voucher, _company, _signFactor);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOriginatingLJTFromIntercompanyLJT</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the originating <c>LedgerJournalTrans</c> record for the given
    ///    intercompany <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <param name="_intercompanyRecId">
    ///    The record ID for the intercompany <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    ///    The record ID for the originating <c>LedgerJournalTrans</c> record.
    /// </returns>
    public RefRecId getOriginatingLJTFromIntercompanyLJT(RefRecId _intercompanyRecId)
    {
        RefRecId returnValue;

        if (interCompanyMap.exists(_intercompanyRecId))
        {
            returnValue = interCompanyMap.lookup(_intercompanyRecId);
        }

        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionalTaxAmountForDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax amount for the voucher.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_interCompany">
    /// true if this is an intercompany journal; otherwise, false.
    /// </param>
    /// <param name="_company">
    /// Gets the tax total for a company.
    /// </param>
    /// <returns>
    /// The tax amount for the given voucher.
    /// </returns>
    public TaxAmountCur getTransactionalTaxAmountForDocument(LedgerJournalTrans _ledgerJournalTrans, boolean _interCompany = false, SelectableDataArea _company = '')
    {
        TaxAmountCur        taxAmount;
        boolean             doesTaxAmountExist = true;
        // <GIN>
        #ISOCountryRegionCodes
        TaxUncommitted      taxUncommitted;
        // </GIN>

        if (!_interCompany)
        {
            doesTaxAmountExist = this.doesTaxAmountExist(_ledgerJournalTrans);
        }

        if (_ledgerJournalTrans.TaxCode == '' &&
            doesTaxAmountExist)
        {
            //<GIN>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]) && _ledgerJournalTrans.OffsetLedgerDimension)
            {
                taxAmount = TaxUncommitted::getActualTaxAmountForVoucher(ledgerJournalTable.TableId, ledgerJournalTable.RecId, _ledgerJournalTrans.Voucher, false, _company, _ledgerJournalTrans.RecId, _ledgerJournalTrans.TransDate);
            }
            else
            {
                //</GIN>
                taxAmount = TaxUncommitted::getActualTaxAmountForVoucher(ledgerJournalTable.TableId, ledgerJournalTable.RecId, _ledgerJournalTrans.Voucher, false, _company, 0, _ledgerJournalTrans.TransDate, _ledgerJournalTrans.CurrencyCode, _ledgerJournalTrans.ExchRate);
                //<GIN>
            }
            //</GIN>

            // <GBR>
            if (BrazilParameters::isEnabled())
            {
                taxAmount -= TaxUncommitted::totalTaxAmountRetained_BR(ledgerJournalTable.TableId, ledgerJournalTable.RecId, _ledgerJournalTrans.Voucher);

                if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
                {
                    taxAmount -= TaxUncommitted::totalTaxNotRecoverable_BR(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId);
                }
            }
            // </GBR>
            // <GIN>
            if (TaxParameters::isServiceTaxEnable_IN()
                &&
                    (
                        (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank)
                                                            &&
                        (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
                    )
               )
            {
                select sum(TaxInCostPrice) from taxUncommitted
                    where taxUncommitted.SourceTableId == _ledgerJournalTrans.TableId
                        && taxUncommitted.SourceRecId  == _ledgerJournalTrans.RecId;

                taxAmount -= taxUncommitted.TaxInCostPrice;
            }
            // </GIN>
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionalTaxAmountForLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax amount for the given <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// The tax amount for the given <c>LedgerJournalTrans</c> record.
    /// </returns>
    public TaxAmountCur getTransactionalTaxAmountForLine(LedgerJournalTrans _ledgerJournalTrans)
    {
        // return the tax for whichever side of this line is being processed.
        if (this.doesTaxAmountExist(_ledgerJournalTrans))
        {
            if (this.isInterCompanyLedgerJournalTrans(_ledgerJournalTrans))
            {
                return this.getTransactionalTaxIntercompanyLine(_ledgerJournalTrans);
            }
            else
            {
                return TaxUncommitted::getActualTaxAmountForSourceLineWithCompany(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId, false, true, true, dataAreaIdPost);
            }
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInterCompanyLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value that indicates if the specified journal line is intercompany.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// specified journal line.
    /// </param>
    /// <returns>
    /// true, if the specified journal line is intercompany; otherwise, false.
    /// </returns>
    private boolean isInterCompanyLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans)
    {
        // If the ledger journal trans is on a different journal and contains a foreign voucher, then we know it belongs to foreign company,
        // not the originating company where Tax is calculated.
        return _ledgerJournalTrans.ForeignVoucher != '' && _ledgerJournalTrans.JournalNum != ledgerJournalTable.JournalNum && interCompanyMap.exists(_ledgerJournalTrans.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionalTaxAmountForPaymentFees</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the total tax amount for the voucher for payment fees.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    ///   The tax amount for the given voucher for payment fees.
    /// </returns>
    private TaxAmountCur getTransactionalTaxAmountForPaymentFees(LedgerJournalTrans _ledgerJournalTrans)
    {
        TaxUncommitted      taxUncommitted;
        LedgerJournalTrans  ledgerJournalTransLocal;

        if (_ledgerJournalTrans.TaxCode == '' &&
            this.doesTaxAmountExist(_ledgerJournalTrans))
        {
            select sum(SourceRegulateAmountCur)
            from taxUncommitted
            where taxUncommitted.HeadingTableId == ledgerJournalTable.TableId &&
                  taxUncommitted.HeadingRecId == ledgerJournalTable.RecId &&
                  taxUncommitted.Voucher == _ledgerJournalTrans.Voucher &&
                  taxUncommitted.TaxOrigin != TaxOrigin::Transfer &&
                  taxUncommitted.TaxDirection != TaxDirection::UseTax
            exists join RecId from ledgerJournalTransLocal
            where ledgerJournalTransLocal.TableId == taxUncommitted.SourceTableId &&
                  ledgerJournalTransLocal.RecId == taxUncommitted.SourceRecId &&
                  ledgerJournalTransLocal.TransactionType == LedgerTransType::Fee;
        }

        return taxUncommitted.SourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionalTaxAmountForPrepayment</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This function returns the tax amount for the given voucher and prepayment.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_prePayment">
    ///    true to get a tax amount for <c>LedgerJournalTrans</c> records that are prepayments. false to get a
    ///    tax amount for <c>LedgerJournalTrans</c> records that are not prepayments.
    /// </param>
    /// <returns>
    ///    The tax amount.
    /// </returns>
    public TaxAmountCur getTransactionalTaxAmountForPrepayment(LedgerJournalTrans _ledgerJournalTrans, boolean _prePayment)
    {
        TaxAmountCur        taxAmount;

        if (this.doesTaxAmountExist(_ledgerJournalTrans))
        {
            taxAmount = TaxUncommitted::getActualTaxAmountForPrepayment(_prePayment, ledgerJournalTable.TableId, ledgerJournalTable.RecId, _ledgerJournalTrans.Voucher);
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionalTaxInCostPriceForLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total tax in cost price for the <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record that is being posted.
    /// </param>
    /// <param name="_isInterCompanyTrans">
    /// Boolean indicating if this the passed in <c>ledgerJournalTrans</c> is from intercompany.
    /// </param>
    /// <returns>
    /// The total tax in cost price.
    /// </returns>
    public TaxAmountCur getTransactionalTaxInCostPriceForLine(LedgerJournalTrans _ledgerJournalTrans, boolean _isInterCompanyTrans = false)
    {
        TaxAmountCur taxInCostPriceForLine;
        RefRecId originatingCompanyRecId;
        LedgerJournalTrans ledgerJournalTransOriginatingCompany;

        if (_isInterCompanyTrans)
        {
            if (interCompanyMap.exists(_ledgerJournalTrans.RecId))
            {
                originatingCompanyRecId = interCompanyMap.lookup(_ledgerJournalTrans.RecId);

                changecompany(_ledgerJournalTrans.ForeignCompany)
                {
                    ledgerJournalTransOriginatingCompany = LedgerJournalTrans::findRecId(originatingCompanyRecId, false);
                    taxInCostPriceForLine = TaxUncommitted::getActualTaxInCostPriceForSourceLine(ledgerJournalTransOriginatingCompany.TableId, ledgerJournalTransOriginatingCompany.RecId);
                }
            }
        }
        else
    {
            taxInCostPriceForLine = TaxUncommitted::getActualTaxInCostPriceForSourceLine(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId);
        }

        return taxInCostPriceForLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionalTaxIntercompanyDocument</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the tax amount for the original company for an intercompany document.
    /// </summary>
    /// <param name="_interCompanyledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_company">
    ///    The company ID to restrict the total tax to; optional.
    /// </param>
    /// <returns>
    ///   The tax amount for the intercompany document.
    /// </returns>
    private TaxAmountCur getTransactionalTaxIntercompanyDocument(LedgerJournalTrans _interCompanyledgerJournalTrans, SelectableDataArea _company = '')
    {
        RefRecId            originatingCompanyRecId;
        LedgerJournalTrans  ledgerJournalTransOriginatingCompany;

        // Get the RecId for the LedgerJournalTrans line for the originating company.
        if (interCompanyMap.exists(_interCompanyledgerJournalTrans.RecId))
        {
            originatingCompanyRecId = interCompanyMap.lookup(_interCompanyledgerJournalTrans.RecId);
        }
        else
        {
            return 0;
        }

        // the current company is the foreign company so switch back to the originating company.
        changecompany(_interCompanyledgerJournalTrans.ForeignCompany)
        {
            // get the LedgerJournalTrans line for the originating company.
            ledgerJournalTransOriginatingCompany = LedgerJournalTrans::findRecId(originatingCompanyRecId, false);

            // Get the tax amount from the originating company.  All taxes are calculated in the originating company
            return this.getTransactionalTaxAmountForDocument(ledgerJournalTransOriginatingCompany, true, _company);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionalTaxIntercompanyLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the tax amount for an intercompany line.
    /// </summary>
    /// <param name="_interCompanyledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_dataArearId">
    ///    The data area id.
    /// </param>
    /// <returns>
    ///    The tax amount for the intercompany <c>LedgerJournalTrans</c> record.
    /// </returns>
    private TaxAmountCur getTransactionalTaxIntercompanyLine(LedgerJournalTrans _interCompanyledgerJournalTrans, DataAreaId _dataArearId = dataAreaIdPost)
    {
        RefRecId            originatingCompanyRecId;
        LedgerJournalTrans  ledgerJournalTransOriginatingCompany;

        // Get the RecId for the LedgerJournalTrans line for the originating company.
        if (interCompanyMap.exists(_interCompanyledgerJournalTrans.RecId))
        {
            originatingCompanyRecId = interCompanyMap.lookup(_interCompanyledgerJournalTrans.RecId);
        }
        else
        {
            return 0;
        }

        // the current company is the foreign company so switch back to the originating company.
        changecompany(_interCompanyledgerJournalTrans.ForeignCompany)
        {
            // get the LedgerJournalTrans line for the originating company.
            ledgerJournalTransOriginatingCompany = LedgerJournalTrans::findRecId(originatingCompanyRecId, false);

            DataAreaId dataAreaId = '';

            if (_dataArearId)
            {
                dataAreaId = (ledgerJournalTable.LedgerJournalInclTax == NoYes::Yes) ? '' : _dataArearId;
            }

            // Get the tax amount from the originating company.  All taxes are calculated in the originating company
            return TaxUncommitted::getActualTaxAmountForSourceLineWithCompany(ledgerJournalTransOriginatingCompany.TableId, ledgerJournalTransOriginatingCompany.RecId, false, true, true, dataAreaId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransTaxAmountForDocLessPaymFees</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets the tax amount for the voucher minus any taxes on payment fees.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    ///   The tax amount for the given voucher less tax on payment fees.
    /// </returns>
    private TaxAmountCur getTransTaxAmountForDocLessPaymFees(LedgerJournalTrans _ledgerJournalTrans)
    {
        TaxUncommitted      taxUncommitted;
        LedgerJournalTrans  ledgerJournalTransLocal;

        if (_ledgerJournalTrans.TaxCode == '' &&
            this.doesTaxAmountExist(_ledgerJournalTrans))
        {
            select sum(SourceRegulateAmountCur) from taxUncommitted
                where taxUncommitted.HeadingTableId == ledgerJournalTable.TableId &&
                  taxUncommitted.HeadingRecId == ledgerJournalTable.RecId &&
                  taxUncommitted.Voucher == _ledgerJournalTrans.Voucher &&
                  taxUncommitted.TaxOrigin != TaxOrigin::Transfer &&
                  taxUncommitted.TaxDirection != TaxDirection::UseTax
            exists join ledgerJournalTransLocal
                where ledgerJournalTransLocal.TableId == taxUncommitted.SourceTableId &&
                  ledgerJournalTransLocal.RecId == taxUncommitted.SourceRecId &&
                  ledgerJournalTransLocal.TransactionType != LedgerTransType::Fee;
        }

        return taxUncommitted.SourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTrxNonRecoverableVATAmountForDoc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total tax in cost price for the <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record that is being posted.
    /// </param>
    /// <returns>
    /// The total tax in cost price.
    /// </returns>
    public TaxAmountCur getTrxNonRecoverableVATAmountForDoc(LedgerJournalTrans _ledgerJournalTrans)
    {
        return TaxUncommitted::getActualNonRecoverableVATAmtForDocAndVo(ledgerJournalTable.TableId, ledgerJournalTable.RecId, _ledgerjournalTrans.Voucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBankVendor_IN</Name>
				<Source><![CDATA[
    private boolean isBankVendor_IN(LedgerJournalTrans    _ledgerJournalTrans)
    {
        boolean bankVendor = false;

        if (TaxParameters::checkTaxParameters_IN())
        {
            if (((_ledgerJournalTrans.AccountType         == LedgerJournalACType::Bank        ||
                _ledgerJournalTrans.AccountType          == LedgerJournalACType::Vend)       &&
               (_ledgerJournalTrans.OffsetAccountType    == LedgerJournalACType::Vend        ||
                _ledgerJournalTrans.OffsetAccountType    == LedgerJournalACType::Bank))      ||
               ((_ledgerJournalTrans.AccountType         == LedgerJournalACType::Bank        ||
                _ledgerJournalTrans.AccountType          == LedgerJournalACType::Cust)       &&
               (_ledgerJournalTrans.OffsetAccountType    == LedgerJournalACType::Cust        ||
                _ledgerJournalTrans.OffsetAccountType    == LedgerJournalACType::Bank)))
            {
                bankVendor = true;
            }
        }

        return bankVendor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOriginatingJournalTaxOnly</Name>
				<Source><![CDATA[
    private boolean isOriginatingJournalTaxOnly(LedgerJournalTrans _intercompanyLedgerJournalTrans)
    {
        LedgerJournalTrans originatingLedgerJournalTrans;

        changeCompany(_intercompanyLedgerJournalTrans.ForeignCompany)
        {
            originatingLedgerJournalTrans = LedgerJournalTrans::findRecId(this.getOriginatingLJTFromIntercompanyLJT(_intercompanyLedgerJournalTrans.RecId), false);

            return originatingLedgerJournalTrans.TaxCode != '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveTaxForeignKeyToTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates all <c>TaxTransGeneralJournalAccountEntry</c> records with a foreign key to the table <c>TaxTrans</c>
    /// removing the foreign key to the table <c>TaxUncommitted</c>.
    /// </summary>
    public void moveTaxForeignKeyToTaxTrans()
    {
        if (taxObligation == TaxObligationCompany::Source)
        {
            select firstOnly crossCompany taxUncommittedTaxTransTmp;
            if (taxUncommittedTaxTransTmp.Company)
            {
                changeCompany (taxUncommittedTaxTransTmp.Company)
                {
                    TaxTransGeneralJournalAccountEntry::moveTaxForeignKeyToTaxTrans(taxUncommittedTaxTransTmp);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new(LedgerJournalTable _ledgerJournalTable)
    {
        asset2CustVendTransMap = new Map(Types::Container, Types::Enum);

        interCompanyMap = new Map(typeName2Type(extendedtypestr(RefRecId)), typeName2Type(extendedtypestr(RefRecId)));
        taxUncommittedCheckedForTaxAmounts = false;
        taxAmountsExistForDocument = false;
        // The offsetForTotalTaxAmountAllocatedByVoucherMap replaces offsetForTotalTaxAmountAllocated to store offsetForTotalTaxAmountAllocated by voucher.
        // The value of offsetForTotalTaxAmountAllocated is set for each voucher in the first loop in LedgerJournalCheckPost.postJournalLines().
        // Then the value is validated by voucher in TaxVoucherService.postTaxOnErrorAccount() in the second loop.
        // But the two loops are separated, so we store offsetForTotalTaxAmountAllocated here by voucher.
        if (taxInterruptOfErrorAccountForMultiVoucherFlightEnabled)
        {
            offsetForTotalTaxAmountAllocatedByVoucherMap = new Map(Types::String, Types::Integer);
        }

        offsetForTotalTaxAmountAllocated = false;

        vendCustExistsForVoucher = false;
        vendCustExistsForVoucherChecked = false;
        intercompanyCustVendBank = false;

        ledgerJournalTable = _ledgerJournalTable;

        taxObligation = ledgerJournalTable.TaxObligationCompany;

         // <GIN>
        isIndiaTaxEnabled = TaxParameters::checkTaxParameters_IN();
        if (isIndiaTaxEnabled)
        {
            priceInclTaxAmountMap   = new Map(typeName2Type(extendedtypestr(String30)), typeName2Type(extendedtypestr(AmountCur)));
            serviceTaxAmountMap     = new Map(typeName2Type(extendedtypestr(String30)), typeName2Type(extendedtypestr(AmountCur)));
        }
        // </GIN>
        
        if (!LedgerParameters::find().AbortErrorAccount)
        {
            postTaxOnErrorAccount = true;
        }

        loggedInCompany = curext();
    }

]]></Source>
			</Method>
			<Method>
				<Name>operationAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>LedgerDimensionAccount</c> operation for the <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// The <c>LedgerDimensionAccount</c> operation.
    /// </returns>
    public LedgerDimensionAccount operationAccount(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTaxLine ledgerJournalTaxLine;
        LedgerJournalTaxDocument ledgerJournalTaxDocument;
        TaxCalculation           taxCalculation;

        ledgerJournalTaxDocument = LedgerJournalTaxDocument::constructForPosting(ledgerJournalTable.JournalNum, '');

        ledgerJournalTaxLine = ledgerJournalTaxDocument.getLineByLedgerJournalTrans(
            _ledgerJournalTrans,
            ledgerJournalTaxDocument.getTaxOnPrepayment()) as LedgerJournalTaxLine;

        taxCalculation = taxCalculation::newForSourceType(TaxSourceType::Journals, ledgerJournalTaxDocument);

        return ledgerJournalTaxLine.findOperationsAccount(taxCalculation.getCompany());
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInterCompanyTaxBase_IN</Name>
				<Source><![CDATA[
    public Amount parmInterCompanyTaxBase_IN(Amount _interCompanyTaxBase = interCompanyTaxBase)
    {
        interCompanyTaxBase = _interCompanyTaxBase;
        return interCompanyTaxBase;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsformulaDefined_IN</Name>
				<Source><![CDATA[
    public boolean parmIsformulaDefined_IN(boolean _isformulaDefined = isformulaDefined)
    {
        isformulaDefined = _isformulaDefined;
        return isformulaDefined;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsInclusiveTax_IN</Name>
				<Source><![CDATA[
    public boolean parmIsInclusiveTax_IN(boolean _isInclusiveTax = isInclusiveTax)
    {
        isInclusiveTax = _isInclusiveTax;
        return isInclusiveTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsInterCompanyTrans_IN</Name>
				<Source><![CDATA[
    public boolean parmIsInterCompanyTrans_IN(boolean _isInterCompanyTrans = isInterCompanyTrans)
    {
        isInterCompanyTrans = _isInterCompanyTrans;
        return isInterCompanyTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsLedgerLedger_IN</Name>
				<Source><![CDATA[
    public boolean parmIsLedgerLedger_IN(boolean _isLedgerLedger = isLedgerLedger)
    {
        isLedgerLedger = _isLedgerLedger;

        return isLedgerLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLoggedInCompany_IN</Name>
				<Source><![CDATA[
    public CompanyId parmLoggedInCompany_IN(CompanyId _loggedInCompany = loggedInCompany)
    {
        loggedInCompany = _loggedInCompany;

        return loggedInCompany;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxObligationCompany</Name>
				<Source><![CDATA[
    public TaxObligationCompany parmTaxObligationCompany(TaxObligationCompany _taxObligationCompany = taxObligation)
    {
        taxObligation = _taxObligationCompany;

        return taxObligation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>post</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method will post all of the tax amounts for the journal.
    /// </summary>
    /// <param name="_ledgerPostingController">
    ///    The ledger posting controller to use for ledger posting.
    /// </param>
    /// <remarks>
    ///    This will cause ledger postings to be created for the tax amounts.Also, the <c>TaxTrans</c> records
    ///    will be created.This should not be used to post intercompany taxes.
    /// </remarks>
    public void post(LedgerPostingController _ledgerPostingController)
    {
        TaxAmountCur        postedTaxAmount;
        LedgerJournalTaxDocument    ledgerJournalTaxDocument;

        ledgerJournalTaxDocument = LedgerJournalTaxDocument::constructForPosting(ledgerJournalTable.JournalNum, '');

        taxPost = TaxPost::newForSourceType(TaxSourceType::Journals, ledgerJournalTaxDocument, NoYes::Yes);

        taxPost.parmEnableTaxUncommittedToTaxTransTmp(taxObligation == TaxObligationCompany::Source);

        postedTaxAmount = taxPost.updateAndPost(_ledgerPostingController, ledgerJournalTable.dataAreaId);

        // if set to source, only one company gets all the tax.  We need the DB Temp table
        // from whichever company posts the tax.
        if (postedTaxAmount != 0 && taxObligation == TaxObligationCompany::Source)
        {
            taxUncommittedTaxTransTmp.linkPhysicalTableInstance(taxPost.getTaxUncommittedTaxTransTmp());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postIntercompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method will post all of the tax amounts for the intercompany journal.
    /// </summary>
    /// <param name="_ledgerPostingController">
    ///    The ledger posting controller to use for ledger posting.
    /// </param>
    /// <param name="_intercompanyJournalNum">
    ///    The intercompany journal number.
    /// </param>
    /// <param name="_intercompanyVoucher">
    ///    The intercompany voucher.
    /// </param>
    /// <remarks>
    ///    This will cause ledger transactions distributions to be created for the tax amounts.Also, the
    ///    <c>TaxTrans</c> records will be created.This should be used to post intercompany tax only.
    /// </remarks>
    public void postIntercompany(LedgerPostingController _ledgerPostingController, JournalId _intercompanyJournalNum, Voucher _intercompanyVoucher)
    {
        LedgerJournalTaxDocument    ledgerJournalTaxDocument;
        TaxAmountCur                postedTaxAmount;

        ledgerJournalTaxDocument = LedgerJournalTaxDocument::constructForPosting(_intercompanyJournalNum, _intercompanyVoucher);
        ledgerJournalTaxDocument.parmIntercompanyJournal(true);
        ledgerJournalTaxDocument.parmIntercompanyMap(interCompanyMap);

        taxPost = TaxPost::newForSourceType(TaxSourceType::Journals, ledgerJournalTaxDocument, NoYes::Yes);

        taxPost.parmEnableTaxUncommittedToTaxTransTmp(taxObligation == TaxObligationCompany::Source);

        changecompany (loggedInCompany)
        {
            postedTaxAmount = taxPost.updateAndPost(_ledgerPostingController, ledgerJournalTaxDocument.getSourceHeader().dataAreaId);
            dataAreaIdPost = taxPost.parmDataAreaIdPost();

            if (postedTaxAmount != 0 && taxObligation == TaxObligationCompany::Source)
            {
                taxUncommittedTaxTransTmp = taxPost.getTaxUncommittedTaxTransTmp();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxAmountForLedgerType_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defines specifics parameters for Localizarion BR. It is a subscriber to event <c>postTaxAmountForLedgerTypeHandler_BR</c> in <c>taxAmountForLedgerType</c> method.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> passed by the method <c>taxAmountForLedgerType</c>.
    /// </param>
    /// <param name="_isOffset">
    /// The is off set passed by the method <c>taxAmountForLedgerType</c>.
    /// </param>
    /// <param name="_interCompany">
    /// A boolean
    /// </param>
    /// <param name="_returnValue">
    /// Value returned by <c>taxAmountForLedgerType</c> method.
    /// </param>
    /// <returns>
    /// The tax amount for the ledger account.
    /// </returns>
    public TaxAmount postTaxAmountForLedgerType_BR(
        LedgerJournalTrans _ledgerJournalTrans,
        boolean _isOffset,
        boolean _interCompany,
        TaxAmount _returnValue)
    {
        TaxAmount taxAmount = _returnValue;

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
        {
            taxAmount = TaxUncommitted::taxInSalesRevenueForSourceLine_BR(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId);
        }

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
        {
            taxAmount = TaxUncommitted::taxInCostPrice_BR(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId);
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxOnErrorAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts the offset for the total tax amount for the voucher to the error account.
    /// </summary>
    /// <param name="_ledgerVoucher">
    ///    The <c>LedgerVoucher</c> object.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher.
    /// </param>
    /// <param name="_sourceCurrencyCode">
    ///    The transactional currency code.
    /// </param>
    /// <param name="_transDate">
    ///    The transaction date.
    /// </param>
    public void postTaxOnErrorAccount(LedgerVoucher _ledgerVoucher, Voucher _voucher, CurrencyCode _sourceCurrencyCode, TransDate _transDate = dateNull())
    {
        CurrencyExchangeHelper exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), _ledgerVoucher.findLedgerVoucherObject().parmAccountingDate());
        TaxAmountCur taxAmountCur;
        TaxAmountCur postedTaxAmount;

        if (!ledgerJournalTable.isTaxSupported())
        {
            return;
        }

        if (postTaxOnErrorAccount)
        {
            postedTaxAmount = Tax::taxTotalVoucherDate(_voucher, _transDate);

            if (!postedTaxAmount)
            {
                taxAmountCur = -TaxUncommitted::getActualTaxAmountForVoucher(ledgerJournalTable.TableId, ledgerJournalTable.RecId, _voucher, false, curext(), 0, _transDate);
                if (this.canPostTransOnErrorAccount(taxAmountCur))
                {
                _ledgerVoucher.addTrans(
                        LedgerVoucherTransObject::newTransactionAmountDefault(
                       _ledgerVoucher.findLedgerVoucherObject(),
                        LedgerPostingType::Tax,
                        LedgerSystemAccounts::find(LedgerPostingType::ErrorAccount).LedgerDimension,
                        _sourceCurrencyCode,
                        taxAmountCur,
                        exchangeRateHelper));
                }
            }
        }
        else if (!this.getOffsetForTotalTaxAmountAllocatedByVoucher(_voucher))
        {
            postedTaxAmount = Tax::taxTotalVoucherDate(_voucher, _transDate);

            if (!postedTaxAmount)
            {
                taxAmountCur = -TaxUncommitted::getActualTaxAmountForVoucher(ledgerJournalTable.TableId, ledgerJournalTable.RecId, _voucher, false, '', 0, _transDate);

                if (taxAmountCur)
                {
                    throw error("@SYS68017");
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postWithholdIntercompany_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method will post tax amounts for both ledger entires and taxwithholdtrans for the intercompany journal.
    /// </summary>
    /// <param name="_ledgerPostingController">
    ///    The ledger posting controller to use for ledger posting.
    /// </param>
    /// <param name="_intercompanyJournalNum">
    ///    The intercompany journal number.
    /// </param>
    /// <param name="_voucherInterCompany">
    ///    The intercompany voucher.
    /// </param>
    /// <param name="_paymentCompanyId">
    ///    The payment company Id.
    /// </param>
    /// <param name="_cpOrigRefRecId">
    ///    The original trans <c>refrecid</c> for centrailized payment
    /// </param>
    /// <param name="_voucherSettle">
    ///    The settle voucher from invoice company which is used for WHT direct settle
    /// </param>
    /// <returns>
    ///     The posted tax amounts for the intercompany journal.
    /// </returns>
    /// <remarks>
    ///    This will cause ledger transactions distributions to be created for the tax amounts.Also, the
    ///    <c>TaxTrans</c> records will be created.This should be used to post intercompany tax only.
    /// </remarks>
    public TaxWithholdAmountCur postWithholdIntercompany_IN(
        LedgerPostingController _ledgerPostingController,
        JournalId               _intercompanyJournalNum,
        Voucher                 _voucherInterCompany,
        CompanyId               _paymentCompanyId,
        RefRecId                _cpOrigRefRecId = 0,
        Voucher                 _voucherSettle = '')
    {
        TaxWithholdPost_IN              taxWithholdPost;
        LedgerJournalTaxDocument        ledgerJournalTaxDocument;

        ledgerJournalTaxDocument = LedgerJournalTaxDocument::constructForPosting(_intercompanyJournalNum, '');

        if (_paymentCompanyId != loggedInCompany)
        {
            ledgerJournalTaxDocument.updateLedgerJournalTableForInterWHT_IN(_intercompanyJournalNum);
        }

        ledgerJournalTaxDocument.parmIntercompanyJournal(true);
        taxWithholdPost = TaxWithholdPost_IN::newForSourceType(TaxSourceType::Journals, ledgerJournalTaxDocument, NoYes::Yes);
        taxWithholdPost.setInvoiceCompany();
        taxWithholdPost.setPaymentCompany(_paymentCompanyId);
        taxWithholdPost.setVoucherInterCompany(_voucherInterCompany);
        taxWithholdPost.setCPOrigRefRecid(_cpOrigRefRecId);
        taxWithholdPost.setVoucherSettle(_voucherSettle);

        changecompany (loggedInCompany)
        {
            withholdTaxAmountCur = taxWithholdPost.updateAndPost(_ledgerPostingController);
        }
        return withholdTaxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postWithholdTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method will post all of the withhold tax amounts for the journal.
    /// </summary>
    /// <param name="_ledgerPostingController">
    ///    The ledger posting controller to use for ledger posting.
    /// </param>
    /// <remarks>
    ///    This will cause ledger postings to be created for the withhold tax amounts.Also, the <c>TaxWithholdTrans</c> records
    ///    will be created.This should not be used to post intercompany taxes.
    /// </remarks>
    public void postWithholdTax_IN(LedgerPostingController _ledgerPostingController)
    {
        TaxWithholdPost_IN          taxWithholdPost;
        LedgerJournalTaxDocument    ledgerJournalTaxDocument;

        ledgerJournalTaxDocument = LedgerJournalTaxDocument::constructForPosting(ledgerJournalTable.JournalNum, '');
        taxWithholdPost = TaxWithholdPost_IN::newForSourceType(TaxSourceType::Journals, ledgerJournalTaxDocument, NoYes::Yes);
        taxWithholdPost.updateAndPost(_ledgerPostingController);
    }

]]></Source>
			</Method>
			<Method>
				<Name>priceInclTaxAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the price incl tax amount.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal transaction.
    /// </param>
    /// <param name="_isOffset">
    /// The check of the offset.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxAmountCur</c> class.
    /// </returns>
    public TaxAmountCur priceInclTaxAmount_IN(LedgerJournalTrans _ledgerJournalTrans, boolean _isOffset = false)
    {
        TaxAmountCur taxAmountCur;

        taxAmountCur = TaxVoucherService::priceInclTaxAmountCalculated_IN(_ledgerJournalTrans.RecId, _ledgerJournalTrans.TableId);

        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountCurForLine_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///   This function returns the tax amount for the given line.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The LedgerJournalTrans line being posted.
    /// </param>
    /// <param name="_isOffset">
    ///    False if the primary side of the LedgerJournalTrans line is being posted.  True if the
    ///    Offset is being posted.
    /// </param>
    /// <returns>
    ///   The tax amount for the given LedgerJournalTransLine.
    /// </returns>
    public TaxAmountCur taxAmountCurForLine_IN(LedgerJournalTrans _ledgerJournalTrans, boolean _isOffset)
    {
        // return the tax for whichever side of this line is being processed.
        return this.getTransactionalTaxAmountForLine(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountForAssetType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax amount for the <c>LedgerJournalTrans</c> record of type fixed assets that is being
    /// posted to.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record that is being posted.
    /// </param>
    /// <param name="_interCompany">
    /// Boolean indicating if we are processing from an company other than logged in company.
    /// </param>
    /// <returns>
    /// The tax amount for the <c>LedgerJournalTrans</c> record with type fixed assets.
    /// </returns>
    public TaxAmount taxAmountForAssetType(LedgerJournalTrans _ledgerJournalTrans, boolean _interCompany = false)
    {
        RefRecId originatingCompanyRecId;
        LedgerJournalTrans ledgerJournalTrans;
        SelectableDataArea company;

        if (!ledgerJournalTable.LedgerJournalInclTax)
        {
            return 0;
        }

        if (_interCompany)
        {
            if (interCompanyMap.exists(_ledgerJournalTrans.RecId))
            {
                originatingCompanyRecId = interCompanyMap.lookup(_ledgerJournalTrans.RecId);
            }
            else
            {
                return 0;
            }

            company = _ledgerJournalTrans.ForeignCompany;

            changecompany(company)
                {
                ledgerJournalTrans = LedgerJournalTrans::findRecId(originatingCompanyRecId, false);
                }
            }
            else
            {
            ledgerJournalTrans = _ledgerJournalTrans;
            company = loggedInCompany;
        }

        return this.getTaxAmountForAssetType(ledgerJournalTrans, company, _interCompany);
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountForBankType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets tax amount for the <c>LedgerJournalTrans</c> record of type bank that is being posted to.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record that is being posted.
    /// </param>
    /// <param name="_interCompany">
    /// true if this is an intercompany journal; otherwise, false.
    /// </param>
    /// <param name="_posting">
    /// The posting type.
    /// </param>
    /// <param name="_dueToDueFromAccount">
    /// true if this is a due to or due from account; otherwise, false.
    /// </param>
    /// <returns>
    /// The tax amount for the <c>LedgerJournalTrans</c> record with type bank.
    /// </returns>
    public TaxAmount taxAmountForBankType(LedgerJournalTrans _ledgerJournalTrans, boolean _interCompany, LedgerPostingType _posting, boolean _dueToDueFromAccount)
    {
        TaxAmount taxAmount;

        if (!this.doesTaxAmountExist(_ledgerJournalTrans) && !_interCompany)
        {
            return 0;
        }

        // Vendor/Customer always is higher priority than Bank for determining where the offset of
        // the total tax amount should get allocated to.  If Vendor/Customer is not
        // found, then the offset of the total tax amount will get allocated to this
        // Bank line.
        if (((!this.checkIfVendCustExistsForDocument(_ledgerJournalTrans)) &&
            !ledgerJournalTable.LedgerJournalInclTax &&
            !this.getOffsetForTotalTaxAmountAllocatedByVoucher(_ledgerJournalTrans.Voucher)) &&
            (taxObligation == TaxObligationCompany::Destination ||
             taxObligationSourceCompany == curext()))
        {
            if (_interCompany)
            {
                taxAmount = -this.getTransactionalTaxIntercompanyDocument(_ledgerJournalTrans, dataAreaIdPost);
                intercompanyCustVendBank = true;
            }
            else
            {
                taxAmount = -this.getTransactionalTaxAmountForDocument(_ledgerJournalTrans, false, dataAreaIdPost);
            }
        }

        if (!_interCompany &&
            _dueToDueFromAccount &&
            !this.getOffsetForTotalTaxAmountAllocatedByVoucher(_ledgerJournalTrans.Voucher))
        {
            if (!intercompanyCustVendBank)
            {
                originalTaxObligationSourceRecord = _ledgerJournalTrans.RecId;
            }

            intercompanyCustVendBank = true;
        }

        if (!this.checkIfVendCustExistsForDocument(_ledgerJournalTrans))
        {
            this.setOffsetForTotalTaxAmountAllocatedByVoucher(_ledgerJournalTrans.Voucher, true);
        }

        // tax on payment fees get allocated to the bank amount.
        if (!paymentFeeTaxAllocated &&
            !ledgerJournalTable.LedgerJournalInclTax &&
             _ledgerJournalTrans.TransactionType == LedgerTransType::Fee &&
             this.doesTaxOnPaymentFeeExist(_ledgerJournalTrans.Voucher, _ledgerJournalTrans.JournalNum))
        {
            taxAmount = -this.getTransactionalTaxAmountForPaymentFees(_ledgerJournalTrans);
            paymentFeeTaxAllocated = true;
        }

        // This must run after the code above so that the state is updated properly before we return
        if (_dueToDueFromAccount &&
            _posting == LedgerPostingType::InterCompany &&
            taxObligation == TaxObligationCompany::Source &&
            !ledgerJournalTable.LedgerJournalInclTax)
        {
            // Since cust/vend is in the intercompany journal don't allocate the tax.
            taxAmount = 0;
        }

        if (_dueToDueFromAccount &&
            _posting == LedgerPostingType::InterCompany &&
            taxObligation == TaxObligationCompany::Source &&
            ledgerJournalTable.LedgerJournalInclTax)
        {
            taxAmount = this.getTransactionalTaxAmountForDocument(_ledgerJournalTrans, false, dataAreaIdPost);
        }

        if (intercompanyCustVendBank
            && _dueToDueFromAccount
            && _posting == LedgerPostingType::InterCompany
            && ledgerJournalTable.TaxObligationCompany == TaxObligationCompany::Source)
        {
            if (!_interCompany)
            {
                taxAmount += this.getNonRecoverableVATForDestinationCo(_ledgerJournalTrans, curext());
            }
            else
            {
                taxAmount += -this.getTrxNonRecoverableVATAmountForDoc(_ledgerJournalTrans);
            }
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountForLedgerType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax amount for an account type of a ledger line.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> to post.
    /// </param>
    /// <param name="_isOffset">
    /// A Boolean value that indicates whether the offset is posted.
    /// </param>
    /// <param name="_interCompany">
    /// true if this is an intercompany journal; otherwise, false.
    /// </param>
    /// <param name="_dueToDueFromAccount">
    /// true if this is a due to or due from account; otherwise, false.
    /// </param>
    /// <returns>
    /// The tax amount for the ledger account.
    /// </returns>
    /// <remarks>
    /// When the normal account that is found on the original <c>LedgerJournalTrans</c> record is not used,
    /// a special account such as the due to or due from accounts is used.
    /// </remarks>
    [Replaceable(true)]
    public TaxAmount taxAmountForLedgerType(LedgerJournalTrans _ledgerJournalTrans, boolean _isOffset, boolean _interCompany, boolean _dueToDueFromAccount)
    {
        TaxAmount taxAmount;
        boolean skipErrorCheck = false;
        boolean prePayment;
        boolean taxOnCustPrepayment;
        boolean taxOnVendPrepayment;
        LedgerJournalACType accountType;
        TaxObligationCompany taxObligationLocal;
        LedgerJournalTrans originalLedgerJournalTrans;

        // <GIN>
        boolean isPriceIncluded;
        // </GIN>

        if (!this.doesTaxAmountExist(_ledgerJournalTrans) && !_interCompany)
        {
            return 0;
        }

        // When TaxObligation is Source then the due to/due from will not contain tax
        // so only leave the tax included if destination.
        if (taxObligation == TaxObligationCompany::Destination)
        {
            // if this amount is for another company then any tax amounts associated with
            // this amount do not apply.
            if (!_isOffset && _ledgerJournalTrans.Company && _ledgerJournalTrans.Company != curext())
            {
                if (ledgerJournalTable.LedgerJournalInclTax)
                {
                    return 0;
                }
            }

            if (_isOffset && _ledgerJournalTrans.OffsetCompany && _ledgerJournalTrans.OffsetCompany != curext())
            {
                if (ledgerJournalTable.LedgerJournalInclTax)
                {
                    return 0;
                }
            }
        }

        // Default prepayment to false unless conditions are met as specified below
        prePayment = false;

        if (_ledgerJournalTrans.Prepayment)
        {
            // Lookup of cust and vend parameters is much less costly than determining
            // account type, so first look up both those values to determine if they
            // are both false
            taxOnCustPrepayment = CustParameters::find().TaxOnPrepayment;
            taxOnVendPrepayment = VendParameters::find().TaxOnPrepayment;

            // If they are both false, then no need to determine account type since the result is false
            if (taxOnCustPrepayment || taxOnVendPrepayment)
            {
                accountType = _ledgerJournalTrans.displayMainAccountType();

                if (accountType == LedgerJournalACType::Cust)
                {
                    prePayment = taxOnCustPrepayment;
                }
                else if (accountType == LedgerJournalACType::Vend)
                {
                    prePayment = taxOnVendPrepayment;
                }
            }
        }

        // it is preferable that the tax on a payment fee get allocated to bank, but if no bank
        // transaction is present then it can be allocated to a Ledger account type.
        if ((!prePayment ||
                _ledgerJournalTrans.TransactionType == LedgerTransType::Fee) &&
                !_ledgerJournalTrans.Cancel && !_interCompany)
        {
            // if this is a ledger to ledger scenario we need to get the tax amount for the proper account.
            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger &&
                _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
            {
                if (((ledgerJournalTable.LedgerJournalInclTax &&
                     !_isOffset) ||
                     (!ledgerJournalTable.LedgerJournalInclTax &&
                     _isOffset)) &&
                    this.doesTaxAmountExist(_ledgerJournalTrans))

                {
                    taxAmount = this.getTransactionalTaxAmountForLine(_ledgerJournalTrans);
                }
            }
            else if (ledgerJournalTable.LedgerJournalInclTax && !(_ledgerJournalTrans.isOffsetCompanyIntercompany() && _isOffset))
            {
                if (_ledgerJournalTrans.canAccountTypeBeTaxed(LedgerJournalACType::Ledger))
                {
                    taxAmount = this.getTransactionalTaxAmountForLine(_ledgerJournalTrans);
                }
            }
        }

        if (_interCompany)
        {
            if ((_dueToDueFromAccount &&
                (taxObligation == TaxObligationCompany::Destination &&
                !ledgerJournalTable.LedgerJournalInclTax) ||
                (taxObligation == TaxObligationCompany::Source &&
                ledgerJournalTable.LedgerJournalInclTax) &&
                !this.isOriginatingJournalTaxOnly(_ledgerJournalTrans)))
            {
                int sign = 0;
                if (_ledgerJournalTrans.AmountCurDebit > 0 || _ledgerJournalTrans.AmountCurCredit < 0)
                {
                    sign = -1;
                }
                else if (_ledgerJournalTrans.AmountCurCredit > 0 || _ledgerJournalTrans.AmountCurDebit < 0)
                {
                    sign = 1;
                }

                if (sign != 0)
                {
                    if (this.shouldRestrictCompanyIdWhenGetTaxAmountForLedgerType(_ledgerJournalTrans, _dueToDueFromAccount, sign))
                    {
                        taxAmount = abs(this.getTransactionalTaxIntercompanyLine(_ledgerJournalTrans, '')) * sign;
                    }
                    else
                    {
                        taxAmount = abs(this.getTransactionalTaxIntercompanyLine(_ledgerJournalTrans)) * sign;
                    }

                    if (!this.getTaxUncommittedExistForIntercompLine(_ledgerJournalTrans))
                    {
                        if (!taxAmount && intercompanyCustVendBank)
                        {
                            changeCompany (_ledgerJournalTrans.ForeignCompany)
                            {
                                originalLedgerJournalTrans = LedgerJournalTrans::findRecId(this.getOriginatingLJTFromIntercompanyLJT(_ledgerJournalTrans.RecId), false);
                            }

                            if (originalLedgerJournalTrans.AccountType != LedgerJournalACType::Ledger
                                || originalLedgerJournalTrans.OffsetAccountType != LedgerJournalACType::Ledger)
                            {
                                if (this.shouldRestrictCompanyIdWhenGetTaxAmountForLedgerType(_ledgerJournalTrans, _dueToDueFromAccount, sign))
                                {
                                    taxAmount = abs(this.getTransactionalTaxIntercompanyDocument(_ledgerJournalTrans, '')) * sign;
                                }
                                else
                                {
                                    taxAmount = abs(this.getTransactionalTaxIntercompanyDocument(_ledgerJournalTrans, dataAreaIdPost)) * sign;
                                }
                            }
                        }
                        else if (!taxAmount && !intercompanyCustVendBank)
                        {
                            if (this.checkIfVendCustExistsInOrigJournal(_ledgerJournalTrans))
                            {
                                taxAmount = abs(this.getTransactionalTaxIntercompanyDocument(_ledgerJournalTrans, curext())) * sign;
                            }
                            else
                            {
                                taxAmount = abs(this.getTransactionalTaxIntercompanyDocument(_ledgerJournalTrans, dataAreaIdPost)) * sign;
                            }
                        }
                    }
                }

                // if tax included in item price then we need to subtract out the tax instead of adding it in
                if (ledgerJournalTable.LedgerJournalInclTax
                    && (taxObligation == TaxObligationCompany::Source
                    || (taxObligation == TaxObligationCompany::Destination
                    &&  this.doesTaxExistForIntercompany(_ledgerJournalTrans))))
                {
                    taxAmount = taxAmount * -1;
                }

                this.setOffsetForTotalTaxAmountAllocatedByVoucher(_ledgerJournalTrans.Voucher, true);
            }

            if (!_dueToDueFromAccount &&
                !this.getOffsetForTotalTaxAmountAllocatedByVoucher(_ledgerJournalTrans.Voucher) &&
                !ledgerJournalTable.LedgerJournalInclTax &&
                !this.doesTaxExistForIntercompany(_ledgerJournalTrans) &&
                taxObligation == TaxObligationCompany::Destination)
            {
                if (this.checkIfVendCustExistsInOrigJournal(_ledgerJournalTrans))
                {
                    taxAmount = this.getTransactionalTaxIntercompanyLine(_ledgerJournalTrans);
                }
                else
                {
                    taxAmount = this.getTransactionalTaxIntercompanyDocument(_ledgerJournalTrans, dataAreaIdPost);
                    this.setOffsetForTotalTaxAmountAllocatedByVoucher(_ledgerJournalTrans.Voucher, true);
                }
            }

            if (!_dueToDueFromAccount &&
                !this.getOffsetForTotalTaxAmountAllocatedByVoucher(_ledgerJournalTrans.Voucher) &&
                !ledgerJournalTable.LedgerJournalInclTax &&
                this.doesTaxExistForIntercompany(_ledgerJournalTrans) &&
                taxObligation == TaxObligationCompany::Source &&
                !intercompanyCustVendBank)
            {
                taxAmount = this.getTransactionalTaxIntercompanyLine(_ledgerJournalTrans);
                this.setOffsetForTotalTaxAmountAllocatedByVoucher(_ledgerJournalTrans.Voucher, true);
            }

            if (ledgerJournalTable.LedgerJournalInclTax
                && this.doesTaxExistForIntercompany(_ledgerJournalTrans))
            {
                if (!_dueToDueFromAccount)
                {
                  // if it isn't the due to/due from account, then we need to get the tax amount for
                  // included only because the account that isn't the due to/due from account should
                  // exclude tax since tax posts seperately
                  taxAmount = this.getTransactionalTaxIntercompanyLine(_ledgerJournalTrans);
                }
            }
        }
        else
        {
            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger &&
                _ledgerJournalTrans.LedgerDimension &&
                _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger &&
                _ledgerJournalTrans.OffsetLedgerDimension &&
                !_isOffset)
            {
                // offset of the total tax amounts never get allocated to the primary
                // account - always the offset account. We are currently processing the
                // primary account so skip the exception check below.
                skipErrorCheck = true;
            }
            else
            {
                if (!this.getOffsetForTotalTaxAmountAllocatedByVoucher(_ledgerJournalTrans.Voucher)
                    && ledgerJournalTable.JournalType != LedgerJournalType::Approval)
                {
                    // tax wasn't allocated to a cust/vend/bank type.  This means that the TaxObligation
                    // must be Destination regardless of what is configured on LedgerJournalTable.
                    taxObligationLocal = taxObligation;
                    taxObligation = TaxObligationCompany::Destination;
                }

                // if the ledger account is not the profit or loss account and it is tax excluded then
                // we always return the tax amount.
                if (!this.getOffsetForTotalTaxAmountAllocatedByVoucher(_ledgerJournalTrans.Voucher) &&
                    !ledgerJournalTable.LedgerJournalInclTax &&
                    (ledgerJournalTable.JournalType != LedgerJournalType::Approval ||
                     ledgerJournalTable.LedgerJournalInclTax))

                {
                    if (!_dueToDueFromAccount)
                    {
                        this.setOffsetForTotalTaxAmountAllocatedByVoucher(_ledgerJournalTrans.Voucher, true);
                    }

                    taxAmount = this.getTransactionalTaxAmountForDocument(_ledgerJournalTrans, false, dataAreaIdPost);
                    if (((taxAmount > 0 && (_ledgerJournalTrans.AmountCurDebit > 0 || _ledgerJournalTrans.AmountCurCredit < 0)) ||
                        (taxAmount < 0 && (_ledgerJournalTrans.AmountCurDebit < 0 || _ledgerJournalTrans.AmountCurCredit > 0))) &&
                        !((_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger ||
                           _ledgerJournalTrans.AccountType == LedgerJournalACType::Project ||
                           _ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets) &&
                          _ledgerJournalTrans.LedgerDimension &&
                          (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger &&
                          _ledgerJournalTrans.OffsetLedgerDimension) ||
                          _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets))
                    {
                        taxAmount = 0;
                        this.setOffsetForTotalTaxAmountAllocatedByVoucher(_ledgerJournalTrans.Voucher, false);
                        taxObligation = taxObligationLocal;
                    }
                }
                else
                {
                    this.setOffsetForTotalTaxAmountAllocatedByVoucher(_ledgerJournalTrans.Voucher, true);
                }
            }

            if (!taxAmount && _dueToDueFromAccount && taxObligation == TaxObligationCompany::Destination)
            {
                if (!ledgerJournalTable.LedgerJournalInclTax)
                {
                    taxAmount = -this.getTransactionalTaxAmountForLine(_ledgerJournalTrans);
                }
            }

            if (!taxAmount && _dueToDueFromAccount && taxObligation == TaxObligationCompany::Source)
            {
                if (ledgerJournalTable.LedgerJournalInclTax)
                {
                    taxAmount = this.getTransactionalTaxAmountForLine(_ledgerJournalTrans);
                }
            }
        }

        // <GIN>
        if (_ledgerJournalTrans.isTaxTypeApplicable_IN())
        {
            isPriceIncluded = FormulaDesigner_IN::isPriceInclTaxOnLineAmount(_ledgerJournalTrans.TaxItemGroup);
            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger // [Ledger-Ledger Scenario]
                && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
            {
                isLedgerLedger = true;
                if (isPriceIncluded)
                {
                    if (!_isOffset/*Main AC && India Price Included*/)
                    {
                        taxAmount = this.getTransactionalTaxAmountForLine(_ledgerJournalTrans);
                    }
                    else/*Offset AC && India Price Included*/
                    {
                        taxAmount = 0;
                    }
                }
            }
            else if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
            {
                if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Project && _isOffset && !isPriceIncluded)
                {
                    taxAmount = this.getTransactionalTaxAmountForLine(_ledgerJournalTrans);
                }
                else if (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets && _isOffset) // [FixedAsset-Ledger Scenario]
                {
                    if (isPriceIncluded)
                    {
                        if (TaxUncommitted::getCustomsDuty_IN(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId))
                        {
                            taxAmount = -this.getTransactionalTaxAmountForLine(_LedgerJournalTrans);
                        }
                        else
                        {
                            taxAmount = 0;
                        }
                    }
                }
                else if (isPriceIncluded
                    && _isOffset/*Offset AC && Price Included Tax, so shud not hit again*/)
                {
                    taxAmount = 0;
                }
            }
        }
        // </GIN>
        if (_ledgerJournalTrans.TaxCode)
        {
            if (this.isTaxDifferencePostingOnJapanConsInvoiceEnabled)
            {
                return _ledgerJournalTrans.ledgerJournalTransTaxExtension().TaxInCostPrice;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return taxAmount;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountForProjectType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax amount for the <c>LedgerJournalTrans</c> record of type project that is being posted
    /// to.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record that is being posted.
    /// </param>
    /// <returns>
    /// The tax amount for the <c>LedgerJournalTrans</c> record of type project.
    /// </returns>
    public TaxAmount taxAmountForProjectType(LedgerJournalTrans _ledgerJournalTrans)
    {
        TaxAmount taxAmount;

        // <GIN>
        boolean isPriceIncluded;
        // </GIN>

        if (!this.doesTaxAmountExist(_ledgerJournalTrans))
        {
            return 0;
        }

        if (ledgerJournalTable.LedgerJournalInclTax)
        {
            if (_ledgerJournalTrans.canAccountTypeBeTaxed(LedgerJournalACType::Project))
            {
                taxAmount = this.getTransactionalTaxAmountForLine(_ledgerJournalTrans);
            }
        }
        else
        {
            taxAmount = 0;
        }

        // <GIN>
        if (_ledgerJournalTrans.isTaxTypeApplicable_IN())
        {
            isPriceIncluded = FormulaDesigner_IN::isPriceInclTaxOnLineAmount(_ledgerJournalTrans.TaxItemGroup);

            if (isPriceIncluded)
            {
                taxAmount = this.getTransactionalTaxAmountForLine(_ledgerJournalTrans);
            }
            else
            {
                taxAmount = 0;
            }
        }
        // </GIN>

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountForVendCustType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax amount for the <c>LedgerJournalTrans</c> record of type customer or vendor that is
    /// being posted to.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record that is being posted.
    /// </param>
    /// <param name="_interCompany">
    /// true if this is an intercompany journal; otherwise, false.
    /// </param>
    /// <param name="_posting">
    /// The posting type.
    /// </param>
    /// <param name="_dueToDueFromAccount">
    /// true if this is a due to or due from account; otherwise, false.
    /// </param>
    /// <returns>
    /// The tax amount for the <c>LedgerJournalTrans</c> record of type customer or vendor.
    /// </returns>
    public TaxAmountCur taxAmountForVendCustType(LedgerJournalTrans _ledgerJournalTrans, boolean _interCompany, LedgerPostingType _posting, boolean _dueToDueFromAccount)
    {
        TaxAmountCur taxAmountCur;

        vendCustExistsForVoucher = true;
        vendCustExistsForVoucherChecked = true;

        if (!this.doesTaxAmountExist(_ledgerJournalTrans) && !_interCompany)
        {
            return 0;
        }

        if ((!this.getOffsetForTotalTaxAmountAllocatedByVoucher(_ledgerJournalTrans.Voucher) && !ledgerJournalTable.LedgerJournalInclTax
            // <GIN>
            || _ledgerJournalTrans.isTaxTypeApplicable_IN()
            // </GIN>
            )&&
            (ledgerJournalTable.TaxObligationCompany == TaxObligationCompany::Destination ||
             taxObligationSourceCompany == curext() ||
             taxObligationSourceCompany == ''))
        {
            if (this.doesTaxOnPaymentFeeExist(_ledgerJournalTrans.Voucher, _ledgerJournalTrans.JournalNum))
            {
                // tax on payment fees get applied to the bank amount - not the vendor/customer
                taxAmountCur = this.getTransTaxAmountForDocLessPaymFees(_ledgerJournalTrans);
            }
            else
            {
                if (_interCompany)
                {
                    if (ledgerJournalTable.TaxObligationCompany == TaxObligationCompany::Destination
                        && !_dueToDueFromAccount
                        && ((isTaxInterCompanyDestinationIncludeTaxFlightEnabled
                                && (_ledgerJournalTrans.AmountCurCredit < 0 || _ledgerJournalTrans.AmountCurDebit > 0))
                            || (_ledgerJournalTrans.AmountCurCredit > 0 || _ledgerJournalTrans.AmountCurDebit < 0)))
                    {
                        taxAmountCur = this.getTransactionalTaxIntercompanyDocument(_ledgerJournalTrans);
                    }
                    else
                    {
                        taxAmountCur = this.getTransactionalTaxIntercompanyDocument(_ledgerJournalTrans, dataAreaIdPost);
                    }
                }
                else
                {
                    taxAmountCur = this.getTransactionalTaxAmountForDocument(_ledgerJournalTrans, false, dataAreaIdPost);
                }
            }
        }

        if (!_interCompany &&
            _dueToDueFromAccount &&
            !this.getOffsetForTotalTaxAmountAllocatedByVoucher(_ledgerJournalTrans.Voucher))
        {
            if (!intercompanyCustVendBank)
            {
                originalTaxObligationSourceRecord = _ledgerJournalTrans.RecId;
            }

            intercompanyCustVendBank = true;
        }

        this.setOffsetForTotalTaxAmountAllocatedByVoucher(_ledgerJournalTrans.Voucher, true);
        // This must run after the code above so that the state properly before we return
        if (_dueToDueFromAccount &&
            _posting == LedgerPostingType::InterCompany &&
            ledgerJournalTable.TaxObligationCompany == TaxObligationCompany::Source &&
            !ledgerJournalTable.LedgerJournalInclTax)
        {
            // Since cust/vend is in the intercompany journal don't allocate the tax.
            taxAmountCur = 0;
        }

        if (_dueToDueFromAccount &&
            _posting == LedgerPostingType::InterCompany &&
            ledgerJournalTable.TaxObligationCompany == TaxObligationCompany::Source &&
            ledgerJournalTable.LedgerJournalInclTax)
        {
            taxAmountCur = -this.getTransactionalTaxAmountForDocument(_ledgerJournalTrans, false, dataAreaIdPost);
        }

        if (intercompanyCustVendBank
            && _dueToDueFromAccount
            && _posting == LedgerPostingType::InterCompany
            && ledgerJournalTable.TaxObligationCompany == TaxObligationCompany::Source)
        {
            if (!_interCompany)
            {
                taxAmountCur += this.getTrxNonRecoverableVATAmountForDoc(_ledgerJournalTrans);
            }
            else
            {
                taxAmountCur += -this.getTrxNonRecoverableVATAmountForDoc(_ledgerJournalTrans);
            }
        }
        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithholdAmountForBankType_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the withhold tax amount for the <c>LedgerJournalTrans</c> record of type bank that is being posted
    ///    to.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record that is being posted.
    /// </param>
    /// <returns>
    ///    The tax amount for the <c>LedgerJournalTrans</c> record with type Bank.
    /// </returns>
    /// <remarks>
    ///    If the <paramref name="_interCompany" /> parameter is not specified, it is assumed that this is not
    ///    an intercompany scenario.
    /// </remarks>
    public TaxAmountCur taxWithholdAmountForBankType_IN(LedgerJournalTrans    _ledgerJournalTrans)
    {
        TaxAmountCur                taxWithholdAmount;
        boolean                     calculateTax;
        int                         sign = 1;
        TaxWithholdCodeType_IN      taxWithholdCodeType;

        taxWithholdCodeType = _ledgerJournalTrans.getWithholdTaxTypeForJournalLine();
        if (taxWithholdCodeType == TaxWithholdCodeType_IN::TDS)
        {
            if ((_ledgerJournalTrans.AccountType    == LedgerJournalACType::Bank && _ledgerJournalTrans.OffsetAccountType   == LedgerJournalACType::Cust
                    && _ledgerJournalTrans.AmountCurDebit  > 0)
                || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank && _ledgerJournalTrans.OffsetAccountType   == LedgerJournalACType::Cust
                    && _ledgerJournalTrans.AmountCurCredit > 0)
                || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank && _ledgerJournalTrans.OffsetAccountType   == LedgerJournalACType::Vend
                    && _ledgerJournalTrans.AmountCurCredit > 0)
                || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank && _ledgerJournalTrans.OffsetAccountType   == LedgerJournalACType::Ledger
                    && _ledgerJournalTrans.AmountCurDebit  > 0)
                || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank
                    && _ledgerJournalTrans.AmountCurCredit > 0)
                || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank   && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger
                    && _ledgerJournalTrans.AmountCurCredit > 0)
                || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank
                    && _ledgerJournalTrans.AmountCurDebit  > 0)
                || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust   && _ledgerJournalTrans.OffsetAccountType   == LedgerJournalACType::Bank
                    && _ledgerJournalTrans.AmountCurDebit  > 0)
                || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend   &&  _ledgerJournalTrans.OffsetAccountType   == LedgerJournalACType::Bank
                    && _ledgerJournalTrans.AmountCurDebit  > 0)
                || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust   && _ledgerJournalTrans.OffsetAccountType   == LedgerJournalACType::Bank
                    && _ledgerJournalTrans.AmountCurCredit > 0)
                || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank   && _ledgerJournalTrans.OffsetAccountType   == LedgerJournalACType::Cust
                    && _ledgerJournalTrans.AmountCurDebit  > 0))
            {
                calculateTax = true;

                if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Bank && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust
                        && _ledgerJournalTrans.AmountCurDebit  > 0)
                {
                    sign = sign * -1;
                }
            }
        }
        else if (taxWithholdCodeType == TaxWithholdCodeType_IN::TCS)
        {
            if (((_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank
                && _ledgerJournalTrans.AmountCurCredit > 0 && _ledgerJournalTrans.SettleVoucher == SettlementType::SelectedTransact)
                || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank
                && _ledgerJournalTrans.AmountCurDebit > 0 && _ledgerJournalTrans.SettleVoucher  == SettlementType::SelectedTransact))
                && !TaxWithholdGroupHeading::find(_ledgerJournalTrans.ledgerJournalTransTaxExtensionIN().TCSGroup).TaxLiabilityOnPayment_IN)
            {
                calculateTax = true;
            }
        }

        if (calculateTax)
        {
            if (_ledgerJournalTrans.LedgerDimension)
            {
                taxWithholdAmount = TaxWithholdUncommitted_IN::getActualTaxAmountForVoucher(_ledgerJournalTrans.ledgerJournalTable().TableId, _ledgerJournalTrans.ledgerJournalTable().RecId, _ledgerJournalTrans.Voucher, false, '', _ledgerJournalTrans.RecId);
            }
            else
            {
            taxWithholdAmount = TaxWithholdUncommitted_IN::getActualTaxAmountForVoucher(_ledgerJournalTrans.ledgerJournalTable().TableId, _ledgerJournalTrans.ledgerJournalTable().RecId, _ledgerJournalTrans.Voucher, false);
            }

            taxWithholdAmount = taxWithholdAmount * sign;
        }

        return taxWithholdAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithholdAmountForCustType_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the withhold tax amount for the <c>LedgerJournalTrans</c> record of type cust that is being posted
    ///    to.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record that is being posted.
    /// </param>
    /// <param name="_excludeCurrentCompany">
    ///    Indicate whether tax withholding amount is excluded from current company.
    /// </param>
    /// <returns>
    ///    The tax amount for the <c>LedgerJournalTrans</c> record with type Bank.
    /// </returns>
    /// <remarks>
    ///    If the <paramref name="_interCompany" /> parameter is not specified, it is assumed that this is not
    ///    an intercompany scenario.
    /// </remarks>
    public TaxAmount taxWithholdAmountForCustType_IN(
        LedgerJournalTrans  _ledgerJournalTrans,
        boolean             _excludeCurrentCompany = false)
    {
        DimensionDynamicDefaultAccount dimensionDynamicDefaultAccount;
        TaxWithholdCodeType_IN         taxWithholdCodeType;

        taxWithholdCodeType = _ledgerJournalTrans.getWithholdTaxTypeForJournalLine();
        if (   (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust        && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger      && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust        && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust        && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Project     && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust)
            // Below conditions moved from \Classes\TaxWithholdCalculation_IN\taxWithholdCustomer() method.
            || (taxWithholdCodeType == TaxWithholdCodeType_IN::TCS && _ledgerJournalTrans.AccountType == LedgerJournalACType::Bank
                && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust  && _ledgerJournalTrans.AmountCurDebit > 0)
            || (taxWithholdCodeType == TaxWithholdCodeType_IN::TCS && _ledgerJournalTrans.AccountType == LedgerJournalACType::Cust
                && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank  && _ledgerJournalTrans.AmountCurCredit > 0)
            || (taxWithholdCodeType == TaxWithholdCodeType_IN::TDS && _ledgerJournalTrans.AccountType == LedgerJournalACType::Cust
                && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank  && _ledgerJournalTrans.AmountCurCredit > 0)
            || (taxWithholdCodeType == TaxWithholdCodeType_IN::TDS && _ledgerJournalTrans.AccountType == LedgerJournalACType::Bank
                && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust  && _ledgerJournalTrans.AmountCurDebit > 0))
        {
            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger)
            {
                dimensionDynamicDefaultAccount = _ledgerJournalTrans.LedgerDimension;
            }
            else if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
            {
                dimensionDynamicDefaultAccount = _ledgerJournalTrans.OffsetLedgerDimension;
            }

            if (dimensionDynamicDefaultAccount)
            {
                if (MainAccount::findByMainAccountId(LedgerDimensionFacade::getDisplayValueForLedgerDimension(dimensionDynamicDefaultAccount)).PostingType == LedgerPostingType::PurchCash)
                {
                    return 0;
                }
            }

            if (_excludeCurrentCompany)
            {
                if (_ledgerJournalTrans.OffsetLedgerDimension)
                {
                    return TaxWithholdUncommitted_IN::getActualTaxAmountForCPVoucher(_ledgerJournalTrans.ledgerJournalTable().TableId, _ledgerJournalTrans.ledgerJournalTable().RecId, _ledgerJournalTrans.Voucher, false, curext(), _ledgerJournalTrans.RecId);
                }
                else
                {
                return TaxWithholdUncommitted_IN::getActualTaxAmountForCPVoucher(_ledgerJournalTrans.ledgerJournalTable().TableId, _ledgerJournalTrans.ledgerJournalTable().RecId, _ledgerJournalTrans.Voucher, false, curext());
            }
            }
            else
            {
                if (_ledgerJournalTrans.OffsetLedgerDimension)
                {
                    return TaxWithholdUncommitted_IN::getActualTaxAmountForVoucher(_ledgerJournalTrans.ledgerJournalTable().TableId, _ledgerJournalTrans.ledgerJournalTable().RecId, _ledgerJournalTrans.Voucher, false, '', _ledgerJournalTrans.RecId);
                }
                else
                {
                return TaxWithholdUncommitted_IN::getActualTaxAmountForVoucher(_ledgerJournalTrans.ledgerJournalTable().TableId, _ledgerJournalTrans.ledgerJournalTable().RecId, _ledgerJournalTrans.Voucher, false);
            }
            }
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithholdAmountForVendType_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the withhold tax amount for the <c>LedgerJournalTrans</c> record of type vend that is being posted
    ///    to.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record that is being posted.
    /// </param>
    /// <param name="_excludeCurrentCompany">
    ///    Indicate whether tax withholding amount is excluded from current company.
    /// </param>
    /// <returns>
    ///    The tax amount for the <c>LedgerJournalTrans</c> record with type Bank.
    /// </returns>
    /// <remarks>
    ///    If the <paramref name="_interCompany" /> parameter is not specified, it is assumed that this is not
    ///    an intercompany scenario.
    /// </remarks>
    public TaxAmount taxWithholdAmountForVendType_IN(
        LedgerJournalTrans  _ledgerJournalTrans,
        boolean             _excludeCurrentCompany = false)
    {
        DimensionDynamicDefaultAccount dimensionDynamicDefaultAccount;
        TaxWithholdCodeType_IN          taxWithholdCodeType;
        LedgerJournalTrans              ledgerJournalLoc;
        boolean                         calcForVendorType;

        select firstonly AccountType, OffsetAccountType from ledgerJournalLoc
            where ledgerJournalLoc.RecId == _ledgerJournalTrans.RecId;

        if (ledgerJournalLoc.AccountType == LedgerJournalACType::Project
            && ledgerJournalLoc.OffsetAccountType == LedgerJournalACType::Vend)
        {
            calcForVendorType = true;
        }
        taxWithholdCodeType = _ledgerJournalTrans.getWithholdTaxTypeForJournalLine();

        if ((_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend           && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger
                 && MainAccount::findByLedgerDimension(_ledgerJournalTrans.OffsetLedgerDimension).PostingType != LedgerPostingType::PurchCash)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger      && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend
                && MainAccount::findByLedgerDimension(_ledgerJournalTrans.LedgerDimension).PostingType != LedgerPostingType::PurchCash)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend        && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
            || (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend        && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Project)
            || (calcForVendorType)
            // Below conditions moved from \Classes\TaxWithholdCalculation_IN\taxWithholdVendor() method.
            || (taxWithholdCodeType == TaxWithholdCodeType_IN::TCS && _ledgerJournalTrans.AccountType == LedgerJournalACType::Vend
                &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank   && _ledgerJournalTrans.AmountCurDebit   > 0 )
            || (taxWithholdCodeType == TaxWithholdCodeType_IN::TCS && _ledgerJournalTrans.AccountType == LedgerJournalACType::Bank
                &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend   && _ledgerJournalTrans.AmountCurCredit  > 0)
            || (taxWithholdCodeType == TaxWithholdCodeType_IN::TDS && _ledgerJournalTrans.AccountType == LedgerJournalACType::Vend
                &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank   && _ledgerJournalTrans.AmountCurDebit   > 0 )
            || (taxWithholdCodeType == TaxWithholdCodeType_IN::TDS && _ledgerJournalTrans.AccountType == LedgerJournalACType::Bank
                &&  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend   && _ledgerJournalTrans.AmountCurCredit  > 0))
        {
            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger)
            {
                dimensionDynamicDefaultAccount = _ledgerJournalTrans.LedgerDimension;
            }
            else if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
            {
                dimensionDynamicDefaultAccount = _ledgerJournalTrans.OffsetLedgerDimension;
            }

            if (dimensionDynamicDefaultAccount)
            {
                if (MainAccount::findByMainAccountId(LedgerDimensionFacade::getDisplayValueForLedgerDimension(dimensionDynamicDefaultAccount)).PostingType == LedgerPostingType::PurchCash)
                {
                    return 0;
                }
            }

            if (_excludeCurrentCompany)
            {
                if (_ledgerJournalTrans.OffsetLedgerDimension)
                {
                    return TaxWithholdUncommitted_IN::getActualTaxAmountForCPVoucher(_ledgerJournalTrans.ledgerJournalTable().TableId, _ledgerJournalTrans.ledgerJournalTable().RecId, _ledgerJournalTrans.Voucher, false, curext(), _ledgerJournalTrans.RecId);
                }
                else
                {
                return TaxWithholdUncommitted_IN::getActualTaxAmountForCPVoucher(_ledgerJournalTrans.ledgerJournalTable().TableId, _ledgerJournalTrans.ledgerJournalTable().RecId, _ledgerJournalTrans.Voucher, false, curext());
            }
            }
            else
            {
                if (_ledgerJournalTrans.OffsetLedgerDimension)
                {
                    return TaxWithholdUncommitted_IN::getActualTaxAmountForVoucher(_ledgerJournalTrans.ledgerJournalTable().TableId, _ledgerJournalTrans.ledgerJournalTable().RecId, _ledgerJournalTrans.Voucher, false, '', _ledgerJournalTrans.RecId);
                }
                else
                {
                return TaxWithholdUncommitted_IN::getActualTaxAmountForVoucher(_ledgerJournalTrans.ledgerJournalTable().TableId, _ledgerJournalTrans.ledgerJournalTable().RecId, _ledgerJournalTrans.Voucher, false);
            }
            }
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerJournalTransIntercompanyMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the <c>interCompanyMap</c>, which links an intercompany <c>LedgerJournalTrans</c> record to
    ///    an originating <c>LedgerJournalTrans</c> record.
    /// </summary>
    /// <param name="_originatingRecId">
    ///    The <c>RecId</c> for the originating <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_intercompanyRecId">
    ///    The <c>RecId</c> value for the intercompany <c>LedgerJournalTrans</c> record.
    /// </param>
    public void updateLedgerJournalTransIntercompanyMap(RefRecId _originatingRecId, RefRecId _intercompanyRecId)
    {
        interCompanyMap.insert(_intercompanyRecId, _originatingRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTaxForJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the taxes for all unique tax documents for the journal.
    /// </summary>
    /// <param name="_journalNum">
    ///    The journal number for which the taxes are calculated.
    /// </param>
    static public void calculateTaxForJournal(JournalId _journalNum)
    {
        LedgerJournalTrans ledgerJournalTrans;
        LedgerJournalTable ledgerJournalTable;
        boolean isTaxIntegrationEnabledForJournal = Tax::isTaxIntegrationEnabledForBusinessProcess(TaxIntegrationBusinessProcess::Journal);
        boolean isTaxIntegrationEnabledForProjExpenseJournal = Tax::isTaxIntegrationEnabledForBusinessProcess(TaxIntegrationBusinessProcess::Project);

        while select JournalNum, Voucher, Invoice from ledgerJournalTrans
            join ledgerJournalTable
            group by ledgerJournalTrans.JournalNum, ledgerJournalTrans.Voucher, ledgerJournalTrans.Invoice
                // <GIN>
                , ledgerJournalTrans.TransDate
                // </GIN>
            where ledgerJournalTrans.JournalNum == _journalNum
                && ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
                && ((isTaxIntegrationEnabledForJournal
                        && (ledgerJournalTable.JournalType == LedgerJournalType::Daily
                            || ledgerJournalTable.JournalType == LedgerJournalType::VendInvoiceRegister
                            || ledgerJournalTable.JournalType == LedgerJournalType::Periodic
                            || ledgerJournalTable.JournalType == LedgerJournalType::CustPayment
                            || ledgerJournalTable.JournalType == LedgerJournalType::Payment)
                            || ledgerJournalTable.JournalType == LedgerJournalType::PurchaseLedger
                            || ledgerJournalTable.JournalType == LedgerJournalType::Approval)
                    || (isTaxIntegrationEnabledForProjExpenseJournal
                        && ledgerJournalTable.JournalType == LedgerJournalType::Cost)
                    || ledgerJournalTrans.TaxCode != ''
                    || (ledgerJournalTrans.TaxGroup != ''
                        && ledgerJournalTrans.TaxItemGroup != ''))
        {
             LedgerJournalTrans::getTaxInstance(_journalNum, ledgerJournalTrans.Voucher, ledgerJournalTrans.Invoice, true
                                                // <GIN>
                                                , null, false, ledgerJournalTrans.transdate
                                                // </GIN>
                                               );
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTaxForVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates taxes for all unique tax documents for the journal and voucher.
    /// </summary>
    /// <param name="_journalNum">
    ///    The journal number.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher.
    /// </param>
    static private void calculateTaxForVoucher(JournalId _journalNum, Voucher _voucher)
    {
        LedgerJournalTrans ledgerJournalTrans;

        while select JournalNum, Voucher, Invoice from ledgerJournalTrans
        group by JournalNum, Voucher, Invoice
        // <GIN>
        , transdate
        // </GIN>
        where  (ledgerJournalTrans.JournalNum == _journalNum &&
               ledgerJournalTrans.Voucher == _voucher &&
               ((ledgerJournalTrans.TaxGroup != '' &&
               ledgerJournalTrans.TaxItemGroup != '') ||
               ledgerJournalTrans.TaxCode != ''))
        {
            LedgerJournalTrans::getTaxInstance(_journalNum, ledgerJournalTrans.Voucher, ledgerJournalTrans.Invoice, true
                                               // <GIN>
                                               , null, false, ledgerJournalTrans.transdate
                                               // </GIN>
                                               );
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateWithholdTaxForJournal_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the withhold taxes for all unique tax documents for the journal.
    /// </summary>
    /// <param name="_journalNum">
    ///    The journal number for which the withhold taxes are calculated.
    /// </param>
    static public void calculateWithholdTaxForJournal_IN(JournalId _journalNum)
    {
        LedgerJournalTrans ledgerJournalTrans;
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt;

        while select JournalNum, Voucher, Invoice from ledgerJournalTrans
        group by JournalNum, Voucher, Invoice
            where LedgerJournaltrans.JournalNum == _journalNum
            join ledgerJournalTransTaxExt
                where ledgerJournalTransTaxExt.LedgerJournalTrans == ledgerJournalTrans.RecId
                    && (ledgerjournaltransTaxExt.TDSGroup != '' ||
                        ledgerjournaltransTaxExt.TCSGroup != '' ||
                        ledgerjournaltransTaxExt.TaxWithholdCode != '')
        {
            LedgerJournalTrans_IN_Extension::getTaxWithholdInstance_IN(_journalNum, ledgerJournalTrans.Voucher, ledgerJournalTrans.Invoice, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an instance of the <c>TaxVoucherService</c> class.
    /// </summary>
    /// <param name="_ledgerJournalTable">
    ///    The <c>LedgerJournalTable</c> record that represents the journal that is being posted.
    /// </param>
    /// <returns>
    ///    An instance of the <c>TaxVoucherService</c> class.
    /// </returns>
    /// <remarks>
    ///    This may be an intercompany journal.
    /// </remarks>
    public static TaxVoucherService construct(LedgerJournalTable _ledgerJournalTable)
    {
        TaxVoucherService taxVoucherService;

        taxVoucherService = new TaxVoucherService(_ledgerJournalTable);

        return taxVoucherService;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxPostingType_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets tax posting type.
    /// </summary>
    /// <param name="_taxType">
    /// The tax type.
    /// </param>
    /// <returns>
    /// The posting type value.
    /// </returns>
    public static LedgerPostingType getTaxPostingType_IN(TaxType_IN _taxType)
    {
        LedgerPostingType taxPostingType;
        switch (_taxType)
        {
            case TaxType_IN::VAT:
                taxPostingType = LedgerPostingType::VAT_IN;
                break;

            case TaxType_IN::SalesTax:
                taxPostingType = LedgerPostingType::SalesTax_IN;
                break;

            case TaxType_IN::ServiceTax:
                taxPostingType = LedgerPostingType::ServiceTax_IN;
                break;

            case TaxType_IN::Excise:
                taxPostingType = LedgerPostingType::Excise_IN;
                break;

            case TaxType_IN::Customs:
                taxPostingType = LedgerPostingType::Customs_IN;
                break;

            default :
                taxPostingType = LedgerPostingType::Tax;
        }
        return taxPostingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxUncommittedExistForIntercompLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the tax record for an intercompany line.
    /// </summary>
    /// <param name="_interCompanyledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    ///    The tax record for the intercompany <c>LedgerJournalTrans</c> record.
    /// </returns>
    private boolean getTaxUncommittedExistForIntercompLine(LedgerJournalTrans _interCompanyledgerJournalTrans)
    {
        RefRecId            originatingCompanyRecId;
        LedgerJournalTrans  ledgerJournalTransOriginatingCompany;

        // Get the RecId for the LedgerJournalTrans line for the originating company.
        if (interCompanyMap.exists(_interCompanyledgerJournalTrans.RecId))
        {
            originatingCompanyRecId = interCompanyMap.lookup(_interCompanyledgerJournalTrans.RecId);
        }
        else
        {
            return false;
        }

        // the current company is the foreign company so switch back to the originating company.
        changecompany(_interCompanyledgerJournalTrans.ForeignCompany)
        {
            // get the LedgerJournalTrans line for the originating company.
            ledgerJournalTransOriginatingCompany = LedgerJournalTrans::findRecId(originatingCompanyRecId, false);

            // Get the tax amount from the originating company.  All taxes are calculated in the originating company
            return TaxUncommitted::existByDocumentLineId(ledgerJournalTransOriginatingCompany.TableId, ledgerJournalTransOriginatingCompany.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerAccountIsVATAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the specified account type and dynamics account refers to a tax account.
    /// </summary>
    /// <param name="_accountType">
    ///    The account type.
    /// </param>
    /// <param name="_ledgerDimension">
    ///    The ledger dimension that specifies the account number.
    /// </param>
    /// <returns>
    ///    true if the specified account number and type refer to a tax account; otherwise, false.
    /// </returns>
    static boolean ledgerAccountIsVATAccount(LedgerJournalACType _accountType, DimensionDynamicAccount _ledgerDimension)
    {
        RecId   mainAccountId;

        if (_accountType != LedgerJournalACType::Ledger)
        {
            return true;
        }
        else
        {
            mainAccountId = LedgerDimensionFacade::getMainAccountRecIdFromLedgerDimension(_ledgerDimension);

            return MainAccount::existLedgerPostingType(mainAccountId, LedgerPostingType::Tax);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxAmountForLedgerTypeHandler_BR</Name>
				<Source><![CDATA[
    [PostHandlerFor(classStr(TaxVoucherService), methodStr(TaxVoucherService, taxAmountForLedgerType))]
    /// <summary>
    /// Observes the event that fires after calling the <c>taxAmountForLedgerType</c> method.
    /// </summary>
    /// <param name="_args">
    /// An <c>XppPrePostArgs</c> that encapsulates the arguments passed in call of <c>taxAmountForLedgerType</c> method.
    /// </param>
    public static void postTaxAmountForLedgerTypeHandler_BR(XppPrePostArgs _args)
    {
        TaxVoucherService TaxVoucherService = _args.getThis();
        anyType returnValue;

        if (!BrazilParameters::isEnabled())
        {
            return;
        }

        returnValue = TaxVoucherService.postTaxAmountForLedgerType_BR(
                _args.getArg('_ledgerJournalTrans'),
                _args.getArg('_isOffset'),
                _args.getArg('_interCompany'),
                _args.getReturnValue());

        _args.setReturnValue(returnValue);
    }

]]></Source>
			</Method>
			<Method>
				<Name>priceInclTaxAmountCalculated_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets calculated price incl tax amount.
    /// </summary>
    /// <param name="recid">
    /// The record id.
    /// </param>
    /// <param name="tableid">
    /// The table id.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxAmount</c> class.
    /// </returns>
    public static TaxAmount priceInclTaxAmountCalculated_IN(RefRecId recid, TableId tableid)
    {
        TaxAmount           taxAmount;
        FormulaDesigner_IN  formulaDesigner;
        TaxableBasis_IN     taxBasis;
        TaxUncommitted taxUncommitted;

        while select SourceRecId, SourceTableId, TaxDirection, TaxOrigin, TaxItemGroup, TaxCode, SourceTaxAmountCur, SourceRegulateAmountCur
            from taxUncommitted
            where taxUncommitted.SourceRecId      == recid &&
                  taxUncommitted.SourceTableId    == tableid &&
                  taxUncommitted.TaxDirection     != TaxDirection::UseTax &&
                  taxUncommitted.TaxOrigin        != TaxOrigin::TaxReversed
        {
            formulaDesigner = FormulaDesigner_IN::findByTaxCode(taxUncommitted.TaxItemGroup, taxUncommitted.TaxCode);
            if (formulaDesigner.PriceInclTax)
            {
                taxBasis = formulaDesigner.TaxableBasis;
                if (taxBasis == TaxableBasis_IN::ExclAmount)
                {
                    taxBasis = Tax::getTaxableBasis_IN(formulaDesigner);
                }
                if (TaxTable::find(taxUncommitted.TaxCode).TaxType_IN != TaxType_IN::None
                    && (taxBasis == TaxableBasis_IN::LineAmount
                        || taxBasis == TaxableBasis_IN::Assessable))
                {
                    if (taxUncommitted.TaxAutogenerated)
                         taxAmount += taxUncommitted.SourceTaxAmountCur;
                    else
                         taxAmount += taxUncommitted.SourceRegulateAmountCur;
                }
            }
        }
        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxAmountForAssetType</Name>
				<Source><![CDATA[
    private TaxAmount getTaxAmountForAssetType(LedgerJournalTrans _ledgerJournalTrans, SelectableDataArea _company = curext(), boolean _interCompany = false)
    {
        TaxAmount taxAmount = 0;

        changeCompany (_company)
        {
            if (this.doesTaxAmountExist(_ledgerJournalTrans) && _ledgerJournalTrans.canAccountTypeBeTaxed(LedgerJournalACType::FixedAssets))
            {
                // return the tax for whichever side of this line is being processed.
                if (this.isInterCompanyLedgerJournalTrans(_ledgerJournalTrans))
                {
                    taxAmount = this.getTransactionalTaxIntercompanyLine(_ledgerJournalTrans);
                }
                else
                {
                    DataAreaId dataAreaId;

                    if (_interCompany && ledgerJournalTable.LedgerJournalInclTax == NoYes::Yes)
                    {
                        dataAreaId = '';
                    }
                    else
                    {
                        dataAreaId = dataAreaIdPost;
                    }

                    taxAmount = TaxUncommitted::getActualTaxAmountForSourceLineWithCompany(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId, false, true, true, dataAreaId);
                }
            }
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value that indicates whether the provided line is taxable.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// An instance of <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name="_isOffset">
    /// Boolean representing to validate the account or offset account.
    /// </param>
    /// <returns>
    /// true if the specific line is taxable; otherwise false.
    /// </returns>
    public boolean isTaxable(LedgerJournalTrans _ledgerJournalTrans, boolean _isOffset)
    {
        return ledgerJournalTable.isTaxSupported()
                && ((_isOffset && _ledgerJournalTrans.isOffsetTaxable()) ||
                    (!_isOffset && _ledgerJournalTrans.isPrimaryTaxable()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOffsetForTotalTaxAmountAllocatedByVoucher</Name>
				<Source><![CDATA[
    protected boolean getOffsetForTotalTaxAmountAllocatedByVoucher(Voucher _voucher)
    {
        return (taxInterruptOfErrorAccountForMultiVoucherFlightEnabled && offsetForTotalTaxAmountAllocatedByVoucherMap.exists(_voucher))
            ? offsetForTotalTaxAmountAllocatedByVoucherMap.lookup(_voucher) : offsetForTotalTaxAmountAllocated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setOffsetForTotalTaxAmountAllocatedByVoucher</Name>
				<Source><![CDATA[
    protected void setOffsetForTotalTaxAmountAllocatedByVoucher(Voucher _voucher, boolean _offsetForTotalTaxAmountAllocated)
    {
        offsetForTotalTaxAmountAllocated = _offsetForTotalTaxAmountAllocated;

        if (taxInterruptOfErrorAccountForMultiVoucherFlightEnabled)
        {
            offsetForTotalTaxAmountAllocatedByVoucherMap.insert(_voucher, offsetForTotalTaxAmountAllocated);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountForAssetTypeInterCompanyAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax amount for the <c>LedgerJournalTrans</c> record of type fixed assets that is being
    /// posted to intercompany.
    /// </summary>
    /// <param name="_originalLedgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record that is being posted.
    /// </param>
    /// <param name="_isOffset">
    /// Boolean indicating which side of ledger journal trans is currently being processed.
    /// </param>
    /// <returns>
    /// The tax amount for the <c>LedgerJournalTrans</c> record with type fixed assets for inter company posting.
    /// </returns>
    /// <remarks>
    /// This method is used when posting to due to / due from account when processing vouchers in logged in company.
    /// </remarks>
    public TaxAmount taxAmountForAssetTypeInterCompanyAccount(LedgerJournalTrans _originalLedgerJournalTrans, boolean _isOffset)
    {
        TaxObligationCompany taxObligationEffective;
        TaxAmount taxAmount;

        changeCompany(loggedInCompany)
        {
            if (!this.isTaxable(_originalLedgerJournalTrans, _isOffset))
            {
                return 0;
            }

            if (!this.getOffsetForTotalTaxAmountAllocatedByVoucher(_originalLedgerJournalTrans.Voucher) && ledgerJournalTable.JournalType != LedgerJournalType::Approval)
            {
                taxObligationEffective = TaxObligationCompany::Destination;
            }
            else
            {
                taxObligationEffective = this.parmTaxObligationCompany();
            }

            if (ledgerJournalTable.TaxObligationCompany == TaxObligationCompany::Source
                && !_originalLedgerJournalTrans.OffsetLedgerDimension
                && this.isAssetToCustVend(_originalLedgerJournalTrans.JournalNum, _originalLedgerJournalTrans.Voucher))
            {
                if (ledgerJournalTable.LedgerJournalInclTax)
                {
                    taxObligationEffective = this.parmTaxObligationCompany();
                }
                else
                {
                    return 0;
                }
            }

            if (!ledgerJournalTable.LedgerJournalInclTax)
            {
                if (taxObligationEffective == TaxObligationCompany::Destination)
                {
                    taxAmount = this.getTaxAmountForAssetType(_originalLedgerJournalTrans);
                }
                else if (taxObligationEffective == TaxObligationCompany::Source)
                {
                    taxAmount = this.getTransactionalTaxInCostPriceForLine(_originalLedgerJournalTrans);
                }
            }
            else if (ledgerJournalTable.LedgerJournalInclTax && taxObligationEffective == TaxObligationCompany::Source)
            {
                taxAmount = -(this.getTaxAmountForAssetType(_originalLedgerJournalTrans) - this.getTransactionalTaxInCostPriceForLine(_originalLedgerJournalTrans));
            }
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostTransOnErrorAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to post trans on error account.
    /// </summary>
    /// <param name = "_taxAmountCur">
    /// Tax amount in tax currency.
    /// </param>
    /// <returns>
    /// True if there is tax amount, otherwise, false.
    /// </returns>
    public boolean canPostTransOnErrorAccount(TaxAmountCur _taxAmountCur)
    {
        return !_taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAssetToCustVend</Name>
				<Source><![CDATA[
    private boolean isAssetToCustVend(LedgerJournalId _journalNum, Voucher _voucher)
    {
        boolean             ret;
        LedgerJournalTrans  ledgerJournalTransLoc;

        if (asset2CustVendTransMap.exists([_journalNum, _voucher]))
        {
            return asset2CustVendTransMap.lookup([_journalNum, _voucher]);
        }
        else
        {
            select count(RecId) from ledgerJournalTransLoc
                where ledgerJournalTransLoc.JournalNum == _journalNum
                    && ledgerJournalTransLoc.Voucher == _voucher;

            if (ledgerJournalTransLoc.RecId == 2)
            {
                select firstonly RecId from ledgerJournalTransLoc
                    where ledgerJournalTransLoc.JournalNum == _journalNum
                        && ledgerJournalTransLoc.Voucher == _voucher
                        && ledgerJournalTransLoc.LedgerDimension != 0
                        && ledgerJournalTransLoc.OffsetLedgerDimension != 0;

                if (ledgerJournalTransLoc.RecId == 0)
                {
                    select firstonly RecId from ledgerJournalTransLoc
                        where ledgerJournalTransLoc.JournalNum == _journalNum
                            && ledgerJournalTransLoc.Voucher == _voucher
                            && ledgerJournalTransLoc.LedgerDimension != 0
                            && ledgerJournalTransLoc.OffsetLedgerDimension == 0
                            && (ledgerJournalTransLoc.AccountType == LedgerJournalACType::Cust
                                || ledgerJournalTransLoc.AccountType == LedgerJournalACType::Vend);

                    ret = ledgerJournalTransLoc.RecId != 0;
                }
                else
                {
                    ret = false;
                }
            }
            else
            {
                ret = false;
            }
        }

        asset2CustVendTransMap.insert([_journalNum, _voucher], ret);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldRestrictCompanyIdWhenGetTaxAmountForLedgerType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if it should restrict company id when system gets tax amount for ledger type during intercompany posting process.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The <c>LedgerJournalTrans</c> to post.</param>
    /// <param name = "_dueToDueFromAccount">true if this is a due to or due from account; otherwise, false.</param>
    /// <param name = "_sign">The sign of tax amount. This parameter can be removed in the future.</param>
    /// <returns>True if it needs to restrict company id; otherwise, false.</returns>
    /// <remarks>Please remove sign part when the flight 'isTaxInterCompanyDestinationIncludeTaxFlightEnabled' is removed.</remarks>
    private boolean shouldRestrictCompanyIdWhenGetTaxAmountForLedgerType(LedgerJournalTrans _ledgerJournalTrans, boolean _dueToDueFromAccount, int _sign)
    {
        return (_sign == -1 || isTaxInterCompanyDestinationIncludeTaxFlightEnabled)
            && _dueToDueFromAccount
            && taxObligation == TaxObligationCompany::Destination
            && !ledgerJournalTable.LedgerJournalInclTax
            && this.checkIfVendCustExistsInOrigJournal(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>