<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>AssetDepCalculation_JP</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// It is used to do depreciation calculation for a specified Japan depreciation method based on parameters.
/// </summary>
abstract public class AssetDepCalculation_JP
{
    private const str FeatureReference = 'JP-00020';

    AssetDepCalculationArgs_JP calcArgs;

    // Cache of beginning balance of accumulated depreciation. It should not be directly used in sub classes.
    // The key must be the start day of period. The value is the beginning balance of the start day.
    // This cache is also used to aviod to access database for recatpure function.
    Map beginningBalanceOfAccumulatedDepCache;

    // Cache of beginning balance of accumulated extraordinary depreciation.
    // The key must be the start day of period. The value is the beginning balance of the start day.
    // This cache is also used to aviod to access database for recatpure function.
    Map beginningBalanceOfAccumulatedExtDepCache;

    // With same set of calculation args, some of methods in this class has static return value with same parameter.
    // To aviod duplicated caclulation, use this map to cache the result for such methods.
    Map methodsResultCache;

    private boolean doesSplittedAssetJournalExist;

    #AssetDepCalculation_JP

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addResultToCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a result to cache. It is used for method result cache.
    /// </summary>
    /// <param name="_owner">
    /// The owner of the cached value.
    /// </param>
    /// <param name="_key">
    /// The key of the cache value.
    /// </param>
    /// <param name="_value">
    /// The value to cache.
    /// </param>
    /// <returns>
    /// true if success; otherwise, return false.
    /// </returns>
    private boolean addResultToCache(str _owner, anytype _key, anytype _value)
    {
        boolean keyExists = false;
        Map oneMethodCache;

        if (methodsResultCache.exists(_owner))
        {
            oneMethodCache = methodsResultCache.lookup(_owner);
        }
        else
        {
            oneMethodCache = new Map(typeOf(_key), typeOf(_value));
            methodsResultCache.insert(_owner, oneMethodCache);
        }

        return oneMethodCache.insert(_key, _value);
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowNegativeCatchUpDep</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the negative depreciation is enabled in current calculation.
    /// </summary>
    /// <returns>
    /// Returns whether allow negative depreciation when catch up is enabled.
    /// </returns>
    protected boolean allowNegativeCatchUpDep()
    {
        boolean ret = false;

        if (calcArgs.parmIsReductionEntry()
            && calcArgs.parmReductionEntryMethod() == AssetReductionEntryMethod_JP::DirectOff
            && this.isReductionEntryInCurPeriod())
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the depreciation amount based on parameters
    /// </summary>
    /// <returns>
    /// The depreciation amount.
    /// </returns>
    public AssetAmount calc()
    {
        AssetAmount ret;
        AssetTableInterval depInterval = calcArgs.parmAssetTableInterval();
        AssetTransDate periodStart = calcArgs.parmPeriodstart();
        AssetAmount beginningBalanceOfDepForCurYear;
        AssetAmount beginningBalanceOfAccumlatedDepInCurYear;
        AssetAmount allowableLimitFinalSumOfYTD;
        AssetAmount remainingDepreciableAmount;
        AssetAmount beginningBalanceOfCurPeriod;
        AssetAmount leaveValue;

        calcArgs.parmIsCalculationStarted(true);

        if (calcArgs.parmUseCatchUpMethod()
            && (calcArgs.parmCatchUpInterval() == AssetDepreciationCatchUpInterval_JP::FiscalPeriod
                || (calcArgs.parmCatchUpInterval() == AssetDepreciationCatchUpInterval_JP::FiscalYear
                    && calcArgs.parmPeriodEnd() == depInterval.findLastDayOfYear(periodStart))))
        {
            beginningBalanceOfDepForCurYear = this.getBeginningBalanceOfAccumulatedDep(this.calcDepStartDateInCurYear());

            allowableLimitFinalSumOfYTD = this.calcAllowableLimitFinalSumOfDepToPeriod(depInterval.indexofPeriod(periodStart))
                                        - beginningBalanceOfDepForCurYear;
            beginningBalanceOfAccumlatedDepInCurYear = this.getBeginningBalanceOfAccumulatedDep(calcArgs.parmPeriodEnd()+1)
                                        - beginningBalanceOfDepForCurYear;
            // Setp 3
            // Use the beginning balance of next period for catch up calculation to aviod the issue about multi depreciation on same period.
            // Keep the sign of depreciation amount same as allowable limit sum of year to date. Because it is normally positive; but after
            // changeover from ODB to OSL, the calculation base (beginning balance of book value at the change - acquisition cost * 10%) can
            // become negetive;
            ret = allowableLimitFinalSumOfYTD - beginningBalanceOfAccumlatedDepInCurYear;
            if (sign(allowableLimitFinalSumOfYTD) * sign(ret) < 0
            	&& !this.allowNegativeCatchUpDep())
            {
                ret = 0;
            }
        }
        else
        {
            ret = this.calcAllowableLimitFinalDepForPeriod();
            ret = this.roundOffDepreciation(ret, true);
        }

        // Ensure depreciation does not go over the "leave net book value" or "Expected scrap value" setting
        AssetAmount assetAcquisitionValue = calcArgs.parmAssetAcquisitionValue();
        if (calcArgs.parmIsAffectedByScrapValue()
            && (assetAcquisitionValue >= 0
                    && ret > 0)
                || (assetAcquisitionValue < 0
                    && ret < 0))
        {
            leaveValue = assetAcquisitionValue >= 0
                ? max(calcArgs.parmNetBookValueRest(), calcArgs.parmScrapValue())
                : min(calcArgs.parmNetBookValueRest(), calcArgs.parmScrapValue());

            remainingDepreciableAmount  = calcArgs.parmAssetAcquisitionValue() - leaveValue - this.getExtraDepreciationAmount();
            beginningBalanceOfCurPeriod = this.getBeginningBalanceOfAccumulatedDep(calcArgs.parmPeriodEnd() + 1);
            if (abs(ret + beginningBalanceOfCurPeriod) >= abs(remainingDepreciableAmount))
            {
                ret = assetAcquisitionValue >= 0
                    ? max(0, remainingDepreciableAmount - beginningBalanceOfCurPeriod)
                    : min(0, remainingDepreciableAmount - beginningBalanceOfCurPeriod);

                remainingDepreciableAmount = calcArgs.parmTotalAmountToDepreciate() - leaveValue - this.getExtraDepreciationAmount();
                // NetBookValue is going to reach zero, the the depreciation going to be done.
                if (calcArgs.parmIsAffectedByNetBookValue()
                    && abs(ret + beginningBalanceOfCurPeriod) >= abs(remainingDepreciableAmount))
                {
                    ret = assetAcquisitionValue >= 0
                        ? max(0, remainingDepreciableAmount - beginningBalanceOfCurPeriod)
                        : min(0, remainingDepreciableAmount - beginningBalanceOfCurPeriod);

                    calcArgs.parmIsDepreciationDone(true);
                    calcArgs.parmIsNBVReachedZero(true);
                }
            }
        }

        // Rounding
        ret = this.roundOffDepreciation(ret);

        // Update the beginning balance of accumulated depreciation for next period
        this.updateBeginningBalanceOfAccumulatedDep(calcArgs.parmPeriodEnd()+1, ret);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAllowableLimitDepForCurYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the allowable limit depreciation amount for current year.
    /// </summary>
    /// <returns>
    /// The final allowable limit depreciation amount for current year.
    /// </returns>
    protected AssetAmount calcAllowableLimitDepForCurYear()
    {
        AssetAmount ret;
        AssetAmount beginningBalanceOfCurYear;
        AssetAmount allowableLimitFinalSumOfDepToYearEnd;
        AssetAmount allowableLimitForAccumulatedDep;

        ret = this.calcDepAmountForCurYear();

        if (this.smoothDepreciationForYear())
        {
            beginningBalanceOfCurYear = this.getBeginningBalanceOfAccumulatedDep(this.calcDepStartDateInCurYear());
            allowableLimitForAccumulatedDep = this.calcAllowableLimitForAccumulatedDep();
            allowableLimitFinalSumOfDepToYearEnd = min(allowableLimitForAccumulatedDep, ret + beginningBalanceOfCurYear);

            ret = allowableLimitFinalSumOfDepToYearEnd - beginningBalanceOfCurYear;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAllowableLimitFinalDepForPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the final allowable limit depreciation amount for current period.
    /// </summary>
    /// <returns>
    /// The final allowable limit depreciation amount for current period.
    /// </returns>
    /// <remarks>
    /// This method is used when not use the catch up method.
    /// </remarks>
    protected AssetAmount calcAllowableLimitFinalDepForPeriod()
    {
        // Step 2 for non-catch_up way
        AssetAmount ret;
        int numOfDepreciablePeriodInCurYear = this.calcNumOfDepreciablePeriodInCurYear();
        AssetAmount beginningBalanceOfCurPeriod;
        AssetAmount allowableLimitForAccumulatedDep;

        if (numOfDepreciablePeriodInCurYear > 0)
        {
            beginningBalanceOfCurPeriod = this.getBeginningBalanceOfAccumulatedDep(calcArgs.parmPeriodstart());
            allowableLimitForAccumulatedDep = this.calcAllowableLimitForAccumulatedDep();

            if (calcArgs.parmAssetDepreciationYear() == AssetDepreciationYear::Fiscal
                && calcArgs.parmAssetAccrualFiscal() == AssetAccrualFiscal::Yearly)
            {
                // For yearly depreciation, depreciation should only run once for each year.
                // So there is always only 1 depreciable period for earch year.
                numOfDepreciablePeriodInCurYear = 1;
            }

            ret = this.calcAllowableLimitDepForCurYear() / numOfDepreciablePeriodInCurYear;

            if (ret + beginningBalanceOfCurPeriod >= allowableLimitForAccumulatedDep)
            {
                ret = allowableLimitForAccumulatedDep - beginningBalanceOfCurPeriod;

                if (this.isDepDoneOnExceedAllowLimitForAccDep())
                {
                    // All allowable limited is going to be depreciated, then the depreciation is going to be done.
                    calcArgs.parmIsDepreciationDone(true);
                }
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAllowableLimitFinalSumOfDepToPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the final allowable limit for sum of depreciation from depreciation start date to specified period.
    /// </summary>
    /// <param name="_indexOfPeriod">
    /// The index of period.
    /// </param>
    /// <returns>
    /// The final allowable limit for sum of depreciation from depreciation start date to specified period.
    /// </returns>
    /// <remarks>
    /// This method is used when use the catch up method.
    /// </remarks>
    public AssetAmount calcAllowableLimitFinalSumOfDepToPeriod(int _indexOfPeriod)
    {
        // Step 2
        AssetAmount ret;
        AssetAmount beginningBalanceOfCurYear;
        AssetAmount allowableLimitForAccumulatedDep;
        container key = [_indexOfPeriod];
        container cachedValue;

        // Try to find result from cache
        cachedValue = this.getResultFromCache(funcName(), key);
        if (cachedValue != conNull())
        {
            return conPeek(cachedValue, 1);
        }

        beginningBalanceOfCurYear = this.getBeginningBalanceOfAccumulatedDep(this.calcDepStartDateInCurYear());
        allowableLimitForAccumulatedDep = this.calcAllowableLimitForAccumulatedDep();

        if (calcArgs.parmAssetIdlePeriods())
        {
            _indexOfPeriod -= calcArgs.parmAssetIdlePeriods();
        }

        ret = beginningBalanceOfCurYear + this.calcAllowableLimitSumOfDepToPeriod(_indexOfPeriod);

        if (abs(ret) >= abs(allowableLimitForAccumulatedDep))
        {
            ret = allowableLimitForAccumulatedDep;

            if (this.isDepDoneOnExceedAllowLimitForAccDep())
            {
                // All allowable limited is going to be depreciated, then the depreciation is going to be done.
                calcArgs.parmIsDepreciationDone(true);
            }
        }

        // Add result to cache
        this.addResultToCache(funcName(), key, ret);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAllowableLimitForAccumulatedDep</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the overall allowable limit of accumulated depreciation amount.
    /// </summary>
    /// <returns>
    /// The overall allowable limit of accumulated depreciation amount.
    /// </returns>
    protected AssetAmount calcAllowableLimitForAccumulatedDep()
    {
        AssetAmount ret;

    	ret = calcArgs.parmAllowableLimitForAccumulatedDep() - this.getExtraDepreciationAmount();
        if (calcArgs.getAssetDocumentType() == AssetDocumentType_JP::AssetRetirementObligation)
        {
            ret += calcArgs.parmDocumentAmountToDep();
        }

	    if (calcArgs.parmIsReductionEntry())
	    {
	        ret += this.getReductionEntryAdjustment(calcArgs.parmPeriodEnd());
	    }

        // Because this allowable limit (threshold) is used to compare with a rounded amount, it also needs to be rounded.
        ret = this.roundOffDepreciation(ret);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAllowableLimitSumOfDepToPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the allowable limit for sum of depreciation from depreciation start date to specified period.
    /// </summary>
    /// <param name="_indexOfPeriod">
    /// The index of period.
    /// </param>
    /// <returns>
    /// The allowable limit for sum of depreciation from depreciation start date to specified period.
    /// </returns>
    /// <remarks>
    /// The result has not been compared to the overall allowable limit of accumulated depreciation amount.
    /// </remarks>
    protected AssetAmount calcAllowableLimitSumOfDepToPeriod(int _indexOfPeriod)
    {
        // Step 1

        AssetAmount ret;
        int numOfDereciablePeriodInCurYear;
        AssetAmount depreciableAmountInCurYear;

        numOfDereciablePeriodInCurYear  = this.calcNumOfDepreciablePeriodInCurYear();
    	depreciableAmountInCurYear = this.calcAllowableLimitDepForCurYear();

        depreciableAmountInCurYear = this.roundOffDepreciation(depreciableAmountInCurYear, true);

        if (numOfDereciablePeriodInCurYear)
        {
            ret = depreciableAmountInCurYear * this.calcDepreciablePeriodYTD(_indexOfPeriod) / numOfDereciablePeriodInCurYear;
        }
        else
        {
            // There is no dereciable period in current year. Then always let each period to depreciate all amount for whole year.
            // In most cases, the depreciable amount for whole year should be 0 if there is no depreciation period.
            // But in some cases, it may be not 0. Like in the equally divided method, user manually adjust the depreciation mount
            // to smaller value. Then after N years, there may still have some amount to depreciate. All of such rest amount should directly
            // depreciated in the folling period (Maybe not only one period, as user can manually adjust the amount again).
            ret = depreciableAmountInCurYear;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcBaseAmountToDepreciate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the base amount to depreciate.
    /// </summary>
    /// <returns>
    /// The base amount to depreciate.
    /// </returns>
    protected AssetAmount calcBaseAmountToDepreciate()
    {
        AssetAmount ret;

        ret = calcArgs.parmAmountToDepreciate() - calcArgs.parmDocumentAmountToDep();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcBeginningBalanceOfAccumulatedDep</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the beginning balance of accumulated depreciation amount for specified date.
    /// </summary>
    /// <param name="_date">
    /// The date.
    /// </param>
    /// <returns>
    /// The beginning balance of accumulated depreciation amount for specified date.
    /// </returns>
    protected AssetAmount calcBeginningBalanceOfAccumulatedDep(AssetTransDate _date)
    {
        AssetAmount ret;
        AssetBook assetBook;

        assetBook.AssetId = calcArgs.parmAssetId();
        assetBook.BookId = calcArgs.parmAssetBookId();

        if (calcArgs.parmIsReductionEntry()
            && calcArgs.parmReductionEntryMethod() == AssetReductionEntryMethod_JP::Reserve)
        {
            ret = AssetDepTransMap_JP::calcBeginningBalOfAccumulatedAlloAmtMst(assetBook, calcArgs.parmAssetTableInterval(), _date);
        }
        else
        {
            ret = AssetDepTransMap_JP::calcBeginningBalOfAccumulatedDepAmtMst(assetBook, calcArgs.parmAssetTableInterval(), _date);
            if (calcArgs.getAssetDocumentType() != AssetDocumentType_JP::None)
            {
                ret += AssetDepTransMap_JP::calcBeginningBalOfAccumulatedDepAmtMst(
                    assetBook,
                    calcArgs.parmAssetTableInterval(),
                    _date,
                    calcArgs.parmAssetDocumentEntry().RecId);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCurYearDepRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the depreciation rate as real for current year.
    /// </summary>
    /// <returns>
    /// The depreciation rate for current year.
    /// </returns>
    /// <remarks>
    /// The result has been ajdusted for the case of less than one year.
    /// </remarks>
    protected real calcCurYearDepRate()
    {
        real ret;
        real depRateNominator;
        real depRateDenominator;

        [depRateNominator, depRateDenominator] = this.calcCurYearDepRateAsFraction();
        if (depRateDenominator != 0)
        {
            ret = depRateNominator / depRateDenominator;
            ret = this.roundOffDepreciationRate(ret);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCurYearDepRateAsFraction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the depreciation rate as fraction for current year.
    /// </summary>
    /// <returns>
    /// The depreciation rate for current year.
    /// </returns>
    /// <remarks>
    /// The result has been ajdusted for the case of less than one year.
    /// </remarks>
    protected container calcCurYearDepRateAsFraction()
    {
        container con;
        real depRateNominator;
        real depRateDenominator = 1;

        depRateNominator = this.calcYearlyDepRate() * this.calcDepreciableRatioForCurYear();
        depRateNominator = this.roundOffDepreciationRate(depRateNominator);

        con = [depRateNominator, depRateDenominator];

        return con;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcDepAmountForCurYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates ideal depreciation amount for current year.
    /// </summary>
    /// <returns>
    /// Returns ideal depreciation amount for current year.
    /// </returns>
    protected AssetAmount calcDepAmountForCurYear()
    {
        AssetAmount     ret;
        container       depRateAsFraction;
        real            depRateNominator;
        real            depRateDenominator;

        depRateAsFraction = this.calcCurYearDepRateAsFraction();
        [depRateNominator, depRateDenominator] = depRateAsFraction;

        if (depRateDenominator != 0)
        {
            ret = this.calcFinalAmountToDepreciate() * depRateNominator / depRateDenominator;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcDepAndTotalNumOfPeriodsForCurYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate the acutual deprecaition time and total time for current year
    /// </summary>
    /// <returns>
    /// container contains actual depreciation time and total time for current year
    /// [actual depreciation time, total time]
    /// </returns>
    protected container calcDepAndTotalNumOfPeriodsForCurYear()
    {
        container ret;
        AssetTransDate startDateInCurYear;
        AssetTransDate depEndDateInCurYear;
        AssetTableInterval  depInterval = calcArgs.parmAssetTableInterval();
        AssetTransDate periodStart = calcArgs.parmPeriodstart();

        AssetTransDate depEndDateInCurPeriod;
        AssetTransDate curDate;

        int numOfYearPerFiscalYear = 0;
        boolean isYearlyFiscalYear = false;

        int numOfMonthPerPeriod = 0;
        boolean isMonthlyPeriod = false;

        int i;

        #TimeConstants
        #define.DaysPerYear(365)

        depEndDateInCurYear = depInterval.findLastDayOfYear(periodStart);
        startDateInCurYear = depInterval.findFirstDayOfYear(periodStart);

        if (depEndDateInCurYear < startDateInCurYear)
        {
            ret = [0, 1];
        }
        else
        {
            // Check if the length of period is 1 or more years.
            curDate = startDateInCurYear;
            while (curDate < depEndDateInCurYear)
            {
                curDate = nextYr(curDate);
                numOfYearPerFiscalYear++;

                if (curDate == depEndDateInCurYear + 1)
                {
                    isYearlyFiscalYear = true;
                    break;
                }
            }

            if (isYearlyFiscalYear)
            {
                ret = [numOfYearPerFiscalYear, 1];
            }
            else
            {
                // Check if the length of period is 1 or more months.
                depEndDateInCurPeriod = depInterval.endPeriod(startDateInCurYear);
                curDate = startDateInCurYear;
                while (curDate < depEndDateInCurPeriod)
                {
                    curDate = nextMth(curDate);
                    numOfMonthPerPeriod++;

                    if (curDate == depEndDateInCurPeriod + 1)
                    {
                        isMonthlyPeriod = true;
                        break;
                    }
                }

                // Go thorugh the rest period to make sure all periods are by month
                while (isMonthlyPeriod && depEndDateInCurPeriod < depEndDateInCurYear)
                {
                    // Switch to next period
                    curDate                 = depEndDateInCurPeriod + 1;
                    depEndDateInCurPeriod   = depInterval.endPeriod(curDate);
                    // Assume this period is still by month, calc the next period start date.
                    for (i = 1; i <= numOfMonthPerPeriod; i++)
                    {
                        curDate = nextMth(curDate);
                    }

                    if (curDate != depEndDateInCurPeriod + 1)
                    {
                        // The calculated next start day is not the real start day of next period.
                        // So the period length is not by month.
                        isMonthlyPeriod = false;
                    }
                }

                if (isMonthlyPeriod)
                {
                    // The period length is one month
                    ret = [this.calcNumOfDepreciablePeriodInCurYear() * numOfMonthPerPeriod, #monthsPerYear];
                }
                else
                {
                    // Calculate the rate based on days.
                    ret = [depEndDateInCurYear - startDateInCurYear + 1,  #DaysPerYear];
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcDepreciablePeriodYTD</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the number of depreciable period from the first period of current year to current period.
    /// </summary>
    /// <param name="_indexOfPeriod">
    /// The index of current period.
    /// </param>
    /// <returns>
    /// The number of depreciable period from the first period of current year to current period.
    /// </returns>
    /// <remarks>
    /// The current period is included.
    /// </remarks>
    protected int calcDepreciablePeriodYTD(int _indexOfPeriod)
    {
        int ret;

        if (calcArgs.parmAssetDepreciationYear() == AssetDepreciationYear::Fiscal
            && calcArgs.parmAssetAccrualFiscal() == AssetAccrualFiscal::Yearly)
        {
            // For yearly depreciation, only depreciate once for the whole year.
            ret = 1;
        }
        else
        {
            ret = max(0, (_indexOfPeriod - this.calcNumOfNotDepreciablePeriodInCurYear()));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcDepreciableRatioForCurYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the ratio of depreciable time in current fiscal year compare to a whole calendar year.
    /// </summary>
    /// <returns>
    /// The ratio of depreciable time in current fiscal year compare to a whole calendar year.
    /// </returns>
    protected real calcDepreciableRatioForCurYear()
    {
        real ret;
        container con = this.calcDepAndTotalNumOfPeriodsForCurYear();
        int depreciablePeriods;
        int totalPeriods;

        [depreciablePeriods, totalPeriods] = con;

        ret = depreciablePeriods / totalPeriods;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcDepStartDateInCurYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the depreciation start date in current year.
    /// </summary>
    /// <returns>
    /// The depreciation start date in current year.
    /// </returns>
    public AssetTransDate calcDepStartDateInCurYear()
    {
        AssetTransDate ret;
        AssetTableInterval  depInterval = calcArgs.parmAssetTableInterval();
        AssetTransDate periodStart = calcArgs.parmPeriodstart();

        ret = max(
            depInterval.findFirstDayOfYear(periodStart),
            calcArgs.parmStartToDepreciateDate());

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcDepStartDateInCurYearBeyondChange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the depreciation start date of the asset in current year
    /// regardless of depreciation profile change.
    /// </summary>
    /// <returns>
    /// The depreciation start date in current year.
    /// </returns>
    public AssetTransDate calcDepStartDateInCurYearBeyondChange()
    {
        AssetTransDate ret;
        AssetTableInterval  depInterval = calcArgs.parmAssetTableInterval();
        AssetTransDate periodStart = calcArgs.parmPeriodstart();

        ret = max(
            depInterval.findFirstDayOfYear(periodStart),
            calcArgs.parmDepreciationStartDate());

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcFinalAmountToDepreciate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the final base amount to depreciate.
    /// </summary>
    /// <returns>
    /// The base amount to depreciate.
    /// </returns>
    protected AssetAmount calcFinalAmountToDepreciate()
    {
        AssetAmount ret;

        ret = this.calcBaseAmountToDepreciate() + calcArgs.parmDocumentAmountToDep();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcNumOfDepreciablePeriodInCurYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the number of depreciable period in current year.
    /// </summary>
    /// <returns>
    /// The number of depreciable period in current year.
    /// </returns>
    protected int calcNumOfDepreciablePeriodInCurYear()
    {
        int ret;
        AssetTransDate depStartDateInCurYear = this.calcDepStartDateInCurYear();
        AssetTableInterval depInterval = calcArgs.parmAssetTableInterval();
        AssetTransDate periodStart = calcArgs.parmPeriodstart();

        if (depStartDateInCurYear > depInterval.findLastDayOfYear(periodStart))
        {
            ret = 0;
        }
        else
        {
            if (calcArgs.parmAssetDepreciationYear() == AssetDepreciationYear::Fiscal
                && calcArgs.parmAssetAccrualFiscal() == AssetAccrualFiscal::Yearly)
            {
                ret = 1;
            }
            // depreciable period starts from the first day of current year.
            else if (calcArgs.parmAssetDepreciationYear() == AssetDepreciationYear::Fiscal
                && (calcArgs.parmAssetAccrualFiscal() == AssetAccrualFiscal::FiscalPeriod
                    ||calcArgs.parmAssetAccrualFiscal() == AssetAccrualFiscal::Quarterly))
            {
                ret = depInterval.numOfPeriodsLeftInYear(depInterval.findFirstDayOfYear(periodStart));
            }
            // depreciable period starts from max(first day of current year, depreication start date).
            else
            {
                ret = depInterval.numOfPeriodsLeftInYear(depStartDateInCurYear);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcSplitAssetExtraDeprAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the sum of the extra depreciation amount after split asset.
    /// </summary>
    /// <remarks>
    /// When a split occurs, it splits the total depreciation from the parent. This total depreciation could span multiple years.
    /// But instead of allocating the depreciation across the same years as the parent, the split amount is just a single value.
    /// To calculate the beginning balance correctly, the portion of the split amount that occurred in the year(s) before the last depreciation date
    /// should be removed from the beginning balance. This portion to be removed is called the extraDeprAmount.
    /// </remarks>
    /// <param name="_date">
    /// The date of ending calculation period.
    /// </param>
    /// <returns>
    /// Extra depreciation amount.
    /// </returns>
    public AssetAmount calcSplitAssetExtraDeprAmount(AssetTransDate _date)
    {
        AssetAmount ret;
        if (doesSplittedAssetJournalExist)
        {
            List splitAmountsToProcess = this.findSplitTransactions(_date);
            ListEnumerator listEnumerator = splitAmountsToProcess.getEnumerator();

            while (listEnumerator.moveNext())
            {
                AssetDepCalculationSplitContract_JP contract = listEnumerator.current();

                this.findPriorYearSplitAmount(_date, contract);
                if (contract.parmIsSplitBrokenUpByYear())
                {
                    // Only consider this amount if its depreciation. This is because depreciaiton adjustment is already factored into the beginning balance.
                    // See AssetDepTransMap_JP.calcBeginningBalOfAccumulatedDepAmtMst() for how this is considered in the beginning balance.
                    // Instead of changing that logic, just skip deprAdj for this calculation and only focus on depreciation.
                    if (contract.getTransType() == AssetTransType::Depreciation)
                    {
                        ret += contract.parmPriorYearSplitAmount();
                    }
                }    
                else
                {
                    ret += this.calculateSplitAmounts(contract);
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findSplitTransactions</Name>
				<Source><![CDATA[
    private List findSplitTransactions(AssetTransDate _date)
    {
        // Find all depreciation amounts for the splits that occurred during this timeframe for this asset.
        // This could include "split from" as well as "split to".

        AssetTransDate periodEnd = calcArgs.parmPeriodEnd();
        AssetTableInterval depInterval = calcArgs.parmAssetTableInterval();
        AssetTransDate startDateYear = depInterval.findFirstDayOfYear(_date);
        AssetTransDate endDateYear = depInterval.findLastDayOfYear(_date);
        AssetId assetId = calcArgs.parmAssetId();
        AssetBookId assetBookId = calcArgs.parmAssetBookId();

        AssetTrans assetTrans;
        LedgerJournalTrans ledgerJournalTrans;
        LedgerJournalTrans_Asset ledgerJournalTransAsset;
        LedgerJournalTable ledgerJournalTable;
        TransactionReversalTrans reversalTrans;
            
        List splitAmountsToProcess = new List(Types::Class);

        while select sum(AmountMST), maxof(TransType), maxof(TransDate)
            from assetTrans
            where assetTrans.AssetId == assetId
                && assetTrans.BookId == assetBookId
                && assetTrans.TransDate >= _date
                && assetTrans.TransDate <= min(periodEnd, endDateYear)
            join JournalNum from ledgerJournalTrans
                group by JournalNum
                where ledgerJournalTrans.Voucher == assetTrans.Voucher
                    && ledgerJournalTrans.TransDate == assetTrans.TransDate
                    && ((assetTrans.TransType == AssetTransType::Depreciation && ledgerJournalTrans.AmountCurCredit != 0) || (assetTrans.TransType == AssetTransType::DepreciationAdj && ledgerJournalTrans.AmountCurDebit != 0))
            join ledgerJournalTransAsset
                where ledgerJournalTransAsset.RefRecId == ledgerJournalTrans.RecId
                    && ledgerJournalTransAsset.IsPriorYear == assetTrans.IsPriorYear
            join ledgerJournalTable
                where ledgerJournalTable.JournalNum == ledgerJournalTrans.JournalNum
                    && ledgerJournalTable.Name == "@SYS67430"
            notexists join reversalTrans
                where reversalTrans.RefRecId  == assetTrans.RecId
                    && reversalTrans.RefTableId == tableNum(AssetTrans)
                    && reversalTrans.Reversed == NoYes::Yes
        {
            AssetDepCalculationSplitContract_JP contract = AssetDepCalculationSplitContract_JP::construct(assetTrans.AmountMST, ledgerJournalTrans.JournalNum, assetTrans.TransType, assetTrans.TransDate, startDateYear);
            splitAmountsToProcess.addEnd(contract);
        }

        return splitAmountsToProcess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPriorYearSplitAmount</Name>
				<Source><![CDATA[
    private void findPriorYearSplitAmount(AssetTransDate _date, AssetDepCalculationSplitContract_JP _contract)
    {
        AssetTableInterval depInterval = calcArgs.parmAssetTableInterval();
        AssetTransDate endDateYear = depInterval.findLastDayOfYear(_date);
        AssetId assetId = calcArgs.parmAssetId();

        AssetTrans assetTrans;
        LedgerJournalTrans ledgerJournalTrans;

        container assetTransTypes = [AssetTransType::Depreciation, AssetTransType::DepreciationAdj];

        // When depreciation is split, it is broken up into 2 transactions. One for the current year and one for the prior year.
        select firstonly RecId, AmountCur from assetTrans
            where assetTrans.AssetId == assetId
                && assetTrans.BookId == calcArgs.parmAssetBookId()
                && assetTrans.TransDate >= _date
                && assetTrans.TransDate <= endDateYear
                && assetTrans.TransType in assetTransTypes
                && assetTrans.IsPriorYear == NoYes::Yes
            join ledgerJournalTrans
                where ledgerJournalTrans.Voucher == assetTrans.Voucher
                    && ledgerJournalTrans.TransDate == assetTrans.TransDate
                    && ledgerJournalTrans.JournalNum == _contract.getJournalNum();

        boolean isSplitBrokenUpByYear = assetTrans.RecId != 0 && !assetTrans.reversed();

        // Its possible that the AssetSplitBreakUpTransactionsByYear flight is enabled, data is created, then disabled.
        // Instead of relying on the flight, rely on the data to tell us how it was created.
        _contract.parmIsSplitBrokenUpByYear(isSplitBrokenUpByYear);
        _contract.parmPriorYearSplitAmount(assetTrans.AmountCur);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSplitAmounts</Name>
				<Source><![CDATA[
    private AssetAmount calculateSplitAmounts(AssetDepCalculationSplitContract_JP _contract)
    {
        AssetAmount ret;
        AssetAmount splitDeprAmount = abs(_contract.getSplitAmount());

        AssetId assetId = calcArgs.parmAssetId();

        // Default the deprAdj asset id to the current asset id and book
        AssetId deprAdjAssetId = assetId;
        AssetBookId deprAdjAssetBookId = calcArgs.parmAssetBookId();

        // The latter half of this method's calculations require using the "split from" asset amounts. Find the matching "split from" if this is the "split to" asset.
        // _TransType_              | _Asset_
        // Depreciation             | Split to/child
        // Depreciation Adjustment  | Split from/parent
        if (_contract.getTransType() == AssetTransType::Depreciation)
        {
            this.findMatchingAssetFromSplit(_contract);

            deprAdjAssetId = _contract.parmDepreciationAdjustmentAssetId();
            deprAdjAssetBookId = _contract.parmDepreciationAdjustmentBookId();
        }

        // assetTrans.TransDate is the LastDepreciationDate (LDD) for the "split from" asset (see the AssetSplit class).
        AssetSumCalc_Trans assetSumCalc_Trans = AssetSumCalc_Trans::newAssetPeriod(deprAdjAssetId, deprAdjAssetBookId, dateNull(), _contract.getTransDate());

        // By adding splitDeprAmount to the total depreciation/adj, we get the total depreciation for the "split from" asset up to the date of the split.
        AssetAmount depreciationValue = abs(assetSumCalc_Trans.depreciationValue() + assetSumCalc_Trans.depreciationAdjValue()) + splitDeprAmount;

        if (depreciationValue)
        {
            // We can now reverse-engineer the percentage of the split. This should be .25 if the split was for 25%.
            Percent percent = abs(splitDeprAmount / depreciationValue);

            assetSumCalc_Trans = AssetSumCalc_Trans::newAssetPeriod(deprAdjAssetId, deprAdjAssetBookId, _contract.getStartDateYear(), _contract.getTransDate());

            // This is the total amount of depreciation between the start of the year and the split. 
            AssetAmount deprAmountPrevPeriod = assetSumCalc_Trans.depreciationValue() + assetSumCalc_Trans.depreciationAdjValue();

            /*
            Example:
            
            Split Percent = 10%
            Total Parent Depreciation = 3000

            |Previous Year | Current year |
            |--------------|--------------|
                2000            1000

            300 depreciation is created for the child asset, but all placed in the current year. However, not all of that belongs in the current year.
            The ratio of previous year/total = 2000/3000 = 2/3 so 2/3 of 300 should be in the previous year = 200.

            If no other DeprAdj exist, the total DeprAdj will equal splitDeprAmount.            
            deprAmountPrevPeriod = -1000 + 300 (depreciaiton + depreciation adjustment) = -700

            extraDeprAmount = 300 - abs(-700 - 300) * .1
            extraDeprAmount = 300 - (1000 * .1)
            extraDeprAmount = 200
            */
            AssetAmount extraDeprAmount = splitDeprAmount - abs(deprAmountPrevPeriod - splitDeprAmount) * percent;

            if (_contract.getTransType() == AssetTransType::DepreciationAdj)
            {
                ret += extraDeprAmount;
            }
            else
            {
                ret -= extraDeprAmount;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findMatchingAssetFromSplit</Name>
				<Source><![CDATA[
    private void findMatchingAssetFromSplit(AssetDepCalculationSplitContract_JP _contract)
    {
        AssetId assetId = calcArgs.parmAssetId();

        AssetTrans assetTrans;
        LedgerJournalTrans ledgerJournalTrans;
        TransactionReversalTrans reversalTrans;

        select firstOnly AssetId, BookId from assetTrans
            where assetTrans.AssetId != assetId
                && assetTrans.TransType == AssetTransType::DepreciationAdj
            join ledgerJournalTrans
                where ledgerJournalTrans.Voucher == assetTrans.Voucher
                    && ledgerJournalTrans.TransDate == assetTrans.TransDate
                    && ledgerJournalTrans.JournalNum == _contract.getJournalNum()
            notexists join reversalTrans
                where reversalTrans.RefRecId  == assetTrans.RecId
                    && reversalTrans.RefTableId == tableNum(AssetTrans)
                    && reversalTrans.Reversed == NoYes::Yes;

        if (assetTrans.AssetId)
        {
            _contract.parmDepreciationAdjustmentAssetId(assetTrans.AssetId);
            _contract.parmDepreciationAdjustmentBookId(assetTrans.BookId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcNumOfNotDepreciablePeriodInCurYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the number of not depreciable period in current year.
    /// </summary>
    /// <returns>
    /// The number of not depreciable period in current year.
    /// </returns>
    /// <remarks>
    /// Not depreciable period can only exists at the beginning of the year.
    /// </remarks>
    protected int calcNumOfNotDepreciablePeriodInCurYear()
    {
        int ret;
        AssetTableInterval depInterval = calcArgs.parmAssetTableInterval();

        ret = depInterval.indexofPeriod(this.calcDepStartDateInCurYear()) - 1;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcYearlyDepRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the yearly depreciation rate.
    /// </summary>
    /// <returns>
    /// The yearly depreciation rate.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// If the rate is not deifned in the fixed asset depreciation rate schedule,
    /// an error will be thrown and user need to define the rate before run again.
    /// </exception>
    protected real calcYearlyDepRate()
    {
        AssetAmount ret = 0;
        AssetDepRate_JP assetDepRate;

        assetDepRate = AssetDepRate_JP::find(
            calcArgs.parmAssetDepRateSet(),
            this.getAssetDepreciationMethod(),
            this.getServiceLife());

        if (assetDepRate.RecId == 0)
        {
            // The depreciation rate is not available in the depreciation rate schedule. Please add the depreciation rate to the depreciation rate schedule or select another schedule.
            throw error("@SYS4002748");
        }

        ret = assetDepRate.DepreciationRate;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getServiceLife</Name>
				<Source><![CDATA[
    internal AssetServiceLife getServiceLife()
    {
        return calcArgs.parmStartAdjustmentPeriodDate()
            ? calcArgs.parmServiceLifeAfterAdjustment()
            : calcArgs.parmAssetServiceLife();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAssetDepreciationMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the type of depreciation method.
    /// </summary>
    /// <returns>
    /// The type of depreciation method.
    /// </returns>
    abstract public AssetDepreciationMethod getAssetDepreciationMethod()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBeginBalanceOfAccumulatedDepResult</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the beginning balance result which based on the cache calculated in process of calculation.
    /// </summary>
    /// <returns>
    /// The calculation cache of accumulated depreciation beginning balance amount
    /// </returns>
    public Map getBeginBalanceOfAccumulatedDepResult()
    {
        return beginningBalanceOfAccumulatedDepCache;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBeginBalanceOfAccumulatedExtDepResult</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the beginning balance result of extraordinary depreciation amount based on extraordinary depreciation trans.
    /// </summary>
    /// <returns>
    /// The calculation cache of accumulated extraordinary depreciation beginning balance amount
    /// </returns>
    public Map getBeginBalanceOfAccumulatedExtDepResult()
    {
        return beginningBalanceOfAccumulatedExtDepCache;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBeginningBalanceOfAccumulatedDep</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the beginning balance of accumulated depreciation amount for specified date.
    /// </summary>
    /// <param name="_date">
    /// The date.
    /// </param>
    /// <returns>
    /// The beginning balance of accumulated depreciation amount for specified date.
    /// </returns>
    /// <remarks>
    /// It will use cache to improve performance. And the cache is also used to avoid
    /// accessing database for recatpure function.
    /// </remarks>
    final public AssetAmount getBeginningBalanceOfAccumulatedDep(AssetTransDate _date)
    {
        AssetAmount         ret;
        AssetTransDate      prevPeriodStartDate;

        prevPeriodStartDate = calcArgs.parmAssetTableInterval().startOfPeriod(_date == dateNull() ? dateNull() : _date - 1 );

        if (calcArgs.parmPeriodStart() < _date)
        {
            prevPeriodStartDate = max(prevPeriodStartDate, calcArgs.parmPeriodStart());
        }

        if (beginningBalanceOfAccumulatedDepCache.exists(_date))
        {
            ret = beginningBalanceOfAccumulatedDepCache.lookup(_date);
        }
        else if (beginningBalanceOfAccumulatedDepCache.exists(prevPeriodStartDate))
        {
            // Add this logic to fix the cache continuity when period frequecy changes
            // between Yearly and Fiscal period during depreciaiton profile change
            ret = beginningBalanceOfAccumulatedDepCache.lookup(prevPeriodStartDate)
                + this.calcBeginningBalanceOfAccumulatedDep(_date)
                - this.calcBeginningBalanceOfAccumulatedDep(prevPeriodStartDate)
                - this.calcSplitAssetExtraDeprAmount(_date);
            beginningBalanceOfAccumulatedDepCache.insert(_date, ret);
        }
        else
        {
            ret = this.calcBeginningBalanceOfAccumulatedDep(_date) - this.calcSplitAssetExtraDeprAmount(_date);
            beginningBalanceOfAccumulatedDepCache.insert(_date, ret);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBeginningBalanceOfAccumulatedExtDep</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the beginning balance of accumulated extraordinary depreciation amount for specified date.
    /// </summary>
    /// <param name="_date">
    /// The date.
    /// </param>
    /// <returns>
    /// The beginning balance of accumulated extraordinary depreciation amount for specified date.
    /// </returns>
    /// <remarks>
    /// It will use cache to improve performance. And the cache is also used to avoid
    /// accessing database for recatpure function.
    /// </remarks>
    public AssetAmount getBeginningBalanceOfAccumulatedExtDep(AssetTransDate _date)
    {
        AssetAmount         ret;
        AssetBook           assetBook;

        if (beginningBalanceOfAccumulatedExtDepCache.exists(_date))
        {
            ret = beginningBalanceOfAccumulatedExtDepCache.lookup(_date);
        }
        else
        {
            assetBook.AssetId = calcArgs.parmAssetId();
            assetBook.BookId = calcArgs.parmAssetBookId();

            ret = AssetDepTransMap_JP::calcAccumulatedExtraDepAmtMst(assetBook, dateNull(), _date - 1);
            beginningBalanceOfAccumulatedExtDepCache.insert(_date, ret);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExtraDepreciationAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns extra deprecation amount.
    /// </summary>
    /// <returns>
    /// extra depreciation amouny which impact net book value.
    /// </returns>
    protected AssetAmount getExtraDepreciationAmount()
    {
        return calcArgs.parmAccumulatedExtraDepAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReductionEntryAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the reduction entry adjustment amount for specified date.
    /// </summary>
    /// <param name="_date">
    /// The date.
    /// </param>
    /// <returns>
    /// The reduction entry adjustment amount for specified date.
    /// </returns>
    public AssetAmount getReductionEntryAdjustment(AssetTransDate _date)
    {
        AssetAmount preAdjustAmount;
        AssetAmount postAdjustAmount;
        Counter counter;
        counter conLength;
        container conReductionEntry;
        AssetAmount preAmount;
        AssetAmount postAmount;
        AssetTransDate transDate;
        AssetAmount ret;

        if (calcArgs.parmIsReductionEntry())
        {
            conReductionEntry = calcArgs.parmReductionEntryContainer();
            conLength = conLen(conReductionEntry);
            for (counter = 1; counter <= conLength; counter++)
            {
                [transDate, preAmount, postAmount] = conPeek(conReductionEntry, counter);
                if (transDate <= _date)
                {
                    preAdjustAmount += preAmount;
                    postAdjustAmount += postAmount;
                }
                else
                {
                    break;
                }
            }
            if (calcArgs.parmReductionEntryMethod() == AssetReductionEntryMethod_JP::DirectOff)
            {
                ret = preAdjustAmount - postAdjustAmount;
            }
            else if (calcArgs.parmReductionEntryMethod() == AssetReductionEntryMethod_JP::Reserve)
            {
                ret = postAdjustAmount - preAdjustAmount;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReductionEntryAdjustmentAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the reduction entry adjustment amount for specified date.
    /// </summary>
    /// <param name="_date">
    /// The date.
    /// </param>
    /// <returns>
    /// The reduction entry pre-adjustment and post-adjustment amount for specified date.
    /// </returns>
    public container getReductionEntryAdjustmentAmounts(AssetTransDate _date)
    {
        AssetAmount preAdjustAmount;
        AssetAmount postAdjustAmount;
        Counter counter;
        counter conLength;
        container conReductionEntry;
        AssetAmount preAmount;
        AssetAmount postAmount;
        AssetTransDate transDate;

        conReductionEntry = calcArgs.parmReductionEntryContainer();
        conLength = conLen(conReductionEntry);
        for (counter = 1; counter <= conLength; counter++)
        {
            [transDate, preAmount, postAmount] = conPeek(conReductionEntry, counter);
            if (transDate <= _date)
            {
                preAdjustAmount += preAmount;
                postAdjustAmount += postAmount;
            }
            else
            {
                break;
            }
        }

        return [preAdjustAmount,postAdjustAmount];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReductionEntryOriginBeginningBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the beginning balance of accumulated depreciation amount for specified date.
    /// </summary>
    /// <param name="_date">
    /// The date.
    /// </param>
    /// <returns>
    /// The beginning balance of accumulated depreciation amount for specified date.
    /// </returns>
    /// <remarks>
    /// It will use cache to improve performance. And the cache is also used to avoid
    /// accessing database for recatpure function.
    /// </remarks>
    final public AssetAmount getReductionEntryOriginBeginningBalance(AssetTransDate _date)
    {
        AssetAmount ret;
        AssetBook assetBook;
        MapEnumerator enumerator;
        AssetTransDate transDate;
        assetBook.AssetId = calcArgs.parmAssetId();
        assetBook.BookId = calcArgs.parmAssetBookId();

        if (calcArgs.parmReductionEntryBeginBalanceMap().exists(_date))
        {
            ret = calcArgs.parmReductionEntryBeginBalanceMap().lookup(_date);
        }
        else
        {
            enumerator = calcArgs.parmReductionEntryBeginBalanceMap().getEnumerator();
            while (enumerator.moveNext())
            {
                transDate = enumerator.currentKey();
                if (transDate < _date)
                {
                    ret = enumerator.currentValue();
                }
                else
                {
                    transDate = dateNull();
                    break;
                }
            }

            // before map range, gather data from posted transaction
            if (!transDate)
            {
                ret = AssetDepTransMap_JP::calcBeginningBalOfAccumulatedDepAmtMst(assetBook, calcArgs.parmAssetTableInterval(), _date);
                calcArgs.parmReductionEntryBeginBalanceMap().insert(_date, ret);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResultFromCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a result from method result cache.
    /// </summary>
    /// <param name="_owner">
    /// The owner of the cached value.
    /// </param>
    /// <param name="_key">
    /// The key of the cache value.
    /// </param>
    /// <returns>
    /// The value.
    /// </returns>
    private container getResultFromCache(str _owner, anytype _key)
    {
        anytype value;
        Map oneMethodCache;
        container ret;

        if (methodsResultCache.exists(_owner))
        {
            oneMethodCache = methodsResultCache.lookup(_owner);
            if (oneMethodCache.exists(_key))
            {
                value = oneMethodCache.lookup(_key);
                ret = [value];
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes anything needed for this instance.
    /// </summary>
    public void init()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initAdditionalAssetTableIntervals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes additional <C>AssetTableInterval</C>
    /// </summary>
    /// <param name="_assetTableIntervals">
    /// <C>AssetTableInterval</C> map
    /// </param>
    public void initAdditionalAssetTableIntervals(Map _assetTableIntervals)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDepDoneOnExceedAllowLimitForAccDep</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if depreciation is done when accumulated depreciation amount exceeds
    /// allowable limit for accumulated depreciation.
    /// </summary>
    /// <returns>
    /// true if depreciation is done; otherwise, reture false.
    /// </returns>
    protected boolean isDepDoneOnExceedAllowLimitForAccDep()
    {
        boolean ret;

        ret = true;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDepDoneOnExceedAmountToDepreciate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if depreciation is done when accumulated depreciation amount exceeds
    /// the amount to be depreciated.
    /// </summary>
    /// <returns>
    /// true if depreciation is done; otherwise, reture false.
    /// </returns>
    protected boolean isDepDoneOnExceedAmountToDepreciate()
    {
        boolean ret;

        ret = true;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPutInUseYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the current period is in the year asset put to use.
    /// </summary>
    /// <returns>
    /// true if it is the first period is in the year asset put to use; otherwise, return false
    /// </returns>
    protected boolean isPutInUseYear()
    {
        boolean ret = false;
        AssetTableInterval  depInterval = calcArgs.parmAssetTableInterval();
        AssetTransDate periodStart = calcArgs.parmPeriodstart();

        if (depInterval.findFirstDayOfYear(periodStart) ==
            depInterval.findFirstDayOfYear(calcArgs.parmDepreciationStartDate()))
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReductionEntryInCurPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the reduction entry occur incurrent period.
    /// </summary>
    /// <returns>
    /// true if it is in current period; otherwise, return false.
    /// </returns>
    protected boolean isReductionEntryInCurPeriod()
    {
        boolean ret = false;
        AssetTransDate periodStart = calcArgs.parmPeriodStart();
        AssetTransDate periodEnd = calcArgs.parmPeriodEnd();
        AssetTransDate reductionEntryDate = dateNull();
        Counter counter;
        counter conLength;
        container conReductionEntry;

        conReductionEntry = calcArgs.parmReductionEntryContainer();
        conLength = conLen(conReductionEntry);
        for (counter = 1; counter <= conLength; counter++)
        {
            [reductionEntryDate]  = conPeek(conReductionEntry, counter);
            if (reductionEntryDate >= periodStart
                && reductionEntryDate <= periodEnd)
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTheFirstPeriodInCurYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the current period is the first period in current year.
    /// </summary>
    /// <returns>
    /// true if it is the first period; otherwise, return false.
    /// </returns>
    protected boolean isTheFirstPeriodInCurYear()
    {
        boolean ret = false;
        AssetTableInterval  depInterval = calcArgs.parmAssetTableInterval();
        AssetTransDate periodStart = calcArgs.parmPeriodstart();

        if (depInterval.indexofPeriod(periodStart) == 1)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTheLastPeriodInCurYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the current period is the last period in current year.
    /// </summary>
    /// <returns>
    /// true if it is the last period; otherwise, return false.
    /// </returns>
    protected boolean isTheLastPeriodInCurYear()
    {
        boolean ret = false;
        AssetTableInterval depInterval = calcArgs.parmAssetTableInterval();
        AssetTransDate periodEnd = calcArgs.parmPeriodEnd();

        if (depInterval.findLastDayOfYear(periodEnd) == periodEnd)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new instance of <C>AssetDepCalculation_JP</C>.
    /// </summary>
    /// <param name="_calcArgs">
    /// An instance of class <C>AssetDepCalculationArgs_JP</C> which includes all calculation related parameters.
    /// </param>
    public void new(AssetDepCalculationArgs_JP _calcArgs)
    {
        GlobalizationInstrumentationHelper::featureRun(FeatureReference, funcName());

        calcArgs = _calcArgs;

        methodsResultCache = new Map(Types::String, Types::Class);
        beginningBalanceOfAccumulatedDepCache = _calcArgs.parmBeginningBalanceOfAccDepCache();
        beginningBalanceOfAccumulatedExtDepCache = new Map(Types::Date, Types::Real);

        doesSplittedAssetJournalExist = AssetCacheManager::getCacheSplitting(calcArgs.parmAssetId(), calcArgs.parmAssetBookId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>preRunCalc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Do initialization for new loop of calculation.
    /// </summary>
    public void preRunCalc()
    {
        AssetAmount     firstBeginningBalance;

        if (!calcArgs.parmIsCalculationStarted()
            && calcArgs.parmIsRecaptureDepreciation())
        {
            if (calcArgs.isForPreTaxDeduction())
            {
                // Do some special init for process of pre-tax deduction feature.
                // It needs to run in recapture way, but the start calculation period is the first period of process year,
                // not the depreciation start period of the asset value model.
                // For recapture, it is assumed that the first period and following periods should not have any depreciation.
                // So, the beginning balance of the second period should equal to the accumulated depreciation amount before the first period.
                firstBeginningBalance = this.calcBeginningBalanceOfAccumulatedDep(calcArgs.parmPeriodStart());
                beginningBalanceOfAccumulatedDepCache.insert(calcArgs.parmPeriodStart(), firstBeginningBalance);
                beginningBalanceOfAccumulatedDepCache.insert(calcArgs.parmPeriodEnd() + 1, firstBeginningBalance);
                // For recapture calculation, the equally divided started date need to recalculated if the current date is after the first day of process year.
                if (calcArgs.parmEquallyDividedStartDate() > calcArgs.parmPeriodStart())
                {
                    calcArgs.parmEquallyDividedStartDate(dateNull());
                }
            }
            else
            {
                beginningBalanceOfAccumulatedDepCache.insert(calcArgs.parmPeriodEnd() + 1, 0);

                // For recapture calculation, the equally divided started date need to recalculated.
                calcArgs.parmEquallyDividedStartDate(dateNull());
            }
        }

        // Clear the methods result cache for each new loop of calculation.
        methodsResultCache = new Map(Types::String, Types::Class);
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundOffDepreciation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Rounds the amount based on the setting for rounding specified on parameter.
    /// </summary>
    /// <param name="_assetAmount">
    ///    The amount that is used for the rounding process.
    /// </param>
    /// <param name="_upToRoundOff">
    ///    If true, when the amount to round is less than the round off value, round up the amount; otherwise, do nothing to the amount
    ///    If false, round off the amount according to the round rule in currency
    /// </param>
    /// <returns>
    ///    The rounded amount.
    /// </returns>
    public AssetAmount roundOffDepreciation(AssetAmount _assetAmount, boolean _upToRoundOff = false)
    {
        AssetAmount assetAmount;

        assetAmount = AssetDepCalculationHelper_JP::roundOffDepreciation(
            _assetAmount,
            calcArgs.parmRoundOffDepreciation(),
            _upToRoundOff);

        return assetAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundOffDepreciationRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rounds the depreciation rate and use round up method to keep 3 decimal.
    /// </summary>
    /// <param name="_depRate">
    /// The depreciation rate to round.
    /// </param>
    /// <returns>
    /// The depreciation rate after rounding.
    /// </returns>
    protected real roundOffDepreciationRate(real _depRate)
    {
        real ret;
        #define.NumOfDecimal(3)

        ret = roundUpDec(_depRate, #NumOfDecimal);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>smoothDepreciationForYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Smoothes the depreciation for whole year.
    /// </summary>
    /// <returns>
    /// true if needs to smooth the depreciation for whole year. Otherwise, return false.
    /// </returns>
    /// <remarks>
    /// In some cases, there is no amount to depreciate in the last serveral period(s). If enable this
    /// function, the whole year's depreciation amount will be smoothly devided into all periods in current year.
    /// </remarks>
    protected boolean smoothDepreciationForYear()
    {
        return (calcArgs.parmSmoothDepForTheYearOver95_JP() == NoYes::Yes);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBeginningBalanceOfAccumulatedDep</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the cache for beginning balance of accumulated depreciation amount for the new calculated depreciation amount.
    /// </summary>
    /// <param name="_periodStartDate">
    /// The start date of next period.
    /// </param>
    /// <param name="_periodDepAmount">
    /// The new calculated depreciation amount for current period.
    /// </param>
    final protected void updateBeginningBalanceOfAccumulatedDep(AssetTransDate _periodStartDate, AssetAmount _periodDepAmount)
    {
        AssetAmount newBeginningBalance  = this.getBeginningBalanceOfAccumulatedDep(_periodStartDate) + _periodDepAmount;
        AssetTransDate nextPeriodStartDate;

        nextPeriodStartDate = calcArgs.parmAssetTableInterval().endPeriod(_periodStartDate) + 1;

        beginningBalanceOfAccumulatedDepCache.insert(
            _periodStartDate,
            newBeginningBalance);

        if (calcArgs.parmIsRecaptureDepreciation())
        {
            // When doing the adjustment to catch up the depreciation for the acquisition change, always ignore all already posted depreciation trans,
            // and recaulculate the depreciation start from the first period to the latest date of depreciation post. So the beginning balance
            // of next period should be the same to the current period.
            beginningBalanceOfAccumulatedDepCache.insert(
                nextPeriodStartDate,
                newBeginningBalance);
        }
        else
        {
            beginningBalanceOfAccumulatedDepCache.insert(
                nextPeriodStartDate,
                newBeginningBalance + this.calcBeginningBalanceOfAccumulatedDep(nextPeriodStartDate) - this.calcBeginningBalanceOfAccumulatedDep(_periodStartDate));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEquallyDividedEnabled</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected boolean isEquallyDividedEnabled()
    {
        boolean result = true;

        result = this.calcArgs.parmNumOfYearsEquallyDivided() > 0;

        return result;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>