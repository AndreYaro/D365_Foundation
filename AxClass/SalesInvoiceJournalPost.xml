<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SalesInvoiceJournalPost</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;

/// <summary>
/// The <c>SalesInvoiceJournalPost</c> class extends <c>SalesInvoiceJournalPostBase</c> to provide the sales order invoicing functionality.
/// </summary>
[DocumentStatusFactoryAttribute(DocumentStatus::Invoice)]
public class SalesInvoiceJournalPost extends SalesInvoiceJournalPostBase
{
    private static CommerceHQEventSource eventSource = CommerceHQEventSource::Log;

    SalesLine salesLine;
    SalesTable salesTable;

    SalesTotals salesTotals;
    RecordSortedList recordListShippingLine;
    RecordInsertList recordInsertListCustInvoiceBackorderLine;
    RecordViewCache custInvoiceJourCache;

    // Credit Card
    SalesTable creditCardSalesTable;
    SalesTotals_Sales creditCardSalesTotals;
    boolean mrcPostingErr;
    boolean mrcPrintOnPack;
    PDSMRCParameters pdsMRCParameters;
    boolean mrcPdsConfigurationKey;

    LedgerVoucher assetLedgerVoucherBase;
    LedgerVoucher assetLedgerVoucherOthers;

    boolean oldCorrection_RU;
    boolean usePerLineCorrectionIsCached_RU;
    boolean cachedUsePerLineCorrection_RU;
    boolean useQualityManagement;
    container salesLineRec;
    container custInvoiceTransRec;
    AmountCur withholdingTax;
    UnknownNoYes requireGLPostingPriorToSettlement;
    internal Set origOrdersWithSpecTrans;

    Set setSalesTableIntallmentEligible;
    boolean installEligblePacked;
    SalesQty salesOrderQty;
    MCRCustPaymTable mcrCustPaymTable;
    private SalesInstrumentationLogger instrumentationLogger;
    private Set rAssetTransReversedSet = new Set(Types::Container);

    private CreditCardPaymentBreakDownLogger creditCardPaymentBreakDownLogger;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>adjustAmountsMST_W</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Adjusts invoice amounts.
    /// </summary>
    protected void adjustAmountsMST_W()
    {
        AmountAdjustEngineCustInvoice_W::adjustInvoiceJour(custInvoiceJour);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new ()
    {
        super();
        instrumentationLogger = SalesInstrumentationLogger::createLogger(classStr(SalesInvoiceJournalPost));
    }

]]></Source>
			</Method>
			<Method>
				<Name>afterLinePost</Name>
				<Source><![CDATA[
    protected void afterLinePost()
    {
        super();

        if (countryRegionIsRU)
        {
            if (this.usePerLineCorrection_RU())
            {
                ledgerVoucher.findLedgerVoucherObject().parmCorrection(oldCorrection_RU);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetId_RU</Name>
				<Source><![CDATA[
    protected RAssetIdOpen assetId_RU()
    {
        return salesLine.AssetId_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>beforeLinePost</Name>
				<Source><![CDATA[
    protected void beforeLinePost()
    {   
        super();

        if (countryRegionIsRU)
        {
            if (this.usePerLineCorrection_RU())
            {
                LedgerVoucherObject voucherObject = ledgerVoucher.findLedgerVoucherObject();
                oldCorrection_RU = voucherObject.parmCorrection();
                voucherObject.parmCorrection(this.isCorrectionLine_RU());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>bondMultipleLedgerBalances_RU</Name>
				<Source><![CDATA[
    private void bondMultipleLedgerBalances_RU(boolean _secondaryAmountPostingEnabled = false)
    {
        LedgerBondClient_RU ledgerBondClient = ledgerVoucher.findLedgerVoucherObject().ledgerBondClient_RU();
        LedgerBondId_RU vendBalanceVRefId;
        TmpLedgerBondLogTable_RU logTable = ledgerBondClient.log2Table(ledgerBondClient.currentLog(ledgerVoucher.lastTransDate()));
        TmpLedgerBondLogTable_RU balanceLogTable;
        Amount amountToBond;
        boolean isSecondaryAmount;
        LedgerBondId_RU positiveDiscVrefID;
        LedgerBondId_RU negativeDiscVrefID;

        void bondPair()
        {
            if (!isSecondaryAmount)
            {
                amountToBond = ledgerBondClient.bondTransObject(logTable.BondId).remainAmountCur();
                if (amountToBond)
                {
                    ledgerBondClient.bondVRef2VRef(vendBalanceVRefId,
                                                    logTable.BondId,
                                                    amountToBond,
                                                    LedgerBondAmountType_RU::Currency,
                                                    (!logTable.Crediting ? LedgerBondOrder_RU::CreditToDebit : LedgerBondOrder_RU::DebitToCredit));
                }
            }
            else
            {
                ledgerBondClient.bondVRef2VRef(vendBalanceVRefId,
                                                logTable.BondId,
                                                logTable.AmountMSTSecondary,
                                                LedgerBondAmountType_RU::MSTSecondary,
                                                (!logTable.Crediting ? LedgerBondOrder_RU::CreditToDebit : LedgerBondOrder_RU::DebitToCredit));
            }
        }

        if (ledgerBondClient && ledgerBondClient.findVRefByPostingType(LedgerPostingType::CustBalance) != 0)
        {
            if (endDiscVrefIDs)
            {
                [positiveDiscVrefID, negativeDiscVrefID] = endDiscVrefIDs;
            }

            balanceLogTable.setTmpData(logTable);

            while select balanceLogTable
                where balanceLogTable.Posting == LedgerPostingType::CustBalance
            {
                isSecondaryAmount = _secondaryAmountPostingEnabled && (!balanceLogTable.AmountMST && balanceLogTable.AmountMSTSecondary);

                vendBalanceVRefId = balanceLogTable.BondId;

                container offsetLog = conNull();

                while select logTable
                    where (!_secondaryAmountPostingEnabled ||
                            (
                                (!logTable.AmountMST == isSecondaryAmount ) &&
                                (logTable.AmountMST || logTable.AmountMSTSecondary)
                            )
                          ) &&
                          logTable.CurrencyCode == balanceLogTable.CurrencyCode &&
                          (logTable.Crediting != balanceLogTable.Crediting
                           // total discount should be corresponging to balance tansaction
                           // but have the same direction
                           || (
                                positiveDiscVrefID
                             && logTable.BondId == positiveDiscVrefID
                             && logTable.Crediting == balanceLogTable.Crediting
                           )
                           || (
                                negativeDiscVrefID
                             && logTable.BondId == negativeDiscVrefID
                             && logTable.Crediting == balanceLogTable.Crediting
                           )
                          )
                          &&
                          logTable.Correcting == balanceLogTable.Correcting &&
                          logTable.BondId != balanceLogTable.BondId &&
                          logTable.Posting != LedgerPostingType::CustBalance
                {
                    if (_secondaryAmountPostingEnabled)
                    {
                        bondPair();
                    }
                    else
                    {
                        offsetLog += logTable.BondId;
                    }
                }

                if (! _secondaryAmountPostingEnabled)
                {
                    ledgerBondClient.bondVRef2Log(vendBalanceVRefId, offsetLog, true);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>bypassCustomerCreditCheck</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether a customer credit check should be bypassed.
    /// </summary>
    /// <returns>
    ///     <c>NoYes::Yes</c> if the customer credit check should be bypassed; otherwise, <c>NoYes::No</c>.
    /// </returns>
    protected NoYes bypassCustomerCreditCheck()
    {
        return salesTable.creditCardBypassCreditLimit() || salesTable.isRetailCashAndCarrySales();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCashPayment</Name>
				<Source><![CDATA[
    protected boolean isCashPayment()
    {
        return (PaymTerm::isCashAccount(salesTable.Payment));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBeforePostingLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Performs validation before posting a line.
    /// </summary>
    protected void checkBeforePostingLine()
    {
        InventDim inventDimCriteria;
        InventDimParm inventDimParm;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) && salesLine.isStocked())
        {
            if (SalesFormLetter::useInventOwnerIdRange_RU(salesParmTable.salesParmUpdate().SplitInventOwnerId_RU, this.documentStatus(), salesLine))
            {
                inventDimCriteria.InventOwnerId_RU = salesParmLine.InventOwnerId_RU;
                inventDimParm.InventOwnerIdFlag_RU = NoYes::Yes;
            }
            if (salesParmLine.RemainBefore !=
                (salesLine.remainSalesFinancial_RU(inventDimCriteria, inventDimParm) + salesLine.remainSalesPhysical_RU(inventDimCriteria, inventDimParm)))
            {
                throw error("@SYS23025");
            }
        }
        else
        {
            if (custInvoiceTrans.RemainBefore != (salesLine.RemainSalesFinancial + salesLine.RemainSalesPhysical) ||
                salesLine.RemainInventPhysical != salesParmLine.RemainBeforeInventPhysical)
            {
                throw error("@SYS23025");
            }
        }

        if (mrcPdsConfigurationKey)
        {
            List psdsDocuRefRecIdList = PdsMRCRegulated_Sales_PackingSlip::checkRegulatedWarnBreakAndPrint(
                mrcPostingErr,
                this.pdsMRCParameters().RegulationWarningOnPack,
                mrcPrintOnPack,
                salesLine);

            if (mrcPrintOnPack)
            {
                if(psdsDocuRefRecIdList && !psdsDocuRefRecIdList.empty())
                {
                    ListEnumerator listEnumerator = psdsDocuRefRecIdList.getEnumerator();

                    while (listEnumerator.moveNext())
                    {
                        docuRefRecIdList.addEnd(listEnumerator.current());
                    }
                }
                else
                {
                    info("@SCM:NoProductDataSheetsMessage");
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCustInvoiceTrans_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if the cust invoice trans exists.
    /// </summary>
    /// <returns>
    ///     Returns true if the cust invoice trans exists.
    /// </returns>
    protected boolean checkCustInvoiceTrans_IN()
    {
        return CustInvoiceTrans::exist(salesLine.InventTransId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCustomJournalInventTransMarked_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if transaction included in custom journals marked
    /// </summary>
    /// <param name="_inventTransId">
    ///     <c>InventTransId</c> to check
    /// </param>
    /// <returns>
    ///     True, if records not marked, or if marked but user chosen to continue
    /// </returns>
    boolean checkCustomJournalInventTransMarked_RU(InventTransId _inventTransId)
    {
        InventTrans inventTrans;
        InventTransOrigin inventTransOrigin;
        CustomJournalTrans_RU customJournalTrans;
        CustomJournalTable_RU customJournalTable;

        select firstonly RecId from inventTrans
            where inventTrans.MarkingRefInventTransOrigin &&
                  inventTrans.PackingSlipReturned == NoYes::No
            join RecId from inventTransOrigin
                where inventTransOrigin.InventTransId == _inventTransId &&
                      inventTransOrigin.RecId == inventTrans.InventTransOrigin &&
                      inventTransOrigin.RecId != inventTrans.MarkingRefInventTransOrigin
                join CustomJournalId from customJournalTrans
                    where customJournalTrans.SalesPurchInventTransId == _inventTransId
                    exists join customJournalTable
                        where customJournalTable.CustomJournalId == customJournalTrans.CustomJournalId &&
                              customJournalTable.CustomJournalStatus == CustomJournalStatus_RU::Open;

        if (inventTrans.RecId)
        {
            if (Box::yesNo(strFmt("@GLS115378", customJournalTrans.CustomJournalId), DialogButton::Yes) == DialogButton::No)
            {
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDateControl_W</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Verifies whether selected date more than invoice issue due date in selected customer packing slip.
    /// </summary>
    /// <param name="_custPackingSlipJour">
    ///     The record of table <c>CustPackingSlipJour</c> where the information about value of invoice issue date and other is taken.
    /// </param>
    /// <param name="_verifiableDate">
    ///     A date value that is checked.
    /// </param>
    /// <param name="_controlType">
    ///     A enum value that specified type for check: Warning or Error.
    /// </param>
    /// <param name="_verifiableDateLabel">
    ///     A string value that specified the name of verifiable date in UI.
    /// </param>
    /// <returns>
    ///     true if all checks are successful; otherwise, false and displays warning or error message.
    /// </returns>
    /// <exception cref="Exception::Error">
    ///     Return Error if _controlType parameter has None value.
    /// </exception>
    protected boolean checkDateControl_W(CustPackingSlipJour _custPackingSlipJour, TransDate _verifiableDate, DateControlType_W _controlType, LabelString _verifiableDateLabel)
    {
        boolean ret = true;

        if (_verifiableDate > _custPackingSlipJour.InvoiceIssueDueDate_W)
        {
            str message = strFmt("@SYS4009621",
                                 _custPackingSlipJour.PackingSlipId,
                                 _verifiableDateLabel,
                                 _verifiableDate,
                                 fieldPName(CustPackingSlipJour, InvoiceIssueDueDate_W),
                                 _custPackingSlipJour.InvoiceIssueDueDate_W);

            switch (_controlType)
            {
                case DateControlType_W::Warning:
                    warning(message);
                    break;

                case DateControlType_W::Error:
                    error(message);
                    ret = false;
                    break;

                default:
                    throw error(Error::wrongUseOfFunction(funcName()));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCustomsFields_IN</Name>
				<Source><![CDATA[
    private void checkCustomsFields_IN()
    {
        TransTaxInformation transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(salesLine);

        if (!transTaxInformation.CustomsTariffCode)
        {
            throw error(strFmt("@SYS26332", fieldPName(TransTaxInformation, CustomsTariffCode)));
        }
        else if (!salesLine.EximPorts_IN)
        {
            throw error(strFmt("@SYS26332", fieldPName(SalesLine, EximPorts_IN)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInvoiceIssueDueDate_W</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Verifies whether the posting dates on exceeding of the invoice issue date in the packing slips
    /// </summary>
    /// <returns>
    ///     true if all checks are successful; otherwise, false
    /// </returns>
    protected boolean checkInvoiceIssueDueDate_W()
    {
        CustPackingSlipJour custPackingSlipJour;
        CustPackingSlipTrans custPackingSlipTrans;
        CustInvoiceTrans custInvoiceTransLocal;
        SalesParameters salesParameters = SalesParameters::find();
        DateControlType_W invoiceDateControlType = this.creditNote() ? salesParameters.CreditNoteInvoiceDateControlType_W : salesParameters.InvoiceDateControlType_W;
        DateControlType_W documentDateControlType = this.creditNote() ? salesParameters.CreditNoteDocumentDateControlType_W : salesParameters.DocumentDateControlType_W;
        boolean ret = true;

        if (invoiceDateControlType == DateControlType_W::None && documentDateControlType == DateControlType_W::None)
        {
            return ret;
        }

        while select PackingSlipId, InvoiceIssueDueDate_W from custPackingSlipJour
            group by PackingSlipId, InvoiceIssueDueDate_W
                where custPackingSlipJour.InvoiceIssueDueDate_W
            exists join custPackingSlipTrans
                where custPackingSlipTrans.SalesId == custPackingSlipJour.SalesId
                   && custPackingSlipTrans.PackingSlipId == custPackingSlipJour.PackingSlipId
                   && custPackingSlipTrans.DeliveryDate == custPackingSlipJour.DeliveryDate
                   && custPackingSlipTrans.Qty != 0
            exists join custInvoiceTransLocal
                where custInvoiceTransLocal.InventTransId == custPackingSlipTrans.InventTransId
                   && custInvoiceTransLocal.SalesId == custInvoiceJour.SalesId
                   && custInvoiceTransLocal.InvoiceId == custInvoiceJour.InvoiceId
                   && custInvoiceTransLocal.InvoiceDate == custInvoiceJour.InvoiceDate
                   && custInvoiceTransLocal.NumberSequenceGroup == custInvoiceJour.NumberSequenceGroup
        {
            if (invoiceDateControlType)
            {
                ret = ret && this.checkDateControl_W(custPackingSlipJour, custInvoiceJour.InvoiceDate, invoiceDateControlType, "@SYS57610");
            }

            if (documentDateControlType)
            {
                ret = ret && this.checkDateControl_W(custPackingSlipJour, custInvoiceJour.DocumentDate, documentDateControlType, fieldPName(CustInvoiceJour, DocumentDate));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNotStockedLineAfterPosting</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Verifies the not stocked order lines after posting.
    /// </summary>
    /// <param name="_notStockedPostCheck">
    ///     The <c>TradeNotStockedPostCheck</c> object to use for verification.
    /// </param>
    /// <returns>
    ///     true if the order line could be posted; otherwise, false.
    /// </returns>
    protected boolean checkNotStockedLineAfterPosting(TradeNotStockedPostCheck _notStockedPostCheck)
    {
        _notStockedPostCheck.parmQtyPhysicalToBeJournalUpdated(invoiceUpdatedOnly);

        return super(_notStockedPostCheck);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSalesBook_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if sales book is open.
    /// </summary>
    /// <returns>
    ///     true if sales book is open; otherwise, false.
    /// </returns>
    protected boolean checkSalesBook_RU()
    {
        #ISOCountryRegionCodes

        boolean exportJour;
        boolean ret = true;

        if (this.tax())
        {
            TmpTaxWorkTrans tmpTaxWorkTrans = this.tax().tmpTaxWorkTrans();
            while select tmpTaxWorkTrans
                group by TaxCode
            {
                if (TaxTable::find(tmpTaxWorkTrans.TaxCode).isExportVAT_RU())
                {
                    exportJour = true;
                    break;
                }
            }
        }

        if (CustParameters::taxation_RU(custInvoiceJour.InvoiceDate) == CustTaxation_RU::OnDelivery &&
            !custInvoiceJour.custInvoiceJour_RU().vatOnPayment_RU &&
            !exportJour)
        {
            ret = SalesBookTable_RU::canProcessDate(custInvoiceJour.InvoiceDate);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSourceLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Verifies the source line for the journal line.
    /// </summary>
    protected void checkSourceLine()
    {
        MainAccount postingMainAccount;
        #ISOCountryRegionCodes

        // Italian functionality of VAT books and VAT book sections
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT])
            && (!TaxIntegrationCheckTaxCode_ITFlight::instance().isEnabled()
                || !Tax::isTaxIntegrationEnabledForBusinessProcess(TaxIntegrationBusinessProcess::Sales)))
        {
            boolean allowBlankItemSalesTaxGroup = salesTable.isRetailSale() &&
                    FeatureStateProvider::IsFeatureEnabled(RetailAllowBlankItemSalesTaxGroupInInvoiceFlight_IT::instance());

            if (!allowBlankItemSalesTaxGroup || salesLine.TaxItemGroup)                
            {
                if (!TaxGroupData::checkTaxGroups(salesLine.TaxGroup, salesLine.TaxItemGroup))
                {
                    throw error("@SYS21533");
                }
            }
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            if (salesTable.CustomsExportOrder_IN
                && TaxParameters::isCustomsEnable_IN())
            {
                this.checkCustomsFields_IN();
            }
        }

        if (taxParameters.ValidateTaxCode)
        {
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                postingMainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(
                    InventPosting::accountItemLedgerDimensionFromParameters(InventPostingAccountItemLedgerDimensionParameters::newFromSalesLine(
                        salesLine,
                        InventAccountType::SalesRevenue,
                        inventTable.itemGroupId(),
                        salesLine.inventDim())));
            }
            else
            {
                postingMainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(
                    InventPosting::accountItemLedgerDimensionFromParameters(InventPostingAccountItemLedgerDimensionParameters::newFromSalesLine(
                        salesLine,
                        InventAccountType::SalesRevenue,
                        inventTable.itemGroupId())));

                if (!Tax::checkNoTax(postingMainAccount, salesLine.TaxGroup, salesLine.TaxItemGroup))
                {
                    throw error("@SYS21533");
                }
            }

            MainAccount summaryMainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(CustLedgerAccounts::summaryLedgerDimension(salesLine.CustAccount));
            
            if (!Tax::checkNoTax(summaryMainAccount, salesLine.TaxGroup, salesLine.TaxItemGroup))
            {
                throw error("@SYS21533");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBackorderLines</Name>
				<Source><![CDATA[
    protected void createBackorderLines()
    {
        SalesLine localSalesLine;
        SalesParameters salesParameters = SalesParameters::find();
        SalesFormletterParmData parmData = SalesFormletterParmData::newData(this.documentStatus());
        boolean splitDeliveryInformation = salesParameters.splitDeliveryInformation(this.documentStatus());

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            parmData.parmParmUpdate(salesParmTable.salesParmUpdate());
        }

        ttsbegin;

        while select localSalesLine
            where localSalesLine.SalesId == salesTable.SalesId
               && localSalesLine.SalesStatus == SalesStatus::Backorder
               && localSalesLine.RemainInventPhysical != 0
               && (localSalesLine.SalesType != SalesType::Subscription || // Only create backorders for subscriptions
                   localSalesLine.RemainInventPhysical != localSalesLine.QtyOrdered) // if the remaining quantity is different from the ordered quantity
               && (splitDeliveryInformation == NoYes::No || // Only check the address if there is a split per address
                     (localSalesLine.DeliveryPostalAddress == custInvoiceJour.DeliveryPostalAddress
                   && localSalesLine.DeliveryName == custInvoiceJour.DeliveryName
                   && localSalesLine.DlvMode == custInvoiceJour.DlvMode))
        {
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                if ((!salesParameters.splitSite(this.documentStatus())
                        || localSalesLine.inventDim().InventSiteId == salesParmTable.InventSiteId)
                    && (!parmData.splitPostingProfile_RU()
                        || parmData.postingProfile_RU(localSalesLine.PostingProfile_RU,
                            salesTable.PostingProfile) == salesParmTable.PostingProfile_RU)
                    && (!parmData.splitInventProfileType_RU()
                        || parmData.inventProfileType_RU(localSalesLine) == salesParmTable.InventProfileType_RU)
                    && (TaxIntegrationUtils::isMultipleTaxIdAllowedWithinOneSalesOrder()
                        && (!salesParameters.splitTaxId(this.documentStatus())
                            || localSalesLine.TaxID == salesParmTable.TaxId)))
                {
                    this.insertBackorderLine(localSalesLine);
                }
            }
            else
            {
                if (TaxIntegrationUtils::isMultipleTaxIdAllowedWithinOneSalesOrder()
                    && (!salesParameters.splitSite(this.documentStatus())
                        || localSalesLine.inventDim().InventSiteId == salesParmTable.InventSiteId)
                    && (!salesParameters.splitTaxId(this.documentStatus())
                        || localSalesLine.TaxID == salesParmTable.TaxId))
                {
                    this.insertBackorderLine(localSalesLine);
                }
                else
                {
                    if (salesParameters.splitSite(this.documentStatus())) // if split on site
                    {
                        if (localSalesLine.inventDim().InventSiteId == salesParmTable.InventSiteId) // check for same site
                        {
                            this.insertBackorderLine(localSalesLine);
                        }
                    }
                    else
                    {
                        this.insertBackorderLine(localSalesLine);
                    }
                }
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustTrans_BR</Name>
				<Source><![CDATA[
    protected boolean createCustTrans_BR()
    {
        return salesTable.createCustTrans_BR();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createExportDocument_CN</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates export document.
    /// </summary>
    protected void createExportDocument_CN()
    {
        TaxIntgrExportDocumentGenerator_CN::generate(custInvoiceJour.RecId, custInvoiceJour.TableId, salesParmTable.RecId, salesParmTable.TableId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNotStockedPostCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a <c>TradeNotStockedPostCheck</c> object that is used to verify order lines during
    /// posting.
    /// </summary>
    /// <returns>
    ///     A <c>TradeNotStockedPostCheck</c> object that is used to verify order lines during posting.
    /// </returns>
    /// <remarks>
    ///     This method will return null when no verification is necessary.
    /// </remarks>
    protected TradeNotStockedPostCheck createNotStockedPostCheck()
    {
        return TradeNotStockedPostCheck::newSalesLine(salesLine, custInvoiceTrans.Qty, salesParmLine.RemainAfter, salesParmLine.RemainBefore);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPayment</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates payments and prints payment proposals if it is needed.
    /// </summary>
    protected void createPayment()
    {
        CustTrans custTrans = custInvoiceJour.custTrans();

        if (custTrans.PaymMode && CustPaymModeTable::find(custTrans.PaymMode).PaymOnInvoice)
        {
            CustVendPaymInvoiceWithJournal::construct(custInvoiceJour).run();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPaymentSched</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a payment schedule.
    /// </summary>
    protected void createPaymentSched()
    {
        CustPaymSched custPaymSched;

        if (BrazilParameters::isEnabled() && !this.createCustTrans_BR())
        {
            return;
        }

        if (CustPaymSched::exist(salesParmTable.TableId, salesParmTable.RecId))
        {
            salesParmTable.copyPaymentSched(custInvoiceJour);
        }
        else if (salesTable.PaymentSched)
        {
            custPaymSched = CustPaymSched::find(salesTable.TableId, salesTable.RecId);

            if (custPaymSched && custPaymSched.CopyPreciselyToInvoice)
            {
                salesTable.copyPaymentSched(custInvoiceJour);
            }
            else
            {
                custInvoiceJour.createPaymentSched();
            }
        }

        // check that schedule amount matches invoice amount
        if (!custInvoiceJour.validatePaymentSched())
        {
            if (custPaymSched && custPaymSched.CopyPreciselyToInvoice)
            {
                error(strFmt("@AccountsPayable:SalesOrderInvoiceCopyPreciselyTotalError", salesTable.SalesId, "@AccountsPayable:PaymentScheduleCopyPreciselyToInvoiceLabel"));
            }

            throw error("@SYS18447");
        }
        if (CFMParameters::isModuleEnabled())
        {
            CFMPlannedPaymentCalc cfmPlannedPaymentCalc = CFMPlannedPaymentCalc::construct(salesTable);
            cfmPlannedPaymentCalc.calc();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditCardDoCaptureOrPostAuthorize</Name>
				<Source><![CDATA[
    protected boolean creditCardDoCaptureOrPostAuthorize(SalesInvoiceId _salesInvoiceId, boolean _isRefund, CustInvoiceJour _custInvoiceJour)
    {
        if (this.canCaptureCreditCard() && creditCardSalesTable.isCreditCardPaymentType())
        {
            if (_isRefund)
            {
                return CreditCardProcess::doRefund(creditCardSalesTable, creditCardSalesTotals, _salesInvoiceId, _custInvoiceJour);
            }
            else
            {
                return CreditCardProcess::doCapture(creditCardSalesTable, creditCardSalesTotals, _salesInvoiceId, _custInvoiceJour);
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCaptureCreditCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the credit card can be captured.
    /// </summary>
    /// <returns>true if the credit card can be captured.</returns>
    protected boolean canCaptureCreditCard()
    {
        return creditCardSalesTable.CreditCardCustRefId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditCardDoPreAuthorize</Name>
				<Source><![CDATA[
    private boolean creditCardDoPreAuthorize()
    {
        // Only pre-authorization credit card when needed
        if (salesTable.CreditCardCustRefId && salesTable.isCreditCardPaymentType() && CustParameters::find().CreditCardPreAuthorization)
        {
            return CreditCardProcess::doPreAuth(salesTable, false);
        }
        else
        {
            eventSource.EventWritePaymentsCreditCardPreAuthorizationSkipped(salesTable.RecId);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the currency code for a source line.
    /// </summary>
    /// <returns>
    ///     The unit of currency for the source line.
    /// </returns>
    /// <remarks>
    ///     Used for ledger posting of the source line.
    /// </remarks>
    protected CustCurrencyCode currencyCode()
    {
        return salesParmTable.CurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custTransAmount_BR</Name>
				<Source><![CDATA[
    protected AmountCur custTransAmount_BR()
    {
        return salesTotals.custTransAmount_BR();
    }

]]></Source>
			</Method>
			<Method>
				<Name>dealQualityOrderLine_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Deals the quality order line.
    /// </summary>
    protected void dealQualityOrderLine_IN()
    {
        CustInvoiceTrans        custInvoiceTransLoc;
        
        InventQualityOrderTable inventQualityOrderTable = InventQualityOrderTable::findSalesPurchRefTransId_IN(salesLine.InventTransId, InventTestReferenceType::Sales);
        if (inventQualityOrderTable)
        {
            TaxEngineQualityOrder taxEngineQualityOrderSales = TaxEngineQualityOrder_Sales::construct(inventQualityOrderTable, salesTable, salesLine);
            
            select firstOnly RecId from custInvoiceTransLoc
                where custInvoiceTransLoc.InventTransId == salesLine.InventTransId
                    && custInvoiceTransLoc.RecId != custInvoiceTrans.RecId;

            if (!custInvoiceTransLoc && taxEngineQualityOrderSales.shouldPostTax())
            {
                taxEngineQualityOrderSales.postTax(ledgerVoucher, transactionTxt, taxDocumentLedgerVoucherMap);
            }
            else
            {
                if (TaxParameters::checkVatExciseParameters_IN()
                    && useQualityManagement
                    && InventQualityOrderTable::findSalesPurchRefTransId_IN(
                    salesLine.InventTransId,
                    InventTestReferenceType::Sales).ApplyIndiaTaxes_IN != ApplyIndiaTaxes_IN::None)
                {
                    this.postQualityOrderTaxes_IN(ledgerVoucher, transactionTxt);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultDimensionMarkupOnJour</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the default dimension for a record.
    /// </summary>
    /// <param name="_source">
    ///     The <c>Common</c> record for which to find the default dimension.
    /// </param>
    /// <returns>
    ///     A <c>DimensionDefault</c> value.
    /// </returns>
    /// <remarks>
    ///     This method is used to calculate miscellaneous charges on the header level.
    /// </remarks>
    protected DimensionDefault defaultDimensionMarkupOnJour(Common _source)
    {
        SalesTable salesTableMarkup = _source as SalesTable;
        return salesTableMarkup.DefaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultDimensionMarkupOnTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the default dimension when miscellaneous charges are posted on a line level.
    /// </summary>
    /// <returns>
    ///     A <c>DimensionDefault</c> value.
    /// </returns>
    /// <remarks>
    ///     This method is used to post miscellaneous charges on the line level.
    /// </remarks>
    protected DimensionDefault defaultDimensionMarkupOnTrans()
    {
        return salesLine.DefaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteFullyInvoiced</Name>
				<Source><![CDATA[
    protected void deleteFullyInvoiced()
    {
        SalesLine localSalesLine;
        SalesId previousSalesId = '';
        SalesId currentSalesId = '';
        SalesDeliverySchedule salesDeliverySchedule;
        SalesLine deliveryLine;
        SalesParameters salesParameters = SalesParameters::find();
        boolean customsMarked = TaxParameters::isCustomsEnable_IN();

        if (!journalLines.elements())
        {
            return;
        }

        ListEnumerator le = journalLines.getEnumerator();

        if (salesParameters.DeleteLine == NoYes::Yes)
        {
            while (le.moveNext())
            {
                salesLine = this.getSalesLine(le);
                if (salesLine.SalesStatus == SalesStatus::Invoiced && salesLine.validateDelete())
                {
                    if (salesLine.LineDeliveryType == LineDeliveryType::DeliveryLine)
                    {
                        // this is a fully invoiced delivery schedule - delete all delivery lines

                        select firstonly salesDeliverySchedule
                            where salesDeliverySchedule.DeliveryLine == salesLine.InventTransId;

                        TradeInventTransId orderLineTransId = salesDeliverySchedule.OrderLine;

                        delete_from deliveryLine
                            exists join salesDeliverySchedule
                            where salesDeliverySchedule.OrderLine == orderLineTransId
                              && salesDeliverySchedule.DeliveryLine == deliveryLine.InventTransId;

                        // then delete the order line
                        delete_from deliveryLine where deliveryLine.InventTransId == orderLineTransId;
                    }
                    else
                    {
                        salesLine.delete();
                    }
                }
            }
        }

        if (salesParameters.DeleteHeading == NoYes::Yes)
        {
            le.reset();

            while (le.moveNext())
            {
                currentSalesId = this.getOrigSalesId(le);

                if (currentSalesId != previousSalesId)
                {
                    salesTable = SalesTable::find(currentSalesId, true);

                    if (salesTable)
                    {
                        select firstonly localSalesLine
                            where localSalesLine.SalesId == currentSalesId
                                && (localSalesLine.SalesStatus == SalesStatus::None
                                    || localSalesLine.SalesStatus == SalesStatus::Backorder
                                    || localSalesLine.SalesStatus == SalesStatus::Delivered);

                        if (customsMarked && salesTable.CustomsExportOrder_IN == NoYes::Yes)
                        {
                            previousSalesId = currentSalesId;
                            le.moveNext();
                        }
                        else
                        {
                            if (!localSalesLine && salesTable.validateDelete())
                            {
                                salesTable.delete();
                            }
                        }
                    }
                }

                previousSalesId = currentSalesId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>discAmountExclTaxcInventoryPosted</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates the discount amount excluded tax for a quantity updated in inventory.
    /// </summary>
    /// <returns>
    ///     The discount amount excluded tax for the quantity updated in inventory.
    /// </returns>
    protected AmountCur discAmountExclTaxcInventoryPosted()
    {
        return salesLine.calcLineDiscExclTax(updateNow, this.updateDate(), tax);
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the type of document.
    /// </summary>
    /// <returns>
    ///     The <c>DocumentStatus::Invoice</c> enumeration value.
    /// </returns>
    DocumentStatus documentStatus()
    {
        return DocumentStatus::Invoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>docuRefCopy</Name>
				<Source><![CDATA[
    protected void docuRefCopy(Common _from, Common _to)
    {
        // Copy notes from the sales order to the custInvoiceJour
        super(_from, _to);

        if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            // Also copy customer level notes to the custInvoiceJour.
            // Note that there will be no way to tell whether the note is from the
            // customer level or order header level.
            if (SalesParameters::find().MCRCopyNotes && salesTable.CustAccount != '')
            {
                CustTable custTable;

                // Do the same for all merged customers.
                while select custTable
                    where custTable.MCRMergedRoot == salesTable.CustAccount
                {
                    Docu::copy(custTable, custInvoiceJour);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>docuRefFindAndCopyMultiple</Name>
				<Source><![CDATA[
    protected void docuRefFindAndCopyMultiple(Common _to)
    {
        SetEnumerator se = ordersPosted.getEnumerator();

        while (se.moveNext())
        {
            this.docuRefCopy(SalesTable::find(se.current()), _to);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>endLedgerVoucher</Name>
				<Source><![CDATA[
    protected void endLedgerVoucher()
    {
        if (countryRegionIsRU)
        {
            LedgerVoucherObject ledgerVoucherObject = ledgerVoucher ? ledgerVoucher.findLedgerVoucherObject() : null;
            LedgerBondClient_RU ledgerBondClient = ledgerVoucherObject ? ledgerVoucherObject.ledgerBondClient_RU() : null;

            if (this.postBalanceAsManyLedgerTransactions_RU() && ledgerBondClient)
            {
                this.bondMultipleLedgerBalances_RU();
            }
        }

        super();

        if (countryRegionIsRU)
        {
            this.createTransLink_RU();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>endLines</Name>
				<Source><![CDATA[
    protected void endLines()
    {
        #ISOCountryRegionCodesEuro_W

        if (!this.checkInvoiceIssueDueDate_W())
        {
            throw error("@SYS21533");
        }

        super();

        this.updateSalesTableForSpecTransChange();
    }

]]></Source>
			</Method>
			<Method>
				<Name>endPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Ends the posting.
    /// </summary>
    protected void endPost()
    {
        super();
        
        this.updateBankLC();

        if (CustParameters::isTaxIntegrationSystem_CN())
        {
            this.createExportDocument_CN();
        }

        this.retailBlockReturnedItems();
    }

]]></Source>
			</Method>
			<Method>
				<Name>endPostLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Ends the posting of one journal line.
    /// </summary>
    protected void endPostLine()
    {
        custInvoiceTrans.updateCommission(ledgerVoucher, custInvoiceJour);

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            this.updateAssetLine_RU();
        }

        super();

        if (BrazilParameters::isEnabled())
        {
            this.postEndPostLine_BR();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>beforeProcessGiftCards</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gives extensibility to perform action before processing gift cards.
    /// </summary>
    protected void beforeProcessGiftCards()
    {
        // Do nothing...
    }

]]></Source>
			</Method>
			<Method>
				<Name>endUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Ends the update of selected records.
    /// </summary>
    /// <remarks>
    /// The <c>endUpdate</c> method in the derived classes contains the code for ending the posting of the
    /// selected records posted by the derived <c>FormLetter</c> class. For example the <c>endUpdate</c>
    /// method in the <c>SalesFormLetter</c> class ends the update for the selected sales orders. The
    /// <c>endUpdate</c> method is added to the <c>FormLetter</c> class so that you can run the
    /// <c>endUpdate</c> method when you post in batch. The <c>endUpdate</c> method is called from the
    /// <c>run</c> method in the abstract classes derived from the <c>FormLetter</c> class, and from the
    /// <c>run</c> method in the <c>FormLetterEndMultiThread</c> class.
    /// </remarks>
    void endUpdate()
    {
        if (RetailTransactionPaymentsHelper::isCallCenterOrCommercePaymentsEnabledOrder(salesTable))
        {
            // If post invoice for return Call Center Sales Order
            // and order pay with Gift Card or Loyalty card
            // then do real refund amount to Gift Card or Loyalty card.
            if (salesTable.SalesType == SalesType::ReturnItem)
            {
                MCRCustPaymTable custPaymTable;

                select firstonly RecId from custPaymTable
                    where custPaymTable.RefRecId == salesTable.RecId &&
                    custPaymTable.RefTableId == salesTable.TableId &&
                    (custPaymTable.CustPaymType == MCRCustPaymType::GiftCard
                    || custPaymTable.CustPaymType == MCRCustPaymType::LoyaltyCard);

                if (custPaymTable)
                {
                    MCRSalesOrderTotals salesOrderTotals;
                    MCRCustPaymTotals mcrCustPaymTotals;
                    salesOrderTotals = new MCRSalesOrderTotals(salesTable);
                    // Submit payments for authorization.
                    mcrCustPaymTotals = MCRCustPaymTotals::construct(salesTable.TableId,
                                                                     salesTable.RecId,
                                                                     salesOrderTotals);
                    if (!mcrCustPaymTotals.validatePost(false))
                    {
                        MCREndOrder::setPostingProfile(salesTable);
                        MCREndOrder::submitOrderPayments(salesTable,
                                                         salesOrderTotals,
                                                         mcrCustPaymTotals,
                                                         true);
                    }
                }
            }

            if (SalesInvoiceJournalPost::canSettlePayments(salesTable, this))
            {
                this.mcrSettlePayments();
            }

            this.mcrProcessGiftCards();

            // Transfer money to item revenue account for continuity orders
            MCRContinuityRevenueTransfer::transferRevenue(SalesParmTable);
        }
        else if (salesTable.isRetailSale())
        {
            this.beforeProcessGiftCards();
            this.mcrProcessGiftCards();
        }

        // Create broker contract calculation and history records
        // which are used in the MCRBrokerCalc form to genearte the
        // claim records needed to pay the broker.
        MCRBrokerAccrual::createAccrualFromInvoice(CustInvoiceJour);

        this.markTaxDocumentDirty();
        this.updateEstimate();
        this.updateWMSShipment();
        this.interCompanyPost();

        if (BrazilParameters::isEnabled())
        {
            this.postEndPost_BR();
        }

        if (custInvoiceJourCache)
        {
            // Manually dispose after sandbox operation to prevent cache data from remaining in the new session scope
            custInvoiceJourCache.dispose();
        }

        if (CustPrepaymentInvoiceFeature::instance().isEnabled() && this.canHandlePrepayment() && this.containsPrepaymentInvoice())
        {
            CustPrepaymentAutoSettlementPostingEvent prepaymentAutoSettlementPostingEvent;

            prepaymentAutoSettlementPostingEvent.CustInvoiceJour = custInvoiceJour.RecId;
            prepaymentAutoSettlementPostingEvent.Status = CustPrepaymentHandlingStatus::NotProcessed;
            prepaymentAutoSettlementPostingEvent.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canHandlePrepayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// If summary update is enabled, prepayment invoicing feature is not allowed
    /// </summary>
    /// <returns>
    /// true if prepayment invoicing feature is allowed
    /// </returns>
    private boolean canHandlePrepayment()
    {
        SalesParmUpdate salesParmUpdate = salesParmTable.salesParmUpdate();
        
        if (this.isProforma() ||salesTable.SalesType != SalesType::Sales || salesParmUpdate.SumBy != AccountOrder::None)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>containsPrepaymentInvoice</Name>
				<Source><![CDATA[
    private boolean containsPrepaymentInvoice()
    {
        CustPrepaymentCustInvoice custPrepaymentCustInvoice;

        select count(RecId) from custPrepaymentCustInvoice
            where custPrepaymentCustInvoice.SourceRecId == salesTable.RecId
                && custPrepaymentCustInvoice.SourceTableId == salesTable.TableId;
        
        if (custPrepaymentCustInvoice.RecId > 0  && this.canSettlePrepayment())
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSettlePrepayment</Name>
				<Source><![CDATA[
    private boolean canSettlePrepayment()
    {
        SalesParmUpdate salesParmUpdate = salesParmTable.salesParmUpdate();

        if (salesParmUpdate.SumBy != AccountOrder::None || salesTable.PaymentSched)
        {
            if (salesParmUpdate.SumBy != AccountOrder::None)
            {
                warning(strFmt("@AccountsReceivable:PrepaymentInvoiceSummaryUpdateWarning"));
            }

            if (salesTable.PaymentSched)
            {
                warning(strFmt("@AccountsReceivable:PrepaymentInvoicePaymentScheduleWarning"));
            }

            CustPrepaymentCustInvoice::deletedAllInvoicedRefEntry(salesTable.RecId, salesTable.TableId);

            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markTaxDocumentDirty</Name>
				<Source><![CDATA[
    private void markTaxDocumentDirty()
    {
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            // Tax document needs to be recalculated after invoicing.
            SalesTable salesTableLoc = salesParmTable.salesTable();
            if (salesTableLoc)
            {
                salesTableLoc.markCurrentTaxDocumentTaxStatusDirty();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRate_W</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines currency exchange rate of the invoice.
    /// </summary>
    /// <returns>
    ///     Currency exchange rate of the invoice.
    /// </returns>
    protected ExchRate exchRate_W()
    {
        return custInvoiceJour.ExchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRateSec_W</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines secondary currency exchange rate of the invoice.
    /// </summary>
    /// <returns>
    ///     Secondary currency exchange rate of the invoice.
    /// </returns>
    protected ExchrateSecondary exchRateSec_W()
    {
        return custInvoiceJour.ExchRateSecondary;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrigSalesId</Name>
				<Source><![CDATA[
    protected SalesIdOrig getOrigSalesId(ListEnumerator _le)
    {
        CustInvoiceTrans localCustInvoiceTrans = _le.current();

        return localCustInvoiceTrans.OrigSalesId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesLine</Name>
				<Source><![CDATA[
    protected SalesLine getSalesLine(ListEnumerator _le)
    {
        CustInvoiceTrans localCustInvoiceTrans = _le.current();

        return localCustInvoiceTrans.salesLine(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasQualityOrder_IN</Name>
				<Source><![CDATA[
    protected boolean hasQualityOrder_IN()
    {
        if (!salesTable.RecId)
        {
            return false;
        }

        InventQualityOrderTable inventQualityOrderTable = InventQualityOrderTable::findLastQualityOrder(InventTestReferenceType::Sales, salesTable.SalesId);

        if (inventQualityOrderTable.RecId)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>includeDiscValueInRevenue</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether to include the discount value in a calculation of revenue.
    /// </summary>
    /// <returns>
    ///     Always returns false.
    /// </returns>
    /// <remarks>
    ///     This method is used when an invoice line is posted.
    /// </remarks>
    protected boolean includeDiscValueInRevenue()
    {
        return salesLine.SalesPrice && formletterProvider.lineDiscountLedgerDimension();
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the class.
    /// </summary>
    public void init()
    {
        salesTable = custInvoiceJour.salesTable();

        if (RetailMCRChannelTable::mcrEnableOrderCompletion(salesTable))
        {
            mcrCustPaymTable = MCRCustPaymTable::findByRefRecIDRefTableID(salesTable.RecId,salesTable.TableId);
        }

        super();

        cashDiscountAmount = salesTotals.cashDiscAmount();
        totalAmountCashDiscOnInvoice = salesTotals.totalAmountCashDiscOnInvoice(true);

        mrcPdsConfigurationKey = isConfigurationkeyEnabled(configurationKeyNum(PdsMRC));

        // Set the creditCardSalesTable and creditCardSalesTotals to be
        // used as part of the creditCardDoCaptureOrPostAuthorize() call.
        creditCardSalesTable = salesTable.data();
        creditCardSalesTotals = salesTotals;

        origOrdersWithSpecTrans = new Set(Types::String);

        if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            setSalesTableIntallmentEligible = new Set(Types::String);
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            useQualityManagement = InventParameters::find().UseQualityManagement;
            this.validateReturnableReference_IN();
        }

        if (BrazilParameters::isEnabled())
        {
            this.postInit_BR();
        }

        // <GMY>
        if (TaxGSTFeatureChecker_MY::isCountryRegionMY())
        {
            this.checkBeforePost_MY();
        }
        // </GMY>
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustInvoiceJourFromTotals</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the journal header from totals.
    /// </summary>
    /// <remarks>
    ///     This method is used to update the journal header with values that are posted in inventory.
    /// </remarks>
    protected void initCustInvoiceJourFromTotals()
    {
        boolean installmentEligible;

        if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            if (setSalesTableIntallmentEligible.in(salesTable.SalesId))
            {
                installmentEligible = true;
            }
        }

        custInvoiceJour.initFromSalesTotals(salesTotals, cashDiscountAmount, installmentEligible);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Constructs a <c>CustVoucher</c> object.
    /// </summary>
    /// <param name="_ledgerTransTxt">
    ///     A <c>LedgerTransText</c> object to be transferred to the <c>CustVoucher</c> object.
    /// </param>
    /// <returns>
    ///     The constructed <c>CustVoucher</c> object.
    /// </returns>
    protected CustVoucher initCustVoucher(LedgerTransTxt _ledgerTransTxt)
    {
        return CustVoucher::newCustVoucherSales(_ledgerTransTxt, custInvoiceJour, salesParmTable, salesTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventMovement</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Constructs a <c>InventMovement</c> object.
    /// </summary>
    /// <returns>
    ///     The constructed <c>InventMovement</c> object.
    /// </returns>
    protected InventMovement initInventMovement()
    {
        return InventMovement::construct(salesLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRecordLists</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the record lists.
    /// </summary>
    protected void initRecordLists()
    {
        super();
        recordInsertListCustInvoiceBackorderLine = new RecordInsertList(tableNum(CustInvoiceBackorderLine));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRelatedLineTables</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the records related to the current journal line.
    /// </summary>
    protected void initRelatedLineTables()
    {
        super();

        salesPurchLine = salesLine;

        setPrefix(#PreFixField(salesLine, SalesId));

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU])
            && salesLine.AssetId_RU && ! salesLine.creditNoteLine())
        {
            RAssetStandards assetStandardsDefault = RAssetStandards::find(salesLine.AssetId_RU, RAssetParameters::find().StandardIdDefault);

            if (assetStandardsDefault && assetStandardsDefault.Depreciation)
            {
                assetLedgerVoucherBase = ledgerVoucher;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTotals</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the totals class to post the invoice.
    /// </summary>
    protected void initTotals()
    {
        if (this.parmTotals())
        {
            salesTotals = this.parmTotals() as SalesTotals;
        }
        else
        {
            salesTotals = SalesTotals::construct(salesParmTable, this.parmSpecQty(), this.parmSumBy(), custInvoiceJour.ParmId, this.parmSumOrderId(), this.documentStatus());
        }

        salesTotals.prepareTotalAmountCalculation();
        salesTotals.prepareQuantitiesCalculation();

        this.tax(salesTotals.tax());

        if (TaxWithholdParameters_IN::checkTaxParameters() && this.checkWithholdCalculate(salesTable))
        {
            this.taxWithholdCalculation_IN(salesTotals.taxWithholdCalculation_IN());
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            if (!this.checkSalesBook_RU())
            {
                error(strFmt("@GLS101326", custInvoiceJour.InvoiceId, custInvoiceJour.InvoiceDate));
                throw error("@GLS101992");
            }

            if (RestoredVATLogTable_RU::checkApproved(custInvoiceJour.InvoiceDate))
            {
                error(RestoredVATLogTable_RU::txtApprovedMsg(custInvoiceJour.InvoiceDate));
                throw error("@GLS101992");
            }

            RestoredVATLogTable_RU::setRecalcAll(custInvoiceJour.InvoiceDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTransactionTxt</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the <c>TransactionTxt</c> object.
    /// </summary>
    /// <param name="_ledgerTransTxt">
    ///     A ledger transaction text.
    /// </param>
    /// <returns>
    ///     An instance of the <c>TransactionTxt</c> object.
    /// </returns>
    protected TransactionTxt initTransactionTxt(LedgerTransTxt _ledgerTransTxt)
    {
        transactionTxt = TransactionTxt::construct();
        transactionTxt.setType(_ledgerTransTxt);
        transactionTxt.setLanguage(custInvoiceJour.LanguageId);
        transactionTxt.setVoucher(custInvoiceJour.LedgerVoucher);
        transactionTxt.setFormLetter(custInvoiceJour.InvoiceId);
        transactionTxt.setKey1(custInvoiceJour.SalesId);
        transactionTxt.setKey2(custInvoiceJour.InvoiceAccount);
        transactionTxt.setKey3(CustTable::groupId(custInvoiceJour.InvoiceAccount));

        if (TransactionTextContext::isTypeSupported(_ledgerTransTxt))
        {
            TransactionTextContext transactionTextContext = TransactionTextContext::newForTransactionType(_ledgerTransTxt);
            transactionTextContext.setTableBuffer(custInvoiceJour);
            transactionTextContext.setTableBuffer(custInvoiceJour.salesTable());
            transactionTxt.setTransactionTextContext(transactionTextContext);
        }

        if (BrazilParameters::isEnabled())
        {
            this.postInitTransactionTxt_BR(transactionTxt);
        }

        return transactionTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromFormLetterContract</Name>
				<Source><![CDATA[
    protected void initFromFormLetterContract(SalesFormLetterContract _formletterContract)
    {
        SalesFormLetterInvoiceContract salesFormLetterInvoiceContract = _formletterContract as SalesFormLetterInvoiceContract;
        this.parmMrcPostingErr(salesFormLetterInvoiceContract.parmMrcPostingErr());
        this.parmMrcPrintOnPack(salesFormLetterInvoiceContract.parmMrcPrintOnPack());
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertBackorderLine</Name>
				<Source><![CDATA[
    protected void insertBackorderLine(SalesLine _salesLine)
    {
        CustInvoiceBackorderLine custInvoiceBackorderLine;

        custInvoiceBackorderLine.initValue();
        custInvoiceBackorderLine.initFromSalesLine(_salesLine);
        custInvoiceBackorderLine.initFromCustInvoiceJour(custInvoiceJour);
        recordInsertListCustInvoiceBackorderLine.add(custInvoiceBackorderLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCreditInvoicingJour</Name>
				<Source><![CDATA[
    protected void insertCreditInvoicingJour(SalesTable _salesTable)
    {
        CustVendCreditInvoicingJour custVendCreditInvoicingJour;

        if (CustVendCreditInvoicingTable::useCreditInvoicingReporting())
        {
            if (_salesTable)
            {
                CustVendCreditInvoicingTable custVendCreditInvoicingTable = CustVendCreditInvoicingTable::findRefId(salesTable.TableId, salesTable.RecId, true);
                if (custVendCreditInvoicingTable)
                {
                    custVendCreditInvoicingJour.insertFromCustVendCreditInvoicingTable(custVendCreditInvoicingTable, custInvoiceJour);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertRecordList</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Inserts records in the record lists into the database.
    /// </summary>
    protected void insertRecordList()
    {
        super();
        recordInsertListCustInvoiceBackorderLine.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>intercompanyAmountMarkupOnTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the intercompany miscellaneous charges amount.
    /// </summary>
    /// <returns>
    ///     Always returns <c>0</c>.
    /// </returns>
    /// <remarks>
    ///     This method is used to calculate miscellaneous charges on the line level.
    /// </remarks>
    protected AmountCur intercompanyAmountMarkupOnTrans()
    {
        return salesLine.interCompanyLineAmount(updateNow,custInvoiceTrans.InvoiceDate, tax);
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyPost</Name>
				<Source><![CDATA[
    protected void interCompanyPost()
    {
        if (!this.isProforma())
        {
            if (custInvoiceJour.interCompanyDoInternalPosting()
                    || (custInvoiceJour.InterCompanyCompanyId && custInvoiceJour.interCompanyDoExternalPosting()))
            {
                SalesInvoiceJournalPrint journalPrint = SalesInvoiceJournalPrint::construct();
                RecordSortedList journalList = journalPrint.newJournalList();
                journalList.ins(custInvoiceJour);

                if (InterCompanyPostStackOverflowPreventionFlight::instance().isEnabled())
                {
                    InterCompanyPost::postContextQueue(
                        InterCompanyPostContractPurch_Invoice::newFromJournal(this.parmChainFormletterContract(), custInvoiceJour, journalList));
                }
                else
                {
                    InterCompanyPostPurch::post(this.parmChainFormletterContract(), custInvoiceJour, journalList);
                }
            }
            else
            {
                if (custInvoiceJour.InterCompanyCompanyId)
                {
                    // If we are not posting down the IC chain, we need to update the deliver remainder of any closed lines
                    InterCompanyPost::syncDlvRemainderCloseLinesFromICSOToICPO(salesParmTable);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventProfileType_RU</Name>
				<Source><![CDATA[
    protected InventProfileType_RU inventProfileType_RU()
    {
        return salesLine.inventProfileType_RU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoicePostingType_RU</Name>
				<Source><![CDATA[
    protected SalesInvoicePostingType_RU invoicePostingType_RU()
    {
        return custInvoiceJour.custInvoiceJour_RU().InvoicePostingType_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isConfigKeyEnabledCreditCard</Name>
				<Source><![CDATA[
    protected boolean isConfigKeyEnabledCreditCard()
    {
        return Global::isConfigurationkeyEnabled(configurationKeyNum(CreditCard));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isConfigkeyEnabledShipCarrier</Name>
				<Source><![CDATA[
    protected boolean isConfigkeyEnabledShipCarrier()
    {
        return Global::isConfigurationkeyEnabled(configurationKeyNum(ShipCarrier));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCorrectionLine_RU</Name>
				<Source><![CDATA[
    private boolean isCorrectionLine_RU()
    {
        return custInvoiceTrans.LineAmount < 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isJournalLinePartDelivery</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether a journal line is a part delivery.
    /// </summary>
    /// <returns>
    ///     true if the journal line is a part delivery; otherwise, false.
    /// </returns>
    protected NoYes isJournalLinePartDelivery()
    {
        return salesLine.SalesQty != custInvoiceTrans.Qty
            || salesLine.canInvoiceOrderLineFromCurrentSalesStatus();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLineStocked</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether a source line is tracked in inventory.
    /// </summary>
    /// <returns>
    ///     true if the source line is tracked in inventory; otherwise, false.
    /// </returns>
    protected boolean isLineStocked()
    {
        return salesLine.isStocked();
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerRefRecid</Name>
				<Source><![CDATA[
    protected RecId ledgerRefRecid()
    {
        return salesLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerRefTableId</Name>
				<Source><![CDATA[
    protected TableId ledgerRefTableId()
    {
        return salesLine.TableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerVoucherObjectDocument</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the document values from the <c>LedgervoucherObject</c> object.
    /// </summary>
    /// <param name="_ledgerVoucherObject">
    ///     A <c>LedgerVoucherObject</c> object.
    /// </param>
    /// <returns>
    ///     A <c>Container</c> that contains document values.
    /// </returns>
    protected container ledgerVoucherObjectDocument(LedgerVoucherObject _ledgerVoucherObject)
    {
        return super(_ledgerVoucherObject);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineAmountExclTaxInventoryPosted</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the line amount excluded tax for a quantity that is updated in inventory.
    /// </summary>
    /// <returns>
    ///     The line amount excluded tax for the quantity that is updated in inventory.
    /// </returns>
    protected AmountCur lineAmountExclTaxInventoryPosted()
    {
        //<GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            return salesParmLine.amountExcludingTaxGTE();
        }
        //</GTE>
        return salesLine.calcLineAmountExclTax(updateNow, this.updateDate(), tax) + salesTotals.lineAdjustment(salesLine.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineAmountInventoryPosted</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the line amount for a quantity that is updated in inventory.
    /// </summary>
    /// <returns>
    ///     The line amount for the quantity that is updated in inventory.
    /// </returns>
    protected AmountCur lineAmountInventoryPosted()
    {
        return salesLine.calcLineAmount(updateNow);
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupOnJourSourceQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Builds a query to find miscellaneous charges on the header level.
    /// </summary>
    /// <returns>
    ///     The built query.
    /// </returns>
    protected Query markupOnJourSourceQuery()
    {
        return salesParmTable.querySalesTable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrProcessGiftCards</Name>
				<Source><![CDATA[
    private void mcrProcessGiftCards()
    {
        RetailParameters retailParameters;
        RefRecId retailChannel;
        RetailSharedParameters retailSharedParameters;

        // <GEERU>
        RetailGiftCardPost_RU giftCardPost_RU;
        // </GEERU>
        Map externalGiftCardItemMap = new Map(Types::String, Types::Class);

        retailChannel = salesTable.retailSalesTable().RetailChannel;

        // Setup external gift card cache
        // During implementation of the external gift card feature the following code was hiding
        // the external gift card functionality using RetailSharedParameters.EnableAdvancedExternalGiftCard
        // Unfortunately when a gift card is external it cannot be switched back to internal and must be
        // processed as an external gift card
        externalGiftCardItemMap = this.getExternalGiftCardCache(retailChannel);

        retailParameters = RetailParameters::find();

        // Only execute if a gift card item has been specified
        if (retailParameters.GiftcardItem)
        {
            // And the order is in a channel that is not in a channel of type store
            if (retailChannel && !RetailStoreTable::findRecId(retailChannel))
            {
                // <GEERU>
                if (retailParameters.ProcessGiftCardsAsPrepayments_RU)
                {
                    giftCardPost_RU = RetailGiftCardPost_RU::construct();
                }
                // </GEERU>

                this.postExternalGiftCards(salesTable, retailChannel, externalGiftCardItemMap, retailParameters);
                this.postInternalGiftCards(salesTable, retailChannel, retailParameters, giftCardPost_RU);

                // <GEERU>
                if (giftCardPost_RU)
                {
                    giftCardPost_RU.post();
                }
                // </GEERU>
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExternalGiftCardCache</Name>
				<Source><![CDATA[
    private Map getExternalGiftCardCache(RefRecId _retailChannel)
    {
        RetailStoreTenderTypeTable retailStoreTenderTypeTable;
        RetailStoreTenderTypeCardTable retailStoreTenderTypeCardTable;
        RetailTenderTypeCardTable retailTenderTypeCardTable;
        CreditCardAccountSetup creditCardAccountSetup;
        CreditCardProcessors creditCardProcessors;

        Map externalGiftCardItemMap = new Map(Types::String, Types::Class);
        
        while
            select Channel, ConnectorName, GiftCardItemId from retailStoreTenderTypeTable
                where retailStoreTenderTypeTable.ConnectorName != ''
                    && retailStoreTenderTypeTable.Channel == _retailChannel
                join Channel, tenderTypeId, cardTypeId from retailStoreTenderTypeCardTable
                    where retailStoreTenderTypeCardTable.Channel == _retailChannel
                        && retailStoreTenderTypeCardTable.tenderTypeId == retailStoreTenderTypeTable.tenderTypeId
                join cardTypeId, cardTypes from retailTenderTypeCardTable
                    where retailTenderTypeCardTable.cardTypeId == retailStoreTenderTypeCardTable.cardTypeId
                        && retailTenderTypeCardTable.cardTypes == RetailCardTypesBase::GiftCard
                join ConnectorName, CreditCardProcessors, SecureMerchantProperties, CreditCardProcessors from creditCardAccountSetup
                    where creditCardAccountSetup.ConnectorName == retailStoreTenderTypeTable.ConnectorName
                join RecId from creditCardProcessors
                    where creditCardProcessors.RecId == creditCardAccountSetup.CreditCardProcessors
        {
            // check payment processors properties
            var merchant = creditCardAccountSetup.manageEncryptionForSecureMerchantProperties(false, '');
            CreditCardPaymentProperties properties = CreditCardPaymentProperties::fromXmlString(merchant);

            CreditCardPaymentProperty property = properties.find(Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_MerchantAccount(), Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.MerchantAccountProperties::SupportedCurrencies);
            str supportedCurrencies = property ? property.parmStringValue() : '';

            property = properties.find(Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.GenericNamespace::get_MerchantAccount(), Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants.MerchantAccountProperties::SupportedTenderTypes);
            str supportedTenderTypes = property ? ';' + property.parmStringValue() + ';' : '';

            // Check this connector supports GiftCard
            if (supportedTenderTypes != '' && strScan(supportedTenderTypes, ';' + Microsoft.Dynamics.Retail.PaymentSDK.Portable.CardType::GiftCard.ToString() + ';', 1, strLen(supportedTenderTypes)))
            {
                if (!externalGiftCardItemMap.exists(retailStoreTenderTypeTable.GiftCardItemId))
                {
                    Map externalGiftCardCurrencyMap = new Map(Types::String, Types::Int64);
                    List supportedCurrencyList = new List(Types::String);
                    supportedCurrencyList = strSplit(supportedCurrencies, ';');
                    ListIterator myIterator = new ListIterator(supportedCurrencyList);
                    while (myIterator.more())
                    {
                        str currency = myIterator.value();
                        if (!externalGiftCardCurrencyMap.exists(currency))
                        {
                            externalGiftCardCurrencyMap.insert(currency, creditCardAccountSetup.CreditCardProcessors);
                        }

                        myIterator.next();
                    }

                    externalGiftCardItemMap.insert(retailStoreTenderTypeTable.GiftCardItemId, externalGiftCardCurrencyMap);
                }
            }
        }

        return externalGiftCardItemMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postExternalGiftCards</Name>
				<Source><![CDATA[
    private void postExternalGiftCards(SalesTable _salesTable, RefRecId _retailChannel, Map _externalGiftCardItemMap, RetailParameters _retailParameters)
    {
        SalesLine localSalesLine;
        RetailStoreTenderTypeTable retailStoreTenderTypeTable;
        MCRSalesLine localMCRSalesLine;

        // Create all external gift cards on the invoiced order, and issue gift card transactions for them
        while select localSalesLine
                    where localSalesLine.SalesId == _salesTable.SalesId
                        && localSalesLine.SalesStatus == SalesStatus::Invoiced
                        && localSalesLine.ItemId != _retailParameters.GiftcardItem
                    join GiftCardItemId from retailStoreTenderTypeTable
                    where retailStoreTenderTypeTable.Channel == _retailChannel
                        && retailStoreTenderTypeTable.GiftCardItemId == localSalesLine.ItemId
                        && retailStoreTenderTypeTable.GiftCardItemId != ''
                    join forupdate localMCRSalesLine
                    where localMCRSalesLine.SalesLine == localSalesLine.RecId
        {
            ttsbegin;

            this.postExternalGiftCard(localMCRSalesLine, _externalGiftCardItemMap, localSalesLine, _retailParameters, _retailChannel);

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInternalGiftCards</Name>
				<Source><![CDATA[
    private void postInternalGiftCards(SalesTable _salesTable, RefRecId _retailChannel, RetailParameters _retailParameters, RetailGiftCardPost_RU _giftCardPost_RU)
    {
        SalesLine localSalesLine;
        MCRSalesLine localMCRSalesLine;
        RetailGiftCardTransactions retailGiftCardTransactions;
        RetailGiftCardTable retailGiftCardTable;

        // Create all internal gift cards on the invoiced order, and issue gift card transactions for them
        while select localSalesLine
                where localSalesLine.SalesId == _salesTable.SalesId
                    && localSalesLine.ItemId == _retailParameters.GiftcardItem
                    && localSalesLine.SalesStatus == SalesStatus::Invoiced
                join forupdate localMCRSalesLine
                    where localMCRSalesLine.SalesLine == localSalesLine.RecId
                notexists join retailGiftCardTransactions
                    where retailGiftCardTransactions.mcrInventTransId == localSalesLine.InventTransId
        {
            ttsbegin;
            if (_retailParameters.GiftCardCompany == curext() || !_retailParameters.GiftCardCompany)
            {
                this.postInternalGiftCard(localMCRSalesLine, localSalesLine, _retailParameters, _retailChannel, _salesTable, retailGiftCardTable);
            }
            else
            {
                changecompany(_retailParameters.GiftCardCompany)
                {
                    this.postInternalGiftCard(localMCRSalesLine, localSalesLine, _retailParameters, _retailChannel, _salesTable, retailGiftCardTable);
                }
            }

            // <GEERU>
            if (_giftCardPost_RU)
            {
                _giftCardPost_RU.createGiftCardJournalLines(
                            retailGiftCardTable.entryId,
                            SalesTable.InvoiceAccount,
                            DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
                            localSalesLine.CurrencyCode,
                            localMCRSalesLine.GiftCardAmount_RU,
                            salesTable.DefaultDimension);
            }
            // </GEERU>

            // insert email notification record for internal gift card
            if (localMCRSalesLine.GiftCardType == MCRGiftCardType::Email)
            {
                RetailEventNotificationAction::insertRetailOENAction(RetailEventNotificationType::MCRIssueGiftCard, localSalesLine.RecId, salesTable);
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInternalGiftCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates the gift card details and its transactions.
    /// </summary>
    /// <param name = "_localMCRSalesLine">
    /// The <c>MCRSalesLine</c> table record.
    /// </param>
    /// <param name = "_localSalesLine">
    /// The <c>SalesLine</c> table record.
    /// </param>
    /// <param name = "_retailParameters">
    /// The <c>RetailParameters</c> table record.
    /// </param>
    /// <param name = "_retailChannel">
    /// The record ID.
    /// </param>
    /// <param name = "_localSalesTable">
    /// The <c>Salestable</c> table record.
    /// </param>
    /// <param name = "_retailGiftCardTable">
    /// The <c>RetailGiftCardTable</c> table record.
    /// </param>
    protected void postInternalGiftCard(MCRSalesLine _localMCRSalesLine, SalesLine _localSalesLine, RetailParameters _retailParameters, RefRecId _retailChannel, SalesTable _localSalesTable, RetailGiftCardTable _retailGiftCardTable)
    {
        CreditCardAuthTrans creditCardAuthTrans;
        RetailGiftCardTransactions insertRetailGiftCardTransactions;
        utcdatetime systemDateTime;

        if (!_localMCRSalesLine.GiftCardNumber && _localMCRSalesLine.GiftCardType == MCRGiftCardType::Physical)
        {
            throw error("@MCR40294");
        }

        systemDateTime = DateTimeUtil::getSystemDateTime();

        ttsbegin;

        // Internal gift cards
        _retailGiftCardTable.selectForUpdate(true);
        if (!_localMCRSalesLine.GiftCardNumber && _localMCRSalesLine.GiftCardType == MCRGiftCardType::Email)
        {
            //create number
            _retailGiftCardTable.EntryId = MCRGiftCard::generateGiftCardSerialNumber();

            this.updateMCRSalesLineGiftCardDetails(_localMCRSalesLine.RecId, _retailGiftCardTable.EntryId, '');
            _localMCRSalesLine.reread();
        }
        else if (_localMCRSalesLine.GiftCardNumber && _localMCRSalesLine.GiftCardType == MCRGiftCardType::Physical)
        {
            _retailGiftCardTable.EntryId = _localMCRSalesLine.GiftCardNumber;
        }
        if (_retailGiftCardTable.EntryId)
        {
            _retailGiftCardTable.mcrGiftCardType = _localMCRSalesLine.GiftCardType;
            _retailGiftCardTable.CurrencyCode = _localSalesLine.CurrencyCode;
            _retailGiftCardTable.Reserved = NoYes::No;
            if (_retailParameters.UseGiftCardPolicies)
            {
                _retailGiftCardTable.initGiftCardPolicies(_retailGiftCardTable.EntryId, DateTimeUtil::applyTimeZoneOffset(systemDateTime, DateTimeUtil::getCompanyTimeZone()), DateTimeUtil::getCompanyTimeZone());
            }

            _retailGiftCardTable.insert();
        }
        else
        {
            throw error("@MCR40295");
        }

        insertRetailGiftCardTransactions.selectForUpdate();
        insertRetailGiftCardTransactions.mcrInventTransId = _localSalesLine.InventTransId;
        insertRetailGiftCardTransactions.Amount =
            // <GEERU>
            (_retailParameters.ProcessGiftCardsAsPrepayments_RU) ?
                    _localMCRSalesLine.GiftCardAmount_RU :
            // </GEERU>
            _localSalesLine.LineAmount;
        insertRetailGiftCardTransactions.Channel = _retailChannel;
        insertRetailGiftCardTransactions.CardNumber = _retailGiftCardTable.EntryId;
        insertRetailGiftCardTransactions.mcrInvoiceAccount = _localSalesTable.InvoiceAccount;
        insertRetailGiftCardTransactions.Operation = RetailGiftCardOperation::Issue;
        insertRetailGiftCardTransactions.TransDate = DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(systemDateTime, DateTimeUtil::getCompanyTimeZone()));
        insertRetailGiftCardTransactions.TransTime = DateTimeUtil::time(DateTimeUtil::applyTimeZoneOffset(systemDateTime, DateTimeUtil::getCompanyTimeZone()));
        insertRetailGiftCardTransactions.Channel = salesTable.retailSalesTable().RetailChannel;
        insertRetailGiftCardTransactions.insert();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postExternalGiftCard</Name>
				<Source><![CDATA[
    private void postExternalGiftCard(MCRSalesLine _localMCRSalesLine, Map _externalGiftCardItemMap, SalesLine _localSalesLine, RetailParameters _retailParameters, RefRecId _retailChannel)
    {
        CreditCardAuthTrans creditCardAuthTrans;
        RetailGiftCardTable retailGiftCardTable;
        RetailGiftCardTransactions insertRetailGiftCardTransactions;
        utcdatetime systemDateTime;

        if (!_localMCRSalesLine.GiftCardNumber && _localMCRSalesLine.GiftCardType == MCRGiftCardType::Physical)
        {
            throw error("@MCR40294");
        }

        systemDateTime = DateTimeUtil::getSystemDateTime();

        if (_localMCRSalesLine.GiftCardType == MCRGiftCardType::Email)
        {
            if (_localMCRSalesLine.GiftCardRecipientEmail == "" || _localMCRSalesLine.GiftCardBuyerName == "")
            {
                throw error("@Retail:RetailMissingEmailDetails");
            }

            // Has this activation been processed already
            creditCardAuthTrans = RetailActivationLinkTable::findLatestGiftCardActivation(_localSalesLine.RecId);

            if (!(creditCardAuthTrans))
            {
                // External virtual gift card, find the credit card processor by gift card item id and currency
                Map CurrencyMap = _externalGiftCardItemMap.lookup(_localSalesLine.ItemId);

                if(CurrencyMap.exists(_localSalesLine.CurrencyCode))
                {
                    // Activate gift card for amount
                    RetailExternalGiftCard retailExternalGiftCard = new RetailExternalGiftCard();
                    retailExternalGiftCard.ActivationProcessorsRecId = CurrencyMap.lookup(_localSalesLine.CurrencyCode);
                    retailExternalGiftCard.ActivationSalesLineRecId = _localSalesLine.RecId;

                    RetailActivationResult result = CreditCardProcess::doActivation(salesTable, retailExternalGiftCard, _localSalesLine.LineAmount);
                
                    if (!result.Success)
                    {
                        throw error("@Retail:RetailFailedToIssueGiftCard");
                    }

                    // Update MCRSaleLine.giftcard number
                    creditCardAuthTrans = RetailActivationLinkTable::findLatestGiftCardActivation(_localSalesLine.RecId);

                    if (creditCardAuthTrans)
                    {
                        try
                        {
                            // Send email without storing details!!!!
                            MCRRetailOENInfo_GiftCardIssue notificationInfo = new MCRRetailOENInfo_GiftCardIssue();
                            notificationInfo.paramRetailExternalGiftCard(retailExternalGiftCard);
                            notificationInfo.initSetting(_localSalesLine.RecId);

                            str fromAddr, toAddr, subject, message;
                            [fromAddr, toAddr, subject, message] = notificationInfo.generateEmail();

                            RetailEventNotificationService eventNotificationService = new RetailEventNotificationService();
                            eventNotificationService.trySendEmail(RetailEventNotificationSendEmailParameters::construct(fromAddr, toAddr, subject, message));

                            this.updateMCRSalesLineGiftCardDetails(_localMCRSalesLine.RecId, MCRGiftCard::maskCardNum(result.CardNumber), result.Expiration);
                            _localMCRSalesLine.reread();
                            eventSource.EventWritePaymentsEmailExternalGiftCardComplete();
                        }
                        catch
                        {
                            eventSource.EventWritePaymentsEmailExternalGiftCardFailed(_localMCRSalesLine.RecId);
                            CreditCardProcess::mcrDoVoidPreAuth(creditCardAuthTrans);
                            throw Error("@Retail:RetailFailedToEmailGiftCard");
                        }
                    }
                    else
                    {
                        eventSource.EventWritePaymentsFailedToFindCreditCardAuthTrans(_localMCRSalesLine.RecId);
                        throw Error("@Retail:RetailMissingLinkRecord");
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMCRSalesLineGiftCardDetails</Name>
				<Source><![CDATA[
    private void updateMCRSalesLineGiftCardDetails(RecId _mcrSalesLineRecId, RetailGiftCardId _giftCardNumber, RetailGiftCardExpirationShort _expiration)
    {
        MCRSalesLine outOfScopeMCRSalesLine;
        var connection = new UserConnection();

        try
        {
            outOfScopeMCRSalesLine.setConnection(connection);

            connection.ttsbegin();

            select firstonly forupdate outOfScopeMCRSalesLine
                    where outOfScopeMCRSalesLine.RecId == _mcrSalesLineRecId;

            if (outOfScopeMCRSalesLine)
            {
                outOfScopeMCRSalesLine.GiftCardNumber = _giftCardNumber;
                outOfScopeMCRSalesLine.GiftCardExpiration = _expiration;
                outOfScopeMCRSalesLine.update();
            }
                
            connection.ttscommit();
        }
        finally
        {
            connection.finalize();
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrSetHasShipped</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates map with current sales ID and whether or
    /// not this order has been shipped.
    /// </summary>
    /// <remarks>
    /// This method sets the flag MCRPreviously shipped to indicate if
    /// any part of the order was shipped earlier.
    /// </remarks>
    void mcrSetHasShipped()
    {
        MCRPreviouslyShipped = salesTable.mcrHasShipped();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrSettlePayments</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Settles payment and invoice transactions for multiple payments.
    /// </summary>
    void mcrSettlePayments()
    {
        MCRCustPaymTotals mcrCustPaymTotals = MCRCustPaymTotals::construct(salesTable.TableId, salesTable.RecId);
        MCRSalesTable mcrSalesTable = salesTable.mcrSalesTable();

        if (!mcrCustPaymTotals.validatePost())
        {
            throw error("@MCR10794");
        }

        // post payments
        // If summary invoice call separate method to post payments
        boolean isMultipleSalesInvoice = CustInvoiceSalesLink::MCRIsMultipleOrdersInvoice(custInvoiceJour.SalesId, custInvoiceJour.InvoiceId);

        //Set parm method on total to settle the payments
        mcrCustPaymTotals.parmSettleNow(true);

        if (isMultipleSalesInvoice)
        {
            mcrCustPaymTotals.postPaymentsMultipleOrders(custInvoiceJour);
            mcrCustPaymTotals.parmSalesInvoiceId(custInvoiceJour.InvoiceId);
        }
        else
        {
            // record the payment amount and the amount due
            // (for use on printed invoices)
            mcrCustPaymTotals.parmCustInvoiceJour(custInvoiceJour);
            mcrCustPaymTotals.parmSalesInvoiceId(custInvoiceJour.InvoiceId);

            int fromLine = Global::infologLine();
            boolean isProcessPaymentsSuccessful;

            if (this.mcrShouldPostNonPrepayments(mcrCustPaymTotals))
            {
                isProcessPaymentsSuccessful = mcrCustPaymTotals.processPayments(MCRProcessPaymAction::PostAll, false, false);
            }
            else
            {
                isProcessPaymentsSuccessful = mcrCustPaymTotals.processPayments(MCRProcessPaymAction::PostOnlyPrepays, false, false);
            }

            if (!isProcessPaymentsSuccessful)
            {
                throw error(strFmt('@Retail:RetailFailureUnauthorizedPayments') + '\n' +
                           '@Retail:RetailFailureUnauthorizedPaymentsPostingDetails' + strFmt('%1', RetailTransactionServiceUtilities::getInfologMessages(fromLine)));
            }

            [custInvoiceJour.MCRPaymAmount, custInvoiceJour.MCRDueAmount] = mcrCustPaymTotals.calcInvoiceAmounts(custInvoiceJour);

            custInvoiceJour.update();
        }

        AmountCur onAccountPayments = mcrCustPaymTotals.getTotalPaymAmount_OnAccount();
        AmountCur nonOnAccountPayments = mcrCustPaymTotals.getTotalPaymAmount_notOnAccount();
        AmountCur totalPaymentAmount = mcrCustPaymTotals.getTotalPaymAmount();

        // settle payments agains invoices
        if (mcrSalesTable.Continuitychild)
        {
            if (SalesTable.mcrIsContParentOrderBillUpFront()
            && mcrSalesTable.ContinuityLineEval == MCRContinuityLineEval::Paid)
            {
                // settle continuity child orders
                mcrCustPaymTotals.settleBillUpFrontContChildren();
            }
        }
        else
        {
            //settle for regular sales
            mcrCustPaymTotals.settlePayments(true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrShouldPostNonPrepayments</Name>
				<Source><![CDATA[
    internal boolean mcrShouldPostNonPrepayments(MCRCustPaymTotals _mcrCustPaymTotals)
    {
        // Regular Invoices: Only post if total posted payment amount is less than total invoiced amount for the order.
        // Credit Notes: Always post.
        real absoluteInvoicePostedDifference = abs(_mcrCustPaymTotals.getTotalInvoicedAmount()) - abs(_mcrCustPaymTotals.getTotalPostedPaymAmount());
        real maximumDifference = 0;

        // when partially invoicing an order, the invoiced portion can be rounded up to one penny more resulting in attempting to charge .01 on the authorized credit card.
        if (_mcrCustPaymTotals.getTotalSalesAmount() > _mcrCustPaymTotals.getTotalInvoicedAmount())
        {
            maximumDifference = Currency::roundingPrecisionAdjusted(_mcrCustPaymTotals.getCurrency());
        }

        return (absoluteInvoicePostedDifference > maximumDifference) || (custInvoiceJour.InvoiceAmount < 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrUpdateCoupon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the coupon for fully invoiced orders.
    /// This method is deprecated.
    /// </summary>
    protected void mcrUpdateCoupon()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrWriteProformaMarkup</Name>
				<Source><![CDATA[
    private void mcrWriteProformaMarkup()
    {
        formletterJournal = this.parmJournalTable();
        formletterJournalTrans = this.journalLine();

        // loop over lines
        this.selectFormletterJournalTrans();

        while (this.formletterJournalTransRecord())
        {
            salesLine salesLineLocal = this.sourceLine();
            custInvoiceTrans custInvoiceTransLocal = custInvoiceTrans::findRecId(this.formletterJournalTransRecord());
            markup.mcrProforma(custInvoiceTransLocal.Qty, // qty
                              lineValue,
                              salesLineLocal, // source
                              custInvoiceTransLocal); // destination
            this.nextFormletterJournalTrans();
        }

        QueryRun queryRun = new QueryRun(salesParmTable.querySalesTable());

        while (queryRun.next())
        {
            if (queryRun.changed(tablenum(SalesTable)))
            {
                SalesTable salesTableMarkupLocal = queryRun.get(tablenum(SalesTable));

                // Use local variable. Return value of parmTotals may be null.
                salesTotals salesTotalsLocal = SalesTotals;

                markup.mcrProforma(1,
                                  salesTotalsLocal.getMarkupTableSourceValue(salesTableMarkupLocal),
                                  salesTableMarkupLocal,
                                  custInvoiceJour,
                                  salesTotalsLocal.mcrTotalOrderBalanceAbsoluteValue(salesTableMarkupLocal.RecId),
                                  salesParmTable.ParmId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveSpecTrans_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Moves the specification from the sales order to the invoice.
    /// </summary>
    protected void moveSpecTrans_RU()
    {
        SpecTrans specTrans;

        while select forupdate specTrans
            where specTrans.SpecTableId == salesTable.TableId
               && specTrans.SpecRecId == salesTable.RecId
               && specTrans.SpecCompany == salesTable.DataAreaId
        {
            specTrans.SpecTableId = custInvoiceJour.TableId;
            specTrans.SpecRecId = custInvoiceJour.RecId;
            specTrans.SpecCompany = custInvoiceJour.company();
            specTrans.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreateScrapOnInventory</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether to create scrap on inventory.
    /// </summary>
    /// <returns>
    ///     true if there should be created scrap on inventory; otherwise, false.
    /// </returns>
    protected boolean mustCreateScrapOnInventory()
    {
        SalesLine localsalesLine = this.sourceLine();
        return localsalesLine.Scrap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalTable</Name>
				<Source><![CDATA[
    public Common parmJournalTable(Common _journalTable = custInvoiceJour)
    {
        CustInvoiceJour custInvoiceJourToCache;

        if (!prmisDefault(_journalTable))
        {
            custInvoiceJour = _journalTable as CustInvoiceJour;

            if (custInvoiceJour)
            {
                select nofetch custInvoiceJourToCache where
                    custInvoiceJourToCache.InvoiceId == custInvoiceJour.InvoiceId &&
                    custInvoiceJourToCache.InvoiceDate == custInvoiceJour.InvoiceDate &&
                    custInvoiceJourToCache.NumberSequenceGroup == custInvoiceJour.NumberSequenceGroup &&
                    custInvoiceJourToCache.SalesId == custInvoiceJour.SalesId;

                custInvoiceJourCache = new RecordViewCache(custInvoiceJourToCache);
            }
        }

        return custInvoiceJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMrcPostingErr</Name>
				<Source><![CDATA[
    public boolean parmMrcPostingErr(boolean _mrcPostingErr = mrcPostingErr)
    {
        mrcPostingErr = _mrcPostingErr;

        return mrcPostingErr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMrcPrintOnPack</Name>
				<Source><![CDATA[
    public boolean parmMrcPrintOnPack(boolean _mrcPrintOnPack = mrcPrintOnPack)
    {
        mrcPrintOnPack = _mrcPrintOnPack;

        return mrcPrintOnPack;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParmTable</Name>
				<Source><![CDATA[
    public Common parmParmTable(Common _parmTable = salesParmTable)
    {
        salesParmTable = _parmTable as SalesParmTable;

        return salesParmTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsMRCParameters</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds related instance of <c>PdsMRCParameters</c> class if relation exists.
    /// </summary>
    /// <returns>
    ///     An instance of the <c>PdsMRCParameters</c> class.
    /// </returns>
    protected PdsMRCParameters pdsMRCParameters()
    {
        if (!pdsMRCParameters.RecId)
        {
            pdsMRCParameters = PdsMRCParameters::find();
        }

        return pdsMRCParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postAsset_RU</Name>
				<Source><![CDATA[
    protected void postAsset_RU()
    {
        if (salesLine.AssetId_RU)
        {
            if (salesLine.creditNoteLine())
            {
                this.updateAssetReverse_RU();
            }
            else
            {
                this.updateAsset_RU(transactionTxt);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postBalanceAsManyLedgerTransactions_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Indicates, that GL transactions related to balance, must be posted as several transaction, i.e. debit and credit transactions
    ///   should not be summarized if there are both positive and negative lines on the invoice.
    /// </summary>
    /// <returns>
    ///   Boolean value.
    /// </returns>
    protected boolean postBalanceAsManyLedgerTransactions_RU()
    {
        return salesTotals.totalAmountBySign_RU(false) && salesTotals.totalAmountBySign_RU(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCrossCompanyGiftcard</Name>
				<Source><![CDATA[
    private void postCrossCompanyGiftcard()
    {
        SalesLine                       giftcardSalesLine;
        MCRCustPaymTable                giftcardPaymentMCRCustPaymTable;
        //LedgerJournalTrans              giftcardPaymentLedgerJournalTrans;
        LedgerJournalName               journalName;
        LedgerJournalTable              ledgerJournal;
        LedgerJournalTrans              ledgerJournalTrans;
        RetailStoreTenderTypeTable      retailStoreTenderTypeTable;

        void createPaymentLedgerTrans(
                LedgerDimensionAccount _accountNum,
                LedgerDimensionAccount _offsetAccountNum,
                CurrencyCode           _currency,
                AmountCur              _Amount,
                TransDate              _date)
        {
            LedgerJournalTrans ledgerJournalLine;

            if (!_Amount)
            {
                return;
            }

            if (!_accountNum || !_offsetAccountNum)
            {
                // Account number or offset account number is not correctly set up, intercompany gift card posting can't proceed.
                throw error("@REX4040024");
            }

            ledgerJournalLine.initValue();
            ledgerJournalLine.JournalNum = ledgerJournal.JournalNum;
            ledgerJournalLine.AccountType = LedgerJournalACType::Ledger;
            ledgerJournalLine.Company = curext();
            ledgerJournalLine.LedgerDimension = _accountNum;

            ledgerJournalLine.OffsetCompany = RetailGiftCardPostingParameters::getGiftCardCompany();
            ledgerJournalLine.OffsetLedgerDimension = _offsetAccountNum;
            ledgerJournalLine.OffsetAccountType = LedgerJournalACType::Ledger;

            ledgerJournalLine.CurrencyCode = _currency;
            ledgerJournalLine.TransDate = _date;

            ledgerJournalLine.DocumentNum = custInvoiceJour.InvoiceId;
            ledgerJournalLine.TransactionType = LedgerTransType::Transfer;

            if (_Amount < 0)
            {
                ledgerJournalLine.AmountCurDebit = abs(_Amount);
            }
            else
            {
                ledgerJournalLine.AmountCurCredit = _Amount;
            }

            ledgerJournalLine.defaultRow();

            ledgerJournalLine.insert();
        }

        DataAreaId giftcardCompany = RetailGiftCardPostingParameters::getGiftCardCompany();

        // This method is only applicable when a gift card company is other than current company.
        if (!giftcardCompany || giftcardCompany == curext())
        {
            // No intercompany giftcard posting is needed.
            return;
        }

        // This method is only applicable when posting Invoices for Call Center Orders
        if (!custInvoiceJour.salesTable().mcrIsCallCenter())
        {
            // No intercompany giftcard posting is needed.
            return;
        }

        // <GEERU>
        if (RetailParameters::find().ProcessGiftCardsAsPrepayments_RU)
        {
            // Standard intercompany giftcard posting should be skipped.
            return;
        }
        // </GEERU>

        select journalName from journalName where journalName.JournalName == RetailGiftCardPostingParameters::getGiftCardLedgerJournalName();

        if (!journalName)
        {
            // Journal name is not correctly set up, intercompany gift card posting can't proceed.
            throw error("@REX4040023");
        }

        // Get the number sequence for slip journal document
        NumberSeq journalNumSeq = NumberSeq::newGetNum(LedgerParameters::numRefJournalNum());

        // Create ledger journal
        ledgerJournal.JournalName = journalName.JournalName;
        ledgerJournal.JournalType = journalName.JournalType;
        ledgerJournal.JournalNum = journalNumSeq.num();
        ledgerJournal.NumberSequenceTable = journalName.NumberSequenceTable;
        ledgerJournal.DocumentNum = custInvoiceJour.InvoiceId;

        ledgerJournal.insert();

        // Create Intercompany voucher for gift cards issued (1 journal for each gift card issued in the order)
        while select salesId, currencyCode, salesPrice, DefaultDimension
        from giftcardSalesLine
        where giftcardSalesLine.SalesId == custInvoiceJour.salesTable().SalesId &&
              giftcardSalesLine.itemId == RetailParameters::find().GiftcardItem
        {
            if (giftcardSalesLine.salesPrice)
            {
                createPaymentLedgerTrans(
                        RetailGiftCardPostingParameters::getSalesOrderAccountNumberForStatementId(curext(), giftcardSalesLine.DefaultDimension, giftcardSalesLine.salesTable().retailSalesTable().StatementId),
                        RetailGiftCardPostingParameters::getSalesOrderAccountNumberForStatementId(RetailGiftCardPostingParameters::getGiftCardCompany(), giftcardSalesLine.DefaultDimension, giftcardSalesLine.salesTable().retailSalesTable().StatementId),
                        giftcardSalesLine.currencyCode,
                        // SalesLine table uses negative amounts while RetailTransactionSalesLines uses positive amounts.
                        // The amount on this voucher should be negative, so we are using original netAmount (positive) multiplied by (-1)
                        (-1) * giftcardSalesLine.salesPrice,
                        DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
            }
        }

        while select RefRecId, TenderTypeId, amount, channel, CurrencyCode
        from giftcardPaymentMCRCustPaymTable
        join retailStoreTenderTypeTable
        where // payments are related to current Sales Order being invoiced
        giftcardPaymentMCRCustPaymTable.refrecId == custInvoiceJour.salesTable().RecId &&
              // only Gift card payments
              giftcardPaymentMCRCustPaymTable.CustPaymType == MCRCustPaymType::GiftCard &&
              // Relation with RetailStoreTenderTypeTable
              giftcardPaymentMCRCustPaymTable.TenderTypeId == retailStoreTenderTypeTable.tenderTypeId &&
              giftcardPaymentMCRCustPaymTable.Channel == retailStoreTenderTypeTable.Channel

        {
            if (giftcardPaymentMCRCustPaymTable.Amount)
            {
                createPaymentLedgerTrans(
                        LedgerDimensionFacade::serviceCreateLedgerDimension(retailStoreTenderTypeTable.LedgerDimension,
                                                                                 custInvoiceJour.salesTable().DefaultDimension),
                        retailStoreTenderTypeTable.LedgerDimensionGiftCardCompany,
                        Ledger::accountingCurrency(),
                        giftcardPaymentMCRCustPaymTable.Amount,
                        DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
            }
        }

        // Post the journal
        select firstonly RecId from ledgerJournalTrans
        where ledgerJournalTrans.JournalNum == ledgerJournal.JournalNum;
        if (ledgerJournalTrans.RecId)
        {
            LedgerJournalPost::postJournal(ledgerJournal, NoYes::No, false, true);
        }
        else
        {
            ledgerJournal.delete();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCustVendDetermineTransRefTypeAndTransRefIdDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to determine the CustTransRefType and TransRefId.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>CustInvoiceJour</c> record that is being posted.
    /// </param>
    /// <param name = "_eventHandlerResult">
    /// An <c>EventHandlerResult</c> where a container for the CustTransRefType and the TransRefId can be returned.
    /// </param>
    delegate void postCustVendDetermineTransRefTypeAndTransRefIdDelegate(CustInvoiceJour _custInvoiceJour, EventHandlerResult _eventHandlerResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustVoucherForPostCustVend</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>CustVoucher</c> object for posting.
    /// </summary>
    /// <param name = "ledgerTransTxt">
    /// A ledger transaction text.
    /// </param>
    /// <returns>
    /// The <c>CustVoucher</c> instance.
    /// </returns>
    protected CustVoucher createCustVoucherForPostCustVend(LedgerTransTxt ledgerTransTxt)
    {
        return CustVoucher::newCustVoucherSales(ledgerTransTxt, custInvoiceJour, salesParmTable, salesTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCustVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the customer voucher.
    /// </summary>
    /// <param name = "_custVoucher">
    /// The customer voucher.
    /// </param>
    /// <param name = "_custTrans">
    /// The customer transaction.
    /// </param>
    protected void postCustVoucher(CustVoucher _custVoucher, CustTrans _custTrans)
    {
        _custVoucher.post(ledgerVoucher, _custTrans, NoYes::No, Currency::noYes2UnknownNoYes(custInvoiceJour.Triangulation));
        
        if (SalesInvoiceAddLoggingFlight::instance().isEnabled())
        {
            instrumentationLogger.logInformation("Posted CustTrans with RecId : " + any2Str(_custTrans.RecId));
        }
     
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCustVend</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the customer related postings.
    /// </summary>
    protected void postCustVend()
    {
        CustTrans custTrans;
        CustTransRefType refType;
        Num refId;
        CustInvoiceJour_RU custInvoiceJour_RU;
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

        LedgerTransTxt ledgerTransTxt;

        SalesLine salesLineloc;
        SalesLine_IN salesLine_IN;

        if (!salesTable.createCustTrans_BR())
        {
            return;
        }

        if (!this.isProforma() && EInvoicePost_MX::checkEInvoicePrerequisites(custInvoiceJour))
        {
            this.insertEInvoice_MX(numberSeq);
        }

        if (this.creditNote())
        {
            ledgerTransTxt = LedgerTransTxt::SalesCreditNoteCust;
        }
        else
        {
            ledgerTransTxt = LedgerTransTxt::SalesInvoiceCust;
        }

        if (countryRegion_RU)
        {
            custInvoiceJour_RU = custInvoiceJour.custInvoiceJour_RU();

            if (custInvoiceJour_RU.InvoicePostingType_RU == SalesInvoicePostingType_RU::GoodsInRoute)
            {
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceRU00051, funcName());
                this.moveSpecTrans_RU();
            }
        }

        CustVoucher custVoucher = this.createCustVoucherForPostCustVend(ledgerTransTxt);

        custVoucher.parmExchRate(custInvoiceJour.ExchRate);
        custVoucher.parmExchRateSecondary(custInvoiceJour.ExchRateSecondary);
        custVoucher.parmReportingCurrencyExchRate(custInvoiceJour.ReportingCurrencyExchangeRate);
        custVoucher.parmReportingCurrencyExchRateSecondary(custInvoiceJour.ReportingCurrencyExchangeRateSecondary);
        custVoucher.parmReasonRefRecID(custInvoiceJour.ReasonTableRef);

        if (countryRegion_RU)
        {
            custVoucher.parmSalesInvoicePostingType_RU(custInvoiceJour_RU.InvoicePostingType_RU);
            if (this.postBalanceAsManyLedgerTransactions_RU())
            {
                custVoucher.parmLedgerBalances_RU([[false, salesTotals.totalAmountBySign_RU(false)], [this.parmStorno(), salesTotals.totalAmountBySign_RU(true)]]);
            }
        }

        if (custInvoiceJour.creditNote())
        {
            refType = CustTransRefType::CreditNote;
            refId = custInvoiceJour.InvoiceId;
        }
        else
        {
            refType = CustTransRefType::Invoice;
            refId = custInvoiceJour.InvoiceId;
        }

        EventHandlerResult transRefTypeAndTransRefIdEventResult = EventHandlerResult::newSingleResponse();
        this.postCustVendDetermineTransRefTypeAndTransRefIdDelegate(custInvoiceJour, transRefTypeAndTransRefIdEventResult);
        if (transRefTypeAndTransRefIdEventResult.hasResult())
        {
            container transRefTypeAndTransRefIdResult = transRefTypeAndTransRefIdEventResult.result();
            refType = conPeek(transRefTypeAndTransRefIdResult, 1);
            refId = conPeek(transRefTypeAndTransRefIdResult, 2);
        }

        custVoucher.parmTransRefType(refType);
        custVoucher.parmTransRefId(refId);

        if (BrazilParameters::isEnabled())
        {
            custVoucher.parmAmountCur(salesTotals.custTransAmount_BR());
        }

        if (TaxWithholdParameters_IN::checkTaxParameters() && this.checkWithholdCalculate(salesTable))
        {
            select firstonly tdsGroup, tcsGroup from salesLine_IN
                    where salesLine_IN.tdsGroup != ''
                        || salesLine_IN.tcsGroup != ''
                exists join salesLineloc
                    where salesLineloc.SalesId == salesTable.SalesId
                        && salesLineloc.RecId == salesLine_IN.SalesLine;

            custVoucher.parmIsTDSApplicable_IN(salesLine_IN.tdsGroup !='');
            custVoucher.parmIsTCSApplicable_IN(salesLine_IN.tcsGroup !='');
            custVoucher.parmTaxWithholdAmount_IN(salesTotals.parmTaxWithholdAmount_IN());
            custVoucher.parmTaxWithholdAmountOriginCur_IN(salesTotals.taxWithholdCalculation_IN().totalTaxAmountOriginCur());
        }

        custVoucher.parmBypassCreditCheck(this.determineBypassCreditCheck());
        custVoucher.parmRequireGLPostingPriorToSettlement(this.requireGLPostingPriorToSettlement());
        custVoucher.parmIsCashPayment(this.isCashPayment());

        this.setUpCashRegisterTerminal_W(CustVoucher);

        this.postCustVoucher(custVoucher, custTrans);

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            this.postPostCustVendPackage();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setUpCashRegisterTerminal_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets up Cash Register Terminal if there are parameters.
    /// </summary>
    /// <param name = "_custVoucher">Voucher.</param>
    private void setUpCashRegisterTerminal_W(CustVoucher _custVoucher)
    {
        if (this.parmChainFormletterContract() && this.parmChainFormletterContract().parmParmUpdate())
        {
            SalesParmUpdate salesParmUpdate = this.parmChainFormletterContract().parmParmUpdate() as SalesParmUpdate;
            _custVoucher.parmCashRegisterTerminalRecId(salesParmUpdate.CashRegisterTerminal_W);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineBypassCreditCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine the by pass credit check.
    /// </summary>
    /// <returns>Returns the bypass credit check.</returns>
    protected NoYes determineBypassCreditCheck()
    {
        return salesTable.creditCardBypassCreditLimit() || salesTable.isRetailCashAndCarrySales();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postEndDiscount</Name>
				<Source><![CDATA[
    protected void postEndDiscount()
    {
        if (countryRegionIsRU && this.postBalanceAsManyLedgerTransactions_RU())
        {
            endDiscAmounts = [[false, salesTotals.totalEndDiscBySign_RU(salesTotals.getSignIndexByAmount_RU(1))],
                [this.parmStorno(), salesTotals.totalEndDiscBySign_RU(salesTotals.getSignIndexByAmount_RU(-1))]];
        }
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postEndPost_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Executes Brazilian localization logic after the <c>endPost</c> method.
    /// </summary>
    protected void postEndPost_BR()
    {
        SalesParmUpdate salesParmUpdate;
        FiscalDocumentPost_BR fiscalDocumentPost;

        if (RetailParameters::isRetailEnabledAndInUse()
            && (salesTable.isRetailStatement_BR() || salesTable.retailSalesTable().isRetailCustomerOrder())
            || this.isMCRGiftCardCustInvoiceTrans_BR())
        {
            return;
        }

        if (custInvoiceJour)
        {
            if (custInvoiceJour.isProforma())
            {
                fiscalDocumentPost = new FiscalDocumentPost_BR(
                    FiscalDocumentParmDataCreator_BR::fromCustProFormaInvoice(custInvoiceJour, salesParmTable, salesTotals, salesParmUpdate, salesTable, journalLines_BR, journalTmpTaxWorkTrans));

                fiscalDocumentPost.run();
            }
            else
            {
                if (custInvoiceJour.SalesType == SalesType::ReturnItem || (!this.creditNote() && !salesTable.isCancellingSalesReturn_BR()))
                {
                    select salesParmUpdate
                        where salesParmUpdate.ParmId == salesParmTable.ParmId;

                    fiscalDocumentPost = new FiscalDocumentPost_BR(FiscalDocumentParmDataCreator_BR::fromCustInvoice(custInvoiceJour, salesParmTable, salesTotals, salesParmUpdate, salesTable, journalLines_BR));

                    fiscalDocumentPost.run();

                    if (this.parmWHSLoadId())
                    {
                        WHSLoadLineFiscalDocument_BR::insertLoadLinesForCustInvoiceJour(this.parmWHSLoadId(), custInvoiceJour, fiscalDocumentPost.getFiscalDocument().RecId);
                    }
                }
                else
                {
                    SalesTable_BR salesTable_BR = salesTable.salesTable_BR();

                    if (salesTable_BR.InvoiceRefRecID_BR)
                    {
                        FiscalDocumentPost_BR::cancelFiscalDocument(CustInvoiceJour::findRecId(salesTable_BR.InvoiceRefRecID_BR).fiscalDocument_BR(),
                                                                    custInvoiceJour.LedgerVoucher,
                                                                    custInvoiceJour.InvoiceDate,
                                                                    '',
                                                                    ReasonTableRef::find(custInvoiceJour.ReasonTableRef).ReasonComment);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postEndPostLine_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Executes Brazilian localization logic after the <c>endPostLine</c> method.
    /// </summary>
    protected void postEndPostLine_BR()
    {
        journalLines_BR.ins(custInvoiceTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postFailed</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Called when the posting of a journal fails.
    /// </summary>
    /// <param name="_logText">
    ///     A String with an error message.
    /// </param>
    public void postFailed(LogText _logText = "")
    {
        ShipCarrierShippingRequest shippingRequest;

        if (Global::strContains(_logText,"@SYS116945"))
        {
            // Shipping charges error
            QueryRun queryRun = new QueryRun(this.buildShippingChargesErrorQuery());
            queryRun.next();
            shippingRequest = queryRun.get(tableNum(ShipCarrierShippingRequest));

            if (shippingRequest)
            {
                ttsbegin;
                shippingRequest.ErrorRetreivingCharge = NoYes::Yes;
                shippingRequest.update();
                ttscommit;
            }
        }

        super(_logText);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildShippingChargesErrorQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Builds a query object to get <c>ShipCarrierShippingRequest</c> table records.
    /// </summary>
    /// <returns>
    ///     A query object that retrieves <c>ShipCarrierShippingRequest</c> table records.
    /// </returns>
    protected Query buildShippingChargesErrorQuery()
    {
        Query query = new Query();

        QueryBuildDataSource qbdsShipCarrierShippingRequest = query.addDataSource(tableNum(ShipCarrierShippingRequest));
        qbdsShipCarrierShippingRequest.firstOnly(true);
        qbdsShipCarrierShippingRequest.update(true);
        qbdsShipCarrierShippingRequest.addRange(fieldNum(ShipCarrierShippingRequest, SalesId)).value(queryValue(salesParmTable.SalesId));
        
        if (this.parmShipmentId())
        {
            qbdsShipCarrierShippingRequest.addRange(fieldNum(ShipCarrierShippingRequest, WMSShipmentId)).value(queryValue(this.parmShipmentId()));
        }
        
        QueryBuildDataSource qbdsShipCarrierStaging = qbdsShipCarrierShippingRequest.addDataSource(tableNum(ShipCarrierStaging));
        qbdsShipCarrierStaging.joinMode(JoinMode::NoExistsJoin);
        qbdsShipCarrierStaging.addLink(fieldNum(ShipCarrierShippingRequest, SalesId), fieldNum(ShipCarrierStaging, SalesId));
        qbdsShipCarrierStaging.addLink(fieldNum(ShipCarrierShippingRequest, PackingSlipId), fieldNum(ShipCarrierStaging, PackingSlipId));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingSales</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the <c>LedgerPostingType</c> value that is used to post an invoice line.
    /// </summary>
    /// <returns>
    ///     A <c>LedgerPostingType</c> value.
    /// </returns>
    protected LedgerPostingType postingSales()
    {
        LedgerPostingType postingType;

        if (EXILFeatures_IT::isFeatureEnabled(EXILFeature::Exil2131))
        {
            postingType = salesLine.postingSales_IT(this.creditNote());
        }
        else
        {
            postingType = salesLine.postingSales();
        }

        return postingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInit_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Populates attributes <c>dlvTransitInventController_BR</c> and <c>journalLines_BR</c>
    /// </summary>
    public void postInit_BR()
    {
        journalLines_BR = new RecordSortedList(tableNum(CustInvoiceTrans));
        journalLines_BR.sortOrder(fieldNum(CustInvoiceTrans, RecId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInitTransactionTxt_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets the name placeholder in the transaction text.
    /// </summary>
    /// <param name="_transactionTxt">
    ///     The ledger transaction text <c>TransactionTxt</c> record.
    /// </param>
    /// <returns>
    ///     The ledger transaction text <c>TransactionTxt</c> record.
    /// </returns>
    protected TransactionTxt postInitTransactionTxt_BR(TransactionTxt _transactionTxt)
    {
        _transactionTxt.setCustVendName(custInvoiceJour.custTable_InvoiceAccount().name());

        return _transactionTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSkipPostInventory</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Can bypass posting of inventory.
    /// </summary>
    /// <returns>
    ///     true if inventory posting should be skipped; otherwise, false.
    /// </returns>
    protected boolean canSkipPostInventory()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInventory</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Posts to inventory.
    /// </summary>
    protected void postInventory()
    {
        if (this.canSkipPostInventory())
        {
            return;
        }

        LedgerVoucherObject ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject(voucher);

        if (InventoryReportingCurrencyTriangulationFeature::instance().isEnabled())
        {
            ledgerVoucherObject.parmTransactionCurrencyCode(salesParmTable.CurrencyCode);

            if (salesTable.FixedExchRate)
            {
                ledgerVoucherObject.parmFixedRateCurrencyExchangeHelper(InventoryReportingCurrencyTriangulationHelper::createFixedRateCurrencyExchangeHelper(ledgerVoucher,  salesTable.FixedExchRate, salesTable.ReportingCurrencyFixedExchRate));
            }
        }

        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

        this.createScrapOnInventory();
        if (countryRegion_RU && salesLine.AssetId_RU)
        {
            InventMov_AssetSale_ru assetInvent = new InventMov_AssetSale_ru(salesLine);
            if (assetInvent.canDisposal())
            {
                InventUpd_Estimated estimated = InventUpd_Estimated::newInventMovement(assetInvent);
                estimated.updateNow();

                InventUpd_Financial inventUpd_Financial = InventUpd_Financial::newPostAsset_RU(assetInvent, ledgerVoucher);
                inventUpd_Financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
                inventUpd_Financial.updateNow();
            }
        }

        inventMovement = InventMovement::construct(salesLine);

        if (countryRegion_RU)
        {
            CustInvoiceTrans_RU custInvoiceTrans_RU = custInvoiceTrans.custInvoiceTrans_RU();

            inventMovement.parmStorno_RU(this.isLineStorno_RU() && this.parmStorno());
            inventMovement.parmGoodsInRoute_RU(salesParmTable.InvoicePostingType_RU == SalesInvoicePostingType_RU::GoodsInRoute);
            inventMovement.parmInventTransIdTransit_RU(custInvoiceTrans_RU.InventTransIdTransit_RU);
            inventMovement.parmInventTransIdDelivery_RU(custInvoiceTrans_RU.InventTransIdDelivery_RU);
            inventMovement.parmStornoPhysical_RU(salesParmTable.salesParmUpdate().StornoPhysical_RU);
        }

        if (this.mustUpdateInventory(inventMovement))
        {
            this.updateInventory(inventMovement);
        }

        if (salesLine.returnItem())
        {
            salesLine.returnLineUpdate(this.documentStatus());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateInventory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the inventory ledger must be updated.
    /// </summary>
    /// <param name="_inventMovement" >An <c>InventMovement</c> object.</param>
    /// <returns>true if the inventory ledger must be updated; otherwise, false.</returns>
    [SuppressBPWarning('BPParameterNotUsed', 'The parameter is not used but it is mandate by the API it is extending, implementing or mocking.')]
    protected boolean mustUpdateInventory(InventMovement _inventMovement)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postJournalPost</Name>
				<Source><![CDATA[
    public void postJournalPost()
    {
        super();

        if (this.parmPostingInBatch())
        {
            // Only create payments here if posting in batch. If not in a batch, payments are created in SalesFormletter_Invoice.createPayment() method
            // This is done so that non-batch invoices can support the payment method's export file format.
            this.createPayment();
        }

        // Post Intercompany Gift Card
        this.postCrossCompanyGiftcard();

        if (#PdsRebateEnabled)
        {
            if (!this.isProforma() && custInvoiceJour && PdsRebateParameters::find().PdsRebateAtInvoicing)
            {
                PdsRebateFindAndCreate::newFromCustInvoiceTrans(custInvoiceJour, custInvoiceTrans).run();
            }
        }

        // Royalties are set up to calculate at invoicing. Evaluate and calculate here.
        if (!this.isProforma() && custInvoiceJour && isConfigurationkeyEnabled(configurationKeyNum(MCRRoyalty)))
        {
            MCRRoyaltyVendTableFindAndCreate::newFromCustInvoiceTrans(custInvoiceJour, custInvoiceTrans).run();
        }

        if (formletterJournal.TableId == tableNum(CustInvoiceJour)
            && isConfigurationkeyEnabled(configurationKeyNum(Retail)))
        {
            CustInvoiceJour custInvoiceJourTemp = formletterJournal;
            CustInvoiceTrans custInvoiceTransTemp;

            // Instead of taking just the single SalesId from 'CustInvoiceJour', we need to take into account
            // the scenario of collective invoicing, which is an invoice containing multiple sales orders.
            // In the 'CustInvoiceTrans' table, using the InvoiceId from 'CustInvoiceJour', you can look at
            // all the Sales IDs associated with that invoice by looking at the OriginalSalesId column.
            // Note: The CustInvoiceTrans table contains one row for each sales line being invoiced. We need
            // to only get distinct OrigSalesId values to ensure loyalty points are posted only once for each sales order.
            while select OrigSalesId from custInvoiceTransTemp
                group by OrigSalesId
                where custInvoiceTransTemp.InvoiceId == custInvoiceJourTemp.InvoiceId
                    && custInvoiceTransTemp.OrigSalesId != ''
            {
                RetailLoyaltyManager::PostCardTransFromSalesTable(custInvoiceTransTemp.OrigSalesId);
            }
        }

        if (formletterJournal.TableId == tableNum(CustInvoiceJour))
        {
            WarrantyPolicyFacade::updatePolicyAfterInvoicing(formletterJournal);
        }

        this.deleteFullyInvoiced();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Posts one journal line.
    /// </summary>
    protected void postLine()
    {
        super();

        if (BrazilParameters::isEnabled())
        {
            this.postPostLine_BR();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSkipPostLineDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Can bypass posting of line discount.
    /// </summary>
    /// <returns>
    ///     true if posting line discount should be skipped; otherwise, false.
    /// </returns>
    protected boolean canSkipPostLineDiscount()
    {
        boolean ret = false;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            InventProfileType_RU inventProfileType = salesLine.inventProfileType_RU();

            if (salesParmTable.InvoicePostingType_RU == SalesInvoicePostingType_RU::GoodsInRoute ||
                inventProfileType == InventProfileType_RU::CommissionPrincipalAgent ||
                inventProfileType == InventProfileType_RU::Bailee)
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postLineDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Posts the line discount.
    /// </summary>
    protected void postLineDiscount()
    {
        if (this.canSkipPostLineDiscount())
        {
            return;
        }

        super();
        this.postRetailPeriodicDiscounts();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postMarkupOnJour</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Posts the markup for the invoice journal header for a source record.
    /// </summary>
    /// <param name="_source">
    ///     The source record for which to post markup on the invoice journal header.
    /// </param>
    protected void postMarkupOnJour(Common _source)
    {
        if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            totalOrderBalanceAbsoluteValue = salesTotals.mcrTotalOrderBalanceAbsoluteValue(_source.RecId);
        }

        super(_source);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postMarkupOnTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Posts markup for the journal lines.
    /// </summary>
    protected void postMarkupOnTrans()
    {
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            postNegativeMarkupsAsCorrection_RU = this.usePerLineCorrection_RU();
        }

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postMarkupTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Posts markup for the journal header.
    /// </summary>
    protected void postMarkupTable()
    {
        super();

        if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            if (this.parmProforma())
            {
                this.mcrWriteProformaMarkup();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postPostCustVendPackage</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates and creates the package posting for an invoice
    /// </summary>
    /// <remarks>
    ///     This method is the post event handler for the <c>postCustVend</c> method.
    /// </remarks>
    protected void postPostCustVendPackage()
    {
        if (this.isProforma() || CustTable::find(custInvoiceJour.InvoiceAccount).PackageDepositExcempt_PL)
        {
            return;
        }

        PlSalesDeposit_Invoice::updatePackageTrans(custInvoiceJour);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postPostLine_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Adds the line to the inventory journal lines.
    /// </summary>
    protected void postPostLine_BR()
    {
        CustLedgerAccounts::summaryLedgerDimension(custInvoiceTrans.invoiceAccount(), custInvoiceJour.PostingProfile);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postQualityOrderTaxes_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Posts the quality order taxes.
    /// </summary>
    /// <param name="_ledgerVoucher">
    ///     The ledger voucher.
    /// </param>
    /// <param name="_transactionTxt">
    ///     The transaction txt.
    /// </param>
    public void postQualityOrderTaxes_IN(LedgerVoucher _ledgerVoucher, TransactionTxt _transactionTxt)
    {
        TaxTrans taxTrans;

        InventQualityOrderTable inventQualityOrderTable = InventQualityOrderTable::findSalesPurchRefTransId_IN(salesLine.InventTransId, InventTestReferenceType::Sales);

        select firstonly RecId from taxTrans
            where taxTrans.SourceTableId == tableNum(InventQualityOrderTable)
                && taxTrans.SourceRecId == inventQualityOrderTable.RecId;

        if (taxTrans.RecId != 0)
        {
            return;
        }

        LedgerVoucherGroup ledgerVoucherGroup = LedgerVoucherGroup::construct();
        NumberSequenceReference numberSeqRef = CustParameters::numRefCustInvoiceVoucher();
        NumberSeq numberSequence = NumberSeq::newGetVoucher(numberSeqRef);

        LedgerVoucher taxTransLedgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Detail,
                                                                           SysModule::Cust,
                                                                           NumberSequenceTable::find(numberSeqRef.NumberSequenceId).NumberSequence);

        taxTransLedgerVoucher.parmCompanyId(curext());

        ledgerVoucherGroup.addLedgerVoucher(taxTransLedgerVoucher);
        LedgerVoucherObject ledgerVoucherObject = taxTransLedgerVoucher.findLedgerVoucherObject();

        if (ledgerVoucherObject == null || ledgerVoucherObject.transElements() != 0)
        {
            taxTransLedgerVoucher.addVoucher(LedgerVoucherObject::newVoucher(numberSequence.voucher(), this.updateDate()));
        }

        voucher = taxTransLedgerVoucher.lastVoucher();
        taxTransLedgerVoucher.findLedgerVoucherObject(voucher).lastTransTxt(_transactionTxt.txt());
        TaxSalesQualityOrder_IN qualityOrderTax = TaxSalesQualityOrder_IN::construct(inventQualityOrderTable);
        qualityOrderTax.setRelatedVoucherObject(taxTransLedgerVoucher);
        qualityOrderTax.inventLossAccount(salesLine.ItemId);

        qualityOrderTax.calc();
        qualityOrderTax.setVoucherId(voucher);
        qualityOrderTax.saveAndPost(LedgerPostingController::newForLedgerPostingJournal(taxTransLedgerVoucher), inventQualityOrderTable);
        ledgerVoucherGroup.end();
        LedgerVoucher settlementLedgerVoucher = ledgerVoucherGroup.findLedgerVoucher(curext(), taxTransLedgerVoucher.parmVoucherSeriesCode());

        if (settlementLedgerVoucher != null)
        {
            settlementLedgerVoucher.createVoucherLinks(_ledgerVoucher.lastVoucher(), _ledgerVoucher.lastTransDate());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>recalcTotals</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Recalculates the totals.
    /// </summary>
    /// <remarks>
    ///     If he quantity is reduced by inventory, use this method.
    /// </remarks>
    protected void recalcTotals()
    {
        salesTotals = SalesTotals::construct(salesParmTable, this.parmSpecQty(), this.parmSumBy(), custInvoiceJour.ParmId, this.parmSumOrderId(), this.documentStatus());
        salesTotals.parmSalesInvoicePostingType_RU(salesParmTable.InvoicePostingType_RU);
        salesTotals.parmGoodsInRouteId_RU(salesParmTable.GoodsInRouteId_RU);
        salesTotals.prepareTotalAmountCalculation();
        salesTotals.prepareQuantitiesCalculation();
        this.tax(salesTotals.tax());
    }

]]></Source>
			</Method>
			<Method>
				<Name>retailBlockReturnedItems</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Reserves items that were returned to location with <c>RetailBlockReturnedItems</c> flag
    /// </summary>
    protected void retailBlockReturnedItems()
    {
        InventBlocking inventBlocking;

        RetailTransactionSalesTrans retailTransactionSalesTrans;
        RetailTransactionInfocodeTrans retailTransactionInfocodeTrans;
        Set salesLinesAlreadyProcessed = new Set(Types::Int64);

        if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
        {
            ListEnumerator listEnumerator = journalLines.getEnumerator();

            while (listEnumerator.moveNext())
            {
                salesLine localSalesLine = this.getSalesLine(listEnumerator);

                if (!localSalesLine || !localSalesLine.RetailBlockQty || salesLinesAlreadyProcessed.in(localSalesLine.RecId))
                {
                    continue;
                }

                InventTable localInventTable = InventTable::find(localSalesLine.ItemId);
                if (localInventTable.ItemType == ItemType::Service)
                {
                    // For Service type item, due to code InventMov_BlockingIssue::mustBeAutoReserved (InventItemType_Service::canBeAutoReserved), it can't be auto reserved,
                    // which evetually triggered error message "Sales order:###### You cannot block X items. Only 0.00 items are available on the inventory" if we do not skip the block inventory logic below.
                    continue;
                }

                if (!localInventTable.isStocked())
                {
                    // Non-stocked item is not tracked in inventory, thus we should also skip the block inventory logic below. Othwewise it will trigger the below error:
                    // @SYS190622 / "The selected item cannot be used in this context if it is associated with an Item model group where Always expensed is selected."
                    continue;
                }

                salesLinesAlreadyProcessed.add(localSalesLine.RecId);

                InventDimParm inventDimParm;

                InventDim inventDim = InventDim::find(localSalesLine.InventDimId);
                inventDimParm.initFromInventDim(inventDim);
                InventOnhand inventOnHand = InventOnhand::newParameters(localSalesLine.ItemId, inventDim, inventDimParm);

                if (InventLocation::find(inventDim.InventLocationId).RetailInventNegPhysical && inventOnHand.availPhysical() < 0)
                {
                    eventSource.EventWriteNoPhysicalInventoryWarning(funcName(), localSalesLine.RecId, inventDim.inventDimId, localSalesLine.ItemId);
                }
                else
                {
                    select firstOnly RecId, InfoCodeId, SubInfoCodeId from retailTransactionInfocodeTrans
                    order by LineNum desc
                    exists join retailTransactionSalesTrans
                        where retailTransactionSalesTrans.store == retailTransactionInfocodeTrans.store
                           && retailTransactionSalesTrans.terminalId == retailTransactionInfocodeTrans.terminal
                           && retailTransactionSalesTrans.transactionId == retailTransactionInfocodeTrans.transactionId
                           && retailTransactionSalesTrans.lineNum == retailTransactionInfocodeTrans.parentLineNum
                           && retailTransactionSalesTrans.Channel == retailTransactionInfocodeTrans.Channel
                           && retailTransactionSalesTrans.inventTransId == localSalesLine.InventTransId
                           && retailTransactionSalesTrans.inventDimId == localSalesLine.InventDimId;

                    ttsBegin;

                    inventBlocking.clear();

                    inventBlocking.BlockingType = InventBlockingType::ReturnLocation;
                    inventBlocking.ExpectReceipt = NoYes::No;
                    inventBlocking.Qty = localSalesLine.RetailBlockQty;
                    inventBlocking.ItemId = localSalesLine.Itemid;
                    inventBlocking.InventDimId = localSalesLine.InventDimId;
                    inventBlocking.ExpectedReceiptDate = dateMax();

                    if (retailTransactionInfocodeTrans)
                    {
                        inventBlocking.Description = strFmt("@REX4520660", retailTransactionInfocodeTrans.infocodeId, retailTransactionInfocodeTrans.subInfocodeId); //Info code: %1, sub code: %2
                    }

                    inventBlocking.write();

                    ttsCommit;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>requireGLPostingPriorToSettlement</Name>
				<Source><![CDATA[
    protected boolean requireGLPostingPriorToSettlement()
    {
        // salesTable.SettleVoucher - comes from the Sales order header field SettlementType and is set to none (derived from the AR parameter) and specTrans records exist.
        if (requireGLPostingPriorToSettlement == UnknownNoYes::Unknown)
        {
            if (salesTable.SettleVoucher &&
                SpecTrans::getSpecTransCount(salesTable.company(), salesTable.TableId, salesTable.RecId))
            {
                requireGLPostingPriorToSettlement = UnknownNoYes::Yes;
            }
            else
            {
                requireGLPostingPriorToSettlement = UnknownNoYes::No;
            }
        }
        return (requireGLPostingPriorToSettlement == UnknownNoYes::Yes);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesTableAuthorizationError</Name>
				<Source><![CDATA[
    private void updateSalesTableAuthorizationError(SalesId _salesId, NoYes _hasError)
    {
        SalesTable salesTableLocal = SalesTable::find(_salesId, true);

        if (salesTableLocal && creditCardSalesTable.CreditCardCustRefId)
        {
            salesTableLocal.CreditCardAuthorizationError = _hasError;
            salesTableLocal.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>capturePaymentJournal</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    protected final void capturePaymentJournal()
    {
        if (this.canCaptureCreditCard())
        {
            // Create the payment journal and settle this invoice with credit card payment.
            CreditCardPaymentJournal creditCardPaymentJournal = new CreditCardPaymentJournal(creditCardSalesTable, custInvoiceJour);
            creditCardPaymentJournal.run();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>capturePaymentFailure</Name>
				<Source><![CDATA[
    private void capturePaymentFailure()
    {
        ttsbegin;
        CreditCardAuthTrans creditCardAuthTrans = CreditCardAuthTrans::findLatest(creditCardSalesTable.SalesId, true);
        creditCardAuthTrans.SalesInvoiceId = ""; // no posting so invoice id does not apply
        creditCardAuthTrans.update();

        // Put the Sales Order into the "Credit card issues list"
        this.updateSalesTableAuthorizationError(creditCardSalesTable.SalesId, NoYes::Yes);
        ttscommit;

        throw error(strFmt("@SYS116944", creditCardSalesTable.SalesId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Posts a journal.
    /// </summary>
    public void run()
    {
        using (var activityContext = instrumentationLogger.salesFormLetterActivities().invoiceSingleOrder())
        {
            if (SalesInvoiceAddLoggingFlight::instance().isEnabled())
            {
                SalesTableRefRecId salesTableRefRecId = this.custInvoiceJour.salesTable().RecId;
                instrumentationLogger.logInformation("Sales Order with RecId " + any2Str(salesTableRefRecId) + " posting started");
                activityContext.addCustomProperty('salesOrderRecId', any2Str(salesTableRefRecId));
            }

            if (CreditCardPaymentBreakDownProcessFeatureExposureHelper::isEnabled())
            {
                super();
                if (!this.isProforma())
                {
                    // delivery to processing queue
                    if (this.canCaptureCreditCard() && creditCardSalesTable.isCreditCardPaymentType() && !CreditCardBreakDownRunnerHelper::isCustInvoiceFullySettled(custInvoiceJour))
                    {
                        // Register the breakdown task. Will roll back if register task is failed.
                        info("@CashManagement:CreditCardPaymentBreakDownInvoicePostSuccess");
                        CreditCardPaymentBreakDownTable creditCardPaymentBreakDownTable = this.registerCreditCardBreakDownTask();
                        this.runCreditCardBreakDownTask(creditCardPaymentBreakDownTable);
                    }
                }
            }
            else
            {
                if (!this.isProforma())
                {
                    ttsbegin;

                    this.updateSalesTableAuthorizationError(salesTable.SalesId, NoYes::No);
                }

                super();

                if (!this.isProforma())
                {
                    boolean isRefund = custInvoiceJour.InvoiceAmount < 0;

                    // When a previous invoicing request fails after capturing a payment, its invoiceid gets stamped into
                    // the CreditCardAuthTrans capture record, butsince the invoice was aborted, this invoiceid is orphan.
                    CreditCardAuthTrans orphanCaptureRecord = CreditCardAuthTrans::findOrphanOrDuplicateCreditCardAuthTransCaptureRecord(salesTable.SalesId, custInvoiceJour);

                    // Recover original orphan capture, Stamping the current invoiceId on it\
                    if (CreditCardAuthTrans::isPaymentDuplicationProtectionFeatureEnabled())
                    {
                        if(orphanCaptureRecord)
                        {
                            ttsbegin;
                            orphanCaptureRecord.selectForUpdate();
                            orphanCaptureRecord.SalesInvoiceId = custInvoiceJour.InvoiceId;
                            orphanCaptureRecord.update();
                            ttscommit;

                            eventSource.EventWritePaymentDuplicationDetectedWarning(
                            funcName(),
                            salesTable.retailSalesTable().RetailChannel,
                            salesTable.SalesId,
                            orphanCaptureRecord.SalesInvoiceId,
                            0);
                        }
                    }

                    // Only capture credit cardin case there are any remaining unsettled amount for the invoice
                    Amount creditCardCaptureAmount = custInvoiceJour.getCreditCardCaptureAmount();

                    if (creditCardCaptureAmount != 0)
                    {
                        // Only capture when there is no orphan capture record from previous failed invoicing process.
                        if (!orphanCaptureRecord)
                        {
                            // In case there are still remaining balances for the invoice, capture the remaining amount
                            if (this.creditCardDoCaptureOrPostAuthorize(custInvoiceJour.InvoiceId, isRefund, custInvoiceJour))
                            {
                                ttscommit;

                                // Reread the buffer to get the data changed during the creditCardDoCaptureOrPostAuthorize().
                                creditCardSalesTable.reread();

                                this.capturePaymentJournal();
                            }
                            else
                            {
                                // Credit card capture failed. Abort to not post the invoice.
                                ttsabort;

                                this.capturePaymentFailure();
                            }
                        }
                        else
                        {
                            ttscommit;

                            // Reread the buffer to get the data changed during the creditCardDoCaptureOrPostAuthorize().
                            creditCardSalesTable.reread();

                            this.capturePaymentJournal();

                            eventSource.EventWritePaymentDuplicationFixedWarning(
                            funcName(),
                            salesTable.retailSalesTable().RetailChannel,
                            salesTable.SalesId,
                            orphanCaptureRecord.SalesInvoiceId,
                            0);
                        }
                    }
                    else
                    {
                        // In case there are no remaining credit card payments to be captured, commit the transaction
                        ttscommit;
                    }

                    this.settleRetailSalesInvoice();

                    this.preauthorizeRemainingAmount(isRefund);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postSingleLine</Name>
				<Source><![CDATA[
    protected void postSingleLine(boolean _countryRegion_RU,
                                  boolean _hasQualityOrder,
                                  boolean _isExciseEnableIN,
                                  boolean _isVATEnableIN,
                                  boolean _isCustomsEnableIN,
                                  boolean _isConfigurationkeyRetailEnabled)
    {
        RefRecId salesLineRecId = this.salesLine.RecId;        
        using (var activityContext = instrumentationLogger.salesFormLetterActivities().invoiceSingleLine())
        {
            if (SalesInvoiceAddLoggingFlight::instance().isEnabled())
            {
                SalesTableRefRecId salesTableRefRecId = this.custInvoiceJour.salesTable().RecId;
                activityContext.addCustomProperty('salesLineRecId', any2Str(salesLineRecId));
                activityContext.addCustomProperty('salesOrderRecId', any2Str(salesTableRefRecId));
            }

            super(_countryRegion_RU,
                    _hasQualityOrder,
                    _isExciseEnableIN,
                    _isVATEnableIN,
                    _isCustomsEnableIN,
                    _isConfigurationkeyRetailEnabled);
            
        }

        // After posting, tax adjustments get removed when all quantity of sales line invoiced.
        if (custParameters.EnableSingleLineTaxAdjustment
            || TaxIntegrationAdjustment::isEnabledForTransaction(this.salesLine.TableId, this.salesLine.RecId))
        {
            this.removeTaxWorkRegulationWhenAllQuantityInvoiced(salesLineRecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerCreditCardBreakDownTask</Name>
				<Source><![CDATA[
    private CreditCardPaymentBreakDownTable registerCreditCardBreakDownTask()
    {
        CreditCardBreakDownInvoiceToPaymentRegister creditCardBreakDownInvoiceToPaymentRegister;
        CreditCardSalesOrderType creditCardSalesOrderType = CreditCardBreakDownRunnerHelper::getSalesOrderType(salesTable);
        if (custInvoiceJour.InvoiceAmount < 0)
        {
            creditCardBreakDownInvoiceToPaymentRegister = CreditCardBreakDownInvoiceToPaymentRegister::construct(salesTable, custInvoiceJour, mcrCustPaymTable, creditCardSalesOrderType, CreditCardPaymentOperation::RefundOperation);
        }
        else
        {
            creditCardBreakDownInvoiceToPaymentRegister = CreditCardBreakDownInvoiceToPaymentRegister::construct(salesTable, custInvoiceJour, mcrCustPaymTable, creditCardSalesOrderType, CreditCardPaymentOperation::CaptureOperation);
        }
        return creditCardBreakDownInvoiceToPaymentRegister.registerTask();
    }

]]></Source>
			</Method>
			<Method>
				<Name>runCreditCardBreakDownTask</Name>
				<Source><![CDATA[
    private void runCreditCardBreakDownTask(CreditCardPaymentBreakDownTable _creditCardPaymentBreakDownTable)
    {
        Microsoft.Dynamics.Ax.Xpp.UpdateConflictException updateConflictException;
        Microsoft.Dynamics.Ax.Xpp.DeadlockException deadlockException;
        Microsoft.Dynamics.Ax.Xpp.ErrorException errorException;
        creditCardPaymentBreakDownLogger = this.getOrCreateCreditCardPaymentBreakDownLogger();
        using (var runActivityContext = creditCardPaymentBreakDownLogger.activityContextWithCustomProperties(CreditCardPaymentBreakDownInstrumentationConstants::CreditCardPaymentBreakDownInvoiceToPaymentProcess))
        {
            try
            {
                CreditCardBreakDownInvoiceToPaymentRunner runner = CreditCardBreakDownInvoiceToPaymentRunner::construct(_creditCardPaymentBreakDownTable.RecId);
                CreditCardPaymentExecutionId creditCardPaymentExecutionId = runner.startWithPreCheck();
                if (!creditCardPaymentExecutionId)
                {
                    error("@CashManagement:CreditCardPaymentBreakDownSystemError");
                }
                else
                {
                    _creditCardPaymentBreakDownTable.reread();
                    Args args = new Args();
                    args.record(_creditCardPaymentBreakDownTable);
                    info("@CashManagement:CreditCardPaymentBreakDownStartExecution");
                    creditCardPaymentBreakDownLogger.logInformation(strFmt('Start execution for break down table record %1', any2Str(_creditCardPaymentBreakDownTable.RecId)));
                    CreditCardPaymentBreakDownController::startProcess(args);
                }
            }
            catch (updateConflictException)
            {
                creditCardPaymentBreakDownLogger.logException(updateConflictException,
                    strFmt('Update conflict exception during processing break down table record %1',
                    any2Str(_creditCardPaymentBreakDownTable.RecId)));
                error("@CashManagement:CreditCardPaymentBreakDownSystemError");
            }
            catch (deadlockException)
            {
                creditCardPaymentBreakDownLogger.logException(deadlockException,
                    strFmt('Deadlock exception during processing break down table record %1',
                    any2Str(_creditCardPaymentBreakDownTable.RecId)));
                error("@CashManagement:CreditCardPaymentBreakDownSystemError");
            }
            catch (errorException)
            {
                creditCardPaymentBreakDownLogger.logException(updateConflictException,
                    strFmt('System error exception during processing break down table record %1',
                    any2Str(_creditCardPaymentBreakDownTable.RecId)));
                error("@CashManagement:CreditCardPaymentBreakDownSystemError");
            }
            catch
            {
                creditCardPaymentBreakDownLogger.logException(updateConflictException,
                    strFmt('General error exception during processing break down table record %1',
                    any2Str(_creditCardPaymentBreakDownTable.RecId)));
                error("@CashManagement:CreditCardPaymentBreakDownSystemError");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrCreateCreditCardPaymentBreakDownLogger</Name>
				<Source><![CDATA[
    private CreditCardPaymentBreakDownLogger getOrCreateCreditCardPaymentBreakDownLogger()
    {
        if (!creditCardPaymentBreakDownLogger)
        {
            creditCardPaymentBreakDownLogger = CreditCardPaymentBreakDownLogger::createLogger();
        }
        return creditCardPaymentBreakDownLogger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeTaxWorkRegulationWhenAllQuantityInvoiced</Name>
				<Source><![CDATA[
    private void removeTaxWorkRegulationWhenAllQuantityInvoiced(RefRecId _salesLineRecId)
    {
        SalesLine salesLine_taxRegulation = SalesLine::findRecId(_salesLineRecId);

        SalesQty salesQty = SalesQuantity::construct(DocumentStatus::Invoice).calcSalesQty(salesLine_taxRegulation);
        if (salesQty == 0)
        {
            TaxWorkRegulation::clearRegulation(salesLine_taxRegulation.TableId, salesLine_taxRegulation.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleRetailSalesInvoice</Name>
				<Source><![CDATA[
    private void settleRetailSalesInvoice()
    {
        if (isConfigurationkeyEnabled(configurationKeyNum(Retail)) &&
            salesTable.isRetailSale() &&
            !salesTable.isRetailCashAndCarrySales()) // Do not auto settle cash and carry transactions.
        {

            // Prepare Retail Settlements for the next invoicing process
            RetailTransactionServiceOrders::prepareRetailSettlements(salesTable, maxInt());

            // Call Center Order / Retail Sales On-Account payments
            // After invoice posting, payments should be already settled against the invoice.
            // If there is still a specification containing the Invoice in SpecTrans, and
            // "The invoice open balance is less than the On-account tender authorized limit.", the specification for the invoice is deleted.
            // Note: This is required for the process of manually remark the invoice for settlement in the payment journals
            // when a payment is received to cover the customer on-account balance.
            RetailTransactionServiceOrders::unlockOnAccountPayments(salesTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>preauthorizeRemainingAmount</Name>
				<Source><![CDATA[
    private void preauthorizeRemainingAmount(boolean _isRefund)
    {
        // Authorize any sales order remaining balance for orders decorated with credit card token
        if (!_isRefund &&
            creditCardSalesTable.canInvoiceOrderFromCurrentSalesStatus() &&
            creditCardSalesTable.CreditCardCustRefId &&
            creditCardSalesTable.isCreditCardPaymentType())
        {
            // The processed sales order has not been marked as invoiced.
            // Preauthorize the remaining amount.
            this.creditCardDoPreAuthorize();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesInvoicePostNotStocked</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates an instance of the <c>SalesInvoicePostNotStocked</c> class.
    /// </summary>
    /// <returns>
    ///     A new instance of the <c>SalesInvoicePostNotStocked</c> class.
    /// </returns>
    protected SalesInvoicePostNotStocked salesInvoicePostNotStocked()
    {
        return SalesInvoicePostNotStocked::construct(custInvoiceTrans,
                                                        salesLine,
                                                        salesParmLine,
                                                        recordInsertListCustInvoicePackingSlipMatch);
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectFormletterJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Selects a journal line.
    /// </summary>
    protected void selectFormletterJournalTrans()
    {
        select forupdate formletterJournalTrans
            where formletterJournalTrans.JournalId == formletterJournal.JournalId
               && formletterJournalTrans.InternalJournalId == formletterJournal.InternalJournalId
               && formletterJournalTrans.OrderId == formletterJournal.OrderId
               && formletterJournalTrans.TransDate == formletterJournal.TransDate
               && formletterJournalTrans.NumberSequenceGroup == formletterJournal.NumberSequenceGroup
            join forupdate salesLine
                where salesLine.InventTransId == formletterJournalTrans.InventTransId
            outer join salesParmLine
                where salesParmLine.ParmId == custInvoiceJour.ParmId
                   && salesParmLine.TableRefId == salesParmTable.TableRefId
                   && salesParmLine.SalesLineRecId == salesLine.RecId
            outer join inventTable
                where inventTable.ItemId == salesLine.ItemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRevenueAmount_BR</Name>
				<Source><![CDATA[
    protected AmountCur setRevenueAmount_BR(AmountCur _revenueAmount)
    {
        _revenueAmount += tax.taxInSalesRevenue_BR(salesLine.TableId, salesLine.RecId);

        if (salesTable.createCustTrans_BR() == false)
        {
            _revenueAmount = 0;
        }

        return _revenueAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCopyMultipleDocuRef</Name>
				<Source><![CDATA[
    protected boolean shouldCopyMultipleDocuRef()
    {
        return !ordersPosted.empty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldPostMarkupTable</Name>
				<Source><![CDATA[
    protected boolean shouldPostMarkupTable()
    {
        boolean mcrShouldPostMarkupTable = true;
        CustInvoiceTrans custInvoiceTransLocal;
        SalesParmLine salesParmLineLocal;
        MCRInventTable mcrInventTable;
        InventTable inventTableLocal;
        MCRSalesOrderType mcrSalesOrderType = salesTable.mcrEvalSalesOrderType();

        if (mcrSalesOrderType == MCRSalesOrderType::OrderAndInstallment)
        {
            MCRSalesOrderTotals mcrSalesOrderTotals = new mcrSalesOrderTotals(SalesTable);
            AmountCur totToBeInvoiced = mcrSalesOrderTotals.getRemainingOrder();
            AmountCur totBeingInvoiced = custInvoiceJour.InvoiceAmountMST;

            if (totToBeInvoiced != totBeingInvoiced)
            {
                SalesParmUpdate salesParmUpdateLocal = SalesParmUpdate::find(salesParmTable.ParmId);
                select firstOnly ItemId from custInvoiceTransLocal
                    join RecId from inventTableLocal
                        where inventTableLocal.ItemId == custInvoiceTransLocal.ItemId
                    join InstallmentEligible from mcrInventTable
                        where mcrInventTable.InventTable == inventTableLocal.RecId
                           && mcrInventTable.InstallmentEligible
                    exists join recId from salesParmLineLocal
                    where custInvoiceTransLocal.OrigSalesId == salesTable.SalesId
                        && salesParmLineLocal.InventTransId == custInvoiceTransLocal.InventTransId
                        && salesParmLineLocal.ParmId == salesParmUpdateLocal.ParmId;

                if (mcrInventTable.InstallmentEligible)
                {
                    mcrShouldPostMarkupTable = false;
                    this.postCustVend();
                }
            }
        }

        return mcrShouldPostMarkupTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceAmountMarkupOnJour</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates the miscellaneous charges amount for a <c>Common</c> record.
    /// </summary>
    /// <param name="_source">
    ///     The source record for which to calculate the miscellaneous charges amount.
    /// </param>
    /// <returns>
    ///     The calculated miscellaneous charges amount.
    /// </returns>
    /// <remarks>
    ///     This method is used to calculate miscellaneous charges on the header level.
    /// </remarks>
    protected AmountCur sourceAmountMarkupOnJour(Common _source)
    {
        return salesTotals.getMarkupTableSourceValue(_source);
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the source line record for the current journal line.
    /// </summary>
    /// <returns>
    ///     A source line record.
    /// </returns>
    protected Common sourceLine()
    {
        return salesLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceLineQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the <c>UnitQty</c> value for the source line that is being invoiced.
    /// </summary>
    /// <returns>
    ///     The <c>UnitQty</c> value for the source line that is being invoiced.
    /// </returns>
    protected UnitQty sourceLineQuantity()
    {
        return salesLine.SalesQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceLineSalesUnit</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the unit of measure for a source line.
    /// </summary>
    /// <returns>
    ///     The unit of measure for the source line.
    /// </returns>
    /// <remarks>
    ///     This method is used to post inventory.
    /// </remarks>
    protected SalesUnit sourceLineSalesUnit()
    {
        return salesLine.SalesUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceMarkupOnTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the source record to post miscellaneous charges on the line level.
    /// </summary>
    /// <returns>
    ///     A <c>Common</c> record .
    /// </returns>
    /// <remarks>
    ///     This method is used to post miscellaneous charges on the line level.
    /// </remarks>
    protected Common sourceMarkupOnTrans()
    {
        return salesLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the source header record for the journal header.
    /// </summary>
    /// <returns>
    ///     A source header record.
    /// </returns>
    protected Common sourceTable()
    {
        return salesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tableIdSourceMarkupJour</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the table ID for a table that is used to find miscellaneous charges on the header level.
    /// </summary>
    /// <returns>
    ///     The table ID.
    /// </returns>
    protected TableId tableIdSourceMarkupJour()
    {
        return tableNum(SalesTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpLineValue_RU</Name>
				<Source><![CDATA[
    protected Amount tmpLineValue_RU()
    {
        return this.tax().taxPrLine(tableNum(SalesLine), salesLine.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the total amount for a sales invoice that is being posted.
    /// </summary>
    /// <returns>
    ///     The total amount for the sales invoice.
    /// </returns>
    /// <remarks>
    ///     This method is used to determine whether the invoice is a credit note.
    /// </remarks>
    protected AmountCur totalAmount()
    {
        return salesTotals.totalAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalQty_RU</Name>
				<Source><![CDATA[
    protected SalesQty totalQty_RU()
    {
        return salesTotals.totalQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>tradeCalcTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets an instance of the <c>TradeCalcTax</c> object.
    /// </summary>
    /// <returns>
    ///     An instance of the <c>TradeCalcTax</c> object.
    /// </returns>
    protected Object tradeCalcTax()
    {
        SalesCalcTax ret = SalesCalcTax::construct(this.parmJournalTable());

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) && this.usePerLineCorrection_RU())
        {
            ret.parmPostNegativeLinesAsStorno_RU(true);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAdvanceInvoiceSettlement_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// For each advance invoice marked to settle with the current sales invoice, creates and posts
    /// a reversing advance invoice, and generates an advance invoice settlement record.
    /// </summary>
    protected void updateAdvanceInvoiceSettlement_W()
    {
        SalesFormLetterContract contract = this.parmChainFormletterContract();
        AdvanceInvoiceSettlement_SalesOrder_W advanceInvoiceSettlement = AdvanceInvoiceSettlement_W::newUnpack(tableNum(SalesTable), SysOperationHelper::base64Decode(contract.parmAdvanceInvoiceSettlementPacked()));

        if (!this.isProforma() && !this.isOnHold())
        {
            if (advanceInvoiceSettlement)
            {
                advanceInvoiceSettlement.reverseSettlement(custInvoiceJour);
                advanceInvoiceSettlement.settleNow(custInvoiceJour);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAsset_RU</Name>
				<Source><![CDATA[
    private void updateAsset_RU(TransactionTxt _transactionTxt)
    {
        RAssetStandards assetStandards;
        RAssetStandardId assetStandardDefault = RAssetParameters::standardIdDefault();
        RAssetTrans rAssetTrans;

        if (assetLedgerVoucherBase)
        {
            RAssetPost rAssetPost = RAssetPost::construct(custInvoiceTrans, assetLedgerVoucherBase, assetStandardDefault);
            rAssetPost.run();
            
            while select AssetStandardId from assetStandards
                where assetStandards.AssetId == salesLine.AssetId_RU &&
                    assetStandards.AssetStandardId != assetStandardDefault &&
                    assetStandards.Depreciation
            exists join rAssetTrans
                where rAssetTrans.AccountNum == assetStandards.AssetId &&
                      rAssetTrans.AssetStandardId == assetStandards.AssetStandardId &&
                      rAssetTrans.AssetTransType == RAssetTransType::Acquisition &&
                      !rAssetTrans.StornoRecId
            {
                RAssetOperationType rAssetOperationType = RAssetOperationType::construct(RAssetTransType::DisposalSale,
                                                                                         salesLine,
                                                                                         salesParmTable.Transdate,
                                                                                         assetStandards.AssetStandardId);
                if (!rAssetOperationType.check())
                {
                    throw error("@SYS25904");
                }

                RefRecId numberSequnceTableId = (select firstonly ledgerJournalName
                                                     where ledgerJournalName.JournalType == LedgerJournalType::Assets_RU).NumberSequenceTable;

                NumberSequenceCode assetNumberSeq = NumberSequenceTable::find(numberSequnceTableId).NumberSequence;

                Voucher assetVoucher = NumberSeq::newGetVoucherFromCode(assetNumberSeq, NumberSeqScopeFactory::createDefaultScope(), false).voucher();

                assetLedgerVoucherOthers = LedgerVoucher::newLedgerPost(DetailSummary::Summary, SysModule::FixedAssets_RU, assetNumberSeq);

                LedgerVoucherObject assetLedgerVoucherObjectOthers = LedgerVoucherObject::newVoucher(
                    assetVoucher,
                    salesParmTable.Transdate,
                    SysModule::FixedAssets_RU,
                    LedgerTransType::FixedAssets_RU,
                    NoYes::No,
                    RAssetStandardTable::find(assetStandards.AssetStandardId).CurrentOperationsTax);

                assetLedgerVoucherObjectOthers.parmDocument(salesParmTable.Transdate, custInvoiceJour.InvoiceId);
                assetLedgerVoucherObjectOthers.lastTransTxt(_transactionTxt.txt());
                assetLedgerVoucherOthers.addVoucher(assetLedgerVoucherObjectOthers);

                if (assetLedgerVoucherOthers)
                {
                    rAssetPost = RAssetPost::construct(custInvoiceTrans, assetLedgerVoucherOthers, assetStandards.AssetStandardId);
                    rAssetPost.run();
                }

                this.updateAssetLine_RU();
            }
            RAssetTable::updateCustInfo(salesLine.AssetId_RU, salesLine.CustAccount, salesLine.SalesId, custInvoiceJour.InvoiceId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAssetLine_RU</Name>
				<Source><![CDATA[
    private void updateAssetLine_RU()
    {
        if (assetLedgerVoucherBase)
        {
            assetLedgerVoucherBase = null;
        }

        if (assetLedgerVoucherOthers)
        {
            assetLedgerVoucherOthers.end();
            assetLedgerVoucherOthers = null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAssetReverse_RU</Name>
				<Source><![CDATA[
    private void updateAssetReverse_RU()
    {
        RAssetStandards rAssetStandards;

        while select AssetStandardId from rAssetStandards
            where rAssetStandards.AssetId == salesLine.AssetId_RU
                && rAssetStandards.Depreciation
        {
            RAssetTrans rAssetTrans = RAssetTrans::findLastType(salesLine.AssetId_RU,
                                                               rAssetStandards.AssetStandardId,
                                                               RAssetTransType::DisposalSale,
                                                               false,
                                                               maxDate(),
                                                               true);
            RAssetTransactionReversal reversal = RAssetTransactionReversal::construct(rAssetTrans);
            reversal.initValue(rAssetTrans);
            reversal.parmReversalDate(salesParmTable.Transdate);
            reversal.parmAssetTransReversedSet(rAssetTransReversedSet);
            reversal.runOperation();

            rAssetTransReversedSet.add([rAssetTrans.Voucher, rAssetTrans.DataAreaId, rAssetTrans.getAccountingDate()]);
        }
        RAssetTable::updateCustInfo(salesLine.AssetId_RU, '', '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBankLC</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates the Letter of Credit after the journal is posted.
    /// </summary>
    private void updateBankLC()
    {
        if (BankLCExportFeatureChecker::checkBankLCExportEnabled() && salesParmTable.BankLCExportLine != 0)
        {
            BankLCExportType bankLCExportType = BankLCExportType::constructBySalesId(salesParmTable.SalesId, true, true);
            bankLCExportType.updateInvoicePosted(salesParmTable.BankLCExportLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateEstimate</Name>
				<Source><![CDATA[
    protected void updateEstimate()
    {
        SetEnumerator se = ordersPosted.getEnumerator();

        while (se.moveNext())
        {
            SalesTable localSalesTable = SalesTable::find(se.current(),true);

            if (localSalesTable && localSalesTable.setEstimate())
            {
                localSalesTable.doUpdate();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJournalLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates the journal line.
    /// </summary>
    protected void updateJournalLine()
    {
        boolean taxParametersLoc = TaxParameters::checkTaxParameters_IN();

        if (taxParametersLoc && !TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            TmpTaxWorkTrans taxWorkTransLoc = this.tax().tmpTaxWorkTrans();
        }

        if (TaxWithholdParameters_IN::checkTaxParameters() && this.checkWithholdCalculate(salesTable))
        {
            custInvoiceTrans.TaxAmount = tax.totalTaxAmountSingleLine(salesLine.TableId,salesLine.RecId);
        }

        custInvoiceTrans.Remain = salesLine.RemainSalesFinancial;

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates the journal header.
    /// </summary>
    protected void updateJournalTable()
    {
        super();

        this.updateSalesShippingStat();
        this.insertCreditInvoicingJour(salesTable);

        if (CustParameters::find().EntryCertificateIssuingEnabled_W && salesParmTable.IssueOwnEntryCertificate_W && ! this.isProforma())
        {
            CustEntryCertificateJour_W::constructFromInvoice(custInvoiceJour);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesParmLineReducedQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the quantities in the <c>SalesParmLine</c> record if inventory have reduced delivered
    /// quantity to the available inventory.
    /// </summary>
    protected void updateSalesParmLineReducedQuantity()
    {
        if (salesParmLine.DeliverNow != updateNow || salesParmLine.InventNow != updateNowInvent)
        {
            SalesParmLine localParmLine;
            localParmLine = SalesParmLine::findRecId(salesParmLine.RecId, true);
            this.setRecalcTotals();
            info(strFmt("@SYS26397",updateNow));
            localParmLine.DeliverNow = updateNow;
            localParmLine.InventNow = updateNowInvent;
            localParmLine.PdsCWDeliverNow = cwUpdateNow;
            localParmLine.setLineAmount(salesLine);
            localParmLine.update();

            salesParmLine.data(localParmLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesShippingStat</Name>
				<Source><![CDATA[
    protected void updateSalesShippingStat()
    {
        #OCCRetryCount

        if (!SalesParameters::find().useShippingStatOnInvoice())
        {
            return;
        }

        try
        {
            SalesShippingStat salesShippingStat;

            ttsbegin;
            delete_from salesShippingStat
                where salesShippingStat.TableRefId == salesParmTable.TableRefId &&
                      salesShippingStat.ParmId == salesParmTable.ParmId &&
                      salesShippingStat.Quantity == 0;
        
            Microsoft.Dynamics.Ax.Xpp.PlatformExtensions.CommonExtensions::SetSqlUpdateIndexHint(salesShippingStat, indexStr(SalesShippingStat, ParmIdx));

            update_recordset salesShippingStat
                setting InvoiceId = custInvoiceJour.InvoiceId,
                        InvoiceDate = custInvoiceJour.InvoiceDate,
                        ParmId = ''
                where salesShippingStat.TableRefId == salesParmTable.TableRefId &&
                      salesShippingStat.ParmId == salesParmTable.ParmId;
            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::Deadlock;
            }
            else
            {
                retry;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSourceLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates the source line for the current journal line.
    /// </summary>
    protected void updateSourceLine()
    {
        SalesLineType salesLineType = salesLine.type();

        if (!salesLine.isStocked())
        {
            //For subscription lines, RemainSalesPhysical is reset to the line quantity if it would become zero; otherwise set to RemainAfter
            salesLine.RemainSalesPhysical =
                (salesLineType.mustInventBeExpectedAgain() && salesParmLine.RemainAfter == 0) ? salesLine.SalesQty : salesParmLine.RemainAfter;
        }

        salesLineType.updateSalesLine(inventMovement ? inventMovement.transIdSum() : null);

        if (salesTable.InterCompanyCompanyId)
        {
            salesLineType.interCompanyResetDeliverNow();
            if (!salesTable.InterCompanyDirectDeliveryOrig)
            {
                InterCompanyTransferInventDim::doTransfer(salesLine.DataAreaId,
                                                          salesLine.InventTransId,
                                                          salesTable.InterCompanyCompanyId,
                                                          salesLine.InterCompanyInventTransId,
                                                          salesTable.interCompanyEndpointActionPolicy().getOrCreateInterCompanyPolicyTransfer(InterCompanyFieldTransferType::External),
                                                          StatusIssue::Sold,
                                                          custInvoiceJour.InvoiceId);
            }
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoLT, #isoEE, #isoLV, #isoCZ, #isoPL, #isoHU]))
        {
            // Update sales status in case of Polish return
            if (salesLine.CreditNoteInternalRef_PL && salesLine.QtyOrdered == 0)
            {
                salesLine.SalesStatus = SalesStatus::Invoiced;
            }
        }

        if (salesTable.mcrIsCallCenter())
        {
            // Flag the sales stats as dirty.
            if (salesLine.SalesStatus == SalesStatus::Invoiced)
            {
                // SO line has been completed which will affect the current stored stats.
                MCRSalesStatsCustTable::salesStatsAffected(salesLine.CustAccount);
            }
        }

        if (FeatureStateProvider::isFeatureEnabled(SalesUpdateFromJournalPostFlight::instance()))
        {
            using (var salesLineSkipBusinessLogicContext = SalesLineSkipBusinessLogicContext::construct())
            {
                salesLineSkipBusinessLogicContext.parmSkipUpdate(true);
                salesLine.update();
            }
        }
        else
        {
            salesLine.doUpdate();
        }

        if (salesLine.LineDeliveryType == LineDeliveryType::DeliveryLine)
        {
            SalesLine orderLine = SalesDeliverySchedule::findOrderLineForDeliveryLine(salesLine.InventTransId, true);
            orderLine.setSalesStatus();
            orderLine.doUpdate();
        }

        if (salesTable.SalesId != custInvoiceTrans.OrigSalesId)
        {
            this.updateSpecTransForNewSalesId();
            this.updateSumSalesId();
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            // Record whether installment eligible
            if (salesLine.mcrSalesLine().InstallmentEligible
                && !setSalesTableIntallmentEligible.in(salesLine.SalesId))
            {
                setSalesTableIntallmentEligible.add(salesLine.SalesId);
            }
        }

        // Update the fulfillmentStatus of non-stocked item.
        if (isConfigurationkeyEnabled(configurationKeyNum(Retail)) && !salesLine.isStocked())
        {
            RetailTransactionServiceFulfillment::updateFulfillmentStatus(salesLine.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSourceTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates the source table for the journal header.
    /// </summary>
    protected void updateSourceTable()
    {
        SetEnumerator se = ordersPosted.getEnumerator();

        ttsbegin;
        while (se.moveNext())
        {
            salesTable = SalesTable::find(se.current(), true);
            if (salesTable)
            {
                salesTable.reread();
                salesTable.updateDocumentStatus(this.documentStatus());
                salesTable.updateBackStatus();
                salesTable.updateSalesType();
                this.createBackorderLines();
                if (salesTable.SalesId != salesParmTable.SalesId)
                {
                    // If this is not the primary sales order in the summary order,
                    // void the credit card preauthorization that may exist as it is no longer valid
                    salesTable.voidCreditCardPreauthorize(); //Invoice
                }
                sourceTableRecIdSet.add(salesTable.RecId);
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSpecTransForNewSalesId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates a <c>SpecTrans</c> record with the new <c>SalesTable</c> record ID.
    /// </summary>
    protected void updateSpecTransForNewSalesId()
    {
        SalesTable origSalesTable = custInvoiceTrans.salesLine().salesTable();
        SpecTrans updateSpecTrans;

        if (origSalesTable.RecId != 0 && this.checkSettlementVoucher(origSalesTable))
        {
            // SpecTrans records exist and point to the original sales table. Update SpecTrans records to reference
            // the new sales table for the Spec reference so they will be settled when this new sales invoice is posted.
            update_recordset updateSpecTrans
                setting SpecRecId = salesTable.RecId
                where updateSpecTrans.SpecCompany == origSalesTable.company() &&
                    updateSpecTrans.SpecTableId == tableNum(SalesTable) &&
                    updateSpecTrans.SpecRecId == origSalesTable.RecId;

            if (origOrdersWithSpecTrans != null)
            {
                origOrdersWithSpecTrans.add(origSalesTable.SalesId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesTableForSpecTransChange</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates the <c>SalesTable</c> record(s) for the current invoice if a <c>SpecTrans</c> record has been moved.
    /// </summary>
    /// <remarks>
    ///    These SalesTable updates would ideally be done in the updateSourceTable method.  But that method runs after
    ///    postCustVend, which is where settlement occurs.
    /// </remarks>
    private void updateSalesTableForSpecTransChange()
    {
        if (origOrdersWithSpecTrans == null)
        {
            return;
        }

        SetEnumerator se = origOrdersWithSpecTrans.getEnumerator();

        ttsbegin;

        while (se.moveNext())
        {
            SalesIdBase origSalesId = se.current();

            if (origSalesId != salesParmTable.SalesId)
            {
                // This is not the primary sales order in the summary order
                // If this order had specTrans moved to the primary order, unmark this order if it was Selected
                if (origOrdersWithSpecTrans.in(origSalesId))
                {
                    this.updateSalesTableSettleVoucher(origSalesId, SettlementType::SelectedTransact, SettlementType::None);
                }
            }
        }

        // If any specTrans have been moved to the primary order, mark the primary order if it was None
        if (!origOrdersWithSpecTrans.empty())
        {
            this.updateSalesTableSettleVoucher(salesParmTable.SalesId, SettlementType::None, SettlementType::SelectedTransact);

            // Reread the main SalesTable buffer to get the data changed during the updateSalesTableSettleVoucher()
            salesTable.reread();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesTableSettleVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates the SettleVoucher field on a <c>SalesTable</c> record.
    /// </summary>
    /// <param name = "_salesId">The unique Id of the <c>SalesTable</c> to be updated.</param>
    /// <param name = "_fromSettlementType">The previous settlement type.</param>
    /// <param name = "_toSettlementType">The new settlement type.</param>
    private void updateSalesTableSettleVoucher(SalesIdBase _salesId, SettlementType _fromSettlementType, SettlementType _toSettlementType)
    {
        SalesTable salesTableUpdate;

        update_recordset salesTableUpdate
            setting SettleVoucher = _toSettlementType
            where salesTableUpdate.SalesId == _salesId &&
                  salesTableUpdate.SettleVoucher == _fromSettlementType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSettlementVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks the settlement voucher type.
    /// </summary>
    /// <param name = "_origSalesTable">
    ///     A <c>SalesTable</c> table buffer.
    /// </param>
    /// <returns>
    ///     true if the settlement voucher type is selectedTransact; otherwise, false.
    /// </returns>
    protected boolean checkSettlementVoucher(SalesTable _origSalesTable)
    {
        return (_origSalesTable.SettleVoucher == SettlementType::SelectedTransact);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSumSalesId</Name>
				<Source><![CDATA[
    protected void updateSumSalesId()
    {
        if (SalesTable::exist(custInvoiceTrans.OrigSalesId))
        {
            ttsbegin;

            SalesTable localSalesTable = custInvoiceTrans.salesLine().salesTable(true);
            localSalesTable.updateBackStatus();

            // Skipping additional write() method for non-Retail scenario because update is performed inside updateBackStatus
            if (!SalesInvoiceSkipAdditionalWriteOnSummaryUpdateFlight::instance().isEnabled()
                || localSalesTable.mcrIsCallCenter())
            {
                localSalesTable.reread();
                localSalesTable.write();
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWMSShipment</Name>
				<Source><![CDATA[
    protected void updateWMSShipment()
    {
        ShipCarrierShipmentInvoice shipCarrierShipmentInvoice;

        if (this.parmPackedLineIdSet())
        {
            SetEnumerator se = Set::create(this.parmPackedLineIdSet()).getEnumerator();
            while (se.moveNext())
            {
                WMSShipmentId wmsShipmentId = se.current();

                if (WMSShipment::exist(wmsShipmentId) && !ShipCarrierShipmentInvoice::exist(wmsShipmentId, custInvoiceJour.RecId))
                {
                    shipCarrierShipmentInvoice.clear();
                    shipCarrierShipmentInvoice.wmsShipmentId = wmsShipmentId;
                    shipCarrierShipmentInvoice.CustInvoiceJourRefRecId = custInvoiceJour.RecId;
                    shipCarrierShipmentInvoice.insert();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>useBillOfLading</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether to use bill of lading when an invoice is posted.
    /// </summary>
    /// <returns>
    ///     true if bill of lading should be used; otherwise, false.
    /// </returns>
    protected boolean useBillOfLading()
    {
        return !this.isProforma() && SalesParameters::find().useBillOfLadingOnInvoice();
    }

]]></Source>
			</Method>
			<Method>
				<Name>useInventOwnerIdRange_RU</Name>
				<Source><![CDATA[
    protected boolean useInventOwnerIdRange_RU()
    {
        return SalesFormLetter::useInventOwnerIdRange_RU(salesParmTable.salesParmUpdate().SplitInventOwnerId_RU, this.documentStatus(), salesLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>usePerLineCorrection_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns true, if negative lines shoule be posted as correction, and positive - not as coections.
    /// </summary>
    /// <returns>
    ///     true, if negatove lines should be posted as corrections: otherwise, false.
    /// </returns>
    private boolean usePerLineCorrection_RU()
    {
        if (!usePerLineCorrectionIsCached_RU)
        {
            cachedUsePerLineCorrection_RU = this.parmStorno()
                && (!salesTotals.totalAmount() || (salesTotals.totalAmountBySign_RU(false) && salesTotals.totalAmountBySign_RU(true)));

            usePerLineCorrectionIsCached_RU = true;
        }
        return cachedUsePerLineCorrection_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateReturnableReference_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates reference for return order is existing or not.
    /// </summary>
    private void validateReturnableReference_IN()
    {
        SalesLine salesLineLoc;
        boolean alreadyMessageAdded = false;
        SalesTable salesTableLoc = custInvoiceJour.salesTable();

        TransTaxInformationHelper helper = TransTaxInformationHelper::newHelper();

        while select salesLineLoc
            where salesLineLoc.SalesId == salesTableLoc.SalesId
               && salesLineLoc.SalesQty < 0
               && !salesLineLoc.InventTransIdReturn
        {
            TransTaxInformation transTaxInformation = helper.getTransTaxInformationByRecord(salesLineLoc);

            SalesLine_IN salesLineIN = salesLineLoc.salesLine_IN();
            SalesLineReturnDetails_IN salesLineReturnDetails = SalesLineReturnDetails_IN::findbySalesLine(salesLineIN.RecId);
            TaxInformation_IN taxInformation = TaxInformation_IN::find(transTaxInformation.TaxInformation);
            SalesReturn_IN salesReturn = SalesReturn_IN::construct(salesLineLoc.TaxItemGroup);
            SalesReturnInformation_IN salesReturnInformation = salesReturn.getReturnInformation(taxInformation);

            if (salesReturnInformation.RecId != 0
                && salesLineReturnDetails.Type != SalesReturnType_IN::None
                && (salesReturnInformation.AlertLevel == SalesReturnAlert_IN::Warning || salesReturnInformation.AlertLevel == SalesReturnAlert_IN::Error))
            {
                if (!alreadyMessageAdded)
                {
                    warning("@SYS4004284");
                    alreadyMessageAdded = true;
                }
                if (salesReturnInformation.AlertLevel == SalesReturnAlert_IN::Error)
                {
                    throw error("@SYS21533");
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>vatRegData_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// A container used to pass various data between methods.
    /// </summary>
    /// <returns>
    /// A container containing various data.
    /// </returns>
    protected container vatRegData_W()
    {
        VatDueDate_W            vatDate;
        DocumentDate            documentDate;
        PlCustVendName          custVendName;
        VATNum                  tmpVATNum;
        Addressing              addressing;
        InvoiceId               invoiceId;
        PlTaxPeriodPaymentCode  taxPeriodPaymentCode;
        CzPostponeVAT           postponeVAT;
        IntraComVATDueDate_W    intraComVatDate;

        if (salesParmTable.RecId)
        {
            vatDate = salesParmTable.VatDueDate_W;

            if (SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAll))
            {
                documentDate = salesParmTable.DocumentDate;
                postponeVAT = salesParmTable.PostponeVAT && custInvoiceJour.creditNote();
                intraComVatDate = NoYes::No;
            }

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
            {
                taxPeriodPaymentCode = salesParmTable.TaxPeriodPaymentCode_PL;
                CustTable custTable = CustTable::find(salesParmTable.InvoiceAccount);
                custVendName = custTable.name();
                addressing = custTable.address();
                tmpVATNum = custTable.getPrimaryRegistrationNumber(TaxRegistrationTypesList::TAXID, vatDate);
                invoiceId = custInvoiceJour.InvoiceId;
            }
        }
        else
        {
            [ vatDate,
              documentDate,
              custVendName,
              tmpVATNum,
              addressing,
              invoiceId,
              taxPeriodPaymentCode,
              postponeVAT,
              intraComVatDate ] = this.tax().parmVatRegData_W();
        }

        return [ vatDate,
                 documentDate,
                 custVendName,
                 tmpVATNum,
                 addressing,
                 invoiceId,
                 taxPeriodPaymentCode,
                 postponeVAT,
                 intraComVatDate ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeTaxAmount_W</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates GEEW tax fields of the invoice lines.
    /// </summary>
    protected void writeTaxAmount_W()
    {
        CustInvoiceTrans trans;

        if (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoPL]))
        {
            return;
        }

        if (!taxParameters.TaxSpecifyLine)
        {
            return;
        }

        FormletterProformaPrint formletterProformaPrint = FormletterProformaPrint::construct();
        formletterProformaPrint.parmTax(this.tax());
        formletterProformaPrint.parmExchRate_W(this.exchRate_W());
        formletterProformaPrint.parmExchRateSec_W(this.exchRateSec_W());

        // formletterProformaPrint.writeTmpTaxWorkTrans(custInvoiceJour.RecId);
        // by this taxWorkTrans rewritten by TaxSalesInvoice.moveFromSales with SourceTableId CustInvoiceTrans
        // and taxWorkTrans cannot be found in formletterProformaPrint.tmpTaxWorkTrans,
        // therefore trans stay without VAT
        // that's why we must use existing journalTmpTaxWorkTrans
        formletterProformaPrint.parmJournalTmpTaxWorkTrans(journalTmpTaxWorkTrans);

        TmpTaxWorkTrans tmpTaxWorkTransLocal;
        tmpTaxWorkTransLocal = formletterProformaPrint.tmpTaxWorkTrans(custInvoiceJour.RecId);

        while select forupdate trans
            where trans.SalesId == custInvoiceJour.SalesId
                && trans.InvoiceId == custInvoiceJour.InvoiceId
                && trans.InvoiceDate == custInvoiceJour.InvoiceDate
                && trans.NumberSequenceGroup == custInvoiceJour.NumberSequenceGroup
        {
            trans.initFromTaxWorkTrans_RU(
                tmpTaxWorkTransLocal,
                tableNum(SalesLine),
                0,
                trans.InventTransId);
            trans.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static SalesInvoiceJournalPost construct()
    {
        return new SalesInvoiceJournalPost();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReportData</Name>
				<Source><![CDATA[
    public boolean createReportData(FormletterJournalPrint _formletterJournalPrint)
    {
        // If we create a paymSched on salesTable, clean it up now.
        // PaymSched on custInvoiceJour is cleaned up by calling method formLetterService.run()
        if (this.isProforma() && salesTable.PaymentSched)
        {
            boolean salesTableAlreadyExists = CustPaymSched::exist(salesTable.TableId, salesTable.RecId);
            this.createPaymentSched();

            if (!salesTableAlreadyExists && CustPaymSched::exist(salesTable.TableId, salesTable.RecId))
            {
                CustPaymSched::deleteCustPaymSched(salesTable.TableId, salesTable.RecId);
            }
        }

        return super(_formletterJournalPrint);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBeforePost_MY</Name>
				<Source><![CDATA[
    private void checkBeforePost_MY()
    {
        AmountCur totalAmount = salesTotals.totalAmount();

        if (totalAmount < 0 || (totalAmount >= 0 && salesTable.hasLinesWithRefrence_MY()))
        {
            if (!SalesTable.CreditNoteReasonCode && !salesTable.retailSalesTable())
            {
                throw error("@SYP4860740");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransLink_RU</Name>
				<Source><![CDATA[
    private void createTransLink_RU()
    {
        LedgerTransLink_RU ledgerTransLink;
        CustInvoiceTrans invoiceTrans;
        InventTrans inventTrans;
        InventTransOrigin inventTransOrigin;
        TransLink_RU transLink;
        CustInvoiceJour_RU custInvoiceJour_RU = custInvoiceJour.custInvoiceJour_RU();

        if (custInvoiceJour_RU.CorrectedInvoiceId_RU)
        {
            CustInvoiceJour correctedInvoiceJour = CustInvoiceJour::findFromCustTrans(custInvoiceJour_RU.CorrectedInvoiceId_RU,
                                                                                      custInvoiceJour_RU.CorrectedInvoiceDate_RU,
                                                                                      custInvoiceJour.InvoiceAccount);

            ledgerTransLink = LedgerTransLink_RU::newTrans(custInvoiceJour, correctedInvoiceJour);
            ledgerTransLink.parmReportingDate(custInvoiceJour_RU.CorrectedInvoiceDate_RU);
            ledgerTransLink.parmVoucherField(fieldnum(CustInvoiceJour, LedgerVoucher));
            ledgerTransLink.parmAccountingDateField(fieldnum(CustInvoiceJour, InvoiceDate));
            ledgerTransLink.run();
        }

        while select inventTrans
            join RefPri from transLink
                where transLink.RefTableId == tablenum(InventTrans)
                   && transLink.RefSec == inventTrans.RecId
            exists join inventTransOrigin
                where inventTransOrigin.RecId == inventTrans.InventTransOrigin
            exists join invoiceTrans
                where invoiceTrans.InventTransId == inventTransOrigin.InventTransId
                   && invoiceTrans.SalesId == custInvoiceJour.SalesId
                   && invoiceTrans.InvoiceId == custInvoiceJour.InvoiceId
                   && invoiceTrans.InvoiceDate == custInvoiceJour.InvoiceDate
                   && invoiceTrans.numberSequenceGroup == custInvoiceJour.numberSequenceGroup
        {
            InventTrans inventTransOrig = InventTrans::findRecId(transLink.RefPri);
            ledgerTransLink = LedgerTransLink_RU::newTrans(inventTrans, inventTransOrig);
            ledgerTransLink.parmVoucherField(fieldnum(InventTrans, Voucher));
            ledgerTransLink.parmAccountingDateField(fieldnum(InventTrans, DateFinancial));
            ledgerTransLink.parmReportingDate(inventTransOrig.DateFinancial);
            ledgerTransLink.run();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucher</Name>
				<Source><![CDATA[
    protected void initLedgerVoucher()
    {
        super();

        this.findOrCreateLedgerVoucherObject(voucher, this.updateDate()).parmReasonRef(salesTable.CreditNoteReasonCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isMCRGiftCardCustInvoiceTrans_BR</Name>
				<Source><![CDATA[
    private boolean isMCRGiftCardCustInvoiceTrans_BR()
    {
        CustInvoiceTrans tmpCustInvoiceTrans;

        journalLines_BR.first(tmpCustInvoiceTrans);

        return MCRGiftCard::isGiftCardOperation(salesTable, tmpCustInvoiceTrans.ItemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxableDocumentDescriptor</Name>
				<Source><![CDATA[
    public TaxableDocumentDescriptor parmTaxableDocumentDescriptor()
    {
        return TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(custInvoiceJour);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldPostRetailDiscountsForNormalOrders</Name>
				<Source><![CDATA[
    [SysObsolete('This method was firstly introduced for creating GUP extension of discount claim posting. Now the discount claim posting is decoupled from retail periodic discount posting and extend methods postLineDiscount() and postLines() of class SalesInvoiceJournalPost instead.', true, 30\06\2022)]
    protected boolean shouldPostRetailDiscountsForNormalOrders()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNotCallCenterAndRetailCustomerOrder</Name>
				<Source><![CDATA[
    protected boolean isNotCallCenterAndRetailCustomerOrder()
    {
        RetailSalesTable retailSalesTable = RetailSalesTable::findSalesTable(salesTable);

        return (!salesTable.mcrIsCallCenter() && !retailSalesTable.isRetailCustomerOrder());
    }

]]></Source>
			</Method>
			<Method>
				<Name>postRetailPeriodicDiscounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post a line for periodic discount.
    /// Revert the original sales discount ledger voucher transaction and add a new periodic discount voucher transaction.
    /// </summary>
    /// <param name = "_salesPurchLine"> The SalesPurchLine record.</param>
    /// <param name = "_exchangeRateHelper"> An instance of the <c>CurrencyExchangeHelper</c> object.</param>
    /// <param name = "_ledgerVoucherObject"> An instance of the <c>LedgerVoucherObject</c> object.</param>
    /// <param name = "_accountDisc"> The sales discount account record Id.</param>
    /// <param name = "_sign"> If discounts are credited, then 1, else -1.</param>
    protected void postRetailPeriodicDiscounts()
    {
        LedgerVoucherTransObject ledgerPostingTransaction;
        RetailSalesDiscountLine retailSalesDiscountLine;
        SalesPurchLineInterface salesPurchLineInterface = salesPurchLine.salesPurchLineInterface();
        LedgerDimensionDefaultAccount   accountDisc =  formletterProvider.lineDiscountLedgerDimension();
        LedgerVoucherObject             ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();
        int                             sign = this.creditDiscount() ? -1 : 1;

        RetailParameters postingRetailSetup = RetailParameters::find();

        if (!postingRetailSetup.PostPeriodicDiscountForOrders
            || (postingRetailSetup.ledgerAccountType != RetailBookingLedgerAccountTypeBase::Periodic)
            || this.isNotCallCenterAndRetailCustomerOrder())
        {
            return;
        }

        container periodicDiscountVRefs;
        boolean isExactBondRequiredForDiscountTransaction;
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            isExactBondRequiredForDiscountTransaction = ledgerVoucherObject.ledgerBondClient_RU() != null;
        }

        CurrencyExchangeHelper exchangeRateHelper  = CurrencyExchangeHelper::newExchangeDate(Ledger::current(),ledgerVoucherObject.parmAccountingDate());
        
        InventQty qtyOrdered = salesLine.SalesQty;
        InventQty invoicedNowQty = updateNow;
        
        // this quantity is being invoiced in current call, but has not been committed in DB.
        InventQty alreadyInvoicedQty = qtyOrdered - (salesLine.RemainSalesPhysical + invoicedNowQty);
        
        AmountCur periodicDiscountAmount, sumRevertAmount;
        LedgerDimensionDefaultAccount ledgerAccountPeriodicDisc;
        LedgerDimensionAccount ledgerDimensionDiscountAccount, ledgerDimensionPeriodicDiscount;
        
        while select PeriodicDiscountOfferId, Amount, DiscountOriginType
                from retailSalesDiscountLine
                where retailSalesDiscountLine.InventTransId == salesLine.InventTransId &&
                        (retailSalesDiscountLine.DiscountOriginType == RetailDiscountOriginType::Periodic
                            || retailSalesDiscountLine.DiscountOriginType == RetailDiscountOriginType::Tender)
        {
            if (salesTable.InclTax == NoYes::yes)
            {
                retailSalesDiscountLine.Amount = salesPurchLineInterface.amountExclTax(retailSalesDiscountLine.Amount, invoicedNowQty, this.transDate, tax);
            }

            if (retailSalesDiscountLine.DiscountOriginType == RetailDiscountOriginType::Periodic)
            {
                ledgerAccountPeriodicDisc = this.getLedgerAccountForPeriodicDisc(retailSalesDiscountLine, salesLine, salesTable);
            }
            else
            {
                ledgerAccountPeriodicDisc = RetailTenderDiscount::ledgerAccountTenderDisc(retailSalesDiscountLine.PeriodicDiscountOfferId, salesLine.ItemId, salesTable.CustAccount);
            }

            ledgerDimensionPeriodicDiscount = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerAccountPeriodicDisc, salesPurchLineInterface.parmDefaultDimension());
            if (invoicedNowQty + alreadyInvoicedQty != qtyOrdered) // Still some qty is pending invoice.
            {
                periodicDiscountAmount = (retailSalesDiscountLine.Amount / qtyOrdered) *  invoicedNowQty;
            }
            else // No more qty for this sales lines left for invoice.
            {
                periodicDiscountAmount = retailSalesDiscountLine.Amount - (retailSalesDiscountLine.Amount / qtyOrdered) * alreadyInvoicedQty;
            }
        
            periodicDiscountAmount = CurrencyExchangeHelper::amount(periodicDiscountAmount, salesPurchLineInterface.parmCurrencyCode());
        
            if (periodicDiscountAmount)
            {
                ledgerPostingTransaction = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                ledgerVoucherObject,
                                                formletterProvider.postingTypeLineDiscount(),
                                                ledgerDimensionPeriodicDiscount,
                                                salesPurchLineInterface.parmCurrencyCode(),
                                                periodicDiscountAmount * sign,
                                                exchangeRateHelper);
        
                this.addTaxParentReference(ledgerPostingTransaction);
                ledgerPostingTransaction.setTaxTransRelationshipType(TaxTransRelationshipType::LineDiscount);
                ledgerPostingTransaction.parmProjLedger(this.projLedger());
                ledgerPostingTransaction.parmSourceTableId(salesPurchLine.TableId);
                ledgerPostingTransaction.parmSourceRecId(salesPurchLine.RecId);
                ledgerPostingTransaction.parmLedgerDetailLevel(LedgerDetailLevel::Detail);
                ledgerVoucher.addTrans(ledgerPostingTransaction);
                sumRevertAmount += periodicDiscountAmount;

                if (isExactBondRequiredForDiscountTransaction)
                {
                    periodicDiscountVRefs += [ledgerVoucherObject.ledgerBondClient_RU().lastVrefId()];
                }
            }
        }
        
        // Revert the amount on account specified under inventory posting setup.
        if (sumRevertAmount)
        {
            ledgerDimensionDiscountAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(accountDisc, salesPurchLineInterface.parmDefaultDimension());
            ledgerPostingTransaction = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                ledgerVoucherObject,
                                                formletterProvider.postingTypeLineDiscount(),
                                                ledgerDimensionDiscountAccount,
                                                salesPurchLineInterface.parmCurrencyCode(),
                                                -1 * sumRevertAmount * sign,
                                                exchangeRateHelper);
        
            this.addTaxParentReference(ledgerPostingTransaction);
            ledgerPostingTransaction.setTaxTransRelationshipType(TaxTransRelationshipType::LineDiscount);
            ledgerPostingTransaction.parmProjLedger(this.projLedger());
            ledgerPostingTransaction.parmSourceTableId(salesPurchLine.TableId);
            ledgerPostingTransaction.parmSourceRecId(salesPurchLine.RecId);
            ledgerPostingTransaction.parmLedgerDetailLevel(LedgerDetailLevel::Detail);
            ledgerVoucher.addTrans(ledgerPostingTransaction);

            if (isExactBondRequiredForDiscountTransaction && conLen(periodicDiscountVRefs) > 0)
            {
                LedgerBondClient_RU ledgerBondClient = ledgerVoucherObject.ledgerBondClient_RU();
                ledgerBondClient.bondVRef2Log(ledgerBondClient.lastVrefId(), periodicDiscountVRefs);
            }
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerAccountForPeriodicDisc</Name>
				<Source><![CDATA[
    protected LedgerDimensionDefaultAccount getLedgerAccountForPeriodicDisc(RetailSalesDiscountLine _retailSalesDiscountLine, SalesLine _salesLine, SalesTable _salesTable)
    {
        return RetailperiodicDiscount::ledgerAccountPeriodicDisc(_retailSalesDiscountLine.PeriodicDiscountOfferId, 0, _salesLine.ItemId, '', _salesTable.CustAccount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processDiscountLineLevelPostings</Name>
				<Source><![CDATA[
    [SysObsolete('This method was firstly introduced for creating GUP extension of discount claim posting. Now the discount claim posting is decoupled from retail periodic discount posting and extend methods postLineDiscount() and postLines() of class SalesInvoiceJournalPost instead.', true, 30\06\2022)]
    protected void processDiscountLineLevelPostings(RetailSalesDiscountLine _retailSalesDiscountLine, LedgerVoucherObject _ledgerVoucherObject, LedgerDimensionAccount _defaultDimension, LedgerDimensionAccount _ledgerDimensionPeriodicDiscount, Amount _periodicDiscountAmount, CurrencyExchangeHelper _exchangeRateHelper, int _sign)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateParmTableJobStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Called when updating JobStatus is required outside journal posting scope- Simulation scenario
    /// </summary>
    /// <param name="_startDateTime">
    /// The start date time of the posting
    /// </param>
    internal void updateParmTableJobStatus(StartDateTime _startDateTime = this.getDateTimeNow())
    {
        salesParmTable.StartDateTime = _startDateTime;
        salesParmTable.EndDateTime   = this.getDateTimeNow();
        salesParmTable.ParmJobStatus = ParmJobStatus::Executed;
        salesParmTable.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWithholdCalculate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether or not the withholding tax should get calculated for the given <c>SalesTable</c> object.
    /// </summary>
    /// <param name = "_salesTable">
    ///     The <c>SalesTable</c> object for checking whether calculate withholding tax.
    /// </param>
    /// <returns>
    ///     true if need to calculate withholding tax; otherwise, false.
    /// </returns>
    private boolean checkWithholdCalculate(SalesTable _salesTable)
    {
        return salesTable.custTable_InvoiceAccount().TaxWithholdCalculate_IN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSettlePayments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the payments can be settled.
    /// </summary>
    /// <param name = "_salesInvoiceJournalPost">
    /// The sales invoice journal object.
    /// </param>
    /// <param name = "_salesTable">
    /// The sales table object.
    /// </param>
    /// <returns>True if the payments can be settled; otherwise, false.</returns>
    internal static boolean canSettlePayments(SalesTable _salesTable, SalesInvoiceJournalPost _salesInvoiceJournalPost)
    {
        return _salesInvoiceJournalPost
            && !_salesInvoiceJournalPost.parmProforma()
            && _salesTable
            && (RetailMCRChannelTable::mcrEnableOrderCompletion(_salesTable)
                || RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(_salesTable, funcName()));
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>