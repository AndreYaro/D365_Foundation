<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustSettlementPriorityProcessing</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>CustSettlementPriorityProcessing</c> class is used to manage the business logic for marking
/// transactions on the <c>CustPaymEntry</c> and <c>CustOpenTrans</c> forms that are based on the
/// settlement priority setup on the <c>CustParameters</c> form.
/// </summary>
/// <remarks>
/// This class uses the <c>CustPaymSettlementManager</c> and <c>CustOpenTransManager</c> classes to
/// handle the business logic of the <c>CustPaymEntry</c> and <c>CustOpenTrans</c> forms, respectively.
/// </remarks>
public class CustSettlementPriorityProcessing
{
    protected CustPaymSettlementManager custPaymEntryManager;
    protected CustVendOpenTransManager custOpenTransManager;
    protected SpecTransManager specManager;
    protected LedgerJournalTrans custPayment;
    protected AmountCur paymAmount;
    protected AmountCur remainingPayment;
    Query query;
    protected QueryBuildDataSource qbds;
    protected boolean noInvoiceWithCreditNoteRestriction;
    protected CustParameters custParameters;

    private CustSettlementPriorityProcessingQueryRangeGenerator queryRangeGenerator;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addCustSettlementTransactionPriorityDSToQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add customer settlement transaction priority data source to the query.
    /// </summary>
    protected void addCustSettlementTransactionPriorityDSToQuery()
    {
        QueryBuildDataSource qbdsLast = query.dataSourceNo(query.dataSourceCount());
        QueryBuildDataSource qbdsCustTrans = query.dataSourceTable(tableNum(CustTrans));
        QueryBuildDataSource qbdsCustLedgerTransTypeMapping;
        QueryBuildDataSource qbdsCustSettlementTransactionPriority;

        // Conditional add of these datasources. The query in OffsetVoucherCust already has them. The query in CustTransOpen and CustPaymEntry do not.
        if (query.dataSourceTable(tableNum(CustLedgerTransTypeMapping)) == null)
        {
            qbdsCustLedgerTransTypeMapping = qbdsLast.addDataSource(tableNum(CustLedgerTransTypeMapping));
            qbdsCustLedgerTransTypeMapping.addLink(fieldNum(CustTrans, TransType), fieldNum(CustLedgerTransTypeMapping, LedgerTransType), qbdsCustTrans.name());
            qbdsCustLedgerTransTypeMapping.joinMode(JoinMode::OuterJoin);
        }

        if (query.dataSourceTable(tableNum(CustSettlementTransactionPriority)) == null)
        {
            qbdsCustLedgerTransTypeMapping = query.dataSourceTable(tableNum(CustLedgerTransTypeMapping));

            qbdsCustSettlementTransactionPriority = qbdsCustLedgerTransTypeMapping.addDataSource(tableNum(CustSettlementTransactionPriority));
            qbdsCustSettlementTransactionPriority.addLink(fieldNum(CustLedgerTransTypeMapping, CustSettleTransType), fieldNum(CustSettlementTransactionPriority, TransactionType));
            qbdsCustSettlementTransactionPriority.joinMode(JoinMode::OuterJoin);

            qbdsCustSettlementTransactionPriority.addRange(fieldNum(CustSettlementTransactionPriority, Company)).value(queryValue(curExt()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes a new instance of the <c>CustSettlementPriorityProcessing</c> class.
    /// </summary>
    /// <param name = "_query">
    ///     The <c>Query</c> object.
    /// </param>
    /// <returns>
    ///     A new instance of the <c>CustSettlementPriorityProcessing</c> class.
    /// </returns>
    public static CustSettlementPriorityProcessing construct(Query _query)
    {
        return new CustSettlementPriorityProcessing(_query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcSettlementPriorityCashDiscDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the cash discount date that is used to prioritize transactions.
    /// </summary>
    /// <param name="_payDate">
    /// A <c>CustCashDiscDate</c> value that indicates the payment date; optional.
    /// </param>
    public void calcSettlementPriorityCashDiscDate(CustCashDiscDate _payDate = dateNull())
    {
        CustTransCashDisc custTransCashDisc;
        CustTransOpen custTransOpen;
        QueryRun queryRun;

        if (_payDate == dateNull())
        {
            _payDate = custPayment.TransDate;
        }

        queryRun = new QueryRun(query);

        while (queryRun.next())
        {
            custTransOpen = queryRun.get(tableNum(CustTransOpen));

            changecompany(custTransOpen.company())
            {
                custTransOpen.selectForUpdate(true);

                if (custTransOpen.CashDiscDate == dateNull())
                {
                    custTransOpen.SettlementPriorityCashDiscDate = maxdate();
                }
                else
                {
                    custTransCashDisc = CustTransCashDisc::findByUseCashDisc(
                        tableNum(CustTransOpen),
                        custTransOpen.RecId,
                        custTransOpen.UseCashDisc,
                        _payDate);

                    if (custTransCashDisc)
                    {
                        custTransOpen.SettlementPriorityCashDiscDate = custTransCashDisc.CashDiscDate;
                    }
                    else
                    {
                        custTransOpen.SettlementPriorityCashDiscDate = maxdate();
                    }
                }

                custTransOpen.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTempData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the temporary table <c>TmpCustOpenLines</c> with the available open transaction lines.
    /// </summary>
    /// <param name="_accountNum">
    /// The customer account number.
    /// </param>
    /// <returns>
    /// Returns the temporary table that contains the open transaction lines.
    /// </returns>
    protected tmpCustOpenLines createTempData(AccountNum _accountNum)
    {
        tmpCustOpenLines tmpCustOpenLines = null;
        CustTransOpen custTransOpen;
        CustTransOpenLine custTransOpenLine;
        CustTrans custTrans;
        CustLedgerTransTypeMapping custLedgerTransTypeMapping;
        CustSettlementTransactionPriority custSettlementTransactionPriority;
        RecId billingCodeId;
        SettlementPriority billingCodePriority, billingClassPriority;

        while select RecId, AmountCur, DueDate, SettlementPriorityCashDiscDate, AccountNum, RefRecId from custTransOpen
            where custTransOpen.AccountNum == _accountNum
                && custTransOpen.AmountCur > 0
            outer join RecId, AmountCur, CustTransOpen, CustInvoiceLineIdRef from custTransOpenLine
                where custTransOpenLine.CustTransOpen == custTransOpen.RecId
            join TransDate, Voucher, TransType, RecId from custTrans
                where custTransOpen.RefRecId == custTrans.RecId
            join LedgerTransType, CustSettleTransType from custLedgerTransTypeMapping
                where custTrans.TransType == custLedgerTransTypeMapping.LedgerTransType
            join Priority, TransactionType from custSettlementTransactionPriority
                where custLedgerTransTypeMapping.CustSettleTransType == custSettlementTransactionPriority.TransactionType
        {

            if (this.skipCustomerTransactionForCreateTempData(custTrans, custTransOpen))
            {
                continue;
            }

            AmountCur remainingAmount = specManager.findUnmarkedAmountForRef(
                custTransOpen.AmountCur,
                custTransOpen.company(),
                tableNum(CustTransOpen),
                custTransOpen.RecId);

            if (remainingAmount > 0.0)
            {
                tmpCustOpenLines.CustTransOpen = custTransOpen.RecId;
                tmpCustOpenLines.CustTransOpenLine = custTransOpenLine.RecId;
                tmpCustOpenLines.TransactionAmount = remainingAmount;
                tmpCustOpenLines.DueDate = custTransOpen.DueDate;
                tmpCustOpenLines.CashDiscDate = custTransOpen.SettlementPriorityCashDiscDate;
                tmpCustOpenLines.TransDate = custTrans.TransDate;
                tmpCustOpenLines.Voucher = custTrans.Voucher;
                tmpCustOpenLines.TransPriority = custSettlementTransactionPriority.Priority;

                if (custTransOpenLine)
                {
                    AmountCur remainingLineAmount = custTransOpenLine.findRemainingAmountCur();

                    if (remainingLineAmount > 0.0)
                    {
                        tmpCustOpenLines.AmountCur = remainingLineAmount;
                        [billingCodeId, billingClassPriority, billingCodePriority] = this.getBillingPriorities(custTransOpen, custTransOpenLine, true);
                    }
                    else
                    {
                        tmpCustOpenLines.AmountCur = remainingAmount;
                        [billingCodeId, billingClassPriority, billingCodePriority] = this.getBillingPriorities(custTransOpen, custTransOpenLine, false);
                    }
                }
                else
                {
                    tmpCustOpenLines.AmountCur = remainingAmount;
                    [billingCodeId, billingClassPriority, billingCodePriority] = this.getBillingPriorities(custTransOpen, custTransOpenLine, false);
                }

                tmpCustOpenLines.CustBillingCode = billingCodeId;
                tmpCustOpenLines.BillingClassPriority = billingClassPriority;
                tmpCustOpenLines.BillingCodePriority = billingCodePriority;

                tmpCustOpenLines.insert();
            }
        }

        return tmpCustOpenLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipCustomerTransactionForCreateTempData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Skip the customer transaction for adding it to the temporary data  temporary table.
    /// </summary>
    /// <param name = "_custTrans">The customer transaction.</param>
    /// <param name = "_custTransOpen">The open customer transaction.</param>
    /// <returns>
    /// True if the current customer transaction should be skipped; otherwise false.
    /// </returns>
    protected boolean skipCustomerTransactionForCreateTempData(CustTrans _custTrans, CustTransOpen _custTransOpen)
    {
        AmountCur openTransAmount;
        boolean skipCustomerTransactionForCreateTempData;

        if (custPaymEntryManager != null)
        {
            openTransAmount = custPaymEntryManager.getSettleAmount(_custTransOpen);

            if (openTransAmount < 0)
            {
                skipCustomerTransactionForCreateTempData = true;
            }
        }

        if (!skipCustomerTransactionForCreateTempData && custOpenTransManager != null)
        {
            openTransAmount = custOpenTransManager.getSettleAmount(_custTransOpen);

            if (custOpenTransManager.getTransMarked(_custTransOpen) == NoYes::Yes
                || custOpenTransManager.getMarkedPrimaryPayment(_custTransOpen) == NoYes::Yes
                || openTransAmount < 0)
            {
                skipCustomerTransactionForCreateTempData = true;
            }
        }

        return skipCustomerTransactionForCreateTempData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBillingPriorities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fetches the billing class and billing code information for the given open transaction line.
    /// </summary>
    /// <param name="_custTransOpen">
    /// The reference record ID of the <c>CustTransOpen</c> record to be inserted.
    /// </param>
    /// <param name="_custTransOpenLine">
    /// The reference record ID of the <c>CustTransOpenLine</c> record to be inserted.
    /// </param>
    /// <param name="_openLineExists">
    /// A Boolean which specifies whether the Open transaction contains single line.
    /// </param>
    /// <returns>
    /// The billing code, billing class priority and billing code priority.
    /// </returns>
    protected container getBillingPriorities(
        CustTransOpen _custTransOpen,
        CustTransOpenLine _custTransOpenLine,
        boolean _openLineExists = false)
    {
        const SettlementPriority MaxBillPriority = 1000;

        CustTrans custTrans;
        CustBillingCode custBillingCode;
        CustInvoiceTable custInvoiceTable;
        CustInvoiceLine custInvoiceLine;
        CustBillingClassification custBillingclassifciation;
        CustBillingClassificationCode custBillingClassificationCode;
        CustInvoiceTrans custInvoiceTrans;
        SettlementPriority billCodePriority;
        SettlementPriority billClassPriority;

        if (_openLineExists)
        {
            // Retrieves the billing classfication and billing code priorities on the basis of given open transaction.
            select firstonly RecId from custBillingCode
                join CustInvoiceLineIdRef, SourceDocumentLine from custInvoiceTrans
                    where custInvoiceTrans.CustInvoiceLineIdRef == _custTransOpenLine.CustInvoiceLineIdRef
                join SourceDocumentLine, CustBillingCode from custInvoiceLine
                    where custInvoiceLine.SourceDocumentLine == custInvoiceTrans.SourceDocumentLine
                        && custInvoiceLine.CustBillingCode == custBillingCode.RecId
                join RecId, SettlementPriority from custBillingclassifciation
                join CustBillingCode, CustBillingClassification, SettlementPriority from custBillingClassificationCode
                    where custInvoiceLine.CustBillingCode == custBillingClassificationCode.CustBillingCode
                        && custBillingClassificationCode.CustBillingClassification == custBillingclassifciation.RecId;
        }
        else
        {
            select firstonly RecId from custBillingCode
                join RecId, Invoice from custTrans
                    where custTrans.RecId == _custTransOpen.RefRecId
                join RecId, InvoiceId from custInvoiceTable
                    where custInvoiceTable.InvoiceId == custTrans.Invoice
                join ParentRecId, CustBillingCode from custInvoiceLine
                    where custInvoiceLine.ParentRecId == custInvoiceTable.RecId
                        && custInvoiceLine.CustBillingCode == custBillingCode.RecId
                join RecId, SettlementPriority from custBillingclassifciation
                join CustBillingCode, CustBillingClassification, SettlementPriority from custBillingClassificationCode
                    where custBillingClassificationCode.CustBillingClassification == custBillingclassifciation.RecId
                        && custInvoiceLine.CustBillingCode == custBillingClassificationCode.CustBillingCode;
        }

        custTrans = _custTransOpen.custTrans();
        custBillingclassifciation = CustBillingClassification::find(custTrans.CustBillingClassification);

        if (custTrans.TransType != enum2int(LedgerTransType::Interest))
        {
            billCodePriority = (custBillingClassificationCode.SettlementPriority > 0) ? custBillingClassificationCode.SettlementPriority : MaxBillPriority;
        }

        billClassPriority = (custBillingclassifciation.SettlementPriority > 0) ? custBillingclassifciation.SettlementPriority : MaxBillPriority;

        return [custBillingCode.RecId, billClassPriority, billCodePriority];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the cash discount for the given open transaction.
    /// </summary>
    /// <param name="_custTransOpen">
    /// The reference record ID of the <c>CustTransOpen</c> record to be inserted.
    /// </param>
    /// <returns>
    /// Returns the discount for the given open transaction.
    /// </returns>
    private CashDiscAmount getCashDiscount(CustTransOpen _custTransOpen)
    {
        CashDiscAmount discAmountToTake = 0.0;

        if (custPaymEntryManager)
        {
            discAmountToTake = custPaymEntryManager.calcCashDiscAmountToTake(_custTransOpen);
        }
        else if (custOpenTransManager)
        {
            discAmountToTake = custOpenTransManager.getCashDiscAmountToTake(_custTransOpen);
        }

        return discAmountToTake;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFullCashDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the full cash discount for the given open transaction.
    /// </summary>
    /// <param name="_custTransOpen">
    /// The reference record ID of the <c>CustTransOpen</c> record to be inserted.
    /// </param>
    /// <returns>
    /// Returns the discount for the given open transaction.
    /// </returns>
    private CashDiscAmount getFullCashDiscount(CustTransOpen _custTransOpen)
    {
        CashDiscAmount discAmountToTake = 0.0;

        if (custPaymEntryManager)
        {
            discAmountToTake = custPaymEntryManager.calcCashDiscAmountToTake(_custTransOpen);
        }
        else if (custOpenTransManager)
        {
            discAmountToTake = custOpenTransManager.getCustVendTransOpenCashDiscAmount(_custTransOpen);
        }

        return discAmountToTake;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPrimaryPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>CustTransOpen</c> record marked as primary payment.
    /// </summary>
    /// <returns>
    /// The <c>CustTransOpen</c> record if found; otherwise, a null buffer.
    /// </returns>
    public CustTransOpen getPrimaryPayment()
    {
        CustTransOpen custTransOpen;
        SpecTrans specTrans;

        Debug::assert(custPaymEntryManager == null);

        if (custOpenTransManager != null)
        {
            specTrans = specManager.findByMarkedPayment();

            if (specTrans)
            {
                custTransOpen = specTrans.custTransOpen();
            }
        }

        return custTransOpen;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSettlementQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the customized settlement query based on the attributes selected by user.
    /// </summary>
    /// <param name="_tmpCustOpenLines">
    /// The buffer of the <c>TmpCustOpenLines</c> table.
    /// </param>
    /// <returns>
    /// Returns the records of the <c>TmpCustOpenLines</c> table.
    /// </returns>
    protected Query getSettlementQuery(tmpCustOpenLines _tmpCustOpenLines)
    {
        CustSettlementPriority custSettlementPriority;
        Query settlementQuery;

        settlementQuery = new Query(queryStr(CustSettlementbyLine));
        qbds = settlementQuery.dataSourceTable(tableNum(tmpCustOpenLines));
        qbds.addOrderByField(fieldNum(tmpCustOpenLines, BillingClassPriority), SortOrder::Ascending);
        qbds.addOrderByField(fieldNum(tmpCustOpenLines, BillingCodePriority), SortOrder::Ascending);

        while select Attribute, Direction from custSettlementPriority
            order by Priority desc
            where custSettlementPriority.Enabled == NoYes::Yes
        {
            this.updateQueryRangeOrderByForSettlementQuery(settlementQuery, custSettlementPriority);
        }

        return settlementQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryRangeOrderByForSettlementQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update query range order by for settlement query.
    /// </summary>
    /// <param name = "_settlementQuery">The settlement query.</param>
    /// <param name = "_custSettlementPriority">The customer settlement priority.</param>
    protected void updateQueryRangeOrderByForSettlementQuery(Query _settlementQuery, CustSettlementPriority _custSettlementPriority)
    {
        queryRangeGenerator.updateQueryRangeOrderByForSettlementQuery(_settlementQuery, _custSettlementPriority);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustPaymEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs initialization for the object created from the <c>CustPaymEntry</c> form.
    /// </summary>
    /// <param name="_manager">
    /// The <c>CustPaymSettlementManager</c> object passed from the <c>CustPaymEntry</c> form.
    /// </param>
    /// <param name="_custPayment">
    /// The <c>LedgerJournalTrans</c> table buffer that contains payment information.
    /// </param>
    public void initCustPaymEntry(CustPaymSettlementManager _manager, LedgerJournalTrans _custPayment)
    {
        custPayment = _custPayment;
        custPaymEntryManager = _manager;
        specManager = custPaymEntryManager.parmSpecTransMgr();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustTransOpen</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs initialization for the object created from the <c>CustOpenTrans</c> form.
    /// </summary>
    /// <param name="_manager">
    /// The <c>CustVendOpenTransManager</c> object passed from the <c>CustOpenTrans</c> form.
    /// </param>
    protected void initCustTransOpen(CustVendOpenTransManager _manager)
    {
        custOpenTransManager = _manager;
        specManager = custOpenTransManager.parmSpecTransManager();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOffsetVoucherCust</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs initialization for the object created from the <c>OffsetVoucherCust</c> class.
    /// </summary>
    /// <param name="_openTransactionQuery">
    /// The Query object passed from the <c>OffsetVoucherCust</c> class.
    /// </param>
    /// <param name="_specTransManager">
    /// The <c>SpecTransManager</c> object passed from the <c>OffsetVoucherCust</c> class.
    /// </param>
    protected void initOffsetVoucherCust(
        Query _openTransactionQuery,
        SpecTransManager _specTransManager)
    {
        query = _openTransactionQuery;
        specManager = _specTransManager;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertAllLinesAccrossInvoices</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks the invoice lines when deals with billing codes across the invoices.
    /// </summary>
    /// <param name="_payment">
    /// The Amount available for payment.
    /// </param>
    /// <param name="_accountNum">
    /// The customer account number.
    /// </param>
    /// <param name="_creditNoteRestriction">
    /// A Boolean which specifies whether the credit note restriction exists.
    /// </param>
    /// <param name="_custBillingClassification">
    /// The reference record ID of the <c>CustBillingClassification</c> record to be inserted.
    /// </param>
    /// <returns>
    /// Returns the remaining settlement amount.
    /// </returns>
    public AmountCur insertAllLinesAccrossInvoices(
        AmountCur _payment,
        AccountNum _accountNum,
        boolean _creditNoteRestriction = false,
        CustBillingClassification _custBillingClassification = null)
    {
        CurrencyExchangeHelper localCurrencyHelper;
        SpecTrans insertSpecTrans;
        CustTransOpen custTransOpen;
        CustTrans custTrans;
        CashDiscAmount discAmountToTake = 0.0;
        CustTransMarkedOpenLine specTransLine;
        CustTransMarkedOpenLine custTransMarkedOpenLine;
        AmountCur lineAmount;
        AmountCur lineAmountToSettle;
        AmountCur lineDiscAmount;
        AmountCur totalAmountCur;
        AmountCur remainingTotalAmount;
        AmountCur remainingDiscToTake;
        AmountCur remainingSettlementAmount;
        QueryRun queryRun;
        RecId recIdCustBillingCode = 0;
        boolean marked = false;
        boolean deleteLine = false;
        boolean noLineExists = false;
        NoYes isPartialCashDisc = NoYes::No;

        TmpCustOpenLines tmpCustOpenLines = this.createTempData(_accountNum);
        Query settlementQuery = this.buildSettlementQuery(_accountNum, tmpCustOpenLines, _creditNoteRestriction, _custBillingClassification);
        isPartialCashDisc = custParameters.CashDiscForPartialPaym;

        queryRun = new QueryRun(settlementQuery);
        queryRun.setCursor(tmpCustOpenLines);

        ttsbegin;

        while (queryRun.next())
        {
            custTransOpen = queryRun.get(tableNum(CustTransOpen)) as CustTransOpen;
            custTrans = queryRun.get(tableNum(CustTrans)) as CustTrans;
            tmpCustOpenLines = queryRun.get(tableNum(tmpCustOpenLines)) as tmpCustOpenLines;
            localCurrencyHelper = CurrencyExchangeHelper::construct();

            discAmountToTake = 0.0;

            if (isPartialCashDisc == NoYes::Yes)
            {
                discAmountToTake = this.getCashDiscount(custTransOpen);
            }

            totalAmountCur = specManager.findUnmarkedAmountForRef(
                custTransOpen.AmountCur,
                custTransOpen.company(),
                tableNum(CustTransOpen),
                custTransOpen.RecId);

            if (_payment > 0.0)
            {
                remainingTotalAmount = discAmountToTake;

                select sum(CashDiscLineToTake), sum(AmountToSettle) from specTransLine
                    join insertSpecTrans
                        where specTransLine.SpecTrans == insertSpecTrans.RecId
                            && insertSpecTrans.RefRecId == custTransOpen.RecId;

                remainingTotalAmount = remainingTotalAmount - specTransLine.CashDiscLineToTake;

                if (tmpCustOpenLines.CustBillingCode != 0 && recIdCustBillingCode != tmpCustOpenLines.CustBillingCode)
                {
                    this.insertNegativeLinesForBillCode(tmpCustOpenLines.CustBillingCode, _accountNum);
                }

                recIdCustBillingCode = tmpCustOpenLines.CustBillingCode;

                if (!specManager.exist(custTransOpen.company(), tableNum(CustTransOpen), custTransOpen.RecId))
                {
                    if (custParameters.UsePriorityOnAutoSettlement == NoYes::Yes)
                    {
                        insertSpecTrans = specManager.insertSpec(
                            insertSpecTrans,
                            custTransOpen.company(),
                            tableNum(CustTransOpen),
                            custTransOpen.RecId,
                            0,
                            custTrans.CurrencyCode,
                            NoYes::No,
                            discAmountToTake);
                    }
                    else
                    {
                         insertSpecTrans = specManager.insertSpec(
                            insertSpecTrans,
                            custTransOpen.company(),
                            tableNum(CustTransOpen),
                            custTransOpen.RecId,
                             0,
                             custTrans.CurrencyCode,
                             NoYes::No,
                             discAmountToTake,
                             custTransOpen.CashDiscDate);
                    }

                    remainingSettlementAmount = totalAmountCur - discAmountToTake;
                    marked = true;
                }
                else
                {
                    insertSpecTrans = specManager.findByRef(custTransOpen.company(), tableNum(CustTransOpen), custTransOpen.RecId);

                    remainingSettlementAmount = totalAmountCur - insertSpecTrans.Balance01;
                }

                SpecTrans specTrans = specManager.findByRef(custTransOpen.company(), tableNum(CustTransOpen), custTransOpen.RecId);

                select firstonly AmountToSettle from custTransMarkedOpenLine
                    where custTransMarkedOpenLine.CustTransOpenLine == tmpCustOpenLines.CustTransOpenLine
                        && custTransMarkedOpenLine.SpecTrans == specTrans.RecId;

                if (custTransMarkedOpenLine.AmountToSettle > 0.0)
                {
                    //Delete those marked positive lines and add their amount to the settlement amount.
                    _payment += custTransMarkedOpenLine.AmountToSettle;
                    specManager.deleteLine(insertSpecTrans, tmpCustOpenLines.CustTransOpenLine);
                    deleteLine = true;
                }

                remainingTotalAmount += _payment;

                if (_payment > 0.0)
                {
                    select sum(CashDiscLineToTake) from specTransLine
                        where specTransLine.SpecTrans == insertSpecTrans.RecId;

                    if (!deleteLine)
                    {
                        remainingDiscToTake = discAmountToTake - specTransLine.CashDiscLineToTake;
                    }

                    lineAmount = (remainingTotalAmount >= tmpCustOpenLines.AmountCur) ? tmpCustOpenLines.AmountCur : remainingTotalAmount;
                    remainingTotalAmount -= lineAmount;

                    if (remainingTotalAmount > 0.0 || lineAmount == tmpCustOpenLines.AmountCur)
                    {
                        lineDiscAmount =  CurrencyExchange::round(((lineAmount / totalAmountCur) * discAmountToTake), custTrans.CurrencyCode);
                        lineAmountToSettle = lineAmount - lineDiscAmount;
                    }
                    else
                    {
                        lineDiscAmount =  remainingDiscToTake;
                        lineAmountToSettle = _payment;
                    }

                    if (lineAmountToSettle > _payment)
                    {
                        lineDiscAmount =  remainingDiscToTake;
                        lineAmountToSettle = _payment;
                    }

                    if (tmpCustOpenLines.CustTransOpenLine)
                    {
                        specTransLine.SpecTrans = insertSpecTrans.RecId;
                        specTransLine.CashDiscLineToTake = lineDiscAmount;
                        specTransLine.AmountToSettle = lineAmountToSettle;
                        specTransLine.CustTransOpenLine = tmpCustOpenLines.CustTransOpenLine;
                        specTransLine.insert();
                        marked = true;
                    }
                    else
                    {
                        insertSpecTrans.selectForUpdate(true);
                        insertSpecTrans.Balance01 = lineAmountToSettle + lineDiscAmount;
                        insertSpecTrans.update();
                        _payment -= lineAmountToSettle;
                        noLineExists = true;
                    }

                    if (marked && !noLineExists)
                    {
                        //update settlement amount_
                        _payment -= lineAmountToSettle;

                        //update balance for the marked transaction

                        select sum(AmountToSettle), sum(CashDiscLineToTake) from specTransLine
                            where specTransLine.SpecTrans == insertSpecTrans.RecId;

                        insertSpecTrans.reread();
                        specManager.updateSettleBalanceAndDisc(
                            insertSpecTrans.RefCompany,
                            insertSpecTrans.RefTableId,
                            insertSpecTrans.RefRecId,
                            specTransLine.AmountToSettle,
                            specTransLine.CashDiscLineToTake,
                            insertSpecTrans.SelectedDateUsedToCalcCashDisc);

                        if (!deleteLine)
                        {
                            select sum(AmountToSettle) from specTransLine
                                where specTransLine.SpecTrans == insertSpecTrans.RecId;

                            marked = false;

                            AmountCur remainingAmount = specManager.findUnmarkedAmountForRef(
                                custTransOpen.AmountCur,
                                custTransOpen.company(),
                                tableNum(CustTransOpen),
                                custTransOpen.RecId);

                            if (specTransLine.AmountToSettle == remainingAmount)
                            {
                                _payment += this.getFullCashDiscount(custTransOpen);
                            }
                        }
                    }

                    deleteLine = false;
                    noLineExists = false;
                }
            }
        }

        //update discounts for partial payments
        if (custOpenTransManager || custPaymEntryManager)
        {
            this.updateMarkedInvoices(_accountNum);
        }

        ttscommit;

        return _payment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSettlementQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Builds the customized settlement query based on the attributes selected by user.
    /// </summary>
    /// <param name = "_accountNum">
    ///     The customer account number.
    /// </param>
    /// <param name = "_tmpCustOpenLines">
    ///     The current <c>TmpCustOpenLines</c> table buffer.
    /// </param>
    /// <param name = "_creditNoteRestriction">
    ///     A boolean which specifies whether the credit note restriction exists.
    /// </param>
    /// <param name = "_custBillingClassification">
    ///     The reference record ID of the <c>CustBillingClassification</c> record to be inserted.
    /// </param>
    /// <returns>
    ///     An initialized <c>Query</c> object used for settlement.
    /// </returns>
    protected Query buildSettlementQuery(
        AccountNum _accountNum,
        tmpCustOpenLines _tmpCustOpenLines,
        boolean _creditNoteRestriction = false,
        CustBillingClassification _custBillingClassification = null)
    {
        Query settlementQuery = this.getSettlementQuery(_tmpCustOpenLines);
        
        if (_creditNoteRestriction && _custBillingClassification != null)
        {
            QueryBuildDataSource qbdsCustTrans = settlementQuery.dataSourceTable(tableNum(CustTrans));

            // defining static ranges and their values
            QueryBuildRange range = qbdsCustTrans.addRange(fieldNum(CustTrans, CustBillingClassification));
            range.value(queryValue(_custBillingClassification.RecId));
        }

        return settlementQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertNegativeLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts negative open transaction lines and uses the negative amount of these lines to mark the positive lines of the invoice.
    /// </summary>
    /// <param name="_refCustTransOpenRecId">
    /// The reference record ID of the <c>CustTransOpen</c> record to be inserted.
    /// </param>
    /// <param name="_refSpecTransRecId">
    /// The reference record ID of the <c>SpecTrans</c> record to be inserted.
    /// </param>
    /// <param name="_discAmountToTake">
    /// The cash discount amount to be distributed among the lines.
    /// </param>
    /// <param name="_amountToPay">
    /// The amount to be distributed among the lines.
    /// </param>
    private void insertNegativeLines(
        RefRecId _refCustTransOpenRecId,
        RefRecId _refSpecTransRecId,
        CashDiscAmount _discAmountToTake,
        AmountCur _amountToPay)
    {
        CustTransMarkedOpenLine insertSpecTransLine;
        CustTransOpenLine custTransOpenLine;
        CustBillingClassificationCode custBillingClassificationCode;
        CustTransOpen custTransOpen;
        CustInvoiceTrans custInvoiceTrans;
        CustInvoiceLine custInvoiceLine;
        CustTrans custTrans;
        CurrencyExchangeHelper localCurrencyHelper;
        AmountCur totalAmountCur;
        AmountCur remainingTotalAmount;
        AmountCur remainingSettlementAmount;
        AmountCur totalNegativeLineAmount;
        CashDiscAmount remainingDiscToTake;
        boolean isAnyLines;
        RecordInsertList recordInsertListMarkedLines;

        totalAmountCur = _amountToPay + _discAmountToTake;
        remainingTotalAmount = totalAmountCur;
        remainingDiscToTake = _discAmountToTake;
        remainingSettlementAmount = _amountToPay;
        custTransOpen = CustTransOpen::find(_refCustTransOpenRecId);
        custTrans = custTransOpen.custTrans();

        recordInsertListMarkedLines = new RecordInsertList(tableNum(CustTransMarkedOpenLine));
        localCurrencyHelper = CurrencyExchangeHelper::construct();

        ttsbegin;

        //mark negative lines
        while select RecId, CustTransOpen, AmountCur from custTransOpenLine
            order by RecId asc
            where custTransOpenLine.CustTransOpen == _refCustTransOpenRecId
                && custTransOpenLine.AmountCur < 0
            {
                [remainingTotalAmount, insertSpecTransLine, remainingSettlementAmount, remainingDiscToTake] = specManager.markedSpecTransLine(custTransOpenLine, _refSpecTransRecId,
                    _discAmountToTake, remainingTotalAmount, totalAmountCur, remainingDiscToTake, remainingSettlementAmount, custTrans.CurrencyCode);

                totalNegativeLineAmount -= insertSpecTransLine.AmountToSettle;
                recordInsertListMarkedLines.add(insertSpecTransLine);
                Debug::assert(remainingTotalAmount == (remainingSettlementAmount + remainingDiscToTake));
                isAnyLines = true;
            }

            remainingTotalAmount = totalNegativeLineAmount;
            remainingSettlementAmount = remainingTotalAmount;

        //mark the postive lines
        while select RecId, CustTransOpen, CustInvoiceLineIdRef, AmountCur from custTransOpenLine
            where custTransOpenLine.CustTransOpen == _refCustTransOpenRecId
            join SettlementPriority, CustBillingCode from custBillingClassificationCode
            join CustInvoiceLineIdRef, SourceDocumentLine from custInvoiceTrans
                where custInvoiceTrans.CustInvoiceLineIdRef == custTransOpenLine.CustInvoiceLineIdRef
            join SourceDocumentLine, CustBillingCode from custInvoiceLine
                order by custBillingClassificationCode.SettlementPriority asc, custTransOpenLine.RecId asc
                where custInvoiceLine.SourceDocumentLine == custInvoiceTrans.SourceDocumentLine
                    && custInvoiceLine.CustBillingCode == custBillingClassificationCode.CustBillingCode
                    && custTransOpenLine.AmountCur > 0.0
        {
            if (remainingTotalAmount > 0.0)
            {
                [remainingTotalAmount, insertSpecTransLine, remainingSettlementAmount, remainingDiscToTake] = specManager.markedSpecTransLine(custTransOpenLine, _refSpecTransRecId,
                _discAmountToTake, remainingTotalAmount, totalAmountCur, remainingDiscToTake, remainingSettlementAmount, custTrans.CurrencyCode);
                recordInsertListMarkedLines.add(insertSpecTransLine);
                isAnyLines = true;
            }
        }

        recordInsertListMarkedLines.insertDatabase();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertNegativeLinesForBillCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Identifies and inserts, if there exists negative lines in an invoice which contains the given billing code.
    /// </summary>
    /// <param name="_custBillingCode">
    /// The reference record ID of the <c>CustBillingCode</c>.
    /// </param>
    /// <param name="_accountNum">
    /// The customer account number.
    /// </param>
    private void insertNegativeLinesForBillCode(
        RefRecId _custBillingCode,
        AccountNum _accountNum)
    {
        CustTransOpenLine custTransOpenLine;
        CustTransOpen custTransOpen;
        tmpCustOpenLines tmpCustOpenLines;
        SpecTrans insertSpecTrans;
        CustTrans custTrans;
        CashDiscAmount discAmountToTake = 0.0;
        RecId recIdCustTransOpen = 0;

        discAmountToTake = 0.0;
        tmpCustOpenLines = this.createTempData(_accountNum);

        ttsbegin;

        //mark the postive lines against the amount exists in the negative lines of the invoice

        while select RecId, CustBillingCode, CustTransOpen from tmpCustOpenLines
            where tmpCustOpenLines.CustBillingCode == _custBillingCode
            join RecId, RefRecId, AmountCur from custTransOpen
                order by custTransOpen.RecId
                where custTransOpen.RecId == tmpCustOpenLines.CustTransOpen
            join AmountCur, CustTransOpen from custTransOpenLine
                where custTransOpenLine.CustTransOpen == custTransOpen.RecId
                    && custTransOpenLine .AmountCur < 0
        {
            discAmountToTake = this.getCashDiscount(custTransOpen);

            if (custTransOpen.RefRecId == recIdCustTransOpen || this.isNegativeLineMarkedForInvoice(custTransOpen))
            {
                continue;
            }
            else
            {
                recIdCustTransOpen = custTransOpen.RefRecId;
            }

            custTrans = custTransOpen.custTrans();

            if (specManager.exist(custTransOpen.company(), tableNum(CustTransOpen), custTransOpen.RecId))
            {
                insertSpecTrans = specManager.findByRef(custTransOpen.company(), tableNum(CustTransOpen), custTransOpen.RecId);
            }
            else
            {
                AmountCur remainingAmount = specManager.findUnmarkedAmountForRef(
                    custTransOpen.AmountCur,
                    custTransOpen.company(),
                    tableNum(CustTransOpen),
                    custTransOpen.RecId);

                insertSpecTrans = specManager.insertSpec(
                    insertSpecTrans,
                    custTransOpen.company(),
                    tableNum(CustTransOpen),
                    custTransOpen.RecId,
                    remainingAmount,
                    custTrans.CurrencyCode,
                    NoYes::No,
                    discAmountToTake,
                    custTransOpen.CashDiscDate);
            }

            //mark negative lines and use their amount to mark positive lines of the same invoice.
            this.insertNegativeLines(custTransOpen.RecId, insertSpecTrans.RecId, discAmountToTake, insertSpecTrans.Balance01);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceExistWithCreditNoteRestriction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether there is any invoice exist with credit not restriction.
    /// </summary>
    /// <returns>
    /// True, if the invoice exist with credit note restriction otherwise false.
    /// </returns>
    public boolean invoiceExistWithCreditNoteRestriction()
    {
        return noInvoiceWithCreditNoteRestriction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAlreadyMarked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether any open transaction is marked for settlement by the current payment.
    /// </summary>
    /// <returns>
    /// true if any open transaction is marked for settlement; otherwise, false.
    /// </returns>
    public boolean isAlreadyMarked()
    {
        boolean ret;
        SpecTrans specTrans;
        Map mapSpecTrans;
        MapEnumerator enumerator;

        // check if some transaction is already marked for CustPaymEntry form
        if (custPaymEntryManager != null)
        {
            if (SpecTrans::findBySpec(custPayment.Company, custPayment.TableId, custPayment.RecId))
            {
                ret = true;
            }
            else
            {
                ret = false;
            }
        }

        // check if some debit transactions are already marked for CustOpenTrans form
        if (custOpenTransManager != null)
        {
            mapSpecTrans = specManager.getAllSpecTransMap();
            enumerator = mapSpecTrans.getEnumerator();

            while (enumerator.moveNext())
            {
                specTrans = enumerator.currentValue();

                if (specTrans.Balance01 > 0)
                {
                    ret = true;
                    break;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isMarked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if any Debit or Credit transaction is marked which has the credit note restriction and an associated class which is different from
    /// the class that is associated with the given transaction (Debit or Credit).
    /// </summary>
    /// <param name="_custTrans">
    /// The current instance of the <c>CustTrans</c> table.
    /// </param>
    /// <param name="_custTransOpen">
    /// The current instance of the <c>CustTransOpen</c> table.
    /// </param>
    /// <returns>
    /// true if the given open transaction can be marked; otherwise, false.
    /// </returns>
    public boolean isMarked(CustTrans _custTrans, CustTransOpen _custTransOpen)
    {
        CustBillingClassification custBillingClassification;
        QueryRun queryRun = new QueryRun(query);

        boolean ret = true;

        noInvoiceWithCreditNoteRestriction = false;
        custBillingClassification = CustBillingClassification::find(_custTrans.CustBillingClassification, false);

        changecompany(_custTransOpen.company())
        {
            if (custPaymEntryManager != null)
            {
                // for CustPaymEntry form
                ret = this.validateMarkedTransactionPaymEntry(
                    _custTrans,
                    _custTransOpen,
                    queryRun,
                    custBillingClassification);
            }
            else if (custOpenTransManager != null)
            {
                // for CustOpenTrans form
                ret = this.validateMarkedTransactionOpenTrans(
                    _custTrans,
                    _custTransOpen,
                    queryRun,
                    custBillingClassification);
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNegativeLineMarkedForInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the given open transaction has marked negative line.
    /// </summary>
    /// <param name="_custTransOpen">
    /// The reference record ID of the <c>CustTransOpen</c> record to be inserted.
    /// </param>
    /// <returns>
    /// true if any negative line of the open transaction is marked; otherwise, false.
    /// </returns>
    private boolean isNegativeLineMarkedForInvoice(CustTransOpen _custTransOpen)
    {
        CustTransOpenLine custTransOpenLine;
        CustTransMarkedOpenLine custTransMarkedOpenLine;
        boolean result = false;

        select firstonly RecId, CustTransOpen, AmountCur from custTransOpenLine
            where custTransOpenLine.CustTransOpen == _custTransOpen.RecId
                && custTransOpenLine.AmountCur < 0
            join CustTransOpenLine, AmountToSettle from custTransMarkedOpenLine
                where custTransMarkedOpenLine.CustTransOpenLine == custTransOpenLine.RecId
                    && custTransMarkedOpenLine.AmountToSettle < 0;

        if (custTransMarkedOpenLine.RecId)
        {
            result = true;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markAllSelected</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks all the selected debit and credit transactions that have not been marked for settlement in another
    /// payment.
    /// </summary>
    /// <param name="_custTransOpenFormDataSource">
    /// <c>FormDataSource</c> with the records selected for marking.
    /// </param>
    public void markAllSelected(FormDataSource _custTransOpenFormDataSource)
    {
        CustTrans trans;
        boolean allowMarkingPastPaymAmount;
        CustTransOpen custTransOpen;
        CustTrans custTrans;
        CustBillingClassification custBillingClassification;
        boolean canBeMarked;

        // For CustPaymEntry form
        if (custPaymEntryManager != null)
        {
            custTransOpen = _custTransOpenFormDataSource.getFirst(true);

            while (custTransOpen)
            {
                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                    && custParameters.CustUseBillingClassification_PSN)
                {
                    custTrans = custTransOpen.joinChild();
                    custBillingClassification = CustBillingClassification::find(custTrans.CustBillingClassification, false);

                    if (custPaymEntryManager.isTransMarked(custTransOpen))
                    {
                        custPaymEntryManager.unmarkTrans(custPayment, custTransOpen);
                    }
                }

                changecompany(custTransOpen.company())
                {
                    canBeMarked = this.canBeMarkedForCustPaymEntry(custTransOpen, custTrans, custBillingClassification);

                    if (canBeMarked)
                    {
                       // Not a prepayment or the user confirmed to mark it anyway
                       allowMarkingPastPaymAmount = (custPayment.displayCustPaymAmount() == 0);
                       custPaymEntryManager.markTrans(custPayment, custTransOpen, trans, allowMarkingPastPaymAmount, false);
                    }
                }

                custTransOpen = _custTransOpenFormDataSource.getNext();
            }
        }

        // For CustOpenTrans form
        if (custOpenTransManager != null)
        {
            custTransOpen = _custTransOpenFormDataSource.getFirst(true);

            while (custTransOpen)
            {
                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                    && custParameters.CustUseBillingClassification_PSN)
                {
                    custTrans = custTransOpen.joinChild();
                    custBillingClassification = CustBillingClassification::find(custTrans.CustBillingClassification, false);

                    if (custOpenTransManager.getTransMarked(custTransOpen) == NoYes::Yes)
                    {
                        this.updateTransMarked(custTransOpen, false);
                    }
                }

                changecompany(custTransOpen.company())
                {
                    canBeMarked = this.canBeMarked(custTransOpen, custTrans, custBillingClassification);

                    if (canBeMarked)
                    {
                        this.updateTransMarked(custTransOpen, true);
                    }
                }

                custTransOpen = _custTransOpenFormDataSource.getNext();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeMarked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the open customer transaction can be marked.
    /// </summary>
    /// <param name = "_custTransOpen">The open customer transaction.</param>
    /// <param name = "_custTrans">The customer transaction.</param>
    /// <param name = "_custBillingClassification">The customer billing classification.</param>
    /// <returns>
    /// True if the open customer transaction can be marked; otherwise false.
    /// </returns>
    protected boolean canBeMarked(CustTransOpen _custTransOpen, CustTrans _custTrans, CustBillingClassification _custBillingClassification)
    {
        boolean canBeMarked;

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
            && custParameters.CustUseBillingClassification_PSN)
        {
            canBeMarked = custOpenTransManager.getTransMarked(_custTransOpen) == NoYes::No
                && !custOpenTransManager.checkTransFullyMarkedByOtherSpec(_custTransOpen)
                && (_custBillingClassification.RestrictCreditNote == NoYes::No || _custTransOpen.AmountCur > 0);
        }
        else
        {
            canBeMarked = custOpenTransManager.getTransMarked(_custTransOpen) == NoYes::No
                && !custOpenTransManager.checkTransFullyMarkedByOtherSpec(_custTransOpen);
        }

        return canBeMarked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBeMarkedForCustPaymEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the open customer transaction can be marked from the <c>CustPaymEntry</c> form.
    /// </summary>
    /// <param name = "_custTransOpen">The open customer transaction.</param>
    /// <param name = "_custTrans">The customer transaction.</param>
    /// <param name = "_custBillingClassification">The customer billing classification.</param>
    /// <returns>
    /// True if the open customer transaction can be marked; otherwise false.
    /// </returns>
    protected boolean canBeMarkedForCustPaymEntry(CustTransOpen _custTransOpen, CustTrans _custTrans, CustBillingClassification _custBillingClassification)
    {
        boolean canBeMarked;

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
             && custParameters.CustUseBillingClassification_PSN)
        {
            canBeMarked = !custPaymEntryManager.isAlreadyFullyMarked(_custTransOpen)
                && (_custBillingClassification.RestrictCreditNote == NoYes::No || _custTransOpen.AmountCur > 0);
        }
        else
        {
            canBeMarked = !custPaymEntryManager.isTransMarked(_custTransOpen)
                 && !custPaymEntryManager.isAlreadyFullyMarked(_custTransOpen);
        }

        return canBeMarked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks the specified open transaction for settlement.
    /// </summary>
    /// <param name="_custTransOpen">
    /// The open transaction.
    /// </param>
    protected void markTrans(CustTransOpen _custTransOpen)
    {
        CustTrans trans;

        // get the CustTrans object
        trans = _custTransOpen.joinChild();

        // checks to see which object is initialized
        // call its appropriate marking method
        if (custPaymEntryManager != null)
        {
            custPaymEntryManager.markTrans(custPayment, _custTransOpen, trans, false, false);
        }
        else if (custOpenTransManager != null)
        {
            this.updateTransMarked(_custTransOpen, NoYes::Yes);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>markTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Iterates through all open transactions and marks the selected transactions until payment is
    /// exhausted.
    /// </summary>
    /// <returns>
    /// true if the payment amount is exhausted; otherwise, false.
    /// </returns>
    protected boolean markTransactions()
    {
        CustTransOpen custTransOpen;
        CustTrans custTrans;
        AmountCur amountToSettleInPaymCur;
        AmountCur openTransAmount;
        boolean isExhausted;
        QueryRun queryRun;

        Debug::assert(query != null);

        queryRun = new QueryRun(query);

        // Iterate through each open transaction in passed datasource
        while (queryRun.next())
        {
            custTransOpen = queryRun.get(tableNum(CustTransOpen));

            changecompany(custTransOpen.company())
            {
                custTrans = custTransOpen.joinChild();

                // calculate amount to settle for CustPaymEntry form by utilizing CustPaymSettlementManager object
                if (custPaymEntryManager != null)
                {
                    openTransAmount = custPaymEntryManager.getSettleAmount(custTransOpen);

                    if (custPaymEntryManager.isAlreadyFullyMarked(custTransOpen)
                        || openTransAmount < 0)
                    {
                        continue;
                    }
                    amountToSettleInPaymCur = custPaymEntryManager.convertTransAmountCurToPaymAmountCur(custTransOpen, openTransAmount);
                }

                // calculate amount to settle for CustOpenTrans form by utilizing CustVendOpenTransManager object
                if (custOpenTransManager != null)
                {
                    openTransAmount = custOpenTransManager.getSettleAmount(custTransOpen);

                    if (custOpenTransManager.getTransMarked(custTransOpen) == NoYes::Yes
                        || custOpenTransManager.getMarkedPrimaryPayment(custTransOpen) == NoYes::Yes
                        || custOpenTransManager.checkTransFullyMarkedByOtherSpec(custTransOpen)
                        || openTransAmount < 0)
                    {
                        continue;
                    }

                    amountToSettleInPaymCur = custOpenTransManager.convertAmountTransCurToAmountPaymCur(custTransOpen, openTransAmount);
                }

                // mark the transactions if payment is not exhausted
                if (remainingPayment > 0 && amountToSettleInPaymCur <= remainingPayment)
                {
                    remainingPayment -= amountToSettleInPaymCur;
                    this.markTrans(custTransOpen);
                }
                else
                {
                    isExhausted = true;
                    break;
                }
            }
        }

        // if some payment amount is unsettled, mark it for partial payment
        if (remainingPayment > 0 && isExhausted)
        {
            this.markTrans(custTransOpen);
            this.updatePartialTrans(custTransOpen);
        }

        return isExhausted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markTransactionsByCreditNoteRestriction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Iterates through all transaction types by their priority retrieved from <c>CustSettlementPriority</c> table.
    /// </summary>
    /// <param name="_accountNum">
    /// The customer account number.
    /// </param>
    /// <param name="_billing">
    /// defines whether billing attribute is selected.
    /// </param>
    /// <returns>
    /// true if some payment amount is utilized; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method calls markTransactions method which iterates through all open transactions
    /// for the particular transaction type.
    /// </remarks>
    public boolean markTransactionsByCreditNoteRestriction(
        AccountNum _accountNum,
        boolean _billing)
    {
        boolean ret = true;
        CustTrans custTrans;
        CustTransOpen custTransOpen;
        CustBillingClassification custBillingClassification;
        QueryRun queryRun;
        SpecTrans specTrans;
        QueryBuildDataSource qbdsCustTrans;
        QueryBuildRange range;
        boolean creditNoteRestriction = false;
        boolean marked = false;
        AmountCur payment;

        Debug::assert(isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && custParameters.CustUseBillingClassification_PSN);

        queryRun = new QueryRun(query);

        while select RecId, CustBillingClassification, AccountNum from custTrans
            group by custBillingClassification.RestrictCreditNote, custBillingClassification.SettlementPriority, custBillingClassification.RecId
            where custTrans.AccountNum == _accountNum
            outer join RecId, RestrictCreditNote, SettlementPriority from custBillingClassification
                order by custBillingClassification.RestrictCreditNote desc, custBillingClassification.SettlementPriority asc
                where custBillingClassification.RecId == custTrans.CustBillingClassification
            join RefRecId from custTransOpen
                where custTransOpen.RefRecId == custTrans.RecId
            join sum(Balance01), RefRecId from specTrans
                where specTrans.RefRecId == custTransOpen.RecId && specTrans.Balance01 < 0
        {
            if (custBillingClassification.RestrictCreditNote)
            {
                qbdsCustTrans = query.dataSourceTable(tableNum(CustTrans));

                //defining static ranges and their values
                range = qbdsCustTrans.addRange(fieldNum(CustTrans, CustBillingClassification));
                range.value(queryValue(custBillingClassification.RecId));
                remainingPayment = abs(specTrans.Balance01);

                custTrans = CustTrans::find(custTrans.RecId);
                custTransOpen = custTrans.transOpen(dateNull(), false);
                creditNoteRestriction = true;
                marked = true;
            }
            else
            {
                select firstonly RecId, CustBillingClassification, AccountNum from custTrans
                    where custTrans.AccountNum == _accountNum
                    join RecId, RefRecId from custTransOpen
                        where custTransOpen.RefRecId == custTrans.RecId
                    outer join RecId, RestrictCreditNote, SettlementPriority from custBillingClassification
                        where custBillingClassification.RecId == custTrans.CustBillingClassification
                            && custBillingClassification.RestrictCreditNote == NoYes::No
                    join sum(Balance01) from specTrans
                        where specTrans.RefRecId == custTransOpen.RecId && specTrans.Balance01 < 0;

                    remainingPayment = abs(specTrans.Balance01);
                    query.dataSourceTable(tableNum(CustTrans)).clearRange(fieldNum(CustTrans, CustBillingClassification));
                    break;
            }

           // remainingPayment = this.setPaymentAmount();
            if (_billing
                && custParameters.InvoiceLinePriority == CustInvoiceLinePriority::BillingCode
                && custParameters.SpanBillingCodeAcrossInvoices == NoYes::Yes)
            {
                payment = remainingPayment;
                remainingPayment = this.insertAllLinesAccrossInvoices(remainingPayment, _accountNum, custBillingClassification.RestrictCreditNote, custBillingClassification);

                if (payment == remainingPayment)
                {
                    this.updateTransMarked(custTransOpen, false);
                }
            }
            else
            {
                this.markTransByCreditNoteOnBillingClasses(creditNoteRestriction);
            }
        }
        // if no payment amount is utilized in marking return false
        if (!marked)
        {
            marked = true;

            if (remainingPayment == 0)
            {
                ret = false;
            }
            else if (_billing
                && custParameters.SpanBillingCodeAcrossInvoices == NoYes::Yes
                && custParameters.InvoiceLinePriority == CustInvoiceLinePriority::BillingCode)
            {
                remainingPayment = this.insertAllLinesAccrossInvoices(remainingPayment, _accountNum);
            }
            else
            {
                this.markTransByCreditNoteOnBillingClasses(creditNoteRestriction);
            }
        }

        //clear the range which was added for billing classificaiton
        query.dataSourceTable(tableNum(CustTrans)).clearRange(fieldNum(CustTrans, CustBillingClassification));

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markTransactionsByPriority</Name>
				<Source><![CDATA[
    /// <summary>
    /// Iterates through all transaction types by their priority retrieved from <c>CustSettlementPriority</c> table.
    /// </summary>
    /// <param name="_payDate">
    /// A <c>CustCashDiscDate</c> value that indicates the payment date; optional.
    /// </param>
    /// <returns>
    /// true if some payment amount is utilized; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method calls markTransactions method which iterates through all open transactions
    /// for the particular transaction type.
    /// </remarks>
    public boolean markTransactionsByPriority(CustCashDiscDate _payDate = dateNull())
    {
        boolean ret = true;
        QueryBuildRange qbr;
        CustSettlementPriority custSettlementPriority;
        CustTrans custTrans;
        QueryRun queryRun;
        CustAccount accountNum;
        boolean billing = false;
        remainingPayment = this.setPaymentAmount();

        custSettlementPriority = CustSettlementPriority::findByAttribute(CustSettlementPriorityAttribute::CashDiscountDate);

        if (custSettlementPriority.Enabled)
        {
            this.calcSettlementPriorityCashDiscDate(_payDate);
        }

        query.clearOrderBy();

        query.dataSourceTable(tableNum(CustSettlementTransactionPriority)).clearRanges();

        qbds = query.dataSourceTable(tableNum(CustSettlementTransactionPriority));
        qbr = qbds.addRange(fieldNum(CustSettlementTransactionPriority, Company));

        qbr.value(curExt());

        while select Attribute, Direction from custSettlementPriority
            order by Priority desc
            where custSettlementPriority.Enabled == NoYes::Yes
        {
            qbds = query.dataSourceTable(tableNum(CustTransOpen));

            this.updateQueryRangeOrderByForCustSettlementPriority(custSettlementPriority);

            if (custSettlementPriority.Attribute == CustSettlementPriorityAttribute::Billing
                && isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
            {
                billing = true;
            }

        }

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && custParameters.CustUseBillingClassification_PSN)
        {
            if (custOpenTransManager)
            {
                queryRun = new QueryRun(query);

                if (queryRun.next())
                {
                    custTrans = queryRun.get(tableNum(CustTrans)) as CustTrans;
                    accountNum = custTrans.AccountNum;
                    this.markTransactionsByCreditNoteRestriction(accountNum, billing);

                    return true;
                }
            }
            else if (custPaymEntryManager)
            {
                accountNum = custPayment.parmAccount();
            }

            if (billing
                && custParameters.SpanBillingCodeAcrossInvoices == NoYes::Yes
                && custParameters.InvoiceLinePriority == CustInvoiceLinePriority::BillingCode)
            {
                remainingPayment = this.insertAllLinesAccrossInvoices(remainingPayment, accountNum);
            }
            else
            {
                this.markTransactions();
            }
        }
        else
        {
            this.markTransactions();
        }

        query.clearOrderBy();

        // if no payment amount is utilized in marking return false
        if (remainingPayment == paymAmount)
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryRangeOrderByForCustSettlementPriority</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update query range order by for customer settlement priority.
    /// </summary>
    /// <param name = "_custSettlementPriority">The customer settlement priority.</param>
    protected void updateQueryRangeOrderByForCustSettlementPriority(CustSettlementPriority _custSettlementPriority)
    {
        queryRangeGenerator.updateQueryFieldSortOrderForCustSettlementPriority(query, _custSettlementPriority);
    }

]]></Source>
			</Method>
			<Method>
				<Name>markTransByCreditNoteOnBillingClasses</Name>
				<Source><![CDATA[
    /// <summary>
    /// Iterates through all open transactions and marks the selected transactions until payment is exhausted.
    /// </summary>
    /// <param name="_creditNoteRestriction">
    /// Defines whether billing class has restriction.
    /// </param>
    /// <returns>
    /// true if the payment amount is exhausted; otherwise, false.
    /// </returns>
    protected boolean markTransByCreditNoteOnBillingClasses(boolean _creditNoteRestriction)
    {
        CustTransOpen custTransOpen;
        CustTrans custTrans;
        CustSettlementPriority custSettlementPriority;
        SpecTrans specTrans;
        AmountCur amountToSettleInPaymCur;
        AmountCur openTransAmount;
        boolean isExhausted;
        boolean found;
        QueryBuildRange qbr;
        QueryRun queryRunWithBillingClass;
        QueryRun queryRunWithoutBillingClass;
        Query qryBillingClass;
        QueryBuildDataSource qbdsCustTrans;
        QueryBuildRange range;

        Debug::assert(query != null);
        Debug::assert(isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && custParameters.CustUseBillingClassification_PSN);

        custSettlementPriority = CustSettlementPriority::findByAttribute(CustSettlementPriorityAttribute::CashDiscountDate);

        query.clearOrderBy();
        query.dataSourceTable(tableNum(CustSettlementTransactionPriority)).clearRanges();

        qbds = query.dataSourceTable(tableNum(CustSettlementTransactionPriority));
        qbr = qbds.addRange(fieldNum(CustSettlementTransactionPriority, Company));

        // for CustOpenTrans form
        qbr.value(queryValue(curExt()));

        while select Attribute, Direction from custSettlementPriority
            order by Priority desc
            where custSettlementPriority.Enabled == NoYes::Yes
        {
            qbds = query.dataSourceTable(tableNum(CustTransOpen));

            this.updateQueryRangeOrderByForCustSettlementPriority(custSettlementPriority);
        }

        // Iterate through each open transaction with billing class in passed datasource
        qryBillingClass = query;
        qbdsCustTrans = query.dataSourceTable(tableNum(CustTrans));

        //defining static ranges and their values
        if (!_creditNoteRestriction)
        {
            range = qbdsCustTrans.addRange(fieldNum(CustTrans, CustBillingClassification));
            range.value(SysQuery::valueNot(0));
        }

        queryRunWithBillingClass = new QueryRun(query);
        qryBillingClass.dataSourceTable(tableNum(CustTrans)).clearRange(fieldNum(CustTrans, CustBillingClassification));
        qbdsCustTrans = qryBillingClass.dataSourceTable(tableNum(CustTrans));

        //defining static ranges and their values
        range = qbdsCustTrans.addRange(fieldNum(CustTrans, CustBillingClassification));
        range.value(queryValue(0));
        queryRunWithoutBillingClass = new QueryRun(qryBillingClass);

        while (queryRunWithBillingClass.next())
        {
            found = false;
            custTransOpen = queryRunWithBillingClass.get(tableNum(CustTransOpen));

            select firstonly RefRecId, Balance01, CashDiscToTake from specTrans
                where specTrans.RefRecId == custTransOpen.RecId
                    && specTrans.Balance01 < 0;

            if (specTrans)
            {
                AmountCur remainingAmount = specManager.findUnmarkedAmountForRef(
                        custTransOpen.AmountCur,
                        custTransOpen.company(),
                        tableNum(CustTransOpen),
                        custTransOpen.RecId);

                if (specTrans.Balance01 + specTrans.CashDiscToTake == remainingAmount)
                {
                    found = true;
                }
                else
                {
                    remainingPayment += specTrans.Balance01;
                    this.updateTransMarked(custTransOpen, NoYes::No);
                }
            }

            changecompany(custTransOpen.company())
            {
                custTrans = custTransOpen.joinChild();

                // calculate amount to settle for CustOpenTrans form by utilizing CustVendOpenTransManager object
                openTransAmount = custOpenTransManager.getSettleAmount(custTransOpen);

                if (this.skipForCreditNoteWithBillingClassification(custTrans, custTransOpen, openTransAmount, found))
                {
                    continue;
                }

                amountToSettleInPaymCur = custOpenTransManager.convertAmountTransCurToAmountPaymCur(custTransOpen, openTransAmount);

                // mark the transactions if payment is not exhausted
                if (remainingPayment > 0 && amountToSettleInPaymCur <= remainingPayment)
                {
                    remainingPayment -= amountToSettleInPaymCur;
                    this.markTrans(custTransOpen);
                }
                else
                {
                    isExhausted = true;
                    break;
                }
            }
        }

        // if some payment amount is unsettled, mark it for partial payment
        if (remainingPayment > 0 && isExhausted)
        {
            this.markTrans(custTransOpen);
            this.updatePartialTrans(custTransOpen);
        }

        // Iterate through each open transaction without billing class in passed datasource
        if (!_creditNoteRestriction)
        {
            while (queryRunWithoutBillingClass.next())
            {
                found = false;
                custTransOpen = queryRunWithoutBillingClass.get(tableNum(CustTransOpen));

                select firstonly RefRecId, Balance01, CashDiscToTake from specTrans
                    where specTrans.RefRecId == custTransOpen.RecId
                        && specTrans.Balance01 > 0;

                if (specTrans)
                {
                    AmountCur remainingAmount = specManager.findUnmarkedAmountForRef(
                        custTransOpen.AmountCur,
                        custTransOpen.company(),
                        tableNum(CustTransOpen),
                        custTransOpen.RecId);

                    if (specTrans.Balance01 + specTrans.CashDiscToTake == remainingAmount)
                    {
                        found = true;
                    }
                    else
                    {
                        remainingPayment += specTrans.Balance01;
                        this.updateTransMarked(custTransOpen, NoYes::No);
                    }
                }

                changecompany(custTransOpen.company())
                {
                    custTrans = custTransOpen.joinChild();

                    // calculate amount to settle for CustOpenTrans form by utilizing CustVendOpenTransManager object
                    openTransAmount = custOpenTransManager.getSettleAmount(custTransOpen);

                    if (this.skipForCreditNoteWithoutBillingClassification(custTrans, custTransOpen, openTransAmount, found))
                    {
                        continue;
                    }

                    amountToSettleInPaymCur = custOpenTransManager.convertAmountTransCurToAmountPaymCur(custTransOpen, openTransAmount);

                    // mark the transactions if payment is not exhausted
                    if (remainingPayment > 0 && amountToSettleInPaymCur <= remainingPayment)
                    {
                        remainingPayment -= amountToSettleInPaymCur;
                        this.markTrans(custTransOpen);
                    }
                    else
                    {
                        isExhausted = true;
                        break;
                    }
                }
            }

            // if some payment amount is unsettled, mark it for partial payment
            if (remainingPayment > 0 && isExhausted)
            {
                this.markTrans(custTransOpen);
                this.updatePartialTrans(custTransOpen);
            }
        }

        return isExhausted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipForCreditNoteWithBillingClassification</Name>
				<Source><![CDATA[
    /// <summary>
    /// Skip for credit note with billing classification. 
    /// </summary>
    /// <param name = "_custTrans">The customer transaction.</param>
    /// <param name = "_custTransOpen">The open customer tranaction.</param>
    /// <param name = "_openTransAmount">The open transaction amount.</param>
    /// <param name = "_foundForSettlement">Indicates it is marked for settlement for the remaining amount.</param>
    /// <returns>
    /// True if the credit note should be skipped; otherwise false.
    /// </returns>
    protected boolean skipForCreditNoteWithBillingClassification(CustTrans _custTrans, CustTransOpen _custTransOpen, AmountCur _openTransAmount, boolean _foundForSettlement)
    {
        boolean skipForCreditNoteWithBillingClassification;

        if (this.skipForCreditNote(_custTrans, _custTransOpen, _openTransAmount, _foundForSettlement))
        {
            skipForCreditNoteWithBillingClassification = true;
        }

        return skipForCreditNoteWithBillingClassification;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipForCreditNoteWithoutBillingClassification</Name>
				<Source><![CDATA[
    /// <summary>
    /// Skip for credit note without billing classification.
    /// </summary>
    /// <param name = "_custTrans">The customer transaction.</param>
    /// <param name = "_custTransOpen">The open customer transaction.</param>
    /// <param name = "_openTransAmount">The open transaction amount.</param>
    /// <param name = "_foundForSettlement">Indicates it is marked for settlement for the remaining amount.</param>
    /// <returns>
    /// True if the credit note should be skipped; otherwise false.
    /// </returns>
    protected boolean skipForCreditNoteWithoutBillingClassification(CustTrans _custTrans, CustTransOpen _custTransOpen, AmountCur _openTransAmount, boolean _foundForSettlement)
    {
        boolean skipForCreditNoteWithoutBillingClassification;

        if (_custTrans.CustBillingClassification != 0)
        {
            skipForCreditNoteWithoutBillingClassification = true;
        }
        else if (this.skipForCreditNote(_custTrans, _custTransOpen, _openTransAmount, _foundForSettlement))
        {
            skipForCreditNoteWithoutBillingClassification = true;
        }

        return skipForCreditNoteWithoutBillingClassification;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipForCreditNote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Skip for credit note.
    /// </summary>
    /// <param name = "_custTrans">The customer transaction.</param>
    /// <param name = "_custTransOpen">The open customer transaction.</param>
    /// <param name = "_openTransAmount">The open transaction amount.</param>
    /// <param name = "_foundForSettlement">Indicates it is marked for settlement for the remaining amount.</param>
    /// <returns>
    /// True if the credit note should be skipped; otherwise false.
    /// </returns>
    protected boolean skipForCreditNote(CustTrans _custTrans, CustTransOpen _custTransOpen, AmountCur _openTransAmount, boolean _foundForSettlement)
    {
        boolean skipForCreditNote;

        if (custOpenTransManager.getTransMarked(_custTransOpen) == NoYes::Yes
            || custOpenTransManager.getMarkedPrimaryPayment(_custTransOpen) == NoYes::Yes
            || custOpenTransManager.checkTransFullyMarkedByOtherSpec(_custTransOpen)
            || _openTransAmount < 0
            || _foundForSettlement)
        {
            skipForCreditNote = true;
        }

        return skipForCreditNote;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes an instance of the <c>CustSettlementPriorityProcessing</c> class.
    /// </summary>
    /// <param name="_query">
    /// The query that contains all open transactions.
    /// </param>
    protected void new(Query _query)
    {
        query = _query;
        custParameters = CustParameters::find();

        this.addCustSettlementTransactionPriorityDSToQuery();

        queryRangeGenerator = CustSettlementPriorityProcessingQueryRangeGenerator::construct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQueryBuildDataSource</Name>
				<Source><![CDATA[
    public QueryBuildDataSource parmQueryBuildDataSource(QueryBuildDataSource _qbds = qbds)
    {
        qbds = _qbds;

        return qbds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateMarkedTransactionOpenTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates any transactions marked for credit note restriction as yes from customer open transactions form.
    /// </summary>
    /// <param name = "_custTrans">
    ///     The customer transaction.
    /// </param>
    /// <param name = "_custTransOpen">
    ///     The open customer transaction.
    /// </param>
    /// <param name = "_queryRun">
    ///     An instance of query run object.
    /// </param>
    /// <param name = "_custBillingClassification">
    ///     The customer billing classification.
    /// </param>
    /// <returns>
    ///     true if the transactions marked for credit note restriction; otherwise false.
    /// </returns>
    protected boolean validateMarkedTransactionOpenTrans(
        CustTrans _custTrans,
        CustTransOpen _custTransOpen,
        QueryRun _queryRun,
        CustBillingClassification _custBillingClassification)
    {
        CustTrans custTrans;
        CustTransOpen custTransOpen;
        boolean invoiceFound = false;
        boolean markedInvoiceFound = false;
        boolean ret = true;
        boolean isTransMarkedByOtherSpec;
        CustBillingClassification custBillingClassification;

        isTransMarkedByOtherSpec = custOpenTransManager.checkTransFullyMarkedByOtherSpec(_custTransOpen);

        if (_custBillingClassification && !isTransMarkedByOtherSpec)
        {
            if (_custTrans.AmountCur < 0)
            {
                while (ret && _queryRun.next())
                {
                    custTransOpen = _queryRun.get(tableNum(CustTransOpen));
                    custTrans = _queryRun.get(tableNum(CustTrans));

                    custBillingClassification = CustBillingClassification::find(custTrans.CustBillingClassification);

                    if (!custOpenTransManager.checkTransFullyMarkedByOtherSpec(custTransOpen))
                    {
                        if (custTransOpen.AmountCur > 0)
                        {
                            if (custOpenTransManager.getTransMarked(custTransOpen))
                            {
                                markedInvoiceFound = true;

                                if (_custBillingClassification.RestrictCreditNote == NoYes::Yes
                                    && custTrans.CustBillingClassification != _custBillingClassification.RecId)
                                {
                                    ret = false;
                                }
                            }
                            else if (_custBillingClassification.RecId == custTrans.CustBillingClassification)
                            {
                                invoiceFound = true;
                            }
                        }
                        else if (custTransOpen.RecId != _custTransOpen.RecId
                            && (custBillingClassification.RestrictCreditNote == NoYes::Yes || _custBillingClassification.RestrictCreditNote == NoYes::Yes)
                            && custOpenTransManager.getTransMarked(custTransOpen)
                            && custTrans.CustBillingClassification != _custBillingClassification.RecId)
                        {
                            ret = false;
                        }
                    }
                }

                if (ret
                    && _custBillingClassification.RestrictCreditNote == NoYes::Yes
                    && !markedInvoiceFound
                    && !invoiceFound)
                {
                    ret = false;
                    noInvoiceWithCreditNoteRestriction = true;
                }
            }
            else
            {
                while (ret && _queryRun.next())
                {
                    custTransOpen = _queryRun.get(tableNum(CustTransOpen));
                    custTrans = _queryRun.get(tableNum(CustTrans));

                    custBillingClassification = CustBillingClassification::find(custTrans.CustBillingClassification);

                    if (custBillingClassification.RestrictCreditNote == NoYes::Yes
                        && custTransOpen.AmountCur < 0
                        && custTrans.CustBillingClassification != _custBillingClassification.RecId
                        && custOpenTransManager.getTransMarked(custTransOpen)
                        && custTrans.CustBillingClassification != _custBillingClassification.RecId)
                    {
                        ret = false;
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateMarkedTransactionPaymEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates any transactions marked for credit note restriction as yes from customer payment entry form.
    /// </summary>
    private boolean validateMarkedTransactionPaymEntry(
        CustTrans _custTrans,
        CustTransOpen _custTransOpen,
        QueryRun _queryRun,
        CustBillingClassification _custBillingClassification)
    {
        CustTrans custTrans;
        CustTransOpen custTransOpen;
        boolean invoiceFound = false;
        boolean markedInvoiceFound = false;
        boolean ret = true;
        CustBillingClassification custBillingClassification;

        if (custPaymEntryManager != null)
        {
            // for CustPaymEntry form
            boolean isAlreadyMarked = custPaymEntryManager.isAlreadyFullyMarked(_custTransOpen);

            if (!isAlreadyMarked && _custBillingClassification)
            {
                if (_custTrans.AmountCur < 0)
                {
                    while (ret && _queryRun.next())
                    {
                        custTransOpen = _queryRun.get(tableNum(CustTransOpen));
                        custTrans = _queryRun.get(tableNum(CustTrans));

                        if (custTransOpen.AmountCur > 0)
                        {
                            if (_custBillingClassification.RestrictCreditNote == NoYes::Yes)
                            {
                                if (custPaymEntryManager.isTransMarked(custTransOpen))
                                {
                                    markedInvoiceFound = true;

                                    if (_custBillingClassification.RestrictCreditNote == NoYes::Yes
                                        && custTrans.CustBillingClassification != _custBillingClassification.RecId)
                                    {
                                        ret = false;
                                    }
                                }
                                else if (_custBillingClassification.RecId == custTrans.CustBillingClassification)
                                {
                                    invoiceFound = true;
                                }
                            }
                        }
                        else if ((custBillingClassification.RestrictCreditNote == NoYes::Yes || _custBillingClassification.RestrictCreditNote == NoYes::Yes)
                            && custTransOpen.RecId != _custTransOpen.RecId
                            && custPaymEntryManager.isTransMarked(custTransOpen)
                            && custTrans.CustBillingClassification != _custBillingClassification.RecId)
                        {
                            ret = false;
                        }
                    }

                    if (ret
                        && _custBillingClassification.RestrictCreditNote == NoYes::Yes
                        && !markedInvoiceFound
                        && !invoiceFound)
                    {
                        ret = false;
                        noInvoiceWithCreditNoteRestriction = true;
                    }
                }
                else
                {
                    while (ret && _queryRun.next())
                    {
                        custTransOpen = _queryRun.get(tableNum(CustTransOpen));
                        custTrans = _queryRun.get(tableNum(CustTrans));

                        custBillingClassification = CustBillingClassification::find(custTrans.CustBillingClassification);

                        if (custBillingClassification.RestrictCreditNote == NoYes::Yes
                            && !custPaymEntryManager.isAlreadyFullyMarked(custTransOpen)
                            && custTransOpen.AmountCur < 0
                            && custPaymEntryManager.isTransMarked(custTransOpen)
                            && custTrans.CustBillingClassification != _custBillingClassification.RecId)
                        {
                            ret = false;
                        }
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaymentAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets and retrieves the payment amount.
    /// </summary>
    /// <returns>
    /// The payment amount.
    /// </returns>
    protected AmountCur setPaymentAmount()
    {
        CustTransOpen primaryPayment;
        SpecTrans specTrans;
        Map paymentTransactionsMap;
        MapEnumerator paymentTransactions;

        if (custPaymEntryManager != null)
        {
            paymAmount = custPayment.displayCustPaymAmount();
        }

        if (custOpenTransManager != null)
        {
            paymAmount = abs(custOpenTransManager.getJournalTransAmountDisplayCur());

            if (paymAmount == 0)
            {
                primaryPayment = this.getPrimaryPayment();

                if (primaryPayment)
                {
                    paymentTransactionsMap = specManager.getAllSpecTransMap();
                    paymentTransactions = new MapEnumerator(paymentTransactionsMap);

                    while (paymentTransactions.moveNext())
                    {
                        specTrans = paymentTransactions.currentValue();

                        changecompany(specTrans.company())
                        {
                            if (specTrans.Balance01 < 0)
                            {
                                paymAmount += abs(custOpenTransManager.convertAmountTransCurToAmountPaymCur(specTrans.custTransOpen(), specTrans.Balance01));
                            }
                        }
                    }
                }
            }
        }

        return paymAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unmarkAll</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unmarks all the marked transactions.
    /// </summary>
    public void unmarkAll()
    {
        QueryRun queryRun;
        CustTransOpen custTransOpen;

        queryRun = new QueryRun(query);

        // for CustPaymEntry form
        if (custPaymEntryManager != null)
        {
            while (queryRun.next())
            {
                custTransOpen = queryRun.get(tableNum(CustTransOpen));

                changecompany(custTransOpen.company())
                {
                    if (custPaymEntryManager.isTransMarked(custTransOpen))
                    {
                         custPaymEntryManager.unmarkTrans(custPayment, custTransOpen);
                    }
                }
            }
        }

        // for CustOpenTrans form
        if (custOpenTransManager != null)
        {
            while (queryRun.next())
            {
                custTransOpen = queryRun.get(tableNum(CustTransOpen));

                changecompany(custTransOpen.company())
                {
                    if (custOpenTransManager.getTransMarked(custTransOpen) == NoYes::Yes)
                    {
                        this.updateTransMarked(custTransOpen, false);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unmarkAllTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unmarks all open transactions marked by the current payment.
    /// </summary>
    public void unmarkAllTransactions()
    {
        CustTransOpen custTransOpen;
        CustTransOpen primaryPayment;
        QueryRun queryRun;

        queryRun = new QueryRun(query);

        // For CustPaymEntry (Enter customer payment) form
        if (custPaymEntryManager != null)
        {
            Debug::assert(custOpenTransManager == null);

            while (queryRun.next())
            {
                custTransOpen = queryRun.get(tableNum(CustTransOpen));

                if (custPaymEntryManager.isTransMarked(custTransOpen))
                {
                    custPaymEntryManager.unmarkTrans(custPayment, custTransOpen);
                }
            }
        }

        // For CustOpenTrans (Open Transaction editing) form
        if (custOpenTransManager != null)
        {
            Debug::assert(custPaymEntryManager == null);
            primaryPayment = this.getPrimaryPayment();

            while (queryRun.next())
            {
                custTransOpen = queryRun.get(tableNum(CustTransOpen));

                if (custOpenTransManager.getTransMarked(custTransOpen) == NoYes::Yes && primaryPayment.RecId != custTransOpen.RecId)
                {
                    if (custTransOpen.AmountCur > 0) // if there is a negative marked transaction then do not unmark it.
                    {
                        this.updateTransMarked(custTransOpen, NoYes::No);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMarkedInvoices</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the discount values for the partially marked transactions and adds the marked transaction to the balance tracking.
    /// </summary>
    /// <param name="_accountNum">
    /// The customer account number.
    /// </param>
    private void updateMarkedInvoices(AccountNum _accountNum)
    {
        CustTransOpen custTransOpen;
        CustTransOpenLine custTransOpenLine;
        SpecTrans specTrans;
        CustTrans custTrans;
        CustTransMarkedOpenLine specTransLine;
        CustInvoiceLine custInvoiceLine;
        CustInvoiceTrans custInvoiceTrans;
        CustBillingClassificationCode custBillingClassificationCode;
        CustTable custTable;
        CustVendTrans custVendTrans;
        CustVendTransOpenData custVendTransOpenData;
        CurrencyExchangeHelper localCurrencyHelper;
        CashDiscAmount discAmountToTake;
        CustVendOpenTransBalances balances;
        AmountCur openTransAmount;
        int markedCount;
        NoYes isPartialCashDisc = NoYes::No;

        select custTable
            where custTable.AccountNum == _accountNum;

        balances = CustVendOpenTransBalances::construct(custTable);

        ttsbegin;

        isPartialCashDisc = CustParameters::find().CashDiscForPartialPaym;

        if (custPaymEntryManager)
        {
            while select specTrans
                join custTransOpen
                join custTrans
                where specTrans.RefRecId == custTransOpen.RecId
                    && custTransOpen.RefRecId == custTrans.RecId
                    && custTransOpen.AccountNum == _accountNum
            {
                if (custPaymEntryManager != null)
                {
                    openTransAmount = custPaymEntryManager.getSettleAmount(custTransOpen);

                    if (custPaymEntryManager.isAlreadyFullyMarked(custTransOpen) || openTransAmount < 0)
                    {
                        continue;
                    }
                }

                if (custOpenTransManager != null)
                {
                    openTransAmount = custOpenTransManager.getSettleAmount(custTransOpen);

                    if (custOpenTransManager.getTransMarked(custTransOpen) == NoYes::Yes
                        || custOpenTransManager.getMarkedPrimaryPayment(custTransOpen) == NoYes::Yes
                        || custOpenTransManager.checkTransFullyMarkedByOtherSpec(custTransOpen)
                        || openTransAmount < 0)
                    {
                        continue;
                    }
                }

                custPayment.updateMarkedInvoiceWithTrans(markedCount, custTransOpen, custTrans);
                custPaymEntryManager.addToMarkedTotal(custTransOpen, (specTrans.Balance01));
                specManager.updateTransCache(specTrans);
            }
        }

        while select forupdate Balance01, RefRecId, CashDiscToTake, RefTableId, RefCompany from specTrans
            join RecId, RefRecId, AmountCur, AccountNum from custTransOpen
                where specTrans.RefRecId == custTransOpen.RecId
                    && custTransOpen.AccountNum == _accountNum
            join RecId, TransType, CurrencyCode from custTrans
                where custTransOpen.RefRecId == custTrans.RecId
        {
            AmountCur remainingAmount = specManager.findUnmarkedAmountForRef(
                custTransOpen.AmountCur,
                custTransOpen.company(),
                tableNum(CustTransOpen),
                custTransOpen.RecId);

            if (specTrans.Balance01 + specTrans.CashDiscToTake != remainingAmount)
            {
                if (isPartialCashDisc == NoYes::No)
                {
                    specTrans.CashDiscToTake = 0.0;
                    specTrans.update();

                    update_recordset specTransLine
                        setting CashDiscLineToTake = 0.0
                        where specTransLine.SpecTrans == specTrans.RecId;
                }
                else
                {
                    localCurrencyHelper = CurrencyExchangeHelper::construct();

                    if (custPaymEntryManager)
                    {
                        discAmountToTake = CurrencyExchange::round(((custPaymEntryManager.calculatePartialApplicableCashDiscount(custTransOpen, specTrans.Balance01))), custTrans.CurrencyCode);
                    }
                    else
                    {
                        discAmountToTake = CurrencyExchange::round(((custOpenTransManager.getCashDiscAmountToTake(custTransOpen) / custTransOpen.AmountCur) * (specTrans.Balance01)), custTrans.CurrencyCode);
                        custOpenTransManager.updateSettleAmount(custTransOpen, custOpenTransManager.convertAmountPaymCurToAmountTransCur(custTransOpen, specTrans.Balance01));
                    }

                    while select forupdate RecId, AmountToSettle, CashDiscLineToTake from specTransLine
                        where specTransLine.SpecTrans == specTrans.RecId
                        join RecId, AmountCur, CustInvoiceLineIdRef from custTransOpenLine
                            where custTransOpenLine.RecId == specTransLine.CustTransOpenLine
                                && custTransOpenLine.AmountCur > 0.0
                        join SettlementPriority, CustBillingCode from custBillingClassificationCode
                        join CustInvoiceLineIdRef, SourceDocumentLine from custInvoiceTrans
                            where custInvoiceTrans.CustInvoiceLineIdRef == custTransOpenLine.CustInvoiceLineIdRef
                        join SourceDocumentLine, CustBillingCode from custInvoiceLine
                            order by custBillingClassificationCode.SettlementPriority desc, custTransOpenLine.RecId desc
                            where custInvoiceLine.SourceDocumentLine == custInvoiceTrans.SourceDocumentLine
                                && custInvoiceLine.CustBillingCode == custBillingClassificationCode.CustBillingCode
                    {
                        AmountCur remainingLineAmount = custTransOpenLine.findRemainingAmountCur();

                        if (remainingLineAmount != specTransLine.AmountToSettle + specTransLine.CashDiscLineToTake && specTrans.Balance01 > 0)
                        {
                            specTransLine.CashDiscLineToTake = CurrencyExchange::round(((discAmountToTake / specTrans.Balance01) * (specTransLine.AmountToSettle)), custTrans.CurrencyCode);
                            specTransLine.update();
                        }
                    }

                    if (specTrans.Balance01 > 0)
                    {
                        specManager.deleteAllLine(specTrans.RefCompany, specTrans.RefTableId, specTrans.RefRecId);
                        specManager.insertAllLines(specTrans.RefCompany, specTrans.RefTableId, specTrans.RefRecId, specTrans.RecId, specTrans.Balance01, discAmountToTake);
                    }

                    select sum(CashDiscLineToTake) from specTransLine
                        where specTransLine.SpecTrans == specTrans.RecId
                            && specTransLine.AmountToSettle > 0;

                    specTrans.CashDiscToTake = specTransLine.CashDiscLineToTake;
                    specTrans.update();
                }

                if (custOpenTransManager)
                {
                    //Updates the amount to settle that is associated with the specified open transaction.
                    custOpenTransManager.updateSettleAmount(custTransOpen, custOpenTransManager.convertAmountPaymCurToAmountTransCur(custTransOpen, specTrans.Balance01));
                    // Set up CustVendTransOpenData
                    custVendTransOpenData = CustVendTransOpenData::construct(custTransOpen);

                    // Get posted transaction record
                    custVendTrans = custVendTransOpenData.custVendTrans();

                    // Adds the specified open transaction to the balance tracking
                    balances.markTrans(
                        custTransOpen,
                        custVendTrans,
                        remainingAmount,
                        custOpenTransManager.getCashDiscAmountToTake(custTransOpen),
                        specManager.findByRef(custTransOpen.company(), tableNum(CustTransOpen), custTransOpen.RecId).CrossRate);
                }
            }
            else if (custOpenTransManager)
            {
                //Updates the amount to settle that is associated with the specified open transaction.
                custOpenTransManager.updateSettleAmount(custTransOpen, custOpenTransManager.convertAmountPaymCurToAmountTransCur(custTransOpen, specTrans.Balance01));

                // Set up CustVendTransOpenData
                custVendTransOpenData = CustVendTransOpenData::construct(custTransOpen);

                // Get posted transaction record
                custVendTrans = custVendTransOpenData.custVendTrans();

                // Adds the specified open transaction to the balance tracking
                balances.markTrans(
                    custTransOpen,
                    custVendTrans,
                    remainingAmount,
                    custOpenTransManager.getCashDiscAmountToTake(custTransOpen),
                    specManager.findByRef(custTransOpen.company(), tableNum(CustTransOpen), custTransOpen.RecId).CrossRate);
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePartialTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the settlement amount of the marked transactions.
    /// </summary>
    /// <param name="_custTransOpen">
    /// The open transaction that is marked for partial payment.
    /// </param>
    /// <remarks>
    /// This method uses the <c>CustPaymSettlementManager</c> and <c>CustVendOpenTransManager</c> update
    /// methods.
    /// </remarks>
    protected void updatePartialTrans(CustTransOpen _custTransOpen)
    {
        // checks to see which object is initialized
        // call its appropriate update method
        if (custPaymEntryManager != null)
        {
            custPaymEntryManager.updateSettleAmount(_custTransOpen, custPaymEntryManager.convertPaymAmountCurToTransAmountCur(_custTransOpen, remainingPayment));
        }
        else if (custOpenTransManager != null)
        {
            custOpenTransManager.updateSettleAmount(_custTransOpen, custOpenTransManager.convertAmountPaymCurToAmountTransCur(_custTransOpen, remainingPayment));
        }

        remainingPayment = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryRangeOrderBy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Applies sorting criteria on open transactions.
    /// </summary>
    /// <param name="_fieldId">
    /// The field ID of the field on which to apply sorting criteria.
    /// </param>
    /// <param name="_attributeDirection">
    /// The <c>CustSettlementAttributeDirection</c> value that specifies the direction in which to apply
    /// sorting criteria.
    /// </param>
    public void updateQueryRangeOrderBy(fieldId _fieldId, CustSettlementAttributeDirection _attributeDirection)
    {
        if (_attributeDirection == CustSettlementAttributeDirection::Ascending)
        {
            qbds.addOrderByField(_fieldId, SortOrder::Ascending);
        }
        else
        {
            qbds.addOrderByField(_fieldId, SortOrder::Descending);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransMarked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the marked status of the specified open transaction.
    /// </summary>
    /// <param name="_custTransOpen">
    /// The open transaction for which to update the marked status.
    /// </param>
    /// <param name="_updateTransMarked">
    /// The marked status with which to update the associated open transaction.
    /// </param>
    protected void updateTransMarked(CustTransOpen _custTransOpen, NoYes _updateTransMarked)
    {
        custOpenTransManager.updateTransMarked(_custTransOpen, _updateTransMarked);
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructCustOpenTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>CustSettlementPriorityProcessing</c> class for the
    /// <c>CustOpenTrans</c> form.
    /// </summary>
    /// <param name="_manager">
    /// The <c>CustVendOpenTransManager</c> object.
    /// </param>
    /// <param name="_custTransOpenDS">
    /// The <c>CustTransOpen</c> data source that contains all open transactions.
    /// </param>
    /// <returns>
    /// A new instance of the <c>CustSettlementPriorityProcessing</c> class.
    /// </returns>
    public static CustSettlementPriorityProcessing constructCustOpenTrans(CustVendOpenTransManager _manager, FormDataSource _custTransOpenDS)
    {
        // the query of the FormDataSource is used to create the object
        CustSettlementPriorityProcessing custSettlePriority = CustSettlementPriorityProcessing::construct(new Query(_custTransOpenDS.query()));
        custSettlePriority.initCustTransOpen(_manager);

        return custSettlePriority;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructCustPaymEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>CustSettlementPriorityProcessing</c> class for the
    /// <c>CustPaymEntry</c> form.
    /// </summary>
    /// <param name="_manager">
    /// The <c>CustPaymSettlementManager</c> object.
    /// </param>
    /// <param name="_custPayment">
    /// The <c>LedgerJournalTrans</c> table buffer that contains payment information.
    /// </param>
    /// <param name="_custTransOpenDS">
    /// The <c>CustTransOpen</c> record that contains all open transactions.
    /// </param>
    /// <returns>
    /// A new instance of the <c>CustSettlementPriorityProcessing</c> class.
    /// </returns>
    public static CustSettlementPriorityProcessing constructCustPaymEntry(CustPaymSettlementManager _manager, LedgerJournalTrans _custPayment, FormDataSource _custTransOpenDS)
    {
        // the query of the FormDataSource is used to create the object
        CustSettlementPriorityProcessing custSettlePriority = CustSettlementPriorityProcessing::construct(new Query(_custTransOpenDS.query()));
        custSettlePriority.initCustPaymEntry(_manager, _custPayment);

        return custSettlePriority;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructOffsetVoucherCust</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>CustSettlementPriorityProcessing</c> class for the
    /// <c>OffsetVoucherCust</c> class.
    /// </summary>
    /// <param name="_openTransactionQuery">
    /// The <c>Query</c> class contains all open transactions.
    /// </param>
    /// <param name="_specTransManager">
    /// A <c>SpecTransManager</c> object.
    /// </param>
    /// <returns>
    /// A new instance of the <c>CustSettlementPriorityProcessing</c> class.
    /// </returns>
    public static CustSettlementPriorityProcessing constructOffsetVoucherCust(
        Query _openTransactionQuery,
        SpecTransManager _specTransManager = null)
    {
        CustSettlementPriorityProcessing custSettlePriority = CustSettlementPriorityProcessing::construct(new Query(_openTransactionQuery));

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            custSettlePriority.initOffsetVoucherCust(_openTransactionQuery, _specTransManager);
        }

        return custSettlePriority;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>