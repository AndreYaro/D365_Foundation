<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerJournalTransUpdateCust</Name>
	<SourceCode>
		<Declaration><![CDATA[
class LedgerJournalTransUpdateCust extends LedgerJournalTransUpdate
{
    // <GTE>
    boolean isGTEEnabled = TaxSolutionScopeIntegrationUtil::isCompanyEnabled();
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>bankDepositReversalUpdate</Name>
				<Source><![CDATA[
    // </GTE>

    /// <summary>
    ///    Performs the steps that are required to reverse a deposit slip for a customer.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record to use during the reversal.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The ledger voucher for which to reverse transactions.
    /// </param>
    protected void bankDepositReversalUpdate(LedgerJournalTrans _ledgerJournalTrans, LedgerVoucher _ledgerVoucher)
    {
        CustTrans custTransLocal;
        BankDeposit bankDeposit;
        TaxReverseTax taxReverseTax;
        CompanyId bankDepositCompany;
        // <GIN>
        TaxWithholdReversePost_IN taxWithholdReversePost;
        LedgerJournalTable ledgerJournalTableloc;
        LedgerJournalTrans ledgerJournalTransOrig;
        TaxAmountCur taxWithholdAmountCurInterCompany;
        // </GIN>

        // If there is a value for the offset company, use that company to find the BankDeposit. Otherwise use the primary company.
        bankDepositCompany = (_ledgerJournalTrans.OffsetCompany != '') ? _ledgerJournalTrans.OffsetCompany : _ledgerJournalTrans.Company;

        changecompany(bankDepositCompany)
        {
            bankDeposit = BankDeposit::find(_ledgerJournalTrans.BankChequeDepositTransRefRecID);
        }

        Debug::assert(bankDeposit.RecId != 0);

        select firstonly forupdate custTransLocal
            where custTransLocal.RecId == bankDeposit.RefRecId;

        if (custTransLocal.RecId != 0)
        {
            custTransLocal.CancelledPayment = true;
            custTransLocal.ReasonRefRecId = ReasonTableRef::checkCreateInCompany(_ledgerJournalTrans.ReasonRefRecID, custTransLocal.DataAreaId);
            custTransLocal.update();

            if (custTransLocal.Prepayment == false)
            {
                // <GIN>
                if (BankParameters::checkParameters_IN())
                {
                    if (_ledgerJournalTrans.ledgerJournalTable().JournalType != LedgerJournalType::BankDepositPaymCancel)
                    {
                        taxReverseTax =
                            new TaxReverseTax(_ledgerJournalTrans.Voucher, _ledgerJournalTrans.DocumentDate, _ledgerJournalTrans.Txt);

                        taxReverseTax.calcAndPost(
                                LedgerPostingController::newForLedgerPostingJournal(_ledgerVoucher),
                                custTransLocal.Voucher,
                                _ledgerJournalTrans.DocumentDate,
                                true);
                    }
                }
                else
                {
                    // </GIN>

                    taxReverseTax =
                        new TaxReverseTax(_ledgerJournalTrans.Voucher, _ledgerJournalTrans.DocumentDate, _ledgerJournalTrans.Txt);

                    taxReverseTax.calcAndPost(
                        LedgerPostingController::newForLedgerPostingJournal(_ledgerVoucher),
                        custTransLocal.Voucher,
                        _ledgerJournalTrans.DocumentDate,
                        true);
                    // <GIN>
                }
                // </GIN>
            }
            // <GIN>
            //Execute only for cross company transactions.
            if (TaxWithholdParameters_IN::checkTaxParameters() && BankParameters::checkParameters_IN()
                && _ledgerJournalTrans.Company != _ledgerJournalTrans.OffsetCompany)
            {
                ledgerJournalTableloc = _ledgerJournalTrans.ledgerJournalTable();
                taxWithholdReversePost = new TaxWithholdReversePost_IN(_ledgerJournalTrans.Voucher,
                                                                       _ledgerJournalTrans.DocumentDate,
                                                                       _ledgerJournalTrans.Txt,
                                                                       ledgerJournalTableloc.TableId,
                                                                       ledgerJournalTableloc.RecId);

                taxWithholdReversePost.setReverseTableId(_ledgerJournalTrans.TableId);
                taxWithholdReversePost.setReverseRecId(_ledgerJournalTrans.RecId);
                taxWithholdReversePost.setSource(TaxModuleType::Voucher);

                select firstOnly ledgerJournalTransOrig
                    where ledgerJournalTransOrig.Voucher == custTransLocal.Voucher
                       && ledgerJournalTransOrig.TransDate == custTransLocal.TransDate;

                taxWithholdAmountCurInterCompany = taxWithholdReversePost.calcAndPost(LedgerPostingController::newForLedgerPostingJournal(_ledgerVoucher),
                                                        custTransLocal.Voucher,
                                                        _ledgerJournalTrans.DocumentDate);

                if (ledgerJournalTransOrig.ledgerJournalTransTaxExtensionIN().TDSGroup)
                {
                    _ledgerVoucher.parmAdvancePaymentWHT_IN(taxWithholdAmountCurInterCompany);
                }
            }
            // </GIN>
        }

        this.reverseSettlement(_ledgerJournalTrans, _ledgerVoucher);
        this.setupClosingSettlement(_ledgerJournalTrans, custTransLocal);
    }

]]></Source>
			</Method>
			<Method>
				<Name>check</Name>
				<Source><![CDATA[
    boolean check(LedgerJournalTrans _ledgerJournalTrans,
                  boolean _checkNoSettlement = true,
                  LedgerVoucher _ledgerVoucher = null,
                  LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        CustTable custTable;
        boolean ok = true;

        // <GEERU>
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        LedgerJournalType ledgerJournalType;

        ledgerJournalType = _ledgerJournalTrans.ledgerJournalTable().JournalType;
        custTable = CustTable::findByLedgerDimension(_ledgerJournalTrans.LedgerDimension);

        if (! custTable)
        {
            if (_ledgerPostingMessageCollection)
            {
                ok = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS4730", _ledgerJournalTrans.parmAccount()));
            }
            else
            {
                ok = checkFailed(strFmt("@SYS4730", _ledgerJournalTrans.parmAccount()));
            }
        }
        else
        {
            ok = this.checkVoucher(_ledgerJournalTrans);

            ok = this.checkAccountBlocked(_ledgerJournalTrans, ledgerJournalType, custTable) && ok;

            if (_ledgerJournalTrans.amount() > 0)
            {
                switch (ledgerJournalType)
                {
                    case LedgerJournalType::CustBillOfExchangeDraw ,
                         LedgerJournalType::CustBillOfExchangeProtest,
                         LedgerJournalType::CustBillOfExchangeRedraw,
                         LedgerJournalType::CustPaymRemittance,
                         LedgerJournalType::CustBillOfExchangeSettle :
                        break;

                    default :
                        // <GEERU>
                        if (countryRegion_RU)
                        {
                            ok = CustTable::checkCreditLimit(custTable.AccountNum,
                                                             CustParameters::find().CreditMaxCheck,
                                                             _ledgerJournalTrans.amount(),
                                                             CustParameters::find().CreditLineError == CreditLineErrorType::Warning,
                                                             AgreementHeaderExt_RU::findByAgreementId(_ledgerJournalTrans.AccountAgreementId_RU).RecId,
                                                             _ledgerJournalTrans.TableId,
                                                             _ledgerJournalTrans.RecId
                                                             ) && ok;
                        }
                        else
                        {
                            // </GEERU>
                            ok = CustTable::checkCreditLimit(custTable.AccountNum, CustParameters::find().CreditMaxCheck, _ledgerJournalTrans.amount()) && ok;
                            // <GEERU>
                        }
                    // </GEERU>
                }
            }
        }

        if (ok)
        {
            ok = this.checkSettleVoucher(_ledgerJournalTrans, _checkNoSettlement, _ledgerPostingMessageCollection);
            ok = this.checkCashDiscCodeAmount(_ledgerJournalTrans, _ledgerPostingMessageCollection) && ok;
            ok = this.checkPrepayment(_ledgerJournalTrans, _ledgerPostingMessageCollection) && ok;
            ok = super(_ledgerJournalTrans, _checkNoSettlement, _ledgerVoucher, _ledgerPostingMessageCollection) && ok;
        }

        // <GEERU>
        if (countryRegion_RU)
        {
            ok = this.checkPrepayments_W(_ledgerJournalTrans, CustParameters::find().TaxOnPrepayment, _ledgerPostingMessageCollection) && ok;
        }
        // </GEERU>

        if (TradeBLWIParameters::isBLWIFeatureEnabled())
        {
            ok = this.checkCentralBankPurposeCode_BE(ledgerJournalType, _ledgerJournalTrans, custTable) && ok;
        }

        if (CashRegisterProcessingBase::isEnabledLedgerJournal(_ledgerJournalTrans.orig()))
        {
            CashRegisterTerminalRecId_W terminalRecId = _ledgerJournalTrans.ledgerJournalTrans_W().CashRegisterTerminal;
            CashRegisterTerminal_W terminal = CashRegisterTerminal_W::find(terminalRecId);
            CashRegisterProcessingBase cashRegisterProcessing = CashRegisterProcessingBase::construct(terminalRecId);
            cashRegisterProcessing.withLedgerJournalTrans(_ledgerJournalTrans)
                .cashRegisterTerminal(terminal)
                .validate();
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCentralBankPurposeCode_BE</Name>
				<Source><![CDATA[
    private boolean checkCentralBankPurposeCode_BE(LedgerJournalType _ledgerJournalType, LedgerJournalTrans _ledgerJournalTrans, CustTable _custTable)
    {
        boolean ret = true;

        if (_ledgerJournalType == LedgerJournalType::Daily)
        {
            ret = TradeBLWIParameters::checkBLWI(_ledgerJournalTrans.RecId, TradeBLWITypeOfForm::LedgerJournalTrans, _custTable);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournalsTransDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the ledger journal transactions for one voucher number and several transaction dates.
    /// </summary>
    /// <param name="_ledgerJournalType">
    ///    The journal type of the transactions to validate.
    /// </param>
    /// <param name="_ledgerJournalName">
    ///    The journal name of the transactions to validate.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher of the transactions to validate.
    /// </param>
    /// <param name="_transDate">
    ///    The transaction date of the transactions to validate.
    /// </param>
    /// <param name="_ledgerPostingMessageCollection">
    ///    The posting messages collection; optional.
    /// </param>
    /// <returns>
    ///    true if validation passes; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method is specific to the validation of ledger journal transactions and is only used when the
    ///    parameter validation on bill of exchange journals is marked in the customer parameters form.
    /// </remarks>
    public boolean checkJournalsTransDate(
        LedgerJournalType _ledgerJournalType,
        LedgerJournalNameId _ledgerJournalName,
        Voucher _voucher,
        TransDate _transDate,
        LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        boolean ok = true;
        LedgerJournalTrans ledgerJournalTrans;

        if (CustParameters::find().BillsJournalsValidations
            && LedgerJournalName::find(_ledgerJournalName).NewVoucher == NewVoucher::OneVoucher
            && (_ledgerJournalType == LedgerJournalType::CustBillOfExchangeAccept
            || _ledgerJournalType == LedgerJournalType::CustBillOfExchangeDraw
            || _ledgerJournalType == LedgerJournalType::CustBillOfExchangeProtest
            || _ledgerJournalType == LedgerJournalType::CustBillOfExchangeRedraw
            || _ledgerJournalType == LedgerJournalType::CustPaymRemittance
            || _ledgerJournalType == LedgerJournalType::CustPayment
            || _ledgerJournalType == LedgerJournalType::CustBillOfExchangeSettle))
        {
            select firstonly RecId from ledgerJournalTrans
                where ledgerJournalTrans.Voucher == _voucher
                   && ledgerJournalTrans.TransDate != _transDate;

            if (ledgerJournalTrans)
            {
                if (_ledgerPostingMessageCollection)
                {
                    ok = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS116346", _voucher));
                }
                else
                {
                    ok = checkFailed(strFmt("@SYS116346", _voucher));
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPaymentStatusNotEqualToNone</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the payment status value for the given <c>LedgerJournalTrans</c> record is not equal to None.
    /// </summary>
    /// <param name = "_ledgterJournalTrans">The <c>LedgerJournalTrans</c> record.</param>
    /// <returns>true if the payment status is None; otherwise, false.</returns>
    protected boolean isPaymentStatusNotEqualToNone(LedgerJournalTrans _ledgerJournalTrans)
    {
        return _ledgerJournalTrans.PaymentStatus != CustVendPaymStatus::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPaymStatus</Name>
				<Source><![CDATA[
    public boolean checkPaymStatus(
        LedgerJournalType _ledgerJournalType,
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        boolean ok = true;
        CustVendPaymStatus paymStatus;
        selectableDataArea journalTransCompany = _ledgerJournalTrans.company();

        if ((_ledgerJournalType == LedgerJournalType::CustPayment ||
             _ledgerJournalType == LedgerJournalType::CustBillOfExchangeDraw ||
             _ledgerJournalType == LedgerJournalType::CustPaymRemittance) &&
             _ledgerJournalTrans.PaymMode)
        {
            changecompany (journalTransCompany)
            {
                paymStatus = CustVendPaymModeTable::findCommon(_ledgerJournalTrans).PaymStatus;
            }

            if (_ledgerJournalType == LedgerJournalType::CustPaymRemittance && this.isPaymentStatusOfNone(_ledgerJournalTrans, paymStatus))
            {
                ok = false;

                if (_ledgerPostingMessageCollection)
                {
                    _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS66070", LedgerJournalTrans::findTmpVoucher(_ledgerJournalTrans.Voucher, tmpVoucherMap),
                        _ledgerJournalTrans.PaymentStatus,
                        CustVendPaymStatus::Sent));
                }
                else
                {
                    checkFailed(strFmt("@SYS66070", LedgerJournalTrans::findTmpVoucher(_ledgerJournalTrans.Voucher, tmpVoucherMap),
                        _ledgerJournalTrans.PaymentStatus,
                        CustVendPaymStatus::Sent));
                }
            }
            else
            {
                changecompany (journalTransCompany)
                {
                    ok = CustVendPaym::checkPaymStatus(ModuleCustVend::Cust, _ledgerJournalTrans.PaymMode, _ledgerJournalTrans.PaymentStatus);
                }

                if (!ok)
                {
                    if (_ledgerPostingMessageCollection)
                    {
                        _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS66070", LedgerJournalTrans::findTmpVoucher(_ledgerJournalTrans.Voucher, tmpVoucherMap),
                            _ledgerJournalTrans.PaymentStatus,
                            paymStatus));
                    }
                    else
                    {
                        checkFailed(strFmt("@SYS66070", LedgerJournalTrans::findTmpVoucher(_ledgerJournalTrans.Voucher, tmpVoucherMap),
                            _ledgerJournalTrans.PaymentStatus,
                            paymStatus));
                    }
                }

                if (_ledgerJournalType == LedgerJournalType::CustPayment
                    && CustPaymModeTable::findByCompany(journalTransCompany, _ledgerJournalTrans.PaymMode).IsSEPA)
                {
                    if (!this.isPaymentStatusNotEqualToNone(_ledgerJournalTrans))
                    {
                        if (_ledgerPostingMessageCollection)
                        {
                            _ledgerPostingMessageCollection.logCheckFailed("@SYS4002642");
                        }
                        else
                        {
                            checkFailed("@SYS4002642");
                        }
                        ok = false;
                    }
                }
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPrepayment</Name>
				<Source><![CDATA[
    boolean checkPrepayment(LedgerJournalTrans _ledgerJournalTrans, LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        boolean ok = true;

        if (_ledgerJournalTrans.Prepayment &&
            CustParameters::find().TaxOnPrepayment)
        {
            if (!_ledgerJournalTrans.ledgerJournalTable().LedgerJournalInclTax)
            {
                if (_ledgerPostingMessageCollection)
                {
                    ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS98399");
                }
                else
                {
                    ok = checkFailed("@SYS98399");
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSettleVoucher</Name>
				<Source><![CDATA[
    public boolean checkSettleVoucher(
        LedgerJournalTrans _ledgerJournalTrans,
        boolean _checkNoSettlement = true,
        LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        SpecTransManager specTransManager;
        CustTable journalTransCustomer;
        SpecTrans specTrans;
        CustTrans custTrans;
        CustTransOpen custTransOpen;
        CustTable custTransCustomer;
        AmountCur totalMarkedAmount;
        LedgerJournalTable ledgerJournalTable = _ledgerJournalTrans.ledgerJournalTable();
        ExchangeRateHelper exchangeRateHelper;

        // Initialize the SpecTransManager for the journal transaction
        specTransManager = SpecTransManager::newFromSpec(_ledgerJournalTrans);

        if (_ledgerJournalTrans.SettleVoucher == SettlementType::None && _checkNoSettlement)
        {
            // Journal transaction is designated as having no marked transactions
            if (specTransManager.getSpecTransCount() > 0)
            {
                // There is a mismatch between the transactions marked and journal transaction setting
                if (_ledgerPostingMessageCollection)
                {
                    return _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS55516", _ledgerJournalTrans.parmAccount(), _ledgerJournalTrans.Voucher));
                }
                else
                {
                    return checkFailed(strFmt("@SYS55516", _ledgerJournalTrans.parmAccount(), _ledgerJournalTrans.Voucher));
                }
            }
        }
        else if (_ledgerJournalTrans.SettleVoucher == SettlementType::SelectedTransact)
        {
            // Journal transaction is designated as having marked transactions
            if (specTransManager.getSpecTransCount() <= 0)
            {
                // There is a mismatch between the transactions marked and journal transaction setting
                if (_ledgerPostingMessageCollection)
                {
                    return _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS55517", _ledgerJournalTrans.parmAccount(), _ledgerJournalTrans.Voucher));
                }
                else
                {
                    return checkFailed(strFmt("@SYS55517", _ledgerJournalTrans.parmAccount(), _ledgerJournalTrans.Voucher));
                }
            }
        }

        if (_ledgerJournalTrans.SettleVoucher != SettlementType::None &&
            ledgerJournalTable.ProtestSettledBill == NoYes::No &&
            (ledgerJournalTable.JournalType != LedgerJournalType::BankChequeReversal &&
             ledgerJournalTable.JournalType != LedgerJournalType::BankDepositPaymCancel))
        {
            // Get the customer from the journal transaction to compare with the customer from the marked transaction
            changecompany(_ledgerJournalTrans.Company)
            {
                journalTransCustomer = CustTable::findByLedgerDimension(_ledgerJournalTrans.LedgerDimension);
            }

            // Validate the individual marked transactions
            while select crossCompany Balance01 from specTrans
                where specTrans.SpecCompany == _ledgerJournalTrans.company() &&
                    specTrans.SpecTableId == _ledgerJournalTrans.TableId &&
                    specTrans.SpecRecId == _ledgerJournalTrans.RecId
                join AmountCur from custTransOpen
                    where specTrans.RefCompany == custTransOpen.DataAreaId &&
                        specTrans.RefTableId == custTransOpen.TableId &&
                        specTrans.RefRecId == custTransOpen.RecId
                join RecId, Voucher, AccountNum, Approved, Closed from custTrans
                    where custTransOpen.RefRecId == custTrans.RecId
                join Party from custTransCustomer
                    where custTrans.AccountNum == custTransCustomer.AccountNum
            {
                if (custTrans.RecId == 0)
                {
                    // No CustTrans was found for the SpecTrans
                    if (_ledgerPostingMessageCollection)
                    {
                        return _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS19285", _ledgerJournalTrans.parmAccount(), custTrans.Voucher));
                    }
                    else
                    {
                        return checkFailed(strFmt("@SYS19285", _ledgerJournalTrans.parmAccount(), custTrans.Voucher));
                    }
                }
                else
                {
                    if (custTrans.AccountNum != _ledgerJournalTrans.parmAccount() &&
                        !isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvInterCompanyAccounting)))
                    {
                        // The account numbers for the CustTrans and LedgerJournalTrans don't match & intercompany accounting is not enabled
                        if (_ledgerPostingMessageCollection)
                        {
                            return _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS19285", _ledgerJournalTrans.parmAccount(), custTrans.Voucher));
                        }
                        else
                        {
                            return checkFailed(strFmt("@SYS19285", _ledgerJournalTrans.parmAccount(), custTrans.Voucher));
                        }
                    }

                    if (journalTransCustomer.Party != custTransCustomer.Party)
                    {
                        // The customers do no share the same PartyId
                        if (_ledgerPostingMessageCollection)
                        {
                            return _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS115976",
                                _ledgerJournalTrans.parmAccount(),
                                _ledgerJournalTrans.Company,
                                custTrans.AccountNum,
                                custTrans.company()));
                        }
                        else
                        {
                            return checkFailed(strFmt("@SYS115976",
                                _ledgerJournalTrans.parmAccount(),
                                _ledgerJournalTrans.Company,
                                custTrans.AccountNum,
                                custTrans.company()));
                        }
                    }

                    if (!custTrans.Approved)
                    {
                        if (_ledgerPostingMessageCollection)
                        {
                            return _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS18654", _ledgerJournalTrans.parmAccount(), custTrans.Voucher));
                        }
                        else
                        {
                            return checkFailed(strFmt("@SYS18654", _ledgerJournalTrans.parmAccount(), custTrans.Voucher));
                        }
                    }

                    if (custTrans.Closed)
                    {
                        if (_ledgerPostingMessageCollection)
                        {
                            return _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS18655", _ledgerJournalTrans.parmAccount(), custTrans.Voucher));
                        }
                        else
                        {
                            return checkFailed(strFmt("@SYS18655", _ledgerJournalTrans.parmAccount(), custTrans.Voucher));
                        }
                    }

                    if (ledgerJournalTable.JournalType == LedgerJournalType::CustPaymRemittance &&
                        specTrans.Balance01 != custTransOpen.AmountCur)
                    {
                        // Each marked transaction must be fully settled
                        if (_ledgerPostingMessageCollection)
                        {
                            return _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS73854", ledgerJournalTable.JournalType));
                        }
                        else
                        {
                            return checkFailed(strFmt("@SYS73854", ledgerJournalTable.JournalType));
                        }
                    }
                }
            }

            // Validate the marked transactions overall
            if (ledgerJournalTable.JournalType == LedgerJournalType::CustPaymRemittance && specTransManager.getSpecTransCount() > 0 ||
                this.isSEPATrans(_ledgerJournalTrans))
            {
                exchangeRateHelper = ExchangeRateHelper::newCurrency(Ledger::primaryLedger(CompanyInfo::findDataArea(_ledgerJournalTrans.Company).RecId), _ledgerJournalTrans.CurrencyCode);

                // Get the total amount of the transactions marked for this journal transaction
                totalMarkedAmount = SpecTransManager::getTotalSettleAmountForSpecReference(
                                        _ledgerJournalTrans.company(),
                                        _ledgerJournalTrans.TableId,
                                        _ledgerJournalTrans.RecId,
                                        _ledgerJournalTrans.CurrencyCode,
                                        _ledgerJournalTrans.Company,
                                        _ledgerJournalTrans.TransDate,
                                        exchangeRateHelper.prepareExchangeRateForStorage(_ledgerJournalTrans.crossrate()));

                if ( _ledgerJournalTrans.amount() != -totalMarkedAmount)
                {
                    // The journal transaction must fully settle all the marked transactions
                    if (_ledgerPostingMessageCollection)
                    {
                        return _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS73854", ledgerJournalTable.JournalType));
                    }
                    else
                    {
                        return checkFailed(strFmt("@SYS73854", ledgerJournalTable.JournalType));
                    }
                }
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that a voucher series on a specific ledger journal transaction line only contains a
    ///    reference to a single customer.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The specific ledger journal transaction line.
    /// </param>
    /// <param name="_ledgerPostingMessageCollection">
    ///    The posting messages collection; optional.
    /// </param>
    /// <returns>
    ///    true if validation passes; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method is specific to the validation of ledger journal transactions and is only used when the
    ///    transaction line also contains an invoice number.
    /// </remarks>
    public boolean checkVoucher(LedgerJournalTrans _ledgerJournalTrans, LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        boolean ok = true;
        LedgerJournalTrans ledgerJournalTrans;

        //
        //  The following rule should only be applied when the invoice number field contains a value.
        //  When "Customer" type is used on any Ledger Journal Transaction it can only
        //  exist once per "Voucher" series.
        //
        //  Since a "Customer" type can be applied to either the primary or offset side
        //  of a transaction. This is both a qualifying factor and additional data to be
        //  validated. Although this only applies to "Daily" (GL) based journals it
        //  should not affect this validation.
        //
        //  The exclusion of the "Fee" type transaction allows for an
        //  LedgerTransType::Fee transaction for a customer to be posted inside
        //  the same voucher grouping.
        //
        if (_ledgerJournalTrans.Invoice)
        {
            // Company context for this validation must the journal's company ID.
            changecompany(_ledgerJournalTrans.company())
            {
                ledgerJournalTrans.selectLocked(false);
                select
                    count(RecId)
                from
                    ledgerJournalTrans
                where
                    ledgerJournalTrans.Voucher == _ledgerJournalTrans.Voucher &&
                    ledgerJournalTrans.JournalNum == _ledgerJournalTrans.JournalNum &&
                    ledgerJournalTrans.TransactionType != LedgerTransType::Fee &&
                    (ledgerJournalTrans.AccountType == LedgerJournalACType::Cust ||
                    (ledgerJournalTrans.OffsetLedgerDimension != 0 &&
                     ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust));

                if (ledgerJournalTrans.RecId > 1)
                {
                    if (_ledgerPostingMessageCollection)
                    {
                        ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS112320");
                    }
                    else
                    {
                        ok = checkFailed("@SYS112320");
                    }
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAccountBlocked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the customer account is blocked.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The journal line containing the amount to check for.</param>
    /// <param name = "_ledgerJournalType">The type of journal.</param>
    /// <param name = "_custTable">The customer to check.</param>
    /// <returns>True if the validation passed; false otherwise.</returns>
    protected boolean checkAccountBlocked(LedgerJournalTrans _ledgerJournalTrans, LedgerJournalType _ledgerJournalType, CustTable _custTable)
    {
        boolean ok;

        if (_ledgerJournalTrans.amount() > 0 &&
                LedgerJournalName::isNegotiableInstrumentJournal(_ledgerJournalType))
        {
            AmountCur checkBlockAmount = 0;
            ok = _custTable.checkAccountBlocked(checkBlockAmount);
        }
        else
        {
            ok = _custTable.checkAccountBlocked(_ledgerJournalTrans.amount());
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWhenPost</Name>
				<Source><![CDATA[
    boolean checkWhenPost(LedgerJournalTrans _ledgerJournalTrans,
                          LedgerJournalTrans _originalLedgerJournalTrans,
                          boolean _checkNoSettlement = true,
                          LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        CustTable custTableFieldList;
        boolean ok = true;
        LedgerJournalTable ledgerJournalTable = _ledgerJournalTrans.ledgerJournalTable();
        boolean checkNoSettlement = _checkNoSettlement;

        select firstonly AccountNum, Blocked from custTableFieldList
            where custTableFieldList.AccountNum == _ledgerJournalTrans.parmAccount();

        if (! custTableFieldList)
        {
            if (_ledgerPostingMessageCollection)
            {
                ok = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS4730", _ledgerJournalTrans.parmAccount()));
            }
            else
            {
                ok = checkFailed(strFmt("@SYS4730", _ledgerJournalTrans.parmAccount()));
            }
        }
        else
        {
            ok = this.checkVoucher(_ledgerJournalTrans);

            ok = this.checkAccountBlocked(_ledgerJournalTrans, ledgerJournalTable.JournalType, custTableFieldList) && ok;

            /* Credit limit will be checked later by method updateNow(..)
            if (ledgerJournalTrans.amount() > 0)
            {
                switch (ledgerJournalType)
                {
                    case ledgerJournalType::CustBillOfExchangeDraw,
                         ledgerJournalType::CustBillOfExchangeProtest,
                         ledgerJournalType::CustBillOfExchangeRedraw,
                         ledgerJournalType::CustPaymRemittance,
                         ledgerJournalType::CustBillOfExchangeSettle :
                        break;
                    default :
                        ok = custTable::checkCreditLimit(custTable.accountNum, custParameters::find().creditMaxCheck, ledgerJournalTrans.amount()) && ok;
                }
            }*/
        }

        ok = this.checkPaymStatus(ledgerJournalTable.JournalType, _ledgerJournalTrans) && ok;

        if (ok)
        {
            if (ledgerJournalTable.JournalType == LedgerJournalType::CustBillOfExchangeProtest &&
                ledgerJournalTable.ProtestSettledBill == NoYes::Yes)
            {
                checkNoSettlement = false;
            }

            ok = this.checkSettleVoucher(_ledgerJournalTrans, checkNoSettlement);
            ok = this.checkCashDiscCodeAmount(_ledgerJournalTrans) && ok;
            ok = this.checkPrepayment(_ledgerJournalTrans) && ok;
            ok = super(_ledgerJournalTrans, _originalLedgerJournalTrans, checkNoSettlement, _ledgerPostingMessageCollection) && ok;
        }

        ok = ok && this.checkJournalsTransDate(ledgerJournalTable.JournalType, ledgerJournalTable.JournalName, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.TransDate);

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            ok = this.checkPrepayments_W(_ledgerJournalTrans, CustParameters::find().TaxOnPrepayment) && ok;
        }
        // </GEERU>

        if (TradeBLWIParameters::isBLWIFeatureEnabled())
        {
            ok = this.checkCentralBankPurposeCode_BE(ledgerJournalTable.JournalType, _ledgerJournalTrans, CustTable::findByLedgerDimension(_ledgerJournalTrans.LedgerDimension)) && ok;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>chequeReversalUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs the steps that are required to reverse a check for a customer.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record to use during the reversal.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The ledger voucher for which to reverse transactions.
    /// </param>
    protected void chequeReversalUpdate(LedgerJournalTrans _ledgerJournalTrans, LedgerVoucher _ledgerVoucher)
    {
        CustTrans custTransLocal;

        select firstonly forupdate custTransLocal
            where custTransLocal.RecId == _ledgerJournalTrans.BankChequeDepositTransRefRecID;

        Debug::assert(custTransLocal.RecId != 0);

        custTransLocal.ReasonRefRecId = ReasonTableRef::checkCreateInCompany(_ledgerJournalTrans.ReasonRefRecID, custTransLocal.DataAreaId);
        custTransLocal.update();

        LedgerJournalTrans::revertBankChequeNum(custTransLocal.TransDate, custTransLocal.Voucher, _ledgerJournalTrans.BankChequeNum, _ledgerJournalTrans.JournalNum);

        this.reverseSettlement(_ledgerJournalTrans, _ledgerVoucher);
        this.setupClosingSettlement(_ledgerJournalTrans, custTransLocal);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxEntryInPaymentCompany_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates voucher entries in payment company
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    _ledgerJournalTrans buffer created either by settlement or through advance payment
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    _ledgerVoucher object to which transactions are added.
    /// </param>
    /// <returns>
    ///    The total withholding tax amount for entire transaction.
    /// </returns>
    protected AmountCur createTaxEntryInPaymentCompany_IN(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerVoucher _ledgerVoucher)
    {
        AmountCur totalWHT;
        AmountCur backWardAmount;
        LedgerInterCompany interCompany;
        CurrencyExchangeHelper currencyExchHelper;
        LedgerVoucherObject ledgerVoucherObject;
        LedgerJournalTrans ledgerJournalTransLoc;

        ledgerJournalTransLoc = LedgerJournalTrans::findRecId(_ledgerJournalTrans.RecId, false);

        totalWHT = taxVoucherService.taxWithholdAmountForCustType_IN(ledgerJournalTransLoc, true);

        if (ledgerJournalTransLoc.SettleVoucher != SettlementType::SelectedTransact
            && ledgerJournalTransLoc.ledgerJournalTransTaxExtensionIN().tcsGroup)
        {
            backWardAmount = -totalWHT;
        }

        ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();

        currencyExchHelper = CurrencyExchangeHelper::newExchangeDate(
            Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
            ledgerVoucherObject.parmAccountingDate());

        interCompany = TaxWithholdCalculation_IN::findLedgerInterCompany(ledgerJournalTransLoc.OffsetCompany, ledgerJournalTransLoc.Company);

        if (totalWHT)
        {
            _ledgerVoucher.addTrans(LedgerVoucherTransObject::newTransactionAmountDefault(
                ledgerVoucherObject,
                LedgerPostingType::InterCompany,
                LedgerDimensionFacade::serviceCreateLedgerDimension(interCompany.OriginatingCreditLedgerDimension, _ledgerJournalTrans.DefaultDimension),
                _ledgerJournalTrans.CurrencyCode,
                totalWHT,
                currencyExchHelper));
        }

        _ledgerVoucher.parmBackWardAmountWHT_IN(backWardAmount);

        return backWardAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount ledgerDimension(LedgerJournalTrans _journalTrans)
    {
        return CustLedgerAccounts::summaryLedgerDimension(_journalTrans.parmAccount(), _journalTrans.PostingProfile);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postNewCustomerVoucherDetermineTransRefTypeAndTransRefIdDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to determine the CustTransRefType and TransRefId.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record that is being posted.
    /// </param>
    /// <param name = "_eventHandlerResult">
    /// An <c>EventHandlerResult</c> where a container for the CustTransRefType and the TransRefId can be returned.
    /// </param>
    delegate void postNewCustomerVoucherDetermineTransRefTypeAndTransRefIdDelegate(LedgerJournalTrans _ledgerJournalTrans, EventHandlerResult _eventHandlerResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustomerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Creates a new customer voucher based on a ledger journal transaction table record.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> table record that is being used in the voucher.
    /// </param>
    /// <param name = "_ledgerVoucher">
    /// The ledger voucher being posted.
    /// </param>
    /// <param name = "_originalJournalType">
    /// The journal type of the original journal transaction.
    /// </param>
    /// <param name = "_ledgerJournalType">
    /// The ledger journal type of the journal transaction.
    /// </param>
    /// <returns>
    ///  A newly created <c>CustVoucher</c> object.
    /// </returns>
    protected CustVoucher createCustomerVoucher(LedgerJournalTrans _ledgerJournalTrans, LedgerVoucher _ledgerVoucher, LedgerJournalType _originalJournalType, LedgerJournalType _ledgerJournalType)
    {
        CustTransRefType    transRefType;
        Num                 transRefId;
        LedgerJournalTrans  ledgerJournalTransOrig;
        CustVoucher         custVoucher;

        custVoucher = CustVoucher::newCustVoucherJournal(_ledgerJournalTrans);
        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets
            || _ledgerJournalTrans.orig().AccountType == LedgerJournalACType::FixedAssets)
        {
            LedgerJournalTrans_Asset ledgerJournalTrans_Asset = _ledgerJournalTrans.findLedgerJournalTransAssetSibling();
            if (ledgerJournalTrans_Asset.isDepreciationTransactionType() && ledgerJournalTrans_Asset.amountReportingCurrency())
            {
                custVoucher.parmReportingCurrencyAmount(-ledgerJournalTrans_Asset.amountReportingCurrency());
            }
        }
        //If the payment term option to post offsetting a/r entries is selected
        //then make sure this transaction posts in detail so records are present
        //in the general journal even if the offsetting entries cancel out.
        //This is an Italian legal requirement for their fiscal journal (GFR 11110)
        if (PaymTerm::find(_ledgerJournalTrans.Payment, false).PostOffsettingAR == NoYes::Yes)
        {
            custVoucher.parmLedgerDetailLevel(LedgerDetailLevel::Detail);
        }

        if (_ledgerJournalTrans.TransactionType == LedgerTransType::Payment)
        {
            transRefType = CustTransRefType::Payment;
            transRefId = _ledgerJournalTrans.Voucher;
        }
        else if (_ledgerJournalTrans.TransactionType == LedgerTransType::Fee)
        {
            transRefType = CustTransRefType::Fee;
            transRefId = _ledgerJournalTrans.Voucher;
        }
        else if ((_ledgerJournalTrans.AmountCurDebit - _ledgerJournalTrans.AmountCurCredit) >= 0)
        {
            if (_ledgerJournalTrans.Invoice != '')
            {
                transRefType = CustTransRefType::Invoice;
                transRefId = _ledgerJournalTrans.Invoice;
            }
            else
            {
                transRefType = CustTransRefType::Other;
                transRefId = _ledgerJournalTrans.Voucher;
            }
        }
        else
        {
            if (_ledgerJournalTrans.Invoice != '')
            {
                transRefType = CustTransRefType::CreditNote;
                transRefId = _ledgerJournalTrans.Invoice;
            }
            else
            {
                transRefType = CustTransRefType::Other;
                transRefId = _ledgerJournalTrans.Voucher;
            }
        }

        EventHandlerResult transRefTypeAndTransRefIdEventResult = new EventHandlerResult();
        this.postNewCustomerVoucherDetermineTransRefTypeAndTransRefIdDelegate(_ledgerJournalTrans, transRefTypeAndTransRefIdEventResult);
        if (transRefTypeAndTransRefIdEventResult.hasResult())
        {
            container transRefTypeAndTransRefIdResult = transRefTypeAndTransRefIdEventResult.result();
            transRefType = conPeek(transRefTypeAndTransRefIdResult, 1);
            transRefId = conPeek(transRefTypeAndTransRefIdResult, 2);
        }

        custVoucher.setTransRef(transRefType, transRefId);

        if (!_ledgerJournalTrans.ReverseEntry)
        {
            ledgerJournalTransOrig = LedgerJournalTrans::findByReverse(_ledgerJournalTrans.RecId);
        }

        if (ledgerJournalTransOrig != null && ledgerJournalTransOrig.ReverseEntry)
        {
            custVoucher.parmExchRate(ledgerJournalTransOrig.ExchRate);
            custVoucher.parmExchRateSecondary(ledgerJournalTransOrig.ExchRateSecond);
            custVoucher.parmExchangeRateDate(ledgerJournalTransOrig.TransDate);
        }
        else
        {
            custVoucher.parmExchRate(_ledgerJournalTrans.ExchRate);
            custVoucher.parmExchRateSecondary(_ledgerJournalTrans.ExchRateSecond);
        }

        // For the Bank reversal journals, there is always closing transactions to settle.
        if (_ledgerJournalType == LedgerJournalType::BankChequeReversal ||
            _ledgerJournalType == LedgerJournalType::BankDepositPaymCancel ||
            _originalJournalType == LedgerJournalType::BankChequeReversal ||
            _originalJournalType == LedgerJournalType::BankDepositPaymCancel)
        {
            custVoucher.parmSettlementType(SettlementType::SelectedTransact);
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
        {
            custVoucher.rboParameters(rboCustTrans,rboTransactionId,rboStoreId,rboTerminalId);
        }

        // <GIN>
        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            if (TaxWithholdJournal_IN::validateBankAccount(_ledgerJournalTrans))
            {
                if (TaxWithholdJournal_IN::checkBankAccount(_ledgerJournalTrans))
                {
                    custVoucher.parmTaxWithholdAmount_IN(taxVoucherService.taxWithholdAmountForCustType_IN(_ledgerJournalTrans));
                }
                else
                {
                    custVoucher.parmTaxWithholdBank_IN(taxVoucherService.taxWithholdAmountForCustType_IN(_ledgerJournalTrans));
                }
            }
            else if (_ledgerJournalTrans.SettleVoucher == SettlementType::SelectedTransact)
            {
                LedgerJournalTaxDocument ledgerJournalTaxDocument = LedgerJournalTaxDocument::construct(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.Invoice);
                TaxWithholdJournal_IN taxWithholdJournal = new TaxWithholdJournal_IN(ledgerJournalTaxDocument, false, false, false);
                boolean checkBankStatus = taxWithholdJournal.checkBankStatus(_ledgerJournalTrans);
                custVoucher.parmTaxWithholdBank_IN(taxVoucherService.taxWithholdAmountForCustType_IN(_ledgerJournalTrans));
                custVoucher.parmCheckBank_IN(checkBankStatus);
                _ledgerVoucher.parmCheckBank_IN(checkBankStatus);
            }
            else
            {
                custVoucher.parmTaxWithholdAmount_IN(taxVoucherService.taxWithholdAmountForCustType_IN(_ledgerJournalTrans));
            }

            custVoucher.parmTaxWithholdAmountOriginCur_IN(TaxWithholdJournal_IN::grossAmountCurForJournalLine(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId));
            //Execute only for cross company transactions.
            if (_ledgerJournalTrans.BankChequeDepositTransRefRecID != 0
                && _ledgerJournalTrans.Company != _ledgerJournalTrans.OffsetCompany)
            {
                custVoucher.parmTaxWithholdAmount_IN(-TaxWithholdTrans_IN::taxWithholdAmountCur(TaxWithholdCodeType_IN::TCS, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.TransDate));
                custVoucher.parmTaxWithholdAmountOriginCur_IN(TaxWithholdJournal_IN::grossAmountCurForPostedTrans(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId));
            }
        }
        // </GIN>

        custVoucher.parmCashRegisterTerminalRecId(_ledgerJournalTrans.ledgerJournalTrans_W().CashRegisterTerminal);

        return custVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postNewCustomerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new customer voucher based on a <c>LedgerJournalTrans</c> record, validates, and posts it.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record that is being posted.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The ledger voucher being posted.
    /// </param>
    /// <param name="_originalJournalType">
    ///    The journal type of the original journal transaction.
    /// </param>
    /// <returns>
    ///    A newly created customer transaction record.
    /// </returns>
    protected CustTrans postNewCustomerVoucher(
        LedgerJournalTrans  _ledgerJournalTrans,
        LedgerVoucher       _ledgerVoucher,
        LedgerJournalType   _originalJournalType)
    {
        #ISOCountryRegionCodes
        if (TaxWithholdingGlobalFeature::isExtendedWHTSupportedInCountryRegionOrParamEnabled() || BrazilParameters::isEnabled())
        {
            TaxWithhold_CustPaym::postTaxWithhold(_ledgerVoucher, _ledgerJournalTrans);
        }

        LedgerJournalType   ledgerJournalType = _ledgerJournalTrans.ledgerJournalTable().JournalType;
        CustVoucher         custVoucher = this.createCustomerVoucher(_ledgerJournalTrans, _ledgerVoucher, _originalJournalType, ledgerJournalType);
        CustTrans           custTrans;

        if (custVoucher.validate())
        {
            if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
            {
                // Needed a record to record link between the CustTrans table,
                // LedgerJournalTrans table, and the MCRCustPaymTable table
                custTrans.MCRPaymOrderID = _ledgerJournalTrans.MCRPaymOrderID;
            }
            custVoucher.parmBypassCreditCheck(NoYes::Yes);
            custVoucher.post(_ledgerVoucher, custTrans);
            
            if (CFMParameters::isPaymentRequestsEnabled())
            {
                if (ledgerJournalTransIntercompanyMap && ledgerJournalTransIntercompanyMap.exists(_ledgerJournalTrans.RecId))
                {
                    LedgerJournalTrans prOrigJournalTrans;
    
                    RecId origTransRecId = ledgerJournalTransIntercompanyMap.lookup(_ledgerJournalTrans.RecId);

                    select firstonly crossCompany prOrigJournalTrans
                        where prOrigJournalTrans.RecId == origTransRecId;

                    CFMPaymentRequestPaymentLink::updatePaymentRequestJournalTransPosting(prOrigJournalTrans);
                    CFMPaymentRequestPaymentLink::createReference(CFMPaymentRequestPaymentLink::findPaymentRequestByPaymentSource(prOrigJournalTrans).PaymentRequest, custTrans);
                }
                else
                {
                    CFMPaymentRequestPaymentLink::updatePaymentRequestJournalTransPosting(_ledgerJournalTrans);
                }
            }
            // <GEERU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                if (custTrans.Prepayment)
                {
                    FactureJour_RU factureJour;

                    select firstonly forupdate factureJour
                        where factureJour.FactureId == custTrans.custTrans_W().PrepaymentFactureId_W
                           && factureJour.Module == FactureModule_RU::Cust
                           && factureJour.FactureType == FactureType_RU::Prepayment
                           && factureJour.Voucher == custTrans.Voucher
                           && factureJour.FactureDate == custTrans.TransDate;

                    if (factureJour)
                    {
                        factureJour.OperationTypeCodes = FactureJour_RU::getInitialTypeCodes(factureJour);
                        factureJour.doUpdate();
                    }
                }

                if (RetailParameters::find().ProcessGiftCardsAsPrepayments_RU)
                {
                    RetailGiftCardPayment_RU::setCustTrans(_ledgerJournalTrans.RecId, custTrans);
                }
            }
            // </GEERU>

            if (_ledgerJournalTrans.Invoice)
            {
                TradeBLWIJournalPurposeCodes::createRecordFromJournal(_ledgerJournalTrans.recId,
                TradeBLWITypeOfForm::LedgerJournalTrans,
                custVoucher.parmCustVendInvoiceJour().RecId,
                TradeBLWITypeOfForm::CustInvoiceJour);
            }
            else
            {
                TradeBLWIJournalPurposeCodes::createRecordFromJournal(_ledgerJournalTrans.recId,
                TradeBLWITypeOfForm::LedgerJournalTrans,
                custTrans.RecId,
                TradeBLWITypeOfForm::CustTrans);
            }

            if (_ledgerJournalTrans.TransactionType == LedgerTransType::Payment &&
                EInvoiceCFDIParameters_MX::isElectronicInvoiceEnabled() &&
                EInvoiceCFDIParameters_MX::find().CFDIVersion >= EInvoiceCFDIVersion_MX::V3_3)
            {
                EPaymentPost_MX::construct().processPayment(custTrans);
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceMX00011, funcName());
            }
        }
        else
        {
            this.parmIsVoucherValid(false);
        }

        Docu::copy(_ledgerJournalTrans, custTrans);

        // If a Bank reversal journal type, update the settlement records so they are not reversable.
        if (ledgerJournalType == LedgerJournalType::BankChequeReversal ||
            ledgerJournalType == LedgerJournalType::BankDepositPaymCancel ||
            _originalJournalType == LedgerJournalType::BankChequeReversal ||
            _originalJournalType == LedgerJournalType::BankDepositPaymCancel)
        {
            CustSettlement custSettlement;

            update_recordset custSettlement
                setting CanBeReversed = NoYes::No
                where custSettlement.CanBeReversed == NoYes::Yes &&
                      (custSettlement.TransRecId == custTrans.RecId ||
                      (custSettlement.OffsetRecid == custTrans.RecId &&
                       custSettlement.OffsetCompany == custTrans.company()));
        }

        // <GTE>
        if (isGTEEnabled)
        {
            taxDocumentLedgerVoucherMap = custVoucher.getTaxDocumentLedgerVoucherMap();
        }
        // </GTE>

        return custTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds an instance of the <c>SpecTransManager</c> class and if there are <c>SpecTransManager</c>
    ///    records in the instance, the <c>ReverseTransact</c> method of the <c>CustTrans</c> table is called.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record to use during the reversal.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The ledger voucher for which to reverse transactions.
    /// </param>
    protected void reverseSettlement(LedgerJournalTrans _ledgerJournalTrans, LedgerVoucher _ledgerVoucher)
    {
        SpecTransManager specTransManager;
        CompanyId originalVoucherCompany;

        specTransManager = SpecTransManager::newFromSpec(_ledgerJournalTrans);

        if (specTransManager.getSpecTransCount() > 0)
        {
            originalVoucherCompany = _ledgerVoucher.parmCompanyId();

            // Set the company because reverseTransact requires LedgerVoucher to have the current company context.
            _ledgerVoucher.parmCompanyId(curext());

            // <GEERU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                CustTrans::reverseTransact(_ledgerJournalTrans,
                                           _ledgerVoucher,
                                           SettleDatePrinc::SelectDate,
                                           _ledgerJournalTrans.TransDate,
                                           false);
            }
            else
            {
                // </GEERU>
                CustTrans::reverseTransact(_ledgerJournalTrans,
                                           _ledgerVoucher,
                                           SettleDatePrinc::SelectDate,
                                           _ledgerJournalTrans.TransDate);
                // <GEERU>
            }
            // </GEERU>

            // Restore the original company so that the rest of the posting process is not affected.
            _ledgerVoucher.parmCompanyId(originalVoucherCompany);

            specTransManager.deleteAll();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupClosingSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds records from the <c>CustTransOpen</c> table that corresponds to the passed in
    ///    <c>CustTrans</c> record, and for each record inserts reversal settlement records.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record for the reversal.
    /// </param>
    /// <param name="_custTrans">
    ///    The customer transaction for which to find <c>CustTransOpen</c> records.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    No records from <c>CustTransOpen</c> were found to reverse.
    /// </exception>
    protected void setupClosingSettlement(LedgerJournalTrans _ledgerJournalTrans, CustTrans _custTrans)
    {
        CustTransOpen custTransOpen;
        SpecTransManager specTransManager;
        boolean paymentFound = false;

        specTransManager = SpecTransManager::newFromSpec(_ledgerJournalTrans);

        while select DataAreaId, TableId, RecId, AmountCur from custTransOpen
            where custTransOpen.RefRecId == _custTrans.RecId
        {
            specTransManager.insert(custTransOpen.DataAreaId, custTransOpen.TableId, custTransOpen.RecId, custTransOpen.AmountCur, _custTrans.CurrencyCode);
            paymentFound = true;
        }

        if (paymentFound == false)
        {
            throw error(strFmt("@SYS18598", funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWriteoffAmountPropotionally</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the write-off amount of <c>CustInterestTrans</c> table proportionally.
    /// </summary>
    /// <param name="_custTrans">
    /// The <c>CustTrans</c> record to use.
    /// </param>
    /// <param name="_settlementAmountCur">
    /// The settlement amount to be distributed.
    /// </param>
    /// <remarks>
    /// This method distributes the amount of the write-off to each interest transactions in proportion to the amount of interest on each transaction.
    /// </remarks>
    protected void setWriteoffAmountPropotionally(
        CustTrans _custTrans,
        AmountCur _settlementAmountCur)
    {
        CustInterestJour custInterestJour;
        CustInterestTrans custInterestTrans;
        GeneralJournalEntry generalJournalEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        Percent writoffPercent;

        //Below queries should be modified paralelly to avoid miscalculation.
        select sum(InterestAmount) from custInterestTrans
            where custInterestTrans.AdjustmentStatus == CustInterestAdjustmentStatus::None
            exists join custInterestJour
            where custInterestTrans.InterestNote == custInterestJour.InterestNote &&
                  custInterestJour.AccountNum == _custTrans.AccountNum
                exists join subledgerVoucherGeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.Voucher == _custTrans.Voucher &&
                      subledgerVoucherGeneralJournalEntry.AccountingDate == _custTrans.TransDate &&
                      subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == custInterestTrans.GeneralJournalEntry
                    exists join generalJournalEntry
                    where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry &&
                           generalJournalEntry.Ledger == Ledger::current();

        if (custInterestTrans.InterestAmount)
        {
            // Divide by total interest to get the percentage to write off
            writoffPercent = _settlementAmountCur / custInterestTrans.InterestAmount;

            update_recordset custInterestTrans
                setting WriteOffAmount = custInterestTrans.WriteOffAmount + custInterestTrans.InterestAmount * writoffPercent
                exists join custInterestJour
                where custInterestTrans.InterestNote == custInterestJour.InterestNote &&
                      custInterestJour.AccountNum == _custTrans.AccountNum
                    exists join subledgerVoucherGeneralJournalEntry
                    where subledgerVoucherGeneralJournalEntry.Voucher == _custTrans.Voucher &&
                          subledgerVoucherGeneralJournalEntry.AccountingDate == _custTrans.TransDate &&
                          subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == custInterestTrans.GeneralJournalEntry
                        exists join generalJournalEntry
                        where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry &&
                              generalJournalEntry.Ledger == Ledger::current();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBankBillOfExchangeStatus</Name>
				<Source><![CDATA[
    protected void updateBankBillOfExchangeStatus(LedgerJournalTrans _ledgerJournalTrans)
    {
        BankBillOfExchangeTable bankBillOfExchangeTable;

        if (_ledgerJournalTrans.BankAccountId && _ledgerJournalTrans.BankBillOfExchangeNum)
        {
            bankBillOfExchangeTable = BankBillOfExchangeTable::find(_ledgerJournalTrans.BankAccountId,
                                                                    _ledgerJournalTrans.BankBillOfExchangeNum,
                                                                    true);

            bankBillOfExchangeTable.DocumentStatus = BankBillOfExchangeStatus::Posted;
            bankBillOfExchangeTable.CustBillOfExchangeID = CustTrans::findVoucherDate(_ledgerJournalTrans.Voucher,_ledgerJournalTrans.TransDate).BillOfExchangeID;
            bankBillOfExchangeTable.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInterestNoteWriteOff</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the write-off field of the <c>CustInterestJour</c> table.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record to use.
    /// </param>
    protected void updateInterestNoteWriteOff(LedgerJournalTrans _ledgerJournalTrans)
    {
        CustTrans custTrans;
        CustSettlement custSettlement;
        CustInterestJour custInterestJour;
        CustInterestTrans custInterestTrans;
        CustSettlementLine custSettlementLine;

        while select AccountNum, Voucher, TransDate from custTrans
            where custTrans.AccountNum == _ledgerJournalTrans.parmAccount() &&
                  custTrans.LastSettleVoucher == _ledgerJournalTrans.Voucher
                  join SettleAmountCur from custSettlement
                  where custSettlement.TransCompany == custTrans.DataAreaId &&
                        custSettlement.AccountNum == custTrans.AccountNum &&
                        custSettlement.TransRecId == custTrans.RecId &&
                        custSettlement.OffsetTransVoucher == _ledgerJournalTrans.Voucher
                    outer join forupdate FeeWriteOffAmount, RecId from custInterestJour
                        where custInterestJour.AccountNum == custTrans.AccountNum &&
                               custInterestJour.FeeVoucher == custTrans.Voucher &&
                               custInterestJour.Updated == custTrans.TransDate
        {
            if (custInterestJour)
            {
                custInterestJour.FeeWriteOffAmount += custSettlement.SettleAmountCur;
                custInterestJour.update();
            }
            else
            {
                update_recordset custInterestTrans
                    setting WriteOffAmount = custInterestTrans.WriteOffAmount + custSettlementLine.SettledAmountCur
                    join sum(SettledAmountCur)
                        from custSettlementLine
                        where custSettlementLine.CustSettlement == custSettlement.RecId &&
                              custInterestTrans.CustInvoiceLineIdRef == custSettlementLine.CustInvoiceLineIdRef;

                if (custInterestTrans.RowCount() == 0)
                {
                    this.setWriteoffAmountPropotionally(custTrans, custSettlement.SettleAmountCur);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxAmountGTE</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get tax amount calculated by GTE
    /// </summary>
    /// <param name = "_ledgerJournalTrans">the journal line for which tax is calculated</param>
    /// <returns>tax amount calculated by GTE</returns>
    protected TaxAmount getTaxAmountGTE(LedgerJournalTrans _ledgerJournalTrans)
    {
        // <GTE>
        TaxAmount           taxAmount;
        ITaxableDocument    taxableDocument;
        ITaxDocument        taxDocumentObject;
        ITaxDocumentLine    taxDocumentLineObject;
        TaxAmountCur        inclTaxAmountTotal;
         
        taxableDocument = TaxableDocumentObject::construct(
            TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(_ledgerJournalTrans));
                
        taxDocumentObject = TaxBusinessService::calculateTax(taxableDocument);
        if (taxDocumentObject)
        {
            if (LedgerJournalTrans::isProjectInvoice(_ledgerJournalTrans))
            {
                taxDocumentLineObject = taxDocumentObject.findLineBySource(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId);
                    
                // For project invoice created in multiple lines, Such as
                // Journal line 1: project 001 credit 100(offset account is empty)
                // Journal line 2: customer 1001 debit 20(offset account is empty)
                // Journal line 3: customer 1002 debit 80(offset account is empty)
                // tax is calculated on journal line 2, and 3 and we need to get tax amount of each line other than whole tax document.
                if (taxDocumentLineObject)
                {
                    taxAmount    = taxDocumentLineObject.sumByTaxAccountingProvider(TaxAccountingProvider::Party, TaxAccountingPostingProfileDistributionSide::Debit).amountTransactionCurrency();
                    taxAmount    -= taxDocumentLineObject.sumByTaxAccountingProvider(TaxAccountingProvider::Party, TaxAccountingPostingProfileDistributionSide::Credit).amountTransactionCurrency();
                    inclTaxAmountTotal  = taxDocumentLineObject.getInclTax().amountTransactionCurrency();
                }
                else
                {
                    taxAmount    = 0;
                    inclTaxAmountTotal  = 0;
                }
            }
            else
            {
                if (_ledgerJournalTrans.LedgerDimension == 0 || _ledgerJournalTrans.OffsetLedgerDimension == 0)
                {
                    taxAmount           = taxDocumentObject.sumByTaxAccountingProvider(TaxAccountingProvider::Party, TaxAccountingPostingProfileDistributionSide::Debit).amountTransactionCurrency();
                    taxAmount           -= taxDocumentObject.sumByTaxAccountingProvider(TaxAccountingProvider::Party, TaxAccountingPostingProfileDistributionSide::Credit).amountTransactionCurrency();
                    inclTaxAmountTotal  = taxDocumentObject.getInclTax().amountTransactionCurrency();
                }
                else
                {
                    taxDocumentLineObject   = taxDocumentObject.findLineBySource(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId);
                    if (taxDocumentLineObject)
                    {
                        taxAmount               = taxDocumentLineObject.sumByTaxAccountingProvider(TaxAccountingProvider::Party, TaxAccountingPostingProfileDistributionSide::Debit).amountTransactionCurrency();
                        taxAmount               -= taxDocumentLineObject.sumByTaxAccountingProvider(TaxAccountingProvider::Party, TaxAccountingPostingProfileDistributionSide::Credit).amountTransactionCurrency();
                        inclTaxAmountTotal      = taxDocumentLineObject.getInclTax().amountTransactionCurrency();
                    }
                }
            }
                    
            taxAmount = -taxAmount;
                    
            if ((LedgerJournalTrans::isCustomerInvoice(_ledgerJournalTrans))
                || (LedgerJournalTrans::isCustomerPayment(_ledgerJournalTrans) && _ledgerJournalTrans.OffsetLedgerDimension ==0)
                || LedgerJournalTrans::isProjectInvoice(_ledgerJournalTrans))
            {
                inclTaxAmountTotal = -inclTaxAmountTotal;
            }
                    
            if (inclTaxAmountTotal)
            {
                if (_ledgerJournalTrans.AmountCurCredit)
                {
                    _ledgerJournalTrans.AmountCurCredit -= inclTaxAmountTotal;
                }
                if (_ledgerJournalTrans.AmountCurDebit)
                {
                    _ledgerJournalTrans.AmountCurDebit += inclTaxAmountTotal;
                }
            }
        }
        
        return taxAmount;
        // </GTE>
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNow</Name>
				<Source><![CDATA[
    public void updateNow(
        LedgerVoucher _ledgerVoucher,
        LedgerPostingType _posting,
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerJournalTrans _originalLedgerJournalTrans,
        boolean _interCompany = false,
        boolean _reversalsMayExist = true,
        boolean _isDueToDueFromAccount = false)
    {
        #ISOCountryRegionCodes
        
        AmountCur originalAmountCur;
        TaxAmount taxAmount;
        CustTrans custTrans;
        LedgerVoucherTransObject ledgerVoucherTransObject;

        LedgerJournalTable ledgerJournalTable = _ledgerJournalTrans.ledgerJournalTable();
        LedgerJournalType ledgerJournalType = ledgerJournalTable.JournalType;
        LedgerJournalType originalJournalType = ledgerJournalTable.findOriginalJournalType();

        LedgerJournalTrans_Asset ledgerJournalTrans_Asset = _ledgerJournalTrans.findLedgerJournalTransAssetSibling();
        
        // If asset journal line is not initialized from _ledgerJournalTrans for offset type, this will initialize from original journal line buffer.
        if (!ledgerJournalTrans_Asset && isOffset)
        {
            ledgerJournalTrans_Asset = _ledgerJournalTrans.orig().findLedgerJournalTransAssetSibling();
        }

        ttsbegin;

        // <GIN>
        boolean countryCheckIN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt;

        if (countryCheckIN)
        {
            ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
        }
        // </GIN>

        if (taxVoucherService)
        {
            // <GTE>
            if (isGTEEnabled)
            {
                if (!TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(_ledgerJournalTrans).skipTaxDocument())
                {
                    taxAmount = this.getTaxAmountGTE(_ledgerJournalTrans);
                }
                else
                {
                    taxAmount = 0;
                }
            }
            else
            {
                // </GTE>
                taxAmount = taxVoucherService.taxAmountForVendCustType(_ledgerJournalTrans, _interCompany, _posting, _isDueToDueFromAccount);
                // <GTE>
            }
            // </GTE>

            // <GIN>
            if (TaxParameters::checkTaxParameters_IN()
                && !isGTEEnabled
                && FormulaDesigner_IN::isPriceInclTaxOnLineAmount(_ledgerJournalTrans.TaxItemGroup))
            {
                // Included price is already available in TaxUncommitted.
                if (taxAmount)
                {
                    if (_ledgerJournalTrans.AmountCurCredit)
                    {
                        _ledgerJournalTrans.AmountCurCredit -= taxVoucherService.priceInclTaxAmount_IN(_ledgerJournalTrans);
                    }
                    if (_ledgerJournalTrans.AmountCurDebit)
                    {
                        _ledgerJournalTrans.AmountCurDebit += taxVoucherService.priceInclTaxAmount_IN(_ledgerJournalTrans);
                    }
                }
            }
            if (TaxParameters::isServiceTaxEnable_IN()
                // <GTE>
                && !isGTEEnabled)
                // </GTE>
            {
                if (_ledgerJournalTrans.orig().AccountType == LedgerJournalACType::Bank ||
                    _ledgerJournalTrans.orig().OffsetAccountType == LedgerJournalACType::Bank)
                {
                    taxAmount = 0;
                }
                // For InterCompanyTransaction...
                if (_ledgerJournalTrans.orig().AccountType == LedgerJournalACType::Cust &&
                    _ledgerJournalTrans.orig().OffsetAccountType == LedgerJournalACType::Ledger &&
                    _ledgerJournalTrans.orig().parmAccount() != '' &&
                    _ledgerJournalTrans.orig().parmOffsetAccount() == '' )
                {
                    if (!taxVoucherService.parmIsInterCompanyTrans_IN())
                    {
                        taxAmount = 0;
                    }
                }
            }
            // </GIN>

            // <GEERU>
            if (_ledgerJournalTrans.isNonTaxablePrepayment_RU())
            {
                taxAmount = 0;
            }
            // </GEERU>

            if (_ledgerJournalTrans.AmountCurCredit)
            {
                originalAmountCur = _ledgerJournalTrans.AmountCurCredit;
                _ledgerJournalTrans.AmountCurCredit += taxAmount;
            }
            if (_ledgerJournalTrans.AmountCurDebit)
            {
                originalAmountCur = _ledgerJournalTrans.AmountCurDebit;
                _ledgerJournalTrans.AmountCurDebit -= taxAmount;
            }
        }

        LedgerVoucherObject ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();

        CurrencyExchangeHelper exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), ledgerVoucherObject.parmAccountingDate());
        exchangeRateHelper.parmExchangeRate1(_ledgerJournalTrans.ExchRate);
        exchangeRateHelper.parmExchangeRate2(_ledgerJournalTrans.ExchRateSecond);
        exchangeRateHelper.parmReportingExchangeRate1(_ledgerJournalTrans.ReportingCurrencyExchRate);
        exchangeRateHelper.parmReportingExchangeRate2(_ledgerJournalTrans.ReportingCurrencyExchRateSecondary);

        if (_ledgerJournalTrans.Prepayment
            && (_posting != LedgerPostingType::InterCompany)
            // <GIN>
            && !(countryCheckIN && _ledgerJournalTrans.isTaxTypeApplicable_IN())
           // </GIN>
           )
        {
            if (_originalLedgerJournalTrans.TaxGroup && CustParameters::find().TaxOnPrepayment == NoYes::Yes)
            {
                LedgerDimensionDefaultAccount prepaymentLedgerDimension =
                    CustLedgerAccounts::vatPrepaymentsLedgerDimension(_ledgerJournalTrans.parmAccount(), _ledgerJournalTrans.PostingProfile);

                if (originalAmountCur && !ledgerJournalTable.LedgerJournalInclTax)
                {
                    if (_ledgerJournalTrans.AmountCurCredit)
                    {
                        _ledgerJournalTrans.AmountCurCredit = originalAmountCur;
                    }
                    if (_ledgerJournalTrans.AmountCurDebit)
                    {
                        _ledgerJournalTrans.AmountCurDebit = originalAmountCur;
                    }
                }

                if (!ledgerJournalTable.LedgerJournalInclTax)
                {
                    taxAmount = taxVoucherService.getTransactionalTaxAmountForPrepayment(_ledgerJournalTrans, true);
                }
                else
                {
                    taxAmount = taxVoucherService.getTransactionalTaxAmountForLine(_originalLedgerJournalTrans);
                }

                LedgerDimensionAccount mergedLedgerDimension = this.mergeLedgerDimensionAndDefaultDimension(prepaymentLedgerDimension, _ledgerJournalTrans.DefaultDimension);

                // <GEERU>
                if (_ledgerJournalTrans.isNonTaxablePrepayment_RU())
                {
                    taxAmount = 0;
                }
                // </GEERU>

                ledgerVoucherTransObject = this.initializeLedgerVoucherTransObjectByMergedLedgerDimension(
                    ledgerVoucherObject,
                    LedgerPostingType::CustPayment,
                    mergedLedgerDimension,
                    _ledgerJournalTrans.CurrencyCode,
                    -taxAmount,
                    exchangeRateHelper,
                    _ledgerJournalTrans,
                    ledgerJournalTrans_Asset);

                _ledgerVoucher.addTrans(ledgerVoucherTransObject);
                // <GEERU>
                LedgerBondClient_RU ledgerBondClient = _ledgerVoucher.findLedgerVoucherObject().ledgerBondClient_RU();

                if (ledgerBondClient)
                {
                    if (ledgerBondClient.findVRefByPostingType(LedgerPostingType::Tax))
                    {
                        ledgerBondClient.bondVRef2Log(ledgerBondClient.lastVrefId(), ledgerBondClient.getLogByPostingType(LedgerPostingType::Tax));
                    }
                }
                // </GEERU>
            }
        }

        if (_posting == LedgerPostingType::InterCompany)
        {
            // <GIN>
            AmountCur backWardAmount;

            if (TaxWithholdParameters_IN::checkTaxParameters() && TaxWithholdParameters_IN::find().CrossCompanyPayment && (ledgerJournalTransTaxExt.tdsGroup || ledgerJournalTransTaxExt.tcsGroup))
            {
                backWardAmount = this.createTaxEntryInPaymentCompany_IN(_ledgerJournalTrans, _ledgerVoucher);
            }
            // </GIN>

            // Assume that this is always on account type of ledger
            Debug::assert(_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger);

            ledgerVoucherTransObject = this.initializeInterCompanyLedgerVoucherTransObject(
                ledgerVoucherObject,
                _posting,
                _ledgerJournalTrans,
                _ledgerJournalTrans.amount() + backWardAmount,
                exchangeRateHelper);

            _ledgerVoucher.addTrans(ledgerVoucherTransObject);
        }
        else
        {
            // A bank reversal during cross company posting may not have a journal type
            // of BankDepositPaymCancel or BankChequeReversal. Check to see if the
            // reversal process must still be performed.
            if (ledgerJournalType == LedgerJournalType::BankChequeReversal ||
                originalJournalType == LedgerJournalType::BankChequeReversal)
            {
                this.chequeReversalUpdate(_ledgerJournalTrans, _ledgerVoucher);
            }
            else if (ledgerJournalType == LedgerJournalType::BankDepositPaymCancel ||
                     originalJournalType == LedgerJournalType::BankDepositPaymCancel)
            {
                this.bankDepositReversalUpdate(_ledgerJournalTrans, _ledgerVoucher);
            }

            switch (ledgerJournalType)
            {
                case LedgerJournalType::CustBillOfExchangeProtest,
                     LedgerJournalType::CustBillOfExchangeRedraw,
                     LedgerJournalType::CustPaymRemittance,
                     LedgerJournalType::CustBillOfExchangeSettle,
                     LedgerJournalType::CustBillOfExchangeDraw:

                    CustVendNegInstPost custVendNegInstPost = CustVendNegInstPost::construct(_ledgerJournalTrans, _ledgerVoucher);
                    custVendNegInstPost.post();

                    if (_ledgerJournalTrans.AccountType == _ledgerJournalTrans.OffsetAccountType &&
                        _ledgerJournalTrans.parmAccount() == _ledgerJournalTrans.parmOffsetAccount())
                    {
                        _ledgerJournalTrans.OffsetLedgerDimension = 0;
                    }

                    if (originalJournalType == LedgerJournalType::BankChequeReversal ||
                        originalJournalType == LedgerJournalType::BankDepositPaymCancel)
                    {
                        custTrans = this.postNewCustomerVoucher(_ledgerJournalTrans, _ledgerVoucher, originalJournalType);
                    }

                    break;

                default :
                    if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                    {
                        if (LedgerParameters::find().JournalizingDefinitionEnableValue == NoYes::Yes &&
                             _ledgerJournalTrans.AccountType == LedgerJournalACType::Cust &&
                             _ledgerJournalTrans.ledgerJournalTable().JournalName == CustParameters::find().CollectionsWriteOffLedgerJournalName)
                        {
                            JournalizingDefinitionManagerBank journalizingDefinitionManagerBank = JournalizingDefinitionManager::newJournalizingDefinitionManagerBank(
                                _ledgerJournalTrans.BankAccountId,
                                _ledgerJournalTrans.PaymMode,
                                _ledgerJournalTrans.TransDate,
                                LedgerPostingType::CustSettlement);

                            journalizingDefinitionManagerBank.parmBankTransactionTypes(BankTransactionTypes::AccountsReceivableSettlement);
                            journalizingDefinitionManagerBank.parmJournalizingDefinition(journalizingDefinitionManagerBank.getDefaultJournalizingDefinition());

                            LedgerDimensionAccount mergedLedgerDimensionAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(CustLedgerAccounts::summaryLedgerDimension(_ledgerJournalTrans.accountDisplay()), _ledgerJournalTrans.DefaultDimension);
                            List systemGeneratedEntriesList = journalizingDefinitionManagerBank.getSystemGeneratedEntries(DebitCredit::Debit, mergedLedgerDimensionAccount);
                            ListEnumerator systemGeneratedEntriesListEnumerator = systemGeneratedEntriesList.getEnumerator();

                            JournalizingDefinitionEntry journalizingDefinitionEntry;
                            LedgerVoucherTransObject postingTransaction;
        
                            while (systemGeneratedEntriesListEnumerator.moveNext())
                            {
                                journalizingDefinitionEntry = systemGeneratedEntriesListEnumerator.current();

                                postingTransaction = this.initializeLedgerVoucherTransObjectByJournalizingDefinitionEntry(
                                    _ledgerJournalTrans,
                                    taxAmount,
                                    _reversalsMayExist,
                                    journalizingDefinitionEntry);

                                _ledgerVoucher.addTrans(postingTransaction);
                            }
                        }
                    }

                    custTrans = this.postNewCustomerVoucher(_ledgerJournalTrans, _ledgerVoucher, originalJournalType);
                    // Only set if it is not already set. Handles the case of a customer to customer transaction
                    if (!_ledgerJournalTrans.CustTransId)
                    {
                        _ledgerJournalTrans.CustTransId = custTrans.RecId;
                    }
                    break;
            }

            // <GIN>
            if (TaxWithholdParameters_IN::checkTaxParameters()
                && TaxWithholdParameters_IN::find().CrossCompanyPayment
                && (ledgerJournalTransTaxExt.tdsGroup
                    || ledgerJournalTransTaxExt.tcsGroup))
            {
                CustTrans offsetCustTrans;
                LedgerDimensionAccount dueToLedgerDimension;
                LedgerDimensionAccount ledgerDimensionMerged;
                int sign = 1;

                while select crossCompany offsetCustTrans
                    group by DataAreaId
                    where offsetCustTrans.OffsetRecid == custTrans.Recid
                {
                    if (custTrans.company() != offsetCustTrans.company())
                    {
                        TaxAmountCur withholdTaxCur = _ledgerVoucher.getWHTInvoiceCompanyFromCache_IN(offsetCustTrans.company(), _ledgerVoucher.lastVoucher());

                        if (ledgerJournalTransTaxExt.TDSGroup)
                        {
                            sign = -1;
                        }

                        dueToLedgerDimension = LedgerInterCompany::getDestinationCompanyLedgerDimensionWithAmount(
                            (sign * withholdTaxCur),
                            custTrans.company(),
                            offsetCustTrans.dataAreaId);

                        ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(dueToLedgerDimension);

                        ledgerVoucherTransObject = this.initializeLedgerVoucherTransObjectByDueToLedgerDimension(
                            ledgerVoucherObject,
                            _posting,
                            ledgerDimensionMerged,
                            _ledgerJournalTrans.CurrencyCode,
                            withholdTaxCur,
                            exchangeRateHelper,
                            _ledgerJournalTrans);

                        _ledgerVoucher.addTrans(ledgerVoucherTransObject);
                    }
                }
            }
            // </GIN>
        }

        if (originalAmountCur)
        {
            if (_ledgerJournalTrans.AmountCurCredit)
            {
                _ledgerJournalTrans.AmountCurCredit = originalAmountCur;
            }

            if (_ledgerJournalTrans.AmountCurDebit)
            {
                _ledgerJournalTrans.AmountCurDebit = originalAmountCur;
            }
        }

        if (_posting != LedgerPostingType::InterCompany &&
            ledgerJournalType != LedgerJournalType::CustBillOfExchangeRedraw &&
            ledgerJournalType != LedgerJournalType::CustPaymRemittance &&
            ledgerJournalType != LedgerJournalType::CustBillOfExchangeSettle)
        {
            LedgerJournalTrans localLedgerJournalTrans;

            select firstonly forupdate localLedgerJournalTrans
                where localLedgerJournalTrans.RecId == _ledgerJournalTrans.RecId;

            if (localLedgerJournalTrans)
            {
                localLedgerJournalTrans.CustTransId = _ledgerJournalTrans.CustTransId;
                localLedgerJournalTrans.doUpdate();
            }
        }

        if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets)
        {
            AssetBook::updateCustInfo(_ledgerJournalTrans.parmOffsetAccount(),
                                      ledgerJournalTrans_Asset.BookId,
                                      custTrans.AccountNum,
                                      custTrans.Invoice,
                                      CurrencyExchangeHelper::amountCur2MST(- _ledgerJournalTrans.amount(),
                                                             _ledgerJournalTrans.CurrencyCode,
                                                             0,
                                                             _ledgerJournalTrans.TransDate));

        }
        BankRemittanceFilesCust bankRemittanceFilesCust = BankRemittanceFilesCust::find(_ledgerJournalTrans.BankRemittanceFileId, true);
        if (bankRemittanceFilesCust.RecId)
        {
            bankRemittanceFilesCust.Posted = NoYes::Yes;
            bankRemittanceFilesCust.update();
        }
        this.updateBankBillOfExchangeStatus(_ledgerJournalTrans);

        CustInterestWriteOffUnPostedJournal custInterestWriteOffUnPostedJournal = CustInterestWriteOffUnPostedJournal::findByLedgerJournalTrans(_ledgerJournalTrans.RecId);

        if (custInterestWriteOffUnPostedJournal.RecId)
        {
            this.updateInterestNoteWriteOff(_ledgerJournalTrans);
        }
  
        if (CashRegisterProcessingBase::isEnabledLedgerJournal( _ledgerJournalTrans.orig(), custTrans.PaymMode))
        {
            CashRegisterTerminalRecId_W terminalRecId = _ledgerJournalTrans.ledgerJournalTrans_W().CashRegisterTerminal;
            CashRegisterTerminal_W terminal = CashRegisterTerminal_W::find(terminalRecId);
            ClassId cashRegisterProcessingClassId = CashRegister_W::find(terminal.CashRegister).ProcessingClassId;
            CashRegisterProcessingBase cashRegisterProcessing = CashRegisterProcessingBase::construct(terminalRecId);
            cashRegisterProcessing.newFromPaymentTrans(custTrans)
                .withLedgerJournalTrans(_ledgerJournalTrans)
                .cashRegisterTerminal(terminal)
                .validate()
                .initFiscalTrans();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInterCompanyLedgerVoucherTransObject</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes a new <c>LedgerVoucherTransObject</c> class instance for an intercompany transaction.
    /// </summary>
    /// <param name = "_ledgerVoucherObject">
    ///     The <c>LedgerVoucherObject</c> class instance.
    /// </param>
    /// <param name = "_posting">
    ///     The <c>LedgerPostingType</c> enumeration value.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    ///     The <c>LedgerJournalTrans</c> table buffer.
    /// </param>
    /// <param name = "_amount">
    ///     The amount in the transaction currency.
    /// </param>
    /// <param name = "_exchangeRateHelper">
    ///     The <c>CurrencyExchangeHelper</c> class instance.
    /// </param>
    /// <returns>
    ///     A newly initialized instance of the <c>LedgerVoucherTransObject</c> class.
    /// </returns>
    [Wrappable(true)]
    protected final LedgerVoucherTransObject initializeInterCompanyLedgerVoucherTransObject(
        LedgerVoucherObject _ledgerVoucherObject,
        LedgerPostingType _posting,
        LedgerJournalTrans _ledgerJournalTrans,
        AmountCur _amount,
        CurrencyExchangeHelper _exchangeRateHelper)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
            _ledgerVoucherObject,
            _posting,
            _ledgerJournalTrans.LedgerDimension,
            _ledgerJournalTrans.CurrencyCode,
            _amount,
            _exchangeRateHelper);

        ledgerVoucherTransObject.parmQuantity(_ledgerJournalTrans.Qty);
        ledgerVoucherTransObject.parmTransTxt(_ledgerJournalTrans.Txt);

        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeLedgerVoucherTransObjectByMergedLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes a new instance of the <c>LedgerVoucherTransObject</c> class based on a merged ledger dimension value.
    /// </summary>
    /// <param name = "_defaultLedgerPostingReference">
    ///     The ledger posting reference used for defaulting.
    /// </param>
    /// <param name = "_postingType">
    ///     The posting type of the general journal entry.
    /// </param>
    /// <param name = "_ledgerDimensionId">
    ///     The dimension attribute value combination of the general journal entry.
    /// </param>
    /// <param name = "_transactionCurrencyCode">
    ///     The currency code of the general journal entry.
    /// </param>
    /// <param name = "_transactionCurrencyAmount">
    ///     The amount in the accounting currency.
    /// </param>
    /// <param name="_exchangeRateHelper">
    ///    The accounting currency amount and secondary currency amount exchange rates.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    ///     The current <c>LedgerJournalTrans</c> table buffer.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    ///     The current <c>LedgerJournalTrans_Asset</c> table buffer.
    /// </param>
    /// <returns>
    ///     A newly initialized instance of the <c>LedgerVoucherTransObject</c> class.
    /// </returns>
    [Wrappable(true)]
    protected final LedgerVoucherTransObject initializeLedgerVoucherTransObjectByMergedLedgerDimension(
        LedgerVoucherObject _defaultLedgerPostingReference,
        LedgerPostingType _postingType,
        LedgerDimensionAccount _ledgerDimensionId,
        CurrencyCode _transactionCurrencyCode,
        Money _transactionCurrencyAmount,
        CurrencyExchangeHelper _exchangeRateHelper,
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerJournalTrans_Asset _ledgerJournalTrans_Asset)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
            _defaultLedgerPostingReference,
            _postingType,
            _ledgerDimensionId,
            _transactionCurrencyCode,
            _transactionCurrencyAmount,
            _exchangeRateHelper);

        if (_ledgerJournalTrans_Asset.isDepreciationTransactionType() && _ledgerJournalTrans_Asset.amountReportingCurrency())
        {
            ledgerVoucherTransObject.parmReportingCurrencyAmount(-_ledgerJournalTrans_Asset.amountReportingCurrency());
        }
        ledgerVoucherTransObject.parmSourceTableId(_ledgerJournalTrans.TableId);
        ledgerVoucherTransObject.parmSourceRecId(_ledgerJournalTrans.RecId);
        ledgerVoucherTransObject.parmQuantity(_ledgerJournalTrans.Qty);

        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeLedgerVoucherTransObjectByDueToLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes a new instance of the <c>LedgerVoucherTransObject</c> class based on a due to ledger dimension value.
    /// </summary>
    /// <param name = "_defaultLedgerPostingReference">
    ///     The ledger posting reference used for defaulting.
    /// </param>
    /// <param name = "_postingType">
    ///     The posting type of the general journal entry.
    /// </param>
    /// <param name = "_ledgerDimensionId">
    ///     The dimension attribute value combination of the general journal entry.
    /// </param>
    /// <param name = "_transactionCurrencyCode">
    ///     The currency code of the general journal entry.
    /// </param>
    /// <param name = "_transactionCurrencyAmount">
    ///     The amount in the accounting currency.
    /// </param>
    /// <param name="_exchangeRateHelper">
    ///    The accounting currency amount and secondary currency amount exchange rates.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    ///     The current <c>LedgerJournalTrans</c> table buffer.
    /// </param>
    /// <returns>
    ///     A newly initialized instance of the <c>LedgerVoucherTransObject</c> class.
    /// </returns>
    [Wrappable(true)]
    protected final LedgerVoucherTransObject initializeLedgerVoucherTransObjectByDueToLedgerDimension(
        LedgerVoucherObject _defaultLedgerPostingReference,
        LedgerPostingType _postingType,
        LedgerDimensionAccount _ledgerDimensionId,
        CurrencyCode _transactionCurrencyCode,
        Money _transactionCurrencyAmount,
        CurrencyExchangeHelper _exchangeRateHelper,
        LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
            _defaultLedgerPostingReference,
            _postingType,
            _ledgerDimensionId,
            _transactionCurrencyCode,
            _transactionCurrencyAmount,
            _exchangeRateHelper);

        ledgerVoucherTransObject.parmTaxParentReferenceTableId(_ledgerJournalTrans.TableId);
        ledgerVoucherTransObject.parmTaxParentReferenceRecId(_ledgerJournalTrans.RecId);
        ledgerVoucherTransObject.parmQuantity(_ledgerJournalTrans.Qty);

        ledgerVoucherTransObject.parmTransTxt(_ledgerJournalTrans.Txt);

        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeLedgerVoucherTransObjectByJournalizingDefinitionEntry</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes a new instance of the <c>LedgerVoucherTransObject</c> based on a given <c>JournalizingDefinitionEntry</c> class instance.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    ///     The current <c>LedgerJournalTrans</c> table buffer.
    /// </param>
    /// <param name = "_taxAmount">
    ///     The tax amount;
    /// </param>
    /// <param name = "_reversalsMayExist">
    ///     true if reversals may exist for this <c>LedgerJournalTrans</c> record; otherwise, false.
    /// </param>
    /// <param name = "_journalizingDefinitionEntry">
    ///     The currenct <c>JournalizingDefinitionEntry</c> class instance to use for the initialization.
    /// </param>
    /// <returns>
    ///     A newly initialized instance of the <c>LedgerVoucherTransObject</c> class.
    /// </returns>
    [Wrappable(true)]
    protected final LedgerVoucherTransObject initializeLedgerVoucherTransObjectByJournalizingDefinitionEntry(
        LedgerJournalTrans _ledgerJournalTrans,
        TaxAmount _taxAmount,
        boolean _reversalsMayExist,
        JournalizingDefinitionEntry _journalizingDefinitionEntry)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newTransLedgerJournal(
            _ledgerJournalTrans,
            _taxAmount,
            false,
            this.parmIntercompanyRecIds(),
            _reversalsMayExist);

        ledgerVoucherTransObject.parmLedgerDimensionId(_journalizingDefinitionEntry.parmLedgerDimension());
        
        if (_journalizingDefinitionEntry.parmJournalizingDefinitionDebitCredit() == DebitCredit::Credit)
        {
            ledgerVoucherTransObject.parmTransactionCurrencyAmount(-ledgerVoucherTransObject.parmTransactionCurrencyAmount());
            ledgerVoucherTransObject.parmAccountingCurrencyAmount(-ledgerVoucherTransObject.parmAccountingCurrencyAmount());
            ledgerVoucherTransObject.parmReportingCurrencyAmount(-ledgerVoucherTransObject.parmReportingCurrencyAmount());
        }

        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRelatedToSEPAInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the ledger journal line related to invoice whose payment mode was marked as a SEPA.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal line buffer.
    /// </param>
    /// <returns>
    /// true if the ledger journal line related to invoice whose payment mode was marked as a SEPA; otherwise, false.
    /// </returns>
    protected boolean isRelatedToSEPAInvoice(LedgerJournalTrans _ledgerJournalTrans)
    {
        SpecTrans specTrans;
        CustTransOpen custTransOpen;
        CustTrans custTrans;
        CustPaymModeTable custPaymModeTable;

        select firstonly crossCompany RecId from specTrans
            where specTrans.SpecCompany == _ledgerJournalTrans.company()
                && specTrans.SpecTableId == _ledgerJournalTrans.TableId
                && specTrans.SpecRecId == _ledgerJournalTrans.RecId
        exists join custTransOpen
            where custTransOpen.dataAreaId == specTrans.RefCompany
                && custTransOpen.TableId == specTrans.RefTableId
                && custTransOpen.RecId == specTrans.RefRecId
        exists join custTrans
            where custTrans.RecId == custTransOpen.RefRecId
        exists join custPaymModeTable
            where custPaymModeTable.PaymMode == custTrans.PaymMode
                && custPaymModeTable.IsSEPA
                && custPaymModeTable.dataAreaId == specTrans.RefCompany;

        return specTrans.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSEPATrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the ledger journal line should be processed as part of SEPA functionality.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The ledger journal line buffer.
    /// </param>
    /// <returns>
    /// true if the ledger journal line should be processed as part of SEPA functionality; otherwise, false.
    /// </returns>
    protected boolean isSEPATrans(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTable ledgerJournalTable = _ledgerJournalTrans.ledgerJournalTable();
        CustPaymModeTable custPaymModeTable = CustPaymModeTable::find(_ledgerJournalTrans.PaymMode);

        return (custPaymModeTable.IsSEPA ||
            (ledgerJournalTable.JournalType == LedgerJournalType::CustBillOfExchangeDraw &&
                (custPaymModeTable.IsSEPA || (!_ledgerJournalTrans.PaymMode && this.isRelatedToSEPAInvoice(_ledgerJournalTrans)))));
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>