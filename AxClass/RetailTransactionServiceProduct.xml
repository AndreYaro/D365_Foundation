<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailTransactionServiceProduct</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;


/// <summary>
/// The <c>RetailTransactionServiceProduct</c> class is a service class between the Ax and the POS for products.
/// </summary>
public class RetailTransactionServiceProduct
{
    #define.DisplayOrderEcoResProductCategoryDS('DisplayOrderEcoResProductCategoryDS')

    private static CommerceHQEventSource eventSource = CommerceHQEventSource::Log;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkChannelExist</Name>
				<Source><![CDATA[
    private static str checkChannelExist(RetailChannelRecId _channelRecId)
    {
        RetailChannelTable channel;
        str error;

        channel = RetailChannelTable::findByRecId(_channelRecId);
        if (!channel)
        {
            eventSource.EventWriteProductsChannelDoesNotExist(classStr(RetailTransactionServiceProduct), funcName(), _channelRecId);
            error = strFmt("@SYS99332", _channelRecId);
        }

        return error;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChannelTimezone</Name>
				<Source><![CDATA[
    private static Timezone getChannelTimezone(RetailChannelRecId _channelRecId)
    {
        RetailChannelTable channel;
        DataArea dataArea;

        channel = RetailChannelTable::findByRecId(_channelRecId);
        if (channel.ChannelTimeZone)
        {
            return channel.ChannelTimeZone;
        }

        select timeZone from dataArea
            where dataArea.Id == channel.inventLocationDataAreaId;
        if (dataArea.timeZone)
        {
            return dataArea.timeZone;
        }

        return Timezone::GMT_DUBLIN_EDINBURGH_LISBON_LONDON;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLanguageId</Name>
				<Source><![CDATA[
    private static LanguageId getLanguageId(RetailChannelRecId _channelRecId, str _languageId)
    {
        RetailChannelDefaultLanguage channelDefaultLanguage;
        str languageId = _languageId;
        if (!languageId)
        {
            select firstonly languageId from channelDefaultLanguage
            where channelDefaultLanguage.Channel == _channelRecId;
            languageId = channelDefaultLanguage.LanguageId;
        }
        if (!languageId)
        {
            languageId = CompanyInfo::find().LanguageId;
        }

        return languageId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductAttributeValuesXmlMap</Name>
				<Source><![CDATA[
    public static Map getProductAttributeValuesXmlMap(
        XmlDocument _xmlDocument,
        RetailChannelRecId _channelRecId,
        CatalogRefRecId _catalogRecId,
        Set _productSet,
        str _attributeRecIdRangeValue,
        LanguageId _languageId,
        RetailTmpCatalogProduct tmpCatalogProduct)
    {
        If (!_attributeRecIdRangeValue)
        {
            return new Map(Types::Int64, Types::Class);
        }

        Query query;
        QueryBuildDataSource queryBuildDataSource;
        QueryBuildRange queryBuildRange;
        QueryRun queryRun;

        RetailTmpCatalogIntOrgAttributeTrans tmpCatalogIntOrgAttributeTrans;
        RetailTmpCatalogProductTrans tmpCatalogProductTrans;

        RetailTmpCatalogInternalOrgAttribute tmpCatalogInternalOrgAttribute;
        str tmpCatalogInternalOrgAttributePhysicalTableName = RetailUtilities::getPhysicalTableName(tmpCatalogInternalOrgAttribute);

        str tmpCatalogProductPhysicalTableName = RetailUtilities::getPhysicalTableName(tmpCatalogProduct);

        RetailTmpInternalOrgLanguage tmpInternalOrgLanguage;
        str tmpInternalOrgLanguagePhysicalTableName = RetailUtilities::getPhysicalTableName(tmpInternalOrgLanguage);

        RetailTmpPubProductAttributeValue tmpPubProductAttributeValue;
        str tmpPubProductAttributeValuePhysicalTableName = RetailUtilities::getPhysicalTableName(tmpPubProductAttributeValue);

        RetailTmpProductAttribute tmpProductAttribute;
        RetailTmpProductAttribute checkTmpProductAttribute;
        str tmpProductAttributePhysicalTableName = RetailUtilities::getPhysicalTableName(tmpProductAttribute);

        RetailTmpProductAttributeValue tmpProductAttributeValue;
        RetailTmpProductAttributeValue checkTmpProductAttributeValue;
        str tmpProductAttributeValuePhysicalTableName = RetailUtilities::getPhysicalTableName(tmpProductAttributeValue);

        RetailAttributeMapView attributeMap;
        RetailCatalogProductCategoryAttribute catalogProductCategoryAttribute;
        RetailInternalOrganization internalOrganization;
        RetailProductCategory productCategory;
        RetailPubCatalogProduct pubCatalogProduct;
        RetailPubProductAttributeChannelMetadata pubProductAttributeChannelMetadata;
        RetailStandardAttribute standardAttribute;

        EcoResAttribute attribute;
        EcoResAttributeGroupAttribute attributeGroupAttribute;
        EcoResAttributeType attributeType;
        EcoResCategoryAttributeLookup categoryAttributeLookup;
        UnitOfMeasure unitOfMeasure;
        LanguageTable languageTable;

        EcoResProductRecId previousProductRecId;
        EcoResProductRecId productRecId;

        RetailInternalOrgRefRecId internalOrgRecId;
        RetailCatalogManager catalogManager;
        RecordInsertList recordInsertList;
        SetEnumerator productSetEnumerator;
        Map productAttributeValueXmlMap;
        XmlElement xmlElementAttributeValues;
        XmlElement xmlElementAttributeValue;
        CreatedTransactionId currentTransactionId;
        boolean hasValue;

        LanguageId sysLanguage = SystemParameters::getSystemLanguageId();
        RetailSharedParameters sharedParameters = RetailSharedParameters::find();

        // Link TempDB physical table instances
        checkTmpProductAttribute.linkPhysicalTableInstance(tmpProductAttribute);
        checkTmpProductAttributeValue.linkPhysicalTableInstance(tmpProductAttributeValue);

        // Find matching attributes.
        query = new Query();
        internalOrganization = RetailInternalOrganization::findByChannelId(_channelRecId);
        if (internalOrganization)
        {
            queryBuildDataSource = query.addDataSource(tableNum(RetailPubProductAttributeChannelMetadata));
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(RetailPubProductAttributeChannelMetadata, HostChannel));
            queryBuildRange.value(queryValue(_channelRecId));
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(RetailPubProductAttributeChannelMetadata, Attribute));
            queryBuildRange.value(RetailTransactionServiceProduct::getRangeValue(_attributeRecIdRangeValue));
        }
        else
        {
            queryBuildDataSource = query.addDataSource(tableNum(EcoResAttribute));
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(EcoResAttribute, RecId));
            queryBuildRange.value(RetailTransactionServiceProduct::getRangeValue(_attributeRecIdRangeValue));
        }

        // Prepare attributes.

        // Start transaction to give the scope for the request
        ttsBegin;

        // Ensure set based operations to not be downgraded to record-by-record operations
        tmpPubProductAttributeValue.skipDatabaseLog(true);
        tmpPubProductAttributeValue.skipEvents(true);
        delete_from tmpPubProductAttributeValue;

        // Ensure set based operations to not be downgraded to record-by-record operations
        tmpCatalogIntOrgAttributeTrans.skipDatabaseLog(true);
        tmpCatalogIntOrgAttributeTrans.skipEvents(true);

        recordInsertList = new RecordInsertList(tableNum(RetailTmpCatalogIntOrgAttributeTrans));
        queryRun = new QueryRun(query);
        while (queryRun.next())
        {
            tmpCatalogIntOrgAttributeTrans.Catalog = _catalogRecId;
            if (internalOrganization)
            {
                pubProductAttributeChannelMetadata = queryRun.get(tableNum(RetailPubProductAttributeChannelMetadata));
                tmpCatalogIntOrgAttributeTrans.InternalOrganization = internalOrganization.RecId;
                tmpCatalogIntOrgAttributeTrans.Attribute = pubProductAttributeChannelMetadata.Attribute;
            }
            else
            {
                attribute = queryRun.get(tableNum(EcoResAttribute));
                tmpCatalogIntOrgAttributeTrans.InternalOrganization = 0;
                tmpCatalogIntOrgAttributeTrans.Attribute = attribute.RecId;
            }
            recordInsertList.add(tmpCatalogIntOrgAttributeTrans);
        }
        recordInsertList.insertDatabase();

        currentTransactionId = appl.curTransactionId();

        // Ensure set based operations to not be downgraded to record-by-record operations
        tmpCatalogInternalOrgAttribute.skipDatabaseLog(true);
        tmpCatalogInternalOrgAttribute.skipEvents(true);

        // Remove this once the TempDB bug is fixed. The TempDB table instance is not cleared when it is recylced
        delete_from tmpCatalogInternalOrgAttribute;

        // Populate tmpCatalogInternalOrgAttribute for this transaction
        insert_recordset tmpCatalogInternalOrgAttribute(Catalog, InternalOrganization, Attribute)
            select Catalog, InternalOrganization, Attribute from tmpCatalogIntOrgAttributeTrans
                where tmpCatalogIntOrgAttributeTrans.createdTransactionId == currentTransactionId;

        // Clear tmpCatalogIntOrgAttributeTrans for current transaction
        delete_from tmpCatalogIntOrgAttributeTrans where tmpCatalogIntOrgAttributeTrans.createdTransactionId == currentTransactionId;

        // Prepare products

        // Ensure set based operations to not be downgraded to record-by-record operations
        tmpCatalogProductTrans.skipDatabaseLog(true);
        tmpCatalogProductTrans.skipEvents(true);

        recordInsertList = new RecordInsertList(tableNum(RetailTmpCatalogProductTrans));
        productSetEnumerator = _productSet.getEnumerator();
        while (productSetEnumerator.moveNext())
        {
            productRecId = productSetEnumerator.current();
            tmpCatalogProductTrans.Catalog = _catalogRecId;
            tmpCatalogProductTrans.Product = productRecId;
            recordInsertList.add(tmpCatalogProductTrans);
        }
        recordInsertList.insertDatabase();

        // Ensure set based operations to not be downgraded to record-by-record operations
        tmpCatalogProduct.skipDatabaseLog(true);
        tmpCatalogProduct.skipEvents(true);

        // Remove this once the TempDB bug is fixed. The TempDB table instance is not cleared when it is recylced
        delete_from tmpCatalogProduct;

        // Populate tmpCatalogProduct for this transaction
        insert_recordset tmpCatalogProduct(Catalog, Product)
            select Catalog, Product from tmpCatalogProductTrans
                where tmpCatalogProductTrans.createdTransactionId == currentTransactionId;

        // Clear tmpCatalogProductTrans for current transaction
        delete_from tmpCatalogProductTrans where tmpCatalogProductTrans.createdTransactionId == currentTransactionId;

        // Populate CatalogProduct field
        update_recordSet tmpCatalogProduct
            setting catalogProduct = pubCatalogProduct.Origin
            join pubCatalogProduct
                where pubCatalogProduct.Catalog == tmpCatalogProduct.Catalog
                    && pubCatalogProduct.Product == tmpCatalogProduct.Product;

        // Ensure set based operations to not be downgraded to record-by-record operations
        tmpProductAttribute.skipDatabaseLog(true);
        tmpProductAttribute.skipEvents(true);

        // Remove this once the TempDB bug is fixed. The TempDB table instance is not cleared when it is recylced
        delete_from tmpProductAttribute;

        if (internalOrganization)
        {
            // Non-category attributes
            insert_recordset tmpProductAttribute(Product, Attribute)
                select Product from tmpCatalogProduct
                join Attribute from tmpCatalogInternalOrgAttribute
                join pubProductAttributeChannelMetadata
                    where pubProductAttributeChannelMetadata.HostChannel == _channelRecId
                        && pubProductAttributeChannelMetadata.Attribute == tmpCatalogInternalOrgAttribute.Attribute
                        && pubProductAttributeChannelMetadata.AttributeRelationType != RetailProductAttributeRelationType::Category;

            // Category attributes for products explicitly added to the catalog
            insert_recordset tmpProductAttribute(Product, Attribute)
                select Product from tmpCatalogProduct
                join Attribute from tmpCatalogInternalOrgAttribute
                join pubProductAttributeChannelMetadata
                    where pubProductAttributeChannelMetadata.HostChannel == _channelRecId
                        && pubProductAttributeChannelMetadata.Attribute == tmpCatalogInternalOrgAttribute.Attribute
                        && pubProductAttributeChannelMetadata.AttributeRelationType == RetailProductAttributeRelationType::Category
                join attributeMap
                    where attributeMap.Attribute == tmpCatalogInternalOrgAttribute.Attribute
                exists join catalogProductCategoryAttribute
                    where catalogProductCategoryAttribute.Catalog == _catalogRecId
                        && catalogProductCategoryAttribute.Product == tmpCatalogProduct.Product
                        && (catalogProductCategoryAttribute.Attribute == attributeMap.Attribute
                            || catalogProductCategoryAttribute.Attribute == attributeMap.ActualAttribute);

            // Category attributes for product masters implicitly added to the catalog because variants are added
            insert_recordset tmpProductAttribute(Product, Attribute)
                select Product from tmpCatalogProduct
                    group by Product
                join Attribute from tmpCatalogInternalOrgAttribute
                    group by Attribute
                join pubProductAttributeChannelMetadata
                    where pubProductAttributeChannelMetadata.HostChannel == _channelRecId
                        && pubProductAttributeChannelMetadata.Attribute == tmpCatalogInternalOrgAttribute.Attribute
                        && pubProductAttributeChannelMetadata.AttributeRelationType == RetailProductAttributeRelationType::Category
                join attributeMap
                    where attributeMap.Attribute == tmpCatalogInternalOrgAttribute.Attribute
                join productCategory
                    where productCategory.Product == tmpCatalogProduct.Product
                join categoryAttributeLookup
                    where categoryAttributeLookup.Category == productCategory.Category
                        && (categoryAttributeLookup.Attribute == attributeMap.Attribute
                            || categoryAttributeLookup.Attribute == attributeMap.ActualAttribute)
                notExists join checkTmpProductAttribute
                    where checkTmpProductAttribute.Product == tmpCatalogProduct.Product
                        && checkTmpProductAttribute.Attribute == tmpCatalogInternalOrgAttribute.Attribute;
        }
        else
        {
            // Standard attributes
            insert_recordset tmpProductAttribute(Product, Attribute)
                select Product from tmpCatalogProduct
                join Attribute from tmpCatalogInternalOrgAttribute
                join attributeMap
                    where attributeMap.Attribute == tmpCatalogInternalOrgAttribute.Attribute
                join standardAttribute
                    where (standardAttribute.Attribute == attributeMap.Attribute
                        || standardAttribute.Attribute == attributeMap.ActualAttribute);

            // Default attributes
            insert_recordset tmpProductAttribute(Product, Attribute)
                select Product from tmpCatalogProduct
                join Attribute from tmpCatalogInternalOrgAttribute
                join attributeMap
                    where attributeMap.Attribute == tmpCatalogInternalOrgAttribute.Attribute
                exists join attributeGroupAttribute
                    where attributeGroupAttribute.AttributeGroup == sharedParameters.ProductDefaultAttributeGroup
                        && (attributeGroupAttribute.Attribute == attributeMap.Attribute
                            || attributeGroupAttribute.Attribute == attributeMap.ActualAttribute)
                notExists join checkTmpProductAttribute
                    where checkTmpProductAttribute.Product == tmpCatalogProduct.Product
                        && checkTmpProductAttribute.Attribute == tmpCatalogInternalOrgAttribute.Attribute;

            // Category attributes
            insert_recordset tmpProductAttribute(Product, Attribute)
                select Product from tmpCatalogProduct
                    group by Product
                join Attribute from tmpCatalogInternalOrgAttribute
                    group by Attribute
                join attributeMap
                    where attributeMap.Attribute == tmpCatalogInternalOrgAttribute.Attribute
                join productCategory
                    where productCategory.Product == tmpCatalogProduct.Product
                join categoryAttributeLookup
                    where categoryAttributeLookup.Category == productCategory.Category
                        && (categoryAttributeLookup.Attribute == attributeMap.Attribute
                            || categoryAttributeLookup.Attribute == attributeMap.ActualAttribute)
                notExists join checkTmpProductAttribute
                    where checkTmpProductAttribute.Product == tmpCatalogProduct.Product
                        && checkTmpProductAttribute.Attribute == tmpCatalogInternalOrgAttribute.Attribute;
        }

        // Exclude attributes not used by any product
        delete_from tmpCatalogInternalOrgAttribute
             notexists join tmpProductAttribute
                where tmpProductAttribute.Attribute == tmpCatalogInternalOrgAttribute.Attribute;

        // Ensure set based operations to not be downgraded to record-by-record operations
        tmpInternalOrgLanguage.skipDatabaseLog(true);
        tmpInternalOrgLanguage.skipEvents(true);

        // Remove this once the TempDB bug is fixed. The TempDB table instance is not cleared when it is recylced
        delete_from tmpInternalOrgLanguage;

        // Prepare languages
        internalOrgRecId = internalOrganization.RecId;
        insert_recordset tmpInternalOrgLanguage(InternalOrganization, LanguageId)
            select internalOrgRecId, LanguageId from languageTable
                where languageTable.LanguageId == _languageId;

        // Calculate product atttribute values
        catalogManager = RetailCatalogManager::newCatalogId(_catalogRecId);
        catalogManager.calculateSelectedProductAttributeValues(
            tmpPubProductAttributeValue,
            tmpCatalogProduct,
            tmpCatalogInternalOrgAttribute,
            tmpInternalOrgLanguage,
            false,  // _requiredCheckOnly
            true);  // _usePublished

        // Ensure set based operations to not be downgraded to record-by-record operations
        tmpProductAttributeValue.skipDatabaseLog(true);
        tmpProductAttributeValue.skipEvents(true);

        // Remove this once the TempDB bug is fixed. The TempDB table instance is not cleared when it is recylced
        delete_from tmpProductAttributeValue;

        // Most specific attribute values win.

        // Product && InternalOrganization
        insert_recordset tmpProductAttributeValue(Attribute, DateTimeValue, FloatValue, IntValue, TextValue, UnitOfMeasure, Product)
            select Attribute, DateTimeValue, FloatValue, IntValue, TextValue, UnitOfMeasure, Product from tmpPubProductAttributeValue
                where tmpPubProductAttributeValue.Product
                    && tmpPubProductAttributeValue.InternalOrganization
                    && tmpPubProductAttributeValue.LanguageId == _languageId
            join tmpProductAttribute
                where tmpProductAttribute.Product == tmpPubProductAttributeValue.Product
                    && tmpProductAttribute.Attribute == tmpPubProductAttributeValue.Attribute;
        if (sysLanguage == _languageId)
        {
            insert_recordset tmpProductAttributeValue(Attribute, DateTimeValue, FloatValue, IntValue, TextValue, UnitOfMeasure, Product)
                select Attribute, DateTimeValue, FloatValue, IntValue, TextValue, UnitOfMeasure, Product from tmpPubProductAttributeValue
                    where tmpPubProductAttributeValue.Product
                        && tmpPubProductAttributeValue.InternalOrganization
                        && !tmpPubProductAttributeValue.LanguageId
                join tmpProductAttribute
                    where tmpProductAttribute.Product == tmpPubProductAttributeValue.Product
                        && tmpProductAttribute.Attribute == tmpPubProductAttributeValue.Attribute
                notExists join checkTmpProductAttributeValue
                    where checkTmpProductAttributeValue.Product == tmpPubProductAttributeValue.Product
                        && checkTmpProductAttributeValue.Attribute == tmpPubProductAttributeValue.Attribute;
        }

        // Product && !InternalOrganization
        insert_recordset tmpProductAttributeValue(Attribute, DateTimeValue, FloatValue, IntValue, TextValue, UnitOfMeasure, Product)
            select Attribute, DateTimeValue, FloatValue, IntValue, TextValue, UnitOfMeasure, Product from tmpPubProductAttributeValue
                where tmpPubProductAttributeValue.Product
                    && !tmpPubProductAttributeValue.InternalOrganization
                    && tmpPubProductAttributeValue.LanguageId == _languageId
            join tmpProductAttribute
                where tmpProductAttribute.Product == tmpPubProductAttributeValue.Product
                    && tmpProductAttribute.Attribute == tmpPubProductAttributeValue.Attribute
            notExists join checkTmpProductAttributeValue
                where checkTmpProductAttributeValue.Product == tmpPubProductAttributeValue.Product
                    && checkTmpProductAttributeValue.Attribute == tmpPubProductAttributeValue.Attribute;
        if (sysLanguage == _languageId)
        {
            insert_recordset tmpProductAttributeValue(Attribute, DateTimeValue, FloatValue, IntValue, TextValue, UnitOfMeasure, Product)
                select Attribute, DateTimeValue, FloatValue, IntValue, TextValue, UnitOfMeasure, Product from tmpPubProductAttributeValue
                    where tmpPubProductAttributeValue.Product
                        && !tmpPubProductAttributeValue.InternalOrganization
                        && !tmpPubProductAttributeValue.LanguageId
                join tmpProductAttribute
                    where tmpProductAttribute.Product == tmpPubProductAttributeValue.Product
                        && tmpProductAttribute.Attribute == tmpPubProductAttributeValue.Attribute
                notExists join checkTmpProductAttributeValue
                    where checkTmpProductAttributeValue.Product == tmpPubProductAttributeValue.Product
                        && checkTmpProductAttributeValue.Attribute == tmpPubProductAttributeValue.Attribute;
        }

        // !Product && InternalOrganization
        insert_recordset tmpProductAttributeValue(Attribute, DateTimeValue, FloatValue, IntValue, TextValue, UnitOfMeasure, Product)
            select Attribute, DateTimeValue, FloatValue, IntValue, TextValue, UnitOfMeasure from tmpPubProductAttributeValue
                where !tmpPubProductAttributeValue.Product
                    && tmpPubProductAttributeValue.InternalOrganization
                    && tmpPubProductAttributeValue.LanguageId == _languageId
            join Product from tmpProductAttribute
                where tmpProductAttribute.Attribute == tmpPubProductAttributeValue.Attribute
            notExists join checkTmpProductAttributeValue
                where checkTmpProductAttributeValue.Product == tmpProductAttribute.Product
                    && checkTmpProductAttributeValue.Attribute == tmpPubProductAttributeValue.Attribute;
        if (sysLanguage == _languageId)
        {
            insert_recordset tmpProductAttributeValue(Attribute, DateTimeValue, FloatValue, IntValue, TextValue, UnitOfMeasure, Product)
                select Attribute, DateTimeValue, FloatValue, IntValue, TextValue, UnitOfMeasure from tmpPubProductAttributeValue
                    where !tmpPubProductAttributeValue.Product
                        && tmpPubProductAttributeValue.InternalOrganization
                        && !tmpPubProductAttributeValue.LanguageId
                join Product from tmpProductAttribute
                    where tmpProductAttribute.Attribute == tmpPubProductAttributeValue.Attribute
                notExists join checkTmpProductAttributeValue
                    where checkTmpProductAttributeValue.Product == tmpProductAttribute.Product
                        && checkTmpProductAttributeValue.Attribute == tmpPubProductAttributeValue.Attribute;
        }

        // !Product && !InternalOrganization
        insert_recordset tmpProductAttributeValue(Attribute, DateTimeValue, FloatValue, IntValue, TextValue, UnitOfMeasure, Product)
            select Attribute, DateTimeValue, FloatValue, IntValue, TextValue, UnitOfMeasure from tmpPubProductAttributeValue
                where !tmpPubProductAttributeValue.Product
                    && !tmpPubProductAttributeValue.InternalOrganization
                    && tmpPubProductAttributeValue.LanguageId == _languageId
            join Product from tmpProductAttribute
                where tmpProductAttribute.Attribute == tmpPubProductAttributeValue.Attribute
            notExists join checkTmpProductAttributeValue
                where checkTmpProductAttributeValue.Product == tmpProductAttribute.Product
                    && checkTmpProductAttributeValue.Attribute == tmpPubProductAttributeValue.Attribute;
        if (sysLanguage == _languageId)
        {
            insert_recordset tmpProductAttributeValue(Attribute, DateTimeValue, FloatValue, IntValue, TextValue, UnitOfMeasure, Product)
                select Attribute, DateTimeValue, FloatValue, IntValue, TextValue, UnitOfMeasure from tmpPubProductAttributeValue
                    where !tmpPubProductAttributeValue.Product
                        && !tmpPubProductAttributeValue.InternalOrganization
                        && !tmpPubProductAttributeValue.LanguageId
                join Product from tmpProductAttribute
                    where tmpProductAttribute.Attribute == tmpPubProductAttributeValue.Attribute
                notExists join checkTmpProductAttributeValue
                    where checkTmpProductAttributeValue.Product == tmpProductAttribute.Product
                        && checkTmpProductAttributeValue.Attribute == tmpPubProductAttributeValue.Attribute;
        }

        // End transaction as soon as the trans tables are used and cleared. No transaction is needed for writing to temp tables.
        ttsCommit;

        // Construct product attribute value xml map.
        productAttributeValueXmlMap = new Map(Types::Int64, Types::Class);
        while select tmpProductAttributeValue order by Product, Attribute
            join ActualAttribute from attributeMap
                where attributeMap.Attribute == tmpProductAttributeValue.Attribute
            join AttributeType from attribute
                where attribute.RecId == attributeMap.ActualAttribute
            join DataType from attributeType
                where attributeType.RecId == attribute.AttributeType
            outer join unitOfMeasure
                where unitOfMeasure.RecId == tmpProductAttributeValue.UnitOfMeasure
        {
            if (previousProductRecId != tmpProductAttributeValue.Product)
            {
                previousProductRecId = tmpProductAttributeValue.Product;
                xmlElementAttributeValues = _xmlDocument.createElement('AttributeValues');
                productAttributeValueXmlMap.insert(previousProductRecId, xmlElementAttributeValues);
            }

            xmlElementAttributeValue = _xmlDocument.createElement('AttributeValue');

            RetailTransactionServiceProduct::setXElementAttributeInt64Value(xmlElementAttributeValue, 'Attribute', tmpProductAttributeValue.Attribute);

            hasValue = false;
            hasValue = RetailTransactionServiceProduct::setXmlFromAttributeDataType(attributeType, xmlElementAttributeValue, tmpProductAttributeValue, unitOfMeasure);

            if (hasValue)
            {
                xmlElementAttributeValues.appendChild(xmlElementAttributeValue);
            }
        }

        return productAttributeValueXmlMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setXmlFromAttributeDataType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets Xml element based on <c>AttributeDataType</c>.
    /// </summary>
    /// <param name = "_attributeType">
    ///     An attribute data type.
    /// </param>
    /// <param name = "_xmlElementAttributeValue">
    ///     Xml element.
    /// </param>
    /// <param name = "_tmpProductAttributeValue">
    ///     A table buffer.
    /// </param>
    /// <param name = "_unitOfMeasure">
    ///     An unit of measure type value.
    /// </param>
    /// <returns>
    ///     true for known <c>AttributeDataType</c>; Otherwise, false.
    /// </returns>
    protected static boolean setXmlFromAttributeDataType(EcoResAttributeType _attributeType, XmlElement _xmlElementAttributeValue,
         RetailTmpProductAttributeValue _tmpProductAttributeValue, UnitOfMeasure _unitOfMeasure)
    {
        boolean hasValue = false;
        switch (_attributeType.DataType)
        {
            case AttributeDataType::Currency:
                hasValue = RetailTransactionServiceProduct::setXElementAttributeFloatValue(_xmlElementAttributeValue, 'CurrencyValue', _tmpProductAttributeValue.FloatValue);
                RetailTransactionServiceProduct::setXElementAttributeTextValue(_xmlElementAttributeValue, 'CurrencyCode', _tmpProductAttributeValue.TextValue);
                break;

            case AttributeDataType::DateTime:
                hasValue = RetailTransactionServiceProduct::setXElementAttributeDateTimeValue(_xmlElementAttributeValue, 'DateTimeValue', _tmpProductAttributeValue.DateTimeValue);
                break;

            case AttributeDataType::Decimal:
                hasValue = RetailTransactionServiceProduct::setXElementAttributeFloatValue(_xmlElementAttributeValue, 'FloatValue', _tmpProductAttributeValue.FloatValue);
                RetailTransactionServiceProduct::setXElementAttributeTextValue(_xmlElementAttributeValue, 'FloatUnitSymbol', _unitOfMeasure.Symbol);
                break;

            case AttributeDataType::Integer:
                hasValue = RetailTransactionServiceProduct::setXElementAttributeIntValue(_xmlElementAttributeValue, 'IntValue', _tmpProductAttributeValue.IntValue);
                RetailTransactionServiceProduct::setXElementAttributeTextValue(_xmlElementAttributeValue, 'IntUnitSymbol', _unitOfMeasure.Symbol);
                break;

            case AttributeDataType::Text:
                hasValue = RetailTransactionServiceProduct::setXElementAttributeTextValue(_xmlElementAttributeValue, 'TextValue', _tmpProductAttributeValue.TextValue);
                break;

            case AttributeDataType::TrueFalse:
                hasValue = RetailTransactionServiceProduct::setXElementAttributeIntValue(_xmlElementAttributeValue, 'BooleanValue', _tmpProductAttributeValue.IntValue);
                break;
        }
        return hasValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the product details based on item ID range.
    /// </summary>
    /// <param name="_rangeValue">
    /// The range value of the search critieria field for which product details need to be fetched.
    /// </param>
    /// <param name="_includeDataSourceMap">
    /// Whether to include the mapping from data source names to table names.
    /// </param>
    /// <param name="_rangeFieldName">
    /// The search critieria field name.
    /// </param>
    /// <returns>
    /// A container having the product details in a XML string.
    /// </returns>
    public static container getProductData(str _rangeValue, boolean _includeDataSourceMap = false, str _rangeFieldName = 'ItemId')
    {
        Map fromToFieldMapping;
        Map oneToManyFieldsMapping;
        Query query;
        #RetailCDX
        boolean success;
        str error;
        int fromLine;
        Xml documentXml;
        Map dataSourceMap;
        boolean shouldCompressXml = false;
        RetailConnChannelSchema channelSchema;

        select firstonly channelSchema
            where channelSchema.SchemaName == #AX7SchemaName;

        try
        {
            if (_rangeValue == '')
            {
                throw Global::error("@Retail:RangeValueEmptyError");
            }

            if (_rangeFieldName == 'Product')
            {
                // GetRetailProductDataQuery retrieves product data for standard and master products only, hence
                // if the _rangeValue includes variantIds then map those Ids to the corresponding master product Id.
                _rangeValue = Retailtransactionserviceproduct::mapVariantsToMasterProductId(_rangeValue);
            }

            fromLine = Global::infologLine();

            Map resultMap = RetailTransactionServiceProduct::GetRetailProductDataQuery();

            query = resultMap.lookup(1);
            fromToFieldMapping = resultMap.lookup(2);
            oneToManyFieldsMapping = resultMap.lookup(3);

            QueryBuildDataSource dataSource = query.dataSourceNo(1);
            QueryBuildRange queryBuildRange = dataSource.addRange(fieldName2id(dataSource.table(), _rangeFieldName));
            queryBuildRange.value(_rangeValue);

            QueryRun queryRun = new QueryRun(query);
            RetailXmlDocumentWriter retailXmlDocumentWriter = new RetailXmlDocumentWriter();
            retailXmlDocumentWriter.paramFromToFieldMapping(fromToFieldMapping);
            retailXmlDocumentWriter.paramOneToManyFieldsMapping(oneToManyFieldsMapping);

            documentXml = retailXmlDocumentWriter.writeDocument(queryRun);

            RetailTransactionServiceProductContext context = RetailTransactionServiceProductContext::current();
            if (context != null)
            {
                shouldCompressXml = context.parmShouldCompressProductData();
            }

            if (shouldCompressXml)
            {
                documentXml = RetailTransactionServiceDataCompressor::compressTextToBase64String(documentXml);
            }

            if (_includeDataSourceMap)
            {
                dataSourceMap = RetailTransactionServiceProduct::getDataSourceMap(query);
            }

            success = true;
        }
        catch(Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
        }

        if (dataSourceMap)
        {
            return [success, error, documentXml, dataSourceMap.pack(), shouldCompressXml];
        }
        else
        {
            return [success, error, documentXml, shouldCompressXml];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mapVariantsToMasterProductId</Name>
				<Source><![CDATA[
    private static str mapVariantsToMasterProductId(str _rangeValue)
    {
        if (_rangeValue != '')
        {
            Query query = new Query();

            QueryBuildDatasource datasource = query.addDataSource(tableNum(EcoResDistinctProductVariant));
            QueryBuildRange qbr = datasource.addRange(fieldNum(EcoResDistinctProductVariant, RecId));
            qbr.value(_rangeValue);

            QueryRun queryrun = new QueryRun(query);

            while (queryrun.next())
            {
                EcoResDistinctProductVariant product = queryrun.getNo(1);
                _rangeValue = strFmt('%1,%2', _rangeValue, product.ProductMaster);
            }
        }

        return _rangeValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetRetailProductDataQuery</Name>
				<Source><![CDATA[
    private static Map GetRetailProductDataQuery()
    {
        #RetailCDX

        const GlobalObjectCacheScope cacheScope = 'RetailTransactionServiceProductCacheScope';
        const GlobalObjectCacheScope fieldMapCacheScope = 'RetailTransactionServiceProductFieldMapCacheScope';
        const GlobalObjectCacheScope oneToManyfieldMapCacheScope = 'RetailTransactionServiceProductOneToManyFieldsMapCacheScope';
        const str QueryNameRetailProductData = 'RetailProductData';

        Map resultMap = new Map(Types::Integer, Types::AnyType);
        SysGlobalObjectCache cache = new SysGlobalObjectCache();
        RetailConnChannelSchemaName channelSchemaName = #AX7SchemaName;
        container cacheKey = [channelSchemaName, QueryNameRetailProductData];
        container cacheValue = cache.find(cacheScope, cacheKey);
        container fieldMapCacheValue = cache.find(fieldMapCacheScope, cacheKey);
        container oneToManyFieldMapCacheValue = cache.find(oneToManyfieldMapCacheScope, cacheKey);

        if (cacheValue == conNull() || fieldMapCacheValue == conNull() || oneToManyFieldMapCacheValue == conNull())
        {
            cache.clear(cacheScope);
            cache.clear(fieldMapCacheScope);
            cache.clear(oneToManyFieldMapCacheScope);

            RetailConnChannelSchema channelSchema;
            select firstonly channelSchema where channelSchema.SchemaName == channelSchemaName;
            if (!channelSchema)
            {
                // Channel schema does not exist: %1.
                throw error(strFmt("@RET4040124", channelSchemaName));
            }
            RetailCDXOnDemandQueryBuilder cdxOnDemandQueryBuilder = RetailCDXOnDemandQueryBuilder::newChannelSchema(channelSchema);
            Query query = new Query();
            query.name(QueryNameRetailProductData);
            cdxOnDemandQueryBuilder.buildProductQuery(query);
            cacheValue = query.pack();
            cache.insert(cacheScope, cacheKey, cacheValue);

            fieldMapCacheValue = cdxOnDemandQueryBuilder.paramTransferFieldMapping().pack();
            cache.insert(fieldMapCacheScope, cacheKey, fieldMapCacheValue);

            oneToManyFieldMapCacheValue = cdxOnDemandQueryBuilder.paramOneToManyFieldsMapping().pack();
            cache.insert(oneToManyfieldMapCacheScope, cacheKey, oneToManyFieldMapCacheValue);
        }

        Query queryCache = new Query(cacheValue);
        Map fieldMapCacheMap = Map::create(fieldMapCacheValue);
        Map oneToManyFieldMappingsCacheMap = Map::create(oneToManyFieldMapCacheValue);

        resultMap.insert(1, queryCache);
        resultMap.insert(2, fieldMapCacheMap);
        resultMap.insert(3, oneToManyFieldMappingsCacheMap);

        return resultMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDataSourceMap</Name>
				<Source><![CDATA[
    private static Map getDataSourceMap(Query _query)
    {
        Map dataSourceMap = new Map(Types::String, Types::String);
        QueryBuildDataSource queryBuildDataSource;
        int i;

        for (i = 1; i <= _query.dataSourceCount(); i++)
        {
            queryBuildDataSource = _query.dataSourceNo(i);
            dataSourceMap.insert(queryBuildDataSource.name(), tableid2name(queryBuildDataSource.table()));
        }

        return dataSourceMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductPrices</Name>
				<Source><![CDATA[
    private static Map getProductPrices(RetailChannelRecId _channelRecId, CatalogRefRecId _catalogRecId, Map _productByItemId, Map _unitIdByItemId)
    {
        Map priceByProduct = new Map(Types::Int64, Types::Real);
        MapEnumerator productEnumerator;
        List priceDiscountLines = new List(Types::Class);
        ListEnumerator priceDiscountLinesEnumerator;
        RetailPriceDiscountLine priceDiscountLine;
        ItemId itemId;

        if (!_productByItemId.empty())
        {
            productEnumerator = _productByItemId.getEnumerator();
            while (productEnumerator.moveNext())
            {
                itemId = productEnumerator.currentKey();

                priceDiscountLine = new RetailPriceDiscountLine();
                priceDiscountLine.parmCatalogRefRecId(_catalogRecId);
                priceDiscountLine.parmItemId(itemId);
                priceDiscountLine.parmQty(1);
                priceDiscountLine.parmReferenceRecId(_productByItemId.lookup(itemId));
                priceDiscountLine.parmSalesUnit(_unitIdByItemId.lookup(itemId));
                priceDiscountLines.addEnd(priceDiscountLine);
            }

            RetailPricingCalculatorCreator::getInstance().createPriceCheck().calculateIndependentPriceDiscounts(_channelRecId, priceDiscountLines);

            priceDiscountLinesEnumerator = priceDiscountLines.getEnumerator();
            while (priceDiscountLinesEnumerator.moveNext())
            {
                priceDiscountLine = priceDiscountLinesEnumerator.current();
                priceByProduct.insert(priceDiscountLine.parmReferenceRecId(), priceDiscountLine.parmPrice());
            }
        }

        return priceByProduct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductsByCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the products by category.
    /// </summary>
    /// <param name="_currentChannelRecId">
    /// The record ID of current channel.
    /// </param>
    /// <param name="_categoryRecId">
    /// The record id of current category.
    /// </param>
    /// <param name="_startPosition">
    /// The starting record position.
    /// </param>
    /// <param name="_pageSize">
    /// The page size.
    /// </param>
    /// <param name="_orderByField">
    /// The order by field name.
    /// </param>
    /// <param name="_sortOrder">
    /// The sort order.
    /// </param>
    /// <param name="_includeTotalCount">
    /// Whether to include total number of records in the return value.
    /// </param>
    /// <param name="_languageId">
    /// The language to search in.
    /// </param>
    /// <param name="_otherChannelRecId">
    /// The record if for other store to search in.
    /// </param>
    /// <param name="_catalogRecId">
    /// The record ID of the catalog to search products from.
    /// </param>
    /// <param name="_attributeRecIdRangeValue">
    /// The attribute record ID range value to filter product attribute values by.
    /// </param>
    /// <param name="_includePrice">
    /// Whether to include product prices in the return value.
    /// </param>
    /// <param name="_includeProductsInDescendantCategories">
    /// Whether to include products in descendant categories.
    /// </param>
    /// <returns>
    /// A container having the products in a XML string.
    /// </returns>
    public static container getProductsByCategory(
        RetailChannelRecId  _currentChannelRecId,
        RefRecId            _categoryRecId,
        int64               _startPosition,
        int64               _pageSize,
        str                 _orderByField = 'ItemId',
        SortOrder           _sortOrder = SortOrder::Ascending,
        boolean             _includeTotalCount = false,
        LanguageId          _languageId = '',
        RetailChannelRecId  _otherChannelRecId = 0,
        CatalogRefRecId     _catalogRecId = 0,
        str                 _attributeRecIdRangeValue = '',
        boolean             _includePrice = true,
        boolean             _includeProductsInDescendantCategories = false)
    {
        str languageId = RetailTransactionServiceProduct::getLanguageId(_currentChannelRecId, _languageId);

        Query query = RetailTransactionServiceProduct::getProductsByCategoryQuery(_currentChannelRecId, _categoryRecId, _orderByField, _sortOrder, languageId, _otherChannelRecId, _catalogRecId, _includeProductsInDescendantCategories);

        return RetailTransactionServiceProduct::getProductsByQuery(_currentChannelRecId, query, _startPosition, _pageSize, _includeTotalCount, languageId, _otherChannelRecId, _catalogRecId, _attributeRecIdRangeValue, _includePrice);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductsByCategoryQuery</Name>
				<Source><![CDATA[
    private static Query getProductsByCategoryQuery(
        RetailChannelRecId  _currentChannelRecId,
        RefRecId            _categoryRecId,
        str                 _orderByField,
        SortOrder           _sortOrder,
        LanguageId          _languageId,
        RetailChannelRecId  _otherChannelRecId,
        CatalogRefRecId     _catalogRecId,
        boolean             _includeProductsInDescendantCategories)
    {
        Query query;
        QueryBuildDataSource queryBuildDataSource;
        QueryBuildRange queryBuildRange;
        date channelDate;
        EcoResCategory category;
        FieldId categoryField;

        // Initialize the query
        if (!_otherChannelRecId && !_catalogRecId)
        {
            query = RetailTransactionServiceProduct::getProductsQuery(queryStr(RetailItemBrowseWarehouse), _orderByField, _sortOrder, _languageId);

            queryBuildDataSource = query.dataSourceTable(tableNum(RetailItemCategory));
            categoryField = fieldNum(RetailItemCategory, Category);
        }
        else if (_otherChannelRecId && _catalogRecId)
        {
            query = RetailTransactionServiceProduct::getProductsQuery(queryStr(RetailItemBrowseOtherStoreCatalog), _orderByField, _sortOrder, _languageId);

            channelDate = DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(DateTimeUtil::utcNow(), RetailChannelTable::getChannelTimezone(_otherChannelRecId)));
            queryBuildDataSource = query.dataSourceTable(tableNum(RetailPubCatalog));
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(RetailPubCatalog, PublishedValidFrom));
            queryBuildRange.value('..' + queryValue(channelDate));
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(RetailPubCatalog, PublishedValidTo));
            queryBuildRange.value(queryValue(channelDate) + '..');

            queryBuildDataSource = query.dataSourceTable(tableNum(RetailPubCatalogChannelCurrent));
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(RetailPubCatalogChannelCurrent, Channel));
            queryBuildRange.value(queryValue(_otherChannelRecId));
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(RetailPubCatalogChannelCurrent, Catalog));
            queryBuildRange.value(queryValue(_catalogRecId));

            queryBuildDataSource = query.dataSourceTable(tableNum(CatalogDisplayProductAll));
            categoryField = fieldNum(CatalogDisplayProductAll, Category);
        }
        else if (_otherChannelRecId && !_catalogRecId)
        {
            query = RetailTransactionServiceProduct::getProductsQuery(queryStr(RetailItemBrowseOtherStore), _orderByField, _sortOrder, _languageId);

            queryBuildDataSource = query.dataSourceTable(tableNum(RetailChannelTable));
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(RetailChannelTable, RecId));
            queryBuildRange.value(queryValue(_otherChannelRecId));

            channelDate = DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(DateTimeUtil::utcNow(), RetailChannelTable::getChannelTimezone(_otherChannelRecId)));
            queryBuildDataSource = query.dataSourceTable(tableNum(RetailAssortmentLookup));
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(RetailAssortmentLookup, ValidFrom));
            queryBuildRange.value('..' + queryValue(channelDate));
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(RetailAssortmentLookup, ValidTo));
            queryBuildRange.value(queryValue(channelDate) + '..');

            queryBuildDataSource = query.dataSourceTable(tableNum(EcoResProductCategory));
            categoryField = fieldNum(EcoResProductCategory, Category);
        }

        // Filtered by category
        if (queryBuildDataSource)
        {
            if (!_includeProductsInDescendantCategories)
            {
                queryBuildRange = queryBuildDataSource.addRange(categoryField);
                queryBuildRange.value(queryValue(_categoryRecId));
            }
            else
            {
                category = EcoResCategory::find(_categoryRecId);

                queryBuildDataSource = queryBuildDataSource.addDataSource(tableNum(EcoResCategory));
                queryBuildDataSource.fetchMode(QueryFetchMode::One2One);
                queryBuildDataSource.relations(false);
                queryBuildDataSource.addLink(categoryField, fieldNum(EcoResCategory, RecId));

                queryBuildRange = queryBuildDataSource.addRange(fieldNum(EcoResCategory, IsActive));
                queryBuildRange.value(queryValue(NoYes::Yes));
                queryBuildRange = queryBuildDataSource.addRange(fieldNum(EcoResCategory, NestedSetLeft));
                queryBuildRange.value(queryValue(category.NestedSetLeft) + '..');
                queryBuildRange = queryBuildDataSource.addRange(fieldNum(EcoResCategory, NestedSetRight));
                queryBuildRange.value('..' + queryValue(category.NestedSetRight));
            }

            if (FeatureStateProvider::isFeatureEnabled(RetailEnableDisplayOrderForMerchandisingFeature::instance()))
            {
                QueryBuildDataSource inventTableDataSource = query.dataSourceTable(tableNum(InventTable));
                QueryBuildDataSource productCategoryDataSource = inventTableDataSource.addDataSource(tableNum(EcoResProductCategory), #DisplayOrderEcoResProductCategoryDS);
                productCategoryDataSource.joinMode(JoinMode::OuterJoin);
                productCategoryDataSource.fetchMode(QueryFetchMode::One2One);
                productCategoryDataSource.relations(false);
                productCategoryDataSource.addLink(fieldNum(InventTable, Product), fieldNum(EcoResProductCategory, Product));
                productCategoryDataSource.addRange(fieldNum(EcoResProductCategory, Category)).value(queryValue(_categoryRecId));

                FieldId displayOrderField = fieldNum(EcoResProductCategory, DisplayOrder);
                productCategoryDataSource.addSelectionField(displayOrderField);
                if (_orderByField == fieldStr(EcoResProductCategory, DisplayOrder))
                {
                    productCategoryDataSource.addOrderByField(displayOrderField, _sortOrder);
                }
            }
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductsByKeyword</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the products by keyword search.
    /// </summary>
    /// <param name="_currentChannelRecId">
    /// The record ID of current channel.
    /// </param>
    /// <param name="_keyword">
    /// The keyword to search for.
    /// </param>
    /// <param name="_startPosition">
    /// The starting record position.
    /// </param>
    /// <param name="_pageSize">
    /// The page size.
    /// </param>
    /// <param name="_orderByField">
    /// The order by field name.
    /// </param>
    /// <param name="_sortOrder">
    /// The sort order.
    /// </param>
    /// <param name="_includeTotalCount">
    /// Whether to include total number of records in the return value.
    /// </param>
    /// <param name="_languageId">
    /// The language to search in.
    /// </param>
    /// <param name="_otherChannelRecId">
    /// The record ID of other channel.
    /// </param>
    /// <param name="_catalogRecId">
    /// The record ID of the catalog to search products from.
    /// </param>
    /// <param name="_attributeRecIdRangeValue">
    /// The attribute record ID range value to filter product attribute values by.
    /// </param>
    /// <param name="_includePrice">
    /// Whether to include product prices in the return value.
    /// </param>
    /// <returns>
    /// A container having the products in a XML string.
    /// </returns>
    public static container getProductsByKeyword(
        RetailChannelRecId  _currentChannelRecId,
        str                 _keyword,
        int64               _startPosition,
        int64               _pageSize,
        str                 _orderByField = 'ItemId',
        SortOrder           _sortOrder = SortOrder::Ascending,
        boolean             _includeTotalCount = false,
        LanguageId          _languageId = '',
        RetailChannelRecId  _otherChannelRecId = 0,
        CatalogRefRecId     _catalogRecId = 0,
        str                 _attributeRecIdRangeValue = '',
        boolean             _includePrice = true)
    {
        str error;
        str languageId;
        Query query;
        int fromLine;

        try
        {
            fromLine = Global::infologLine();

            languageId = RetailTransactionServiceProduct::getLanguageId(_currentChannelRecId, _languageId);

            query = RetailTransactionServiceProduct::getProductsByKeywordQuery(_currentChannelRecId, _keyword, _orderByField, _sortOrder, languageId, _otherChannelRecId, _catalogRecId);
        }
        catch (Exception::CLRError)
        {
            error = AifUtil::getClrErrorMessage();
        }
        catch (Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
        }

        if (error)
        {
            error = RetailTransactionServiceUtilities::getErrorCode(error);
            return [false, error, ''];
        }

        return RetailTransactionServiceProduct::getProductsByQuery(_currentChannelRecId, query, _startPosition, _pageSize, _includeTotalCount, languageId, _otherChannelRecId, _catalogRecId, _attributeRecIdRangeValue, _includePrice);
    }

]]></Source>
			</Method>
			<Method>
				<Name>countProductVariants</Name>
				<Source><![CDATA[
    /// <summary>
    /// Count the variants of the products based on product IDs range.
    /// </summary>
    /// <param name = "productIds">
    /// The range value of product identifiers that are being counted, separated by comma.
    /// For example, a valid value could be "22565423130,22565423125,22565423120".
    /// </param>
    /// <returns>
    /// A container containing an array of product variants count in XML format.
    /// </returns>
    public static container countProductVariants(str productIds)
    {
        boolean success = true;
        str error;

        XmlDocument doc = RetailTransactionServiceUtilities::getXmlDocumentForSerializedEntities();
        int fromLine;

        try
        {
            if (productIds == '')
            {
                throw Global::error("@Retail:RangeValueEmptyError");
            }
            fromLine = Global::infologLine();

            Query productVariantsQuery;
            QueryRun productVariantsQueryRun;
            QueryBuildDataSource productVariantsDataSource;
            QueryBuildRange productVariantsRange;

            productVariantsQuery = new Query();
            productVariantsDataSource = productVariantsQuery.addDataSource(tableNum(EcoResDistinctProductVariant));

            // Filter by ProductMaster.
            productVariantsRange = productVariantsDataSource.addRange(fieldNum(EcoResDistinctProductVariant, ProductMaster));
            productVariantsRange.value(productIds);

            // Group by ProductMaster column.
            productVariantsDataSource.addGroupByField(fieldNum(EcoResDistinctProductVariant, ProductMaster));

            // Count the variants of each ProductMaster.
            productVariantsDataSource.addSelectionField(fieldNum(EcoResDistinctProductVariant, RecId), SelectionField::Count);

            productVariantsQueryRun = new QueryRun(productVariantsQuery);
            EcoResDistinctProductVariant ecoResDistinctProductVariant;
            if (productVariantsQueryRun.next())
            {
                ecoResDistinctProductVariant = productVariantsQueryRun.get(tableNum(EcoResDistinctProductVariant));
            }

            // Generate the XML document.
            XmlElement rootNode;
            XmlElement recordNode;
            XmlElement fieldNode;

            rootNode = doc.createElement('ArrayOfProductVariantsCount');
            rootNode.setAttribute('xmlns', RetailTransactionServiceUtilities::getCrtDataModelXmlNamespace());
            doc.appendChild(rootNode);

            while (ecoResDistinctProductVariant)
            {
                int64 productId = ecoResDistinctProductVariant.ProductMaster;
                int64 variantsCount = ecoResDistinctProductVariant.RecId;

                recordNode = doc.createElement('ProductVariantsCount');

                fieldNode = doc.createElement('ProductId');
                fieldNode.text(int642Str(productId));
                recordNode.appendChild(fieldNode);

                fieldNode = doc.createElement('VariantsCount');
                fieldNode.text(int642Str(variantsCount));
                recordNode.appendChild(fieldNode);

                rootNode.appendChild(recordNode);

                next ecoResDistinctProductVariant;
            }

            success = true;
        }
        catch(Exception::Error)
        {
            success = false;
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
        }

        return [success, error, doc.xml()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductsByKeywordQuery</Name>
				<Source><![CDATA[
    private static Query getProductsByKeywordQuery(
        RetailChannelRecId _currentChannelRecId,
        str _keyword,
        str _orderByField,
        SortOrder _sortOrder,
        LanguageId _languageId,
        RetailChannelRecId _otherChannelRecId,
        CatalogRefRecId _catalogRecId)
    {
        QueryBuildDataSource queryBuildDataSource;
        QueryBuildRange queryBuildRange;
        QueryFilter queryFilter;

        Query query = RetailTransactionServiceProduct::getProductSearchQuery(_currentChannelRecId, _orderByField, _sortOrder, _languageId, _otherChannelRecId, _catalogRecId);

        if (query == null)
        {
            return null;
        }

        if (_keyword)
        {
            // Search by item ID
            queryBuildDataSource = query.dataSourceName(queryDatasourceStr(RetailItemSearchWarehouse, ItemById));
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(InventTable, ItemId));
            queryBuildRange.value(_keyword + '*');

            // Searching item by barcode, if the keyword is of barcode then trying to fetch the item id from table InventItemBarcode.
            queryBuildDataSource = query.dataSourceTable(tableNum(InventItemBarcode));
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(InventItemBarcode, ItemBarCode));
            queryBuildRange.value(_keyword);

            // Search by product name and language.
            queryBuildDataSource = query.dataSourceName(queryDatasourceStr(RetailItemSearchWarehouse, ProductTranslationByName));
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(EcoResProductTranslation, Name));
            queryBuildRange.rangeType(QueryRangeType::FullText);
            queryBuildRange.value(_keyword);

            // Search by product search name
            queryBuildDataSource = query.dataSourceTable(tableNum(EcoResProduct));
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(EcoResProduct, SearchName));
            queryBuildRange.rangeType(QueryRangeType::FullText);
            queryBuildRange.value(_keyword);

            // Search by item name alias
            queryBuildDataSource = query.dataSourceName(queryDatasourceStr(RetailItemSearchWarehouse, ItemByNameAlias));
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(InventTable, NameAlias));
            queryBuildRange.rangeType(QueryRangeType::FullText);
            queryBuildRange.value(_keyword);

            // Any match of the above searches is fine
            queryFilter = query.addQueryFilter(queryBuildDataSource, fieldStr(EcoResProduct, RecId));
            queryFilter = query.addQueryFilter(queryBuildDataSource, fieldStr(InventItemBarcode, RecId));
            queryFilter.value('((ItemById.RecId != 0) || (ProductTranslationByName.RecId != 0) || (ItemByNameAlias.RecId != 0) || (Product.RecId != 0) || (InventItemBarcode.RecId != 0))');
        }
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductsByQuery</Name>
				<Source><![CDATA[
    private static container getProductsByQuery(
        RetailChannelRecId  _currentChannelRecId,
        Query               _query,
        int64               _startPosition,
        int64               _pageSize,
        boolean             _includeTotalCount,
        LanguageId          _languageId,
        RetailChannelRecId  _otherChannelRecId,
        CatalogRefRecId     _catalogRecId,
        str                 _attributeRecIdRangeValue,
        boolean             _includePrice)
    {
        boolean success;
        str error;
        int fromLine;

        RetailChannelTable currentChannel;
        XMLDocument xmlDocument;
        XmlElement xmlElementProducts;
        str xml;

        try
        {
            if (_query == null)
            {
                eventSource.EventWriteProductsRTSUnsupportedContext(classStr(RetailTransactionServiceProduct), funcName(), _otherChannelRecId, _catalogRecId);
                error = strFmt("@REX4161083", _otherChannelRecId, _catalogRecId);
            }
            else
            {
                fromLine = Global::infologLine();

                error = RetailTransactionServiceProduct::checkChannelExist(_currentChannelRecId);
                if (!error)
                {
                    if (_otherChannelRecId)
                    {
                        error = RetailTransactionServiceProduct::checkChannelExist(_otherChannelRecId);
                    }
                }

                if (!error)
                {
                    currentChannel = RetailChannelTable::findByRecId(_currentChannelRecId);
                    changeCompany(currentChannel.inventLocationDataAreaId)
                    {
                        xmlDocument = XMLDocument::newBlank();
                        xmlElementProducts = RetailTransactionServiceProduct::getProductsXml(
                            xmlDocument,
                            _currentChannelRecId,
                            _query,
                            _startPosition,
                            _pageSize,
                            _includeTotalCount,
                            _languageId,
                            _otherChannelRecId,
                            _catalogRecId,
                            _attributeRecIdRangeValue,
                            _includePrice);
                        xmlDocument.appendChild(xmlElementProducts);
                        xml = xmlDocument.toString();
                        success = true;
                    }
                }
            }
        }
        catch (Exception::CLRError)
        {
            error = AifUtil::getClrErrorMessage();
        }
        catch (Exception::Error)
        {
            error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
        }

        //Return sanitized error code.
        error = RetailTransactionServiceUtilities::getErrorCode(error);

        return [success, error, xml];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductsQuery</Name>
				<Source><![CDATA[
    private static Query getProductsQuery(str _queryName, str _orderByField, SortOrder _sortOrder, LanguageId _languageId)
    {
        Query query;
        QueryBuildDataSource queryBuildDataSource;
        QueryBuildRange queryBuildRange;

        // Initialize the query
        query = new Query(_queryName);

        // Add language filter
        queryBuildDataSource = query.dataSourceTable(tableNum(EcoResProductTranslation));
        queryBuildRange = queryBuildDataSource.addRange(fieldNum(EcoResProductTranslation, LanguageId));
        queryBuildRange.value(queryValue(_languageId));

        // Add default language name
        query.dataSourceTable(tableNum(InventTable)).addSelectionField(fieldNum(InventTable, NameAlias));

        // Add stop sales filter
        QueryBuildDataSource rootQueryBuildDataSource = query.dataSourceTable(tableNum(InventTable));
        QueryBuildDataSource filterQueryBuildDataSource = rootQueryBuildDataSource.addDataSource(tableNum(InventItemSalesSetupStopped));
        filterQueryBuildDataSource.joinMode(JoinMode::NoExistsJoin);
        filterQueryBuildDataSource.fetchMode(QueryFetchMode::One2One);
        filterQueryBuildDataSource.relations(false);
        filterQueryBuildDataSource.addLink(fieldNum(InventTable, ItemId), fieldNum(InventItemSalesSetupStopped, ItemId));

        // Add order by fields
        if (_orderByField == fieldStr(EcoResProductTranslation, Name))
        {
            queryBuildDataSource.addOrderByField(fieldNum(EcoResProductTranslation, Name), _sortOrder);
        }

        if (!FeatureStateProvider::isFeatureEnabled(RetailEnableDisplayOrderForMerchandisingFeature::instance()) || _orderByField != fieldStr(EcoResProductCategory, DisplayOrder))
        {
            query.dataSourceTable(tableNum(InventTable)).addOrderByField(fieldNum(InventTable, ItemId), _sortOrder);
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductsXml</Name>
				<Source><![CDATA[
    private static XmlElement getProductsXml(
        XmlDocument _xmlDocument,
        RetailChannelRecId _channelRecId,
        Query _query,
        int64 _startPosition,
        int64 _pageSize,
        boolean _includeTotalCount,
        LanguageId _languageId,
        RetailChannelRecId _otherChannelRecId,
        CatalogRefRecId _catalogRecId,
        str _attributeRecIdRangeValue,
        boolean _includePrice)
    {
        QueryRun queryRun;
        Map productByItemId;
        Map nameByItemId;
        Map unitIdByItemId;
        Map priceByProduct;
        Map displayOrderByItemId;
        Map kitByProduct;
        Map masterProductByProduct;
        Map attributeValueXmlByProduct;
        Set productRecIds;
        List itemIdList;
        XmlElement xmlElementProducts;
        XmlElement xmlElementProduct;
        XmlElement xmlElementAttributeValues;
        ListEnumerator listEnumerator;
        InventTable item;
        EcoResProductTranslation productTranslation;
        InventTableModule inventTableModule;
        EcoResProductCategory productCategory;
        str itemId;
        str name;
        str image;
        str unitOfMeasure;
        real displayOrder;
        Price price;
        EcoResProductRecId productRecId;
        EcoResProductMaster ecoResProductMaster;
        RetailTmpCatalogProduct retailTmpCatalogProduct;
        RetailKit retailKit;
        QueryBuildDataSource displayOrderDataSource;
        RefRecId internalOrganizationRecId = 0;
        RetailInternalOrganization retailInternalOrg = RetailInternalOrganization::findByChannelId(_otherChannelRecId);

        if (retailInternalOrg)
        {
            internalOrganizationRecId = retailInternalOrg.RecId;
        }

        // Set up paging
        queryRun = new QueryRun(_query);
        queryRun.enablePositionPaging(true);
        queryRun.addPageRange(_startPosition, _pageSize);

        // Gather query result
        itemIdList = new List(Types::String);
        productByItemId = new Map(Types::String, Types::Int64);
        nameByItemId = new Map(Types::String, Types::String);
        unitIdByItemId = new Map(Types::String, Types::String);
        productRecIds = new Set(Types::Int64);
        displayOrderByItemId = new Map(Types::String, Types::Real);

        while (queryRun.next())
        {
            item = queryRun.get(tableNum(InventTable));
            itemIdList.addEnd(item.ItemId);
            productByItemId.insert(item.ItemId, item.Product);

            productTranslation = queryRun.get(tableNum(EcoResProductTranslation));
            // Use translated product name if available, otherwise use the product alias name.
            if (productTranslation != null)
            {
                nameByItemId.insert(item.ItemId, productTranslation.Name);
            }
            else
            {
                nameByItemId.insert(item.ItemId, item.NameAlias);
            }

            inventTableModule = queryRun.get(tableNum(InventTableModule));
            unitIdByItemId.insert(item.ItemId, inventTableModule.UnitId);

            displayOrderDataSource = queryRun.query().dataSourceName(#DisplayOrderEcoResProductCategoryDS);
            if (displayOrderDataSource)
            {
                productCategory = displayOrderDataSource.getNo() as EcoResProductCategory;
                if (productCategory)
                {
                    displayOrderByItemId.insert(item.ItemId, productCategory.DisplayOrder);
                }
            }

            if (!productRecIds.in(item.Product))
            {
                productRecIds.add(item.Product);
            }
        }

        Map imageByProductRecId = RetailMediaHelper::getProductPrimaryImageUrl(productRecIds, _catalogRecId, internalOrganizationRecId, _languageId);

        // Calculate product prices
        if (_includePrice)
        {
            priceByProduct = RetailTransactionServiceProduct::getProductPrices(_channelRecId, _catalogRecId, productByItemId, unitIdByItemId);
        }

        // Gather attribute values XML by product
        attributeValueXmlByProduct = RetailTransactionServiceProduct::getProductAttributeValuesXmlMap(
            _xmlDocument,
            _otherChannelRecId,
            _catalogRecId,
            productByItemId.valueSet(),
            _attributeRecIdRangeValue,
            _languageId,
            retailTmpCatalogProduct);

        masterProductByProduct = new Map(Types::Int64, Types::Int64);
        kitByProduct = new Map(Types::Int64, Types::Int64);
        while select Product from retailTmpCatalogProduct
            join RecId from ecoResProductMaster where ecoResProductMaster.RecId == retailTmpCatalogProduct.Product
            outer join RecId from retailKit where retailKit.ProductMaster == retailTmpCatalogProduct.Product
        {
            if (ecoResProductMaster.RecId != 0)
            {
                masterProductByProduct.insert(retailTmpCatalogProduct.Product, ecoResProductMaster.RecId);
            }
            if (retailKit.RecId !=0)
            {
                kitByProduct.insert(retailTmpCatalogProduct.Product, retailKit.RecId);
            }
        }

        // Assemble products XML
        xmlElementProducts = _xmlDocument.createElement('Products');
        if (_includeTotalCount)
        {
            xmlElementProducts.setAttribute('TotalCount', int2str(SysQuery::countLoops(queryRun)));
        }

        listEnumerator = itemIdList.getEnumerator();
        while (listEnumerator.moveNext())
        {
            itemId = listEnumerator.current();
            productRecId = productByItemId.lookup(itemId);

            xmlElementProduct = _xmlDocument.createElement('Product');
            RetailTransactionServiceProduct::setXElementAttributeInt64Value(xmlElementProduct, 'RecordId', productRecId);
            RetailTransactionServiceProduct::setXElementAttributeTextValue(xmlElementProduct, 'ItemId', itemId);

            name = nameByItemId.lookup(itemId);
            RetailTransactionServiceProduct::setXElementAttributeTextValue(xmlElementProduct, 'Name', name);

            image = imageByProductRecId.lookup(productRecId);
            RetailTransactionServiceProduct::setXElementAttributeTextValue(xmlElementProduct, 'PrimaryImageUrl', image);

            unitOfMeasure = unitIdByItemId.lookup(itemId);
            RetailTransactionServiceProduct::setXElementAttributeTextValue(xmlElementProduct, 'UnitOfMeasure', unitOfMeasure);

            if (displayOrderByItemId.exists(itemId))
            {
                displayOrder = displayOrderByItemId.lookup(itemId);
                RetailTransactionServiceProduct::setXElementAttributeFloatValue(xmlElementProduct, 'DisplayOrder', displayOrder, true);
            }

            if (_includePrice && priceByProduct.exists(productRecId))
            {
                price = priceByProduct.lookup(productRecId);
                RetailTransactionServiceProduct::setXElementAttributeFloatValue(xmlElementProduct, 'Price', price);
            }

            if (kitByProduct.exists(productRecId))
            {
                RetailTransactionServiceProduct::setXElementAttributeTextValue(xmlElementProduct, 'IsKit', 'true');
            }

            if (masterProductByProduct.exists(productRecId))
            {
                RetailTransactionServiceProduct::setXElementAttributeTextValue(xmlElementProduct, 'IsMasterProduct', 'true');
            }

            if (attributeValueXmlByProduct.exists(productRecId))
            {
                xmlElementAttributeValues = attributeValueXmlByProduct.lookup(productRecId);
                xmlElementProduct.appendChild(xmlElementAttributeValues);
            }

            xmlElementProducts.appendChild(xmlElementProduct);
        }

        return xmlElementProducts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateProductRecIdTempTable</Name>
				<Source><![CDATA[
    private static RetailTmpRecId populateProductRecIdTempTable(Map _productRecIds)
    {
        int              i;
        RetailTmpRecId  productRecIdTmptable;
        int              startTime, endTime;

        RecordInsertList productRecIdsToBeInserted = new RecordInsertList(tableNum(RetailTmpRecId), // table id
        false, // skip insert
        false, // skip database log
        false, // skip events
        false, // skip aos validation
        false, // skip RLS validation
        productRecIdTmptable); // buffer where records will be inserted

        MapIterator productIdIterator = new MapIterator(_productRecIds);
        while (productIdIterator.more())
        {
            RefRecId productRecId = productIdIterator.key();
            productRecIdTmptable.ReferenceRecId = productRecId;
            productRecIdsToBeInserted.add(productRecIdTmptable);

            productIdIterator.next();
        }

        productRecIdsToBeInserted.insertDatabase();
        return productRecIdTmptable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRangeValue</Name>
				<Source><![CDATA[
    private static str getRangeValue(str _rangeValue)
    {
        if (!_rangeValue)
        {
            return sysquery::valueEmptyString();
        }
        return _rangeValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setXElementAttributeDateTimeValue</Name>
				<Source><![CDATA[
    private static boolean setXElementAttributeDateTimeValue(XmlElement _xmlElement, str _attributeName, utcDateTime _dateTimeValue)
    {
        boolean hasValue;

        if (_dateTimeValue)
        {
            _xmlElement.setAttribute(_attributeName, DateTimeUtil::toStr(_dateTimeValue));
            hasValue = true;
        }

        return hasValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setXElementAttributeFloatValue</Name>
				<Source><![CDATA[
    private static boolean setXElementAttributeFloatValue(XmlElement _xmlElement, str _attributeName, real _floatValue, boolean _allowZero = false)
    {
        boolean hasValue;

        if (_floatValue || _allowZero)
        {
            _xmlElement.setAttribute(_attributeName, num2str(_floatValue, 5, 3, 1, 0));
            hasValue = true;
        }

        return hasValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setXElementAttributeInt64Value</Name>
				<Source><![CDATA[
    private static boolean setXElementAttributeInt64Value(XmlElement _xmlElement, str _attributeName, int64 _int64Value)
    {
        boolean hasValue;

        if (_int64Value)
        {
            _xmlElement.setAttribute(_attributeName, int642str(_int64Value));
            hasValue = true;
        }

        return hasValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setXElementAttributeIntValue</Name>
				<Source><![CDATA[
    private static boolean setXElementAttributeIntValue(XmlElement _xmlElement, str _attributeName, int _intValue)
    {
        boolean hasValue;

        if (_intValue)
        {
            _xmlElement.setAttribute(_attributeName, int642str(_intValue));
            hasValue = true;
        }

        return hasValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setXElementAttributeTextValue</Name>
				<Source><![CDATA[
    private static boolean setXElementAttributeTextValue(XmlElement _xmlElement, str _attributeName, str _textValue)
    {
        boolean hasValue;

        if (_textValue)
        {
            _xmlElement.setAttribute(_attributeName, _textValue);
            hasValue = true;
        }

        return hasValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductsByItemId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the products by item ID.
    /// </summary>
    /// <param name="_currentChannelRecId">
    /// The record ID of current channel.
    /// </param>
    /// <param name="_itemIdRangeValue">
    /// The item ID range to search for.
    /// </param>
    /// <param name="_startPosition">
    /// The starting record position.
    /// </param>
    /// <param name="_pageSize">
    /// The page size.
    /// </param>
    /// <param name="_orderByField">
    /// The order by field name.
    /// </param>
    /// <param name="_sortOrder">
    /// The sort order.
    /// </param>
    /// <param name="_includeTotalCount">
    /// Whether to include total number of records in the return value.
    /// </param>
    /// <param name="_languageId">
    /// The language to search in.
    /// </param>
    /// <param name="_otherChannelRecId">
    /// The record ID of other channel.
    /// </param>
    /// <param name="_catalogRecId">
    /// The record ID of the catalog to search products from.
    /// </param>
    /// <param name="_attributeRecIdRangeValue">
    /// The attribute record ID range value to filter product attribute values by.
    /// </param>
    /// <param name="_includePrice">
    /// Whether to include product prices in the return value.
    /// </param>
    /// <returns>
    /// A container having the products in a XML string.
    /// </returns>
    public static container getProductsByItemId(
        RetailChannelRecId  _currentChannelRecId,
        str                 _itemIdRangeValue,
        int64               _startPosition,
        int64               _pageSize,
        str                 _orderByField,
        SortOrder           _sortOrder,
        boolean             _includeTotalCount,
        LanguageId          _languageId,
        RetailChannelRecId  _otherChannelRecId,
        CatalogRefRecId     _catalogRecId,
        str                 _attributeRecIdRangeValue,
        boolean             _includePrice)
    {
        return RetailTransactionServiceProduct::getProducts(_currentChannelRecId, _itemIdRangeValue, fieldStr(InventTable, ItemId), _startPosition, _pageSize,
            _orderByField, _sortOrder, _includeTotalCount, _languageId, _otherChannelRecId, _catalogRecId, _attributeRecIdRangeValue, _includePrice);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductsByProductRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the products by product record ID range.
    /// </summary>
    /// <param name="_currentChannelRecId">
    /// The record ID of current channel.
    /// </param>
    /// <param name="_productRecIdRangeValue">
    /// The product record ID range to search for.
    /// </param>
    /// <param name="_startPosition">
    /// The starting record position.
    /// </param>
    /// <param name="_pageSize">
    /// The page size.
    /// </param>
    /// <param name="_orderByField">
    /// The order by field name.
    /// </param>
    /// <param name="_sortOrder">
    /// The sort order.
    /// </param>
    /// <param name="_includeTotalCount">
    /// Whether to include total number of records in the return value.
    /// </param>
    /// <param name="_languageId">
    /// The language to search in.
    /// </param>
    /// <param name="_otherChannelRecId">
    /// The record ID of other channel.
    /// </param>
    /// <param name="_catalogRecId">
    /// The record ID of the catalog to search products from.
    /// </param>
    /// <param name="_attributeRecIdRangeValue">
    /// The attribute record ID range value to filter product attribute values by.
    /// </param>
    /// <param name="_includePrice">
    /// Whether to include product prices in the return value.
    /// </param>
    /// <returns>
    /// A container having the products in a XML string.
    /// </returns>
    public static container getProductsByProductRecId(
        RetailChannelRecId  _currentChannelRecId,
        str                 _productRecIdRangeValue,
        int64               _startPosition,
        int64               _pageSize,
        str                 _orderByField,
        SortOrder           _sortOrder,
        boolean             _includeTotalCount,
        LanguageId          _languageId,
        RetailChannelRecId  _otherChannelRecId,
        CatalogRefRecId     _catalogRecId,
        str                 _attributeRecIdRangeValue,
        boolean             _includePrice)
    {
        return RetailTransactionServiceProduct::getProducts(_currentChannelRecId, _productRecIdRangeValue, fieldStr(InventTable, Product), _startPosition, _pageSize,
            _orderByField, _sortOrder, _includeTotalCount, _languageId, _otherChannelRecId, _catalogRecId, _attributeRecIdRangeValue, _includePrice
            );
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProducts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the product list.
    /// </summary>
    /// <param name = "_currentChannelRecId">The record ID of current channel.</param>
    /// <param name = "_rangeValue">The item ID or product ID to search for.</param>
    /// <param name = "_rangeFieldName">Field name.</param>
    /// <param name = "_startPosition">The starting record position.</param>
    /// <param name = "_pageSize">The page size.</param>
    /// <param name = "_orderByField">The order by field name.</param>
    /// <param name = "_sortOrder">The sort order.</param>
    /// <param name = "_includeTotalCount">Whether to include total number of records in the return value.</param>
    /// <param name = "_languageId">The language id.</param>
    /// <param name = "_otherChannelRecId">The record ID of other channel.</param>
    /// <param name = "_catalogRecId">The record ID of the catalog to search products from.</param>
    /// <param name = "_attributeRecIdRangeValue">The attribute record ID range value to filter product attribute values by.</param>
    /// <param name = "_includePrice">Whether to include product prices in the return value.</param>
    /// <returns>A container having the products in a XML string.</returns>
    private static container getProducts(
        RetailChannelRecId _currentChannelRecId,
        str         _rangeValue,
        str         _rangeFieldName,
        int64       _startPosition,
        int64       _pageSize,
        str         _orderByField,
        SortOrder   _sortOrder = SortOrder::Ascending,
        boolean     _includeTotalCount = false,
        LanguageId  _languageId = '',
        RetailChannelRecId _otherChannelRecId = 0,
        CatalogRefRecId _catalogRecId = 0,
        str         _attributeRecIdRangeValue = '',
        boolean     _includePrice = true
        )
    {
        str languageId = RetailTransactionServiceProduct::getLanguageId(_currentChannelRecId, _languageId);

        Query query = RetailTransactionServiceProduct::getProductsByIdRangeQuery(_currentChannelRecId, _rangeValue, _rangeFieldName, _orderByField, _sortOrder, languageId, _otherChannelRecId, _catalogRecId);

        return RetailTransactionServiceProduct::getProductsByQuery(_currentChannelRecId, query, _startPosition, _pageSize, _includeTotalCount, languageId, _otherChannelRecId, _catalogRecId, _attributeRecIdRangeValue, _includePrice);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductsByIdRangeQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the products by ID range search.
    /// </summary>
    /// <param name="_currentChannelRecId">
    /// The record ID of current channel.
    /// </param>
    /// <param name="_rangeValue">
    /// The ID range to search for
    /// </param>
    /// <param name="_orderByField">
    /// The order by field name.
    /// </param>
    /// <param name="_sortOrder">
    /// The sort order.
    /// </param>
    /// <param name="_languageId">
    /// The language to search in.
    /// </param>
    /// <param name="_otherChannelRecId">
    /// The record ID of other channel
    /// </param>
    /// <param name="_catalogRecId">
    /// The record ID of the catalog to search products from.
    /// </param>
    /// <returns>
    /// A query to get products by itemid.
    /// </returns>
    private static Query getProductsByIdRangeQuery(
        RetailChannelRecId  _currentChannelRecId,
        str                 _rangeValue,
        str                 _rangeFieldName,
        str                 _orderByField,
        SortOrder           _sortOrder,
        LanguageId          _languageId,
        RetailChannelRecId  _otherChannelRecId,
        CatalogRefRecId     _catalogRecId)
    {
        QueryBuildDataSource queryBuildDataSource;
        QueryBuildRange queryBuildRange;

        Query query = RetailTransactionServiceProduct::getProductSearchQuery(_currentChannelRecId, _orderByField, _sortOrder, _languageId, _otherChannelRecId, _catalogRecId);

        if (query == null)
        {
            return null;
        }

        _rangeValue = RetailTransactionServiceProduct::getRangeValue(_rangeValue);

        // Search by range field
        queryBuildDataSource = query.dataSourceTable(tableNum(InventTable));
        queryBuildDataSource.joinMode(JoinMode::InnerJoin);
        queryBuildRange = queryBuildDataSource.addRange(fieldName2Id(tableNum(InventTable), _rangeFieldName));
        queryBuildRange.value(_rangeValue);

        // Search by product name and language
        queryBuildDataSource = query.dataSourceName(queryDatasourceStr(RetailItemSearchWarehouse, ProductTranslationByName));
        queryBuildDataSource.enabled(false);

        // Search by product search name
        queryBuildDataSource = query.dataSourceTable(tableNum(EcoResProduct));
        queryBuildDataSource.enabled(false);

        // Search by item name alias
        queryBuildDataSource = query.dataSourceName(queryDatasourceStr(RetailItemSearchWarehouse, ItemById));
        queryBuildDataSource.enabled(false);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductSearchQuery</Name>
				<Source><![CDATA[
    private static Query getProductSearchQuery(
        RetailChannelRecId  _currentChannelRecId,
        str                 _orderByField,
        SortOrder           _sortOrder,
        LanguageId          _languageId,
        RetailChannelRecId  _otherChannelRecId,
        CatalogRefRecId     _catalogRecId)
    {
        Query query;
        QueryBuildDataSource queryBuildDataSource;
        QueryBuildRange queryBuildRange;
        date channelDate;

        // Initialize the query
        if (!_otherChannelRecId && !_catalogRecId)
        {
            query = RetailTransactionServiceProduct::getProductsQuery(queryStr(RetailItemSearchWarehouse), _orderByField, _sortOrder, _languageId);
        }
        else if (_otherChannelRecId && _catalogRecId)
        {
            query = RetailTransactionServiceProduct::getProductsQuery(queryStr(RetailItemSearchOtherStoreCatalog), _orderByField, _sortOrder, _languageId);

            channelDate = DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(DateTimeUtil::utcNow(), RetailChannelTable::getChannelTimezone(_otherChannelRecId)));
            queryBuildDataSource = query.dataSourceTable(tableNum(RetailPubCatalog));
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(RetailPubCatalog, PublishedValidFrom));
            queryBuildRange.value('..' + queryValue(channelDate));
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(RetailPubCatalog, PublishedValidTo));
            queryBuildRange.value(queryValue(channelDate) + '..');

            queryBuildDataSource = query.dataSourceTable(tableNum(RetailPubCatalogChannelCurrent));
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(RetailPubCatalogChannelCurrent, Channel));
            queryBuildRange.value(queryValue(_otherChannelRecId));
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(RetailPubCatalogChannelCurrent, Catalog));
            queryBuildRange.value(queryValue(_catalogRecId));
        }
        else if (_otherChannelRecId && !_catalogRecId)
        {
            query = RetailTransactionServiceProduct::getProductsQuery(queryStr(RetailItemSearchOtherStore), _orderByField, _sortOrder, _languageId);

            queryBuildDataSource = query.dataSourceTable(tableNum(RetailChannelTable));
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(RetailChannelTable, RecId));
            queryBuildRange.value(queryValue(_otherChannelRecId));

            channelDate = DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(DateTimeUtil::utcNow(), RetailChannelTable::getChannelTimezone(_otherChannelRecId)));
            queryBuildDataSource = query.dataSourceTable(tableNum(RetailAssortmentLookup));
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(RetailAssortmentLookup, ValidFrom));
            queryBuildRange.value('..' + queryValue(channelDate));
            queryBuildRange = queryBuildDataSource.addRange(fieldNum(RetailAssortmentLookup, ValidTo));
            queryBuildRange.value(queryValue(channelDate) + '..');
        }
        else
        {
            return null;
        }

        queryBuildDataSource = query.dataSourceName(queryDatasourceStr(RetailItemSearchWarehouse, ProductTranslationByName));
        queryBuildRange = queryBuildDataSource.addRange(fieldNum(EcoResProductTranslation, LanguageId));
        queryBuildRange.value(queryValue(_languageId));

        return query;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>